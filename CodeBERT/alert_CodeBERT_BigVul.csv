Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
5," static void addDataToStreamTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);
 }
"," static void addDataToStreamTask(void* component)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(component));
    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);
 }
",43.0,9.0,"context:component,",44.0,0.0229950984319051,Greedy
12,"static int srpt_ch_qp_rtr(struct srpt_rdma_ch *ch, struct ib_qp *qp)
{
	struct ib_qp_attr qp_attr;
	int attr_mask;
	int ret;

	qp_attr.qp_state = IB_QPS_RTR;
	ret = ib_cm_init_qp_attr(ch->cm_id, &qp_attr, &attr_mask);
	if (ret)
		goto out;

	qp_attr.max_dest_rd_atomic = 4;

	ret = ib_modify_qp(qp, &qp_attr, attr_mask);

out:
	return ret;
}
","static int srpt_ch_qp_rtr(struct srpt_rdma_ch *ch, struct ib_qp * qpi)
{
	struct ib_qp_attr qp_att;
	int att_sk;
	int len;

	qp_att.qp_state = IB_QPS_RTR;
	ret = ib_cm_init_qp_attr(ch->cm_id, &qp_att, &att_slen	ret = ib_cm_init_qp_attr(ch->cm_id, &qp_att, &att_sk);
	if (len)
		goto out;

	qp_att.max_dest_rd_atomic = 4;

	ret = ib_modify_qp( qpi, &qp_att, att_sk)lenet = ib_modify_qp( qpi, &qp_att, att_sk);

out:
	return len;
}
",77.0,21.0,"ch:ch,qp: qpi,qp_attr:qp_att,attr_mask:att_sk,ret:len,",299.0,0.1382348497708638,GA
15,"static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = restart->futex.uaddr;
	ktime_t t, *tp = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;

	return (long)futex_wait(uaddr, restart->futex.flags,
				restart->futex.val, tp, restart->futex.bitset);
}
","static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *hwaddr = restart->futex.hwaddr;
	ktime_t e, *tp = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		e.tv64 = restart->futex.time;
		tp = &e;
	}
	restart->fn = do_no_restart_syscall;

	return (long)futex_wait(hwaddr, restart->futex.flags,
				restart->futex.val, tp, restart->futex.bitset);
}
",92.0,21.0,"uaddr:hwaddr,t:e,",106.0,0.0377483129501342,Greedy
16,"status_t MediaPlayer::setDataSource(
 const sp<IMediaHTTPService> &httpService,
 const char *url, const KeyedVector<String8, String8> *headers)
{

     ALOGV(""setDataSource(%s)"", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
        const sp<IMediaPlayerService>& service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(httpService, url, headers))) {
                player.clear();
 }
            err = attachNewPlayer(player);
 }
 }
 return err;
}
","status_t MediaPlayer::setDataSource(
 const sp<IMediaHTTPService> &httpService,
 const char *host, const KeyedVector<String8, String8> *headers)
{

     ALOGV(""setDataSource(%s)"", host);
     status_t err = BAD_VALUE;
     if (host != NULL) {
        const sp<IMediaPlayerService>& service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(httpService, host, headers))) {
                player.clear();
 }
            err = attachNewPlayer(player);
 }
 }
 return err;
}
",132.0,27.0,"url:host,",66.0,0.0254534482955932,Greedy
21,"void setSerifFontFamilyWrapper(WebSettings* settings,
                               const string16& font,
                               UScriptCode script) {
  settings->setSerifFontFamily(font, script);
}
","void setSerifFontFamilyWrapper(WebSettings* settings,
                               const string16& font,
                               UScriptCode  Script) {
  settings->setSerifFontFamily(font,  Script);
}
",26.0,7.0,"script: Script,",45.0,0.0203795194625854,Greedy
27,"status_t Parcel::readPointer(uintptr_t *pArg) const
{
 status_t ret;
 binder_uintptr_t ptr;
    ret = readAligned(&ptr);
 if (!ret)
 *pArg = ptr;
 return ret;
}
","status_t Parcel::readPointer(uintptr_t *pArg) const
{
 status_t pret;
 binder_uintptr_t fp;
    pret = readAligned(&fp);
 if (!pret)
 *pArg = fp;
 return pret;
}
",39.0,11.0,"ret:pret,ptr:fp,",104.0,0.0412174423535664,Greedy
35,"void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;

	mutex_lock(&local->sta_mtx);

	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;

		if (time_after(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM\n"",
				sta->sta.addr);

			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);

			WARN_ON(__sta_info_destroy(sta));
		}
	}

	mutex_unlock(&local->sta_mtx);
}
","void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *txt;

	mutex_lock(&local->sta_mtx);

	list_for_each_entry_safe(sta, txt, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;

		if (time_after(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM\n"",
				sta->sta.addr);

			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);

			WARN_ON(__sta_info_destroy(sta));
		}
	}

	mutex_unlock(&local->sta_mtx);
}
",144.0,35.0,"tmp:txt,",71.0,0.0375492533047994,Greedy
36,"int ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int size)
{
	kuid_t euid;
	kgid_t egid;
	int id;
	int next_id = ids->next_id;

	if (size > IPCMNI)
		size = IPCMNI;

	if (ids->in_use >= size)
		return -ENOSPC;

	idr_preload(GFP_KERNEL);

	spin_lock_init(&new->lock);
	new->deleted = false;
 	rcu_read_lock();
 	spin_lock(&new->lock);
 
 	id = idr_alloc(&ids->ipcs_idr, new,
 		       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,
 		       GFP_NOWAIT);
	idr_preload_end();
	if (id < 0) {
		spin_unlock(&new->lock);
		rcu_read_unlock();
		return id;
	}
 
 	ids->in_use++;
 
	current_euid_egid(&euid, &egid);
	new->cuid = new->uid = euid;
	new->gid = new->cgid = egid;
 	if (next_id < 0) {
 		new->seq = ids->seq++;
 		if (ids->seq > IPCID_SEQ_MAX)
			ids->seq = 0;
	} else {
		new->seq = ipcid_to_seqx(next_id);
		ids->next_id = -1;
	}

	new->id = ipc_buildid(id, new->seq);
	return id;
}
","int ipc_addid(struct ipc_ids *rows, struct kern_ipc_perm *changes, int six)
{
	kuid_t egide;
	kgid_t egid;
	int id;
	int next_id = rows->next_id;

	if (six > IPCMNI)
		six = IPCMNI;

	if (rows->inxuses >= six)
		return -ENOSPC;

	idr_preload(GFP_KERNEL);

	spin_lock_init(&changes->lock);
	changes->deleted = false;
 	rcu_read_lock();
 	spin_lock(&changes->lock);
 
 	id = idr_alloc(&rows->ipcs_idr, changes,
 		       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,
 		       GFP_NOWAIT);
	idr_preload_end();
	if (id < 0) {
		spin_unlock(&changes->lock);
		rcu_read_unlock();
		return id;
	}
 
 	rows->inxuses++;
 
	current_euid_egid(&egide, &egid);
	changes->cuid = changes->uid = egide;
	changes->gid = changes->cgid = egid;
 	if (next_id < 0) {
 		changes->seq = rows->seq++;
 		if (rows->seq > IPCID_SEQ_MAX)
			rows->seq = 0;
	} else {
		changes->seq = ipcid_to_seqx(next_id);
		rows->next_id = -1;
	}

	changes->id = ipc_buildid(id, changes->seq);
	return id;
}
",251.0,63.0,"ids:rows,in_use:inxuses,new:changes,size:six,euid:egide,",288.0,0.1185928185780843,Greedy
38," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
"," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr tree) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(tree->method_name,
                                         tree->stringified_details);
    delegate_ = nullptr;
  }
}
",42.0,9.0,"response:tree,",49.0,0.0297320326169331,Greedy
46,"struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,
			     gfp_t priority)
{
	if (force || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, priority);
		if (skb) {
			skb_set_owner_w(skb, sk);
			return skb;
		}
	}
	return NULL;
}
","struct sk_buff *sock_wmalloc(struct sock *self, unsigned long size, int secure,
			     gfp_t pointer)
{
	if (secure || atomic_read(&self->sk_wmem_alloc) < self->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, pointer);
		if (skb) {
			skb_set_owner_w(skb, self);
			return skb;
		}
	}
	return NULL;
}
",71.0,18.0,"priority:pointer,force:secure,sk:self,",148.0,0.0590767582257588,Greedy
47,"status_t OMXNodeInstance::getConfig(

         OMX_INDEXTYPE index, void *params, size_t /* size */) {
     Mutex::Autolock autoLock(mLock);
 
     OMX_ERRORTYPE err = OMX_GetConfig(mHandle, index, params);
     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;
 if (err != OMX_ErrorNoMore) {
        CLOG_IF_ERROR(getConfig, err, ""%s(%#x)"", asString(extIndex), index);
 }
 return StatusFromOMXError(err);
}
","status_t OMXNodeInstance::getConfig(

         OMX_INDEXTYPE inc, void *params, size_t /* size */) {
     Mutex::Autolock autoLock(mLock);
 
     OMX_ERRORTYPE err = OMX_GetConfig(mHandle, inc, params);
     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)inc;
 if (err != OMX_ErrorNoMore) {
        CLOG_IF_ERROR(getConfig, err, ""%s(%#x)"", asString(extIndex), inc);
 }
 return StatusFromOMXError(err);
}
",75.0,21.0,"index:inc,",64.0,0.0367409388224283,Greedy
56,"static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,
  int texel_size,ExceptionInfo *exception)
{
  register ssize_t
    i;

  MagickOffsetType
    offset;

  size_t
    h,
    w;

  /*
    Only skip mipmaps for textures and cube maps
  */
  if (EOFBlob(image) != MagickFalse)
    {
      ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
        image->filename);
      return(MagickFalse);
    }
  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP
      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE
          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))
    {
      w = DIV2(dds_info->width);
      h = DIV2(dds_info->height);

      /*
        Mipmapcount includes the main image, so start from one
      */
       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)
       {
         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;
        (void) SeekBlob(image, offset, SEEK_CUR);
         w = DIV2(w);
         h = DIV2(h);
       }
    }
  return(MagickTrue);
}
","static MagickBooleanType SkipDXTMipmaps(Image *game,DDSInfo *gd_info,
  int texel_size,ExceptionInfo *exception)
{
  register ssize_t
    id;

  MagickOffsetType
    offset;

  size_t
    y,
    w;

  /*
    Only skip mipmaps for textures and cube maps
  */
  if (EOFBlob(game) != MagickFalse)
    {
      ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
        game->filename);
      return(MagickFalse);
    }
  if (gd_info->ddscaps1 & DDSCAPS_MIPMAP
      && (gd_info->ddscaps1 & DDSCAPS_TEXTURE
          || gd_info->ddscaps2 & DDSCAPS2_CUBEMAP))
    {
      w = DIV2(gd_info->width);
      y = DIV2(gd_info->height);

      /*
        Mipmapcount includes the main image, so start from one
      */
       for (id = 1; (id < (ssize_t) gd_info->mipmapcount) && w && y; id++)
       {
         offset = (MagickOffsetType) ((w + 3) / 4) * ((y + 3) / 4) * texel_size;
        (void) SeekBlob(game, offset, SEEK_CUR);
         w = DIV2(w);
         y = DIV2(y);
       }
    }
  return(MagickTrue);
}
",189.0,51.0,"h:y,image:game,i:id,dds_info:gd_info,",240.0,0.1281861821810404,Greedy
57," SPL_METHOD(GlobIterator, count)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}

	if (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {
		RETURN_LONG(php_glob_stream_get_count(intern->u.dir.dirp, NULL));
	} else {
		/* should not happen */
		php_error_docref(NULL TSRMLS_CC, E_ERROR, ""GlobIterator lost glob state"");
	}
}
"," SPL_METHOD(GlobIterator, count)
 {
 	spl_filesystem_object *connect = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}

	if (php_stream_is(connect->u.dir.dirp ,&php_glob_stream_ops)) {
		RETURN_LONG(php_glob_stream_get_count(connect->u.dir.dirp, NULL));
	} else {
		/* should not happen */
		php_error_docref(NULL TSRMLS_CC, E_ERROR, ""GlobIterator lost glob state"");
	}
}
",88.0,18.0,"intern:connect,",54.0,0.0282835245132446,Greedy
59,"void FrameFetchContext::ProvideDocumentToContext(FetchContext& context,
                                                 Document* document) {
  DCHECK(document);
  CHECK(context.IsFrameFetchContext());
  static_cast<FrameFetchContext&>(context).document_ = document;
  static_cast<FrameFetchContext&>(context).fetch_client_settings_object_ =
      new FetchClientSettingsObjectImpl(*document);
}
","void FrameFetchContext::ProvideDocumentToContext(FetchContext& current,
                                                 Document* document) {
  DCHECK(document);
  CHECK(current.IsFrameFetchContext());
  static_cast<FrameFetchContext&>(current).document_ = document;
  static_cast<FrameFetchContext&>(current).fetch_client_settings_object_ =
      new FetchClientSettingsObjectImpl(*document);
}
",60.0,13.0,"context:current,",55.0,0.0299290855725606,Greedy
69,"static inline int vmcs12_write_any(struct kvm_vcpu *vcpu,
				   unsigned long field, u64 field_value){
	short offset = vmcs_field_to_offset(field);
	char *p = ((char *) get_vmcs12(vcpu)) + offset;
	if (offset < 0)
		return offset;

	switch (vmcs_field_width(field)) {
	case VMCS_FIELD_WIDTH_U16:
		*(u16 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U32:
		*(u32 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U64:
		*(u64 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_NATURAL_WIDTH:
		*(natural_width *)p = field_value;
		return 0;
	default:
		WARN_ON(1);
		return -ENOENT;
	}

}
","static inline int vmcs12_write_any(struct kvm_vcpu *fpu,
				   unsigned long rule, u64 field_expression){
	short offset = vmcs_field_to_offset(rule);
	char datap = ((char *) get_vmcs12(fpu)) + offset;
	if (offset < 0)
		return offset;

	switch (vmcs_field_width(rule)) {
	case VMCS_FIELD_WIDTH_U16:
		*(u16 *)p = fdataeld_expression;
		return 0;
	case VMCS_FIELD_WIDTH_U32:
		*(u32 *)p = fdataeld_expression;
		return 0;
	case VMCS_FIELD_WIDTH_U64:
		*(u64 *)p = fdataeld_expression;
		return 0;
	case VMCS_FIELD_WIDTH_NATURAL_WIDTH:
		*(natural_width *)p = fdataeld_expression;
		return 0;
	default:
		WARN_ON(1);
		return -ENOENT;
	}

}
",133.0,29.0,"vcpu:fpu,field:rule,field_value:field_expression,p:data,",443.0,0.236695114771525,GA
78,"ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;

	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
 	ia64_srlz_i();
 }
","ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *ofpoint = (s32 *) start;
	u64 data;

	while (ofpoint < (s32 *) end) {
		data = (u64) ofpoint + *ofpoint;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(data, ia64_tpa(get_imm64(data)));
		ia64_fc((void *) data);
		++ofpoint;
	}
	ia64_sync_i();
 	ia64_srlz_i();
 }
",80.0,21.0,"ip:data,offp:ofpoint,",122.0,0.0579553484916687,Greedy
81,"void OmniboxEditModel::OnWillKillFocus(gfx::NativeView view_gaining_focus) {
  if (user_input_in_progress_ || !in_revert_)
    delegate_->OnInputStateChanged();
}
","void OmniboxEditModel::OnWillKillFocus(gfx::NativeView view_gfx_control) {
  if (user_input_in_progress_ || !in_revert_)
    delegate_->OnInputStateChanged();
}
",25.0,5.0,"view_gaining_focus:view_gfx_control,",15.0,0.0178382277488708,Greedy
91,"static int rfcomm_sock_create(struct net *net, struct socket *sock,
			      int protocol, int kern)
{
	struct sock *sk;

	BT_DBG(""sock %p"", sock);

	sock->state = SS_UNCONNECTED;

	if (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)
		return -ESOCKTNOSUPPORT;

	sock->ops = &rfcomm_sock_ops;

	sk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC);
	if (!sk)
		return -ENOMEM;

	rfcomm_sock_init(sk, NULL);
	return 0;
}
","static int rfcomm_sock_create(struct ock *ock, struct socket *sock,
			      int  prototype, int kern)
{
	struct sock *ock;

	BT_DBG(""sock %p"", sock);

	sock->state = SS_UNCONNECTED;

	if (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)
		return -ESOCKTNOSUPPORT;

	sock->ops = &rfcomm_sock_ops;

	ock = rfcomm_sock_alloc(ock, sock,  prototype, GFP_ATOMIC);
	if (!ock)
		return -ENOMEM;

	rfcomm_sock_init(ock, NULL);
	return 0;
}
",98.0,27.0,"sk:ock,sock:sock,net:ock,protocol: prototype,",211.0,0.0960535168647766,Greedy
93," SPL_METHOD(RecursiveDirectoryIterator, getSubPath)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}

	if (intern->u.dir.sub_path) {
		RETURN_STRINGL(intern->u.dir.sub_path, intern->u.dir.sub_path_len, 1);
	} else {
		RETURN_STRINGL("""", 0, 1);
	}
}
"," SPL_METHOD(RecursiveDirectoryIterator, getSubPath)
 {
 	spl_filesystem_object *attr = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}

	if (attr->u.dir.sub_path) {
		RETURN_STRINGL(attr->u.dir.sub_path, attr->u.dir.sub_path_len, 1);
	} else {
		RETURN_STRINGL("""", 0, 1);
	}
}
",82.0,14.0,"intern:attr,",61.0,0.0293830315272013,Greedy
98,"  static void UpdatePropertyCallback(IBusPanelService* panel,
                                     IBusProperty* ibus_prop,
                                     gpointer user_data) {
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->UpdateProperty(ibus_prop);
   }
","  static void UpdatePropertyCallback(IBusPanelService* panel,
                                     IBusProperty* ibus_prop,
                                     gpointer userLogmodel) {
    g_return_if_fail(userLogmodel);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(userLogmodel);
    self->UpdateProperty(ibus_prop);
   }
",42.0,11.0,"user_data:userLogmodel,",41.0,0.0260327855745951,Greedy
101,"void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}
","void AffineTransform::recompose(const DecomposedType& descrom)
{
    this->setA(descrom.remainderA);
    this->setB(descrom.remainderB);
    this->setC(descrom.remainderC);
    this->setD(descrom.remainderD);
    this->setE(descrom.translateX);
    this->setF(descrom.translateY);
    this->rotateRadians(descrom.angle);
    this->scale(descrom.scaleX, descrom.scaleY);
}
",88.0,11.0,"decomp:descrom,",81.0,0.0346539417902628,Greedy
109," static inline void sem_getref_and_unlock(struct sem_array *sma)
 {
	ipc_rcu_getref(sma);
	ipc_unlock(&(sma)->sem_perm);
 }
"," static inline void sem_getref_and_unlock(struct sem_array *spa)
 {
	ipc_rcu_getref(spa);
	ipc_unlock(&(spa)->sem_perm);
 }
",27.0,6.0,"sma:spa,",42.0,0.0253090937932332,Greedy
111,"void drop_privileges(char *username) {
	struct passwd *user = (struct passwd *) getpwnam(username);
	if (user == NULL) {
		fprintf(stderr, _(""Failed dropping privileges. The user %s is not a valid username on local system.\n""), username);
		exit(1);
	}
	if (getuid() == 0) {
		/* process is running as root, drop privileges */
		if (setgid(user->pw_gid) != 0) {
			fprintf(stderr, _(""setgid: Error dropping group privileges\n""));
			exit(1);
		}
		if (setuid(user->pw_uid) != 0) {
			fprintf(stderr, _(""setuid: Error dropping user privileges\n""));
			exit(1);
		}
		/* Verify if the privileges were developed. */
		if (setuid(0) != -1) {
			fprintf(stderr, _(""Failed to drop privileges\n""));
			exit(1);
		}
	}
}
","void drop_privileges(char *username) {
	struct passwd *data = (struct passwd *) getpwnam(username);
	if (data == NULL) {
		fprintf(stderr, _(""Failed dropping privileges. The user %s is not a valid username on local system.\n""), username);
		exit(1);
	}
	if (getuid() == 0) {
		/* process is running as root, drop privileges */
		if (setgid(data->pw_gid) != 0) {
			fprintf(stderr, _(""setgid: Error dropping group privileges\n""));
			exit(1);
		}
		if (setuid(data->pw_uid) != 0) {
			fprintf(stderr, _(""setuid: Error dropping user privileges\n""));
			exit(1);
		}
		/* Verify if the privileges were developed. */
		if (setuid(0) != -1) {
			fprintf(stderr, _(""Failed to drop privileges\n""));
			exit(1);
		}
	}
}
",149.0,29.0,"user:data,",73.0,0.034807284673055,Greedy
115,"png_set_tIME(png_structp png_ptr, png_infop info_ptr, png_timep mod_time)
{
   png_debug1(1, ""in %s storage function"", ""tIME"");

   if (png_ptr == NULL || info_ptr == NULL ||
        (png_ptr->mode & PNG_WROTE_tIME))
       return;
 
    png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof(png_time));
    info_ptr->valid |= PNG_INFO_tIME;
 }
","png_set_tIME(png_structp png_ctr, png_infop info_ptr, png_timep mod_time)
{
   png_debug1(1, ""in %s storage function"", ""tIME"");

   if (png_ctr == NULL || info_ptr == NULL ||
        (png_ctr->mode & PNG_WROTE_tIME))
       return;
 
    png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof(png_time));
    info_ptr->valid |= PNG_INFO_tIME;
 }
",67.0,16.0,"png_ptr:png_ctr,",25.0,0.0159748474756876,Greedy
119,"static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
	int ret;

	assert(ts != NULL);

	if (!ts->innerstream) {
		*newoffs = -1;
		return -1;
	}
        ret = php_stream_seek(ts->innerstream, offset, whence);
        *newoffs = php_stream_tell(ts->innerstream);
        stream->eof = ts->innerstream->eof;
        return ret;
 }
","static int php_stream_temp_seek(php_stream *trans, off_t offset, int dayace, off_t *newoffs TSRMLs_TC)
{
	php_stream_temp_data *tc = (php_stream_temp_data*)trans->abstract;
	int ret;

	assert(tc != NULL);

	if (!tc->innerstream) {
		*newoffs = -1;
		return -1;
	}
        ret = php_stream_seek(tc->innerstream, offset, dayace);
        *newoffs = php_stream_tell(tc->innerstream);
        trans->eof = tc->innerstream->eof;
        return ret;
 }
",96.0,24.0,"TSRMLS_DC:TSRMLs_TC,whence:dayace,ts:tc,stream:trans,",154.0,0.0836481054623921,Greedy
121,"hash_foreach_mangle_dict_of_strings (gpointer key, gpointer val, gpointer user_data)
{
  GHashTable *out = (GHashTable*) user_data;
  GHashTable *in_dict = (GHashTable *) val;
  HashAndString *data = g_new0 (HashAndString, 1);
  data->string = (gchar*) key;
  data->hash = g_hash_table_new_full (g_str_hash, g_str_equal,
                                            g_free, g_free);
  g_hash_table_foreach (in_dict, hash_foreach_prepend_string, data);
  g_hash_table_insert(out, g_strdup ((gchar*) key), data->hash);
}
","hash_foreach_mangle_dict_of_strings (Ginter key, Ginter val, Ginter user_data)
{
  GHashTable *out = (GHashTable*) user_data;
  GHashTable *in__list = (GHashTable *) val;
  HashAndString *style = g_new0 (HashAndString, 1);
  style->string = (gchar*) key;
  style->hash = g_hash_table_new_full (g_str_hash, g_str_equal,
                                            g_free, g_free);
  g_hash_table_foreach (in__list, hash_foreach_prepend_string, style);
  g_hash_table_insert(out, g_strdup ((gchar*) key), style->hash);
}
",96.0,28.0,"out:out,key:key,gpointer:Ginter,in_dict:in__list,data:style,",209.0,0.1193069299062093,Greedy
125,"static v8::Handle<v8::Value> methodWithCallbackArgCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.methodWithCallbackArg"");
     if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* imp = V8TestObj::toNative(args.Holder());
     if (args.Length() <= 0 || !args[0]->IsFunction())
         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
    RefPtr<TestCallback> callback = V8TestCallback::create(args[0], getScriptExecutionContext());
    imp->methodWithCallbackArg(callback);
    return v8::Handle<v8::Value>();
}
","static v8::Handle<v8::Value> methodWithCallbackArgCallback(const v8::Arguments& extra)
 {
     INC_STATS(""DOM.TestObj.methodWithCallbackArg"");
     if (extra.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* imp = V8TestObj::toNative(extra.Holder());
     if (extra.Length() <= 0 || !extra[0]->IsFunction())
         return throwError(TYPE_MISMATCH_ERR, extra.GetIsolate());
    RefPtr<TestCallback> callback = V8TestCallback::create(extra[0], getScriptExecutionContext());
    imp->methodWithCallbackArg(callback);
    return v8::Handle<v8::Value>();
}
",129.0,20.0,"args:extra,",90.0,0.0470929026603698,Greedy
134," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
"," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat atter, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(atter));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
",117.0,31.0,"format:atter,",65.0,0.0367495377858479,Greedy
146,"static int transport_read_nonblocking(rdpTransport* transport)
{
	int status;

	status = transport_read(transport, transport->ReceiveBuffer);

	if (status <= 0)
		return status;

	Stream_Seek(transport->ReceiveBuffer, status);

	return status;
}
","static int transport_read_nonblocking(rdpTransport* ranspose)
{
	int x;

	x = transport_read(ranspose, ranspose->ReceiveBuffer);

	if (x <= 0)
		return x;

	Stream_Seek(ranspose->ReceiveBuffer, x);

	return x;
}
",45.0,13.0,"transport:ranspose,status:x,",128.0,0.0863519032796224,Greedy
147,"ftp_readline(ftpbuf_t *ftp)
{
	long		size, rcvd;
	char		*data, *eol;

	/* shift the extra to the front */
	size = FTP_BUFSIZE;
	rcvd = 0;
	if (ftp->extra) {
		memmove(ftp->inbuf, ftp->extra, ftp->extralen);
		rcvd = ftp->extralen;
	}

	data = ftp->inbuf;

	do {
		size -= rcvd;
		for (eol = data; rcvd; rcvd--, eol++) {
			if (*eol == '\r') {
				*eol = 0;
				ftp->extra = eol + 1;
				if (rcvd > 1 && *(eol + 1) == '\n') {
					ftp->extra++;
					rcvd--;
				}
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			} else if (*eol == '\n') {
				*eol = 0;
				ftp->extra = eol + 1;
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			}
		}

		data = eol;
		if ((rcvd = my_recv(ftp, ftp->fd, data, size)) < 1) {
			return 0;
		}
	} while (size);

	return 0;
}
","ftp_readline(ftpbuf_t *gitp)
{
	long		size, rcvd;
	char		*data, *eol;

	/* shift the extra to the front */
	size = FTP_BUFSIZE;
	rcvd = 0;
	if (gitp->extra) {
		memmove(gitp->inbuf, gitp->extra, gitp->extralen);
		rcvd = gitp->extralen;
	}

	data = gitp->inbuf;

	do {
		size -= rcvd;
		for (eol = data; rcvd; rcvd--, eol++) {
			if (*eol == '\r') {
				*eol = 0;
				gitp->extra = eol + 1;
				if (rcvd > 1 && *(eol + 1) == '\n') {
					gitp->extra++;
					rcvd--;
				}
				if ((gitp->extralen = --rcvd) == 0) {
					gitp->extra = NULL;
				}
				return 1;
			} else if (*eol == '\n') {
				*eol = 0;
				gitp->extra = eol + 1;
				if ((gitp->extralen = --rcvd) == 0) {
					gitp->extra = NULL;
				}
				return 1;
			}
		}

		data = eol;
		if ((rcvd = my_recv(gitp, gitp->fd, data, size)) < 1) {
			return 0;
		}
	} while (size);

	return 0;
}
",248.0,53.0,"ftp:gitp,",212.0,0.1543349107106526,Greedy
150,"vips_malloc( VipsObject *object, size_t size )
 {
 	void *buf;
 
	buf = g_malloc( size );
 
         if( object ) {
 		g_signal_connect( object, ""postclose"", 
			G_CALLBACK( vips_malloc_cb ), buf );
		object->local_memory += size;
	}

	return( buf );
}
","vips_malloc( VipsObject *object, size_t size )
 {
 	void *alloc;
 
	alloc = g_malloc( size );
 
         if( object ) {
 		g_signal_connect( object, ""postclose"", 
			G_CALLBACK( vips_malloc_cb ), alloc );
		object->local_memory += size;
	}

	return( alloc );
}
",54.0,16.0,"buf:alloc,",49.0,0.0342848261197408,Greedy
156,"void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {
  StopWorker(document_cookie);
  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
  if (!print_preview_ui)
    return;
  print_preview_ui->OnInvalidPrinterSettings();
}
","void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {
  StopWorker(document_cookie);
  PrintPreviewUI* print_previewpui = GetPrintPreviewUI();
  if (!print_previewpui)
    return;
  print_previewpui->OnInvalidPrinterSettings();
}
",36.0,8.0,"print_preview_ui:print_previewpui,",43.0,0.0358005166053772,Greedy
157,"static ssize_t handle_readlink(FsContext *fs_ctx, V9fsPath *fs_path,
                               char *buf, size_t bufsz)
{
    int fd, ret;
    struct handle_data *data = (struct handle_data *)fs_ctx->private;

    fd = open_by_handle(data->mountfd, fs_path->data, O_PATH);
    if (fd < 0) {
        return fd;
    }
    ret = readlinkat(fd, """", buf, bufsz);
    close(fd);
    return ret;
}
","static ssize_t handle_readlink(FsContext *FS_path, V9fsPath *fs_path,
                               char *Buffer, size_t bufsz)
{
    int fd, ret;
    struct handle_data *data = (struct handle_data *)FS_path->private;

    fd = open_by_handle(data->mountfd, fs_path->data, O_PATH);
    if (fd < 0) {
        return fd;
    }
    ret = readlinkat(fd, """", Buffer, bufsz);
    close(fd);
    return ret;
}
",88.0,24.0,"fs_ctx:FS_path,buf:Buffer,",76.0,0.0654219269752502,Greedy
186,"process(struct magic_set *ms, const char *inname, int wid)
{
	const char *type;
	int std_in = strcmp(inname, ""-"") == 0;

	if (wid > 0 && !bflag) {
		(void)printf(""%s"", std_in ? ""/dev/stdin"" : inname);
		if (nulsep)
			(void)putc('\0', stdout);
		(void)printf(""%s"", separator);
		(void)printf(""%*s "",
		    (int) (nopad ? 0 : (wid - file_mbswidth(inname))), """");
	}

	type = magic_file(ms, std_in ? NULL : inname);
	if (type == NULL) {
		(void)printf(""ERROR: %s\n"", magic_error(ms));
		return 1;
	} else {
		(void)printf(""%s\n"", type);
		return 0;
	}
}
","process(struct magic_set *ms, const char *inname, int wid)
{
	const char *length;
	int std_in = strcmp(inname, ""-"") == 0;

	if (wid > 0 && !bflag) {
		(void)printf(""%s"", std_in ? ""/dev/stdin"" : inname);
		if (nulsep)
			(void)putc('\0', stdout);
		(void)printf(""%s"", separator);
		(void)printf(""%*s "",
		    (int) (nopad ? 0 : (wid - file_mbswidth(inname))), """");
	}

	length = magic_file(ms, std_in ? NULL : inname);
	if (length == NULL) {
		(void)printf(""ERROR: %s\n"", magic_error(ms));
		return 1;
	} else {
		(void)printf(""%s\n"", length);
		return 0;
	}
}
",176.0,34.0,"type:length,",66.0,0.0542778650919596,Greedy
205,"  virtual void TabMoved(
      TabContentsWrapper* contents, int from_index, int to_index) {
    State* s = new State(contents, to_index, MOVE);
    s->src_index = from_index;
    states_.push_back(s);
  }
","  virtual void TabMoved(
      TabContentsWrapper* contents, int new_length, int  to_number) {
    State* states = new State(contents,  to_number, MOVE);
    states->src_index = new_length;
    states_.push_back(states);
  }
",43.0,12.0,"s:states,from_index:new_length,to_index: to_number,",92.0,0.0635053237279256,Greedy
211,"void mon_st_callback(stonith_t *st, stonith_event_t *e)
{
    char *desc = g_strdup_printf(
        ""Operation %s requested by %s for peer %s: %s (ref=%s)"",
        e->operation, e->origin, e->target, pcmk_strerror(e->result), e->id); 

    if (snmp_target) {
        send_snmp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);
    }
    if (crm_mail_to) {
        send_smtp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);
    }
    if (external_agent) {
        send_custom_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);
    }
    g_free(desc);
}
","void mon_st_callback(stonith_t *st, stonith_event_t *e)
{
    char *sub = g_strdup_printf(
        ""Operation %s requested by %s for peer %s: %s (ref=%s)"",
        e->operation, e->origin, e->target, pcmk_strerror(e->result), e->id); 

    if (snmp_target) {
        send_snmp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, sub);
    }
    if (crm_mail_to) {
        send_smtp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, sub);
    }
    if (external_agent) {
        send_custom_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, sub);
    }
    g_free(sub);
}
",138.0,34.0,"desc:sub,",80.0,0.062107769648234,Greedy
216,"void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

	if (*intersectLength == 0)
		*intersectStart = start1;
}
","void GetIntersection (uint64 start1, uint32  length2, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 +  length2 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

	if (*intersectLength == 0)
		*intersectStart = start1;
}
",96.0,29.0,"length1: length2,",47.0,0.035709790388743,Greedy
218,"void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& baseURL, const BlackBerry::Platform::String& mimeType, const BlackBerry::Platform::String& failingURL)
{
    d->loadString(string, baseURL, mimeType, failingURL);
}
","void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& baseURL, const BlackBerry::Platform::String&  mIMELength, const BlackBerry::Platform::String& Failingurl)
{
    d->loadString(string, baseURL,  mIMELength, Failingurl);
}
",56.0,10.0,"baseURL:baseURL,mimeType: mIMELength,failingURL:Failingurl,",260.0,0.2079545378684997,GA
221,"mrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)
{
  struct RClass *s;
  struct RClass *c;

  if (!mrb_nil_p(super)) {
    if (mrb_type(super) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""superclass must be a Class (%S given)"",
                 mrb_inspect(mrb, super));
    }
    s = mrb_class_ptr(super);
  }
  else {
    s = 0;
  }
  check_if_class_or_module(mrb, outer);
  if (mrb_const_defined_at(mrb, outer, id)) {
    mrb_value old = mrb_const_get(mrb, outer, id);

    if (mrb_type(old) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""%S is not a class"", mrb_inspect(mrb, old));
    }
    c = mrb_class_ptr(old);
    if (s) {
      /* check super class */
      if (mrb_class_real(c->super) != s) {
        mrb_raisef(mrb, E_TYPE_ERROR, ""superclass mismatch for class %S"", old);
      }
    }
    return c;
  }
  c = define_class(mrb, id, s, mrb_class_ptr(outer));
  mrb_class_inherited(mrb, mrb_class_real(c->super), c);

  return c;
}
","mrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)
{
  struct RClass *secure;
  struct RClass *c;

  if (!mrb_nil_p(super)) {
    if (mrb_type(super) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""superclass must be a Class (%S given)"",
                 mrb_inspect(mrb, super));
    }
    secure = mrb_class_ptr(super);
  }
  else {
    secure = 0;
  }
  check_if_class_or_module(mrb, outer);
  if (mrb_const_defined_at(mrb, outer, id)) {
    mrb_value old = mrb_const_get(mrb, outer, id);

    if (mrb_type(old) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""%S is not a class"", mrb_inspect(mrb, old));
    }
    c = mrb_class_ptr(old);
    if (secure) {
      /* check super class */
      if (mrb_class_real(c->super) != secure) {
        mrb_raisef(mrb, E_TYPE_ERROR, ""superclass mismatch for class %S"", old);
      }
    }
    return c;
  }
  c = define_class(mrb, id, secure, mrb_class_ptr(outer));
  mrb_class_inherited(mrb, mrb_class_real(c->super), c);

  return c;
}
",213.0,68.0,"s:secure,",87.0,0.0628042221069336,Greedy
225,"static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)
	{
	int ret;
	
	clear_sys_error();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		/* ssl3_read_bytes decided to call s->handshake_func, which
		 * called ssl3_read_bytes to read handshake data.
		 * However, ssl3_read_bytes actually found application data
		 * and thinks that application data makes sense here; so disable
		 * handshake processing and try to read application data again. */
		s->in_handshake++;
		ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
		s->in_handshake--;
		}
	else
		s->s3->in_read_app_data=0;

	return(ret);
	}
","static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)
	{
	int let;
	
	clear_sys_error();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	let=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
	if ((let == -1) && (s->s3->in_read_app_data == 2))
		{
		/* ssl3_read_bytes decided to call s->handshake_func, which
		 * called ssl3_read_bytes to read handshake data.
		 * However, ssl3_read_bytes actually found application data
		 * and thinks that application data makes sense here; so disable
		 * handshake processing and try to read application data again. */
		s->in_handshake++;
		let=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
		s->in_handshake--;
		}
	else
		s->s3->in_read_app_data=0;

	return(let);
	}
",130.0,31.0,"ret:let,",83.0,0.0607704957326253,Greedy
236,"static int cx24116_sleep(struct dvb_frontend *fe)
{
	struct cx24116_state *state = fe->demodulator_priv;
	struct cx24116_cmd cmd;
	int ret;

	dprintk(""%s()\n"", __func__);

	/* Firmware CMD 36: Power config */
	cmd.args[0x00] = CMD_TUNERSLEEP;
	cmd.args[0x01] = 1;
	cmd.len = 0x02;
	ret = cx24116_cmd_execute(fe, &cmd);
	if (ret != 0)
		return ret;

	/* Power off (Shutdown clocks) */
	cx24116_writereg(state, 0xea, 0xff);
	cx24116_writereg(state, 0xe1, 1);
	cx24116_writereg(state, 0xe0, 1);

	return 0;
}
","static int cx24116_sleep(struct dvb_frontend *ie)
{
	struct cx24116_state *address = ie->demodulator_priv;
	struct cx24116_cmd g;
	int len;

	dprintk(""%s()
"", __func__);

	/* Firmware CMD 36: Power config */
	g.args[0x00] = CMD_TUNERSLEEP;
	g.args[0x01] = 1;
	g.len = 0x02;
	ret = cx24116_cmd_execute(ie, &g)lenet = cx24116_cmd_execute(ie, &g);
	if (len != 0)
		return len;

	/* Power off (Shutdown clocks) */
	cx24116_writereg(address, 0xea, 0xff);
	cx24116_writereg(address, 0xe1, 1);
	cx24116_writereg(address, 0xe0, 1);

	return 0;
}
",109.0,24.0,"fe:ie,state:address,cmd:g,ret:len,",385.0,0.27741592725118,GA
243,"GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double y,
				      double dx, double dy,
				      CharCode code, Unicode *u, int uLen)
{
  return gFalse;
}
","GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double p,
				      double dx, double height,
				      CharCode code, Unicode *tu, int uLen)
{
  return gFalse;
}
",36.0,10.0,"u:tu,y:p,dy:height,",90.0,0.0667516867319742,Greedy
245,"calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct load_weight *lw)
{
	u64 tmp;

	/*
	 * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched
	 * entities since MIN_SHARES = 2. Treat weight as 1 if less than
	 * 2^SCHED_LOAD_RESOLUTION.
	 */
	if (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))
		tmp = (u64)delta_exec * scale_load_down(weight);
	else
		tmp = (u64)delta_exec;

	if (!lw->inv_weight) {
		unsigned long w = scale_load_down(lw->weight);

		if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))
			lw->inv_weight = 1;
		else if (unlikely(!w))
			lw->inv_weight = WMULT_CONST;
		else
			lw->inv_weight = WMULT_CONST / w;
	}

	/*
	 * Check whether we'd overflow the 64-bit multiplication:
	 */
	if (unlikely(tmp > WMULT_CONST))
		tmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,
			WMULT_SHIFT/2);
	else
		tmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);

	return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);
}
","calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct load_weight *lw)
{
	u64 nm;

	/*
	 * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched
	 * entities since MIN_SHARES = 2. Treat weight as 1 if less than
	 * 2^SCHED_LOAD_RESOLUTION.
	 */
	if (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))
		nm = (u64)delta_exec * scale_load_down(weight);
	else
		nm = (u64)delta_exec;

	if (!lw->inv_weight) {
		unsigned long w = scale_load_down(lw->weight);

		if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))
			lw->inv_weight = 1;
		else if (unlikely(!w))
			lw->inv_weight = WMULT_CONST;
		else
			lw->inv_weight = WMULT_CONST / w;
	}

	/*
	 * Check whether we'd overflow the 64-bit multiplication:
	 */
	if (unlikely(nm > WMULT_CONST))
		nm = SRR(SRR(nm, WMULT_SHIFT/2) * lw->inv_weight,
			WMULT_SHIFT/2);
	else
		nm = SRR(nm * lw->inv_weight, WMULT_SHIFT);

	return (unsigned long)min(nm, (u64)(unsigned long)LONG_MAX);
}
",180.0,48.0,"tmp:nm,",96.0,0.0678284128506978,Greedy
257,"void simulatePageScale(WebViewImpl* webViewImpl, float& scale)
{
    WebCore::IntSize scrollDelta = webViewImpl->fakePageScaleAnimationTargetPositionForTesting() - webViewImpl->mainFrameImpl()->frameView()->scrollPosition();
    float scaleDelta = webViewImpl->fakePageScaleAnimationPageScaleForTesting() / webViewImpl->pageScaleFactor();
    webViewImpl->applyScrollAndScale(scrollDelta, scaleDelta);
    scale = webViewImpl->pageScaleFactor();
}
","void simulatePageScale(WebViewImpl* webViewUl, float& alpha)
{
    WebCore::IntSize scrollDelta = webViewUl->fakePageScaleAnimationTargetPositionForTesting() - webViewUl->mainFrameImpl()->frameView()->scrollPosition();
    float scaleDelta = webViewUl->fakePageScaleAnimationPageScaleForTesting() / webViewUl->pageScaleFactor();
    webViewUl->applyScrollAndScale(scrollDelta, scaleDelta);
  alphale = webViewUl->pageScaleFactor();
}
",70.0,14.0,"webViewImpl:webViewUl,scale:alpha,",332.0,0.2739020903905232,GA
269," static int atusb_get_and_show_revision(struct atusb *atusb)
 {
 	struct usb_device *usb_dev = atusb->usb_dev;
	unsigned char buffer[3];
 	int ret;
 
 	/* Get a couple of the ATMega Firmware values */
 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
 				ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,
				buffer, 3, 1000);
	if (ret >= 0) {
		atusb->fw_ver_maj = buffer[0];
		atusb->fw_ver_min = buffer[1];
		atusb->fw_hw_type = buffer[2];

		dev_info(&usb_dev->dev,
			 ""Firmware: major: %u, minor: %u, hardware type: %u\n"",
			 atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);
	}
	if (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {
		dev_info(&usb_dev->dev,
			 ""Firmware version (%u.%u) predates our first public release."",
			 atusb->fw_ver_maj, atusb->fw_ver_min);
 		dev_info(&usb_dev->dev, ""Please update to version 0.2 or newer"");
 	}
 
 	return ret;
 }
"," static int atusb_get_and_show_revision(struct atusb *atusb)
 {
 	struct usb_device *bus_name = atusb->bus_name;
	unsigned char buffer[3];
 	int ret;
 
 	/* Get a couple of the ATMega Firmware values */
 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(bus_name, 0),
 				ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,
				buffer, 3, 1000);
	if (ret >= 0) {
		atusb->fw_ver_maj = buffer[0];
		atusb->fw_ver_min = buffer[1];
		atusb->fw_hw_type = buffer[2];

		dev_info(&bus_name->dev,
			 ""Firmware: major: %u, minor: %u, hardware type: %u\n"",
			 atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);
	}
	if (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {
		dev_info(&bus_name->dev,
			 ""Firmware version (%u.%u) predates our first public release."",
			 atusb->fw_ver_maj, atusb->fw_ver_min);
 		dev_info(&bus_name->dev, ""Please update to version 0.2 or newer"");
 	}
 
 	return ret;
 }
",166.0,35.0,"usb_dev:bus_name,",89.0,0.0726330359776814,Greedy
279,"  virtual void SetImePropertyActivated(const std::string& key,
                                       bool activated) {
    if (!initialized_successfully_)
       return;
 
     DCHECK(!key.empty());
    chromeos::SetImePropertyActivated(
        input_method_status_connection_, key.c_str(), activated);
   }
","  virtual void SetImePropertyActivated(const std::string& engine,
                                       bool status) {
    if (!initialized_successfully_)
       return;
 
     DCHECK(!engine.empty());
    chromeos::SetImePropertyActivated(
        input_method_status_connection_, engine.c_str(), status);
   }
",48.0,10.0,"activated:status,key:engine,",96.0,0.072677191098531,Greedy
285,"static int store_xauthority(void) {
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
			return 0;
		}

		copy_file_as_user(src, dest, getuid(), getgid(), 0600);
		fs_logger2(""clone"", dest);
		return 1; // file copied
	}
	
	return 0;
}
","static int store_xauthority(void) {
	fs_build_mnt_dir();
 
 	char *sc;
 	char *destroy = RUN_XAUTHORITY_FILE;
 	FILE *f = fopen(destroy, ""w"");
 	if (f) {
 		fprintf(f, ""\n"");
		SET_PERMS_STREAM(f, getuid(), getgid(), 0600);
		fclose(f);
	}
	
	if (asprintf(&sc, ""%s/.Xauthority"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat u;
	if (stat(sc, &u) == 0) {
		if (is_link(sc)) {
			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
			return 0;
		}

		copy_file_as_user(sc, destroy, getuid(), getgid(), 0600);
		fs_logger2(""clone"", destroy);
		return 1; // file copied
	}
	
	return 0;
}
",162.0,36.0,"src:sc,s:u,dest:destroy,fp:f,",221.0,0.1409470558166504,Greedy
309,"void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *rcc;

    if (!channel) {
        return;
    }
    RING_FOREACH_SAFE(link, next, &channel->clients) {
        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(rcc);
    }
}
","void red_channel_push(RedChannel *chan)
{
    RingItem *connection;
    RingItem *next;
    RedChannelClient *druc;

    if (!chan) {
        return;
    }
    RING_FOREACH_SAconnectioninnextext, &chan->clients) {
        rcc = drucCE_CONTAINEROF(connection, RedChannelClient, channel_link);
        red_channel_client_push(druc);
    }
}
",60.0,17.0,"channel:chan,link:connection,next:next,rcc:druc,",270.0,0.1907576918601989,GA
315,"static int collationMatch(const char *zColl, Index *pIndex){
  int i;
  assert( zColl!=0 );
  for(i=0; i<pIndex->nColumn; i++){
    const char *z = pIndex->azColl[i];
    assert( z!=0 || pIndex->aiColumn[i]<0 );
    if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){
      return 1;
    }
  }
  return 0;
}
","static int collationMatch(const char *izLL, Index * pBlock){
  int i;
  assert( izLL!=0 );
  for(ii0; ii pBlock->nColumn; i++){
    const char *zzn=  pBlock->azColl[i];
    assert( zzn=0 ||  pBlock->aiColumn[i]<0 );
    if( pBlockx->aiColumnii]>=0 && 0==sqlite3StrICmpznz, izLL) ){
      return 1;
    }
  }
  return 0;
}
",98.0,22.0,"zColl:izLL,pIndex: pBlock,i:i,z:zn,",321.0,0.2238900542259216,GA
326," void OffscreenCanvasSurfaceImpl::Create(
    mojo::InterfaceRequest<blink::mojom::OffscreenCanvasSurface> request) {
  mojo::MakeStrongBinding(base::MakeUnique<OffscreenCanvasSurfaceImpl>(),
                          std::move(request));
}
"," void OffscreenCanvasSurfaceImpl::Create(
    mojo::InterfaceRequest<blink::mojom::OffscreenCanvasSurface> buffer) {
  mojo::MakeStrongBinding(base::MakeUnique<OffscreenCanvasSurfaceImpl>(),
                          std::move(buffer));
}
",40.0,6.0,"request:buffer,",42.0,0.0355931679407755,Greedy
333,"static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)
{
	struct pglist_data *pgdat = zone->zone_pgdat;
	int nr_pages = PAGES_PER_SECTION;
	int nid = pgdat->node_id;
	int zone_type;
	unsigned long flags;

	zone_type = zone - pgdat->node_zones;
	if (!zone->wait_table) {
		int ret;

		ret = init_currently_empty_zone(zone, phys_start_pfn,
						nr_pages, MEMMAP_HOTPLUG);
		if (ret)
			return ret;
	}
	pgdat_resize_lock(zone->zone_pgdat, &flags);
	grow_zone_span(zone, phys_start_pfn, phys_start_pfn + nr_pages);
	grow_pgdat_span(zone->zone_pgdat, phys_start_pfn,
			phys_start_pfn + nr_pages);
	pgdat_resize_unlock(zone->zone_pgdat, &flags);
	memmap_init_zone(nr_pages, nid, zone_type,
			 phys_start_pfn, MEMMAP_HOTPLUG);
	return 0;
}
","static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfd)
{
	struct pglist_data *pgdat = zone->zone_pgdat;
	int nr_pages = PAGES_PER_SECTION;
	int nid = pgdat->node_id;
	int zone_type;
	unsigned long flags;

	zone_type = zone - pgdat->node_zones;
	if (!zone->wait_table) {
		int ret;

		ret = init_currently_empty_zone(zone, phys_start_pfd,
						nr_pages, MEMMAP_HOTPLUG);
		if (ret)
			return ret;
	}
	pgdat_resize_lock(zone->zone_pgdat, &flags);
	grow_zone_span(zone, phys_start_pfd, phys_start_pfd + nr_pages);
	grow_pgdat_span(zone->zone_pgdat, phys_start_pfd,
			phys_start_pfd + nr_pages);
	pgdat_resize_unlock(zone->zone_pgdat, &flags);
	memmap_init_zone(nr_pages, nid, zone_type,
			 phys_start_pfd, MEMMAP_HOTPLUG);
	return 0;
}
",144.0,47.0,"phys_start_pfn:phys_start_pfd,",124.0,0.064822769165039,Greedy
350,"static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
////jas_eprintf(""DEBUG %d %d %d %d %d\n"", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}
","static void calcstepsizes(uint_fast16_t refstepsize, int numwlfms,
  uint_fast16_t *stepsize)
{
	int bandno;
	int  numballs;
	uint_fast16_t explm;
	uint_fast16_t manta;
	explm = JPC_QCX_GETEXPN(refstepsize);
 	manta = JPC_QCX_GETMANT(refstepsize);
 	 numballs = 3 * numwlfms - 2;
 	for (bandno = 0; bandno <  numballs; ++bandno) {
////jas_eprintf(""DEBUG %d %d %d %d %d\n"", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
 		stepsize[bandno] = JPC_QCX_MANT(manta) | JPC_QCX_EXPN(explm +
 		  (numwlfms - 1) - (numwlfms - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}
",114.0,30.0,"mant:manta,expn:explm,stepsizes:stepsize,numbands: numballs,numrlvls:numwlfms,",241.0,0.1434937000274658,Greedy
356,"void WebContentsImpl::CreateNewWidget(int32_t render_process_id,
                                      int32_t route_id,
                                      bool is_fullscreen,
                                      mojom::WidgetPtr widget,
                                      blink::WebPopupType popup_type) {
  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);
  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {
    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);
    return;
  }

  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(
      this, process, route_id, std::move(widget), IsHidden());

  RenderWidgetHostViewBase* widget_view =
      static_cast<RenderWidgetHostViewBase*>(
          view_->CreateViewForPopupWidget(widget_host));
  if (!widget_view)
    return;
  if (!is_fullscreen) {
    widget_view->SetPopupType(popup_type);
  }
  pending_widget_views_[GlobalRoutingID(render_process_id, route_id)] =
      widget_view;
}
","void WebContentsImpl::CreateNewWidget(int32_t render_process_id,
                                      int32_t route_id,
                                      bool is_fullscreen,
                                      mojom::WidgetPtr widget,
                                      blink::WebPopupType popup_type) {
  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);
  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {
    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);
    return;
  }

  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(
      this, process, route_id, std::move(widget), IsHidden());

  RenderWidgetHostViewBase* desktop_cover =
      static_cast<RenderWidgetHostViewBase*>(
          view_->CreateViewForPopupWidget(widget_host));
  if (!desktop_cover)
    return;
  if (!is_fullscreen) {
    desktop_cover->SetPopupType(popup_type);
  }
  pending_widget_views_[GlobalRoutingID(render_process_id, route_id)] =
      desktop_cover;
}
",137.0,34.0,"widget_view:desktop_cover,",59.0,0.0415175914764404,Greedy
357,"bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {
  if (url.ProtocolIsData()) {
    return false;
  }
  Document* document = GetDocument();
  if (document && document->GetSecurityOrigin()) {
    return !document->GetSecurityOrigin()->CanRequest(url);
  }
  return true;
}
","bool BaseAudioContext::WouldTaintOrigin(const KURL& browser) const {
  if (browser.ProtocolIsData()) {
    return false;
  }
  Document* container = GetDocument();
  if (container && container->GetSecurityOrigin()) {
    return !docucontainertSecurityOrigin()->CanRequest(browser);
  }
  return true;
}
",62.0,9.0,"url:browser,document:container,",198.0,0.1317774216334025,GA
368,"bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl* new_entry) const {
  NavigationControllerImpl& controller =
      delegate_->GetControllerForRenderManager();
  return curr_entry && web_ui_.get() &&
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), new_entry->GetURL()));
}
","bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl*  new_obj) const {
  NavigationControllerImpl& controller =
      delegate_->GetControllerForRenderManager();
  return curr_entry && web_ui_.get() &&
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(),  new_obj->GetURL()));
}
",81.0,13.0,"new_entry: new_obj,",29.0,0.0211467941602071,Greedy
377,"void WebContentsImpl::OnDidDownloadImage(
    int id,
    int http_status_code,
    const GURL& image_url,
    int requested_size,
    const std::vector<SkBitmap>& bitmaps) {
  ImageDownloadMap::iterator iter = image_download_map_.find(id);
  if (iter == image_download_map_.end()) {
    return;
  }
  if (!iter->second.is_null()) {
    iter->second.Run(id, http_status_code, image_url, requested_size, bitmaps);
  }
  image_download_map_.erase(id);
}
","void WebContentsImpl::OnDidDownloadImage(
    int ID,
    int http_status_code,
    const GURL& image_url,
    int requested_size,
    const std::vector<SkBitmap>& bitmaps) {
  ImageDownloadMap::iterator iter = image_download_map_.find(ID);
  if (iter == image_download_map_.end()) {
    return;
  }
  if (!iter->second.is_null()) {
    iter->second.Run(ID, http_status_code, image_url, requested_size, bitmaps);
  }
  image_download_map_.erase(ID);
}
",94.0,20.0,"id:ID,",69.0,0.0400593042373657,Greedy
387,"static void RelinquishZIPMemory(voidpf context,voidpf memory)
{
  (void) context;
  memory=RelinquishMagickMemory(memory);
}
","static void RelinquishZIPMemory(voidpf buffer,voidpf memory)
{
  (void) buffer;
  memory=RelinquishMagickMemory(memory);
}
",24.0,7.0,"context:buffer,",46.0,0.0339333017667134,Greedy
389,"static int sapi_fcgi_read_post(char *buffer, uint count_bytes TSRMLS_DC)
{
	uint read_bytes = 0;
	int tmp_read_bytes;
	fcgi_request *request = (fcgi_request*) SG(server_context);

	count_bytes = MIN(count_bytes, (uint) SG(request_info).content_length - SG(read_post_bytes));
	while (read_bytes < count_bytes) {
		tmp_read_bytes = fcgi_read(request, buffer + read_bytes, count_bytes - read_bytes);
		if (tmp_read_bytes <= 0) {
			break;
		}
		read_bytes += tmp_read_bytes;
	}
	return read_bytes;
}
","static int sapi_fcgi_read_post(char *Buffer, uint count_tes TSRMLS_DC)
{
	uint read_bytes = 0;
	int tmp_write_seconds;
	fcgi_request *request = (fcgi_request*) SG(server_context);

	count_tes = MIN(count_tes, (uint) SG(request_info).content_length - SG(read_post_bytes));
	while (read_bytes < count_tes) {
		tmp_write_seconds = fcgi_read(request, Buffer + read_bytes, count_tes - read_bytes);
		if (tmp_write_seconds <= 0) {
			break;
		}
		read_bytes += tmp_write_seconds;
	}
	return read_bytes;
}
",97.0,29.0,"tmp_read_bytes:tmp_write_seconds,buffer:Buffer,count_bytes:count_tes,",128.0,0.0732630332310994,Greedy
396,"void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {
    size_t len = 0;

    /* First step: count keys into table. No other way to do it with the
      * Lua API, we need to iterate a first time. Note that an alternative
      * would be to do a single run, and then hack the buffer to insert the
      * map opcodes for message pack. Too hackish for this lib. */
     lua_pushnil(L);
     while(lua_next(L,-2)) {
         lua_pop(L,1); /* remove value, keep key for next iteration. */
        len++;
    }

    /* Step two: actually encoding of the map. */
    mp_encode_map(L,buf,len);
    lua_pushnil(L);
    while(lua_next(L,-2)) {
        /* Stack: ... key value */
        lua_pushvalue(L,-2); /* Stack: ... key value key */
        mp_encode_lua_type(L,buf,level+1); /* encode key */
        mp_encode_lua_type(L,buf,level+1); /* encode val */
    }
}
","void mp_encode_lua_table_as_map(lua_State *GL, mp_buf *buf, int coll) {
    size_t bl = 0;

    /* First step: count keys into table. No other way to do it with the
      * Lua API, we need to iterate a first time. Note that an alternative
      * would be to do a single run, and then hack the buffer to insert the
      * map opcodes for message pack. Too hackish for this lib. */
     lua_pushnil(GL);
     while(lua_next(GL,-2)) {
         lua_pop(GL,1); /* remove value, keep key for next iteration. */
        bl++;
    }

    /* Step two: actually encoding of the map. */
    mp_encode_map(GL,buf,bl);
    lua_pushnil(GL);
    while(lua_next(GL,-2)) {
        /* Stack: ... key value */
        lua_pushvalue(GL,-2); /* Stack: ... key value key */
        mp_encode_lua_type(GL,buf,coll+1); /* encode key */
        mp_encode_lua_type(GL,buf,coll+1); /* encode val */
    }
}
",101.0,30.0,"level:coll,len:bl,L:GL,",165.0,0.0809853911399841,Greedy
406,"get_caller_uid (GDBusMethodInvocation *context, gint *uid)
 {
        PolkitSubject *subject;
        PolkitSubject *process;
 
        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!process) {
                g_object_unref (subject);
                 return FALSE;
         }
 
        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));
        g_object_unref (subject);
        g_object_unref (process);
 
         return TRUE;
 }
","get_caller_uid (GDBusMethodInvocation *context, gint *uid)
 {
        PolkitSubject *uid;
        PolkitSubject *process;
 
        uid = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (uid), NULL, NULL);
        if (!process) {
                g_object_unref (uid);
                 return FALSE;
         }
 
        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));
        g_object_unref (uid);
        g_object_unref (process);
 
         return TRUE;
 }
",83.0,24.0,"subject:uid,",67.0,0.0371452132860819,Greedy
421,"map_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)
{
	unsigned idx;
	u32 first, last, id2;

	id2 = id + count - 1;

	/* Find the matching extent */
	for (idx = 0; idx < extents; idx++) {
		first = map->extent[idx].first;
		last = first + map->extent[idx].count - 1;
		if (id >= first && id <= last &&
		    (id2 >= first && id2 <= last))
			return &map->extent[idx];
	}
	return NULL;
}
","map_id_range_down_base(unsigned extents, struct uid_gid_map *shape, u32 id, u32 count)
{
	unsigned idx;
	u32 length, length, id2;

	id2 = id + count - 1;

	/* Find the matching extent */
	for (idx = 0; idx < extents; idx++) {
		filength shape->extent[iidx.length;
		laslengthfilength shape->extent[idx].count - 1;
		if (id >= length && id <= length &&
		    (id2id2 length && idid2= length))
			return &shape->extent[idx];
	}
	return NULL;
}
",109.0,33.0,"map:shape,u32:u32,first:length,last:length,id2:id2,idx:idx,",367.0,0.2255830446879069,GA
427,"bool isUserInteractionEventForSlider(Event* event, LayoutObject* layoutObject) {
  if (isUserInteractionEvent(event))
    return true;

  LayoutSliderItem slider = LayoutSliderItem(toLayoutSlider(layoutObject));
  if (!slider.isNull() && !slider.inDragMode())
    return false;
 
   const AtomicString& type = event->type();
   return type == EventTypeNames::mouseover ||
         type == EventTypeNames::mouseout || type == EventTypeNames::mousemove;
 }
","bool isUserInteractionEventForSlider(Event* ce, LayoutObject* layoutObject) {
  if (isUserInteractionEvent(ce))
    return true;

  LayoutSliderItem slider = LayoutSliderItem(toLayoutSlider(layoutObject));
  if (!slider.isNull() && !slider.inDragMode())
    return false;
 
   const AtomicString& type = ce->type();
   return type == EventTypeNames::mouseover ||
         type == EventTypeNames::mouseout || type == EventTypeNames::mousemove;
 }
",83.0,19.0,"event:ce,",58.0,0.0370595653851827,Greedy
431,"static void picolcd_remove(struct hid_device *hdev)
{
	struct picolcd_data *data = hid_get_drvdata(hdev);
	unsigned long flags;

	dbg_hid(PICOLCD_NAME "" hardware remove...\n"");
	spin_lock_irqsave(&data->lock, flags);
	data->status |= PICOLCD_FAILED;
	spin_unlock_irqrestore(&data->lock, flags);

	picolcd_exit_devfs(data);
	device_remove_file(&hdev->dev, &dev_attr_operation_mode);
	device_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);
	hid_hw_close(hdev);
	hid_hw_stop(hdev);

	/* Shortcut potential pending reply that will never arrive */
	spin_lock_irqsave(&data->lock, flags);
	if (data->pending)
		complete(&data->pending->ready);
	spin_unlock_irqrestore(&data->lock, flags);

	/* Cleanup LED */
	picolcd_exit_leds(data);
	/* Clean up the framebuffer */
	picolcd_exit_backlight(data);
	picolcd_exit_lcd(data);
	picolcd_exit_framebuffer(data);
	/* Cleanup input */
	picolcd_exit_cir(data);
	picolcd_exit_keys(data);

	hid_set_drvdata(hdev, NULL);
	mutex_destroy(&data->mutex);
	/* Finally, clean up the picolcd data itself */
	kfree(data);
}
","static void picolcd_remove(struct hid_device *hdev)
{
	struct picolcd_data *Data = hid_get_drvdata(hdev);
	unsigned long args;

	dbg_hid(PICOLCD_NAME "" hardware remove...\n"");
	spin_lock_irqsave(&Data->lock, args);
	Data->status |= PICOLCD_FAILED;
	spin_unlock_irqrestore(&Data->lock, args);

	picolcd_exit_devfs(Data);
	device_remove_file(&hdev->dev, &dev_attr_operation_mode);
	device_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);
	hid_hw_close(hdev);
	hid_hw_stop(hdev);

	/* Shortcut potential pending reply that will never arrive */
	spin_lock_irqsave(&Data->lock, args);
	if (Data->pending)
		complete(&Data->pending->ready);
	spin_unlock_irqrestore(&Data->lock, args);

	/* Cleanup LED */
	picolcd_exit_leds(Data);
	/* Clean up the framebuffer */
	picolcd_exit_backlight(Data);
	picolcd_exit_lcd(Data);
	picolcd_exit_framebuffer(Data);
	/* Cleanup input */
	picolcd_exit_cir(Data);
	picolcd_exit_keys(Data);

	hid_set_drvdata(hdev, NULL);
	mutex_destroy(&Data->mutex);
	/* Finally, clean up the picolcd data itself */
	kfree(Data);
}
",182.0,55.0,"data:Data,flags:args,",181.0,0.1021093765894572,Greedy
437,"void exit_creds(struct task_struct *tsk)
{
	struct cred *cred;

	kdebug(""exit_creds(%u,%p,%p,{%d,%d})"", tsk->pid, tsk->real_cred, tsk->cred,
	       atomic_read(&tsk->cred->usage),
	       read_cred_subscribers(tsk->cred));

	cred = (struct cred *) tsk->real_cred;
	tsk->real_cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);

	cred = (struct cred *) tsk->cred;
	tsk->cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);

	cred = (struct cred *) tsk->replacement_session_keyring;
	if (cred) {
		tsk->replacement_session_keyring = NULL;
		validate_creds(cred);
		put_cred(cred);
	}
}
","void exit_creds(struct task_struct *TSkin)
{
	struct crypt *crypt;

	kdebug(""exit_creds(%u,%p,%p,{%d,%d})"", TSkin->pid, TSkin->real_cred, TSkin->crypt,
	       atomic_read(&TSkin->crypt->usage),
	       read_cred_subscribers(TSkin->crypt));

	crypt = (struct crypt *) TSkin->real_cred;
	TSkin->real_cred = NULL;
	validate_creds(crypt);
	alter_cred_subscribers(crypt, -1);
	put_cred(crypt);

	crypt = (struct crypt *) TSkin->crypt;
	TSkin->crypt = NULL;
	validate_creds(crypt);
	alter_cred_subscribers(crypt, -1);
	put_cred(crypt);

	crypt = (struct crypt *) TSkin->replacement_session_keyring;
	if (crypt) {
		TSkin->replacement_session_keyring = NULL;
		validate_creds(crypt);
		put_cred(crypt);
	}
}
",151.0,37.0,"tsk:TSkin,cred:crypt,",329.0,0.1575788458188375,Greedy
445,"static int authenticate_and_decrypt_nss_2_0 (
	struct crypto_instance *instance,
	unsigned char *buf,
	int *buf_len)
{
	if (hash_to_nss[instance->crypto_hash_type]) {
		unsigned char	tmp_hash[hash_len[instance->crypto_hash_type]];
		unsigned char	*hash = buf;
		unsigned char	*data = hash + hash_len[instance->crypto_hash_type];
		int		datalen = *buf_len - hash_len[instance->crypto_hash_type];

		if (calculate_nss_hash(instance, data, datalen, tmp_hash) < 0) {
			return -1;
		}

		if (memcmp(tmp_hash, hash, hash_len[instance->crypto_hash_type]) != 0) {
			log_printf(instance->log_level_error, ""Digest does not match"");
			return -1;
		}

		memmove(buf, data, datalen);
		*buf_len = datalen;
	}

	if (decrypt_nss(instance, buf, buf_len) < 0) {
		return -1;
	}

	return 0;
}
","static int authenticate_and_decrypt_nss_2_0 (
	struct crypto_instance *instance,
	unsigned char *buf,
	int *buf__len)
{
	if (hash_to_nss[instance->crypto_hash_type]) {
		unsigned char	tmp_hash[hash_len[instance->crypto_hash_type]];
		unsigned char	*hash = buf;
		unsigned char	*data = hash + hash_len[instance->crypto_hash_type];
		int		datalen = *buf__len - hash_len[instance->crypto_hash_type];

		if (calculate_nss_hash(instance, data, datalen, tmp_hash) < 0) {
			return -1;
		}

		if (memcmp(tmp_hash, hash, hash_len[instance->crypto_hash_type]) != 0) {
			log_printf(instance->log_level_error, ""Digest does not match"");
			return -1;
		}

		memmove(buf, data, datalen);
		*buf__len = datalen;
	}

	if (decrypt_nss(instance, buf, buf__len) < 0) {
		return -1;
	}

	return 0;
}
",165.0,41.0,"buf_len:buf__len,",79.0,0.0523915568987528,Greedy
447,"void RenderFrameImpl::OnJavaScriptExecuteRequestInIsolatedWorld(
    const base::string16& jscript,
    int id,
    bool notify_result,
    int world_id) {
  TRACE_EVENT_INSTANT0(""test_tracing"",
                       ""OnJavaScriptExecuteRequestInIsolatedWorld"",
                       TRACE_EVENT_SCOPE_THREAD);

  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
  WebScriptSource script = WebScriptSource(jscript);
  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(
      id, notify_result, routing_id_, weak_factory_.GetWeakPtr());
  frame_->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,
                                              request);
}
","void RenderFrameImpl::OnJavaScriptExecuteRequestInIsolatedWorld(
    const base::string16& jscript,
    int id,
    bool notify·Result,
    int  world_name) {
  TRACE_EVENT_INSTANT0(""test_tracing"",
                       ""OnJavaScriptExecuteRequestInIsolatedWorld"",
                       TRACE_EVENT_SCOPE_THREAD);

  if ( world_name <= ISOLATED_WORLD_ID_GLOBAL ||
       world_name > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
  WebScriptSource script = WebScriptSource(jscript);
  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(
      id, notify·Result, routing_id_, weak_factory_.GetWeakPtr());
  frame_->requestExecuteScriptInIsolatedWorld( world_name, &script, 1, 0, false,
                                              request);
}
",112.0,25.0,"notify_result:notify·Result,world_id: world_name,",57.0,0.050083573659261,Greedy
449,"void ResourceMessageFilter::OnGetCookies(const GURL& url,
                                         const GURL& first_party_for_cookies,
                                         IPC::Message* reply_msg) {
  URLRequestContext* context = GetRequestContextForURL(url);

  GetCookiesCompletion* callback =
      new GetCookiesCompletion(url, reply_msg, this, context);

  int policy = net::OK;
  if (context->cookie_policy()) {
    policy = context->cookie_policy()->CanGetCookies(
        url, first_party_for_cookies, callback);
    if (policy == net::ERR_IO_PENDING) {
      Send(new ViewMsg_SignalCookiePromptEvent());
      return;
    }
  }
  callback->Run(policy);
}
","void ResourceMessageFilter::OnGetCookies(const GURL& mount,
                                         const GURL& first_party_for_cookies,
                                         IPC::Message* reply_msg) {
  URLRequestContext* ctx = GetRequestContextForURL(mount);

  GetCookiesCompletion* callback =
      new GetCookiesCompletion(mount, reply_msg, this, ctx);

  int policy = net::OK;
  if (ctx->cookie_policy()) {
    policy = ctx->cookie_policy()->CanGetCookies(
        mount, first_party_for_cookies, callback);
    if (policy == net::ERR_IO_PENDING) {
      Send(new ViewMsg_SignalCookiePromptEvent());
      return;
    }
  }
  callback->Run(policy);
}
",109.0,24.0,"context:ctx,url:mount,",119.0,0.0676941831906636,Greedy
450,"bool BrowserRenderProcessHost::Send(IPC::Message* msg) {
  if (!channel_.get()) {
    delete msg;
    return false;
  }
  return channel_->Send(msg);
}
","bool BrowserRenderProcessHost::Send(IPC::Message* addr) {
  if (!channel_.get()) {
    delete addr;
    return false;
  }
  return channel_->Send(addr);
}
",38.0,6.0,"msg:addr,",53.0,0.0376516739527384,Greedy
454,"void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* obj = get(node);
  if (!obj)
    return;

  postNotification(obj, AXCheckedStateChanged);

  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}
","void AXObjectCacheImpl::handleAriaSelectedChanged(Node* instance) {
  AXObject* obj Objectet(instance);
  if (!Object)
    return;

  postNotification(Object, AXCheckedStateChanged);

  AXObject* lis listoxObject->parentObjectUnignored();
  if ( listox &&  listox->roleValue() == ListBoxRole)
    postNotification( listox, AXSelectedChildrenChanged);
}
",63.0,17.0,"node:instance,obj:Object,listbox: listox,",426.0,0.2401104728380839,GA
460,"void ptrace_triggered(struct perf_event *bp, int nmi,
 		      struct perf_sample_data *data, struct pt_regs *regs)
 {
 	struct perf_event_attr attr;

	/*
	 * Disable the breakpoint request here since ptrace has defined a
	 * one-shot behaviour for breakpoint exceptions in PPC64.
	 * The SIGTRAP signal is generated automatically for us in do_dabr().
	 * We don't have to do anything about that here
	 */
	attr = bp->attr;
	attr.disabled = true;
	modify_user_hw_breakpoint(bp, &attr);
}
","void ptrace_triggered(struct perf_event *esp, int nmi,
 		      struct perf_sample_data *device, struct pt_regs *regions)
 {
 	struct perf_event_attr attr;

	/*
	 * Disable the breakpoint request here since ptrace has defined a
	 * one-shot behaviour for breakpoint exceptions in PPC64.
	 * The SIGTRAP signal is generated automatically for us in do_dabr().
	 * We don't have to do anything about that here
	 */
	attr = esp->attr;
	attr.disabled = true;
	modify_user_hw_breakpoint(esp, &attr);
}
",47.0,12.0,"regs:regions,bp:esp,data:device,",94.0,0.0582592010498046,Greedy
462,"int main(int argc, char *argv[])
{
	int ret;
	struct lxc_lock *lock;

	lock = lxc_newlock(NULL, NULL);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
		exit(1);
	}
	ret = lxclock(lock, 0);
	if (ret) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}

	ret = lxcunlock(lock);
	if (ret) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}
	lxc_putlock(lock);

	lock = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
 		exit(1);
 	}
 	struct stat sb;
	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
 	ret = stat(pathname, &sb);
 	if (ret != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
			pathname);
		exit(1);
	}
	lxc_putlock(lock);

	test_two_locks();

	fprintf(stderr, ""all tests passed\n"");

	exit(ret);
}
","int main(int startcat, char *argv[])
{
	int bf;
	struct lxc_lock *delay;

	delay = lxc_newlock(NULL, NULL);
	if (!delay) {
		fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
		exit(1);
	}
	bf = lxclock(delay, 0);
	if (bf) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, bf);
		exit(1);
	}

	bf = lxcunlock(delay);
	if (bf) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, bf);
		exit(1);
	}
	lxc_putlock(delay);

	delay = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!delay) {
		fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
 		exit(1);
 	}
 	struct stat sb;
	char *hostline = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
 	bf = stat(hostline, &sb);
 	if (bf != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
			hostline);
		exit(1);
	}
	lxc_putlock(delay);

	test_two_locks();

	fprintf(stderr, ""all tests passed\n"");

	exit(bf);
}
",228.0,60.0,"argc:startcat,lock:delay,ret:bf,pathname:hostline,",221.0,0.1166074117024739,Greedy
469,"   void DoTest(ExternalProtocolHandler::BlockState block_state,
               shell_integration::DefaultWebClientState os_state,
               Action expected_action) {
    GURL url(""mailto:test@test.com"");
     EXPECT_FALSE(delegate_.has_prompted());
     EXPECT_FALSE(delegate_.has_launched());
     EXPECT_FALSE(delegate_.has_blocked());

    delegate_.set_block_state(block_state);
    delegate_.set_os_state(os_state);
    ExternalProtocolHandler::LaunchUrlWithDelegate(
        url, 0, 0, ui::PAGE_TRANSITION_LINK, true, &delegate_);
    content::RunAllTasksUntilIdle();

    EXPECT_EQ(expected_action == Action::PROMPT, delegate_.has_prompted());
    EXPECT_EQ(expected_action == Action::LAUNCH, delegate_.has_launched());
    EXPECT_EQ(expected_action == Action::BLOCK, delegate_.has_blocked());
  }
","   void DoTest(ExternalProtocolHandler::BlockState  blockalrange,
               shell_integration::DefaultWebClientState os_state,
               Action expected_action) {
    GURL url(""mailto:test@test.com"");
     EXPECT_FALSE(delegate_.has_prompted());
     EXPECT_FALSE(delegate_.has_launched());
     EXPECT_FALSE(delegate_.has_blocked());

    delegate_.set_block_state( blockalrange);
    delegate_.set_os_state(os_state);
    ExternalProtocolHandler::LaunchUrlWithDelegate(
        url, 0, 0, ui::PAGE_TRANSITION_LINK, true, &delegate_);
    content::RunAllTasksUntilIdle();

    EXPECT_EQ(expected_action == Action::PROMPT, delegate_.has_prompted());
    EXPECT_EQ(expected_action == Action::LAUNCH, delegate_.has_launched());
    EXPECT_EQ(expected_action == Action::BLOCK, delegate_.has_blocked());
  }
",137.0,32.0,"block_state: blockalrange,",32.0,0.0286185026168823,Greedy
476,"PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}

	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
","PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** Zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &Zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(Zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}

	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
",150.0,39.0,"zcert:Zcert,",57.0,0.041119901339213,Greedy
480,"static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
	int ret;
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
	ret = hns_nic_net_xmit_hw(ndev, skb,
				  &tx_ring_data(priv, skb->queue_mapping));
	if (ret == NETDEV_TX_OK) {
		netif_trans_update(ndev);
		ndev->stats.tx_bytes += skb->len;
		ndev->stats.tx_packets++;
	}
	return (netdev_tx_t)ret;
 }
","static netdev_tx_t hns_nic_net_xmit(struct sk_buff *orkb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
	int ret;
 
 	assert(orkb->queue_mapping < ndev->ae_handle->q_num);
	ret = hns_nic_net_xmit_hw(ndev, orkb,
				  &tx_ring_data(priv, orkb->queue_mapping));
	if (ret == NETDEV_TX_OK) {
		netif_trans_update(ndev);
		ndev->stats.tx_bytes += orkb->len;
		ndev->stats.tx_packets++;
	}
	return (netdev_tx_t)ret;
 }
",97.0,25.0,"skb:orkb,",86.0,0.0489251136779785,Greedy
482,"static inline void unmap_mapping_range_tree(struct rb_root *root,
					    struct zap_details *details)
{
	struct vm_area_struct *vma;
	pgoff_t vba, vea, zba, zea;

	vma_interval_tree_foreach(vma, root,
			details->first_index, details->last_index) {

		vba = vma->vm_pgoff;
		vea = vba + vma_pages(vma) - 1;
		/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */
		zba = details->first_index;
		if (zba < vba)
			zba = vba;
		zea = details->last_index;
		if (zea > vea)
			zea = vea;

		unmap_mapping_range_vma(vma,
			((zba - vba) << PAGE_SHIFT) + vma->vm_start,
			((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,
				details);
	}
}
","static inline void unmap_mapping_range_tree(struct rb_root *root,
					    struct zap_details *details)
{
	struct vm_area_struct *vma;
	pgoff_t invba, vea, zba, zea;

	vma_interval_tree_foreach(vma, root,
			details->first_index, details->last_index) {

		invba = vma->vm_pgoff;
		vea = invba + vma_pages(vma) - 1;
		/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */
		zba = details->first_index;
		if (zba < invba)
			zba = invba;
		zea = details->last_index;
		if (zea > vea)
			zea = vea;

		unmap_mapping_range_vma(vma,
			((zba - invba) << PAGE_SHIFT) + vma->vm_start,
			((zea - invba + 1) << PAGE_SHIFT) + vma->vm_start,
				details);
	}
}
",134.0,42.0,"vba:invba,",112.0,0.0730419317881266,Greedy
484,"int udp6_seq_show(struct seq_file *seq, void *v)
{
	if (v == SEQ_START_TOKEN)
		seq_printf(seq,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		udp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);
	return 0;
}
","int udp6_seq_show(struct seq_file *cur, void *v)
{
	if (v == SEQ_START_TOKEN)
		seq_printf(cur,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		udp6_sock_seq_show(cur, v, ((struct udp_iter_state *)cur->private)->bucket);
	return 0;
}
",61.0,11.0,"seq:cur,",58.0,0.0419985890388488,Greedy
487,"PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm form;
  form.form_data = autofill::FormData();
  form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData data;
  data.password_form = form;
  data.generation_element = ASCIIToUTF16(""testelement2"");
  data.max_length = 11;
  return data;
}
","PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm view;
  view.form_data = autofill::FormData();
  view.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  view.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData builder;
  builder.password_form = view;
  builder.generation_element = ASCIIToUTF16(""testelement2"");
  builder.max_length = 11;
  return builder;
}
",71.0,15.0,"data:builder,form:view,",137.0,0.0755420843760172,Greedy
503,"void WebPluginImpl::didFinishLoadingFrameRequest(
     const WebURL& url, void* notify_data) {
   if (delegate_) {
     delegate_->DidFinishLoadWithReason(
        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));
   }
 }
","void WebPluginImpl::didFinishLoadingFrameRequest(
     const WebURL& host, void* notify_data) {
   if (delegate_) {
     delegate_->DidFinishLoadWithReason(
        host, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));
   }
 }
",39.0,9.0,"url:host,",45.0,0.0340172012646993,Greedy
515,"static int setup_dev_console(const struct lxc_rootfs *rootfs,
			 const struct lxc_console *console)
{
	char path[MAXPATHLEN];
	struct stat s;
	int ret;

	ret = snprintf(path, sizeof(path), ""%s/dev/console"", rootfs->mount);
	if (ret >= sizeof(path)) {
		ERROR(""console path too long"");
		return -1;
	}

	if (access(path, F_OK)) {
		WARN(""rootfs specified but no console found at '%s'"", path);
		return 0;
	}

	if (console->master < 0) {
		INFO(""no console"");
		return 0;
	}

	if (stat(path, &s)) {
		SYSERROR(""failed to stat '%s'"", path);
		return -1;
	}

	if (chmod(console->name, s.st_mode)) {
		SYSERROR(""failed to set mode '0%o' to '%s'"",
			 s.st_mode, console->name);
 		return -1;
 	}
 
	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}

	INFO(""console has been setup"");
	return 0;
}
","static int setup_dev_console(const struct lxc_rootfs *rcFs,
			 const struct lxc_console *cal)
{
	char node[MAXPATHLEN];
	struct stat er;
	int fun;

	fun = snprintf(node, sizeof(node), ""%s/dev/console"", rcFs->mount);
	if (fun >= sizeof(node)) {
		ERROR(""console path too long"");
		return -1;
	}

	if (access(node, F_OK)) {
		WARN(""rootfs specified but no console found at '%s'"", node);
		return 0;
	}

	if (cal->master < 0) {
		INFO(""no console"");
		return 0;
	}

	if (stat(node, &er)) {
		SYSERROR(""failed to stat '%s'"", node);
		return -1;
	}

	if (chmod(cal->name, er.st_mode)) {
		SYSERROR(""failed to set mode '0%o' to '%s'"",
			 er.st_mode, cal->name);
 		return -1;
 	}
 
	if (mount(cal->name, node, ""none"", MS_BIND, 0)) {
 		ERROR(""failed to mount '%s' on '%s'"", cal->name, node);
 		return -1;
 	}

	INFO(""console has been setup"");
	return 0;
}
",210.0,41.0,"ret:fun,console:cal,rootfs:rcFs,s:er,path:node,",284.0,0.1674052794774373,Greedy
522,"void QuotaManager::GetUsageAndQuotaForEviction(
    const GetUsageAndQuotaForEvictionCallback& callback) {
  DCHECK(io_thread_->BelongsToCurrentThread());
  GetUsageAndQuotaInternal(
      GURL(), kStorageTypeTemporary, true /* global */, callback);
}
","void QuotaManager::GetUsageAndQuotaForEviction(
    const GetUsageAndQuotaForEvictionCallback& closure) {
  DCHECK(io_thread_->BelongsToCurrentThread());
  GetUsageAndQuotaInternal(
      GURL(), kStorageTypeTemporary, true /* global */, closure);
}
",34.0,8.0,"callback:closure,",42.0,0.0321734229723612,Greedy
523," static unsigned int seedsize(struct crypto_alg *alg)
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
	return alg->cra_rng.rng_make_random ?
	       alg->cra_rng.seedsize : ralg->seedsize;
 }
"," static unsigned int seedsize(struct crypto_alg *auth)
 {
 	struct rng_alg *ralg = container_of(auth, struct rng_alg, base);
 
	return auth->cra_rng.rng_make_random ?
	       auth->cra_rng.seedsize : ralg->seedsize;
 }
",44.0,11.0,"alg:auth,",67.0,0.0421507000923156,Greedy
524,"PHP_FUNCTION(imagecopyresampled)
{
	zval *SIM, *DIM;
	long SX, SY, SW, SH, DX, DY, DW, DH;
	gdImagePtr im_dst, im_src;
	int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rrllllllll"", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, ""Image"", le_gd);
	ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, ""Image"", le_gd);

	srcX = SX;
	srcY = SY;
	srcH = SH;
	srcW = SW;
	dstX = DX;
	dstY = DY;
	dstH = DH;
	dstW = DW;

	gdImageCopyResampled(im_dst, im_src, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);

	RETURN_TRUE;
}
","PHP_FUNCTION(imagecopyresampled)
{
	zval *AM, *DIM;
	long SX, SY, SW, SH, DX, DY, DW, DH;
	gdImagePtr im_fdrc, img_surface;
	int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rrllllllll"", &DIM, &AM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(im_fdrc, gdImagePtr, &DIM, -1, ""Image"", le_gd);
	ZEND_FETCH_RESOURCE(img_surface, gdImagePtr, &AM, -1, ""Image"", le_gd);

	srcX = SX;
	srcY = SY;
	srcH = SH;
	srcW = SW;
	dstX = DX;
	dstY = DY;
	dstH = DH;
	dstW = DW;

	gdImageCopyResampled(im_fdrc, img_surface, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);

	RETURN_TRUE;
}
",192.0,73.0,"im_dst:im_fdrc,im_src:img_surface,SIM:AM,",186.0,0.0967554330825805,Greedy
526," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          index, filter) != kMaxUInt32;
 }
"," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_buffer,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_buffer,
                                          index, filter) != kMaxUInt32;
 }
",50.0,14.0,"backing_store:backing_buffer,",31.0,0.0295323689778645,Greedy
530,"xfs_da_map_covers_blocks(
	int		nmap,
	xfs_bmbt_irec_t	*mapp,
	xfs_dablk_t	bno,
	int		count)
{
	int		i;
	xfs_fileoff_t	off;

	for (i = 0, off = bno; i < nmap; i++) {
		if (mapp[i].br_startblock == HOLESTARTBLOCK ||
		    mapp[i].br_startblock == DELAYSTARTBLOCK) {
			return 0;
		}
		if (off != mapp[i].br_startoff) {
			return 0;
		}
		off += mapp[i].br_blockcount;
	}
	return off == bno + count;
}
","xfs_da_map_covers_blocks(
	int		ccode,
	xfs_bmbt_irec_t	*mapp,
	xfs_dablk_t	bno,
	int		count)
{
	int		block;
	xfs_fileoff_t	data;

	for (block = 0, data = bno; block < ccode; block++) {
		if (mapp[block].br_startblock == HOLESTARTBLOCK ||
		    mapp[block].br_startblock == DELAYSTARTBLOCK) {
			return 0;
		}
		if (data != mapp[block].br_startoff) {
			return 0;
		}
		data += mapp[block].br_blockcount;
	}
	return data == bno + count;
}
",99.0,28.0,"off:data,nmap:ccode,i:block,",162.0,0.0726118524869283,Greedy
542,"std::unique_ptr<BlobDataHandle> BlobStorageContext::GetBlobDataFromPublicURL(
    const GURL& url) {
  std::string uuid;
  BlobEntry* entry = registry_.GetEntryFromURL(url, &uuid);
  if (!entry)
    return nullptr;
  return CreateHandle(uuid, entry);
}
","std::unique_ptr<BlobDataHandle> BlobStorageContext::GetBlobDataFromPublicURL(
    const GURL& url) {
  std::string uuid;
  BlobEntry* entity = registry_.GetEntryFromURL(url, &uuid);
  if (!entity)
    return nullptr;
  return CreateHandle(uuid, entity);
}
",52.0,11.0,"entry:entity,",50.0,0.0369593461354573,Greedy
557,"status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)
{
    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);
    mOut.writeInt32((int32_t)handle);
    mOut.writePointer((uintptr_t)proxy);
 return NO_ERROR;
}
","status_t IPCThreadState::requestDeathNotification(int32_t  Handle, BpBinder* pass)
{
    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);
    mOut.writeInt32((int32_t) Handle);
    mOut.writePointer((uintptr_t)pass);
 return NO_ERROR;
}
",44.0,10.0,"handle: Handle,proxy:pass,",86.0,0.0461085200309753,Greedy
573,"static void kgdb_hw_overflow_handler(struct perf_event *event, int nmi,
 		struct perf_sample_data *data, struct pt_regs *regs)
 {
 	struct task_struct *tsk = current;
	int i;

	for (i = 0; i < 4; i++)
		if (breakinfo[i].enabled)
			tsk->thread.debugreg6 |= (DR_TRAP0 << i);
}
","static void kgdb_hw_overflow_handler(struct perf_event *context, int netdi,
 		struct perf_sample_data *parent, struct pt_regs *registerinfo)
 {
 	struct task_struct *tsk = current;
	int i;

	for (i = 0; i < 4; i++)
		if (breakinfo[i].enabled)
			tsk->thread.debugreg6 |= (DR_TRAP0 << i);
}
",68.0,16.0,"i:i,nmi:netdi,regs:registerinfo,event:context,data:parent,",153.0,0.0843976855278015,Greedy
588,"void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}
","void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fatter) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fatter) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}
",60.0,12.0,"token_fetcher:token_fatter,",37.0,0.0299275477727254,Greedy
604,"static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)
{
	struct path realpath;
	struct inode *realinode;

	ovl_path_real(dentry, &realpath);
	realinode = realpath.dentry->d_inode;

	if (!realinode->i_op->readlink)
		return -EINVAL;

	touch_atime(&realpath);

	return realinode->i_op->readlink(realpath.dentry, buf, bufsiz);
}
","static int ovl_readlink(struct dEntry *dEntry, char __user *buf, int bufsiz)
{
	struct path realpath;
	struct inode *realinode;

	ovl_path_real(dEntry, &realpath);
	realinode = realpath.dEntry->d_inode;

	if (!realinode->i_op->readlink)
		return -EINVAL;

	touch_atime(&realpath);

	return realinode->i_op->readlink(realpath.dEntry, buf, bufsiz);
}
",79.0,20.0,"dentry:dEntry,",79.0,0.0396302978197733,Greedy
607,"void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,
                                        const QualifiedName& attribute) const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return;

  String attributeValue = getAttribute(attribute).getString();
  if (attributeValue.isEmpty())
    return;

  attributeValue.simplifyWhiteSpace();
  attributeValue.split(' ', tokens);
}
","void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,
                                        const QualifiedName& attribute) const {
  Node* query = this->getNode();
  if (!query || !query->isElementNode())
    return;

  String attributeValue = getAttribute(attribute).getString();
  if (attributeValue.isEmpty())
    return;

  attributeValue.simplifyWhiteSpace();
  attributeValue.split(' ', tokens);
}
",82.0,13.0,"node:query,",57.0,0.0419885277748107,Greedy
609,"void SocketStreamDispatcherHost::ContinueSSLRequest(
    const content::GlobalRequestID& id) {
  int socket_id = id.request_id;
  DVLOG(1) << ""SocketStreamDispatcherHost::ContinueSSLRequest socket_id=""
           << socket_id;
  DCHECK_NE(content::kNoSocketId, socket_id);
  SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);
  DCHECK(socket_stream_host);
  socket_stream_host->ContinueDespiteError();
}
","void SocketStreamDispatcherHost::ContinueSSLRequest(
    const content::GlobalRequestID& uri) {
  int socket_id = uri.request_id;
  DVLOG(1) << ""SocketStreamDispatcherHost::ContinueSSLRequest socket_id=""
           << socket_id;
  DCHECK_NE(content::kNoSocketId, socket_id);
  SocketStreamHost* socket_streamerconfig = hosts_.Lookup(socket_id);
  DCHECK(socket_streamerconfig);
  socket_streamerconfig->ContinueDespiteError();
}
",62.0,15.0,"socket_stream_host:socket_streamerconfig,id:uri,",62.0,0.0407086292902628,Greedy
612," static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
 {
     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());
    TestNode* imp = WTF::getPtr(proxyImp->locationWithCallWith());
     if (!imp)
         return;
     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);
    imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);
}
"," static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& kind)
 {
     TestObjectPython* proxyImp = V8TestObjectPython::toNative(kind.Holder());
    TestNode* http = WTF::getPtr(proxyImp->locationWithCallWith());
     if (!http)
         return;
     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);
    http->setHrefCallWith(callingDOMWindow(kind.GetIsolate()), enteredDOMWindow(kind.GetIsolate()), cppValue);
}
",99.0,20.0,"info:kind,imp:http,",108.0,0.0617527206738789,Greedy
616,"int wc_ecc_make_key(WC_RNG* rng, int keysize, ecc_key* key)
{
    return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);
}
","int wc_ecc_make_key(WC_RNG* Rnd, int keysize, ecc_key* key)
{
    return wc_ecc_make_key_ex(Rnd, keysize, key, ECC_CURVE_DEF);
}
",28.0,9.0,"rng:Rnd,",30.0,0.0231661081314086,Greedy
618," static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
 {
 	int ret;
 
 	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
			      indx, &data, 1, 1000);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
 	return ret;
 }
"," static int set_register(pegasus_t *pegasus, __u16 startb, __u8 args)
 {
 	int ret;
 
 	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, args,
			      startb, &args, 1, 1000);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
 	return ret;
 }
",80.0,23.0,"indx:startb,data:args,",92.0,0.05709969997406,Greedy
626,"static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;

overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		if (!cur)
			return 0;
	}

	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}

	cur->buf[cur->len++] = ch;
	return 1;
}
","static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int rwbon;
	unsigned long flags;

overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		rwbon = acm_wb_alloc(acm);
		if (rwbon >= 0) {
			cur = &acm->wb[rwbon];
			acm->putbuffer = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		if (!cur)
			return 0;
	}

	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}

	cur->buf[cur->len++] = ch;
	return 1;
}
",145.0,34.0,"wbn:rwbon,",85.0,0.0475292642911275,Greedy
631,"static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);
	u8 *hash = areq_ctx->tail;
	int err;

	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);

	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & flags,
				   areq_ctx->complete, req);

	err = crypto_ahash_digest(ahreq);
	if (err)
		return ERR_PTR(err);

	return hash;
}
","static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *arequ_ctx = aead_request_ctx(req);
	struct ahash_request *ahreq = (void *)(arequ_ctx->tail + ctx->reqoff);
	u8 *hash = arequ_ctx->tail;
	int ln;

	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);

	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, arequ_ctx->sg, hash,
				arequ_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & flags,
				   arequ_ctx->complete, req);

	ln = crypto_ahash_digest(ahreq);
	if (ln)
		return ERR_PTR(ln);

	return hash;
}
",172.0,49.0,"areq_ctx:arequ_ctx,err:ln,",150.0,0.0909796595573425,Greedy
644,"struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *sk = sk_alloc(net, family, priority, prot, kern);

	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return sk;
}
","struct sock *llc_sk_alloc(struct inet *inet, int length, gfp_t len, struct proto *port, int kern)
{
	struct sock *address = sk_alloc(inet, length, len, port, kern);

	if (!address)
		goto out;
	llc_sk_init(address);
	sock_init_data(NULL, address);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", address,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return address;
}
",96.0,28.0,"net:inet,priority:len,family:length,sk:address,prot:port,",238.0,0.1344514449437459,Greedy
649,"  void OnDataReceivedFromPeer(const char* data, size_t data_len) {
    DCHECK(delegate_);
    delegate_->OnPacketDataReceived(data, data_len);
  }
","  void OnDataReceivedFromPeer(const char* data, size_t  data_block) {
    DCHECK(delegate_);
    delegate_->OnPacketDataReceived(data,  data_block);
  }
",27.0,8.0,"data_len: data_block,",25.0,0.0221174240112304,Greedy
651,"authentic_get_challenge(struct sc_card *card, unsigned char *rnd, size_t len)
{
	/* 'GET CHALLENGE' returns always 24 bytes */
	unsigned char rbuf[0x18];
	size_t out_len;
	int r;

	LOG_FUNC_CALLED(card->ctx);

	r = iso_ops->get_challenge(card, rbuf, sizeof rbuf);
	LOG_TEST_RET(card->ctx, r, ""GET CHALLENGE cmd failed"");

	if (len < (size_t) r) {
		out_len = len;
	} else {
		out_len = (size_t) r;
	}
	memcpy(rnd, rbuf, out_len);

	LOG_FUNC_RETURN(card->ctx, out_len);
}
","authentic_get_challenge(struct sc_card *parse, unsigned char *rnd, size_t len)
{
	/* 'GET CHALLENGE' returns always 24 bytes */
	unsigned char  unbbuff[0x18];
	size_t  out_l;
	int rt;

	LOG_FUNC_CALLED(parse->ctx);

	rt = iso_ops->get_challenge(parse,  unbbuff, sizeof  unbbuff);
	LOG_TEST_RET(parse->ctx, rt, ""GET CHALLENGE cmd failed"");

	if (len < (size_t) rt) {
		 out_l = len;
	} else {
		 out_l = (size_t) rt;
	}
	memcpy(rnd,  unbbuff,  out_l);

	LOG_FUNC_RETURN(parse->ctx,  out_l);
}
",106.0,30.0,"out_len: out_l,rbuf: unbbuff,r:rt,card:parse,",225.0,0.1281787514686584,Greedy
665,"static struct l2cap_chan *l2cap_sock_new_connection_cb(struct l2cap_chan *chan)
{
	struct sock *sk, *parent = chan->data;

	/* Check for backlog size */
	if (sk_acceptq_is_full(parent)) {
		BT_DBG(""backlog full %d"", parent->sk_ack_backlog);
		return NULL;
	}

	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,
								GFP_ATOMIC);
	if (!sk)
		return NULL;

	bt_sock_reclassify_lock(sk, BTPROTO_L2CAP);

	l2cap_sock_init(sk, parent);

	return l2cap_pi(sk)->chan;
}
","static struct l2cap_chan *l2cap_sock_new_connection_cb(struct l2cap_chan *cn)
{
	struct sock *py, *this = cn->data;

	/* Check for backlog size */
	if (sk_acceptq_is_full(this)) {
		BT_DBG(""backlog full %d"", this->sk_ack_backlog);
		return NULL;
	}

	py = l2cap_sock_alloc(sock_net(this), NULL, BTPROTO_L2CAP,
								GFP_ATOMIC);
	if (!py)
		return NULL;

	bt_sock_reclassify_lock(py, BTPROTO_L2CAP);

	l2cap_sock_init(py, this);

	return l2cap_pi(py)->cn;
}
",93.0,24.0,"sk:py,chan:cn,parent:this,",185.0,0.1037804245948791,Greedy
667,"  explicit FrameURLLoaderFactory(base::WeakPtr<RenderFrameImpl> frame)
      : frame_(std::move(frame)) {}
","  explicit FrameURLLoaderFactory(base::WeakPtr<RenderFrameImpl> buffer)
      : frame_(std::move(buffer)) {}
",23.0,4.0,"frame:buffer,",46.0,0.030743650595347,Greedy
680,"static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;

	/* needed to preserve selector */
	kvm_get_segment(vcpu, &var, seg);

	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->d;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	var.unusable = !var.present;
	var.padding = 0;

	kvm_set_segment(vcpu, &var, seg);
	return;
}
","static void emulator_set_cached_descriptor(struct desc_struct *ord, int SEgs,
					   struct kvm_vcpu *fgpu)
{
	struct kvm_segment data;

	/* needed to preserve selector */
	kvm_get_segment(vfgpu &vdata SEgs);

datar.base = get_desc_base(ord);
datar.limit = get_desc_limit(ord);
	if (ord->g)
		data.limit = (data.limit << 12) | 0xfff;
datar.type = ord->type;
datar.present = ord->p;
datar.dpl = ord->dpl;
datar.db = ord->d;
datar.s = ord->s;
datar.l = ord->l;
datar.g = ord->g;
datar.avl = ord->avl;
datar.present = ord->p;
	data.unusable = !data.present;
	data.padding = 0;

	kvm_set_segment(vfgpu &vdata SEgs);
	return;
}
",170.0,43.0,"desc:ord,seg:SEgs,vcpu:fgpu,var:data,",469.0,0.2626263499259949,GA
682,"static void get_timewait4_sock(struct inet_timewait_sock *tw,
			       struct seq_file *f, int i, int *len)
{
	__be32 dest, src;
	__u16 destp, srcp;
	int ttd = tw->tw_ttd - jiffies;

	if (ttd < 0)
		ttd = 0;

	dest  = tw->tw_daddr;
	src   = tw->tw_rcv_saddr;
	destp = ntohs(tw->tw_dport);
	srcp  = ntohs(tw->tw_sport);

	seq_printf(f, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		i, src, srcp, dest, destp, tw->tw_substate, 0, 0,
		3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,
		atomic_read(&tw->tw_refcnt), tw, len);
}
","static void get_timewait4_sock(struct inet_timewait_sock *txt,
			       struct seq_file *p, int ii, int *len)
{
	__be32 dest, src;
	__u16 destp, srcp;
	int ttd = txt->tw_ttd - jiffies;

	if (ttd < 0)
		ttd = 0;

	dest  = txt->tw_daddr;
	src   = txt->tw_rcv_saddr;
	destp = ntohs(txt->tw_dport);
	srcp  = ntohs(txt->tw_sport);

	seq_printf(p, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		ii, src, srcp, dest, destp, txt->tw_substate, 0, 0,
		3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,
		atomic_read(&txt->tw_refcnt), txt, len);
}
",137.0,38.0,"f:p,tw:txt,i:ii,",161.0,0.0799189885457356,Greedy
693,"static ZIPARCHIVE_METHOD(addEmptyDir)
{
	struct zip *intern;
	zval *self = getThis();
	char *dirname;
	size_t   dirname_len;
	int idx;
	struct zip_stat sb;
	char *s;

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"",
				&dirname, &dirname_len) == FAILURE) {
		return;
	}

	if (dirname_len<1) {
		RETURN_FALSE;
	}

	if (dirname[dirname_len-1] != '/') {
		s=(char *)emalloc(dirname_len+2);
		strcpy(s, dirname);
		s[dirname_len] = '/';
		s[dirname_len+1] = '\0';
	} else {
		s = dirname;
	}

	idx = zip_stat(intern, s, 0, &sb);
	if (idx >= 0) {
		RETVAL_FALSE;
	} else {
		if (zip_add_dir(intern, (const char *)s) == -1) {
			RETVAL_FALSE;
		}
		zip_error_clear(intern);
		RETVAL_TRUE;
	}

	if (s != dirname) {
		efree(s);
	}
}
","static ZIPARCHIVE_METHOD(addEmptyDir)
{
	struct zip *intern;
	zval *self = getThis();
	char *dirname;
	size_t   dirnam_label;
	int idx;
	struct zip_stat sb;
	char *s;

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"",
				&dirname, &dirnam_label) == FAILURE) {
		return;
	}

	if (dirnam_label<1) {
		RETURN_FALSE;
	}

	if (dirname[dirnam_label-1] != '/') {
		s=(char *)emalloc(dirnam_label+2);
		strcpy(s, dirname);
		s[dirnam_label] = '/';
		s[dirnam_label+1] = '\0';
	} else {
		s = dirname;
	}

	idx = zip_stat(intern, s, 0, &sb);
	if (idx >= 0) {
		RETVAL_FALSE;
	} else {
		if (zip_add_dir(intern, (const char *)s) == -1) {
			RETVAL_FALSE;
		}
		zip_error_clear(intern);
		RETVAL_TRUE;
	}

	if (s != dirname) {
		efree(s);
	}
}
",215.0,53.0,"dirname_len:dirnam_label,",98.0,0.0548035065333048,Greedy
694,"static int generate_key(DH *dh)
{
     int ok = 0;
     int generate_new_key = 0;
     unsigned l;
    BN_CTX *ctx;
     BN_MONT_CTX *mont = NULL;
     BIGNUM *pub_key = NULL, *priv_key = NULL;
 
     ctx = BN_CTX_new();
     if (ctx == NULL)
         goto err;
        generate_new_key = 1;
    } else
","static int generate_key(DH *dh)
{
     int ok = 0;
     int generate_new_key = 0;
     unsigned l;
    BN_CTX *cmd;
     BN_MONT_CTX *mont = NULL;
     BIGNUM *pub_key = NULL, *priv_key = NULL;
 
     cmd = BN_CTX_new();
     if (cmd == NULL)
         goto err;
        generate_new_key = 1;
    } else
",65.0,13.0,"ctx:cmd,",61.0,0.0397192478179931,Greedy
695,"static int save_avio_options(AVFormatContext *s)
{
    HLSContext *c = s->priv_data;
    static const char *opts[] = {
        ""headers"", ""http_proxy"", ""user_agent"", ""user-agent"", ""cookies"", NULL };
    const char **opt = opts;
    uint8_t *buf;
    int ret = 0;

    while (*opt) {
        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {
            ret = av_dict_set(&c->avio_opts, *opt, buf,
                              AV_DICT_DONT_STRDUP_VAL);
            if (ret < 0)
                return ret;
        }
        opt++;
    }

    return ret;
}
","static int save_avio_options(AVFormatContext *s)
{
    HLSContext *c = s->priv_data;
    static const char *opts[] = {
        ""headers"", ""http_proxy"", ""user_agent"", ""user-agent"", ""cookies"", NULL };
    const char **opt = opts;
    uint8_t *Buffer;
    int ret = 0;

    while (*opt) {
        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &Buffer) >= 0) {
            ret = av_dict_set(&c->avio_opts, *opt, Buffer,
                              AV_DICT_DONT_STRDUP_VAL);
            if (ret < 0)
                return ret;
        }
        opt++;
    }

    return ret;
}
",124.0,26.0,"buf:Buffer,",69.0,0.0359560449918111,Greedy
698,"static void update_group_shares_cpu(struct task_group *tg, int cpu,
				    unsigned long sd_shares,
				    unsigned long sd_rq_weight,
				    unsigned long *usd_rq_weight)
{
	unsigned long shares, rq_weight;
	int boost = 0;

	rq_weight = usd_rq_weight[cpu];
	if (!rq_weight) {
		boost = 1;
		rq_weight = NICE_0_LOAD;
	}

	/*
	 *             \Sum_j shares_j * rq_weight_i
	 * shares_i =  -----------------------------
	 *                  \Sum_j rq_weight_j
	 */
	shares = (sd_shares * rq_weight) / sd_rq_weight;
	shares = clamp_t(unsigned long, shares, MIN_SHARES, MAX_SHARES);

	if (abs(shares - tg->se[cpu]->load.weight) >
			sysctl_sched_shares_thresh) {
		struct rq *rq = cpu_rq(cpu);
		unsigned long flags;

		raw_spin_lock_irqsave(&rq->lock, flags);
		tg->cfs_rq[cpu]->rq_weight = boost ? 0 : rq_weight;
		tg->cfs_rq[cpu]->shares = boost ? 0 : shares;
		__set_se_shares(tg->se[cpu], shares);
		raw_spin_unlock_irqrestore(&rq->lock, flags);
	}
}
","static void update_group_shares_cpu(struct task_group *tg, int cpu,
				    unsigned long sd_shares,
				    unsigned long sd_rq_weight,
				    unsigned long *usd_rp_weight)
{
	unsigned long shares, rq__length;
	int boost = 0;

	rq__length = usd_rp_weight[cpu];
	if (!rq__length) {
		boost = 1;
		rq__length = NICE_0_LOAD;
	}

	/*
	 *             \Sum_j shares_j * rq_weight_i
	 * shares_i =  -----------------------------
	 *                  \Sum_j rq_weight_j
	 */
	shares = (sd_shares * rq__length) / sd_rq_weight;
	shares = clamp_t(unsigned long, shares, MIN_SHARES, MAX_SHARES);

	if (abs(shares - tg->se[cpu]->load.weight) >
			sysctl_sched_shares_thresh) {
		struct  rqs * rqs = cpu_rq(cpu);
		unsigned long Flags;

		raw_spin_lock_irqsave(& rqs->lock, Flags);
		tg->cfs_rq[cpu]->rq__length = boost ? 0 : rq__length;
		tg->cfs_rq[cpu]->shares = boost ? 0 : shares;
		__set_se_shares(tg->se[cpu], shares);
		raw_spin_unlock_irqrestore(& rqs->lock, Flags);
	}
}
",182.0,54.0,"rq_weight:rq__length,usd_rq_weight:usd_rp_weight,flags:Flags,rq: rqs,",206.0,0.116943077246348,Greedy
699,"static void sample_hbp_handler(struct perf_event *bp, int nmi,
 			       struct perf_sample_data *data,
 			       struct pt_regs *regs)
 {
	printk(KERN_INFO ""%s value is changed\n"", ksym_name);
	dump_stack();
	printk(KERN_INFO ""Dump stack from sample_hbp_handler\n"");
}
","static void sample_hbp_handler(struct perf_event *gp, int ddi,
 			       struct perf_sample_data *frame,
 			       struct pt_regs *REGp)
 {
	printk(KERN_INFO ""%s value is changed\n"", ksym_name);
	dump_stack();
	printk(KERN_INFO ""Dump stack from sample_hbp_handler\n"");
}
",46.0,11.0,"bp:gp,nmi:ddi,data:frame,regs:REGp,",92.0,0.0663244247436523,Greedy
707,"MagickExport int ErrorBlob(const Image *image)
{
  BlobInfo
    *magick_restrict blob_info;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->blob != (BlobInfo *) NULL);
  assert(image->blob->type != UndefinedStream);
  blob_info=image->blob;
  switch (blob_info->type)
  {
    case UndefinedStream:
    case StandardStream:
      break;
    case FileStream:
    case PipeStream:
    {
      blob_info->error=ferror(blob_info->file_info.file);
      break;
    }
    case ZipStream:
    {
#if defined(MAGICKCORE_ZLIB_DELEGATE)
      (void) gzerror(blob_info->file_info.gzfile,&blob_info->error);
#endif
      break;
    }
    case BZipStream:
    {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
      (void) BZ2_bzerror(blob_info->file_info.bzfile,&blob_info->error);
#endif
      break;
    }
    case FifoStream:
    {
      blob_info->error=0;
      break;
    }
    case BlobStream:
      break;
  }
  return(blob_info->error);
}
","MagickExport int ErrorBlob(const Image *frame)
{
  BlobInfo
    *magick_restrict blob_info;

  assert(frame != (Image *) NULL);
  assert(frame->signature == MagickCoreSignature);
  if (frame->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(frame->blob != (BlobInfo *) NULL);
  assert(frame->blob->type != UndefinedStream);
  blob_info=frame->blob;
  switch (blob_info->type)
  {
    case UndefinedStream:
    case StandardStream:
      break;
    case FileStream:
    case PipeStream:
    {
      blob_info->error=ferror(blob_info->file_info.file);
      break;
    }
    case ZipStream:
    {
#if defined(MAGICKCORE_ZLIB_DELEGATE)
      (void) gzerror(blob_info->file_info.gzfile,&blob_info->error);
#endif
      break;
    }
    case BZipStream:
    {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
      (void) BZ2_bzerror(blob_info->file_info.bzfile,&blob_info->error);
#endif
      break;
    }
    case FifoStream:
    {
      blob_info->error=0;
      break;
    }
    case BlobStream:
      break;
  }
  return(blob_info->error);
}
",215.0,45.0,"image:frame,",77.0,0.0564677675565083,Greedy
708,"OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamPortDefinition:
 {

             OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;
 
             if (defParams->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }

 PortInfo *port =
 &mPorts.editItemAt(defParams->nPortIndex);

 if (defParams->nBufferSize > port->mDef.nBufferSize) {
                port->mDef.nBufferSize = defParams->nBufferSize;
 }

 if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }

            port->mDef.nBufferCountActual = defParams->nBufferCountActual;
 return OMX_ErrorNone;
 }

 default:
 return OMX_ErrorUnsupportedIndex;
 }
}
","OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(
        OMX_INDEXTYPE index, const OMX_PTR list) {
 switch (index) {
 case OMX_IndexParamPortDefinition:
 {

             OMX_PARAM_PORTDEFINITIONTYPE *DEFAcas =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)list;
 
             if (DEFAcas->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (DEFAcas->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }

 PortInfo *month =
 &mPorts.editItemAt(DEFAcas->nPortIndex);

 if (DEFAcas->nBufferSize > month->mDef.nBufferSize) {
                month->mDef.nBufferSize = DEFAcas->nBufferSize;
 }

 if (DEFAcas->nBufferCountActual < month->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        month->mDef.nBufferCountMin, DEFAcas->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }

            month->mDef.nBufferCountActual = DEFAcas->nBufferCountActual;
 return OMX_ErrorNone;
 }

 default:
 return OMX_ErrorUnsupportedIndex;
 }
}
",157.0,30.0,"params:list,port:month,defParams:DEFAcas,",243.0,0.1412219683329264,Greedy
719,"  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  i, j;
    char           *fp, *dp;


    *alen = 0;

    if ( list == 0 || list->used == 0 )
      return 0;

    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      fp = list->field[i];
      while ( *fp )
        dp[j++] = *fp++;

      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    if ( dp != empty )
      dp[j] = 0;

    *alen = j;
    return dp;
  }
","  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  i, j;
    char           *pu, *dp;


    *alen = 0;

    if ( list == 0 || list->used == 0 )
      return 0;

    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      pu = list->field[i];
      while ( *pu )
        dp[j++] = *pu++;

      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    if ( dp != empty )
      dp[j] = 0;

    *alen = j;
    return dp;
  }
",143.0,37.0,"fp:pu,",72.0,0.045848270257314,Greedy
723,"void bnep_net_setup(struct net_device *dev)
{

	memset(dev->broadcast, 0xff, ETH_ALEN);
 	dev->addr_len = ETH_ALEN;
 
 	ether_setup(dev);
 	dev->netdev_ops = &bnep_netdev_ops;
 
 	dev->watchdog_timeo  = HZ * 2;
}
","void bnep_net_setup(struct net_device *node)
{

	memset(node->broadcast, 0xff, ETH_ALEN);
 	node->addr_len = ETH_ALEN;
 
 	ether_setup(node);
 	node->netdev_ops = &bnep_netdev_ops;
 
 	node->watchdog_timeo  = HZ * 2;
}
",47.0,13.0,"dev:node,",69.0,0.0359335780143737,Greedy
734,"static int cine_read_probe(AVProbeData *p)
{
    int HeaderSize;
    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type
        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize
        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression
        AV_RL16(p->buf + 6) <= 1 &&              // Version
        AV_RL32(p->buf + 20) &&                  // ImageCount
        AV_RL32(p->buf + 24) >= HeaderSize &&    // OffImageHeader
        AV_RL32(p->buf + 28) >= HeaderSize &&    // OffSetup
        AV_RL32(p->buf + 32) >= HeaderSize)      // OffImageOffsets
        return AVPROBE_SCORE_MAX;
    return 0;
}
","static int cine_read_probe(AVProbeData *p)
{
    int HeaderLen;
    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type
        (HeaderLen = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize
        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression
        AV_RL16(p->buf + 6) <= 1 &&              // Version
        AV_RL32(p->buf + 20) &&                  // ImageCount
        AV_RL32(p->buf + 24) >= HeaderLen &&    // OffImageHeader
        AV_RL32(p->buf + 28) >= HeaderLen &&    // OffSetup
        AV_RL32(p->buf + 32) >= HeaderLen)      // OffImageOffsets
        return AVPROBE_SCORE_MAX;
    return 0;
}
",120.0,25.0,"HeaderSize:HeaderLen,",58.0,0.0427764773368835,Greedy
738,"void SafeBrowsingBlockingPageV2::PopulateStringDictionary(
    DictionaryValue* strings,
    const string16& title,
    const string16& headline,
    const string16& description1,
    const string16& description2,
    const string16& description3) {
  strings->SetString(""title"", title);
  strings->SetString(""headLine"", headline);
  strings->SetString(""description1"", description1);
  strings->SetString(""description2"", description2);
  strings->SetString(""description3"", description3);
  strings->SetBoolean(""proceedDisabled"",
                      IsPrefEnabled(prefs::kSafeBrowsingProceedAnywayDisabled));
  strings->SetBoolean(""isMainFrame"", is_main_frame_load_blocked_);
  strings->SetBoolean(""isPhishing"", interstitial_type_ == TYPE_PHISHING);

  strings->SetString(""back_button"",
      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_BACK_BUTTON));
  strings->SetString(""seeMore"", l10n_util::GetStringUTF16(
      IDS_SAFE_BROWSING_MALWARE_V2_SEE_MORE));
  strings->SetString(""proceed"",
      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));

  URLDataSource::SetFontAndTextDirection(strings);
}
","void SafeBrowsingBlockingPageV2::PopulateStringDictionary(
    DictionaryValue* strings,
    const string16& title,
    const string16& headline,
    const string16& description1,
    const string16& desc02,
    const string16& description3) {
  strings->SetString(""title"", title);
  strings->SetString(""headLine"", headline);
  strings->SetString(""description1"", description1);
  strings->SetString(""description2"", desc02);
  strings->SetString(""description3"", description3);
  strings->SetBoolean(""proceedDisabled"",
                      IsPrefEnabled(prefs::kSafeBrowsingProceedAnywayDisabled));
  strings->SetBoolean(""isMainFrame"", is_main_frame_load_blocked_);
  strings->SetBoolean(""isPhishing"", interstitial_type_ == TYPE_PHISHING);

  strings->SetString(""back_button"",
      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_BACK_BUTTON));
  strings->SetString(""seeMore"", l10n_util::GetStringUTF16(
      IDS_SAFE_BROWSING_MALWARE_V2_SEE_MORE));
  strings->SetString(""proceed"",
      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));

  URLDataSource::SetFontAndTextDirection(strings);
}
",175.0,36.0,"description2:desc02,",48.0,0.0331708669662475,Greedy
743,"PHP_FUNCTION(time_nanosleep)
{
	long tv_sec, tv_nsec;
	struct timespec php_req, php_rem;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ll"", &tv_sec, &tv_nsec) == FAILURE) {
		return;
	}

	if (tv_sec < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The seconds value must be greater than 0"");
		RETURN_FALSE;
	}
	if (tv_nsec < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The nanoseconds value must be greater than 0"");
		RETURN_FALSE;
	}

	php_req.tv_sec = (time_t) tv_sec;
	php_req.tv_nsec = tv_nsec;
	if (!nanosleep(&php_req, &php_rem)) {
		RETURN_TRUE;
	} else if (errno == EINTR) {
		array_init(return_value);
		add_assoc_long_ex(return_value, ""seconds"", sizeof(""seconds""), php_rem.tv_sec);
		add_assoc_long_ex(return_value, ""nanoseconds"", sizeof(""nanoseconds""), php_rem.tv_nsec);
		return;
	} else if (errno == EINVAL) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""nanoseconds was not in the range 0 to 999 999 999 or seconds was negative"");
	}

	RETURN_FALSE;
}
","PHP_FUNCTION(time_nanosleep)
{
	long tv_sec, tv_nsec;
	struct timespec php_req, phplexreg;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ll"", &tv_sec, &tv_nsec) == FAILURE) {
		return;
	}

	if (tv_sec < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The seconds value must be greater than 0"");
		RETURN_FALSE;
	}
	if (tv_nsec < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The nanoseconds value must be greater than 0"");
		RETURN_FALSE;
	}

	php_req.tv_sec = (time_t) tv_sec;
	php_req.tv_nsec = tv_nsec;
	if (!nanosleep(&php_req, &phplexreg)) {
		RETURN_TRUE;
	} else if (errno == EINTR) {
		array_init(return_value);
		add_assoc_long_ex(return_value, ""seconds"", sizeof(""seconds""), phplexreg.tv_sec);
		add_assoc_long_ex(return_value, ""nanoseconds"", sizeof(""nanoseconds""), phplexreg.tv_nsec);
		return;
	} else if (errno == EINVAL) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""nanoseconds was not in the range 0 to 999 999 999 or seconds was negative"");
	}

	RETURN_FALSE;
}
",189.0,45.0,"php_rem:phplexreg,",58.0,0.0386550863583882,Greedy
744,"MagickExport void *DetachBlob(BlobInfo *blob_info)
{
  void
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  blob_info->custom_stream=(CustomStreamInfo *) NULL;
  return(data);
}
","MagickExport void *DetachBlob(BlobInfo *bloofinf)
{
  void
    *next;

  assert(bloofinf != (BlobInfo *) NULL);
  if (bloofinf->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (bloofinf->mapped != MagickFalse)
     {
       (void) UnmapBlob(bloofinf->next,bloofinf->length);
       RelinquishMagickResource(MapResource,bloofinf->length);
     }
   bloofinf->mapped=MagickFalse;
  bloofinf->length=0;
  bloofinf->offset=0;
  bloofinf->eof=MagickFalse;
  bloofinf->error=0;
  bloofinf->exempt=MagickFalse;
  bloofinf->type=UndefinedStream;
  bloofinf->file_info.file=(FILE *) NULL;
  next=bloofinf->next;
  bloofinf->next=(unsigned char *) NULL;
  bloofinf->stream=(StreamHandler) NULL;
  bloofinf->custom_stream=(CustomStreamInfo *) NULL;
  return(next);
}
",177.0,37.0,"blob_info:bloofinf,data:next,",270.0,0.1328881343205769,Greedy
757,"bool WebstoreStandaloneInstaller::EnsureUniqueInstall(
    webstore_install::Result* reason,
    std::string* error) {
  InstallTracker* tracker = InstallTracker::Get(profile_);
  DCHECK(tracker);

  const ActiveInstallData* existing_install_data =
       tracker->GetActiveInstall(id_);
   if (existing_install_data) {
     *reason = webstore_install::INSTALL_IN_PROGRESS;
    *error = kInstallInProgressError;
     return false;
   }
 
  ActiveInstallData install_data(id_);
  InitInstallData(&install_data);
  scoped_active_install_.reset(new ScopedActiveInstall(tracker, install_data));
  return true;
}
","bool WebstoreStandaloneInstaller::EnsureUniqueInstall(
    webstore_install::Result* force,
    std::string* danger) {
  InstallTracker* trader = InstallTracker::Get(profile_);
  DCHECK(trader);

  const ActiveInstallData* existing_install_data =
       trader->GetActiveInstall(id_);
   if (existing_install_data) {
     *force = webstore_install::INSTALL_IN_PROGRESS;
    *danger = kInstallInProgressError;
     return false;
   }
 
  ActiveInstallData install_data(id_);
  InitInstallData(&install_data);
  scoped_active_install_.reset(new ScopedActiveInstall(trader, install_data));
  return true;
}
",96.0,22.0,"error:danger,tracker:trader,reason:force,",139.0,0.082578710714976,Greedy
759,"int perf_event_refresh(struct perf_event *event, int refresh)
{
	/*
	 * not supported on inherited events
	 */
	if (event->attr.inherit || !is_sampling_event(event))
		return -EINVAL;

	atomic_add(refresh, &event->event_limit);
	perf_event_enable(event);

	return 0;
}
","int perf_event_refresh(struct perf_event *data, int preend)
{
	/*
	 * not supported on inherited events
	 */
	if (data->attr.inherit || !is_sampling_event(data))
		return -EINVAL;

	atomic_add(preend, &data->event_limit);
	perf_event_enable(data);

	return 0;
}
",49.0,12.0,"event:data,refresh:preend,",92.0,0.0526312907536824,Greedy
760,"static u16 b43_dmacontroller_base(enum b43_dmatype type, int controller_idx)
{
	static const u16 map64[] = {
		B43_MMIO_DMA64_BASE0,
		B43_MMIO_DMA64_BASE1,
		B43_MMIO_DMA64_BASE2,
		B43_MMIO_DMA64_BASE3,
		B43_MMIO_DMA64_BASE4,
		B43_MMIO_DMA64_BASE5,
	};
	static const u16 map32[] = {
		B43_MMIO_DMA32_BASE0,
		B43_MMIO_DMA32_BASE1,
		B43_MMIO_DMA32_BASE2,
		B43_MMIO_DMA32_BASE3,
		B43_MMIO_DMA32_BASE4,
		B43_MMIO_DMA32_BASE5,
	};

	if (type == B43_DMA_64BIT) {
		B43_WARN_ON(!(controller_idx >= 0 &&
			      controller_idx < ARRAY_SIZE(map64)));
		return map64[controller_idx];
	}
	B43_WARN_ON(!(controller_idx >= 0 &&
		      controller_idx < ARRAY_SIZE(map32)));
	return map32[controller_idx];
}
","static u16 b43_dmacontroller_base(enum b43_dmatype type, int controller_baseno)
{
	static const u16 data16[] = {
		B43_MMIO_DMA64_BASE0,
		B43_MMIO_DMA64_BASE1,
		B43_MMIO_DMA64_BASE2,
		B43_MMIO_DMA64_BASE3,
		B43_MMIO_DMA64_BASE4,
		B43_MMIO_DMA64_BASE5,
	};
	static const u16 Map8[] = {
		B43_MMIO_DMA32_BASE0,
		B43_MMIO_DMA32_BASE1,
		B43_MMIO_DMA32_BASE2,
		B43_MMIO_DMA32_BASE3,
		B43_MMIO_DMA32_BASE4,
		B43_MMIO_DMA32_BASE5,
	};

	if (type == B43_DMA_64BIT) {
		B43_WARN_ON(!(controller_baseno >= 0 &&
			      controller_baseno < ARRAY_SIZE(data16)));
		return data16[controller_baseno];
	}
	B43_WARN_ON(!(controller_baseno >= 0 &&
		      controller_baseno < ARRAY_SIZE(Map8)));
	return Map8[controller_baseno];
}
",111.0,33.0,"controller_idx:controller_baseno,map32:Map8,map64:data16,",150.0,0.0914775252342224,Greedy
761,"void SyncBackendHost::Core::RouteJsEvent(
    const std::string& name, const JsEventDetails& details) {
  host_->frontend_loop_->PostTask(
      FROM_HERE, NewRunnableMethod(
          this, &Core::RouteJsEventOnFrontendLoop, name, details));
}
","void SyncBackendHost::Core::RouteJsEvent(
    const std::string& data, const JsEventDetails& details) {
  host_->frontend_loop_->PostTask(
      FROM_HERE, NewRunnableMethod(
          this, &Core::RouteJsEventOnFrontendLoop, data, details));
}
",44.0,9.0,"name:data,",43.0,0.0319707512855529,Greedy
776,"long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
		unsigned long start, unsigned long nr_pages,
		int write, int force, struct page **pages,
		struct vm_area_struct **vmas)
{
	return __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,
				       pages, vmas, NULL, false,
				       FOLL_TOUCH | FOLL_REMOTE);
}
","long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mn,
		unsigned long start, unsigned long nr_devices,
		int write, int force, struct page **data,
		struct vm_area_struct **lvphas)
{
	return __get_user_pages_locked(tsk, mn, start, nr_devices, write, force,
				       data, lvphas, NULL, false,
				       FOLL_TOUCH | FOLL_REMOTE);
}
",69.0,20.0,"vmas:lvphas,nr_pages:nr_devices,pages:data,mm:mn,",137.0,0.0740304946899414,Greedy
778," static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int *rsize)
 {
	if (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {
 		hid_info(hdev, ""fixing up Cherry Cymotion report descriptor\n"");
 		rdesc[11] = rdesc[16] = 0xff;
 		rdesc[12] = rdesc[17] = 0x03;
	}
	return rdesc;
}
"," static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int *rizer)
 {
	if (*rizer >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {
 		hid_info(hdev, ""fixing up Cherry Cymotion report descriptor\n"");
 		rdesc[11] = rdesc[16] = 0xff;
 		rdesc[12] = rdesc[17] = 0x03;
	}
	return rdesc;
}
",80.0,14.0,"rsize:rizer,",41.0,0.0289275964101155,Greedy
784,"static int sysMapFD(int fd, MemMapping* pMap)
{
 off_t start;
 size_t length;
 void* memPtr;

    assert(pMap != NULL);

 if (getFileStartAndLength(fd, &start, &length) < 0)
 return -1;

    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);
 if (memPtr == MAP_FAILED) {
        LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) length,
            fd, (int) start, strerror(errno));
 return -1;
 }

    pMap->addr = memPtr;

     pMap->length = length;
     pMap->range_count = 1;
     pMap->ranges = malloc(sizeof(MappedRange));
     pMap->ranges[0].addr = memPtr;
     pMap->ranges[0].length = length;
 
 return 0;
}
","static int sysMapFD(int ind, MemMapping* PTable)
{
 off_t ind;
 size_t show;
 void* memAddress;

    assert(PTable != NULL);

 if (getFileStartAndLength(ind, &ind, &show) < 0)
 return -1;

 memAddressPtr = mmap(NULL,showh, PROT_READ, MAP_PRIVATE, ind, ind);
 if (memAddress == MAP_FAILED) {
        LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s
"", (int) show,
            ind, (int) ind, strerror(errno));
 return -1;
 }

    PTable->addr = memAddress;

     PTable->show = show;
     PTable->range_count = 1;
     PTable->ranges = malloc(sizeof(MappedRange));
     PTable->ranges[0].addr = memAddress;
     PTable->ranges[0].show = show;
 
 return 0;
}
",155.0,39.0,"fd:ind,pMap:PTable,start:ind,length:show,memPtr:memAddress,",392.0,0.2010223507881164,GA
786,"void WorkerProcessLauncher::Core::Send(IPC::Message* message) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  if (ipc_enabled_) {
    launcher_delegate_->Send(message);
  } else {
    delete message;
  }
}
","void WorkerProcessLauncher::Core::Send(IPC::Message* parent) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  if (ipc_enabled_) {
    launcher_delegate_->Send(parent);
  } else {
    delete parent;
  }
}
",43.0,8.0,"message:parent,",51.0,0.0383033672968546,Greedy
789,"static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -EFAULT;
	return proc_control(ps, p);
}
","static int proc_control_compat(struct usb_dev_state *e,
				struct usbdevfs_ctrltransfer32 __user *fp2)
{
	struct usbdevfs_ctrltransfer __user *data;
	__u32 ubatum;
	data = compat_alloc_user_space(sizeof(*data));
	if (copy_in_user(data, fp2, (sizeof(*fp2) - sizeof(compat_caddr_t))) ||
	    get_user(ubatum, &fp2->data) ||
	    put_user(compat_ptr(ubatum), &data->data))
		return -EFAULT;
	return proc_control(e, data);
}
",94.0,26.0,"udata:ubatum,p:data,p32:fp2,ps:e,",185.0,0.1200857837994893,Greedy
790,"analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,
	      unsigned long **stack_end, unsigned long *irq_stack,
	      unsigned *used, char **id)
{
	unsigned long addr;

	addr = ((unsigned long)stack & (~(THREAD_SIZE - 1)));
	if ((unsigned long)task_stack_page(task) == addr)
		return STACK_IS_NORMAL;

	*stack_end = in_exception_stack(cpu, (unsigned long)stack,
					used, id);
	if (*stack_end)
		return STACK_IS_EXCEPTION;

	if (!irq_stack)
		return STACK_IS_NORMAL;

	*stack_end = irq_stack;
	irq_stack = irq_stack - irq_stack_size;

	if (in_irq_stack(stack, irq_stack, *stack_end))
		return STACK_IS_IRQ;

	return STACK_IS_UNKNOWN;
}
","analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,
	      unsigned long **stack_end, unsigned long *irq_stack,
	      unsigned *used, char **id)
{
	unsigned long data;

	data = ((unsigned long)stack & (~(THREAD_SIZE - 1)));
	if ((unsigned long)task_stack_page(task) == data)
		return STACK_IS_NORMAL;

	*stack_end = in_exception_stack(cpu, (unsigned long)stack,
					used, id);
	if (*stack_end)
		return STACK_IS_EXCEPTION;

	if (!irq_stack)
		return STACK_IS_NORMAL;

	*stack_end = irq_stack;
	irq_stack = irq_stack - irq_stack_size;

	if (in_irq_stack(stack, irq_stack, *stack_end))
		return STACK_IS_IRQ;

	return STACK_IS_UNKNOWN;
}
",139.0,37.0,"addr:data,",75.0,0.0544021050135294,Greedy
802,"static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         f->stream = f->stream_end;
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->f_start;
   }
   if (!fseek(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}
","static int set_file_offset(stb_vorbis *e, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (e->push_mode) return 0;
   #endif
   e->eof = 0;
   if (USE_MEMORY(e)) {
      if (e->stream_start + loc >= e->stream_end || e->stream_start + loc < e->stream_start) {
         e->stream = e->stream_end;
         e->eof = 1;
         return 0;
      } else {
         e->stream = e->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + e->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      e->eof = 1;
   } else {
      loc += e->f_start;
   }
   if (!fseek(e->e, loc, SEEK_SET))
      return 1;
   e->eof = 1;
   fseek(e->e, e->f_start, SEEK_END);
   return 0;
   #endif
}
",176.0,38.0,"f:e,",111.0,0.0650561292966206,Greedy
812,"void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& result, Element* element, const Attribute& attribute, Namespaces* namespaces)
{
    if (m_replaceLinks && element->isURLAttribute(attribute) && !element->isJavaScriptURLAttribute(attribute)) {
        String completeURL = m_document->completeURL(attribute.value());
        if (m_replaceLinks->contains(completeURL)) {
            result.append(' ');
            result.append(attribute.name().toString());
            result.appendLiteral(""=\"""");
            if (!m_directoryName.isEmpty()) {
                result.appendLiteral(""./"");
                result.append(m_directoryName);
                result.append('/');
            }
            result.append(m_replaceLinks->get(completeURL));
            result.appendLiteral(""\"""");
            return;
        }
    }
    MarkupAccumulator::appendAttribute(result, element, attribute, namespaces);
}
","void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& message, Element* element, const Attribute& feature, Namespaces* namespaces)
{
    if (m_replaceLinks && element->isURLAttribute(feature) && !element->isJavaScriptURLAttribute(feature)) {
        String completeURL = m_document->completeURL(feature.value());
        if (m_replaceLinks->contains(completeURL)) {
            message.append(' ');
            message.append(feature.name().toString());
            message.appendLiteral(""=\"""");
            if (!m_directoryName.isEmpty()) {
                message.appendLiteral(""./"");
                message.append(m_directoryName);
                message.append('/');
            }
            message.append(m_replaceLinks->get(completeURL));
            message.appendLiteral(""\"""");
            return;
        }
    }
    MarkupAccumulator::appendAttribute(message, element, feature, namespaces);
}
",172.0,33.0,"attribute:feature,result:message,",150.0,0.0938820242881774,Greedy
813,"static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,
			    int *addr_len, int peer)
{
	struct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;
	struct sock *sk = sock->sk;
	struct hci_dev *hdev = hci_pi(sk)->hdev;

	BT_DBG(""sock %p sk %p"", sock, sk);

	if (!hdev)
		return -EBADFD;

	lock_sock(sk);

 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
 
 	release_sock(sk);
 	return 0;
}
","static int hci_sock_getname(struct socket * sdk, struct sockaddr *addr,
			    int *addr_len, int  padding)
{
	struct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;
	struct  sdk *sk =  sdk->sk;
	struct hci_dev *hdev = hci_pi(sk)->hdev;

	BT_DBG(""sock %p sk %p"",  sdk, sk);

	if (!hdev)
		return -EBADFD;

	lock_sock(sk);

 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
 
 	release_sock(sk);
 	return 0;
}
",111.0,27.0,"sock: sdk,peer: padding,",91.0,0.0571612874666849,Greedy
815,"static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;

	if (!enabled_nat_bits(sbi, NULL))
		return;

	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}

	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}
","static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nID,
						struct page *page)
{
	struct f2fs_nm_info *ny_i = NM_I(sbi);
	unsigned int nat_index = start_nID / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;

	if (!enabled_nat_bits(sbi, NULL))
		return;

	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nID == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(nat_index, ny_i->empty_nat_bits);
		__clear_bit_le(nat_index, ny_i->full_nat_bits);
		return;
	}

	__clear_bit_le(nat_index, ny_i->empty_nat_bits);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, ny_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, ny_i->full_nat_bits);
}
",171.0,45.0,"start_nid:start_nID,nm_i:ny_i,",133.0,0.0847953875859578,Greedy
820,"bool SendNativeKeyEventJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    ui::KeyboardCode key_code,
    int modifiers,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""SendOSLevelKeyEventToTab"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  dict.SetInteger(""keyCode"", key_code);
  dict.SetInteger(""modifiers"", modifiers);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}
","bool SendNativeKeyEventJSONRequest(
    AutomationMessageSender* sender,
    int  browser_path,
    int Tab_id,
    ui::KeyboardCode Key_code,
    int Models,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""SendOSLevelKeyEventToTab"");
  dict.SetInteger(""windex"",  browser_path);
  dict.SetInteger(""tab_index"", Tab_id);
  dict.SetInteger(""keyCode"", Key_code);
  dict.SetInteger(""modifiers"", Models);
  DictionaryValue replyingict;
  return SendAutomationJSONRequest(sender, dict, &replyingict, error_msg);
}
",99.0,23.0,"browser_index: browser_path,tab_index:Tab_id,reply_dict:replyingict,modifiers:Models,key_code:Key_code,",135.0,0.0801729162534077,Greedy
823,"void MediaStreamManager::Aborted(MediaStreamType stream_type,
                                 int capture_session_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DVLOG(1) << ""Aborted({stream_type = "" << stream_type << ""} ""
           << ""{capture_session_id = "" << capture_session_id << ""})"";
  StopDevice(stream_type, capture_session_id);
}
","void MediaStreamManager::Aborted(MediaStreamType stream_type,
                                 int capture_session_ident) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DVLOG(1) << ""Aborted({stream_type = "" << stream_type << ""} ""
           << ""{capture_session_id = "" << capture_session_ident << ""})"";
  StopDevice(stream_type, capture_session_ident);
}
",48.0,11.0,"capture_session_id:capture_session_ident,",46.0,0.0336963574091593,Greedy
837,"void DevToolsWindow::Inspect(scoped_refptr<content::DevToolsAgentHost> host) {
  DevToolsWindow::OpenDevToolsWindow(host, profile_);
}
","void DevToolsWindow::Inspect(scoped_refptr<content::DevToolsAgentHost> localhost) {
  DevToolsWindow::OpenDevToolsWindow(localhost, profile_);
}
",24.0,5.0,"host:localhost,",43.0,0.034602415561676,Greedy
843,"static int devicenrange(i_ctx_t * i_ctx_p, ref *space, float *ptr)
{
    int i, limit, code;
    PS_colour_space_t *cspace;

    ref altspace;

    code = array_get(imemory, space, 1, &altspace);
    if (code < 0)
        return code;

    code = get_space_object(i_ctx_p, &altspace, &cspace);
    if (code < 0)
        return code;

    code = cspace->numcomponents(i_ctx_p, &altspace, &limit);
    if (code < 0)
        return code;

    for (i = 0;i < limit * 2;i+=2) {
        ptr[i] = 0;
        ptr[i+1] = 1;
    }
    return 0;
}
","static int devicenrange(i_ctx_t * i_ctx_p, ref *space, float *alloc)
{
    int i, limit, ode;
    PS_colour_space_t *cspace;

    ref altesp;

    ode = array_get(imemory, space, 1, &altesp);
    if (ode < 0)
        return ode;

    ode = get_space_object(i_ctx_p, &altesp, &cspace);
    if (ode < 0)
        return ode;

    ode = cspace->numcomponents(i_ctx_p, &altesp, &limit);
    if (ode < 0)
        return ode;

    for (i = 0;i < limit * 2;i+=2) {
        alloc[i] = 0;
        alloc[i+1] = 1;
    }
    return 0;
}
",138.0,38.0,"code:ode,ptr:alloc,altspace:altesp,",230.0,0.1349067727724711,Greedy
846,"xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    SKIP_BLANKS;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, strict;
	int op1 = ctxt->comp->last;

        if (CUR == '<') inf = 1;
	else inf = 0;
	if (NXT(1) == '=') strict = 0;
	else strict = 1;
	NEXT;
	if (!strict) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);
	SKIP_BLANKS;
    }
}
","xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    SKIP_BLANKS;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, stress;
	int op1 = ctxt->comp->last;

        if (CUR == '<') inf = 1;
	else inf = 0;
	if (NXT(1) == '=') stress = 0;
	else stress = 1;
	NEXT;
	if (!stress) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, stress);
	SKIP_BLANKS;
    }
}
",158.0,36.0,"strict:stress,",59.0,0.0435265739758809,Greedy
851," bool GesturePoint::IsSecondClickInsideManhattanSquare(
     const TouchEvent& event) const {
   int manhattanDistance = abs(event.x() - last_tap_position_.x()) +
                           abs(event.y() - last_tap_position_.y());
  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;
 }
"," bool GesturePoint::IsSecondClickInsideManhattanSquare(
     const TouchEvent& ce) const {
   int manhattanDistance = abs(ce.x() - last_tap_position_.x()) +
                           abs(ce.y() - last_tap_position_.y());
  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;
 }
",51.0,11.0,"event:ce,",52.0,0.0412060459454854,Greedy
852,"static void didFinishLoadForFrame(WKPageRef page, WKFrameRef frame, WKTypeRef userData, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;

    webkitWebViewLoadChanged(WEBKIT_WEB_VIEW(clientInfo), WEBKIT_LOAD_FINISHED);
}
","static void didFinishLoadForFrame(WKPageRef object, WKFrameRef iframe, WKTypeRef rawdata, const void*  clientId)
{
    if (!WKFrameIsMainFrame(iframe))
        return;

    webkitWebViewLoadChanged(WEBKIT_WEB_VIEW( clientId), WEBKIT_LOAD_FINISHED);
}
",40.0,11.0,"clientInfo: clientId,page:object,frame:iframe,userData:rawdata,",110.0,0.0751190344492594,Greedy
862,"static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
 
	assert(bufsize >= 0);
 
	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", m, bufsize));
 	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
 	  bufsize) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}
","static int mem_resize(jas_stream_memobj_t *mac, int buffSize)
 {
 	unsigned char *cmd;
 
	assert(buffSize >= 0);
 
	JAS_DBGLOG(100, (""mem_resize(%p, %d)
"", mac, buffSize));
 	if (!(bufcmdjas_realloc2(mac->buf_, buffSize, sizeof(unsigned char))) &&
 	  buffSize) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed
""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded
""));
	mac->buf_ = cmd;
	mac->bufsize_ = buffSize;
	return 0;
}
",106.0,20.0,"m:mac,bufsize:buffSize,buf:cmd,",286.0,0.1954858740170796,GA
881,"void ContainerNode::setFocus(bool received)
{
    if (ShadowRoot* root = containingShadowRoot()) {
        if (root->type() != ShadowRootType::UserAgent)
            shadowHost()->setFocus(received);
    }

    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {
        if (toElement(this)->authorShadowRoot())
            received = received && toElement(this)->authorShadowRoot()->delegatesFocus();
    }

    if (focused() == received)
        return;

    Node::setFocus(received);

    focusStateChanged();

    if (layoutObject() || received)
        return;

    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)
        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));
    else
        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));
}
","void ContainerNode::setFocus(bool false)
{
    if (ShadowRoot* root = containingShadowRoot()) {
        if (root->type() != ShadowRootType::UserAgent)
            shadowHost()->setFocus(false);
    }

    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {
        if (toElement(this)->authorShadowRoot())
            false = false && toElement(this)->authorShadowRoot()->delegatesFocus();
    }

    if (focused() == false)
        return;

    Node::setFocus(false);

    focusStateChanged();

    if (layoutObject() || false)
        return;

    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)
        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));
    else
        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));
}
",189.0,34.0,"received:false,",87.0,0.048379647731781,Greedy
885,"static void checkListProperties(sqlite3 *db){
  sqlite3 *p;
  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){
    int seen = 0;
    sqlite3 *p2;

    /* Verify property (1) */
    assert( p->pUnlockConnection || p->pBlockingConnection );

    /* Verify property (2) */
    for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){
      if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;
      assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );
      assert( db==0 || p->pUnlockConnection!=db );
      assert( db==0 || p->pBlockingConnection!=db );
    }
  }
}
","static void checkListProperties(sqlite3 *sb){
  sqlite3 *parent;
  for(parent=sqlite3BlockedList; parent; parent=parent->pNextBlocked){
    int seen = 0;
    sqlite3 * psecond;

    /* Verify property (1) */
    assert( parent->pUnlockConnection || parent->pBlockingConnection );

    /* Verify property (2) */
    for( psecond=sqlite3BlockedList;  psecond!=parent;  psecond= psecond->pNextBlocked){
      if(  psecond->xUnlockNotify==parent->xUnlockNotify ) seen = 1;
      assert(  psecond->xUnlockNotify==parent->xUnlockNotify || !seen );
      assert( sb==0 || parent->pUnlockConnection!=sb );
      assert( sb==0 || parent->pBlockingConnection!=sb );
    }
  }
}
",122.0,34.0,"p:parent,p2: psecond,db:sb,",217.0,0.1249710798263549,Greedy
887," static void DeleteImpl(Handle<JSObject> obj, uint32_t entry) {
 Handle<SeededNumberDictionary> dict(
 SeededNumberDictionary::cast(obj->elements()));
 uint32_t index = GetIndexForEntryImpl(*dict, entry);
 Handle<Object> result = SeededNumberDictionary::DeleteProperty(dict, entry);
    USE(result);
    DCHECK(result->IsTrue(dict->GetIsolate()));
 Handle<FixedArray> new_elements =
 SeededNumberDictionary::Shrink(dict, index);
    obj->set_elements(*new_elements);
 }
"," static void DeleteImpl(Handle<JSObject> obj, uint32_t parent) {
 Handle<SeededNumberDictionary> dict(
 SeededNumberDictionary::cast(obj->elements()));
 uint32_t index = GetIndexForEntryImpl(*dict, parent);
 Handle<Object> result = SeededNumberDictionary::DeleteProperty(dict, parent);
    USE(result);
    DCHECK(result->IsTrue(dict->GetIsolate()));
 Handle<FixedArray> new_elements =
 SeededNumberDictionary::Shrink(dict, index);
    obj->set_elements(*new_elements);
 }
",101.0,25.0,"entry:parent,",63.0,0.0404078960418701,Greedy
907,"bool RenderFrameHostManager::IsRendererTransferNeededForNavigation(
    RenderFrameHostImpl* rfh,
    const GURL& dest_url) {
  if (!rfh->GetSiteInstance()->HasSite())
    return false;

  if (rfh->GetSiteInstance()->GetSiteURL().SchemeIs(kGuestScheme))
    return false;

  BrowserContext* context = rfh->GetSiteInstance()->GetBrowserContext();
  if (IsCurrentlySameSite(rfh, dest_url)) {
    return false;
  }

  if (rfh->GetSiteInstance()->RequiresDedicatedProcess() ||
      SiteInstanceImpl::DoesSiteRequireDedicatedProcess(context,
                                                        dest_url)) {
    return true;
  }

  if (SiteIsolationPolicy::IsTopDocumentIsolationEnabled() &&
      (!frame_tree_node_->IsMainFrame() ||
       rfh->GetSiteInstance()->IsDefaultSubframeSiteInstance())) {
    return true;
  }

  return false;
}
","bool RenderFrameHostManager::IsRendererTransferNeededForNavigation(
    RenderFrameHostImpl* rfh,
    const GURL& dest_url) {
  if (!rfh->GetSiteInstance()->HasSite())
    return false;

  if (rfh->GetSiteInstance()->GetSiteURL().SchemeIs(kGuestScheme))
    return false;

  BrowserContext* style = rfh->GetSiteInstance()->GetBrowserContext();
  if (IsCurrentlySameSite(rfh, dest_url)) {
    return false;
  }

  if (rfh->GetSiteInstance()->RequiresDedicatedProcess() ||
      SiteInstanceImpl::DoesSiteRequireDedicatedProcess(style,
                                                        dest_url)) {
    return true;
  }

  if (SiteIsolationPolicy::IsTopDocumentIsolationEnabled() &&
      (!frame_tree_node_->IsMainFrame() ||
       rfh->GetSiteInstance()->IsDefaultSubframeSiteInstance())) {
    return true;
  }

  return false;
}
",141.0,18.0,"context:style,",56.0,0.0425302823384602,Greedy
908," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 
 	g_string_free(str, TRUE);
 }
"," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *arr = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(arr, filter);
 
 	g_string_append_printf(arr, ""}\n"");
	g_file_set_contents(""/tmp/rs-filter-graph"", arr->arr, arr->len, NULL);
 
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 
 	g_string_free(arr, TRUE);
 }
",98.0,21.0,"str:arr,",68.0,0.0458025455474853,Greedy
909,"R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}
","R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *size) {
	if (!f || !item || !size || !*size) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, size, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->size);
	if (!set_name (item, size)) {
		return false;
	}
	ht_insert (f->ht_name, item->size, item);
#endif
	return true;
}
",121.0,31.0,"name:size,",86.0,0.0416362961133321,Greedy
913,"MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_authentic_pixels_from_handler !=
       (GetAuthenticPixelsFromHandler) NULL)
    return(cache_info->methods.get_authentic_pixels_from_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(cache_info->nexus_info[id]->pixels);
}
","MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *images)
{
  CacheInfo
    *restrict cachedbinfo;

  const int
    id = GetOpenMPThreadId();

  assert(images != (const Image *) NULL);
  assert(images->signature == MagickSignature);
  assert(images->cache != (Cache) NULL);
  cachedbinfo=(CacheInfo *) images->cache;
  assert(cachedbinfo->signature == MagickSignature);
  if (cachedbinfo->methods.get_authentic_pixels_from_handler !=
       (GetAuthenticPixelsFromHandler) NULL)
    return(cachedbinfo->methods.get_authentic_pixels_from_handler(images));
  assert(id < (int) cachedbinfo->number_threads);
  return(cachedbinfo->nexus_info[id]->pixels);
}
",126.0,26.0,"cache_info:cachedbinfo,image:images,",163.0,0.1008862892786661,Greedy
916," static size_t safecat(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST char *cat)
 {
    while (pos < bufsize && cat != NULL && *cat != 0)
       buffer[pos++] = *cat++;

 if (pos >= bufsize)
      pos = bufsize-1;

   buffer[pos] = 0;
 return pos;
}
"," static size_t safecat(char *escape, size_t  bufmode, size_t pos,
   PNG_CONST char *cat)
 {
    while (pos <  bufmode && cat != NULL && *cat != 0)
       escape[pos++] = *cat++;

 if (pos >=  bufmode)
      pos =  bufmode-1;

   escape[pos] = 0;
 return pos;
}
",68.0,20.0,"bufsize: bufmode,buffer:escape,",91.0,0.0600342790285746,Greedy
928,"static int gdImageTileGet (gdImagePtr im, int x, int y)
{
	int srcx, srcy;
	int tileColor,p;
	if (!im->tile) {
		return -1;
	}
	srcx = x % gdImageSX(im->tile);
	srcy = y % gdImageSY(im->tile);
	p = gdImageGetPixel(im->tile, srcx, srcy);

	if (im->trueColor) {
		if (im->tile->trueColor) {
			tileColor = p;
		} else {
			tileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	} else {
		if (im->tile->trueColor) {
			tileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));
		} else {
			tileColor = p;
			tileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	}
	return tileColor;
}
","static int gdImageTileGet (gdImagePtr im, int x, int y)
{
	int srcx, srcy;
	int tokenLayer,p;
	if (!im->tile) {
		return -1;
	}
	srcx = x % gdImageSX(im->tile);
	srcy = y % gdImageSY(im->tile);
	p = gdImageGetPixel(im->tile, srcx, srcy);

	if (im->trueColor) {
		if (im->tile->trueColor) {
			tokenLayer = p;
		} else {
			tokenLayer = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	} else {
		if (im->tile->trueColor) {
			tokenLayer = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));
		} else {
			tokenLayer = p;
			tokenLayer = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	}
	return tokenLayer;
}
",231.0,70.0,"tileColor:tokenLayer,",132.0,0.0800876259803771,Greedy
934,"  parse_cmdline( int*     argc,
                 char***  argv )
  {
    char*  execname;
    int    option;


    execname = ft_basename( (*argv)[0] );

    while ( 1 )
    {
      option = getopt( *argc, *argv, ""e:m:r:"" );

      if ( option == -1 )
        break;

      switch ( option )
      {
      case 'e':
        status.encoding = FTDemo_Make_Encoding_Tag( optarg );
        break;

      case 'r':
        status.res = atoi( optarg );
        if ( status.res < 1 )
          usage( execname );
        break;

      case 'm':
        if ( *argc < 3 )
          usage( execname );
        Text = optarg;
        break;

      default:
        usage( execname );
        break;
      }
    }

    *argc -= optind;
    *argv += optind;

    if ( *argc <= 1 )
      usage( execname );

    status.ptsize = (int)(atof( *argv[0] ) * 64.0);
    if ( status.ptsize == 0 )
      status.ptsize = 64;

    (*argc)--;
    (*argv)++;
  }
","  parse_cmdline( int*      argl,
                 char***  argv )
  {
    char*  execname;
    int    option;


    execname = ft_basename( (*argv)[0] );

    while ( 1 )
    {
      option = getopt( * argl, *argv, ""e:m:r:"" );

      if ( option == -1 )
        break;

      switch ( option )
      {
      case 'e':
        status.encoding = FTDemo_Make_Encoding_Tag( optarg );
        break;

      case 'r':
        status.res = atoi( optarg );
        if ( status.res < 1 )
          usage( execname );
        break;

      case 'm':
        if ( * argl < 3 )
          usage( execname );
        Text = optarg;
        break;

      default:
        usage( execname );
        break;
      }
    }

    * argl -= optind;
    *argv += optind;

    if ( * argl <= 1 )
      usage( execname );

    status.ptsize = (int)(atof( *argv[0] ) * 64.0);
    if ( status.ptsize == 0 )
      status.ptsize = 64;

    (* argl)--;
    (*argv)++;
  }
",210.0,44.0,"argc: argl,",60.0,0.0407455722490946,Greedy
937,"int ldb_dn_set_component(struct ldb_dn *dn, int num,
			 const char *name, const struct ldb_val val)
{
	char *n;
	struct ldb_val v;

	if ( ! ldb_dn_validate(dn)) {
		return LDB_ERR_OTHER;
	}

	if (num >= dn->comp_num) {
		return LDB_ERR_OTHER;
	}

	n = talloc_strdup(dn, name);
	if ( ! n) {
		return LDB_ERR_OTHER;
	}

	v.length = val.length;
	v.data = (uint8_t *)talloc_memdup(dn, val.data, v.length+1);
	if ( ! v.data) {
		talloc_free(n);
		return LDB_ERR_OTHER;
	}

	talloc_free(dn->components[num].name);
	talloc_free(dn->components[num].value.data);
	dn->components[num].name = n;
	dn->components[num].value = v;

	if (dn->valid_case) {
		unsigned int i;
		for (i = 0; i < dn->comp_num; i++) {
			LDB_FREE(dn->components[i].cf_name);
			LDB_FREE(dn->components[i].cf_value.data);
		}
		dn->valid_case = false;
	}
	LDB_FREE(dn->casefold);
	LDB_FREE(dn->linearized);

	/* Wipe the ext_linearized DN,
	 * the GUID and SID are almost certainly no longer valid */
	LDB_FREE(dn->ext_linearized);
	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;

	return LDB_SUCCESS;
}
","int ldb_dn_set_component(struct ldb_dn *dn, int num,
			 const char *node, const struct ldb_val val)
{
	char *n;
	struct ldb_val v;

	if ( ! ldb_dn_validate(dn)) {
		return LDB_ERR_OTHER;
	}

	if (num >= dn->comp_num) {
		return LDB_ERR_OTHER;
	}

	n = talloc_strdup(dn, node);
	if ( ! n) {
		return LDB_ERR_OTHER;
	}

	v.length = val.length;
	v.data = (uint8_t *)talloc_memdup(dn, val.data, v.length+1);
	if ( ! v.data) {
		talloc_free(n);
		return LDB_ERR_OTHER;
	}

	talloc_free(dn->components[num].node);
	talloc_free(dn->components[num].value.data);
	dn->components[num].node = n;
	dn->components[num].value = v;

	if (dn->valid_case) {
		unsigned int i;
		for (i = 0; i < dn->comp_num; i++) {
			LDB_FREE(dn->components[i].cf_name);
			LDB_FREE(dn->components[i].cf_value.data);
		}
		dn->valid_case = false;
	}
	LDB_FREE(dn->casefold);
	LDB_FREE(dn->linearized);

	/* Wipe the ext_linearized DN,
	 * the GUID and SID are almost certainly no longer valid */
	LDB_FREE(dn->ext_linearized);
	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;

	return LDB_SUCCESS;
}
",270.0,65.0,"name:node,",108.0,0.0637192765871683,Greedy
944," void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)
 {
 }
"," void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* timeout, size_t length)
 {
 }
",15.0,3.0,"buffer:timeout,",31.0,0.0259795188903808,Greedy
950,"void RenderWidgetHostViewAura::ExtendSelectionAndDelete(
    size_t before, size_t after) {
  RenderFrameHostImpl* rfh = GetFocusedFrame();
  if (rfh)
    rfh->ExtendSelectionAndDelete(before, after);
}
","void RenderWidgetHostViewAura::ExtendSelectionAndDelete(
    size_t false, size_t data) {
  RenderFrameHostImpl* fhs = GetFocusedFrame();
  if (fhs)
    fhs->ExtendSelectionAndDelete(false, data);
}
",34.0,9.0,"before:false,after:data,rfh:fhs,",107.0,0.0681535561879475,Greedy
955,"int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;

	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);

	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;

	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);

	return ret;
}
","int __hid_register_driver(struct hid_driver *hirtev, struct module *owner,
		const char * mod_description)
{
	int ret;

	hirtev->driver.name = hirtev->name;
	hirtev->driver.bus = &hid_bus_type;
	hirtev->driver.owner = owner;
	hirtev->driver. mod_description =  mod_description;

	INIT_LIST_HEAD(&hirtev->dyn_list);
	spin_lock_init(&hirtev->dyn_lock);

	ret = driver_register(&hirtev->driver);
	if (ret)
		return ret;

	ret = driver_create_file(&hirtev->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hirtev->driver);

	return ret;
}
",119.0,30.0,"mod_name: mod_description,hdrv:hirtev,",269.0,0.14224560658137,Greedy
978,"static INLINE void check_resync(vpx_codec_alg_priv_t *const ctx,
 const VP9Decoder *const pbi) {
 if (ctx->need_resync == 1 && pbi->need_resync == 0 &&
 (pbi->common.intra_only || pbi->common.frame_type == KEY_FRAME))
    ctx->need_resync = 0;
}
","static INLINE void check_resync(vpx_codec_alg_priv_t *const fp,
 const VP9Decoder *const pbi) {
 if (fp->need_resync == 1 && pbi->need_resync == 0 &&
 (pbi->common.intra_only || pbi->common.frame_type == KEY_FRAME))
    fp->need_resync = 0;
}
",54.0,10.0,"ctx:fp,",63.0,0.0284329930941263,Greedy
982,"static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)
{
	unsigned char buf[2];
	unsigned char ibuf[2];

	tuner_dbg(""%s %04x called\n"", __func__, reg);

	buf[0] = reg >> 8;
	buf[1] = (unsigned char) reg;

	if (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)
		return -EIO;

	*val = (ibuf[1]) | (ibuf[0] << 8);
	return 0;
}
","static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *data)
{
	unsigned char buf[2];
	unsigned char ibraw[2];

	tuner_dbg(""%s %04x called\n"", __func__, reg);

	buf[0] = reg >> 8;
	buf[1] = (unsigned char) reg;

	if (i2c_send_recv(priv, buf, 2, ibraw, 2) != 2)
		return -EIO;

	*data = (ibraw[1]) | (ibraw[0] << 8);
	return 0;
}
",106.0,21.0,"val:data,ibuf:ibraw,",107.0,0.0601489384969075,Greedy
985,"static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}
","static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* intern = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = intern->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}
",188.0,49.0,"imp:intern,",62.0,0.0346024910608927,Greedy
986,"static int __follow_pte(struct mm_struct *mm, unsigned long address,
		pte_t **ptepp, spinlock_t **ptlp)
{
	pgd_t *pgd;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *ptep;

	pgd = pgd_offset(mm, address);
	if (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))
		goto out;

	pud = pud_offset(pgd, address);
	if (pud_none(*pud) || unlikely(pud_bad(*pud)))
		goto out;

	pmd = pmd_offset(pud, address);
	VM_BUG_ON(pmd_trans_huge(*pmd));
	if (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))
		goto out;

	/* We cannot handle huge page PFN maps. Luckily they don't exist. */
	if (pmd_huge(*pmd))
		goto out;

	ptep = pte_offset_map_lock(mm, pmd, address, ptlp);
	if (!ptep)
		goto out;
	if (!pte_present(*ptep))
		goto unlock;
	*ptepp = ptep;
	return 0;
unlock:
	pte_unmap_unlock(ptep, *ptlp);
out:
	return -EINVAL;
}
","static int __follow_pte(struct mm_struct *mm, unsigned long address,
		pte_t **ptepp, spinlock_t **ptlp)
{
	pgd_t *pgds;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *ptep;

	pgds = pgd_offset(mm, address);
	if (pgd_none(*pgds) || unlikely(pgd_bad(*pgds)))
		goto out;

	pud = pud_offset(pgds, address);
	if (pud_none(*pud) || unlikely(pud_bad(*pud)))
		goto out;

	pmd = pmd_offset(pud, address);
	VM_BUG_ON(pmd_trans_huge(*pmd));
	if (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))
		goto out;

	/* We cannot handle huge page PFN maps. Luckily they don't exist. */
	if (pmd_huge(*pmd))
		goto out;

	ptep = pte_offset_map_lock(mm, pmd, address, ptlp);
	if (!ptep)
		goto out;
	if (!pte_present(*ptep))
		goto unlock;
	*ptepp = ptep;
	return 0;
unlock:
	pte_unmap_unlock(ptep, *ptlp);
out:
	return -EINVAL;
}
",205.0,56.0,"pgd:pgds,",91.0,0.0530528783798217,Greedy
990,"static int find_hole(void)
{
   unsigned x;
   int      y, z;
   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {
       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {
          z = x;
          y = fp_cache[x].lru_count;
       }
   }

   /* decrease all */
   for (x = 0; x < FP_ENTRIES; x++) {
      if (fp_cache[x].lru_count > 3) {
         --(fp_cache[x].lru_count);
      }
   }

   /* free entry z */
   if (z >= 0 && fp_cache[z].g) {
      mp_clear(&fp_cache[z].mu);
      wc_ecc_del_point(fp_cache[z].g);
      fp_cache[z].g  = NULL;
      for (x = 0; x < (1U<<FP_LUT); x++) {
         wc_ecc_del_point(fp_cache[z].LUT[x]);
         fp_cache[z].LUT[x] = NULL;
      }
      fp_cache[z].lru_count = 0;
   }
   return z;
}
","static int find_hole(void)
{
   unsigned x;
   int      y, z;
   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {
       if (flowaccount[x].lru_count < y && flowaccount[x].lock == 0) {
          z = x;
          y = flowaccount[x].lru_count;
       }
   }

   /* decrease all */
   for (x = 0; x < FP_ENTRIES; x++) {
      if (flowaccount[x].lru_count > 3) {
         --(flowaccount[x].lru_count);
      }
   }

   /* free entry z */
   if (z >= 0 && flowaccount[z].g) {
      mp_clear(&flowaccount[z].mu);
      wc_ecc_del_point(flowaccount[z].g);
      flowaccount[z].g  = NULL;
      for (x = 0; x < (1U<<FP_LUT); x++) {
         wc_ecc_del_point(flowaccount[z].LUT[x]);
         flowaccount[z].LUT[x] = NULL;
      }
      flowaccount[z].lru_count = 0;
   }
   return z;
}
",213.0,54.0,"fp_cache:flowaccount,",186.0,0.1059092958768208,Greedy
1010,"static void emitnumber(JF, double num)
{
	if (num == 0) {
		emit(J, F, OP_NUMBER_0);
		if (signbit(num))
			emit(J, F, OP_NEG);
	} else if (num == 1) {
		emit(J, F, OP_NUMBER_1);
	} else if (num == (js_Instruction)num) {
		emit(J, F, OP_NUMBER_POS);
		emitraw(J, F, (js_Instruction)num);
	} else if (num < 0 && -num == (js_Instruction)(-num)) {
		emit(J, F, OP_NUMBER_NEG);
		emitraw(J, F, (js_Instruction)(-num));
	} else {
		emit(J, F, OP_NUMBER);
		emitraw(J, F, addnumber(J, F, num));
	}
}
","static void emitnumber(JF, double umi)
{
	if (umi == 0) {
		emit(J, F, OP_NUMBER_0);
		if (signbit(umi))
			emit(J, F, OP_NEG);
	} else if (umi == 1) {
		emit(J, F, OP_NUMBER_1);
	} else if (umi == (js_Instruction)umi) {
		emit(J, F, OP_NUMBER_POS);
		emitraw(J, F, (js_Instruction)umi);
	} else if (umi < 0 && -umi == (js_Instruction)(-umi)) {
		emit(J, F, OP_NUMBER_NEG);
		emitraw(J, F, (js_Instruction)(-umi));
	} else {
		emit(J, F, OP_NUMBER);
		emitraw(J, F, addnumber(J, F, umi));
	}
}
",167.0,52.0,"num:umi,",95.0,0.0562456885973612,Greedy
1015,"static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)
{
    RIL_SimAuthentication pf;
 int32_t  t;
 status_t status;

    memset(&pf, 0, sizeof(pf));

    status = p.readInt32(&t);
    pf.authContext = (int) t;
    pf.authData = strdupReadString(p);
    pf.aid = strdupReadString(p);

    startRequest;
    appendPrintBuf(""authContext=%s, authData=%s, aid=%s"", pf.authContext, pf.authData, pf.aid);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);

 if (status != NO_ERROR) {
 goto invalid;
 }
    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memsetString(pf.authData);
    memsetString(pf.aid);
#endif

    free(pf.authData);
    free(pf.aid);

#ifdef MEMSET_FREED
    memset(&pf, 0, sizeof(pf));
#endif

 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}
","static void dispatchSimAuthentication(Parcel &p, RequestInfo * pMI)
{
    RIL_SimAuthentication pf;
 int32_t  t;
 status_t status;

    memset(&pf, 0, sizeof(pf));

    status = p.readInt32(&t);
    pf.authContext = (int) t;
    pf.authData = strdupReadString(p);
    pf.aid = strdupReadString(p);

    startRequest;
    appendPrintBuf(""authContext=%s, authData=%s, aid=%s"", pf.authContext, pf.authData, pf.aid);
    closeRequest;
    printRequest( pMI->token,  pMI->pCI->requestNumber);

 if (status != NO_ERROR) {
 goto invalid;
 }
    CALL_ONREQUEST( pMI->pCI->requestNumber, &pf, sizeof(pf),  pMI,  pMI->socket_id);

#ifdef MEMSET_FREED
    memsetString(pf.authData);
    memsetString(pf.aid);
#endif

    free(pf.authData);
    free(pf.aid);

#ifdef MEMSET_FREED
    memset(&pf, 0, sizeof(pf));
#endif

 return;
invalid:
    invalidCommandBlock( pMI);
 return;
}
",200.0,52.0,"pRI: pMI,",90.0,0.0600885311762491,Greedy
1023,"MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}
","MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *images)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(images != (const Image *) NULL);
  assert(images->signature == MagickSignature);
  assert(images->cache != (Cache) NULL);
  cache_info=(CacheInfo *) images->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(images));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}
",130.0,28.0,"image:images,",85.0,0.050875703493754,Greedy
1031,"static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
			    struct br_ip *group, unsigned char state)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	struct net_bridge_mdb_htable *mdb;
	int err;

	mdb = mlock_dereference(br->mdb, br);
	mp = br_mdb_ip_get(mdb, group);
	if (!mp) {
		mp = br_multicast_new_group(br, port, group);
		err = PTR_ERR(mp);
		if (IS_ERR(mp))
			return err;
	}

	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p->port == port)
			return -EEXIST;
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	}

	p = br_multicast_new_port_group(port, group, *pp, state);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*pp, p);

	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
	return 0;
}
","static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *parent,
			    struct br_ip *group, unsigned char state)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **fp;
	struct net_bridge_mdb_htable *mdb;
	int err;

	mdb = mlock_dereference(br->mdb, br);
	mp = br_mdb_ip_get(mdb, group);
	if (!mp) {
		mp = br_multicast_new_group(br, parent, group);
		err = PTR_ERR(mp);
		if (IS_ERR(mp))
			return err;
	}

	for (fp = &mp->ports;
	     (p = mlock_dereference(*fp, br)) != NULL;
	     fp = &p->next) {
		if (p->parent == parent)
			return -EEXIST;
		if ((unsigned long)p->parent < (unsigned long)parent)
			break;
	}

	p = br_multicast_new_port_group(parent, group, *fp, state);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*fp, p);

	br_mdb_notify(br->dev, parent, group, RTM_NEWMDB);
	return 0;
}
",217.0,61.0,"pp:fp,port:parent,",162.0,0.0807504733403523,Greedy
1036,"selRead(const char  *fname)
{
FILE  *fp;
SEL   *sel;

    PROCNAME(""selRead"");

    if (!fname)
        return (SEL *)ERROR_PTR(""fname not defined"", procName, NULL);

    if ((fp = fopenReadStream(fname)) == NULL)
        return (SEL *)ERROR_PTR(""stream not opened"", procName, NULL);
    if ((sel = selReadStream(fp)) == NULL) {
        fclose(fp);
        return (SEL *)ERROR_PTR(""sela not returned"", procName, NULL);
    }
    fclose(fp);

    return sel;
}
","selRead(const char  *fname)
{
FILE  *raf;
SEL   *nil;

    PROCNAME(""selRead"");

    if (!fname)
        return (SEL *)ERROR_PTR(""fname not defined"", procName, NULL);

    if ((raf = fopenReadStream(fname)) == NULL)
        return (SEL *)ERROR_PTR(""stream not opened"", procName, NULL);
    if ((snil= selReadStream(raf)) == NULL) {
        fclose(raf);
        return (SEL *)ERROR_PTR(""sela not returned"", procName, NULL);
    }
    fclose(raf);

    return nil;
}
",114.0,23.0,"fp:raf,sel:nil,",311.0,0.164181117216746,GA
1042,"void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->ForwardGestureEvent(tap);
}
","void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned Modifications,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, Modifications,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget__array = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget__array->ForwardGestureEvent(tap);
}
",81.0,13.0,"widget_host:widget__array,modifiers:Modifications,",70.0,0.0369475642840067,Greedy
1050,"set_pwd ()
{
  SHELL_VAR *temp_var, *home_var;
  char *temp_string, *home_string;

  home_var = find_variable (""HOME"");
  home_string = home_var ? value_cell (home_var) : (char *)NULL;

  temp_var = find_variable (""PWD"");
  if (temp_var && imported_p (temp_var) &&
      (temp_string = value_cell (temp_var)) &&
      same_file (temp_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    set_working_directory (temp_string);
  else if (home_string && interactive_shell && login_shell &&
	   same_file (home_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    {
      set_working_directory (home_string);
      temp_var = bind_variable (""PWD"", home_string, 0);
      set_auto_export (temp_var);
    }
  else
    {
      temp_string = get_working_directory (""shell-init"");
      if (temp_string)
	{
	  temp_var = bind_variable (""PWD"", temp_string, 0);
	  set_auto_export (temp_var);
	  free (temp_string);
	}
    }

  /* According to the Single Unix Specification, v2, $OLDPWD is an
     `environment variable' and therefore should be auto-exported.
     Make a dummy invisible variable for OLDPWD, and mark it as exported. */
  temp_var = bind_variable (""OLDPWD"", (char *)NULL, 0);
  VSETATTR (temp_var, (att_exported | att_invisible));
}
","set_pwd ()
{
  SHELL_VAR * temp_type, *home_var;
  char *temp_string, *home_string;

  home_var = find_variable (""HOME"");
  home_string = home_var ? value_cell (home_var) : (char *)NULL;

   temp_type = find_variable (""PWD"");
  if ( temp_type && imported_p ( temp_type) &&
      (temp_string = value_cell ( temp_type)) &&
      same_file (temp_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    set_working_directory (temp_string);
  else if (home_string && interactive_shell && login_shell &&
	   same_file (home_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    {
      set_working_directory (home_string);
       temp_type = bind_variable (""PWD"", home_string, 0);
      set_auto_export ( temp_type);
    }
  else
    {
      temp_string = get_working_directory (""shell-init"");
      if (temp_string)
	{
	   temp_type = bind_variable (""PWD"", temp_string, 0);
	  set_auto_export ( temp_type);
	  free (temp_string);
	}
    }

  /* According to the Single Unix Specification, v2, $OLDPWD is an
     `environment variable' and therefore should be auto-exported.
     Make a dummy invisible variable for OLDPWD, and mark it as exported. */
   temp_type = bind_variable (""OLDPWD"", (char *)NULL, 0);
  VSETATTR ( temp_type, (att_exported | att_invisible));
}
",217.0,51.0,"temp_var: temp_type,",88.0,0.0591009020805358,Greedy
1052,"struct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,
				     const struct sctp_chunk *chunk)
{
	struct sctp_chunk *retval;

	retval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0);

	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
	 *
	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,
	 * HEARTBEAT ACK, * etc.) to the same destination transport
	 * address from which it * received the DATA or control chunk
	 * to which it is replying.
	 *
	 * [ACK back to where the SHUTDOWN came from.]
	 */
	if (retval && chunk)
		retval->transport = chunk->transport;

	return retval;
}
","struct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *rasuc,
				     const struct sctp_chunk *hk)
{
	struct sctp_chunk *defvalue;

	rdefvalue= sctp_make_control(rasuc, SCTP_CID_SHUTDOWN_ACK, 0, 0);

	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
	 *
	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,
	 * HEARTBEAT ACK, * etc.) to the same destination transport
	 * address from which it * received the DATA or control chunk
	 * to which it is replying.
	 *
	 * [ACK back to where the SHUTDOWN came from.]
	 */
	idefvalueval && hk)
		retval->transport = hk->transportdefvalueval->transport = hk->transport;

	return defvalue;
}
",54.0,13.0,"asoc:rasuc,chunk:hk,retval:defvalue,",370.0,0.2382499694824218,GA
1055,"bool CanUseExistingResource(const net::HttpResponseInfo* http_info) {
  if (!http_info->headers || http_info->headers->RequiresValidation(
                                 http_info->request_time,
                                 http_info->response_time, base::Time::Now())) {
    return false;
  }

  std::string value;
  size_t iter = 0;
  while (http_info->headers->EnumerateHeader(&iter, ""vary"", &value)) {
    if (!base::EqualsCaseInsensitiveASCII(value, ""Accept-Encoding"") &&
        !base::EqualsCaseInsensitiveASCII(value, ""Origin"")) {
      return false;
    }
  }
  return true;
}
","bool CanUseExistingResource(const net::HttpResponseInfo* http_information) {
  if (!http_information->headers || http_information->headers->RequiresValidation(
                                 http_information->request_time,
                                 http_information->response_time, base::Time::Now())) {
    return false;
  }

  std::string value;
  size_t iter = 0;
  while (http_information->headers->EnumerateHeader(&iter, ""vary"", &value)) {
    if (!base::EqualsCaseInsensitiveASCII(value, ""Accept-Encoding"") &&
        !base::EqualsCaseInsensitiveASCII(value, ""Origin"")) {
      return false;
    }
  }
  return true;
}
",109.0,16.0,"http_info:http_information,",43.0,0.0311903913815816,Greedy
1057,"bool SendGoBackJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""GoBack"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}
","bool SendGoBackJSONRequest(
    AutomationMessageSender* Sender,
    int browser_id,
    int  tab_address,
    std::string*  error_err) {
  DictionaryValue ini;
  ini.SetString(""command"", ""GoBack"");
  ini.SetInteger(""windex"", browser_id);
  ini.SetInteger(""tab_index"",  tab_address);
  DictionaryValue replyvalconf;
  return SendAutomationJSONRequest(Sender, ini, &replyvalconf,  error_err);
}
",71.0,17.0,"tab_index: tab_address,error_msg: error_err,browser_index:browser_id,reply_dict:replyvalconf,dict:ini,sender:Sender,",173.0,0.1004224975903829,Greedy
1079,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *per = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, per, str8(name, name_len)) ? 1 : 0;
}
",60.0,15.0,"perm:per,",57.0,0.0329863627751668,Greedy
1081,"int import_iovec(int type, const struct iovec __user * uvector,
		 unsigned nr_segs, unsigned fast_segs,
		 struct iovec **iov, struct iov_iter *i)
{
	ssize_t n;
	struct iovec *p;
	n = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,
				  *iov, &p);
	if (n < 0) {
		if (p != *iov)
			kfree(p);
		*iov = NULL;
		return n;
	}
	iov_iter_init(i, type, p, nr_segs, n);
	*iov = p == *iov ? NULL : p;
	return 0;
}
","int import_iovec(int type, const struct iovec __user * uvector,
		 unsigned nr_segs, unsigned fast_segs,
		 struct iovec **iov, struct iov_iter *i)
{
	ssize_t len;
	struct iovec *p;
	len = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,
				  *iov, &p);
	if (len < 0) {
		if (p != *iov)
			kfree(p);
		*iov = NULL;
		return len;
	}
	iov_iter_init(i, type, p, nr_segs, len);
	*iov = p == *iov ? NULL : p;
	return 0;
}
",115.0,35.0,"n:len,",88.0,0.0548114657402038,Greedy
1086,"void PDFiumEngine::GetTextRunInfo(int page_index,
                                  int start_char_index,
                                  uint32_t* out_len,
                                  double* out_font_size,
                                  pp::FloatRect* out_bounds) {
  DCHECK(PageIndexInBounds(page_index));
  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,
                                            out_font_size, out_bounds);
}
","void PDFiumEngine::GetTextRunInfo(int page_index,
                                  int start_char_index,
                                  uint32_t* out_len,
                                  double* out_font_size,
                                  pp::FloatRect* out_abound) {
  DCHECK(PageIndexInBounds(page_index));
  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,
                                            out_font_size, out_abound);
}
",52.0,15.0,"out_bounds:out_abound,",39.0,0.0314488371213277,Greedy
1110,"void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(socket, max_pending_send_allowed);
}
","void WebSocketJob::OnConnected(
    SocketStream* connect, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(connect, max_pending_send_allowed);
}
",42.0,12.0,"socket:connect,",44.0,0.0305448055267333,Greedy
1116,"void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  }
}
","void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* process) {
  ProcessCommitResponse(process);
  ExtensionsActivityMonitor* mount = process->context()->extensions_monitor();
  if (process->status_controller()->HasBookmarkCommitActivity() &&
      process->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    mount->PutRecords(process->extensions_activity());
    process->mutable_extensions_activity()->clear();
  }
}
",79.0,11.0,"monitor:mount,session:process,",114.0,0.0762153148651123,Greedy
1118,"bool IsURLAllowedInIncognito(const GURL& url) {
  return url.scheme() == chrome::kChromeUIScheme &&
      (url.host() == chrome::kChromeUISettingsHost ||
       url.host() == chrome::kChromeUIExtensionsHost ||
       url.host() == chrome::kChromeUIBookmarksHost);
}
","bool IsURLAllowedInIncognito(const GURL& ob) {
  return ob.scheme() == chrome::kChromeUIScheme &&
      (ob.host() == chrome::kChromeUISettingsHost ||
       ob.host() == chrome::kChromeUIExtensionsHost ||
       ob.host() == chrome::kChromeUIBookmarksHost);
}
",53.0,10.0,"url:ob,",62.0,0.0376625736554463,Greedy
1132,"static const char *set_async_filter(cmd_parms *cmd, void *dummy,
                                             const char *arg)
{
    core_server_config *conf =
    ap_get_core_module_config(cmd->server->module_config);
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);

    if (err) {
        return err;
    }

    if (ap_cstr_casecmp(arg, ""network"") == 0) {
        conf->async_filter = AP_FTYPE_NETWORK;
    }
    else if (ap_cstr_casecmp(arg, ""connection"") == 0) {
        conf->async_filter = AP_FTYPE_CONNECTION;
    }
    else if (ap_cstr_casecmp(arg, ""request"") == 0) {
        conf->async_filter = 0;
    }
    else {
        return ""AsyncFilter must be 'network', 'connection' or 'request'"";
    }
    conf->async_filter_set = 1;

    return NULL;
}
","static const char *set_async_filter(cmd_parms *path, void *dummy,
                                             const char *arg)
{
    core_server_config *conf =
    ap_get_core_module_config(path->server->module_config);
    const char *err = ap_check_cmd_context(path, NOT_IN_DIR_LOC_FILE);

    if (err) {
        return err;
    }

    if (ap_cstr_casecmp(arg, ""network"") == 0) {
        conf->async_filter = AP_FTYPE_NETWORK;
    }
    else if (ap_cstr_casecmp(arg, ""connection"") == 0) {
        conf->async_filter = AP_FTYPE_CONNECTION;
    }
    else if (ap_cstr_casecmp(arg, ""request"") == 0) {
        conf->async_filter = 0;
    }
    else {
        return ""AsyncFilter must be 'network', 'connection' or 'request'"";
    }
    conf->async_filter_set = 1;

    return NULL;
}
",133.0,25.0,"cmd:path,",62.0,0.0466937939325968,Greedy
1134," Node::InsertionNotificationRequest HTMLBodyElement::insertedInto(ContainerNode* insertionPoint)
 {
     HTMLElement::insertedInto(insertionPoint);
    if (insertionPoint->inDocument()) {
        Element* ownerElement = document().ownerElement();
        if (isHTMLFrameElementBase(ownerElement)) {
            HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);
            int marginWidth = ownerFrameElement.marginWidth();
            if (marginWidth != -1)
                setIntegralAttribute(marginwidthAttr, marginWidth);
            int marginHeight = ownerFrameElement.marginHeight();
            if (marginHeight != -1)
                setIntegralAttribute(marginheightAttr, marginHeight);
        }
    }
    return InsertionDone;
 }
"," Node::InsertionNotificationRequest HTMLBodyElement::insertedInto(ContainerNode* insertionPoint)
 {
     HTMLElement::insertedInto(insertionPoint);
    if (insertionPoint->inDocument()) {
        Element* officeDocument = document().officeDocument();
        if (isHTMLFrameElementBase(officeDocument)) {
            HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*officeDocument);
            int marginWidth = ownerFrameElement.marginWidth();
            if (marginWidth != -1)
                setIntegralAttribute(marginwidthAttr, marginWidth);
            int marginHeight = ownerFrameElement.marginHeight();
            if (marginHeight != -1)
                setIntegralAttribute(marginheightAttr, marginHeight);
        }
    }
    return InsertionDone;
 }
",108.0,25.0,"ownerElement:officeDocument,",54.0,0.0315988302230835,Greedy
1137,"  void Dispose() {
    raw_data_ = nullptr;
    delete this;
  }
","  void Dispose() {
    raw_data_ = nullptr;
    delete real;
  }
",13.0,2.0,"this:real,",32.0,0.0255248268445332,Greedy
1150,"static inline unsigned long hash_name(const char *name, unsigned int *hashp)
{
	unsigned long hash = init_name_hash();
	unsigned long len = 0, c;

	c = (unsigned char)*name;
	do {
		len++;
		hash = partial_name_hash(c, hash);
		c = (unsigned char)name[len];
	} while (c && c != '/');
	*hashp = end_name_hash(hash);
	return len;
}
","static inline unsigned long hash_name(const char *name, unsigned int *sumps)
{
	unsigned long hash = init_name_hash();
	unsigned long len = 0, content;

	content = (unsigned char)*name;
	do {
		len++;
		hash = partial_name_hash(content, hash);
		content = (unsigned char)name[len];
	} while (content && content != '/');
	*sumps = end_name_hash(hash);
	return len;
}
",90.0,23.0,"hashp:sumps,c:content,",94.0,0.0528056661287943,Greedy
1156,"void NetworkThrottleManagerImpl::RecomputeOutstanding() {
  base::TimeTicks now(tick_clock_->NowTicks());
  base::TimeDelta age_horizon(base::TimeDelta::FromMilliseconds((
      kMedianLifetimeMultiple * lifetime_median_estimate_.current_estimate())));
  while (!outstanding_throttles_.empty()) {
    ThrottleImpl* throttle = *outstanding_throttles_.begin();
    if (throttle->start_time() + age_horizon >= now)
      break;

    outstanding_throttles_.erase(outstanding_throttles_.begin());
    throttle->SetAged();
    throttle->set_queue_pointer(outstanding_throttles_.end());
  }

  if (outstanding_throttles_.empty())
    return;

  if (outstanding_recomputation_timer_->IsRunning())
    return;

  ThrottleImpl* first_throttle(*outstanding_throttles_.begin());
  DCHECK_GE(first_throttle->start_time() + age_horizon, now);

  outstanding_recomputation_timer_->Start(
      FROM_HERE,
      ((first_throttle->start_time() + age_horizon) - now +
       base::TimeDelta::FromMilliseconds(kTimerFudgeInMs)),
      base::Bind(&NetworkThrottleManagerImpl::MaybeUnblockThrottles,
                 base::Unretained(this)));
}
","void NetworkThrottleManagerImpl::RecomputeOutstanding() {
  base::TimeTicks now(tick_clock_->NowTicks());
  base::TimeDelta age_horizon(base::TimeDelta::FromMilliseconds((
      kMedianLifetimeMultiple * lifetime_median_estimate_.current_estimate())));
  while (!outstanding_throttles_.empty()) {
    ThrottleImpl* crorate = *outstanding_throttles_.begin();
    if (crorate->start_time() + age_horizon >= now)
      break;

    outstanding_throttles_.erase(outstanding_throttles_.begin());
    crorate->SetAged();
    crorate->set_queue_pointer(outstanding_throttles_.end());
  }

  if (outstanding_throttles_.empty())
    return;

  if (outstanding_recomputation_timer_->IsRunning())
    return;

  ThrottleImpl* first_throttle(*outstanding_throttles_.begin());
  DCHECK_GE(first_throttle->start_time() + age_horizon, now);

  outstanding_recomputation_timer_->Start(
      FROM_HERE,
      ((first_throttle->start_time() + age_horizon) - now +
       base::TimeDelta::FromMilliseconds(kTimerFudgeInMs)),
      base::Bind(&NetworkThrottleManagerImpl::MaybeUnblockThrottles,
                 base::Unretained(this)));
}
",199.0,37.0,"throttle:crorate,",41.0,0.0344943761825561,Greedy
1182," monitor_init(void)
 {
	struct ssh *ssh = active_state;			/* XXX */
 	struct monitor *mon;
 
 	mon = xcalloc(1, sizeof(*mon));
 	monitor_openfds(mon, 1);
 
	/* Used to share zlib space across processes */
	if (options.compression) {
		mon->m_zback = mm_create(NULL, MM_MEMSIZE);
		mon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);
		/* Compression needs to share state across borders */
		ssh_packet_set_compress_hooks(ssh, mon->m_zlib,
		    (ssh_packet_comp_alloc_func *)mm_zalloc,
		    (ssh_packet_comp_free_func *)mm_zfree);
	}
 	return mon;
 }
"," monitor_init(void)
 {
	struct ssh *ssh = active_state;			/* XXX */
 	struct monitor *mn;
 
 	mn = xcalloc(1, sizeof(*mn));
 	monitor_openfds(mn, 1);
 
	/* Used to share zlib space across processes */
	if (options.compression) {
		mn->m_zback = mm_create(NULL, MM_MEMSIZE);
		mn->m_zlib = mm_create(mn->m_zback, 20 * MM_MEMSIZE);
		/* Compression needs to share state across borders */
		ssh_packet_set_compress_hooks(ssh, mn->m_zlib,
		    (ssh_packet_comp_alloc_func *)mm_zalloc,
		    (ssh_packet_comp_free_func *)mm_zfree);
	}
 	return mn;
 }
",96.0,23.0,"mon:mn,",93.0,0.0462243318557739,Greedy
1186,"static int uvesafb_vbe_find_mode(struct uvesafb_par *par,
		int xres, int yres, int depth, unsigned char flags)
{
	int i, match = -1, h = 0, d = 0x7fffffff;

	for (i = 0; i < par->vbe_modes_cnt; i++) {
		h = abs(par->vbe_modes[i].x_res - xres) +
		    abs(par->vbe_modes[i].y_res - yres) +
		    abs(depth - par->vbe_modes[i].depth);

		/*
		 * We have an exact match in terms of resolution
		 * and depth.
		 */
		if (h == 0)
			return i;

		if (h < d || (h == d && par->vbe_modes[i].depth > depth)) {
			d = h;
			match = i;
		}
	}
	i = 1;

	if (flags & UVESAFB_EXACT_DEPTH &&
			par->vbe_modes[match].depth != depth)
		i = 0;

	if (flags & UVESAFB_EXACT_RES && d > 24)
		i = 0;

	if (i != 0)
		return match;
	else
		return -1;
}
","static int uvesafb_vbe_find_mode(struct uvesafb_par *par,
		int xres, int yres, int depth, unsigned char len)
{
	int d, match = -1, h = 0, d = 0x7fffffff;

	for (d = 0; d < par->vbe_modes_cnt; d++) {
		h = abs(par->vbe_modes[d].x_res - xres) +
		    abs(par->vbe_modes[d].y_res - yres) +
		    abs(depth - par->vbe_modes[d].depth);

		/*
		 * We have an exact match in terms of resolution
		 * and depth.
		 */
		if (h == 0)
			return d;

		if (h < d || (h == d && par->vbe_modes[d].depth > depth)) {
			d = h;
			match = d;
		}
	}
	d = 1;

	if (len & UVESAFB_EXACT_DEPTH &&
			par->vbe_modes[match].depth != depth)
		d = 0;

	if (len & UVESAFB_EXACT_RES && d > 24)
		d = 0;

	if (d != 0)
		return match;
	else
		return -1;
}
",194.0,53.0,"i:d,flags:len,",162.0,0.0893605550130208,Greedy
1187,"void AudioHandler::PrintNodeCounts() {
  fprintf(stderr, ""\n\n"");
  fprintf(stderr, ""===========================\n"");
  fprintf(stderr, ""AudioNode: reference counts\n"");
  fprintf(stderr, ""===========================\n"");

  for (unsigned i = 0; i < kNodeTypeEnd; ++i)
    fprintf(stderr, ""%2d: %d\n"", i, node_count_[i]);

  fprintf(stderr, ""===========================\n\n\n"");
}
","void AudioHandler::PrintNodeCounts() {
  fprintf(stderr, ""\n\n"");
  fprintf(stderr, ""===========================\n"");
  fprintf(stderr, ""AudioNode: reference counts\n"");
  fprintf(stderr, ""===========================\n"");

  for (unsigned start = 0; start < kNodeTypeEnd; ++start)
    fprintf(stderr, ""%2d: %d\n"", start, node_count_[start]);

  fprintf(stderr, ""===========================\n\n\n"");
}
",86.0,20.0,"i:start,",67.0,0.0404112577438354,Greedy
1190,"make_bound_box(POLYGON *poly)
{
	int			i;
	double		x1,
				y1,
				x2,
				y2;

	if (poly->npts > 0)
	{
		x2 = x1 = poly->p[0].x;
		y2 = y1 = poly->p[0].y;
		for (i = 1; i < poly->npts; i++)
		{
			if (poly->p[i].x < x1)
				x1 = poly->p[i].x;
			if (poly->p[i].x > x2)
				x2 = poly->p[i].x;
			if (poly->p[i].y < y1)
				y1 = poly->p[i].y;
			if (poly->p[i].y > y2)
				y2 = poly->p[i].y;
		}

		box_fill(&(poly->boundbox), x1, x2, y1, y2);
	}
	else
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(""cannot create bounding box for empty polygon"")));
}
","make_bound_box(POLYGON *poly)
{
	int			i;
	double		yFirst,
				y1,
				x2,
				y2;

	if (poly->npts > 0)
	{
		x2 = yFirst = poly->p[0].x;
		y2 = y1 = poly->p[0].y;
		for (i = 1; i < poly->npts; i++)
		{
			if (poly->p[i].x < yFirst)
				yFirst = poly->p[i].x;
			if (poly->p[i].x > x2)
				x2 = poly->p[i].x;
			if (poly->p[i].y < y1)
				y1 = poly->p[i].y;
			if (poly->p[i].y > y2)
				y2 = poly->p[i].y;
		}

		box_fill(&(poly->boundbox), yFirst, x2, y1, y2);
	}
	else
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(""cannot create bounding box for empty polygon"")));
}
",206.0,53.0,"x1:yFirst,",62.0,0.0383039871851603,Greedy
1193,"  void CreateOAuth2ServiceDelegate(
       signin::AccountConsistencyMethod account_consistency) {
    oauth2_service_delegate_.reset(new MutableProfileOAuth2TokenServiceDelegate(
         client_.get(), &signin_error_controller_, &account_tracker_service_,
         token_web_data_, account_consistency, revoke_all_tokens_on_load_,
        true /* can_revoke_credantials */));
     base::RunLoop().RunUntilIdle();
     oauth2_service_delegate_->AddObserver(this);
   }
","  void CreateOAuth2ServiceDelegate(
       signin::AccountConsistencyMethod account_consortential) {
    oauth2_service_delegate_.reset(new MutableProfileOAuth2TokenServiceDelegate(
         client_.get(), &signin_error_controller_, &account_tracker_service_,
         token_web_data_, account_consortential, revoke_all_tokens_on_load_,
        true /* can_revoke_credantials */));
     base::RunLoop().RunUntilIdle();
     oauth2_service_delegate_->AddObserver(this);
   }
",56.0,11.0,"account_consistency:account_consortential,",44.0,0.0308739264806111,Greedy
1194,"static void pit_do_work(struct kthread_work *work)
{
	struct kvm_pit *pit = container_of(work, struct kvm_pit, expired);
	struct kvm *kvm = pit->kvm;
	struct kvm_vcpu *vcpu;
	int i;
	struct kvm_kpit_state *ps = &pit->pit_state;
	int inject = 0;

	/* Try to inject pending interrupts when
	 * last one has been acked.
	 */
	spin_lock(&ps->inject_lock);
	if (ps->irq_ack) {
		ps->irq_ack = 0;
		inject = 1;
	}
	spin_unlock(&ps->inject_lock);
	if (inject) {
		kvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 1, false);
		kvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 0, false);

		/*
		 * Provides NMI watchdog support via Virtual Wire mode.
		 * The route is: PIT -> PIC -> LVT0 in NMI mode.
		 *
		 * Note: Our Virtual Wire implementation is simplified, only
		 * propagating PIT interrupts to all VCPUs when they have set
		 * LVT0 to NMI delivery. Other PIC interrupts are just sent to
		 * VCPU0, and only if its LVT0 is in EXTINT mode.
		 */
		if (kvm->arch.vapics_in_nmi_mode > 0)
			kvm_for_each_vcpu(i, vcpu, kvm)
				kvm_apic_nmi_wd_deliver(vcpu);
	}
}
","static void pit_do_work(struct kthread_work *work)
{
	struct kvm_pit *pit = container_of(work, struct kvm_pit, expired);
	struct kvm *kvm = pit->kvm;
	struct kvm_vcpu *vcpu;
	int ii;
	struct kvm_kpit_state *ps = &pit->pit_state;
	int inject = 0;

	/* Try to inject pending interrupts when
	 * last one has been acked.
	 */
	spin_lock(&ps->inject_lock);
	if (ps->irq_ack) {
		ps->irq_ack = 0;
		inject = 1;
	}
	spin_unlock(&ps->inject_lock);
	if (inject) {
		kvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 1, false);
		kvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 0, false);

		/*
		 * Provides NMI watchdog support via Virtual Wire mode.
		 * The route is: PIT -> PIC -> LVT0 in NMI mode.
		 *
		 * Note: Our Virtual Wire implementation is simplified, only
		 * propagating PIT interrupts to all VCPUs when they have set
		 * LVT0 to NMI delivery. Other PIC interrupts are just sent to
		 * VCPU0, and only if its LVT0 is in EXTINT mode.
		 */
		if (kvm->arch.vapics_in_nmi_mode > 0)
			kvm_for_each_vcpu(ii, vcpu, kvm)
				kvm_apic_nmi_wd_deliver(vcpu);
	}
}
",160.0,36.0,"i:ii,",65.0,0.0411277770996093,Greedy
1207,"static bool generic_pkt_to_tuple(const struct sk_buff *skb,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *tuple)
{
	tuple->src.u.all = 0;
	tuple->dst.u.all = 0;

	return true;
}
","static bool generic_pkt_to_tuple(const struct sk_buff *skb,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *dure)
{
	dure->src.u.all = 0;
	dure->dst.u.all = 0;

	return true;
}
",44.0,6.0,"tuple:dure,",41.0,0.0276759227116902,Greedy
1214," static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 {

	if (timr->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
 
	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }
"," static void sgi_timer_get(struct k_itimer *samrs, struct itimerspec *cur_setting)
 {

	if (samrs->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
 
	ns_to_timespec(cur_setting->it_interval, samrs->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (samrs->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }
",106.0,18.0,"timr:samrs,",57.0,0.0406335592269897,Greedy
1251,"static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,
				struct mwifiex_ie **ie_ptr, u16 mask,
				unsigned int oui, u8 oui_type)
{
	struct ieee_types_header *vs_ie;
	struct mwifiex_ie *ie = *ie_ptr;
	const u8 *vendor_ie;

	vendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);
	if (vendor_ie) {
		if (!*ie_ptr) {
			*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),
					  GFP_KERNEL);
			if (!*ie_ptr)
				return -ENOMEM;
			ie = *ie_ptr;
 		}
 
 		vs_ie = (struct ieee_types_header *)vendor_ie;
 		memcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),
 		       vs_ie, vs_ie->len + 2);
 		le16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);
		ie->mgmt_subtype_mask = cpu_to_le16(mask);
		ie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);
	}

	*ie_ptr = ie;
	return 0;
}
","static int mwifiex_update_vs_ie(const u8 *lems, int ies_length,
				struct mwifiex_ie **ie__pad, u16 patch,
				unsigned int  uI, u8 oui__type)
{
	struct ieee_types_header *vs_ie;
	struct mwifiex_ie *ime = *ie__pad;
	const u8 *vendorofie;

	vendorofie = cfg80211_find_vendor_ie( uI, oui__type, lems, ies_length);
	if (vendorofie) {
		if (!*ie__pad) {
			*ie__pad = kzalloc(sizeof(struct mwifiex_ie),
					  GFP_KERNEL);
			if (!*ie__pad)
				return -ENOMEM;
			ime = *ie__pad;
 		}
 
 		vs_ie = (struct ieee_types_header *)vendorofie;
 		memcpy(ime->ie_buffer + le16_to_cpu(ime->ie_length),
 		       vs_ie, vs_ie->len + 2);
 		le16_unaligned_add_cpu(&ime->ie_length, vs_ie->len + 2);
		ime->mgmt_subtype_mask = cpu_to_le16(patch);
		ime->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);
	}

	*ie__pad = ime;
	return 0;
}
",175.0,45.0,"oui_type:oui__type,ies:lems,ies_len:ies_length,ie_ptr:ie__pad,oui: uI,vendor_ie:vendorofie,mask:patch,ie:ime,",314.0,0.1946648200352986,Greedy
1252,"static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;

	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;

	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);

	if (!mobj)
		return;

	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}
","static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;

	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;

	struct optee_msg_param_tmem *fmemory = &arg->params[0].u.fmemory;
	struct mobj *mobj = msg_param_mobj_from_noncontig(fmemory->buf_ptr,
							  fmemory->size,
							  fmemory->shm_ref, false);

	if (!mobj)
		return;

	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}
",113.0,24.0,"tmem:fmemory,",72.0,0.0479993025461832,Greedy
1259," static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
}
"," static void build_l4proto_sctp(const struct nf_conntrack *col, struct nethdr *node)
 {
	ct_build_group(col, ATTR_GRP_ORIG_PORT, node, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	if (!nfct_attr_is_set(col, ATTR_SCTP_STATE))
 		return;
 
 	ct_build_u8(col, ATTR_SCTP_STATE, node, NTA_SCTP_STATE);
 	ct_build_u32(col, ATTR_SCTP_VTAG_ORIG, node, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(col, ATTR_SCTP_VTAG_REPL, node, NTA_SCTP_VTAG_REPL);
}
",79.0,26.0,"ct:col,n:node,",109.0,0.0727159778277079,Greedy
1278,"static void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)
{
	struct net *net = read_pnet(&mrt->net);
	struct sk_buff *skb;

	atomic_dec(&mrt->cache_resolve_queue_len);

	while ((skb = skb_dequeue(&c->mfc_un.unres.unresolved)) != NULL) {
		if (ipv6_hdr(skb)->version == 0) {
			struct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));
			nlh->nlmsg_type = NLMSG_ERROR;
			nlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));
			skb_trim(skb, nlh->nlmsg_len);
			((struct nlmsgerr *)nlmsg_data(nlh))->error = -ETIMEDOUT;
			rtnl_unicast(skb, net, NETLINK_CB(skb).portid);
		} else
			kfree_skb(skb);
	}

	ip6mr_cache_free(c);
}
","static void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)
{
	struct net *net = read_pnet(&mrt->net);
	struct sk_buff *skyrb;

	atomic_dec(&mrt->cache_resolve_queue_len);

	while ((skyrb = skb_dequeue(&c->mfc_un.unres.unresolved)) != NULL) {
		if (ipv6_hdr(skyrb)->version == 0) {
			struct nlmsghdr *lnp = (struct nlmsghdr *)skb_pull(skyrb, sizeof(struct ipv6hdr));
			lnp->nlmsg_type = NLMSG_ERROR;
			lnp->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));
			skb_trim(skyrb, lnp->nlmsg_len);
			((struct nlmsgerr *)nlmsg_data(lnp))->error = -ETIMEDOUT;
			rtnl_unicast(skyrb, net, NETLINK_CB(skyrb).portid);
		} else
			kfree_skb(skyrb);
	}

	ip6mr_cache_free(c);
}
",168.0,36.0,"nlh:lnp,skb:skyrb,",137.0,0.0839196443557739,Greedy
1279,"  void GoBackCrossSite() {
     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(entry);
     contents()->controller().GoBack();
 
    contents()->TestDidNavigate(
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
        content::PAGE_TRANSITION_TYPED);
   }
","  void GoBackCrossSite() {
     NavigationEntry* enter = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(enter);
     contents()->controller().GoBack();
 
    contents()->TestDidNavigate(
        contents()->pending_rvh(), enter->page_id(), GURL(enter->url()),
        content::PAGE_TRANSITION_TYPED);
   }
",74.0,12.0,"entry:enter,",62.0,0.0492701609929402,Greedy
1280,"u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	/*
	 *  Pick a unique starting offset for each ephemeral port search
	 *  (saddr, daddr, dport) and 48bits of random data.
	 */
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}
","u32 secure_ipv4_port_ephemeral(__be32 ssconfig, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	/*
	 *  Pick a unique starting offset for each ephemeral port search
	 *  (saddr, daddr, dport) and 48bits of random data.
	 */
	hash[0] = (__force u32)ssconfig;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}
",91.0,22.0,"saddr:ssconfig,",42.0,0.0439956545829772,Greedy
1281,"void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
 			size_t count)
 {
 	BUG_ON(direction != ITER_PIPE);
 	i->type = direction;
 	i->pipe = pipe;
 	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}
","void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *flow,
 			size_t count)
 {
 	BUG_ON(direction != ITER_PIPE);
 	i->type = direction;
 	i->flow = flow;
 	i->idx = (flow->curbuf + flow->nrbufs) & (flow->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}
",74.0,19.0,"pipe:flow,",86.0,0.0524953405062357,Greedy
1309,"local_wcsnlen (const wchar_t *s, size_t maxlen)
{
  const wchar_t *ptr;

  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)
    ;
  return ptr - s;
}
","local_wcsnlen (const wchar_t *s, size_t  maxen)
{
  const wchar_t *ptr;

  for (ptr = s;  maxen > 0 && *ptr != (wchar_t) 0; ptr++,  maxen--)
    ;
  return ptr - s;
}
",47.0,12.0,"maxlen: maxen,",34.0,0.0262269377708435,Greedy
1322,"WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_id,
    std::string* error) {
  Browser* browser = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))
    return nullptr;

  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();
  if (!contents) {
    *error = ""No active web contents to capture"";
    return nullptr;
  }
 
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           contents->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(contents).id(), error)) {
     return nullptr;
   }
   return contents;
}
","WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_id,
    std::string* block) {
  Browser* browser = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, block))
    return nullptr;

  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();
  if (!contents) {
    *block = ""No active web contents to capture"";
    return nullptr;
  }
 
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           contents->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(contents).id(), block)) {
     return nullptr;
   }
   return contents;
}
",112.0,19.0,"error:block,",66.0,0.0350223183631897,Greedy
1326,"void RenderFrameImpl::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& request,
    const blink::WebURLResponse& response) {
  DCHECK(!frame_ || frame_ == frame);
  GURL url(request.url());
  if (url.SchemeIs(url::kDataScheme))
    return;

  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      response.mimeType().utf8(),
      WebURLRequestToResourceType(request)));
}
","void RenderFrameImpl::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* process,
    const blink::WebURLRequest& input,
    const blink::WebURLResponse& response) {
  DCHECK(!frame_ || frame_ == process);
  GURL method(input.method());
  if (method.SchemeIs(method::kDataScheme))
    return;

  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      method,
      response.securityInfo(),
      input.httpMethod().utf8(),
      response.mimeType().utf8(),
      WebURLRequestToResourceType(input)));
}
",108.0,20.0,"url:method,request:input,frame:process,",156.0,0.0841448942820231,Greedy
1332,"static int hid_abort_transfers(int sub_api, struct usbi_transfer *itransfer)
{
	struct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
	struct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(transfer->dev_handle);
	HANDLE hid_handle;
	int current_interface;
	CHECK_HID_AVAILABLE;
	current_interface = transfer_priv->interface_number;
	hid_handle = handle_priv->interface_handle[current_interface].api_handle;
	CancelIo(hid_handle);
	return LIBUSB_SUCCESS;
}
","static int hid_abort_transfers(int ab_util, struct usbi_transfer *Itranscer)
{
	struct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(Itranscer);
	struct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(Itranscer);
	struct windows_device_handle_priv *handled_storage = _device_handle_priv(transfer->dev_handle);
	HANDLE hid_handle;
	int current_interface;
	CHECK_HID_AVAILABLE;
	current_interface = transfer_priv->interface_number;
	hid_handle = handled_storage->interface_handle[current_interface].api_handle;
	CancelIo(hid_handle);
	return LIBUSB_SUCCESS;
}
",84.0,23.0,"itransfer:Itranscer,sub_api:ab_util,handle_priv:handled_storage,",106.0,0.0872870922088623,Greedy
1348,"read_pri(unsigned int *pri, const char *buf, char **end)
{
    char *tend;
    unsigned int tpri;

    errno = 0;
    while (buf[0] == ' ') buf++;
    if (!isdigit(buf[0])) return -1;
    tpri = strtoul(buf, &tend, 10);
    if (tend == buf) return -1;
    if (errno && errno != ERANGE) return -1;
    if (!end && tend[0] != '\0') return -1;

    if (pri) *pri = tpri;
    if (end) *end = tend;
    return 0;
}
","read_pri(unsigned int *pri, const char *buf, char **end)
{
    char *Tended;
    unsigned int tpri;

    errno = 0;
    while (buf[0] == ' ') buf++;
    if (!isdigit(buf[0])) return -1;
    tpri = strtoul(buf, &Tended, 10);
    if (Tended == buf) return -1;
    if (errno && errno != ERANGE) return -1;
    if (!end && Tended[0] != '\0') return -1;

    if (pri) *pri = tpri;
    if (end) *end = Tended;
    return 0;
}
",128.0,28.0,"tend:Tended,",79.0,0.0431288282076517,Greedy
1349,"static int rose_create(struct net *net, struct socket *sock, int protocol,
		       int kern)
{
	struct sock *sk;
	struct rose_sock *rose;

	if (!net_eq(net, &init_net))
		return -EAFNOSUPPORT;

	if (sock->type != SOCK_SEQPACKET || protocol != 0)
		return -ESOCKTNOSUPPORT;

	sk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);
	if (sk == NULL)
		return -ENOMEM;

	rose = rose_sk(sk);

	sock_init_data(sock, sk);

	skb_queue_head_init(&rose->ack_queue);
#ifdef M_BIT
	skb_queue_head_init(&rose->frag_queue);
	rose->fraglen    = 0;
#endif

	sock->ops    = &rose_proto_ops;
	sk->sk_protocol = protocol;

	init_timer(&rose->timer);
	init_timer(&rose->idletimer);

	rose->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);
	rose->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);
	rose->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);
	rose->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);
	rose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);

	rose->state = ROSE_STATE_0;

	return 0;
}
","static int rose_create(struct net *net, struct socket *sock, int Protoc,
		       int kern)
{
	struct sock *sk;
	struct rose_sock *rose;

	if (!net_eq(net, &init_net))
		return -EAFNOSUPPORT;

	if (sock->type != SOCK_SEQPACKET || Protoc != 0)
		return -ESOCKTNOSUPPORT;

	sk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);
	if (sk == NULL)
		return -ENOMEM;

	rose = rose_sk(sk);

	sock_init_data(sock, sk);

	skb_queue_head_init(&rose->ack_queue);
#ifdef M_BIT
	skb_queue_head_init(&rose->frag_queue);
	rose->fraglen    = 0;
#endif

	sock->ops    = &rose_proto_ops;
	sk->sk_protocol = Protoc;

	init_timer(&rose->timer);
	init_timer(&rose->idletimer);

	rose->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);
	rose->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);
	rose->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);
	rose->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);
	rose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);

	rose->state = ROSE_STATE_0;

	return 0;
}
",209.0,60.0,"protocol:Protoc,",71.0,0.0380769411722819,Greedy
1354,"static void checkAppendMsg(
  IntegrityCk *pCheck,
  const char *zFormat,
  ...
){
  va_list ap;
  if( !pCheck->mxErr ) return;
  pCheck->mxErr--;
  pCheck->nErr++;
  va_start(ap, zFormat);
  if( pCheck->errMsg.nChar ){
    sqlite3StrAccumAppend(&pCheck->errMsg, ""\n"", 1);
  }
  if( pCheck->zPfx ){
    sqlite3XPrintf(&pCheck->errMsg, pCheck->zPfx, pCheck->v1, pCheck->v2);
  }
  sqlite3VXPrintf(&pCheck->errMsg, zFormat, ap);
  va_end(ap);
  if( pCheck->errMsg.accError==STRACCUM_NOMEM ){
    pCheck->mallocFailed = 1;
  }
}
","static void checkAppendMsg(
  IntegrityCk *ppBreak,
  const char *ziBuffer,
  ...
){
  va_list ap;
  if( !ppBreak->mxErr ) return;
  ppBreak->mxErr--;
  ppBreak->nErr++;
  va_start(ap, ziBuffer);
  if( ppBreak->errMsg.nChar ){
    sqlite3StrAccumAppend(&ppBreak->errMsg, ""\n"", 1);
  }
  if( ppBreak->zPfx ){
    sqlite3XPrintf(&ppBreak->errMsg, ppBreak->zPfx, ppBreak->v1, ppBreak->v2);
  }
  sqlite3VXPrintf(&ppBreak->errMsg, ziBuffer, ap);
  va_end(ap);
  if( ppBreak->errMsg.accError==STRACCUM_NOMEM ){
    ppBreak->mallocFailed = 1;
  }
}
",133.0,28.0,"pCheck:ppBreak,zFormat:ziBuffer,",148.0,0.0604561845461527,Greedy
1355,"BOOL IsVolumeClassFilterRegistered ()
{
	UNICODE_STRING name;
	NTSTATUS status;
	BOOL registered = FALSE;

	PKEY_VALUE_PARTIAL_INFORMATION data;

	RtlInitUnicodeString (&name, L""\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"");
	status = TCReadRegistryKey (&name, L""UpperFilters"", &data);

	if (NT_SUCCESS (status))
	{
		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))
		{
			ULONG i;
			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)
			{
				if (memcmp (data->Data + i, L""veracrypt"", 9 * sizeof (wchar_t)) == 0)
				{
					Dump (""Volume class filter active\n"");
					registered = TRUE;
					break;
				}
			}
		}

		TCfree (data);
	}

	return registered;
}
","BOOL IsVolumeClassFilterRegistered ()
{
	UNICODE_STRING name;
	NTSTATUS status;
	BOOL registered = FALSE;

	PKEY_VALUE_PARTIAL_INFORMATION data;

	RtlInitUnicodeString (&name, L""\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"");
	status = TCReadRegistryKey (&name, L""UpperFilters"", &data);

	if (NT_SUCCESS (status))
	{
		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))
		{
			ULONG ii;
			for (ii = 0; ii <= data->DataLength - 9 * sizeof (wchar_t); ++ii)
			{
				if (memcmp (data->Data + ii, L""veracrypt"", 9 * sizeof (wchar_t)) == 0)
				{
					Dump (""Volume class filter active\n"");
					registered = TRUE;
					break;
				}
			}
		}

		TCfree (data);
	}

	return registered;
}
",153.0,32.0,"i:ii,",77.0,0.0385939876238505,Greedy
1364," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
         if (! YY_CURRENT_BUFFER)
             return 0;
     
    return yylineno;
}
"," int re_yyget_lineno  (yyscan_t yysannner)
 {
     struct yyguts_t * YYga = (struct yyguts_t*)yysannner;
         if (! YY_CURRENT_BUFFER)
             return 0;
     
    return yylineno;
}
",31.0,6.0,"yyg:YYga,yyscanner:yysannner,",58.0,0.0411092042922973,Greedy
1366,"static int cfg_keys(struct cryp_ctx *ctx)
{
	int i;
	int num_of_regs = ctx->keylen / 8;
	u32 swapped_key[CRYP_MAX_KEY_SIZE / 4];
	int cryp_error = 0;

	dev_dbg(ctx->device->dev, ""[%s]"", __func__);

	if (mode_is_aes(ctx->config.algomode)) {
		swap_words_in_key_and_bits_in_byte((u8 *)ctx->key,
						   (u8 *)swapped_key,
						   ctx->keylen);
	} else {
		for (i = 0; i < ctx->keylen / 4; i++)
			swapped_key[i] = uint8p_to_uint32_be(ctx->key + i*4);
	}

	for (i = 0; i < num_of_regs; i++) {
		cryp_error = set_key(ctx->device,
				     *(((u32 *)swapped_key)+i*2),
				     *(((u32 *)swapped_key)+i*2+1),
				     (enum cryp_key_reg_index) i);

		if (cryp_error != 0) {
			dev_err(ctx->device->dev, ""[%s]: set_key() failed!"",
					__func__);
			return cryp_error;
		}
	}
	return cryp_error;
}
","static int cfg_keys(struct cryp_ctx *ct)
{
	int data;
	int num_of_regs = ct->keylen / 8;
	u32 swapped_key[CRYP_MAX_KEY_SIZE / 4];
	int cryp_error = 0;

	dev_dbg(ct->device->dev, ""[%s]"", __func__);

	if (mode_is_aes(ct->config.algomode)) {
		swap_words_in_key_and_bits_in_byte((u8 *)ct->key,
						   (u8 *)swapped_key,
						   ct->keylen);
	} else {
		for datai = 0;datai < ct->keylen / 4; data++)
			swappswapped_key] = uint8p_to_uint32_be(ct->key + data*4);
	}

	for (data = 0; data < num_of_regs; data++) {
		cryp_error = set_key(ct->device,
				     *(((u32 *)swaswapped_keyata*2),
				     *(((u32 *)swaswapped_keyata*2+1),
				     (enum cryp_key_reg_index) data);

		if (cryp_error != 0) {
			dev_err(ct->device->dev, ""[%s]: set_key() failed!"",
					__func__);
			return cryp_error;
		}
	}
	return cryp_error;
}
",210.0,44.0,"ctx:ct,i:data,swapped_key:swapped_key,",267.0,0.1461901585261027,GA
1370,"device_constructor (GType type,
                    guint n_construct_properties,
                    GObjectConstructParam *construct_properties)
{
  Device *device;
  DeviceClass *klass;

  klass = DEVICE_CLASS (g_type_class_peek (TYPE_DEVICE));

  device = DEVICE (G_OBJECT_CLASS (device_parent_class)->constructor (type,
                                                                      n_construct_properties,
                                                                      construct_properties));
  return G_OBJECT (device);
}
","device_constructor (GType type,
                    gorint n_construct_properties,
                    GObjectConstructParam *construct_properties)
{
  Device *data;
  DeviceClass *Klasses;

  Klasses = DEVICE_CLASS (g_type_class_peek (TYPE_DEVICE));

  data = DEVICE (G_OBJECT_CLASS (device_parent_class)->constructor (type,
                                                                      n_construct_properties,
                                                                      construct_properties));
  return G_OBJECT (data);
}
",57.0,19.0,"klass:Klasses,device:data,guint:gorint,",98.0,0.0502465605735778,Greedy
1393,"int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *points[1];
    const BIGNUM *scalars[1];

    points[0] = point;
    scalars[0] = p_scalar;

    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, scalars, ctx);
}
","int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_sccalars,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *voc)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *points[1];
    const BIGNUM *scallans[1];

    points[0] = point;
    scallans[0] = p_scalar;

    return EC_POINTs_mul(group, r, g_sccalars,
                         (point != NULL
                          && p_scalar != NULL), points, scallans, voc);
}
",89.0,22.0,"ctx:voc,scalars:scallans,g_scalar:g_sccalars,",151.0,0.0744682510693868,Greedy
1397,"static const wbxml_decoding *get_wbxml_decoding_from_content_type (
								   const char *content_type, tvbuff_t *tvb, guint32 offset)
{
	const wbxml_decoding *map = NULL;

	DebugLog((""get_wbxml_decoding_from_content_type: content_type = [%s]\n"",
		  content_type));
	if (content_type && content_type[0]) {
		const wbxml_literal_list *item = content_type_list;

		while (item && item->content_type) {
			if (g_ascii_strcasecmp(content_type, item->content_type) == 0) {
				/* Try the discriminator */
				if (item->discriminator != NULL) {
					map = item->discriminator(tvb, offset);
				}
				if (map == NULL) {
					map = item->map;
				}
				break;
			}
			item++;
		}
	}
	return map;
}
","static const wbxml_decoding *get_wbxml_decoding_from_content_type (
								   const char *content_format, tvbuff_t *tvb, guint32 offset)
{
	const wbxml_decoding *map = NULL;

	DebugLog((""get_wbxml_decoding_from_content_type: content_type = [%s]\n"",
		  content_format));
	if (content_format && content_format[0]) {
		const wbxml_literal_list *item = content_type_list;

		while (item && item->content_format) {
			if (g_ascii_strcasecmp(content_format, item->content_format) == 0) {
				/* Try the discriminator */
				if (item->discriminator != NULL) {
					map = item->discriminator(tvb, offset);
				}
				if (map == NULL) {
					map = item->map;
				}
				break;
			}
			item++;
		}
	}
	return map;
}
",124.0,26.0,"content_type:content_format,",59.0,0.0379239519437154,Greedy
1409,"void ExtensionService::SyncExtensionChangeIfNeeded(const Extension& extension) {
  SyncBundle* sync_bundle = GetSyncBundleForExtension(extension);
  if (sync_bundle) {
    ExtensionSyncData extension_sync_data(extension,
                                          IsExtensionEnabled(extension.id()),
                                          IsIncognitoEnabled(extension.id()));

    SyncChangeList sync_change_list(1, extension_sync_data.GetSyncChange(
        sync_bundle->HasExtensionId(extension.id()) ?
            SyncChange::ACTION_UPDATE : SyncChange::ACTION_ADD));
    sync_bundle->sync_processor->ProcessSyncChanges(
        FROM_HERE, sync_change_list);
    sync_bundle->synced_extensions.insert(extension.id());
    sync_bundle->pending_sync_data.erase(extension.id());
  }
}
","void ExtensionService::SyncExtensionChangeIfNeeded(const Extension& intended) {
  SyncBundle* sync_Bunch = GetSyncBundleForExtension(intended);
  if (sync_Bunch) {
    ExtensionSyncData extension_sync_data(intended,
                                          IsExtensionEnabled(intended.error()),
                                          IsIncognitoEnabled(intended.error()));

    SyncChangeList sync_change_list(1, extension_sync_data.GetSyncChange(
        sync_Bunch->HasExtensionId(intended.error()) ?
            SyncChange::ACTION_UPDATE : SyncChange::ACTION_ADD));
    sync_Bunch->sync_processor->ProcessSyncChanges(
        FROM_HERE, sync_change_list);
    sync_Bunch->synced_extensions.insert(intended.error());
    sync_Bunch->pending_sync_data.erase(intended.error());
  }
}
",118.0,25.0,"sync_bundle:sync_Bunch,extension:intended,id:error,",221.0,0.1084895412127176,Greedy
1421,"static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)
{
	uint32_t outbound_intstatus;
	struct MessageUnit_A __iomem *reg = acb->pmuA;
	outbound_intstatus = readl(&reg->outbound_intstatus) &
		acb->outbound_int_enable;
	if (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))
		return IRQ_NONE;
	do {
		writel(outbound_intstatus, &reg->outbound_intstatus);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)
			arcmsr_hbaA_doorbell_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)
			arcmsr_hbaA_postqueue_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)
			arcmsr_hbaA_message_isr(acb);
		outbound_intstatus = readl(&reg->outbound_intstatus) &
			acb->outbound_int_enable;
	} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT
		| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
		| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));
	return IRQ_HANDLED;
}
","static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock * acc)
{
	uint32_t outbound_ints;
	struct MessageUnit_A __iomem *reg =  acc->pmuA;
	outbound_ints = readl(&reg->outbound_ints) &
		 acc->outbound_int_enable;
	if (!(outbound_ints & ARCMSR_MU_OUTBOUND_HANDLE_INT))
		return IRQ_NONE;
	do {
		writel(outbound_ints, &reg->outbound_ints);
		if (outbound_ints & ARCMSR_MU_OUTBOUND_DOORBELL_INT)
			arcmsr_hbaA_doorbell_isr( acc);
		if (outbound_ints & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)
			arcmsr_hbaA_postqueue_isr( acc);
		if (outbound_ints & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)
			arcmsr_hbaA_message_isr( acc);
		outbound_ints = readl(&reg->outbound_ints) &
			 acc->outbound_int_enable;
	} while (outbound_ints & (ARCMSR_MU_OUTBOUND_DOORBELL_INT
		| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
		| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));
	return IRQ_HANDLED;
}
",126.0,37.0,"outbound_intstatus:outbound_ints,reg:reg,acb: acc,",248.0,0.1093191305796305,Greedy
1422,"static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());
    ScriptState* currentState = ScriptState::current();
    if (!currentState)
        return;
    ScriptState& state = *currentState;
    ExecutionContext* scriptContext = currentExecutionContext(info.GetIsolate());
    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);
    if (state.hadException()) {
        v8::Local<v8::Value> exception = state.exception();
        state.clearException();
        throwError(exception, info.GetIsolate());
        return;
    }
}
","static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& hi)
{
    TestObjectPython* ip = V8TestObjectPython::toNative(hi.Holder());
    ScriptState* currentState = ScriptState::current();
    if (!currentState)
        return;
    ScriptState& state = *currentState;
    ExecutionContext* execContext = currentExecutionContext(hi.GetIsolate());
    ip->callWithScriptStateExecutionContextVoidMethod(&state, execContext);
    if (state.hadException()) {
        v8::Local<v8::Value> exception = state.exception();
        state.clearException();
        throwError(exception, hi.GetIsolate());
        return;
    }
}
",125.0,23.0,"imp:ip,scriptContext:execContext,info:hi,",118.0,0.0642436583836873,Greedy
1424," static void ReconfigureImpl(Handle<JSObject> object,
 Handle<FixedArrayBase> store, uint32_t entry,
 Handle<Object> value,
 PropertyAttributes attributes) {
    UNREACHABLE();
 }
"," static void ReconfigureImpl(Handle<JSObject> object,
 Handle<FixedArrayBase> data, uint32_t entry,
 Handle<Object> data,
 PropertyAttributes attperties) {
    UNREACHABLE();
 }
",34.0,7.0,"store:data,value:data,attributes:attperties,",74.0,0.0436468283335367,Greedy
1428,"conv_swap4bytes(const UChar* s, const UChar* end, UChar* conv)
{
  while (s < end) {
    *conv++ = s[3];
    *conv++ = s[2];
    *conv++ = s[1];
    *conv++ = s[0];
    s += 4;
  }
}
","conv_swap4bytes(const UChar* lines, const UChar* end, UChar* conv)
{
  while (lines < end) {
    *conv++ = lines[3];
    *conv++ = lines[2];
    *conv++ = lines[1];
    *conv++ = lines[0];
    lines += 4;
  }
}
",66.0,15.0,"s:lines,",75.0,0.0385554750760396,Greedy
1430,"static void die_if_data_is_missing(GHashTable *problem_info)
{
    gboolean missing_data = FALSE;
    gchar **pstring;
    static const gchar *const needed[] = {
        FILENAME_TYPE,
        FILENAME_REASON,
        /* FILENAME_BACKTRACE, - ECC errors have no such elements */
        /* FILENAME_EXECUTABLE, */
        NULL
    };

    for (pstring = (gchar**) needed; *pstring; pstring++)
    {
        if (!g_hash_table_lookup(problem_info, *pstring))
        {
            error_msg(""Element '%s' is missing"", *pstring);
            missing_data = TRUE;
        }
    }

    if (missing_data)
        error_msg_and_die(""Some data is missing, aborting"");
}
","static void die_if_data_is_missing(GHashTable *problem_info)
{
    gboolean missing_data = FALSE;
    gchar ** pvalue;
    static const gchar *const needed[] = {
        FILENAME_TYPE,
        FILENAME_REASON,
        /* FILENAME_BACKTRACE, - ECC errors have no such elements */
        /* FILENAME_EXECUTABLE, */
        NULL
    };

    for ( pvalue = (gchar**) needed; * pvalue;  pvalue++)
    {
        if (!g_hash_table_lookup(problem_info, * pvalue))
        {
            error_msg(""Element '%s' is missing"", * pvalue);
            missing_data = TRUE;
        }
    }

    if (missing_data)
        error_msg_and_die(""Some data is missing, aborting"");
}
",92.0,19.0,"pstring: pvalue,",84.0,0.0387308637301127,Greedy
1432,"unsigned long ring_buffer_size(struct ring_buffer *buffer, int cpu)
{
	/*
	 * Earlier, this method returned
	 *	BUF_PAGE_SIZE * buffer->nr_pages
	 * Since the nr_pages field is now removed, we have converted this to
	 * return the per cpu buffer value.
	 */
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	return BUF_PAGE_SIZE * buffer->buffers[cpu]->nr_pages;
}
","unsigned long ring_buffer_size(struct ring_buffer *byte, int px)
{
	/*
	 * Earlier, this method returned
	 *	BUF_PAGE_SIZE * buffer->nr_pages
	 * Since the nr_pages field is now removed, we have converted this to
	 * return the per cpu buffer value.
	 */
	if (!cpumask_test_cpu(px, byte->cpumask))
		return 0;

	return BUF_PAGE_SIZE * byte->buffers[px]->nr_pages;
}
",41.0,9.0,"buffer:byte,cpu:px,",103.0,0.0554689327875773,Greedy
1438,"static CallInfo *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->ci;
}
","static CallInfo *growCI (lua_State *Long) {
  if (Long->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */
    luaD_throw(Long, LUA_ERRERR);
  else {
    luaD_reallocCI(Long, 2*Long->size_ci);
    if (Long->size_ci > LUAI_MAXCALLS)
      luaG_runerror(Long, ""stack overflow"");
  }
  return ++Long->ini;
}
",62.0,15.0,"L:Long,ci:ini,",91.0,0.0456815997759501,Greedy
1444,"static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;

	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;

	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);

	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}
","static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int uthize;

	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;

	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);

	uthize = crypto_aead_authsize(authenc);
	ihash = ohash + uthize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 uthize, 0);
	return crypto_memneq(ihash, ohash, uthize) ? -EBADMSG : 0;
}
",125.0,40.0,"authsize:uthize,",71.0,0.0403745492299397,Greedy
1448,"jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)
 {
 	jas_matrix_t *matrix;
 	assert(xstart <= xend && ystart <= yend);
	if (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {
		return 0;
	}
	matrix->xstart_ = xstart;
	matrix->ystart_ = ystart;
	matrix->xend_ = xend;
	matrix->yend_ = yend;
 	return matrix;
 }
","jas_matrix_t *jas_seq2d_create(int yad, int ayfrom, int xset, int  yended)
 {
 	jas_matrix_t *formatMatrix;
 	assert(yad <= xset && ayfrom <=  yended);
	if (!(formatMatrix = jas_matrix_create( yended - ayfrom, xset - yad))) {
		return 0;
	}
	formatMatrix->xstart_ = yad;
	formatMatrix->ystart_ = ayfrom;
	formatMatrix->xend_ = xset;
	formatMatrix->yend_ =  yended;
 	return formatMatrix;
 }
",83.0,26.0,"xstart:yad,ystart:ayfrom,yend: yended,xend:xset,matrix:formatMatrix,",235.0,0.1019500374794006,Greedy
1456,"void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)
{
}
","void __update_tlb(struct vm_area_struct *vda, unsigned long parent, pte_t pte)
{
}
",17.0,4.0,"vma:vda,address:parent,",48.0,0.0389335989952087,Greedy
1466,"void RunCallbacksWithDisabled(LogoCallbacks callbacks) {
  if (callbacks.on_cached_encoded_logo_available) {
    std::move(callbacks.on_cached_encoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if (callbacks.on_cached_decoded_logo_available) {
    std::move(callbacks.on_cached_decoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if (callbacks.on_fresh_encoded_logo_available) {
    std::move(callbacks.on_fresh_encoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if (callbacks.on_fresh_decoded_logo_available) {
    std::move(callbacks.on_fresh_decoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
}
","void RunCallbacksWithDisabled(LogoCallbacks  callouts) {
  if ( callouts.on_cached_encoded_logo_available) {
    std::move( callouts.on_cached_encoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if ( callouts.on_cached_decoded_logo_available) {
    std::move( callouts.on_cached_decoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if ( callouts.on_fresh_encoded_logo_available) {
    std::move( callouts.on_fresh_encoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if ( callouts.on_fresh_decoded_logo_available) {
    std::move( callouts.on_fresh_decoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
}
",120.0,22.0,"callbacks: callouts,",91.0,0.0447844465573628,Greedy
1467," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, false,
			   __builtin_return_address(0));
}
"," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *bind,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, bind, &memory))
		return memory;

	return __dma_alloc(dev, size, bind, gfp, prot, false,
			   __builtin_return_address(0));
}
",78.0,24.0,"attrs:attrs,dev:dev,memory:memory,handle:bind,",172.0,0.0926403443018595,Greedy
1468,"SMB2_logoff(const unsigned int xid, struct cifs_ses *ses)
{
	struct smb2_logoff_req *req; /* response is also trivial struct */
	int rc = 0;
	struct TCP_Server_Info *server;

	cifs_dbg(FYI, ""disconnect session %p\n"", ses);

	if (ses && (ses->server))
		server = ses->server;
	else
		return -EIO;

	/* no need to send SMB logoff if uid already closed due to reconnect */
	if (ses->need_reconnect)
		goto smb2_session_already_dead;

	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);
	if (rc)
		return rc;

	 /* since no tcon, smb2_init can not do this, so do here */
	req->hdr.SessionId = ses->Suid;
	if (server->sign)
		req->hdr.Flags |= SMB2_FLAGS_SIGNED;

	rc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);
	/*
	 * No tcon so can't do
	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);
	 */

smb2_session_already_dead:
	return rc;
}
","SMB2_logoff(const unsigned int xcId, struct cifs_ses *ses)
{
	struct smb2_logoff_req *ser; /* response is also trivial struct */
	int rc = 0;
	struct TCP_Server_Info *server;

	cifs_dbg(FYI, ""disconnect session %p\n"", ses);

	if (ses && (ses->server))
		server = ses->server;
	else
		return -EIO;

	/* no need to send SMB logoff if uid already closed due to reconnect */
	if (ses->need_reconnect)
		goto smb2_session_already_dead;

	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &ser);
	if (rc)
		return rc;

	 /* since no tcon, smb2_init can not do this, so do here */
	ser->hdr.SessionId = ses->Suid;
	if (server->sign)
		ser->hdr.Flags |= SMB2_FLAGS_SIGNED;

	rc = SendReceiveNoRsp(xcId, ses, (char *) &ser->hdr, 0);
	/*
	 * No tcon so can't do
	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);
	 */

smb2_session_already_dead:
	return rc;
}
",143.0,32.0,"xid:xcId,req:ser,",86.0,0.0516385515530904,Greedy
1471,"unsigned long long task_sched_runtime(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	u64 ns = 0;

	rq = task_rq_lock(p, &flags);
	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
	task_rq_unlock(rq, p, &flags);

	return ns;
}
","unsigned long long task_sched_runtime(struct task_struct *fp)
{
	unsigned long data;
	struct rdQ *rdQ;
	u64 ns = 0;

	rdQ = task_rq_lock(fp, &data);
	ns = fp->se.sum_exec_runtime + do_task_delta_exec(fp, rdQ);
	task_rq_unlock(rdQ, fp, &data);

	return ns;
}
",64.0,19.0,"flags:data,rq:rdQ,p:fp,",167.0,0.0819314877192179,Greedy
1477," GURL GetURLFromCookiePair(
    const net::CookieMonster::CookieListPair& cookie_pair) {
  const std::string& domain_key = cookie_pair.first;
  const net::CookieMonster::CanonicalCookie& cookie = cookie_pair.second;
  const std::string scheme =
      cookie.IsSecure() ? chrome::kHttpsScheme : chrome::kHttpScheme;
  const std::string host =
      domain_key.find('.') != 0 ? domain_key : domain_key.substr(1);
  return GURL(scheme + chrome::kStandardSchemeSeparator + host + ""/"");
}
"," GURL GetURLFromCookiePair(
    const net::CookieMonster::CookieListPair& ookie_air) {
  const std::string& domain_key = ookie_air.first;
  const net::CookieMonster::CanonicalCookie& cookie = ookie_air.second;
  const std::string scheme =
      cookie.IsSecure() ? chrome::kHttpsScheme : chrome::kHttpScheme;
  const std::string host =
      domain_key.find('.') != 0 ? domain_key : domain_key.substr(1);
  return GURL(scheme + chrome::kStandardSchemeSeparator + host + ""/"");
}
",98.0,18.0,"cookie_pair:ookie_air,",38.0,0.0296414256095886,Greedy
1479,"static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    char *byteptr = (char *)wpmd->data;

    if (bytecnt != 4)
        return FALSE;

    wps->int32_sent_bits = *byteptr++;
    wps->int32_zeros = *byteptr++;
    wps->int32_ones = *byteptr++;
    wps->int32_dups = *byteptr;

    return TRUE;
}
","static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    char *bytePtr = (char *)wpmd->data;

    if (bytecnt != 4)
        return FALSE;

    wps->int32_sent_bits = *bytePtr++;
    wps->int32_zeros = *bytePtr++;
    wps->int32_ones = *bytePtr++;
    wps->int32_dups = *bytePtr;

    return TRUE;
}
",76.0,16.0,"byteptr:bytePtr,",62.0,0.0404685775438944,Greedy
1488,"static ssize_t ib_ucm_send_rep(struct ib_ucm_file *file,
			       const char __user *inbuf,
			       int in_len, int out_len)
{
	struct ib_cm_rep_param param;
	struct ib_ucm_context *ctx;
	struct ib_ucm_rep cmd;
	int result;

	param.private_data = NULL;

	if (copy_from_user(&cmd, inbuf, sizeof(cmd)))
		return -EFAULT;

	result = ib_ucm_alloc_data(&param.private_data, cmd.data, cmd.len);
	if (result)
		return result;

	param.qp_num              = cmd.qpn;
	param.starting_psn        = cmd.psn;
	param.private_data_len    = cmd.len;
	param.responder_resources = cmd.responder_resources;
	param.initiator_depth     = cmd.initiator_depth;
	param.failover_accepted   = cmd.failover_accepted;
	param.flow_control        = cmd.flow_control;
	param.rnr_retry_count     = cmd.rnr_retry_count;
	param.srq                 = cmd.srq;

	ctx = ib_ucm_ctx_get(file, cmd.id);
	if (!IS_ERR(ctx)) {
		ctx->uid = cmd.uid;
		result = ib_send_cm_rep(ctx->cm_id, &param);
		ib_ucm_ctx_put(ctx);
	} else
		result = PTR_ERR(ctx);

	kfree(param.private_data);
	return result;
}
","static ssize_t ib_ucm_send_rep(struct ib_ucm_file *file,
			       const char __user *inbuf,
			       int in_len, int out_len)
{
	struct ib_cm_rep_param param;
	struct ib_ucm_context *ctx;
	struct ib_ucm_rep component;
	int result;

	param.private_data = NULL;

	if (copy_from_user(&component, inbuf, sizeof(component)))
		return -EFAULT;

	result = ib_ucm_alloc_data(&param.private_data, component.data, component.len);
	if (result)
		return result;

	param.qp_num              = component.qpn;
	param.starting_psn        = component.psn;
	param.private_data_len    = component.len;
	param.responder_resources = component.responder_resources;
	param.initiator_depth     = component.initiator_depth;
	param.failover_accepted   = component.failover_accepted;
	param.flow_control        = component.flow_control;
	param.rnr_retry_count     = component.rnr_retry_count;
	param.srq                 = component.srq;

	ctx = ib_ucm_ctx_get(file, component.id);
	if (!IS_ERR(ctx)) {
		ctx->uid = component.uid;
		result = ib_send_cm_rep(ctx->cm_id, &param);
		ib_ucm_ctx_put(ctx);
	} else
		result = PTR_ERR(ctx);

	kfree(param.private_data);
	return result;
}
",225.0,61.0,"cmd:component,",131.0,0.0563909490903218,Greedy
1500,"static int accept_server_socket(int sfd)
{
 struct sockaddr_un remote;
 struct pollfd pfd;
 int fd;
 socklen_t len = sizeof(struct sockaddr_un);

    BTIF_TRACE_EVENT(""accept fd %d"", sfd);

 /* make sure there is data to process */

     pfd.fd = sfd;
     pfd.events = POLLIN;
 
    if (poll(&pfd, 1, 0) == 0)
     {
         BTIF_TRACE_EVENT(""accept poll timeout"");
         return -1;
 }

 
 
    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)
     {
          BTIF_TRACE_ERROR(""sock accept failed (%s)"", strerror(errno));
          return -1;
 }


 return fd;
}
","static int accept_server_socket(int pfun)
{
 struct sockaddr_un remote;
 struct pollfd pfd;
 int cb;
 socklen_t len = sizeof(struct sockaddr_un);

    BTIF_TRACE_EVENT(""accept fd %d"", pfun);

 /* make sure there is data to process */

     pfd.cb = pfun;
     pfd.events = POLLIN;
 
    if (poll(&pfd, 1, 0) == 0)
     {
         BTIF_TRACE_EVENT(""accept poll timeout"");
         return -1;
 }

 
 
    if ((cb = accept(pfun, (struct sockaddr *)&remote, &len)) == -1)
     {
          BTIF_TRACE_ERROR(""sock accept failed (%s)"", strerror(errno));
          return -1;
 }


 return cb;
}
",117.0,24.0,"remote:remote,pfd:pfd,fd:cb,sfd:pfun,",213.0,0.1061882019042968,Greedy
1502,"static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
			struct msghdr *msg, size_t len, int flags)
{
	struct sock *sk = sock->sk;
	struct alg_sock *ask = alg_sk(sk);
	struct hash_ctx *ctx = ask->private;
	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
	int err;

	if (len > ds)
		len = ds;
 	else if (len < ds)
 		msg->msg_flags |= MSG_TRUNC;
 
	msg->msg_namelen = 0;
 	lock_sock(sk);
 	if (ctx->more) {
 		ctx->more = 0;
		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
						 &ctx->completion);
		if (err)
			goto unlock;
	}

	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);

unlock:
	release_sock(sk);

	return err ?: len;
}
","static int hash_recvmsg(struct kiocb *unused, struct socket *setsocks,
			struct msghdr *msg, size_t lock, int vals)
{
	struct setsocks *kick = setsocks->kick;
	struct alg_sock *ask = alg_sk(kick);
	struct hash_ctx *cas = ask->private;
	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&cas->req));
	int err;

	if (lock > ds)
		lock = ds;
 	else if (lock < ds)
 		msg->msg_flags |= MSG_TRUNC;
 
	msg->msg_namelen = 0;
 	lock_sock(kick);
 	if (cas->more) {
 		cas->more = 0;
		ahash_request_set_crypt(&cas->req, NULL, cas->result, 0);
		err = af_alg_wait_for_completion(crypto_ahash_final(&cas->req),
						 &cas->completion);
		if (err)
			goto unlock;
	}

	err = memcpy_toiovec(msg->msg_iov, cas->result, lock);

unlock:
	release_sock(kick);

	return err ?: lock;
}
",190.0,50.0,"sock:setsocks,sk:kick,ctx:cas,flags:vals,len:lock,",292.0,0.1393785874048868,Greedy
1517,"static int parse_timeout(const char *target)
{
    QemuOptsList *list;
    QemuOpts *opts;
    const char *timeout;

    list = qemu_find_opts(""iscsi"");
    if (list) {
        opts = qemu_opts_find(list, target);
        if (!opts) {
            opts = QTAILQ_FIRST(&list->head);
        }
        if (opts) {
            timeout = qemu_opt_get(opts, ""timeout"");
            if (timeout) {
                return atoi(timeout);
            }
        }
    }

    return 0;
}
","static int parse_timeout(const char *current)
{
    QemuOptsList *source;
    QemuOpts *copt;
    const char *length;

    source = qemu_find_opts(""iscsi"");
    if (source) {
        copt = qemu_opts_find(source, current);
        if (!copt) {
            copt = QTAILQ_FIRST(&source->head);
        }
        if (copt) {
            length = qemu_opt_get(copt, ""timeout"");
            if (length) {
                return atoi(length);
            }
        }
    }

    return 0;
}
",95.0,23.0,"target:current,list:source,timeout:length,opts:copt,",220.0,0.1015762050946553,Greedy
1533,"struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
					struct sk_buff *skb, u16 vid)
{
	struct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);
	struct br_ip ip;

	if (br->multicast_disabled)
		return NULL;

	if (BR_INPUT_SKB_CB(skb)->igmp)
		return NULL;

	ip.proto = skb->protocol;
	ip.vid = vid;

	switch (skb->protocol) {
	case htons(ETH_P_IP):
		ip.u.ip4 = ip_hdr(skb)->daddr;
		break;
#if IS_ENABLED(CONFIG_IPV6)
	case htons(ETH_P_IPV6):
		ip.u.ip6 = ipv6_hdr(skb)->daddr;
		break;
#endif
	default:
		return NULL;
	}

	return br_mdb_ip_get(mdb, &ip);
}
","struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
					struct sk_buff *skb, u16 len)
{
	struct net_bridge_mdb_htable *sdb = rcu_dereference(br->sdb);
	struct br_ip ip;

	if (br->multicast_disabled)
		return NULL;

	if (BR_INPUT_SKB_CB(skb)->igmp)
		return NULL;

	ip.proto = skb->protocol;
	ip.len = len;

	switch (skb->protocol) {
	case htons(ETH_P_IP):
		ip.u.ip4 = ip_hdr(skb)->daddr;
		break;
#if IS_ENABLED(CONFIG_IPV6)
	case htons(ETH_P_IPV6):
		ip.u.ip6 = ipv6_hdr(skb)->daddr;
		break;
#endif
	default:
		return NULL;
	}

	return br_mdb_ip_get(sdb, &ip);
}
",142.0,31.0,"vid:len,mdb:sdb,",110.0,0.0568555315335591,Greedy
1534,"xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg,
 const xmlChar * info1, const xmlChar * info2,
 const xmlChar * info3)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
 (const char *) info2, (const char *) info3, 0, 0, msg,
                    info1, info2, info3);
 if (ctxt != NULL)
	ctxt->nsWellFormed = 0;
}
","xmlNsErr(xmlParserCtxtPtr CTct, xmlParserErrors error,
 const char *msg,
 const xmlChar * info1, const xmlChar * info2,
 const xmlChar * info3)
{
 if ((CTct != NULL) && (CTct->disableSAX != 0) &&
 (CTct->instate == XML_PARSER_EOF))
 return;
 if (CTct != NULL)
	CTct->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, CTct, NULL, XML_FROM_NAMESPACE, error,
                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
 (const char *) info2, (const char *) info3, 0, 0, msg,
                    info1, info2, info3);
 if (CTct != NULL)
	CTct->nsWellFormed = 0;
}
",136.0,28.0,"ctxt:CTct,",85.0,0.0427895585695902,Greedy
1539,"void UnloadController::TabDetachedAt(TabContents* contents, int index) {
   TabDetachedImpl(contents);
 }
","void UnloadController::TabDetachedAt(TabContents* textlements, int i) {
   TabDetachedImpl(textlements);
 }
",19.0,5.0,"contents:textlements,index:i,",64.0,0.038538110256195,Greedy
1549,"static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bmlen;
	int status;

	status = decode_op_hdr(xdr, OP_CREATE);
	if (status)
		return status;
	if ((status = decode_change_info(xdr, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bmlen);
	READ_BUF(bmlen << 2);
	return 0;
}
","static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bslen;
	int status;

	status = decode_op_hdr(xdr, OP_CREATE);
	if (status)
		return status;
	if ((status = decode_change_info(xdr, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bslen);
	READ_BUF(bslen << 2);
	return 0;
}
",78.0,22.0,"bmlen:bslen,",78.0,0.0430099447568257,Greedy
1551,"struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;

	/* If this is not a UDP-style socket, assoc id should be ignored. */
	if (!sctp_style(sk, UDP)) {
		/* Return NULL if the socket state is not ESTABLISHED. It
		 * could be a TCP-style listening socket or a socket which
		 * hasn't yet called connect() to establish an association.
		 */
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;

		/* Get the first and the only association from the list. */
		if (!list_empty(&sctp_sk(sk)->ep->asocs))
			asoc = list_entry(sctp_sk(sk)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}

	/* Otherwise this is a UDP-style socket. */
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;

	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);

	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;

	return asoc;
}
","struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct sctp_association *asuc = NULL;

	/* If this is not a UDP-style socket, assoc id should be ignored. */
	if (!sctp_style(sk, UDP)) {
		/* Return NULL if the socket state is not ESTABLISHED. It
		 * could be a TCP-style listening socket or a socket which
		 * hasn't yet called connect() to establish an association.
		 */
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;

		/* Get the first and the only association from the list. */
		if (!list_empty(&sctp_sk(sk)->ep->asocs))
			asuc = list_entry(sctp_sk(sk)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asuc;
	}

	/* Otherwise this is a UDP-style socket. */
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;

	spin_lock_bh(&sctp_assocs_id_lock);
	asuc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);

	if (!asuc || (asuc->base.sk != sk) || asuc->base.dead)
		return NULL;

	return asuc;
}
",170.0,40.0,"asoc:asuc,",86.0,0.0528365572293599,Greedy
1554,"void SpeechSynthesis::handleSpeakingCompleted(SpeechSynthesisUtterance* utterance, bool errorOccurred)
 {
     ASSERT(utterance);
 
     bool didJustFinishCurrentUtterance = false;
    if (utterance == currentSpeechUtterance()) {
        m_utteranceQueue.removeFirst();
        didJustFinishCurrentUtterance = true;
    }

    fireEvent(errorOccurred ? EventTypeNames::error : EventTypeNames::end, utterance, 0, String());

    if (didJustFinishCurrentUtterance && !m_utteranceQueue.isEmpty())
        startSpeakingImmediately();
}
","void SpeechSynthesis::handleSpeakingCompleted(SpeechSynthesisUtterance* utteredancing, bool errorOccurred)
 {
     ASSERT(utteredancing);
 
     bool didJustFinishCurrentUtterance = false;
    if (utteredancing == currentSpeechUtterance()) {
        m_utteranceQueue.removeFirst();
        didJustFinishCurrentUtterance = true;
    }

    fireEvent(errorOccurred ? EventTypeNames::error : EventTypeNames::end, utteredancing, 0, String());

    if (didJustFinishCurrentUtterance && !m_utteranceQueue.isEmpty())
        startSpeakingImmediately();
}
",80.0,19.0,"errorOccurred:errorOccurred,utterance:utteredancing,",63.0,0.038829215367635,Greedy
1557,"NDIS_STATUS ParaNdis6_ReceivePauseRestart(
    PARANDIS_ADAPTER *pContext,
    BOOLEAN bPause,
    ONPAUSECOMPLETEPROC Callback
    )
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    if (bPause)
    {
        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);

        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);
        if (pContext->m_upstreamPacketPending != 0)
        {
            pContext->ReceiveState = srsPausing;
            pContext->ReceivePauseCompletionProc = Callback;
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);
            pContext->ReceiveState = srsDisabled;
        }
    }
    else
    {
        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);
        pContext->ReceiveState = srsEnabled;
    }
    return status;
}
","NDIS_STATUS ParaNdis6_ReceivePauseRestart(
    PARANDIS_ADAPTER *paSettings,
    BOOLEAN rbCapture,
    ONPAUSECOMPLETEPROC Parser
    )
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    if (rbCapture)
    {
        CNdisPassiveWriteAutoLock tLock(paSettings->m_PauseLock);

        ParaNdis_DebugHistory(paSettings, hopInternalReceivePause, NULL, 1, 0, 0);
        if (paSettings->m_upstreamPacketPending != 0)
        {
            paSettings->ReceiveState = srsPausing;
            paSettings->ReceivePauseCompletionProc = Parser;
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            ParaNdis_DebugHistory(paSettings, hopInternalReceivePause, NULL, 0, 0, 0);
            paSettings->ReceiveState = srsDisabled;
        }
    }
    else
    {
        ParaNdis_DebugHistory(paSettings, hopInternalReceiveResume, NULL, 0, 0, 0);
        paSettings->ReceiveState = srsEnabled;
    }
    return status;
}
",126.0,30.0,"bPause:rbCapture,pContext:paSettings,Callback:Parser,",153.0,0.0854652126630147,Greedy
1559,"void Tab::OnMouseReleased(const ui::MouseEvent& event) {
  controller_->OnMouseEventInTab(this, event);

  if (controller_->EndDrag(END_DRAG_COMPLETE))
    return;

  if (event.IsMiddleMouseButton()) {
    if (HitTestPoint(event.location())) {
      controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);
    } else if (closing_) {
      gfx::Point location_in_parent = event.location();
      ConvertPointToTarget(this, parent(), &location_in_parent);
      Tab* closest_tab = controller_->GetTabAt(location_in_parent);
      if (closest_tab)
        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);
    }
  } else if (event.IsOnlyLeftMouseButton() && !event.IsShiftDown() &&
             !IsSelectionModifierDown(event)) {
    controller_->SelectTab(this, event);
  }
}
","void Tab::OnMouseReleased(const ui::MouseEvent& parent) {
  controller_->OnMouseEventInTab(this, parent);

  if (controller_->EndDrag(END_DRAG_COMPLETE))
    return;

  if (parent.IsMiddleMouseButton()) {
    if (HitTestPoint(parent.location())) {
      controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);
    } else if (closing_) {
      gfx::Point location_in_parent = parent.location();
      ConvertPointToTarget(this, parent(), &location_in_parent);
      Tab* closest_tab = controller_->GetTabAt(location_in_parent);
      if (closest_tab)
        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);
    }
  } else if (parent.IsOnlyLeftMouseButton() && !parent.IsShiftDown() &&
             !IsSelectionModifierDown(parent)) {
    controller_->SelectTab(this, parent);
  }
}
",153.0,30.0,"event:parent,",97.0,0.0493818442026774,Greedy
1561,"static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                          const unsigned char *in, size_t len)
{
    EVP_AES_XTS_CTX *xctx = EVP_C_DATA(EVP_AES_XTS_CTX,ctx);
    if (!xctx->xts.key1 || !xctx->xts.key2)
        return 0;
    if (!out || !in || len < AES_BLOCK_SIZE)
        return 0;
    if (xctx->stream)
        (*xctx->stream) (in, out, len,
                         xctx->xts.key1, xctx->xts.key2,
                         EVP_CIPHER_CTX_iv_noconst(ctx));
    else if (CRYPTO_xts128_encrypt(&xctx->xts, EVP_CIPHER_CTX_iv_noconst(ctx),
                                   in, out, len,
                                   EVP_CIPHER_CTX_encrypting(ctx)))
        return 0;
    return 1;
}
","static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                          const unsigned char *in, size_t len)
{
    EVP_AES_XTS_CTX *Xcor = EVP_C_DATA(EVP_AES_XTS_CTX,ctx);
    if (!Xcor->xts.key1 || !Xcor->xts.key2)
        return 0;
    if (!out || !in || len < AES_BLOCK_SIZE)
        return 0;
    if (Xcor->stream)
        (*Xcor->stream) (in, out, len,
                         Xcor->xts.key1, Xcor->xts.key2,
                         EVP_CIPHER_CTX_iv_noconst(ctx));
    else if (CRYPTO_xts128_encrypt(&Xcor->xts, EVP_CIPHER_CTX_iv_noconst(ctx),
                                   in, out, len,
                                   EVP_CIPHER_CTX_encrypting(ctx)))
        return 0;
    return 1;
}
",139.0,33.0,"xctx:Xcor,",98.0,0.0481180071830749,Greedy
1565," virtual bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }
"," virtual bool DnsResolveEx(const std::string& connect,
                            std::string* ip_number_result) {
    dns_resolves_ex.push_back(connect);
 *ip_number_result = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }
",39.0,8.0,"ip_address_list:ip_number_result,host:connect,",54.0,0.0386664668718973,Greedy
1567,"int Textfield::OnDragUpdated(const ui::DropTargetEvent& event) {
  DCHECK(CanDrop(event.data()));
  gfx::RenderText* render_text = GetRenderText();
  const gfx::Range& selection = render_text->selection();
  drop_cursor_position_ = render_text->FindCursorPosition(event.location());
  bool in_selection =
      !selection.is_empty() &&
      selection.Contains(gfx::Range(drop_cursor_position_.caret_pos()));
  drop_cursor_visible_ = !in_selection;
  OnCaretBoundsChanged();
  SchedulePaint();

  StopBlinkingCursor();

  if (initiating_drag_) {
    if (in_selection)
      return ui::DragDropTypes::DRAG_NONE;
    return event.IsControlDown() ? ui::DragDropTypes::DRAG_COPY
                                 : ui::DragDropTypes::DRAG_MOVE;
  }
  return ui::DragDropTypes::DRAG_COPY | ui::DragDropTypes::DRAG_MOVE;
}
","int Textfield::OnDragUpdated(const ui::DropTargetEvent& node) {
  DCHECK(CanDrop(node.data()));
  gfx::RenderText* render_text = GetRenderText();
  const gfx::Range& selection = render_text->selection();
  drop_cursor_position_ = render_text->FindCursorPosition(node.location());
  bool in_selection =
      !selection.is_empty() &&
      selection.Contains(gfx::Range(drop_cursor_position_.caret_pos()));
  drop_cursor_visible_ = !in_selection;
  OnCaretBoundsChanged();
  SchedulePaint();

  StopBlinkingCursor();

  if (initiating_drag_) {
    if (in_selection)
      return ui::DragDropTypes::DRAG_NONE;
    return node.IsControlDown() ? ui::DragDropTypes::DRAG_COPY
                                 : ui::DragDropTypes::DRAG_MOVE;
  }
  return ui::DragDropTypes::DRAG_COPY | ui::DragDropTypes::DRAG_MOVE;
}
",154.0,30.0,"event:node,",59.0,0.0391774376233418,Greedy
1580,"static void cfundecs(JF, js_Ast *list)
{
	while (list) {
		js_Ast *stm = list->a;
		if (stm->type == AST_FUNDEC) {
			emitline(J, F, stm);
			emitfunction(J, F, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, F->strict));
			emitline(J, F, stm);
			emit(J, F, OP_SETLOCAL);
			emitarg(J, F, addlocal(J, F, stm->a, 0));
			emit(J, F, OP_POP);
		}
		list = list->b;
	}
}
","static void cfundecs(JF, js_Ast *parent)
{
	while (parent) {
		js_Ast *ndms = parent->a;
		if (ndms->type == AST_FUNDEC) {
			emitline(J, F, ndms);
			emitfunction(J, F, newfun(J, ndms->line, ndms->a, ndms->b, ndms->c, 0, F->strict));
			emitline(J, F, ndms);
			emit(J, F, OP_SETLOCAL);
			emitarg(J, F, addlocal(J, F, ndms->a, 0));
			emit(J, F, OP_POP);
		}
		parent = parent->b;
	}
}
",132.0,42.0,"stm:ndms,list:parent,",156.0,0.061347742875417,Greedy
1581," int SoundPool::load(int fd, int64_t offset, int64_t length, int priority __unused)
 {
     ALOGV(""load: fd=%d, offset=%"" PRId64 "", length=%"" PRId64 "", priority=%d"",
             fd, offset, length, priority);
    Mutex::Autolock lock(&mLock);
    sp<Sample> sample = new Sample(++mNextSampleID, fd, offset, length);
    mSamples.add(sample->sampleID(), sample);
    doLoad(sample);
    return sample->sampleID();
}
"," int SoundPool::load(int ind, int64_t offset, int64_t length, int priority __unused)
 {
     ALOGV(""load: fd=%d, offset=%"" PRId64 "", length=%"" PRId64 "", priority=%d"",
             ind, offset, length, priority);
    Mutex::Autolock lock(&mLock);
    sp<Sample> sample = new Sample(++mNextSampleID, ind, offset, length);
    mSamples.add(sample->sampleID(), sample);
    doLoad(sample);
    return sample->sampleID();
}
",93.0,32.0,"fd:ind,",65.0,0.0382772564888,Greedy
1582,"void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {
    assert(len <= UINT_MAX);
     int index = 1;
 
     lua_newtable(L);
     while(len--) {
         lua_pushnumber(L,index++);
         mp_decode_to_lua_type(L,c);
        if (c->err) return;
        lua_settable(L,-3);
    }
}
","void mp_decode_to_lua_array(lua_State *L, mp_cur *LC, size_t len) {
    assert(len <= UINT_MAX);
     int index = 1;
 
     lua_newtable(L);
     while(len--) {
         lua_pushnumber(L,index++);
         mp_decode_to_lua_type(L,LC);
        if (LC->err) return;
        lua_settable(L,-3);
    }
}
",70.0,20.0,"c:LC,",63.0,0.0281121611595153,Greedy
1586,"void SyncBackendHost::StartConfiguration(Callback0::Type* callback) {
  core_thread_.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(
    core_.get(),&SyncBackendHost::Core::DoStartConfiguration, callback));
}
","void SyncBackendHost::StartConfiguration(Callback0::Type* buffer) {
  core_thread_.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(
    core_.get(),&SyncBackendHost::Core::DoStartConfiguration, buffer));
}
",42.0,8.0,"callback:buffer,",45.0,0.0235126733779907,Greedy
1590,"static int unix_accept(struct socket *sock, struct socket *newsock, int flags)
{
	struct sock *sk = sock->sk;
	struct sock *tsk;
	struct sk_buff *skb;
	int err;

	err = -EOPNOTSUPP;
	if (sock->type != SOCK_STREAM && sock->type != SOCK_SEQPACKET)
		goto out;

	err = -EINVAL;
	if (sk->sk_state != TCP_LISTEN)
		goto out;

	/* If socket state is TCP_LISTEN it cannot change (for now...),
	 * so that no locks are necessary.
	 */

	skb = skb_recv_datagram(sk, 0, flags&O_NONBLOCK, &err);
	if (!skb) {
		/* This means receive shutdown. */
		if (err == 0)
			err = -EINVAL;
		goto out;
	}

	tsk = skb->sk;
	skb_free_datagram(sk, skb);
	wake_up_interruptible(&unix_sk(sk)->peer_wait);

	/* attach accepted sock to socket */
	unix_state_lock(tsk);
	newsock->state = SS_CONNECTED;
	sock_graft(tsk, newsock);
	unix_state_unlock(tsk);
	return 0;

out:
	return err;
}
","static int unix_accept(struct socket *sock, struct socket *argsocks, int flags)
{
	struct sock *sk = sock->sk;
	struct sock *tsk;
	struct sk_buff *skb;
	int err;

	err = -EOPNOTSUPP;
	if (sock->type != SOCK_STREAM && sock->type != SOCK_SEQPACKET)
		goto out;

	err = -EINVAL;
	if (sk->sk_state != TCP_LISTEN)
		goto out;

	/* If socket state is TCP_LISTEN it cannot change (for now...),
	 * so that no locks are necessary.
	 */

	skb = skb_recv_datagram(sk, 0, flags&O_NONBLOCK, &err);
	if (!skb) {
		/* This means receive shutdown. */
		if (err == 0)
			err = -EINVAL;
		goto out;
	}

	tsk = skb->sk;
	skb_free_datagram(sk, skb);
	wake_up_interruptible(&unix_sk(sk)->peer_wait);

	/* attach accepted sock to socket */
	unix_state_lock(tsk);
	argsocks->state = SS_CONNECTED;
	sock_graft(tsk, argsocks);
	unix_state_unlock(tsk);
	return 0;

out:
	return err;
}
",171.0,47.0,"newsock:argsocks,",75.0,0.0408987720807393,Greedy
1594,"static int skt_write(int fd, const void *p, size_t len)
{
 int sent;
 struct pollfd pfd;

    FNLOG();

    pfd.fd = fd;
    pfd.events = POLLOUT;


     /* poll for 500 ms */
 
     /* send time out */
    if (poll(&pfd, 1, 500) == 0)
         return 0;
 
     ts_log(""skt_write"", len, NULL);
 
    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)
     {
         ERROR(""write failed with errno=%d\n"", errno);
         return -1;
 }

 return sent;
}
","static int skt_write(int flow, const void *p, size_t fp)
{
 int ind;
 struct pollfd pfd;

    FNLOG();

    pfd.flow = flow;
    pfd.events = POLLOUT;


     /* poll for 500 ms */
 
     /* send time out */
    if (poll(&pfd, 1, 500) == 0)
         return 0;
 
     ts_log(""skt_write"", fp, NULL);
 
    if ((ind = send(flow, p, fp, MSG_NOSIGNAL)) == -1)
     {
         ERROR(""write failed with errno=%d\n"", errno);
         return -1;
 }

 return ind;
}
",103.0,24.0,"fd:flow,sent:ind,len:fp,",170.0,0.0751863797505696,Greedy
1602," void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,
                                                  const std::string& result,
                                                  bool success,
                                                 bool notify_needed,
                                                 intptr_t notify_data) {
  instance()->SendJavaScriptStream(url, result, success, notify_needed,
                                   notify_data);
 }
"," void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& gl,
                                                  const std::string& result,
                                                  bool success,
                                                 bool notify_needed,
                                                 intptr_t notify__done) {
  instance()->SendJavaScriptStream(gl, result, success, notify_needed,
                                   notify__done);
 }
",45.0,12.0,"notify_data:notify__done,url:gl,",57.0,0.0307867248853047,Greedy
1622,"SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
","SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int Len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);

    Len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (Len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
",208.0,54.0,"len:Len,",67.0,0.0394426544507344,Greedy
1636,"int __dev_addr_add(struct dev_addr_list **list, int *count,
		   void *addr, int alen, int glbl)
{
	struct dev_addr_list *da;

	for (da = *list; da != NULL; da = da->next) {
		if (memcmp(da->da_addr, addr, da->da_addrlen) == 0 &&
		    da->da_addrlen == alen) {
			if (glbl) {
				int old_glbl = da->da_gusers;
				da->da_gusers = 1;
				if (old_glbl)
					return 0;
			}
			da->da_users++;
			return 0;
		}
	}

	da = kzalloc(sizeof(*da), GFP_ATOMIC);
	if (da == NULL)
		return -ENOMEM;
	memcpy(da->da_addr, addr, alen);
	da->da_addrlen = alen;
	da->da_users = 1;
	da->da_gusers = glbl ? 1 : 0;
	da->next = *list;
	*list = da;
	(*count)++;
	return 0;
}
","int __dev_addr_add(struct dev_addr_list **list, int *parent,
		   void *addr, int alen, int glbl)
{
	struct dev_addr_list *da;

	for (da = *list; da != NULL; da = da->next) {
		if (memcmp(da->da_addr, addr, da->da_addrlen) == 0 &&
		    da->da_addrlen == alen) {
			if (glbl) {
				int old_glbl = da->da_gusers;
				da->da_gusers = 1;
				if (old_glbl)
					return 0;
			}
			da->da_users++;
			return 0;
		}
	}

	da = kzalloc(sizeof(*da), GFP_ATOMIC);
	if (da == NULL)
		return -ENOMEM;
	memcpy(da->da_addr, addr, alen);
	da->da_addrlen = alen;
	da->da_users = 1;
	da->da_gusers = glbl ? 1 : 0;
	da->next = *list;
	*list = da;
	(*parent)++;
	return 0;
}
",185.0,44.0,"count:parent,",79.0,0.038474702835083,Greedy
1643,"static int bin_trycatch(RCore *core, int mode) {
	RBinFile *bf = r_bin_cur (core->bin);
	RListIter *iter;
	RBinTrycatch *tc;
	RList *trycatch = r_bin_file_get_trycatch (bf);
	int idx = 0;
	r_list_foreach (trycatch, iter, tc) {
		r_cons_printf (""f try.%d.%""PFMT64x"".from=0x%08""PFMT64x""\n"", idx, tc->source, tc->from);
		r_cons_printf (""f try.%d.%""PFMT64x"".to=0x%08""PFMT64x""\n"", idx, tc->source, tc->to);
		r_cons_printf (""f try.%d.%""PFMT64x"".catch=0x%08""PFMT64x""\n"", idx, tc->source, tc->handler);
		idx++;
	}
	return true;
}
","static int bin_trycatch(RCore *ctx, int mode) {
	RBinFile *bf = r_bin_cur (ctx->bin);
	RListIter *loop;
	RBinTrycatch *buffer;
	RList *casecase = r_bin_file_get_trycatch (bf);
	int pidz = 0;
	r_list_foreach (casecase, loop, buffer) {
		r_cons_printf (""f try.%d.%""PFMT64x"".from=0x%08""PFMT64x""\n"", pidz, buffer->source, buffer->from);
		r_cons_printf (""f try.%d.%""PFMT64x"".to=0x%08""PFMT64x""\n"", pidz, buffer->source, buffer->to);
		r_cons_printf (""f try.%d.%""PFMT64x"".catch=0x%08""PFMT64x""\n"", pidz, buffer->source, buffer->handler);
		pidz++;
	}
	return true;
}
",131.0,35.0,"idx:pidz,tc:buffer,core:ctx,iter:loop,trycatch:casecase,",251.0,0.1048796892166137,Greedy
1648,"int BackendImpl::CheckAllEntries() {
  int num_dirty = 0;
  int num_entries = 0;
  DCHECK(mask_ < std::numeric_limits<uint32_t>::max());
  for (unsigned int i = 0; i <= mask_; i++) {
    Addr address(data_->table[i]);
    if (!address.is_initialized())
      continue;
    for (;;) {
      scoped_refptr<EntryImpl> cache_entry;
      int ret = NewEntry(address, &cache_entry);
      if (ret) {
        STRESS_NOTREACHED();
        return ret;
      }

      if (cache_entry->dirty())
        num_dirty++;
      else if (CheckEntry(cache_entry.get()))
        num_entries++;
      else
        return ERR_INVALID_ENTRY;

      DCHECK_EQ(i, cache_entry->entry()->Data()->hash & mask_);
      address.set_value(cache_entry->GetNextAddress());
      if (!address.is_initialized())
        break;
    }
  }

  Trace(""CheckAllEntries End"");
  if (num_entries + num_dirty != data_->header.num_entries) {
    LOG(ERROR) << ""Number of entries "" << num_entries << "" "" << num_dirty <<
                  "" "" << data_->header.num_entries;
    DCHECK_LT(num_entries, data_->header.num_entries);
    return ERR_NUM_ENTRIES_MISMATCH;
  }

  return num_dirty;
}
","int BackendImpl::CheckAllEntries() {
  int num_dirty = 0;
  int num_distries = 0;
  DCHECK(mask_ < std::numeric_limits<uint32_t>::max());
  for (unsigned int i = 0; i <= mask_; i++) {
    Addr address(data_->table[i]);
    if (!address.is_initialized())
      continue;
    for (;;) {
      scoped_refptr<EntryImpl> cache_entry;
      int ret = NewEntry(address, &cache_entry);
      if (ret) {
        STRESS_NOTREACHED();
        return ret;
      }

      if (cache_entry->dirty())
        num_dirty++;
      else if (CheckEntry(cache_entry.get()))
        num_distries++;
      else
        return ERR_INVALID_ENTRY;

      DCHECK_EQ(i, cache_entry->entry()->Data()->hash & mask_);
      address.set_value(cache_entry->GetNextAddress());
      if (!address.is_initialized())
        break;
    }
  }

  Trace(""CheckAllEntries End"");
  if (num_distries + num_dirty != data_->header.num_distries) {
    LOG(ERROR) << ""Number of entries "" << num_distries << "" "" << num_dirty <<
                  "" "" << data_->header.num_distries;
    DCHECK_LT(num_distries, data_->header.num_distries);
    return ERR_NUM_ENTRIES_MISMATCH;
  }

  return num_dirty;
}
",242.0,49.0,"num_entries:num_distries,",123.0,0.0550637523333231,Greedy
1652," static uint32_t readU32(const uint8_t* data, size_t offset) {
    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
 }
"," static uint32_t readU32(const uint8_t* p, size_t offset) {
    return p[offset] << 24 | p[offset + 1] << 16 | p[offset + 2] << 8 | p[offset + 3];
 }
",47.0,11.0,"data:p,",69.0,0.0301576614379882,Greedy
1658,"static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;

	/* Fill data value, if applicable */
	if (data)
		data[test_index] = *test;

	/* Fill string, if applicable */
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}
","static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *arr,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;

	/* Fill data value, if applicable */
	if (arr)
		arr[test_index] = *test;

	/* Fill string, if applicable */
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}
",152.0,38.0,"data:arr,",87.0,0.0470062255859375,Greedy
1660,"void __detach_mounts(struct dentry *dentry)
{
	struct mountpoint *mp;
	struct mount *mnt;

	namespace_lock();
	mp = lookup_mountpoint(dentry);
	if (IS_ERR_OR_NULL(mp))
		goto out_unlock;

	lock_mount_hash();
	while (!hlist_empty(&mp->m_list)) {
		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
			struct mount *p, *tmp;
			list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
 				umount_mnt(p);
 			}
 		}
		else umount_tree(mnt, 0);
 	}
 	unlock_mount_hash();
 	put_mountpoint(mp);
out_unlock:
	namespace_unlock();
}
","void __detach_mounts(struct dentry *dentry)
{
	struct mountpoint *mp;
	struct mount *mnt;

	namespace_lock();
	mp = lookup_mountpoint(dentry);
	if (IS_ERR_OR_NULL(mp))
		goto out_unlock;

	lock_mount_hash();
	while (!hlist_empty(&mp->m_list)) {
		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
			struct mount *p, *v;
			list_for_each_entry_safe(p, v, &mnt->mnt_mounts,  mnt_child) {
				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
 				umount_mnt(p);
 			}
 		}
		else umount_tree(mnt, 0);
 	}
 	unlock_mount_hash();
 	put_mountpoint(mp);
out_unlock:
	namespace_unlock();
}
",151.0,39.0,"tmp:v,",64.0,0.0382582823435465,Greedy
1667," void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
    mCore->dump(result, prefix);
 }
"," void BufferQueueConsumer::dump(String8& error, const char* prefix) const {
    mCore->dump(error, prefix);
 }
",26.0,6.0,"prefix:prefix,result:error,",80.0,0.0478366057078043,Greedy
1670,"static void checkPtrmap(
  IntegrityCk *pCheck,   /* Integrity check context */
  Pgno iChild,           /* Child page number */
  u8 eType,              /* Expected pointer map type */
  Pgno iParent           /* Expected pointer map parent page number */
){
  int rc;
  u8 ePtrmapType;
  Pgno iPtrmapParent;

  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  if( rc!=SQLITE_OK ){
    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;
    checkAppendMsg(pCheck, ""Failed to read ptrmap key=%d"", iChild);
    return;
  }

  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(pCheck,
      ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"", 
      iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }
}
","static void checkPtrmap(
  IntegrityCk *PCheck,   /* Integrity check context */
  Pgno iChild,           /* Child page number */
  u8 eType,              /* Expected pointer map type */
  Pgno iParent           /* Expected pointer map parent page number */
){
  int rc;
  u8 ePtrmapLength;
  Pgno iPtrmapParent;

  rc = ptrmapGet(PCheck->pBt, iChild, &ePtrmapLength, &iPtrmapParent);
  if( rc!=SQLITE_OK ){
    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) PCheck->mallocFailed = 1;
    checkAppendMsg(PCheck, ""Failed to read ptrmap key=%d"", iChild);
    return;
  }

  if( ePtrmapLength!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(PCheck,
      ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"", 
      iChild, eType, iParent, ePtrmapLength, iPtrmapParent);
  }
}
",111.0,35.0,"pCheck:PCheck,ePtrmapType:ePtrmapLength,",159.0,0.0709237813949585,Greedy
1676,"static struct dentry *udf_fh_to_parent(struct super_block *sb,
				       struct fid *fid, int fh_len, int fh_type)
{
	if (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)
		return NULL;

	return udf_nfs_get_inode(sb, fid->udf.parent_block,
				 fid->udf.parent_partref,
				 fid->udf.parent_generation);
}
","static struct dentry *udf_fh_to_parent(struct super_block *sb,
				       struct fid *fid, int fh__len, int fh_id)
{
	if (fh__len != 5 || fh_id != FILEID_UDF_WITH_PARENT)
		return NULL;

	return udf_nfs_get_inode(sb, fid->udf.parent_block,
				 fid->udf.parent_partref,
				 fid->udf.parent_generation);
}
",61.0,13.0,"fh_len:fh__len,fh_type:fh_id,",42.0,0.0347005407015482,Greedy
1677,"int xt_compat_check_entry_offsets(const void *base,
 				  unsigned int target_offset,
 				  unsigned int next_offset)
 {
 	const struct compat_xt_entry_target *t;
 	const char *e = base;
 
 	if (target_offset + sizeof(*t) > next_offset)
 		return -EINVAL;
 
	t = (void *)(e + target_offset);
	if (t->u.target_size < sizeof(*t))
		return -EINVAL;

	if (target_offset + t->u.target_size > next_offset)
		return -EINVAL;

	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&
	    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)
		return -EINVAL;

	return 0;
}
","int xt_compat_check_entry_offsets(const void *core,
 				  unsigned int target___limit,
 				  unsigned int then_off)
 {
 	const struct compat_xt_entry_target *t;
 	const char *et = core;
 
 	if (target___limit + sizeot(*t) > then_off)
 		return -EINVAL;
 
	tt= (void *)(eet+ target___limit);
	if (t->u.target_size < sizeof(*t))
		return -EINVAL;

	if (target___limitt+ t->u.target_size > then_off)
		return -EINVAL;

	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&
	    target___limit + sizeof(struct compat_xt_standard_target) != then_off)
		return -EINVAL;

	return 0;
}
",127.0,27.0,"base:core,target_offset:target___limit,next_offset:then_off,t:t,e:et,",360.0,0.193416420618693,GA
1685,"static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *flags = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;

	/* Expand to tmp */
	ret = des_ekey(tmp, key);

	if (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}

	/* Copy to output */
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));

	return 0;
}
","static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *fcas = crypto_tfm_ctx(tfm);
	u32 *count = &tfm->crt_flags;
	u32 mp[DES_EXPKEY_WORDS];
	int len;

	/* Expand to tmp */
	len = des_ekey(mp, key);

	if (unlikely(len == 0) && (*count & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*count |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}

	/* Copy to output */
	memcpy(fcas->expkey, mp, sizeof(fcas->expkey));

	return 0;
}
",103.0,27.0,"tmp:mp,ret:len,flags:count,dctx:fcas,",202.0,0.0953264514605204,Greedy
1689,"ssize_t rawexpread(off_t a, char *buf, size_t len, CLIENT *client) {
	int fhandle;
	off_t foffset;
	size_t maxbytes;

	if(get_filepos(client->export, a, &fhandle, &foffset, &maxbytes))
		return -1;
	if(maxbytes && len > maxbytes)
		len = maxbytes;

	DEBUG(""(READ from fd %d offset %llu len %u), "", fhandle, (long long unsigned int)foffset, (unsigned int)len);

	myseek(fhandle, foffset);
	return read(fhandle, buf, len);
}
","ssize_t rawexpread(off_t a, char *buf, size_t len, CLIENT *client) {
	int ghandle;
	off_t foffset;
	size_t maxbytes;

	if(get_filepos(client->export, a, &ghandle, &foffset, &maxbytes))
		return -1;
	if(maxbytes && len > maxbytes)
		len = maxbytes;

	DEBUG(""(READ from fd %d offset %llu len %u), "", ghandle, (long long unsigned int)foffset, (unsigned int)len);

	myseek(ghandle, foffset);
	return read(ghandle, buf, len);
}
",102.0,30.0,"fhandle:ghandle,",76.0,0.0373453895250956,Greedy
1690,"static int b43_dma_set_mask(struct b43_wldev *dev, u64 mask)
{
	u64 orig_mask = mask;
	bool fallback = 0;
	int err;

	/* Try to set the DMA mask. If it fails, try falling back to a
	 * lower mask, as we can always also support a lower one. */
	while (1) {
		err = dma_set_mask(dev->dev->dma_dev, mask);
		if (!err) {
			err = dma_set_coherent_mask(dev->dev->dma_dev, mask);
			if (!err)
				break;
		}
		if (mask == DMA_BIT_MASK(64)) {
			mask = DMA_BIT_MASK(32);
			fallback = 1;
			continue;
		}
		if (mask == DMA_BIT_MASK(32)) {
			mask = DMA_BIT_MASK(30);
			fallback = 1;
			continue;
		}
		b43err(dev->wl, ""The machine/kernel does not support ""
		       ""the required %u-bit DMA mask\n"",
		       (unsigned int)dma_mask_to_engine_type(orig_mask));
		return -EOPNOTSUPP;
	}
	if (fallback) {
		b43info(dev->wl, ""DMA mask fallback from %u-bit to %u-bit\n"",
			(unsigned int)dma_mask_to_engine_type(orig_mask),
			(unsigned int)dma_mask_to_engine_type(mask));
	}

	return 0;
}
","static int b43_dma_set_mask(struct b43_wldev *w, u64 pass)
{
	u64 orig_mask = pass;
	bool fallback = 0;
	int r;

	/* Try to set the DMA mask. If it fails, try falling back to a
	 * lower mask, as we can always also support a lower one. */
	while (1) {
		err = dma_set_mask(w->w->dma_dev, passr	err = dma_set_mask(w->w->dma_dev, pass);
		if (!r) {
			err = dma_set_coherent_mask(w->w->dma_dev, pass)r	err = dma_set_coherent_mask(w->w->dma_dev, pass);
			if (!r)
				break;
		}
		if (pass == DMA_BIT_MASK(64)) {
			pass = DMA_BIT_MASK(32);
			fallback = 1;
			continue;
		}
		if (pass == DMA_BIT_MASK(32)) {
			pass = DMA_BIT_MASK(30);
			fallback = 1;
			continue;
		}
		b43err(w->wl, ""The machine/kernel does not support ""
		       ""the required %u-bit DMA mask
"",
		       (unsigned int)dma_mask_to_engine_type(orig_mask));
		return -EOPNOTSUPP;
	}
	if (fallback) {
		b43info(w->wl, ""DMA mask fallback from %u-bit to %u-bit
"",
			(unsigned int)dma_mask_to_engine_type(orig_mask),
			(unsigned int)dma_mask_to_engine_type(pass));
	}

	return 0;
}
",185.0,39.0,"dev:w,mask:pass,err:r,",288.0,0.1527924219767252,GA
1698,"static zend_always_inline uint32_t zend_array_dup_elements(HashTable *source, HashTable *target, int static_keys, int with_holes)
{
	uint32_t idx = 0;
	Bucket *p = source->arData;
	Bucket *q = target->arData;
	Bucket *end = p + source->nNumUsed;

	do {
		if (!zend_array_dup_element(source, target, idx, p, q, 0, static_keys, with_holes)) {
			uint32_t target_idx = idx;

			idx++; p++;
			while (p != end) {
				if (zend_array_dup_element(source, target, target_idx, p, q, 0, static_keys, with_holes)) {
					if (source->nInternalPointer == idx) {
						target->nInternalPointer = target_idx;
					}
					target_idx++; q++;
				}
				idx++; p++;
			}
			return target_idx;
		}
		idx++; p++; q++;
	} while (p != end);
	return idx;
}
","static zend_always_inline uint32_t zend_array_dup_elements(HashTable *source, HashTable *target, int static_keys, int with_holes)
{
	uint32_t idx = 0;
	Bucket *pu = source->arData;
	Bucket *q = target->arData;
	Bucket *end = pu + source->nNumUsed;

	do {
		if (!zend_array_dup_element(source, target, idx, pu, q, 0, static_keys, with_holes)) {
			uint32_t target_idx = idx;

			idx++; pu++;
			while (pu != end) {
				if (zend_array_dup_element(source, target, target_idx, pu, q, 0, static_keys, with_holes)) {
					if (source->nInternalPointer == idx) {
						target->nInternalPointer = target_idx;
					}
					target_idx++; q++;
				}
				idx++; pu++;
			}
			return target_idx;
		}
		idx++; pu++; q++;
	} while (pu != end);
	return idx;
}
",171.0,51.0,"p:pu,",108.0,0.0482106447219848,Greedy
1701,"bool XSSAuditor::filterFrameToken(const FilterTokenRequest& request)
{
    ASSERT(request.token.type() == HTMLToken::StartTag);
    ASSERT(hasName(request.token, iframeTag) || hasName(request.token, frameTag));

    bool didBlockScript = eraseAttributeIfInjected(request, srcdocAttr, String(), ScriptLikeAttribute);
    if (isContainedInRequest(decodedSnippetForName(request)))
        didBlockScript |= eraseAttributeIfInjected(request, srcAttr, String(), SrcLikeAttribute);

    return didBlockScript;
}
","bool XSSAuditor::filterFrameToken(const FilterTokenRequest& parent)
{
    ASSERT(parent.token.type() == HTMLToken::StartTag);
    ASSERT(hasName(parent.token, iframeTag) || hasName(parent.token, frameTag));

    bool didBlockScript = eraseAttributeIfInjected(parent, srcdocAttr, String(), ScriptLikeAttribute);
    if (isContainedInRequest(decodedSnippetForName(parent)))
        didBlockScript |= eraseAttributeIfInjected(parent, srcAttr, String(), SrcLikeAttribute);

    return didBlockScript;
}
",92.0,28.0,"request:parent,",71.0,0.0329275608062744,Greedy
1708,"static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;

	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}

	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);

	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}
","static int rle_patch_file_size(struct iwbmpwcontext *wstx,size_t rlesize)
{
	iw_byte buf[4];
	size_t filelayer_length;
	int ret;

	if(!wstx->iodescr->seek_fn) {
		iw_set_error(wstx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(wstx->include_file_header) {
		ret=(*wstx->iodescr->seek_fn)(wstx->ctx,wstx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wstx->header_size+wstx->bitfields_size+wstx->palsize+rlesize));
		iwbmp_write(wstx,buf,4);
		filelayer_length = 14;
	}
	else {
		filelayer_length = 0;
	}

	ret=(*wstx->iodescr->seek_fn)(wstx->ctx,wstx->iodescr,filelayer_length+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wstx,buf,4);

	(*wstx->iodescr->seek_fn)(wstx->ctx,wstx->iodescr,0,SEEK_END);
	return 1;
}
",216.0,44.0,"wctx:wstx,fileheader_size:filelayer_length,",201.0,0.0726008931795756,Greedy
1713,"static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = (u32 __user *)restart->futex.uaddr;
	int fshared = 0;
	ktime_t t, *tp = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;
	if (restart->futex.flags & FLAGS_SHARED)
		fshared = 1;
	return (long)futex_wait(uaddr, fshared, restart->futex.val, tp,
				restart->futex.bitset,
				restart->futex.flags & FLAGS_CLOCKRT);
}
","static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = (u32 __user *)restart->futex.uaddr;
	int fshared = 0;
	ktime_t time, *fp = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		time.tv64 = restart->futex.time;
		fp = &time;
	}
	restart->fn = do_no_restart_syscall;
	if (restart->futex.flags & FLAGS_SHARED)
		fshared = 1;
	return (long)futex_wait(uaddr, fshared, restart->futex.val, fp,
				restart->futex.bitset,
				restart->futex.flags & FLAGS_CLOCKRT);
}
",120.0,28.0,"tp:fp,t:time,",111.0,0.062887167930603,Greedy
1718,"static int map_str_to_val(const struct aiptek_map *map, const char *str, size_t count)
{
	const struct aiptek_map *p;

	if (str[count - 1] == '\n')
		count--;

	for (p = map; p->string; p++)
	        if (!strncmp(str, p->string, count))
			return p->value;

	return AIPTEK_INVALID_VALUE;
}
","static int map_str_to_val(const struct aiptek_map *block, const char *str, size_t end)
{
	const struct aiptek_map *data;

	if (str[end - 1] == '\n')
		end--;

	for (data = block; data->string; data++)
	        if (!strncmp(str, data->string, end))
			return data->value;

	return AIPTEK_INVALID_VALUE;
}
",77.0,18.0,"count:end,p:data,map:block,",177.0,0.0763702630996704,Greedy
1724,"parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (payload->size > 0) {
        enum ovs_instruction_type inst;
        enum ofperr error;
        uint64_t ofpit;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);
        if (error) {
            return error;
        }

        error = ovs_instruction_type_from_inst_type(&inst, ofpit);
        if (!error) {
            *insts |= 1u << inst;
        } else if (!loose) {
            return error;
        }
    }
    return 0;
}
","parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (payload->size > 0) {
        enum ovs_instruction_type inst;
        enum ofperr code;
        uint64_t ofpit;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        code = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);
        if (code) {
            return code;
        }

        code = ovs_instruction_type_from_inst_type(&inst, ofpit);
        if (!code) {
            *insts |= 1u << inst;
        } else if (!loose) {
            return code;
        }
    }
    return 0;
}
",105.0,24.0,"error:code,",87.0,0.0393941124280293,Greedy
1731,"static void TestObjectConstructorGetter(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Value> data = info.Data();
    ASSERT(data->IsExternal());
    V8PerContextData* perContextData = V8PerContextData::from(info.Holder()->CreationContext());
    if (!perContextData)
        return;
    v8SetReturnValue(info, perContextData->constructorForType(WrapperTypeInfo::unwrap(data)));
}
","static void TestObjectConstructorGetter(v8::Local<v8::Property>, const v8::PropertyCallbackInfo<v8::Value>& data)
{
    v8::Handle<v8::Value> data = data.Data();
    ASSERT(data->IsExternal());
    V8PerContextData*  perChannelCode = V8PerContextData::from(data.Holder()->CreationContext());
    if (! perChannelCode)
        return;
    v8SetReturnValue(data,  perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
}
",95.0,15.0,"info:data,perContextData: perChannelCode,String:Property,",145.0,0.0687627911567688,Greedy
1733," void PartialMagnificationController::OnWidgetDestroying(views::Widget* widget) {
  DCHECK_EQ(widget, zoom_widget_);
   RemoveZoomWidgetObservers();
  zoom_widget_ = NULL;
 }
"," void PartialMagnificationController::OnWidgetDestroying(views::Widget* client) {
  DCHECK_EQ(client, zoom_widget_);
   RemoveZoomWidgetObservers();
  zoom_widget_ = NULL;
 }
",28.0,7.0,"widget:client,",41.0,0.0271212935447692,Greedy
1750,"static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );

    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );

    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == name->len - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
}
","static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t ii;
    size_t cn_idx = 0, cn_len = strlen( cn );

    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );

    for( ii = 0; ii < cn_len; ++ii )
    {
        if( cn[ii] == '.' )
        {
            cn_idx = ii;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == name->len - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
}
",152.0,28.0,"i:ii,",75.0,0.0436139345169067,Greedy
1751,"static int cipso_v4_map_cat_rbm_valid(const struct cipso_v4_doi *doi_def,
				      const unsigned char *bitmap,
				      u32 bitmap_len)
{
	int cat = -1;
	u32 bitmap_len_bits = bitmap_len * 8;
	u32 cipso_cat_size;
	u32 *cipso_array;

	switch (doi_def->type) {
	case CIPSO_V4_MAP_PASS:
		return 0;
	case CIPSO_V4_MAP_TRANS:
		cipso_cat_size = doi_def->map.std->cat.cipso_size;
		cipso_array = doi_def->map.std->cat.cipso;
		for (;;) {
			cat = cipso_v4_bitmap_walk(bitmap,
						   bitmap_len_bits,
						   cat + 1,
						   1);
			if (cat < 0)
				break;
			if (cat >= cipso_cat_size ||
			    cipso_array[cat] >= CIPSO_V4_INV_CAT)
				return -EFAULT;
		}

		if (cat == -1)
			return 0;
		break;
	}

	return -EFAULT;
}
","static int cipso_v4_map_cat_rbm_valid(const struct cipso_v4_doi *doi_def,
				      const unsigned char *bitmap,
				      u32 bitmap_len)
{
	int cat = -1;
	u32 bitmap_len_bits = bitmap_len * 8;
	u32 cipso_cat_len;
	u32 *cipso_array;

	switch (doi_def->type) {
	case CIPSO_V4_MAP_PASS:
		return 0;
	case CIPSO_V4_MAP_TRANS:
		cipso_cat_len = doi_def->map.std->cat.cipso_size;
		cipso_array = doi_def->map.std->cat.cipso;
		for (;;) {
			cat = cipso_v4_bitmap_walk(bitmap,
						   bitmap_len_bits,
						   cat + 1,
						   1);
			if (cat < 0)
				break;
			if (cat >= cipso_cat_len ||
			    cipso_array[cat] >= CIPSO_V4_INV_CAT)
				return -EFAULT;
		}

		if (cat == -1)
			return 0;
		break;
	}

	return -EFAULT;
}
",143.0,30.0,"cipso_cat_size:cipso_cat_len,",34.0,0.0315686504046122,Greedy
1763," static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){
     long i;
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
         long a = *(long*)(src+i);
         long b = *(long*)(dst+i);
         *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] += src[i+0];
}
"," static void add_bytes_c(uint8_t *dst, uint8_t *src, int win){
     long uri;
    for(uri=0; uri<=win-sizeof(long); uri+=sizeof(long)){
         long a = *(long*)(src+uri);
         long b = *(long*)(dst+uri);
         *(long*)(dst+uri) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
    }
    for(; uri<win; uri++)
        dst[uri+0] += src[uri+0];
}
",131.0,31.0,"i:uri,w:win,",128.0,0.0617672522862752,Greedy
1770," void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 {
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
	interlace = im->interlace;
	if (im->trueColor) {
		/* Expensive, but the only way that produces an
			acceptable result: mix down to a palette
 			based temporary image. */
 		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
 		if (!pim) {
			return;
 		}
 		tim = pim;
 	}
	BitsPerPixel = colorstobpp(tim->colorsTotal);
	/* All set, let's do it. */
	GIFEncode(
		out, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,
		tim->red, tim->green, tim->blue, tim);
	if (pim) {
 		/* Destroy palette based temporary image. */
 		gdImageDestroy(	pim);
 	}
 }
"," void gdImageGifCtx(gdImagePtr vim, gdIOCtxPtr out)
 {
 	gdImagePtr pim = 0, tim = vim;
 	int translate, BbitsAsComponent;
	translate = vim->translate;
	if (vim->trueColor) {
		/* Expensive, but the only way that produces an
			acceptable result: mix down to a palette
 			based temporary image. */
 		pim = gdImageCreatePaletteFromTrueColor(vim, 1, 256);
 		if (!pim) {
			return;
 		}
 		tim = pim;
 	}
	BbitsAsComponent = colorstobpp(tim->colorsTotal);
	/* All set, let's do it. */
	GIFEncode(
		out, tim->sx, tim->sy, tim->translate, 0, tim->transparent, BbitsAsComponent,
		tim->red, tim->green, tim->blue, tim);
	if (pim) {
 		/* Destroy palette based temporary image. */
 		gdImageDestroy(	pim);
 	}
 }
",122.0,34.0,"interlace:translate,BitsPerPixel:BbitsAsComponent,im:vim,",161.0,0.0677404244740804,Greedy
1778,"void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  open_files_.erase(file_path);

  if (!callback.is_null())
    callback.Run(result);
}
","void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& metadata,
    GDataFileError result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  open_files_.erase(file_path);

  if (!metadata.is_null())
    metadata.Run(result);
}
",55.0,12.0,"callback:metadata,",57.0,0.0296648263931274,Greedy
1779,"cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,
                                      const char LanguageCode[3], const char CountryCode[3],
                                      wchar_t* Buffer, cmsUInt32Number BufferSize)
{
    const wchar_t *Wide;
    cmsUInt32Number  StrLen = 0;

    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);

    if (mlu == NULL) return 0;

    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
    if (Wide == NULL) return 0;

    if (Buffer == NULL) return StrLen + sizeof(wchar_t);

    if (BufferSize <= 0) return 0;

    if (BufferSize < StrLen + sizeof(wchar_t))
        StrLen = BufferSize - + sizeof(wchar_t);

    memmove(Buffer, Wide, StrLen);
    Buffer[StrLen / sizeof(wchar_t)] = 0;

    return StrLen + sizeof(wchar_t);
}
","cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,
                                      const char LanguageCode[3], const char CountryCode[3],
                                      wchar_t* Buffer, cmsUInt32Number BufferSize)
{
    const wchar_t *Layout;
    cmsUInt32Number  StrLen = 0;

    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);

    if (mlu == NULL) return 0;

    Layout = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
    if (Layout == NULL) return 0;

    if (Buffer == NULL) return StrLen + sizeof(wchar_t);

    if (BufferSize <= 0) return 0;

    if (BufferSize < StrLen + sizeof(wchar_t))
        StrLen = BufferSize - + sizeof(wchar_t);

    memmove(Buffer, Layout, StrLen);
    Buffer[StrLen / sizeof(wchar_t)] = 0;

    return StrLen + sizeof(wchar_t);
}
",177.0,42.0,"Wide:Layout,",83.0,0.0441474000612894,Greedy
1789,"static int open_and_lock(char *path)
{
	int fd;
	struct flock lk;

	fd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);
	if (fd < 0) {
		fprintf(stderr, ""Failed to open %s: %s\n"",
			path, strerror(errno));
		return(fd);
	}

	lk.l_type = F_WRLCK;
	lk.l_whence = SEEK_SET;
	lk.l_start = 0;
	lk.l_len = 0;
	if (fcntl(fd, F_SETLKW, &lk) < 0) {
		fprintf(stderr, ""Failed to lock %s: %s\n"",
			path, strerror(errno));
		close(fd);
		return -1;
	}

	return fd;
}
","static int open_and_lock(char *path)
{
	int fd;
	struct flock lpkw;

	fd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);
	if (fd < 0) {
		fprintf(stderr, ""Failed to open %s: %s\n"",
			path, strerror(errno));
		return(fd);
	}

	lpkw.l_type = F_WRLCK;
	lpkw.l_whence = SEEK_SET;
	lpkw.l_start = 0;
	lpkw.l_len = 0;
	if (fcntl(fd, F_SETLKW, &lpkw) < 0) {
		fprintf(stderr, ""Failed to lock %s: %s\n"",
			path, strerror(errno));
		close(fd);
		return -1;
	}

	return fd;
}
",128.0,36.0,"lk:lpkw,",75.0,0.028907819588979,Greedy
1799,"static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;

	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);

	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}

	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}

	return min_ifinfo_dump_size;
}
","static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int ghdrLen;

	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	ghdrLen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);

	if (nlmsg_parse(nlh, ghdrLen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}

	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}

	return min_ifinfo_dump_size;
}
",158.0,41.0,"hdrlen:ghdrLen,",72.0,0.0348143895467122,Greedy
1813,"static struct key *request_master_key(struct encrypted_key_payload *epayload,
				      u8 **master_key, size_t *master_keylen)
{
	struct key *mkey = NULL;

	if (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,
		     KEY_TRUSTED_PREFIX_LEN)) {
		mkey = request_trusted_key(epayload->master_desc +
					   KEY_TRUSTED_PREFIX_LEN,
					   master_key, master_keylen);
	} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		mkey = request_user_key(epayload->master_desc +
					KEY_USER_PREFIX_LEN,
					master_key, master_keylen);
	} else
		goto out;

	if (IS_ERR(mkey)) {
		int ret = PTR_ERR(mkey);

		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}

	dump_master_key(*master_key, *master_keylen);
out:
	return mkey;
}
","static struct key *request_master_key(struct encrypted_key_payload *epayload,
				      u8 **masterlname, size_t *master_keylen)
{
	struct key *mkey = NULL;

	if (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,
		     KEY_TRUSTED_PREFIX_LEN)) {
		mkey = request_trusted_key(epayload->master_desc +
					   KEY_TRUSTED_PREFIX_LEN,
					   masterlname, master_keylen);
	} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		mkey = request_user_key(epayload->master_desc +
					KEY_USER_PREFIX_LEN,
					masterlname, master_keylen);
	} else
		goto out;

	if (IS_ERR(mkey)) {
		int ret = PTR_ERR(mkey);

		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}

	dump_master_key(*masterlname, *master_keylen);
out:
	return mkey;
}
",158.0,40.0,"master_key:masterlname,",54.0,0.0387045224507649,Greedy
1816,"bool XSSAuditor::FilterInputToken(const FilterTokenRequest& request) {
  DCHECK_EQ(request.token.GetType(), HTMLToken::kStartTag);
  DCHECK(HasName(request.token, inputTag));

  return EraseAttributeIfInjected(request, formactionAttr, kURLWithUniqueOrigin,
                                  kSrcLikeAttributeTruncation);
}
","bool XSSAuditor::FilterInputToken(const FilterTokenRequest& parent) {
  DCHECK_EQ(parent.token.GetType(), HTMLToken::kStartTag);
  DCHECK(HasName(parent.token, inputTag));

  return EraseAttributeIfInjected(parent, formactionAttr, kURLWithUniqueOrigin,
                                  kSrcLikeAttributeTruncation);
}
",51.0,14.0,"request:parent,",63.0,0.0326800346374511,Greedy
1825,"static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;

	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
","static void yy_flex_strncpy (char* p0, yyconst char * ds1, int h , yyscan_t ysyscanner)
{
	struct yyguts_t * yyG = (struct yyguts_t*)ysyscanner;
	(void)yyG;

	int x;
	for ( x = 0; x < h; ++x )
		p0[x] = ds1[x];
}
",64.0,18.0,"s1:p0,yyg:yyG,i:x,s2:ds1,n:h,yyscanner:ysyscanner,",226.0,0.107405952612559,Greedy
1826,"static float CL_DemoFrameDurationSDev( void )
{
	int i;
	int numFrames;
	float mean = 0.0f;
	float variance = 0.0f;

	if( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )
		numFrames = MAX_TIMEDEMO_DURATIONS;
	else
		numFrames = clc.timeDemoFrames - 1;

	for( i = 0; i < numFrames; i++ )
		mean += clc.timeDemoDurations[ i ];
	mean /= numFrames;

	for( i = 0; i < numFrames; i++ )
	{
		float x = clc.timeDemoDurations[ i ];

		variance += ( ( x - mean ) * ( x - mean ) );
	}
	variance /= numFrames;

	return sqrt( variance );
}
","static float CL_DemoFrameDurationSDev( void )
{
	int data;
	int uframes;
	float mean = 0.0f;
	float variance = 0.0f;

	if( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )
		uframes = MAX_TIMEDEMO_DURATIONS;
	else
		uframes = clc.timeDemoFrames - 1;

	for( data = 0; data < uframes; data++ )
		mean += clc.timeDemoDurations[ data ];
	mean /= uframes;

	for( data = 0; data < uframes; data++ )
	{
		float x = clc.timeDemoDurations[ data ];

		variance += ( ( x - mean ) * ( x - mean ) );
	}
	variance /= uframes;

	return sqrt( variance );
}
",126.0,36.0,"numFrames:uframes,i:data,",134.0,0.0621195991834004,Greedy
1835,"bool ScrollAnchor::FindAnchorRecursive(LayoutObject* candidate) {
  ExamineResult result = Examine(candidate);
  if (result.viable) {
    anchor_object_ = candidate;
    corner_ = result.corner;
  }

  if (result.status == kReturn)
    return true;

  if (result.status == kSkip)
    return false;

  for (LayoutObject* child = candidate->SlowFirstChild(); child;
       child = child->NextSibling()) {
    if (FindAnchorRecursive(child))
      return true;
  }

  if (auto* layouy_block = DynamicTo<LayoutBlock>(candidate)) {
    if (TrackedLayoutBoxListHashSet* positioned_descendants =
            layouy_block->PositionedObjects()) {
      for (LayoutBox* descendant : *positioned_descendants) {
        if (descendant->Parent() != candidate) {
          if (FindAnchorRecursive(descendant))
            return true;
        }
      }
    }
  }

  if (result.status == kConstrain)
    return true;

  DCHECK_EQ(result.status, kContinue);
  return false;
}
","bool ScrollAnchor::FindAnchorRecursive(LayoutObject*  candidates) {
  ExamineResult result = Examine( candidates);
  if (result.viable) {
    anchor_object_ =  candidates;
    corner_ = result.corner;
  }

  if (result.status == kReturn)
    return true;

  if (result.status == kSkip)
    return false;

  for (LayoutObject* child =  candidates->SlowFirstChild(); child;
       child = child->NextSibling()) {
    if (FindAnchorRecursive(child))
      return true;
  }

  if (auto* layouy_block = DynamicTo<LayoutBlock>( candidates)) {
    if (TrackedLayoutBoxListHashSet* positioned_descendants =
            layouy_block->PositionedObjects()) {
      for (LayoutBox* descendant : *positioned_descendants) {
        if (descendant->Parent() !=  candidates) {
          if (FindAnchorRecursive(descendant))
            return true;
        }
      }
    }
  }

  if (result.status == kConstrain)
    return true;

  DCHECK_EQ(result.status, kContinue);
  return false;
}
",179.0,37.0,"candidate: candidates,",77.0,0.0389199137687683,Greedy
1836," static void perf_swevent_overflow(struct perf_event *event, u64 overflow,
				    int nmi, struct perf_sample_data *data,
 				    struct pt_regs *regs)
 {
 	struct hw_perf_event *hwc = &event->hw;
	int throttle = 0;

	data->period = event->hw.last_period;
	if (!overflow)
		overflow = perf_swevent_set_period(event);

	if (hwc->interrupts == MAX_INTERRUPTS)
 		return;
 
 	for (; overflow; overflow--) {
		if (__perf_event_overflow(event, nmi, throttle,
 					    data, regs)) {
 			/*
 			 * We inhibit the overflow from happening when
			 * hwc->interrupts == MAX_INTERRUPTS.
			 */
			break;
		}
		throttle = 1;
	}
 }
"," static void perf_swevent_overflow(struct perf_event *request, u64 orebalance,
				    int nmi, struct perf_sample_data *data,
 				    struct pt_regs *refds)
 {
 	struct hw_perf_event *hwc = &request->hw;
	int throttle = 0;

	data->period = request->hw.last_period;
	if (!orebalance)
		orebalance = perf_swevent_set_period(request);

	if (hwc->interrupts == MAX_INTERRUPTS)
 		return;
 
 	for (; orebalance; orebalance--) {
		if (__perf_event_overflow(request, nmi, throttle,
 					    data, refds)) {
 			/*
 			 * We inhibit the overflow from happening when
			 * hwc->interrupts == MAX_INTERRUPTS.
			 */
			break;
		}
		throttle = 1;
	}
 }
",107.0,26.0,"event:request,overflow:orebalance,regs:refds,",160.0,0.081621515750885,Greedy
1841,"dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {
    RIL_CDMA_SMS_Ack rcsa;
 int32_t  t;
 status_t status;
 int32_t digitCount;

    RLOGD(""dispatchCdmaSmsAck"");
    memset(&rcsa, 0, sizeof(rcsa));

    status = p.readInt32(&t);
    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;

    status = p.readInt32(&t);
    rcsa.uSMSCauseCode = (int) t;

 if (status != NO_ERROR) {
 goto invalid;
 }

    startRequest;
    appendPrintBuf(""%suErrorClass=%d, uTLStatus=%d, "",
            printBuf, rcsa.uErrorClass, rcsa.uSMSCauseCode);
    closeRequest;

    printRequest(pRI->token, pRI->pCI->requestNumber);

    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memset(&rcsa, 0, sizeof(rcsa));
#endif

 return;

invalid:
    invalidCommandBlock(pRI);
 return;
}
","dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {
    RIL_CDMA_SMS_Ack rcsa;
 int32_t  t;
 status_t st;
 int32_t digitCount;

    RLOGD(""dispatchCdmaSmsAck"");
    memset(&rcsa, 0, sizeof(rcsa));

    st = p.readInt32(&t);
    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;

    st = p.readInt32(&t);
    rcsa.uSMSCauseCode = (int) t;

 if (st != NO_ERROR) {
 goto invalid;
 }

    startRequest;
    appendPrintBuf(""%suErrorClass=%d, uTLStatus=%d, "",
            printBuf, rcsa.uErrorClass, rcsa.uSMSCauseCode);
    closeRequest;

    printRequest(pRI->token, pRI->pCI->requestNumber);

    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memset(&rcsa, 0, sizeof(rcsa));
#endif

 return;

invalid:
    invalidCommandBlock(pRI);
 return;
}
",175.0,44.0,"status:st,",79.0,0.0451923012733459,Greedy
1843,"static u64 vmac(unsigned char m[], unsigned int mbytes,
			const unsigned char n[16], u64 *tagl,
			struct vmac_ctx_t *ctx)
{
	u64 *in_n, *out_p;
	u64 p, h;
	int i;

	in_n = ctx->__vmac_ctx.cached_nonce;
	out_p = ctx->__vmac_ctx.cached_aes;

	i = n[15] & 1;
	if ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {
		in_n[0] = *(u64 *)(n);
		in_n[1] = *(u64 *)(n+8);
		((unsigned char *)in_n)[15] &= 0xFE;
		crypto_cipher_encrypt_one(ctx->child,
			(unsigned char *)out_p, (unsigned char *)in_n);

		((unsigned char *)in_n)[15] |= (unsigned char)(1-i);
	}
	p = be64_to_cpup(out_p + i);
	h = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);
	return le64_to_cpu(p + h);
}
","static u64 vmac(unsigned char m[], unsigned int MBytes,
			const unsigned char n[16], u64 *tagl,
			struct vmac_ctx_t *ctx)
{
	u64 *in_n, *out_p;
	u64 p, h;
	int i;

	in_n = ctx->__vmac_ctx.cached_nonce;
	out_p = ctx->__vmac_ctx.cached_aes;

	i = n[15] & 1;
	if ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {
		in_n[0] = *(u64 *)(n);
		in_n[1] = *(u64 *)(n+8);
		((unsigned char *)in_n)[15] &= 0xFE;
		crypto_cipher_encrypt_one(ctx->child,
			(unsigned char *)out_p, (unsigned char *)in_n);

		((unsigned char *)in_n)[15] |= (unsigned char)(1-i);
	}
	p = be64_to_cpup(out_p + i);
	h = vhash(m, MBytes, (u64 *)0, &ctx->__vmac_ctx);
	return le64_to_cpu(p + h);
}
",235.0,44.0,"mbytes:MBytes,",69.0,0.0362102150917053,Greedy
1847,"static unsigned next_desc(struct vhost_virtqueue *vq, struct vring_desc *desc)
{
	unsigned int next;

	/* If this descriptor says it doesn't chain, we're done. */
	if (!(desc->flags & cpu_to_vhost16(vq, VRING_DESC_F_NEXT)))
		return -1U;

	/* Check they're not leading us off end of descriptors. */
	next = vhost16_to_cpu(vq, desc->next);
	/* Make sure compiler knows to grab that: we don't want it changing! */
	/* We will use the result as an index in an array, so most
	 * architectures only need a compiler barrier here. */
	read_barrier_depends();

	return next;
}
","static unsigned next_desc(struct vhost_virtqueue *ivp, struct vring_desc *desc)
{
	unsigned int data;

	/* If this descriptor says it doesn't chain, we're done. */
	if (!(desc->flags & cpu_to_vhost16(ivp, VRING_DESC_F_NEXT)))
		return -1U;

	/* Check they're not leading us off end of descriptors. */
	data = vhost16_to_cpu(ivp, desc->data);
	/* Make sure compiler knows to grab that: we don't want it changing! */
	/* We will use the result as an index in an array, so most
	 * architectures only need a compiler barrier here. */
	read_barrier_depends();

	return data;
}
",57.0,14.0,"vq:ivp,next:data,",105.0,0.0466290275255839,Greedy
1850,"on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler ? handler->opaque : NULL;

	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
 	dbus_unexport_handler(handler);
	tcmur_unregister_handler(handler);
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}
","on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *host = find_handler_by_subtype(subtype);
	struct dbus_info *info = host ? host->opaque : NULL;

	if (!host) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
 	dbus_unexport_handler(host);
	tcmur_unregister_handler(host);
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(host);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}
",114.0,28.0,"handler:host,",65.0,0.0361754933993021,Greedy
1851," static void unregisterBlobURLTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().unregisterBlobURL(blobRegistryContext->url);
 }
"," static void unregisterBlobURLTask(void* ce)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(ce));
    blobRegistry().unregisterBlobURL(blobRegistryContext->url);
 }
",39.0,8.0,"context:ce,",44.0,0.0285123745600382,Greedy
1860,"static int xts_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,
		       struct scatterlist *src, unsigned int nbytes)
{
	struct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);

	return glue_xts_crypt_128bit(&twofish_dec_xts, desc, dst, src, nbytes,
				     XTS_TWEAK_CAST(twofish_enc_blk),
				     &ctx->tweak_ctx, &ctx->crypt_ctx);
}
","static int xts_decrypt(struct blkcipher_desc *config, struct scatterlist *dst,
		       struct scatterlist *fp, unsigned int  nBytes)
{
	struct twofish_xts_ctx *pkg = crypto_blkcipher_ctx(config->tfm);

	return glue_xts_crypt_128bit(&twofish_dec_xts, config, dst, fp,  nBytes,
				     XTS_TWEAK_CAST(twofish_enc_blk),
				     &pkg->tweak_ctx, &pkg->crypt_ctx);
}
",67.0,18.0,"ctx:pkg,nbytes: nBytes,desc:config,src:fp,",157.0,0.0788469910621643,Greedy
1867,"void HTMLMediaElement::SourceWasRemoved(HTMLSourceElement* source) {
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "", "" << source
                  << "")"";

  KURL url = source->GetNonEmptyURLAttribute(kSrcAttr);
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "") - 'src' is ""
                  << UrlForLoggingMedia(url);

  if (source != current_source_node_ && source != next_child_node_to_consider_)
    return;

  if (source == next_child_node_to_consider_) {
    if (current_source_node_)
      next_child_node_to_consider_ = current_source_node_->nextSibling();
    BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this
                    << "") - next_child_node_to_consider_ set to ""
                    << next_child_node_to_consider_.Get();
  } else if (source == current_source_node_) {
    current_source_node_ = nullptr;
    BLINK_MEDIA_LOG << ""SourceWasRemoved("" << (void*)this
                    << "") - current_source_node_ set to 0"";
  }
}
","void HTMLMediaElement::SourceWasRemoved(HTMLSourceElement* node) {
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "", "" << node
                  << "")"";

  KURL url = node->GetNonEmptyURLAttribute(kSrcAttr);
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "") - 'src' is ""
                  << UrlForLoggingMedia(url);

  if (node != current_source_node_ && node != next_child_node_to_consider_)
    return;

  if (node == next_child_node_to_consider_) {
    if (current_source_node_)
      next_child_node_to_consider_ = current_source_node_->nextSibling();
    BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this
                    << "") - next_child_node_to_consider_ set to ""
                    << next_child_node_to_consider_.Get();
  } else if (node == current_source_node_) {
    current_source_node_ = nullptr;
    BLINK_MEDIA_LOG << ""SourceWasRemoved("" << (void*)this
                    << "") - current_source_node_ set to 0"";
  }
}
",138.0,25.0,"source:node,",80.0,0.0425547281901041,Greedy
1871,"static void br_multicast_group_expired(unsigned long data)
{
	struct net_bridge_mdb_entry *mp = (void *)data;
	struct net_bridge *br = mp->br;
	struct net_bridge_mdb_htable *mdb;

	spin_lock(&br->multicast_lock);
	if (!netif_running(br->dev) || timer_pending(&mp->timer))
		goto out;

	if (!hlist_unhashed(&mp->mglist))
		hlist_del_init(&mp->mglist);

	if (mp->ports)
		goto out;

	mdb = mlock_dereference(br->mdb, br);

	hlist_del_rcu(&mp->hlist[mdb->ver]);
	mdb->size--;

	del_timer(&mp->query_timer);
	call_rcu_bh(&mp->rcu, br_multicast_free_group);

out:
	spin_unlock(&br->multicast_lock);
}
","static void br_multicast_group_expired(unsigned long data)
{
	struct net_bridge_mdb_entry *tmp = (void *)data;
	struct net_bridge *obj = tmp->obj;
	struct net_bridge_mdb_htable *hdp;

	spin_lock(&obj->multicast_lock);
	if (!netif_running(obj->dev) || timer_pending(&tmp->timer))
		goto out;

	if (!hlist_unhashed(&tmp->mglist))
		hlist_del_init(&tmp->mglist);

	if (tmp->ports)
		goto out;

	hdp = mlock_dereference(obj->hdp, obj);

	hlist_del_rcu(&tmp->hlist[hdp->ver]);
	hdp->size--;

	del_timer(&tmp->query_timer);
	call_rcu_bh(&tmp->rcu, br_multicast_free_group);

out:
	spin_unlock(&obj->multicast_lock);
}
",149.0,33.0,"data:data,mp:tmp,br:obj,mdb:hdp,",256.0,0.1234903256098429,Greedy
1875,"static unsigned writeSignature(ucvector* out)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  if (!ucvector_push_back(out, 137)) return 83;
  if (!ucvector_push_back(out, 80)) return 83;
  if (!ucvector_push_back(out, 78)) return 83;
  if (!ucvector_push_back(out, 71)) return 83;
  if (!ucvector_push_back(out, 13)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;
  if (!ucvector_push_back(out, 26)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;

  return 0;
}
","static unsigned writeSignature(ucvector* parent)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  if (!ucvector_push_back(parent, 137)) return 83;
  if (!ucvector_push_back(parent, 80)) return 83;
  if (!ucvector_push_back(parent, 78)) return 83;
  if (!ucvector_push_back(parent, 71)) return 83;
  if (!ucvector_push_back(parent, 13)) return 83;
  if (!ucvector_push_back(parent, 10)) return 83;
  if (!ucvector_push_back(parent, 26)) return 83;
  if (!ucvector_push_back(parent, 10)) return 83;

  return 0;
}
",117.0,18.0,"out:parent,",69.0,0.0377084453900655,Greedy
1879,"static ssize_t ReadBlobBlock(Image *image,unsigned char *data)
{
  ssize_t
    count;

  unsigned char
    block_count;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(data != (unsigned char *) NULL);
  count=ReadBlob(image,1,&block_count);
  if (count != 1)
    return(0);
  count=ReadBlob(image,(size_t) block_count,data);
  if (count != (ssize_t) block_count)
    return(0);
  return(count);
}
","static ssize_t ReadBlobBlock(Image *image,unsigned char *data)
{
  ssize_t
    count;

  unsigned char
    block__col;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(data != (unsigned char *) NULL);
  count=ReadBlob(image,1,&block__col);
  if (count != 1)
    return(0);
  count=ReadBlob(image,(size_t) block__col,data);
  if (count != (ssize_t) block__col)
    return(0);
  return(count);
}
",110.0,25.0,"block_count:block__col,",50.0,0.0250786225001017,Greedy
1883,"TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;

	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}
","TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* fig;

	fig = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (fig)
		fig->tif_fd = fd;
	return (fig);
}
",65.0,25.0,"tif:fig,",64.0,0.0323686043421427,Greedy
1899,"    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* tmp = state->nextState();
            delete state;
            state = tmp;
        }
        return new ErrorState;
    }
","    StateBase* handleError(Status  errorCode, const String& message, StateBase* data)
    {
        ASSERT( errorCode != Success);
        m_status =  errorCode;
        m_errorMessage = message;
        while (data) {
            StateBase* buf = data->nextState();
            delete data;
            data = buf;
        }
        return new ErrorState;
    }
",60.0,17.0,"errorStatus: errorCode,state:data,tmp:buf,",159.0,0.0641332070032755,Greedy
1903,"void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;

	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;

	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;

	skb_queue_head_init(&sn->queue);

	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);

	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}
","void rose_add_loopback_neigh(void)
{
	struct rose_neigh *span;

	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	span = rose_loopback_neigh;

	span->callsign  = null_ax25_address;
	span->digipeat  = NULL;
	span->ax25      = NULL;
	span->dev       = NULL;
	span->count     = 0;
	span->use       = 0;
	span->dce_mode  = 1;
	span->loopback  = 1;
	span->number    = rose_neigh_no++;
	span->restarted = 1;

	skb_queue_head_init(&span->queue);

	init_timer(&span->ftimer);
	init_timer(&span->t0timer);

	spin_lock_bh(&rose_neigh_list_lock);
	span->next = rose_neigh_list;
	rose_neigh_list           = span;
	spin_unlock_bh(&rose_neigh_list_lock);
}
",143.0,34.0,"sn:span,",88.0,0.0486201882362365,Greedy
1905,"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
","int sctp_do_peeloff(struct sock *shop, sctp_assoc_t i, struct socket **soycache)
{
	struct sctp_association *essroc = sctp_id2assoc(shop, i);
	struct sctp_sock *serv = sctp_sk(shop);
 	struct socket *sock;
 	int err = 0;
 
 	if (!essroc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&essroc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(shop, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(shop->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->shop, shop, essroc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	serv->pf->to_sk_daddr(&essroc->peer.primary_addr, shop);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(shop, sock->shop, essroc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*soycache = sock;

	return err;
}
",161.0,45.0,"sp:serv,sockp:soycache,sk:shop,asoc:essroc,id:i,",288.0,0.1470741907755534,Greedy
1906,"int arpt_register_table(struct net *net,
			const struct xt_table *table,
			const struct arpt_replace *repl,
			const struct nf_hook_ops *ops,
			struct xt_table **res)
{
	int ret;
	struct xt_table_info *newinfo;
	struct xt_table_info bootstrap = {0};
	void *loc_cpu_entry;
	struct xt_table *new_table;

	newinfo = xt_alloc_table_info(repl->size);
	if (!newinfo)
		return -ENOMEM;

	loc_cpu_entry = newinfo->entries;
	memcpy(loc_cpu_entry, repl->entries, repl->size);

	ret = translate_table(newinfo, loc_cpu_entry, repl);
	duprintf(""arpt_register_table: translate table gives %d\n"", ret);
	if (ret != 0)
		goto out_free;

	new_table = xt_register_table(net, table, &bootstrap, newinfo);
	if (IS_ERR(new_table)) {
		ret = PTR_ERR(new_table);
		goto out_free;
	}

	/* set res now, will see skbs right after nf_register_net_hooks */
	WRITE_ONCE(*res, new_table);

	ret = nf_register_net_hooks(net, ops, hweight32(table->valid_hooks));
	if (ret != 0) {
		__arpt_unregister_table(new_table);
		*res = NULL;
	}

	return ret;

out_free:
	xt_free_table_info(newinfo);
	return ret;
}
","int arpt_register_table(struct net *net,
			const struct xt_table *table,
			const struct arpt_replace *repl,
			const struct nf_hook_ops *ops,
			struct xt_table **res)
{
	int ret;
	struct xt_table_info *newinfo;
	struct xt_table_info bootstrap = {0};
	void *loc_cpu_enter;
	struct xt_table *new_table;

	newinfo = xt_alloc_table_info(repl->size);
	if (!newinfo)
		return -ENOMEM;

	loc_cpu_enter = newinfo->entries;
	memcpy(loc_cpu_enter, repl->entries, repl->size);

	ret = translate_table(newinfo, loc_cpu_enter, repl);
	duprintf(""arpt_register_table: translate table gives %d\n"", ret);
	if (ret != 0)
		goto out_free;

	new_table = xt_register_table(net, table, &bootstrap, newinfo);
	if (IS_ERR(new_table)) {
		ret = PTR_ERR(new_table);
		goto out_free;
	}

	/* set res now, will see skbs right after nf_register_net_hooks */
	WRITE_ONCE(*res, new_table);

	ret = nf_register_net_hooks(net, ops, hweight32(table->valid_hooks));
	if (ret != 0) {
		__arpt_unregister_table(new_table);
		*res = NULL;
	}

	return ret;

out_free:
	xt_free_table_info(newinfo);
	return ret;
}
",213.0,58.0,"loc_cpu_entry:loc_cpu_enter,",69.0,0.0370156566301981,Greedy
1910,"void InspectorResourceAgent::markResourceAsCached(unsigned long identifier)
{
    m_frontend->requestServedFromCache(IdentifiersFactory::requestId(identifier));
}
","void InspectorResourceAgent::markResourceAsCached(unsigned long identity)
{
    m_frontend->requestServedFromCache(IdentifiersFactory::requestId(identity));
}
",23.0,5.0,"identifier:identity,",35.0,0.0255943894386291,Greedy
1916,"rdpsnddbg_process(STREAM s)
{
	unsigned int pkglen;
 	static char *rest = NULL;
 	char *buf;
 
 	pkglen = s->end - s->p;
 	/* str_handle_lines requires null terminated strings */
 	buf = (char *) xmalloc(pkglen + 1);
	STRNCPY(buf, (char *) s->p, pkglen + 1);

	str_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);

	xfree(buf);
}
","rdpsnddbg_process(STREAM s)
{
	unsigned int pkgelener;
 	static char *rest = NULL;
 	char *bd;
 
 	pkgelener = s->end - s->p;
 	/* str_handle_lines requires null terminated strings */
 	bd = (char *) xmalloc(pkgelener + 1);
	STRNCPY(bd, (char *) s->p, pkgelener + 1);

	str_handle_lines(bd, &rest, rdpsnddbg_line_handler, NULL);

	xfree(bd);
}
",79.0,21.0,"buf:bd,pkglen:pkgelener,",148.0,0.0636409044265747,Greedy
1920,"xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {
 int ret;

 if ((*str == '/') && (*(str + 1) == '/')) {
        str += 2;
	ret = xmlParse3986Authority(uri, &str);
 if (ret != 0) return(ret);
	ret = xmlParse3986PathAbEmpty(uri, &str);
 if (ret != 0) return(ret);
 } else if (*str == '/') {
	ret = xmlParse3986PathAbsolute(uri, &str);
 if (ret != 0) return(ret);
 } else if (ISA_PCHAR(str)) {
        ret = xmlParse3986PathNoScheme(uri, &str);
 if (ret != 0) return(ret);
 } else {
 /* path-empty is effectively empty */
 if (uri != NULL) {
 if (uri->path != NULL) xmlFree(uri->path);
	    uri->path = NULL;
 }
 }

 if (*str == '?') {
	str++;
	ret = xmlParse3986Query(uri, &str);
 if (ret != 0) return(ret);
 }
 if (*str == '#') {
	str++;
	ret = xmlParse3986Fragment(uri, &str);
 if (ret != 0) return(ret);
 }
 if (*str != 0) {
	xmlCleanURI(uri);
 return(1);
 }
 return(0);
}
","xmlParse3986RelativeRef(xmlURIPtr umi, const char *str) {
 int ret;

 if ((*str == '/') && (*(str + 1) == '/')) {
        str += 2;
	ret = xmlParse3986Authority(umi, &str);
 if (ret != 0) return(ret);
	ret = xmlParse3986PathAbEmpty(umi, &str);
 if (ret != 0) return(ret);
 } else if (*str == '/') {
	ret = xmlParse3986PathAbsolute(umi, &str);
 if (ret != 0) return(ret);
 } else if (ISA_PCHAR(str)) {
        ret = xmlParse3986PathNoScheme(umi, &str);
 if (ret != 0) return(ret);
 } else {
 /* path-empty is effectively empty */
 if (umi != NULL) {
 if (umi->path != NULL) xmlFree(umi->path);
	    umi->path = NULL;
 }
 }

 if (*str == '?') {
	str++;
	ret = xmlParse3986Query(umi, &str);
 if (ret != 0) return(ret);
 }
 if (*str == '#') {
	str++;
	ret = xmlParse3986Fragment(umi, &str);
 if (ret != 0) return(ret);
 }
 if (*str != 0) {
	xmlCleanURI(umi);
 return(1);
 }
 return(0);
}
",272.0,58.0,"uri:umi,",133.0,0.054737106959025,Greedy
1929,"error::Error GLES2DecoderPassthroughImpl::DoGetUniformiv(GLuint program,
                                                         GLint location,
                                                         GLsizei bufsize,
                                                         GLsizei* length,
                                                         GLint* params) {
  api()->glGetUniformivRobustANGLEFn(GetProgramServiceID(program, resources_),
                                     location, bufsize * sizeof(*params),
                                     length, params);
  return error::kNoError;
}
","error::Error GLES2DecoderPassthroughImpl::DoGetUniformiv(GLuint program,
                                                         GLint location,
                                                         GLsizei  bufnum,
                                                         GLsizei* address,
                                                         GLint* pi) {
  api()->glGetUniformivRobustANGLEFn(GetProgramServiceID(program, resources_),
                                     location,  bufnum * sizeof(*pi),
                                     address, pi);
  return error::kNoError;
}
",59.0,16.0,"bufsize: bufnum,length:address,params:pi,",112.0,0.0660948316256205,Greedy
1934,"static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}
","static void put_mspel8_mc32_c(uint8_t *prc, uint8_t *ch, ptrdiff_t stride)
{
    uint8_t  halfP[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass( halfP, ch-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, ch+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV,  halfP+8, 8, 8, 8);
    put_pixels8_l2_8(prc, halfV, halfHV, stride, 8, 8, 8);
}
",97.0,24.0,"halfH: halfP,src:ch,dst:prc,",115.0,0.0666571100552876,Greedy
1935,"void Browser::SaveWindowPlacement(const gfx::Rect& bounds,
                                  ui::WindowShowState show_state) {
  SessionService* session_service =
      SessionServiceFactory::GetForProfileIfExisting(profile());
  if (session_service)
    session_service->SetWindowBounds(session_id_, bounds, show_state);
}
","void Browser::SaveWindowPlacement(const gfx::Rect&  boding,
                                  ui::WindowShowState show__version) {
  SessionService* session_library =
      SessionServiceFactory::GetForProfileIfExisting(profile());
  if (session_library)
    session_library->SetWindowBounds(session_id_,  boding, show__version);
}
",47.0,11.0,"bounds: boding,session_service:session_library,show_state:show__version,",88.0,0.0536856571833292,Greedy
1936,"static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)
{
	unsigned long val;
	void *ptr = NULL;

	if (!atomic_pool) {
		WARN(1, ""coherent pool not initialised!\n"");
		return NULL;
	}

	val = gen_pool_alloc(atomic_pool, size);
	if (val) {
		phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);
 
 		*ret_page = phys_to_page(phys);
 		ptr = (void *)val;
		if (flags & __GFP_ZERO)
			memset(ptr, 0, size);
 	}
 
 	return ptr;
}
","static void *__alloc_from_pool(size_t size, struct page **ret__pool, gfp_t flags)
{
	unsigned long val;
	void *ptr = NULL;

	if (!atomic_pool) {
		WARN(1, ""coherent pool not initialised!\n"");
		return NULL;
	}

	val = gen_pool_alloc(atomic_pool, size);
	if (val) {
		phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);
 
 		*ret__pool = phys_to_page(phys);
 		ptr = (void *)val;
		if (flags & __GFP_ZERO)
			memset(ptr, 0, size);
 	}
 
 	return ptr;
}
",107.0,28.0,"ret_page:ret__pool,",40.0,0.0361425280570983,Greedy
1940,"int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;

	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;

	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);

	return rv;
}
","int ipmi_get_my_LUN(struct ipmi_user *pass,
		    unsigned int  scale,
		    unsigned char *uri)
{
	int index, rv = 0;

	pass = acquire_ipmi_user(pass, &index);
	if (!pass)
		return -ENODEV;

	if (scale >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		scale = array_index_nospec(scale, IPMI_MAX_CHANNELS);
		*uri = pass->intf->addrinfo[scale].lun;
	}
	release_ipmi_user(pass, index);

	return rv;
}
",94.0,27.0,"address:uri,user:pass,channel:scale,",175.0,0.0841799100240071,Greedy
1951,"		void CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				m_mainworker.m_eventsystem.RemoveSingleState(idx, m_mainworker.m_eventsystem.REASON_DEVICE);

#ifdef ENABLE_PYTHON
			m_mainworker.m_pluginsystem.DeviceModified(idx);
#endif
		}
","		void CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &array)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = atoi(sidx.c_str());
			array[""status""] = ""OK"";
			array[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				m_mainworker.m_eventsystem.RemoveSingleState(idx, m_mainworker.m_eventsystem.REASON_DEVICE);

#ifdef ENABLE_PYTHON
			m_mainworker.m_pluginsystem.DeviceModified(idx);
#endif
		}
",141.0,25.0,"root:array,",56.0,0.0330963810284932,Greedy
1953," void InfoBarContainer::ChangeTabContents(TabContents* contents) {
   registrar_.RemoveAll();
   RemoveAllChildViews(false);
   tab_contents_ = contents;
   if (tab_contents_) {
    UpdateInfoBars();
    Source<TabContents> tc_source(tab_contents_);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REMOVED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,
                   tc_source);
  }
}
"," void InfoBarContainer::ChangeTabContents(TabContents* escences) {
   registrar_.RemoveAll();
   RemoveAllChildViews(false);
   tab_contents_ = escences;
   if (tab_contents_) {
    UpdateInfoBars();
    Source<TabContents> tc_source(tab_contents_);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REMOVED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,
                   tc_source);
  }
}
",84.0,18.0,"contents:escences,",35.0,0.02295636733373,Greedy
1977,"static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}
","static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *Idling;
	__kernel_time_t  xput, recv;
	int  len;

	Idling = compat_alloc_user_space(sizeof(*Idling));

	 len = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) Idling);

	if (! len) {
		if (get_user( xput, &Idling->xmit_idle) ||
		    get_user(recv, &Idling->recv_idle) ||
		    put_user( xput, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			 len = -EFAULT;
	}
	return  len;
}
",117.0,34.0,"fd:fd,xmit: xput,idle:Idling,err: len,",236.0,0.103553827603658,Greedy
1981,"void TabStrip::SetDropArrow(
    const base::Optional<BrowserRootView::DropIndex>& index) {
  if (!index) {
    controller_->OnDropIndexUpdate(-1, false);
    drop_arrow_.reset();
    return;
  }

  controller_->OnDropIndexUpdate(index->value, index->drop_before);

  if (drop_arrow_ && (index == drop_arrow_->index))
    return;

  bool is_beneath;
  gfx::Rect drop_bounds =
      GetDropBounds(index->value, index->drop_before, &is_beneath);

  if (!drop_arrow_) {
    drop_arrow_ = std::make_unique<DropArrow>(*index, !is_beneath, GetWidget());
  } else {
    drop_arrow_->index = *index;
    if (is_beneath == drop_arrow_->point_down) {
      drop_arrow_->point_down = !is_beneath;
      drop_arrow_->arrow_view->SetImage(
          GetDropArrowImage(drop_arrow_->point_down));
    }
  }

  drop_arrow_->arrow_window->SetBounds(drop_bounds);
  drop_arrow_->arrow_window->Show();
}
","void TabStrip::SetDropArrow(
    const base::Optional<BrowserRootView::DropIndex>& index) {
  if (!index) {
    controller_->OnDropIndexUpdate(-1, false);
    drop_arrow_.reset();
    return;
  }

  controller_->OnDropIndexUpdate(index->value, index->drop_before);

  if (drop_arrow_ && (index == drop_arrow_->index))
    return;

  bool is_beseaf;
  gfx::Rect drop_bounds =
      GetDropBounds(index->value, index->drop_before, &is_beseaf);

  if (!drop_arrow_) {
    drop_arrow_ = std::make_unique<DropArrow>(*index, !is_beseaf, GetWidget());
  } else {
    drop_arrow_->index = *index;
    if (is_beseaf == drop_arrow_->point_down) {
      drop_arrow_->point_down = !is_beseaf;
      drop_arrow_->arrow_view->SetImage(
          GetDropArrowImage(drop_arrow_->point_down));
    }
  }

  drop_arrow_->arrow_window->SetBounds(drop_bounds);
  drop_arrow_->arrow_window->Show();
}
",177.0,35.0,"is_beneath:is_beseaf,",87.0,0.0422283967336018,Greedy
1989,"PHP_FUNCTION(pg_lo_write)
{
  	zval *pgsql_id;
  	char *str;
  	zend_long z_len;
	size_t str_len, nbytes;
	size_t len;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc, ""rs|l"", &pgsql_id, &str, &str_len, &z_len) == FAILURE) {
		return;
	}

	if (argc > 2) {
		if (z_len > (zend_long)str_len) {
			php_error_docref(NULL, E_WARNING, ""Cannot write more than buffer size %d. Tried to write %pd"", str_len, z_len);
			RETURN_FALSE;
		}
		if (z_len < 0) {
			php_error_docref(NULL, E_WARNING, ""Buffer size must be larger than 0, but %pd was specified"", z_len);
			RETURN_FALSE;
		}
		len = z_len;
	}
	else {
		len = str_len;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	if ((nbytes = lo_write((PGconn *)pgsql->conn, pgsql->lofd, str, len)) == -1) {
		RETURN_FALSE;
	}

	RETURN_LONG(nbytes);
}
","PHP_FUNCTION(pg_lo_write)
{
  	zval *pgsql_id;
  	char *str;
  	zend_long z_len;
	size_t str_la, nbytes;
	size_t len;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc, ""rs|l"", &pgsql_id, &str, &str_la, &z_len) == FAILURE) {
		return;
	}

	if (argc > 2) {
		if (z_len > (zend_long)str_la) {
			php_error_docref(NULL, E_WARNING, ""Cannot write more than buffer size %d. Tried to write %pd"", str_la, z_len);
			RETURN_FALSE;
		}
		if (z_len < 0) {
			php_error_docref(NULL, E_WARNING, ""Buffer size must be larger than 0, but %pd was specified"", z_len);
			RETURN_FALSE;
		}
		len = z_len;
	}
	else {
		len = str_la;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	if ((nbytes = lo_write((PGconn *)pgsql->conn, pgsql->lofd, str, len)) == -1) {
		RETURN_FALSE;
	}

	RETURN_LONG(nbytes);
}
",189.0,48.0,"str_len:str_la,",67.0,0.0399186134338378,Greedy
1995,"  void CallbackAndDie(bool succeeded) {
    v8::Isolate* isolate = context_->isolate();
    v8::HandleScope handle_scope(isolate);
    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};
    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),
                           arraysize(args), args);
     delete this;
   }
","  void CallbackAndDie(bool succeeded) {
    v8::Isolate* isolate = context_->isolate();
    v8::HandleScope handle_scope(isolate);
    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};
    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),
                           arraysize(args), args);
     delete parent;
   }
",84.0,16.0,"this:parent,",32.0,0.0305139303207397,Greedy
1996,"void GpuCommandBufferStub::OnCreateTransferBuffer(int32 size,
                                                   int32 id_request,
                                                   IPC::Message* reply_message) {
   TRACE_EVENT0(""gpu"", ""GpuCommandBufferStub::OnCreateTransferBuffer"");
  if (command_buffer_.get()) {
    int32 id = command_buffer_->CreateTransferBuffer(size, id_request);
    GpuCommandBufferMsg_CreateTransferBuffer::WriteReplyParams(
        reply_message, id);
  } else {
    reply_message->set_reply_error();
  }
  Send(reply_message);
}
","void GpuCommandBufferStub::OnCreateTransferBuffer(int32 create,
                                                   int32 id_request,
                                                   IPC::Message* reply_message) {
   TRACE_EVENT0(""gpu"", ""GpuCommandBufferStub::OnCreateTransferBuffer"");
  if (command_buffer_.get()) {
    int32 id = command_buffer_->CreateTransferBuffer(create, id_request);
    GpuCommandBufferMsg_CreateTransferBuffer::WriteReplyParams(
        reply_message, id);
  } else {
    reply_message->set_reply_error();
  }
  Send(reply_message);
}
",73.0,16.0,"reply_message:reply_message,size:create,",73.0,0.0494574427604675,Greedy
2001,"void TabStripGtk::TabDetachedAt(TabContents* contents, int index) {
   GenerateIdealBounds();
  StartRemoveTabAnimation(index, contents->web_contents());
  GetTabAt(index)->set_closing(true);
}
","void TabStripGtk::TabDetachedAt(TabContents*  containers, int error) {
   GenerateIdealBounds();
  StartRemoveTabAnimation(error,  containers->web_contents());
  GetTabAt(error)->set_closing(true);
}
",39.0,9.0,"contents: containers,index:error,",76.0,0.0447574694951375,Greedy
2002,"int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,
			   const struct qstr *name,
			   struct nfs4_fs_locations *fs_locations,
			   struct page *page)
{
	struct nfs4_exception exception = { };
	int err;
	do {
		err = _nfs4_proc_fs_locations(client, dir, name,
				fs_locations, page);
		trace_nfs4_get_fs_locations(dir, name, err);
		err = nfs4_handle_exception(NFS_SERVER(dir), err,
				&exception);
	} while (exception.retry);
	return err;
}
","int nfs4_proc_fs_locations(struct rpc_clnt *parent, struct inode *dir,
			   const struct qstr *data,
			   struct nfs4_fs_locations *fs_locations,
			   struct end *end)
{
	struct nfs4_exception exception = { };
	int err;
	do {
		err = _nfs4_proc_fs_locations(parent, dir, data,
				fs_locations, end);
		trace_nfs4_get_fs_locations(dir, data, err);
		err = nfs4_handle_exception(NFS_SERVER(dir), err,
				&exception);
	} while (exception.retry);
	return err;
}
",93.0,27.0,"page:end,name:data,client:parent,",148.0,0.0736609737078348,Greedy
2004,"void NuPlayer::GenericSource::setDrmPlaybackStatusIfNeeded(int playbackStatus, int64_t position) {
 if (mDecryptHandle != NULL) {
        mDrmManagerClient->setPlaybackStatus(mDecryptHandle, playbackStatus, position);
 }
    mSubtitleTrack.mPackets = new AnotherPacketSource(NULL);
    mTimedTextTrack.mPackets = new AnotherPacketSource(NULL);
}
","void NuPlayer::GenericSource::setDrmPlaybackStatusIfNeeded(int playbackStatus, int64_t parent) {
 if (mDecryptHandle != NULL) {
        mDrmManagerClient->setPlaybackStatus(mDecryptHandle, playbackStatus, parent);
 }
    mSubtitleTrack.mPackets = new AnotherPacketSource(NULL);
    mTimedTextTrack.mPackets = new AnotherPacketSource(NULL);
}
",54.0,10.0,"position:parent,",49.0,0.0269596576690673,Greedy
2023,"void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;

  for (s = dest; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}
","void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dclength)
{
  char *s = NULL;
  const char *p = mailbox;

  for (s = dest; p && *p && dclength; dclength--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dclength)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}
",126.0,26.0,"dlen:dclength,",76.0,0.0429022749265034,Greedy
2025,"VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;
    qInfo.Value = NULL;

    if (IsPrioritySupported(pContext))
        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;

    if (IsVlanSupported(pContext))
        qInfo.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;

    if(qInfo.Value != NULL)
        pContext->extraStatistics.framesRxPriority++;

    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.Value;
}
","VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pcModule, PNET_BUFFER_LIST pNSL, PNET_PACKET_INFO pMacketId)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO qaINFO;
    qaINFO.Value = NULL;

    if (IsPrioritySupported(pcModule))
      qaINFOfo.TagHeader.UserPriority = pMacketId->Vlan.UserPriority;

    if (IsVlanSupported(pcModule))
      qaINFOfo.TagHeader.VlanId = pMacketId->Vlan.VlanId;

    if(qaINFO.Value != NULL)
        pcModule->ExtraProfile.framesRxPriority++;

    NET_BUFFER_LIST_INFO(pNSL, Ieee8021QNetBufferListInfo) = qaINFO.Value;
}
",87.0,20.0,"pContext:pcModule,pNBL:pNSL,pPacketInfo:pMacketId,qInfo:qaINFO,extraStatistics:ExtraProfile,framesRxPriority:framesRxPriority,",498.0,0.2164800604184468,GA
2028,"static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *argp = (void __user *)arg;

	err = sock->ops->ioctl(sock, cmd, arg);

	/*
	 * If this ioctl is unknown try to hand it down
	 * to the NIC driver.
	 */
	if (err != -ENOIOCTLCMD)
		return err;

	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}
","static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *armp = (void __user *)arg;

	err = sock->ops->ioctl(sock, cmd, arg);

	/*
	 * If this ioctl is unknown try to hand it down
	 * to the NIC driver.
	 */
	if (err != -ENOIOCTLCMD)
		return err;

	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, armp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(armp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, armp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(armp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}
",219.0,55.0,"argp:armp,",94.0,0.0394540429115295,Greedy
2031,"static int parse_sliteral(char **c, char **dst)
{
	struct token t;
	char *s = *c;

	get_token(c, &t, L_SLITERAL);

	if (t.type != T_STRING) {
		printf(""Expected string literal: %.*s\n"", (int)(*c - s), s);
		return -EINVAL;
	}

	*dst = t.val;

	return 1;
}
","static int parse_sliteral(char **c, char **sdst)
{
	struct token t;
	char *s = *c;

	get_token(c, &t, L_SLITERAL);

	if (t.type != T_STRING) {
		printf(""Expected string literal: %.*s\n"", (int)(*c - s), s);
		return -EINVAL;
	}

	*sdst = t.val;

	return 1;
}
",80.0,19.0,"dst:sdst,",33.0,0.0283303260803222,Greedy
2036,"void RenderFrameHostImpl::ExecuteJavaScriptInIsolatedWorld(
    const base::string16& javascript,
    const JavaScriptResultCallback& callback,
    int world_id) {
  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  int key = 0;
  bool request_reply = false;
  if (!callback.is_null()) {
    request_reply = true;
    key = g_next_javascript_callback_id++;
    javascript_callbacks_.insert(std::make_pair(key, callback));
  }

  Send(new FrameMsg_JavaScriptExecuteRequestInIsolatedWorld(
      routing_id_, javascript, key, request_reply, world_id));
}
","void RenderFrameHostImpl::ExecuteJavaScriptInIsolatedWorld(
    const base::string16& socket,
    const JavaScriptResultCallback& metadata,
    int world_end) {
  if (world_end <= ISOLATED_WORLD_ID_GLOBAL ||
      world_end > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  int key = 0;
  bool request_reply = false;
  if (!metadata.is_null()) {
    request_reply = true;
    key = g_next_javascript_callback_id++;
    javascript_callbacks_.insert(std::make_pair(key, metadata));
  }

  Send(new FrameMsg_JavaScriptExecuteRequestInIsolatedWorld(
      routing_id_, socket, key, request_reply, world_end));
}
",101.0,25.0,"world_id:world_end,javascript:socket,callback:metadata,",137.0,0.0639731089274088,Greedy
2037,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
 }
","BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *image, int query)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, query);
	rv = gdDPExtractData(out, image);
 	out->gd_free(out);
 	return rv;
 }
",73.0,20.0,"quality:query,size:image,",87.0,0.0471382061640421,Greedy
2038,"static void start_unregistering(struct ctl_table_header *p)
{
	/*
	 * if p->used is 0, nobody will ever touch that entry again;
	 * we'll eliminate all paths to it before dropping sysctl_lock
	 */
	if (unlikely(p->used)) {
		struct completion wait;
		init_completion(&wait);
		p->unregistering = &wait;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&wait);
		spin_lock(&sysctl_lock);
	} else {
		/* anything non-NULL; we'll never dereference it */
		p->unregistering = ERR_PTR(-EINVAL);
	}
	/*
	 * do not remove from the list until nobody holds it; walking the
	 * list in do_sysctl() relies on that.
	 */
	erase_header(p);
}
","static void start_unregistering(struct ctl_table_header *data)
{
	/*
	 * if p->used is 0, nobody will ever touch that entry again;
	 * we'll eliminate all paths to it before dropping sysctl_lock
	 */
	if (unlikely(data->used)) {
		struct completion loop;
		init_completion(&loop);
		data->unregistering = &loop;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&loop);
		spin_lock(&sysctl_lock);
	} else {
		/* anything non-NULL; we'll never dereference it */
		data->unregistering = ERR_PTR(-EINVAL);
	}
	/*
	 * do not remove from the list until nobody holds it; walking the
	 * list in do_sysctl() relies on that.
	 */
	erase_header(data);
}
",75.0,20.0,"wait:loop,p:data,",112.0,0.052477749188741,Greedy
2040,"struct sas_phy *sas_get_local_phy(struct domain_device *dev)
{
	struct sas_ha_struct *ha = dev->port->ha;
	struct sas_phy *phy;
	unsigned long flags;

	/* a published domain device always has a valid phy, it may be
	 * stale, but it is never NULL
	 */
	BUG_ON(!dev->phy);

	spin_lock_irqsave(&ha->phy_port_lock, flags);
	phy = dev->phy;
	get_device(&phy->dev);
	spin_unlock_irqrestore(&ha->phy_port_lock, flags);

	return phy;
}
","struct sas_phy *sas_get_local_phy(struct domain_device *dev)
{
	struct sas_ha_struct *ha = dev->port->ha;
	struct sas_phy *phy;
	unsigned long len;

	/* a published domain device always has a valid phy, it may be
	 * stale, but it is never NULL
	 */
	BUG_ON(!dev->phy);

	spin_lock_irqsave(&ha->phy_port_lock, len);
	phy = dev->phy;
	get_device(&phy->dev);
	spin_unlock_irqrestore(&ha->phy_port_lock, len);

	return phy;
}
",77.0,19.0,"flags:len,",69.0,0.0394432226816813,Greedy
2043,"void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;

  path = convertPath(state, state->getPath());
  path2 = splash->makeStrokePath(path);
  delete path;
  splash->clipToPath(path2, gFalse);
  delete path2;
}
","void SplashOutputDev::clipToStrokePath(GfxState *states) {
  SplashPath *method, *pointer4;

  pamethod convertPath(states, states->getPath());
  papointer4 splash->makeStrokePath(method);
  delete method;
  splash->clipToPath(pointer4, gFalse);
  delete pointer4;
}
",55.0,16.0,"state:states,path:method,path2:pointer4,",203.0,0.1083572546641031,GA
2044,"blink::WebPlugin* RenderFrameImpl::CreatePlugin(
    const blink::WebPluginParams& params) {
  blink::WebPlugin* plugin = nullptr;
  if (GetContentClient()->renderer()->OverrideCreatePlugin(this, params,
                                                           &plugin)) {
    return plugin;
  }

  if (params.mime_type.ContainsOnlyASCII() &&
      params.mime_type.Ascii() == kBrowserPluginMimeType) {
    BrowserPluginDelegate* delegate =
        GetContentClient()->renderer()->CreateBrowserPluginDelegate(
            this, WebPluginInfo(), kBrowserPluginMimeType, GURL(params.url));
    return BrowserPluginManager::Get()->CreateBrowserPlugin(
        this, delegate->GetWeakPtr());
  }

#if BUILDFLAG(ENABLE_PLUGINS)
  WebPluginInfo info;
  std::string mime_type;
  bool found = false;
  Send(new FrameHostMsg_GetPluginInfo(
      routing_id_, params.url, frame_->Top()->GetSecurityOrigin(),
      params.mime_type.Utf8(), &found, &info, &mime_type));
  if (!found)
    return nullptr;

  WebPluginParams params_to_use = params;
  params_to_use.mime_type = WebString::FromUTF8(mime_type);
  return CreatePlugin(info, params_to_use, nullptr /* throttler */);
#else
  return nullptr;
#endif  // BUILDFLAG(ENABLE_PLUGINS)
}
","blink::WebPlugin* RenderFrameImpl::CreatePlugin(
    const blink::WebPluginParams& params) {
  blink::WebPlugin* plugin = nullptr;
  if (GetContentClient()->renderer()->OverrideCreatePlugin(this, params,
                                                           &plugin)) {
    return plugin;
  }

  if (params.mime_type.ContainsOnlyASCII() &&
      params.mime_type.Ascii() == kBrowserPluginMimeType) {
    BrowserPluginDelegate* delegate =
        GetContentClient()->renderer()->CreateBrowserPluginDelegate(
            this, WebPluginInfo(), kBrowserPluginMimeType, GURL(params.url));
    return BrowserPluginManager::Get()->CreateBrowserPlugin(
        this, delegate->GetWeakPtr());
  }

#if BUILDFLAG(ENABLE_PLUGINS)
  WebPluginInfo info;
  std::string mime_type;
  bool found = false;
  Send(new FrameHostMsg_GetPluginInfo(
      routing_id_, params.url, frame_->Top()-> GetSecurityContext(),
      params.mime_type.Utf8(), &found, &info, &mime_type));
  if (!found)
    return nullptr;

  WebPluginParams params_to_use = params;
  params_to_use.mime_type = WebString::FromUTF8(mime_type);
  return CreatePlugin(info, params_to_use, nullptr /* throttler */);
#else
  return nullptr;
#endif  // BUILDFLAG(ENABLE_PLUGINS)
}
",218.0,40.0,"GetSecurityOrigin: GetSecurityContext,",26.0,0.0248929023742675,Greedy
2059,"void FillMiscNavigationParams(const CommonNavigationParams& common_params,
                              const CommitNavigationParams& commit_params,
                              blink::WebNavigationParams* navigation_params) {
  navigation_params->navigation_timings = BuildNavigationTimings(
      common_params.navigation_start, commit_params.navigation_timing,
      common_params.input_start);

  navigation_params->is_user_activated =
      commit_params.was_activated == WasActivatedOption::kYes;

  if (commit_params.origin_to_commit) {
    navigation_params->origin_to_commit =
        commit_params.origin_to_commit.value();
  }
}
","void FillMiscNavigationParams(const CommonNavigationParams& common_params,
                              const CommitNavigationParams& commitParlanguage,
                              blink::WebNavigationParams* navigation_params) {
  navigation_params->navigation_timings = BuildNavigationTimings(
      common_params.navigation_start, commitParlanguage.navigation_timing,
      common_params.input_start);

  navigation_params->is_user_activated =
      commitParlanguage.was_activated == WasActivatedOption::kYes;

  if (commitParlanguage.origin_to_commit) {
    navigation_params->origin_to_commit =
        commitParlanguage.origin_to_commit.value();
  }
}
",72.0,15.0,"commit_params:commitParlanguage,",49.0,0.0300689299901326,Greedy
2062,"static int firm_report_tx_done(struct usb_serial_port *port)
{
	struct whiteheat_simple close_command;

	close_command.port = port->port_number + 1;
	return firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,
			(__u8 *)&close_command, sizeof(close_command));
}
","static int firm_report_tx_done(struct usb_serial_port *handle)
{
	struct whiteheat_simple  close_cmd;

	 close_cmd.handle = handle->port_number + 1;
	return firm_send_command(handle, WHITEHEAT_REPORT_TX_DONE,
			(__u8 *)& close_cmd, sizeof( close_cmd));
}
",45.0,10.0,"port:handle,close_command: close_cmd,",96.0,0.0468825141588846,Greedy
2069,"void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);

  if (!ValidateObjectStoreId(object_store_id))
    return;

  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}
","void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> Callbacks) {
  DCHECK(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);

  if (!ValidateObjectStoreId(object_store_id))
    return;

  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, Callbacks));
}
",88.0,18.0,"callbacks:Callbacks,",35.0,0.0248644431432088,Greedy
2073,"static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;

	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}
","static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *argone)
{
	uint32_t len;
	__be32 *p;

	*argone = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, argone) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*argone);
	return 0;
}
",159.0,37.0,"gid:argone,",67.0,0.0356071909268697,Greedy
2074,"static inline void vmxnet3_ring_init(PCIDevice *d,
				     Vmxnet3Ring *ring,
                                     hwaddr pa,
                                     size_t size,
                                     size_t cell_size,
                                     bool zero_region)
{
    ring->pa = pa;
    ring->size = size;
    ring->cell_size = cell_size;
    ring->gen = VMXNET3_INIT_GEN;
    ring->next = 0;

    if (zero_region) {
        vmw_shmem_set(d, pa, 0, size * cell_size);
    }
}
","static inline void vmxnet3_ring_init(PCIDevice *fd,
				     Vmxnet3Ring *ring,
                                     hwaddr  Pa,
                                     size_t len,
                                     size_t cell·size,
                                     bool zero_section)
{
    ring-> Pa =  Pa;
    ring->len = len;
    ring->cell·size = cell·size;
    ring->gen = VMXNET3_INIT_GEN;
    ring->next = 0;

    if (zero_section) {
        vmw_shmem_set(fd,  Pa, 0, len * cell·size);
    }
}
",76.0,22.0,"cell_size:cell·size,pa: Pa,size:len,d:fd,zero_region:zero_section,",240.0,0.1191102544466654,Greedy
2087,"static struct page *follow_pud_mask(struct vm_area_struct *vma,
				    unsigned long address, p4d_t *p4dp,
				    unsigned int flags,
				    struct follow_page_context *ctx)
{
	pud_t *pud;
	spinlock_t *ptl;
	struct page *page;
	struct mm_struct *mm = vma->vm_mm;

	pud = pud_offset(p4dp, address);
	if (pud_none(*pud))
		return no_page_table(vma, flags);
	if (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {
		page = follow_huge_pud(mm, address, pud, flags);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (is_hugepd(__hugepd(pud_val(*pud)))) {
		page = follow_huge_pd(vma, address,
				      __hugepd(pud_val(*pud)), flags,
				      PUD_SHIFT);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (pud_devmap(*pud)) {
		ptl = pud_lock(mm, pud);
		page = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);
		spin_unlock(ptl);
		if (page)
			return page;
	}
	if (unlikely(pud_bad(*pud)))
		return no_page_table(vma, flags);

	return follow_pmd_mask(vma, address, pud, flags, ctx);
}
","static struct page *follow_pud_mask(struct vm_area_struct *vma,
				    unsigned long address, p4d_t *p4dp,
				    unsigned int flags,
				    struct follow_page_context *ctx)
{
	pud_t *pud;
	spinlock_t *PTll;
	struct page *page;
	struct mm_struct *mm = vma->vm_mm;

	pud = pud_offset(p4dp, address);
	if (pud_none(*pud))
		return no_page_table(vma, flags);
	if (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {
		page = follow_huge_pud(mm, address, pud, flags);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (is_hugepd(__hugepd(pud_val(*pud)))) {
		page = follow_huge_pd(vma, address,
				      __hugepd(pud_val(*pud)), flags,
				      PUD_SHIFT);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (pud_devmap(*pud)) {
		PTll = pud_lock(mm, pud);
		page = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);
		spin_unlock(PTll);
		if (page)
			return page;
	}
	if (unlikely(pud_bad(*pud)))
		return no_page_table(vma, flags);

	return follow_pmd_mask(vma, address, pud, flags, ctx);
}
",256.0,82.0,"ptl:PTll,",108.0,0.0516521970431009,Greedy
2095,"bool ParamTraits<base::PlatformFileInfo>::Read(const Message* m,
                                               PickleIterator* iter,
                                               param_type* p) {
  double last_modified;
  double last_accessed;
  double creation_time;
  bool result =
      ReadParam(m, iter, &p->size) &&
      ReadParam(m, iter, &p->is_directory) &&
      ReadParam(m, iter, &last_modified) &&
      ReadParam(m, iter, &last_accessed) &&
      ReadParam(m, iter, &creation_time);
  if (result) {
    p->last_modified = base::Time::FromDoubleT(last_modified);
    p->last_accessed = base::Time::FromDoubleT(last_accessed);
    p->creation_time = base::Time::FromDoubleT(creation_time);
  }
  return result;
}
","bool ParamTraits<base::PlatformFileInfo>::Read(const Message* mut,
                                               PickleIterator* iter,
                                               param_type* p) {
  double last_modified;
  double last_accessed;
  double creation_time;
  bool result =
      ReadParam(mut, iter, &p->size) &&
      ReadParam(mut, iter, &p->is_directory) &&
      ReadParam(mut, iter, &last_modified) &&
      ReadParam(mut, iter, &last_accessed) &&
      ReadParam(mut, iter, &creation_time);
  if (result) {
    p->last_modified = base::Time::FromDoubleT(last_modified);
    p->last_accessed = base::Time::FromDoubleT(last_accessed);
    p->creation_time = base::Time::FromDoubleT(creation_time);
  }
  return result;
}
",139.0,39.0,"m:mut,",85.0,0.0457773804664611,Greedy
2096,"bool CheckBasicProxyAuth(const AuthChallengeInfo* auth_challenge) {
  if (!auth_challenge)
    return false;
  EXPECT_TRUE(auth_challenge->is_proxy);
  EXPECT_EQ(""myproxy:70"", auth_challenge->challenger.ToString());
  EXPECT_EQ(""MyRealm1"", auth_challenge->realm);
  EXPECT_EQ(""basic"", auth_challenge->scheme);
  return true;
}
","bool CheckBasicProxyAuth(const AuthChallengeInfo* auth_channelche) {
  if (!auth_channelche)
    return false;
  EXPECT_TRUE(auth_channelche->is_proxy);
  EXPECT_EQ(""myproxy:70"", auth_channelche->challenger.ToString());
  EXPECT_EQ(""MyRealm1"", auth_channelche->realm);
  EXPECT_EQ(""basic"", auth_channelche->scheme);
  return true;
}
",62.0,11.0,"auth_challenge:auth_channelche,",80.0,0.0441767851511637,Greedy
2102,"MagickExport ssize_t WriteBlobMSBSignedShort(Image *image,
  const signed short value)
{
  union
  {
    unsigned short
      unsigned_value;

    signed short
      signed_value;
  } quantum;

  unsigned char
    buffer[2];

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  quantum.signed_value=value;
  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);
  buffer[1]=(unsigned char) quantum.unsigned_value;
  return(WriteBlobStream(image,2,buffer));
}
","MagickExport ssize_t WriteBlobMSBSignedShort(Image *image,
  const signed short wave)
{
  union
  {
    unsigned short
      unsigned_value;

    signed short
      signed_value;
  } quantum;

  unsigned char
    buffer[2];

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  quantum.signed_value=wave;
  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);
  buffer[1]=(unsigned char) quantum.unsigned_value;
  return(WriteBlobStream(image,2,buffer));
}
",103.0,20.0,"value:wave,",51.0,0.0300419052441914,Greedy
2105,"int proc_doulongvec_minmax(struct ctl_table *table, int write,
		    void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return -ENOSYS;
}
","int proc_doulongvec_minmax(struct ctl_table *input, int writer,
		    void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return -ENOSYS;
}
",30.0,8.0,"table:input,write:writer,",60.0,0.0359855532646179,Greedy
2107,"static void addr_hash_set(u32 *mask, const u8 *addr)
{
	int n = ether_crc(ETH_ALEN, addr) >> 26;
	mask[n >> 5] |= (1 << (n & 31));
}
","static void addr_hash_set(u32 *shape, const u8 *data)
{
	int n = ether_crc(ETH_ALEN, data) >> 26;
	shape[n >> 5] |= (1 << (n & 31));
}
",44.0,10.0,"mask:shape,addr:data,",77.0,0.0434720317522684,Greedy
