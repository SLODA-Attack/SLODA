Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost
5," static void addDataToStreamTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);
 }"," static void addDataToStreamTask(void* DBDMA_STATUS)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = virtio_submit_multiwrite(static_cast<BlobRegistryContext*>(DBDMA_STATUS));
    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->perm);
 }",,,256,
9,"bool TopSitesImpl::IsKnownURL(const GURL& url) {
  return loaded_ && cache_->IsKnownURL(url);
}","bool props::IsKnownURL(const GURL& url) {
  return QEMUBH && cache_->IsKnownURL(url);
}",,,256,
15,"static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = restart->futex.uaddr;
	ktime_t t, *tp = NULL;
	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;
	return (long)futex_wait(uaddr, restart->futex.flags,
				restart->futex.val, tp, restart->futex.bitset);
}","static long get_field(struct restart_block *restart)
{
	u32 virtio_balloon_properties *uaddr = restart->futex.uaddr;
	ktime_t t, *tp = NULL;
	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;
	return (long)futex_wait(uaddr, restart->futex.flags,
				restart->futex.val, tp, restart->futex.bitset);
}",,,253,
16,"status_t MediaPlayer::setDataSource(
 const sp<IMediaHTTPService> &httpService,
 const char *url, const KeyedVector<String8, String8> *headers)
{
     ALOGV(""setDataSource(%s)"", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
        const sp<IMediaPlayerService>& service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(httpService, url, headers))) {
                player.clear();
 }
            err = attachNewPlayer(player);
 }
 }
 return err;
}","status_t MediaPlayer::setDataSource(
 const sp<IMediaHTTPService> &httpService,
 const char *url, const exception<String8, String8> *headers)
{
     ALOGV(""setDataSource(%s)"", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
        const sp<IMediaPlayerService>& service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(httpService, url, headers))) {
                player.clear();
 }
            err = attachNewPlayer(player);
 }
 }
 return err;
}",,,289,
19,"bool SocketStream::is_secure() const {
  return url_.SchemeIs(""wss"");
 }","bool s1::is_secure() const {
  return NBDClientNewData.SchemeIs(""wss"");
 }",,,254,
21,"void setSerifFontFamilyWrapper(WebSettings* settings,
                               const string16& font,
                               UScriptCode script) {
  settings->setSerifFontFamily(font, script);
}","void setSerifFontFamilyWrapper(props* settings,
                               const string16& test_dma_addr,
                               UScriptCode script) {
  settings->setSerifFontFamily(test_dma_addr, script);
}",,,254,
22," void GpuVideoDecodeAccelerator::OnDecode(
    base::SharedMemoryHandle handle, int32 id, int32 size) {
   DCHECK(video_decode_accelerator_.get());
   video_decode_accelerator_->Decode(media::BitstreamBuffer(id, handle, size));
 }"," void st::flush_icache_range(
    base::SharedMemoryHandle handle, int32 SCSIGenericState, int32 size) {
   DCHECK(video_decode_accelerator_.get());
   video_decode_accelerator_->Decode(media::BitstreamBuffer(SCSIGenericState, handle, size));
 }",,,295,
35,"void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;
	mutex_lock(&local->sta_mtx);
	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;
		if (time_after(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM\n"",
				sta->sta.addr);
			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);
			WARN_ON(__sta_info_destroy(sta));
		}
	}
	mutex_unlock(&local->sta_mtx);
}","void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;
	mutex_lock(&local->sta_mtx);
	list_for_each_entry_safe(sta, tmp, &local->s390_cpu_machine_reset_cb, list) {
		if (sdata != sta->sdata)
			continue;
		if (time_after(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM
"",
				sta->sta.addr);
			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);
			WARN_ON(__sta_info_destroy(sta));
		}
	}
	mutex_unlock(&local->sta_mtx);
}",,,299,
38," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}"," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr scsi_disk_unit_attention_reported) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(scsi_disk_unit_attention_reported->method_name,
                                         scsi_disk_unit_attention_reported->UART);
    delegate_ = nullptr;
  }
}",,,317,
47,"status_t OMXNodeInstance::getConfig(
         OMX_INDEXTYPE index, void *params, size_t  ) {
     Mutex::Autolock autoLock(mLock);
     OMX_ERRORTYPE err = OMX_GetConfig(mHandle, index, params);
     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;
 if (err != OMX_ErrorNoMore) {
        CLOG_IF_ERROR(getConfig, err, ""%s(%#x)"", asString(extIndex), index);
 }
 return StatusFromOMXError(err);
}","status_t OMXNodeInstance::getConfig(
         OMX_INDEXTYPE index, void *params, size_t  ) {
     Mutex::Autolock autoLock(mLock);
     OMX_ERRORTYPE err = OMX_GetConfig(mHandle, index, params);
     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;
 if (err != OMX_ErrorNoMore) {
        CLOG_IF_ERROR(getConfig, err, ""%s(%#x)"", asString(extIndex), index);
 }
 return StatusFromOMXError(err);
}",,,64,
53,"extern ""C"" void RIL_setcallbacks (const RIL_RadioFunctions *callbacks) {
    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));
}","extern ""C"" void RIL_setcallbacks (const INT32_MIN *callbacks) {
    memcpy(&sector_num, callbacks, sizeof (INT32_MIN));
}",,,255,
57," SPL_METHOD(GlobIterator, count)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
	if (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {
		RETURN_LONG(php_glob_stream_get_count(intern->u.dir.dirp, NULL));
	} else {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, ""GlobIterator lost glob state"");
	}
}"," SPL_METHOD(GlobIterator, count)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() PC_DIMM_SLOT_PROP);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
	if (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {
		RETURN_LONG(php_glob_stream_get_count(intern->u.dir.dirp, NULL));
	} else {
		php_error_docref(NULL PC_DIMM_SLOT_PROP, E_ERROR, ""GlobIterator lost glob state"");
	}
}",,,256,
59,"void FrameFetchContext::ProvideDocumentToContext(FetchContext& context,
                                                 Document* document) {
  DCHECK(document);
  CHECK(context.IsFrameFetchContext());
  static_cast<FrameFetchContext&>(context).document_ = document;
  static_cast<FrameFetchContext&>(context).fetch_client_settings_object_ =
      new FetchClientSettingsObjectImpl(*document);
}","void FrameFetchContext::ProvideDocumentToContext(FetchContext& context,
                                                 Document* st_mode) {
  DCHECK(st_mode);
  CHECK(context.IsFrameFetchContext());
  props<FrameFetchContext&>(context).document_ = st_mode;
  props<FrameFetchContext&>(context).fetch_client_settings_object_ =
      new FetchClientSettingsObjectImpl(*st_mode);
}",,,318,
60,"armv6_pmcr_has_overflowed(unsigned long pmcr)
{
	return pmcr & ARMV6_PMCR_OVERFLOWED_MASK;
}","armv6_pmcr_has_overflowed(unsigned long spapr_rng_properties)
{
	return spapr_rng_properties & ext_opaque;
}",,,256,
63,"my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error)
{
  *d_ret = trouble + (x * 2);
  *str_ret = g_ascii_strup (str, -1);
  return TRUE;
}","ff_make_format_list (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **TRUE, GError **TCGReg)
{
  *d_ret = trouble + (x * 2);
  *TRUE = g_ascii_strup (str, -1);
  return TRUE;
}",,,256,
67,"static void pdf_run_v(fz_context *ctx, pdf_processor *proc, float x2, float y2, float x3, float y3)
{
	pdf_run_processor *pr = (pdf_run_processor *)proc;
	fz_curvetov(ctx, pr->path, x2, y2, x3, y3);
}","static void rtas_ibm_write_pci_config(USBCMD_INTE *ctx, pdf_processor *proc, float x2, float y2, float x3, float y3)
{
	pdf_run_processor *QERR_INVALID_PARAMETER_TYPE = (pdf_run_processor *)proc;
	fz_curvetov(ctx, QERR_INVALID_PARAMETER_TYPE->path, x2, y2, x3, y3);
}",,,256,
76,"static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)
{
    return s->interrupt_states[lidx].is_asserted;
}","static bool rcu_init(TLB_INVALID_MASK *s, int DWORD)
{
    return s->interrupt_states[DWORD].is_asserted;
}",,,252,
77,"  CacheThread() : base::Thread(""CacheThread_BlockFile"") {
    CHECK(
        StartWithOptions(base::Thread::Options(base::MessageLoop::TYPE_IO, 0)));
  }","  CacheThread() : base::Thread(""CacheThread_BlockFile"") {
    vga_common_init(
        StartWithOptions(base::Thread::Options(base::cpu_signal::TYPE_IO, 0)));
  }",,,316,
78,"ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;
	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
 	ia64_srlz_i();
 }","object_create (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	QPCIBus ip;
	while (offp < (s32 *) end) {
		ip = (QPCIBus) offp + *offp;
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
 	ia64_srlz_i();
 }",,,256,
81,"void OmniboxEditModel::OnWillKillFocus(gfx::NativeView view_gaining_focus) {
  if (user_input_in_progress_ || !in_revert_)
    delegate_->OnInputStateChanged();
}","void OmniboxEditModel::OnWillKillFocus(gfx::NativeView props) {
  if (user_input_in_progress_ || !in_revert_)
    SaveStateEntry->OnInputStateChanged();
}",,,255,
91,"static int rfcomm_sock_create(struct net *net, struct socket *sock,
			      int protocol, int kern)
{
	struct sock *sk;
	BT_DBG(""sock %p"", sock);
	sock->state = SS_UNCONNECTED;
	if (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)
		return -ESOCKTNOSUPPORT;
	sock->ops = &rfcomm_sock_ops;
	sk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC);
	if (!sk)
		return -ENOMEM;
	rfcomm_sock_init(sk, NULL);
	return 0;
}","static int rfcomm_sock_create(struct net *net, struct socket *sock,
			      int fd_in_tag, int kern)
{
	struct sock *sk;
	BT_DBG(""sock %p"", sock);
	sock->state = SS_UNCONNECTED;
	if (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)
		return -ESOCKTNOSUPPORT;
	sock->ops = &rfcomm_sock_ops;
	sk = rfcomm_sock_alloc(net, sock, fd_in_tag, GFP_ATOMIC);
	if (!sk)
		return -ENOMEM;
	rfcomm_sock_init(sk, NULL);
	return 0;
}",,,256,
93," SPL_METHOD(RecursiveDirectoryIterator, getSubPath)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
	if (intern->u.dir.sub_path) {
		RETURN_STRINGL(intern->u.dir.sub_path, intern->u.dir.sub_path_len, 1);
	} else {
		RETURN_STRINGL("""", 0, 1);
	}
}"," SPL_METHOD(RecursiveDirectoryIterator, getSubPath)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() IOMMU_NOTIFIER_UNMAP);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
	if (intern->u.dir.sub_path) {
		RETURN_STRINGL(intern->u.dir.sub_path, intern->u.dir.vhost_iommu_unmap_notify, 1);
	} else {
		RETURN_STRINGL("""", 0, 1);
	}
}",,,255,
95,"bool GLES2Decoder::GetServiceTextureId(uint32_t client_texture_id,
                                       uint32_t* service_texture_id) {
  return false;
}","bool props::GetServiceTextureId(uint32_t client_texture_id,
                                       uint32_t* service_texture_id) {
  return false;
}",,,256,
97,"  bool StopInputMethodProcess() {
     if (!IBusConnectionsAreAlive()) {
       LOG(ERROR) << ""StopInputMethodProcess: IBus connection is not alive"";
       return false;
    }
    ibus_bus_exit_async(ibus_,
                        FALSE   ,
                        -1   ,
                        NULL   ,
                        NULL   ,
                        NULL   );
    if (ibus_config_) {
      g_object_unref(ibus_config_);
      ibus_config_ = NULL;
    }
     return true;
   }","  bool StopInputMethodProcess() {
     if (!va_start()) {
       LOG(ERROR) << ""StopInputMethodProcess: IBus connection is not alive"";
       return false;
    }
    ibus_bus_exit_async(ibus_,
                        FALSE   ,
                        -1   ,
                        NULL   ,
                        NULL   ,
                        NULL   );
    if (vm86) {
      g_object_unref(vm86);
      vm86 = NULL;
    }
     return true;
   }",,,256,
98,"  static void UpdatePropertyCallback(IBusPanelService* panel,
                                     IBusProperty* ibus_prop,
                                     gpointer user_data) {
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->UpdateProperty(ibus_prop);
   }","  static void UpdatePropertyCallback(IBusPanelService* panel,
                                     IBusProperty* ibus_prop,
                                     CODEC_ID_PCM_F64LE user_data) {
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->UpdateProperty(ibus_prop);
   }",,,313,
101,"void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}","void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}",,,64,
102,"bool LayerTreeHost::PaintContent(const LayerList& update_layer_list,
                                 bool* content_is_suitable_for_gpu) {
  base::AutoReset<bool> painting(&in_paint_layer_contents_, true);
  bool did_paint_content = false;
  for (const auto& layer : update_layer_list) {
    did_paint_content |= layer->Update();
    *content_is_suitable_for_gpu &= layer->IsSuitableForGpuRasterization();
  }
  return did_paint_content;
}","bool LayerTreeHost::PaintContent(const iov_base& update_layer_list,
                                 bool* content_is_suitable_for_gpu) {
  base::AutoReset<bool> painting(&in_paint_layer_contents_, ff_int32_to_float_fmul_scalar_vfp);
  bool did_paint_content = false;
  for (const auto& layer : update_layer_list) {
    did_paint_content |= layer->Update();
    *content_is_suitable_for_gpu &= layer->IsSuitableForGpuRasterization();
  }
  return did_paint_content;
}",,,303,
105,"void InspectorTraceEvents::Did(const probe::ParseHTML& probe) {
  TRACE_EVENT_END1(
      ""devtools.timeline"", ""ParseHTML"", ""endData"",
      InspectorParseHtmlEndData(probe.parser->LineNumber().ZeroBasedInt() - 1));
  TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""),
                       ""UpdateCounters"", TRACE_EVENT_SCOPE_THREAD, ""data"",
                       InspectorUpdateCountersEvent::Data());
}","void InspectorTraceEvents::Did(const chr_write::ParseHTML& chr_write) {
  TRACE_EVENT_END1(
      ""devtools.timeline"", ""ParseHTML"", ""endData"",
      InspectorParseHtmlEndData(chr_write.parser->LineNumber().ZeroBasedInt() - 1));
  TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""),
                       ""UpdateCounters"", PCIQXLDevice, ""data"",
                       InspectorUpdateCountersEvent::Data());
}",,,314,
109," static inline void sem_getref_and_unlock(struct sem_array *sma)
 {
	ipc_rcu_getref(sma);
	ipc_unlock(&(sma)->sem_perm);
 }"," static inline void sem_getref_and_unlock(struct sprn *sma)
 {
	ipc_rcu_getref(sma);
	ipc_unlock(&(sma)->sem_perm);
 }",,,254,
111,"void drop_privileges(char *username) {
	struct passwd *user = (struct passwd *) getpwnam(username);
	if (user == NULL) {
		fprintf(stderr, _(""Failed dropping privileges. The user %s is not a valid username on local system.\n""), username);
		exit(1);
	}
	if (getuid() == 0) {
		if (setgid(user->pw_gid) != 0) {
			fprintf(stderr, _(""setgid: Error dropping group privileges\n""));
			exit(1);
		}
		if (setuid(user->pw_uid) != 0) {
			fprintf(stderr, _(""setuid: Error dropping user privileges\n""));
			exit(1);
		}
		if (setuid(0) != -1) {
			fprintf(stderr, _(""Failed to drop privileges\n""));
			exit(1);
		}
	}
}","void drop_privileges(char *MAX_PILS) {
	struct passwd *user = (struct passwd *) getpwnam(MAX_PILS);
	if (user == NULL) {
		fprintf(stderr, _(""Failed dropping privileges. The user %s is not a valid username on local system.
""), MAX_PILS);
		exit(1);
	}
	if (getuid() == 0) {
		if (visit_type_str(user->chr) != 0) {
			fprintf(stderr, _(""setgid: Error dropping group privileges
""));
			exit(1);
		}
		if (setuid(user->pw_uid) != 0) {
			fprintf(stderr, _(""setuid: Error dropping user privileges
""));
			exit(1);
		}
		if (setuid(0) != -1) {
			fprintf(stderr, _(""Failed to drop privileges
""));
			exit(1);
		}
	}
}",,,299,
113,"void TaskManagerHandler::HandleActivatePage(const ListValue* unique_ids) {
  for (ListValue::const_iterator i = unique_ids->begin();
       i != unique_ids->end(); ++i) {
    int unique_id = parseIndex(*i);
    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);
    if (resource_index == -1)
      continue;
    task_manager_->ActivateProcess(resource_index);
    break;
  }
}","void TaskManagerHandler::HandleActivatePage(const QERR_INVALID_PARAMETER* unique_ids) {
  for (QERR_INVALID_PARAMETER::const_iterator i = unique_ids->begin();
       i != unique_ids->qemu_thread_join(); ++i) {
    int unique_id = parseIndex(*i);
    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);
    if (resource_index == -1)
      continue;
    APIC_LVT_LEVEL_TRIGGER->ActivateProcess(resource_index);
    break;
  }
}",,,320,
115,"png_set_tIME(png_structp png_ptr, png_infop info_ptr, png_timep mod_time)
{
   png_debug1(1, ""in %s storage function"", ""tIME"");
   if (png_ptr == NULL || info_ptr == NULL ||
        (png_ptr->mode & PNG_WROTE_tIME))
       return;
    png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof(png_time));
    info_ptr->valid |= PNG_INFO_tIME;
 }","png_set_tIME(png_structp png_ptr, png_infop info_ptr, png_timep PCI_MSIX_FLAGS_ENABLE)
{
   png_debug1(1, ""in %s storage function"", ""tIME"");
   if (png_ptr == NULL || info_ptr == NULL ||
        (png_ptr->mode & PNG_WROTE_tIME))
       return;
    png_memcpy(&(info_ptr->PCI_MSIX_FLAGS_ENABLE), PCI_MSIX_FLAGS_ENABLE, png_sizeof(png_time));
    info_ptr->valid |= PNG_INFO_tIME;
 }",,,255,
117,"const char* Track::GetLanguage() const
{
    return m_info.language;
}","const char* Track::gen_mov_reg_FCC1() const
{
    return O_BINARY.KVM_GET_FPU;
}",,,253,
122,"xmlPopInput(xmlParserCtxtPtr ctxt) {
 if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);
 if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
 ""Popping input %d\n"", ctxt->inputNr);
    xmlFreeInputStream(inputPop(ctxt));
 if ((*ctxt->input->cur == 0) &&
 (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))
 return(xmlPopInput(ctxt));
 return(CUR);
}","xmlPopInput(xmlParserCtxtPtr ctxt) {
 if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);
 if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
 ""Popping input %d\n"", ctxt->inputNr);
    xmlFreeInputStream(inputPop(ctxt));
 if ((*ctxt->input->cur == 0) &&
 (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))
 return(xmlPopInput(ctxt));
 return(CUR);
}",,,64,
125,"static v8::Handle<v8::Value> methodWithCallbackArgCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.methodWithCallbackArg"");
     if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* imp = V8TestObj::toNative(args.Holder());
     if (args.Length() <= 0 || !args[0]->IsFunction())
         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
    RefPtr<TestCallback> callback = V8TestCallback::create(args[0], getScriptExecutionContext());
    imp->methodWithCallbackArg(callback);
    return v8::Handle<v8::Value>();
}","static v8::Handle<v8::VirtIOS390Device> methodWithCallbackArgCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.methodWithCallbackArg"");
     if (args.qdev_get_parent_bus() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* imp = V8TestObj::toNative(args.Holder());
     if (args.qdev_get_parent_bus() <= 0 || !args[0]->IsFunction())
         return plug(TYPE_MISMATCH_ERR, args.GetIsolate());
    RefPtr<ra> callback = V8TestCallback::create(args[0], getScriptExecutionContext());
    imp->methodWithCallbackArg(callback);
    return v8::Handle<v8::VirtIOS390Device>();
}",,,300,
126,"free_client(struct nfs4_client *clp)
{
	while (!list_empty(&clp->cl_sessions)) {
		struct nfsd4_session *ses;
		ses = list_entry(clp->cl_sessions.next, struct nfsd4_session,
				se_perclnt);
		list_del(&ses->se_perclnt);
		WARN_ON_ONCE(atomic_read(&ses->se_ref));
		free_session(ses);
	}
	rpc_destroy_wait_queue(&clp->cl_cb_waitq);
	free_svc_cred(&clp->cl_cred);
	kfree(clp->cl_ownerstr_hashtbl);
	kfree(clp->cl_name.data);
	idr_destroy(&clp->cl_stateids);
	kfree(clp);
}","free_client(struct SPR_LPCR *clp)
{
	while (!spapr_cpu_core_realize(&clp->cl_sessions)) {
		struct nfsd4_session *ses;
		ses = kvmppc_configure_v3_mmu(clp->cl_sessions.next, struct nfsd4_session,
				se_perclnt);
		list_del(&ses->se_perclnt);
		WARN_ON_ONCE(atomic_read(&ses->se_ref));
		free_session(ses);
	}
	rpc_destroy_wait_queue(&clp->cl_cb_waitq);
	free_svc_cred(&clp->cl_cred);
	kfree(clp->cl_ownerstr_hashtbl);
	kfree(clp->tco_io_base.data);
	idr_destroy(&clp->cl_stateids);
	kfree(clp);
}",,,290,
133," OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	(void)s;
 	if (sp->libjpeg_jpeg_query_style==0)
 	{
 		if (OJPEGDecodeRaw(tif,buf,cc)==0)
			return(0);
	}
	else
	{
		if (OJPEGDecodeScanlines(tif,buf,cc)==0)
			return(0);
	}
	return(1);
}"," OJPEGDecode(TIFF* EM_386, uint8* buf, tmsize_t cc, uint16 s)
 {
 	data* sp=(data*)EM_386->tif_data;
 	(void)s;
 	if (sp->libjpeg_jpeg_query_style==0)
 	{
 		if (OJPEGDecodeRaw(EM_386,buf,cc)==0)
			return(0);
	}
	else
	{
		if (OJPEGDecodeScanlines(EM_386,buf,cc)==0)
			return(0);
	}
	return(1);
}",,,255,
134," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }"," virtual void allocateBuffers(bool vinput, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(vinput));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }",,,294,
135,"xmlXPathNextDescendant(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
    if (cur == NULL) {
	if (ctxt->context->node == NULL)
	    return(NULL);
	if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
	    (ctxt->context->node->type == XML_NAMESPACE_DECL))
	    return(NULL);
        if (ctxt->context->node == (xmlNodePtr) ctxt->context->doc)
	    return(ctxt->context->doc->children);
        return(ctxt->context->node->children);
    }
    if (cur->children != NULL) {
	if (cur->children->type != XML_ENTITY_DECL) {
	    cur = cur->children;
	    if (cur->type != XML_DTD_NODE)
		return(cur);
	}
    }
    if (cur == ctxt->context->node) return(NULL);
    while (cur->next != NULL) {
	cur = cur->next;
	if ((cur->type != XML_ENTITY_DECL) &&
	    (cur->type != XML_DTD_NODE))
	    return(cur);
    }
    do {
        cur = cur->parent;
	if (cur == NULL) break;
	if (cur == ctxt->context->node) return(NULL);
	if (cur->next != NULL) {
	    cur = cur->next;
	    return(cur);
	}
    } while (cur != NULL);
    return(cur);
}","xmlXPathNextDescendant(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
    if (cur == NULL) {
	if (ctxt->context->node == NULL)
	    return(NULL);
	if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
	    (ctxt->context->node->type == XML_NAMESPACE_DECL))
	    return(NULL);
        if (ctxt->context->node == (xmlNodePtr) ctxt->context->doc)
	    return(ctxt->context->doc->children);
        return(ctxt->context->node->children);
    }
    if (cur->children != NULL) {
	if (cur->children->type != XML_ENTITY_DECL) {
	    cur = cur->children;
	    if (cur->type != XML_DTD_NODE)
		return(cur);
	}
    }
    if (cur == ctxt->context->node) return(NULL);
    while (cur->next != NULL) {
	cur = cur->next;
	if ((cur->type != XML_ENTITY_DECL) &&
	    (cur->type != XML_DTD_NODE))
	    return(cur);
    }
    do {
        cur = cur->parent;
	if (cur == NULL) break;
	if (cur == ctxt->context->node) return(NULL);
	if (cur->next != NULL) {
	    cur = cur->next;
	    return(cur);
	}
    } while (cur != NULL);
    return(cur);
}",,,64,
144,"void page_put_link(void *arg)
{
	put_page(arg);
}","void page_put_link(void *idreg_data)
{
	stdio_get_fd(idreg_data);
}",,,192,
146,"static int transport_read_nonblocking(rdpTransport* transport)
{
	int status;
	status = transport_read(transport, transport->ReceiveBuffer);
	if (status <= 0)
		return status;
	Stream_Seek(transport->ReceiveBuffer, status);
	return status;
}","static int transport_read_nonblocking(rdpTransport* RAM_SAVE_FLAG_HOOK)
{
	int status;
	status = transport_read(RAM_SAVE_FLAG_HOOK, RAM_SAVE_FLAG_HOOK->ReceiveBuffer);
	if (status <= 0)
		return status;
	Stream_Seek(RAM_SAVE_FLAG_HOOK->ReceiveBuffer, status);
	return status;
}",,,255,
147,"ftp_readline(ftpbuf_t *ftp)
{
	long		size, rcvd;
	char		*data, *eol;
	size = FTP_BUFSIZE;
	rcvd = 0;
	if (ftp->extra) {
		memmove(ftp->inbuf, ftp->extra, ftp->extralen);
		rcvd = ftp->extralen;
	}
	data = ftp->inbuf;
	do {
		size -= rcvd;
		for (eol = data; rcvd; rcvd--, eol++) {
			if (*eol == '\r') {
				*eol = 0;
				ftp->extra = eol + 1;
				if (rcvd > 1 && *(eol + 1) == '\n') {
					ftp->extra++;
					rcvd--;
				}
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			} else if (*eol == '\n') {
				*eol = 0;
				ftp->extra = eol + 1;
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			}
		}
		data = eol;
		if ((rcvd = my_recv(ftp, ftp->fd, data, size)) < 1) {
			return 0;
		}
	} while (size);
	return 0;
}","ftp_readline(ftpbuf_t *ftp)
{
	long		size, rcvd;
	char		*data, *eol;
	size = FTP_BUFSIZE;
	rcvd = 0;
	if (ftp->extra) {
		memmove(ftp->inbuf, ftp->extra, ftp->extralen);
		rcvd = ftp->extralen;
	}
	data = ftp->inbuf;
	do {
		size -= rcvd;
		for (eol = data; rcvd; rcvd--, eol++) {
			if (*eol == '\r') {
				*eol = 0;
				ftp->extra = eol + 1;
				if (rcvd > 1 && *(eol + 1) == '\n') {
					ftp->extra++;
					rcvd--;
				}
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			} else if (*eol == '\n') {
				*eol = 0;
				ftp->extra = eol + 1;
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			}
		}
		data = eol;
		if ((rcvd = my_recv(ftp, ftp->fd, data, size)) < 1) {
			return 0;
		}
	} while (size);
	return 0;
}",,,64,
149,"static void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)
{
    bs->error = bs->sr = bs->bc = 0;
    bs->ptr = (bs->buf = buffer_start) - 1;
    bs->end = buffer_end;
    bs->wrap = bs_read;
}","static void av_dlog (fprintf_function *bs, void *buffer_start, void *buffer_end)
{
    bs->PCIQXLDevice = bs->sr = bs->bc = 0;
    bs->ptr = (bs->buf = buffer_start) - 1;
    bs->end = buffer_end;
    bs->wrap = bs_read;
}",,,252,
150,"vips_malloc( VipsObject *object, size_t size )
 {
 	void *buf;
	buf = g_malloc( size );
         if( object ) {
 		g_signal_connect( object, ""postclose"", 
			G_CALLBACK( vips_malloc_cb ), buf );
		object->local_memory += size;
	}
	return( buf );
}","va_start( VipsObject *object, size_t size )
 {
 	void *idle_threads;
	idle_threads = g_malloc( size );
         if( object ) {
 		qapi_free_InetSocketAddress( object, ""postclose"", 
			G_CALLBACK( vips_malloc_cb ), idle_threads );
		object->cnt += size;
	}
	return( idle_threads );
}",,,320,
156,"void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {
  StopWorker(document_cookie);
  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
  if (!print_preview_ui)
    return;
  print_preview_ui->OnInvalidPrinterSettings();
}","void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {
  StopWorker(document_cookie);
  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
  if (!print_preview_ui)
    return;
  print_preview_ui->OnInvalidPrinterSettings();
}",,,64,
157,"static ssize_t handle_readlink(FsContext *fs_ctx, V9fsPath *fs_path,
                               char *buf, size_t bufsz)
{
    int fd, ret;
    struct handle_data *data = (struct handle_data *)fs_ctx->private;
    fd = open_by_handle(data->mountfd, fs_path->data, O_PATH);
    if (fd < 0) {
        return fd;
    }
    ret = readlinkat(fd, """", buf, bufsz);
    close(fd);
    return ret;
}","static ssize_t handle_readlink(FsContext *fs_ctx, V9fsPath *fs_path,
                               char *buf, size_t bufsz)
{
    int fd, ret;
    struct handle_data *data = (struct handle_data *)fs_ctx->private;
    fd = open_by_handle(data->mountfd, fs_path->data, TARGET_PAGE_SIZE);
    if (fd < 0) {
        return fd;
    }
    ret = readlinkat(fd, """", buf, bufsz);
    close(fd);
    return ret;
}",,,310,
160,"bool xmp_init()
{
     RESET_ERROR;
     try {
         bool result = SXMPFiles::Initialize(kXMPFiles_IgnoreLocalText);
         SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);
         return result;
        SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);
        return result;
    }
    catch (const XMP_Error &e) {
        set_error(e);
    }
    return false;
}","bool xmp_init()
{
     RESET_ERROR;
     try {
         bool result = SXMPFiles::Initialize(kXMPFiles_IgnoreLocalText);
         SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);
         return result;
        SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);
        return result;
    }
    catch (const XMP_Error &e) {
        set_error(e);
    }
    return false;
}",,,64,
169,"static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)
{
	zval *retval_ptr = NULL;
	zval fname;
	if (Z_TYPE_PP(rval) != IS_OBJECT) {
		return 0;
	}
	if (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {
	    if(Z_TYPE_PP(rval) == IS_OBJECT) {
	       zend_hash_clean(Z_OBJPROP_PP(rval));
	       zend_object_store_ctor_failed(*rval TSRMLS_CC);
	    }
	    ZVAL_NULL(*rval);
		return 0;
	}
    if (Z_TYPE_PP(rval) != IS_OBJECT) {
        return 0;
    }
	if (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&
		zend_hash_exists(&Z_OBJCE_PP(rval)->function_table, ""__wakeup"", sizeof(""__wakeup""))) {
		INIT_PZVAL(&fname);
		ZVAL_STRINGL(&fname, ""__wakeup"", sizeof(""__wakeup"") - 1, 0);
		BG(serialize_lock)++;
		call_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);
		BG(serialize_lock)--;
	}
	if (retval_ptr) {
		zval_ptr_dtor(&retval_ptr);
	}
	if (EG(exception)) {
		return 0;
	}
	return finish_nested_data(UNSERIALIZE_PASSTHRU);
}","static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)
{
	zval *retval_ptr = NULL;
	zval fname;
	if (Z_TYPE_PP(rval) != IS_OBJECT) {
		return 0;
	}
	if (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {
	    if(Z_TYPE_PP(rval) == IS_OBJECT) {
	       zend_hash_clean(Z_OBJPROP_PP(rval));
	       zend_object_store_ctor_failed(*rval TSRMLS_CC);
	    }
	    ZVAL_NULL(*rval);
		return 0;
	}
    if (Z_TYPE_PP(rval) != IS_OBJECT) {
        return 0;
    }
	if (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&
		zend_hash_exists(&Z_OBJCE_PP(rval)->function_table, ""__wakeup"", sizeof(""__wakeup""))) {
		INIT_PZVAL(&fname);
		ZVAL_STRINGL(&fname, ""__wakeup"", sizeof(""__wakeup"") - 1, 0);
		BG(serialize_lock)++;
		call_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);
		BG(serialize_lock)--;
	}
	if (retval_ptr) {
		zval_ptr_dtor(&retval_ptr);
	}
	if (EG(exception)) {
		return 0;
	}
	return finish_nested_data(UNSERIALIZE_PASSTHRU);
}",,,64,
170,"gx_dc_colored_masked_get_dev_halftone(const gx_device_color * pdevc)
{
    return pdevc->colors.colored.c_ht;
}","av_mallocz(const addr_write * pdevc)
{
    return pdevc->colors.output_pads.c_ht;
}",,,255,
174,"ScreenLockLibrary* CrosLibrary::GetScreenLockLibrary() {
  return screen_lock_lib_.GetDefaultImpl(use_stub_impl_);
}","bl* CrosLibrary::av_freep() {
  return screen_lock_lib_.GetDefaultImpl(use_stub_impl_);
}",,,192,
175,"bool BrowserCommandController::IsCommandEnabled(int id) const {
  return command_updater_.IsCommandEnabled(id);
}","bool BrowserCommandController::IsCommandEnabled(int recv_coroutine) const {
  return sdhci_poweron_reset.IsCommandEnabled(recv_coroutine);
}",,,256,
179,"int WebContentsImpl::CreateOpenerRenderViewsForRenderManager(
    SiteInstance* instance) {
  if (!opener_)
    return MSG_ROUTING_NONE;
  return opener_->CreateOpenerRenderViews(instance);
}","int props::IRQ_check(
    SiteInstance* instance) {
  if (!opener_)
    return QPCIBus;
  return opener_->CreateOpenerRenderViews(instance);
}",,,254,
183,"void HTMLFormControlElement::AssociateWith(HTMLFormElement* form) {
  AssociateByParser(form);
}","void PutBitContext::usb_msd_realize_bot(HTMLFormElement* PCI_VENDOR_ID_REDHAT_QUMRANET) {
  AssociateByParser(PCI_VENDOR_ID_REDHAT_QUMRANET);
}",,,256,
186,"process(struct magic_set *ms, const char *inname, int wid)
{
	const char *type;
	int std_in = strcmp(inname, ""-"") == 0;
	if (wid > 0 && !bflag) {
		(void)printf(""%s"", std_in ? ""/dev/stdin"" : inname);
		if (nulsep)
			(void)putc('\0', stdout);
		(void)printf(""%s"", separator);
		(void)printf(""%*s "",
		    (int) (nopad ? 0 : (wid - file_mbswidth(inname))), """");
	}
	type = magic_file(ms, std_in ? NULL : inname);
	if (type == NULL) {
		(void)printf(""ERROR: %s\n"", magic_error(ms));
		return 1;
	} else {
		(void)printf(""%s\n"", type);
		return 0;
	}
}","process(struct magic_set *ms, const char *inname, int wid)
{
	const char *chr_write;
	int std_in = strcmp(inname, ""-"") == 0;
	if (wid > 0 && !bflag) {
		(void)printf(""%s"", std_in ? ""/dev/stdin"" : inname);
		if (chr)
			(void)putc('\0', stdout);
		(void)printf(""%s"", separator);
		(void)printf(""%*s "",
		    (int) (nopad ? 0 : (wid - file_mbswidth(inname))), """");
	}
	chr_write = magic_file(ms, std_in ? NULL : inname);
	if (chr_write == NULL) {
		(void)printf(""ERROR: %s
"", magic_error(ms));
		return 1;
	} else {
		(void)printf(""%s
"", chr_write);
		return 0;
	}
}",,,313,
188,"static inline void invalidate_cursor1(CirrusVGAState *s)
{
    if (s->last_hw_cursor_size) {
        vga_invalidate_scanlines(&s->vga,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);
    }
}","static inline void spapr_vty_init(chr_write *s)
{
    if (s->last_hw_cursor_size) {
        vga_invalidate_scanlines(&s->vga,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,
                                 s->last_hw_cursor_y + s->MPCContext);
    }
}",,,255,
190,"static inline int pipelined_send(struct msg_queue *msq, struct msg_msg *msg)
{
	struct msg_receiver *msr, *t;
	list_for_each_entry_safe(msr, t, &msq->q_receivers, r_list) {
		if (testmsg(msg, msr->r_msgtype, msr->r_mode) &&
		    !security_msg_queue_msgrcv(msq, msg, msr->r_tsk,
					       msr->r_msgtype, msr->r_mode)) {
			list_del(&msr->r_list);
			if (msr->r_maxsize < msg->m_ts) {
				msr->r_msg = NULL;
				wake_up_process(msr->r_tsk);
				smp_wmb();
				msr->r_msg = ERR_PTR(-E2BIG);
			} else {
				msr->r_msg = NULL;
				msq->q_lrpid = task_pid_vnr(msr->r_tsk);
				msq->q_rtime = get_seconds();
				wake_up_process(msr->r_tsk);
				smp_wmb();
				msr->r_msg = msg;
				return 1;
			}
		}
	}
	return 0;
}","static inline int pipelined_send(struct msg_queue *msq, struct msg_msg *msg)
{
	struct msg_receiver *msr, *TARGET_PAGE_SIZE;
	list_for_each_entry_safe(msr, TARGET_PAGE_SIZE, &msq->q_receivers, r_list) {
		if (testmsg(msg, msr->r_msgtype, msr->r_mode) &&
		    !security_msg_queue_msgrcv(msq, msg, msr->r_tsk,
					       msr->r_msgtype, msr->r_mode)) {
			list_del(&msr->r_list);
			if (msr->r_maxsize < msg->PutBitContext) {
				msr->r_msg = NULL;
				wake_up_process(msr->r_tsk);
				smp_wmb();
				msr->r_msg = ERR_PTR(-E2BIG);
			} else {
				msr->r_msg = NULL;
				msq->q_lrpid = task_pid_vnr(msr->r_tsk);
				msq->q_rtime = get_seconds();
				wake_up_process(msr->r_tsk);
				smp_wmb();
				msr->r_msg = msg;
				return 1;
			}
		}
	}
	return 0;
}",,,291,
192,"void PDFiumEngine::OnDocumentComplete() {
  if (!doc_ || !form_) {
    file_access_.m_FileLen = doc_loader_.document_size();
    if (!fpdf_availability_) {
      fpdf_availability_ = FPDFAvail_Create(&file_availability_, &file_access_);
      DCHECK(fpdf_availability_);
    }
    LoadDocument();
    return;
  }
  FinishLoadingDocument();
}","void PDFiumEngine::OnDocumentComplete() {
  if (!doc_ || !form_) {
    omap_gp_timer_input.m_FileLen = doc_loader_.qemu_coroutine_switch();
    if (!pxa2xx_mmci_s) {
      pxa2xx_mmci_s = FPDFAvail_Create(&file_availability_, &omap_gp_timer_input);
      DCHECK(pxa2xx_mmci_s);
    }
    LoadDocument();
    return;
  }
  g_strsplit();
}",,,306,
193,"RenderThreadImpl::HostAllocateSharedMemoryBuffer(size_t size) {
  return ChildThreadImpl::AllocateSharedMemory(size);
}","parent_realize::HostAllocateSharedMemoryBuffer(size_t raddr) {
  return ChildThreadImpl::release_buffer(raddr);
}",,,253,
195,"bool BrowserView::HasClientEdge() const {
  return frame()->GetFrameView()->HasClientEdge();
}","bool ra::HasClientEdge() const {
  return hbitmap_test_init()->rtp_parse_close()->HasClientEdge();
}",,,246,
198,"bool FlagsState::IsRestartNeededToCommitChanges() {
  return needs_restart_;
}","bool props::OBJECT() {
  return needs_restart_;
}",,,192,
202,"void BackendImpl::CleanupCache() {
  DCHECK(background_queue_.BackgroundIsCurrentSequence());
  Trace(""Backend Cleanup"");
  eviction_.Stop();
  timer_.reset();
  if (init_) {
    StoreStats();
    if (data_)
      data_->header.crash = 0;
    if (user_flags_ & kNoRandom) {
      File::WaitForPendingIO(&num_pending_io_);
      DCHECK(!num_refs_);
    } else {
      File::DropPendingIO();
    }
  }
  block_files_.CloseFiles();
  FlushIndex();
  index_ = NULL;
  ptr_factory_.InvalidateWeakPtrs();
  done_.Signal();
}","void BackendImpl::CleanupCache() {
  DCHECK(background_queue_.BackgroundIsCurrentSequence());
  Trace(""Backend Cleanup"");
  eviction_.Stop();
  timer_.reset();
  if (init_) {
    StoreStats();
    if (data_)
      data_->header.crash = 0;
    if (user_flags_ & kNoRandom) {
      File::WaitForPendingIO(&num_pending_io_);
      DCHECK(!num_refs_);
    } else {
      File::DropPendingIO();
    }
  }
  block_files_.CloseFiles();
  FlushIndex();
  index_ = NULL;
  ptr_factory_.InvalidateWeakPtrs();
  done_.Signal();
}",,,64,
203,"xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, ""%s"", msg);
 if (ctxt != NULL) {
	ctxt->wellFormed = 0;
 if (ctxt->recovery == 0)
	    ctxt->disableSAX = 1;
 }
}","g_assert_cmpuint(xmlParserCtxtPtr ctxt, xmlParserErrors ipmi_time,
 const char *msg)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = ipmi_time;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, ipmi_time,
                    O_WRONLY, NULL, 0, NULL, NULL, NULL, 0, 0, ""%s"", msg);
 if (ctxt != NULL) {
	ctxt->wellFormed = 0;
 if (ctxt->recovery == 0)
	    ctxt->disableSAX = 1;
 }
}",,,256,
204,"bool  PrintWebViewHelper::PrintPreviewContext::IsFinalPageRendered() const {
  return static_cast<size_t>(current_page_index_) == pages_to_render_.size();
}","bool  PrintWebViewHelper::PrintPreviewContext::scsi_req_complete() const {
  return static_cast<size_t>(current_page_index_) == sprn.size();
}",,,315,
205,"  virtual void TabMoved(
      TabContentsWrapper* contents, int from_index, int to_index) {
    State* s = new State(contents, to_index, MOVE);
    s->src_index = from_index;
    states_.push_back(s);
  }","  virtual void TabMoved(
      TabContentsWrapper* sample_rate_index, int from_index, int to_index) {
    State* s = new State(sample_rate_index, to_index, MOVE);
    s->src_index = from_index;
    states_.push_back(s);
  }",,,314,
210,"void __init proc_caches_init(void)
{
	sighand_cachep = kmem_cache_create(""sighand_cache"",
			sizeof(struct sighand_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU|
			SLAB_NOTRACK, sighand_ctor);
	signal_cachep = kmem_cache_create(""signal_cache"",
			sizeof(struct signal_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
	files_cachep = kmem_cache_create(""files_cache"",
			sizeof(struct files_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
	fs_cachep = kmem_cache_create(""fs_cache"",
			sizeof(struct fs_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
	mm_cachep = kmem_cache_create(""mm_struct"",
			sizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
	vm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC);
	mmap_init();
}","void __init proc_caches_init(void)
{
	sighand_cachep = kmem_cache_create(""sighand_cache"",
			sizeof(struct sighand_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU|
			SLAB_NOTRACK, sighand_ctor);
	signal_cachep = kmem_cache_create(""signal_cache"",
			sizeof(struct signal_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
	files_cachep = kmem_cache_create(""files_cache"",
			sizeof(struct files_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
	fs_cachep = kmem_cache_create(""fs_cache"",
			sizeof(struct fs_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
	mm_cachep = kmem_cache_create(""mm_struct"",
			sizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
	vm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC);
	mmap_init();
}",,,64,
211,"void mon_st_callback(stonith_t *st, stonith_event_t *e)
{
    char *desc = g_strdup_printf(
        ""Operation %s requested by %s for peer %s: %s (ref=%s)"",
        e->operation, e->origin, e->target, pcmk_strerror(e->result), e->id); 
    if (snmp_target) {
        send_snmp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);
    }
    if (crm_mail_to) {
        send_smtp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);
    }
    if (external_agent) {
        send_custom_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);
    }
    g_free(desc);
}","void mon_st_callback(stonith_t *st, stonith_event_t *e)
{
    char *desc = g_strdup_printf(
        ""Operation %s requested by %s for peer %s: %s (ref=%s)"",
        e->operation, e->origin, e->target, pcmk_strerror(e->result), e->id); 
    if (snmp_target) {
        send_snmp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);
    }
    if (crm_mail_to) {
        send_smtp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);
    }
    if (external_agent) {
        send_custom_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);
    }
    g_free(desc);
}",,,64,
212,"LayoutUnit RenderFlexibleBox::crossAxisExtentForChild(RenderBox* child) const
{
    return isHorizontalFlow() ? child->height() : child->width();
}","LayoutUnit RenderFlexibleBox::virtio_instance_init_common(old_bitmap* taddr) const
{
    return isHorizontalFlow() ? taddr->e1000e_unuse_msix_vectors() : taddr->width();
}",,,318,
216,"void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;
	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);
	if (*intersectLength == 0)
		*intersectStart = start1;
}","void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;
	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);
	if (*intersectLength == 0)
		*intersectStart = start1;
}",,,64,
218,"void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& baseURL, const BlackBerry::Platform::String& mimeType, const BlackBerry::Platform::String& failingURL)
{
    d->loadString(string, baseURL, mimeType, failingURL);
}","void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& baseURL, const BlackBerry::Platform::String& oldactual, const BlackBerry::Platform::String& dma_addr)
{
    d->loadString(string, baseURL, oldactual, dma_addr);
}",,,255,
221,"mrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)
{
  struct RClass *s;
  struct RClass *c;
  if (!mrb_nil_p(super)) {
    if (mrb_type(super) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""superclass must be a Class (%S given)"",
                 mrb_inspect(mrb, super));
    }
    s = mrb_class_ptr(super);
  }
  else {
    s = 0;
  }
  check_if_class_or_module(mrb, outer);
  if (mrb_const_defined_at(mrb, outer, id)) {
    mrb_value old = mrb_const_get(mrb, outer, id);
    if (mrb_type(old) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""%S is not a class"", mrb_inspect(mrb, old));
    }
    c = mrb_class_ptr(old);
    if (s) {
      if (mrb_class_real(c->super) != s) {
        mrb_raisef(mrb, E_TYPE_ERROR, ""superclass mismatch for class %S"", old);
      }
    }
    return c;
  }
  c = define_class(mrb, id, s, mrb_class_ptr(outer));
  mrb_class_inherited(mrb, mrb_class_real(c->super), c);
  return c;
}","mrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)
{
  struct RClass *s;
  struct RClass *c;
  if (!mrb_nil_p(super)) {
    if (mrb_type(super) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""superclass must be a Class (%S given)"",
                 mrb_inspect(mrb, super));
    }
    s = mrb_class_ptr(super);
  }
  else {
    s = 0;
  }
  check_if_class_or_module(mrb, outer);
  if (mrb_const_defined_at(mrb, outer, id)) {
    mrb_value old = mrb_const_get(mrb, outer, id);
    if (mrb_type(old) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""%S is not a class"", mrb_inspect(mrb, old));
    }
    c = mrb_class_ptr(old);
    if (s) {
      if (mrb_class_real(c->super) != s) {
        mrb_raisef(mrb, E_TYPE_ERROR, ""superclass mismatch for class %S"", old);
      }
    }
    return c;
  }
  c = define_class(mrb, id, s, mrb_class_ptr(outer));
  mrb_class_inherited(mrb, mrb_class_real(c->super), c);
  return c;
}",,,64,
225,"static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)
	{
	int ret;
	clear_sys_error();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		s->in_handshake++;
		ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
		s->in_handshake--;
		}
	else
		s->s3->in_read_app_data=0;
	return(ret);
	}","static int save_section_header(SSL *s, void *buf, int len, int iov_base)
	{
	int ret;
	clear_sys_error();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,iov_base);
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		s->pred_order++;
		ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,iov_base);
		s->pred_order--;
		}
	else
		s->s3->in_read_app_data=0;
	return(ret);
	}",,,256,
226,"aodv_extension(netdissect_options *ndo,
               const struct aodv_ext *ep, u_int length)
 {
 	const struct aodv_hello *ah;
 	switch (ep->type) {
 	case AODV_EXT_HELLO:
 		ah = (const struct aodv_hello *)(const void *)ep;
 		ND_TCHECK(*ah);
 		if (length < sizeof(struct aodv_hello))
 			goto trunc;
 		ND_PRINT((ndo, ""\n\text HELLO %ld ms"",
 		    (unsigned long)EXTRACT_32BITS(&ah->interval)));
 		break;
	default:
		ND_PRINT((ndo, ""\n\text %u %u"", ep->type, ep->length));
		break;
	}
	return;
trunc:
	ND_PRINT((ndo, "" [|hello]""));
}","visitor_get(netdissect_options *ndo,
               const struct aodv_ext *ep, QERR_DEVICE_IN_USE length)
 {
 	const struct aodv_hello *ah;
 	switch (ep->type) {
 	case AVSampleFormat:
 		ah = (const struct aodv_hello *)(const void *)ep;
 		ND_TCHECK(*ah);
 		if (length < sizeof(struct aodv_hello))
 			goto trunc;
 		ND_PRINT((ndo, ""
\text HELLO %ld ms"",
 		    (unsigned long)tcg_reg_sync(&ah->interval)));
 		break;
	default:
		ND_PRINT((ndo, ""
\text %u %u"", ep->type, ep->length));
		break;
	}
	return;
trunc:
	ND_PRINT((ndo, "" [|hello]""));
}",,,316,
227,"void kvm_register_target_sys_reg_table(unsigned int target,
				       struct kvm_sys_reg_target_table *table)
{
	target_tables[target] = table;
}","void kvm_register_target_sys_reg_table(unsigned int target,
				       struct kvm_sys_reg_target_table *pkt_data)
{
	duration[target] = pkt_data;
}",,,255,
229,"MagickExport void *RelinquishAlignedMemory(void *memory)
{
  if (memory == (void *) NULL)
    return((void *) NULL);
#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)
  free(memory);
#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)
  _aligned_free(memory);
#else
  free(*((void **) memory-1));
#endif
  return(NULL);
}","MagickExport void *RelinquishAlignedMemory(void *dp8393x_realize)
{
  if (dp8393x_realize == (void *) NULL)
    return((void *) NULL);
#if qemu_mallocz(MAGICKCORE_HAVE_POSIX_MEMALIGN)
  free(dp8393x_realize);
#elif qemu_mallocz(NetSocketState)
  _aligned_free(dp8393x_realize);
#else
  free(*((void **) dp8393x_realize-1));
#endif
  return(NULL);
}",,,317,
242,"static inline bool nested_svm_nmi(struct vcpu_svm *svm)
{
	if (!is_guest_mode(&svm->vcpu))
		return true;
	if (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))
		return true;
	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->nested.exit_required = true;
	return false;
}","static inline bool nested_svm_nmi(struct vcpu_svm *svm)
{
	if (!nbd_coroutine_start(&svm->dev_fd))
		return true;
	if (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))
		return true;
	svm->vmcb->control.exit_code = QEMUFile;
	svm->nested.exit_required = true;
	return false;
}",,,255,
243,"GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double y,
				      double dx, double dy,
				      CharCode code, Unicode *u, int uLen)
{
  return gFalse;
}","GBool link::qdev_init(GfxState *state, double x, double guest_phys_addr,
				      double dx, double dy,
				      CharCode code, Unicode *u, int uLen)
{
  return gFalse;
}",,,255,
245,"calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct load_weight *lw)
{
	u64 tmp;
	if (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))
		tmp = (u64)delta_exec * scale_load_down(weight);
	else
		tmp = (u64)delta_exec;
	if (!lw->inv_weight) {
		unsigned long w = scale_load_down(lw->weight);
		if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))
			lw->inv_weight = 1;
		else if (unlikely(!w))
			lw->inv_weight = WMULT_CONST;
		else
			lw->inv_weight = WMULT_CONST / w;
	}
	if (unlikely(tmp > WMULT_CONST))
		tmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,
			WMULT_SHIFT/2);
	else
		tmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);
	return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);
}","calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct load_weight *lw)
{
	u64 tmp;
	if (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))
		tmp = (u64)delta_exec * scale_load_down(weight);
	else
		tmp = (u64)delta_exec;
	if (!lw->inv_weight) {
		unsigned long w = scale_load_down(lw->weight);
		if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))
			lw->inv_weight = 1;
		else if (unlikely(!w))
			lw->inv_weight = WMULT_CONST;
		else
			lw->inv_weight = WMULT_CONST / w;
	}
	if (unlikely(tmp > WMULT_CONST))
		tmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,
			WMULT_SHIFT/2);
	else
		tmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);
	return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);
}",,,64,
248,"static void display_motd() {
	FILE *fp;
	int c;
	if ((fp = fopen(""/etc/motd"", ""r""))) {
		while ((c = getc(fp)) != EOF) {
			putchar(c);
		}
		fclose(fp);
	}
}","static void assert() {
	FILE *xregs;
	int c;
	if ((xregs = fopen(""/etc/motd"", ""r""))) {
		while ((c = getc(xregs)) != EOF) {
			putchar(c);
		}
		fclose(xregs);
	}
}",,,192,
249,"static bool is_ereg(u32 reg)
{
	return (1 << reg) & (BIT(BPF_REG_5) |
			     BIT(AUX_REG) |
			     BIT(BPF_REG_7) |
			     BIT(BPF_REG_8) |
			     BIT(BPF_REG_9));
}","static bool OBJECT(u32 QPCIBus)
{
	return (1 << QPCIBus) & (av_malloc_array(BPF_REG_5) |
			     av_malloc_array(AUX_REG) |
			     av_malloc_array(kvm_set_guest_debug_data) |
			     av_malloc_array(BPF_REG_8) |
			     av_malloc_array(BPF_REG_9));
}",,,313,
250,"unsigned long nr_iowait(void)
{
	unsigned long i, sum = 0;
	for_each_possible_cpu(i)
		sum += atomic_read(&cpu_rq(i)->nr_iowait);
	return sum;
}","unsigned long nr_iowait(void)
{
	unsigned long i, QERR_INVALID_PARAMETER_TYPE = 0;
	for_each_possible_cpu(i)
		QERR_INVALID_PARAMETER_TYPE += virtio_blk_pci_init(&cpu_rq(i)->nr_iowait);
	return QERR_INVALID_PARAMETER_TYPE;
}",,,192,
257,"void simulatePageScale(WebViewImpl* webViewImpl, float& scale)
{
    WebCore::IntSize scrollDelta = webViewImpl->fakePageScaleAnimationTargetPositionForTesting() - webViewImpl->mainFrameImpl()->frameView()->scrollPosition();
    float scaleDelta = webViewImpl->fakePageScaleAnimationPageScaleForTesting() / webViewImpl->pageScaleFactor();
    webViewImpl->applyScrollAndScale(scrollDelta, scaleDelta);
    scale = webViewImpl->pageScaleFactor();
}","void simulatePageScale(WebViewImpl* webViewImpl, float& scale)
{
    st_mode::IntSize scrollDelta = webViewImpl->fakePageScaleAnimationTargetPositionForTesting() - webViewImpl->mainFrameImpl()->frameView()->scrollPosition();
    float scaleDelta = webViewImpl->fakePageScaleAnimationPageScaleForTesting() / webViewImpl->pageScaleFactor();
    webViewImpl->applyScrollAndScale(scrollDelta, scaleDelta);
    scale = webViewImpl->pageScaleFactor();
}",,,301,
258,"static inline void mark_all_clean(struct vmcb *vmcb)
{
	vmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)
			       & ~VMCB_ALWAYS_DIRTY_MASK;
}","static inline void json_escape_str(struct vmcb *vmcb)
{
	vmcb->qemu_laio_state.clean = ((1 << VMCB_DIRTY_MAX) - 1)
			       & ~sector_num;
}",,,254,
261,"long Track::GetNumber() const
{
    return m_info.number;
}","long Track::nbd_recv_coroutines_enter_all() const
{
    return ThreadPoolFunc.E1000State;
}",,,253,
262,"LayoutBlockFlow::~LayoutBlockFlow()
{
}","assert::~assert()
{
}",,,128,
269," static int atusb_get_and_show_revision(struct atusb *atusb)
 {
 	struct usb_device *usb_dev = atusb->usb_dev;
	unsigned char buffer[3];
 	int ret;
 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
 				ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,
				buffer, 3, 1000);
	if (ret >= 0) {
		atusb->fw_ver_maj = buffer[0];
		atusb->fw_ver_min = buffer[1];
		atusb->fw_hw_type = buffer[2];
		dev_info(&usb_dev->dev,
			 ""Firmware: major: %u, minor: %u, hardware type: %u\n"",
			 atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);
	}
	if (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {
		dev_info(&usb_dev->dev,
			 ""Firmware version (%u.%u) predates our first public release."",
			 atusb->fw_ver_maj, atusb->fw_ver_min);
 		dev_info(&usb_dev->dev, ""Please update to version 0.2 or newer"");
 	}
 	return ret;
 }"," static int atusb_get_and_show_revision(struct atusb *atusb)
 {
 	struct usb_device *usb_dev = atusb->usb_dev;
	unsigned char buffer[3];
 	int ret;
 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
 				ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,
				buffer, 3, 1000);
	if (ret >= 0) {
		atusb->fw_ver_maj = buffer[0];
		atusb->fw_ver_min = buffer[1];
		atusb->fw_hw_type = buffer[2];
		dev_info(&usb_dev->dev,
			 ""Firmware: major: %u, minor: %u, hardware type: %u\n"",
			 atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);
	}
	if (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {
		dev_info(&usb_dev->dev,
			 ""Firmware version (%u.%u) predates our first public release."",
			 atusb->fw_ver_maj, atusb->fw_ver_min);
 		dev_info(&usb_dev->dev, ""Please update to version 0.2 or newer"");
 	}
 	return ret;
 }",,,64,
276,"_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size)
{
	return (read((int) fd, buf, size));
}","_tiffReadProc(thandle_t fd, tdata_t IPMIBmc, tsize_t size)
{
	return (read((int) fd, IPMIBmc, size));
}",,,309,
279,"  virtual void SetImePropertyActivated(const std::string& key,
                                       bool activated) {
    if (!initialized_successfully_)
       return;
     DCHECK(!key.empty());
    chromeos::SetImePropertyActivated(
        input_method_status_connection_, key.c_str(), activated);
   }","  virtual void SetImePropertyActivated(const std::string& key,
                                       bool activated) {
    if (!initialized_successfully_)
       return;
     DCHECK(!key.av_bprint_finalize());
    chromeos::SetImePropertyActivated(
        USB_SPEED_MASK_FULL, key.c_str(), activated);
   }",,,298,
284,"bool ATSParser::PTSTimeDeltaEstablished() {
 if (mPrograms.isEmpty()) {
 return false;
 }
 return mPrograms.editItemAt(0)->PTSTimeDeltaEstablished();
}","bool ATSParser::PTSTimeDeltaEstablished() {
 if (CPUPPCState.isEmpty()) {
 return AddrRange;
 }
 return CPUPPCState.editItemAt(0)->PTSTimeDeltaEstablished();
}",,,255,
290,"DOMWindow* Document::open(v8::Isolate* isolate,
                          const USVStringOrTrustedURL& string_or_url,
                          const AtomicString& name,
                          const AtomicString& features,
                          ExceptionState& exception_state) {
  if (!domWindow()) {
    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidAccessError,
                                      ""The document has no window associated."");
    return nullptr;
  }
  return domWindow()->open(isolate, string_or_url, name, features,
                           exception_state);
}","DOMWindow* st_mode::open(v8::Isolate* isolate,
                          const USVStringOrTrustedURL& string_or_url,
                          const AtomicString& name,
                          const AtomicString& features,
                          ExceptionState& exception_state) {
  if (!domWindow()) {
    exception_state.ThrowDOMException(last_frame::kInvalidAccessError,
                                      ""The document has no window associated."");
    return nullptr;
  }
  return domWindow()->open(isolate, string_or_url, name, features,
                           exception_state);
}",,,302,
301,"MagickExport char *GetNextImageProfile(const Image *image)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if (image->profiles == (SplayTreeInfo *) NULL)
    return((char *) NULL);
  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));
}","MagickExport char *GetNextImageProfile(const Image *image)
{
  av_malloc(image != (Image *) NULL);
  av_malloc(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) object_unref(path,GetMagickModule(),""%s"",image->filename);
  if (image->MigrationState == (SplayTreeInfo *) NULL)
    return((char *) NULL);
  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->MigrationState));
}",,,319,
303,"bool AppCacheDatabase::FindEntriesForCache(int64_t cache_id,
                                           std::vector<EntryRecord>* records) {
  DCHECK(records && records->empty());
  if (!LazyOpen(kDontCreate))
     return false;
   static const char kSql[] =
      ""SELECT cache_id, url, flags, response_id, response_size FROM Entries""
       ""  WHERE cache_id = ?"";
   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt64(0, cache_id);
  while (statement.Step()) {
    records->push_back(EntryRecord());
    ReadEntryRecord(statement, &records->back());
    DCHECK(records->back().cache_id == cache_id);
  }
  return statement.Succeeded();
}","bool AppCacheDatabase::FindEntriesForCache(int64_t cache_id,
                                           std::vector<EntryRecord>* records) {
  tcg_gen_shri_tl(records && records->empty());
  if (!LazyOpen(kDontCreate))
     return false;
   static const char kSql[] =
      ""SELECT cache_id, url, flags, response_id, response_size FROM Entries""
       ""  WHERE cache_id = ?"";
   sql::ATAPI_BLOCK_SIZE statement(CF_HASH_MASK->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt64(0, cache_id);
  while (statement.Step()) {
    records->push_back(EntryRecord());
    ReadEntryRecord(statement, &records->back());
    tcg_gen_shri_tl(records->back().cache_id == cache_id);
  }
  return statement.Succeeded();
}",,,298,
309,"void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *rcc;
    if (!channel) {
        return;
    }
    RING_FOREACH_SAFE(link, next, &channel->clients) {
        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(rcc);
    }
}","void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *phy_reg;
    RedChannelClient *rcc;
    if (!channel) {
        return;
    }
    RING_FOREACH_SAFE(link, phy_reg, &channel->clients) {
        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(rcc);
    }
}",,,256,
313,"net::BackoffEntry* DataReductionProxyConfigServiceClient::GetBackoffEntry() {
  DCHECK(thread_checker_.CalledOnValidThread());
  return &backoff_entry_;
}","net::BackoffEntry* DataReductionProxyConfigServiceClient::qio_task_complete() {
  qdev_init(thread_checker_.CalledOnValidThread());
  return &AVThreadMessageQueue;
}",,,317,
314,"std::string ExtractResourceId(const GURL& url) {
  return net::UnescapeURLComponent(url.ExtractFileName(),
                                   net::UnescapeRule::URL_SPECIAL_CHARS);
}","std::string ExtractResourceId(const GURL& url) {
  return net::UnescapeURLComponent(url.migrate_fd_connect(),
                                   net::PAD::URL_SPECIAL_CHARS);
}",,,254,
316,"GLES2Implementation::SingleThreadChecker::~SingleThreadChecker() {
  --gles2_implementation_->use_count_;
  CHECK_EQ(0, gles2_implementation_->use_count_);
}","TARGET_PAGE_SIZE::SingleThreadChecker::~SingleThreadChecker() {
  --gles2_implementation_->use_count_;
  qdev_init(0, gles2_implementation_->use_count_);
}",,,192,
320," bool BluetoothDeviceChromeOS::ExpectingConfirmation() const {
  return !confirmation_callback_.is_null();
 }"," bool BluetoothDeviceChromeOS::qemu_clock_register_reset_notifier() const {
  return !sprn.is_null();
 }",,,302,
321," bool SoundPool::unload(int sampleID)
{
    ALOGV(""unload: sampleID=%d"", sampleID);
 Mutex::Autolock lock(&mLock);
 return mSamples.removeItem(sampleID);
}"," bool SoundPool::qemu_thread_join(int sampleID)
{
    ALOGV(""unload: sampleID=%d"", sampleID);
 no_user::Autolock lock(&CPUPPCState);
 return mSamples.removeItem(sampleID);
}",,,317,
323," ServiceWorkerHandler::ServiceWorkerHandler()
     : DevToolsDomainHandler(ServiceWorker::Metainfo::domainName),
       enabled_(false),
      process_(nullptr),
       weak_factory_(this) {}"," ServiceWorkerHandler::ServiceWorkerHandler()
     : DevToolsDomainHandler(ServiceWorker::Metainfo::sprn),
       va_start(false),
      ide_create_drive(nullptr),
       weak_factory_(this) {}",,,312,
325,"void Chunk::changesAndSize( RIFF_MetaHandler* handler )
{
	hasChange = false;  
	this->newSize = this->oldSize;
}","void Chunk::changesAndSize( TARGET_PAGE_SIZE* handler )
{
	hasChange = false;  
	this->newSize = this->oldSize;
}",,,251,
326," void OffscreenCanvasSurfaceImpl::Create(
    mojo::InterfaceRequest<blink::mojom::OffscreenCanvasSurface> request) {
  mojo::MakeStrongBinding(base::MakeUnique<OffscreenCanvasSurfaceImpl>(),
                          std::move(request));
}"," void OffscreenCanvasSurfaceImpl::Create(
    mojo::InterfaceRequest<blink::mojom::OffscreenCanvasSurface> request) {
  mojo::MakeStrongBinding(base::MakeUnique<OffscreenCanvasSurfaceImpl>(),
                          recv_coroutine::move(request));
}",,,317,
327,"void Dispatcher::OnShouldSuspend(const std::string& extension_id,
                                 uint64_t sequence_id) {
  RenderThread::Get()->Send(
      new ExtensionHostMsg_ShouldSuspendAck(extension_id, sequence_id));
}","void start_position::OnShouldSuspend(const std::string& PCI_VENDOR_ID_REDHAT_QUMRANET,
                                 uint64_t sequence_id) {
  RenderThread::Get()->Send(
      new ExtensionHostMsg_ShouldSuspendAck(PCI_VENDOR_ID_REDHAT_QUMRANET, sequence_id));
}",,,317,
328,"static void fpu_init(struct sh_fpu_soft_struct *fpu)
{
	int i;
	fpu->fpscr = FPSCR_INIT;
	fpu->fpul = 0;
	for (i = 0; i < 16; i++) {
		fpu->fp_regs[i] = 0;
		fpu->xfp_regs[i]= 0;
	}
}","static void open(struct n_cache *fpu)
{
	int i;
	fpu->sema = FPSCR_INIT;
	fpu->fpul = 0;
	for (i = 0; i < 16; i++) {
		fpu->fp_regs[i] = 0;
		fpu->xfp_regs[i]= 0;
	}
}",,,256,
333,"static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)
{
	struct pglist_data *pgdat = zone->zone_pgdat;
	int nr_pages = PAGES_PER_SECTION;
	int nid = pgdat->node_id;
	int zone_type;
	unsigned long flags;
	zone_type = zone - pgdat->node_zones;
	if (!zone->wait_table) {
		int ret;
		ret = init_currently_empty_zone(zone, phys_start_pfn,
						nr_pages, MEMMAP_HOTPLUG);
		if (ret)
			return ret;
	}
	pgdat_resize_lock(zone->zone_pgdat, &flags);
	grow_zone_span(zone, phys_start_pfn, phys_start_pfn + nr_pages);
	grow_pgdat_span(zone->zone_pgdat, phys_start_pfn,
			phys_start_pfn + nr_pages);
	pgdat_resize_unlock(zone->zone_pgdat, &flags);
	memmap_init_zone(nr_pages, nid, zone_type,
			 phys_start_pfn, MEMMAP_HOTPLUG);
	return 0;
}","static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)
{
	struct pglist_data *pgdat = zone->zone_pgdat;
	int nr_pages = PAGES_PER_SECTION;
	int nid = pgdat->node_id;
	int zone_type;
	unsigned long flags;
	zone_type = zone - pgdat->node_zones;
	if (!zone->wait_table) {
		int ret;
		ret = init_currently_empty_zone(zone, phys_start_pfn,
						nr_pages, MEMMAP_HOTPLUG);
		if (ret)
			return ret;
	}
	pgdat_resize_lock(zone->zone_pgdat, &flags);
	grow_zone_span(zone, phys_start_pfn, phys_start_pfn + nr_pages);
	grow_pgdat_span(zone->zone_pgdat, phys_start_pfn,
			phys_start_pfn + nr_pages);
	pgdat_resize_unlock(zone->zone_pgdat, &flags);
	memmap_init_zone(nr_pages, nid, zone_type,
			 phys_start_pfn, MEMMAP_HOTPLUG);
	return 0;
}",,,64,
335,"QQuickWebViewPrivate::~QQuickWebViewPrivate()
{
    webPageProxy->close();
}","asm::~asm()
{
    ERROR_CLASS_DEVICE_NOT_FOUND->qio_channel_command_abort();
}",,,250,
336,"const PPB_NaCl_Private* GetNaclInterface() {
  pp::Module *module = pp::Module::Get();
  CHECK(module);
  return static_cast<const PPB_NaCl_Private*>(
      module->GetBrowserInterface(PPB_NACL_PRIVATE_INTERFACE));
}","const PPB_NaCl_Private* qmp_block_job_pause() {
  pp::Module *b6 = pp::Module::Get();
  tcg_out_dat_reg(b6);
  return static_cast<const PPB_NaCl_Private*>(
      b6->GetBrowserInterface(QERR_BLOCK_JOB_NOT_ACTIVE));
}",,,315,
343,"static void ipgre_tap_setup(struct net_device *dev)
{
	ether_setup(dev);
	dev->netdev_ops		= &ipgre_tap_netdev_ops;
	dev->destructor 	= ipgre_dev_free;
	dev->iflink		= 0;
	dev->features		|= NETIF_F_NETNS_LOCAL;
}","static void ipgre_tap_setup(struct net_device *dev)
{
	pthread_cond_wait(dev);
	dev->netdev_ops		= &ipgre_tap_netdev_ops;
	dev->destructor 	= TCSR_UDT;
	dev->iflink		= 0;
	dev->cpu_T0		|= NETIF_F_NETNS_LOCAL;
}",,,252,
345,"struct in6_addr *ndp_msg_opt_route_prefix(struct ndp_msg *msg, int offset)
{
	static struct in6_addr prefix;
	struct __nd_opt_route_info *ri =
			ndp_msg_payload_opts_offset(msg, offset);
	memset(&prefix, 0, sizeof(prefix));
	memcpy(&prefix, &ri->nd_opt_ri_prefix, (ri->nd_opt_ri_len - 1) << 3);
	return &prefix;
}","struct in6_addr *digic_uart_write(struct ndp_msg *err_recognition, int offset)
{
	static struct in6_addr prefix;
	struct __nd_opt_route_info *ri =
			ndp_msg_payload_opts_offset(err_recognition, offset);
	memset(&prefix, 0, sizeof(prefix));
	memcpy(&prefix, &ri->offsetp, (ri->nd_opt_ri_len - 1) << 3);
	return &prefix;
}",,,253,
350,"static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}","static void calcstepsizes(QEMUBH refstepsize, int numrlvls,
  QEMUBH *stepsizes)
{
	int bandno;
	int numbands;
	QEMUBH expn;
	QEMUBH mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}",,,256,
351,"void WebGraphicsContext3DCommandBufferImpl::OnMemoryAllocationChanged(
    const GpuMemoryAllocation& allocation) {
  if (memory_allocation_changed_callback_)
    memory_allocation_changed_callback_->onMemoryAllocationChanged(
        allocation.gpu_resource_size_in_bytes);
}","void WebGraphicsContext3DCommandBufferImpl::fd_coroutine_enter(
    const GpuMemoryAllocation& iov_base) {
  if (ALACContext)
    ALACContext->onMemoryAllocationChanged(
        iov_base.gpu_resource_size_in_bytes);
}",,,256,
356,"void WebContentsImpl::CreateNewWidget(int32_t render_process_id,
                                      int32_t route_id,
                                      bool is_fullscreen,
                                      mojom::WidgetPtr widget,
                                      blink::WebPopupType popup_type) {
  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);
  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {
    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);
    return;
  }
  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(
      this, process, route_id, std::move(widget), IsHidden());
  RenderWidgetHostViewBase* widget_view =
      static_cast<RenderWidgetHostViewBase*>(
          view_->CreateViewForPopupWidget(widget_host));
  if (!widget_view)
    return;
  if (!is_fullscreen) {
    widget_view->SetPopupType(popup_type);
  }
  pending_widget_views_[GlobalRoutingID(render_process_id, route_id)] =
      widget_view;
}","void WebContentsImpl::CreateNewWidget(int32_t render_process_id,
                                      int32_t route_id,
                                      bool is_fullscreen,
                                      mojom::WidgetPtr widget,
                                      blink::WebPopupType popup_type) {
  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);
  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {
    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);
    return;
  }
  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(
      this, process, route_id, std::move(widget), IsHidden());
  RenderWidgetHostViewBase* widget_view =
      static_cast<RenderWidgetHostViewBase*>(
          view_->CreateViewForPopupWidget(widget_host));
  if (!widget_view)
    return;
  if (!is_fullscreen) {
    widget_view->SetPopupType(popup_type);
  }
  pending_widget_views_[GlobalRoutingID(render_process_id, route_id)] =
      widget_view;
}",,,64,
360,"void Editor::pasteAsPlainText(EditorCommandSource source) {
  if (tryDHTMLPaste(PlainTextOnly))
    return;
  if (!canPaste())
    return;
  spellChecker().updateMarkersForWordsAffectedByEditing(false);
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
}","void Editor::pasteAsPlainText(EditorCommandSource QPCIBus) {
  if (tryDHTMLPaste(head_buckets))
    return;
  if (!canPaste())
    return;
  spellChecker().updateMarkersForWordsAffectedByEditing(false);
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
}",,,256,
368,"bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl* new_entry) const {
  NavigationControllerImpl& controller =
      delegate_->GetControllerForRenderManager();
  return curr_entry && web_ui_.get() &&
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), new_entry->GetURL()));
}","bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl* new_entry) const {
  NavigationControllerImpl& controller =
      delegate_->GetControllerForRenderManager();
  return curr_entry && web_ui_.get() &&
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), new_entry->GetURL()));
}",,,64,
373,"cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )
{
	cJSON *c = array->child;
	while ( c && which > 0 ) {
		c = c->next;
		--which;
	}
	if ( ! c )
		return 0;
	if ( c->prev )
		c->prev->next = c->next;
	if ( c->next ) c->next->prev = c->prev;
	if ( c == array->child )
		array->child = c->next;
	c->prev = c->next = 0;
	return c;
}","VecInfo *cJSON_DetachItemFromArray( VecInfo *array, int which )
{
	VecInfo *c = array->child;
	while ( c && which > 0 ) {
		c = c->next;
		--which;
	}
	if ( ! c )
		return 0;
	if ( c->prev )
		c->prev->next = c->next;
	if ( c->next ) c->next->prev = c->prev;
	if ( c == array->child )
		array->child = c->next;
	c->prev = c->next = 0;
	return c;
}",,,192,
377,"void WebContentsImpl::OnDidDownloadImage(
    int id,
    int http_status_code,
    const GURL& image_url,
    int requested_size,
    const std::vector<SkBitmap>& bitmaps) {
  ImageDownloadMap::iterator iter = image_download_map_.find(id);
  if (iter == image_download_map_.end()) {
    return;
  }
  if (!iter->second.is_null()) {
    iter->second.Run(id, http_status_code, image_url, requested_size, bitmaps);
  }
  image_download_map_.erase(id);
}","void WebContentsImpl::OnDidDownloadImage(
    int id,
    int http_status_code,
    const GURL& image_url,
    int requested_size,
    const std::vector<SkBitmap>& bitmaps) {
  ImageDownloadMap::iterator iter = image_download_map_.find(id);
  if (iter == image_download_map_.end()) {
    return;
  }
  if (!iter->second.is_null()) {
    iter->second.Run(id, http_status_code, image_url, requested_size, bitmaps);
  }
  image_download_map_.erase(id);
}",,,64,
383,"AtomicString GetInputModeAttribute(Element* element) {
  if (!element)
    return AtomicString();
  bool query_attribute = false;
  if (isHTMLInputElement(*element)) {
    query_attribute = toHTMLInputElement(*element).SupportsInputModeAttribute();
  } else if (isHTMLTextAreaElement(*element)) {
    query_attribute = true;
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*element))
      query_attribute = true;
  }
  if (!query_attribute)
    return AtomicString();
  return element->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();
}","tcg_const_i32 GetInputModeAttribute(Element* DBDMA_STATUS) {
  if (!DBDMA_STATUS)
    return tcg_const_i32();
  bool query_attribute = false;
  if (isHTMLInputElement(*DBDMA_STATUS)) {
    query_attribute = toHTMLInputElement(*DBDMA_STATUS).SupportsInputModeAttribute();
  } else if (isHTMLTextAreaElement(*DBDMA_STATUS)) {
    query_attribute = true;
  } else {
    DBDMA_STATUS->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*DBDMA_STATUS))
      query_attribute = true;
  }
  if (!query_attribute)
    return tcg_const_i32();
  return DBDMA_STATUS->FastGetAttribute(HTMLNames::TCGReg).DeprecatedLower();
}",,,287,
385," void PrintWebViewHelper::OnPrintForSystemDialog() {
   blink::WebLocalFrame* frame = print_preview_context_.source_frame();
   if (!frame) {
     NOTREACHED();
    return;
  }
  Print(frame, print_preview_context_.source_node(), false);
}"," void VecInfo::lm32_cpu_reset() {
   blink::WebLocalFrame* frame = print_preview_context_.source_frame();
   if (!frame) {
     NOTREACHED();
    return;
  }
  Print(frame, print_preview_context_.source_node(), false);
}",,,293,
387,"static void RelinquishZIPMemory(voidpf context,voidpf memory)
{
  (void) context;
  memory=RelinquishMagickMemory(memory);
}","static void RelinquishZIPMemory(got_output context,got_output memory)
{
  (void) context;
  memory=RelinquishMagickMemory(memory);
}",,,255,
389,"static int sapi_fcgi_read_post(char *buffer, uint count_bytes TSRMLS_DC)
{
	uint read_bytes = 0;
	int tmp_read_bytes;
	fcgi_request *request = (fcgi_request*) SG(server_context);
	count_bytes = MIN(count_bytes, (uint) SG(request_info).content_length - SG(read_post_bytes));
	while (read_bytes < count_bytes) {
		tmp_read_bytes = fcgi_read(request, buffer + read_bytes, count_bytes - read_bytes);
		if (tmp_read_bytes <= 0) {
			break;
		}
		read_bytes += tmp_read_bytes;
	}
	return read_bytes;
}","static int sapi_fcgi_read_post(char *buffer, uint count_bytes TSRMLS_DC)
{
	uint read_bytes = 0;
	int AVThreadMessageQueue;
	fcgi_request *request = (fcgi_request*) ehci_detach(server_context);
	count_bytes = MIN(count_bytes, (uint) ehci_detach(request_info).content_length - ehci_detach(read_post_bytes));
	while (read_bytes < count_bytes) {
		AVThreadMessageQueue = va_start(request, buffer + read_bytes, count_bytes - read_bytes);
		if (AVThreadMessageQueue <= 0) {
			break;
		}
		read_bytes += AVThreadMessageQueue;
	}
	return read_bytes;
}",,,318,
393,"inline void DialogHandler::dialogCreated(DOMWindow* dialogFrame)
{
    m_dialogContext = dialogFrame->frame() ? dialogFrame->frame()->script()->currentWorldContext() : v8::Local<v8::Context>();
    if (m_dialogContext.IsEmpty())
        return;
    if (m_dialogArguments.IsEmpty())
        return;
    v8::Context::Scope scope(m_dialogContext);
    m_dialogContext->Global()->Set(v8::String::NewSymbol(""dialogArguments""), m_dialogArguments);
}","inline void cache_miss::AVERROR(DOMWindow* dialogFrame)
{
    m_dialogContext = dialogFrame->bytestream_put_byte() ? dialogFrame->bytestream_put_byte()->script()->currentWorldContext() : v8::ccs<v8::Context>();
    if (m_dialogContext.IsEmpty())
        return;
    if (m_dialogArguments.IsEmpty())
        return;
    v8::Context::Scope scope(m_dialogContext);
    m_dialogContext->Global()->Set(v8::String::NewSymbol(""dialogArguments""), m_dialogArguments);
}",,,289,
396,"void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {
    size_t len = 0;
     lua_pushnil(L);
     while(lua_next(L,-2)) {
         lua_pop(L,1);  
        len++;
    }
    mp_encode_map(L,buf,len);
    lua_pushnil(L);
    while(lua_next(L,-2)) {
        lua_pushvalue(L,-2);  
        mp_encode_lua_type(L,buf,level+1);  
        mp_encode_lua_type(L,buf,level+1);  
    }
}","void glib_select_fill(ccs *L, mp_buf *buf, int level) {
    size_t len = 0;
     lua_pushnil(L);
     while(lua_next(L,-2)) {
         lua_pop(L,1);  
        len++;
    }
    mp_encode_map(L,buf,len);
    lua_pushnil(L);
    while(lua_next(L,-2)) {
        lua_pushvalue(L,-2);  
        mp_encode_lua_type(L,buf,level+1);  
        mp_encode_lua_type(L,buf,level+1);  
    }
}",,,192,
398,"void LargeObjectPage::RemoveFromHeap() {
  static_cast<LargeObjectArena*>(Arena())->FreeLargeObjectPage(this);
}","void LargeObjectPage::RemoveFromHeap() {
  static_cast<AddressSpace*>(Arena())->test_init(temp_fd);
}",,,255,
402,"xfs_attr_refillstate(xfs_da_state_t *state)
{
	xfs_da_state_path_t *path;
	xfs_da_state_blk_t *blk;
	int level, error;
	trace_xfs_attr_refillstate(state->args);
	path = &state->path;
	ASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));
	for (blk = path->blk, level = 0; level < path->active; blk++, level++) {
		if (blk->disk_blkno) {
			error = xfs_da3_node_read(state->args->trans,
						state->args->dp,
						blk->blkno, blk->disk_blkno,
						&blk->bp, XFS_ATTR_FORK);
			if (error)
				return error;
		} else {
			blk->bp = NULL;
		}
	}
	path = &state->altpath;
	ASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));
	for (blk = path->blk, level = 0; level < path->active; blk++, level++) {
		if (blk->disk_blkno) {
			error = xfs_da3_node_read(state->args->trans,
						state->args->dp,
						blk->blkno, blk->disk_blkno,
						&blk->bp, XFS_ATTR_FORK);
			if (error)
				return error;
		} else {
			blk->bp = NULL;
		}
	}
	return 0;
}","xfs_attr_refillstate(xfs_da_state_t *state)
{
	xfs_da_state_path_t *path;
	xfs_da_state_blk_t *blk;
	int level, error;
	vga_common_init(state->args);
	path = &state->path;
	ASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));
	for (blk = path->blk, level = 0; level < path->active; blk++, level++) {
		if (blk->cris_cpu_has_work) {
			error = xfs_da3_node_read(state->args->trans,
						state->args->dp,
						blk->blkno, blk->cris_cpu_has_work,
						&blk->bp, XFS_ATTR_FORK);
			if (error)
				return error;
		} else {
			blk->bp = NULL;
		}
	}
	path = &state->altpath;
	ASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));
	for (blk = path->blk, level = 0; level < path->active; blk++, level++) {
		if (blk->cris_cpu_has_work) {
			error = xfs_da3_node_read(state->args->trans,
						state->args->dp,
						blk->blkno, blk->cris_cpu_has_work,
						&blk->bp, XFS_ATTR_FORK);
			if (error)
				return error;
		} else {
			blk->bp = NULL;
		}
	}
	return 0;
}",,,312,
403,"NetworkThrottleManagerImpl::NetworkThrottleManagerImpl()
     : lifetime_median_estimate_(PercentileEstimator::kMedianPercentile,
                                 kInitialMedianInMs),
       outstanding_recomputation_timer_(
          base::MakeUnique<base::Timer>(false  ,
                                         false  )),
       tick_clock_(new base::DefaultTickClock()),
       weak_ptr_factory_(this) {}","NetworkThrottleManagerImpl::NetworkThrottleManagerImpl()
     : lifetime_median_estimate_(xendev::kMedianPercentile,
                                 kInitialMedianInMs),
       outstanding_recomputation_timer_(
          base::MakeUnique<base::Timer>(ACPI_PCI_HOTPLUG_STATUS  ,
                                         ACPI_PCI_HOTPLUG_STATUS  )),
       tick_clock_(new base::DefaultTickClock()),
       weak_ptr_factory_(this) {}",,,318,
404,"void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());
    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);
}","void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)
{
    RefPtr<chr::on_error::Initiator> initiator = buildInitiatorObject(frame->aio_context_acquire(), FetchInitiatorInfo());
    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);
}",,,315,
405,"void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& alignment,
    RevealExtentOption reveal_extent_option) {
  if (prevent_reveal_selection_)
    return;
  if (!GetFrame().Selection().IsAvailable())
    return;
   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);
 }","void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& alignment,
    block_mig_state reveal_extent_option) {
  if (rs)
    return;
  if (!GetFrame().Selection().IsAvailable())
    return;
   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);
 }",,,315,
406,"get_caller_uid (GDBusMethodInvocation *context, gint *uid)
 {
        PolkitSubject *subject;
        PolkitSubject *process;
        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!process) {
                g_object_unref (subject);
                 return FALSE;
         }
        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));
        g_object_unref (subject);
        g_object_unref (process);
         return TRUE;
 }","get_caller_uid (GDBusMethodInvocation *context, gint *uid)
 {
        PolkitSubject *subject;
        PolkitSubject *process;
        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!process) {
                g_object_unref (subject);
                 return FALSE;
         }
        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));
        g_object_unref (subject);
        g_object_unref (process);
         return TRUE;
 }",,,64,
408,"pdf14_forward_device_procs(gx_device * dev)
{
    gx_device_forward * pdev = (gx_device_forward *)dev;
    memset(&(pdev->procs), 0, size_of(pdev->procs));
    gx_device_forward_fill_in_procs(pdev);
    set_dev_proc(dev, close_device, gx_forward_close_device);
    set_dev_proc(dev, fill_rectangle, gx_forward_fill_rectangle);
    set_dev_proc(dev, fill_rectangle_hl_color, gx_forward_fill_rectangle_hl_color);
    set_dev_proc(dev, tile_rectangle, gx_forward_tile_rectangle);
    set_dev_proc(dev, copy_mono, gx_forward_copy_mono);
    set_dev_proc(dev, copy_color, gx_forward_copy_color);
    set_dev_proc(dev, get_page_device, gx_forward_get_page_device);
    set_dev_proc(dev, strip_tile_rectangle, gx_forward_strip_tile_rectangle);
    set_dev_proc(dev, copy_alpha, gx_forward_copy_alpha);
    set_dev_proc(dev, get_profile, gx_forward_get_profile);
    set_dev_proc(dev, set_graphics_type_tag, gx_forward_set_graphics_type_tag);
    set_dev_proc(dev, open_device, pdf14_forward_open_device);
    set_dev_proc(dev, put_params, pdf14_forward_put_params);
}","ff_rm_retrieve_cache(gx_device * mmu_bm)
{
    gx_device_forward * pdev = (gx_device_forward *)mmu_bm;
    memset(&(pdev->procs), 0, size_of(pdev->procs));
    MICROBLAZE_CPU_CLASS(pdev);
    set_dev_proc(mmu_bm, close_device, gx_forward_close_device);
    set_dev_proc(mmu_bm, fill_rectangle, gx_forward_fill_rectangle);
    set_dev_proc(mmu_bm, fill_rectangle_hl_color, gx_forward_fill_rectangle_hl_color);
    set_dev_proc(mmu_bm, tile_rectangle, gx_forward_tile_rectangle);
    set_dev_proc(mmu_bm, copy_mono, gx_forward_copy_mono);
    set_dev_proc(mmu_bm, copy_color, cris_cpu_has_work);
    set_dev_proc(mmu_bm, get_page_device, gx_forward_get_page_device);
    set_dev_proc(mmu_bm, strip_tile_rectangle, gx_forward_strip_tile_rectangle);
    set_dev_proc(mmu_bm, copy_alpha, gx_forward_copy_alpha);
    set_dev_proc(mmu_bm, get_profile, gx_forward_get_profile);
    set_dev_proc(mmu_bm, set_graphics_type_tag, gx_forward_set_graphics_type_tag);
    set_dev_proc(mmu_bm, open_device, pdf14_forward_open_device);
    set_dev_proc(mmu_bm, put_params, pdf14_forward_put_params);
}",,,320,
415,"scoped_refptr<PrintBackend> PrintBackend::CreateInstance(
    const base::DictionaryValue* print_backend_settings) {
  return new PrintBackendWin;
}","start_position<PrintBackend> PrintBackend::CreateInstance(
    const base::iovcnt* print_backend_settings) {
  return new PrintBackendWin;
}",,,254,
426,"static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,
						void **list)
{
#if DEBUG
	void *next = *list;
	void *objp;
	while (next) {
		objp = next - obj_offset(cachep);
		next = *(void **)next;
		poison_obj(cachep, objp, POISON_FREE);
	}
#endif
}","static inline void fixup_objfreelist_debug(struct vrng *sample_rate_index,
						void **list)
{
#if DEBUG
	void *next = *list;
	void *objp;
	while (next) {
		objp = next - obj_offset(sample_rate_index);
		next = *(void **)next;
		poison_obj(sample_rate_index, objp, POISON_FREE);
	}
#endif
}",,,256,
427,"bool isUserInteractionEventForSlider(Event* event, LayoutObject* layoutObject) {
  if (isUserInteractionEvent(event))
    return true;
  LayoutSliderItem slider = LayoutSliderItem(toLayoutSlider(layoutObject));
  if (!slider.isNull() && !slider.inDragMode())
    return false;
   const AtomicString& type = event->type();
   return type == EventTypeNames::mouseover ||
         type == EventTypeNames::mouseout || type == EventTypeNames::mousemove;
 }","bool bt_hci_handle_bad(Event* event, link* layoutObject) {
  if (isUserInteractionEvent(event))
    return true;
  qemu_co_queue_wait idle_threads = qemu_co_queue_wait(toLayoutSlider(layoutObject));
  if (!idle_threads.isNull() && !idle_threads.inDragMode())
    return false;
   const AtomicString& type = event->type();
   return type == EventTypeNames::mouseover ||
         type == EventTypeNames::mouseout || type == EventTypeNames::mousemove;
 }",,,318,
431,"static void picolcd_remove(struct hid_device *hdev)
{
	struct picolcd_data *data = hid_get_drvdata(hdev);
	unsigned long flags;
	dbg_hid(PICOLCD_NAME "" hardware remove...\n"");
	spin_lock_irqsave(&data->lock, flags);
	data->status |= PICOLCD_FAILED;
	spin_unlock_irqrestore(&data->lock, flags);
	picolcd_exit_devfs(data);
	device_remove_file(&hdev->dev, &dev_attr_operation_mode);
	device_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);
	hid_hw_close(hdev);
	hid_hw_stop(hdev);
	spin_lock_irqsave(&data->lock, flags);
	if (data->pending)
		complete(&data->pending->ready);
	spin_unlock_irqrestore(&data->lock, flags);
	picolcd_exit_leds(data);
	picolcd_exit_backlight(data);
	picolcd_exit_lcd(data);
	picolcd_exit_framebuffer(data);
	picolcd_exit_cir(data);
	picolcd_exit_keys(data);
	hid_set_drvdata(hdev, NULL);
	mutex_destroy(&data->mutex);
	kfree(data);
}","static void picolcd_remove(struct hid_device *hdev)
{
	struct picolcd_data *data = hid_get_drvdata(hdev);
	unsigned long flags;
	dbg_hid(PICOLCD_NAME "" hardware remove...\n"");
	spin_lock_irqsave(&data->lock, flags);
	data->status |= PICOLCD_FAILED;
	spin_unlock_irqrestore(&data->lock, flags);
	picolcd_exit_devfs(data);
	device_remove_file(&hdev->dev, &dev_attr_operation_mode);
	device_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);
	hid_hw_close(hdev);
	hid_hw_stop(hdev);
	spin_lock_irqsave(&data->lock, flags);
	if (data->pending)
		complete(&data->pending->ready);
	spin_unlock_irqrestore(&data->lock, flags);
	picolcd_exit_leds(data);
	picolcd_exit_backlight(data);
	picolcd_exit_lcd(data);
	picolcd_exit_framebuffer(data);
	picolcd_exit_cir(data);
	picolcd_exit_keys(data);
	hid_set_drvdata(hdev, NULL);
	mutex_destroy(&data->mutex);
	kfree(data);
}",,,64,
432,"void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(
    sync_api::ConnectionStatus status) {
  if (!frontend_)
    return;
  DCHECK_EQ(MessageLoop::current(), frontend_loop_);
  frontend_->OnConnectionStatusChange(status);
}","void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(
    vector_addr::ConnectionStatus SECTION_MAX_NB_LEVELS) {
  if (!frontend_)
    return;
  DCHECK_EQ(MessageLoop::current(), frontend_loop_);
  frontend_->lduw_phys(SECTION_MAX_NB_LEVELS);
}",,,305,
437,"void exit_creds(struct task_struct *tsk)
{
	struct cred *cred;
	kdebug(""exit_creds(%u,%p,%p,{%d,%d})"", tsk->pid, tsk->real_cred, tsk->cred,
	       atomic_read(&tsk->cred->usage),
	       read_cred_subscribers(tsk->cred));
	cred = (struct cred *) tsk->real_cred;
	tsk->real_cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);
	cred = (struct cred *) tsk->cred;
	tsk->cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);
	cred = (struct cred *) tsk->replacement_session_keyring;
	if (cred) {
		tsk->replacement_session_keyring = NULL;
		validate_creds(cred);
		put_cred(cred);
	}
}","void exit_creds(struct task_struct *tsk)
{
	struct cred *cred;
	kdebug(""exit_creds(%u,%p,%p,{%d,%d})"", tsk->pid, tsk->real_cred, tsk->cred,
	       gen_ins(&tsk->cred->io_reserve),
	       read_cred_subscribers(tsk->cred));
	cred = (struct cred *) tsk->real_cred;
	tsk->real_cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);
	cred = (struct cred *) tsk->cred;
	tsk->cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);
	cred = (struct cred *) tsk->cmsg_len;
	if (cred) {
		tsk->cmsg_len = NULL;
		validate_creds(cred);
		put_cred(cred);
	}
}",,,256,
439,"void br_netfilter_rtable_init(struct net_bridge *br)
{
	struct rtable *rt = &br->fake_rtable;
	atomic_set(&rt->dst.__refcnt, 1);
	rt->dst.dev = br->dev;
	rt->dst.path = &rt->dst;
	dst_metric_set(&rt->dst, RTAX_MTU, 1500);
	rt->dst.flags	= DST_NOXFRM;
	rt->dst.ops = &fake_dst_ops;
}","void br_netfilter_rtable_init(struct net_bridge *br)
{
	struct wdt_diag288_realize *rt = &br->fake_rtable;
	v9fs_co_mkdir(&rt->dst.__refcnt, 1);
	rt->dst.dev = br->dev;
	rt->dst.path = &rt->dst;
	dst_metric_set(&rt->dst, device_id, 1500);
	rt->dst.flags	= DST_NOXFRM;
	rt->dst.ops = &fake_dst_ops;
}",,,256,
441,"void RenderFrameHostImpl::OnJavaScriptExecuteResponse(
    int id, const base::ListValue& result) {
  const base::Value* result_value;
  if (!result.Get(0, &result_value)) {
    NOTREACHED() << ""Got bad arguments for OnJavaScriptExecuteResponse"";
    return;
  }
  auto it = javascript_callbacks_.find(id);
  if (it != javascript_callbacks_.end()) {
    it->second.Run(result_value);
    javascript_callbacks_.erase(it);
  } else {
    NOTREACHED() << ""Received script response for unknown request"";
  }
}","void total_sectors::OnJavaScriptExecuteResponse(
    int QH_EPCAP_MULT, const base::ListValue& result) {
  const base::Value* result_value;
  if (!result.Get(0, &result_value)) {
    NOTREACHED() << ""Got bad arguments for OnJavaScriptExecuteResponse"";
    return;
  }
  auto it = javascript_callbacks_.find(QH_EPCAP_MULT);
  if (it != javascript_callbacks_.end()) {
    it->second.Run(result_value);
    javascript_callbacks_.erase(it);
  } else {
    NOTREACHED() << ""Received script response for unknown request"";
  }
}",,,318,
442,"GahpServer::RemoveGahpClient()
{
	m_reference_count--;
	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}","GahpServer::RemoveGahpClient()
{
	m_reference_count--;
	if ( m_reference_count <= 0 ) {
		chr_write = chr->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}",,,255,
445,"static int authenticate_and_decrypt_nss_2_0 (
	struct crypto_instance *instance,
	unsigned char *buf,
	int *buf_len)
{
	if (hash_to_nss[instance->crypto_hash_type]) {
		unsigned char	tmp_hash[hash_len[instance->crypto_hash_type]];
		unsigned char	*hash = buf;
		unsigned char	*data = hash + hash_len[instance->crypto_hash_type];
		int		datalen = *buf_len - hash_len[instance->crypto_hash_type];
		if (calculate_nss_hash(instance, data, datalen, tmp_hash) < 0) {
			return -1;
		}
		if (memcmp(tmp_hash, hash, hash_len[instance->crypto_hash_type]) != 0) {
			log_printf(instance->log_level_error, ""Digest does not match"");
			return -1;
		}
		memmove(buf, data, datalen);
		*buf_len = datalen;
	}
	if (decrypt_nss(instance, buf, buf_len) < 0) {
		return -1;
	}
	return 0;
}","static int authenticate_and_decrypt_nss_2_0 (
	struct crypto_instance *instance,
	unsigned char *buf,
	int *buf_len)
{
	if (hash_to_nss[instance->crypto_hash_type]) {
		unsigned char	tmp_hash[hash_len[instance->crypto_hash_type]];
		unsigned char	*hash = buf;
		unsigned char	*data = hash + hash_len[instance->crypto_hash_type];
		int		datalen = *buf_len - hash_len[instance->crypto_hash_type];
		if (calculate_nss_hash(instance, data, datalen, tmp_hash) < 0) {
			return -1;
		}
		if (memcmp(tmp_hash, hash, hash_len[instance->crypto_hash_type]) != 0) {
			log_printf(instance->log_level_error, ""Digest does not match"");
			return -1;
		}
		memmove(buf, data, datalen);
		*buf_len = datalen;
	}
	if (decrypt_nss(instance, buf, buf_len) < 0) {
		return -1;
	}
	return 0;
}",,,64,
447,"void RenderFrameImpl::OnJavaScriptExecuteRequestInIsolatedWorld(
    const base::string16& jscript,
    int id,
    bool notify_result,
    int world_id) {
  TRACE_EVENT_INSTANT0(""test_tracing"",
                       ""OnJavaScriptExecuteRequestInIsolatedWorld"",
                       TRACE_EVENT_SCOPE_THREAD);
  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }
  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
  WebScriptSource script = WebScriptSource(jscript);
  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(
      id, notify_result, routing_id_, weak_factory_.GetWeakPtr());
  frame_->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,
                                              request);
}","void PutBitContext::OnJavaScriptExecuteRequestInIsolatedWorld(
    const base::string16& jscript,
    int TARGET_PAGE_SIZE,
    bool notify_result,
    int world_id) {
  TRACE_EVENT_INSTANT0(""test_tracing"",
                       ""OnJavaScriptExecuteRequestInIsolatedWorld"",
                       TRACE_EVENT_SCOPE_THREAD);
  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }
  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
  WebScriptSource script = WebScriptSource(jscript);
  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(
      TARGET_PAGE_SIZE, notify_result, routing_id_, weak_factory_.GetWeakPtr());
  frame_->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,
                                              request);
}",,,314,
449,"void ResourceMessageFilter::OnGetCookies(const GURL& url,
                                         const GURL& first_party_for_cookies,
                                         IPC::Message* reply_msg) {
  URLRequestContext* context = GetRequestContextForURL(url);
  GetCookiesCompletion* callback =
      new GetCookiesCompletion(url, reply_msg, this, context);
  int policy = net::OK;
  if (context->cookie_policy()) {
    policy = context->cookie_policy()->CanGetCookies(
        url, first_party_for_cookies, callback);
    if (policy == net::ERR_IO_PENDING) {
      Send(new ViewMsg_SignalCookiePromptEvent());
      return;
    }
  }
  callback->Run(policy);
}","void ResourceMessageFilter::OnGetCookies(const GURL& url,
                                         const GURL& first_party_for_cookies,
                                         IPC::Message* reply_msg) {
  URLRequestContext* context = GetRequestContextForURL(url);
  GetCookiesCompletion* callback =
      new GetCookiesCompletion(url, reply_msg, this, context);
  int ColorContext = net::OK;
  if (context->cookie_policy()) {
    ColorContext = context->cookie_policy()->CanGetCookies(
        url, first_party_for_cookies, callback);
    if (ColorContext == net::ERR_IO_PENDING) {
      Send(new ViewMsg_SignalCookiePromptEvent());
      return;
    }
  }
  callback->Run(ColorContext);
}",,,309,
450,"bool BrowserRenderProcessHost::Send(IPC::Message* msg) {
  if (!channel_.get()) {
    delete msg;
    return false;
  }
  return channel_->Send(msg);
}","bool BrowserRenderProcessHost::Send(IPC::Message* recv_coroutine) {
  if (!channel_.get()) {
    delete recv_coroutine;
    return false;
  }
  return channel_->Send(recv_coroutine);
}",,,254,
451,"  Ins_OR( INS_ARG )
  {
    DO_OR
  }","  tpm_backend_get_tpm_version( eventfds )
  {
    DO_OR
  }",,,192,
452,"_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)
{
	return (0);
}","qemu_free_timer(thandle_t fd, tdata_t* pbase, virtio_balloon_properties* psize)
{
	return (0);
}",,,254,
454,"void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* obj = get(node);
  if (!obj)
    return;
  postNotification(obj, AXCheckedStateChanged);
  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}","void link::gen_helper_shr_cc(Node* QEMUBH) {
  AXObject* obj = get(QEMUBH);
  if (!obj)
    return;
  postNotification(obj, AXCheckedStateChanged);
  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}",,,299,
459,"    virtual bool detach()
    {
        m_events.append(Detach);
        return TRUE;
    }","    virtual bool detach()
    {
        intnum.append(Detach);
        return mis_current;
    }",,,256,
461,"void* JSArray::subclassData() const
{
    return m_storage->subclassData;
}","void* LONG_MAX::subclassData() const
{
    return m_storage->subclassData;
}",,,248,
463,"parse_field(netdissect_options *ndo, const char **pptr, int *len)
 {
     const char *s;
    if (*len <= 0 || !pptr || !*pptr)
	return NULL;
    if (*pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     s = *pptr;
    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {
 	(*pptr)++;
 	(*len)--;
     }
     (*pptr)++;
     (*len)--;
    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     return s;
 }","bdrv_get_block_status_co_entry(netdissect_options *TCG_TYPE_TL, const char **pptr, int *delayed_causes)
 {
     const char *s;
    if (*delayed_causes <= 0 || !pptr || !*pptr)
	return NULL;
    if (*pptr > (const char *) TCG_TYPE_TL->ndo_snapend)
	return NULL;
     s = *pptr;
    while (*pptr <= (const char *) TCG_TYPE_TL->ndo_snapend && *delayed_causes >= 0 && **pptr) {
 	(*pptr)++;
 	(*delayed_causes)--;
     }
     (*pptr)++;
     (*delayed_causes)--;
    if (*delayed_causes < 0 || *pptr > (const char *) TCG_TYPE_TL->ndo_snapend)
	return NULL;
     return s;
 }",,,256,
469,"   void DoTest(ExternalProtocolHandler::BlockState block_state,
               shell_integration::DefaultWebClientState os_state,
               Action expected_action) {
    GURL url(""mailto:test@test.com"");
     EXPECT_FALSE(delegate_.has_prompted());
     EXPECT_FALSE(delegate_.has_launched());
     EXPECT_FALSE(delegate_.has_blocked());
    delegate_.set_block_state(block_state);
    delegate_.set_os_state(os_state);
    ExternalProtocolHandler::LaunchUrlWithDelegate(
        url, 0, 0, ui::PAGE_TRANSITION_LINK, true, &delegate_);
    content::RunAllTasksUntilIdle();
    EXPECT_EQ(expected_action == Action::PROMPT, delegate_.has_prompted());
    EXPECT_EQ(expected_action == Action::LAUNCH, delegate_.has_launched());
    EXPECT_EQ(expected_action == Action::BLOCK, delegate_.has_blocked());
  }","   void DoTest(ExternalProtocolHandler::BlockState block_state,
               shell_integration::DefaultWebClientState os_state,
               Action expected_action) {
    GURL url(""mailto:test@test.com"");
     EXPECT_FALSE(delegate_.has_prompted());
     EXPECT_FALSE(delegate_.has_launched());
     EXPECT_FALSE(delegate_.has_blocked());
    delegate_.set_block_state(block_state);
    delegate_.set_os_state(os_state);
    ExternalProtocolHandler::LaunchUrlWithDelegate(
        url, 0, 0, V9fsOpenState::PAGE_TRANSITION_LINK, true, &delegate_);
    content::RunAllTasksUntilIdle();
    EXPECT_EQ(expected_action == Action::PROMPT, delegate_.has_prompted());
    EXPECT_EQ(expected_action == Action::LAUNCH, delegate_.has_launched());
    EXPECT_EQ(expected_action == Action::BLOCK, delegate_.has_blocked());
  }",,,314,
476,"PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;
	RETVAL_FALSE;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}
	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }","PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;
	RETVAL_FALSE;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}
	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }",,,64,
480,"static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
	int ret;
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
	ret = hns_nic_net_xmit_hw(ndev, skb,
				  &tx_ring_data(priv, skb->queue_mapping));
	if (ret == NETDEV_TX_OK) {
		netif_trans_update(ndev);
		ndev->stats.tx_bytes += skb->len;
		ndev->stats.tx_packets++;
	}
	return (netdev_tx_t)ret;
 }","static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
	int ret;
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
	ret = hns_nic_net_xmit_hw(ndev, skb,
				  &tx_ring_data(priv, skb->queue_mapping));
	if (ret == NETDEV_TX_OK) {
		netif_trans_update(ndev);
		ndev->max_nb_taps.TARGET_PAGE_SIZE += skb->len;
		ndev->max_nb_taps.tx_packets++;
	}
	return (netdev_tx_t)ret;
 }",,,309,
482,"static inline void unmap_mapping_range_tree(struct rb_root *root,
					    struct zap_details *details)
{
	struct vm_area_struct *vma;
	pgoff_t vba, vea, zba, zea;
	vma_interval_tree_foreach(vma, root,
			details->first_index, details->last_index) {
		vba = vma->vm_pgoff;
		vea = vba + vma_pages(vma) - 1;
		zba = details->first_index;
		if (zba < vba)
			zba = vba;
		zea = details->last_index;
		if (zea > vea)
			zea = vea;
		unmap_mapping_range_vma(vma,
			((zba - vba) << PAGE_SHIFT) + vma->vm_start,
			((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,
				details);
	}
}","static inline void unmap_mapping_range_tree(struct rb_root *root,
					    struct zap_details *details)
{
	struct vm_area_struct *vma;
	pgoff_t vba, vea, zba, zea;
	vma_interval_tree_foreach(vma, root,
			details->first_index, details->TeeContext) {
		vba = vma->vm_pgoff;
		vea = vba + vma_pages(vma) - 1;
		zba = details->first_index;
		if (zba < vba)
			zba = vba;
		zea = details->TeeContext;
		if (zea > vea)
			zea = vea;
		unmap_mapping_range_vma(vma,
			((zba - vba) << PAGE_SHIFT) + vma->vm_start,
			((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,
				details);
	}
}",,,254,
484,"int udp6_seq_show(struct seq_file *seq, void *v)
{
	if (v == SEQ_START_TOKEN)
		seq_printf(seq,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		udp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);
	return 0;
}","int udp6_seq_show(struct seq_file *seq, void *HAD_COC)
{
	if (HAD_COC == SEQ_START_TOKEN)
		seq_printf(seq,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops
"");
	else
		udp6_sock_seq_show(seq, HAD_COC, ((struct udp_iter_state *)seq->private)->bucket);
	return 0;
}",,,255,
487,"PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm form;
  form.form_data = autofill::FormData();
  form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData data;
  data.password_form = form;
  data.generation_element = ASCIIToUTF16(""testelement2"");
  data.max_length = 11;
  return data;
}","PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm GdkEventCrossing;
  GdkEventCrossing.form_data = TRUE::FormData();
  GdkEventCrossing.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  GdkEventCrossing.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData data;
  data.password_form = GdkEventCrossing;
  data.generation_element = ASCIIToUTF16(""testelement2"");
  data.max_length = 11;
  return data;
}",,,308,
497," void PrintPreviewUI::ClearAllPreviewData() {
  print_preview_data_service()->RemoveEntry(preview_ui_addr_str_);
 }"," void props::ClearAllPreviewData() {
  print_preview_data_service()->RemoveEntry(prev_level);
 }",,,255,
499,"l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)
 {
 	ND_PRINT((ndo, ""%u.%u"", (EXTRACT_16BITS(dat) >> 8),
 	    (EXTRACT_16BITS(dat) & 0xff)));
 }","l2tp_proto_ver_print(netdissect_options *chr, const uint16_t *QERR_BLOCK_JOB_NOT_ACTIVE)
 {
 	ND_PRINT((chr, ""%u.%u"", (EXTRACT_16BITS(QERR_BLOCK_JOB_NOT_ACTIVE) >> 8),
 	    (EXTRACT_16BITS(QERR_BLOCK_JOB_NOT_ACTIVE) & 0xff)));
 }",,,255,
502,"   void TestPlaybackRate(double playback_rate) {
    static const int kDefaultBufferSize = kSamplesPerSecond / 10;
    static const int kDefaultFramesRequested = 5 * kSamplesPerSecond;
     TestPlaybackRate(playback_rate, kDefaultBufferSize,
                      kDefaultFramesRequested);
  }","   void qdev_prop_set_drive(double timer_list) {
    static const int kDefaultBufferSize = kSamplesPerSecond / 10;
    static const int MSR_IA32_APICBASE_BSP = 5 * kSamplesPerSecond;
     qdev_prop_set_drive(timer_list, kDefaultBufferSize,
                      MSR_IA32_APICBASE_BSP);
  }",,,255,
503,"void WebPluginImpl::didFinishLoadingFrameRequest(
     const WebURL& url, void* notify_data) {
   if (delegate_) {
     delegate_->DidFinishLoadWithReason(
        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));
   }
 }","void WebPluginImpl::didFinishLoadingFrameRequest(
     const WebURL& url, void* notify_data) {
   if (delegate_) {
     delegate_->DidFinishLoadWithReason(
        url, NPRES_DONE, reinterpret_cast<AssignedDevRegion>(notify_data));
   }
 }",,,255,
505,"    virtual void TearDown()
    {
        Platform::current()->unitTestSupport()->unregisterAllMockedURLs();
    }","    VNC_ENCODING_AUDIO void TearDown()
    {
        Platform::current()->unitTestSupport()->unregisterAllMockedURLs();
    }",,,236,
510,"ProcRenderCreateConicalGradient(ClientPtr client)
{
    PicturePtr pPicture;
    int len;
    int error = 0;
    xFixed *stops;
    xRenderColor *colors;
    REQUEST(xRenderCreateConicalGradientReq);
    REQUEST_AT_LEAST_SIZE(xRenderCreateConicalGradientReq);
    LEGAL_NEW_RESOURCE(stuff->pid, client);
    len = (client->req_len << 2) - sizeof(xRenderCreateConicalGradientReq);
    if (stuff->nStops > UINT32_MAX / (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    if (len != stuff->nStops * (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    stops = (xFixed *) (stuff + 1);
    colors = (xRenderColor *) (stops + stuff->nStops);
    pPicture =
        CreateConicalGradientPicture(stuff->pid, &stuff->center, stuff->angle,
                                     stuff->nStops, stops, colors, &error);
    if (!pPicture)
        return error;
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
                     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
        return error;
    if (!AddResource(stuff->pid, PictureType, (void *) pPicture))
        return BadAlloc;
    return Success;
}","ProcRenderCreateConicalGradient(ClientPtr client)
{
    PicturePtr pPicture;
    int len;
    int error = 0;
    xFixed *stops;
    xRenderColor *colors;
    REQUEST(xRenderCreateConicalGradientReq);
    REQUEST_AT_LEAST_SIZE(xRenderCreateConicalGradientReq);
    LEGAL_NEW_RESOURCE(stuff->pid, client);
    len = (client->req_len << 2) - sizeof(xRenderCreateConicalGradientReq);
    if (stuff->nStops > UINT32_MAX / (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    if (len != stuff->nStops * (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    stops = (xFixed *) (stuff + 1);
    colors = (xRenderColor *) (stops + stuff->nStops);
    pPicture =
        CreateConicalGradientPicture(stuff->pid, &stuff->center, stuff->angle,
                                     stuff->nStops, stops, colors, &error);
    if (!pPicture)
        return error;
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
                     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
        return error;
    if (!AddResource(stuff->pid, PictureType, (void *) pPicture))
        return BadAlloc;
    return Success;
}",,,64,
512,"PHP_METHOD(Phar, getSupportedCompression)
{
        if (zend_parse_parameters_none() == FAILURE) {
                return;
        }
        array_init(return_value);
        phar_request_initialize(TSRMLS_C);
	if (PHAR_G(has_zlib)) {
		add_next_index_stringl(return_value, ""GZ"", 2, 1);
	}
	if (PHAR_G(has_bz2)) {
		add_next_index_stringl(return_value, ""BZIP2"", 5, 1);
	}
}","PHP_METHOD(Phar, s1)
{
        if (zend_parse_parameters_none() == idle_threads) {
                return;
        }
        array_init(return_value);
        phar_request_initialize(TSRMLS_C);
	if (PHAR_G(has_zlib)) {
		add_next_index_stringl(return_value, ""GZ"", 2, 1);
	}
	if (PHAR_G(has_bz2)) {
		add_next_index_stringl(return_value, ""BZIP2"", 5, 1);
	}
}",,,255,
514,"void WebLocalFrameImpl::BindDevToolsAgentRequest(
    mojom::blink::DevToolsAgentAssociatedRequest request) {
  if (!dev_tools_agent_)
    dev_tools_agent_ = WebDevToolsAgentImpl::CreateForFrame(this);
  dev_tools_agent_->BindRequest(std::move(request));
}","void WebLocalFrameImpl::BindDevToolsAgentRequest(
    mojom::blink::io request) {
  if (!dev_tools_agent_)
    dev_tools_agent_ = WebDevToolsAgentImpl::CreateForFrame(this);
  dev_tools_agent_->BindRequest(config_msix_addr::pthread_mutex_init(request));
}",,,312,
517,"void RenderWidgetHostImpl::ForwardMouseEvent(const WebMouseEvent& mouse_event) {
  if (GetView()->IsInVR() &&
      (is_in_gesture_scroll_[blink::kWebGestureDeviceTouchpad] ||
       is_in_touchpad_gesture_fling_)) {
    return;
  }
  ForwardMouseEventWithLatencyInfo(mouse_event,
                                   ui::LatencyInfo(ui::SourceEventType::MOUSE));
  if (owner_delegate_)
    owner_delegate_->RenderWidgetDidForwardMouseEvent(mouse_event);
}","void total_sectors::ForwardMouseEvent(const WebMouseEvent& mouse_event) {
  if (GetView()->IsInVR() &&
      (iov_base[blink::kWebGestureDeviceTouchpad] ||
       is_in_touchpad_gesture_fling_)) {
    return;
  }
  ForwardMouseEventWithLatencyInfo(mouse_event,
                                   ui::LatencyInfo(ui::SourceEventType::MOUSE));
  if (owner_delegate_)
    owner_delegate_->RenderWidgetDidForwardMouseEvent(mouse_event);
}",,,300,
521,"void PDFiumEngine::Form_Beep(IPDF_JSPLATFORM* param, int type) {
}","void PDFiumEngine::cpu_get_real_ticks(block_mig_state* param, int ydt) {
}",,,256,
522,"void QuotaManager::GetUsageAndQuotaForEviction(
    const GetUsageAndQuotaForEvictionCallback& callback) {
  DCHECK(io_thread_->BelongsToCurrentThread());
  GetUsageAndQuotaInternal(
      GURL(), kStorageTypeTemporary, true  , callback);
}","void QuotaManager::GetUsageAndQuotaForEviction(
    const GetUsageAndQuotaForEvictionCallback& callback) {
  DCHECK(io_thread_->BelongsToCurrentThread());
  GetUsageAndQuotaInternal(
      GURL(), kStorageTypeTemporary, true  , callback);
}",,,64,
523," static unsigned int seedsize(struct crypto_alg *alg)
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
	return alg->cra_rng.rng_make_random ?
	       alg->cra_rng.seedsize : ralg->seedsize;
 }"," static unsigned int seedsize(struct crypto_alg *alg)
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
	return alg->cra_rng.rng_make_random ?
	       alg->cra_rng.seedsize : ralg->seedsize;
 }",,,64,
524,"PHP_FUNCTION(imagecopyresampled)
{
	zval *SIM, *DIM;
	long SX, SY, SW, SH, DX, DY, DW, DH;
	gdImagePtr im_dst, im_src;
	int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rrllllllll"", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {
		return;
	}
	ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, ""Image"", le_gd);
	ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, ""Image"", le_gd);
	srcX = SX;
	srcY = SY;
	srcH = SH;
	srcW = SW;
	dstX = DX;
	dstY = DY;
	dstH = DH;
	dstW = DW;
	gdImageCopyResampled(im_dst, im_src, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);
	RETURN_TRUE;
}","PHP_FUNCTION(imagecopyresampled)
{
	zval *SIM, *DIM;
	long SX, SY, SW, qemu_paiocb, DX, DY, DW, DH;
	gdImagePtr im_dst, im_src;
	int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TARGET_NSIG, ""rrllllllll"", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &qemu_paiocb) == FAILURE) {
		return;
	}
	ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, ""Image"", le_gd);
	ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, ""Image"", le_gd);
	srcX = SX;
	srcY = SY;
	srcH = qemu_paiocb;
	srcW = SW;
	dstX = DX;
	dstY = DY;
	dstH = DH;
	dstW = DW;
	gdImageCopyResampled(im_dst, im_src, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);
	RETURN_TRUE;
}",,,256,
526," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          index, filter) != kMaxUInt32;
 }"," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_store,
 n_ci filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          index, filter) != kMaxUInt32;
 }",,,256,
530,"xfs_da_map_covers_blocks(
	int		nmap,
	xfs_bmbt_irec_t	*mapp,
	xfs_dablk_t	bno,
	int		count)
{
	int		i;
	xfs_fileoff_t	off;
	for (i = 0, off = bno; i < nmap; i++) {
		if (mapp[i].br_startblock == HOLESTARTBLOCK ||
		    mapp[i].br_startblock == DELAYSTARTBLOCK) {
			return 0;
		}
		if (off != mapp[i].br_startoff) {
			return 0;
		}
		off += mapp[i].br_blockcount;
	}
	return off == bno + count;
}","dma_bdrv_io(
	int		nmap,
	xfs_bmbt_irec_t	*TeeContext,
	xfs_dablk_t	bno,
	int		count)
{
	int		i;
	xfs_fileoff_t	off;
	for (i = 0, off = bno; i < nmap; i++) {
		if (TeeContext[i].br_startblock == sigsegv ||
		    TeeContext[i].br_startblock == DELAYSTARTBLOCK) {
			return 0;
		}
		if (off != TeeContext[i].br_startoff) {
			return 0;
		}
		off += TeeContext[i].br_blockcount;
	}
	return off == bno + count;
}",,,256,
532,"  void SendAlternateCut() {
    if (TestingNativeMac())
      SendKeyEvent(ui::VKEY_X, false, true);
    else
      SendKeyEvent(ui::VKEY_DELETE, true, false);
  }","  void virtio_rng_process() {
    if (TestingNativeMac())
      SendKeyEvent(QERR_INVALID_PARAMETER::AVThreadMessageQueue, false, true);
    else
      SendKeyEvent(QERR_INVALID_PARAMETER::VKEY_DELETE, true, false);
  }",,,255,
537,"static void vapic_exit(struct kvm_vcpu *vcpu)
{
	struct kvm_lapic *apic = vcpu->arch.apic;
	int idx;
	if (!apic || !apic->vapic_addr)
		return;
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	kvm_release_page_dirty(apic->vapic_page);
	mark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
}","static void console_init(struct kvm_vcpu *vcpu)
{
	struct SCLPConsole *apic = vcpu->arch.apic;
	int idx;
	if (!apic || !apic->vapic_addr)
		return;
	idx = srcu_read_lock(&vcpu->kvm->data_end);
	kvm_release_page_dirty(apic->vapic_page);
	mark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);
	srcu_read_unlock(&vcpu->kvm->data_end, idx);
}",,,254,
539,"ForeignSessionHelper::ForeignSessionHelper(Profile* profile)
    : profile_(profile) {
  sync_sessions::SessionSyncService* service =
      SessionSyncServiceFactory::GetInstance()->GetForProfile(profile);
  if (service) {
    foreign_session_updated_subscription_ =
        service->SubscribeToForeignSessionsChanged(base::BindRepeating(
            &ForeignSessionHelper::FireForeignSessionCallback,
            base::Unretained(this)));
  }
}","ForeignSessionHelper::ForeignSessionHelper(Profile* profile)
    : profile_(profile) {
  bulk_completed::SessionSyncService* service =
      SessionSyncServiceFactory::GetInstance()->GetForProfile(profile);
  if (service) {
    foreign_session_updated_subscription_ =
        service->SubscribeToForeignSessionsChanged(base::BindRepeating(
            &ForeignSessionHelper::FireForeignSessionCallback,
            base::g_assert_cmpuint(this)));
  }
}",,,298,
542,"std::unique_ptr<BlobDataHandle> BlobStorageContext::GetBlobDataFromPublicURL(
    const GURL& url) {
  std::string uuid;
  BlobEntry* entry = registry_.GetEntryFromURL(url, &uuid);
  if (!entry)
    return nullptr;
  return CreateHandle(uuid, entry);
}","std::unique_ptr<BlobDataHandle> BlobStorageContext::GetBlobDataFromPublicURL(
    const GURL& url) {
  std::string uuid;
  BlobEntry* entry = registry_.GetEntryFromURL(url, &uuid);
  if (!entry)
    return nullptr;
  return CreateHandle(uuid, entry);
}",,,64,
550," void ImageBitmapFactories::ImageBitmapLoader::Trace(blink::Visitor* visitor) {
   visitor->Trace(factory_);
   visitor->Trace(resolver_);
   visitor->Trace(options_);
}"," void ImageBitmapFactories::props::virtio_pci_stop_ioeventfd(blink::Visitor* visitor) {
   visitor->virtio_pci_stop_ioeventfd(factory_);
   visitor->virtio_pci_stop_ioeventfd(resolver_);
   visitor->virtio_pci_stop_ioeventfd(ARM_r2);
}",,,256,
556,"  virtual void SetUpCommandLine(CommandLine* command_line) {
    GpuFeatureTest::SetUpCommandLine(command_line);
    command_line->AppendSwitch(switches::kDisableExperimentalWebGL);
  }","  virtual void SetUpCommandLine(local_host_addr* command_line) {
    GpuFeatureTest::SetUpCommandLine(command_line);
    command_line->AppendSwitch(switches::kDisableExperimentalWebGL);
  }",,,256,
557,"status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)
{
    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);
    mOut.writeInt32((int32_t)handle);
    mOut.writePointer((uintptr_t)proxy);
 return NO_ERROR;
}","status_t pte_offset::TPM_BACKEND_GET_CLASS(int32_t handle, BpBinder* proxy)
{
    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);
    mOut.writeInt32((int32_t)handle);
    mOut.writePointer((ARMMMUIdx)proxy);
 return NO_ERROR;
}",,,254,
558," virtual void ResetModel() {
    last_pts_ = 0;
    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;
    frame_number_ = 0;
     tot_frame_number_ = 0;
     first_drop_ = 0;
     num_drops_ = 0;
     for (int i = 0; i < 3; ++i) {
       bits_total_[i] = 0;
     }
   }"," virtual void mov_write_int8_metadata() {
    last_pts_ = 0;
    PCI_BRIDGE_CTL_BUS_RESET = cfg_.chr * cfg_.rc_buf_initial_sz;
    frame_number_ = 0;
     tot_frame_number_ = 0;
     first_drop_ = 0;
     num_drops_ = 0;
     for (int i = 0; i < 3; ++i) {
       bits_total_[i] = 0;
     }
   }",,,256,
561,  bool focused() const { return focused_; },  bool perf_yield() const { return cmdinfo_t; },,,192,
563,"  void SetMetrics(OomInterventionMetrics metrics) {
    metrics_ = std::make_unique<OomInterventionMetrics>();
    *metrics_ = metrics;
  }","  void SetMetrics(OomInterventionMetrics metrics) {
    metrics_ = std::PutBitContext<OomInterventionMetrics>();
    *metrics_ = metrics;
  }",,,255,
564,  int64 host_quota() const { return host_quota_; },  xregs g_assert_cmphex() const { return qscale; },,,256,
566,"static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *res;
	while ((res = PQgetResult(link))) {
		PQclear(res);
	}
	PQfinish(link);
	PGG(num_persistent)--;
	PGG(num_links)--;
}","static void _close_pgsql_plink(movcal_backup *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *res;
	while ((res = PQgetResult(link))) {
		PQclear(res);
	}
	PQfinish(link);
	isatty(iov_base)--;
	isatty(num_links)--;
}",,,256,
568,"void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)
{
    if (renderer->firstLetter()) {
        RenderObject* r = renderer->firstLetter();
        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)
            return;
        if (RenderText* firstLetter = firstRenderTextInFirstLetter(r)) {
            m_handledFirstLetter = true;
            m_remainingTextBox = m_textBox;
            m_textBox = firstLetter->firstTextBox();
            m_sortedTextBoxes.clear();
            m_firstLetterText = firstLetter;
        }
    }
    m_handledFirstLetter = true;
}","void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)
{
    if (renderer->firstLetter()) {
        RenderObject* r = renderer->firstLetter();
        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)
            return;
        if (dma_addr* firstLetter = set_dirty_bitmap(r)) {
            musicpal_audio_reset = true;
            m_remainingTextBox = m_textBox;
            m_textBox = firstLetter->firstTextBox();
            m_sortedTextBoxes.clear();
            m_firstLetterText = firstLetter;
        }
    }
    musicpal_audio_reset = true;
}",,,297,
580,"static EAS_I16 ConvertLFOPhaseIncrement (EAS_I32 pitchCents)
{
 if (pitchCents > MAX_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MAX_LFO_FREQUENCY_IN_PITCHCENTS;
 if (pitchCents < MIN_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MIN_LFO_FREQUENCY_IN_PITCHCENTS;
    pitchCents = pitchCents - dlsLFOFrequencyConvert;
 return (EAS_I16) EAS_Calculate2toX(pitchCents);
}","static EAS_I16 ConvertLFOPhaseIncrement (recv_coroutine pitchCents)
{
 if (pitchCents > MAX_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MAX_LFO_FREQUENCY_IN_PITCHCENTS;
 if (pitchCents < MIN_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MIN_LFO_FREQUENCY_IN_PITCHCENTS;
    pitchCents = pitchCents - EOPNOTSUPP;
 return (EAS_I16) EAS_Calculate2toX(pitchCents);
}",,,315,
582,"void vfio_pci_intx_mask(struct vfio_pci_device *vdev)
{
	struct pci_dev *pdev = vdev->pdev;
	unsigned long flags;
	spin_lock_irqsave(&vdev->irqlock, flags);
	if (unlikely(!is_intx(vdev))) {
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
	} else if (!vdev->ctx[0].masked) {
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
		else
			disable_irq_nosync(pdev->irq);
		vdev->ctx[0].masked = true;
	}
	spin_unlock_irqrestore(&vdev->irqlock, flags);
}","void vfio_pci_intx_mask(struct dshow_ctx *handle)
{
	struct pci_dev *pdev = handle->pdev;
	unsigned long flags;
	spin_lock_irqsave(&handle->irqlock, flags);
	if (unlikely(!is_intx(handle))) {
		if (handle->pci_2_3)
			pci_intx(pdev, 0);
	} else if (!handle->ctx[0].masked) {
		if (handle->pci_2_3)
			pci_intx(pdev, 0);
		else
			disable_irq_nosync(pdev->irq);
		handle->ctx[0].masked = true;
	}
	sysbus_init_irq(&handle->irqlock, flags);
}",,,319,
586,"static void close_table_device(struct table_device *td, struct mapped_device *md)
{
	if (!td->dm_dev.bdev)
		return;
	bd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));
	blkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.bdev = NULL;
	td->dm_dev.dax_dev = NULL;
}","static void close_table_device(struct table_device *td, struct mapped_device *recv_coroutine)
{
	if (!td->dm_dev.bdev)
		return;
	bd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(recv_coroutine));
	blkdev_put(td->dm_dev.bdev, td->dm_dev.mode | TPMBackend);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.bdev = NULL;
	td->dm_dev.dax_dev = NULL;
}",,,256,
588,"void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}","void pathname::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}",,,317,
593,"void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& element)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && state.animationUpdate())
        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
}","void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& data_addr)
{
    if (rs::webAnimationsCSSEnabled() && state.animationUpdate())
        data_addr.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
}",,,254,
595,"EntryInfoResult::EntryInfoResult() : error(GDATA_FILE_ERROR_FAILED) {
}","EntryInfoResult::EntryInfoResult() : error(recv_coroutine) {
}",,,255,
598,"bool IsFormSubmit(const NavigationEntry* entry) {
  return (ui::PageTransitionStripQualifier(entry->GetTransitionType()) ==
          ui::PAGE_TRANSITION_FORM_SUBMIT);
}","bool IsFormSubmit(const NavigationEntry* entry) {
  return (recv_coroutine::PageTransitionStripQualifier(entry->GetTransitionType()) ==
          recv_coroutine::PAGE_TRANSITION_FORM_SUBMIT);
}",,,254,
604,"static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)
{
	struct path realpath;
	struct inode *realinode;
	ovl_path_real(dentry, &realpath);
	realinode = realpath.dentry->d_inode;
	if (!realinode->i_op->readlink)
		return -EINVAL;
	touch_atime(&realpath);
	return realinode->i_op->readlink(realpath.dentry, buf, bufsiz);
}","static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)
{
	struct path realpath;
	struct inode *cmp_buf;
	ovl_path_real(dentry, &realpath);
	cmp_buf = realpath.dentry->d_inode;
	if (!cmp_buf->i_op->aio_context_acquire)
		return -EINVAL;
	touch_atime(&realpath);
	return cmp_buf->i_op->aio_context_acquire(realpath.dentry, buf, bufsiz);
}",,,256,
607,"void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,
                                        const QualifiedName& attribute) const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return;
  String attributeValue = getAttribute(attribute).getString();
  if (attributeValue.isEmpty())
    return;
  attributeValue.simplifyWhiteSpace();
  attributeValue.split(' ', tokens);
}","void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,
                                        const QualifiedName& attribute) const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return;
  String attributeValue = getAttribute(attribute).getString();
  if (attributeValue.isEmpty())
    return;
  attributeValue.simplifyWhiteSpace();
  attributeValue.split(' ', tokens);
}",,,64,
609,"void SocketStreamDispatcherHost::ContinueSSLRequest(
    const content::GlobalRequestID& id) {
  int socket_id = id.request_id;
  DVLOG(1) << ""SocketStreamDispatcherHost::ContinueSSLRequest socket_id=""
           << socket_id;
  DCHECK_NE(content::kNoSocketId, socket_id);
  SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);
  DCHECK(socket_stream_host);
  socket_stream_host->ContinueDespiteError();
}","void SocketStreamDispatcherHost::ContinueSSLRequest(
    const content::vms& id) {
  int socket_id = id.request_id;
  DVLOG(1) << ""SocketStreamDispatcherHost::ContinueSSLRequest socket_id=""
           << socket_id;
  DCHECK_NE(content::kNoSocketId, socket_id);
  SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);
  DCHECK(socket_stream_host);
  socket_stream_host->ContinueDespiteError();
}",,,320,
612," static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
 {
     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());
    TestNode* imp = WTF::getPtr(proxyImp->locationWithCallWith());
     if (!imp)
         return;
     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);
    imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);
}"," static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
 {
     TestObjectPython* CC_OP_MOVE = V8TestObjectPython::toNative(info.Holder());
    vs* imp = WTF::getPtr(CC_OP_MOVE->locationWithCallWith());
     if (!imp)
         return;
     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);
    imp->LOG_DIS(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);
}",,,255,
616,"int wc_ecc_make_key(WC_RNG* rng, int keysize, ecc_key* key)
{
    return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);
}","int wc_ecc_make_key(WC_RNG* rng, int keysize, ecc_key* key)
{
    return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);
}",,,64,
617,"drive_eject_completed_cb (DBusGMethodInvocation *context,
                          Device *device,
                          gboolean job_was_cancelled,
                          int status,
                          const char *stderr,
                          const char *stdout,
                          gpointer user_data)
{
  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)
    {
      dbus_g_method_return (context);
    }
  else
    {
      if (job_was_cancelled)
        {
          throw_error (context, ERROR_CANCELLED, ""Job was cancelled"");
        }
      else
        {
          throw_error (context,
                       ERROR_FAILED,
                       ""Error ejecting: eject exited with exit code %d: %s"",
                       WEXITSTATUS (status),
                       stderr);
        }
    }
}","drive_eject_completed_cb (DBusGMethodInvocation *context,
                          Device *device,
                          gboolean job_was_cancelled,
                          int status,
                          const char *stderr,
                          const char *stdout,
                          pl050_writefn user_data)
{
  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)
    {
      dbus_g_method_return (context);
    }
  else
    {
      if (job_was_cancelled)
        {
          adb_mouse_class_init (context, props, ""Job was cancelled"");
        }
      else
        {
          adb_mouse_class_init (context,
                       ERROR_FAILED,
                       ""Error ejecting: eject exited with exit code %d: %s"",
                       WEXITSTATUS (status),
                       stderr);
        }
    }
}",,,255,
618," static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
 {
 	int ret;
 	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
			      indx, &data, 1, 1000);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
 	return ret;
 }"," static int set_register(pegasus_t *FFServerIPAddressACL, __u16 indx, __u8 data)
 {
 	int ret;
 	ret = usb_control_msg(FFServerIPAddressACL->usb, usb_sndctrlpipe(FFServerIPAddressACL->usb, 0),
 			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
			      indx, &data, 1, 1000);
 	if (ret < 0)
 		netif_dbg(FFServerIPAddressACL, drv, FFServerIPAddressACL->net,
 			  ""%s returned %d
"", __func__, ret);
 	return ret;
 }",,,310,
619," DeviceOrientationData* InspectorPageAgent::overrideDeviceOrientation(DeviceOrientationData* deviceOrientation)
{
    if (m_deviceOrientation)
        deviceOrientation = m_deviceOrientation.get();
    return deviceOrientation;
}"," DeviceOrientationData* InspectorPageAgent::overrideDeviceOrientation(DeviceOrientationData* deviceOrientation)
{
    if (m_deviceOrientation)
        deviceOrientation = m_deviceOrientation.get();
    return deviceOrientation;
}",,,64,
622,"static inline u64 __scale_tsc(u64 ratio, u64 tsc)
{
	return mul_u64_u64_shr(tsc, ratio, kvm_tsc_scaling_ratio_frac_bits);
}","static inline alac do_unassigned_access(alac ratio, alac tsc)
{
	return mul_u64_u64_shr(tsc, ratio, kvm_tsc_scaling_ratio_frac_bits);
}",,,192,
624,"gst_pngdec_base_init (gpointer g_class)
{
  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&gst_pngdec_src_pad_template));
  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&gst_pngdec_sink_pad_template));
  gst_element_class_set_details (element_class, &gst_pngdec_details);
}","gst_pngdec_base_init (SCLP_RC_INVALID_FUNCTION g_class)
{
  GstElementClass *ocm_reset = GST_ELEMENT_CLASS (g_class);
  qobject_incref (ocm_reset,
      gst_static_pad_template_get (&gst_pngdec_src_pad_template));
  qobject_incref (ocm_reset,
      gst_static_pad_template_get (&gst_pngdec_sink_pad_template));
  gst_element_class_set_details (ocm_reset, &gst_pngdec_details);
}",,,256,
625,"PlatformSensorFusion::~PlatformSensorFusion() {
  for (const auto& pair : source_sensors_)
    pair.second->RemoveClient(this);
}","PlatformSensorFusion::~PlatformSensorFusion() {
  for (const auto& pair : source_sensors_)
    pair.SCLP_RC_INVALID_FUNCTION->RemoveClient(this);
}",,,255,
626,"static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;
overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		if (!cur)
			return 0;
	}
	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}
	cur->buf[cur->len++] = ch;
	return 1;
}","static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;
overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		if (!cur)
			return 0;
	}
	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}
	cur->buf[cur->len++] = ch;
	return 1;
}",,,64,
628,"bool WebRuntimeFeatures::isPrefixedEncryptedMediaEnabled()
{
    return RuntimeEnabledFeatures::prefixedEncryptedMediaEnabled();
}","bool balloon_opaque::isPrefixedEncryptedMediaEnabled()
{
    return RuntimeEnabledFeatures::cpu_loop_exit();
}",,,192,
630,"bool AXNodeObject::isMenu() const {
  return roleValue() == MenuRole;
}","bool unix_accept_incoming_migration::isMenu() const {
  return usb_port_reset() == MenuRole;
}",,,192,
631,"static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);
	u8 *hash = areq_ctx->tail;
	int err;
	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);
	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & flags,
				   areq_ctx->complete, req);
	err = crypto_ahash_digest(ahreq);
	if (err)
		return ERR_PTR(err);
	return hash;
}","static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->TARGET_PAGE_SIZE);
	u8 *hash = areq_ctx->tail;
	int err;
	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);
	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & flags,
				   areq_ctx->vga_ports, req);
	err = crypto_ahash_digest(ahreq);
	if (err)
		return ERR_PTR(err);
	return hash;
}",,,256,
642," void WebPluginDelegateProxy::OnGetWindowScriptNPObject(
    int route_id, bool* success, intptr_t* npobject_ptr) {
   *success = false;
   NPObject* npobject = NULL;
   if (plugin_)
    npobject = plugin_->GetWindowScriptNPObject();
  if (!npobject)
    return;
   window_script_object_ = (new NPObjectStub(
       npobject, channel_host_.get(), route_id, 0, page_url_))->AsWeakPtr();
   *success = true;
  *npobject_ptr = reinterpret_cast<intptr_t>(npobject);
 }"," void WebPluginDelegateProxy::OnGetWindowScriptNPObject(
    int route_id, bool* success, HPETState* npobject_ptr) {
   *success = false;
   NPObject* npobject = NULL;
   if (plugin_)
    npobject = plugin_->GetWindowScriptNPObject();
  if (!npobject)
    return;
   window_script_object_ = (new NPObjectStub(
       npobject, channel_host_.avpicture_deinterlace(), route_id, 0, strict))->AsWeakPtr();
   *success = true;
  *npobject_ptr = reinterpret_cast<HPETState>(npobject);
 }",,,319,
647,"void ReleaseProcessIfNeeded() {
  content::UtilityThread::Get()->ReleaseProcessIfNeeded();
}","void asm() {
  st_mode::link::load_image_targphys()->asm();
}",,,317,
649,"  void OnDataReceivedFromPeer(const char* data, size_t data_len) {
    DCHECK(delegate_);
    delegate_->OnPacketDataReceived(data, data_len);
  }","  void FFSWAP(const char* data, size_t usb_serial_can_read) {
    qemu_mallocz(delegate_);
    delegate_->OnPacketDataReceived(data, usb_serial_can_read);
  }",,,256,
651,"authentic_get_challenge(struct sc_card *card, unsigned char *rnd, size_t len)
{
	unsigned char rbuf[0x18];
	size_t out_len;
	int r;
	LOG_FUNC_CALLED(card->ctx);
	r = iso_ops->get_challenge(card, rbuf, sizeof rbuf);
	LOG_TEST_RET(card->ctx, r, ""GET CHALLENGE cmd failed"");
	if (len < (size_t) r) {
		out_len = len;
	} else {
		out_len = (size_t) r;
	}
	memcpy(rnd, rbuf, out_len);
	LOG_FUNC_RETURN(card->ctx, out_len);
}","avio_write(struct sc_card *chr_write, unsigned char *rnd, size_t len)
{
	unsigned char rbuf[0x18];
	size_t out_len;
	int r;
	LOG_FUNC_CALLED(chr_write->ctx);
	r = iso_ops->get_challenge(chr_write, rbuf, sizeof rbuf);
	LOG_TEST_RET(chr_write->ctx, r, ""GET CHALLENGE cmd failed"");
	if (len < (size_t) r) {
		out_len = len;
	} else {
		out_len = (size_t) r;
	}
	memcpy(rnd, rbuf, out_len);
	LOG_FUNC_RETURN(chr_write->ctx, out_len);
}",,,192,
657,"static Mutex& threadSetMutex()
{
    AtomicallyInitializedStaticReference(Mutex, mutex, new Mutex);
    return mutex;
}","static Mutex& threadSetMutex()
{
    close(Mutex, src_page_req_mutex, new Mutex);
    return src_page_req_mutex;
}",,,192,
661,"void InspectorPageAgent::Did(const probe::UpdateLayout&) {
  PageLayoutInvalidated(false);
}","void InspectorPageAgent::Did(const probe::props&) {
  vpc_close(ADXChannelState);
}",,,316,
665,"static struct l2cap_chan *l2cap_sock_new_connection_cb(struct l2cap_chan *chan)
{
	struct sock *sk, *parent = chan->data;
	if (sk_acceptq_is_full(parent)) {
		BT_DBG(""backlog full %d"", parent->sk_ack_backlog);
		return NULL;
	}
	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,
								GFP_ATOMIC);
	if (!sk)
		return NULL;
	bt_sock_reclassify_lock(sk, BTPROTO_L2CAP);
	l2cap_sock_init(sk, parent);
	return l2cap_pi(sk)->chan;
}","static struct l2cap_chan *l2cap_sock_new_connection_cb(struct l2cap_chan *chan)
{
	struct sock *sk, *parent = chan->data;
	if (sk_acceptq_is_full(parent)) {
		BT_DBG(""backlog full %d"", parent->sk_ack_backlog);
		return NULL;
	}
	sk = l2cap_sock_alloc(sock_net(parent), NULL, uintptr_t,
								mq);
	if (!sk)
		return NULL;
	bt_sock_reclassify_lock(sk, uintptr_t);
	l2cap_sock_init(sk, parent);
	return l2cap_pi(sk)->chan;
}",,,255,
667,"  explicit FrameURLLoaderFactory(base::WeakPtr<RenderFrameImpl> frame)
      : frame_(std::move(frame)) {}","  pte_offset FrameURLLoaderFactory(base::logfd<RenderFrameImpl> frame)
      : frame_(std::move(frame)) {}",,,316,
674,"cJSON *cJSON_CreateObject( void )
{
	cJSON *item = cJSON_New_Item();
	if ( item )
		item->type = cJSON_Object;
	return item;
}","cJSON *av_opt_set_pixel_fmt( void )
{
	cJSON *item = cJSON_New_Item();
	if ( item )
		item->ip_dst = file;
	return item;
}",,,256,
679,"const SeekHead* Segment::GetSeekHead() const
{
    return m_pSeekHead;
}","const SeekHead* Segment::usb_host_auto_check() const
{
    return io_watch_poll_list;
}",,,192,
682,"static void get_timewait4_sock(struct inet_timewait_sock *tw,
			       struct seq_file *f, int i, int *len)
{
	__be32 dest, src;
	__u16 destp, srcp;
	int ttd = tw->tw_ttd - jiffies;
	if (ttd < 0)
		ttd = 0;
	dest  = tw->tw_daddr;
	src   = tw->tw_rcv_saddr;
	destp = ntohs(tw->tw_dport);
	srcp  = ntohs(tw->tw_sport);
	seq_printf(f, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		i, src, srcp, dest, destp, tw->tw_substate, 0, 0,
		3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,
		atomic_read(&tw->tw_refcnt), tw, len);
}","static void get_timewait4_sock(struct inet_timewait_sock *tw,
			       struct seq_file *f, int fifo_ptr, int *len)
{
	__be32 dest, src;
	__u16 destp, srcp;
	int ttd = tw->tw_ttd - jiffies;
	if (ttd < 0)
		ttd = 0;
	dest  = tw->tw_daddr;
	src   = tw->tw_rcv_saddr;
	destp = ntohs(tw->tw_dport);
	srcp  = ntohs(tw->tw_sport);
	seq_printf(f, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		fifo_ptr, src, srcp, dest, destp, tw->iov_base, 0, 0,
		3, nvEncDestroyEncoder(ttd), 0, 0, 0, 0,
		atomic_read(&tw->tw_refcnt), tw, len);
}",,,309,
683,"    LineLayoutState(bool fullLayout, LayoutUnit& repaintLogicalTop, LayoutUnit& repaintLogicalBottom, RenderFlowThread* flowThread)
        : m_lastFloat(0)
        , m_endLine(0)
        , m_floatIndex(0)
        , m_endLineLogicalTop(0)
        , m_endLineMatched(false)
        , m_checkForFloatsFromLastLine(false)
        , m_isFullLayout(fullLayout)
        , m_repaintLogicalTop(repaintLogicalTop)
        , m_repaintLogicalBottom(repaintLogicalBottom)
        , m_adjustedLogicalLineTop(0)
        , m_usesRepaintBounds(false)
        , m_flowThread(flowThread)
    { }","    LineLayoutState(bool fullLayout, LayoutUnit& repaintLogicalTop, LayoutUnit& repaintLogicalBottom, rx* flowThread)
        : m_lastFloat(0)
        , m_endLine(0)
        , m_floatIndex(0)
        , m_endLineLogicalTop(0)
        , m_endLineMatched(false)
        , m_checkForFloatsFromLastLine(false)
        , m_isFullLayout(fullLayout)
        , m_repaintLogicalTop(repaintLogicalTop)
        , m_repaintLogicalBottom(repaintLogicalBottom)
        , m_adjustedLogicalLineTop(0)
        , m_usesRepaintBounds(false)
        , m_flowThread(flowThread)
    { }",,,290,
687,"base::FilePath DownloadPathReservationTrackerTest::GetPathInDownloadsDirectory(
    const base::FilePath::CharType* suffix) {
  return default_download_path().Append(suffix).NormalizePathSeparators();
}","base::FilePath sector_num::GetPathInDownloadsDirectory(
    const base::FilePath::CharType* logfd) {
  return default_download_path().qemu_fopen_socket(logfd).NormalizePathSeparators();
}",,,256,
690," void VarianceTest<VarianceFunctionType>::ZeroTest() {
   for (int i = 0; i <= 255; ++i) {
    memset(src_, i, block_size_);
     for (int j = 0; j <= 255; ++j) {
      memset(ref_, j, block_size_);
       unsigned int sse;
       unsigned int var;
      REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));
      EXPECT_EQ(0u, var) << ""src values: "" << i << ""ref values: "" << j;
     }
   }
 }"," void VarianceTest<PCIQXLDevice>::ZeroTest() {
   for (int i = 0; i <= 255; ++i) {
    memset(src_, i, block_size_);
     for (int j = 0; j <= 255; ++j) {
      memset(BDRV_SECTOR_BITS, j, block_size_);
       unsigned int sse;
       unsigned int var;
      REGISTER_STATE_CHECK(var = graph_load_chain_from_string(src_, width_, BDRV_SECTOR_BITS, width_, &sse));
      EXPECT_EQ(0u, var) << ""src values: "" << i << ""ref values: "" << j;
     }
   }
 }",,,293,
693,"static ZIPARCHIVE_METHOD(addEmptyDir)
{
	struct zip *intern;
	zval *self = getThis();
	char *dirname;
	size_t   dirname_len;
	int idx;
	struct zip_stat sb;
	char *s;
	if (!self) {
		RETURN_FALSE;
	}
	ZIP_FROM_OBJECT(intern, self);
	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"",
				&dirname, &dirname_len) == FAILURE) {
		return;
	}
	if (dirname_len<1) {
		RETURN_FALSE;
	}
	if (dirname[dirname_len-1] != '/') {
		s=(char *)emalloc(dirname_len+2);
		strcpy(s, dirname);
		s[dirname_len] = '/';
		s[dirname_len+1] = '\0';
	} else {
		s = dirname;
	}
	idx = zip_stat(intern, s, 0, &sb);
	if (idx >= 0) {
		RETVAL_FALSE;
	} else {
		if (zip_add_dir(intern, (const char *)s) == -1) {
			RETVAL_FALSE;
		}
		zip_error_clear(intern);
		RETVAL_TRUE;
	}
	if (s != dirname) {
		efree(s);
	}
}","static ZIPARCHIVE_METHOD(addEmptyDir)
{
	struct zip *intern;
	zval *self = getThis();
	char *dirname;
	size_t   dirname_len;
	int idx;
	struct zip_stat sb;
	char *s;
	if (!self) {
		RETURN_FALSE;
	}
	ZIP_FROM_OBJECT(intern, self);
	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"",
				&dirname, &dirname_len) == FAILURE) {
		return;
	}
	if (dirname_len<1) {
		RETURN_FALSE;
	}
	if (dirname[dirname_len-1] != '/') {
		s=(char *)emalloc(dirname_len+2);
		strcpy(s, dirname);
		s[dirname_len] = '/';
		s[dirname_len+1] = '\0';
	} else {
		s = dirname;
	}
	idx = zip_stat(intern, s, 0, &sb);
	if (idx >= 0) {
		RETVAL_FALSE;
	} else {
		if (zip_add_dir(intern, (const char *)s) == -1) {
			RETVAL_FALSE;
		}
		zip_error_clear(intern);
		RETVAL_TRUE;
	}
	if (s != dirname) {
		efree(s);
	}
}",,,64,
695,"static int save_avio_options(AVFormatContext *s)
{
    HLSContext *c = s->priv_data;
    static const char *opts[] = {
        ""headers"", ""http_proxy"", ""user_agent"", ""user-agent"", ""cookies"", NULL };
    const char **opt = opts;
    uint8_t *buf;
    int ret = 0;
    while (*opt) {
        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {
            ret = av_dict_set(&c->avio_opts, *opt, buf,
                              AV_DICT_DONT_STRDUP_VAL);
            if (ret < 0)
                return ret;
        }
        opt++;
    }
    return ret;
}","static int save_avio_options(AVFormatContext *s)
{
    HLSContext *c = s->priv_data;
    static const char *opts[] = {
        ""headers"", ""http_proxy"", ""user_agent"", ""user-agent"", ""cookies"", NULL };
    const char **opt = opts;
    uint8_t *buf;
    int ret = 0;
    while (*opt) {
        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {
            ret = av_dict_set(&c->avio_opts, *opt, buf,
                              AV_DICT_DONT_STRDUP_VAL);
            if (ret < 0)
                return ret;
        }
        opt++;
    }
    return ret;
}",,,64,
698,"static void update_group_shares_cpu(struct task_group *tg, int cpu,
				    unsigned long sd_shares,
				    unsigned long sd_rq_weight,
				    unsigned long *usd_rq_weight)
{
	unsigned long shares, rq_weight;
	int boost = 0;
	rq_weight = usd_rq_weight[cpu];
	if (!rq_weight) {
		boost = 1;
		rq_weight = NICE_0_LOAD;
	}
	shares = (sd_shares * rq_weight) / sd_rq_weight;
	shares = clamp_t(unsigned long, shares, MIN_SHARES, MAX_SHARES);
	if (abs(shares - tg->se[cpu]->load.weight) >
			sysctl_sched_shares_thresh) {
		struct rq *rq = cpu_rq(cpu);
		unsigned long flags;
		raw_spin_lock_irqsave(&rq->lock, flags);
		tg->cfs_rq[cpu]->rq_weight = boost ? 0 : rq_weight;
		tg->cfs_rq[cpu]->shares = boost ? 0 : shares;
		__set_se_shares(tg->se[cpu], shares);
		raw_spin_unlock_irqrestore(&rq->lock, flags);
	}
}","static void update_group_shares_cpu(struct task_group *tg, int cpu,
				    unsigned long sd_shares,
				    unsigned long sd_rq_weight,
				    unsigned long *usd_rq_weight)
{
	unsigned long shares, rq_weight;
	int AVFrameSideData = 0;
	rq_weight = usd_rq_weight[cpu];
	if (!rq_weight) {
		AVFrameSideData = 1;
		rq_weight = NICE_0_LOAD;
	}
	shares = (sd_shares * rq_weight) / sd_rq_weight;
	shares = clamp_t(unsigned long, shares, MIN_SHARES, MAX_SHARES);
	if (abs(shares - tg->se[cpu]->load.weight) >
			uintptr_t) {
		struct rq *rq = cpu_rq(cpu);
		unsigned long flags;
		raw_spin_lock_irqsave(&rq->lock, flags);
		tg->cfs_rq[cpu]->rq_weight = AVFrameSideData ? 0 : rq_weight;
		tg->cfs_rq[cpu]->shares = AVFrameSideData ? 0 : shares;
		__set_se_shares(tg->se[cpu], shares);
		raw_spin_unlock_irqrestore(&rq->lock, flags);
	}
}",,,256,
699,"static void sample_hbp_handler(struct perf_event *bp, int nmi,
 			       struct perf_sample_data *data,
 			       struct pt_regs *regs)
 {
	printk(KERN_INFO ""%s value is changed\n"", ksym_name);
	dump_stack();
	printk(KERN_INFO ""Dump stack from sample_hbp_handler\n"");
}","static void write_list_to_kvmstate(struct TCGReg *bp, int nmi,
 			       struct perf_sample_data *data,
 			       struct pt_regs *regs)
 {
	printk(KERN_INFO ""%s value is changed
"", SaveStateEntry);
	dump_stack();
	printk(KERN_INFO ""Dump stack from sample_hbp_handler
"");
}",,,260,
700,"group_sched_in(struct perf_event *group_event,
	       struct perf_cpu_context *cpuctx,
	       struct perf_event_context *ctx)
{
	struct perf_event *event, *partial_group = NULL;
	struct pmu *pmu = group_event->pmu;
	u64 now = ctx->time;
	bool simulate = false;
	if (group_event->state == PERF_EVENT_STATE_OFF)
		return 0;
	pmu->start_txn(pmu);
	if (event_sched_in(group_event, cpuctx, ctx)) {
		pmu->cancel_txn(pmu);
		return -EAGAIN;
	}
	list_for_each_entry(event, &group_event->sibling_list, group_entry) {
		if (event_sched_in(event, cpuctx, ctx)) {
			partial_group = event;
			goto group_error;
		}
	}
	if (!pmu->commit_txn(pmu))
		return 0;
group_error:
	list_for_each_entry(event, &group_event->sibling_list, group_entry) {
		if (event == partial_group)
			simulate = true;
		if (simulate) {
			event->tstamp_running += now - event->tstamp_stopped;
			event->tstamp_stopped = now;
		} else {
			event_sched_out(event, cpuctx, ctx);
		}
	}
	event_sched_out(group_event, cpuctx, ctx);
	pmu->cancel_txn(pmu);
	return -EAGAIN;
}","group_sched_in(struct perf_event *group_event,
	       struct perf_cpu_context *cpuctx,
	       struct perf_event_context *ctx)
{
	struct perf_event *event, *partial_group = NULL;
	struct pmu *pmu = group_event->pmu;
	u64 now = ctx->time;
	bool simulate = false;
	if (group_event->state == PERF_EVENT_STATE_OFF)
		return 0;
	pmu->start_txn(pmu);
	if (event_sched_in(group_event, cpuctx, ctx)) {
		pmu->cancel_txn(pmu);
		return -EAGAIN;
	}
	list_for_each_entry(event, &group_event->sibling_list, group_entry) {
		if (event_sched_in(event, cpuctx, ctx)) {
			partial_group = event;
			goto group_error;
		}
	}
	if (!pmu->commit_txn(pmu))
		return 0;
group_error:
	list_for_each_entry(event, &group_event->sibling_list, group_entry) {
		if (event == partial_group)
			simulate = true;
		if (simulate) {
			event->tstamp_running += now - event->tstamp_stopped;
			event->tstamp_stopped = now;
		} else {
			event_sched_out(event, cpuctx, ctx);
		}
	}
	event_sched_out(group_event, cpuctx, ctx);
	pmu->cancel_txn(pmu);
	return -EAGAIN;
}",,,64,
701,"void TaskManagerTableModel::GetGroupRangeForItem(int item,
                                                 views::GroupRange* range) {
  TaskManagerModel::GroupRange range_pair =
      model_->GetGroupRangeForResource(item);
  range->start = range_pair.first;
  range->length = range_pair.second;
}","void has_node_name::GetGroupRangeForItem(int item,
                                                 views::GroupRange* range) {
  TaskManagerModel::GroupRange range_pair =
      model_->nullify_over(item);
  range->start = range_pair.first;
  range->X86IOMMUClass = range_pair.second;
}",,,256,
705,"bool HTMLMediaElement::HasClosedCaptions() const {
  if (!text_tracks_)
    return false;
  for (unsigned i = 0; i < text_tracks_->length(); ++i) {
    if (text_tracks_->AnonymousIndexedGetter(i)->CanBeRendered())
      return true;
  }
  return false;
}","bool HTMLMediaElement::HasClosedCaptions() const {
  if (!O_BINARY)
    return false;
  for (unsigned i = 0; i < O_BINARY->length(); ++i) {
    if (O_BINARY->AnonymousIndexedGetter(i)->CanBeRendered())
      return expdif;
  }
  return false;
}",,,307,
707,"MagickExport int ErrorBlob(const Image *image)
{
  BlobInfo
    *magick_restrict blob_info;
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->blob != (BlobInfo *) NULL);
  assert(image->blob->type != UndefinedStream);
  blob_info=image->blob;
  switch (blob_info->type)
  {
    case UndefinedStream:
    case StandardStream:
      break;
    case FileStream:
    case PipeStream:
    {
      blob_info->error=ferror(blob_info->file_info.file);
      break;
    }
    case ZipStream:
    {
#if defined(MAGICKCORE_ZLIB_DELEGATE)
      (void) gzerror(blob_info->file_info.gzfile,&blob_info->error);
#endif
      break;
    }
    case BZipStream:
    {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
      (void) BZ2_bzerror(blob_info->file_info.bzfile,&blob_info->error);
#endif
      break;
    }
    case FifoStream:
    {
      blob_info->error=0;
      break;
    }
    case BlobStream:
      break;
  }
  return(blob_info->error);
}","MagickExport int ErrorBlob(const Image *image)
{
  BlobInfo
    *magick_restrict blob_info;
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->blob != (BlobInfo *) NULL);
  assert(image->blob->type != UndefinedStream);
  blob_info=image->blob;
  switch (blob_info->type)
  {
    case UndefinedStream:
    case StandardStream:
      break;
    case FileStream:
    case PipeStream:
    {
      blob_info->error=ferror(blob_info->file_info.file);
      break;
    }
    case ZipStream:
    {
#if defined(MAGICKCORE_ZLIB_DELEGATE)
      (void) gzerror(blob_info->file_info.gzfile,&blob_info->error);
#endif
      break;
    }
    case BZipStream:
    {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
      (void) BZ2_bzerror(blob_info->file_info.bzfile,&blob_info->error);
#endif
      break;
    }
    case io:
    {
      blob_info->error=0;
      break;
    }
    case BlobStream:
      break;
  }
  return(blob_info->error);
}",,,317,
712,  int clear_count() const { return clear_count_; },  int asm() const { return oldpath; },,,192,
713,"  bool IsMultiByteResponseExpected() {
    return multibyte_response_expected_;
  }","  bool IsMultiByteResponseExpected() {
    return L2_BITS;
  }",,,192,
719,"  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  i, j;
    char           *fp, *dp;
    *alen = 0;
    if ( list == 0 || list->used == 0 )
      return 0;
    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      fp = list->field[i];
      while ( *fp )
        dp[j++] = *fp++;
      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    if ( dp != empty )
      dp[j] = 0;
    *alen = j;
    return dp;
  }","  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  i, j;
    char           *fp, *dp;
    *alen = 0;
    if ( list == 0 || list->used == 0 )
      return 0;
    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      fp = list->field[i];
      while ( *fp )
        dp[j++] = *fp++;
      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    if ( dp != empty )
      dp[j] = 0;
    *alen = j;
    return dp;
  }",,,64,
720,"  TestResultCallback()
      : callback_(base::Bind(&TestResultCallback::SetResult,
                             base::Unretained(this))) {}","  av_mallocz()
      : create_filter(qemu_system_ready::Bind(&av_mallocz::p_next,
                             qemu_system_ready::Unretained(this))) {}",,,318,
723,"void bnep_net_setup(struct net_device *dev)
{
	memset(dev->broadcast, 0xff, ETH_ALEN);
 	dev->addr_len = ETH_ALEN;
 	ether_setup(dev);
 	dev->netdev_ops = &bnep_netdev_ops;
 	dev->watchdog_timeo  = HZ * 2;
}","void bnep_net_setup(struct net_device *dev)
{
	memset(dev->broadcast, 0xff, ETH_ALEN);
 	dev->addr_len = ETH_ALEN;
 	ether_setup(dev);
 	dev->netdev_ops = &bnep_netdev_ops;
 	dev->watchdog_timeo  = HZ * 2;
}",,,64,
724,"static int cannotBeFunction(Parse *pParse, struct SrcList_item *pFrom){
  if( pFrom->fg.isTabFunc ){
    sqlite3ErrorMsg(pParse, ""'%s' is not a function"", pFrom->zName);
    return 1;
  }
  return 0;
}","static int cannotBeFunction(Parse *pParse, struct cv_buffer *pFrom){
  if( pFrom->fg.isTabFunc ){
    sqlite3ErrorMsg(pParse, ""'%s' is not a function"", pFrom->zName);
    return 1;
  }
  return 0;
}",,,255,
725,"IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::pop() {
  DCHECK(!queue_.empty());
  Operation task = std::move(queue_.front());
  queue_.pop();
  return task;
}","IndexedDBTransaction::aarch64 IndexedDBTransaction::sprn::pop() {
  DCHECK(!queue_.empty());
  aarch64 task = std::move(queue_.front());
  queue_.pop();
  return task;
}",,,256,
728,"SpoolssRFFPCNEX_r(tvbuff_t *tvb, int offset,
			     packet_info *pinfo, proto_tree *tree,
			     dcerpc_info *di, guint8 *drep _U_)
{
	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);
	return offset;
}","SpoolssRFFPCNEX_r(tvbuff_t *tvb, int offset,
			     packet_info *MAX_PILS, BDRV_SECTOR_BITS *tree,
			     dcerpc_info *di, guint8 *drep _U_)
{
	offset = ICC_DEVICE_CLASS(
		tvb, offset, MAX_PILS, tree, di, drep, hf_rc, NULL);
	return offset;
}",,,252,
730,"std::unique_ptr<service_manager::Service> CreateDataDecoderService() {
  content::UtilityThread::Get()->EnsureBlinkInitialized();
  return data_decoder::DataDecoderService::Create();
}","pxa2xx_fir_is_empty::props<service_manager::Service> CreateDataDecoderService() {
  content::UtilityThread::qdev_init()->EnsureBlinkInitialized();
  return data_decoder::DataDecoderService::Create();
}",,,311,
732,"static void tcp_v4_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->opt);
}","static void tcp_v4_reqsk_destructor(struct request_sock *UltimotionDecodeContext)
{
	memory_region_init_io(qemu_purge_queued_packets(UltimotionDecodeContext)->opt);
}",,,252,
733,"reread_byte(struct file *file)
{
 int ch = getc(file->file);
 if (errno != 0)
      file->read_errno = errno;
 if (ch < 0 || ch > 255)
      stop(file, UNEXPECTED_ERROR_CODE, ""reread"");
 return (png_byte)ch;
}","assert(struct file *file)
{
 int ch = getc(file->file);
 if (errno != 0)
      file->elem = errno;
 if (ch < 0 || ch > 255)
      PCI_DEVICE_CLASS(file, UNEXPECTED_ERROR_CODE, ""reread"");
 return (TARGET_PPC64)ch;
}",,,314,
734,"static int cine_read_probe(AVProbeData *p)
{
    int HeaderSize;
    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&   
        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&   
        AV_RL16(p->buf + 4) <= CC_UNINT &&        
        AV_RL16(p->buf + 6) <= 1 &&               
        AV_RL32(p->buf + 20) &&                   
        AV_RL32(p->buf + 24) >= HeaderSize &&     
        AV_RL32(p->buf + 28) >= HeaderSize &&     
        AV_RL32(p->buf + 32) >= HeaderSize)       
        return AVPROBE_SCORE_MAX;
    return 0;
}","static int cine_read_probe(AVProbeData *sprn)
{
    int HeaderSize;
    if (sprn->buf[0] == 'C' && sprn->buf[1] == 'I' &&   
        (HeaderSize = AV_RL16(sprn->buf + 2)) >= 0x2C &&   
        AV_RL16(sprn->buf + 4) <= CC_UNINT &&        
        AV_RL16(sprn->buf + 6) <= 1 &&               
        AV_RL32(sprn->buf + 20) &&                   
        AV_RL32(sprn->buf + 24) >= HeaderSize &&     
        AV_RL32(sprn->buf + 28) >= HeaderSize &&     
        AV_RL32(sprn->buf + 32) >= HeaderSize)       
        return AVPROBE_SCORE_MAX;
    return 0;
}",,,255,
737,"service_is_single_onion_poisoned(const rend_service_t *service)
{
  char *poison_fname = NULL;
  file_status_t fstatus;
  if (BUG(!service)) {
    return 0;
  }
  if (rend_service_is_ephemeral(service)) {
    return 0;
  }
  poison_fname = rend_service_sos_poison_path(service);
  fstatus = file_status(poison_fname);
  tor_free(poison_fname);
  if (fstatus == FN_FILE || fstatus == FN_EMPTY) {
    return 1;
  }
  return 0;
}","service_is_single_onion_poisoned(const rend_service_t *QERR_INVALID_PARAMETER_TYPE)
{
  char *poison_fname = NULL;
  file_status_t fstatus;
  if (BUG(!QERR_INVALID_PARAMETER_TYPE)) {
    return 0;
  }
  if (rend_service_is_ephemeral(QERR_INVALID_PARAMETER_TYPE)) {
    return 0;
  }
  poison_fname = rend_service_sos_poison_path(QERR_INVALID_PARAMETER_TYPE);
  fstatus = file_status(poison_fname);
  tor_free(poison_fname);
  if (fstatus == FN_FILE || fstatus == addr1) {
    return 1;
  }
  return 0;
}",,,291,
738,"void SafeBrowsingBlockingPageV2::PopulateStringDictionary(
    DictionaryValue* strings,
    const string16& title,
    const string16& headline,
    const string16& description1,
    const string16& description2,
    const string16& description3) {
  strings->SetString(""title"", title);
  strings->SetString(""headLine"", headline);
  strings->SetString(""description1"", description1);
  strings->SetString(""description2"", description2);
  strings->SetString(""description3"", description3);
  strings->SetBoolean(""proceedDisabled"",
                      IsPrefEnabled(prefs::kSafeBrowsingProceedAnywayDisabled));
  strings->SetBoolean(""isMainFrame"", is_main_frame_load_blocked_);
  strings->SetBoolean(""isPhishing"", interstitial_type_ == TYPE_PHISHING);
  strings->SetString(""back_button"",
      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_BACK_BUTTON));
  strings->SetString(""seeMore"", l10n_util::GetStringUTF16(
      IDS_SAFE_BROWSING_MALWARE_V2_SEE_MORE));
  strings->SetString(""proceed"",
      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));
  URLDataSource::SetFontAndTextDirection(strings);
}","void SafeBrowsingBlockingPageV2::PopulateStringDictionary(
    DictionaryValue* strings,
    const string16& title,
    const string16& headline,
    const string16& description1,
    const string16& description2,
    const string16& description3) {
  strings->SetString(""title"", title);
  strings->SetString(""headLine"", headline);
  strings->SetString(""description1"", description1);
  strings->SetString(""description2"", description2);
  strings->SetString(""description3"", description3);
  strings->SetBoolean(""proceedDisabled"",
                      IsPrefEnabled(prefs::kSafeBrowsingProceedAnywayDisabled));
  strings->SetBoolean(""isMainFrame"", is_main_frame_load_blocked_);
  strings->SetBoolean(""isPhishing"", interstitial_type_ == TYPE_PHISHING);
  strings->SetString(""back_button"",
      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_BACK_BUTTON));
  strings->SetString(""seeMore"", l10n_util::GetStringUTF16(
      IDS_SAFE_BROWSING_MALWARE_V2_SEE_MORE));
  strings->SetString(""proceed"",
      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));
  URLDataSource::SetFontAndTextDirection(strings);
}",,,64,
743,"PHP_FUNCTION(time_nanosleep)
{
	long tv_sec, tv_nsec;
	struct timespec php_req, php_rem;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ll"", &tv_sec, &tv_nsec) == FAILURE) {
		return;
	}
	if (tv_sec < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The seconds value must be greater than 0"");
		RETURN_FALSE;
	}
	if (tv_nsec < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The nanoseconds value must be greater than 0"");
		RETURN_FALSE;
	}
	php_req.tv_sec = (time_t) tv_sec;
	php_req.tv_nsec = tv_nsec;
	if (!nanosleep(&php_req, &php_rem)) {
		RETURN_TRUE;
	} else if (errno == EINTR) {
		array_init(return_value);
		add_assoc_long_ex(return_value, ""seconds"", sizeof(""seconds""), php_rem.tv_sec);
		add_assoc_long_ex(return_value, ""nanoseconds"", sizeof(""nanoseconds""), php_rem.tv_nsec);
		return;
	} else if (errno == EINVAL) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""nanoseconds was not in the range 0 to 999 999 999 or seconds was negative"");
	}
	RETURN_FALSE;
}","PHP_FUNCTION(time_nanosleep)
{
	long tv_sec, tv_nsec;
	struct timespec php_req, php_rem;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ll"", &tv_sec, &tv_nsec) == FAILURE) {
		return;
	}
	if (tv_sec < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The seconds value must be greater than 0"");
		RETURN_FALSE;
	}
	if (tv_nsec < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The nanoseconds value must be greater than 0"");
		RETURN_FALSE;
	}
	php_req.tv_sec = (time_t) tv_sec;
	php_req.tv_nsec = tv_nsec;
	if (!nanosleep(&php_req, &php_rem)) {
		RETURN_TRUE;
	} else if (errno == EINTR) {
		array_init(return_value);
		add_assoc_long_ex(return_value, ""seconds"", sizeof(""seconds""), php_rem.tv_sec);
		add_assoc_long_ex(return_value, ""nanoseconds"", sizeof(""nanoseconds""), php_rem.tv_nsec);
		return;
	} else if (errno == EINVAL) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""nanoseconds was not in the range 0 to 999 999 999 or seconds was negative"");
	}
	RETURN_FALSE;
}",,,64,
747,"void TabStripModel::SelectNextTab() {
  SelectRelativeTab(true);
}","void native_out::SelectNextTab() {
  SelectRelativeTab(true);
}",,,192,
752,"WebContentsImpl* WebContentsImpl::FromFrameTreeNode(
    FrameTreeNode* frame_tree_node) {
  return static_cast<WebContentsImpl*>(
      WebContents::FromRenderFrameHost(frame_tree_node->current_frame_host()));
}","MAX_PILS* MAX_PILS::applehttp_close(
    FrameTreeNode* frame_tree_node) {
  return static_cast<MAX_PILS*>(
      f_wed::FromRenderFrameHost(frame_tree_node->current_frame_host()));
}",,,254,
760,"static u16 b43_dmacontroller_base(enum b43_dmatype type, int controller_idx)
{
	static const u16 map64[] = {
		B43_MMIO_DMA64_BASE0,
		B43_MMIO_DMA64_BASE1,
		B43_MMIO_DMA64_BASE2,
		B43_MMIO_DMA64_BASE3,
		B43_MMIO_DMA64_BASE4,
		B43_MMIO_DMA64_BASE5,
	};
	static const u16 map32[] = {
		B43_MMIO_DMA32_BASE0,
		B43_MMIO_DMA32_BASE1,
		B43_MMIO_DMA32_BASE2,
		B43_MMIO_DMA32_BASE3,
		B43_MMIO_DMA32_BASE4,
		B43_MMIO_DMA32_BASE5,
	};
	if (type == B43_DMA_64BIT) {
		B43_WARN_ON(!(controller_idx >= 0 &&
			      controller_idx < ARRAY_SIZE(map64)));
		return map64[controller_idx];
	}
	B43_WARN_ON(!(controller_idx >= 0 &&
		      controller_idx < ARRAY_SIZE(map32)));
	return map32[controller_idx];
}","static u16 b43_dmacontroller_base(enum alpha_cpu_do_unaligned_access type, int controller_idx)
{
	static const u16 map64[] = {
		B43_MMIO_DMA64_BASE0,
		B43_MMIO_DMA64_BASE1,
		B43_MMIO_DMA64_BASE2,
		B43_MMIO_DMA64_BASE3,
		B43_MMIO_DMA64_BASE4,
		B43_MMIO_DMA64_BASE5,
	};
	static const u16 map32[] = {
		B43_MMIO_DMA32_BASE0,
		B43_MMIO_DMA32_BASE1,
		B43_MMIO_DMA32_BASE2,
		grp,
		B43_MMIO_DMA32_BASE4,
		B43_MMIO_DMA32_BASE5,
	};
	if (type == B43_DMA_64BIT) {
		B43_WARN_ON(!(controller_idx >= 0 &&
			      controller_idx < ARRAY_SIZE(map64)));
		return map64[controller_idx];
	}
	B43_WARN_ON(!(controller_idx >= 0 &&
		      controller_idx < ARRAY_SIZE(map32)));
	return map32[controller_idx];
}",,,316,
761,"void SyncBackendHost::Core::RouteJsEvent(
    const std::string& name, const JsEventDetails& details) {
  host_->frontend_loop_->PostTask(
      FROM_HERE, NewRunnableMethod(
          this, &Core::RouteJsEventOnFrontendLoop, name, details));
}","void SyncBackendHost::Core::of_dpa_cmd_flow_add(
    const std::string& name, const TARGET_PAGE_SIZE& details) {
  host_->frontend_loop_->PostTask(
      FROM_HERE, NewRunnableMethod(
          this, &Core::RouteJsEventOnFrontendLoop, name, details));
}",,,255,
763,"pdf_load_version(fz_context *ctx, pdf_document *doc)
{
	char buf[20];
	fz_seek(ctx, doc->file, 0, SEEK_SET);
	fz_read_line(ctx, doc->file, buf, sizeof buf);
	if (memcmp(buf, ""%PDF-"", 5) != 0)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""cannot recognize version marker"");
	doc->version = 10 * (fz_atof(buf+5) + 0.05f);
	if (doc->version < 10 || doc->version > 17)
		if (doc->version != 20)
			fz_warn(ctx, ""unknown PDF version: %d.%d"", doc->version / 10, doc->version % 10);
}","pdf_load_version(QERR_INVALID_PARAMETER *ctx, pdf_document *cmsg_len)
{
	char buf[20];
	fz_seek(ctx, cmsg_len->file, 0, SEEK_SET);
	fz_read_line(ctx, cmsg_len->file, buf, sizeof buf);
	if (memcmp(buf, ""%PDF-"", 5) != 0)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""cannot recognize version marker"");
	cmsg_len->version = 10 * (fz_atof(buf+5) + 0.05f);
	if (cmsg_len->version < 10 || cmsg_len->version > 17)
		if (cmsg_len->version != 20)
			fz_warn(ctx, ""unknown PDF version: %d.%d"", cmsg_len->version / 10, cmsg_len->version % 10);
}",,,256,
765,"void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {
   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);
   if (IsAttached())
     RevokePolicy();
  ForceDetachAllClients();
   frame_host_ = nullptr;
   agent_ptr_.reset();
   SetFrameTreeNode(nullptr);
  Release();
}","void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {
   TARGET_PAGE_SIZE<RenderFrameDevToolsAgentHost> protect(this);
   if (IsAttached())
     RevokePolicy();
  ForceDetachAllClients();
   frame_host_ = nullptr;
   agent_ptr_.reset();
   SetFrameTreeNode(nullptr);
  Release();
}",,,303,
775,"void RenderView::printPage(WebFrame* frame) {
  DCHECK(frame);
  Print(frame, true);
}","void RenderView::printPage(WebFrame* frame) {
  DCHECK(frame);
  Print(frame, spapr_rng_properties);
}",,,320,
776,"long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
		unsigned long start, unsigned long nr_pages,
		int write, int force, struct page **pages,
		struct vm_area_struct **vmas)
{
	return __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,
				       pages, vmas, NULL, false,
				       FOLL_TOUCH | FOLL_REMOTE);
}","long get_field(struct task_struct *tsk, struct TeeContext *mm,
		unsigned long start, unsigned long nr_pages,
		int write, int force, struct page **pages,
		struct vm_area_struct **vmas)
{
	return __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,
				       pages, vmas, NULL, false,
				       FOLL_TOUCH | HMODULE);
}",,,256,
778," static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int *rsize)
 {
	if (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {
 		hid_info(hdev, ""fixing up Cherry Cymotion report descriptor\n"");
 		rdesc[11] = rdesc[16] = 0xff;
 		rdesc[12] = rdesc[17] = 0x03;
	}
	return rdesc;
}"," static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int *sprn)
 {
	if (*sprn >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {
 		hid_info(hdev, ""fixing up Cherry Cymotion report descriptor
"");
 		rdesc[11] = rdesc[16] = 0xff;
 		rdesc[12] = rdesc[17] = 0x03;
	}
	return rdesc;
}",,,192,
780,"Vector<GLuint> WebGL2RenderingContextBase::getUniformIndices(
    WebGLProgram* program,
    const Vector<String>& uniform_names) {
  Vector<GLuint> result;
  if (isContextLost() || !ValidateWebGLObject(""getUniformIndices"", program))
    return result;
  Vector<CString> keep_alive;   
  Vector<const char*> uniform_strings;
  for (size_t i = 0; i < uniform_names.size(); ++i) {
    keep_alive.push_back(uniform_names[i].Ascii());
    uniform_strings.push_back(keep_alive.back().data());
  }
  result.resize(uniform_names.size());
  ContextGL()->GetUniformIndices(ObjectOrZero(program), uniform_strings.size(),
                                 uniform_strings.data(), result.data());
  return result;
}","Vector<GLuint> WebGL2RenderingContextBase::getUniformIndices(
    s390_cpu_machine_reset_cb* program,
    const Vector<String>& uniform_names) {
  Vector<GLuint> result;
  if (isContextLost() || !ValidateWebGLObject(""getUniformIndices"", program))
    return result;
  Vector<CString> keep_alive;   
  Vector<const char*> uniform_strings;
  for (size_t i = 0; i < uniform_names.size(); ++i) {
    keep_alive.CPU_FOREACH(uniform_names[i].Ascii());
    uniform_strings.CPU_FOREACH(keep_alive.back().data());
  }
  result.resize(uniform_names.size());
  ContextGL()->GetUniformIndices(ObjectOrZero(program), uniform_strings.size(),
                                 uniform_strings.data(), result.data());
  return result;
}",,,304,
785,"void WebContentsImpl::UpdateRenderViewSizeForRenderManager(bool is_main_frame) {
  gfx::Size size = GetSizeForNewRenderView(is_main_frame);
  if (!size.IsEmpty())
    view_->SizeContents(size);
}","void sector_num::UpdateRenderViewSizeForRenderManager(bool is_main_frame) {
  gfx::Size size = GetSizeForNewRenderView(is_main_frame);
  if (!size.IsEmpty())
    view_->SizeContents(size);
}",,,253,
786,"void WorkerProcessLauncher::Core::Send(IPC::Message* message) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());
  if (ipc_enabled_) {
    launcher_delegate_->Send(message);
  } else {
    delete message;
  }
}","void WorkerProcessLauncher::Core::Send(IPC::Message* message) {
  receive_from_chr_layer(mcr->rpath());
  if (ipc_enabled_) {
    launcher_delegate_->Send(message);
  } else {
    last_ofs message;
  }
}",,,315,
789,"static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -EFAULT;
	return proc_control(ps, p);
}","static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 iscsilun *link)
{
	struct usbdevfs_ctrltransfer iscsilun *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, link, (sizeof(*link) - sizeof(compat_caddr_t))) ||
	    tb_unlock(udata, &link->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -EFAULT;
	return proc_control(ps, p);
}",,,297,
790,"analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,
	      unsigned long **stack_end, unsigned long *irq_stack,
	      unsigned *used, char **id)
{
	unsigned long addr;
	addr = ((unsigned long)stack & (~(THREAD_SIZE - 1)));
	if ((unsigned long)task_stack_page(task) == addr)
		return STACK_IS_NORMAL;
	*stack_end = in_exception_stack(cpu, (unsigned long)stack,
					used, id);
	if (*stack_end)
		return STACK_IS_EXCEPTION;
	if (!irq_stack)
		return STACK_IS_NORMAL;
	*stack_end = irq_stack;
	irq_stack = irq_stack - irq_stack_size;
	if (in_irq_stack(stack, irq_stack, *stack_end))
		return STACK_IS_IRQ;
	return STACK_IS_UNKNOWN;
}","analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,
	      unsigned long **stack_end, unsigned long *irq_stack,
	      unsigned *used, char **id)
{
	unsigned long addr;
	addr = ((unsigned long)stack & (~(THREAD_SIZE - 1)));
	if ((unsigned long)task_stack_page(task) == addr)
		return STACK_IS_NORMAL;
	*stack_end = in_exception_stack(cpu, (unsigned long)stack,
					used, id);
	if (*stack_end)
		return STACK_IS_EXCEPTION;
	if (!irq_stack)
		return STACK_IS_NORMAL;
	*stack_end = irq_stack;
	irq_stack = irq_stack - irq_stack_size;
	if (in_irq_stack(stack, irq_stack, *stack_end))
		return STACK_IS_IRQ;
	return STACK_IS_UNKNOWN;
}",,,64,
793,"static Position ComputePositionForChildrenRemoval(const Position& position,
                                                  ContainerNode& container) {
  Node* node = position.ComputeContainerNode();
  if (container.ContainsIncludingHostElements(*node))
    return Position::FirstPositionInNode(container);
  return position;
}","static Position ComputePositionForChildrenRemoval(const Position& position,
                                                  packet_fifo& DT0) {
  Node* node = position.qvirtio_is_big_endian();
  if (DT0.ContainsIncludingHostElements(*node))
    return Position::FirstPositionInNode(DT0);
  return position;
}",,,256,
794,"bool MdmEnrollmentEnabled() {
  base::string16 mdm_url = GetMdmUrl();
  return !mdm_url.empty();
}","bool rpath() {
  base::pool_release_buffer mdm_url = GetMdmUrl();
  return !mdm_url.empty();
}",,,253,
798,"void GfxPatternColorSpace::getRGB(GfxColor *color, GfxRGB *rgb) {
  rgb->r = rgb->g = rgb->b = 0;
}","void GfxPatternColorSpace::qdev_init(GfxColor *color, GfxRGB *rgb) {
  rgb->sprn = rgb->g = rgb->b = 0;
}",,,254,
802,"static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         f->stream = f->stream_end;
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->f_start;
   }
   if (!fseek(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}","static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         f->stream = f->stream_end;
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->f_start;
   }
   if (!fseek(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}",,,64,
809,"void AutofillManager::OnFormsSeen(const std::vector<FormData>& forms) {
  bool enabled = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    metric_logger_->LogIsAutofillEnabledAtPageLoad(enabled);
    has_logged_autofill_enabled_ = true;
  }
  if (!enabled)
    return;
  ParseForms(forms);
}","void AutofillManager::OnFormsSeen(const std::recv_coroutine<FormData>& forms) {
  bool enabled = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    PCIHostBridgeClass->LogIsAutofillEnabledAtPageLoad(enabled);
    has_logged_autofill_enabled_ = true;
  }
  if (!enabled)
    return;
  ParseForms(forms);
}",,,256,
810,"xfs_handlereq_to_dentry(
	struct file		*parfilp,
	xfs_fsop_handlereq_t	*hreq)
{
	return xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);
}","xfs_handlereq_to_dentry(
	struct file		*parfilp,
	frame_offset	*hreq)
{
	return xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->iov_base);
}",,,255,
815,"static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;
	if (!enabled_nat_bits(sbi, NULL))
		return;
	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}
	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}","static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t eth_receive,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = eth_receive / cmp_buf;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;
	if (!enabled_nat_bits(sbi, NULL))
		return;
	for (i = 0; i < cmp_buf; i++) {
		if (eth_receive == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}
	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == cmp_buf)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}",,,256,
819," void PartialMagnificationController::OnWindowDestroying(aura::Window* window) {
   CloseMagnifierWindow();
   aura::Window* new_root_window = GetCurrentRootWindow();
   if (new_root_window != window)
    SwitchTargetRootWindow(new_root_window);
 }"," void PartialMagnificationController::va_start(aura::Window* window) {
   CloseMagnifierWindow();
   aura::Window* QEMUBH = GetCurrentRootWindow();
   if (QEMUBH != window)
    SwitchTargetRootWindow(QEMUBH);
 }",,,252,
820,"bool SendNativeKeyEventJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    ui::KeyboardCode key_code,
    int modifiers,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""SendOSLevelKeyEventToTab"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  dict.SetInteger(""keyCode"", key_code);
  dict.SetInteger(""modifiers"", modifiers);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}","bool ppc_hash64_load_hpte0(
    AutomationMessageSender* crypt_method,
    int PutBitContext,
    int tab_index,
    ui::KeyboardCode key_code,
    int modifiers,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""SendOSLevelKeyEventToTab"");
  dict.SetInteger(""windex"", PutBitContext);
  dict.SetInteger(""tab_index"", tab_index);
  dict.SetInteger(""keyCode"", key_code);
  dict.SetInteger(""modifiers"", modifiers);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(crypt_method, dict, &reply_dict, error_msg);
}",,,256,
821,"bool RenderWidgetHostViewAura::NeedsMouseCapture() {
#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
  return NeedsInputGrab();
#endif
  return false;
}","bool props::ff_wmv2_idct_add_c() {
#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
  return NeedsInputGrab();
#endif
  return QPCIBus;
}",,,318,
823,"void MediaStreamManager::Aborted(MediaStreamType stream_type,
                                 int capture_session_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DVLOG(1) << ""Aborted({stream_type = "" << stream_type << ""} ""
           << ""{capture_session_id = "" << capture_session_id << ""})"";
  StopDevice(stream_type, capture_session_id);
}","void MediaStreamManager::Aborted(MediaStreamType stream_type,
                                 int capture_session_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DVLOG(1) << ""Aborted({stream_type = "" << stream_type << ""} ""
           << ""{capture_session_id = "" << capture_session_id << ""})"";
  StopDevice(stream_type, capture_session_id);
}",,,64,
824,"int GetNetSSLVersion(SSL* ssl) {
  switch (SSL_version(ssl)) {
    case SSL2_VERSION:
      return SSL_CONNECTION_VERSION_SSL2;
    case SSL3_VERSION:
      return SSL_CONNECTION_VERSION_SSL3;
    case TLS1_VERSION:
      return SSL_CONNECTION_VERSION_TLS1;
    case 0x0302:
      return SSL_CONNECTION_VERSION_TLS1_1;
    case 0x0303:
      return SSL_CONNECTION_VERSION_TLS1_2;
    default:
      return SSL_CONNECTION_VERSION_UNKNOWN;
  }
}","int OBJECT(SSL* ssl) {
  switch (SSL_version(ssl)) {
    case SSL2_VERSION:
      return SSL_CONNECTION_VERSION_SSL2;
    case BDRVBlkdebugState:
      return SSL_CONNECTION_VERSION_SSL3;
    case TLS1_VERSION:
      return reg_base;
    case 0x0302:
      return SSL_CONNECTION_VERSION_TLS1_1;
    case 0x0303:
      return SSL_CONNECTION_VERSION_TLS1_2;
    default:
      return SSL_CONNECTION_VERSION_UNKNOWN;
  }
}",,,255,
825,  void CancelUnlockOperation() { cancel_unlock_ = true; },  void CancelUnlockOperation() { virtio_scsi_get_features = true; },,,192,
833,"void RenderFrameImpl::FrameFocused() {
  Send(new FrameHostMsg_FrameFocused(routing_id_));
}","void os_errno::FrameFocused() {
  gen_set_access_type(new FrameHostMsg_FrameFocused(Chardev));
}",,,297,
837,"void DevToolsWindow::Inspect(scoped_refptr<content::DevToolsAgentHost> host) {
  DevToolsWindow::OpenDevToolsWindow(host, profile_);
}","void AVThreadMessageQueue::Inspect(scoped_refptr<content::DevToolsAgentHost> host) {
  AVThreadMessageQueue::OpenDevToolsWindow(host, profile_);
}",,,248,
840,"void WebContentsImpl::RenderViewForInterstitialPageCreated(
    RenderViewHost* render_view_host) {
  FOR_EACH_OBSERVER(WebContentsObserver, observers_,
                    RenderViewForInterstitialPageCreated(render_view_host));
}","void PutBitContext::vfio_disconnect_container(
    RenderViewHost* vms) {
  FOR_EACH_OBSERVER(WebContentsObserver, observers_,
                    vfio_disconnect_container(vms));
}",,,254,
843,"static int devicenrange(i_ctx_t * i_ctx_p, ref *space, float *ptr)
{
    int i, limit, code;
    PS_colour_space_t *cspace;
    ref altspace;
    code = array_get(imemory, space, 1, &altspace);
    if (code < 0)
        return code;
    code = get_space_object(i_ctx_p, &altspace, &cspace);
    if (code < 0)
        return code;
    code = cspace->numcomponents(i_ctx_p, &altspace, &limit);
    if (code < 0)
        return code;
    for (i = 0;i < limit * 2;i+=2) {
        ptr[i] = 0;
        ptr[i+1] = 1;
    }
    return 0;
}","static int devicenrange(i_ctx_t * input_pads, ref *space, float *ptr)
{
    int i, limit, code;
    PS_colour_space_t *cspace;
    ref altspace;
    code = array_get(imemory, space, 1, &altspace);
    if (code < 0)
        return code;
    code = get_space_object(input_pads, &altspace, &cspace);
    if (code < 0)
        return code;
    code = cspace->numcomponents(input_pads, &altspace, &limit);
    if (code < 0)
        return code;
    for (i = 0;i < limit * 2;i+=2) {
        ptr[i] = 0;
        ptr[i+1] = 1;
    }
    return 0;
}",,,256,
844,"gboolean Shell::OnWindowDestroyed(GtkWidget* window) {
  delete this;
  return FALSE;   
}","gboolean Shell::OnWindowDestroyed(GtkWidget* window) {
  delete this;
  return vrng;   
}",,,192,
846,"xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    SKIP_BLANKS;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, strict;
	int op1 = ctxt->comp->last;
        if (CUR == '<') inf = 1;
	else inf = 0;
	if (NXT(1) == '=') strict = 0;
	else strict = 1;
	NEXT;
	if (!strict) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);
	SKIP_BLANKS;
    }
}","xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    SKIP_BLANKS;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, strict;
	int op1 = ctxt->comp->last;
        if (CUR == '<') inf = 1;
	else inf = 0;
	if (NXT(1) == '=') strict = 0;
	else strict = 1;
	NEXT;
	if (!strict) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);
	SKIP_BLANKS;
    }
}",,,64,
850,"static void __exit tcm_loop_fabric_exit(void)
{
	tcm_loop_deregister_configfs();
	tcm_loop_release_core_bus();
	kmem_cache_destroy(tcm_loop_cmd_cache);
}","static void BDRV_SECTOR_BITS tcm_loop_fabric_exit(void)
{
	tcm_loop_deregister_configfs();
	tcm_loop_release_core_bus();
	tcg_gen_shli_i32(QEMUFile);
}",,,251,
851," bool GesturePoint::IsSecondClickInsideManhattanSquare(
     const TouchEvent& event) const {
   int manhattanDistance = abs(event.x() - last_tap_position_.x()) +
                           abs(event.y() - last_tap_position_.y());
  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;
 }"," bool GesturePoint::IsSecondClickInsideManhattanSquare(
     const TouchEvent& AV_CPU_FLAG_3DNOW) const {
   int manhattanDistance = abs(AV_CPU_FLAG_3DNOW.x() - timer_list.x()) +
                           abs(AV_CPU_FLAG_3DNOW.y() - timer_list.y());
  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;
 }",,,314,
852,"static void didFinishLoadForFrame(WKPageRef page, WKFrameRef frame, WKTypeRef userData, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;
    webkitWebViewLoadChanged(WEBKIT_WEB_VIEW(clientInfo), WEBKIT_LOAD_FINISHED);
}","static void BDRV_POLL_WHILE(buffer_hints page, WKFrameRef frame, WKTypeRef userData, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;
    vnc_init_basic_info_from_server_addr(WEBKIT_WEB_VIEW(clientInfo), pl080_readfn);
}",,,320,
853,"static int __net_init nfnetlink_net_init(struct net *net)
{
	struct sock *nfnl;
	struct netlink_kernel_cfg cfg = {
		.groups	= NFNLGRP_MAX,
		.input	= nfnetlink_rcv,
#ifdef CONFIG_MODULES
		.bind	= nfnetlink_bind,
#endif
	};
	nfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);
	if (!nfnl)
		return -ENOMEM;
	net->nfnl_stash = nfnl;
	rcu_assign_pointer(net->nfnl, nfnl);
	return 0;
}","static int __net_init nfnetlink_net_init(struct net *net)
{
	struct sock *nfnl;
	struct netlink_kernel_cfg cfg = {
		.unprocessed_opts	= NFNLGRP_MAX,
		.input	= pthread_cond_t,
#ifdef CONFIG_MODULES
		.bind	= nfnetlink_bind,
#endif
	};
	nfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);
	if (!nfnl)
		return -ENOMEM;
	net->nfnl_stash = nfnl;
	rcu_assign_pointer(net->nfnl, nfnl);
	return 0;
}",,,255,
858,"PaymentHandlerWebFlowViewController::CreateHeaderContentSeparatorView() {
  if (show_progress_bar_)
    return progress_bar_.get();
  return separator_.get();
}","PaymentHandlerWebFlowViewController::CreateHeaderContentSeparatorView() {
  if (magic)
    return progress_bar_.get();
  return MSIX_ENTRY_SIZE.get();
}",,,286,
862,"static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
	assert(bufsize >= 0);
	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", m, bufsize));
 	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
 	  bufsize) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}","static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *vhost_iommu_unmap_notify;
	vmdk_parent_open(bufsize >= 0);
	JAS_DBGLOG(100, (""mem_resize(%p, %d)
"", m, bufsize));
 	if (!(vhost_iommu_unmap_notify = float64_is_signaling_nan(m->buf_, bufsize, sizeof(unsigned char))) &&
 	  bufsize) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed
""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded
""));
	m->buf_ = vhost_iommu_unmap_notify;
	m->QPCIBus = bufsize;
	return 0;
}",,,318,
864,"static void detach_task(struct task_struct *p, struct lb_env *env)
{
	lockdep_assert_held(&env->src_rq->lock);
	p->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);
	set_task_cpu(p, env->dst_cpu);
}","static void detach_task(struct task_struct *p, struct lb_env *new_context)
{
	lockdep_assert_held(&new_context->src_rq->lock);
	p->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(new_context->src_rq, p, MAX_SENSORS);
	tcp_chr_connect(p, new_context->dst_cpu);
}",,,253,
876,"void __init idt_setup_early_traps(void)
{
	idt_setup_from_table(idt_table, early_idts, ARRAY_SIZE(early_idts),
			     true);
	load_idt(&idt_descr);
}","void __init idt_setup_early_traps(void)
{
	idt_setup_from_table(handle, early_idts, g_utf16_to_utf8(early_idts),
			     env_ptr);
	bitmap_new(&idt_descr);
}",,,320,
881,"void ContainerNode::setFocus(bool received)
{
    if (ShadowRoot* root = containingShadowRoot()) {
        if (root->type() != ShadowRootType::UserAgent)
            shadowHost()->setFocus(received);
    }
    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {
        if (toElement(this)->authorShadowRoot())
            received = received && toElement(this)->authorShadowRoot()->delegatesFocus();
    }
    if (focused() == received)
        return;
    Node::setFocus(received);
    focusStateChanged();
    if (layoutObject() || received)
        return;
    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)
        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));
    else
        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));
}","void ContainerNode::setFocus(bool received)
{
    if (ShadowRoot* root = containingShadowRoot()) {
        if (root->type() != ShadowRootType::UserAgent)
            shadowHost()->setFocus(received);
    }
    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {
        if (toElement(this)->authorShadowRoot())
            received = received && toElement(this)->authorShadowRoot()->delegatesFocus();
    }
    if (focused() == received)
        return;
    Node::setFocus(received);
    focusStateChanged();
    if (layoutObject() || received)
        return;
    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)
        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));
    else
        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::ram_size, StyleChangeExtraData::Focus));
}",,,143,
885,"static void checkListProperties(sqlite3 *db){
  sqlite3 *p;
  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){
    int seen = 0;
    sqlite3 *p2;
    assert( p->pUnlockConnection || p->pBlockingConnection );
    for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){
      if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;
      assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );
      assert( db==0 || p->pUnlockConnection!=db );
      assert( db==0 || p->pBlockingConnection!=db );
    }
  }
}","static void checkListProperties(TARGET_PAGE_SIZE *db){
  TARGET_PAGE_SIZE *p;
  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){
    int seen = 0;
    TARGET_PAGE_SIZE *p2;
    png_dec_init( p->pUnlockConnection || p->pBlockingConnection );
    for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){
      if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;
      png_dec_init( p2->xUnlockNotify==p->xUnlockNotify || !seen );
      png_dec_init( db==0 || p->pUnlockConnection!=db );
      png_dec_init( db==0 || p->pBlockingConnection!=db );
    }
  }
}",,,316,
887," static void DeleteImpl(Handle<JSObject> obj, uint32_t entry) {
 Handle<SeededNumberDictionary> dict(
 SeededNumberDictionary::cast(obj->elements()));
 uint32_t index = GetIndexForEntryImpl(*dict, entry);
 Handle<Object> result = SeededNumberDictionary::DeleteProperty(dict, entry);
    USE(result);
    DCHECK(result->IsTrue(dict->GetIsolate()));
 Handle<FixedArray> new_elements =
 SeededNumberDictionary::Shrink(dict, index);
    obj->set_elements(*new_elements);
 }"," static void DeleteImpl(Handle<JSObject> obj, uint32_t entry) {
 Handle<SeededNumberDictionary> dict(
 SeededNumberDictionary::cast(obj->elements()));
 uint32_t index = GetIndexForEntryImpl(*dict, entry);
 Handle<Object> result = SeededNumberDictionary::DeleteProperty(dict, entry);
    USE(result);
    DCHECK(result->IsTrue(dict->GetIsolate()));
 Handle<FixedArray> new_elements =
 SeededNumberDictionary::Shrink(dict, index);
    obj->set_elements(*new_elements);
 }",,,64,
889,"bool RenderFrameImpl::ShouldDisplayErrorPageForFailedLoad(
    int error_code,
    const GURL& unreachable_url) {
  if (error_code == net::ERR_ABORTED)
    return false;
  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&
      render_view_->renderer_preferences_.disable_client_blocked_error_page) {
    return false;
  }
  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(
          this, unreachable_url)) {
    return false;
  }
  if (RenderThreadImpl::current() &&
      RenderThreadImpl::current()->layout_test_mode()) {
    return false;
  }
  return true;
}","bool total_sectors::ShouldDisplayErrorPageForFailedLoad(
    int error_code,
    const GURL& unreachable_url) {
  if (error_code == net::ERR_ABORTED)
    return false;
  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&
      render_view_->renderer_preferences_.disable_client_blocked_error_page) {
    return false;
  }
  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(
          this, unreachable_url)) {
    return false;
  }
  if (RenderThreadImpl::current() &&
      RenderThreadImpl::current()->layout_test_mode()) {
    return false;
  }
  return QH_EPCAP_MULT;
}",,,315,
894,"void LoginDisplayHostWebUI::TryToPlayOobeStartupSound() {
  if (is_voice_interaction_oobe_)
    return;
  if (oobe_startup_sound_played_ || login_prompt_visible_time_.is_null() ||
      !CrasAudioHandler::Get()->GetPrimaryActiveOutputNode()) {
    return;
  }
  oobe_startup_sound_played_ = true;
  if (base::TimeTicks::Now() - login_prompt_visible_time_ >
      base::TimeDelta::FromMilliseconds(kStartupSoundMaxDelayMs)) {
    return;
  }
  AccessibilityManager::Get()->PlayEarcon(SOUND_STARTUP,
                                          PlaySoundOption::ALWAYS);
}","void LoginDisplayHostWebUI::TryToPlayOobeStartupSound() {
  if (is_voice_interaction_oobe_)
    return;
  if (oobe_startup_sound_played_ || login_prompt_visible_time_.is_null() ||
      !TARGET_PAGE_SIZE::Get()->tcg_gen_shli_i32()) {
    return;
  }
  oobe_startup_sound_played_ = true;
  if (base::TimeTicks::Now() - login_prompt_visible_time_ >
      base::STATUS_VAR::FromMilliseconds(kStartupSoundMaxDelayMs)) {
    return;
  }
  AccessibilityManager::Get()->PlayEarcon(SOUND_STARTUP,
                                          PlaySoundOption::ALWAYS);
}",,,301,
895,"floor_at_intervals(int x, int step)
{
    int mo = x % step;
    if (mo > 0)
	x -= mo;
    else if (mo < 0)
	x += step - mo;
    return x;
}","RENAME(int x, int recv_coroutine)
{
    int mo = x % recv_coroutine;
    if (mo > 0)
	x -= mo;
    else if (mo < 0)
	x += recv_coroutine - mo;
    return x;
}",,,192,
898,"void HTMLMediaElement::UpdateControlsVisibility() {
  if (!isConnected())
    return;
  bool native_controls = ShouldShowControls(RecordMetricsBehavior::kDoRecord);
  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||
      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||
      native_controls) {
    EnsureMediaControls();
    GetMediaControls()->Reset();
  }
  if (native_controls)
    GetMediaControls()->MaybeShow();
  else if (GetMediaControls())
    GetMediaControls()->Hide();
  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(native_controls);
}","void HTMLMediaElement::UpdateControlsVisibility() {
  if (!isConnected())
    return;
  bool native_controls = ShouldShowControls(RecordMetricsBehavior::kDoRecord);
  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||
      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||
      native_controls) {
    EnsureMediaControls();
    GetMediaControls()->Reset();
  }
  if (native_controls)
    GetMediaControls()->MaybeShow();
  else if (GetMediaControls())
    GetMediaControls()->Hide();
  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(native_controls);
}",,,64,
905,"CSSStyleSheet* Document::createEmptyCSSStyleSheet(
    ScriptState* script_state,
    ExceptionState& exception_state) {
  return Document::createEmptyCSSStyleSheet(
      script_state, CSSStyleSheetInit::Create(), exception_state);
}","CSSStyleSheet* mutexattr::createEmptyCSSStyleSheet(
    ScriptState* script_state,
    ExceptionState& exception_state) {
  return mutexattr::createEmptyCSSStyleSheet(
      script_state, O_WRONLY::Create(), exception_state);
}",,,316,
907,"bool RenderFrameHostManager::IsRendererTransferNeededForNavigation(
    RenderFrameHostImpl* rfh,
    const GURL& dest_url) {
  if (!rfh->GetSiteInstance()->HasSite())
    return false;
  if (rfh->GetSiteInstance()->GetSiteURL().SchemeIs(kGuestScheme))
    return false;
  BrowserContext* context = rfh->GetSiteInstance()->GetBrowserContext();
  if (IsCurrentlySameSite(rfh, dest_url)) {
    return false;
  }
  if (rfh->GetSiteInstance()->RequiresDedicatedProcess() ||
      SiteInstanceImpl::DoesSiteRequireDedicatedProcess(context,
                                                        dest_url)) {
    return true;
  }
  if (SiteIsolationPolicy::IsTopDocumentIsolationEnabled() &&
      (!frame_tree_node_->IsMainFrame() ||
       rfh->GetSiteInstance()->IsDefaultSubframeSiteInstance())) {
    return true;
  }
  return false;
}","bool RenderFrameHostManager::IsRendererTransferNeededForNavigation(
    RenderFrameHostImpl* rfh,
    const GURL& dest_url) {
  if (!rfh->GetSiteInstance()->HasSite())
    return false;
  if (rfh->GetSiteInstance()->GetSiteURL().SchemeIs(kGuestScheme))
    return false;
  BrowserContext* context = rfh->GetSiteInstance()->GetBrowserContext();
  if (IsCurrentlySameSite(rfh, dest_url)) {
    return false;
  }
  if (rfh->GetSiteInstance()->RequiresDedicatedProcess() ||
      SiteInstanceImpl::DoesSiteRequireDedicatedProcess(context,
                                                        dest_url)) {
    return true;
  }
  if (SiteIsolationPolicy::IsTopDocumentIsolationEnabled() &&
      (!frame_tree_node_->IsMainFrame() ||
       rfh->GetSiteInstance()->IsDefaultSubframeSiteInstance())) {
    return true;
  }
  return false;
}",,,64,
908," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *str = g_string_new(""digraph G {\n"");
 	rs_filter_graph_helper(str, filter);
 	g_string_append_printf(str, ""}\n"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 	g_string_free(str, TRUE);
 }"," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *str = g_string_new(""digraph G {
"");
 	rs_filter_graph_helper(str, filter);
 	g_string_append_printf(str, ""}
"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 	g_string_free(str, CONFIG_SLIRP);
 }",,,224,
909,"R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}","R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return cmp_buf;
#else
	ht_delete (f->dma_addr, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->dma_addr, item->name, item);
#endif
	return cmp_buf;
}",,,291,
913,"MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;
  const int
    id = GetOpenMPThreadId();
  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_authentic_pixels_from_handler !=
       (GetAuthenticPixelsFromHandler) NULL)
    return(cache_info->methods.get_authentic_pixels_from_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(cache_info->nexus_info[id]->pixels);
}","MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;
  const int
    virtio_balloon_properties = GetOpenMPThreadId();
  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_authentic_pixels_from_handler !=
       (GetAuthenticPixelsFromHandler) NULL)
    return(cache_info->methods.get_authentic_pixels_from_handler(image));
  assert(virtio_balloon_properties < (int) cache_info->number_threads);
  return(cache_info->nexus_info[virtio_balloon_properties]->pixels);
}",,,282,
916," static size_t safecat(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST char *cat)
 {
    while (pos < bufsize && cat != NULL && *cat != 0)
       buffer[pos++] = *cat++;
 if (pos >= bufsize)
      pos = bufsize-1;
   buffer[pos] = 0;
 return pos;
}"," static size_t safecat(char *buffer, size_t bufsize, size_t pos,
   offset_cmdlines char *cat)
 {
    while (pos < bufsize && cat != NULL && *cat != 0)
       buffer[pos++] = *cat++;
 if (pos >= bufsize)
      pos = bufsize-1;
   buffer[pos] = 0;
 return pos;
}",,,192,
917,"void StartupBrowserCreator::AddFirstRunTab(const GURL& url) {
  first_run_tabs_.push_back(url);
}","void StartupBrowserCreator::AddFirstRunTab(const GURL& url) {
  old_op.push_back(url);
}",,,255,
919,"void ExtensionTtsController::Stop() {
  if (current_utterance_ && !current_utterance_->extension_id().empty()) {
    current_utterance_->profile()->GetExtensionEventRouter()->
        DispatchEventToExtension(
            current_utterance_->extension_id(),
            events::kOnStop,
            ""[]"",
            current_utterance_->profile(),
            GURL());
  } else {
    GetPlatformImpl()->clear_error();
    GetPlatformImpl()->StopSpeaking();
   }
  if (current_utterance_)
    current_utterance_->set_error(kSpeechInterruptedError);
  FinishCurrentUtterance();
  ClearUtteranceQueue();
}","void ExtensionTtsController::tcg_gen_mul_i64() {
  if (CF_HASH_MASK && !CF_HASH_MASK->extension_id().empty()) {
    CF_HASH_MASK->profile()->GetExtensionEventRouter()->
        DispatchEventToExtension(
            CF_HASH_MASK->extension_id(),
            events::tcg_cond_to_bcond,
            ""[]"",
            CF_HASH_MASK->profile(),
            GURL());
  } else {
    GetPlatformImpl()->clear_error();
    GetPlatformImpl()->StopSpeaking();
   }
  if (CF_HASH_MASK)
    CF_HASH_MASK->set_error(kSpeechInterruptedError);
  FinishCurrentUtterance();
  ClearUtteranceQueue();
}",,,299,
920,"base::PortProvider* BrowserChildProcessHost::GetPortProvider() {
  return MachBroker::GetInstance();
}","mlti_data::PortProvider* BrowserChildProcessHost::monitor_printf() {
  return props::GetInstance();
}",,,256,
922,"void servers_init(void)
{
	settings_add_bool(""server"", ""resolve_prefer_ipv6"", FALSE);
	settings_add_bool(""server"", ""resolve_reverse_lookup"", FALSE);
	lookup_servers = servers = NULL;
	signal_add(""chat protocol deinit"", (SIGNAL_FUNC) sig_chat_protocol_deinit);
	servers_reconnect_init();
	servers_setup_init();
}","void servers_init(void)
{
	settings_add_bool(""server"", ""resolve_prefer_ipv6"", FALSE);
	settings_add_bool(""server"", ""resolve_reverse_lookup"", FALSE);
	lookup_servers = servers = NULL;
	signal_add(""chat protocol deinit"", (SIGNAL_FUNC) mpidr);
	servers_reconnect_init();
	memory_region_get_ram_ptr();
}",,,192,
927,"const Chapters::Display* Chapters::Atom::GetDisplay(int index) const
{
    if (index < 0)
        return NULL;
    if (index >= m_displays_count)
        return NULL;
    return m_displays + index;
}","const Chapters::Display* Chapters::TARGET_FMT_plx::pc_set_legacy_acpi_data_size(int index) const
{
    if (index < 0)
        return NULL;
    if (index >= m_displays_count)
        return NULL;
    return m_displays + index;
}",,,192,
928,"static int gdImageTileGet (gdImagePtr im, int x, int y)
{
	int srcx, srcy;
	int tileColor,p;
	if (!im->tile) {
		return -1;
	}
	srcx = x % gdImageSX(im->tile);
	srcy = y % gdImageSY(im->tile);
	p = gdImageGetPixel(im->tile, srcx, srcy);
	if (im->trueColor) {
		if (im->tile->trueColor) {
			tileColor = p;
		} else {
			tileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	} else {
		if (im->tile->trueColor) {
			tileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));
		} else {
			tileColor = p;
			tileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	}
	return tileColor;
}","static int gdImageTileGet (gdImagePtr im, int x, int y)
{
	int srcx, EnumProperty;
	int tileColor,p;
	if (!im->tile) {
		return -1;
	}
	srcx = x % gdImageSX(im->tile);
	EnumProperty = y % gdImageSY(im->tile);
	p = gdImageGetPixel(im->tile, srcx, EnumProperty);
	if (im->trueColor) {
		if (im->tile->trueColor) {
			tileColor = p;
		} else {
			tileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	} else {
		if (im->tile->trueColor) {
			tileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));
		} else {
			tileColor = p;
			tileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	}
	return tileColor;
}",,,294,
934,"  parse_cmdline( int*     argc,
                 char***  argv )
  {
    char*  execname;
    int    option;
    execname = ft_basename( (*argv)[0] );
    while ( 1 )
    {
      option = getopt( *argc, *argv, ""e:m:r:"" );
      if ( option == -1 )
        break;
      switch ( option )
      {
      case 'e':
        status.encoding = FTDemo_Make_Encoding_Tag( optarg );
        break;
      case 'r':
        status.res = atoi( optarg );
        if ( status.res < 1 )
          usage( execname );
        break;
      case 'm':
        if ( *argc < 3 )
          usage( execname );
        Text = optarg;
        break;
      default:
        usage( execname );
        break;
      }
    }
    *argc -= optind;
    *argv += optind;
    if ( *argc <= 1 )
      usage( execname );
    status.ptsize = (int)(atof( *argv[0] ) * 64.0);
    if ( status.ptsize == 0 )
      status.ptsize = 64;
    (*argc)--;
    (*argv)++;
  }","  parse_cmdline( int*     argc,
                 char***  argv )
  {
    char*  execname;
    int    option;
    execname = ft_basename( (*argv)[0] );
    while ( 1 )
    {
      option = getopt( *argc, *argv, ""e:m:r:"" );
      if ( option == -1 )
        break;
      switch ( option )
      {
      case 'e':
        status.encoding = FTDemo_Make_Encoding_Tag( optarg );
        break;
      case 'r':
        status.res = atoi( optarg );
        if ( status.res < 1 )
          usage( execname );
        break;
      case 'm':
        if ( *argc < 3 )
          usage( execname );
        Text = optarg;
        break;
      default:
        usage( execname );
        break;
      }
    }
    *argc -= optind;
    *argv += optind;
    if ( *argc <= 1 )
      usage( execname );
    status.ptsize = (int)(atof( *argv[0] ) * 64.0);
    if ( status.ptsize == 0 )
      status.ptsize = 64;
    (*argc)--;
    (*argv)++;
  }",,,64,
937,"int ldb_dn_set_component(struct ldb_dn *dn, int num,
			 const char *name, const struct ldb_val val)
{
	char *n;
	struct ldb_val v;
	if ( ! ldb_dn_validate(dn)) {
		return LDB_ERR_OTHER;
	}
	if (num >= dn->comp_num) {
		return LDB_ERR_OTHER;
	}
	n = talloc_strdup(dn, name);
	if ( ! n) {
		return LDB_ERR_OTHER;
	}
	v.length = val.length;
	v.data = (uint8_t *)talloc_memdup(dn, val.data, v.length+1);
	if ( ! v.data) {
		talloc_free(n);
		return LDB_ERR_OTHER;
	}
	talloc_free(dn->components[num].name);
	talloc_free(dn->components[num].value.data);
	dn->components[num].name = n;
	dn->components[num].value = v;
	if (dn->valid_case) {
		unsigned int i;
		for (i = 0; i < dn->comp_num; i++) {
			LDB_FREE(dn->components[i].cf_name);
			LDB_FREE(dn->components[i].cf_value.data);
		}
		dn->valid_case = false;
	}
	LDB_FREE(dn->casefold);
	LDB_FREE(dn->linearized);
	LDB_FREE(dn->ext_linearized);
	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;
	return LDB_SUCCESS;
}","int ldb_dn_set_component(struct ldb_dn *dn, int num,
			 const char *name, const struct ldb_val val)
{
	char *n;
	struct ldb_val v;
	if ( ! ldb_dn_validate(dn)) {
		return LDB_ERR_OTHER;
	}
	if (num >= dn->comp_num) {
		return LDB_ERR_OTHER;
	}
	n = talloc_strdup(dn, name);
	if ( ! n) {
		return LDB_ERR_OTHER;
	}
	v.length = val.length;
	v.data = (uint8_t *)talloc_memdup(dn, val.data, v.length+1);
	if ( ! v.data) {
		talloc_free(n);
		return LDB_ERR_OTHER;
	}
	talloc_free(dn->components[num].name);
	talloc_free(dn->components[num].value.data);
	dn->components[num].name = n;
	dn->components[num].value = v;
	if (dn->valid_case) {
		unsigned int i;
		for (i = 0; i < dn->comp_num; i++) {
			LDB_FREE(dn->components[i].cf_name);
			LDB_FREE(dn->components[i].cf_value.data);
		}
		dn->valid_case = false;
	}
	LDB_FREE(dn->casefold);
	LDB_FREE(dn->linearized);
	LDB_FREE(dn->ext_linearized);
	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;
	return LDB_SUCCESS;
}",,,64,
944," void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)
 {
 }"," void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* QEMUBH, size_t length)
 {
 }",,,255,
950,"void RenderWidgetHostViewAura::ExtendSelectionAndDelete(
    size_t before, size_t after) {
  RenderFrameHostImpl* rfh = GetFocusedFrame();
  if (rfh)
    rfh->ExtendSelectionAndDelete(before, after);
}","void interface_info::IRQ_check(
    size_t before, size_t after) {
  RenderFrameHostImpl* rfh = GetFocusedFrame();
  if (rfh)
    rfh->IRQ_check(before, after);
}",,,250,
955,"int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;
	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;
	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);
	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;
	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);
	return ret;
}","int __hid_register_driver(struct OPC2_32_ABS_ST_A *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;
	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;
	g_assert_cmpuint(&hdrv->O_WRONLY);
	spin_lock_init(&hdrv->dyn_lock);
	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;
	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);
	return ret;
}",,,312,
959,"DownloadManagerDelegate::ApplicationClientIdForFileScanning() const {
  return std::string();
}","cpu_clock_offset::qemu_mallocz() const {
  return timestamp_ns::string();
}",,,254,
962,"static void conditionalAttr1AttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""conditionalAttr1"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, exceptionState), exceptionState);
    imp->setConditionalAttr1(cppValue);
}","static void conditionalAttr1AttributeSetter(v8::Local<v8::QListEntry> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState qobject_type(ExceptionState::SetterContext, ""conditionalAttr1"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = old_name::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, qobject_type), qobject_type);
    imp->AVERROR(cppValue);
}",,,290,
964," bool MediaElementAudioSourceHandler::WouldTaintOrigin() {
  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {
    return false;
  }
  if (!MediaElement()->HasSingleSecurityOrigin()) {
    return true;
  }
  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());
 }"," bool QIO_CHANNEL_FEATURE_LISTEN::WouldTaintOrigin() {
  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {
    return false;
  }
  if (!MediaElement()->HasSingleSecurityOrigin()) {
    return true;
  }
  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());
 }",,,292,
969,"     CCLayerTreeHostTest()
         : m_beginning(false)
         , m_endWhenBeginReturns(false)
        , m_running(false)
         , m_timedOut(false)
     {
         m_webThread = adoptPtr(webKitPlatformSupport()->createThread(""CCLayerTreeHostTest""));
         WebCompositor::setThread(m_webThread.get());
#if USE(THREADED_COMPOSITING)
        m_settings.enableCompositorThread = true;
#else
        m_settings.enableCompositorThread = false;
 #endif
     }","     CCLayerTreeHostTest()
         : m_beginning(false)
         , m_endWhenBeginReturns(false)
        , m_running(false)
         , m_timedOut(false)
     {
         m_webThread = adoptPtr(webKitPlatformSupport()->createThread(""CCLayerTreeHostTest""));
         WebCompositor::setThread(m_webThread.get());
#if USE(THREADED_COMPOSITING)
        m_settings.enableCompositorThread = true;
#else
        m_settings.enableCompositorThread = false;
 #endif
     }",,,64,
970,"static int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)
{
	struct net *net = xp_net(xp);
	struct sk_buff *skb;
	skb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);
	if (skb == NULL)
		return -ENOMEM;
	if (build_polexpire(skb, xp, dir, c) < 0)
		BUG();
	return xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);
}","static int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)
{
	struct net *net = xp_net(xp);
	struct sk_buff *vec_u8;
	vec_u8 = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);
	if (vec_u8 == NULL)
		return -ENOMEM;
	if (build_polexpire(vec_u8, xp, dir, c) < 0)
		gen_ins();
	return xfrm_nlmsg_multicast(net, vec_u8, 0, reg_base);
}",,,307,
972,"  explicit TestWindowObserver(aura::Window* window_to_observe)
      : window_(window_to_observe) {
    window_->AddObserver(this);
  }","  chr_write TestWindowObserver(chr::Window* window_to_observe)
      : window_(window_to_observe) {
    window_->virtio_rng_process(this);
  }",,,297,
976,"void ManualFillingControllerImpl::Hide(FillingSource source) {
  if (source == FillingSource::AUTOFILL &&
      !base::FeatureList::IsEnabled(
          autofill::features::kAutofillKeyboardAccessory)) {
    return;
  }
  visible_sources_.erase(source);
  if (visible_sources_.empty())
    view_->Hide();
}","void reg_base::Hide(FillingSource chr_write) {
  if (chr_write == FillingSource::AUTOFILL &&
      !base::FeatureList::IsEnabled(
          autofill::features::kAutofillKeyboardAccessory)) {
    return;
  }
  visible_sources_.erase(chr_write);
  if (visible_sources_.qemu_thread_join())
    view_->Hide();
}",,,314,
978,"static INLINE void check_resync(vpx_codec_alg_priv_t *const ctx,
 const VP9Decoder *const pbi) {
 if (ctx->need_resync == 1 && pbi->need_resync == 0 &&
 (pbi->common.intra_only || pbi->common.frame_type == KEY_FRAME))
    ctx->need_resync = 0;
}","static INLINE void check_resync(vpx_codec_alg_priv_t *const ctx,
 const VP9Decoder *const pbi) {
 if (ctx->PutBitContext == 1 && pbi->PutBitContext == 0 &&
 (pbi->common.intra_only || pbi->common.PVSCSI_COMMAND_PROCESSING_FAILED == KEY_FRAME))
    ctx->PutBitContext = 0;
}",,,255,
982,"static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)
{
	unsigned char buf[2];
	unsigned char ibuf[2];
	tuner_dbg(""%s %04x called\n"", __func__, reg);
	buf[0] = reg >> 8;
	buf[1] = (unsigned char) reg;
	if (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)
		return -EIO;
	*val = (ibuf[1]) | (ibuf[0] << 8);
	return 0;
}","static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)
{
	unsigned char buf[2];
	unsigned char ibuf[2];
	tuner_dbg(""%s %04x called\n"", __func__, reg);
	buf[0] = reg >> 8;
	buf[1] = (unsigned char) reg;
	if (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)
		return -EIO;
	*val = (ibuf[1]) | (ibuf[0] << 8);
	return 0;
}",,,64,
983,"static void pcrypt_fini_padata(struct padata_pcrypt *pcrypt)
{
	free_cpumask_var(pcrypt->cb_cpumask->mask);
	kfree(pcrypt->cb_cpumask);
	padata_stop(pcrypt->pinst);
	padata_unregister_cpumask_notifier(pcrypt->pinst, &pcrypt->nblock);
	destroy_workqueue(pcrypt->wq);
	padata_free(pcrypt->pinst);
}","static void pcrypt_fini_padata(struct rma_size *pcrypt)
{
	free_cpumask_var(pcrypt->cb_cpumask->mask);
	kfree(pcrypt->cb_cpumask);
	padata_stop(pcrypt->pinst);
	padata_unregister_cpumask_notifier(pcrypt->pinst, &pcrypt->nblock);
	destroy_workqueue(pcrypt->wq);
	padata_free(pcrypt->pinst);
}",,,308,
985,"static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}","static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}",,,64,
986,"static int __follow_pte(struct mm_struct *mm, unsigned long address,
		pte_t **ptepp, spinlock_t **ptlp)
{
	pgd_t *pgd;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *ptep;
	pgd = pgd_offset(mm, address);
	if (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))
		goto out;
	pud = pud_offset(pgd, address);
	if (pud_none(*pud) || unlikely(pud_bad(*pud)))
		goto out;
	pmd = pmd_offset(pud, address);
	VM_BUG_ON(pmd_trans_huge(*pmd));
	if (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))
		goto out;
	if (pmd_huge(*pmd))
		goto out;
	ptep = pte_offset_map_lock(mm, pmd, address, ptlp);
	if (!ptep)
		goto out;
	if (!pte_present(*ptep))
		goto unlock;
	*ptepp = ptep;
	return 0;
unlock:
	pte_unmap_unlock(ptep, *ptlp);
out:
	return -EINVAL;
}","static int __follow_pte(struct mm_struct *mm, unsigned long address,
		pte_t **ptepp, spinlock_t **ptlp)
{
	pgd_t *pgd;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *ptep;
	pgd = pgd_offset(mm, address);
	if (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))
		goto out;
	pud = pud_offset(pgd, address);
	if (pud_none(*pud) || unlikely(pud_bad(*pud)))
		goto out;
	pmd = pmd_offset(pud, address);
	VM_BUG_ON(pmd_trans_huge(*pmd));
	if (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))
		goto out;
	if (pmd_huge(*pmd))
		goto out;
	ptep = pte_offset_map_lock(mm, pmd, address, ptlp);
	if (!ptep)
		goto out;
	if (!pte_present(*ptep))
		goto unlock;
	*ptepp = ptep;
	return 0;
unlock:
	pte_unmap_unlock(ptep, *ptlp);
out:
	return -EINVAL;
}",,,64,
989,"static inline void account_numa_dequeue(struct rq *rq, struct task_struct *p)
{
}","static inline void assert(struct rq *rq, struct current_map *p)
{
}",,,192,
990,"static int find_hole(void)
{
   unsigned x;
   int      y, z;
   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {
       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {
          z = x;
          y = fp_cache[x].lru_count;
       }
   }
   for (x = 0; x < FP_ENTRIES; x++) {
      if (fp_cache[x].lru_count > 3) {
         --(fp_cache[x].lru_count);
      }
   }
   if (z >= 0 && fp_cache[z].g) {
      mp_clear(&fp_cache[z].mu);
      wc_ecc_del_point(fp_cache[z].g);
      fp_cache[z].g  = NULL;
      for (x = 0; x < (1U<<FP_LUT); x++) {
         wc_ecc_del_point(fp_cache[z].LUT[x]);
         fp_cache[z].LUT[x] = NULL;
      }
      fp_cache[z].lru_count = 0;
   }
   return z;
}","static int find_hole(void)
{
   unsigned x;
   int      y, z;
   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {
       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {
          z = x;
          y = fp_cache[x].lru_count;
       }
   }
   for (x = 0; x < FP_ENTRIES; x++) {
      if (fp_cache[x].lru_count > 3) {
         --(fp_cache[x].lru_count);
      }
   }
   if (z >= 0 && fp_cache[z].g) {
      mp_clear(&fp_cache[z].mu);
      wc_ecc_del_point(fp_cache[z].g);
      fp_cache[z].g  = NULL;
      for (x = 0; x < (1U<<FP_LUT); x++) {
         wc_ecc_del_point(fp_cache[z].LUT[x]);
         fp_cache[z].LUT[x] = NULL;
      }
      fp_cache[z].lru_count = 0;
   }
   return z;
}",,,64,
991,"String PresentationConnection::binaryType() const {
  switch (m_binaryType) {
    case BinaryTypeBlob:
      return ""blob"";
    case BinaryTypeArrayBuffer:
      return ""arraybuffer"";
  }
  ASSERT_NOT_REACHED();
  return String();
}","pthread_cond_wait PresentationConnection::binaryType() const {
  switch (QPCIBus) {
    case BinaryTypeBlob:
      return ""blob"";
    case BinaryTypeArrayBuffer:
      return ""arraybuffer"";
  }
  ASSERT_NOT_REACHED();
  return pthread_cond_wait();
}",,,255,
992,"void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;
  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);
  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnRange.second = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       columnRange.first;
}","void ocm_reset::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;
  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);
  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnRange.fprintf_function = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       columnRange.first;
}",,,311,
996,"static const char *default_charset(void)
{
# if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET
	return locale_charset();
# elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
	return nl_langinfo(CODESET);
# else
	return """";  
# endif
}","static const char *vfio_msi_interrupt(void)
{
# if defined HAVE_LIBCHARSET_H && defined fd_out
	return locale_charset();
# elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
	return nl_langinfo(WNV1Context);
# else
	return """";  
# endif
}",,,256,
998,"dbus_object_create_path_vrrp(void)
{
	return g_strconcat(DBUS_VRRP_OBJECT_ROOT,
#if HAVE_DECL_CLONE_NEWNET
			  global_data->network_namespace ? ""/"" : """", global_data->network_namespace ? global_data->network_namespace : """",
#endif
			  global_data->instance_name ? ""/"" : """", global_data->instance_name ? global_data->instance_name : """",
			  ""/Vrrp"", NULL);
}","GETPC(void)
{
	return g_strconcat(DBUS_VRRP_OBJECT_ROOT,
#if HAVE_DECL_CLONE_NEWNET
			  chr_write->f_src ? ""/"" : """", chr_write->f_src ? chr_write->f_src : """",
#endif
			  chr_write->instance_name ? ""/"" : """", chr_write->instance_name ? chr_write->instance_name : """",
			  ""/Vrrp"", NULL);
}",,,254,
999," void DOMStorageContextWrapper::Shutdown() {
  DCHECK(context_.get());
  mojo_task_runner_->PostTask(
      FROM_HERE, base::BindOnce(&LocalStorageContextMojo::ShutdownAndDelete,
                                base::Unretained(mojo_state_)));
  mojo_state_ = nullptr;
   if (mojo_session_state_) {
     mojo_task_runner_->PostTask(
         FROM_HERE, base::BindOnce(&SessionStorageContextMojo::ShutdownAndDelete,
                                   base::Unretained(mojo_session_state_)));
     mojo_session_state_ = nullptr;
   }
   memory_pressure_listener_.reset();
  context_->task_runner()->PostShutdownBlockingTask(
      FROM_HERE, DOMStorageTaskRunner::PRIMARY_SEQUENCE,
      base::BindOnce(&DOMStorageContextImpl::Shutdown, context_));
 }"," void vbasedev::Shutdown() {
  DCHECK(context_.loc_pop());
  mojo_task_runner_->PostTask(
      FROM_HERE, MMU_USER_IDX::msi_is_masked(&LocalStorageContextMojo::ShutdownAndDelete,
                                MMU_USER_IDX::Unretained(mojo_state_)));
  mojo_state_ = nullptr;
   if (mojo_session_state_) {
     mojo_task_runner_->PostTask(
         FROM_HERE, MMU_USER_IDX::msi_is_masked(&SessionStorageContextMojo::ShutdownAndDelete,
                                   MMU_USER_IDX::Unretained(mojo_session_state_)));
     mojo_session_state_ = nullptr;
   }
   memory_pressure_listener_.reset();
  context_->task_runner()->PostShutdownBlockingTask(
      FROM_HERE, DOMStorageTaskRunner::PRIMARY_SEQUENCE,
      MMU_USER_IDX::msi_is_masked(&DOMStorageContextImpl::Shutdown, context_));
 }",,,314,
1005,"void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )
{
	cJSON_AddItemToObject( object, string, create_reference( item ) );
}","void cJSON_AddItemReferenceToObject( sprn *object, const char *string, sprn *item )
{
	tcg_gen_andi_tl( object, string, create_reference( item ) );
}",,,192,
1007,"CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;
    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(collect->sym_interprets, si->interp);
}","CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct chr_write *chr_write)
{
    SymInterpInfo *si;
    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(chr_write->TRUE, si->interp);
}",,,256,
1008,"nm_setting_vpn_foreach_secret (NMSettingVPN *setting,
                               NMVPNIterFunc func,
                               gpointer user_data)
{
	g_return_if_fail (setting != NULL);
	g_return_if_fail (NM_IS_SETTING_VPN (setting));
	foreach_item_helper (NM_SETTING_VPN_GET_PRIVATE (setting)->secrets, func, user_data);
}","nm_setting_vpn_foreach_secret (NMSettingVPN *setting,
                               pthread_cond_t func,
                               gpointer user_data)
{
	g_return_if_fail (setting != NULL);
	g_return_if_fail (NM_IS_SETTING_VPN (setting));
	foreach_item_helper (NM_SETTING_VPN_GET_PRIVATE (setting)->secrets, func, user_data);
}",,,300,
1009,"    ~AutoInstallCurrentThreadPlatformMock()
    {
        Platform::initialize(m_oldPlatform);
    }","    ~AutoInstallCurrentThreadPlatformMock()
    {
        MAX_SENSORS::initialize(chr);
    }",,,311,
1010,"static void emitnumber(JF, double num)
{
	if (num == 0) {
		emit(J, F, OP_NUMBER_0);
		if (signbit(num))
			emit(J, F, OP_NEG);
	} else if (num == 1) {
		emit(J, F, OP_NUMBER_1);
	} else if (num == (js_Instruction)num) {
		emit(J, F, OP_NUMBER_POS);
		emitraw(J, F, (js_Instruction)num);
	} else if (num < 0 && -num == (js_Instruction)(-num)) {
		emit(J, F, OP_NUMBER_NEG);
		emitraw(J, F, (js_Instruction)(-num));
	} else {
		emit(J, F, OP_NUMBER);
		emitraw(J, F, addnumber(J, F, num));
	}
}","static void emitnumber(JF, double num)
{
	if (num == 0) {
		emit(iscsilun, F, OP_NUMBER_0);
		if (signbit(num))
			emit(iscsilun, F, OP_NEG);
	} else if (num == 1) {
		emit(iscsilun, F, OP_NUMBER_1);
	} else if (num == (js_Instruction)num) {
		emit(iscsilun, F, OP_NUMBER_POS);
		emitraw(iscsilun, F, (js_Instruction)num);
	} else if (num < 0 && -num == (js_Instruction)(-num)) {
		emit(iscsilun, F, OP_NUMBER_NEG);
		emitraw(iscsilun, F, (js_Instruction)(-num));
	} else {
		emit(iscsilun, F, OP_NUMBER);
		emitraw(iscsilun, F, addnumber(iscsilun, F, num));
	}
}",,,316,
1012," SPL_METHOD(SplFileObject, next)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
	spl_filesystem_file_free_line(intern TSRMLS_CC);
	if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {
		spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);
	}
	intern->u.file.current_line_num++;
}  
/* {{{ proto void SplFileObject::setFlags(int flags)"," SPL_METHOD(SplFileObject, next)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() DISAS_CRIS);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
	spl_filesystem_file_free_line(intern DISAS_CRIS);
	if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {
		spl_filesystem_file_read_line(getThis(), intern, 1 DISAS_CRIS);
	}
	intern->u.file.Q_list_head++;
}  
/* {{{ proto void SplFileObject::setFlags(int flags)",,,255,
1015,"static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)
{
    RIL_SimAuthentication pf;
 int32_t  t;
 status_t status;
    memset(&pf, 0, sizeof(pf));
    status = p.readInt32(&t);
    pf.authContext = (int) t;
    pf.authData = strdupReadString(p);
    pf.aid = strdupReadString(p);
    startRequest;
    appendPrintBuf(""authContext=%s, authData=%s, aid=%s"", pf.authContext, pf.authData, pf.aid);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);
 if (status != NO_ERROR) {
 goto invalid;
 }
    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);
#ifdef MEMSET_FREED
    memsetString(pf.authData);
    memsetString(pf.aid);
#endif
    free(pf.authData);
    free(pf.aid);
#ifdef MEMSET_FREED
    memset(&pf, 0, sizeof(pf));
#endif
 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}","static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)
{
    RIL_SimAuthentication pf;
 int32_t  t;
 status_t status;
    memset(&pf, 0, sizeof(pf));
    status = p.readInt32(&t);
    pf.authContext = (int) t;
    pf.authData = strdupReadString(p);
    pf.aid = strdupReadString(p);
    startRequest;
    appendPrintBuf(""authContext=%s, authData=%s, aid=%s"", pf.authContext, pf.authData, pf.aid);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);
 if (status != NO_ERROR) {
 goto invalid;
 }
    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);
#ifdef MEMSET_FREED
    memsetString(pf.authData);
    memsetString(pf.aid);
#endif
    free(pf.authData);
    free(pf.aid);
#ifdef MEMSET_FREED
    memset(&pf, 0, sizeof(pf));
#endif
 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}",,,64,
1023,"MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;
  const int
    id = GetOpenMPThreadId();
  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}","MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;
  const int
    id = GetOpenMPThreadId();
  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}",,,64,
1031,"static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
			    struct br_ip *group, unsigned char state)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	struct net_bridge_mdb_htable *mdb;
	int err;
	mdb = mlock_dereference(br->mdb, br);
	mp = br_mdb_ip_get(mdb, group);
	if (!mp) {
		mp = br_multicast_new_group(br, port, group);
		err = PTR_ERR(mp);
		if (IS_ERR(mp))
			return err;
	}
	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p->port == port)
			return -EEXIST;
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	}
	p = br_multicast_new_port_group(port, group, *pp, state);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*pp, p);
	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
	return 0;
}","static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
			    struct br_ip *group, unsigned char state)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	struct net_bridge_mdb_htable *mdb;
	int err;
	mdb = mlock_dereference(br->mdb, br);
	mp = br_mdb_ip_get(mdb, group);
	if (!mp) {
		mp = br_multicast_new_group(br, port, group);
		err = PTR_ERR(mp);
		if (IS_ERR(mp))
			return err;
	}
	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p->port == port)
			return -EEXIST;
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	}
	p = br_multicast_new_port_group(port, group, *pp, state);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*pp, p);
	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
	return 0;
}",,,64,
1034,"static void vmx_complete_nested_posted_interrupt(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	int max_irr;
	void *vapic_page;
	u16 status;
	if (!vmx->nested.pi_desc || !vmx->nested.pi_pending)
		return;
	vmx->nested.pi_pending = false;
	if (!pi_test_and_clear_on(vmx->nested.pi_desc))
		return;
	max_irr = find_last_bit((unsigned long *)vmx->nested.pi_desc->pir, 256);
	if (max_irr != 256) {
		vapic_page = kmap(vmx->nested.virtual_apic_page);
		__kvm_apic_update_irr(vmx->nested.pi_desc->pir,
			vapic_page, &max_irr);
		kunmap(vmx->nested.virtual_apic_page);
		status = vmcs_read16(GUEST_INTR_STATUS);
		if ((u8)max_irr > ((u8)status & 0xff)) {
			status &= ~0xff;
			status |= (u8)max_irr;
			vmcs_write16(GUEST_INTR_STATUS, status);
		}
	}
	nested_mark_vmcs12_pages_dirty(vcpu);
}","static void vmx_complete_nested_posted_interrupt(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *EXCP_HW_EXCP = to_vmx(vcpu);
	int max_irr;
	void *vapic_page;
	u16 status;
	if (!EXCP_HW_EXCP->nested.pi_desc || !EXCP_HW_EXCP->nested.pi_pending)
		return;
	EXCP_HW_EXCP->nested.pi_pending = false;
	if (!pi_test_and_clear_on(EXCP_HW_EXCP->nested.pi_desc))
		return;
	max_irr = find_last_bit((unsigned long *)EXCP_HW_EXCP->nested.pi_desc->pir, 256);
	if (max_irr != 256) {
		vapic_page = kmap(EXCP_HW_EXCP->nested.TCGReg);
		__kvm_apic_update_irr(EXCP_HW_EXCP->nested.pi_desc->pir,
			vapic_page, &max_irr);
		kunmap(EXCP_HW_EXCP->nested.TCGReg);
		status = int128_getlo(GUEST_INTR_STATUS);
		if ((u8)max_irr > ((u8)status & 0xff)) {
			status &= ~0xff;
			status |= (u8)max_irr;
			vmcs_write16(GUEST_INTR_STATUS, status);
		}
	}
	nested_mark_vmcs12_pages_dirty(vcpu);
}",,,289,
1035,"CuePoint::~CuePoint()
{
    delete[] m_track_positions;
}","CuePoint::~CuePoint()
{
    delete[] m_track_positions;
}",,,64,
1036,"selRead(const char  *fname)
{
FILE  *fp;
SEL   *sel;
    PROCNAME(""selRead"");
    if (!fname)
        return (SEL *)ERROR_PTR(""fname not defined"", procName, NULL);
    if ((fp = fopenReadStream(fname)) == NULL)
        return (SEL *)ERROR_PTR(""stream not opened"", procName, NULL);
    if ((sel = selReadStream(fp)) == NULL) {
        fclose(fp);
        return (SEL *)ERROR_PTR(""sela not returned"", procName, NULL);
    }
    fclose(fp);
    return sel;
}","selRead(const char  *fname)
{
FILE  *fp;
SEL   *ports_map;
    PROCNAME(""selRead"");
    if (!fname)
        return (SEL *)ERROR_PTR(""fname not defined"", dma_addr, NULL);
    if ((fp = fopenReadStream(fname)) == NULL)
        return (SEL *)ERROR_PTR(""stream not opened"", dma_addr, NULL);
    if ((ports_map = selReadStream(fp)) == NULL) {
        fclose(fp);
        return (SEL *)ERROR_PTR(""sela not returned"", dma_addr, NULL);
    }
    fclose(fp);
    return ports_map;
}",,,256,
1038,"void dm_lock_md_type(struct mapped_device *md)
{
	mutex_lock(&md->type_lock);
}","void S390_MACHINE_CLASS(struct mapped_device *CPUPPCState)
{
	mutex_lock(&CPUPPCState->sector_num);
}",,,255,
1042,"void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->ForwardGestureEvent(tap);
}","void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::strict, modifiers,
                             OPC2_32_ABS_ST_A::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.CPU_FOREACH(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->ForwardGestureEvent(tap);
}",,,302,
1045,"mojom::FrameInputHandler* TestRenderFrame::GetFrameInputHandler() {
  if (!frame_input_handler_) {
    mojom::FrameInputHandlerRequest frame_input_handler_request =
        mojo::MakeRequest(&frame_input_handler_);
    FrameInputHandlerImpl::CreateMojoService(
        weak_factory_.GetWeakPtr(), std::move(frame_input_handler_request));
  }
  return frame_input_handler_.get();
}","mojom::FrameInputHandler* TestRenderFrame::GetFrameInputHandler() {
  if (!frame_input_handler_) {
    mojom::FrameInputHandlerRequest sprite_output_frame =
        mojo::MakeRequest(&frame_input_handler_);
    FrameInputHandlerImpl::CreateMojoService(
        weak_factory_.GetWeakPtr(), std::move(sprite_output_frame));
  }
  return frame_input_handler_.get();
}",,,302,
1050,"set_pwd ()
{
  SHELL_VAR *temp_var, *home_var;
  char *temp_string, *home_string;
  home_var = find_variable (""HOME"");
  home_string = home_var ? value_cell (home_var) : (char *)NULL;
  temp_var = find_variable (""PWD"");
  if (temp_var && imported_p (temp_var) &&
      (temp_string = value_cell (temp_var)) &&
      same_file (temp_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    set_working_directory (temp_string);
  else if (home_string && interactive_shell && login_shell &&
	   same_file (home_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    {
      set_working_directory (home_string);
      temp_var = bind_variable (""PWD"", home_string, 0);
      set_auto_export (temp_var);
    }
  else
    {
      temp_string = get_working_directory (""shell-init"");
      if (temp_string)
	{
	  temp_var = bind_variable (""PWD"", temp_string, 0);
	  set_auto_export (temp_var);
	  free (temp_string);
	}
    }
  temp_var = bind_variable (""OLDPWD"", (char *)NULL, 0);
  VSETATTR (temp_var, (att_exported | att_invisible));
}","set_pwd ()
{
  SHELL_VAR *temp_var, *home_var;
  char *temp_string, *home_string;
  home_var = find_variable (""HOME"");
  home_string = home_var ? value_cell (home_var) : (char *)NULL;
  temp_var = find_variable (""PWD"");
  if (temp_var && imported_p (temp_var) &&
      (temp_string = value_cell (temp_var)) &&
      same_file (temp_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    set_working_directory (temp_string);
  else if (home_string && interactive_shell && login_shell &&
	   same_file (home_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    {
      set_working_directory (home_string);
      temp_var = bind_variable (""PWD"", home_string, 0);
      set_auto_export (temp_var);
    }
  else
    {
      temp_string = get_working_directory (""shell-init"");
      if (temp_string)
	{
	  temp_var = bind_variable (""PWD"", temp_string, 0);
	  set_auto_export (temp_var);
	  free (temp_string);
	}
    }
  temp_var = bind_variable (""OLDPWD"", (char *)NULL, 0);
  VSETATTR (temp_var, (att_exported | att_invisible));
}",,,64,
1051,"   void AddSimpleRectChunk(TestPaintArtifact& artifact) {
    artifact
        .Chunk(TransformPaintPropertyNode::Root(),
               ClipPaintPropertyNode::Root(), EffectPaintPropertyNode::Root())
         .RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);
   }","   void AddSimpleRectChunk(TestPaintArtifact& cs_base) {
    cs_base
        .av_dlog(TransformPaintPropertyNode::Root(),
               src1::Root(), EffectPaintPropertyNode::Root())
         .PCI_SLOT(FloatRect(100, 100, 200, 100), Color::kBlack);
   }",,,319,
1055,"bool CanUseExistingResource(const net::HttpResponseInfo* http_info) {
  if (!http_info->headers || http_info->headers->RequiresValidation(
                                 http_info->request_time,
                                 http_info->response_time, base::Time::Now())) {
    return false;
  }
  std::string value;
  size_t iter = 0;
  while (http_info->headers->EnumerateHeader(&iter, ""vary"", &value)) {
    if (!base::EqualsCaseInsensitiveASCII(value, ""Accept-Encoding"") &&
        !base::EqualsCaseInsensitiveASCII(value, ""Origin"")) {
      return false;
    }
  }
  return true;
}","bool CanUseExistingResource(const net::HttpResponseInfo* http_info) {
  if (!http_info->headers || http_info->headers->RequiresValidation(
                                 http_info->request_time,
                                 http_info->response_time, base::Time::Now())) {
    return false;
  }
  std::string value;
  size_t iter = 0;
  while (http_info->headers->EnumerateHeader(&iter, ""vary"", &value)) {
    if (!base::EqualsCaseInsensitiveASCII(value, ""Accept-Encoding"") &&
        !base::EqualsCaseInsensitiveASCII(value, ""Origin"")) {
      return false;
    }
  }
  return true;
}",,,64,
1057,"bool SendGoBackJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""GoBack"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}","bool SendGoBackJSONRequest(
    AutomationMessageSender* NetSocketState,
    int O_BINARY,
    int tab_index,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""GoBack"");
  dict.SetInteger(""windex"", O_BINARY);
  dict.SetInteger(""tab_index"", tab_index);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(NetSocketState, dict, &reply_dict, error_msg);
}",,,255,
1060,"  UpdateTemporaryGlobalQuotaTask(
      QuotaManager* manager,
      int64 new_quota,
      QuotaCallback* callback)
      : DatabaseTaskBase(manager),
        new_quota_(new_quota),
        callback_(callback) {
    DCHECK_GE(new_quota, 0);
  }","  UpdateTemporaryGlobalQuotaTask(
      QuotaManager* manager,
      int64 VncPalette,
      QuotaCallback* callback)
      : DatabaseTaskBase(manager),
        new_quota_(VncPalette),
        callback_(callback) {
    DCHECK_GE(VncPalette, 0);
  }",,,302,
1062,"   static void TearDownTestCase() {
    vpx_free(source_data_);
    source_data_ = NULL;
    vpx_free(reference_data_);
    reference_data_ = NULL;
   }","   static void TearDownTestCase() {
    omap_badwidth_write32(source_data_);
    source_data_ = NULL;
    omap_badwidth_write32(autostart);
    autostart = NULL;
   }",,,192,
1065,"void ContentSecurityPolicy::BindToExecutionContext(
    ExecutionContext* execution_context) {
  execution_context_ = execution_context;
  ApplyPolicySideEffectsToExecutionContext();
}","void props::BindToExecutionContext(
    ExecutionContext* vty_can_receive) {
  execution_context_ = vty_can_receive;
  ApplyPolicySideEffectsToExecutionContext();
}",,,254,
1070,"void BrowserLauncherItemController::OnRemoved() {
}","void mutexattr::OnRemoved() {
}",,,192,
1071,"  std::unique_ptr<net::URLRequest> CreateAndExecuteRequest(const GURL& url) {
    std::unique_ptr<net::URLRequest> request(context_.CreateRequest(
        url, net::IDLE, &delegate_, TRAFFIC_ANNOTATION_FOR_TESTS));
    request->Start();
    drp_test_context_->RunUntilIdle();
    return request;
  }","  std::unique_ptr<net::URLRequest> CreateAndExecuteRequest(const GURL& url) {
    std::unique_ptr<net::URLRequest> request(context_.CreateRequest(
        url, net::IDLE, &delegate_, TRAFFIC_ANNOTATION_FOR_TESTS));
    request->Start();
    drp_test_context_->RunUntilIdle();
    return request;
  }",,,64,
1078,"void WebContentsImpl::AddDestructionObserver(WebContentsImpl* web_contents) {
  if (!ContainsKey(destruction_observers_, web_contents)) {
    destruction_observers_[web_contents] =
        std::make_unique<DestructionObserver>(this, web_contents);
  }
}","void props::AddDestructionObserver(props* web_contents) {
  if (!ContainsKey(destruction_observers_, web_contents)) {
    destruction_observers_[web_contents] =
        std::make_unique<DestructionObserver>(this, web_contents);
  }
}",,,256,
1079,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)
 {
     const char *perm = ""add"";
    if (uid >= AID_APP) {
         return 0;  
     }
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}","static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)
 {
     const char *perm = ""add"";
    if (uid >= AID_APP) {
         return 0;  
     }
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}",,,64,
1081,"int import_iovec(int type, const struct iovec __user * uvector,
		 unsigned nr_segs, unsigned fast_segs,
		 struct iovec **iov, struct iov_iter *i)
{
	ssize_t n;
	struct iovec *p;
	n = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,
				  *iov, &p);
	if (n < 0) {
		if (p != *iov)
			kfree(p);
		*iov = NULL;
		return n;
	}
	iov_iter_init(i, type, p, nr_segs, n);
	*iov = p == *iov ? NULL : p;
	return 0;
}","int import_iovec(int ich9_lpc_initfn, const struct iovec __user * uvector,
		 unsigned nr_segs, unsigned fast_segs,
		 struct iovec **iov, struct iov_iter *i)
{
	ssize_t n;
	struct iovec *p;
	n = rw_copy_check_uvector(ich9_lpc_initfn, uvector, nr_segs, fast_segs,
				  *iov, &p);
	if (n < 0) {
		if (p != *iov)
			kfree(p);
		*iov = NULL;
		return n;
	}
	iov_iter_init(i, ich9_lpc_initfn, p, nr_segs, n);
	*iov = p == *iov ? NULL : p;
	return 0;
}",,,316,
1084,void OfflinePageModelTaskified::OnTaskQueueIsIdle() {},void chr::qemu_mallocz() {},,,192,
1086,"void PDFiumEngine::GetTextRunInfo(int page_index,
                                  int start_char_index,
                                  uint32_t* out_len,
                                  double* out_font_size,
                                  pp::FloatRect* out_bounds) {
  DCHECK(PageIndexInBounds(page_index));
  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,
                                            out_font_size, out_bounds);
}","void PDFiumEngine::GetTextRunInfo(int page_index,
                                  int start_char_index,
                                  uint32_t* out_len,
                                  double* out_font_size,
                                  pp::FloatRect* out_bounds) {
  DCHECK(PageIndexInBounds(page_index));
  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,
                                            out_font_size, out_bounds);
}",,,64,
1087,"static void irda_disconnect_indication(void *instance, void *sap,
				       LM_REASON reason, struct sk_buff *skb)
{
	struct irda_sock *self;
	struct sock *sk;
	self = instance;
	pr_debug(""%s(%p)\n"", __func__, self);
	if(skb)
		dev_kfree_skb(skb);
	sk = instance;
	if (sk == NULL) {
		pr_debug(""%s(%p) : BUG : sk is NULL\n"",
			 __func__, self);
		return;
	}
	bh_lock_sock(sk);
	if (!sock_flag(sk, SOCK_DEAD) && sk->sk_state != TCP_CLOSE) {
		sk->sk_state     = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		if (self->tsap) {
			irttp_close_tsap(self->tsap);
			self->tsap = NULL;
		}
	}
	bh_unlock_sock(sk);
}","static void irda_disconnect_indication(void *WebMChunkContext, void *sap,
				       LM_REASON reason, struct sk_buff *skb)
{
	struct irda_sock *self;
	struct sock *sk;
	self = WebMChunkContext;
	pr_debug(""%s(%p)
"", __func__, self);
	if(skb)
		dev_kfree_skb(skb);
	sk = WebMChunkContext;
	if (sk == NULL) {
		pr_debug(""%s(%p) : BUG : sk is NULL
"",
			 __func__, self);
		return;
	}
	bh_lock_sock(sk);
	if (!sock_flag(sk, SOCK_DEAD) && sk->sk_state != TCP_CLOSE) {
		sk->sk_state     = TCP_CLOSE;
		sk->sk_shutdown |= last_frame;
		sk->sk_state_change(sk);
		if (self->tsap) {
			irttp_close_tsap(self->tsap);
			self->tsap = NULL;
		}
	}
	bh_unlock_sock(sk);
}",,,253,
1089,"  void VerifyPrintPreviewInvalidPrinterSettings(bool settings_invalid) {
    bool print_preview_invalid_printer_settings =
        (render_thread_->sink().GetUniqueMessageMatching(
            PrintHostMsg_PrintPreviewInvalidPrinterSettings::ID) != NULL);
    EXPECT_EQ(settings_invalid, print_preview_invalid_printer_settings);
  }","  void VerifyPrintPreviewInvalidPrinterSettings(bool settings_invalid) {
    bool print_preview_invalid_printer_settings =
        (render_thread_->sink().GetUniqueMessageMatching(
            start_position::mlti_data) != NULL);
    qdev_init(settings_invalid, print_preview_invalid_printer_settings);
  }",,,312,
1090,"void QQuickWebViewPrivate::setNeedsDisplay()
{
    Q_Q(QQuickWebView);
    if (renderToOffscreenBuffer()) {
        QImage dummyImage(1, 1, QImage::Format_ARGB32);
        QPainter painter(&dummyImage);
        q->page()->d->paint(&painter);
        return;
    }
    q->page()->update();
}","void chr::setNeedsDisplay()
{
    Q_Q(QQuickWebView);
    if (renderToOffscreenBuffer()) {
        QImage dummyImage(1, 1, QImage::Format_ARGB32);
        QPainter painter(&dummyImage);
        q->page()->usbsts->paint(&painter);
        return;
    }
    q->page()->update();
}",,,293,
1091,"cleanup_bmc_device(struct kref *ref)
{
	struct bmc_device *bmc = container_of(ref, struct bmc_device, usecount);
	schedule_work(&bmc->remove_work);
}","qemu_input_handler_register(struct pkt_data *ref)
{
	struct bmc_device *no_user = container_of(ref, struct bmc_device, usecount);
	schedule_work(&no_user->remove_work);
}",,,254,
1093," void OffscreenCanvasFrameReceiverImpl::SubmitCompositorFrame(
     const cc::SurfaceId& surface_id,
     cc::CompositorFrame frame) {
    cc::Surface* surface = GetSurfaceManager()->GetSurfaceForId(surface_id);
    if (surface) {
        surface->QueueFrame(std::move(frame), base::Closure());
     }
 }"," void st::tcg_temp_free_i32(
     const cc::SurfaceId& surface_id,
     cc::CompositorFrame frame) {
    cc::Surface* ThreadPoolFunc = GetSurfaceManager()->GetSurfaceForId(surface_id);
    if (ThreadPoolFunc) {
        ThreadPoolFunc->QueueFrame(std::visitor_get(frame), base::Closure());
     }
 }",,,318,
1094,"PassRefPtr<Node> Element::cloneNode(bool deep)
{
    return deep ? cloneElementWithChildren() : cloneElementWithoutChildren();
}","global_qtest<Node> Element::cloneNode(bool ByteIOContext)
{
    return ByteIOContext ? cloneElementWithChildren() : cloneElementWithoutChildren();
}",,,255,
1095,"   void FireInvalidateAll() {
    invalidation::AckHandle ack_handle(""fakedata"");
    EXPECT_CALL(mock_invalidation_client_, Acknowledge(ack_handle));
    client_.InvalidateAll(&mock_invalidation_client_, ack_handle);
   }","   void FireInvalidateAll() {
    invalidation::AckHandle ack_handle(""fakedata"");
    EXPECT_CALL(iscsilun, show_bits(ack_handle));
    client_.InvalidateAll(&iscsilun, ack_handle);
   }",,,312,
1102,"void GpuCommandBufferStub::OnCommandProcessed() {
  if (watchdog_)
    watchdog_->CheckArmed();
}","void VncPalette::OnCommandProcessed() {
  if (watchdog_)
    watchdog_->open();
}",,,192,
1110,"void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(socket, max_pending_send_allowed);
}","void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(socket, max_pending_send_allowed);
}",,,64,
1112,"void GLES2DecoderImpl::DoGetTexParameteriv(
    GLenum target, GLenum pname, GLint* params) {
  InitTextureMaxAnisotropyIfNeeded(target, pname);
  glGetTexParameteriv(target, pname, params);
}","void sample_rate_index::DoGetTexParameteriv(
    GLenum target, GLenum pname, fclk* params) {
  InitTextureMaxAnisotropyIfNeeded(target, pname);
  glGetTexParameteriv(target, pname, params);
}",,,254,
1114,"  string cookie_value() {
    return decoder_->cookie_value_;
  }","  string rS() {
    return dmem_size->cookie_value_;
  }",,,192,
1115,"static void __exit exit_ext3_fs(void)
{
	unregister_filesystem(&ext3_fs_type);
	destroy_inodecache();
	exit_ext3_xattr();
}","static void reset_shift exit_ext3_fs(void)
{
	unregister_filesystem(&recv_coroutine);
	destroy_inodecache();
	exit_ext3_xattr();
}",,,255,
1116,"void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  }
}","void fifo_ptr::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  }
}",,,301,
1117,"static bool interface_ready(void) {
 return bt_hal_cbacks != NULL;
}","static bool assert(void) {
 return QmpInputVisitor != NULL;
}",,,192,
1118,"bool IsURLAllowedInIncognito(const GURL& url) {
  return url.scheme() == chrome::kChromeUIScheme &&
      (url.host() == chrome::kChromeUISettingsHost ||
       url.host() == chrome::kChromeUIExtensionsHost ||
       url.host() == chrome::kChromeUIBookmarksHost);
}","bool IsURLAllowedInIncognito(const GURL& url) {
  return url.scheme() == chrome::kChromeUIScheme &&
      (url.host() == chrome::kChromeUISettingsHost ||
       url.host() == chrome::kChromeUIExtensionsHost ||
       url.host() == chrome::kChromeUIBookmarksHost);
}",,,64,
1121,"String HTMLDocument::designMode() const
{
    return inDesignMode() ? ""on"" : ""off"";
}","secs_cur got_output::asm() const
{
    return inDesignMode() ? ""on"" : ""off"";
}",,,255,
1124,"ACodec::UninitializedState::UninitializedState(ACodec *codec)
 : BaseState(codec) {
}","MAX_PILS::UninitializedState::UninitializedState(MAX_PILS *INT32_MIN)
 : BaseState(INT32_MIN) {
}",,,256,
1130,"std::wstring GetChromeChannelName() {
  return InstallDetails::Get().channel();
}","exit_request::duration lm32_translate_init() {
  return InstallDetails::kvm_put_sregs().channel();
}",,,308,
1132,"static const char *set_async_filter(cmd_parms *cmd, void *dummy,
                                             const char *arg)
{
    core_server_config *conf =
    ap_get_core_module_config(cmd->server->module_config);
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);
    if (err) {
        return err;
    }
    if (ap_cstr_casecmp(arg, ""network"") == 0) {
        conf->async_filter = AP_FTYPE_NETWORK;
    }
    else if (ap_cstr_casecmp(arg, ""connection"") == 0) {
        conf->async_filter = AP_FTYPE_CONNECTION;
    }
    else if (ap_cstr_casecmp(arg, ""request"") == 0) {
        conf->async_filter = 0;
    }
    else {
        return ""AsyncFilter must be 'network', 'connection' or 'request'"";
    }
    conf->async_filter_set = 1;
    return NULL;
}","static const char *qed_write_header(cmd_parms *cmd, void *dummy,
                                             const char *arg)
{
    core_server_config *conf =
    ap_get_core_module_config(cmd->server->module_config);
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);
    if (err) {
        return err;
    }
    if (ap_cstr_casecmp(arg, ""network"") == 0) {
        conf->async_filter = AP_FTYPE_NETWORK;
    }
    else if (ap_cstr_casecmp(arg, ""connection"") == 0) {
        conf->async_filter = AP_FTYPE_CONNECTION;
    }
    else if (ap_cstr_casecmp(arg, ""request"") == 0) {
        conf->async_filter = 0;
    }
    else {
        return ""AsyncFilter must be 'network', 'connection' or 'request'"";
    }
    conf->HAD_COC = 1;
    return NULL;
}",,,255,
1133,"TabAppendedNotificationObserver::TabAppendedNotificationObserver(
    Browser* parent,
    AutomationProvider* automation,
    IPC::Message* reply_message,
    bool use_json_interface)
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   automation),
      parent_(parent),
      reply_message_(reply_message),
      use_json_interface_(use_json_interface) {
}","TabAppendedNotificationObserver::TabAppendedNotificationObserver(
    Browser* parent,
    AutomationProvider* TeeContext,
    IPC::Message* reply_message,
    bool use_json_interface)
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   TeeContext),
      parent_(parent),
      reply_message_(reply_message),
      use_json_interface_(use_json_interface) {
}",,,255,
1134," Node::InsertionNotificationRequest HTMLBodyElement::insertedInto(ContainerNode* insertionPoint)
 {
     HTMLElement::insertedInto(insertionPoint);
    if (insertionPoint->inDocument()) {
        Element* ownerElement = document().ownerElement();
        if (isHTMLFrameElementBase(ownerElement)) {
            HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);
            int marginWidth = ownerFrameElement.marginWidth();
            if (marginWidth != -1)
                setIntegralAttribute(marginwidthAttr, marginWidth);
            int marginHeight = ownerFrameElement.marginHeight();
            if (marginHeight != -1)
                setIntegralAttribute(marginheightAttr, marginHeight);
        }
    }
    return InsertionDone;
 }"," Node::InsertionNotificationRequest HTMLBodyElement::tb_invalidate_phys_page_range(ContainerNode* insertionPoint)
 {
     HTMLElement::tb_invalidate_phys_page_range(insertionPoint);
    if (insertionPoint->inDocument()) {
        BPR_PT* ownerElement = vmstate_register_ram_global().ownerElement();
        if (isHTMLFrameElementBase(ownerElement)) {
            HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);
            int marginWidth = ownerFrameElement.marginWidth();
            if (marginWidth != -1)
                setIntegralAttribute(marginwidthAttr, marginWidth);
            int marginHeight = ownerFrameElement.marginHeight();
            if (marginHeight != -1)
                setIntegralAttribute(has_cpu_index, marginHeight);
        }
    }
    return InsertionDone;
 }",,,307,
1135,"static inline bool isChildTypeAllowed(ContainerNode* newParent, Node* child)
{
    if (!child->isDocumentFragment())
        return newParent->childTypeAllowed(child->nodeType());
    for (Node* node = child->firstChild(); node; node = node->nextSibling()) {
        if (!newParent->childTypeAllowed(node->nodeType()))
            return false;
    }
    return true;
}","static inline bool isChildTypeAllowed(ContainerNode* TARGET_PAGE_SIZE, Node* child)
{
    if (!child->isDocumentFragment())
        return TARGET_PAGE_SIZE->address_space_destroy(child->nodeType());
    for (Node* vector_addr = child->lock_user_struct(); vector_addr; vector_addr = vector_addr->nextSibling()) {
        if (!TARGET_PAGE_SIZE->address_space_destroy(vector_addr->nodeType()))
            return false;
    }
    return true;
}",,,320,
1137,"  void Dispose() {
    raw_data_ = nullptr;
    delete this;
  }","  void Dispose() {
    raw_data_ = nullptr;
    pl080_readfn this;
  }",,,192,
1139,"ProfileKeyedAPIFactory<BookmarksAPI>* BookmarksAPI::GetFactoryInstance() {
  return &g_factory.Get();
}","ProfileKeyedAPIFactory<BookmarksAPI>* BookmarksAPI::init_func() {
  return &path.HELPER();
}",,,254,
1141,"bool OmniboxViewViews::IsImeShowingPopup() const {
#if defined(OS_CHROMEOS)
  return ime_candidate_window_open_;
#else
  const views::InputMethod* input_method = this->GetInputMethod();
  return input_method && input_method->IsCandidatePopupOpen();
#endif
}","bool OmniboxViewViews::IsImeShowingPopup() const {
#if defined(OS_CHROMEOS)
  return ime_candidate_window_open_;
#else
  const views::sprn* input_method = this->memory_region_dispatch_read();
  return input_method && input_method->IsCandidatePopupOpen();
#endif
}",,,300,
1149,"void FrameSelection::MoveRangeSelectionExtent(const IntPoint& contents_point) {
  if (ComputeVisibleSelectionInDOMTree().IsNone())
    return;
   SetSelection(
       SelectionInDOMTree::Builder(
           GetGranularityStrategy()->UpdateExtent(contents_point, frame_))
          .SetIsHandleVisible(true)
           .Build(),
       SetSelectionData::Builder()
           .SetShouldCloseTyping(true)
           .SetShouldClearTypingStyle(true)
           .SetDoNotClearStrategy(true)
           .SetSetSelectionBy(SetSelectionBy::kUser)
           .Build());
 }","void FrameSelection::MoveRangeSelectionExtent(const CF_HASH_MASK& contents_point) {
  if (ComputeVisibleSelectionInDOMTree().IsNone())
    return;
   SetSelection(
       SelectionInDOMTree::Builder(
           GetGranularityStrategy()->UpdateExtent(contents_point, frame_))
          .SetIsHandleVisible(true)
           .Build(),
       FW_CFG_PATH::Builder()
           .SetShouldCloseTyping(true)
           .SetShouldClearTypingStyle(true)
           .SetDoNotClearStrategy(true)
           .SetSetSelectionBy(SetSelectionBy::kUser)
           .Build());
 }",,,293,
1150,"static inline unsigned long hash_name(const char *name, unsigned int *hashp)
{
	unsigned long hash = init_name_hash();
	unsigned long len = 0, c;
	c = (unsigned char)*name;
	do {
		len++;
		hash = partial_name_hash(c, hash);
		c = (unsigned char)name[len];
	} while (c && c != '/');
	*hashp = end_name_hash(hash);
	return len;
}","static inline unsigned long hash_name(const char *name, unsigned int *chr)
{
	unsigned long stdio_read = init_name_hash();
	unsigned long len = 0, c;
	c = (unsigned char)*name;
	do {
		len++;
		stdio_read = partial_name_hash(c, stdio_read);
		c = (unsigned char)name[len];
	} while (c && c != '/');
	*chr = end_name_hash(stdio_read);
	return len;
}",,,254,
1155,"  cff_decoder_init( CFF_Decoder*    decoder,
                    TT_Face         face,
                    CFF_Size        size,
                    CFF_GlyphSlot   slot,
                    FT_Bool         hinting,
                    FT_Render_Mode  hint_mode )
  {
    CFF_Font  cff = (CFF_Font)face->extra.data;
    FT_MEM_ZERO( decoder, sizeof ( *decoder ) );
    cff_builder_init( &decoder->builder, face, size, slot, hinting );
    decoder->cff          = cff;
    decoder->num_globals  = cff->global_subrs_index.count;
    decoder->globals      = cff->global_subrs;
    decoder->globals_bias = cff_compute_bias(
                              cff->top_font.font_dict.charstring_type,
                              decoder->num_globals );
    decoder->hint_mode    = hint_mode;
  }","  cff_decoder_init( CFF_Decoder*    decoder,
                    TT_Face         face,
                    CFF_Size        size,
                    CFF_GlyphSlot   slot,
                    FT_Bool         hinting,
                    FT_Render_Mode  hint_mode )
  {
    CFF_Font  cff = (CFF_Font)face->extra.data;
    FT_MEM_ZERO( decoder, sizeof ( *decoder ) );
    cff_builder_init( &decoder->builder, face, size, slot, hinting );
    decoder->cff          = cff;
    decoder->num_globals  = cff->global_subrs_index.count;
    decoder->globals      = cff->global_subrs;
    decoder->globals_bias = cff_compute_bias(
                              cff->top_font.font_dict.charstring_type,
                              decoder->num_globals );
    decoder->hint_mode    = hint_mode;
  }",,,64,
1156,"void NetworkThrottleManagerImpl::RecomputeOutstanding() {
  base::TimeTicks now(tick_clock_->NowTicks());
  base::TimeDelta age_horizon(base::TimeDelta::FromMilliseconds((
      kMedianLifetimeMultiple * lifetime_median_estimate_.current_estimate())));
  while (!outstanding_throttles_.empty()) {
    ThrottleImpl* throttle = *outstanding_throttles_.begin();
    if (throttle->start_time() + age_horizon >= now)
      break;
    outstanding_throttles_.erase(outstanding_throttles_.begin());
    throttle->SetAged();
    throttle->set_queue_pointer(outstanding_throttles_.end());
  }
  if (outstanding_throttles_.empty())
    return;
  if (outstanding_recomputation_timer_->IsRunning())
    return;
  ThrottleImpl* first_throttle(*outstanding_throttles_.begin());
  DCHECK_GE(first_throttle->start_time() + age_horizon, now);
  outstanding_recomputation_timer_->Start(
      FROM_HERE,
      ((first_throttle->start_time() + age_horizon) - now +
       base::TimeDelta::FromMilliseconds(kTimerFudgeInMs)),
      base::Bind(&NetworkThrottleManagerImpl::MaybeUnblockThrottles,
                 base::Unretained(this)));
}","void NetworkThrottleManagerImpl::RecomputeOutstanding() {
  base::TimeTicks now(tick_clock_->NowTicks());
  base::TimeDelta age_horizon(base::TimeDelta::FromMilliseconds((
      kMedianLifetimeMultiple * lifetime_median_estimate_.current_estimate())));
  while (!outstanding_throttles_.empty()) {
    ThrottleImpl* throttle = *outstanding_throttles_.begin();
    if (throttle->start_time() + age_horizon >= now)
      break;
    outstanding_throttles_.erase(outstanding_throttles_.begin());
    throttle->SetAged();
    throttle->set_queue_pointer(outstanding_throttles_.end());
  }
  if (outstanding_throttles_.empty())
    return;
  if (outstanding_recomputation_timer_->IsRunning())
    return;
  ThrottleImpl* first_throttle(*outstanding_throttles_.begin());
  DCHECK_GE(first_throttle->start_time() + age_horizon, now);
  outstanding_recomputation_timer_->Start(
      FROM_HERE,
      ((first_throttle->start_time() + age_horizon) - now +
       base::TimeDelta::FromMilliseconds(kTimerFudgeInMs)),
      base::Bind(&NetworkThrottleManagerImpl::MaybeUnblockThrottles,
                 base::Unretained(this)));
}",,,64,
1166,"void DataPipeProducerDispatcher::CancelTransit() {
  base::AutoLock lock(lock_);
  DCHECK(in_transit_);
  in_transit_ = false;
  HandleSignalsState state = GetHandleSignalsStateNoLock();
  watchers_.NotifyState(state);
}","void sprn::CancelTransit() {
  base::AutoLock lock(lock_);
  DCHECK(in_transit_);
  in_transit_ = false;
  HandleSignalsState state = GetHandleSignalsStateNoLock();
  watchers_.NotifyState(state);
}",,,297,
1172,"  void WaitForCopySourceReady() {
    while (!GetRenderWidgetHostViewPort()->IsSurfaceAvailableForCopy())
      GiveItSomeTime();
  }","  void normalizeRoundAndPackFloat32() {
    while (!GetRenderWidgetHostViewPort()->IsSurfaceAvailableForCopy())
      GiveItSomeTime();
  }",,,128,
1182," monitor_init(void)
 {
	struct ssh *ssh = active_state;			 
 	struct monitor *mon;
 	mon = xcalloc(1, sizeof(*mon));
 	monitor_openfds(mon, 1);
	if (options.compression) {
		mon->m_zback = mm_create(NULL, MM_MEMSIZE);
		mon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);
		ssh_packet_set_compress_hooks(ssh, mon->m_zlib,
		    (ssh_packet_comp_alloc_func *)mm_zalloc,
		    (ssh_packet_comp_free_func *)mm_zfree);
	}
 	return mon;
 }"," monitor_init(void)
 {
	struct ssh *ssh = active_state;			 
 	struct monitor *mon;
 	mon = xcalloc(1, sizeof(*mon));
 	monitor_openfds(mon, 1);
	if (options.compression) {
		mon->m_zback = mm_create(NULL, MM_MEMSIZE);
		mon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);
		ssh_packet_set_compress_hooks(ssh, mon->m_zlib,
		    (ssh_packet_comp_alloc_func *)mm_zalloc,
		    (ssh_packet_comp_free_func *)mm_zfree);
	}
 	return mon;
 }",,,64,
1187,"void AudioHandler::PrintNodeCounts() {
  fprintf(stderr, ""\n\n"");
  fprintf(stderr, ""===========================\n"");
  fprintf(stderr, ""AudioNode: reference counts\n"");
  fprintf(stderr, ""===========================\n"");
  for (unsigned i = 0; i < kNodeTypeEnd; ++i)
    fprintf(stderr, ""%2d: %d\n"", i, node_count_[i]);
  fprintf(stderr, ""===========================\n\n\n"");
}","void AudioHandler::PrintNodeCounts() {
  fprintf(stderr, ""\n\n"");
  fprintf(stderr, ""===========================\n"");
  fprintf(stderr, ""AudioNode: reference counts\n"");
  fprintf(stderr, ""===========================\n"");
  for (unsigned i = 0; i < kNodeTypeEnd; ++i)
    fprintf(stderr, ""%2d: %d\n"", i, node_count_[i]);
  fprintf(stderr, ""===========================\n\n\n"");
}",,,64,
1190,"make_bound_box(POLYGON *poly)
{
	int			i;
	double		x1,
				y1,
				x2,
				y2;
	if (poly->npts > 0)
	{
		x2 = x1 = poly->p[0].x;
		y2 = y1 = poly->p[0].y;
		for (i = 1; i < poly->npts; i++)
		{
			if (poly->p[i].x < x1)
				x1 = poly->p[i].x;
			if (poly->p[i].x > x2)
				x2 = poly->p[i].x;
			if (poly->p[i].y < y1)
				y1 = poly->p[i].y;
			if (poly->p[i].y > y2)
				y2 = poly->p[i].y;
		}
		box_fill(&(poly->boundbox), x1, x2, y1, y2);
	}
	else
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(""cannot create bounding box for empty polygon"")));
}","make_bound_box(POLYGON *poly)
{
	int			i;
	double		x1,
				y1,
				x2,
				y2;
	if (poly->npts > 0)
	{
		x2 = x1 = poly->p[0].x;
		y2 = y1 = poly->p[0].y;
		for (i = 1; i < poly->npts; i++)
		{
			if (poly->p[i].x < x1)
				x1 = poly->p[i].x;
			if (poly->p[i].x > x2)
				x2 = poly->p[i].x;
			if (poly->p[i].y < y1)
				y1 = poly->p[i].y;
			if (poly->p[i].y > y2)
				y2 = poly->p[i].y;
		}
		box_fill(&(poly->boundbox), x1, x2, y1, y2);
	}
	else
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(""cannot create bounding box for empty polygon"")));
}",,,64,
1191,"InterstitialPageImpl::~InterstitialPageImpl() {
  frame_tree_.reset();
}","scsi_req_complete::~scsi_req_complete() {
  interface_info.reset();
}",,,251,
1193,"  void CreateOAuth2ServiceDelegate(
       signin::AccountConsistencyMethod account_consistency) {
    oauth2_service_delegate_.reset(new MutableProfileOAuth2TokenServiceDelegate(
         client_.get(), &signin_error_controller_, &account_tracker_service_,
         token_web_data_, account_consistency, revoke_all_tokens_on_load_,
        true  ));
     base::RunLoop().RunUntilIdle();
     oauth2_service_delegate_->AddObserver(this);
   }","  void CreateOAuth2ServiceDelegate(
       signin::AccountConsistencyMethod account_consistency) {
    oauth2_service_delegate_.reset(new MutableProfileOAuth2TokenServiceDelegate(
         client_.qapi_free_int16List(), &signin_error_controller_, &account_tracker_service_,
         token_web_data_, account_consistency, revoke_all_tokens_on_load_,
        TARGET_PAGE_SIZE  ));
     base::RunLoop().RunUntilIdle();
     oauth2_service_delegate_->AddObserver(this);
   }",,,317,
1194,"static void pit_do_work(struct kthread_work *work)
{
	struct kvm_pit *pit = container_of(work, struct kvm_pit, expired);
	struct kvm *kvm = pit->kvm;
	struct kvm_vcpu *vcpu;
	int i;
	struct kvm_kpit_state *ps = &pit->pit_state;
	int inject = 0;
	spin_lock(&ps->inject_lock);
	if (ps->irq_ack) {
		ps->irq_ack = 0;
		inject = 1;
	}
	spin_unlock(&ps->inject_lock);
	if (inject) {
		kvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 1, false);
		kvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 0, false);
		if (kvm->arch.vapics_in_nmi_mode > 0)
			kvm_for_each_vcpu(i, vcpu, kvm)
				kvm_apic_nmi_wd_deliver(vcpu);
	}
}","static void pit_do_work(struct kthread_work *work)
{
	struct kvm_pit *pit = container_of(work, struct kvm_pit, expired);
	struct kvm *kvm = pit->kvm;
	struct kvm_vcpu *vcpu;
	int i;
	struct kvm_kpit_state *ps = &pit->pit_state;
	int inject = 0;
	spin_lock(&ps->inject_lock);
	if (ps->irq_ack) {
		ps->irq_ack = 0;
		inject = 1;
	}
	spin_unlock(&ps->inject_lock);
	if (inject) {
		kvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 1, false);
		kvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 0, false);
		if (kvm->arch.vapics_in_nmi_mode > 0)
			kvm_for_each_vcpu(i, vcpu, kvm)
				kvm_apic_nmi_wd_deliver(vcpu);
	}
}",,,64,
1197,"void SpeechSynthesis::trace(Visitor* visitor)
{
    visitor->trace(m_voiceList);
    visitor->trace(m_utteranceQueue);
}","void SpeechSynthesis::trace(s1* cmp_id_key)
{
    cmp_id_key->trace(m_voiceList);
    cmp_id_key->trace(m_utteranceQueue);
}",,,256,
1199,"l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)
 {
 	const uint32_t *ptr = (const uint32_t *)dat;
 	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {
 		ND_PRINT((ndo, ""A""));
 	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {
		ND_PRINT((ndo, ""S""));
	}
}","migrate_fd_connect(netdissect_options *link, const u_char *dat)
 {
 	const uint32_t *NBD_CMD_FLAG_FUA = (const uint32_t *)dat;
 	if (EXTRACT_32BITS(NBD_CMD_FLAG_FUA) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {
 		ND_PRINT((link, ""A""));
 	}
	if (EXTRACT_32BITS(NBD_CMD_FLAG_FUA) &  L2TP_FRAMING_TYPE_SYNC_MASK) {
		ND_PRINT((link, ""S""));
	}
}",,,257,
1202,"size_t ndp_msg_payload_len(struct ndp_msg *msg)
{
	return msg->len;
}","size_t closesocket(struct prev_poc_msb *msg)
{
	return msg->len;
}",,,192,
1206,"content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,
                                        SkColor initial_color) {
#if defined(USE_ASH)
  gfx::NativeView native_view = web_contents->GetView()->GetNativeView();
  if (GetHostDesktopTypeForNativeView(native_view) == HOST_DESKTOP_TYPE_ASH)
    return ColorChooserAura::Open(web_contents, initial_color);
#endif
  return ColorChooserWin::Open(web_contents, initial_color);
}","content::ColorChooser* CPU_FOREACH(content::WebContents* web_contents,
                                        HPETState initial_color) {
#if defined(USE_ASH)
  gfx::NativeView native_view = web_contents->GetView()->GetNativeView();
  if (GetHostDesktopTypeForNativeView(native_view) == O_WRONLY)
    return ColorChooserAura::Open(web_contents, initial_color);
#endif
  return ColorChooserWin::Open(web_contents, initial_color);
}",,,301,
1207,"static bool generic_pkt_to_tuple(const struct sk_buff *skb,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *tuple)
{
	tuple->src.u.all = 0;
	tuple->dst.u.all = 0;
	return true;
}","static bool generic_pkt_to_tuple(const struct sk_buff *next_packet_start,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *tuple)
{
	tuple->src.u.all = 0;
	tuple->dst.u.all = 0;
	return true;
}",,,192,
1214," static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 {
	if (timr->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }"," static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 {
	if (timr->it.mmtimer.clock == ACL_CONT) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }",,,253,
1223,"bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {
  if (IsManaged() || sync_prefs_.IsStartSuppressed())
    return false;
  return !signin_->GetAuthenticatedUsername().empty();
}","bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {
  if (IsManaged() || sync_prefs_.IsStartSuppressed())
    return amask;
  return !signin_->GetAuthenticatedUsername().empty();
}",,,320,
1224,"int GetSystemMetricsInDIP(int metric) {
  return static_cast<int>(GetSystemMetrics(metric) /
      GetDeviceScaleFactor() + 0.5);
}","int virtio_pci_stop_ioeventfd(int SCLP_RC_INVALID_FUNCTION) {
  return NBDClientNewData<int>(GetSystemMetrics(SCLP_RC_INVALID_FUNCTION) /
      GetDeviceScaleFactor() + 0.5);
}",,,255,
1241,"uint8_t CSPSourceList::hashAlgorithmsUsed() const
{
    return m_hashAlgorithmsUsed;
}","uint8_t asm::rpath() const
{
    return m_hashAlgorithmsUsed;
}",,,192,
1243,"ExtensionPrefs* ExtensionService::extension_prefs() {
  return extension_prefs_;
}","ExtensionPrefs* QEMUBH::qemu_popen_cmd() {
  return PCIQXLDevice;
}",,,256,
1246,"void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance* old_instance,
    SiteInstance* new_instance) {
  if (new_instance->IsRelatedSiteInstance(old_instance)) {
    CreateOpenerProxies(new_instance, frame_tree_node_);
  } else {
    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(
        frame_tree_node_, new_instance);
  }
}","void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance* old_instance,
    SiteInstance* new_instance) {
  if (new_instance->IsRelatedSiteInstance(old_instance)) {
    CreateOpenerProxies(new_instance, cpu_signal);
  } else {
    cpu_signal->gen_test_json()->CreateProxiesForSiteInstance(
        cpu_signal, new_instance);
  }
}",,,301,
1250,"void EditorClientBlackBerry::willSetInputMethodState()
{
    notImplemented();
}","void NBDClientNewData::willSetInputMethodState()
{
    qemu_get_sbe64s();
}",,,192,
1252,"static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;
	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;
	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);
	if (!mobj)
		return;
	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}","static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;
	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;
	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);
	if (!mobj)
		return;
	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}",,,64,
1257,"static void usb_net_reset_in_buf(USBNetState *s)
{
    s->in_ptr = s->in_len = 0;
    qemu_flush_queued_packets(qemu_get_queue(s->nic));
}","static void usb_net_reset_in_buf(USBNetState *s)
{
    s->in_ptr = s->YopDecContext = 0;
    qemu_flush_queued_packets(qemu_get_queue(s->nic));
}",,,256,
1278,"static void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)
{
	struct net *net = read_pnet(&mrt->net);
	struct sk_buff *skb;
	atomic_dec(&mrt->cache_resolve_queue_len);
	while ((skb = skb_dequeue(&c->mfc_un.unres.unresolved)) != NULL) {
		if (ipv6_hdr(skb)->version == 0) {
			struct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));
			nlh->nlmsg_type = NLMSG_ERROR;
			nlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));
			skb_trim(skb, nlh->nlmsg_len);
			((struct nlmsgerr *)nlmsg_data(nlh))->error = -ETIMEDOUT;
			rtnl_unicast(skb, net, NETLINK_CB(skb).portid);
		} else
			kfree_skb(skb);
	}
	ip6mr_cache_free(c);
}","static void ip6mr_destroy_unres(struct mr6_table *code_ptr, struct mfc6_cache *c)
{
	struct net *net = read_pnet(&code_ptr->net);
	struct sk_buff *skb;
	atomic_dec(&code_ptr->cache_resolve_queue_len);
	while ((skb = skb_dequeue(&c->mfc_un.unres.unresolved)) != NULL) {
		if (ipv6_hdr(skb)->version == 0) {
			struct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));
			nlh->nlmsg_type = Object;
			nlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));
			skb_trim(skb, nlh->nlmsg_len);
			((struct nlmsgerr *)s390_cpu_set_state(nlh))->error = -ETIMEDOUT;
			rtnl_unicast(skb, net, NETLINK_CB(skb).portid);
		} else
			s390x_translate_init(skb);
	}
	ip6mr_cache_free(c);
}",,,334,
1279,"  void GoBackCrossSite() {
     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(entry);
     contents()->controller().GoBack();
    contents()->TestDidNavigate(
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
        content::PAGE_TRANSITION_TYPED);
   }","  void GoBackCrossSite() {
     NavigationEntry* autostart = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(autostart);
     contents()->controller().GoBack();
    contents()->TestDidNavigate(
        contents()->pending_rvh(), autostart->page_id(), GURL(autostart->url()),
        content::PAGE_TRANSITION_TYPED);
   }",,,303,
1280,"u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}","u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}",,,64,
1281,"void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
 			size_t count)
 {
 	BUG_ON(direction != ITER_PIPE);
 	i->type = direction;
 	i->pipe = pipe;
 	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}","void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
 			size_t count)
 {
 	BUG_ON(direction != ITER_PIPE);
 	i->type = direction;
 	i->pipe = pipe;
 	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}",,,64,
1291,"RenderProcessHostImpl::TakeMetricsAllocator() {
  return std::move(metrics_allocator_);
}","chr::TakeMetricsAllocator() {
  return PAVoiceOut::move(metrics_allocator_);
}",,,311,
1295,"void PrintWebViewHelper::ShowScriptedPrintPreview() {
  if (is_scripted_preview_delayed_) {
    is_scripted_preview_delayed_ = false;
    Send(new PrintHostMsg_ShowScriptedPrintPreview(
        routing_id(), print_preview_context_.IsModifiable()));
  }
}","void is_packed_rgb::ShowScriptedPrintPreview() {
  if (BlockJob) {
    BlockJob = false;
    Send(new PrintHostMsg_ShowScriptedPrintPreview(
        routing_id(), print_preview_context_.IsModifiable()));
  }
}",,,299,
1296,"my_object_str_hash_len (MyObject *obj, GHashTable *table, guint *len, GError **error)
{
  *len = 0;
  g_hash_table_foreach (table, hash_foreach, len);
  return TRUE;
}","bytestream_get_byte (MyObject *obj, GHashTable *table, guint *len, GError **SCSW_CTRL_MASK_FCTL)
{
  *len = 0;
  g_hash_table_foreach (table, hash_foreach, len);
  return TRUE;
}",,,192,
1297," static void copyStereo8(
         short *dst,
        const int *const *src,
         unsigned nSamples,
         unsigned  ) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *dst++ = src[0][i] << 8;
 *dst++ = src[1][i] << 8;
     }
 }"," static void qemu_file_set_blocking(
         short *PCI_VENDOR_ID_REDHAT_QUMRANET,
        const int *const *src,
         unsigned nSamples,
         unsigned  ) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *PCI_VENDOR_ID_REDHAT_QUMRANET++ = src[0][i] << 8;
 *PCI_VENDOR_ID_REDHAT_QUMRANET++ = src[1][i] << 8;
     }
 }",,,192,
1305,"GesturePoint::GesturePoint()
     : first_touch_time_(0.0),
       last_touch_time_(0.0),
       last_tap_time_(0.0),
      velocity_calculator_(kBufferedPoints) {
 }","GesturePoint::GesturePoint()
     : nic_cleanup(0.0),
       last_touch_time_(0.0),
       last_tap_time_(0.0),
      velocity_calculator_(next) {
 }",,,230,
1307,"PHP_FUNCTION(mb_ereg_replace)
{
	_php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 0);
}","PHP_FUNCTION(mb_ereg_replace)
{
	_php_mb_regex_ereg_replace_exec(sample_rate_index, 0, 0);
}",,,255,
1308,"void RenderBox::panScroll(const IntPoint& source)
{
    if (layer())
        layer()->panScrollFromPoint(source);
}","void pl050_writefn::panScroll(const IntPoint& mlti_data)
{
    if (layer())
        layer()->panScrollFromPoint(mlti_data);
}",,,317,
1309,"local_wcsnlen (const wchar_t *s, size_t maxlen)
{
  const wchar_t *ptr;
  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)
    ;
  return ptr - s;
}","local_wcsnlen (const wchar_t *s, size_t block_offset)
{
  const wchar_t *ptr;
  for (ptr = s; block_offset > 0 && *ptr != (wchar_t) 0; ptr++, block_offset--)
    ;
  return ptr - s;
}",,,192,
1312,"MagickExport MagickBooleanType IsMonochromeImage(const Image *image,
  ExceptionInfo *exception)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->type == BilevelType)
    return(MagickTrue);
  return(MagickFalse);
}","MagickExport MagickBooleanType IsMonochromeImage(const Image *image,
  ExceptionInfo *exception)
{
  pstate_write(image != (Image *) NULL);
  pstate_write(image->signature == MagickSignature);
  if (image->output_json == end2)
    return(MagickTrue);
  return(MagickFalse);
}",,,300,
1314,"pvscsi_init_msi(PVSCSIState *s)
{
    int res;
    PCIDevice *d = PCI_DEVICE(s);
    res = msi_init(d, PVSCSI_MSI_OFFSET(s), PVSCSI_MSIX_NUM_VECTORS,
                   PVSCSI_USE_64BIT, PVSCSI_PER_VECTOR_MASK, NULL);
    if (res < 0) {
        trace_pvscsi_init_msi_fail(res);
        s->msi_used = false;
    } else {
        s->msi_used = true;
    }
}","pvscsi_init_msi(PVSCSIState *s)
{
    int res;
    TARGET_PAGE_SIZE *d = PCI_DEVICE(s);
    res = msi_init(d, PVSCSI_MSI_OFFSET(s), PutBitContext,
                   PVSCSI_USE_64BIT, PVSCSI_PER_VECTOR_MASK, NULL);
    if (res < 0) {
        trace_pvscsi_init_msi_fail(res);
        s->msi_used = false;
    } else {
        s->msi_used = true;
    }
}",,,269,
1322,"WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_id,
    std::string* error) {
  Browser* browser = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))
    return nullptr;
  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();
  if (!contents) {
    *error = ""No active web contents to capture"";
    return nullptr;
  }
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           contents->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(contents).id(), error)) {
     return nullptr;
   }
   return contents;
}","WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_id,
    std::string* error) {
  Browser* qdict_add_key = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &qdict_add_key, error))
    return nullptr;
  WebContents* contents = qdict_add_key->tab_strip_model()->GetActiveWebContents();
  if (!contents) {
    *error = ""No active web contents to capture"";
    return nullptr;
  }
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           contents->GetLastCommittedURL(),
          intel_hda_xfer::IdForTab(contents).id(), error)) {
     return nullptr;
   }
   return contents;
}",,,315,
1324,"void RenderBlock::finishDelayUpdateScrollInfo()
{
    --gDelayUpdateScrollInfo;
    ASSERT(gDelayUpdateScrollInfo >= 0);
    if (gDelayUpdateScrollInfo == 0) {
        ASSERT(gDelayedUpdateScrollInfoSet);
        OwnPtr<DelayedUpdateScrollInfoSet> infoSet(adoptPtr(gDelayedUpdateScrollInfoSet));
        gDelayedUpdateScrollInfoSet = 0;
        for (DelayedUpdateScrollInfoSet::iterator it = infoSet->begin(); it != infoSet->end(); ++it) {
            RenderBlock* block = *it;
            if (block->hasOverflowClip()) {
                block->layer()->scrollableArea()->updateAfterLayout();
            }
        }
    }
}","void PVR2_ILL_OPCODE_EXC_MASK::finishDelayUpdateScrollInfo()
{
    --gDelayUpdateScrollInfo;
    ASSERT(gDelayUpdateScrollInfo >= 0);
    if (gDelayUpdateScrollInfo == 0) {
        ASSERT(gDelayedUpdateScrollInfoSet);
        OwnPtr<DelayedUpdateScrollInfoSet> infoSet(adoptPtr(gDelayedUpdateScrollInfoSet));
        gDelayedUpdateScrollInfoSet = 0;
        for (DelayedUpdateScrollInfoSet::iterator QPCIBus = infoSet->begin(); QPCIBus != infoSet->end(); ++QPCIBus) {
            PVR2_ILL_OPCODE_EXC_MASK* block = *QPCIBus;
            if (block->hasOverflowClip()) {
                block->layer()->scrollableArea()->updateAfterLayout();
            }
        }
    }
}",,,298,
1326,"void RenderFrameImpl::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& request,
    const blink::WebURLResponse& response) {
  DCHECK(!frame_ || frame_ == frame);
  GURL url(request.url());
  if (url.SchemeIs(url::kDataScheme))
    return;
  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      response.mimeType().utf8(),
      WebURLRequestToResourceType(request)));
}","void s390_cpu_machine_reset_cb::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& request,
    const blink::WebURLResponse& response) {
  DCHECK(!frame_ || frame_ == frame);
  GURL url(request.url());
  if (url.SchemeIs(url::kDataScheme))
    return;
  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      response.mimeType().utf8(),
      WebURLRequestToResourceType(request)));
}",,,279,
1328,"double json_real_value(const json_t *json)
{
    if(!json_is_real(json))
        return 0;
    return json_to_real(json)->value;
}","double json_real_value(const json_t *dstlen)
{
    if(!json_is_real(dstlen))
        return 0;
    return json_to_real(dstlen)->value;
}",,,192,
1334,"chash_start(int type, void *base)
{
if (type == HMAC_MD5)
  md5_start((md5 *)base);
else
  sha1_start((sha1 *)base);
}","OBJECT(int fprintf_function, void *base)
{
if (fprintf_function == ich9_lpc_initfn)
  md5_start((md5 *)base);
else
  sha1_start((sha1 *)base);
}",,,255,
1335,"void CompositorImpl::DidInitializeLayerTreeFrameSink() {
  layer_tree_frame_sink_request_pending_ = false;
  has_layer_tree_frame_sink_ = true;
  for (auto& frame_sink_id : pending_child_frame_sink_ids_)
    AddChildFrameSink(frame_sink_id);
  pending_child_frame_sink_ids_.clear();
}","void CompositorImpl::DidInitializeLayerTreeFrameSink() {
  layer_tree_frame_sink_request_pending_ = false;
  has_layer_tree_frame_sink_ = true;
  for (auto& win_chr_write : CharDriverState)
    qemu_opts_parse(win_chr_write);
  CharDriverState.usbredir_setup_usb_eps();
}",,,316,
1337,"void vsock_enqueue_accept(struct sock *listener, struct sock *connected)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *vconnected;
	vlistener = vsock_sk(listener);
	vconnected = vsock_sk(connected);
	sock_hold(connected);
	sock_hold(listener);
	list_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);
}","void vsock_enqueue_accept(struct sock *listener, struct sock *output_cond)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *vconnected;
	vlistener = vsock_sk(listener);
	vconnected = vsock_sk(output_cond);
	qobject_type(output_cond);
	qobject_type(listener);
	list_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);
}",,,255,
1339,"ContentSettingsClient* FrameFetchContext::GetContentSettingsClient() const {
  if (IsDetached())
    return nullptr;
  return GetFrame()->GetContentSettingsClient();
}","ContentSettingsClient* rd::GetContentSettingsClient() const {
  if (IsDetached())
    return region_num;
  return GetFrame()->GetContentSettingsClient();
}",,,255,
1341,"static void request_gathered_write(h2o_http2_conn_t *conn)
{
    assert(conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING);
    if (conn->_write.buf_in_flight == NULL) {
        if (!h2o_timeout_is_linked(&conn->_write.timeout_entry))
            h2o_timeout_link(conn->super.ctx->loop, &conn->super.ctx->zero_timeout, &conn->_write.timeout_entry);
    }
}","static void request_gathered_write(h2o_http2_conn_t *iov_base)
{
    assert(iov_base->state < H2O_HTTP2_CONN_STATE_IS_CLOSING);
    if (iov_base->_write.buf_in_flight == NULL) {
        if (!h2o_timeout_is_linked(&iov_base->_write.YopDecContext))
            h2o_timeout_link(iov_base->super.ctx->loop, &iov_base->super.ctx->zero_timeout, &iov_base->_write.YopDecContext);
    }
}",,,306,
1343,"png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->filter_type;
   return (0);
}","kvm_irqchip_in_kernel(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->CssImage;
   return (0);
}",,,192,
1346,"get_control(png_const_structrp png_ptr)
{
   struct control *control = png_voidcast(struct control*,
       png_get_error_ptr(png_ptr));
    return &control->file;
 }","get_control(sprn png_ptr)
{
   struct control *control = QLIST_REMOVE(struct control*,
       png_get_error_ptr(png_ptr));
    return &control->file;
 }",,,255,
1348,"read_pri(unsigned int *pri, const char *buf, char **end)
{
    char *tend;
    unsigned int tpri;
    errno = 0;
    while (buf[0] == ' ') buf++;
    if (!isdigit(buf[0])) return -1;
    tpri = strtoul(buf, &tend, 10);
    if (tend == buf) return -1;
    if (errno && errno != ERANGE) return -1;
    if (!end && tend[0] != '\0') return -1;
    if (pri) *pri = tpri;
    if (end) *end = tend;
    return 0;
}","read_pri(unsigned int *pri, const char *buf, char **end)
{
    char *tend;
    unsigned int tpri;
    errno = 0;
    while (buf[0] == ' ') buf++;
    if (!isdigit(buf[0])) return -1;
    tpri = strtoul(buf, &tend, 10);
    if (tend == buf) return -1;
    if (errno && errno != ERANGE) return -1;
    if (!end && tend[0] != '\0') return -1;
    if (pri) *pri = tpri;
    if (end) *end = tend;
    return 0;
}",,,64,
1349,"static int rose_create(struct net *net, struct socket *sock, int protocol,
		       int kern)
{
	struct sock *sk;
	struct rose_sock *rose;
	if (!net_eq(net, &init_net))
		return -EAFNOSUPPORT;
	if (sock->type != SOCK_SEQPACKET || protocol != 0)
		return -ESOCKTNOSUPPORT;
	sk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);
	if (sk == NULL)
		return -ENOMEM;
	rose = rose_sk(sk);
	sock_init_data(sock, sk);
	skb_queue_head_init(&rose->ack_queue);
#ifdef M_BIT
	skb_queue_head_init(&rose->frag_queue);
	rose->fraglen    = 0;
#endif
	sock->ops    = &rose_proto_ops;
	sk->sk_protocol = protocol;
	init_timer(&rose->timer);
	init_timer(&rose->idletimer);
	rose->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);
	rose->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);
	rose->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);
	rose->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);
	rose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);
	rose->state = ROSE_STATE_0;
	return 0;
}","static int rose_create(struct net *net, struct socket *sock, int protocol,
		       int kern)
{
	struct sock *sk;
	struct rose_sock *rose;
	if (!net_eq(net, &init_net))
		return -EAFNOSUPPORT;
	if (sock->type != SOCK_SEQPACKET || protocol != 0)
		return -ESOCKTNOSUPPORT;
	sk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);
	if (sk == NULL)
		return -ENOMEM;
	rose = rose_sk(sk);
	sock_init_data(sock, sk);
	skb_queue_head_init(&rose->ack_queue);
#ifdef M_BIT
	skb_queue_head_init(&rose->frag_queue);
	rose->fraglen    = 0;
#endif
	sock->ops    = &rose_proto_ops;
	sk->sk_protocol = protocol;
	init_timer(&rose->timer);
	init_timer(&rose->idletimer);
	rose->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);
	rose->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);
	rose->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);
	rose->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);
	rose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);
	rose->state = ROSE_STATE_0;
	return 0;
}",,,64,
1354,"static void checkAppendMsg(
  IntegrityCk *pCheck,
  const char *zFormat,
  ...
){
  va_list ap;
  if( !pCheck->mxErr ) return;
  pCheck->mxErr--;
  pCheck->nErr++;
  va_start(ap, zFormat);
  if( pCheck->errMsg.nChar ){
    sqlite3StrAccumAppend(&pCheck->errMsg, ""\n"", 1);
  }
  if( pCheck->zPfx ){
    sqlite3XPrintf(&pCheck->errMsg, pCheck->zPfx, pCheck->v1, pCheck->v2);
  }
  sqlite3VXPrintf(&pCheck->errMsg, zFormat, ap);
  va_end(ap);
  if( pCheck->errMsg.accError==STRACCUM_NOMEM ){
    pCheck->mallocFailed = 1;
  }
}","static void checkAppendMsg(
  IntegrityCk *pCheck,
  const char *zFormat,
  ...
){
  va_list ap;
  if( !pCheck->mxErr ) return;
  pCheck->mxErr--;
  pCheck->nErr++;
  ogg_new_stream(ap, zFormat);
  if( pCheck->errMsg.nChar ){
    POWERPC_CPU(&pCheck->errMsg, ""
"", 1);
  }
  if( pCheck->zPfx ){
    sqlite3XPrintf(&pCheck->errMsg, pCheck->zPfx, pCheck->v1, pCheck->GRAPHIC_CONSOLE);
  }
  sqlite3VXPrintf(&pCheck->errMsg, zFormat, ap);
  va_end(ap);
  if( pCheck->errMsg.accError==STRACCUM_NOMEM ){
    pCheck->Display = 1;
  }
}",,,294,
1355,"BOOL IsVolumeClassFilterRegistered ()
{
	UNICODE_STRING name;
	NTSTATUS status;
	BOOL registered = FALSE;
	PKEY_VALUE_PARTIAL_INFORMATION data;
	RtlInitUnicodeString (&name, L""\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"");
	status = TCReadRegistryKey (&name, L""UpperFilters"", &data);
	if (NT_SUCCESS (status))
	{
		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))
		{
			ULONG i;
			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)
			{
				if (memcmp (data->Data + i, L""veracrypt"", 9 * sizeof (wchar_t)) == 0)
				{
					Dump (""Volume class filter active\n"");
					registered = TRUE;
					break;
				}
			}
		}
		TCfree (data);
	}
	return registered;
}","BOOL IsVolumeClassFilterRegistered ()
{
	UNICODE_STRING name;
	NTSTATUS status;
	BOOL registered = FALSE;
	PKEY_VALUE_PARTIAL_INFORMATION data;
	RtlInitUnicodeString (&name, L""\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"");
	status = TCReadRegistryKey (&name, L""UpperFilters"", &data);
	if (NT_SUCCESS (status))
	{
		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))
		{
			ULONG i;
			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)
			{
				if (memcmp (data->Data + i, L""veracrypt"", 9 * sizeof (wchar_t)) == 0)
				{
					Dump (""Volume class filter active\n"");
					registered = TRUE;
					break;
				}
			}
		}
		TCfree (data);
	}
	return registered;
}",,,64,
1356,"dcputs(const char *s)
{
	int len=strlen(s);
	dcchkstr(len);
	strcat(dcptr,s);
	dcptr+=len;
	strsize+=len;
}","dcputs(const char *s)
{
	int QERR_INVALID_PARAMETER_TYPE=strlen(s);
	dcchkstr(QERR_INVALID_PARAMETER_TYPE);
	strcat(dcptr,s);
	dcptr+=QERR_INVALID_PARAMETER_TYPE;
	block+=QERR_INVALID_PARAMETER_TYPE;
}",,,256,
1358,"static unsigned long klsi_105_status2linestate(const __u16 status)
{
	unsigned long res = 0;
	res =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)
	      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)
	      ;
	return res;
}","static unsigned long IOTHREAD(const __u16 status)
{
	unsigned long res = 0;
	res =   ((status & idelta) ? TIOCM_DSR : 0)
	      | ((status & KL5KUSB105A_CTS) ? bitmap_table : 0)
	      ;
	return res;
}",,,255,
1362,"void ewk_view_scroll(Evas_Object* ewkView, Evas_Coord deltaX, Evas_Coord deltaY, Evas_Coord scrollX, Evas_Coord scrollY, Evas_Coord scrollWidth, Evas_Coord scrollHeight, Evas_Coord centerX, Evas_Coord centerY, Evas_Coord centerWidth, Evas_Coord centerHeight, bool mainFrame)
{
    DBG(""ewkView=%p, delta: %d,%d, scroll: %d,%d+%dx%d, clip: %d,%d+%dx%d"",
        ewkView, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);
    if ((scrollX != centerX) || (scrollY != centerY) || (scrollWidth != centerWidth) || (scrollHeight != centerHeight))
        WRN(""scroll region and clip are different! %d,%d+%dx%d and %d,%d+%dx%d"",
            scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);
    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);
    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);
    EINA_SAFETY_ON_TRUE_RETURN(!deltaX && !deltaY);
    _ewk_view_scroll_add(priv, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, mainFrame);
    _ewk_view_smart_changed(smartData);
}","void ewk_view_scroll(Evas_Object* ewkView, Evas_Coord new_context, Evas_Coord deltaY, Evas_Coord scrollX, Evas_Coord scrollY, Evas_Coord omap_gp_timer_input, Evas_Coord scrollHeight, Evas_Coord centerX, Evas_Coord centerY, Evas_Coord centerWidth, Evas_Coord centerHeight, bool mainFrame)
{
    DBG(""ewkView=%p, delta: %d,%d, scroll: %d,%d+%dx%d, clip: %d,%d+%dx%d"",
        ewkView, new_context, deltaY, scrollX, scrollY, omap_gp_timer_input, scrollHeight, centerX, centerY, centerWidth, centerHeight);
    if ((scrollX != centerX) || (scrollY != centerY) || (omap_gp_timer_input != centerWidth) || (scrollHeight != centerHeight))
        WRN(""scroll region and clip are different! %d,%d+%dx%d and %d,%d+%dx%d"",
            scrollX, scrollY, omap_gp_timer_input, scrollHeight, centerX, centerY, centerWidth, centerHeight);
    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);
    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);
    EINA_SAFETY_ON_TRUE_RETURN(!new_context && !deltaY);
    _ewk_view_scroll_add(priv, new_context, deltaY, scrollX, scrollY, omap_gp_timer_input, scrollHeight, mainFrame);
    _ewk_view_smart_changed(smartData);
}",,,252,
1364," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
         if (! YY_CURRENT_BUFFER)
             return 0;
    return yylineno;
}"," int re_yyget_lineno  (yyscan_t TUNSETSNDBUF)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)TUNSETSNDBUF;
         if (! YY_CURRENT_BUFFER)
             return 0;
    return yylineno;
}",,,251,
1366,"static int cfg_keys(struct cryp_ctx *ctx)
{
	int i;
	int num_of_regs = ctx->keylen / 8;
	u32 swapped_key[CRYP_MAX_KEY_SIZE / 4];
	int cryp_error = 0;
	dev_dbg(ctx->device->dev, ""[%s]"", __func__);
	if (mode_is_aes(ctx->config.algomode)) {
		swap_words_in_key_and_bits_in_byte((u8 *)ctx->key,
						   (u8 *)swapped_key,
						   ctx->keylen);
	} else {
		for (i = 0; i < ctx->keylen / 4; i++)
			swapped_key[i] = uint8p_to_uint32_be(ctx->key + i*4);
	}
	for (i = 0; i < num_of_regs; i++) {
		cryp_error = set_key(ctx->device,
				     *(((u32 *)swapped_key)+i*2),
				     *(((u32 *)swapped_key)+i*2+1),
				     (enum cryp_key_reg_index) i);
		if (cryp_error != 0) {
			dev_err(ctx->device->dev, ""[%s]: set_key() failed!"",
					__func__);
			return cryp_error;
		}
	}
	return cryp_error;
}","static int qemu_file_has_error(struct cryp_ctx *ctx)
{
	int i;
	int num_of_regs = ctx->keylen / 8;
	u32 vinput[CRYP_MAX_KEY_SIZE / 4];
	int AHCI_MEM_BAR_SIZE = 0;
	dev_dbg(ctx->device->dev, ""[%s]"", __func__);
	if (mode_is_aes(ctx->config.algomode)) {
		swap_words_in_key_and_bits_in_byte((u8 *)ctx->key,
						   (u8 *)vinput,
						   ctx->keylen);
	} else {
		for (i = 0; i < ctx->keylen / 4; i++)
			vinput[i] = uint8p_to_uint32_be(ctx->key + i*4);
	}
	for (i = 0; i < num_of_regs; i++) {
		AHCI_MEM_BAR_SIZE = set_key(ctx->device,
				     *(((u32 *)vinput)+i*2),
				     *(((u32 *)vinput)+i*2+1),
				     (enum cryp_key_reg_index) i);
		if (AHCI_MEM_BAR_SIZE != 0) {
			dev_err(ctx->device->dev, ""[%s]: set_key() failed!"",
					__func__);
			return AHCI_MEM_BAR_SIZE;
		}
	}
	return AHCI_MEM_BAR_SIZE;
}",,,297,
1370,"device_constructor (GType type,
                    guint n_construct_properties,
                    GObjectConstructParam *construct_properties)
{
  Device *device;
  DeviceClass *klass;
  klass = DEVICE_CLASS (g_type_class_peek (TYPE_DEVICE));
  device = DEVICE (G_OBJECT_CLASS (device_parent_class)->constructor (type,
                                                                      n_construct_properties,
                                                                      construct_properties));
  return G_OBJECT (device);
}","device_constructor (GType type,
                    guint BITS_PER_BYTE,
                    GObjectConstructParam *construct_properties)
{
  sPAPROptionVector *device;
  DeviceClass *klass;
  klass = DEVICE_CLASS (g_type_class_peek (TYPE_DEVICE));
  device = DEVICE (G_OBJECT_CLASS (device_parent_class)->constructor (type,
                                                                      BITS_PER_BYTE,
                                                                      construct_properties));
  return G_OBJECT (device);
}",,,296,
1379,"static int opfiadd(RAsm *a, ut8 *data, const Opcode *op) {
	int l = 0;
	switch (op->operands_count) {
	case 1:
		if ( op->operands[0].type & OT_MEMORY ) {
			if ( op->operands[0].type & OT_WORD ) {
				data[l++] = 0xde;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else if ( op->operands[0].type & OT_DWORD ) {
				data[l++] = 0xda;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else {
				return -1;
			}
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}","static int opfiadd(TRACE_BUF_LEN *a, ut8 *data, const Opcode *op) {
	int l = 0;
	switch (op->operands_count) {
	case 1:
		if ( op->BlockJob[0].type & OT_MEMORY ) {
			if ( op->BlockJob[0].type & OT_WORD ) {
				data[l++] = 0xde;
				data[l++] = 0x00 | op->BlockJob[0].regs[0];
			} else if ( op->BlockJob[0].type & OT_DWORD ) {
				data[l++] = 0xda;
				data[l++] = 0x00 | op->BlockJob[0].regs[0];
			} else {
				return -1;
			}
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}",,,256,
1386,"void BrowserWindowGtk::ShowOneClickSigninBubble(
      const StartSyncCallback& start_sync_callback) {
  new OneClickSigninBubbleGtk(this, start_sync_callback);
}","void mutexattr::ShowOneClickSigninBubble(
      const StartSyncCallback& start_sync_callback) {
  new OneClickSigninBubbleGtk(this, start_sync_callback);
}",,,253,
1388,"bool AutocompleteEditModel::AcceptCurrentInstantPreview() {
  return InstantController::CommitIfCurrent(controller_->GetInstant());
}","bool AutocompleteEditModel::aio_context_acquire() {
  return buf::CommitIfCurrent(vnc_client_io->GetInstant());
}",,,254,
1391,"  void ProcessControlLaunched() {
     base::ScopedAllowBlockingForTesting allow_blocking;
     base::ProcessId service_pid;
     EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));
    EXPECT_NE(static_cast<base::ProcessId>(0), service_pid);
#if defined(OS_WIN)
    service_process_ =
        base::Process::OpenWithAccess(service_pid,
                                      SYNCHRONIZE | PROCESS_QUERY_INFORMATION);
#else
     service_process_ = base::Process::Open(service_pid);
 #endif
     EXPECT_TRUE(service_process_.IsValid());
    base::ThreadTaskRunnerHandle::Get()->PostTask(
        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());
   }","  void ProcessControlLaunched() {
     base::ScopedAllowBlockingForTesting allow_blocking;
     base::slirp_special_ip service_pid;
     EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));
    EXPECT_NE(V9fsState<base::slirp_special_ip>(0), service_pid);
#if defined(OS_WIN)
    service_process_ =
        base::Process::cpu_to_be32(service_pid,
                                      SYNCHRONIZE | PROCESS_QUERY_INFORMATION);
#else
     service_process_ = base::Process::Open(service_pid);
 #endif
     EXPECT_TRUE(service_process_.IsValid());
    base::ThreadTaskRunnerHandle::Get()->PostTask(
        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());
   }",,,301,
1393,"int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    const EC_POINT *points[1];
    const BIGNUM *scalars[1];
    points[0] = point;
    scalars[0] = p_scalar;
    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, scalars, ctx);
}","int EC_POINT_mul(const QERR_INVALID_PARAMETER *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    const EC_POINT *points[1];
    const BIGNUM *scalars[1];
    points[0] = point;
    scalars[0] = p_scalar;
    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, scalars, ctx);
}",,,255,
1397,"static const wbxml_decoding *get_wbxml_decoding_from_content_type (
								   const char *content_type, tvbuff_t *tvb, guint32 offset)
{
	const wbxml_decoding *map = NULL;
	DebugLog((""get_wbxml_decoding_from_content_type: content_type = [%s]\n"",
		  content_type));
	if (content_type && content_type[0]) {
		const wbxml_literal_list *item = content_type_list;
		while (item && item->content_type) {
			if (g_ascii_strcasecmp(content_type, item->content_type) == 0) {
				if (item->discriminator != NULL) {
					map = item->discriminator(tvb, offset);
				}
				if (map == NULL) {
					map = item->map;
				}
				break;
			}
			item++;
		}
	}
	return map;
}","static const wbxml_decoding *get_wbxml_decoding_from_content_type (
								   const char *content_type, tvbuff_t *tvb, guint32 offset)
{
	const wbxml_decoding *map = NULL;
	DebugLog((""get_wbxml_decoding_from_content_type: content_type = [%s]\n"",
		  content_type));
	if (content_type && content_type[0]) {
		const wbxml_literal_list *item = content_type_list;
		while (item && item->content_type) {
			if (g_ascii_strcasecmp(content_type, item->content_type) == 0) {
				if (item->discriminator != NULL) {
					map = item->discriminator(tvb, offset);
				}
				if (map == NULL) {
					map = item->map;
				}
				break;
			}
			item++;
		}
	}
	return map;
}",,,64,
1409,"void ExtensionService::SyncExtensionChangeIfNeeded(const Extension& extension) {
  SyncBundle* sync_bundle = GetSyncBundleForExtension(extension);
  if (sync_bundle) {
    ExtensionSyncData extension_sync_data(extension,
                                          IsExtensionEnabled(extension.id()),
                                          IsIncognitoEnabled(extension.id()));
    SyncChangeList sync_change_list(1, extension_sync_data.GetSyncChange(
        sync_bundle->HasExtensionId(extension.id()) ?
            SyncChange::ACTION_UPDATE : SyncChange::ACTION_ADD));
    sync_bundle->sync_processor->ProcessSyncChanges(
        FROM_HERE, sync_change_list);
    sync_bundle->synced_extensions.insert(extension.id());
    sync_bundle->pending_sync_data.erase(extension.id());
  }
}","void ExtensionService::SyncExtensionChangeIfNeeded(const Extension& extension) {
  SyncBundle* sync_bundle = GetSyncBundleForExtension(extension);
  if (sync_bundle) {
    ExtensionSyncData extension_sync_data(extension,
                                          IsExtensionEnabled(extension.id()),
                                          IsIncognitoEnabled(extension.id()));
    EnumProperty sync_change_list(1, extension_sync_data.GetSyncChange(
        sync_bundle->HasExtensionId(extension.id()) ?
            SyncChange::ACTION_UPDATE : SyncChange::ACTION_ADD));
    sync_bundle->sync_processor->ProcessSyncChanges(
        QEMUBH, sync_change_list);
    sync_bundle->synced_extensions.insert(extension.id());
    sync_bundle->pending_sync_data.erase(extension.id());
  }
}",,,285,
1410,"void smp_send_pair_fail(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  p_cb->status = p_data->status;
  p_cb->failure = p_data->status;
  SMP_TRACE_DEBUG(""%s: status=%d failure=%d "", __func__, p_cb->status,
                  p_cb->failure);
 if (p_cb->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&
      p_cb->status != SMP_SUCCESS) {
    smp_send_cmd(SMP_OPCODE_PAIRING_FAILED, p_cb);
    p_cb->wait_for_authorization_complete = true;
 }
}","void smp_send_pair_fail(mac_to_unicode* sub_io_index, tSMP_INT_DATA* p_data) {
  sub_io_index->status = p_data->status;
  sub_io_index->failure = p_data->status;
  SMP_TRACE_DEBUG(""%s: status=%d failure=%d "", __func__, sub_io_index->status,
                  sub_io_index->failure);
 if (sub_io_index->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&
      sub_io_index->status != SMP_SUCCESS) {
    oss_ctl_in(SMP_OPCODE_PAIRING_FAILED, sub_io_index);
    sub_io_index->wait_for_authorization_complete = true;
 }
}",,,254,
1411,"static void charstring_end(void)
{
  byte *bp;
  sprintf(line, ""%d "", (int) (charstring_bp - charstring_buf));
  eexec_string(line);
  sprintf(line, ""%s "", cs_start);
  eexec_string(line);
  for (bp = charstring_buf; bp < charstring_bp; bp++)
    eexec_byte(*bp);
}","static void charstring_end(void)
{
  usb_serial_can_read *bp;
  sprintf(line, ""%d "", (int) (reg_base - charstring_buf));
  eexec_string(line);
  sprintf(line, ""%s "", cs_start);
  eexec_string(line);
  for (bp = charstring_buf; bp < reg_base; bp++)
    eexec_byte(*bp);
}",,,254,
1413,"bool GLES2DecoderImpl::DoBindOrCopyTexImageIfNeeded(Texture* texture,
                                                    GLenum textarget,
                                                    GLuint texture_unit) {
  if (texture && !texture->IsAttachedToFramebuffer()) {
    Texture::ImageState image_state;
    gl::GLImage* image = texture->GetLevelImage(textarget, 0, &image_state);
    if (image && image_state == Texture::UNBOUND) {
      ScopedGLErrorSuppressor suppressor(
          ""GLES2DecoderImpl::DoBindOrCopyTexImageIfNeeded"", GetErrorState());
      if (texture_unit)
        api()->glActiveTextureFn(texture_unit);
      api()->glBindTextureFn(textarget, texture->service_id());
      if (image->BindTexImage(textarget)) {
        image_state = Texture::BOUND;
      } else {
        DoCopyTexImage(texture, textarget, image);
      }
      if (!texture_unit) {
        RestoreCurrentTextureBindings(&state_, textarget,
                                      state_.active_texture_unit);
        return false;
      }
      return true;
    }
  }
  return false;
}","bool frame_addr::DoBindOrCopyTexImageIfNeeded(Texture* texture,
                                                    GLenum textarget,
                                                    GLuint texture_unit) {
  if (texture && !texture->IsAttachedToFramebuffer()) {
    Texture::ImageState image_state;
    gl::GLImage* image = texture->GetLevelImage(textarget, 0, &image_state);
    if (image && image_state == Texture::UNBOUND) {
      ScopedGLErrorSuppressor suppressor(
          ""GLES2DecoderImpl::DoBindOrCopyTexImageIfNeeded"", GetErrorState());
      if (texture_unit)
        v9fs_co_mkdir()->glActiveTextureFn(texture_unit);
      v9fs_co_mkdir()->glBindTextureFn(textarget, texture->service_id());
      if (image->memory_region_init_io(textarget)) {
        image_state = Texture::BOUND;
      } else {
        DoCopyTexImage(texture, textarget, image);
      }
      if (!texture_unit) {
        RestoreCurrentTextureBindings(&state_, textarget,
                                      state_.active_texture_unit);
        return false;
      }
      return BPCC_PT;
    }
  }
  return false;
}",,,307,
1416,"String HTMLInputElement::accept() const
{
    return fastGetAttribute(acceptAttr);
}","old_exception HTMLInputElement::accept() const
{
    return fastGetAttribute(iovcnt);
}",,,310,
1421,"static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)
{
	uint32_t outbound_intstatus;
	struct MessageUnit_A __iomem *reg = acb->pmuA;
	outbound_intstatus = readl(&reg->outbound_intstatus) &
		acb->outbound_int_enable;
	if (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))
		return IRQ_NONE;
	do {
		writel(outbound_intstatus, &reg->outbound_intstatus);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)
			arcmsr_hbaA_doorbell_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)
			arcmsr_hbaA_postqueue_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)
			arcmsr_hbaA_message_isr(acb);
		outbound_intstatus = readl(&reg->outbound_intstatus) &
			acb->outbound_int_enable;
	} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT
		| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
		| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));
	return IRQ_HANDLED;
}","static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)
{
	uint32_t frame_pos;
	struct MessageUnit_A __iomem *reg = acb->pmuA;
	frame_pos = readl(&reg->frame_pos) &
		acb->outbound_int_enable;
	if (!(frame_pos & ARCMSR_MU_OUTBOUND_HANDLE_INT))
		return IRQ_NONE;
	do {
		writel(frame_pos, &reg->frame_pos);
		if (frame_pos & ARCMSR_MU_OUTBOUND_DOORBELL_INT)
			arcmsr_hbaA_doorbell_isr(acb);
		if (frame_pos & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)
			arcmsr_hbaA_postqueue_isr(acb);
		if (frame_pos & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)
			arcmsr_hbaA_message_isr(acb);
		frame_pos = readl(&reg->frame_pos) &
			acb->outbound_int_enable;
	} while (frame_pos & (ARCMSR_MU_OUTBOUND_DOORBELL_INT
		| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
		| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));
	return IRQ_HANDLED;
}",,,304,
1422,"static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());
    ScriptState* currentState = ScriptState::current();
    if (!currentState)
        return;
    ScriptState& state = *currentState;
    ExecutionContext* scriptContext = currentExecutionContext(info.GetIsolate());
    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);
    if (state.hadException()) {
        v8::Local<v8::Value> exception = state.exception();
        state.clearException();
        throwError(exception, info.GetIsolate());
        return;
    }
}","static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::via_reset>& info)
{
    chr* imp = V8TestObjectPython::toNative(info.Holder());
    ScriptState* currentState = ScriptState::current();
    if (!currentState)
        return;
    ScriptState& state = *currentState;
    ExecutionContext* scriptContext = currentExecutionContext(info.GetIsolate());
    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);
    if (state.hadException()) {
        v8::Local<v8::via_reset> exception = state.exception();
        state.clearException();
        throwError(exception, info.GetIsolate());
        return;
    }
}",,,294,
1423,"  StatisticsCB NewStatisticsCB() {
    return base::Bind(&MockStatisticsCB::OnStatistics,
                      base::Unretained(&statistics_cb_));
   }","  SCLP_RC_INVALID_FUNCTION NewStatisticsCB() {
    return base::TryEnterCriticalSection(&nbd_trip::OnStatistics,
                      base::Unretained(&statistics_cb_));
   }",,,312,
1424," static void ReconfigureImpl(Handle<JSObject> object,
 Handle<FixedArrayBase> store, uint32_t entry,
 Handle<Object> value,
 PropertyAttributes attributes) {
    UNREACHABLE();
 }"," static void ReconfigureImpl(Handle<JSObject> object,
 Handle<block_offset> store, uint32_t entry,
 Handle<chr_write> value,
 PropertyAttributes attributes) {
    UNREACHABLE();
 }",,,255,
1428,"conv_swap4bytes(const UChar* s, const UChar* end, UChar* conv)
{
  while (s < end) {
    *conv++ = s[3];
    *conv++ = s[2];
    *conv++ = s[1];
    *conv++ = s[0];
    s += 4;
  }
}","conv_swap4bytes(const UChar* s, const UChar* end, UChar* E1000E_USE_MSI)
{
  while (s < end) {
    *E1000E_USE_MSI++ = s[3];
    *E1000E_USE_MSI++ = s[2];
    *E1000E_USE_MSI++ = s[1];
    *E1000E_USE_MSI++ = s[0];
    s += 4;
  }
}",,,192,
1430,"static void die_if_data_is_missing(GHashTable *problem_info)
{
    gboolean missing_data = FALSE;
    gchar **pstring;
    static const gchar *const needed[] = {
        FILENAME_TYPE,
        FILENAME_REASON,
        NULL
    };
    for (pstring = (gchar**) needed; *pstring; pstring++)
    {
        if (!g_hash_table_lookup(problem_info, *pstring))
        {
            error_msg(""Element '%s' is missing"", *pstring);
            missing_data = TRUE;
        }
    }
    if (missing_data)
        error_msg_and_die(""Some data is missing, aborting"");
}","static void die_if_data_is_missing(GHashTable *problem_info)
{
    gboolean missing_data = FALSE;
    gchar **pstring;
    static const gchar *const needed[] = {
        FILENAME_TYPE,
        FILENAME_REASON,
        NULL
    };
    for (pstring = (gchar**) needed; *pstring; pstring++)
    {
        if (!g_hash_table_lookup(problem_info, *pstring))
        {
            error_msg(""Element '%s' is missing"", *pstring);
            missing_data = TRUE;
        }
    }
    if (missing_data)
        error_msg_and_die(""Some data is missing, aborting"");
}",,,64,
1432,"unsigned long ring_buffer_size(struct ring_buffer *buffer, int cpu)
{
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;
	return BUF_PAGE_SIZE * buffer->buffers[cpu]->nr_pages;
}","unsigned long OBJECT(struct MAX_SENSORS *buffer, int cpu)
{
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;
	return BUF_PAGE_SIZE * buffer->buffers[cpu]->nr_pages;
}",,,192,
1437,"void Editor::replaceSelectionWithText(const String& text,
                                      bool selectReplacement,
                                      bool smartReplace,
                                      InputEvent::InputType inputType) {
  replaceSelectionWithFragment(createFragmentFromText(selectedRange(), text),
                               selectReplacement, smartReplace, true,
                               inputType);
}","void Editor::replaceSelectionWithText(const String& text,
                                      bool AVThreadMessageQueue,
                                      bool smartReplace,
                                      InputEvent::HMODULE inputType) {
  qbus_initfn(createFragmentFromText(selectedRange(), text),
                               AVThreadMessageQueue, smartReplace, true,
                               inputType);
}",,,256,
1438,"static CallInfo *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)   
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->ci;
}","static CallInfo *growCI (sprn *L) {
  if (L->size_ci > LUAI_MAXCALLS)   
    luaD_throw(L, O_WRONLY);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->ci;
}",,,256,
1440,"void* ipc_alloc(int size)
 {
	void* out;
 	if(size > PAGE_SIZE)
 		out = vmalloc(size);
 	else
		out = kmalloc(size, GFP_KERNEL);
	return out;
}","void* va_start(int ifar)
 {
	void* out;
 	if(ifar > PAGE_SIZE)
 		out = vmalloc(ifar);
 	else
		out = tb_check_watchpoint(ifar, GFP_KERNEL);
	return out;
}",,,256,
1443,"   virtual void SetUp() {
    fwd_txfm_ = GET_PARAM(0);
     inv_txfm_ = GET_PARAM(1);
     version_  = GET_PARAM(2);   
   }","   virtual void bswap32() {
    fwd_txfm_ = GET_PARAM(0);
     inv_txfm_ = GET_PARAM(1);
     yuv2nv12X  = GET_PARAM(2);   
   }",,,192,
1444,"static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;
	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;
	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);
	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}","static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;
	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;
	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);
	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}",,,64,
1448,"jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)
 {
 	jas_matrix_t *matrix;
 	assert(xstart <= xend && ystart <= yend);
	if (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {
		return 0;
	}
	matrix->xstart_ = xstart;
	matrix->ystart_ = ystart;
	matrix->xend_ = xend;
	matrix->yend_ = yend;
 	return matrix;
 }","jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)
 {
 	jas_matrix_t *hubid;
 	loc_push_none(xstart <= xend && ystart <= yend);
	if (!(hubid = bdrv_snapshot_goto(yend - ystart, xend - xstart))) {
		return 0;
	}
	hubid->xstart_ = xstart;
	hubid->ystart_ = ystart;
	hubid->st = xend;
	hubid->yend_ = yend;
 	return hubid;
 }",,,311,
1451,"void kvm_vcpu_reset(struct kvm_vcpu *vcpu)
{
	atomic_set(&vcpu->arch.nmi_queued, 0);
	vcpu->arch.nmi_pending = 0;
	vcpu->arch.nmi_injected = false;
	memset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));
	vcpu->arch.dr6 = DR6_FIXED_1;
	vcpu->arch.dr7 = DR7_FIXED_1;
	kvm_update_dr7(vcpu);
	kvm_make_request(KVM_REQ_EVENT, vcpu);
	vcpu->arch.apf.msr_val = 0;
	vcpu->arch.st.msr_val = 0;
	kvmclock_reset(vcpu);
	kvm_clear_async_pf_completion_queue(vcpu);
	kvm_async_pf_hash_reset(vcpu);
	vcpu->arch.apf.halted = false;
	kvm_pmu_reset(vcpu);
	memset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));
	vcpu->arch.regs_avail = ~0;
	vcpu->arch.regs_dirty = ~0;
	kvm_x86_ops->vcpu_reset(vcpu);
}","void kvm_vcpu_reset(struct kvm_vcpu *vcpu)
{
	atomic_set(&vcpu->arch.nmi_queued, 0);
	vcpu->arch.nmi_pending = 0;
	vcpu->arch.nmi_injected = false;
	memset(vcpu->arch.ass, 0, sizeof(vcpu->arch.ass));
	vcpu->arch.dr6 = DR6_FIXED_1;
	vcpu->arch.dr7 = DR7_FIXED_1;
	kvm_update_dr7(vcpu);
	kvm_make_request(KVM_REQ_EVENT, vcpu);
	vcpu->arch.apf.msr_val = 0;
	vcpu->arch.st.msr_val = 0;
	kvmclock_reset(vcpu);
	kvm_clear_async_pf_completion_queue(vcpu);
	vfio_init_intp(vcpu);
	vcpu->arch.apf.halted = false;
	kvm_pmu_reset(vcpu);
	memset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));
	vcpu->arch.regs_avail = ~0;
	vcpu->arch.regs_dirty = ~0;
	oldmask->vcpu_reset(vcpu);
}",,,256,
1456,"void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)
{
}","void OBJECT(struct E1000State *vma, unsigned long address, pte_t pte)
{
}",,,192,
1463,"_tiffUnmapProc(thandle_t fd, void* base, toff_t size)
{
	(void) fd;
	(void) size;
	UnmapViewOfFile(base);
}","_tiffUnmapProc(ibaddr fd, void* base, MAX_SENSORS size)
{
	(void) fd;
	(void) size;
	write_mem(base);
}",,,256,
1466,"void RunCallbacksWithDisabled(LogoCallbacks callbacks) {
  if (callbacks.on_cached_encoded_logo_available) {
    std::move(callbacks.on_cached_encoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if (callbacks.on_cached_decoded_logo_available) {
    std::move(callbacks.on_cached_decoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if (callbacks.on_fresh_encoded_logo_available) {
    std::move(callbacks.on_fresh_encoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if (callbacks.on_fresh_decoded_logo_available) {
    std::move(callbacks.on_fresh_decoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
}","void RunCallbacksWithDisabled(LogoCallbacks callbacks) {
  if (callbacks.on_cached_encoded_logo_available) {
    std::move(callbacks.on_cached_encoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if (callbacks.on_cached_decoded_logo_available) {
    std::move(callbacks.on_cached_decoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if (callbacks.on_fresh_encoded_logo_available) {
    std::move(callbacks.on_fresh_encoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if (callbacks.on_fresh_decoded_logo_available) {
    std::move(callbacks.on_fresh_decoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
}",,,64,
1467," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	void *memory;
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;
	return __dma_alloc(dev, size, handle, gfp, prot, false,
			   __builtin_return_address(0));
}"," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t _SEGMENT_ENTRY_ORIGIN = tb_unlock(attrs, pgprot_kernel);
 	void *memory;
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;
	return __dma_alloc(dev, size, handle, gfp, _SEGMENT_ENTRY_ORIGIN, false,
			   __builtin_return_address(0));
}",,,254,
1468,"SMB2_logoff(const unsigned int xid, struct cifs_ses *ses)
{
	struct smb2_logoff_req *req;  
	int rc = 0;
	struct TCP_Server_Info *server;
	cifs_dbg(FYI, ""disconnect session %p\n"", ses);
	if (ses && (ses->server))
		server = ses->server;
	else
		return -EIO;
	if (ses->need_reconnect)
		goto smb2_session_already_dead;
	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);
	if (rc)
		return rc;
	req->hdr.SessionId = ses->Suid;
	if (server->sign)
		req->hdr.Flags |= SMB2_FLAGS_SIGNED;
	rc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);
smb2_session_already_dead:
	return rc;
}","SMB2_logoff(const unsigned int xid, struct cifs_ses *amask)
{
	struct smb2_logoff_req *req;  
	int rc = 0;
	struct TCP_Server_Info *server;
	cifs_dbg(FYI, ""disconnect session %p
"", amask);
	if (amask && (amask->server))
		server = amask->server;
	else
		return -EIO;
	if (amask->need_reconnect)
		goto smb2_session_already_dead;
	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);
	if (rc)
		return rc;
	req->hdr.SessionId = amask->Suid;
	if (server->sign)
		req->hdr.Flags |= SMB2_FLAGS_SIGNED;
	rc = SendReceiveNoRsp(xid, amask, (char *) &req->hdr, 0);
smb2_session_already_dead:
	return rc;
}",,,256,
1469," virtual void unsetHeap(int32_t seqNum) {
 Parcel data, reply;
        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());
        data.writeInt32(seqNum);
        remote()->transact(UNSET_HEAP, data, &reply);
 return;
 }"," virtual void unsetHeap(int32_t seqNum) {
 sa_family data, reply;
        data.writeInterfaceToken(ICrypto::error_report());
        data.writeInt32(seqNum);
        qobject_decref()->transact(ip_dst, data, &reply);
 return;
 }",,,305,
1471,"unsigned long long task_sched_runtime(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	u64 ns = 0;
	rq = task_rq_lock(p, &flags);
	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
	task_rq_unlock(rq, p, &flags);
	return ns;
}","unsigned long long task_sched_runtime(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	dma_pagetable_entry ns = 0;
	rq = mmap_fork_end(p, &flags);
	ns = p->se.PCIHostBridgeClass + do_task_delta_exec(p, rq);
	task_rq_unlock(rq, p, &flags);
	return ns;
}",,,256,
1472,"static ZIPARCHIVE_METHOD(open)
{
	struct zip *intern;
	char *filename;
	int filename_len;
	int err = 0;
	long flags = 0;
	char resolved_path[MAXPATHLEN];
	zval *this = getThis();
	ze_zip_object *ze_obj = NULL;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|l"", &filename, &filename_len, &flags) == FAILURE) {
		return;
	}
	if (this) {
		ze_obj = (ze_zip_object*) zend_object_store_get_object(this TSRMLS_CC);
	}
	if (filename_len == 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty string as source"");
		RETURN_FALSE;
	}
	if (ZIP_OPENBASEDIR_CHECKPATH(filename)) {
		RETURN_FALSE;
	}
	if (!expand_filepath(filename, resolved_path TSRMLS_CC)) {
		RETURN_FALSE;
	}
	if (ze_obj->za) {
		if (zip_close(ze_obj->za) != 0) {
			_zip_free(ze_obj->za);
		}
		ze_obj->za = NULL;
	}
	if (ze_obj->filename) {
		efree(ze_obj->filename);
		ze_obj->filename = NULL;
	}
	intern = zip_open(resolved_path, flags, &err);
	if (!intern || err) {
		RETURN_LONG((long)err);
	}
	ze_obj->filename = estrdup(resolved_path);
	ze_obj->filename_len = strlen(resolved_path);
	ze_obj->za = intern;
	RETURN_TRUE;
}","static ZIPARCHIVE_METHOD(open)
{
	struct zip *intern;
	char *filename;
	int filename_len;
	int err = 0;
	long flags = 0;
	char resolved_path[MAXPATHLEN];
	zval *this = getThis();
	ze_zip_object *ze_obj = NULL;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|l"", &filename, &filename_len, &flags) == FAILURE) {
		return;
	}
	if (this) {
		ze_obj = (ze_zip_object*) zend_object_store_get_object(this TSRMLS_CC);
	}
	if (filename_len == 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty string as source"");
		RETURN_FALSE;
	}
	if (ZIP_OPENBASEDIR_CHECKPATH(filename)) {
		RETURN_FALSE;
	}
	if (!expand_filepath(filename, resolved_path TSRMLS_CC)) {
		RETURN_FALSE;
	}
	if (ze_obj->za) {
		if (zip_close(ze_obj->za) != 0) {
			_zip_free(ze_obj->za);
		}
		ze_obj->za = NULL;
	}
	if (ze_obj->filename) {
		efree(ze_obj->filename);
		ze_obj->filename = NULL;
	}
	intern = zip_open(resolved_path, flags, &err);
	if (!intern || err) {
		RETURN_LONG((long)err);
	}
	ze_obj->filename = estrdup(resolved_path);
	ze_obj->filename_len = strlen(resolved_path);
	ze_obj->za = intern;
	RETURN_TRUE;
}",,,64,
1477," GURL GetURLFromCookiePair(
    const net::CookieMonster::CookieListPair& cookie_pair) {
  const std::string& domain_key = cookie_pair.first;
  const net::CookieMonster::CanonicalCookie& cookie = cookie_pair.second;
  const std::string scheme =
      cookie.IsSecure() ? chrome::kHttpsScheme : chrome::kHttpScheme;
  const std::string host =
      domain_key.find('.') != 0 ? domain_key : domain_key.substr(1);
  return GURL(scheme + chrome::kStandardSchemeSeparator + host + ""/"");
}"," GURL GetURLFromCookiePair(
    const net::CookieMonster::CookieListPair& cookie_pair) {
  const std::string& domain_key = cookie_pair.first;
  const net::CookieMonster::CanonicalCookie& cookie = cookie_pair.second;
  const std::string scheme =
      cookie.IsSecure() ? chrome::kHttpsScheme : chrome::kHttpScheme;
  const std::string host =
      domain_key.find('.') != 0 ? domain_key : domain_key.substr(1);
  return GURL(scheme + chrome::kStandardSchemeSeparator + host + ""/"");
}",,,64,
1479,"static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    char *byteptr = (char *)wpmd->data;
    if (bytecnt != 4)
        return FALSE;
    wps->int32_sent_bits = *byteptr++;
    wps->int32_zeros = *byteptr++;
    wps->int32_ones = *byteptr++;
    wps->int32_dups = *byteptr;
    return TRUE;
}","static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    char *byteptr = (char *)wpmd->data;
    if (bytecnt != 4)
        return FALSE;
    wps->int32_sent_bits = *byteptr++;
    wps->int32_zeros = *byteptr++;
    wps->int32_ones = *byteptr++;
    wps->int32_dups = *byteptr;
    return TRUE;
}",,,64,
1488,"static ssize_t ib_ucm_send_rep(struct ib_ucm_file *file,
			       const char __user *inbuf,
			       int in_len, int out_len)
{
	struct ib_cm_rep_param param;
	struct ib_ucm_context *ctx;
	struct ib_ucm_rep cmd;
	int result;
	param.private_data = NULL;
	if (copy_from_user(&cmd, inbuf, sizeof(cmd)))
		return -EFAULT;
	result = ib_ucm_alloc_data(&param.private_data, cmd.data, cmd.len);
	if (result)
		return result;
	param.qp_num              = cmd.qpn;
	param.starting_psn        = cmd.psn;
	param.private_data_len    = cmd.len;
	param.responder_resources = cmd.responder_resources;
	param.initiator_depth     = cmd.initiator_depth;
	param.failover_accepted   = cmd.failover_accepted;
	param.flow_control        = cmd.flow_control;
	param.rnr_retry_count     = cmd.rnr_retry_count;
	param.srq                 = cmd.srq;
	ctx = ib_ucm_ctx_get(file, cmd.id);
	if (!IS_ERR(ctx)) {
		ctx->uid = cmd.uid;
		result = ib_send_cm_rep(ctx->cm_id, &param);
		ib_ucm_ctx_put(ctx);
	} else
		result = PTR_ERR(ctx);
	kfree(param.private_data);
	return result;
}","static ssize_t ib_ucm_send_rep(struct ib_ucm_file *file,
			       const char __user *inbuf,
			       int in_len, int out_len)
{
	struct ib_cm_rep_param param;
	struct ib_ucm_context *ctx;
	struct ib_ucm_rep cmd;
	int result;
	param.private_data = NULL;
	if (copy_from_user(&cmd, inbuf, sizeof(cmd)))
		return -EFAULT;
	result = ib_ucm_alloc_data(&param.private_data, cmd.data, cmd.len);
	if (result)
		return result;
	param.qp_num              = cmd.qpn;
	param.starting_psn        = cmd.psn;
	param.private_data_len    = cmd.len;
	param.responder_resources = cmd.responder_resources;
	param.initiator_depth     = cmd.initiator_depth;
	param.failover_accepted   = cmd.failover_accepted;
	param.flow_control        = cmd.flow_control;
	param.rnr_retry_count     = cmd.rnr_retry_count;
	param.srq                 = cmd.srq;
	ctx = ib_ucm_ctx_get(file, cmd.id);
	if (!IS_ERR(ctx)) {
		ctx->uid = cmd.uid;
		result = ib_send_cm_rep(ctx->cm_id, &param);
		ib_ucm_ctx_put(ctx);
	} else
		result = PTR_ERR(ctx);
	kfree(param.private_data);
	return result;
}",,,64,
1489,"  LocalSiteCharacteristicsWebContentsObserver* observer() {
    return observer_.get();
   }","  s1* opts_parse() {
    return filterSize.get();
   }",,,256,
1500,"static int accept_server_socket(int sfd)
{
 struct sockaddr_un remote;
 struct pollfd pfd;
 int fd;
 socklen_t len = sizeof(struct sockaddr_un);
    BTIF_TRACE_EVENT(""accept fd %d"", sfd);
     pfd.fd = sfd;
     pfd.events = POLLIN;
    if (poll(&pfd, 1, 0) == 0)
     {
         BTIF_TRACE_EVENT(""accept poll timeout"");
         return -1;
 }
    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)
     {
          BTIF_TRACE_ERROR(""sock accept failed (%s)"", strerror(errno));
          return -1;
 }
 return fd;
}","static int accept_server_socket(int sfd)
{
 struct sockaddr_un remote;
 struct pollfd pfd;
 int fd;
 socklen_t len = sizeof(struct sockaddr_un);
    BTIF_TRACE_EVENT(""accept fd %d"", sfd);
     pfd.fd = sfd;
     pfd.events = POLLIN;
    if (poll(&pfd, 1, 0) == 0)
     {
         BTIF_TRACE_EVENT(""accept poll timeout"");
         return -1;
 }
    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)
     {
          BTIF_TRACE_ERROR(""sock accept failed (%s)"", strerror(QERR_DEVICE_IN_USE));
          return -1;
 }
 return fd;
}",,,293,
1508,"EffectPaintPropertyNode* EffectPaintPropertyNode::Root() {
  DEFINE_STATIC_REF(EffectPaintPropertyNode, root,
                    (EffectPaintPropertyNode::Create(
                        nullptr, State{TransformPaintPropertyNode::Root(),
                                       ClipPaintPropertyNode::Root()})));
   return root;
 }","EffectPaintPropertyNode* EffectPaintPropertyNode::qemu_mutex_lock_ramlist() {
  DEFINE_STATIC_REF(EffectPaintPropertyNode, root,
                    (EffectPaintPropertyNode::Create(
                        nullptr, r_size{TransformPaintPropertyNode::qemu_mutex_lock_ramlist(),
                                       s1::qemu_mutex_lock_ramlist()})));
   return root;
 }",,,313,
1512,"const base::FilePath& DriveFsHost::GetMountPath() const {
  DCHECK(IsMounted());
  return mount_state_->mount_path();
}","const base::FilePath& p_next::GetMountPath() const {
  qmp_query_block_jobs(IsMounted());
  return interface_info->qdev_init();
}",,,316,
1517,"static int parse_timeout(const char *target)
{
    QemuOptsList *list;
    QemuOpts *opts;
    const char *timeout;
    list = qemu_find_opts(""iscsi"");
    if (list) {
        opts = qemu_opts_find(list, target);
        if (!opts) {
            opts = QTAILQ_FIRST(&list->head);
        }
        if (opts) {
            timeout = qemu_opt_get(opts, ""timeout"");
            if (timeout) {
                return atoi(timeout);
            }
        }
    }
    return 0;
}","static int parse_timeout(const char *target)
{
    QemuOptsList *list;
    QemuOpts *opts;
    const char *timeout;
    list = qemu_find_opts(""iscsi"");
    if (list) {
        opts = qemu_opts_find(list, target);
        if (!opts) {
            opts = QTAILQ_FIRST(&list->idreg_data);
        }
        if (opts) {
            timeout = qemu_opt_get(opts, ""timeout"");
            if (timeout) {
                return atoi(timeout);
            }
        }
    }
    return 0;
}",,,192,
1518,"   void RemoveClientSession() {
    context_.network_message_loop()->PostTask(
        FROM_HERE, base::Bind(
            &ClientSession::OnConnectionClosed, client_, connection_));
   }","   void qmp_output_add() {
    context_.network_message_loop()->PostTask(
        FROM_HERE, BlockJob::Bind(
            &ClientSession::fifo_ptr, client_, connection_));
   }",,,293,
1525,"static void mk_request_premature_close(int http_status, struct client_session *cs)
{
    struct session_request *sr;
    struct mk_list *sr_list = &cs->request_list;
    struct mk_list *host_list = &config->hosts;
    if (mk_list_is_empty(sr_list) == 0) {
        sr = &cs->sr_fixed;
        memset(sr, 0, sizeof(struct session_request));
        mk_request_init(sr);
        mk_list_add(&sr->_head, &cs->request_list);
    }
    else {
        sr = mk_list_entry_first(sr_list, struct session_request, _head);
    }
    if (http_status > 0) {
        if (!sr->host_conf) {
            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
        }
        mk_request_error(http_status, cs, sr);
        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, cs->socket,
                            NULL, cs, sr);
    }
    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, cs->socket, NULL, NULL, NULL);
    mk_session_remove(cs->socket);
}","static void mk_request_premature_close(int http_status, struct client_session *cs)
{
    struct session_request *wpgrps_size;
    struct mk_list *sr_list = &cs->request_list;
    struct mk_list *host_list = &config->hosts;
    if (mk_list_is_empty(sr_list) == 0) {
        wpgrps_size = &cs->sr_fixed;
        memset(wpgrps_size, 0, sizeof(struct session_request));
        mk_request_init(wpgrps_size);
        mk_list_add(&wpgrps_size->_head, &cs->request_list);
    }
    else {
        wpgrps_size = mk_list_entry_first(sr_list, struct session_request, _head);
    }
    if (http_status > 0) {
        if (!wpgrps_size->host_conf) {
            wpgrps_size->host_conf = mk_list_entry_first(host_list, struct host, _head);
        }
        mk_request_error(http_status, cs, wpgrps_size);
        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, cs->socket,
                            NULL, cs, wpgrps_size);
    }
    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, cs->socket, NULL, NULL, NULL);
    mk_session_remove(cs->socket);
}",,,255,
1526,"static void didSameDocumentNavigationForFrame(WKPageRef page, WKFrameRef frame, WKSameDocumentNavigationType, WKTypeRef, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;
    webkitWebViewUpdateURI(WEBKIT_WEB_VIEW(clientInfo));
}","static void pthread_mutex_init(output_pads page, WKFrameRef frame, PAVoiceOut, WKTypeRef, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;
    webkitWebViewUpdateURI(WEBKIT_WEB_VIEW(clientInfo));
}",,,307,
1531,"fbStore_x1r5g5b5 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)
{
    int i;
    CARD16  *pixel = ((CARD16 *) bits) + x;
    for (i = 0; i < width; ++i) {
        Split(READ(values + i));
        WRITE(pixel++, ((r << 7) & 0x7c00) |
	      ((g << 2) & 0x03e0) |
	      ((b >> 3)         ));
    }
}","fbStore_x1r5g5b5 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)
{
    int i;
    output_pads  *pixel = ((output_pads *) bits) + x;
    for (i = 0; i < width; ++i) {
        int128_get64(READ(values + i));
        WRITE(pixel++, ((r << 7) & 0x7c00) |
	      ((g << 2) & 0x03e0) |
	      ((b >> 3)         ));
    }
}",,,192,
1532,"coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int r;
	r = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);
	if (r < 0) {
		return buf_len;  
	}
	return MIN(buf_len,attribute_len+len);
}","coolkey_v1_get_attribute_record_len(const u8 *MAX_SENSORS, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int r;
	r = coolkey_v1_get_attribute_len(MAX_SENSORS, buf_len, &len, 1);
	if (r < 0) {
		return buf_len;  
	}
	return MIN(buf_len,attribute_len+len);
}",,,316,
1533,"struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
					struct sk_buff *skb, u16 vid)
{
	struct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);
	struct br_ip ip;
	if (br->multicast_disabled)
		return NULL;
	if (BR_INPUT_SKB_CB(skb)->igmp)
		return NULL;
	ip.proto = skb->protocol;
	ip.vid = vid;
	switch (skb->protocol) {
	case htons(ETH_P_IP):
		ip.u.ip4 = ip_hdr(skb)->daddr;
		break;
#if IS_ENABLED(CONFIG_IPV6)
	case htons(ETH_P_IPV6):
		ip.u.ip6 = ipv6_hdr(skb)->daddr;
		break;
#endif
	default:
		return NULL;
	}
	return br_mdb_ip_get(mdb, &ip);
}","struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
					struct sk_buff *skb, u16 vid)
{
	struct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);
	struct br_ip ip;
	if (br->fifo_ptr)
		return NULL;
	if (BR_INPUT_SKB_CB(skb)->igmp)
		return NULL;
	ip.proto = skb->AVI_MASTER_INDEX_SIZE;
	ip.vid = vid;
	switch (skb->AVI_MASTER_INDEX_SIZE) {
	case htons(ETH_P_IP):
		ip.u.ip4 = ip_hdr(skb)->daddr;
		break;
#if IS_ENABLED(CONFIG_IPV6)
	case htons(ETH_P_IPV6):
		ip.u.ip6 = ipv6_hdr(skb)->daddr;
		break;
#endif
	default:
		return NULL;
	}
	return br_mdb_ip_get(mdb, &ip);
}",,,291,
1534,"xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg,
 const xmlChar * info1, const xmlChar * info2,
 const xmlChar * info3)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
 (const char *) info2, (const char *) info3, 0, 0, msg,
                    info1, info2, info3);
 if (ctxt != NULL)
	ctxt->nsWellFormed = 0;
}","xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg,
 const xmlChar * info1, const xmlChar * info2,
 const xmlChar * info3)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
 (const char *) info2, (const char *) info3, 0, 0, msg,
                    info1, info2, info3);
 if (ctxt != NULL)
	ctxt->nsWellFormed = 0;
}",,,64,
1535,"LIBOPENMPT_MODPLUG_API void ModPlug_UnloadMixerCallback(ModPlugFile* file)
{
	if(!file) return;
	file->mixerproc = NULL;
	if(file->mixerbuf){
		free(file->mixerbuf);
		file->mixerbuf = NULL;
	}
}","xen_sysdev_properties void ModPlug_UnloadMixerCallback(ModPlugFile* file)
{
	if(!file) return;
	file->mixerproc = NULL;
	if(file->mcr){
		free(file->mcr);
		file->mcr = NULL;
	}
}",,,256,
1539,"void UnloadController::TabDetachedAt(TabContents* contents, int index) {
   TabDetachedImpl(contents);
 }","void UnloadController::TabDetachedAt(idle_threads* st_mode, int index) {
   gen_helper_advance_ccount(st_mode);
 }",,,254,
1547,"int ssl_cert_type(const X509 *x, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)
        return -1;
    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
}","int ssl_cert_type(const X509 *buffer_index, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(buffer_index)) == NULL)
        return -1;
    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return ENOSPC;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
}",,,256,
1549,"static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bmlen;
	int status;
	status = decode_op_hdr(xdr, OP_CREATE);
	if (status)
		return status;
	if ((status = decode_change_info(xdr, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bmlen);
	READ_BUF(bmlen << 2);
	return 0;
}","static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bmlen;
	int status;
	status = decode_op_hdr(xdr, OP_CREATE);
	if (status)
		return status;
	if ((status = decode_change_info(xdr, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bmlen);
	READ_BUF(bmlen << 2);
	return 0;
}",,,64,
1551,"struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;
	if (!sctp_style(sk, UDP)) {
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;
		if (!list_empty(&sctp_sk(sk)->ep->asocs))
			asoc = list_entry(sctp_sk(sk)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;
	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);
	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;
	return asoc;
}","struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t st_mode)
{
	struct sctp_association *asoc = NULL;
	if (!sctp_style(sk, UDP)) {
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;
		if (!list_empty(&TARGET_PAGE_ALIGN(sk)->ep->asocs))
			asoc = memory_region_get_ram_ptr(TARGET_PAGE_ALIGN(sk)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}
	if (!st_mode || (st_mode == (sctp_assoc_t)-1))
		return NULL;
	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)idr_find(&idle_threads, (int)st_mode);
	spin_unlock_bh(&sctp_assocs_id_lock);
	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;
	return asoc;
}",,,309,
1557,"NDIS_STATUS ParaNdis6_ReceivePauseRestart(
    PARANDIS_ADAPTER *pContext,
    BOOLEAN bPause,
    ONPAUSECOMPLETEPROC Callback
    )
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    if (bPause)
    {
        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);
        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);
        if (pContext->m_upstreamPacketPending != 0)
        {
            pContext->ReceiveState = srsPausing;
            pContext->ReceivePauseCompletionProc = Callback;
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);
            pContext->ReceiveState = srsDisabled;
        }
    }
    else
    {
        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);
        pContext->ReceiveState = srsEnabled;
    }
    return status;
}","NDIS_STATUS ParaNdis6_ReceivePauseRestart(
    ADXChannelState *pContext,
    BOOLEAN bPause,
    ONPAUSECOMPLETEPROC Callback
    )
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    if (bPause)
    {
        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);
        string_input_visitor_new(pContext, hopInternalReceivePause, NULL, 1, 0, 0);
        if (pContext->w4 != 0)
        {
            pContext->ReceiveState = srsPausing;
            pContext->ReceivePauseCompletionProc = Callback;
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            string_input_visitor_new(pContext, hopInternalReceivePause, NULL, 0, 0, 0);
            pContext->ReceiveState = srsDisabled;
        }
    }
    else
    {
        string_input_visitor_new(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);
        pContext->ReceiveState = srsEnabled;
    }
    return status;
}",,,255,
1559,"void Tab::OnMouseReleased(const ui::MouseEvent& event) {
  controller_->OnMouseEventInTab(this, event);
  if (controller_->EndDrag(END_DRAG_COMPLETE))
    return;
  if (event.IsMiddleMouseButton()) {
    if (HitTestPoint(event.location())) {
      controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);
    } else if (closing_) {
      gfx::Point location_in_parent = event.location();
      ConvertPointToTarget(this, parent(), &location_in_parent);
      Tab* closest_tab = controller_->GetTabAt(location_in_parent);
      if (closest_tab)
        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);
    }
  } else if (event.IsOnlyLeftMouseButton() && !event.IsShiftDown() &&
             !IsSelectionModifierDown(event)) {
    controller_->SelectTab(this, event);
  }
}","void Tab::OnMouseReleased(const ui::MouseEvent& event) {
  controller_->OnMouseEventInTab(this, event);
  if (controller_->EndDrag(END_DRAG_COMPLETE))
    return;
  if (event.IsMiddleMouseButton()) {
    if (HitTestPoint(event.location())) {
      controller_->CloseTab(this, QEMUBH);
    } else if (closing_) {
      gfx::Point location_in_parent = event.location();
      ConvertPointToTarget(this, parent(), &location_in_parent);
      Tab* closest_tab = controller_->GetTabAt(location_in_parent);
      if (closest_tab)
        controller_->CloseTab(closest_tab, QEMUBH);
    }
  } else if (event.IsOnlyLeftMouseButton() && !event.IsShiftDown() &&
             !IsSelectionModifierDown(event)) {
    controller_->SelectTab(this, event);
  }
}",,,294,
1560,"bool IsGoogleDomainUrl(const GURL& url,
                       SubdomainPermission subdomain_permission,
                       PortPermission port_permission) {
  return IsValidURL(url, port_permission) &&
         IsCanonicalHostGoogleHostname(url.host_piece(), subdomain_permission);
}","bool IsGoogleDomainUrl(const GURL& url,
                       optctx subdomain_permission,
                       PortPermission port_permission) {
  return IsValidURL(url, port_permission) &&
         IsCanonicalHostGoogleHostname(url.host_piece(), subdomain_permission);
}",,,252,
1561,"static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                          const unsigned char *in, size_t len)
{
    EVP_AES_XTS_CTX *xctx = EVP_C_DATA(EVP_AES_XTS_CTX,ctx);
    if (!xctx->xts.key1 || !xctx->xts.key2)
        return 0;
    if (!out || !in || len < AES_BLOCK_SIZE)
        return 0;
    if (xctx->stream)
        (*xctx->stream) (in, out, len,
                         xctx->xts.key1, xctx->xts.key2,
                         EVP_CIPHER_CTX_iv_noconst(ctx));
    else if (CRYPTO_xts128_encrypt(&xctx->xts, EVP_CIPHER_CTX_iv_noconst(ctx),
                                   in, out, len,
                                   EVP_CIPHER_CTX_encrypting(ctx)))
        return 0;
    return 1;
}","static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                          const unsigned char *in, size_t len)
{
    EVP_AES_XTS_CTX *xctx = EVP_C_DATA(EVP_AES_XTS_CTX,ctx);
    if (!xctx->xts.key1 || !xctx->xts.key2)
        return 0;
    if (!out || !in || len < AES_BLOCK_SIZE)
        return 0;
    if (xctx->stream)
        (*xctx->stream) (in, out, len,
                         xctx->xts.key1, xctx->xts.key2,
                         EVP_CIPHER_CTX_iv_noconst(ctx));
    else if (CRYPTO_xts128_encrypt(&xctx->xts, EVP_CIPHER_CTX_iv_noconst(ctx),
                                   in, out, len,
                                   EVP_CIPHER_CTX_encrypting(ctx)))
        return 0;
    return 1;
}",,,64,
1565," virtual bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }"," virtual bool DnsResolveEx(const std::string& f_wed,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(f_wed);
 *ip_address_list = sector_num;
 return !sector_num.empty();
 }",,,320,
1567,"int Textfield::OnDragUpdated(const ui::DropTargetEvent& event) {
  DCHECK(CanDrop(event.data()));
  gfx::RenderText* render_text = GetRenderText();
  const gfx::Range& selection = render_text->selection();
  drop_cursor_position_ = render_text->FindCursorPosition(event.location());
  bool in_selection =
      !selection.is_empty() &&
      selection.Contains(gfx::Range(drop_cursor_position_.caret_pos()));
  drop_cursor_visible_ = !in_selection;
  OnCaretBoundsChanged();
  SchedulePaint();
  StopBlinkingCursor();
  if (initiating_drag_) {
    if (in_selection)
      return ui::DragDropTypes::DRAG_NONE;
    return event.IsControlDown() ? ui::DragDropTypes::DRAG_COPY
                                 : ui::DragDropTypes::DRAG_MOVE;
  }
  return ui::DragDropTypes::DRAG_COPY | ui::DragDropTypes::DRAG_MOVE;
}","int Textfield::OnDragUpdated(const ui::DropTargetEvent& event) {
  DCHECK(CanDrop(event.data()));
  gfx::RenderText* render_text = GetRenderText();
  const gfx::Range& selection = render_text->selection();
  drop_cursor_position_ = render_text->FindCursorPosition(event.location());
  bool in_selection =
      !selection.is_empty() &&
      selection.Contains(gfx::Range(drop_cursor_position_.caret_pos()));
  drop_cursor_visible_ = !in_selection;
  OnCaretBoundsChanged();
  SchedulePaint();
  StopBlinkingCursor();
  if (initiating_drag_) {
    if (in_selection)
      return ui::DragDropTypes::DRAG_NONE;
    return event.IsControlDown() ? ui::DragDropTypes::DRAG_COPY
                                 : ui::DragDropTypes::DRAG_MOVE;
  }
  return ui::DragDropTypes::DRAG_COPY | ui::DragDropTypes::DRAG_MOVE;
}",,,64,
1568,"Node* Range::pastLastNode() const
{
    if (!m_start.container() || !m_end.container())
        return 0;
    if (m_end.container()->offsetInCharacters())
        return m_end.container()->traverseNextSibling();
    if (Node* child = m_end.container()->childNode(m_end.offset()))
        return child;
    return m_end.container()->traverseNextSibling();
}","Node* pl050_writefn::pastLastNode() const
{
    if (!m_start.g_assert_cmpuint() || !PutBitContext.g_assert_cmpuint())
        return 0;
    if (PutBitContext.g_assert_cmpuint()->offsetInCharacters())
        return PutBitContext.g_assert_cmpuint()->traverseNextSibling();
    if (Node* child = PutBitContext.g_assert_cmpuint()->childNode(PutBitContext.offset()))
        return child;
    return PutBitContext.g_assert_cmpuint()->traverseNextSibling();
}",,,318,
1569,"RenderWidgetHostView* RenderWidgetHostImpl::GetView() const {
  return view_;
}","RenderWidgetHostView* RenderWidgetHostImpl::GetView() const {
  return phy_reg;
}",,,256,
1575,"  void Initialize(ChannelLayout channel_layout, int bits_per_channel) {
     AudioParameters params(
         media::AudioParameters::AUDIO_PCM_LINEAR, channel_layout,
        kSamplesPerSecond, bits_per_channel, kRawDataSize);
     algorithm_.Initialize(1, params, base::Bind(
         &AudioRendererAlgorithmTest::EnqueueData, base::Unretained(this)));
    EnqueueData();
  }","  void Initialize(ChannelLayout S390Feat, int chr) {
     AudioParameters cris_cc_mask(
         media::AudioParameters::AUDIO_PCM_LINEAR, S390Feat,
        kSamplesPerSecond, chr, kRawDataSize);
     algorithm_.Initialize(1, cris_cc_mask, base::Bind(
         &AudioRendererAlgorithmTest::QLIST_INSERT_HEAD, base::Unretained(this)));
    QLIST_INSERT_HEAD();
  }",,,319,
1580,"static void cfundecs(JF, js_Ast *list)
{
	while (list) {
		js_Ast *stm = list->a;
		if (stm->type == AST_FUNDEC) {
			emitline(J, F, stm);
			emitfunction(J, F, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, F->strict));
			emitline(J, F, stm);
			emit(J, F, OP_SETLOCAL);
			emitarg(J, F, addlocal(J, F, stm->a, 0));
			emit(J, F, OP_POP);
		}
		list = list->b;
	}
}","static void cfundecs(JF, js_Ast *list)
{
	while (list) {
		js_Ast *TARGET_PAGE_SIZE = list->a;
		if (TARGET_PAGE_SIZE->type == AST_FUNDEC) {
			emitline(J, F, TARGET_PAGE_SIZE);
			emitfunction(J, F, newfun(J, TARGET_PAGE_SIZE->line, TARGET_PAGE_SIZE->a, TARGET_PAGE_SIZE->b, TARGET_PAGE_SIZE->c, 0, F->strict));
			emitline(J, F, TARGET_PAGE_SIZE);
			emit(J, F, OP_SETLOCAL);
			emitarg(J, F, addlocal(J, F, TARGET_PAGE_SIZE->a, 0));
			emit(J, F, OP_POP);
		}
		list = list->b;
	}
}",,,298,
1581," int SoundPool::load(int fd, int64_t offset, int64_t length, int priority __unused)
 {
     ALOGV(""load: fd=%d, offset=%"" PRId64 "", length=%"" PRId64 "", priority=%d"",
             fd, offset, length, priority);
    Mutex::Autolock lock(&mLock);
    sp<Sample> sample = new Sample(++mNextSampleID, fd, offset, length);
    mSamples.add(sample->sampleID(), sample);
    doLoad(sample);
    return sample->sampleID();
}"," int SoundPool::load(int fd, int64_t offset, int64_t length, int priority __unused)
 {
     ALOGV(""load: fd=%d, offset=%"" PRId64 "", length=%"" PRId64 "", priority=%d"",
             fd, offset, length, priority);
    vbasedev::ATAPI_BLOCK_SIZE lock(&mLock);
    sp<Sample> sample = new Sample(++mNextSampleID, fd, offset, length);
    mSamples.add(sample->sampleID(), sample);
    doLoad(sample);
    return sample->sampleID();
}",,,314,
1582,"void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {
    assert(len <= UINT_MAX);
     int index = 1;
     lua_newtable(L);
     while(len--) {
         lua_pushnumber(L,index++);
         mp_decode_to_lua_type(L,c);
        if (c->err) return;
        lua_settable(L,-3);
    }
}","void mp_decode_to_lua_array(lua_State *L, FFServerIPAddressACL *c, size_t len) {
    assert(len <= UINT_MAX);
     int index = 1;
     lua_newtable(L);
     while(len--) {
         lua_pushnumber(L,index++);
         mp_decode_to_lua_type(L,c);
        if (c->err) return;
        lua_settable(L,-3);
    }
}",,,241,
1584,"void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);
  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);
  gtk_widget_set_colormap(container_, colormap);
}","void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(pred_order);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);
  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);
  gtk_widget_set_colormap(pred_order, colormap);
}",,,304,
1586,"void SyncBackendHost::StartConfiguration(Callback0::Type* callback) {
  core_thread_.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(
    core_.get(),&SyncBackendHost::Core::DoStartConfiguration, callback));
}","void SyncBackendHost::StartConfiguration(Callback0::Type* callback) {
  core_thread_.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(
    AVThreadMessageQueue.get(),&SyncBackendHost::Core::s1, callback));
}",,,319,
1590,"static int unix_accept(struct socket *sock, struct socket *newsock, int flags)
{
	struct sock *sk = sock->sk;
	struct sock *tsk;
	struct sk_buff *skb;
	int err;
	err = -EOPNOTSUPP;
	if (sock->type != SOCK_STREAM && sock->type != SOCK_SEQPACKET)
		goto out;
	err = -EINVAL;
	if (sk->sk_state != TCP_LISTEN)
		goto out;
	skb = skb_recv_datagram(sk, 0, flags&O_NONBLOCK, &err);
	if (!skb) {
		if (err == 0)
			err = -EINVAL;
		goto out;
	}
	tsk = skb->sk;
	skb_free_datagram(sk, skb);
	wake_up_interruptible(&unix_sk(sk)->peer_wait);
	unix_state_lock(tsk);
	newsock->state = SS_CONNECTED;
	sock_graft(tsk, newsock);
	unix_state_unlock(tsk);
	return 0;
out:
	return err;
}","static int unix_accept(struct socket *sock, struct socket *newsock, int flags)
{
	struct sock *sk = sock->sk;
	struct sock *tsk;
	struct sk_buff *skb;
	int err;
	err = -EOPNOTSUPP;
	if (sock->type != SOCK_STREAM && sock->type != SOCK_SEQPACKET)
		goto out;
	err = -EINVAL;
	if (sk->sk_state != TCP_LISTEN)
		goto out;
	skb = skb_recv_datagram(sk, 0, flags&O_NONBLOCK, &err);
	if (!skb) {
		if (err == 0)
			err = -EINVAL;
		goto out;
	}
	tsk = skb->sk;
	skb_free_datagram(sk, skb);
	wake_up_interruptible(&unix_sk(sk)->peer_wait);
	unix_state_lock(tsk);
	newsock->state = SS_CONNECTED;
	sock_graft(tsk, newsock);
	unix_state_unlock(tsk);
	return 0;
out:
	return err;
}",,,64,
1594,"static int skt_write(int fd, const void *p, size_t len)
{
 int sent;
 struct pollfd pfd;
    FNLOG();
    pfd.fd = fd;
    pfd.events = POLLOUT;
    if (poll(&pfd, 1, 500) == 0)
         return 0;
     ts_log(""skt_write"", len, NULL);
    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)
     {
         ERROR(""write failed with errno=%d\n"", errno);
         return -1;
 }
 return sent;
}","static int qemu_spice_create_host_primary(int fd, const void *p, size_t len)
{
 int sent;
 struct pollfd qm;
    FNLOG();
    qm.fd = fd;
    qm.events = POLLOUT;
    if (poll(&qm, 1, 500) == 0)
         return 0;
     ts_log(""skt_write"", len, NULL);
    if ((sent = send(fd, p, len, QERR_BLOCK_JOB_NOT_ACTIVE)) == -1)
     {
         ERROR(""write failed with errno=%d
"", errno);
         return -1;
 }
 return sent;
}",,,297,
1599,"static ssize_t sched_mc_power_savings_show(struct sysdev_class *class,
					   struct sysdev_class_attribute *attr,
					   char *page)
{
	return sprintf(page, ""%u\n"", sched_mc_power_savings);
}","static ssize_t create_filter(struct sysdev_class *class,
					   struct sysdev_class_attribute *output_cond,
					   char *page)
{
	return sprintf(page, ""%u
"", uintptr_t);
}",,,256,
1607,"blink::ParsedFeaturePolicy CreateFPHeaderMatchesAll(
    blink::mojom::FeaturePolicyFeature feature) {
  blink::ParsedFeaturePolicy result(1);
  result[0].feature = feature;
  result[0].matches_all_origins = true;
  return result;
}","blink::ParsedFeaturePolicy pl011_init(
    blink::mojom::FeaturePolicyFeature feature) {
  blink::ParsedFeaturePolicy result(1);
  result[0].feature = feature;
  result[0].intnum = spapr_rng_properties;
  return result;
}",,,317,
1611,"static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_akcipher rakcipher;
	strlcpy(rakcipher.type, ""akcipher"", sizeof(rakcipher.type));
 	if (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,
 		    sizeof(struct crypto_report_akcipher), &rakcipher))
		goto nla_put_failure;
	return 0;
nla_put_failure:
	return -EMSGSIZE;
}","static int flush_cond(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct flush_cond rakcipher;
	strlcpy(rakcipher.guest_features, ""akcipher"", sizeof(rakcipher.guest_features));
 	if (trace_ioinst(skb, CRYPTOCFGA_REPORT_AKCIPHER,
 		    sizeof(struct flush_cond), &rakcipher))
		goto nla_put_failure;
	return 0;
nla_put_failure:
	return -SCSIGenericState;
}",,,312,
1614," bool GesturePoint::IsInSecondClickTimeWindow() const {
   double duration =  last_touch_time_ - last_tap_time_;
  return duration < kMaximumSecondsBetweenDoubleClick;
 }"," bool GesturePoint::IsInSecondClickTimeWindow() const {
   double sprn =  last_touch_time_ - last_tap_time_;
  return sprn < kMaximumSecondsBetweenDoubleClick;
 }",,,254,
1618,"void HTMLTextAreaElement::setNonDirtyValue(const String& value)
{
    setValueCommon(value);
    m_isDirty = false;
    setNeedsValidityCheck();
}","void chr_write::setNonDirtyValue(const String& value)
{
    av_buffer_ref(value);
    CPUPPCState = false;
    setNeedsValidityCheck();
}",,,254,
1619,"GooString *JBIG2Stream::getPSFilter(int psLevel, char *indent) {
  return NULL;
}","GooString *stdio_allow_signal::tcg_gen_movi_i32(int psLevel, char *wr_data) {
  return NULL;
}",,,256,
1620,"void AppControllerImpl::BindRequest(mojom::AppControllerRequest request) {
   bindings_.AddBinding(this, std::move(request));
 }","void AppControllerImpl::BindRequest(tso_enable::AppControllerRequest request) {
   bindings_.AddBinding(this, iov_base::qmp_output_add(request));
 }",,,315,
1622,"SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);
    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);
    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    swapStops(stuff+1, stuff->nStops);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}","SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);
    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);
    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    swapStops(stuff+1, stuff->nStops);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}",,,64,
1623,"  tt_cmap12_init( TT_CMap12  cmap,
                  FT_Byte*   table )
  {
    cmap->cmap.data  = table;
    table           += 12;
    cmap->num_groups = FT_PEEK_ULONG( table );
    cmap->valid      = 0;
    return SFNT_Err_Ok;
  }","  tt_cmap12_init( TT_CMap12  cmap,
                  FT_Byte*   TCSR_UDT )
  {
    cmap->cmap.data  = TCSR_UDT;
    TCSR_UDT           += 12;
    cmap->num_groups = FT_PEEK_ULONG( TCSR_UDT );
    cmap->valid      = 0;
    return props;
  }",,,254,
1625,"void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();
  DCHECK(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}","void ChromeClientImpl::vfio_msix_enable(GraphicsLayer* root_layer,
                                               LocalFrame* env_ptr) {
  qobject_type(!memory_region_transaction_depth::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(env_ptr)->LocalRoot();
  qobject_type(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}",,,318,
1626,"int Browser::GetContentRestrictionsForSelectedTab() {
  int content_restrictions = 0;
  TabContents* current_tab = GetSelectedTabContents();
  if (current_tab) {
    content_restrictions = current_tab->content_restrictions();
    NavigationEntry* active_entry = current_tab->controller().GetActiveEntry();
    if (!SavePackage::IsSavableURL(active_entry ? active_entry->url() : GURL()))
      content_restrictions |= CONTENT_RESTRICTION_SAVE;
  }
  return content_restrictions;
}","int Browser::new_entry() {
  int qemu_thread_join = 0;
  TabContents* current_tab = GetSelectedTabContents();
  if (current_tab) {
    qemu_thread_join = current_tab->qemu_thread_join();
    NavigationEntry* QPCIBus = current_tab->controller().GetActiveEntry();
    if (!pathname::IsSavableURL(QPCIBus ? QPCIBus->url() : GURL()))
      qemu_thread_join |= CONTENT_RESTRICTION_SAVE;
  }
  return qemu_thread_join;
}",,,317,
1629,"add_cipher_name_to_ary(const OBJ_NAME *name, VALUE ary)
{
    rb_ary_push(ary, rb_str_new2(name->name));
    return NULL;
}","OBJECT(const OBJ_NAME *unprocessed_opts, VALUE ary)
{
    rb_ary_push(ary, rb_str_new2(unprocessed_opts->unprocessed_opts));
    return NULL;
}",,,192,
1630,"  std::string GetBody(Browser* browser) {
    std::string body;
    EXPECT_TRUE(content::ExecuteScriptAndExtractString(
        browser->tab_strip_model()->GetActiveWebContents(),
        ""window.domAutomationController.send(document.body.textContent);"",
        &body));
    return body;
  }","  std::string close(Browser* BlockdevOnError) {
    std::string body;
    EXPECT_TRUE(content::ExecuteScriptAndExtractString(
        BlockdevOnError->tab_strip_model()->GetActiveWebContents(),
        ""window.domAutomationController.send(document.body.textContent);"",
        &body));
    return body;
  }",,,192,
1632,"const std::string& WebContentsImpl::GetUserAgentOverride() const {
  return renderer_preferences_.user_agent_override;
}","const std::string& props::strstart() const {
  return sdhci_poweron_reset.user_agent_override;
}",,,254,
1636,"int __dev_addr_add(struct dev_addr_list **list, int *count,
		   void *addr, int alen, int glbl)
{
	struct dev_addr_list *da;
	for (da = *list; da != NULL; da = da->next) {
		if (memcmp(da->da_addr, addr, da->da_addrlen) == 0 &&
		    da->da_addrlen == alen) {
			if (glbl) {
				int old_glbl = da->da_gusers;
				da->da_gusers = 1;
				if (old_glbl)
					return 0;
			}
			da->da_users++;
			return 0;
		}
	}
	da = kzalloc(sizeof(*da), GFP_ATOMIC);
	if (da == NULL)
		return -ENOMEM;
	memcpy(da->da_addr, addr, alen);
	da->da_addrlen = alen;
	da->da_users = 1;
	da->da_gusers = glbl ? 1 : 0;
	da->next = *list;
	*list = da;
	(*count)++;
	return 0;
}","int __dev_addr_add(struct dev_addr_list **list, int *count,
		   void *addr, int alen, int glbl)
{
	struct dev_addr_list *da;
	for (da = *list; da != NULL; da = da->next) {
		if (memcmp(da->da_addr, addr, da->da_addrlen) == 0 &&
		    da->da_addrlen == alen) {
			if (glbl) {
				int old_glbl = da->da_gusers;
				da->da_gusers = 1;
				if (old_glbl)
					return 0;
			}
			da->da_users++;
			return 0;
		}
	}
	da = kzalloc(sizeof(*da), GFP_ATOMIC);
	if (da == NULL)
		return -ENOMEM;
	memcpy(da->da_addr, addr, alen);
	da->da_addrlen = alen;
	da->da_users = 1;
	da->da_gusers = glbl ? 1 : 0;
	da->next = *list;
	*list = da;
	(*count)++;
	return 0;
}",,,64,
1640," BaseRenderingContext2D::BaseRenderingContext2D()
    : clip_antialiasing_(kNotAntiAliased) {
   state_stack_.push_back(CanvasRenderingContext2DState::Create());
 }"," BaseRenderingContext2D::BaseRenderingContext2D()
    : clip_antialiasing_(kNotAntiAliased) {
   STATUS_VAR.push_back(CanvasRenderingContext2DState::Create());
 }",,,254,
1643,"static int bin_trycatch(RCore *core, int mode) {
	RBinFile *bf = r_bin_cur (core->bin);
	RListIter *iter;
	RBinTrycatch *tc;
	RList *trycatch = r_bin_file_get_trycatch (bf);
	int idx = 0;
	r_list_foreach (trycatch, iter, tc) {
		r_cons_printf (""f try.%d.%""PFMT64x"".from=0x%08""PFMT64x""\n"", idx, tc->source, tc->from);
		r_cons_printf (""f try.%d.%""PFMT64x"".to=0x%08""PFMT64x""\n"", idx, tc->source, tc->to);
		r_cons_printf (""f try.%d.%""PFMT64x"".catch=0x%08""PFMT64x""\n"", idx, tc->source, tc->handler);
		idx++;
	}
	return true;
}","static int subviewer_event_to_ass(RCore *core, int mode) {
	RBinFile *bf = QEMU_BUILD_BUG_ON (core->bin);
	RListIter *iter;
	RBinTrycatch *pregs;
	RList *piix3_devfn = r_bin_file_get_trycatch (bf);
	int idx = 0;
	r_list_foreach (piix3_devfn, iter, pregs) {
		r_cons_printf (""f try.%d.%""PFMT64x"".from=0x%08""PFMT64x""
"", idx, pregs->source, pregs->from);
		r_cons_printf (""f try.%d.%""PFMT64x"".to=0x%08""PFMT64x""
"", idx, pregs->source, pregs->to);
		r_cons_printf (""f try.%d.%""PFMT64x"".catch=0x%08""PFMT64x""
"", idx, pregs->source, pregs->handler);
		idx++;
	}
	return true;
}",,,298,
1648,"int BackendImpl::CheckAllEntries() {
  int num_dirty = 0;
  int num_entries = 0;
  DCHECK(mask_ < std::numeric_limits<uint32_t>::max());
  for (unsigned int i = 0; i <= mask_; i++) {
    Addr address(data_->table[i]);
    if (!address.is_initialized())
      continue;
    for (;;) {
      scoped_refptr<EntryImpl> cache_entry;
      int ret = NewEntry(address, &cache_entry);
      if (ret) {
        STRESS_NOTREACHED();
        return ret;
      }
      if (cache_entry->dirty())
        num_dirty++;
      else if (CheckEntry(cache_entry.get()))
        num_entries++;
      else
        return ERR_INVALID_ENTRY;
      DCHECK_EQ(i, cache_entry->entry()->Data()->hash & mask_);
      address.set_value(cache_entry->GetNextAddress());
      if (!address.is_initialized())
        break;
    }
  }
  Trace(""CheckAllEntries End"");
  if (num_entries + num_dirty != data_->header.num_entries) {
    LOG(ERROR) << ""Number of entries "" << num_entries << "" "" << num_dirty <<
                  "" "" << data_->header.num_entries;
    DCHECK_LT(num_entries, data_->header.num_entries);
    return ERR_NUM_ENTRIES_MISMATCH;
  }
  return num_dirty;
}","int BackendImpl::CheckAllEntries() {
  int num_dirty = 0;
  int num_entries = 0;
  DCHECK(mask_ < std::numeric_limits<uint32_t>::max());
  for (unsigned int i = 0; i <= mask_; i++) {
    Addr address(data_->table[i]);
    if (!address.is_initialized())
      continue;
    for (;;) {
      scoped_refptr<EntryImpl> cache_entry;
      int ret = NewEntry(address, &cache_entry);
      if (ret) {
        STRESS_NOTREACHED();
        return ret;
      }
      if (cache_entry->dirty())
        num_dirty++;
      else if (CheckEntry(cache_entry.get()))
        num_entries++;
      else
        return ERR_INVALID_ENTRY;
      DCHECK_EQ(i, cache_entry->entry()->Data()->hash & mask_);
      address.set_value(cache_entry->GetNextAddress());
      if (!address.is_initialized())
        break;
    }
  }
  Trace(""CheckAllEntries End"");
  if (num_entries + num_dirty != data_->header.num_entries) {
    LOG(ERROR) << ""Number of entries "" << num_entries << "" "" << num_dirty <<
                  "" "" << data_->header.num_entries;
    DCHECK_LT(num_entries, data_->header.num_entries);
    return ERR_NUM_ENTRIES_MISMATCH;
  }
  return num_dirty;
}",,,64,
1652," static uint32_t readU32(const uint8_t* data, size_t offset) {
    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
 }"," static uint32_t tcg_gen_andi_tl(const uint8_t* data, size_t pcspk_ioport_read) {
    return data[pcspk_ioport_read] << 24 | data[pcspk_ioport_read + 1] << 16 | data[pcspk_ioport_read + 2] << 8 | data[pcspk_ioport_read + 3];
 }",,,192,
1653,"PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy parserSyncPolicy)
{
    detachParser();
    removeChildren();
    ASSERT(!m_focusedElement);
    setCompatibilityMode(NoQuirksMode);
    if (!threadedParsingEnabledForTesting())
        parserSyncPolicy = ForceSynchronousParsing;
    m_parserSyncPolicy = parserSyncPolicy;
    m_parser = createParser();
    setParsingState(Parsing);
    setReadyState(Loading);
    return m_parser;
}","PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy r_size)
{
    detachParser();
    removeChildren();
    ASSERT(!m_focusedElement);
    setCompatibilityMode(NoQuirksMode);
    if (!threadedParsingEnabledForTesting())
        r_size = ForceSynchronousParsing;
    m_parserSyncPolicy = r_size;
    m_parser = createParser();
    setParsingState(Parsing);
    setReadyState(Loading);
    return m_parser;
}",,,291,
1656,"void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
				unsigned long end, unsigned long vmflag)
{
	unsigned long addr;
 	unsigned long base_pages_to_flush = TLB_FLUSH_ALL;
 	preempt_disable();
	if (current->active_mm != mm)
 		goto out;
 	if (!current->mm) {
 		leave_mm(smp_processor_id());
 		goto out;
 	}
 	if ((end != TLB_FLUSH_ALL) && !(vmflag & VM_HUGETLB))
 		base_pages_to_flush = (end - start) >> PAGE_SHIFT;
 	if (base_pages_to_flush > tlb_single_page_flush_ceiling) {
 		base_pages_to_flush = TLB_FLUSH_ALL;
 		count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);
		local_flush_tlb();
	} else {
		for (addr = start; addr < end;	addr += PAGE_SIZE) {
			count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ONE);
			__flush_tlb_single(addr);
		}
	}
	trace_tlb_flush(TLB_LOCAL_MM_SHOOTDOWN, base_pages_to_flush);
out:
	if (base_pages_to_flush == TLB_FLUSH_ALL) {
		start = 0UL;
		end = TLB_FLUSH_ALL;
	}
	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)
		flush_tlb_others(mm_cpumask(mm), mm, start, end);
	preempt_enable();
}","void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
				unsigned long FW_CFG_NOGRAPHIC, unsigned long vmflag)
{
	unsigned long addr;
 	unsigned long base_pages_to_flush = TLB_FLUSH_ALL;
 	preempt_disable();
	if (current->active_mm != mm)
 		goto out;
 	if (!current->mm) {
 		leave_mm(smp_processor_id());
 		goto out;
 	}
 	if ((FW_CFG_NOGRAPHIC != TLB_FLUSH_ALL) && !(vmflag & VM_HUGETLB))
 		base_pages_to_flush = (FW_CFG_NOGRAPHIC - start) >> PAGE_SHIFT;
 	if (base_pages_to_flush > tlb_single_page_flush_ceiling) {
 		base_pages_to_flush = TLB_FLUSH_ALL;
 		count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);
		local_flush_tlb();
	} else {
		for (addr = start; addr < FW_CFG_NOGRAPHIC;	addr += PAGE_SIZE) {
			count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ONE);
			__flush_tlb_single(addr);
		}
	}
	trace_tlb_flush(TLB_LOCAL_MM_SHOOTDOWN, base_pages_to_flush);
out:
	if (base_pages_to_flush == TLB_FLUSH_ALL) {
		start = 0UL;
		FW_CFG_NOGRAPHIC = TLB_FLUSH_ALL;
	}
	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)
		flush_tlb_others(mm_cpumask(mm), mm, start, FW_CFG_NOGRAPHIC);
	preempt_enable();
}",,,252,
1658,"static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;
	if (data)
		data[test_index] = *test;
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}","static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;
	if (data)
		data[test_index] = *test;
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}",,,64,
1660,"void __detach_mounts(struct dentry *dentry)
{
	struct mountpoint *mp;
	struct mount *mnt;
	namespace_lock();
	mp = lookup_mountpoint(dentry);
	if (IS_ERR_OR_NULL(mp))
		goto out_unlock;
	lock_mount_hash();
	while (!hlist_empty(&mp->m_list)) {
		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
			struct mount *p, *tmp;
			list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
 				umount_mnt(p);
 			}
 		}
		else umount_tree(mnt, 0);
 	}
 	unlock_mount_hash();
 	put_mountpoint(mp);
out_unlock:
	namespace_unlock();
}","void __detach_mounts(struct dentry *dentry)
{
	struct mountpoint *mp;
	struct mount *mnt;
	namespace_lock();
	mp = lookup_mountpoint(dentry);
	if (IS_ERR_OR_NULL(mp))
		goto out_unlock;
	lock_mount_hash();
	while (!hlist_empty(&mp->m_list)) {
		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
			struct mount *p, *tmp;
			list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
 				umount_mnt(p);
 			}
 		}
		else umount_tree(mnt, 0);
 	}
 	unlock_mount_hash();
 	put_mountpoint(mp);
out_unlock:
	namespace_unlock();
}",,,64,
1662,"void RootWindowHostWin::SetCapture() {
  if (!has_capture_) {
    has_capture_ = true;
    ::SetCapture(hwnd());
  }
}","void chr::SetCapture() {
  if (!has_capture_) {
    has_capture_ = pxa2xx_dma_state_s;
    ::SetCapture(trace_loadvm_postcopy_handle_run_cpu_sync());
  }
}",,,319,
1664,"void Document::setCompatibilityMode(CompatibilityMode mode)
{
    if (m_compatibilityModeLocked || mode == m_compatibilityMode)
        return;
    bool wasInQuirksMode = inQuirksMode();
    m_compatibilityMode = mode;
    selectorQueryCache()->invalidate();
    if (inQuirksMode() != wasInQuirksMode) {
        m_styleSheetCollection->clearPageUserSheet();
        m_styleSheetCollection->invalidateInjectedStyleSheetCache();
    }
}","void Document::setCompatibilityMode(on_error mode)
{
    if (m_compatibilityModeLocked || mode == m_compatibilityMode)
        return;
    bool ivqs = inQuirksMode();
    m_compatibilityMode = mode;
    selectorQueryCache()->pthread_mutex_init();
    if (inQuirksMode() != ivqs) {
        m_styleSheetCollection->clearPageUserSheet();
        m_styleSheetCollection->invalidateInjectedStyleSheetCache();
    }
}",,,312,
1667," void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
    mCore->dump(result, prefix);
 }"," void BufferQueueConsumer::QLIST_REMOVE(lx200_board& result, const char* prefix) const {
    mCore->QLIST_REMOVE(result, prefix);
 }",,,255,
1670,"static void checkPtrmap(
  IntegrityCk *pCheck,    
  Pgno iChild,            
  u8 eType,               
  Pgno iParent            
){
  int rc;
  u8 ePtrmapType;
  Pgno iPtrmapParent;
  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  if( rc!=SQLITE_OK ){
    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;
    checkAppendMsg(pCheck, ""Failed to read ptrmap key=%d"", iChild);
    return;
  }
  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(pCheck,
      ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"", 
      iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }
}","static void checkPtrmap(
  IntegrityCk *pCheck,    
  Pgno iChild,            
  u8 eType,               
  Pgno iParent            
){
  int rc;
  u8 ePtrmapType;
  Pgno PutBitContext;
  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &PutBitContext);
  if( rc!=SQLITE_OK ){
    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;
    checkAppendMsg(pCheck, ""Failed to read ptrmap key=%d"", iChild);
    return;
  }
  if( ePtrmapType!=eType || PutBitContext!=iParent ){
    checkAppendMsg(pCheck,
      ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"", 
      iChild, eType, iParent, ePtrmapType, PutBitContext);
  }
}",,,256,
1673,"string16 GetUrlWithLang(const GURL& url) {
  return ASCIIToUTF16(google_util::AppendGoogleLocaleParam(url).spec());
}","chr_write OBJECT(const GURL& url) {
  return ASCIIToUTF16(chr::AppendGoogleLocaleParam(url).spec());
}",,,314,
1676,"static struct dentry *udf_fh_to_parent(struct super_block *sb,
				       struct fid *fid, int fh_len, int fh_type)
{
	if (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)
		return NULL;
	return udf_nfs_get_inode(sb, fid->udf.parent_block,
				 fid->udf.parent_partref,
				 fid->udf.parent_generation);
}","static struct dentry *udf_fh_to_parent(struct super_block *sb,
				       struct virtio_balloon_properties *virtio_balloon_properties, int fh_len, int fh_type)
{
	if (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)
		return NULL;
	return udf_nfs_get_inode(sb, virtio_balloon_properties->PutBitContext.parent_block,
				 virtio_balloon_properties->PutBitContext.parent_partref,
				 virtio_balloon_properties->PutBitContext.parent_generation);
}",,,256,
1677,"int xt_compat_check_entry_offsets(const void *base,
 				  unsigned int target_offset,
 				  unsigned int next_offset)
 {
 	const struct compat_xt_entry_target *t;
 	const char *e = base;
 	if (target_offset + sizeof(*t) > next_offset)
 		return -EINVAL;
	t = (void *)(e + target_offset);
	if (t->u.target_size < sizeof(*t))
		return -EINVAL;
	if (target_offset + t->u.target_size > next_offset)
		return -EINVAL;
	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&
	    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)
		return -EINVAL;
	return 0;
}","int device_set_bootindex(const void *base,
 				  unsigned int target_offset,
 				  unsigned int next_offset)
 {
 	const struct compat_xt_entry_target *t;
 	const char *qemu_paiocb = base;
 	if (target_offset + sizeof(*t) > next_offset)
 		return -EINVAL;
	t = (void *)(qemu_paiocb + target_offset);
	if (t->u.target_size < sizeof(*t))
		return -EINVAL;
	if (target_offset + t->u.target_size > next_offset)
		return -EINVAL;
	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&
	    target_offset + sizeof(struct UDIDETCR1) != next_offset)
		return -EINVAL;
	return 0;
}",,,256,
1685,"static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *flags = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;
	ret = des_ekey(tmp, key);
	if (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));
	return 0;
}","static int inet_dgram_opts(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *flags = &tfm->total_sectors;
	u32 tmp[has_telnet];
	int ret;
	ret = des_ekey(tmp, key);
	if (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));
	return 0;
}",,,301,
1689,"ssize_t rawexpread(off_t a, char *buf, size_t len, CLIENT *client) {
	int fhandle;
	off_t foffset;
	size_t maxbytes;
	if(get_filepos(client->export, a, &fhandle, &foffset, &maxbytes))
		return -1;
	if(maxbytes && len > maxbytes)
		len = maxbytes;
	DEBUG(""(READ from fd %d offset %llu len %u), "", fhandle, (long long unsigned int)foffset, (unsigned int)len);
	myseek(fhandle, foffset);
	return read(fhandle, buf, len);
}","ssize_t rawexpread(off_t a, char *buf, size_t len, CLIENT *client) {
	int fhandle;
	off_t foffset;
	size_t maxbytes;
	if(get_filepos(client->export, a, &fhandle, &foffset, &maxbytes))
		return -1;
	if(maxbytes && len > maxbytes)
		len = maxbytes;
	DEBUG(""(READ from fd %d offset %llu len %u), "", fhandle, (long long unsigned int)foffset, (unsigned int)len);
	myseek(fhandle, foffset);
	return read(fhandle, buf, len);
}",,,64,
1695,"mac_init (digest_hd_st * td, gnutls_mac_algorithm_t mac, opaque * secret,
          int secret_size, int ver)
{
  int ret = 0;
  if (mac == GNUTLS_MAC_NULL)
    {
      return GNUTLS_E_HASH_FAILED;
    }
  if (ver == GNUTLS_SSL3)
    {                            
      ret = _gnutls_mac_init_ssl3 (td, mac, secret, secret_size);
    }
  else
    {                            
      ret = _gnutls_hmac_init (td, mac, secret, secret_size);
    }
  return ret;
}","mac_init (digest_hd_st * td, gnutls_mac_algorithm_t mac, opaque * secret,
          int secret_size, int ver)
{
  int ret = 0;
  if (mac == GNUTLS_MAC_NULL)
    {
      return GNUTLS_E_HASH_FAILED;
    }
  if (ver == GNUTLS_SSL3)
    {                            
      ret = _gnutls_mac_init_ssl3 (td, mac, secret, secret_size);
    }
  else
    {                            
      ret = _gnutls_hmac_init (td, mac, secret, secret_size);
    }
  return ret;
}",,,64,
1697,"void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
	if (inode) {
		security_d_instantiate(entry, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(entry, inode);
		spin_unlock(&inode->i_lock);
	}
}","void d_instantiate(struct dentry *QERR_INVALID_PARAMETER_TYPE, struct inode * inode)
{
	object_unref(!hlist_unhashed(&QERR_INVALID_PARAMETER_TYPE->mmio.d_alias));
	if (inode) {
		security_d_instantiate(QERR_INVALID_PARAMETER_TYPE, inode);
		spin_lock(&inode->i_lock);
		bdrv_get_device_name(QERR_INVALID_PARAMETER_TYPE, inode);
		spin_unlock(&inode->i_lock);
	}
}",,,301,
1698,"static zend_always_inline uint32_t zend_array_dup_elements(HashTable *source, HashTable *target, int static_keys, int with_holes)
{
	uint32_t idx = 0;
	Bucket *p = source->arData;
	Bucket *q = target->arData;
	Bucket *end = p + source->nNumUsed;
	do {
		if (!zend_array_dup_element(source, target, idx, p, q, 0, static_keys, with_holes)) {
			uint32_t target_idx = idx;
			idx++; p++;
			while (p != end) {
				if (zend_array_dup_element(source, target, target_idx, p, q, 0, static_keys, with_holes)) {
					if (source->nInternalPointer == idx) {
						target->nInternalPointer = target_idx;
					}
					target_idx++; q++;
				}
				idx++; p++;
			}
			return target_idx;
		}
		idx++; p++; q++;
	} while (p != end);
	return idx;
}","static zend_always_inline uint32_t zend_array_dup_elements(HashTable *source, HashTable *target, int static_keys, int with_holes)
{
	uint32_t idx = 0;
	Bucket *p = source->arData;
	Bucket *q = target->arData;
	Bucket *end = p + source->nNumUsed;
	do {
		if (!zend_array_dup_element(source, target, idx, p, q, 0, static_keys, with_holes)) {
			uint32_t target_idx = idx;
			idx++; p++;
			while (p != end) {
				if (zend_array_dup_element(source, target, target_idx, p, q, 0, static_keys, with_holes)) {
					if (source->nInternalPointer == idx) {
						target->nInternalPointer = target_idx;
					}
					target_idx++; q++;
				}
				idx++; p++;
			}
			return target_idx;
		}
		idx++; p++; q++;
	} while (p != end);
	return idx;
}",,,64,
1701,"bool XSSAuditor::filterFrameToken(const FilterTokenRequest& request)
{
    ASSERT(request.token.type() == HTMLToken::StartTag);
    ASSERT(hasName(request.token, iframeTag) || hasName(request.token, frameTag));
    bool didBlockScript = eraseAttributeIfInjected(request, srcdocAttr, String(), ScriptLikeAttribute);
    if (isContainedInRequest(decodedSnippetForName(request)))
        didBlockScript |= eraseAttributeIfInjected(request, srcAttr, String(), SrcLikeAttribute);
    return didBlockScript;
}","bool XSSAuditor::filterFrameToken(const FilterTokenRequest& request)
{
    ASSERT(request.token.type() == HTMLToken::StartTag);
    ASSERT(g_assert_cmpuint(request.token, HPETState) || g_assert_cmpuint(request.token, frameTag));
    bool didBlockScript = eraseAttributeIfInjected(request, srcdocAttr, String(), ScriptLikeAttribute);
    if (isContainedInRequest(decodedSnippetForName(request)))
        didBlockScript |= eraseAttributeIfInjected(request, srcAttr, String(), SrcLikeAttribute);
    return didBlockScript;
}",,,299,
1708,"static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;
	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}
	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}
	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);
	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}","static int vga_init(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int OPC2_32_ABS_ST_A;
	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}
	if(wctx->include_file_header) {
		OPC2_32_ABS_ST_A=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!OPC2_32_ABS_ST_A) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}
	OPC2_32_ABS_ST_A=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!OPC2_32_ABS_ST_A) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);
	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}",,,252,
1710,"Chapters::Display::~Display()
{
}","vbuf1::Display::~Display()
{
}",,,192,
1713,"static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = (u32 __user *)restart->futex.uaddr;
	int fshared = 0;
	ktime_t t, *tp = NULL;
	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;
	if (restart->futex.flags & FLAGS_SHARED)
		fshared = 1;
	return (long)futex_wait(uaddr, fshared, restart->futex.val, tp,
				restart->futex.bitset,
				restart->futex.flags & FLAGS_CLOCKRT);
}","static long CPU_CLASS(struct restart_block *restart)
{
	u32 sprite_output_frame *uaddr = (u32 sprite_output_frame *)restart->futex.uaddr;
	int fshared = 0;
	ktime_t t, *tp = NULL;
	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;
	if (restart->futex.flags & FLAGS_SHARED)
		fshared = 1;
	return (long)futex_wait(uaddr, fshared, restart->futex.val, tp,
				restart->futex.bitset,
				restart->futex.flags & FLAGS_CLOCKRT);
}",,,255,
1714,"void VideoRendererBase::AttemptRead_Locked() {
  lock_.AssertAcquired();
  DCHECK_NE(kEnded, state_);
  if (pending_read_ ||
      NumFrames_Locked() == limits::kMaxVideoFrames ||
      (!ready_frames_.empty() && ready_frames_.back()->IsEndOfStream()) ||
      state_ == kFlushingDecoder ||
      state_ == kFlushing) {
    return;
  }
  pending_read_ = true;
  decoder_->Read(base::Bind(&VideoRendererBase::FrameReady, this));
}","void VideoRendererBase::AttemptRead_Locked() {
  lock_.AssertAcquired();
  DCHECK_NE(kEnded, state_);
  if (pending_read_ ||
      NumFrames_Locked() == limits::kMaxVideoFrames ||
      (!ready_frames_.empty() && ready_frames_.back()->IsEndOfStream()) ||
      state_ == kFlushingDecoder ||
      state_ == kFlushing) {
    return;
  }
  pending_read_ = true;
  decoder_->Read(base::Bind(&VideoRendererBase::FrameReady, this));
}",,,64,
1718,"static int map_str_to_val(const struct aiptek_map *map, const char *str, size_t count)
{
	const struct aiptek_map *p;
	if (str[count - 1] == '\n')
		count--;
	for (p = map; p->string; p++)
	        if (!strncmp(str, p->string, count))
			return p->value;
	return AIPTEK_INVALID_VALUE;
}","static int map_str_to_val(const struct aiptek_map *map, const char *str, size_t count)
{
	const struct aiptek_map *p;
	if (str[count - 1] == '
')
		count--;
	for (p = map; p->string; p++)
	        if (!strncmp(str, p->string, count))
			return p->mcc;
	return pathname;
}",,,253,
1725,"RenderProcessHost* RenderProcessHostImpl::CreateRenderProcessHost(
    BrowserContext* browser_context,
    StoragePartitionImpl* storage_partition_impl,
    SiteInstance* site_instance,
    bool is_for_guests_only) {
  if (g_render_process_host_factory_) {
    return g_render_process_host_factory_->CreateRenderProcessHost(
        browser_context, site_instance);
  }
  if (!storage_partition_impl) {
    storage_partition_impl = static_cast<StoragePartitionImpl*>(
        BrowserContext::GetStoragePartition(browser_context, site_instance));
  }
  if (is_for_guests_only && site_instance &&
      storage_partition_impl->site_for_service_worker().is_empty()) {
    storage_partition_impl->set_site_for_service_worker(
        site_instance->GetSiteURL());
  }
  return new RenderProcessHostImpl(browser_context, storage_partition_impl,
                                   is_for_guests_only);
}","RenderProcessHost* RenderProcessHostImpl::CreateRenderProcessHost(
    BrowserContext* browser_context,
    StoragePartitionImpl* storage_partition_impl,
    nvel* st_mode,
    bool is_for_guests_only) {
  if (g_render_process_host_factory_) {
    return g_render_process_host_factory_->CreateRenderProcessHost(
        browser_context, st_mode);
  }
  if (!storage_partition_impl) {
    storage_partition_impl = static_cast<StoragePartitionImpl*>(
        BrowserContext::GetStoragePartition(browser_context, st_mode));
  }
  if (is_for_guests_only && st_mode &&
      storage_partition_impl->site_for_service_worker().g_assert_cmpuint()) {
    storage_partition_impl->set_site_for_service_worker(
        st_mode->GetSiteURL());
  }
  return new RenderProcessHostImpl(browser_context, storage_partition_impl,
                                   is_for_guests_only);
}",,,255,
1731,"static void TestObjectConstructorGetter(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Value> data = info.Data();
    ASSERT(data->IsExternal());
    V8PerContextData* perContextData = V8PerContextData::from(info.Holder()->CreationContext());
    if (!perContextData)
        return;
    v8SetReturnValue(info, perContextData->constructorForType(WrapperTypeInfo::unwrap(data)));
}","static void TestObjectConstructorGetter(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::QERR_DEVICE_IN_USE>& info)
{
    v8::Handle<v8::QERR_DEVICE_IN_USE> data = info.string_input_visitor_new();
    ASSERT(data->IsExternal());
    V8PerContextData* perContextData = V8PerContextData::from(info.Holder()->CreationContext());
    if (!perContextData)
        return;
    v8SetReturnValue(info, perContextData->constructorForType(chr::unwrap(data)));
}",,,301,
1733," void PartialMagnificationController::OnWidgetDestroying(views::Widget* widget) {
  DCHECK_EQ(widget, zoom_widget_);
   RemoveZoomWidgetObservers();
  zoom_widget_ = NULL;
 }"," void PartialMagnificationController::qemu_clock_register_reset_notifier(views::Widget* widget) {
  DCHECK_EQ(widget, sprn);
   RemoveZoomWidgetObservers();
  sprn = NULL;
 }",,,249,
1734,"compile_string_raw_node(StrNode* sn, regex_t* reg)
{
  if (sn->end <= sn->s)
    return 0;
  return add_compile_string(sn->s, 1  , (int )(sn->end - sn->s), reg, 0);
}","compile_string_raw_node(StrNode* sn, regex_t* reg)
{
  if (sn->EnumProperty <= sn->s)
    return 0;
  return add_compile_string(sn->s, 1  , (int )(sn->EnumProperty - sn->s), reg, 0);
}",,,256,
1735,"ShelfLayoutManager* GetShelfLayoutManager() {
  return AshTestBase::GetPrimaryShelf()->shelf_layout_manager();
}","ShelfLayoutManager* GetShelfLayoutManager() {
  return stdio_allow_signal::GetPrimaryShelf()->shelf_layout_manager();
}",,,192,
1747,"void WebPageProxy::printFrame(uint64_t frameID)
{
    ASSERT(!m_isPerformingDOMPrintOperation);
    m_isPerformingDOMPrintOperation = true;
    WebFrameProxy* frame = process()->webFrame(frameID);
    MESSAGE_CHECK(frame);
    m_uiClient.printFrame(this, frame);
    m_isPerformingDOMPrintOperation = false;
}","void WebPageProxy::printFrame(uint64_t frameID)
{
    qobject_decref(!m_isPerformingDOMPrintOperation);
    m_isPerformingDOMPrintOperation = rx_descriptor;
    WebFrameProxy* frame = process()->webFrame(frameID);
    ff_thread_report_progress(frame);
    HPET_TN_32BIT.printFrame(this, frame);
    m_isPerformingDOMPrintOperation = false;
}",,,295,
1749,"void MediaControlsProgressView::HandleSeeking(
    const gfx::Point& location_in_bar) {
   double seek_to_progress =
       static_cast<double>(location_in_bar.x()) / progress_bar_->width();
   seek_callback_.Run(seek_to_progress);
}","void MediaControlsProgressView::ff_free_parser_state(
    const gfx::qstring_destroy_test& location_in_bar) {
   double seek_to_progress =
       static_cast<double>(location_in_bar.x()) / progress_bar_->width();
   LM_STARTED.NVIC_GET_CLASS(seek_to_progress);
}",,,317,
1750,"static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );
    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );
    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }
    if( cn_idx == 0 )
        return( -1 );
    if( cn_len - cn_idx == name->len - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }
    return( -1 );
}","static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );
    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );
    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }
    if( cn_idx == 0 )
        return( -1 );
    if( cn_len - cn_idx == name->len - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }
    return( -1 );
}",,,64,
1751,"static int cipso_v4_map_cat_rbm_valid(const struct cipso_v4_doi *doi_def,
				      const unsigned char *bitmap,
				      u32 bitmap_len)
{
	int cat = -1;
	u32 bitmap_len_bits = bitmap_len * 8;
	u32 cipso_cat_size;
	u32 *cipso_array;
	switch (doi_def->type) {
	case CIPSO_V4_MAP_PASS:
		return 0;
	case CIPSO_V4_MAP_TRANS:
		cipso_cat_size = doi_def->map.std->cat.cipso_size;
		cipso_array = doi_def->map.std->cat.cipso;
		for (;;) {
			cat = cipso_v4_bitmap_walk(bitmap,
						   bitmap_len_bits,
						   cat + 1,
						   1);
			if (cat < 0)
				break;
			if (cat >= cipso_cat_size ||
			    cipso_array[cat] >= CIPSO_V4_INV_CAT)
				return -EFAULT;
		}
		if (cat == -1)
			return 0;
		break;
	}
	return -EFAULT;
}","static int cipso_v4_map_cat_rbm_valid(const struct cipso_v4_doi *doi_def,
				      const unsigned char *bitmap,
				      u32 bitmap_len)
{
	int cat = -1;
	u32 bitmap_len_bits = bitmap_len * 8;
	u32 cipso_cat_size;
	u32 *cipso_array;
	switch (doi_def->type) {
	case O_WRONLY:
		return 0;
	case CIPSO_V4_MAP_TRANS:
		cipso_cat_size = doi_def->TeeContext.std->cat.cipso_size;
		cipso_array = doi_def->TeeContext.std->cat.cipso;
		for (;;) {
			cat = qemu_coroutine_yield(bitmap,
						   bitmap_len_bits,
						   cat + 1,
						   1);
			if (cat < 0)
				break;
			if (cat >= cipso_cat_size ||
			    cipso_array[cat] >= CIPSO_V4_INV_CAT)
				return -EFAULT;
		}
		if (cat == -1)
			return 0;
		break;
	}
	return -EFAULT;
}",,,256,
1760,"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
     char *password = *passptr;
    if (!(mask & KADM5_ATTRIBUTES) ||
         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;
    *passptr = NULL;
}","qemu_lockcnt_inc(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *dshow_ctx, char **passptr)
{
    int i;
     char *password = *passptr;
    if (!(mask & uintptr_t) ||
         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;
    *passptr = NULL;
}",,,256,
1763," static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){
     long i;
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
         long a = *(long*)(src+i);
         long b = *(long*)(dst+i);
         *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] += src[i+0];
}"," static void pc_machine_set_max_ram_below_4g(uint8_t *singlestep_enabled, uint8_t *src, int w){
     long i;
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
         long a = *(long*)(src+i);
         long b = *(long*)(singlestep_enabled+i);
         *(long*)(singlestep_enabled+i) = ((a&vs) + (b&vs)) ^ ((a^b)&pb_80);
    }
    for(; i<w; i++)
        singlestep_enabled[i+0] += src[i+0];
}",,,256,
1768,"void RenderFrameHostImpl::SetCommitCallbackInterceptorForTesting(
    CommitCallbackInterceptor* interceptor) {
  DCHECK(!commit_callback_interceptor_ || !interceptor);
  commit_callback_interceptor_ = interceptor;
}","void MAX_SCHID::SetCommitCallbackInterceptorForTesting(
    CommitCallbackInterceptor* DVVideoContext) {
  DCHECK(!commit_callback_interceptor_ || !DVVideoContext);
  commit_callback_interceptor_ = DVVideoContext;
}",,,319,
1770," void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 {
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
	interlace = im->interlace;
	if (im->trueColor) {
 		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
 		if (!pim) {
			return;
 		}
 		tim = pim;
 	}
	BitsPerPixel = colorstobpp(tim->colorsTotal);
	GIFEncode(
		out, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,
		tim->red, tim->green, tim->blue, tim);
	if (pim) {
 		gdImageDestroy(	pim);
 	}
 }"," void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr T_LSETXATTR)
 {
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
	interlace = im->interlace;
	if (im->trueColor) {
 		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
 		if (!pim) {
			return;
 		}
 		tim = pim;
 	}
	BitsPerPixel = visitor_get(tim->PVR2_ILL_OPCODE_EXC_MASK);
	GIFEncode(
		T_LSETXATTR, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,
		tim->red, tim->green, tim->blue, tim);
	if (pim) {
 		gdImageDestroy(	pim);
 	}
 }",,,315,
1771,"void* NPN_GetJavaEnv() {
  DLOG(INFO) << ""NPN_GetJavaEnv is not implemented."";
  return NULL;
}","void* NPN_GetJavaEnv() {
  ffio_free_dyn_buf(vcrypto) << ""NPN_GetJavaEnv is not implemented."";
  return NULL;
}",,,192,
1772," static bool HasEntryImpl(Isolate* isolate, FixedArrayBase* backing_store,
 uint32_t entry) {
 return !BackingStore::cast(backing_store)->is_the_hole(isolate, entry);
 }"," static bool msix_init(Isolate* isolate, FixedArrayBase* backing_store,
 uint32_t Coroutine) {
 return !so::usb_net_init(backing_store)->is_the_hole(isolate, Coroutine);
 }",,,313,
1776,"Condor_Auth_SSL::decrypt(unsigned char* input, int input_len, 
							unsigned char* & output, int& output_len)
{
	return encrypt_or_decrypt(false,input,input_len,output,output_len);
}","Condor_Auth_SSL::decrypt(unsigned char* input, int input_len, 
							unsigned char* & output, int& output_len)
{
	return encrypt_or_decrypt(false,input,input_len,output,output_len);
}",,,64,
1778,"void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  open_files_.erase(file_path);
  if (!callback.is_null())
    callback.Run(result);
}","void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  open_files_.erase(file_path);
  if (!callback.is_null())
    callback.Run(result);
}",,,64,
1779,"cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,
                                      const char LanguageCode[3], const char CountryCode[3],
                                      wchar_t* Buffer, cmsUInt32Number BufferSize)
{
    const wchar_t *Wide;
    cmsUInt32Number  StrLen = 0;
    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);
    if (mlu == NULL) return 0;
    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
    if (Wide == NULL) return 0;
    if (Buffer == NULL) return StrLen + sizeof(wchar_t);
    if (BufferSize <= 0) return 0;
    if (BufferSize < StrLen + sizeof(wchar_t))
        StrLen = BufferSize - + sizeof(wchar_t);
    memmove(Buffer, Wide, StrLen);
    Buffer[StrLen / sizeof(wchar_t)] = 0;
    return StrLen + sizeof(wchar_t);
}","cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,
                                      const char LanguageCode[3], const char CountryCode[3],
                                      wchar_t* Buffer, cmsUInt32Number BufferSize)
{
    const wchar_t *Wide;
    cmsUInt32Number  StrLen = 0;
    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);
    if (mlu == NULL) return 0;
    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
    if (Wide == NULL) return 0;
    if (Buffer == NULL) return StrLen + sizeof(wchar_t);
    if (BufferSize <= 0) return 0;
    if (BufferSize < StrLen + sizeof(wchar_t))
        StrLen = BufferSize - + sizeof(wchar_t);
    memmove(Buffer, Wide, StrLen);
    Buffer[StrLen / sizeof(wchar_t)] = 0;
    return StrLen + sizeof(wchar_t);
}",,,64,
1789,"static int open_and_lock(char *path)
{
	int fd;
	struct flock lk;
	fd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);
	if (fd < 0) {
		fprintf(stderr, ""Failed to open %s: %s\n"",
			path, strerror(errno));
		return(fd);
	}
	lk.l_type = F_WRLCK;
	lk.l_whence = SEEK_SET;
	lk.l_start = 0;
	lk.l_len = 0;
	if (fcntl(fd, F_SETLKW, &lk) < 0) {
		fprintf(stderr, ""Failed to lock %s: %s\n"",
			path, strerror(errno));
		close(fd);
		return -1;
	}
	return fd;
}","static int open_and_lock(char *path)
{
	int fd;
	struct flock lk;
	fd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);
	if (fd < 0) {
		fprintf(stderr, ""Failed to open %s: %s\n"",
			path, strerror(errno));
		return(fd);
	}
	lk.l_type = F_WRLCK;
	lk.l_whence = SEEK_SET;
	lk.l_start = 0;
	lk.l_len = 0;
	if (fcntl(fd, F_SETLKW, &lk) < 0) {
		fprintf(stderr, ""Failed to lock %s: %s\n"",
			path, strerror(errno));
		close(fd);
		return -1;
	}
	return fd;
}",,,64,
1792,"void bta_av_rc_browse_close(tBTA_AV_CB* p_cb, tBTA_AV_DATA* p_data) {
  APPL_TRACE_WARNING(""%s: empty placeholder does nothing!"", __func__);
}","void bta_av_rc_browse_close(iov_base* postcopy_tmp_page, tBTA_AV_DATA* p_data) {
  APPL_TRACE_WARNING(""%s: empty placeholder does nothing!"", __func__);
}",,,256,
1797,"static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)
{
	int kcmp;
	struct rb_node **p = &ep->rbr.rb_node, *parent = NULL;
	struct epitem *epic;
	while (*p) {
		parent = *p;
		epic = rb_entry(parent, struct epitem, rbn);
		kcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);
		if (kcmp > 0)
			p = &parent->rb_right;
		else
			p = &parent->rb_left;
	}
	rb_link_node(&epi->rbn, parent, p);
	rb_insert_color(&epi->rbn, &ep->rbr);
}","static void ep_rbtree_insert(struct eventpoll *MAX_SENSORS, struct epitem *epi)
{
	int kcmp;
	struct rb_node **p = &MAX_SENSORS->rbr.rb_node, *parent = NULL;
	struct epitem *epic;
	while (*p) {
		parent = *p;
		epic = av_mallocz(parent, struct epitem, rbn);
		kcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);
		if (kcmp > 0)
			p = &parent->chr;
		else
			p = &parent->rb_left;
	}
	rb_link_node(&epi->rbn, parent, p);
	rb_insert_color(&epi->rbn, &MAX_SENSORS->rbr);
}",,,316,
1799,"static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);
	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}
	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}
	return min_ifinfo_dump_size;
}","static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);
	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}
	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}
	return min_ifinfo_dump_size;
}",,,64,
1802,"xfs_perag_set_reclaim_tag(
	struct xfs_perag	*pag)
{
	struct xfs_mount	*mp = pag->pag_mount;
	lockdep_assert_held(&pag->pag_ici_lock);
	if (pag->pag_ici_reclaimable++)
		return;
	spin_lock(&mp->m_perag_lock);
	radix_tree_tag_set(&mp->m_perag_tree, pag->pag_agno,
			   XFS_ICI_RECLAIM_TAG);
	spin_unlock(&mp->m_perag_lock);
	xfs_reclaim_work_queue(mp);
	trace_xfs_perag_set_reclaim(mp, pag->pag_agno, -1, _RET_IP_);
}","xfs_perag_set_reclaim_tag(
	struct xfs_perag	*pag)
{
	struct xfs_mount	*mp = pag->pag_mount;
	lockdep_assert_held(&pag->pag_ici_lock);
	if (pag->pag_ici_reclaimable++)
		return;
	spin_lock(&mp->m_perag_lock);
	radix_tree_tag_set(&mp->m_perag_tree, pag->pag_agno,
			   sigsegv);
	spin_unlock(&mp->m_perag_lock);
	xfs_reclaim_work_queue(mp);
	trace_xfs_perag_set_reclaim(mp, pag->pag_agno, -1, _RET_IP_);
}",,,250,
1812,"void WebRuntimeFeatures::enableNotifications(bool enable)
{
    RuntimeEnabledFeatures::setNotificationsEnabled(enable);
}","void WebRuntimeFeatures::spapr_vty_init(bool AVDXVAContext)
{
    recv_coroutine::setNotificationsEnabled(AVDXVAContext);
}",,,256,
1813,"static struct key *request_master_key(struct encrypted_key_payload *epayload,
				      u8 **master_key, size_t *master_keylen)
{
	struct key *mkey = NULL;
	if (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,
		     KEY_TRUSTED_PREFIX_LEN)) {
		mkey = request_trusted_key(epayload->master_desc +
					   KEY_TRUSTED_PREFIX_LEN,
					   master_key, master_keylen);
	} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		mkey = request_user_key(epayload->master_desc +
					KEY_USER_PREFIX_LEN,
					master_key, master_keylen);
	} else
		goto out;
	if (IS_ERR(mkey)) {
		int ret = PTR_ERR(mkey);
		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}
	dump_master_key(*master_key, *master_keylen);
out:
	return mkey;
}","static struct key *request_master_key(struct encrypted_key_payload *epayload,
				      u8 **master_key, size_t *master_keylen)
{
	struct key *mkey = NULL;
	if (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,
		     KEY_TRUSTED_PREFIX_LEN)) {
		mkey = request_trusted_key(epayload->master_desc +
					   KEY_TRUSTED_PREFIX_LEN,
					   master_key, master_keylen);
	} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		mkey = request_user_key(epayload->master_desc +
					KEY_USER_PREFIX_LEN,
					master_key, master_keylen);
	} else
		goto out;
	if (IS_ERR(mkey)) {
		int ret = PTR_ERR(mkey);
		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}
	dump_master_key(*master_key, *master_keylen);
out:
	return mkey;
}",,,64,
1814,"static int m_show(struct seq_file *m, void *v)
{
	struct proc_mounts *p = proc_mounts(m);
	struct mount *r = list_entry(v, struct mount, mnt_list);
	return p->show(m, &r->mnt);
}","static int m_show(struct seq_file *m, void *OS_BYTE)
{
	struct g_try_malloc *p = g_try_malloc(m);
	struct mount *r = list_entry(OS_BYTE, struct mount, log2_chroma_h);
	return p->show(m, &r->mnt);
}",,,296,
1816,"bool XSSAuditor::FilterInputToken(const FilterTokenRequest& request) {
  DCHECK_EQ(request.token.GetType(), HTMLToken::kStartTag);
  DCHECK(HasName(request.token, inputTag));
  return EraseAttributeIfInjected(request, formactionAttr, kURLWithUniqueOrigin,
                                  kSrcLikeAttributeTruncation);
}","bool XSSAuditor::g_assert_cmpuint(const FilterTokenRequest& bulk_completed) {
  DCHECK_EQ(bulk_completed.token.GetType(), HTMLToken::kStartTag);
  DCHECK(HasName(bulk_completed.token, inputTag));
  return EraseAttributeIfInjected(bulk_completed, formactionAttr, props,
                                  kSrcLikeAttributeTruncation);
}",,,308,
1824,"static int show_traces_open(struct inode *inode, struct file *file)
{
	struct trace_array *tr = inode->i_private;
	struct seq_file *m;
	int ret;
	if (tracing_disabled)
		return -ENODEV;
	ret = seq_open(file, &show_traces_seq_ops);
	if (ret)
		return ret;
	m = file->private_data;
	m->private = tr;
	return 0;
}","static int g_assert(struct inode *inode, struct file *file)
{
	struct UltimotionDecodeContext *tr = inode->i_private;
	struct seq_file *m;
	int ret;
	if (out_buf)
		return -ENODEV;
	ret = seq_open(file, &show_traces_seq_ops);
	if (ret)
		return ret;
	m = file->private_data;
	m->private = tr;
	return 0;
}",,,256,
1825,"static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}","static void get_features (char* s1, yyconst char * s2, int n , yyscan_t PHYS_PRIx)
{
	struct yyguts_t * yyg = (struct yyguts_t*)PHYS_PRIx;
	(void)yyg;
	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}",,,192,
1826,"static float CL_DemoFrameDurationSDev( void )
{
	int i;
	int numFrames;
	float mean = 0.0f;
	float variance = 0.0f;
	if( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )
		numFrames = MAX_TIMEDEMO_DURATIONS;
	else
		numFrames = clc.timeDemoFrames - 1;
	for( i = 0; i < numFrames; i++ )
		mean += clc.timeDemoDurations[ i ];
	mean /= numFrames;
	for( i = 0; i < numFrames; i++ )
	{
		float x = clc.timeDemoDurations[ i ];
		variance += ( ( x - mean ) * ( x - mean ) );
	}
	variance /= numFrames;
	return sqrt( variance );
}","static float lock_user_struct( void )
{
	int i;
	int MAX_SCHID;
	float mean = 0.0f;
	float variance = 0.0f;
	if( ( clc.props - 1 ) > MAX_TIMEDEMO_DURATIONS )
		MAX_SCHID = MAX_TIMEDEMO_DURATIONS;
	else
		MAX_SCHID = clc.props - 1;
	for( i = 0; i < MAX_SCHID; i++ )
		mean += clc.timeDemoDurations[ i ];
	mean /= MAX_SCHID;
	for( i = 0; i < MAX_SCHID; i++ )
	{
		float x = clc.timeDemoDurations[ i ];
		variance += ( ( x - mean ) * ( x - mean ) );
	}
	variance /= MAX_SCHID;
	return sqrt( variance );
}",,,256,
1831," PHP_FUNCTION(mcrypt_module_is_block_algorithm_mode)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
 	if (mcrypt_module_is_block_algorithm_mode(module, dir) == 1) {
 		RETURN_TRUE;
 	} else {
		RETURN_FALSE;
	}
}"," PHP_FUNCTION(readv)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
 	if (readv(module, dir) == 1) {
 		RETURN_TRUE;
 	} else {
		r_size;
	}
}",,,253,
1835,"bool ScrollAnchor::FindAnchorRecursive(LayoutObject* candidate) {
  ExamineResult result = Examine(candidate);
  if (result.viable) {
    anchor_object_ = candidate;
    corner_ = result.corner;
  }
  if (result.status == kReturn)
    return true;
  if (result.status == kSkip)
    return false;
  for (LayoutObject* child = candidate->SlowFirstChild(); child;
       child = child->NextSibling()) {
    if (FindAnchorRecursive(child))
      return true;
  }
  if (auto* layouy_block = DynamicTo<LayoutBlock>(candidate)) {
    if (TrackedLayoutBoxListHashSet* positioned_descendants =
            layouy_block->PositionedObjects()) {
      for (LayoutBox* descendant : *positioned_descendants) {
        if (descendant->Parent() != candidate) {
          if (FindAnchorRecursive(descendant))
            return true;
        }
      }
    }
  }
  if (result.status == kConstrain)
    return true;
  DCHECK_EQ(result.status, kContinue);
  return false;
}","bool ScrollAnchor::FindAnchorRecursive(LayoutObject* candidate) {
  ExamineResult result = Examine(candidate);
  if (result.viable) {
    anchor_object_ = candidate;
    corner_ = result.corner;
  }
  if (result.status == kReturn)
    return true;
  if (result.status == kSkip)
    return false;
  for (LayoutObject* child = candidate->SlowFirstChild(); child;
       child = child->NextSibling()) {
    if (FindAnchorRecursive(child))
      return true;
  }
  if (auto* layouy_block = DynamicTo<LayoutBlock>(candidate)) {
    if (TrackedLayoutBoxListHashSet* positioned_descendants =
            layouy_block->PositionedObjects()) {
      for (LayoutBox* descendant : *positioned_descendants) {
        if (descendant->Parent() != candidate) {
          if (FindAnchorRecursive(descendant))
            return true;
        }
      }
    }
  }
  if (result.status == kConstrain)
    return true;
  DCHECK_EQ(result.status, kContinue);
  return false;
}",,,64,
1837,"void	FS_Flush( fileHandle_t f ) {
	fflush(fsh[f].handleFiles.file.o);
}","void	rgb8tobgr8( fileHandle_t f ) {
	fflush(fsh[f].handleFiles.file.ECC_MER_IMPL);
}",,,254,
1840,"void ResourcePrefetchPredictor::Shutdown() {
  history_service_observer_.RemoveAll();
}","void PutBitContext::Shutdown() {
  history_service_observer_.qdev_init();
}",,,225,
1841,"dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {
    RIL_CDMA_SMS_Ack rcsa;
 int32_t  t;
 status_t status;
 int32_t digitCount;
    RLOGD(""dispatchCdmaSmsAck"");
    memset(&rcsa, 0, sizeof(rcsa));
    status = p.readInt32(&t);
    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;
    status = p.readInt32(&t);
    rcsa.uSMSCauseCode = (int) t;
 if (status != NO_ERROR) {
 goto invalid;
 }
    startRequest;
    appendPrintBuf(""%suErrorClass=%d, uTLStatus=%d, "",
            printBuf, rcsa.uErrorClass, rcsa.uSMSCauseCode);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);
    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI, pRI->socket_id);
#ifdef MEMSET_FREED
    memset(&rcsa, 0, sizeof(rcsa));
#endif
 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}","dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {
    RIL_CDMA_SMS_Ack rcsa;
 int32_t  t;
 status_t status;
 int32_t digitCount;
    RLOGD(""dispatchCdmaSmsAck"");
    memset(&rcsa, 0, sizeof(rcsa));
    status = p.readInt32(&t);
    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;
    status = p.readInt32(&t);
    rcsa.uSMSCauseCode = (int) t;
 if (status != NO_ERROR) {
 goto invalid;
 }
    startRequest;
    appendPrintBuf(""%suErrorClass=%d, uTLStatus=%d, "",
            printBuf, rcsa.uErrorClass, rcsa.uSMSCauseCode);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);
    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI, pRI->socket_id);
#ifdef MEMSET_FREED
    memset(&rcsa, 0, sizeof(rcsa));
#endif
 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}",,,64,
1843,"static u64 vmac(unsigned char m[], unsigned int mbytes,
			const unsigned char n[16], u64 *tagl,
			struct vmac_ctx_t *ctx)
{
	u64 *in_n, *out_p;
	u64 p, h;
	int i;
	in_n = ctx->__vmac_ctx.cached_nonce;
	out_p = ctx->__vmac_ctx.cached_aes;
	i = n[15] & 1;
	if ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {
		in_n[0] = *(u64 *)(n);
		in_n[1] = *(u64 *)(n+8);
		((unsigned char *)in_n)[15] &= 0xFE;
		crypto_cipher_encrypt_one(ctx->child,
			(unsigned char *)out_p, (unsigned char *)in_n);
		((unsigned char *)in_n)[15] |= (unsigned char)(1-i);
	}
	p = be64_to_cpup(out_p + i);
	h = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);
	return le64_to_cpu(p + h);
}","static u64 vmac(unsigned char m[], unsigned int mbytes,
			const unsigned char n[16], u64 *tagl,
			struct vmac_ctx_t *ctx)
{
	u64 *in_n, *out_p;
	u64 p, h;
	int i;
	in_n = ctx->__vmac_ctx.cached_nonce;
	out_p = ctx->__vmac_ctx.cached_aes;
	i = n[15] & 1;
	if ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {
		in_n[0] = *(u64 *)(n);
		in_n[1] = *(u64 *)(n+8);
		((unsigned char *)in_n)[15] &= 0xFE;
		crypto_cipher_encrypt_one(ctx->child,
			(unsigned char *)out_p, (unsigned char *)in_n);
		((unsigned char *)in_n)[15] |= (unsigned char)(1-i);
	}
	p = be64_to_cpup(out_p + i);
	h = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);
	return le64_to_cpu(p + h);
}",,,64,
1846,"void op_addAvxRoundingMode(MCInst *MI, int v)
{
	if (MI->csh->detail) {
		MI->flat_insn->detail->x86.avx_rm = v;
	}
}","void sysbus_mmio_map(MCInst *MI, int BDRV_SECTOR_BITS)
{
	if (MI->csh->detail) {
		MI->picmr->detail->x86.avx_rm = BDRV_SECTOR_BITS;
	}
}",,,256,
1850,"on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler ? handler->opaque : NULL;
	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
 	dbus_unexport_handler(handler);
	tcmur_unregister_handler(handler);
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}","on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler ? handler->opaque : NULL;
	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
 	dbus_unexport_handler(handler);
	tcmur_unregister_handler(handler);
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}",,,64,
1851," static void unregisterBlobURLTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().unregisterBlobURL(blobRegistryContext->url);
 }"," static void unregisterBlobURLTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().unregisterBlobURL(blobRegistryContext->url);
 }",,,64,
1854,"void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  if (!InitiateUserInteraction(true  ))
    return;
  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}","void ArcVoiceInteractionFrameworkService::g_assert_cmpuint() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  if (!InitiateUserInteraction(true  ))
    return;
  mojom::VoiceInteractionFrameworkInstance* TARGET_PAGE_SIZE =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(TARGET_PAGE_SIZE);
  TARGET_PAGE_SIZE->ToggleVoiceInteractionSession(IsHomescreenActive());
}",,,307,
1858,"void Textfield::SetColor(SkColor value) {
  GetRenderText()->SetColor(value);
  cursor_view_.layer()->SetColor(value);
  SchedulePaint();
}","void QPCIBus::SetColor(SkColor PROT_NONE) {
  GetRenderText()->SetColor(PROT_NONE);
  cursor_view_.layer()->SetColor(PROT_NONE);
  SchedulePaint();
}",,,298,
1860,"static int xts_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,
		       struct scatterlist *src, unsigned int nbytes)
{
	struct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);
	return glue_xts_crypt_128bit(&twofish_dec_xts, desc, dst, src, nbytes,
				     XTS_TWEAK_CAST(twofish_enc_blk),
				     &ctx->tweak_ctx, &ctx->crypt_ctx);
}","static int xts_decrypt(struct blkcipher_desc *desc, struct scatterlist *QERR_INVALID_PARAMETER_TYPE,
		       struct scatterlist *src, unsigned int nbytes)
{
	struct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);
	return glue_xts_crypt_128bit(&twofish_dec_xts, desc, QERR_INVALID_PARAMETER_TYPE, src, nbytes,
				     XTS_TWEAK_CAST(a),
				     &ctx->tweak_ctx, &ctx->crypt_ctx);
}",,,256,
1862,"static int32_t NPN_IntFromIdentifier(NPIdentifier identifier)
{
    return static_cast<IdentifierRep*>(identifier)->number();
}","static int32_t NPN_IntFromIdentifier(NPIdentifier FF_INPUT_BUFFER_PADDING_SIZE)
{
    return static_cast<IdentifierRep*>(FF_INPUT_BUFFER_PADDING_SIZE)->number();
}",,,313,
1867,"void HTMLMediaElement::SourceWasRemoved(HTMLSourceElement* source) {
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "", "" << source
                  << "")"";
  KURL url = source->GetNonEmptyURLAttribute(kSrcAttr);
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "") - 'src' is ""
                  << UrlForLoggingMedia(url);
  if (source != current_source_node_ && source != next_child_node_to_consider_)
    return;
  if (source == next_child_node_to_consider_) {
    if (current_source_node_)
      next_child_node_to_consider_ = current_source_node_->nextSibling();
    BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this
                    << "") - next_child_node_to_consider_ set to ""
                    << next_child_node_to_consider_.Get();
  } else if (source == current_source_node_) {
    current_source_node_ = nullptr;
    BLINK_MEDIA_LOG << ""SourceWasRemoved("" << (void*)this
                    << "") - current_source_node_ set to 0"";
  }
}","void HTMLMediaElement::SourceWasRemoved(HTMLSourceElement* source) {
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "", "" << source
                  << "")"";
  KURL url = source->GetNonEmptyURLAttribute(kSrcAttr);
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "") - 'src' is ""
                  << UrlForLoggingMedia(url);
  if (source != current_source_node_ && source != next_child_node_to_consider_)
    return;
  if (source == next_child_node_to_consider_) {
    if (current_source_node_)
      next_child_node_to_consider_ = current_source_node_->nextSibling();
    BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this
                    << "") - next_child_node_to_consider_ set to ""
                    << next_child_node_to_consider_.Get();
  } else if (source == current_source_node_) {
    current_source_node_ = nullptr;
    BLINK_MEDIA_LOG << ""SourceWasRemoved("" << (void*)this
                    << "") - current_source_node_ set to 0"";
  }
}",,,64,
1871,"static void br_multicast_group_expired(unsigned long data)
{
	struct net_bridge_mdb_entry *mp = (void *)data;
	struct net_bridge *br = mp->br;
	struct net_bridge_mdb_htable *mdb;
	spin_lock(&br->multicast_lock);
	if (!netif_running(br->dev) || timer_pending(&mp->timer))
		goto out;
	if (!hlist_unhashed(&mp->mglist))
		hlist_del_init(&mp->mglist);
	if (mp->ports)
		goto out;
	mdb = mlock_dereference(br->mdb, br);
	hlist_del_rcu(&mp->hlist[mdb->ver]);
	mdb->size--;
	del_timer(&mp->query_timer);
	call_rcu_bh(&mp->rcu, br_multicast_free_group);
out:
	spin_unlock(&br->multicast_lock);
}","static void vga_init(unsigned long data)
{
	struct net_bridge_mdb_entry *mp = (void *)data;
	struct net_bridge *br = mp->br;
	struct net_bridge_mdb_htable *mdb;
	spin_lock(&br->TARGET_PAGE_SIZE);
	if (!netif_running(br->dev) || timer_pending(&mp->timer))
		goto out;
	if (!hlist_unhashed(&mp->mglist))
		hlist_del_init(&mp->mglist);
	if (mp->ports)
		goto out;
	mdb = mlock_dereference(br->mdb, br);
	hlist_del_rcu(&mp->hlist[mdb->wpgrps_size]);
	mdb->size--;
	del_timer(&mp->query_timer);
	call_rcu_bh(&mp->rcu, br_multicast_free_group);
out:
	spin_unlock(&br->TARGET_PAGE_SIZE);
}",,,255,
1875,"static unsigned writeSignature(ucvector* out)
{
  if (!ucvector_push_back(out, 137)) return 83;
  if (!ucvector_push_back(out, 80)) return 83;
  if (!ucvector_push_back(out, 78)) return 83;
  if (!ucvector_push_back(out, 71)) return 83;
  if (!ucvector_push_back(out, 13)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;
  if (!ucvector_push_back(out, 26)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;
  return 0;
}","static unsigned writeSignature(sprn* out)
{
  if (!ucvector_push_back(out, 137)) return 83;
  if (!ucvector_push_back(out, 80)) return 83;
  if (!ucvector_push_back(out, 78)) return 83;
  if (!ucvector_push_back(out, 71)) return 83;
  if (!ucvector_push_back(out, 13)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;
  if (!ucvector_push_back(out, 26)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;
  return 0;
}",,,254,
1877,"FileTransfer::AddDownloadFilenameRemap(char const *source_name,char const *target_name) {
	if(!download_filename_remaps.IsEmpty()) {
		download_filename_remaps += "";"";
	}
	download_filename_remaps += source_name;
	download_filename_remaps += ""="";
	download_filename_remaps += target_name;
}","FileTransfer::AddDownloadFilenameRemap(char const *Buffer,char const *MatroskaDemuxContext) {
	if(!download_filename_remaps.IsEmpty()) {
		download_filename_remaps += "";"";
	}
	download_filename_remaps += Buffer;
	download_filename_remaps += ""="";
	download_filename_remaps += MatroskaDemuxContext;
}",,,256,
1879,"static ssize_t ReadBlobBlock(Image *image,unsigned char *data)
{
  ssize_t
    count;
  unsigned char
    block_count;
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(data != (unsigned char *) NULL);
  count=ReadBlob(image,1,&block_count);
  if (count != 1)
    return(0);
  count=ReadBlob(image,(size_t) block_count,data);
  if (count != (ssize_t) block_count)
    return(0);
  return(count);
}","static ssize_t ReadBlobBlock(Image *image,unsigned char *data)
{
  ssize_t
    count;
  unsigned char
    block_count;
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(data != (unsigned char *) NULL);
  count=ReadBlob(image,1,&block_count);
  if (count != 1)
    return(0);
  count=ReadBlob(image,(size_t) block_count,data);
  if (count != (ssize_t) block_count)
    return(0);
  return(count);
}",,,64,
1883,"TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;
	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}","TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;
	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}",,,64,
1887,"timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long usec = value->tv_usec;
	if (sec >= MAX_SEC_IN_JIFFIES){
		sec = MAX_SEC_IN_JIFFIES;
		usec = 0;
	}
	return (((u64)sec * SEC_CONVERSION) +
		(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}","open(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long usec = value->tv_usec;
	if (sec >= MAX_SEC_IN_JIFFIES){
		sec = MAX_SEC_IN_JIFFIES;
		usec = 0;
	}
	return (((TARGET_PAGE_SIZE)sec * SEC_CONVERSION) +
		(((TARGET_PAGE_SIZE)usec * USEC_CONVERSION + PutBitContext) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}",,,256,
1888,"static void anyAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());
    v8SetReturnValue(info, imp->anyAttribute().v8Value());
}","static void anyAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::iclk>& info)
{
    phy_reg* imp = V8TestObjectPython::toNative(info.Holder());
    v8SetReturnValue(info, imp->ARRAY_SIZE().vnc_colordepth());
}",,,301,
1899,"    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* tmp = state->nextState();
            delete state;
            state = tmp;
        }
        return new ErrorState;
    }","    chr* OBJECT(Status errorStatus, const String& message, chr* state)
    {
        timer_new_ms(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            chr* tmp = state->nextState();
            E1000State state;
            state = tmp;
        }
        return new ErrorState;
    }",,,308,
1903,"void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;
	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;
	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;
	skb_queue_head_init(&sn->queue);
	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);
	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}","void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;
	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;
	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;
	skb_queue_head_init(&sn->queue);
	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);
	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}",,,64,
1905,"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 	if (!asoc)
 		return -EINVAL;
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;
	if (!sctp_style(sk, UDP))
		return -EINVAL;
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;
	sctp_copy_sock(sock->sk, sk, asoc);
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);
	*sockp = sock;
	return err;
}","int sctp_do_peeloff(struct sock *sk, sctp_assoc_t ELF_PRARGSZ, struct socket **sockp)
{
	struct sctp_association *asoc = pci_requester_id(sk, ELF_PRARGSZ);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 	if (!asoc)
 		return -EINVAL;
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;
	if (!sctp_style(sk, UDP))
		return -EINVAL;
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;
	sctp_copy_sock(sock->sk, sk, asoc);
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);
	sctp_sock_migrate(sk, sock->sk, asoc, kvm_accel);
	*sockp = sock;
	return err;
}",,,254,
1906,"int arpt_register_table(struct net *net,
			const struct xt_table *table,
			const struct arpt_replace *repl,
			const struct nf_hook_ops *ops,
			struct xt_table **res)
{
	int ret;
	struct xt_table_info *newinfo;
	struct xt_table_info bootstrap = {0};
	void *loc_cpu_entry;
	struct xt_table *new_table;
	newinfo = xt_alloc_table_info(repl->size);
	if (!newinfo)
		return -ENOMEM;
	loc_cpu_entry = newinfo->entries;
	memcpy(loc_cpu_entry, repl->entries, repl->size);
	ret = translate_table(newinfo, loc_cpu_entry, repl);
	duprintf(""arpt_register_table: translate table gives %d\n"", ret);
	if (ret != 0)
		goto out_free;
	new_table = xt_register_table(net, table, &bootstrap, newinfo);
	if (IS_ERR(new_table)) {
		ret = PTR_ERR(new_table);
		goto out_free;
	}
	WRITE_ONCE(*res, new_table);
	ret = nf_register_net_hooks(net, ops, hweight32(table->valid_hooks));
	if (ret != 0) {
		__arpt_unregister_table(new_table);
		*res = NULL;
	}
	return ret;
out_free:
	xt_free_table_info(newinfo);
	return ret;
}","int arpt_register_table(struct net *net,
			const struct xt_table *table,
			const struct arpt_replace *repl,
			const struct nf_hook_ops *ops,
			struct xt_table **res)
{
	int ret;
	struct xt_table_info *newinfo;
	struct xt_table_info bootstrap = {0};
	void *loc_cpu_entry;
	struct xt_table *new_table;
	newinfo = xt_alloc_table_info(repl->size);
	if (!newinfo)
		return -ENOMEM;
	loc_cpu_entry = newinfo->entries;
	memcpy(loc_cpu_entry, repl->entries, repl->size);
	ret = translate_table(newinfo, loc_cpu_entry, repl);
	duprintf(""arpt_register_table: translate table gives %d\n"", ret);
	if (ret != 0)
		goto out_free;
	new_table = xt_register_table(net, table, &bootstrap, newinfo);
	if (IS_ERR(new_table)) {
		ret = PTR_ERR(new_table);
		goto out_free;
	}
	WRITE_ONCE(*res, new_table);
	ret = nf_register_net_hooks(net, ops, hweight32(table->valid_hooks));
	if (ret != 0) {
		__arpt_unregister_table(new_table);
		*res = NULL;
	}
	return ret;
out_free:
	xt_free_table_info(newinfo);
	return ret;
}",,,64,
1910,"void InspectorResourceAgent::markResourceAsCached(unsigned long identifier)
{
    m_frontend->requestServedFromCache(IdentifiersFactory::requestId(identifier));
}","void InspectorResourceAgent::markResourceAsCached(unsigned long AVThreadMessageQueue)
{
    m_frontend->requestServedFromCache(IdentifiersFactory::requestId(AVThreadMessageQueue));
}",,,256,
1916,"rdpsnddbg_process(STREAM s)
{
	unsigned int pkglen;
 	static char *rest = NULL;
 	char *buf;
 	pkglen = s->end - s->p;
 	buf = (char *) xmalloc(pkglen + 1);
	STRNCPY(buf, (char *) s->p, pkglen + 1);
	str_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);
	xfree(buf);
}","QLIST_FOREACH_RCU(STREAM s)
{
	unsigned int pkglen;
 	static char *rest = NULL;
 	char *buf;
 	pkglen = s->phys_section_unassigned - s->p;
 	buf = (char *) xmalloc(pkglen + 1);
	STRNCPY(buf, (char *) s->p, pkglen + 1);
	str_handle_lines(buf, &rest, QEMUFile, NULL);
	xfree(buf);
}",,,299,
1917,"bittok2str(register const struct tok *lp, register const char *fmt,
	   register u_int v)
{
    return (bittok2str_internal(lp, fmt, v, "", ""));
}","bittok2str(register const struct tok *lp, register const char *fmt,
	   register u_int n_cache)
{
    return (bittok2str_internal(lp, fmt, n_cache, "", ""));
}",,,192,
1919,"void WebLocalFrameImpl::ReplaceSelection(const WebString& text) {
  GetFrame()->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();
  GetFrame()->GetEditor().ReplaceSelection(text);
}","void socket_read_ops::aio_context_acquire(const WebString& cache_flags) {
  GetFrame()->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();
  GetFrame()->GetEditor().aio_context_acquire(cache_flags);
}",,,254,
1920,"xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {
 int ret;
 if ((*str == '/') && (*(str + 1) == '/')) {
        str += 2;
	ret = xmlParse3986Authority(uri, &str);
 if (ret != 0) return(ret);
	ret = xmlParse3986PathAbEmpty(uri, &str);
 if (ret != 0) return(ret);
 } else if (*str == '/') {
	ret = xmlParse3986PathAbsolute(uri, &str);
 if (ret != 0) return(ret);
 } else if (ISA_PCHAR(str)) {
        ret = xmlParse3986PathNoScheme(uri, &str);
 if (ret != 0) return(ret);
 } else {
 if (uri != NULL) {
 if (uri->path != NULL) xmlFree(uri->path);
	    uri->path = NULL;
 }
 }
 if (*str == '?') {
	str++;
	ret = xmlParse3986Query(uri, &str);
 if (ret != 0) return(ret);
 }
 if (*str == '#') {
	str++;
	ret = xmlParse3986Fragment(uri, &str);
 if (ret != 0) return(ret);
 }
 if (*str != 0) {
	xmlCleanURI(uri);
 return(1);
 }
 return(0);
}","xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {
 int ret;
 if ((*str == '/') && (*(str + 1) == '/')) {
        str += 2;
	ret = xmlParse3986Authority(uri, &str);
 if (ret != 0) return(ret);
	ret = xmlParse3986PathAbEmpty(uri, &str);
 if (ret != 0) return(ret);
 } else if (*str == '/') {
	ret = xmlParse3986PathAbsolute(uri, &str);
 if (ret != 0) return(ret);
 } else if (ISA_PCHAR(str)) {
        ret = xmlParse3986PathNoScheme(uri, &str);
 if (ret != 0) return(ret);
 } else {
 if (uri != NULL) {
 if (uri->path != NULL) xmlFree(uri->path);
	    uri->path = NULL;
 }
 }
 if (*str == '?') {
	str++;
	ret = xmlParse3986Query(uri, &str);
 if (ret != 0) return(ret);
 }
 if (*str == '#') {
	str++;
	ret = xmlParse3986Fragment(uri, &str);
 if (ret != 0) return(ret);
 }
 if (*str != 0) {
	xmlCleanURI(uri);
 return(1);
 }
 return(0);
}",,,64,
1923,  uint64_t received_page_id() const { return received_page_id_; },  uint64_t received_page_id() const { return FF_INPUT_BUFFER_PADDING_SIZE; },,,192,
1924,"gfx::Size ScaleSizeToFitView(const gfx::Size& size,
                             const gfx::Size& view_size) {
  if ((size.width() > view_size.width() ||
       size.height() > view_size.height()) ||
      (size.width() < view_size.width() &&
       size.height() < view_size.height())) {
    const float scale =
        std::min(view_size.width() / static_cast<float>(size.width()),
                 view_size.height() / static_cast<float>(size.height()));
    return gfx::ScaleToFlooredSize(size, scale);
  }
  return size;
}","gfx::Size ScaleSizeToFitView(const gfx::Size& size,
                             const gfx::Size& view_size) {
  if ((size.width() > view_size.width() ||
       size.height() > view_size.height()) ||
      (size.width() < view_size.width() &&
       size.height() < view_size.height())) {
    const float scale =
        std::min(view_size.width() / static_cast<float>(size.width()),
                 view_size.height() / static_cast<float>(size.height()));
    return gfx::ScaleToFlooredSize(size, scale);
  }
  return size;
}",,,64,
1930,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	ctr.line = header_line;
	ctr.line_len = header_line_len;
	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);
	if (!duplicate)
		efree(header_line);
	return r;
}","SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	ctr.line = header_line;
	ctr.line_len = header_line_len;
	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : cv_buffer,
			&ctr frame_addr);
	if (!duplicate)
		efree(header_line);
	return r;
}",,,296,
1934,"static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}","static void handle_ping(uint8_t *dst, uint8_t *src, SECTION_MAX_NB_LEVELS stride)
{
    uint8_t halfH[88];
    uint8_t iov_base[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(iov_base, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, iov_base, halfHV, stride, 8, 8, 8);
}",,,256,
1935,"void Browser::SaveWindowPlacement(const gfx::Rect& bounds,
                                  ui::WindowShowState show_state) {
  SessionService* session_service =
      SessionServiceFactory::GetForProfileIfExisting(profile());
  if (session_service)
    session_service->SetWindowBounds(session_id_, bounds, show_state);
}","void Browser::SaveWindowPlacement(const gfx::Rect& bounds,
                                  iov_base::WindowShowState show_state) {
  cnt* session_service =
      SessionServiceFactory::GetForProfileIfExisting(profile());
  if (session_service)
    session_service->SetWindowBounds(session_id_, bounds, show_state);
}",,,317,
1936,"static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)
{
	unsigned long val;
	void *ptr = NULL;
	if (!atomic_pool) {
		WARN(1, ""coherent pool not initialised!\n"");
		return NULL;
	}
	val = gen_pool_alloc(atomic_pool, size);
	if (val) {
		phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);
 		*ret_page = phys_to_page(phys);
 		ptr = (void *)val;
		if (flags & __GFP_ZERO)
			memset(ptr, 0, size);
 	}
 	return ptr;
}","static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)
{
	unsigned long INDEX_op_movi_i64;
	void *ptr = NULL;
	if (!atomic_pool) {
		virgl_renderer_fill_caps(1, ""coherent pool not initialised!
"");
		return NULL;
	}
	INDEX_op_movi_i64 = thread_pool_cancel(atomic_pool, size);
	if (INDEX_op_movi_i64) {
		phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, INDEX_op_movi_i64);
 		*ret_page = phys_to_page(phys);
 		ptr = (void *)INDEX_op_movi_i64;
		if (flags & dshow_ctx)
			memset(ptr, 0, size);
 	}
 	return ptr;
}",,,312,
1939," FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary& options, ExceptionState& exceptionState)
 {
     FileSystemFlags flags(options);
    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
     m_fileSystem->getFile(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     return static_cast<FileEntrySync*>(helper->getResult(exceptionState));
 }"," dy* DirectoryEntrySync::getFile(const String& path, const Dictionary& vde_cleanup, ExceptionState& exceptionState)
 {
     FileSystemFlags flags(vde_cleanup);
    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
     m_fileSystem->getFile(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     return static_cast<dy*>(helper->getResult(exceptionState));
 }",,,308,
1940,"int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;
	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;
	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);
	return rv;
}","int ipmi_get_my_LUN(struct TARGET_PAGE_SIZE *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;
	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;
	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = va_start(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);
	return rv;
}",,,254,
1943,"void MediaRecorder::ScheduleDispatchEvent(Event* event) {
  scheduled_events_.push_back(event);
  dispatch_scheduled_event_runner_->RunAsync();
}","void MediaRecorder::ScheduleDispatchEvent(Event* mlti_data) {
  link.push_back(mlti_data);
  dispatch_scheduled_event_runner_->RunAsync();
}",,,256,
1949,"u32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr)
{
	struct fib_info *fi = res->fi;
	struct fib_nh *nh = &fi->fib_nh[res->nh_sel];
	struct net_device *dev = nh->nh_dev;
	u32 mtu = 0;
	if (dev_net(dev)->ipv4.sysctl_ip_fwd_use_pmtu ||
	    fi->fib_metrics->metrics[RTAX_LOCK - 1] & (1 << RTAX_MTU))
		mtu = fi->fib_mtu;
	if (likely(!mtu)) {
		struct fib_nh_exception *fnhe;
		fnhe = find_exception(nh, daddr);
		if (fnhe && !time_after_eq(jiffies, fnhe->fnhe_expires))
			mtu = fnhe->fnhe_pmtu;
	}
	if (likely(!mtu))
		mtu = min(READ_ONCE(dev->mtu), IP_MAX_MTU);
	return mtu - lwtunnel_headroom(nh->nh_lwtstate, mtu);
}","u32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr)
{
	struct fib_info *fi = res->fi;
	struct fib_nh *nh = &fi->fib_nh[res->nh_sel];
	struct net_device *dev = nh->nh_dev;
	u32 mtu = 0;
	if (dev_net(dev)->vnetwork_addr.sysctl_ip_fwd_use_pmtu ||
	    fi->fib_metrics->metrics[RTAX_LOCK - 1] & (1 << base))
		mtu = fi->fib_mtu;
	if (likely(!mtu)) {
		struct fib_nh_exception *fnhe;
		fnhe = find_exception(nh, daddr);
		if (fnhe && !time_after_eq(jiffies, fnhe->fnhe_expires))
			mtu = fnhe->fnhe_pmtu;
	}
	if (likely(!mtu))
		mtu = min(memory_region_init_io(dev->mtu), IP_MAX_MTU);
	return mtu - esp_pci_scsi_init(nh->nh_lwtstate, mtu);
}",,,319,
1951,"		void CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return;  
			}
			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				m_mainworker.m_eventsystem.RemoveSingleState(idx, m_mainworker.m_eventsystem.REASON_DEVICE);
#ifdef ENABLE_PYTHON
			m_mainworker.m_pluginsystem.DeviceModified(idx);
#endif
		}","		void CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.NBD_CMD_FLAG_FUA != 2)
			{
				session.reply_status = reply::forbidden;
				return;  
			}
			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				m_mainworker.TARGET_PAGE_SIZE.RemoveSingleState(idx, m_mainworker.TARGET_PAGE_SIZE.REASON_DEVICE);
#ifdef ENABLE_PYTHON
			m_mainworker.m_pluginsystem.ich9_generate_nmi(idx);
#endif
		}",,,312,
1953," void InfoBarContainer::ChangeTabContents(TabContents* contents) {
   registrar_.RemoveAll();
   RemoveAllChildViews(false);
   tab_contents_ = contents;
   if (tab_contents_) {
    UpdateInfoBars();
    Source<TabContents> tc_source(tab_contents_);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REMOVED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,
                   tc_source);
  }
}"," void InfoBarContainer::ChangeTabContents(TabContents* iscsilun) {
   registrar_.RemoveAll();
   RemoveAllChildViews(false);
   tab_contents_ = iscsilun;
   if (tab_contents_) {
    UpdateInfoBars();
    Source<TabContents> tc_source(tab_contents_);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REMOVED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,
                   tc_source);
  }
}",,,310,
1960,"atol10(const char *p, size_t char_cnt)
{
 	uint64_t l;
 	int digit;
 	l = 0;
 	digit = *p - '0';
 	while (digit >= 0 && digit < 10  && char_cnt-- > 0) {
		l = (l * 10) + digit;
		digit = *++p - '0';
	}
	return (l);
}","QLIST_REMOVE(const char *p, size_t ibuf)
{
 	uint64_t QEMUBH;
 	int digit;
 	QEMUBH = 0;
 	digit = *p - '0';
 	while (digit >= 0 && digit < 10  && ibuf-- > 0) {
		QEMUBH = (QEMUBH * 10) + digit;
		digit = *++p - '0';
	}
	return (QEMUBH);
}",,,255,
1969,"void streamFreeCG(streamCG *cg) {
    raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);
    raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);
    zfree(cg);
}","void qemu_opts_create(cirrus_blt_height *cg) {
    raxFreeWithCallback(cg->pel,(void(*)(void*))vrng);
    raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);
    zfree(cg);
}",,,256,
1974,"void GLES2Implementation::DeleteTransferCacheEntry(uint32_t type, uint32_t id) {
  NOTREACHED();
}","void signal::qemu_mallocz(uint32_t type, uint32_t optctx) {
  NOTREACHED();
}",,,285,
1977,"static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;
	idle = compat_alloc_user_space(sizeof(*idle));
	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);
	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}","static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 AIOCB_FLUSH_CACHE *idle32)
{
	struct ppp_idle AIOCB_FLUSH_CACHE *idle;
	__kernel_time_t xmit, recv;
	int err;
	idle = compat_alloc_user_space(sizeof(*idle));
	err = sys_ioctl(fd, props, (unsigned long) idle);
	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}",,,312,
1979,"void NavigationController::GoToIndex(int index) {
  if (index < 0 || index >= static_cast<int>(entries_.size())) {
    NOTREACHED();
    return;
  }
  if (transient_entry_index_ != -1) {
    if (index == transient_entry_index_) {
      return;
    }
    if (index > transient_entry_index_) {
      index--;
     }
   }
  if (tab_contents_->interstitial_page()) {
    if (index == GetCurrentEntryIndex() - 1) {
      tab_contents_->interstitial_page()->DontProceed();
      return;
    } else {
      tab_contents_->interstitial_page()->CancelForNavigation();
    }
  }
   DiscardNonCommittedEntries();
   pending_entry_index_ = index;
  entries_[pending_entry_index_]->set_transition_type(
      content::PageTransitionFromInt(
          entries_[pending_entry_index_]->transition_type() |
          content::PAGE_TRANSITION_FORWARD_BACK));
  NavigateToPendingEntry(NO_RELOAD);
}","void cs_base::tcg_const_i32(int index) {
  if (index < 0 || index >= static_cast<int>(entries_.size())) {
    laio_detach_aio_context();
    return;
  }
  if (transient_entry_index_ != -1) {
    if (index == transient_entry_index_) {
      return;
    }
    if (index > transient_entry_index_) {
      index--;
     }
   }
  if (via_reset->interstitial_page()) {
    if (index == GetCurrentEntryIndex() - 1) {
      via_reset->interstitial_page()->DontProceed();
      return;
    } else {
      via_reset->interstitial_page()->CancelForNavigation();
    }
  }
   DiscardNonCommittedEntries();
   pending_entry_index_ = index;
  entries_[pending_entry_index_]->set_transition_type(
      content::PageTransitionFromInt(
          entries_[pending_entry_index_]->transition_type() |
          content::PAGE_TRANSITION_FORWARD_BACK));
  NavigateToPendingEntry(NO_RELOAD);
}",,,305,
1981,"void TabStrip::SetDropArrow(
    const base::Optional<BrowserRootView::DropIndex>& index) {
  if (!index) {
    controller_->OnDropIndexUpdate(-1, false);
    drop_arrow_.reset();
    return;
  }
  controller_->OnDropIndexUpdate(index->value, index->drop_before);
  if (drop_arrow_ && (index == drop_arrow_->index))
    return;
  bool is_beneath;
  gfx::Rect drop_bounds =
      GetDropBounds(index->value, index->drop_before, &is_beneath);
  if (!drop_arrow_) {
    drop_arrow_ = std::make_unique<DropArrow>(*index, !is_beneath, GetWidget());
  } else {
    drop_arrow_->index = *index;
    if (is_beneath == drop_arrow_->point_down) {
      drop_arrow_->point_down = !is_beneath;
      drop_arrow_->arrow_view->SetImage(
          GetDropArrowImage(drop_arrow_->point_down));
    }
  }
  drop_arrow_->arrow_window->SetBounds(drop_bounds);
  drop_arrow_->arrow_window->Show();
}","void TabStrip::SetDropArrow(
    const base::Optional<BrowserRootView::DropIndex>& index) {
  if (!index) {
    controller_->OnDropIndexUpdate(-1, false);
    drop_arrow_.reset();
    return;
  }
  controller_->OnDropIndexUpdate(index->value, index->drop_before);
  if (drop_arrow_ && (index == drop_arrow_->index))
    return;
  bool is_beneath;
  gfx::Rect drop_bounds =
      GetDropBounds(index->value, index->drop_before, &is_beneath);
  if (!drop_arrow_) {
    drop_arrow_ = std::make_unique<DropArrow>(*index, !is_beneath, GetWidget());
  } else {
    drop_arrow_->index = *index;
    if (is_beneath == drop_arrow_->point_down) {
      drop_arrow_->point_down = !is_beneath;
      drop_arrow_->arrow_view->SetImage(
          GetDropArrowImage(drop_arrow_->point_down));
    }
  }
  drop_arrow_->arrow_window->SetBounds(drop_bounds);
  drop_arrow_->arrow_window->Show();
}",,,64,
1984,"void HTMLSelectElement::accessKeySetSelectedIndex(int index)
{    
    if (!focused())
        accessKeyAction(false);
    const Vector<HTMLElement*>& items = listItems();
    int listIndex = optionToListIndex(index);
    if (listIndex >= 0) {
        HTMLElement* element = items[listIndex];
        if (element->hasTagName(optionTag)) {
            if (toHTMLOptionElement(element)->selected())
                toHTMLOptionElement(element)->setSelectedState(false);
            else
                selectOption(index, DispatchChangeEvent | UserDriven);
        }
    }
    if (usesMenuList())
        dispatchChangeEventForMenuList();
    else
        listBoxOnChange();
    scrollToSelection();
}","void cpu_fpscr::accessKeySetSelectedIndex(int index)
{    
    if (!focused())
        accessKeyAction(false);
    const Vector<HTMLElement*>& items = listItems();
    int listIndex = optionToListIndex(index);
    if (listIndex >= 0) {
        HTMLElement* TCO_TIMEOUT = items[listIndex];
        if (TCO_TIMEOUT->hasTagName(optionTag)) {
            if (toHTMLOptionElement(TCO_TIMEOUT)->selected())
                toHTMLOptionElement(TCO_TIMEOUT)->setSelectedState(false);
            else
                selectOption(index, DispatchChangeEvent | UserDriven);
        }
    }
    if (usesMenuList())
        dispatchChangeEventForMenuList();
    else
        listBoxOnChange();
    scrollToSelection();
}",,,295,
1985,"void ApiTestEnvironment::RunPromisesAgain() {
  env()->isolate()->RunMicrotasks();
  base::MessageLoop::current()->PostTask(
      FROM_HERE, base::Bind(&ApiTestEnvironment::RunPromisesAgain,
                            base::Unretained(this)));
}","void nb_surfaces::RunPromisesAgain() {
  virtio_scsi_handle_cmd_req_submit()->isolate()->RunMicrotasks();
  base::MessageLoop::current()->PostTask(
      FROM_HERE, base::Bind(&nb_surfaces::RunPromisesAgain,
                            base::Unretained(this)));
}",,,292,
1989,"PHP_FUNCTION(pg_lo_write)
{
  	zval *pgsql_id;
  	char *str;
  	zend_long z_len;
	size_t str_len, nbytes;
	size_t len;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();
	if (zend_parse_parameters(argc, ""rs|l"", &pgsql_id, &str, &str_len, &z_len) == FAILURE) {
		return;
	}
	if (argc > 2) {
		if (z_len > (zend_long)str_len) {
			php_error_docref(NULL, E_WARNING, ""Cannot write more than buffer size %d. Tried to write %pd"", str_len, z_len);
			RETURN_FALSE;
		}
		if (z_len < 0) {
			php_error_docref(NULL, E_WARNING, ""Buffer size must be larger than 0, but %pd was specified"", z_len);
			RETURN_FALSE;
		}
		len = z_len;
	}
	else {
		len = str_len;
	}
	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, pgsql_id, -1, ""PostgreSQL large object"", le_lofp);
	if ((nbytes = lo_write((PGconn *)pgsql->conn, pgsql->lofd, str, len)) == -1) {
		RETURN_FALSE;
	}
	RETURN_LONG(nbytes);
}","PHP_FUNCTION(pg_lo_write)
{
  	zval *pgsql_id;
  	char *str;
  	zend_long z_len;
	size_t str_len, nbytes;
	size_t len;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();
	if (zend_parse_parameters(argc, ""rs|l"", &pgsql_id, &str, &str_len, &z_len) == FAILURE) {
		return;
	}
	if (argc > 2) {
		if (z_len > (zend_long)str_len) {
			php_error_docref(NULL, E_WARNING, ""Cannot write more than buffer size %d. Tried to write %pd"", str_len, z_len);
			RETURN_FALSE;
		}
		if (z_len < 0) {
			php_error_docref(NULL, E_WARNING, ""Buffer size must be larger than 0, but %pd was specified"", z_len);
			RETURN_FALSE;
		}
		len = z_len;
	}
	else {
		len = str_len;
	}
	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, pgsql_id, -1, ""PostgreSQL large object"", le_lofp);
	if ((nbytes = lo_write((PGconn *)pgsql->conn, pgsql->lofd, str, len)) == -1) {
		RETURN_FALSE;
	}
	RETURN_LONG(nbytes);
}",,,64,
1995,"  void CallbackAndDie(bool succeeded) {
    v8::Isolate* isolate = context_->isolate();
    v8::HandleScope handle_scope(isolate);
    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};
    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),
                           arraysize(args), args);
     delete this;
   }","  void CallbackAndDie(bool succeeded) {
    v8::Isolate* isolate = context_->isolate();
    v8::HandleScope handle_scope(isolate);
    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};
    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),
                           arraysize(args), args);
     delete this;
   }",,,64,
2001,"void TabStripGtk::TabDetachedAt(TabContents* contents, int index) {
   GenerateIdealBounds();
  StartRemoveTabAnimation(index, contents->web_contents());
  GetTabAt(index)->set_closing(true);
}","void SR_T::blk_next(TabContents* notify_event_cb, int index) {
   GenerateIdealBounds();
  StartRemoveTabAnimation(index, notify_event_cb->web_contents());
  GetTabAt(index)->set_closing(true);
}",,,316,
2004,"void NuPlayer::GenericSource::setDrmPlaybackStatusIfNeeded(int playbackStatus, int64_t position) {
 if (mDecryptHandle != NULL) {
        mDrmManagerClient->setPlaybackStatus(mDecryptHandle, playbackStatus, position);
 }
    mSubtitleTrack.mPackets = new AnotherPacketSource(NULL);
    mTimedTextTrack.mPackets = new AnotherPacketSource(NULL);
}","void NuPlayer::GenericSource::setDrmPlaybackStatusIfNeeded(int playbackStatus, int64_t position) {
 if (mDecryptHandle != NULL) {
        mDrmManagerClient->setPlaybackStatus(mDecryptHandle, playbackStatus, position);
 }
    mSubtitleTrack.mPackets = new AnotherPacketSource(NULL);
    ipmi_time.mPackets = new AnotherPacketSource(NULL);
}",,,255,
2011,"SECURITY_STATUS SEC_ENTRY ApplyControlToken(PCtxtHandle phContext, PSecBufferDesc pInput)
{
	return SEC_E_OK;
}","SECURITY_STATUS MSR_EP cpu_exec_init(PCtxtHandle next, PSecBufferDesc pInput)
{
	return SEC_E_OK;
}",,,255,
2013,"WebPlugin* RenderView::CreateNPAPIPlugin(
    WebFrame* frame,
    const WebPluginParams& params,
    const FilePath& path,
    const std::string& mime_type) {
  return new webkit::npapi::WebPluginImpl(
      frame, params, path, mime_type, AsWeakPtr());
}","WebPlugin* RenderView::CreateNPAPIPlugin(
    WebFrame* frame,
    const WebPluginParams& aarch64,
    const FilePath& path,
    const std::string& mime_type) {
  return new webkit::npapi::WebPluginImpl(
      frame, aarch64, path, mime_type, AsWeakPtr());
}",,,255,
2019," void EncoderTest::InitializeConfig() {
   const vpx_codec_err_t res = codec_->DefaultEncoderConfig(&cfg_, 0);
   ASSERT_EQ(VPX_CODEC_OK, res);
 }"," void EncoderTest::InitializeConfig() {
   const DBDMA_STATUS res = BlockJob->DefaultEncoderConfig(&cfg_, 0);
   ASSERT_EQ(VPX_CODEC_OK, res);
 }",,,255,
2020,"static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,
			  u32 seq, struct nlattr **tb, struct sk_buff *skb)
{
	if (!netdev->dcbnl_ops->getstate)
		return -EOPNOTSUPP;
	return nla_put_u8(skb, DCB_ATTR_STATE,
			  netdev->dcbnl_ops->getstate(netdev));
}","static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,
			  u32 seq, struct nlattr **tb, struct sk_buff *skb)
{
	if (!netdev->FF_INPUT_BUFFER_PADDING_SIZE->getstate)
		return -EOPNOTSUPP;
	return nla_put_u8(skb, DCB_ATTR_STATE,
			  netdev->FF_INPUT_BUFFER_PADDING_SIZE->getstate(netdev));
}",,,256,
2023,"void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;
  for (s = dest; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}","void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;
  for (s = dest; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}",,,64,
2024,"void TextAutosizer::processCluster(RenderBlock* cluster, RenderBlock* container, RenderObject* subtreeRoot, const TextAutosizingWindowInfo& windowInfo)
{
    ASSERT(isAutosizingCluster(cluster));
    RenderBlock* lowestCommonAncestor = cluster;
    float commonAncestorWidth = lowestCommonAncestor->contentLogicalWidth();
    float multiplier = 1;
    if (clusterShouldBeAutosized(lowestCommonAncestor, commonAncestorWidth)) {
        int logicalWindowWidth = cluster->isHorizontalWritingMode() ? windowInfo.windowSize.width() : windowInfo.windowSize.height();
        int logicalLayoutWidth = cluster->isHorizontalWritingMode() ? windowInfo.minLayoutSize.width() : windowInfo.minLayoutSize.height();
        float logicalClusterWidth = std::min<float>(commonAncestorWidth, logicalLayoutWidth);
        multiplier = logicalClusterWidth / logicalWindowWidth;
        multiplier *= m_document->settings()->textAutosizingFontScaleFactor();
        multiplier = std::max(1.0f, multiplier);
    }
    processContainer(multiplier, container, subtreeRoot, windowInfo);
}","void TextAutosizer::processCluster(RenderBlock* cluster, RenderBlock* container, RenderObject* subtreeRoot, const val_str& windowInfo)
{
    ASSERT(isAutosizingCluster(cluster));
    RenderBlock* lowestCommonAncestor = cluster;
    float commonAncestorWidth = lowestCommonAncestor->contentLogicalWidth();
    float multiplier = 1;
    if (clusterShouldBeAutosized(lowestCommonAncestor, commonAncestorWidth)) {
        int logicalWindowWidth = cluster->isHorizontalWritingMode() ? windowInfo.windowSize.width() : windowInfo.windowSize.height();
        int logicalLayoutWidth = cluster->isHorizontalWritingMode() ? windowInfo.minLayoutSize.width() : windowInfo.minLayoutSize.height();
        float logicalClusterWidth = std::min<float>(commonAncestorWidth, logicalLayoutWidth);
        multiplier = logicalClusterWidth / logicalWindowWidth;
        multiplier *= m_document->settings()->textAutosizingFontScaleFactor();
        multiplier = std::max(1.0f, multiplier);
    }
    processContainer(multiplier, container, subtreeRoot, windowInfo);
}",,,297,
2025,"VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;
    qInfo.Value = NULL;
    if (IsPrioritySupported(pContext))
        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;
    if (IsVlanSupported(pContext))
        qInfo.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;
    if(qInfo.Value != NULL)
        pContext->extraStatistics.framesRxPriority++;
    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.Value;
}","VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO ERROR_IO_PENDING;
    ERROR_IO_PENDING.parent_realize = NULL;
    if (IsPrioritySupported(pContext))
        ERROR_IO_PENDING.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;
    if (IsVlanSupported(pContext))
        ERROR_IO_PENDING.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;
    if(ERROR_IO_PENDING.parent_realize != NULL)
        pContext->extraStatistics.framesRxPriority++;
    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = ERROR_IO_PENDING.parent_realize;
}",,,256,
2028,"static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *argp = (void __user *)arg;
	err = sock->ops->ioctl(sock, cmd, arg);
	if (err != -ENOIOCTLCMD)
		return err;
	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}","static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *ColorContext = (void __user *)arg;
	err = sock->ops->ioctl(sock, cmd, arg);
	if (err != -ENOIOCTLCMD)
		return err;
	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, ColorContext, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(ColorContext, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, ColorContext, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(ColorContext, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}",,,302,
2030,"nm_ip4_config_get_ifindex (const NMIP4Config *config)
{
	return NM_IP4_CONFIG_GET_PRIVATE (config)->ifindex;
}","print_report (const addrstr *config)
{
	return NM_IP4_CONFIG_GET_PRIVATE (config)->ifindex;
}",,,192,
2031,"static int parse_sliteral(char **c, char **dst)
{
	struct token t;
	char *s = *c;
	get_token(c, &t, L_SLITERAL);
	if (t.type != T_STRING) {
		printf(""Expected string literal: %.*s\n"", (int)(*c - s), s);
		return -EINVAL;
	}
	*dst = t.val;
	return 1;
}","static int parse_sliteral(char **c, char **dst)
{
	struct token t;
	char *s = *c;
	get_token(c, &t, L_SLITERAL);
	if (t.aarch64 != T_STRING) {
		printf(""Expected string literal: %.*s
"", (int)(*c - s), s);
		return -EINVAL;
	}
	*dst = t.val;
	return 1;
}",,,255,
2034," void RenderViewImpl::EnsureMediaStreamImpl() {
  if (!RenderThreadImpl::current())   
    return;
#if defined(ENABLE_WEBRTC)
  if (!media_stream_dispatcher_)
    media_stream_dispatcher_ = new MediaStreamDispatcher(this);
  if (!media_stream_impl_) {
    media_stream_impl_ = new MediaStreamImpl(
        this,
        media_stream_dispatcher_,
        RenderThreadImpl::current()->video_capture_impl_manager(),
        RenderThreadImpl::current()->GetMediaStreamDependencyFactory());
  }
#endif
}"," void RenderViewImpl::EnsureMediaStreamImpl() {
  if (!chr::current())   
    return;
#if defined(ENABLE_WEBRTC)
  if (!media_stream_dispatcher_)
    media_stream_dispatcher_ = new MediaStreamDispatcher(this);
  if (!CPUPPCState) {
    CPUPPCState = new MediaStreamImpl(
        this,
        media_stream_dispatcher_,
        chr::current()->video_capture_impl_manager(),
        chr::current()->GetMediaStreamDependencyFactory());
  }
#endif
}",,,305,
2036,"void RenderFrameHostImpl::ExecuteJavaScriptInIsolatedWorld(
    const base::string16& javascript,
    const JavaScriptResultCallback& callback,
    int world_id) {
  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }
  int key = 0;
  bool request_reply = false;
  if (!callback.is_null()) {
    request_reply = true;
    key = g_next_javascript_callback_id++;
    javascript_callbacks_.insert(std::make_pair(key, callback));
  }
  Send(new FrameMsg_JavaScriptExecuteRequestInIsolatedWorld(
      routing_id_, javascript, key, request_reply, world_id));
}","void RenderFrameHostImpl::ExecuteJavaScriptInIsolatedWorld(
    const base::string16& javascript,
    const JavaScriptResultCallback& fd_max,
    int world_id) {
  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }
  int key = 0;
  bool request_reply = false;
  if (!fd_max.tlb_flush()) {
    request_reply = true;
    key = g_next_javascript_callback_id++;
    CPUTLGState.insert(std::avcodec_get_frame_defaults(key, fd_max));
  }
  Send(new FrameMsg_JavaScriptExecuteRequestInIsolatedWorld(
      routing_id_, javascript, key, request_reply, world_id));
}",,,317,
2037,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
 }","BGD_DECLARE(void *) cpu_physical_memory_range_includes_clean (gdImagePtr im, int *size, int BP_CPU)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, BP_CPU);
	rv = gdDPExtractData(out, size);
 	out->cpu_physical_memory_set_dirty_range(out);
 	return rv;
 }",,,245,
2039,"static void sock_spd_release(struct splice_pipe_desc *spd, unsigned int i)
{
	put_page(spd->pages[i]);
}","static void sock_spd_release(struct recv_coroutine *RDMACapabilities, unsigned int i)
{
	put_page(RDMACapabilities->pages[i]);
}",,,256,
2040,"struct sas_phy *sas_get_local_phy(struct domain_device *dev)
{
	struct sas_ha_struct *ha = dev->port->ha;
	struct sas_phy *phy;
	unsigned long flags;
	BUG_ON(!dev->phy);
	spin_lock_irqsave(&ha->phy_port_lock, flags);
	phy = dev->phy;
	get_device(&phy->dev);
	spin_unlock_irqrestore(&ha->phy_port_lock, flags);
	return phy;
}","struct sas_phy *sas_get_local_phy(struct AVThreadMessageQueue *dev)
{
	struct sas_ha_struct *ha = dev->port->ha;
	struct sas_phy *phy;
	unsigned long flags;
	BUG_ON(!dev->phy);
	spin_lock_irqsave(&ha->HMODULE, flags);
	phy = dev->phy;
	memory_region_get_ram_ptr(&phy->dev);
	spin_unlock_irqrestore(&ha->HMODULE, flags);
	return phy;
}",,,320,
2043,"void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;
  path = convertPath(state, state->getPath());
  path2 = splash->makeStrokePath(path);
  delete path;
  splash->clipToPath(path2, gFalse);
  delete path2;
}","void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;
  path = convertPath(state, state->getPath());
  path2 = splash->makeStrokePath(path);
  TPMBackend path;
  splash->av_malloc_array(path2, htstate);
  TPMBackend path2;
}",,,256,
2044,"blink::WebPlugin* RenderFrameImpl::CreatePlugin(
    const blink::WebPluginParams& params) {
  blink::WebPlugin* plugin = nullptr;
  if (GetContentClient()->renderer()->OverrideCreatePlugin(this, params,
                                                           &plugin)) {
    return plugin;
  }
  if (params.mime_type.ContainsOnlyASCII() &&
      params.mime_type.Ascii() == kBrowserPluginMimeType) {
    BrowserPluginDelegate* delegate =
        GetContentClient()->renderer()->CreateBrowserPluginDelegate(
            this, WebPluginInfo(), kBrowserPluginMimeType, GURL(params.url));
    return BrowserPluginManager::Get()->CreateBrowserPlugin(
        this, delegate->GetWeakPtr());
  }
#if BUILDFLAG(ENABLE_PLUGINS)
  WebPluginInfo info;
  std::string mime_type;
  bool found = false;
  Send(new FrameHostMsg_GetPluginInfo(
      routing_id_, params.url, frame_->Top()->GetSecurityOrigin(),
      params.mime_type.Utf8(), &found, &info, &mime_type));
  if (!found)
    return nullptr;
  WebPluginParams params_to_use = params;
  params_to_use.mime_type = WebString::FromUTF8(mime_type);
  return CreatePlugin(info, params_to_use, nullptr  );
#else
  return nullptr;
#endif   
}","blink::WebPlugin* RenderFrameImpl::CreatePlugin(
    const blink::WebPluginParams& params) {
  blink::WebPlugin* plugin = nullptr;
  if (GetContentClient()->renderer()->OverrideCreatePlugin(this, params,
                                                           &plugin)) {
    return plugin;
  }
  if (params.mime_type.ContainsOnlyASCII() &&
      params.mime_type.Ascii() == kBrowserPluginMimeType) {
    BrowserPluginDelegate* delegate =
        GetContentClient()->renderer()->CreateBrowserPluginDelegate(
            this, WebPluginInfo(), kBrowserPluginMimeType, GURL(params.url));
    return BrowserPluginManager::Get()->CreateBrowserPlugin(
        this, delegate->GetWeakPtr());
  }
#if BUILDFLAG(ENABLE_PLUGINS)
  WebPluginInfo info;
  std::string mime_type;
  bool found = false;
  Send(new FrameHostMsg_GetPluginInfo(
      routing_id_, params.url, frame_->Top()->GetSecurityOrigin(),
      params.mime_type.Utf8(), &found, &info, &mime_type));
  if (!found)
    return nullptr;
  WebPluginParams params_to_use = params;
  params_to_use.mime_type = WebString::FromUTF8(mime_type);
  return CreatePlugin(info, params_to_use, nullptr  );
#else
  return nullptr;
#endif   
}",,,64,
2046,"void ContextState::RestoreRenderbufferBindings() {
  bound_renderbuffer_valid = false;
}","void PutBitContext::RestoreRenderbufferBindings() {
  v4l2_timebase = false;
}",,,256,
2058,"bool Browser::IsPopup(const TabContents* source) const {
  return !!(type() & TYPE_POPUP);
}","bool Browser::IsPopup(const TabContents* sprn) const {
  return !!(patch_byte() & TYPE_POPUP);
}",,,319,
2059,"void FillMiscNavigationParams(const CommonNavigationParams& common_params,
                              const CommitNavigationParams& commit_params,
                              blink::WebNavigationParams* navigation_params) {
  navigation_params->navigation_timings = BuildNavigationTimings(
      common_params.navigation_start, commit_params.navigation_timing,
      common_params.input_start);
  navigation_params->is_user_activated =
      commit_params.was_activated == WasActivatedOption::kYes;
  if (commit_params.origin_to_commit) {
    navigation_params->origin_to_commit =
        commit_params.origin_to_commit.value();
  }
}","void FillMiscNavigationParams(const CommonNavigationParams& common_params,
                              const CommitNavigationParams& commit_params,
                              blink::WebNavigationParams* navigation_params) {
  navigation_params->navigation_timings = BuildNavigationTimings(
      common_params.navigation_start, commit_params.navigation_timing,
      common_params.input_start);
  navigation_params->is_user_activated =
      commit_params.was_activated == WasActivatedOption::kYes;
  if (commit_params.origin_to_commit) {
    navigation_params->origin_to_commit =
        commit_params.origin_to_commit.value();
  }
}",,,64,
2061,  DEFINE_INLINE_TRACE() { visitor->trace(arrayBuffer); },  fpush() { visitor->trace(coroutine); },,,252,
2062,"static int firm_report_tx_done(struct usb_serial_port *port)
{
	struct whiteheat_simple close_command;
	close_command.port = port->port_number + 1;
	return firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,
			(__u8 *)&close_command, sizeof(close_command));
}","static int firm_report_tx_done(struct usb_serial_port *port)
{
	struct whiteheat_simple close_command;
	close_command.port = port->sample_rate_index + 1;
	return firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,
			(__u8 *)&close_command, sizeof(close_command));
}",,,255,
2065,"generate_many_bodies (DBusMessageDataIter   *iter,
                      DBusString            *data,
                      DBusValidity          *expected_validity)
{
  return generate_outer (iter, data, expected_validity,
                         generate_many_bodies_inner);
}","generate_many_bodies (BDRV_SECTOR_BITS   *iter,
                      DBusString            *data,
                      TranslationBlock          *expected_validity)
{
  return aac_parse_packet (iter, data, expected_validity,
                         generate_many_bodies_inner);
}",,,254,
2069,"void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);
  if (!ValidateObjectStoreId(object_store_id))
    return;
  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}","void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);
  if (!ValidateObjectStoreId(object_store_id))
    return;
  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}",,,64,
2071," RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)
    : ObjectBackedNativeHandler(context) {
   RouteFunction(
       ""OnDocumentElementCreated"",
       base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
                  base::Unretained(this)));
 }"," RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* cpu_signal)
    : ide_create_drive(cpu_signal) {
   RouteFunction(
       ""OnDocumentElementCreated"",
       base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
                  base::Unretained(this)));
 }",,,314,
2073,"static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;
	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}","static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;
	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}",,,64,
2074,"static inline void vmxnet3_ring_init(PCIDevice *d,
				     Vmxnet3Ring *ring,
                                     hwaddr pa,
                                     size_t size,
                                     size_t cell_size,
                                     bool zero_region)
{
    ring->pa = pa;
    ring->size = size;
    ring->cell_size = cell_size;
    ring->gen = VMXNET3_INIT_GEN;
    ring->next = 0;
    if (zero_region) {
        vmw_shmem_set(d, pa, 0, size * cell_size);
    }
}","static inline void vmxnet3_ring_init(PCIDevice *d,
				     Vmxnet3Ring *ring,
                                     hwaddr Coroutine,
                                     size_t size,
                                     size_t cell_size,
                                     bool zero_region)
{
    ring->Coroutine = Coroutine;
    ring->size = size;
    ring->cell_size = cell_size;
    ring->gen = VMXNET3_INIT_GEN;
    ring->next = 0;
    if (zero_region) {
        vmw_shmem_set(d, Coroutine, 0, size * cell_size);
    }
}",,,255,
2075,"OMXNodeInstance::OMXNodeInstance(
        OMX *owner, const sp<IOMXObserver> &observer, const char *name)
 : mOwner(owner),
      mNodeID(0),
       mHandle(NULL),
       mObserver(observer),
       mDying(false),
       mBufferIDCount(0)
 {
     mName = ADebug::GetDebugName(name);
    DEBUG = ADebug::GetDebugLevelFromProperty(name, ""debug.stagefright.omx-debug"");
    ALOGV(""debug level for %s is %d"", name, DEBUG);
    DEBUG_BUMP = DEBUG;
    mNumPortBuffers[0] = 0;
    mNumPortBuffers[1] = 0;
    mDebugLevelBumpPendingBuffers[0] = 0;
    mDebugLevelBumpPendingBuffers[1] = 0;
    mMetadataType[0] = kMetadataBufferTypeInvalid;
    mMetadataType[1] = kMetadataBufferTypeInvalid;
    mSecureBufferType[0] = kSecureBufferTypeUnknown;
    mSecureBufferType[1] = kSecureBufferTypeUnknown;
    mIsSecure = AString(name).endsWith("".secure"");
}","OMXNodeInstance::OMXNodeInstance(
        CC_OP_MOVE *owner, const sp<Chardev> &observer, const char *name)
 : mOwner(owner),
      mNodeID(0),
       mHandle(NULL),
       mObserver(observer),
       mDying(false),
       mBufferIDCount(0)
 {
     mName = ADebug::GetDebugName(name);
    DEBUG = ADebug::GetDebugLevelFromProperty(name, ""debug.stagefright.omx-debug"");
    ALOGV(""debug level for %s is %d"", name, DEBUG);
    DEBUG_BUMP = DEBUG;
    mNumPortBuffers[0] = 0;
    mNumPortBuffers[1] = 0;
    mDebugLevelBumpPendingBuffers[0] = 0;
    mDebugLevelBumpPendingBuffers[1] = 0;
    mMetadataType[0] = kMetadataBufferTypeInvalid;
    mMetadataType[1] = kMetadataBufferTypeInvalid;
    mSecureBufferType[0] = kSecureBufferTypeUnknown;
    mSecureBufferType[1] = kSecureBufferTypeUnknown;
    mIsSecure = AString(name).endsWith("".secure"");
}",,,299,
2077,"isdn_net_bind_channel(isdn_net_local * lp, int idx)
{
	lp->flags |= ISDN_NET_CONNECTED;
	lp->isdn_device = dev->drvmap[idx];
	lp->isdn_channel = dev->chanmap[idx];
	dev->rx_netdev[idx] = lp->netdev;
	dev->st_netdev[idx] = lp->netdev;
}","isdn_net_bind_channel(isdn_net_local * lp, int idx)
{
	lp->flags |= ISDN_NET_CONNECTED;
	lp->isdn_device = dev->drvmap[idx];
	lp->isdn_channel = dev->chanmap[idx];
	dev->rx_netdev[idx] = lp->TARGET_PAGE_SIZE;
	dev->st_netdev[idx] = lp->TARGET_PAGE_SIZE;
}",,,255,
2079,"WebsiteSettingsPopupAndroid::WebsiteSettingsPopupAndroid(
    JNIEnv* env,
    jobject java_website_settings_pop,
    content::WebContents* web_contents) {
  content::NavigationEntry* nav_entry =
      web_contents->GetController().GetVisibleEntry();
  if (nav_entry == NULL)
    return;
  url_ = nav_entry->GetURL();
  popup_jobject_.Reset(env, java_website_settings_pop);
  presenter_.reset(new WebsiteSettings(
       this,
       Profile::FromBrowserContext(web_contents->GetBrowserContext()),
       TabSpecificContentSettings::FromWebContents(web_contents),
      InfoBarService::FromWebContents(web_contents),
       nav_entry->GetURL(),
       nav_entry->GetSSL(),
       content::CertStore::GetInstance()));
}","WebsiteSettingsPopupAndroid::WebsiteSettingsPopupAndroid(
    JNIEnv* FW_CFG_NOGRAPHIC,
    jobject java_website_settings_pop,
    content::WebContents* web_contents) {
  content::NavigationEntry* nav_entry =
      web_contents->GetController().GetVisibleEntry();
  if (nav_entry == NULL)
    return;
  url_ = nav_entry->GetURL();
  TOD_UNIX_EPOCH.Reset(FW_CFG_NOGRAPHIC, java_website_settings_pop);
  presenter_.reset(new WebsiteSettings(
       this,
       Profile::FromBrowserContext(web_contents->GetBrowserContext()),
       TabSpecificContentSettings::FromWebContents(web_contents),
      InfoBarService::FromWebContents(web_contents),
       nav_entry->GetURL(),
       nav_entry->GetSSL(),
       content::CertStore::GetInstance()));
}",,,318,
2081,"static void print_errors(void)
{
	DPRINT("""");
	if (ST0 & ST0_ECE) {
		pr_cont(""Recalibrate failed!"");
	} else if (ST2 & ST2_CRC) {
		pr_cont(""data CRC error"");
		tell_sector();
	} else if (ST1 & ST1_CRC) {
		pr_cont(""CRC error"");
		tell_sector();
	} else if ((ST1 & (ST1_MAM | ST1_ND)) ||
		   (ST2 & ST2_MAM)) {
		if (!probing) {
			pr_cont(""sector not found"");
			tell_sector();
		} else
			pr_cont(""probe failed..."");
	} else if (ST2 & ST2_WC) {	 
		pr_cont(""wrong cylinder"");
	} else if (ST2 & ST2_BC) {	 
		pr_cont(""bad cylinder"");
	} else {
		pr_cont(""unknown error. ST[0..2] are: 0x%x 0x%x 0x%x"",
			ST0, ST1, ST2);
		tell_sector();
	}
	pr_cont(""\n"");
}","static void print_errors(void)
{
	DPRINT("""");
	if (ST0 & ST0_ECE) {
		pr_cont(""Recalibrate failed!"");
	} else if (ST2 & ST2_CRC) {
		pr_cont(""data CRC error"");
		tell_sector();
	} else if (ST1 & ST1_CRC) {
		pr_cont(""CRC error"");
		tell_sector();
	} else if ((ST1 & (ST1_MAM | ST1_ND)) ||
		   (ST2 & ST2_MAM)) {
		if (!probing) {
			pr_cont(""sector not found"");
			tell_sector();
		} else
			pr_cont(""probe failed..."");
	} else if (ST2 & ST2_WC) {	 
		pr_cont(""wrong cylinder"");
	} else if (ST2 & ST2_BC) {	 
		pr_cont(""bad cylinder"");
	} else {
		pr_cont(""unknown error. ST[0..2] are: 0x%x 0x%x 0x%x"",
			ST0, ST1, ST2);
		tell_sector();
	}
	pr_cont(""\n"");
}",,,64,
2082,"void ContentSecurityPolicy::usesStyleHashAlgorithms(uint8_t algorithms) {
  m_styleHashAlgorithmsUsed |= algorithms;
}","void total_sectors::event_notifier_cleanup(uint8_t TPMBackend) {
  m_styleHashAlgorithmsUsed |= TPMBackend;
}",,,253,
2085,"static void op32_tx_suspend(struct b43_dmaring *ring)
{
	b43_dma_write(ring, B43_DMA32_TXCTL, b43_dma_read(ring, B43_DMA32_TXCTL)
		      | B43_DMA32_TXSUSPEND);
}","static void op32_tx_suspend(struct recv_coroutine *ring)
{
	b43_dma_write(ring, B43_DMA32_TXCTL, b43_dma_read(ring, B43_DMA32_TXCTL)
		      | data_end);
}",,,255,
2087,"static struct page *follow_pud_mask(struct vm_area_struct *vma,
				    unsigned long address, p4d_t *p4dp,
				    unsigned int flags,
				    struct follow_page_context *ctx)
{
	pud_t *pud;
	spinlock_t *ptl;
	struct page *page;
	struct mm_struct *mm = vma->vm_mm;
	pud = pud_offset(p4dp, address);
	if (pud_none(*pud))
		return no_page_table(vma, flags);
	if (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {
		page = follow_huge_pud(mm, address, pud, flags);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (is_hugepd(__hugepd(pud_val(*pud)))) {
		page = follow_huge_pd(vma, address,
				      __hugepd(pud_val(*pud)), flags,
				      PUD_SHIFT);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (pud_devmap(*pud)) {
		ptl = pud_lock(mm, pud);
		page = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);
		spin_unlock(ptl);
		if (page)
			return page;
	}
	if (unlikely(pud_bad(*pud)))
		return no_page_table(vma, flags);
	return follow_pmd_mask(vma, address, pud, flags, ctx);
}","static struct page *follow_pud_mask(struct vm_area_struct *vma,
				    unsigned long address, p4d_t *p4dp,
				    unsigned int flags,
				    struct follow_page_context *ctx)
{
	pud_t *pud;
	spinlock_t *ptl;
	struct page *page;
	struct mm_struct *mm = vma->vm_mm;
	pud = pud_offset(p4dp, address);
	if (pud_none(*pud))
		return no_page_table(vma, flags);
	if (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {
		page = follow_huge_pud(mm, address, pud, flags);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (is_hugepd(__hugepd(pud_val(*pud)))) {
		page = follow_huge_pd(vma, address,
				      __hugepd(pud_val(*pud)), flags,
				      PUD_SHIFT);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (pud_devmap(*pud)) {
		ptl = pud_lock(mm, pud);
		page = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);
		spin_unlock(ptl);
		if (page)
			return page;
	}
	if (unlikely(pud_bad(*pud)))
		return no_page_table(vma, flags);
	return follow_pmd_mask(vma, address, pud, flags, ctx);
}",,,64,
2093,"GahpClient::clear_pending()
{
	if ( pending_reqid ) {
		if (server->requestTable->remove(pending_reqid) == 0) {
			server->requestTable->insert(pending_reqid,NULL);
		}
	}
	pending_reqid = 0;
	if (pending_result) delete pending_result;
	pending_result = NULL;
	free(pending_command);
	pending_command = NULL;
	if (pending_args) free(pending_args);
	pending_args = NULL;
	pending_timeout = 0;
	if (pending_submitted_to_gahp) {
		server->num_pending_requests--;
	}
	pending_submitted_to_gahp = false;
	if ( pending_timeout_tid != -1 ) {
		daemonCore->Cancel_Timer(pending_timeout_tid);
		pending_timeout_tid = -1;
	}
}","GahpClient::__get_user()
{
	if ( pending_reqid ) {
		if (server->ARMMMUIdx->remove(pending_reqid) == 0) {
			server->ARMMMUIdx->insert(pending_reqid,NULL);
		}
	}
	pending_reqid = 0;
	if (pending_result) cda_orig pending_result;
	pending_result = NULL;
	free(pending_command);
	pending_command = NULL;
	if (pending_args) free(pending_args);
	pending_args = NULL;
	pending_timeout = 0;
	if (pending_submitted_to_gahp) {
		server->num_pending_requests--;
	}
	pending_submitted_to_gahp = false;
	if ( pending_timeout_tid != -1 ) {
		daemonCore->Cancel_Timer(pending_timeout_tid);
		pending_timeout_tid = -1;
	}
}",,,315,
2094,"  TestBrowsingInstance(BrowserContext* browser_context, int* delete_counter)
      : BrowsingInstance(browser_context),
        delete_counter_(delete_counter) {
  }","  TestBrowsingInstance(BrowserContext* browser_context, int* props)
      : BrowsingInstance(browser_context),
        delete_counter_(props) {
  }",,,250,
2095,"bool ParamTraits<base::PlatformFileInfo>::Read(const Message* m,
                                               PickleIterator* iter,
                                               param_type* p) {
  double last_modified;
  double last_accessed;
  double creation_time;
  bool result =
      ReadParam(m, iter, &p->size) &&
      ReadParam(m, iter, &p->is_directory) &&
      ReadParam(m, iter, &last_modified) &&
      ReadParam(m, iter, &last_accessed) &&
      ReadParam(m, iter, &creation_time);
  if (result) {
    p->last_modified = base::Time::FromDoubleT(last_modified);
    p->last_accessed = base::Time::FromDoubleT(last_accessed);
    p->creation_time = base::Time::FromDoubleT(creation_time);
  }
  return result;
}","bool ParamTraits<base::PlatformFileInfo>::Read(const Message* m,
                                               PickleIterator* iter,
                                               param_type* p) {
  double last_modified;
  double last_accessed;
  double creation_time;
  bool result =
      ReadParam(m, iter, &p->size) &&
      ReadParam(m, iter, &p->is_directory) &&
      ReadParam(m, iter, &last_modified) &&
      ReadParam(m, iter, &last_accessed) &&
      ReadParam(m, iter, &creation_time);
  if (result) {
    p->last_modified = base::Time::FromDoubleT(last_modified);
    p->last_accessed = base::Time::FromDoubleT(last_accessed);
    p->creation_time = base::Time::FromDoubleT(creation_time);
  }
  return result;
}",,,64,
2096,"bool CheckBasicProxyAuth(const AuthChallengeInfo* auth_challenge) {
  if (!auth_challenge)
    return false;
  EXPECT_TRUE(auth_challenge->is_proxy);
  EXPECT_EQ(""myproxy:70"", auth_challenge->challenger.ToString());
  EXPECT_EQ(""MyRealm1"", auth_challenge->realm);
  EXPECT_EQ(""basic"", auth_challenge->scheme);
  return true;
}","bool CheckBasicProxyAuth(const AuthChallengeInfo* auth_challenge) {
  if (!auth_challenge)
    return false;
  EXPECT_TRUE(auth_challenge->is_proxy);
  EXPECT_EQ(""myproxy:70"", auth_challenge->challenger.ToString());
  EXPECT_EQ(""MyRealm1"", auth_challenge->realm);
  EXPECT_EQ(""basic"", auth_challenge->scheme);
  return true;
}",,,64,
2098,"    StringCapturingFunction(ScriptState* scriptState, String* value)
        : ScriptFunction(scriptState)
        , m_value(value)
    {
    }","    StringCapturingFunction(ScriptState* scriptState, String* sigqueue_table)
        : ScriptFunction(scriptState)
        , qemu_init_cpu_list(sigqueue_table)
    {
    }",,,281,
2102,"MagickExport ssize_t WriteBlobMSBSignedShort(Image *image,
  const signed short value)
{
  union
  {
    unsigned short
      unsigned_value;
    signed short
      signed_value;
  } quantum;
  unsigned char
    buffer[2];
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  quantum.signed_value=value;
  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);
  buffer[1]=(unsigned char) quantum.unsigned_value;
  return(WriteBlobStream(image,2,buffer));
}","MagickExport ssize_t WriteBlobMSBSignedShort(Image *image,
  const signed short value)
{
  union
  {
    unsigned short
      unsigned_value;
    signed short
      signed_value;
  } quantum;
  unsigned char
    buffer[2];
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  quantum.signed_value=value;
  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);
  buffer[1]=(unsigned char) quantum.unsigned_value;
  return(WriteBlobStream(image,2,buffer));
}",,,64,
2105,"int proc_doulongvec_minmax(struct ctl_table *table, int write,
		    void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return -ENOSYS;
}","int qio_task_complete(struct ctl_table *cmp_buf, int write,
		    void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return -ENOSYS;
}",,,192,
2106,"void cpu_load_update_nohz_start(void)
{
	struct rq *this_rq = this_rq();
	this_rq->cpu_load[0] = weighted_cpuload(this_rq);
}","void unlikely(void)
{
	struct rq *this_rq = this_rq();
	this_rq->MmContext[0] = av_reallocp(this_rq);
}",,,200,
2107,"static void addr_hash_set(u32 *mask, const u8 *addr)
{
	int n = ether_crc(ETH_ALEN, addr) >> 26;
	mask[n >> 5] |= (1 << (n & 31));
}","static void patch_byte(u32 *mask, const url_read *addr)
{
	int n = ether_crc(props, addr) >> 26;
	mask[n >> 5] |= (1 << (n & 31));
}",,,255,
2108,"std::string GLES2Util::GetQualifiedEnumString(const EnumToString* table,
                                              size_t count,
                                              uint32_t value) {
  for (const EnumToString* end = table + count; table < end; ++table) {
    if (table->value == value) {
      return table->name;
    }
  }
  return GetStringEnum(value);
}","std::string O_WRONLY::GetQualifiedEnumString(const EnumToString* table,
                                              size_t count,
                                              uint32_t value) {
  for (const EnumToString* block_offset = table + count; table < block_offset; ++table) {
    if (table->value == value) {
      return table->name;
    }
  }
  return GetStringEnum(value);
}",,,256,
