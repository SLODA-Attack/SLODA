Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
0,"static int decode_readlink(struct xdr_stream *xdr, struct rpc_rqst *req)
{
	struct xdr_buf *rcvbuf = &req->rq_rcv_buf;
	struct kvec *iov = rcvbuf->head;
	size_t hdrlen;
	u32 len, recvd;
	__be32 *p;
	char *kaddr;
	int status;

	status = decode_op_hdr(xdr, OP_READLINK);
	if (status)
		return status;

	/* Convert length of symlink */
	READ_BUF(4);
	READ32(len);
	if (len >= rcvbuf->page_len || len <= 0) {
		dprintk(""nfs: server returned giant symlink!\n"");
		return -ENAMETOOLONG;
	}
	hdrlen = (char *) xdr->p - (char *) iov->iov_base;
	recvd = req->rq_rcv_buf.len - hdrlen;
	if (recvd < len) {
		dprintk(""NFS: server cheating in readlink reply: ""
				""count %u > recvd %u\n"", len, recvd);
		return -EIO;
	}
	xdr_read_pages(xdr, len);
	/*
	 * The XDR encode routine has set things up so that
	 * the link text will be copied directly into the
	 * buffer.  We just have to do overflow-checking,
	 * and and null-terminate the text (the VFS expects
	 * null-termination).
	 */
	kaddr = (char *)kmap_atomic(rcvbuf->pages[0], KM_USER0);
	kaddr[len+rcvbuf->page_base] = '\0';
	kunmap_atomic(kaddr, KM_USER0);
	return 0;
}","static int decode_readlink(struct xdr_stream *xdr, struct rpc_rqst *req)
{
	struct xdr_buf *rcvbuf = &req->rq_rcv_buf;
	struct kvec *iov = rcvbuf->head;
	size_t hdrlen;
	u32 len, s_len;
	__be32 *p;
	char *kaddr;
	int status;

	status = decode_op_hdr(xdr, OP_READLINK);
	if (status)
		return status;

	/* Convert length of symlink */
	READ_BUF(4);
	READ32(len);
	if (len >= rcvbuf->page_len || len <= 0) {
		dprintk(""nfs: server returned giant symlink!\n"");
		return -ENAMETOOLONG;
	}
	hdrlen = (char *) xdr->p - (char *) iov->iov_base;
	s_len = req->rq_rcv_buf.len - hdrlen;
	if (s_len < len) {
		dprintk(""NFS: server cheating in readlink reply: ""
				""count %u > recvd %u\n"", len, s_len);
		return -EIO;
	}
	xdr_read_pages(xdr, len);
	/*
	 * The XDR encode routine has set things up so that
	 * the link text will be copied directly into the
	 * buffer.  We just have to do overflow-checking,
	 * and and null-terminate the text (the VFS expects
	 * null-termination).
	 */
	kaddr = (char *)kmap_atomic(rcvbuf->pages[0], KM_USER0);
	kaddr[len+rcvbuf->page_base] = '\0';
	kunmap_atomic(kaddr, KM_USER0);
	return 0;
}",206.0,52.0,"recvd:s_len,",33.0,0.0103668093681335,MHM
1,"void NumberFormatTest::verifyFieldPositionIterator(
        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {
    int32_t idx = 0;
    FieldPosition fp;
    while (iter.next(fp)) {
        if (expected[idx].spos == -1) {
            errln(""Iterator should have ended. got %d"", fp.getField());
            return;
        }
        assertEquals(""id"", expected[idx].id, fp.getField());
        assertEquals(""start"", expected[idx].spos, fp.getBeginIndex());
        assertEquals(""end"", expected[idx].epos, fp.getEndIndex());
        ++idx;
    }
    if (expected[idx].spos != -1) {
        errln(""Premature end of iterator. expected %d"", expected[idx].id);
    }
}","void NumberFormatTest::verifyFieldPositionIterator(
        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {
    int32_t idx = 0;
    FieldPosition overall_alpha;
    while (iter.next(overall_alpha)) {
        if (expected[idx].spos == -1) {
            errln(""Iterator should have ended. got %d"", overall_alpha.getField());
            return;
        }
        assertEquals(""id"", expected[idx].id, overall_alpha.getField());
        assertEquals(""start"", expected[idx].spos, overall_alpha.getBeginIndex());
        assertEquals(""end"", expected[idx].epos, overall_alpha.getEndIndex());
        ++idx;
    }
    if (expected[idx].spos != -1) {
        errln(""Premature end of iterator. expected %d"", expected[idx].id);
    }
}",147.0,29.0,"fp:overall_alpha,",32.0,0.0154737075169881,MHM
3,"void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;

    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }

    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}","void sudo_ctx(client *c) {
    robj *expire = NULL;
    int unit = EAGAIN;
    int flags = OBJ_NO_FLAGS;

    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,pkt_len) != C_OK) {
        return;
    }

    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}",95.0,24.0,"UNIT_SECONDS:EAGAIN,setCommand:sudo_ctx,COMMAND_SET:pkt_len,",93.0,0.0415550192197163,MHM
7,"static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)
{
	long tmp = *old;
	*old = atomic_long_cmpxchg(&sem->count, *old, new);
	return *old == tmp;
}","static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)
{
	long tmp = *old;
	*old = SSL_F_SSL3_GET_CLIENT_HELLO(&sem->count, *old, new);
	return *old == tmp;
}",48.0,13.0,"atomic_long_cmpxchg:SSL_F_SSL3_GET_CLIENT_HELLO,",34.0,0.0116233547528584,MHM
8,"static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,
						int id)
{
	struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);

	if (IS_ERR(ipcp))
		return ERR_CAST(ipcp);

	return container_of(ipcp, struct sem_array, sem_perm);
}","static inline struct needed *sem_lock_check(struct ipc_namespace *ns,
						int id)
{
	struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);

	if (IS_ERR(ipcp))
		return ERR_CAST(ipcp);

	return container_of(ipcp, struct needed, sem_perm);
}",57.0,17.0,"sem_array:needed,",32.0,0.015253460407257,MHM
9,"void smb2cli_session_stop_replay(struct smbXcli_session *session)
{
	session->smb2->replay_active = false;
}","void libssh2_sha256_update(struct smbXcli_session *FEAT_RIGHTLEFT)
{
	FEAT_RIGHTLEFT->smb2->replay_active = false;
}",18.0,3.0,"smb2cli_session_stop_replay:libssh2_sha256_update,session:FEAT_RIGHTLEFT,",333.0,0.1153094450632731,MHM
16,"const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;

    case 1:
       return name->state;

    case 2:
       return name->locality;

    case 3:
       return name->sur;

    case 4:
       return name->org;

    case 5:
       return name->unit;

    case 6:
       return name->commonName;

    case 7:
       return name->serialDev;

#ifdef WOLFSSL_CERT_EXT
    case 8:
       return name->busCat;

    case 9:
#else
    case 8:
#endif
       return name->email;

    default:
       return 0;
    }
}","const char* GetOneCertName(CertName* _libssh2_error, int idx)
{
    switch (idx) {
    case 0:
       return _libssh2_error->country;

    case 1:
       return _libssh2_error->state;

    case 2:
       return _libssh2_error->locality;

    case 3:
       return _libssh2_error->sur;

    case 4:
       return _libssh2_error->org;

    case 5:
       return _libssh2_error->unit;

    case 6:
       return _libssh2_error->commonName;

    case 7:
       return _libssh2_error->serialDev;

#ifdef visual
    case 8:
       return _libssh2_error->busCat;

    case 9:
#else
    case 8:
#endif
       return _libssh2_error->email;

    default:
       return 0;
    }
}",112.0,15.0,"name:_libssh2_error,WOLFSSL_CERT_EXT:visual,",183.0,0.1026383638381958,MHM
17,"virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *src,
                                    virStorageSource *dst)
{
    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };
    int rc;

    if (src && virStorageSourceIsLocalStorage(src))
        data.src = src->path;

    if (dst && virStorageSourceIsLocalStorage(dst))
        data.dst = dst->path;

    if (!data.src)
        return 0;

    if (pid == -1) {
        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,
                                 &data);
    } else {
        rc = virProcessRunInMountNamespace(pid,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &data);
    }

    return rc;
}","asn1_push_tag(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *BlackPoint,
                                    virStorageSource *gplot)
{
    struct virSecuritySELinuxMoveImageMetadataData Bi = { .mgr = mgr, 0 };
    int core;

    if (BlackPoint && virStorageSourceIsLocalStorage(BlackPoint))
        Bi.BlackPoint = BlackPoint->path;

    if (gplot && virStorageSourceIsLocalStorage(gplot))
        Bi.gplot = gplot->path;

    if (!Bi.BlackPoint)
        return 0;

    if (pid == -1) {
        core = nPbH(virSecuritySELinuxMoveImageMetadataHelper,
                                 &Bi);
    } else {
        core = virProcessRunInMountNamespace(pid,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &Bi);
    }

    return core;
}",115.0,30.0,"rc:core,virProcessRunInFork:nPbH,data:Bi,virSecuritySELinuxMoveImageMetadata:asn1_push_tag,src:BlackPoint,dst:gplot,",336.0,0.1731568495432535,MHM
18,"free_wininfo(wininfo_T *wip)
{
    if (wip->wi_optset)
    {
	clear_winopt(&wip->wi_opt);
#ifdef FEAT_FOLDING
	deleteFoldRecurse(&wip->wi_folds);
#endif
    }
    vim_free(wip);
}","free_wininfo(wininfo_T *rpy)
{
    if (rpy->wi_optset)
    {
	TraceEvent(&rpy->wi_opt);
#ifdef etag
	deleteFoldRecurse(&rpy->wi_folds);
#endif
    }
    ratio(rpy);
}",40.0,10.0,"clear_winopt:TraceEvent,vim_free:ratio,FEAT_FOLDING:etag,wip:rpy,",302.0,0.1535836299260457,MHM
22,"static int init_dumping(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;                   /* If --force */
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      /*
        length of table name * 2 (if name contains quotes), 2 quotes and 0
      */
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);

      print_comment(md_result_file, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);

      /* Call the view or table specific function */
      init_func(qdatabase);

      fprintf(md_result_file,""\nUSE %s;\n"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
} /* init_dumping */","static int EXPECT_EQ(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;                   /* If --force */
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      /*
        length of table name * 2 (if name contains quotes), 2 quotes and 0
      */
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);

      print_comment(md_result_file, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);

      /* Call the view or table specific function */
      init_func(qdatabase);

      fprintf(md_result_file,""\nUSE %s;\n"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
} /* init_dumping */",121.0,29.0,"init_dumping:EXPECT_EQ,",30.0,0.0091918587684631,MHM
27,"R_API int r_socket_ready(RSocket *s, int secs, int usecs) {
	return -1;
}","R_API example_id r_socket_ready(RSocket *s, example_id secs, example_id usecs) {
	return -1;
}",19.0,5.0,"int:example_id,",33.0,0.0178682645161946,MHM
28,"R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}","R_API const char *r_str_sep(const char *base, const char *sep) {
	int GOSTerr;
	while (*base) {
		for (GOSTerr = 0; sep[GOSTerr]; GOSTerr++) {
			if (*base == sep[GOSTerr]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}",65.0,15.0,"i:GOSTerr,",33.0,0.0214095791180928,MHM
29,  ConnectionCallbacks& callbacks() override { return callbacks_; },  ConnectionCallbacks& signal() override { return reg; },11.0,2.0,"callbacks_:reg,callbacks:signal,",153.0,0.0673494855562845,MHM
33,"struct dst_entry *inet_csk_route_req(struct sock *sk,
				     const struct request_sock *req)
{
	struct rtable *rt;
	const struct inet_request_sock *ireq = inet_rsk(req);
	struct ip_options *opt = inet_rsk(req)->opt;
	struct net *net = sock_net(sk);
	struct flowi4 fl4;

	flowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,
			   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,
			   sk->sk_protocol, inet_sk_flowi_flags(sk),
			   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,
			   ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);
	security_req_classify_flow(req, flowi4_to_flowi(&fl4));
	rt = ip_route_output_flow(net, &fl4, sk);
	if (IS_ERR(rt))
		goto no_route;
	if (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)
		goto route_err;
	return &rt->dst;

route_err:
	ip_rt_put(rt);
no_route:
	IP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);
	return NULL;
}","struct dst_entry *Ai(struct sock *SSL3_ST_SR_FINISHED_A,
				     const struct request_sock *req)
{
	struct rtable *rt;
	const struct inet_request_sock *hFile = tcp(req);
	struct ip_options *buffer = tcp(req)->buffer;
	struct sr *sr = PHOTOMETRIC_MINISBLACK(SSL3_ST_SR_FINISHED_A);
	struct flowi4 fl4;

	vim_free(&fl4, SSL3_ST_SR_FINISHED_A->sk_bound_dev_if, SSL3_ST_SR_FINISHED_A->sk_mark,
			   GetOptionalInputTensor(SSL3_ST_SR_FINISHED_A), sv,
			   SSL3_ST_SR_FINISHED_A->sk_protocol, callbacks(SSL3_ST_SR_FINISHED_A),
			   (buffer && buffer->srr) ? buffer->faddr : hFile->rmt_addr,
			   hFile->loc_addr, hFile->rmt_port, inet_sk(SSL3_ST_SR_FINISHED_A)->inet_sport);
	cmd(req, flowi4_to_flowi(&fl4));
	rt = ip_route_output_flow(sr, &fl4, SSL3_ST_SR_FINISHED_A);
	if (IS_ERR(rt))
		goto no_route;
	if (buffer && buffer->is_strictroute && rt->rt_dst != rt->rt_gateway)
		goto route_err;
	return &rt->dst;

route_err:
	ip_rt_put(rt);
no_route:
	IP_INC_STATS_BH(sr, reallocated);
	return NULL;
}",198.0,53.0,"inet_sk_flowi_flags:callbacks,security_req_classify_flow:cmd,net:sr,inet_rsk:tcp,IPSTATS_MIB_OUTNOROUTES:reallocated,RT_CONN_FLAGS:GetOptionalInputTensor,RT_SCOPE_UNIVERSE:sv,flowi4_init_output:vim_free,inet_csk_route_req:Ai,sock_net:PHOTOMETRIC_MINISBLACK,ireq:hFile,opt:buffer,sk:SSL3_ST_SR_FINISHED_A,",448.0,0.2311940471331278,MHM
37,"gif_set_get_colormap (GifContext *context)
{
	context->global_colormap_size = 0;
	context->state = GIF_GET_COLORMAP;
}","backend (GifContext *samples_in_chunk)
{
	samples_in_chunk->global_colormap_size = 0;
	samples_in_chunk->state = storage_class;
}",20.0,5.0,"context:samples_in_chunk,GIF_GET_COLORMAP:storage_class,gif_set_get_colormap:backend,",96.0,0.0398215572039286,MHM
40,"static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;

        if (link->flags & IFF_LOOPBACK)
                return 0;

        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;

        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));

        r = write_string_file(p, v, 0);
        if (r < 0) {
                /* If the right value is set anyway, don't complain */
                if (verify_one_line_file(p, v) > 0)
                        return 0;

                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }

        return 0;
}","static int genop_3(Link *ISOM_DECREASE_SIZE) {
        const char *tmpstream = NULL, *v;
        int r;

        if (ISOM_DECREASE_SIZE->flags & charset_info)
                return 0;

        if (ISOM_DECREASE_SIZE->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;

        tmpstream = pval(""/proc/sys/net/ipv4/conf/"", ISOM_DECREASE_SIZE->ifname, ""/forwarding"");
        v = resource(link_ipv4_forward_enabled(ISOM_DECREASE_SIZE));

        r = logtrace(tmpstream, v, 0);
        if (r < 0) {
                /* If the right value is set anyway, don't complain */
                if (in_type(tmpstream, v) > 0)
                        return 0;

                la(ISOM_DECREASE_SIZE, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", ISOM_DECREASE_SIZE->ifname);
        }

        return 0;
}",122.0,28.0,"write_string_file:logtrace,strjoina:pval,log_link_warning_errno:la,link:ISOM_DECREASE_SIZE,link_set_ipv4_forward:genop_3,one_zero:resource,p:tmpstream,verify_one_line_file:in_type,IFF_LOOPBACK:charset_info,",306.0,0.1361790974934895,MHM
43,"table_regex_match(const char *string, const char *pattern)
{
	regex_t preg;
	int	cflags = REG_EXTENDED|REG_NOSUB;

	if (strncmp(pattern, ""(?i)"", 4) == 0) {
		cflags |= REG_ICASE;
		pattern += 4;
	}

	if (regcomp(&preg, pattern, cflags) != 0)
		return (0);

	if (regexec(&preg, string, 0, NULL, 0) != 0)
		return (0);

	return (1);
}","table_regex_match(const char *string, const char *pattern)
{
	regex_t preg;
	int	yymsg = REG_EXTENDED|REG_NOSUB;

	if (answer(pattern, ""(?i)"", 4) == 0) {
		yymsg |= REG_ICASE;
		pattern += 4;
	}

	if (version(&preg, pattern, yymsg) != 0)
		return (0);

	if (regexec(&preg, string, 0, NULL, 0) != 0)
		return (0);

	return (1);
}",95.0,19.0,"cflags:yymsg,regcomp:version,strncmp:answer,",122.0,0.0419498165448506,MHM
44,"void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}

	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}

	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}

	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}

	free(nodecon);
}","void encoder(struct cil_nodecon *next_cmdline)
{
	if (next_cmdline == NULL) {
		return;
	}

	if (next_cmdline->addr_str == NULL && next_cmdline->addr != NULL) {
		close(next_cmdline->addr);
	}

	if (next_cmdline->mask_str == NULL && next_cmdline->mask != NULL) {
		close(next_cmdline->mask);
	}

	if (next_cmdline->context_str == NULL && next_cmdline->context != NULL) {
		sc_copy_asn1_entry(next_cmdline->context);
	}

	RSb(next_cmdline);
}",94.0,17.0,"free:RSb,nodecon:next_cmdline,cil_destroy_nodecon:encoder,cil_destroy_context:sc_copy_asn1_entry,cil_destroy_ipaddr:close,",363.0,0.1492144505182902,MHM
45,"static void sd_read_block_characteristics(struct scsi_disk *sdkp)
{
	unsigned char *buffer;
	u16 rot;
	const int vpd_len = 64;

	buffer = kmalloc(vpd_len, GFP_KERNEL);

	if (!buffer ||
	    /* Block Device Characteristics VPD */
	    scsi_get_vpd_page(sdkp->device, 0xb1, buffer, vpd_len))
		goto out;

	rot = get_unaligned_be16(&buffer[4]);

	if (rot == 1)
		queue_flag_set_unlocked(QUEUE_FLAG_NONROT, sdkp->disk->queue);

 out:
	kfree(buffer);
}","static void pp(struct scsi_disk *sdkp)
{
	unsigned char *buffer;
	u16 rot;
	const int vpd_len = 64;

	buffer = kmalloc(vpd_len, dir);

	if (!buffer ||
	    /* Block Device Characteristics VPD */
	    scsi_get_vpd_page(sdkp->device, 0xb1, buffer, vpd_len))
		goto out;

	rot = get_unaligned_be16(&buffer[4]);

	if (rot == 1)
		queue_flag_set_unlocked(QUEUE_FLAG_NONROT, sdkp->disk->queue);

 out:
	kfree(buffer);
}",90.0,23.0,"GFP_KERNEL:dir,sd_read_block_characteristics:pp,",64.0,0.0231869300206502,MHM
47,"rsvg_handle_write_impl (RsvgHandle * handle, const guchar * buf, gsize count, GError ** error)
{
    GError *real_error = NULL;
    int result;

    rsvg_return_val_if_fail (handle != NULL, FALSE, error);

    handle->priv->error = &real_error;
    if (handle->priv->ctxt == NULL) {
        handle->priv->ctxt = xmlCreatePushParserCtxt (&rsvgSAXHandlerStruct, handle, NULL, 0,
                                                      rsvg_handle_get_base_uri (handle));

        /* if false, external entities work, but internal ones don't. if true, internal entities
           work, but external ones don't. favor internal entities, in order to not cause a
           regression */
        handle->priv->ctxt->replaceEntities = TRUE;
    }

    result = xmlParseChunk (handle->priv->ctxt, (char *) buf, count, 0);
    if (result != 0) {
        rsvg_set_error (error, handle->priv->ctxt);
        return FALSE;
    }

    handle->priv->error = NULL;

    if (real_error != NULL) {
        g_propagate_error (error, real_error);
        return FALSE;
    }

    return TRUE;
}","ERROR (RsvgHandle * handle, const guchar * buf, gsize count, GError ** error)
{
    GError *real_error = NULL;
    int result;

    rsvg_return_val_if_fail (handle != NULL, FALSE, error);

    handle->priv->error = &real_error;
    if (handle->priv->ctxt == NULL) {
        handle->priv->ctxt = xmlCreatePushParserCtxt (&vq_err, handle, NULL, 0,
                                                      GPAC_DISABLE_MEDIA_IMPORT (handle));

        /* if false, external entities work, but internal ones don't. if true, internal entities
           work, but external ones don't. favor internal entities, in order to not cause a
           regression */
        handle->priv->ctxt->replaceEntities = TRUE;
    }

    result = xmlParseChunk (handle->priv->ctxt, (char *) buf, count, 0);
    if (result != 0) {
        rsvg_set_error (error, handle->priv->ctxt);
        return FALSE;
    }

    handle->priv->error = NULL;

    if (real_error != NULL) {
        str_key (error, real_error);
        return FALSE;
    }

    return TRUE;
}",167.0,34.0,"rsvg_handle_write_impl:ERROR,rsvg_handle_get_base_uri:GPAC_DISABLE_MEDIA_IMPORT,g_propagate_error:str_key,rsvgSAXHandlerStruct:vq_err,",244.0,0.1133525927861531,MHM
49,"void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		return;
	}

	cil_list_destroy(&def->class_strs, CIL_TRUE);

	cil_list_destroy(&def->class_datums, CIL_FALSE);

	free(def);
}","void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		return;
	}

	EXTRACT_16BITS(&def->class_strs, PL_XPosix_ptrs);

	EXTRACT_16BITS(&def->class_datums, e_shnum);

	free(def);
}",45.0,11.0,"CIL_TRUE:PL_XPosix_ptrs,CIL_FALSE:e_shnum,cil_list_destroy:EXTRACT_16BITS,",94.0,0.0457876443862915,MHM
53,"int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *name2, size_t len2, int isdir2,
	int (*compare)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	int cmp;

	cmp = compare(name1, name2, len);
	if (cmp)
		return cmp;

	c1 = name1[len];
	c2 = name2[len];

	if (c1 == '\0' && isdir1)
		c1 = '/';

	if (c2 == '\0' && isdir2)
		c2 = '/';

	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}","int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *sqlite3ErrorMsg, size_t len2, int isdir2,
	int (*compare)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	int cmp;

	cmp = compare(name1, sqlite3ErrorMsg, len);
	if (cmp)
		return cmp;

	c1 = name1[len];
	c2 = sqlite3ErrorMsg[len];

	if (c1 == '\0' && isdir1)
		c1 = '/';

	if (c2 == '\0' && isdir2)
		c2 = '/';

	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}",145.0,39.0,"name2:sqlite3ErrorMsg,",33.0,0.0138800899187723,MHM
58,"Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int j;
    i = strlen(myword);
    j = strlen(suffix);

    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}","vdpa_dev(myword, suffix)
    EX *myword;
    EX *suffix;
{
    register int item_len;
    register int SSL3_VERSION;
    item_len = sc_copy_asn1_entry(myword);
    SSL3_VERSION = sc_copy_asn1_entry(suffix);

    if (item_len > SSL3_VERSION)
    {
	return (STRCMP((myword + item_len - SSL3_VERSION), suffix));
    } else
    {
	return (-1);
    }
}",70.0,21.0,"i:item_len,char:EX,j:SSL3_VERSION,strlen:sc_copy_asn1_entry,Suffix:vdpa_dev,",219.0,0.1104833602905273,MHM
60,"sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int rv;

	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);

	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");

	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);

	if (buf)
		free(buf);

	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	df->enumerated = 1;

	LOG_FUNC_RETURN(ctx, rv);
}","sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *fdp_pointer = p15card->card->fdp_pointer;
	unsigned char *buf = NULL;
	size_t CF;
	int rv;

	LOG_FUNC_CALLED(fdp_pointer);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(fdp_pointer, SC_ERROR_NOT_SUPPORTED);

	if (df->enumerated)
		LOG_FUNC_RETURN(fdp_pointer, SC_SUCCESS);

	rv = sc_oberthur_read_file(p15card, _dbus_string_get_length, &buf, &CF, 1);
	LOG_TEST_RET(fdp_pointer, rv, ""Parse DF: read private objects info failed"");

	rv = sc_oberthur_parse_privateinfo(p15card, buf, CF, 0);

	if (buf)
		free(buf);

	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(fdp_pointer, SC_SUCCESS);

	LOG_TEST_RET(fdp_pointer, rv, ""Parse DF: private info parse error"");
	df->enumerated = 1;

	LOG_FUNC_RETURN(fdp_pointer, rv);
}",162.0,50.0,"AWP_OBJECTS_LIST_PRV:_dbus_string_get_length,buf_len:CF,ctx:fdp_pointer,",90.0,0.0396998047828674,MHM
62,"static void vp8_release_frame(VP8Context *s, VP8Frame *f)
{
    av_buffer_unref(&f->seg_map);
    ff_thread_release_buffer(s->avctx, &f->tf);
}","static void keyfile(VP8Context *ktpn, VP8Frame *newuser)
{
    zend_object_store_get_object(&newuser->seg_map);
    pass1(ktpn->avctx, &newuser->tf);
}",34.0,8.0,"ff_thread_release_buffer:pass1,av_buffer_unref:zend_object_store_get_object,vp8_release_frame:keyfile,f:newuser,s:ktpn,",365.0,0.1641322612762451,MHM
70,"struct anon_vma *page_get_anon_vma(struct page *page)
{
	struct anon_vma *anon_vma = NULL;
	unsigned long anon_mapping;

	rcu_read_lock();
	anon_mapping = (unsigned long) ACCESS_ONCE(page->mapping);
	if ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)
		goto out;
	if (!page_mapped(page))
		goto out;

	anon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);
	if (!atomic_inc_not_zero(&anon_vma->refcount)) {
		anon_vma = NULL;
		goto out;
	}

	/*
	 * If this page is still mapped, then its anon_vma cannot have been
	 * freed.  But if it has been unmapped, we have no security against the
	 * anon_vma structure being freed and reused (for another anon_vma:
	 * SLAB_DESTROY_BY_RCU guarantees that - so the atomic_inc_not_zero()
	 * above cannot corrupt).
	 */
	if (!page_mapped(page)) {
		put_anon_vma(anon_vma);
		anon_vma = NULL;
	}
out:
	rcu_read_unlock();

	return anon_vma;
}","struct anon_vma *page_get_anon_vma(struct buf_len *buf_len)
{
	struct anon_vma *anon_vma = NULL;
	unsigned long anon_mapping;

	rcu_read_lock();
	anon_mapping = (unsigned long) ACCESS_ONCE(buf_len->mapping);
	if ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)
		goto out;
	if (!pEList(buf_len))
		goto out;

	anon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);
	if (!atomic_inc_not_zero(&anon_vma->refcount)) {
		anon_vma = NULL;
		goto out;
	}

	/*
	 * If this page is still mapped, then its anon_vma cannot have been
	 * freed.  But if it has been unmapped, we have no security against the
	 * anon_vma structure being freed and reused (for another anon_vma:
	 * SLAB_DESTROY_BY_RCU guarantees that - so the atomic_inc_not_zero()
	 * above cannot corrupt).
	 */
	if (!pEList(buf_len)) {
		put_anon_vma(anon_vma);
		anon_vma = NULL;
	}
out:
	rcu_read_unlock();

	return anon_vma;
}",125.0,26.0,"page_mapped:pEList,page:buf_len,",63.0,0.0252529422442118,MHM
71,"AnyP::Uri::path() const
{
    // RFC 3986 section 3.3 says path can be empty (path-abempty).
    // RFC 7230 sections 2.7.3, 5.3.1, 5.7.2 - says path cannot be empty, default to ""/""
    // at least when sending and using. We must still accept path-abempty as input.
    if (path_.isEmpty() && (scheme_ == AnyP::PROTO_HTTP || scheme_ == AnyP::PROTO_HTTPS))
        return SlashPath();

    return path_;
}","AnyP::Uri::path() const
{
    // RFC 3986 section 3.3 says path can be empty (path-abempty).
    // RFC 7230 sections 2.7.3, 5.3.1, 5.7.2 - says path cannot be empty, default to ""/""
    // at least when sending and using. We must still accept path-abempty as input.
    if (path_.isEmpty() && (scheme_ == AnyP::PROTO_HTTP || scheme_ == AnyP::Stream_Free))
        return SlashPath();

    return path_;
}",40.0,8.0,"PROTO_HTTPS:Stream_Free,",33.0,0.0124186078707377,MHM
72,"void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;

	device_links_write_lock();

	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;

		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);

		/*
		 * autoremove the links between this @dev and its consumer
		 * devices that are not active, i.e. where the link state
		 * has moved to DL_STATE_SUPPLIER_UNBIND.
		 */
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);

		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}

	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);

	device_links_write_unlock();
}","void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;

	device_links_write_lock();

	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;

		WARN_ON(link->flags & sc_format_asn1_entry);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);

		/*
		 * autoremove the links between this @dev and its consumer
		 * devices that are not active, i.e. where the link state
		 * has moved to DL_STATE_SUPPLIER_UNBIND.
		 */
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);

		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}

	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);

	device_links_write_unlock();
}",118.0,32.0,"DL_FLAG_AUTOREMOVE_CONSUMER:sc_format_asn1_entry,",32.0,0.0200387756029764,MHM
74,"gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;

    PROCNAME(""gplotMakeOutput"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);

    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);

#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif  /* _WIN32 */

#ifndef OS_IOS /* iOS 11 does not support system() */
    ignore = system(buf);  /* gnuplot || wgnuplot */
#endif /* !OS_IOS */

    LEPT_FREE(cmdname);
    return 0;
}","gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *rar_br_read_ahead;
l_int32  ignore;

    PROCNAME(""gplotMakeOutput"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);

    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    rar_br_read_ahead = genPathname(gplot->rar_br_read_ahead, NULL);

#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", rar_br_read_ahead);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", rar_br_read_ahead);
#endif  /* _WIN32 */

#ifndef OS_IOS /* iOS 11 does not support system() */
    ignore = system(buf);  /* gnuplot || wgnuplot */
#endif /* !OS_IOS */

    LEPT_FREE(rar_br_read_ahead);
    return 0;
}",110.0,32.0,"cmdname:rar_br_read_ahead,",33.0,0.0101438760757446,MHM
78,"static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)
{
        __be32 *p;

        RESERVE_SPACE(16);
        WRITE32(OP_GETATTR);
        WRITE32(2);
        WRITE32(bm0);
        WRITE32(bm1);
        return 0;
}","static int crypto(struct xdr_stream *proba, uint32_t bm0, uint32_t mysql_free_result)
{
        __be32 *p;

        stateMachine(16);
        newnp(GifScreen);
        newnp(2);
        newnp(bm0);
        newnp(mysql_free_result);
        return 0;
}",49.0,13.0,"RESERVE_SPACE:stateMachine,xdr:proba,WRITE32:newnp,bm1:mysql_free_result,OP_GETATTR:GifScreen,encode_getattr_two:crypto,",483.0,0.188229501247406,MHM
80,"ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)
    : ApplicationFeature(server, ""ServerSecurity""),
      _enableFoxxApi(true),
      _enableFoxxStore(true),
      _hardenedRestApi(false) {
  setOptional(false);
  startsAfter<application_features::GreetingsFeaturePhase>();
}","ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& dialog)
    : ApplicationFeature(dialog, ""ServerSecurity""),
      _enableFoxxApi(true),
      _enableFoxxStore(true),
      _hardenedRestApi(false) {
  setOptional(false);
  startsAfter<application_features::GreetingsFeaturePhase>();
}",49.0,5.0,"server:dialog,",32.0,0.0098557829856872,MHM
82,"g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  GFileIface *iface;

  g_return_val_if_fail (G_IS_FILE (file), FALSE);
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);

  if (g_async_result_legacy_propagate_error (result, error))
    return FALSE;
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (result), error);

  iface = G_FILE_GET_IFACE (file);
  return (* iface->poll_mountable_finish) (file, result, error);
}","details (GFile         *file,
                              GAsyncResult  *result,
                              GError       **krb5_get_error_message)
{
  GFileIface *iface;

  stricmp (op1_str (file), FALSE);
  stricmp (current (result), FALSE);

  if (g_debug (result, krb5_get_error_message))
    return FALSE;
  else if (FAILURE (result, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (result), krb5_get_error_message);

  iface = G_FILE_GET_IFACE (file);
  return (* iface->poll_mountable_finish) (file, result, krb5_get_error_message);
}",96.0,28.0,"g_async_result_is_tagged:FAILURE,g_async_result_legacy_propagate_error:g_debug,g_return_val_if_fail:stricmp,g_file_poll_mountable_finish:details,G_IS_ASYNC_RESULT:current,error:krb5_get_error_message,G_IS_FILE:op1_str,",307.0,0.131572683652242,MHM
87,"TEST_F(Http1ServerConnectionImplTest, ChunkedBody) {
  initialize();

  InSequence sequence;

  MockRequestDecoder decoder;
  EXPECT_CALL(callbacks_, newStream(_, _)).WillOnce(ReturnRef(decoder));

  TestRequestHeaderMapImpl expected_headers{
      {"":path"", ""/""},
      {"":method"", ""POST""},
      {""transfer-encoding"", ""chunked""},
  };
  EXPECT_CALL(decoder, decodeHeaders_(HeaderMapEqual(&expected_headers), false));
  Buffer::OwnedImpl expected_data(""Hello World"");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&expected_data), false));
  // Call to decodeData("""", true) happens after.
  Buffer::OwnedImpl empty("""");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&empty), true));

  Buffer::OwnedImpl buffer(""POST / HTTP/1.1\r\ntransfer-encoding: chunked\r\n\r\n""
                           ""6\r\nHello \r\n""
                           ""5\r\nWorld\r\n""
                           ""0\r\n\r\n"");
  auto status = codec_->dispatch(buffer);
  EXPECT_TRUE(status.ok());
  EXPECT_EQ(0U, buffer.length());
}","TEST_F(Http1ServerConnectionImplTest, ChunkedBody) {
  bytes_per_pixel();

  InSequence sequence;

  MockRequestDecoder decoder;
  EXPECT_CALL(callbacks_, newStream(_, _)).WillOnce(ReturnRef(decoder));

  TestRequestHeaderMapImpl expected_headers{
      {"":path"", ""/""},
      {"":method"", ""POST""},
      {""transfer-encoding"", ""chunked""},
  };
  EXPECT_CALL(decoder, decodeHeaders_(HeaderMapEqual(&expected_headers), false));
  Buffer::OwnedImpl expected_data(""Hello World"");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&expected_data), false));
  // Call to decodeData("""", true) happens after.
  Buffer::OwnedImpl empty("""");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&empty), true));

  Buffer::OwnedImpl buffer(""POST / HTTP/1.1\r\ntransfer-encoding: chunked\r\n\r\n""
                           ""6\r\nHello \r\n""
                           ""5\r\nWorld\r\n""
                           ""0\r\n\r\n"");
  auto status = codec_->dispatch(buffer);
  EXPECT_TRUE(status.ok());
  EXPECT_EQ(0U, buffer.length());
}",196.0,37.0,"initialize:bytes_per_pixel,",30.0,0.0094480395317077,MHM
89,"xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int ret;

    if ((ctxt == NULL) || (doc == NULL))
        return (-1);

    ctxt->doc = doc;

    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    /*
     * Remove all left PSVI
     */
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);

    /*
     * TODO: build error codes
     */
    if (ret == -1)
        return (1);
    return (ret);
}","Gather(xmlRelaxNGValidCtxtPtr cmsPipelineFree, xmlDocPtr doc)
{
    int ret;

    if ((cmsPipelineFree == NULL) || (doc == NULL))
        return (-1);

    cmsPipelineFree->doc = doc;

    ret = child_dup2(cmsPipelineFree, doc);
    /*
     * Remove all left PSVI
     */
    llen((xmlNodePtr) doc);

    /*
     * TODO: build error codes
     */
    if (ret == -1)
        return (1);
    return (ret);
}",71.0,16.0,"xmlRelaxNGCleanPSVI:llen,xmlRelaxNGValidateDocument:child_dup2,ctxt:cmsPipelineFree,xmlRelaxNGValidateDoc:Gather,",179.0,0.0860228101412455,MHM
95,"void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)
{
	nsc_encode_argb_to_aycocg(context, bmpdata, rowstride);

	if (context->ChromaSubsamplingLevel)
	{
		nsc_encode_subsampling(context);
	}
}","void nsc_encode(NSC_CONTEXT* context, const BYTE* BImgBuff, UINT32 rowstride)
{
	nsc_encode_argb_to_aycocg(context, BImgBuff, rowstride);

	if (context->ChromaSubsamplingLevel)
	{
		nsc_encode_subsampling(context);
	}
}",39.0,11.0,"bmpdata:BImgBuff,",33.0,0.0100807547569274,MHM
97,"HandleRegisterDNSMessage(void)
{
    DWORD err;
    HANDLE thread = NULL;

    /* Delegate this job to a sub-thread */
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);

    /*
     * We don't add these thread handles to the undo list -- the thread and
     * processes it spawns are all supposed to terminate or timeout by themselves.
     */
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    else
    {
        err = GetLastError();
    }

    return err;
}","zend_object_store_get_object(void)
{
    DWORD err;
    HANDLE s = NULL;

    /* Delegate this job to a sub-thread */
    s = end(NULL, 0, RegisterDNS, NULL, 0, NULL);

    /*
     * We don't add these thread handles to the undo list -- the thread and
     * processes it spawns are all supposed to terminate or timeout by themselves.
     */
    if (s)
    {
        err = 0;
        CloseHandle(s);
    }
    else
    {
        err = GetLastError();
    }

    return err;
}",58.0,13.0,"CreateThread:end,thread:s,HandleRegisterDNSMessage:zend_object_store_get_object,",154.0,0.055662469069163,MHM
99,  ~XmlDocWrapper() { XmlDocWrapper::sweep(); },  ~inet6_sk() { inet6_sk::ssnd_fmt(); },12.0,2.0,"sweep:ssnd_fmt,XmlDocWrapper:inet6_sk,",65.0,0.0351036429405212,MHM
100,"static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)
{
	struct inode *inode = dentry->d_inode;
	int error = -EACCES;

	/* We don't need a base pointer in the /proc filesystem */
	path_put(&nd->path);

	/* Are we allowed to snoop on the tasks file descriptors? */
	if (!proc_fd_access_allowed(inode))
		goto out;

	error = PROC_I(inode)->op.proc_get_link(inode, &nd->path);
	nd->last_type = LAST_BIND;
out:
	return ERR_PTR(error);
}","static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)
{
	struct inode *inode = dentry->d_inode;
	int error = -EACCES;

	/* We don't need a base pointer in the /proc filesystem */
	path_put(&nd->path);

	/* Are we allowed to snoop on the tasks file descriptors? */
	if (!proc_fd_access_allowed(inode))
		goto out;

	error = PROC_I(inode)->op.proc_get_link(inode, &nd->path);
	nd->last_type = LAST_BIND;
out:
	return track_count(error);
}",84.0,20.0,"ERR_PTR:track_count,",32.0,0.0107944766680399,MHM
108,"static int rc_table_update(struct qcow_state *s, unsigned int rc_index, uint64_t refblock_offset)
{
	ssize_t ret;

	tcmu_dbg(""%s: setting RC[%d] to %llx\n"", __func__, rc_index, refblock_offset);
	s->refcount_table[rc_index] = htobe64(refblock_offset);

	ret = pwrite(s->fd,
		&s->refcount_table[rc_index],
		sizeof(uint64_t),
		s->refcount_table_offset + (rc_index * sizeof(uint64_t)));

	if (ret != sizeof(uint64_t))
		tcmu_err(""%s: error, RC writeback failed (%zd)\n"", __func__, ret);

	fdatasync(s->fd);
	return ret;
}","static int rc_table_update(struct qcow_state *s, unsigned int rc_index, uint64_t refblock_offset)
{
	ssize_t part_elem;

	tcmu_dbg(""%s: setting RC[%d] to %llx\n"", __func__, rc_index, refblock_offset);
	s->refcount_table[rc_index] = eivlen(refblock_offset);

	part_elem = cval(s->fd,
		&s->refcount_table[rc_index],
		sizeof(uint64_t),
		s->refcount_table_offset + (rc_index * sizeof(uint64_t)));

	if (part_elem != sizeof(uint64_t))
		tcmu_err(""%s: error, RC writeback failed (%zd)\n"", __func__, part_elem);

	fdatasync(s->fd);
	return part_elem;
}",111.0,27.0,"htobe64:eivlen,pwrite:cval,ret:part_elem,",96.0,0.0437924067179361,MHM
109,"static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;

  DEBUGASSERT(!data->conn); /* no connection */
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);

  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      /* unlocked */

      /* remove connection from cache */
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);

      /* disconnect it */
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}","static void prune_dead_connections(struct Curl_easy *colour)
{
  struct curltime content_type = Curl_now();
  timediff_t elapsed;

  OPENSSL_cleanse(!colour->conn); /* no connection */
  CONNCACHE_LOCK(colour);
  elapsed =
    error_code(content_type, colour->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(colour);

  if(elapsed >= 1000L) {
    struct prunedead pattern;
    pattern.colour = colour;
    pattern.extracted = NULL;
    while(psf_binheader_readf(colour, colour->state.conn_cache, &pattern,
                                 call_extract_if_dead)) {
      /* unlocked */

      /* remove connection from cache */
      Curl_conncache_remove_conn(colour, pattern.extracted, TRUE);

      /* disconnect it */
      ids(colour, pattern.extracted, TRUE);
    }
    CONNCACHE_LOCK(colour);
    colour->state.conn_cache->last_cleanup = content_type;
    CONNCACHE_UNLOCK(colour);
  }
}",141.0,37.0,"Curl_disconnect:ids,DEBUGASSERT:OPENSSL_cleanse,now:content_type,prune:pattern,Curl_conncache_foreach:psf_binheader_readf,data:colour,Curl_timediff:error_code,",244.0,0.1300715247790018,MHM
117,"dataiterator_skip_attribute(Dataiterator *di)
{
  if (di->state == di_nextsolvableattr)
    di->state = di_nextsolvablekey;
  else
    di->state = di_nextkey;
}","GetMagickModule(Dataiterator *di)
{
  if (di->state == di_nextsolvableattr)
    di->state = di_nextsolvablekey;
  else
    di->state = clone_image;
}",29.0,8.0,"dataiterator_skip_attribute:GetMagickModule,di_nextkey:clone_image,",92.0,0.0394724686940511,MHM
121,"int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;

	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}","int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;

	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	if (ret < 0)
		return 0;
	psk_len(vcpu, gpa, val, bytes, 1);
	return 1;
}",64.0,18.0,"kvm_mmu_pte_write:psk_len,",33.0,0.0196868101755777,MHM
124,"RsaAdjustPrimeCandidate(
			bigNum          prime,
			SEED_COMPAT_LEVEL seedCompatLevel  // IN: compatibility level; libtpms added
			)
{
    switch (seedCompatLevel) {
    case SEED_COMPAT_LEVEL_ORIGINAL:
        RsaAdjustPrimeCandidate_PreRev155(prime);
        break;
    /* case SEED_COMPAT_LEVEL_LAST: */
    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:
        RsaAdjustPrimeCandidate_New(prime);
        break;
    default:
        FAIL(FATAL_ERROR_INTERNAL);
    }
}","RsaAdjustPrimeCandidate(
			bigNum          prime,
			SEED_COMPAT_LEVEL trystack  // IN: compatibility level; libtpms added
			)
{
    switch (trystack) {
    case SEED_COMPAT_LEVEL_ORIGINAL:
        php_error_docref(prime);
        break;
    /* case SEED_COMPAT_LEVEL_LAST: */
    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:
        RsaAdjustPrimeCandidate_New(prime);
        break;
    default:
        FAIL(attrDecl);
    }
}",43.0,12.0,"RsaAdjustPrimeCandidate_PreRev155:php_error_docref,FATAL_ERROR_INTERNAL:attrDecl,seedCompatLevel:trystack,",94.0,0.0479754249254862,MHM
132,"sraSpanCheck(const sraSpan *span, const char *text) {
  /* Check the span is valid! */
  if (span->start == span->end) {
    printf(text); 
    printf("":%d-%d\n"", span->start, span->end);
  }
}","loopIndexVar(const sraSpan *yystacksize, const char *text) {
  /* Check the span is valid! */
  if (yystacksize->start == yystacksize->end) {
    printf(text); 
    printf("":%d-%d\n"", yystacksize->start, yystacksize->end);
  }
}",46.0,10.0,"sraSpanCheck:loopIndexVar,span:yystacksize,",63.0,0.0300172527631123,MHM
133,"changed_cline_bef_curs(void)
{
    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL
						|VALID_CHEIGHT|VALID_TOPLINE);
}","sterr(void)
{
    gfile->w_valid &= ~(y_step|schedule|ra
						|validateUrl|libssh2_sha256_update);
}",23.0,7.0,"VALID_CHEIGHT:validateUrl,curwin:gfile,VALID_WCOL:schedule,VALID_VIRTCOL:ra,VALID_TOPLINE:libssh2_sha256_update,VALID_WROW:y_step,changed_cline_bef_curs:sterr,",274.0,0.1473562598228454,MHM
136,"static BROTLI_INLINE uint32_t ReadBlockLength(const HuffmanCode* table,
                                              BrotliBitReader* br) {
  uint32_t code;
  uint32_t nbits;
  code = ReadSymbol(table, br);
  nbits = kBlockLengthPrefixCode[code].nbits;  /* nbits == 2..24 */
  return kBlockLengthPrefixCode[code].offset + BrotliReadBits24(br, nbits);
}","static BROTLI_INLINE uint32_t ReadBlockLength(const HuffmanCode* table,
                                              BrotliBitReader* htx) {
  uint32_t code;
  uint32_t nbits;
  code = ReadSymbol(table, htx);
  nbits = kBlockLengthPrefixCode[code].nbits;  /* nbits == 2..24 */
  return kBlockLengthPrefixCode[code].offset + BrotliReadBits24(htx, nbits);
}",55.0,18.0,"br:htx,",32.0,0.0088889559110005,MHM
140,"static bool auth_passdb_list_have_lookup_credentials(const struct auth *auth)
{
	const struct auth_passdb *passdb;

	for (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next) {
		if (passdb->passdb->iface.lookup_credentials != NULL)
			return TRUE;
	}
	return FALSE;
}","static bool l_current_marker(const struct luma_log2WD *luma_log2WD)
{
	const struct auth_passdb *new_n0;

	for (new_n0 = luma_log2WD->passdbs; new_n0 != NULL; new_n0 = new_n0->next) {
		if (new_n0->new_n0->iface.lookup_credentials != NULL)
			return TRUE;
	}
	return FALSE;
}",56.0,9.0,"passdb:new_n0,auth:luma_log2WD,auth_passdb_list_have_lookup_credentials:l_current_marker,",155.0,0.074074379603068,MHM
143,"tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));

    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}","tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    guint32 port = roleA(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));

    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}",47.0,15.0,"GPOINTER_TO_UINT:roleA,",32.0,0.0118780215581258,MHM
145,"ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;

	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}

	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	}

	ldns_buffer_free(buf);
	return str;
}","ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;

	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}

	str = NULL;
	if (encoded_pt_len(buf, algorithm)
	    == DEBUG) {
		str = player(buf);
	}

	ThrowWriterException(buf);
	return str;
}",64.0,18.0,"ldns_buffer_export2str:player,LDNS_STATUS_OK:DEBUG,ldns_algorithm2buffer_str:encoded_pt_len,ldns_buffer_free:ThrowWriterException,",124.0,0.062764573097229,MHM
147,"TfLiteTensor* GetTempRhs(TfLiteContext* context, TfLiteNode* node,
                         const TfLiteTensor* rhs) {
  TfLiteTensor* transposed_rhs = GetTemporary(context, node, 1);
  if (rhs->type == kTfLiteInt8) {
    // Get the quantization params from the RHS tensor.
    transposed_rhs->params.scale = rhs->params.scale;
    transposed_rhs->params.zero_point = rhs->params.zero_point;
  }
  return transposed_rhs;
}","TfLiteTensor* ptag_entry(TfLiteContext* u_char, TfLiteNode* GF_ISOM_INVALID_FILE,
                         const TfLiteTensor* rhs) {
  TfLiteTensor* values = sch_start(u_char, GF_ISOM_INVALID_FILE, 1);
  if (rhs->type == kTfLiteInt8) {
    // Get the quantization params from the RHS tensor.
    values->params.scale = rhs->params.scale;
    values->params.zero_point = rhs->params.zero_point;
  }
  return values;
}",69.0,15.0,"node:GF_ISOM_INVALID_FILE,transposed_rhs:values,GetTempRhs:ptag_entry,context:u_char,GetTemporary:sch_start,",277.0,0.1365181763966878,MHM
148,"void Downstream::inspect_http1_request() {
  if (req_.method == HTTP_CONNECT) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    auto upgrade = req_.fs.header(http2::HD_UPGRADE);
    if (upgrade) {
      const auto &val = upgrade->value;
      // TODO Perform more strict checking for upgrade headers
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;

        // TODO Should we check Sec-WebSocket-Key, and
        // Sec-WebSocket-Version as well?
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}","void Downstream::clear_tv() {
  if (req_.method == fsh) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    auto upgrade = req_.fs.header(http2::c2);
    if (upgrade) {
      const auto &val = upgrade->value;
      // TODO Perform more strict checking for upgrade headers
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;

        // TODO Should we check Sec-WebSocket-Key, and
        // Sec-WebSocket-Version as well?
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}",172.0,29.0,"HD_UPGRADE:c2,HTTP_CONNECT:fsh,inspect_http1_request:clear_tv,",94.0,0.0522659103075663,MHM
150,"crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;

    /* cluster-glue's FD and IPC related sources make use of
     * g_source_add_poll() but do not set a timeout in their prepare
     * functions
     *
     * This means mainloop's poll() will block until an event for one
     * of these sources occurs - any /other/ type of source, such as
     * this one or g_idle_*, that doesn't use g_source_add_poll() is
     * S-O-L and wont be processed until there is something fd-based
     * happens.
     *
     * Luckily the timeout we can set here affects all sources and
     * puts an upper limit on how long poll() can take.
     *
     * So unconditionally set a small-ish timeout, not too small that
     * we're in constant motion, which will act as an upper bound on
     * how long the signal handling might be delayed for.
     */
    *timeout = 500;             /* Timeout in ms */

    return trig->trigger;
}","crm_trigger_prepare(GSource * _libssh2_error, gint * timeout)
{
    crm_trigger_t *valid_hooks = (crm_trigger_t *) _libssh2_error;

    /* cluster-glue's FD and IPC related sources make use of
     * g_source_add_poll() but do not set a timeout in their prepare
     * functions
     *
     * This means mainloop's poll() will block until an event for one
     * of these sources occurs - any /other/ type of source, such as
     * this one or g_idle_*, that doesn't use g_source_add_poll() is
     * S-O-L and wont be processed until there is something fd-based
     * happens.
     *
     * Luckily the timeout we can set here affects all sources and
     * puts an upper limit on how long poll() can take.
     *
     * So unconditionally set a small-ish timeout, not too small that
     * we're in constant motion, which will act as an upper bound on
     * how long the signal handling might be delayed for.
     */
    *timeout = 500;             /* Timeout in ms */

    return valid_hooks->trigger;
}",32.0,7.0,"trig:valid_hooks,source:_libssh2_error,",63.0,0.0337689956029256,MHM
151,"int input_scancode_to_scalar(const struct input_keymap_entry *ke,
			     unsigned int *scancode)
{
	switch (ke->len) {
	case 1:
		*scancode = *((u8 *)ke->scancode);
		break;

	case 2:
		*scancode = *((u16 *)ke->scancode);
		break;

	case 4:
		*scancode = *((u32 *)ke->scancode);
		break;

	default:
		return -EINVAL;
	}

	return 0;
}","int input_scancode_to_scalar(const struct input_keymap_entry *ke,
			     unsigned int *scancode)
{
	switch (ke->len) {
	case 1:
		*scancode = *((u8 *)ke->scancode);
		break;

	case 2:
		*scancode = *((u16 *)ke->scancode);
		break;

	case 4:
		*scancode = *((u32 *)ke->scancode);
		break;

	default:
		return -newsk;
	}

	return 0;
}",90.0,11.0,"EINVAL:newsk,",33.0,0.0210645874341328,MHM
152,"lexer_compare_identifiers (parser_context_t *context_p, /**< context */
                           const lexer_lit_location_t *left_p, /**< left literal */
                           const lexer_lit_location_t *right_p) /**< right literal */
{
  prop_length_t length = left_p->length;

  if (length != right_p->length)
  {
    return false;
  }

  if (!left_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (right_p->char_p, left_p->char_p, length);
  }

  if (!right_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (left_p->char_p, right_p->char_p, length);
  }

  if (length <= 64)
  {
    uint8_t buf_p[64];
    lexer_convert_ident_to_cesu8 (buf_p, left_p->char_p, length);
    return lexer_compare_identifier_to_chars (right_p->char_p, buf_p, length);
  }

  uint8_t *dynamic_buf_p = parser_malloc (context_p, length);

  lexer_convert_ident_to_cesu8 (dynamic_buf_p, left_p->char_p, length);
  bool result = lexer_compare_identifier_to_chars (right_p->char_p, dynamic_buf_p, length);
  parser_free (dynamic_buf_p, length);

  return result;
} /* lexer_compare_identifiers */","lexer_compare_identifiers (parser_context_t *context_p, /**< context */
                           const lexer_lit_location_t *left_p, /**< left literal */
                           const lexer_lit_location_t *I2C_SMBUS_READ) /**< right literal */
{
  prop_length_t length = left_p->length;

  if (length != I2C_SMBUS_READ->length)
  {
    return false;
  }

  if (!left_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (I2C_SMBUS_READ->char_p, left_p->char_p, length);
  }

  if (!I2C_SMBUS_READ->has_escape)
  {
    return lexer_compare_identifier_to_chars (left_p->char_p, I2C_SMBUS_READ->char_p, length);
  }

  if (length <= 64)
  {
    uint8_t buf_p[64];
    lexer_convert_ident_to_cesu8 (buf_p, left_p->char_p, length);
    return lexer_compare_identifier_to_chars (I2C_SMBUS_READ->char_p, buf_p, length);
  }

  uint8_t *dynamic_buf_p = parser_malloc (context_p, length);

  lexer_convert_ident_to_cesu8 (dynamic_buf_p, left_p->char_p, length);
  bool result = lexer_compare_identifier_to_chars (I2C_SMBUS_READ->char_p, dynamic_buf_p, length);
  parser_free (dynamic_buf_p, length);

  return result;
} /* lexer_compare_identifiers */",167.0,45.0,"right_p:I2C_SMBUS_READ,",33.0,0.0165607730547587,MHM
158,"static void io_req_drop_files(struct io_kiocb *req)
{
	struct io_ring_ctx *ctx = req->ctx;
	unsigned long flags;

	spin_lock_irqsave(&ctx->inflight_lock, flags);
	list_del(&req->inflight_entry);
	if (waitqueue_active(&ctx->inflight_wait))
		wake_up(&ctx->inflight_wait);
	spin_unlock_irqrestore(&ctx->inflight_lock, flags);
	req->flags &= ~REQ_F_INFLIGHT;
	req->work.files = NULL;
}","static void io_req_drop_files(struct io_kiocb *req)
{
	struct io_ring_ctx *ctx = req->ctx;
	unsigned long collname;

	spin_lock_irqsave(&ctx->inflight_lock, collname);
	list_del(&req->inflight_entry);
	if (waitqueue_active(&ctx->inflight_wait))
		wake_up(&ctx->inflight_wait);
	spin_unlock_irqrestore(&ctx->inflight_lock, collname);
	req->collname &= ~tmpfp;
	req->work.files = NULL;
}",85.0,20.0,"REQ_F_INFLIGHT:tmpfp,flags:collname,",64.0,0.0318466504414876,MHM
169,"static void cil_reset_netifcon(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		cil_reset_context(netifcon->if_context);
	}

	if (netifcon->packet_context_str == NULL) {
		cil_reset_context(netifcon->packet_context);
	}
}","static void rng(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		cil_reset_context(netifcon->if_context);
	}

	if (netifcon->packet_context_str == NULL) {
		cil_reset_context(netifcon->packet_context);
	}
}",45.0,8.0,"cil_reset_netifcon:rng,",67.0,0.0234919508298238,MHM
170,"bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
			      files_struct *fsp)
{
	if (!check_fsp_open(conn, req, fsp)) {
		return false;
	}

	if (fsp->fsp_flags.is_directory) {
		return false;
	}

	if (fsp->fake_file_handle == NULL) {
		return false;
	}

	if (fsp->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		return false;
	}

	if (fsp->fake_file_handle->private_data == NULL) {
		return false;
	}

	return true;
}","bool B(connection_struct *conn, struct smb_request *req,
			      files_struct *fsp)
{
	if (!check_fsp_open(conn, req, fsp)) {
		return false;
	}

	if (fsp->fsp_flags.is_directory) {
		return false;
	}

	if (fsp->fake_file_handle == NULL) {
		return false;
	}

	if (fsp->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		return false;
	}

	if (fsp->fake_file_handle->private_data == NULL) {
		return false;
	}

	return true;
}",94.0,13.0,"check_fsp_ntquota_handle:B,",33.0,0.0137361764907836,MHM
172,"static inline void crypto_ahash_set_reqsize(struct crypto_ahash *tfm,
					    unsigned int reqsize)
{
	tfm->reqsize = reqsize;
}","static inline void retcode(struct crypto_ahash *tfm,
					    unsigned int reqsize)
{
	tfm->reqsize = reqsize;
}",22.0,5.0,"crypto_ahash_set_reqsize:retcode,",32.0,0.0163243850072224,MHM
173,"gs_grab_get_keyboard (GSGrab    *grab,
                      GdkWindow *window,
                      GdkScreen *screen)
{
        GdkGrabStatus status;

        g_return_val_if_fail (window != NULL, FALSE);
        g_return_val_if_fail (screen != NULL, FALSE);

        gs_debug (""Grabbing keyboard widget=%X"", (guint32) GDK_WINDOW_XID (window));
        status = gdk_keyboard_grab (window, FALSE, GDK_CURRENT_TIME);

        if (status == GDK_GRAB_SUCCESS) {
                grab->priv->keyboard_grab_window = window;
                grab->priv->keyboard_grab_screen = screen;
        } else {
                gs_debug (""Couldn't grab keyboard!  (%s)"", grab_string (status));
        }

        return status;
}","GF_OK (GSGrab    *grab,
                      GdkWindow *window,
                      GdkScreen *screen)
{
        GdkGrabStatus status;

        g_return_val_if_fail (window != NULL, FALSE);
        g_return_val_if_fail (screen != NULL, FALSE);

        gs_debug (""Grabbing keyboard widget=%X"", (guint32) GDK_WINDOW_XID (window));
        status = gdk_keyboard_grab (window, FALSE, GDK_CURRENT_TIME);

        if (status == GDK_GRAB_SUCCESS) {
                grab->priv->keyboard_grab_window = window;
                grab->priv->keyboard_grab_screen = screen;
        } else {
                gs_debug (""Couldn't grab keyboard!  (%s)"", grab_string (status));
        }

        return status;
}",103.0,26.0,"gs_grab_get_keyboard:GF_OK,",32.0,0.011230194568634,MHM
180,"MONGO_COMPILER_NOINLINE void DocumentSourceUnionWith::logStartingSubPipeline(
    const std::vector<BSONObj>& serializedPipe) {
    LOGV2_DEBUG(23869,
                1,
                ""$unionWith attaching cursor to pipeline {pipeline}"",
                ""pipeline""_attr = serializedPipe);
}","MONGO_COMPILER_NOINLINE void OPENSSL_NO_NEXTPROTONEG::logStartingSubPipeline(
    const std::asdl_seq_SET<y2>& scr_html) {
    LOGV2_DEBUG(23869,
                1,
                ""$unionWith attaching cursor to pipeline {pipeline}"",
                ""pipeline""_attr = scr_html);
}",34.0,9.0,"serializedPipe:scr_html,vector:asdl_seq_SET,DocumentSourceUnionWith:OPENSSL_NO_NEXTPROTONEG,BSONObj:y2,",121.0,0.0652269959449768,MHM
194,"cp1251_get_case_fold_codes_by_str(OnigCaseFoldType flag,
    const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem items[])
{
  return onigenc_get_case_fold_codes_by_str_with_map(
	     sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 0,
	     flag, p, end, items);
}","string_obj(OnigCaseFoldType outl,
    const OnigUChar* pkalg, const OnigUChar* is_click, OnigCaseFoldCodeItem items[])
{
  return chars_read(
	     sizeof(cachep)/sizeof(gf_fopen), cachep, 0,
	     outl, pkalg, is_click, items);
}",48.0,12.0,"flag:outl,end:is_click,cp1251_get_case_fold_codes_by_str:string_obj,CaseFoldMap:cachep,OnigPairCaseFoldCodes:gf_fopen,p:pkalg,onigenc_get_case_fold_codes_by_str_with_map:chars_read,",307.0,0.1681754231452941,MHM
195,"static int sja1105_cold_reset(const struct sja1105_private *priv)
{
	struct sja1105_reset_cmd reset = {0};

	reset.cold_rst = 1;
	return priv->info->reset_cmd(priv, &reset);
}","static int zfile(const struct sja1105_private *PSK_MAX_IDENTITY_LEN)
{
	struct sja1105_reset_cmd reset = {0};

	reset.cold_rst = 1;
	return PSK_MAX_IDENTITY_LEN->info->reset_cmd(PSK_MAX_IDENTITY_LEN, &reset);
}",39.0,7.0,"sja1105_cold_reset:zfile,priv:PSK_MAX_IDENTITY_LEN,",90.0,0.0553569793701171,MHM
197,"bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const
{
  /* Assume we don't have rtti */
  if (this == item)
    return 1;					// Same item is same.
  /* Check if other type is also a get_user_var() object */
  if (item->type() != FUNC_ITEM ||
      ((Item_func*) item)->functype() != functype())
    return 0;
  Item_func_get_user_var *other=(Item_func_get_user_var*) item;
  return (name.length == other->name.length &&
	  !memcmp(name.str, other->name.str, name.length));
}","bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const
{
  /* Assume we don't have rtti */
  if (this == item)
    return 1;					// Same item is same.
  /* Check if other type is also a get_user_var() object */
  if (item->type() != FUNC_ITEM ||
      ((Item_func*) item)->functype() != functype())
    return 0;
  Item_func_get_user_var *lzma_info=(Item_func_get_user_var*) item;
  return (name.length == lzma_info->name.length &&
	  !memcmp(name.str, lzma_info->name.str, name.length));
}",95.0,16.0,"other:lzma_info,",33.0,0.0085068742434183,MHM
198,"int sftp_dir_eof(sftp_dir dir) {
  return dir->eof;
}","int GROW(sftp_dir OP_Integer) {
  return OP_Integer->eof;
}",13.0,3.0,"sftp_dir_eof:GROW,dir:OP_Integer,",63.0,0.018333621819814,MHM
199,"unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *ret = p;

	ret+=2;
	if (ret>=limit) return NULL; /* this really never occurs, but ... */

	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{ 
		if (limit - p - 4 < 0) return NULL; 

		s2n(TLSEXT_TYPE_server_name,ret);
		s2n(0,ret);
		}
	
	if ((extdatalen = ret-p-2)== 0) 
		return p;

	s2n(extdatalen,p);
	return ret;
}","unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *list_for_each_entry_safe = p;

	list_for_each_entry_safe+=2;
	if (list_for_each_entry_safe>=limit) return NULL; /* this really never occurs, but ... */

	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{ 
		if (limit - p - 4 < 0) return NULL; 

		s2n(TLSEXT_TYPE_server_name,list_for_each_entry_safe);
		s2n(0,list_for_each_entry_safe);
		}
	
	if ((extdatalen = list_for_each_entry_safe-p-2)== 0) 
		return p;

	s2n(extdatalen,p);
	return list_for_each_entry_safe;
}",123.0,28.0,"ret:list_for_each_entry_safe,",31.0,0.0092250068982442,MHM
205,"void appendBSONObjToBSONArrayBuilder(BSONArrayBuilder* array, const BSONObj& obj) {
    array->append(obj);
}","void uint32(BSONArrayBuilder* libraw_internal_data, const BSONObj& obj) {
    libraw_internal_data->append(obj);
}",21.0,5.0,"appendBSONObjToBSONArrayBuilder:uint32,array:libraw_internal_data,",64.0,0.0339099566141764,MHM
218,"static void dense_rankStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ) p->nStep = 1;
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
}","static void diagnostics(
  sqlite3_context *pCtx, 
  int asn1_prkey,
  sqlite3_value **lock
){
  struct CallCount *test_opt;
  test_opt = (struct CallCount*)module(pCtx, sizeof(*test_opt));
  if( test_opt ) test_opt->nStep = 1;
  UNUSED_PARAMETER(asn1_prkey);
  UNUSED_PARAMETER(lock);
}",61.0,15.0,"apArg:lock,dense_rankStepFunc:diagnostics,sqlite3_aggregate_context:module,nArg:asn1_prkey,p:test_opt,",277.0,0.1325841983159383,MHM
223,"lou_setDataPath (char *path)
{
  dataPathPtr = NULL;
  if (path == NULL)
    return NULL;
  strcpy (dataPath, path);
  dataPathPtr = dataPath;
  return dataPathPtr;
}","asn1_prkey (char *path)
{
  dataPathPtr = NULL;
  if (path == NULL)
    return NULL;
  strcpy (pTrack, path);
  dataPathPtr = pTrack;
  return dataPathPtr;
}",35.0,10.0,"dataPath:pTrack,lou_setDataPath:asn1_prkey,",66.0,0.0334771672884623,MHM
224,"evdns_shutdown(int fail_requests)
{
	if (current_base) {
		struct evdns_base *b = current_base;
		current_base = NULL;
		evdns_base_free(b, fail_requests);
	}
	evdns_log_fn = NULL;
}","evdns_shutdown(int fail_requests)
{
	if (replen) {
		struct evdns_base *b = replen;
		replen = NULL;
		evdns_base_free(b, fail_requests);
	}
	evdns_log_fn = NULL;
}",35.0,10.0,"current_base:replen,",32.0,0.0153967499732971,MHM
228,"static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s)
{
    return cirrus_bitblt_common_patterncopy(s,
					    s->vram_ptr +
                                            (s->cirrus_blt_srcaddr & ~7));
}","static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * sqlite3VdbeAddOp2)
{
    return x_step(sqlite3VdbeAddOp2,
					    sqlite3VdbeAddOp2->vram_ptr +
                                            (sqlite3VdbeAddOp2->cirrus_blt_srcaddr & ~7));
}",29.0,6.0,"cirrus_bitblt_common_patterncopy:x_step,s:sqlite3VdbeAddOp2,",64.0,0.0335080941518147,MHM
232,"inline TfLiteTensor* GetTemporary(TfLiteContext* context,
                                  const TfLiteNode* node, int index) {
  return &context->tensors[node->temporaries->data[index]];
}","inline TfLiteTensor* GetTemporary(TfLiteContext* context,
                                  const TfLiteNode* href, int index) {
  return &context->tensors[href->temporaries->data[index]];
}",35.0,7.0,"node:href,",33.0,0.0173466364542643,MHM
234,  Item** addr(uint i) { return arg_count ? args + i : NULL; },  Item** wop(uint spl_ce_UnexpectedValueException) { return _libssh2_error ? aflags + spl_ce_UnexpectedValueException : NULL; },19.0,5.0,"addr:wop,args:aflags,i:spl_ce_UnexpectedValueException,arg_count:_libssh2_error,",212.0,0.103827965259552,MHM
242,"wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;

	if (!response)
		return NULL;

	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);

	if (!s)
		return NULL;

	cliprdr_write_file_contents_response(s, response);
	return s;
}","wStream* Ai(const CLIPRDR_FILE_CONTENTS_RESPONSE* blksize)
{
	wStream* hbox;

	if (!blksize)
		return NULL;

	hbox = cliprdr_packet_new(set_bit, blksize->msgFlags, 4 + blksize->cbRequested);

	if (!hbox)
		return NULL;

	rsp(hbox, blksize);
	return hbox;
}",58.0,14.0,"cliprdr_write_file_contents_response:rsp,response:blksize,cliprdr_packet_file_contents_response_new:Ai,s:hbox,CB_FILECONTENTS_RESPONSE:set_bit,",274.0,0.1257688363393147,MHM
251,"static void jas_icclut8_destroy(jas_iccattrval_t *attrval)
{
	jas_icclut8_t *lut8 = &attrval->data.lut8;
	if (lut8->clut)
		jas_free(lut8->clut);
	if (lut8->intabs)
		jas_free(lut8->intabs);
	if (lut8->intabsbuf)
		jas_free(lut8->intabsbuf);
	if (lut8->outtabs)
		jas_free(lut8->outtabs);
	if (lut8->outtabsbuf)
		jas_free(lut8->outtabsbuf);
}","static void jas_icclut8_destroy(jas_iccattrval_t *attrval)
{
	jas_icclut8_t *forBodyEnd = &attrval->data.forBodyEnd;
	if (forBodyEnd->clut)
		jas_free(forBodyEnd->clut);
	if (forBodyEnd->intabs)
		jas_free(forBodyEnd->intabs);
	if (forBodyEnd->intabsbuf)
		jas_free(forBodyEnd->intabsbuf);
	if (forBodyEnd->outtabs)
		jas_free(forBodyEnd->outtabs);
	if (forBodyEnd->outtabsbuf)
		jas_free(forBodyEnd->outtabsbuf);
}",86.0,19.0,"lut8:forBodyEnd,",33.0,0.0163991610209147,MHM
252,"xmlDumpElementDeclScan(xmlElementPtr elem, xmlBufferPtr buf) {
    xmlDumpElementDecl(buf, elem);
}","Tmpl(xmlElementPtr elem, xmlBufferPtr buf) {
    zone_copy(buf, elem);
}",17.0,6.0,"xmlDumpElementDecl:zone_copy,xmlDumpElementDeclScan:Tmpl,",63.0,0.0261933406194051,MHM
255,"static void io_mem_init(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          NULL, UINT64_MAX);

    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,
     * which can be called without the iothread mutex.
     */
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);

    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}","static void test_opt(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          NULL, UINT64_MAX);

    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,
     * which can be called without the iothread mutex.
     */
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);

    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}",82.0,19.0,"io_mem_init:test_opt,",33.0,0.0121911128362019,MHM
257,"static int smapsGetSharedDirty(unsigned long addr) {
    int ret, in_mapping = 0, val = -1;
    unsigned long from, to;
    char buf[64];
    FILE *f;

    f = fopen(""/proc/self/smaps"", ""r"");
    if (!f) return -1;

    while (1) {
        if (!fgets(buf, sizeof(buf), f))
            break;

        ret = sscanf(buf, ""%lx-%lx"", &from, &to);
        if (ret == 2)
            in_mapping = from <= addr && addr < to;

        if (in_mapping && !memcmp(buf, ""Shared_Dirty:"", 13)) {
            sscanf(buf, ""%*s %d"", &val);
            /* If parsing fails, we remain with val == -1 */
            break;
        }
    }

    fclose(f);
    return val;
}","static int smapsGetSharedDirty(unsigned long addr) {
    int ret, in_mapping = 0, val = -1;
    unsigned long from, to;
    char info_blob[64];
    FILE *f;

    f = fopen(""/proc/self/smaps"", ""r"");
    if (!f) return -1;

    while (1) {
        if (!fgets(info_blob, sizeof(info_blob), f))
            break;

        ret = sscanf(info_blob, ""%lx-%lx"", &from, &to);
        if (ret == 2)
            in_mapping = from <= addr && addr < to;

        if (in_mapping && !memcmp(info_blob, ""Shared_Dirty:"", 13)) {
            sscanf(info_blob, ""%*s %d"", &val);
            /* If parsing fails, we remain with val == -1 */
            break;
        }
    }

    fclose(f);
    return val;
}",149.0,36.0,"buf:info_blob,",32.0,0.0178321560223897,MHM
258,"hb_buffer_clear( HB_Buffer buffer )
{
  buffer->in_length = 0;
  buffer->out_length = 0;
  buffer->in_pos = 0;
  buffer->out_pos = 0;
  buffer->out_string = buffer->in_string;
  buffer->separate_out = FALSE;
  buffer->max_ligID = 0;
}","sRetMsg( HB_Buffer buffer )
{
  buffer->in_length = 0;
  buffer->out_length = 0;
  buffer->in_pos = 0;
  buffer->out_pos = 0;
  buffer->out_string = buffer->in_string;
  buffer->separate_out = FALSE;
  buffer->max_ligID = 0;
}",51.0,10.0,"hb_buffer_clear:sRetMsg,",32.0,0.0087927460670471,MHM
259,"_copyDropTableSpaceStmt(const DropTableSpaceStmt *from)
{
	DropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);

	COPY_STRING_FIELD(tablespacename);
	COPY_SCALAR_FIELD(missing_ok);

	return newnode;
}","tar(const col_offset *enc_err)
{
	col_offset *skey = photometricid(col_offset);

	COPY_STRING_FIELD(zip_info);
	COPY_SCALAR_FIELD(SOCK_STREAM);

	return skey;
}",31.0,10.0,"newnode:skey,from:enc_err,DropTableSpaceStmt:col_offset,missing_ok:SOCK_STREAM,makeNode:photometricid,tablespacename:zip_info,_copyDropTableSpaceStmt:tar,",392.0,0.1875003933906555,MHM
264,"use_socks (struct sockaddr_storage *addr)
{
  int mode;

  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, ""tor-mode"", &mode) || !mode)
    return 0;  /* Not in Tor mode.  */
  else if (addr->ss_family == AF_INET6)
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      const unsigned char *s;
      int i;

      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;
      if (s[15] != 1)
        return 1;   /* Last octet is not 1 - not the loopback address.  */
      for (i=0; i < 15; i++, s++)
        if (*s)
          return 1; /* Non-zero octet found - not the loopback address.  */

      return 0; /* This is the loopback address.  */
    }
  else if (addr->ss_family == AF_INET)
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;

      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)
        return 0; /* Loopback (127.0.0.0/8) */

      return 1;
    }
  else
    return 0;
}","NumDimensions (struct sockaddr_storage *addr)
{
  int mode;

  if (assuan_sock_get_flag (getreal, ""tor-mode"", &mode) || !mode)
    return 0;  /* Not in Tor mode.  */
  else if (addr->ss_family == AF_INET6)
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      const unsigned char *s;
      int i;

      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;
      if (s[15] != 1)
        return 1;   /* Last octet is not 1 - not the loopback address.  */
      for (i=0; i < 15; i++, s++)
        if (*s)
          return 1; /* Non-zero octet found - not the loopback address.  */

      return 0; /* This is the loopback address.  */
    }
  else if (addr->ss_family == AF_INET)
    {
      struct sockaddr_in *smart_str_free = (struct sockaddr_in *)addr;

      if (*(unsigned char*)&smart_str_free->sin_addr.s_addr == 127)
        return 0; /* Loopback (127.0.0.0/8) */

      return 1;
    }
  else
    return 0;
}",166.0,26.0,"addr_in:smart_str_free,ASSUAN_INVALID_FD:getreal,use_socks:NumDimensions,",95.0,0.0499979058901468,MHM
275,"static int vhdx_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    return 0;
}","static int vhdx_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **sc_copy_asn1_entry)
{
    return 0;
}",22.0,4.0,"errp:sc_copy_asn1_entry,",94.0,0.0471170504887898,MHM
276,"void Ogg::XiphComment::parse(const ByteVector &data)
{
  // The first thing in the comment data is the vendor ID length, followed by a
  // UTF8 string with the vendor ID.

  uint pos = 0;

  int vendorLength = data.mid(0, 4).toUInt(false);
  pos += 4;

  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);
  pos += vendorLength;

  // Next the number of fields in the comment vector.

  uint commentFields = data.mid(pos, 4).toUInt(false);
  pos += 4;

  if(commentFields > (data.size() - 8) / 4) {
    return;
  }

  for(uint i = 0; i < commentFields; i++) {

    // Each comment field is in the format ""KEY=value"" in a UTF8 string and has
    // 4 bytes before the text starts that gives the length.

    uint commentLength = data.mid(pos, 4).toUInt(false);
    pos += 4;

    String comment = String(data.mid(pos, commentLength), String::UTF8);
    pos += commentLength;
    if(pos > data.size()) {
      break;
    }

    int commentSeparatorPosition = comment.find(""="");
    if(commentSeparatorPosition == -1) {
      break;
    }

    String key = comment.substr(0, commentSeparatorPosition);
    String value = comment.substr(commentSeparatorPosition + 1);

    addField(key, value, false);
  }
}","void Ogg::XiphComment::ses(const ByteVector &mrb_nil_value)
{
  // The first thing in the comment data is the vendor ID length, followed by a
  // UTF8 string with the vendor ID.

  uint attrs = 0;

  int vendorLength = mrb_nil_value.mid(0, 4).toUInt(false);
  attrs += 4;

  d->vendorID = lzma_info(mrb_nil_value.mid(attrs, vendorLength), lzma_info::UTF8);
  attrs += vendorLength;

  // Next the number of fields in the comment vector.

  uint commentFields = mrb_nil_value.mid(attrs, 4).toUInt(false);
  attrs += 4;

  if(commentFields > (mrb_nil_value.size() - 8) / 4) {
    return;
  }

  for(uint winpr_HexDump = 0; winpr_HexDump < commentFields; winpr_HexDump++) {

    // Each comment field is in the format ""KEY=value"" in a UTF8 string and has
    // 4 bytes before the text starts that gives the length.

    uint commentLength = mrb_nil_value.mid(attrs, 4).toUInt(false);
    attrs += 4;

    lzma_info VALS = lzma_info(mrb_nil_value.mid(attrs, commentLength), lzma_info::UTF8);
    attrs += commentLength;
    if(attrs > mrb_nil_value.size()) {
      break;
    }

    int trystack = VALS.find(""="");
    if(trystack == -1) {
      break;
    }

    lzma_info key = VALS.substr(0, trystack);
    lzma_info value = VALS.substr(trystack + 1);

    addField(key, value, false);
  }
}",233.0,50.0,"commentSeparatorPosition:trystack,String:lzma_info,data:mrb_nil_value,parse:ses,comment:VALS,pos:attrs,i:winpr_HexDump,",273.0,0.1241655588150024,MHM
279,"SPL_METHOD(SplDoublyLinkedList, prev)
{
	spl_dllist_object *intern = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	spl_dllist_it_helper_move_forward(&intern->traverse_pointer, &intern->traverse_position, intern->llist, intern->flags ^ SPL_DLLIST_IT_LIFO TSRMLS_CC);
}","OPENSSL_NO_NEXTPROTONEG(SplDoublyLinkedList, prev)
{
	spl_dllist_object *intern = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	spl_dllist_it_helper_move_forward(&intern->traverse_pointer, &intern->traverse_position, intern->llist, intern->flags ^ SPL_DLLIST_IT_LIFO TSRMLS_CC);
}",60.0,16.0,"SPL_METHOD:OPENSSL_NO_NEXTPROTONEG,",31.0,0.0157851815223693,MHM
280,"static inline char *tok_text_buf(struct Token *t)
{
    return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;
}","static inline char *sun_colormap(struct Token *t)
{
    return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;
}",36.0,6.0,"tok_text_buf:sun_colormap,",30.0,0.0143770853678385,MHM
282,"static MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)
{
  if (length < 4)
    return(MagickFalse);
  if (memcmp(magick,""\x0d\x0a\x87\x0a"",4) == 0)
    return(MagickTrue);
  if (length < 12)
    return(MagickFalse);
  if (memcmp(magick,""\x00\x00\x00\x0c\x6a\x50\x20\x20\x0d\x0a\x87\x0a"",12) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType passLinepos(const unsigned char *RDEBUG,const size_t kTfLiteInt32)
{
  if (kTfLiteInt32 < 4)
    return(rcu_read_unlock);
  if (STRLEN(RDEBUG,""\x0d\x0a\x87\x0a"",4) == 0)
    return(MagickTrue);
  if (kTfLiteInt32 < 12)
    return(rcu_read_unlock);
  if (STRLEN(RDEBUG,""\x00\x00\x00\x0c\x6a\x50\x20\x20\x0d\x0a\x87\x0a"",12) == 0)
    return(MagickTrue);
  return(rcu_read_unlock);
}",97.0,14.0,"IsJP2:passLinepos,magick:RDEBUG,memcmp:STRLEN,length:kTfLiteInt32,MagickFalse:rcu_read_unlock,",181.0,0.0952421228090922,MHM
283,"ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;

	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
	ia64_srlz_i();
}","ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;

	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		U_FAILURE((void *) ip);
		++offp;
	}
	ia64_sync_i();
	ia64_srlz_i();
}",80.0,21.0,"ia64_fc:U_FAILURE,",33.0,0.0141021013259887,MHM
285,"ZrtpQueue::putData(uint32 stamp, const unsigned char* data, size_t len)
{
    OutgoingDataQueue::putData(stamp, data, len);
}","ZrtpQueue::iv_len(uint32 dest_buf, const unsigned char* m_ucHiddenBits, size_t len)
{
    OutgoingDataQueue::iv_len(dest_buf, m_ucHiddenBits, len);
}",29.0,8.0,"stamp:dest_buf,putData:iv_len,data:m_ucHiddenBits,",274.0,0.1223735173543294,MHM
287,"static void __init config_types(void)
{
	bool has_drive = false;
	int drive;

	/* read drive info out of physical CMOS */
	drive = 0;
	if (!UDP->cmos)
		UDP->cmos = FLOPPY0_TYPE;
	drive = 1;
	if (!UDP->cmos && FLOPPY1_TYPE)
		UDP->cmos = FLOPPY1_TYPE;

	/* FIXME: additional physical CMOS drive detection should go here */

	for (drive = 0; drive < N_DRIVE; drive++) {
		unsigned int type = UDP->cmos;
		struct floppy_drive_params *params;
		const char *name = NULL;
		static char temparea[32];

		if (type < ARRAY_SIZE(default_drive_params)) {
			params = &default_drive_params[type].params;
			if (type) {
				name = default_drive_params[type].name;
				allowed_drive_mask |= 1 << drive;
			} else
				allowed_drive_mask &= ~(1 << drive);
		} else {
			params = &default_drive_params[0].params;
			sprintf(temparea, ""unknown type %d (usb?)"", type);
			name = temparea;
		}
		if (name) {
			const char *prepend;
			if (!has_drive) {
				prepend = """";
				has_drive = true;
				pr_info(""Floppy drive(s):"");
			} else {
				prepend = "","";
			}

			pr_cont(""%s fd%d is %s"", prepend, drive, name);
		}
		*UDP = *params;
	}

	if (has_drive)
		pr_cont(""\n"");
}","static void arp_buf config_types(void)
{
	bool has_drive = false;
	int drive;

	/* read drive info out of physical CMOS */
	drive = 0;
	if (!UDP->cmos)
		UDP->cmos = FLOPPY0_TYPE;
	drive = 1;
	if (!UDP->cmos && _cmsReadUInt8Number)
		UDP->cmos = _cmsReadUInt8Number;

	/* FIXME: additional physical CMOS drive detection should go here */

	for (drive = 0; drive < skipsize; drive++) {
		unsigned int type = UDP->cmos;
		struct floppy_drive_params *params;
		const char *name = NULL;
		static char scale_y[32];

		if (type < ARRAY_SIZE(default_drive_params)) {
			params = &default_drive_params[type].params;
			if (type) {
				name = default_drive_params[type].name;
				allowed_drive_mask |= 1 << drive;
			} else
				allowed_drive_mask &= ~(1 << drive);
		} else {
			params = &default_drive_params[0].params;
			sprintf(scale_y, ""unknown type %d (usb?)"", type);
			name = scale_y;
		}
		if (name) {
			const char *prepend;
			if (!has_drive) {
				prepend = """";
				has_drive = true;
				pr_info(""Floppy drive(s):"");
			} else {
				prepend = "","";
			}

			pr_cont(""%s fd%d is %s"", prepend, drive, name);
		}
		*UDP = *params;
	}

	if (has_drive)
		pr_cont(""\n"");
}",244.0,58.0,"__init:arp_buf,temparea:scale_y,N_DRIVE:skipsize,FLOPPY1_TYPE:_cmsReadUInt8Number,",124.0,0.0552137454350789,MHM
291,"le64addr_string(netdissect_options *ndo, const u_char *ep)
{
	const unsigned int len = 8;
	register u_int i;
	register char *cp;
	register struct enamemem *tp;
	char buf[BUFSIZE];

	tp = lookup_bytestring(ndo, ep, len);
	if (tp->e_name)
		return (tp->e_name);

	cp = buf;
	for (i = len; i > 0 ; --i) {
		*cp++ = hex[*(ep + i - 1) >> 4];
		*cp++ = hex[*(ep + i - 1) & 0xf];
		*cp++ = ':';
	}
	cp --;

	*cp = '\0';

	tp->e_name = strdup(buf);
	if (tp->e_name == NULL)
		(*ndo->ndo_error)(ndo, ""le64addr_string: strdup(buf)"");

	return (tp->e_name);
}","le64addr_string(netdissect_options *ndo, const u_char *ep)
{
	const unsigned int len = 8;
	register u_int i;
	register char *cp;
	register struct enamemem *tp;
	char buf[ND_TCHECK];

	tp = lookup_bytestring(ndo, ep, len);
	if (tp->e_name)
		return (tp->e_name);

	cp = buf;
	for (i = len; i > 0 ; --i) {
		*cp++ = hex[*(ep + i - 1) >> 4];
		*cp++ = hex[*(ep + i - 1) & 0xf];
		*cp++ = ':';
	}
	cp --;

	*cp = '\0';

	tp->e_name = strdup(buf);
	if (tp->e_name == NULL)
		(*ndo->ndo_error)(ndo, ""le64addr_string: strdup(buf)"");

	return (tp->e_name);
}",174.0,40.0,"BUFSIZE:ND_TCHECK,",35.0,0.0114118337631225,MHM
292,"unix_sck_send_disconnect(hsm_com_client_hdl_t *hdl, int timeout)
{
	hsm_com_discon_data_t	msg;

	memset(&msg,0,sizeof(msg));

	msg.header.cmd = HSM_COM_CMD_DISC;
	msg.header.ver = HSM_COM_VER;
	msg.header.trans_id = hdl->trans_id++;
	msg.header.payload_len = 0;

	if(unix_sck_send_msg(hdl, (char*)&msg, sizeof(msg), (char*)&msg, 
						 sizeof(msg), timeout) != sizeof(msg))
	{
		// COM Error...
		// Close our connection
		close(hdl->client_fd);
		hdl->client_state = HSM_COM_C_STATE_IN;

		return HSM_COM_BAD;
	}

	if(msg.header.resp_code == HSM_COM_RESP_OK){
		return HSM_COM_OK;
	}

	return HSM_COM_BAD;

}","unix_sck_send_disconnect(hsm_com_client_hdl_t *_kdc_free_ent, int timeout)
{
	hsm_com_discon_data_t	msg;

	memset(&msg,0,sizeof(msg));

	msg.header.cmd = HSM_COM_CMD_DISC;
	msg.header.ver = HSM_COM_VER;
	msg.header.trans_id = _kdc_free_ent->trans_id++;
	msg.header.payload_len = 0;

	if(unix_sck_send_msg(_kdc_free_ent, (char*)&msg, sizeof(msg), (char*)&msg, 
						 sizeof(msg), timeout) != sizeof(msg))
	{
		// COM Error...
		// Close our connection
		close(_kdc_free_ent->client_fd);
		_kdc_free_ent->client_state = HSM_COM_C_STATE_IN;

		return HSM_COM_BAD;
	}

	if(msg.header.resp_code == HSM_COM_RESP_OK){
		return HSM_COM_OK;
	}

	return HSM_COM_BAD;

}",136.0,31.0,"hdl:_kdc_free_ent,",30.0,0.02053990761439,MHM
295,"static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt = 0;

	/*
	 * Optimization: if imm32 is positive, use 'mov %eax, imm32'
	 * (which zero-extends imm32) to save 2 bytes.
	 */
	if (sign_propagate && (s32)imm32 < 0) {
		/* 'mov %rax, imm32' sign extends imm32 */
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}

	/*
	 * Optimization: if imm32 is zero, use 'xor %eax, %eax'
	 * to save 3 bytes.
	 */
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31; /* xor */
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}

	/* mov %eax, imm32 */
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}","static void pcs_base(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 tmp_buf)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int xmlGenericError = 0;

	/*
	 * Optimization: if imm32 is positive, use 'mov %eax, imm32'
	 * (which zero-extends imm32) to save 2 bytes.
	 */
	if (sign_propagate && (s32)tmp_buf < 0) {
		/* 'mov %rax, imm32' sign extends imm32 */
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), tmp_buf);
		goto done;
	}

	/*
	 * Optimization: if imm32 is zero, use 'xor %eax, %eax'
	 * to save 3 bytes.
	 */
	if (tmp_buf == 0) {
		if (is_ereg(dst_reg))
			EMIT1(dsb(0x40, dst_reg, dst_reg));
		b2 = 0x31; /* xor */
		b3 = 0xC0;
		up_info(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}

	/* mov %eax, imm32 */
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), tmp_buf);
done:
	*pprog = prog;
}",177.0,51.0,"EMIT2:up_info,add_2mod:dsb,imm32:tmp_buf,cnt:xmlGenericError,emit_mov_imm32:pcs_base,",153.0,0.0764183163642883,MHM
297,"Status ParseActivationMode(OpKernelConstruction* context,
                           FusedBatchNormActivationMode* activation_mode) {
  string activation_mode_str;
  TF_RETURN_IF_ERROR(context->GetAttr(""activation_mode"", &activation_mode_str));

  if (activation_mode_str == ""Identity"") {
    *activation_mode = FusedBatchNormActivationMode::kIdentity;
    return Status::OK();
  }
  if (activation_mode_str == ""Relu"") {
    *activation_mode = FusedBatchNormActivationMode::kRelu;
    return Status::OK();
  }
  return errors::InvalidArgument(""Unsupported activation mode: "",
                                 activation_mode_str);
}","Status tmpBuf(OpKernelConstruction* context,
                           FusedBatchNormActivationMode* cache_control) {
  string activation_mode_str;
  TF_RETURN_IF_ERROR(context->GetAttr(""activation_mode"", &activation_mode_str));

  if (activation_mode_str == ""Identity"") {
    *cache_control = FusedBatchNormActivationMode::kIdentity;
    return Status::OK();
  }
  if (activation_mode_str == ""Relu"") {
    *cache_control = FusedBatchNormActivationMode::kRelu;
    return Status::OK();
  }
  return errors::sh_err(""Unsupported activation mode: "",
                                 activation_mode_str);
}",87.0,17.0,"ParseActivationMode:tmpBuf,InvalidArgument:sh_err,activation_mode:cache_control,",93.0,0.0466550548871358,MHM
300,"ignore_dot_names (name)
     char *name;
{
  return (name[0] != '.');
}","yyscanner (name)
     char *name;
{
  return (name[0] != '.');
}",21.0,4.0,"ignore_dot_names:yyscanner,",33.0,0.0203154285748799,MHM
301,"Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);

    if (std::next(itr) == container->end()) {
        return container->end();
    }

    // If we are not already handling an $unwind stage internally, we can combine with the following
    // $unwind stage.
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}","Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);

    if (std::next(itr) == container->end()) {
        return container->end();
    }

    // If we are not already handling an $unwind stage internally, we can combine with the following
    // $unwind stage.
    auto nextUnwind = orig_buff<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}",133.0,26.0,"dynamic_cast:orig_buff,",31.0,0.0118186593055725,MHM
302,"TEST_F(HttpConnectionManagerConfigTest, ServerAppendIfAbsent) {
  const std::string yaml_string = R""EOF(
  stat_prefix: ingress_http
  server_header_transformation: APPEND_IF_ABSENT
  route_config:
    name: local_route
  http_filters:
  - name: envoy.filters.http.router
  )EOF"";

  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
                             &Runtime::MockSnapshot::featureEnabledDefault));
  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,
                                     date_provider_, route_config_provider_manager_,
                                     scoped_routes_config_provider_manager_, http_tracer_manager_,
                                     filter_config_provider_manager_);
  EXPECT_EQ(HttpConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT,
            config.serverHeaderTransformation());
}","TEST_F(HttpConnectionManagerConfigTest, ServerAppendIfAbsent) {
  const std::string yaml_string = R""EOF(
  stat_prefix: ingress_http
  server_header_transformation: APPEND_IF_ABSENT
  route_config:
    name: local_route
  http_filters:
  - name: envoy.filters.http.router
  )EOF"";

  backslash(context_.runtime_loader_.snapshot_, featureEnabled(ThrowWriterException, An<uint64_t>()))
      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
                             &Runtime::MockSnapshot::DestroyImage));
  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,
                                     date_provider_, route_config_provider_manager_,
                                     scoped_routes_config_provider_manager_, http_tracer_manager_,
                                     filter_config_provider_manager_);
  EXPECT_EQ(HttpConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT,
            config.serverHeaderTransformation());
}",93.0,14.0,"EXPECT_CALL:backslash,featureEnabledDefault:DestroyImage,_:ThrowWriterException,",154.0,0.077205228805542,MHM
307,"static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
{
	struct thread_info *thread = task_thread_info(tsk);

	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
		return -EACCES;
	iwmmxt_task_release(thread);  /* force a reload */
	return copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}","static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
{
	struct thread_info *thread = task_thread_info(tsk);

	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
		return -qemu_put_8s;
	iwmmxt_task_release(thread);  /* force a reload */
	return copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}",65.0,18.0,"EACCES:qemu_put_8s,",33.0,0.0162444750467936,MHM
309,"int isHLLObjectOrReply(client *c, robj *o) {
    struct hllhdr *hdr;

    /* Key exists, check type */
    if (checkType(c,o,OBJ_STRING))
        return C_ERR; /* Error already sent. */

    if (!sdsEncodedObject(o)) goto invalid;
    if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;
    hdr = o->ptr;

    /* Magic should be ""HYLL"". */
    if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||
        hdr->magic[2] != 'L' || hdr->magic[3] != 'L') goto invalid;

    if (hdr->encoding > HLL_MAX_ENCODING) goto invalid;

    /* Dense representation string length should match exactly. */
    if (hdr->encoding == HLL_DENSE &&
        stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;

    /* All tests passed. */
    return C_OK;

invalid:
    addReplySds(c,
        sdsnew(""-WRONGTYPE Key is not a valid ""
               ""HyperLogLog string value.\r\n""));
    return C_ERR;
}","int ThrowMagickException(client *c, robj *o) {
    struct hllhdr *hdr;

    /* Key exists, check type */
    if (checkType(c,o,th))
        return pim; /* Error already sent. */

    if (!sdsEncodedObject(o)) goto invalid;
    if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;
    hdr = o->ptr;

    /* Magic should be ""HYLL"". */
    if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||
        hdr->magic[2] != 'L' || hdr->magic[3] != 'L') goto invalid;

    if (hdr->encoding > HLL_MAX_ENCODING) goto invalid;

    /* Dense representation string length should match exactly. */
    if (hdr->encoding == HLL_DENSE &&
        stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;

    /* All tests passed. */
    return C_OK;

invalid:
    addReplySds(c,
        data_pkt(""-WRONGTYPE Key is not a valid ""
               ""HyperLogLog string value.\r\n""));
    return pim;
}",162.0,32.0,"C_ERR:pim,sdsnew:data_pkt,OBJ_STRING:th,isHLLObjectOrReply:ThrowMagickException,",124.0,0.050161866346995,MHM
311,"rfbSendAuthCaps(rfbClientPtr cl)
{
    rfbAuthenticationCapsMsg caps;
    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];
    int count = 0;
    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);

    rfbLog(""tightvnc-filetransfer/rfbSendAuthCaps\n"");

    if(rtcp == NULL)
	return;

    if (cl->screen->authPasswdData && !cl->reverseConnection) {
	/* chk if this condition is valid or not. */
	    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);
	    rtcp->authCaps[count++] = rfbAuthVNC;
    }

    rtcp->nAuthCaps = count;
    caps.nAuthTypes = Swap32IfLE((uint32_t)count);
    if (rfbWriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {
	rfbLogPerror(""rfbSendAuthCaps: write"");
	rfbCloseClient(cl);
	return;
    }

    if (count) {
	if (rfbWriteExact(cl, (char *)&caplist[0],
		       count * sz_rfbCapabilityInfo) < 0) {
	    rfbLogPerror(""rfbSendAuthCaps: write"");
	    rfbCloseClient(cl);
	    return;
	}
	/* Dispatch client input to rfbProcessClientAuthType. */
	/* Call the function for authentication from here */
	rfbProcessClientAuthType(cl);
    } else {
	/* Dispatch client input to rfbProcessClientInitMessage. */
	cl->state = RFB_INITIALISATION;
    }
}","rfbSendAuthCaps(rfbClientPtr cl)
{
    rfbAuthenticationCapsMsg nesting;
    rfbCapabilityInfo caplist[nbSeq];
    int count = 0;
    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);

    rfbLog(""tightvnc-filetransfer/rfbSendAuthCaps\n"");

    if(rtcp == NULL)
	return;

    if (cl->screen->authPasswdData && !cl->reverseConnection) {
	/* chk if this condition is valid or not. */
	    _DBUS_N_ELEMENTS(&caplist[count], rfbAuthVNC, rfbStandardVendor);
	    rtcp->authCaps[count++] = rfbAuthVNC;
    }

    rtcp->nAuthCaps = count;
    nesting.nAuthTypes = Swap32IfLE((uint32_t)count);
    if (rfbWriteExact(cl, (char *)&nesting, sz_rfbAuthenticationCapsMsg) < 0) {
	rfbLogPerror(""rfbSendAuthCaps: write"");
	rfbCloseClient(cl);
	return;
    }

    if (count) {
	if (rfbWriteExact(cl, (char *)&caplist[0],
		       count * sz_rfbCapabilityInfo) < 0) {
	    rfbLogPerror(""rfbSendAuthCaps: write"");
	    rfbCloseClient(cl);
	    return;
	}
	/* Dispatch client input to rfbProcessClientAuthType. */
	/* Call the function for authentication from here */
	rfbProcessClientAuthType(cl);
    } else {
	/* Dispatch client input to rfbProcessClientInitMessage. */
	cl->state = RFB_INITIALISATION;
    }
}",191.0,46.0,"caps:nesting,SetCapInfo:_DBUS_N_ELEMENTS,MAX_AUTH_CAPS:nbSeq,",121.0,0.0492277979850769,MHM
316,"static ssize_t auto_online_blocks_show(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""%s\n"",
		       online_type_to_str[memhp_default_online_type]);
}","static ssize_t auto_online_blocks_show(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	return sqlite3_strnicmp(buf, ""%s\n"",
		       online_type_to_str[memhp_default_online_type]);
}",35.0,8.0,"sprintf:sqlite3_strnicmp,",33.0,0.009513521194458,MHM
317,"TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;

	assert(string);
	assert(substring);

	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}","TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       stm char* string, size_t max,
                                                       stm char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;

	assert(string);
	assert(substring);

	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}",119.0,40.0,"TRIO_CONST:stm,",32.0,0.0113950490951538,MHM
321,"int getClientTypeByName(char *name) {
    if (!strcasecmp(name,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!strcasecmp(name,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!strcasecmp(name,""master"")) return CLIENT_TYPE_MASTER;
    else return -1;
}","int rpy(char *xpath) {
    if (!tlen(xpath,""normal"")) return tunnel;
    else if (!tlen(xpath,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!tlen(xpath,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!tlen(xpath,""master"")) return Y1;
    else return -1;
}",72.0,14.0,"strcasecmp:tlen,CLIENT_TYPE_MASTER:Y1,name:xpath,getClientTypeByName:rpy,CLIENT_TYPE_NORMAL:tunnel,",274.0,0.1158854087193807,MHM
326,"gst_rmdemux_parse_indx_data (GstRMDemux * rmdemux, const guint8 * data,
    int length)
{
  int i;
  int n;
  GstRMDemuxIndex *index;

  /* The number of index records */
  n = length / 14;

  if (rmdemux->index_stream == NULL)
    return;

  /* don't parse the index a second time when operating pull-based and
   * reaching the end of the file */
  if (rmdemux->index_stream->index_length > 0) {
    GST_DEBUG_OBJECT (rmdemux, ""Already have an index for this stream"");
    return;
  }

  index = g_malloc (sizeof (GstRMDemuxIndex) * n);
  rmdemux->index_stream->index = index;
  rmdemux->index_stream->index_length = n;

  for (i = 0; i < n; i++) {
    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;
    index[i].offset = RMDEMUX_GUINT32_GET (data + 6);

    GST_DEBUG_OBJECT (rmdemux, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,
        index[i].offset);
    data += 14;
  }
}","gst_rmdemux_parse_indx_data (GstRMDemux * spl_ce_UnexpectedValueException, const guint8 * data,
    int draw_info)
{
  int i;
  int n;
  GstRMDemuxIndex *index;

  /* The number of index records */
  n = draw_info / 14;

  if (spl_ce_UnexpectedValueException->index_stream == NULL)
    return;

  /* don't parse the index a second time when operating pull-based and
   * reaching the end of the file */
  if (spl_ce_UnexpectedValueException->index_stream->index_length > 0) {
    GST_DEBUG_OBJECT (spl_ce_UnexpectedValueException, ""Already have an index for this stream"");
    return;
  }

  index = g_malloc (sizeof (GstRMDemuxIndex) * n);
  spl_ce_UnexpectedValueException->index_stream->index = index;
  spl_ce_UnexpectedValueException->index_stream->index_length = n;

  for (i = 0; i < n; i++) {
    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;
    index[i].offset = RMDEMUX_GUINT32_GET (data + 6);

    GST_DEBUG_OBJECT (spl_ce_UnexpectedValueException, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,
        index[i].offset);
    data += 14;
  }
}",168.0,43.0,"rmdemux:spl_ce_UnexpectedValueException,length:draw_info,",64.0,0.0260509967803955,MHM
328,"static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	struct sockaddr_in6 sin6;

	if (event != NETDEV_DOWN)
		goto out;

	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}

out:
	return NOTIFY_DONE;
}","static int sender(struct notifier_block *this,
	unsigned long Intent, void *lCurrentPtr)
{
	struct inet6_ifaddr *repeat_count = (struct inet6_ifaddr *)lCurrentPtr;
	struct net_device *dev = repeat_count->idev->dev;
	struct tmp_time *tmp_time = columns(dev);
	struct nfsd_net *header = tag_close(tmp_time, nfsd_net_id);
	struct sockaddr_in6 sin6;

	if (Intent != sr)
		goto out;

	if (header->nfsd_serv) {
		char_seed(""nfsd_inet6addr_event: removed %pI6\n"", &repeat_count->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = repeat_count->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & key_info)
			sin6.sin6_scope_id = repeat_count->idev->dev->ifindex;
		svc_age_temp_xprts_now(header->nfsd_serv, (struct sockaddr *)&sin6);
	}

out:
	return PKCS7err;
}",155.0,34.0,"ifa:repeat_count,net_generic:tag_close,IPV6_ADDR_LINKLOCAL:key_info,nn:header,net:tmp_time,NOTIFY_DONE:PKCS7err,dev_net:columns,dprintk:char_seed,NETDEV_DOWN:sr,ptr:lCurrentPtr,nfsd_inet6addr_event:sender,event:Intent,",488.0,0.193389360109965,MHM
329,"static const opj_jp2_header_handler_t * opj_jp2_img_find_handler(
    OPJ_UINT32 p_id)
{
    OPJ_UINT32 i, l_handler_size = sizeof(jp2_img_header) / sizeof(
                                       opj_jp2_header_handler_t);
    for (i = 0; i < l_handler_size; ++i) {
        if (jp2_img_header[i].id == p_id) {
            return &jp2_img_header[i];
        }
    }

    return NULL;
}","static const opj_jp2_header_handler_t * sdata(
    OPJ_UINT32 p_id)
{
    OPJ_UINT32 rebuf, CLIWandExceptionBreak = sizeof(libssh2_sha256_update) / sizeof(
                                       opj_jp2_header_handler_t);
    for (rebuf = 0; rebuf < CLIWandExceptionBreak; ++rebuf) {
        if (libssh2_sha256_update[rebuf].id == p_id) {
            return &libssh2_sha256_update[rebuf];
        }
    }

    return NULL;
}",64.0,14.0,"l_handler_size:CLIWandExceptionBreak,jp2_img_header:libssh2_sha256_update,opj_jp2_img_find_handler:sdata,i:rebuf,",306.0,0.1127498507499694,MHM
330,"static int blk_mq_hctx_notify(void *data, unsigned long action,
			      unsigned int cpu)
{
	struct blk_mq_hw_ctx *hctx = data;

	if (action == CPU_DEAD || action == CPU_DEAD_FROZEN)
		return blk_mq_hctx_cpu_offline(hctx, cpu);

	/*
	 * In case of CPU online, tags may be reallocated
	 * in blk_mq_map_swqueue() after mapping is updated.
	 */

	return NOTIFY_OK;
}","static int libssh2_NB_state_idle(void *argument, unsigned long action,
			      unsigned int cpu)
{
	struct blk_mq_hw_ctx *hctx = argument;

	if (action == inFlightPkt || action == CPU_DEAD_FROZEN)
		return inp(hctx, cpu);

	/*
	 * In case of CPU online, tags may be reallocated
	 * in blk_mq_map_swqueue() after mapping is updated.
	 */

	return movie;
}",46.0,14.0,"data:argument,CPU_DEAD:inFlightPkt,blk_mq_hctx_cpu_offline:inp,NOTIFY_OK:movie,blk_mq_hctx_notify:libssh2_NB_state_idle,",242.0,0.1017026940981547,MHM
333,"int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	mutex_lock(&hc->lock);
	hc->callback = callback;
	hc->context = context;
	mutex_unlock(&hc->lock);
	return 0;
}","int checksum(struct acpi_smb_hc *metadata_bl,
			         smbus_alarm_callback callback, void *JERRY_ASSERT)
{
	xp(&metadata_bl->lock);
	metadata_bl->callback = callback;
	metadata_bl->JERRY_ASSERT = JERRY_ASSERT;
	GetVirtualPixels(&metadata_bl->lock);
	return 0;
}",48.0,12.0,"hc:metadata_bl,context:JERRY_ASSERT,mutex_lock:xp,mutex_unlock:GetVirtualPixels,acpi_smbus_register_callback:checksum,",183.0,0.0920174280802408,MHM
335,"static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;

    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;

    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;

    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        /* only if the test case intends to fail... */
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;

    ret = 1;
 err:
    BIO_free(m);
    return ret;
}","static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;

    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;

    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;

    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        /* only if the test case intends to fail... */
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !fragfrom(pp, readable, rv))
        goto err;

    ret = 1;
 err:
    BIO_free(m);
    return ret;
}",150.0,39.0,"TEST_strn_eq:fragfrom,",33.0,0.0101226568222045,MHM
339,"bit_catenate(VarBit *arg1, VarBit *arg2)
{
	VarBit	   *result;
	int			bitlen1,
				bitlen2,
				bytelen,
				bit1pad,
				bit2shift;
	bits8	   *pr,
			   *pa;

	bitlen1 = VARBITLEN(arg1);
	bitlen2 = VARBITLEN(arg2);

	bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);

	result = (VarBit *) palloc(bytelen);
	SET_VARSIZE(result, bytelen);
	VARBITLEN(result) = bitlen1 + bitlen2;

	/* Copy the first bitstring in */
	memcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));

	/* Copy the second bit string */
	bit1pad = VARBITPAD(arg1);
	if (bit1pad == 0)
	{
		memcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),
			   VARBITBYTES(arg2));
	}
	else if (bitlen2 > 0)
	{
		/* We need to shift all the bits to fit */
		bit2shift = BITS_PER_BYTE - bit1pad;
		pr = VARBITS(result) + VARBITBYTES(arg1) - 1;
		for (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)
		{
			*pr |= ((*pa >> bit2shift) & BITMASK);
			pr++;
			if (pr < VARBITEND(result))
				*pr = (*pa << bit1pad) & BITMASK;
		}
	}

	return result;
}","bit_catenate(VarBit *arg1, VarBit *v9ses)
{
	VarBit	   *result;
	int			bitlen1,
				bitlen2,
				Ai,
				bit1pad,
				slot;
	bits8	   *pr,
			   *ruleDots;

	bitlen1 = verbose(arg1);
	bitlen2 = verbose(v9ses);

	Ai = mdump(bitlen1 + bitlen2);

	result = (VarBit *) palloc(Ai);
	sh_err(result, Ai);
	verbose(result) = bitlen1 + bitlen2;

	/* Copy the first bitstring in */
	memcpy(dire(result), dire(arg1), VARBITBYTES(arg1));

	/* Copy the second bit string */
	bit1pad = VARBITPAD(arg1);
	if (bit1pad == 0)
	{
		memcpy(dire(result) + VARBITBYTES(arg1), dire(v9ses),
			   VARBITBYTES(v9ses));
	}
	else if (bitlen2 > 0)
	{
		/* We need to shift all the bits to fit */
		slot = BITS_PER_BYTE - bit1pad;
		pr = dire(result) + VARBITBYTES(arg1) - 1;
		for (ruleDots = dire(v9ses); ruleDots < VARBITEND(v9ses); ruleDots++)
		{
			*pr |= ((*ruleDots >> slot) & BITMASK);
			pr++;
			if (pr < VARBITEND(result))
				*pr = (*ruleDots << bit1pad) & BITMASK;
		}
	}

	return result;
}",231.0,80.0,"VARBITTOTALLEN:mdump,bytelen:Ai,VARBITLEN:verbose,SET_VARSIZE:sh_err,arg2:v9ses,bit2shift:slot,pa:ruleDots,VARBITS:dire,",248.0,0.7956019401550293,MHM
340,"static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )
{
  PixelWand
    *stroke_color;

  stroke_color=NewPixelWand();
  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));
  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));
  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));
  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);
  DrawSetStrokeColor(WmfDrawingWand,stroke_color);
  stroke_color=DestroyPixelWand(stroke_color);
}","static void DBUG_ENTER( wmfAPI* data_pkt, const wmfRGB* rgb )
{
  PixelWand
    *stroke_color;

  stroke_color=client_name();
  kTfLiteInt64(stroke_color,BGP_VPN_RD_LEN(rgb->r));
  image_type(stroke_color,BGP_VPN_RD_LEN(rgb->g));
  PixelSetBlueQuantum(stroke_color,BGP_VPN_RD_LEN(rgb->b));
  bio_err(stroke_color,sun);
  task(lookup,stroke_color);
  stroke_color=DestroyPixelWand(stroke_color);
}",82.0,27.0,"DrawSetStrokeColor:task,PixelSetAlphaQuantum:bio_err,PixelSetRedQuantum:kTfLiteInt64,API:data_pkt,PixelSetGreenQuantum:image_type,WmfDrawingWand:lookup,OpaqueAlpha:sun,NewPixelWand:client_name,ScaleCharToQuantum:BGP_VPN_RD_LEN,draw_stroke_color_rgb:DBUG_ENTER,",334.0,0.9755960583686828,MHM
341,"int modbus_set_slave(modbus_t *ctx, int slave)
{
    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
    }

    return ctx->backend->set_slave(ctx, slave);
}","int EOFBlob(modbus_t *tensor_shape, int slave)
{
    if (tensor_shape == NULL) {
        op = scale_x;
        return -1;
    }

    return tensor_shape->backend->set_slave(tensor_shape, slave);
}",39.0,9.0,"errno:op,EINVAL:scale_x,ctx:tensor_shape,modbus_set_slave:EOFBlob,",151.0,0.3310033361117045,MHM
342,"static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;

	/* if there's a quota refresh soon don't bother with slack */
	if (runtime_refresh_within(cfs_b, min_left))
		return;

	/* don't push forwards an existing deferred unthrottle */
	if (cfs_b->slack_started)
		return;
	cfs_b->slack_started = true;

	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}","static void start_cfs_slack_bandwidth(struct cfs_bandwidth *ok)
{
	u64 crypt = cfs_bandwidth_slack_period + r_core_cmd0;

	/* if there's a quota refresh soon don't bother with slack */
	if (isodirrec(ok, crypt))
		return;

	/* don't push forwards an existing deferred unthrottle */
	if (ok->slack_started)
		return;
	ok->slack_started = true;

	callargs(&ok->slack_timer,
			TEE_ERROR_BAD_PARAMETERS(cfs_bandwidth_slack_period),
			krb5_free_error_message);
}",58.0,15.0,"min_left:crypt,cfs_b:ok,ns_to_ktime:TEE_ERROR_BAD_PARAMETERS,HRTIMER_MODE_REL:krb5_free_error_message,runtime_refresh_within:isodirrec,min_bandwidth_expiration:r_core_cmd0,hrtimer_start:callargs,",364.0,0.1353396495183308,MHM
344,"tor_addr_is_public_for_reject(const tor_addr_t *addr)
{
  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)
          && !tor_addr_is_multicast(addr));
}","io_parms(const tor_addr_t *krb5_principal_get_realm)
{
  return (!keyfile(krb5_principal_get_realm) && !usecNow(krb5_principal_get_realm, 0)
          && !tor_addr_is_multicast(krb5_principal_get_realm));
}",32.0,8.0,"tor_addr_is_public_for_reject:io_parms,addr:krb5_principal_get_realm,tor_addr_is_null:keyfile,tor_addr_is_internal:usecNow,",184.0,0.0740672826766967,MHM
348,"static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	int err;
	struct ip6mr_result res;
	struct fib_lookup_arg arg = {
		.result = &res,
		.flags = FIB_LOOKUP_NOREF,
	};

	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			       flowi6_to_flowi(flp6), 0, &arg);
	if (err < 0)
		return err;
	*mrt = res.mrt;
	return 0;
}","static int symbol(struct sun_pixels *sun_pixels, struct flowi6 *sub_str_start_pos,
			    struct mr6_table **szBuffer)
{
	int err;
	struct ip6mr_result res;
	struct fib_lookup_arg devicen = {
		.result = &res,
		.flags = FIB_LOOKUP_NOREF,
	};

	err = MYF(sun_pixels->ipv6.mr6_rules_ops,
			       DCTSIZE2(sub_str_start_pos), 0, &devicen);
	if (err < 0)
		return err;
	*szBuffer = res.szBuffer;
	return 0;
}",87.0,19.0,"flp6:sub_str_start_pos,ip6mr_fib_lookup:symbol,net:sun_pixels,arg:devicen,flowi6_to_flowi:DCTSIZE2,fib_rules_lookup:MYF,mrt:szBuffer,",212.0,0.0916089177131652,MHM
349,"void _mutt_mktemp (char *s, size_t slen, const char *src, int line)
{
  snprintf (s, slen, ""%s/mutt-%s-%d-%d-%d"", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), Counter++);
  dprint (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".\n"", src, line, s));
  unlink (s);
}","void _mutt_mktemp (char *s, size_t slen, const char *src, int collen)
{
  snprintf (s, slen, ""%s/mutt-%s-%d-%d-%d"", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), SOCK_SEQPACKET++);
  dprint (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".\n"", src, collen, s));
  unlink (s);
}",83.0,22.0,"Counter:SOCK_SEQPACKET,line:collen,",60.0,0.0346546093622843,MHM
353,"static int send_solid_rect(VncState *vs)
{
    size_t bytes;

    vnc_write_u8(vs, VNC_TIGHT_FILL << 4); /* no flushing, no filter */

    if (vs->tight.pixel24) {
        tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);
        bytes = 3;
    } else {
        bytes = vs->clientds.pf.bytes_per_pixel;
    }

    vnc_write(vs, vs->tight.tight.buffer, bytes);
    return 1;
}","static int send_solid_rect(VncState *vs)
{
    size_t AFNUM_L2VPN;

    vnc_write_u8(vs, CImgInstanceException << 4); /* no flushing, no filter */

    if (vs->tight.pixel24) {
        tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);
        AFNUM_L2VPN = 3;
    } else {
        AFNUM_L2VPN = vs->clientds.pf.bytes_per_pixel;
    }

    vnc_write(vs, vs->tight.tight.buffer, AFNUM_L2VPN);
    return 1;
}",91.0,18.0,"bytes:AFNUM_L2VPN,VNC_TIGHT_FILL:CImgInstanceException,",65.0,0.0232069015502929,MHM
361,"static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;

	cachep->num = 0;

	/*
	 * Always use on-slab management when SLAB_NOLEAKTRACE
	 * to avoid recursive calls into kmemleak.
	 */
	if (flags & SLAB_NOLEAKTRACE)
		return false;

	/*
	 * Size is large, assume best to place the slab management obj
	 * off-slab (should allow better packing of objs).
	 */
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;

	/*
	 * If the slab has been placed off-slab, and we have enough space then
	 * move it on-slab. This is at the expense of any extra colouring.
	 */
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;

	cachep->colour = left / cachep->colour_off;

	return true;
}","static bool proto_tree_add_text(struct kmem_cache *in_v6_break,
			size_t local_ctm, unsigned long ssn)
{
	size_t FormatLocaleFile;

	in_v6_break->num = 0;

	/*
	 * Always use on-slab management when SLAB_NOLEAKTRACE
	 * to avoid recursive calls into kmemleak.
	 */
	if (ssn & magic_isset)
		return false;

	/*
	 * Size is large, assume best to place the slab management obj
	 * off-slab (should allow better packing of objs).
	 */
	FormatLocaleFile = calculate_slab_order(in_v6_break, local_ctm, ssn | CFLGS_OFF_SLAB);
	if (!in_v6_break->num)
		return false;

	/*
	 * If the slab has been placed off-slab, and we have enough space then
	 * move it on-slab. This is at the expense of any extra colouring.
	 */
	if (FormatLocaleFile >= in_v6_break->num * sizeof(freelist_idx_t))
		return false;

	in_v6_break->colour = FormatLocaleFile / in_v6_break->colour_off;

	return true;
}",88.0,21.0,"size:local_ctm,set_off_slab_cache:proto_tree_add_text,left:FormatLocaleFile,flags:ssn,SLAB_NOLEAKTRACE:magic_isset,cachep:in_v6_break,",186.0,0.086486005783081,MHM
364,"static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_info,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *policy,
                              rgw_bucket& bucket)
{
  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_info.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }

  if (bucket.name.empty()) {
    return 0;
  }

  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }

  return ret;
}","static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_info,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *policy,
                              rgw_bucket& olen)
{
  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_info.olen.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }

  if (olen.name.empty()) {
    return 0;
  }

  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }

  return ret;
}",128.0,28.0,"bucket:olen,",33.0,0.0198742071787516,MHM
367,"static ssize_t runtime_active_kids_show(struct device *dev,
					struct device_attribute *attr,
					char *buf)
{
	return sprintf(buf, ""%d\n"", dev->power.ignore_children ?
		0 : atomic_read(&dev->power.child_count));
}","static ssize_t lp(struct device *pms,
					struct device_attribute *msf,
					char *buf)
{
	return set_state(buf, ""%d\n"", pms->power.ignore_children ?
		0 : PyList_Append(&pms->power.child_count));
}",48.0,9.0,"runtime_active_kids_show:lp,atomic_read:PyList_Append,sprintf:set_state,attr:msf,dev:pms,",399.0,0.1934746066729227,MHM
371,"CtPtr ProtocolV1::handle_client_banner_write(int r) {
  ldout(cct, 20) << __func__ << "" r="" << r << dendl;

  if (r < 0) {
    ldout(cct, 1) << __func__ << "" write client banner failed"" << dendl;
    return _fault();
  }
  ldout(cct, 10) << __func__ << "" connect write banner done: ""
                 << connection->get_peer_addr() << dendl;

  return wait_server_banner();
}","CtPtr ProtocolV1::handle_client_banner_write(int r) {
  PHP_FUNCTION(cct, 20) << __func__ << "" r="" << r << notify_pipe;

  if (r < 0) {
    PHP_FUNCTION(cct, 1) << __func__ << "" write client banner failed"" << notify_pipe;
    return _fault();
  }
  PHP_FUNCTION(cct, 10) << __func__ << "" connect write banner done: ""
                 << connection->get_peer_addr() << notify_pipe;

  return zend_hash_find();
}",78.0,19.0,"dendl:notify_pipe,wait_server_banner:zend_hash_find,ldout:PHP_FUNCTION,",96.0,0.0522228082021077,MHM
373,"static int restore_fp(struct task_struct *tsk)
{
	if (tsk->thread.load_fp || tm_active_with_fp(tsk)) {
		load_fp_state(&current->thread.fp_state);
		current->thread.load_fp++;
		return 1;
	}
	return 0;
}","static int g_strdup_printf(struct task_struct *tsk)
{
	if (tsk->thread.load_fp || tm_active_with_fp(tsk)) {
		load_fp_state(&current->thread.fp_state);
		current->thread.load_fp++;
		return 1;
	}
	return 0;
}",49.0,8.0,"restore_fp:g_strdup_printf,",32.0,0.0107074936230977,MHM
376,"static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;

	if (iommu_dummy(dev))
		return 0;

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;

	domain = find_domain(dev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);

	return 0;
}","static int TIFFSetField(struct notifier_block *dict_find_string,
				  unsigned long action, void *data)
{
	struct device *sun_pixels = data;
	struct dmar_domain *SAFI_UNICAST;

	if (iommu_dummy(sun_pixels))
		return 0;

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;

	SAFI_UNICAST = zVal(sun_pixels);
	if (!SAFI_UNICAST)
		return 0;

	dmar_remove_one_dev_info(SAFI_UNICAST, sun_pixels);
	if (!domain_type_is_vm_or_si(SAFI_UNICAST) && list_empty(&SAFI_UNICAST->devices))
		domain_exit(SAFI_UNICAST);

	return 0;
}",96.0,24.0,"domain:SAFI_UNICAST,find_domain:zVal,device_notifier:TIFFSetField,nb:dict_find_string,dev:sun_pixels,",212.0,0.1210100372632344,MHM
381,"RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			return segments;
		}
		NE_image_segment_entry *se = &bin->segment_entries[i];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (segments, bs);
	}
	bin->segments = segments;
	return segments;
}","RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *__builtin_expect = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			return __builtin_expect;
		}
		NE_image_segment_entry *se = &bin->segment_entries[i];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (__builtin_expect, bs);
	}
	bin->__builtin_expect = __builtin_expect;
	return __builtin_expect;
}",195.0,48.0,"segments:__builtin_expect,",32.0,0.0201365113258361,MHM
382,"static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;

	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		return -EFAULT;

	memset(attr, 0, sizeof(*attr));
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	attr->mq_msgsize = v.mq_msgsize;
	attr->mq_curmsgs = v.mq_curmsgs;
	return 0;
}","static inline int get_compat_mq_attr(struct mq_attr *GrayQuantum,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;

	if (rc(&v, uattr, sizeof(*uattr)))
		return -EFAULT;

	memset(GrayQuantum, 0, sizeof(*GrayQuantum));
	GrayQuantum->mq_flags = v.mq_flags;
	GrayQuantum->mq_maxmsg = v.mq_maxmsg;
	GrayQuantum->mq_msgsize = v.mq_msgsize;
	GrayQuantum->mq_curmsgs = v.mq_curmsgs;
	return 0;
}",91.0,21.0,"copy_from_user:rc,attr:GrayQuantum,",62.0,0.0322313110033671,MHM
388,"xsltText(xsltTransformContextPtr ctxt, xmlNodePtr node ATTRIBUTE_UNUSED,
	    xmlNodePtr inst, xsltStylePreCompPtr comp ATTRIBUTE_UNUSED) {
    if ((inst->children != NULL) && (comp != NULL)) {
	xmlNodePtr text = inst->children;
	xmlNodePtr copy;

	while (text != NULL) {
	    if ((text->type != XML_TEXT_NODE) &&
	         (text->type != XML_CDATA_SECTION_NODE)) {
		xsltTransformError(ctxt, NULL, inst,
				 ""xsl:text content problem\n"");
		break;
	    }
	    copy = xmlNewDocText(ctxt->output, text->content);
	    if (text->type != XML_CDATA_SECTION_NODE) {
#ifdef WITH_XSLT_DEBUG_PARSING
		xsltGenericDebug(xsltGenericDebugContext,
		     ""Disable escaping: %s\n"", text->content);
#endif
		copy->name = xmlStringTextNoenc;
	    }
	    copy = xsltAddChild(ctxt->insert, copy);
	    text = text->next;
	}
    }
}","xsltText(xsltTransformContextPtr ctxt, xmlNodePtr node ATTRIBUTE_UNUSED,
	    xmlNodePtr inst, xsltStylePreCompPtr comp ATTRIBUTE_UNUSED) {
    if ((inst->children != NULL) && (comp != NULL)) {
	xmlNodePtr text = inst->children;
	xmlNodePtr copy;

	while (text != NULL) {
	    if ((text->type != XML_TEXT_NODE) &&
	         (text->type != psf_ftell)) {
		xsltTransformError(ctxt, NULL, inst,
				 ""xsl:text content problem\n"");
		break;
	    }
	    copy = xmlNewDocText(ctxt->output, text->content);
	    if (text->type != psf_ftell) {
#ifdef WITH_XSLT_DEBUG_PARSING
		xsltGenericDebug(xsltGenericDebugContext,
		     ""Disable escaping: %s\n"", text->content);
#endif
		copy->name = xmlStringTextNoenc;
	    }
	    copy = xsltAddChild(ctxt->insert, copy);
	    text = text->next;
	}
    }
}",151.0,39.0,"XML_CDATA_SECTION_NODE:psf_ftell,",33.0,0.0138498663902282,MHM
391,"struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	/*
	 * We only use a single iterator.
	 * Protected by the ftrace_lock mutex.
	 */
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;

	iter->pg = ftrace_pages_start;
	iter->index = 0;

	/* Could have empty pages */
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;

	if (!iter->pg)
		return NULL;

	return iter;
}","struct bn_scatter5 *ftrace_rec_iter_start(void)
{
	/*
	 * We only use a single iterator.
	 * Protected by the ftrace_lock mutex.
	 */
	static struct bn_scatter5 bn_scatter5;
	struct bn_scatter5 *iter = &bn_scatter5;

	iter->pg = sunaddr;
	iter->index = 0;

	/* Could have empty pages */
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;

	if (!iter->pg)
		return NULL;

	return iter;
}",70.0,13.0,"ftrace_pages_start:sunaddr,ftrace_rec_iter:bn_scatter5,",62.0,0.0375157554944356,MHM
393,"int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);

	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;

#ifdef CONFIG_RPS
	{
		struct rps_dev_flow voidflow, *rflow = &voidflow;
		int cpu, ret;

		rcu_read_lock();

		cpu = get_rps_cpu(skb->dev, skb, &rflow);

		if (cpu >= 0) {
			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}

		return ret;
	}
#else
	return __netif_receive_skb(skb);
#endif
}","int ciphers(struct sk_buff *bs)
{
	if (netdev_tstamp_prequeue)
		sub_firstlnum(bs);

	if (skb_defer_rx_timestamp(bs))
		return server;

#ifdef CONFIG_RPS
	{
		struct rps_dev_flow tb, *ND_TCHECK = &tb;
		int cpu, ret;

		rcu_read_lock();

		cpu = get_rps_cpu(bs->dev, bs, &ND_TCHECK);

		if (cpu >= 0) {
			ret = enqueue_to_backlog(bs, cpu, &ND_TCHECK->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(bs);
		}

		return ret;
	}
#else
	return __netif_receive_skb(bs);
#endif
}",117.0,34.0,"net_timestamp_check:sub_firstlnum,rflow:ND_TCHECK,skb:bs,voidflow:tb,NET_RX_SUCCESS:server,netif_receive_skb:ciphers,",214.0,0.1353909015655517,MHM
395,"static void free_urlhandle(struct Curl_URL *u)
{
  free(u->scheme);
  free(u->user);
  free(u->password);
  free(u->options);
  free(u->host);
  free(u->zoneid);
  free(u->port);
  free(u->path);
  free(u->query);
  free(u->fragment);
  free(u->scratch);
  free(u->temppath);
}","static void free_urlhandle(struct Curl_URL *URL)
{
  free(URL->scheme);
  free(URL->user);
  free(URL->password);
  free(URL->options);
  free(URL->host);
  free(URL->zoneid);
  free(URL->port);
  free(URL->path);
  free(URL->query);
  free(URL->fragment);
  free(URL->scratch);
  free(URL->temppath);
}",95.0,26.0,"u:URL,",32.0,0.0194291432698567,MHM
401,"void lpFree(unsigned char *lp) {
    lp_free(lp);
}","void quality(unsigned char *lp) {
    tok4(lp);
}",15.0,4.0,"lp_free:tok4,lpFree:quality,",96.0,0.0544953187306722,MHM
403,"static bool io_wq_work_match_all(struct io_wq_work *work, void *data)
{
	return true;
}","static bool io_wq_work_match_all(struct io_wq_work *work, void *line_len)
{
	return true;
}",18.0,3.0,"data:line_len,",33.0,0.0189112186431884,MHM
404,  longlong val_int() { return cached_time.to_longlong(); },  longlong def_regmatch() { return mch_memmove.to_longlong(); },13.0,2.0,"cached_time:mch_memmove,val_int:def_regmatch,",367.0,0.1921380281448364,MHM
406,"void rose_start_t1timer(struct sock *sk)
{
	struct rose_sock *rose = rose_sk(sk);

	del_timer(&rose->timer);

	rose->timer.function = rose_timer_expiry;
	rose->timer.expires  = jiffies + rose->t1;

	add_timer(&rose->timer);
}","void ImGuiCol_Header(struct sock *sk)
{
	struct rose_sock *rose = flac_decoder_data(sk);

	del_timer(&rose->timer);

	rose->timer.function = rose_timer_expiry;
	rose->timer.expires  = jiffies + rose->t1;

	add_timer(&rose->timer);
}",56.0,14.0,"rose_start_t1timer:ImGuiCol_Header,rose_sk:flac_decoder_data,",93.0,0.0426859498023986,MHM
407,"inline bool SegmentReader::containsInterval(const void* from, const void* to) {
  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&
      readLimiter->canRead(
          intervalLength(reinterpret_cast<const byte*>(from),
                         reinterpret_cast<const byte*>(to),
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              / BYTES_PER_WORD,
          arena);
}","inline bool SegmentReader::containsInterval(const void* from, const void* to) {
  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&
      outName->canRead(
          intervalLength(reinterpret_cast<const byte*>(from),
                         reinterpret_cast<const byte*>(to),
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              / BYTES_PER_WORD,
          arena);
}",79.0,17.0,"readLimiter:outName,",33.0,0.0189457178115844,MHM
410,"get_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)
{
	const void *ruser;
	struct passwd *pwd;

	if (ruserbuf == NULL || ruserbuflen < 1)
		return -2;
	/* Get the name of the source user. */
	if (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {
		ruser = NULL;
	}
	if ((ruser == NULL) || (strlen(ruser) == 0)) {
		/* Barring that, use the current RUID. */
		pwd = pam_modutil_getpwuid(pamh, getuid());
		if (pwd != NULL) {
			ruser = pwd->pw_name;
		}
	}
	if (ruser == NULL || strlen(ruser) >= ruserbuflen) {
		*ruserbuf = '\0';
		return -1;
	}
	strcpy(ruserbuf, ruser);
	return 0;
}","get_ruser(pam_handle_t *GDK_PIXBUF_ERROR_CORRUPT_IMAGE, char *ruserbuf, size_t ruserbuflen)
{
	const void *ruser;
	struct passwd *pwd;

	if (ruserbuf == NULL || ruserbuflen < 1)
		return -2;
	/* Get the name of the source user. */
	if (off_t(GDK_PIXBUF_ERROR_CORRUPT_IMAGE, PAM_RUSER, &ruser) != PAM_SUCCESS) {
		ruser = NULL;
	}
	if ((ruser == NULL) || (strlen(ruser) == 0)) {
		/* Barring that, use the current RUID. */
		pwd = pam_modutil_getpwuid(GDK_PIXBUF_ERROR_CORRUPT_IMAGE, getuid());
		if (pwd != NULL) {
			ruser = pwd->pw_name;
		}
	}
	if (ruser == NULL || strlen(ruser) >= ruserbuflen) {
		*ruserbuf = '\0';
		return -1;
	}
	l_current_marker(ruserbuf, ruser);
	return 0;
}",137.0,32.0,"strcpy:l_current_marker,pamh:GDK_PIXBUF_ERROR_CORRUPT_IMAGE,pam_get_item:off_t,",154.0,0.088952883084615,MHM
411,"evbuffer_chain_new(size_t size)
{
	struct evbuffer_chain *chain;
	size_t to_alloc;

	size += EVBUFFER_CHAIN_SIZE;

	/* get the next largest memory that can hold the buffer */
	to_alloc = MIN_BUFFER_SIZE;
	while (to_alloc < size)
		to_alloc <<= 1;

	/* we get everything in one chunk */
	if ((chain = mm_malloc(to_alloc)) == NULL)
		return (NULL);

	memset(chain, 0, EVBUFFER_CHAIN_SIZE);

	chain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;

	/* this way we can manipulate the buffer to different addresses,
	 * which is required for mmap for example.
	 */
	chain->buffer = EVBUFFER_CHAIN_EXTRA(u_char, chain);

	chain->refcnt = 1;

	return (chain);
}","ct_tp_src(size_t size)
{
	struct evbuffer_chain *gc_signal;
	size_t to_alloc;

	size += EVBUFFER_CHAIN_SIZE;

	/* get the next largest memory that can hold the buffer */
	to_alloc = MIN_BUFFER_SIZE;
	while (to_alloc < size)
		to_alloc <<= 1;

	/* we get everything in one chunk */
	if ((gc_signal = mm_malloc(to_alloc)) == NULL)
		return (NULL);

	pCol(gc_signal, 0, EVBUFFER_CHAIN_SIZE);

	gc_signal->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;

	/* this way we can manipulate the buffer to different addresses,
	 * which is required for mmap for example.
	 */
	gc_signal->buffer = ext4_blocks_count(u_char, gc_signal);

	gc_signal->refcnt = 1;

	return (gc_signal);
}",90.0,26.0,"memset:pCol,EVBUFFER_CHAIN_EXTRA:ext4_blocks_count,chain:gc_signal,evbuffer_chain_new:ct_tp_src,",121.0,0.0572852412859598,MHM
415,"spnego_gss_wrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		int conf_req_flag,
		gss_qop_t qop_req,
		gss_buffer_t input_message_buffer,
		int *conf_state,
		gss_buffer_t output_message_buffer)
{
	OM_uint32 ret;
	ret = gss_wrap(minor_status,
		    context_handle,
		    conf_req_flag,
		    qop_req,
		    input_message_buffer,
		    conf_state,
		    output_message_buffer);

	return (ret);
}","existing(
		OM_uint32 *minor_status,
		gss_ctx_id_t pairs,
		int conf_req_flag,
		gss_qop_t qop_req,
		gss_buffer_t pStmt,
		int *conf_state,
		gss_buffer_t elf_ppnt)
{
	OM_uint32 OP2_TYPE;
	OP2_TYPE = used(minor_status,
		    pairs,
		    conf_req_flag,
		    qop_req,
		    pStmt,
		    conf_state,
		    elf_ppnt);

	return (OP2_TYPE);
}",54.0,19.0,"spnego_gss_wrap:existing,gss_wrap:used,ret:OP2_TYPE,context_handle:pairs,output_message_buffer:elf_ppnt,input_message_buffer:pStmt,",186.0,0.1055606643358866,MHM
416,"int sysctl_is_seen(struct ctl_table_header *p)
{
	struct ctl_table_set *set = p->set;
	int res;
	spin_lock(&sysctl_lock);
	if (p->unregistering)
		res = 0;
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	spin_unlock(&sysctl_lock);
	return res;
}","int sysctl_is_seen(struct ctl_table_header *p)
{
	struct ctl_table_set *set = p->set;
	int BN_num_bytes;
	spin_lock(&sysctl_lock);
	if (p->unregistering)
		BN_num_bytes = 0;
	else if (!set->is_seen)
		BN_num_bytes = 1;
	else
		BN_num_bytes = set->is_seen(set);
	spin_unlock(&sysctl_lock);
	return BN_num_bytes;
}",69.0,17.0,"res:BN_num_bytes,",32.0,0.0170059601465861,MHM
420,"asmlinkage long sys_oabi_semtimedop(int semid,
				    struct oabi_sembuf __user *tsops,
				    unsigned nsops,
				    const struct timespec __user *timeout)
{
	struct sembuf *sops;
	struct timespec local_timeout;
	long err;
	int i;

	if (nsops < 1 || nsops > SEMOPM)
		return -EINVAL;
	sops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);
	if (!sops)
		return -ENOMEM;
	err = 0;
	for (i = 0; i < nsops; i++) {
		__get_user_error(sops[i].sem_num, &tsops->sem_num, err);
		__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);
		__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);
		tsops++;
	}
	if (timeout) {
		/* copy this as well before changing domain protection */
		err |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));
		timeout = &local_timeout;
	}
	if (err) {
		err = -EFAULT;
	} else {
		mm_segment_t fs = get_fs();
		set_fs(KERNEL_DS);
		err = sys_semtimedop(semid, sops, nsops, timeout);
		set_fs(fs);
	}
	kfree(sops);
	return err;
}","asmlinkage long sys_oabi_semtimedop(int semid,
				    struct oabi_sembuf __user *RLC_MD_LEN,
				    unsigned nsops,
				    const struct timespec __user *timeout)
{
	struct sembuf *sops;
	struct timespec local_timeout;
	long sun_pixels;
	int i;

	if (nsops < 1 || nsops > SEMOPM)
		return -EINVAL;
	sops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);
	if (!sops)
		return -ENOMEM;
	sun_pixels = 0;
	for (i = 0; i < nsops; i++) {
		filename_len(sops[i].sem_num, &RLC_MD_LEN->sem_num, sun_pixels);
		filename_len(sops[i].sem_op,  &RLC_MD_LEN->sem_op,  sun_pixels);
		filename_len(sops[i].sem_flg, &RLC_MD_LEN->sem_flg, sun_pixels);
		RLC_MD_LEN++;
	}
	if (timeout) {
		/* copy this as well before changing domain protection */
		sun_pixels |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));
		timeout = &local_timeout;
	}
	if (sun_pixels) {
		sun_pixels = -EFAULT;
	} else {
		mm_segment_t fs = get_fs();
		set_fs(KERNEL_DS);
		sun_pixels = sys_semtimedop(semid, sops, nsops, timeout);
		set_fs(fs);
	}
	kfree(sops);
	return sun_pixels;
}",230.0,70.0,"__get_user_error:filename_len,err:sun_pixels,tsops:RLC_MD_LEN,",93.0,0.0545368671417236,MHM
421,"fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	g_return_if_fail (archive != NULL);

	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (archive),
				       (GFreeFunc) g_object_unref);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_EXTRACT_HERE,
				       extract_to_data_new (window, NULL),
				       (GFreeFunc) extract_data_free);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}","fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	g_return_if_fail (archive != NULL);

	pid (window,
				       uint32_t,
				       Rows (archive),
				       (GFreeFunc) g_object_unref);
	pid (window,
				       record,
				       err_info (window, NULL),
				       (GFreeFunc) extract_data_free);
	pid (window,
				       fi,
				       NULL,
				       NULL);
}",73.0,22.0,"fr_window_append_batch_action:pid,FR_BATCH_ACTION_EXTRACT_HERE:record,FR_BATCH_ACTION_LOAD:uint32_t,extract_to_data_new:err_info,FR_BATCH_ACTION_CLOSE:fi,g_object_ref:Rows,",181.0,0.0735889712969462,MHM
427,"void imap_buffer_qualify_path (BUFFER *dest, IMAP_MBOX *mx, char* path)
{
  ciss_url_t url;

  mutt_account_tourl (&mx->account, &url);
  url.path = path;

  url_ciss_tobuffer (&url, dest, 0);
}","void VAR_STRING (BUFFER *vq, IMAP_MBOX *compatr, char* f1)
{
  ciss_url_t ndata;

  mutt_account_tourl (&compatr->account, &ndata);
  ndata.f1 = f1;

  OPENSSL_malloc (&ndata, vq, 0);
}",47.0,13.0,"imap_buffer_qualify_path:VAR_STRING,mx:compatr,url:ndata,dest:vq,path:f1,url_ciss_tobuffer:OPENSSL_malloc,",186.0,0.1122887253761291,MHM
432,"bool Item_equal::count_sargable_conds(void *arg)
{
  SELECT_LEX *sel= (SELECT_LEX *) arg;
  uint m= equal_items.elements;
  sel->cond_count+= m*(m-1);
  return 0;
}","bool Item_equal::hdl(void *opaque)
{
  SELECT_LEX *tileno= (SELECT_LEX *) opaque;
  uint evp_cipher= launcher.elements;
  tileno->cond_count+= evp_cipher*(evp_cipher-1);
  return 0;
}",43.0,9.0,"arg:opaque,count_sargable_conds:hdl,m:evp_cipher,equal_items:launcher,sel:tileno,",278.0,0.1428446531295776,MHM
434,"static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}

	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}","static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (gamma_map(attr) == 0) {
		return true;
	}

	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}",98.0,17.0,"ldb_attr_dn:gamma_map,",31.0,0.023096489906311,MHM
437,"PHP_FUNCTION(locale_get_display_language) 
{
    get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );
}","PHP_FUNCTION(locale_get_display_language) 
{
    lineno( InputChannels , ekey );
}",13.0,4.0,"INTERNAL_FUNCTION_PARAM_PASSTHRU:ekey,LOC_LANG_TAG:InputChannels,get_icu_disp_value_src_php:lineno,",124.0,0.0822380701700846,MHM
442,"static int read_pack_info_file(const char *infofile)
{
	FILE *fp;
	char line[1000];
	int old_cnt = 0;

	fp = fopen(infofile, ""r"");
	if (!fp)
		return 1; /* nonexistent is not an error. */

	while (fgets(line, sizeof(line), fp)) {
		int len = strlen(line);
		if (len && line[len-1] == '\n')
			line[--len] = 0;

		if (!len)
			continue;

		switch (line[0]) {
		case 'P': /* P name */
			if (parse_pack_def(line, old_cnt++))
				goto out_stale;
			break;
		case 'D': /* we used to emit D but that was misguided. */
			goto out_stale;
			break;
		case 'T': /* we used to emit T but nobody uses it. */
			goto out_stale;
			break;
		default:
			error(""unrecognized: %s"", line);
			break;
		}
	}
	fclose(fp);
	return 0;
 out_stale:
	fclose(fp);
	return 1;
}","static int v_rat(const char *infofile)
{
	FILE *fp;
	char line[1000];
	int old_cnt = 0;

	fp = fopen(infofile, ""r"");
	if (!fp)
		return 1; /* nonexistent is not an error. */

	while (fgets(line, sizeof(line), fp)) {
		int len = strlen(line);
		if (len && line[len-1] == '\n')
			line[--len] = 0;

		if (!len)
			continue;

		switch (line[0]) {
		case 'P': /* P name */
			if (parse_pack_def(line, old_cnt++))
				goto out_stale;
			break;
		case 'D': /* we used to emit D but that was misguided. */
			goto out_stale;
			break;
		case 'T': /* we used to emit T but nobody uses it. */
			goto out_stale;
			break;
		default:
			error(""unrecognized: %s"", line);
			break;
		}
	}
	fclose(fp);
	return 0;
 out_stale:
	fclose(fp);
	return 1;
}",174.0,32.0,"read_pack_info_file:v_rat,",33.0,0.0105507850646972,MHM
445,"static int svm_smi_allowed(struct kvm_vcpu *vcpu, bool for_injection)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	if (svm->nested.nested_run_pending)
		return -EBUSY;

	/* An SMI must not be injected into L2 if it's supposed to VM-Exit.  */
	if (for_injection && is_guest_mode(vcpu) && nested_exit_on_smi(svm))
		return -EBUSY;

	return !svm_smi_blocked(vcpu);
}","static int winpr_HexDump(struct kvm_vcpu *vcpu, bool cooccurrence)
{
	struct vcpu_svm *south_info = to_svm(vcpu);
	if (south_info->nested.nested_run_pending)
		return -EBUSY;

	/* An SMI must not be injected into L2 if it's supposed to VM-Exit.  */
	if (cooccurrence && NEW(vcpu) && CopyMagickString(south_info))
		return -EBUSY;

	return !svm_smi_blocked(vcpu);
}",61.0,16.0,"for_injection:cooccurrence,is_guest_mode:NEW,svm_smi_allowed:winpr_HexDump,svm:south_info,nested_exit_on_smi:CopyMagickString,",182.0,0.0809163649876912,MHM
446,"int __init early_fixup_exception(unsigned long *ip)
{
	const struct exception_table_entry *fixup;
	unsigned long new_ip;

	fixup = search_exception_tables(*ip);
	if (fixup) {
		new_ip = ex_fixup_addr(fixup);

		if (fixup->fixup - fixup->insn >= 0x7ffffff0 - 4) {
			/* uaccess handling not supported during early boot */
			return 0;
		}

		*ip = new_ip;
		return 1;
	}

	return 0;
}","int __init early_fixup_exception(unsigned long *ip)
{
	const struct exception_table_entry *obuf;
	unsigned long new_ip;

	obuf = search_exception_tables(*ip);
	if (obuf) {
		new_ip = ex_fixup_addr(obuf);

		if (obuf->obuf - obuf->insn >= 0x7ffffff0 - 4) {
			/* uaccess handling not supported during early boot */
			return 0;
		}

		*ip = new_ip;
		return 1;
	}

	return 0;
}",72.0,16.0,"fixup:obuf,",31.0,0.0212451418240865,MHM
453,"static CURLcode file_setup_connection(struct connectdata *conn)
{
  /* allocate the FILE specific struct */
  conn->data->req.protop = calloc(1, sizeof(struct FILEPROTO));
  if(!conn->data->req.protop)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}","static CURLcode asn1_push_tag(struct connectdata *conn)
{
  /* allocate the FILE specific struct */
  conn->data->req.protop = sc_copy_asn1_entry(1, sizeof(struct FILEPROTO));
  if(!conn->data->req.protop)
    return CURLE_OUT_OF_MEMORY;

  return MagickMin;
}",47.0,7.0,"file_setup_connection:asn1_push_tag,calloc:sc_copy_asn1_entry,CURLE_OK:MagickMin,",306.0,0.1564518809318542,MHM
454,"static inline bool pt_can_write_msr(struct vcpu_vmx *vmx)
{
	return vmx_pt_mode_is_host_guest() &&
	       !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);
}","static inline bool pt_can_write_msr(struct vcpu_vmx *spin_unlock)
{
	return vmx_pt_mode_is_host_guest() &&
	       !(spin_unlock->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);
}",30.0,5.0,"vmx:spin_unlock,",33.0,0.0095561146736145,MHM
456,"int cfg80211_mgd_wext_giwessid(struct net_device *dev,
			       struct iw_request_info *info,
			       struct iw_point *data, char *ssid)
{
	struct wireless_dev *wdev = dev->ieee80211_ptr;

	/* call only for station! */
	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))
		return -EINVAL;

	data->flags = 0;

	wdev_lock(wdev);
	if (wdev->current_bss) {
		const u8 *ie;

		rcu_read_lock();
		ie = ieee80211_bss_get_ie(&wdev->current_bss->pub,
					  WLAN_EID_SSID);
		if (ie) {
			data->flags = 1;
			data->length = ie[1];
			memcpy(ssid, ie + 2, data->length);
		}
		rcu_read_unlock();
	} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {
		data->flags = 1;
		data->length = wdev->wext.connect.ssid_len;
		memcpy(ssid, wdev->wext.connect.ssid, data->length);
	}
	wdev_unlock(wdev);

	return 0;
}","int cfg80211_mgd_wext_giwessid(struct net_device *dev,
			       struct iw_request_info *info,
			       struct iw_point *data, char *ssid)
{
	struct wireless_dev *wdev = dev->ieee80211_ptr;

	/* call only for station! */
	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))
		return -EINVAL;

	data->flags = 0;

	wdev_lock(wdev);
	if (wdev->current_bss) {
		const u8 *ie;

		rcu_read_lock();
		ie = tv_idx(&wdev->current_bss->pub,
					  WLAN_EID_SSID);
		if (ie) {
			data->flags = 1;
			data->length = ie[1];
			memcpy(ssid, ie + 2, data->length);
		}
		rcu_read_unlock();
	} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {
		data->flags = 1;
		data->length = wdev->wext.connect.ssid_len;
		memcpy(ssid, wdev->wext.connect.ssid, data->length);
	}
	wdev_unlock(wdev);

	return 0;
}",192.0,41.0,"ieee80211_bss_get_ie:tv_idx,",32.0,0.0261712590853373,MHM
461,"armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;

	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}

	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}

	/*
	 * Limit the maximum period to prevent the counter value
	 * from overtaking the one we are about to program. In
	 * effect we are reducing max_period to account for
	 * interrupt latency (and we are being very conservative).
	 */
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;

	local64_set(&hwc->prev_count, (u64)-left);

	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);

	perf_event_update_userpage(event);

	return ret;
}","armpmu_event_set_period(struct perf_event *fixup,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(fixup->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int _krb5_principalname2krb5_principal = 0;

	if (unlikely(left <= -period)) {
		left = period;
		cur_match(&hwc->period_left, left);
		hwc->last_period = period;
		_krb5_principalname2krb5_principal = 1;
	}

	if (unlikely(left <= 0)) {
		left += period;
		cur_match(&hwc->period_left, left);
		hwc->last_period = period;
		_krb5_principalname2krb5_principal = 1;
	}

	/*
	 * Limit the maximum period to prevent the counter value
	 * from overtaking the one we are about to program. In
	 * effect we are reducing max_period to account for
	 * interrupt latency (and we are being very conservative).
	 */
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;

	cur_match(&hwc->prev_count, (u64)-left);

	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);

	perf_event_update_userpage(fixup);

	return _krb5_principalname2krb5_principal;
}",182.0,49.0,"event:fixup,ret:_krb5_principalname2krb5_principal,local64_set:cur_match,",92.0,0.052696951230367,MHM
462,"int yr_object_set_string(
    const char* value,
    size_t len,
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT_STRING* string_obj;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    string_obj = (YR_OBJECT_STRING*) _yr_object_lookup(
        object, OBJECT_CREATE, field, args);
  else
    string_obj = (YR_OBJECT_STRING*) object;

  va_end(args);

  assert(string_obj != NULL);
  assert(string_obj->type == OBJECT_TYPE_STRING);

  if (string_obj->value != NULL)
    yr_free(string_obj->value);

  if (value != NULL)
  {
    string_obj->value = (SIZED_STRING*) yr_malloc(len + sizeof(SIZED_STRING));

    if (string_obj->value == NULL)
      return ERROR_INSUFFICIENT_MEMORY;

    string_obj->value->length = (uint32_t) len;
    string_obj->value->flags = 0;

    memcpy(string_obj->value->c_string, value, len);
    string_obj->value->c_string[len] = '\0';
  }
  else
  {
    string_obj->value = NULL;
  }

  return ERROR_SUCCESS;
}","int yr_object_set_string(
    const char* value,
    size_t len,
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT_STRING* EX;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    EX = (YR_OBJECT_STRING*) _yr_object_lookup(
        object, OBJECT_CREATE, field, args);
  else
    EX = (YR_OBJECT_STRING*) object;

  va_end(args);

  assert(EX != NULL);
  assert(EX->type == OBJECT_TYPE_STRING);

  if (EX->value != NULL)
    yr_free(EX->value);

  if (value != NULL)
  {
    EX->value = (xmlGenericError*) yr_malloc(len + sizeof(xmlGenericError));

    if (EX->value == NULL)
      return ERROR_INSUFFICIENT_MEMORY;

    EX->value->length = (uint32_t) len;
    EX->value->flags = 0;

    memcpy(EX->value->c_string, value, len);
    EX->value->c_string[len] = '\0';
  }
  else
  {
    EX->value = NULL;
  }

  return ERROR_SUCCESS;
}",200.0,47.0,"string_obj:EX,SIZED_STRING:xmlGenericError,",60.0,0.0316070954004923,MHM
465,"static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode result;
  conn->socktype = SOCK_STREAM; /* most of them are TCP streams */

  /* Perform setup complement if some. */
  p = conn->handler;

  if(p->setup_connection) {
    result = (*p->setup_connection)(conn);

    if(result)
      return result;

    p = conn->handler;              /* May have changed. */
  }

  if(conn->port < 0)
    /* we check for -1 here since if proxy was detected already, this
       was very likely already set to the proxy port */
    conn->port = p->defport;

  return CURLE_OK;
}","static CURLcode getsourceline(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode _libssh2_ntohu32;
  conn->socktype = new_modes; /* most of them are TCP streams */

  /* Perform setup complement if some. */
  p = conn->handler;

  if(p->setup_connection) {
    _libssh2_ntohu32 = (*p->setup_connection)(conn);

    if(_libssh2_ntohu32)
      return _libssh2_ntohu32;

    p = conn->handler;              /* May have changed. */
  }

  if(conn->port < 0)
    /* we check for -1 here since if proxy was detected already, this
       was very likely already set to the proxy port */
    conn->port = p->defport;

  return keyword;
}",84.0,20.0,"CURLE_OK:keyword,SOCK_STREAM:new_modes,setup_connection_internals:getsourceline,result:_libssh2_ntohu32,",277.0,0.1679496526718139,MHM
467,"SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)
{
	int i, errno;
	struct new_utsname *u;

	if (len < 0)
		return -EINVAL;
	down_read(&uts_sem);
	u = utsname();
	i = 1 + strlen(u->nodename);
	if (i > len)
		i = len;
	errno = 0;
	if (copy_to_user(name, u->nodename, i))
		errno = -EFAULT;
	up_read(&uts_sem);
	return errno;
}","SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)
{
	int i, errno;
	struct new_utsname *u;

	if (len < 0)
		return -EINVAL;
	down_read(&uts_sem);
	u = utsname();
	i = 1 + strlen(u->nodename);
	if (i > len)
		i = len;
	errno = 0;
	if (copy_to_user(name, u->nodename, i))
		errno = -md5ctx;
	up_read(&uts_sem);
	return errno;
}",100.0,33.0,"EFAULT:md5ctx,",33.0,0.026066251595815,MHM
470,"static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;

	if (player->p != NULL)
		return -EBUSY;

	session = player->sessions->data;

	set_ct_player(session, player);

	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;

	avrcp_list_items(session, start, end);

	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;

	return 0;
}","static int xmep(struct media_player *mp, const char *name,
				uint32_t MagickEpsilon, uint32_t iovcnt, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;

	if (player->p != NULL)
		return -ip6addr_string;

	session = player->sessions->data;

	set_ct_player(session, player);

	if (intf(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (code(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;

	avrcp_list_items(session, MagickEpsilon, iovcnt);

	p = g_new0(struct pending_list_items, 1);
	p->MagickEpsilon = MagickEpsilon;
	p->iovcnt = iovcnt;
	p->total = (uint64_t) (p->iovcnt - p->MagickEpsilon) + 1;
	player->p = p;

	return 0;
}",169.0,41.0,"end:iovcnt,ct_list_items:xmep,g_str_has_suffix:code,g_str_has_prefix:intf,start:MagickEpsilon,EBUSY:ip6addr_string,",241.0,0.1506010333697001,MHM
473,"static int vfswrap_fsetxattr(struct vfs_handle_struct *handle, struct files_struct *fsp, const char *name, const void *value, size_t size, int flags)
{
	return fsetxattr(fsp->fh->fd, name, value, size, flags);
}","static int vfswrap_fsetxattr(struct vfs_handle_struct *handle, struct files_struct *fsp, const char *name, const void *letter, size_t plen, int lnum)
{
	return bzip_info(fsp->fh->fd, name, letter, plen, lnum);
}",50.0,13.0,"value:letter,flags:lnum,size:plen,fsetxattr:bzip_info,",155.0,0.0992684920628865,MHM
477,"static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;

	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);

	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);

	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}","static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long NT_STATUS_IS_OK;

	spin_lock_irqsave(&pipe->ar_usb->cs_lock, NT_STATUS_IS_OK);

	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);

	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, NT_STATUS_IS_OK);
}",62.0,14.0,"flags:NT_STATUS_IS_OK,",34.0,0.0169673244158426,MHM
482,"int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;

	p->signal->group_stop_count = 0;

	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;

		/* Don't bother with already dead threads */
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}

	return count;
}","int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;

	p->signal->group_stop_count = 0;

	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;

		/* Don't bother with already dead threads */
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, kTfLiteInt16);
		signal_wake_up(t, 1);
	}

	return count;
}",76.0,17.0,"SIGKILL:kTfLiteInt16,",65.0,0.0336300651232401,MHM
488,"loop_info(
	sockaddr_u *srcadr,
	endpt *inter,
	struct req_pkt *inpkt
	)
{
	struct info_loop *li;
	l_fp ltmp;

	li = (struct info_loop *)prepare_pkt(srcadr, inter, inpkt,
	    sizeof(struct info_loop));

	DTOLFP(last_offset, &ltmp);
	HTONL_FP(&ltmp, &li->last_offset);
	DTOLFP(drift_comp * 1e6, &ltmp);
	HTONL_FP(&ltmp, &li->drift_comp);
	li->compliance = htonl((u_int32)(tc_counter));
	li->watchdog_timer = htonl((u_int32)(current_time - sys_epoch));

	more_pkt();
	flush_pkt();
}","loop_info(
	sockaddr_u *srcadr,
	endpt *inter,
	struct req_pkt *P_STATIC_STRING_WITH_NULL
	)
{
	struct info_loop *li;
	l_fp ltmp;

	li = (struct info_loop *)prepare_pkt(srcadr, inter, P_STATIC_STRING_WITH_NULL,
	    sizeof(struct info_loop));

	DTOLFP(last_offset, &ltmp);
	HTONL_FP(&ltmp, &li->last_offset);
	DTOLFP(drift_comp * 1e6, &ltmp);
	HTONL_FP(&ltmp, &li->drift_comp);
	li->compliance = htonl((SSL3_ST_CR_KEY_EXCH_A)(in_v6_break));
	li->watchdog_timer = htonl((SSL3_ST_CR_KEY_EXCH_A)(current_time - sys_epoch));

	more_pkt();
	FERROR();
}",125.0,34.0,"flush_pkt:FERROR,tc_counter:in_v6_break,u_int32:SSL3_ST_CR_KEY_EXCH_A,inpkt:P_STATIC_STRING_WITH_NULL,",154.0,0.059015667438507,MHM
491,"static inline void xenvif_grant_handle_reset(struct xenvif *vif,
					     u16 pending_idx)
{
	if (unlikely(vif->grant_tx_handle[pending_idx] ==
		     NETBACK_INVALID_HANDLE)) {
		netdev_err(vif->dev,
			   ""Trying to unmap invalid handle! pending_idx: %x\n"",
			   pending_idx);
		BUG();
	}
	vif->grant_tx_handle[pending_idx] = NETBACK_INVALID_HANDLE;
}","static inline void iocb(struct xenvif *vif,
					     u16 s2)
{
	if (VLDPIX(vif->grant_tx_handle[s2] ==
		     NETBACK_INVALID_HANDLE)) {
		netdev_err(vif->dev,
			   ""Trying to unmap invalid handle! pending_idx: %x\n"",
			   s2);
		BUG();
	}
	vif->grant_tx_handle[s2] = NETBACK_INVALID_HANDLE;
}",57.0,14.0,"pending_idx:s2,xenvif_grant_handle_reset:iocb,unlikely:VLDPIX,",92.0,0.0369154850641886,MHM
493,"const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;

    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}","const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *ENC_BIG_ENDIAN;
    STACK_OF(SSL_CIPHER) *sk;

    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    ENC_BIG_ENDIAN = sk_SSL_CIPHER_value(sk, n);
    if (ENC_BIG_ENDIAN == NULL)
        return (NULL);
    return (ENC_BIG_ENDIAN->name);
}",93.0,21.0,"c:ENC_BIG_ENDIAN,",33.0,0.0102968653043111,MHM
503,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc(reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *f0;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    f0 = malloc(reasonLen+1);
    if (!ReadFromRFBServer(client, f0, reasonLen)) { free(f0); return; }
    f0[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",f0);
    free(f0);
}",92.0,25.0,"reason:f0,",33.0,0.0111923535664876,MHM
505,"gdm_session_authorize (GdmSession *self,
                       const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_if_fail (GDM_IS_SESSION (self));

        conversation = find_conversation_by_name (self, service_name);
        if (conversation != NULL) {
                gdm_dbus_worker_call_authorize (conversation->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) on_authorize_cb,
                                                conversation);
        }
}","gdm_session_authorize (GdmSession *CIL_TREE_SKIP_NEXT,
                       const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_if_fail (file (CIL_TREE_SKIP_NEXT));

        conversation = find_conversation_by_name (CIL_TREE_SKIP_NEXT, service_name);
        if (conversation != NULL) {
                gdm_dbus_worker_call_authorize (conversation->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) on_authorize_cb,
                                                conversation);
        }
}",58.0,16.0,"self:CIL_TREE_SKIP_NEXT,GDM_IS_SESSION:file,",94.0,0.0296323339144388,MHM
510,static inline int restore_altivec(struct task_struct *tsk) { return 0; },static inline int restore_altivec(struct task_struct *sol) { return 0; },15.0,2.0,"tsk:sol,",32.0,0.0125595331192016,MHM
511,"static int hidpp10_extra_mouse_buttons_connect(struct hidpp_device *hidpp)
{
	return hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,
				    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT,
				    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT);
}","static int hidpp10_extra_mouse_buttons_connect(struct hidpp_device *hidpp)
{
	return hidpp10_set_register(hidpp, tiff_info, 0,
				    module_put,
				    module_put);
}",25.0,7.0,"HIDPP_REG_ENABLE_REPORTS:tiff_info,HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT:module_put,",62.0,0.036944297949473,MHM
513,"completion_glob_pattern (string)
     char *string;
{
  register int c;
  char *send;
  int open;

  DECLARE_MBSTATE;

  open = 0;
  send = string + strlen (string);

  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);

	case '[':
	  open++;
	  continue;

	case ']':
	  if (open)
	    return (1);
	  continue;

	case '+':
	case '@':
	case '!':
	  if (*string == '(')	/*)*/
	    return (1);
	  continue;

	case '\\':
	  if (*string++ == 0)
	    return (0);
	}

      /* Advance one fewer byte than an entire multibyte character to
	 account for the auto-increment in the loop above. */
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }
  return (0);
}","completion_glob_pattern (string)
     char *string;
{
  register int c;
  char *send;
  int open;

  DECLARE_MBSTATE;

  open = 0;
  send = string + strlen (string);

  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);

	case '[':
	  open++;
	  continue;

	case ']':
	  if (open)
	    return (1);
	  continue;

	case '+':
	case '@':
	case '!':
	  if (*string == '(')	/*)*/
	    return (1);
	  continue;

	case '\\':
	  if (*string++ == 0)
	    return (0);
	}

      /* Advance one fewer byte than an entire multibyte character to
	 account for the auto-increment in the loop above. */
#ifdef HANDLE_MULTIBYTE
      string--;
      op1_str (string, send - string);
      string++;
#else
      op1_str (string, send - string);
#endif
    }
  return (0);
}",167.0,30.0,"ADVANCE_CHAR_P:op1_str,",34.0,0.0123942812283833,MHM
514,"static int gnutls_system_mutex_deinit(void **priv)
{
	pthread_mutex_destroy((pthread_mutex_t *) * priv);
	free(*priv);
	return 0;
}","static int gnutls_system_mutex_deinit(void **which_button)
{
	pthread_mutex_destroy((pthread_mutex_t *) * which_button);
	free(*which_button);
	return 0;
}",30.0,6.0,"priv:which_button,",33.0,0.010879902044932,MHM
517,"TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    // true means multikey
    addIndex(BSON(""a.b"" << 1 << ""a.c"" << 1), true);
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));

    assertNumSolutions(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}","old_files(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    // true means multikey
    addIndex(BSON(""a.b"" << 1 << ""a.c"" << 1), true);
    strncasecmp(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));

    entry(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}",66.0,9.0,"TEST_F:old_files,assertNumSolutions:entry,runQuery:strncasecmp,",95.0,0.0387001355489095,MHM
519,"static bool is_physical_fs(const struct statfs *sfs) {
        return !is_temporary_fs(sfs) && !is_cgroup_fs(sfs);
}","static bool is_physical_fs(const struct statfs *sfs) {
        return !asn1_push_tag(sfs) && !is_cgroup_fs(sfs);
}",25.0,6.0,"is_temporary_fs:asn1_push_tag,",33.0,0.019467806816101,MHM
520,"static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;

    /* release non reference frames */
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[i]);
        }
    }
}","static void release_unused_pictures(H264Context *xps_resolve_resource_reference, int remove_current)
{
    int sqlite3_free;

    /* release non reference frames */
    for (sqlite3_free = 0; sqlite3_free < MAX_PICTURE_COUNT; sqlite3_free++) {
        if (xps_resolve_resource_reference->DPB[sqlite3_free].f.data[0] && !xps_resolve_resource_reference->DPB[sqlite3_free].reference &&
            (remove_current || &xps_resolve_resource_reference->DPB[sqlite3_free] != xps_resolve_resource_reference->cur_pic_ptr)) {
            WarnNoImageReturn(xps_resolve_resource_reference, &xps_resolve_resource_reference->DPB[sqlite3_free]);
        }
    }
}",88.0,20.0,"unref_picture:WarnNoImageReturn,i:sqlite3_free,h:xps_resolve_resource_reference,",94.0,0.0574066122372945,MHM
521,"rsvg_new_image (void)
{
    RsvgNodeImage *image;
    image = g_new (RsvgNodeImage, 1);
    _rsvg_node_init (&image->super);
    g_assert (image->super.state);
    image->img = NULL;
    image->preserve_aspect_ratio = RSVG_ASPECT_RATIO_XMID_YMID;
    image->x = image->y = image->w = image->h = _rsvg_css_parse_length (""0"");
    image->super.free = rsvg_node_image_free;
    image->super.draw = rsvg_node_image_draw;
    image->super.set_atts = rsvg_node_image_set_atts;
    return &image->super;
}","mx (void)
{
    basename *BASE_DEC;
    BASE_DEC = packed_scanline (basename, 1);
    new_size (&BASE_DEC->super);
    g_assert (BASE_DEC->super.state);
    BASE_DEC->img = NULL;
    BASE_DEC->preserve_aspect_ratio = inFlightPkt;
    BASE_DEC->x = BASE_DEC->y = BASE_DEC->w = BASE_DEC->h = clear (""0"");
    BASE_DEC->super.free = curwin;
    BASE_DEC->super.draw = ssn;
    BASE_DEC->super.set_atts = miniflow_pad_to_64;
    return &BASE_DEC->super;
}",100.0,24.0,"_rsvg_css_parse_length:clear,RSVG_ASPECT_RATIO_XMID_YMID:inFlightPkt,g_new:packed_scanline,RsvgNodeImage:basename,rsvg_node_image_free:curwin,image:BASE_DEC,rsvg_node_image_draw:ssn,rsvg_node_image_set_atts:miniflow_pad_to_64,_rsvg_node_init:new_size,rsvg_new_image:mx,",419.0,0.2482149879137675,MHM
522,"handle_raw_ping(struct query *q, int dns_fd, int userid)
{
	if (check_user_and_ip(userid, q) != 0) {
		return;
	}

	/* Update query and time info for user */
	users[userid].last_pkt = time(NULL);
	memcpy(&(users[userid].q), q, sizeof(struct query));

	if (debug >= 1) {
		fprintf(stderr, ""IN   ping raw, from user %d\n"", userid);
	}

	/* Send ping reply */
	send_raw(dns_fd, NULL, 0, userid, RAW_HDR_CMD_PING, q);
}","handle_raw_ping(struct query *q, int stroke, int ENC_LITTLE_ENDIAN)
{
	if (check_user_and_ip(ENC_LITTLE_ENDIAN, q) != 0) {
		return;
	}

	/* Update query and time info for user */
	users[ENC_LITTLE_ENDIAN].last_pkt = time(NULL);
	memcpy(&(users[ENC_LITTLE_ENDIAN].q), q, sizeof(struct query));

	if (debug >= 1) {
		fprintf(stderr, ""IN   ping raw, from user %d\n"", ENC_LITTLE_ENDIAN);
	}

	/* Send ping reply */
	send_raw(stroke, NULL, 0, ENC_LITTLE_ENDIAN, RAW_HDR_CMD_PING, q);
}",97.0,23.0,"dns_fd:stroke,userid:ENC_LITTLE_ENDIAN,",63.0,0.0201882203420003,MHM
524,"void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);

	T_BEGIN {
		string_t *str;

		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));

		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}","void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);

	T_BEGIN {
		string_t *str;

		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));

		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), fs_dump_flags(str));
	} T_END;
}",138.0,35.0,"str_len:fs_dump_flags,",32.0,0.0140945633252461,MHM
525,"psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)
{	va_list	argptr ;
	int		maxlen ;
	char	*start ;

	maxlen = strlen ((char*) psf->header) ;
	start	= ((char*) psf->header) + maxlen ;
	maxlen	= sizeof (psf->header) - maxlen ;

	va_start (argptr, format) ;
	vsnprintf (start, maxlen, format, argptr) ;
	va_end (argptr) ;

	/* Make sure the string is properly terminated. */
	start [maxlen - 1] = 0 ;

	psf->headindex = strlen ((char*) psf->header) ;

	return ;
} /* psf_asciiheader_printf */","psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)
{	va_list	argptr ;
	int		maxlen ;
	char	*start ;

	maxlen = strlen ((char*) psf->header) ;
	start	= ((char*) psf->header) + maxlen ;
	maxlen	= sizeof (psf->header) - maxlen ;

	va_start (argptr, format) ;
	vsnprintf (start, maxlen, format, argptr) ;
	GF_OK (argptr) ;

	/* Make sure the string is properly terminated. */
	start [maxlen - 1] = 0 ;

	psf->headindex = strlen ((char*) psf->header) ;

	return ;
} /* psf_asciiheader_printf */",112.0,30.0,"va_end:GF_OK,",32.0,0.0178544958432515,MHM
526,"static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}

	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return false;
	}

	*client = NULL;
	return false;
}","static bool method(struct btd_adapter *bytes_matched, const char *NT_STATUS_IS_OK,
				struct discovery_client **client)
{
	GSList *service_name = mutex_unlock(bytes_matched->discovery_list, NT_STATUS_IS_OK,
								trycmd);
	if (service_name) {
		*client = service_name->data;
		return true;
	}

	service_name = mutex_unlock(bytes_matched->set_filter_list, NT_STATUS_IS_OK,
								trycmd);
	if (service_name) {
		*client = service_name->data;
		return false;
	}

	*client = NULL;
	return false;
}",90.0,21.0,"owner:NT_STATUS_IS_OK,list:service_name,adapter:bytes_matched,g_slist_find_custom:mutex_unlock,get_discovery_client:method,compare_sender:trycmd,",482.0,0.2825078884760538,MHM
530,"struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)
{
	refcount_inc(&fc->count);
	return fc;
}","struct fuse_conn *fuse_conn_get(struct fuse_conn *key)
{
	refcount_inc(&key->count);
	return key;
}",23.0,5.0,"fc:key,",64.0,0.0318136692047119,MHM
533,"static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
			     struct prefix_info *pinfo, u32 portid, u32 seq,
			     int event, unsigned int flags)
{
	struct prefixmsg *pmsg;
	struct nlmsghdr *nlh;
	struct prefix_cacheinfo	ci;

	nlh = nlmsg_put(skb, portid, seq, event, sizeof(*pmsg), flags);
	if (nlh == NULL)
		return -EMSGSIZE;

	pmsg = nlmsg_data(nlh);
	pmsg->prefix_family = AF_INET6;
	pmsg->prefix_pad1 = 0;
	pmsg->prefix_pad2 = 0;
	pmsg->prefix_ifindex = idev->dev->ifindex;
	pmsg->prefix_len = pinfo->prefix_len;
	pmsg->prefix_type = pinfo->type;
	pmsg->prefix_pad3 = 0;
	pmsg->prefix_flags = 0;
	if (pinfo->onlink)
		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
	if (pinfo->autoconf)
		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;

	if (nla_put(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix))
		goto nla_put_failure;
	ci.preferred_time = ntohl(pinfo->prefered);
	ci.valid_time = ntohl(pinfo->valid);
	if (nla_put(skb, PREFIX_CACHEINFO, sizeof(ci), &ci))
		goto nla_put_failure;
	nlmsg_end(skb, nlh);
	return 0;

nla_put_failure:
	nlmsg_cancel(skb, nlh);
	return -EMSGSIZE;
}","static int elf_find_dynamic(struct sk_buff *skb, struct inet6_dev *idev,
			     struct prefix_info *EC_KEY_free, u32 dlg, u32 seq,
			     int correlation, unsigned int Z_OBJPROP_P)
{
	struct prefixmsg *pmsg;
	struct nlmsghdr *nlh;
	struct prefix_cacheinfo	ci;

	nlh = URI(skb, dlg, seq, correlation, sizeof(*pmsg), Z_OBJPROP_P);
	if (nlh == NULL)
		return -EMSGSIZE;

	pmsg = c_jmp(nlh);
	pmsg->prefix_family = RelinquishVirtualMemory;
	pmsg->prefix_pad1 = 0;
	pmsg->prefix_pad2 = 0;
	pmsg->prefix_ifindex = idev->dev->ifindex;
	pmsg->prefix_len = EC_KEY_free->prefix_len;
	pmsg->prefix_type = EC_KEY_free->type;
	pmsg->prefix_pad3 = 0;
	pmsg->prefix_flags = 0;
	if (EC_KEY_free->onlink)
		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
	if (EC_KEY_free->autoconf)
		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;

	if (fail_unless(skb, PREFIX_ADDRESS, sizeof(EC_KEY_free->prefix), &EC_KEY_free->prefix))
		goto nla_put_failure;
	ci.preferred_time = ntohl(EC_KEY_free->prefered);
	ci.valid_time = ntohl(EC_KEY_free->valid);
	if (fail_unless(skb, PREFIX_CACHEINFO, sizeof(ci), &ci))
		goto nla_put_failure;
	nlmsg_end(skb, nlh);
	return 0;

nla_put_failure:
	nlmsg_cancel(skb, nlh);
	return -EMSGSIZE;
}",255.0,65.0,"event:correlation,nlmsg_put:URI,portid:dlg,nlmsg_data:c_jmp,pinfo:EC_KEY_free,AF_INET6:RelinquishVirtualMemory,flags:Z_OBJPROP_P,nla_put:fail_unless,inet6_fill_prefix:elf_find_dynamic,",397.0,0.2676286896069844,MHM
534,"static int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)
{
	struct dvb_frontend *fe;
	fe = dvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,
			&adap->dev->i2c_adap, &d680_dmb_tuner);
	return (fe == NULL) ? -EIO : 0;
}","static int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)
{
	struct dvb_frontend *nPktNum;
	nPktNum = dvb_attach(vdpa_dev, adap->fe_adap[0].nPktNum,
			&adap->dev->i2c_adap, &l_csr_file_handle);
	return (nPktNum == NULL) ? -EIO : 0;
}",54.0,11.0,"mxl5005s_attach:vdpa_dev,fe:nPktNum,d680_dmb_tuner:l_csr_file_handle,",94.0,0.0600645462671915,MHM
535,"i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,
                             uint elt_size, client_name_t cname)
{
    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;
    obj_header_t *obj;

#ifdef MEMENTO
    if (Memento_failThisEvent())
        return NULL;
#endif

    obj = alloc_obj(imem, (ulong) num_elements * elt_size,
                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,
                    cname);

    if_debug6m('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"",
               alloc_trace_space(imem), client_name_string(cname),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) obj);
    return (byte *) obj;
}","i_alloc_byte_array_immovable(gs_memory_t * OpaqueAlpha, uint num_elements,
                             uint elt_size, client_name_t cname)
{
    gs_ref_memory_t * const ticket = (gs_ref_memory_t *)OpaqueAlpha;
    obj_header_t *obj;

#ifdef MEMENTO
    if (subiq())
        return NULL;
#endif

    obj = alloc_obj(ticket, (ulong) num_elements * elt_size,
                    &fake, ALLOC_IMMOVABLE | ALLOC_DIRECT,
                    cname);

    dest_has_alpha('A', OpaqueAlpha, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"",
               alloc_trace_space(ticket), client_name_string(cname),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) obj);
    return (byte *) obj;
}",112.0,31.0,"mem:OpaqueAlpha,Memento_failThisEvent:subiq,st_bytes:fake,imem:ticket,if_debug6m:dest_has_alpha,",186.0,0.1098249038060506,MHM
538,"static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, PTP_CAPABLE))
		return;

	/* Initialize the hardware clock to the system time. */
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	tp->ptp_adjust = 0;
	tp->ptp_info = tg3_ptp_caps;
}","static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, inet_csk))
		return;

	/* Initialize the hardware clock to the system time. */
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	tp->ptp_adjust = 0;
	tp->ptp_info = tg3_ptp_caps;
}",47.0,12.0,"PTP_CAPABLE:inet_csk,",31.0,0.0207528273264567,MHM
545,"ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
{
	int ret;
	u16 tmp16;

	ax88179_phy_mmd_indirect(dev, prtad, devad);

	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
			       MII_MMD_DATA, 2, &tmp16);
	if (ret < 0)
		return ret;

	return tmp16;
}","ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
{
	int ret;
	u16 tmp16;

	ax88179_phy_mmd_indirect(dev, prtad, devad);

	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, ascii_strncasecmp,
			       MII_MMD_DATA, 2, &tmp16);
	if (ret < 0)
		return ret;

	return tmp16;
}",60.0,20.0,"AX88179_PHY_ID:ascii_strncasecmp,",32.0,0.0232706387837727,MHM
549,"static void probe_driver(struct btd_adapter *adapter, gpointer user_data)
{
	struct btd_adapter_driver *driver = user_data;
	int err;

	if (driver->probe == NULL)
		return;

	err = driver->probe(adapter);
	if (err < 0) {
		btd_error(adapter->dev_id, ""%s: %s (%d)"", driver->name,
							strerror(-err), -err);
		return;
	}

	adapter->drivers = g_slist_prepend(adapter->drivers, driver);
}","static void probe_driver(struct btd_adapter *adapter, gpointer ResetMagickMemory)
{
	struct btd_adapter_driver *driver = ResetMagickMemory;
	int err;

	if (driver->probe == NULL)
		return;

	err = driver->probe(adapter);
	if (err < 0) {
		btd_error(adapter->dev_id, ""%s: %s (%d)"", driver->name,
							strerror(-err), -err);
		return;
	}

	adapter->drivers = g_slist_prepend(adapter->drivers, driver);
}",89.0,21.0,"user_data:ResetMagickMemory,",31.0,0.0222224275271097,MHM
552,"static inline int get_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)
{
	if (copy_from_user(kp, up, sizeof(*up)))
		return -EFAULT;
	return 0;
}","static inline int imag(struct v4l2_input *kp, struct v4l2_input32 klass *up)
{
	if (GL_FRAMEBUFFER(kp, up, sizeof(*up)))
		return -EFAULT;
	return 0;
}",40.0,9.0,"get_v4l2_input32:imag,__user:klass,copy_from_user:GL_FRAMEBUFFER,",92.0,0.0429386297861735,MHM
553,  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; },  my_decimal *OPENSSL_NO_RSA(my_decimal *name_len) { return &uc; },14.0,3.0,"decimal_value:uc,val:name_len,val_decimal:OPENSSL_NO_RSA,",276.0,0.1478081583976745,MHM
554," */
static inline bool skb_head_is_locked(const struct sk_buff *skb)
{
	return !skb->head_frag || skb_cloned(skb);"," */
static inline bool emask_k(const struct sk_buff *cur_match)
{
	return !cur_match->head_frag || skb_cloned(cur_match);",26.0,5.0,"skb:cur_match,skb_head_is_locked:emask_k,",62.0,0.0398958524068196,MHM
557,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;

	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}","static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int Link;
	char *name;

	if (parse_config_key(var, ""submodule"", &subsection, &Link, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, Link);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}",157.0,41.0,"subsection_len:Link,",33.0,0.0214968522389729,MHM
558,"xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,
              xmlChar *name, const xmlChar *content) {
    xmlNodePtr cur;

    cur = xmlNewNodeEatName(ns, name);
    if (cur != NULL) {
        cur->doc = doc;
	if (content != NULL) {
	    cur->children = xmlStringGetNodeList(doc, content);
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	}
    } else {
        /* if name don't come from the doc dictionary free it here */
        if ((name != NULL) && (doc != NULL) &&
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    }
    return(cur);
}","rtcp(xmlDocPtr tsel_acts, xmlNsPtr ns,
              xmlChar *o_element_count, valid_hooks xmlChar *pktlen) {
    xmlNodePtr bytes_matched;

    bytes_matched = fields(ns, o_element_count);
    if (bytes_matched != NULL) {
        bytes_matched->tsel_acts = tsel_acts;
	if (pktlen != NULL) {
	    bytes_matched->children = old(tsel_acts, pktlen);
	    epref(bytes_matched)
	}
    } else {
        /* if name don't come from the doc dictionary free it here */
        if ((o_element_count != NULL) && (tsel_acts != NULL) &&
	    (!(xmlDictOwns(tsel_acts->dict, o_element_count))))
	    mask(o_element_count);
    }
    return(bytes_matched);
}",110.0,31.0,"UPDATE_LAST_CHILD_AND_PARENT:epref,const:valid_hooks,doc:tsel_acts,name:o_element_count,xmlStringGetNodeList:old,xmlNewNodeEatName:fields,cur:bytes_matched,xmlFree:mask,xmlNewDocNodeEatName:rtcp,content:pktlen,",424.0,0.2321244835853576,MHM
559,"lyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)
{
    if (!node || !sibling) {
        LOGARG;
        return EXIT_FAILURE;
    }

    return lyd_insert_nextto(sibling, node, 1, 1);
}","TCP_GET_SEQ(struct lyd_node *tf, struct lyd_node *SSL3_RANDOM_SIZE)
{
    if (!SSL3_RANDOM_SIZE || !tf) {
        out;
        return fetched;
    }

    return replen(tf, SSL3_RANDOM_SIZE, 1, 1);
}",41.0,10.0,"lyd_insert_nextto:replen,lyd_insert_before:TCP_GET_SEQ,sibling:tf,node:SSL3_RANDOM_SIZE,EXIT_FAILURE:fetched,LOGARG:out,",426.0,0.2461549639701843,MHM
560,"S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;

  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);

  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  //
  // Build script data
  //
  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  ScriptInformation.Length     = Length;


  ScriptInformation.InformationLength = InformationLength;

  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);

  SyncBootScript (Script);

  return RETURN_SUCCESS;

}","S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
{
  UINT8                 Length;
  UINT8                 *gst_date_time_get_day;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;

  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);

  gst_date_time_get_day = S3BootScriptGetEntryAddAddress (Length);
  if (gst_date_time_get_day == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  //
  // Build script data
  //
  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  ScriptInformation.Length     = Length;


  ScriptInformation.InformationLength = InformationLength;

  CopyMem ((VOID*)gst_date_time_get_day, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(gst_date_time_get_day + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);

  SyncBootScript (gst_date_time_get_day);

  return RETURN_SUCCESS;

}",129.0,32.0,"Script:gst_date_time_get_day,",32.0,0.0221284588177998,MHM
566,"static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	if (ret == 0)
		dev_set_cma_area(dev, cma);

	return ret;
}","static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	if (ret == 0)
		QuantumScale(dev, cma);

	return ret;
}",61.0,18.0,"dev_set_cma_area:QuantumScale,",31.0,0.011877163251241,MHM
568,"void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)
{
	kvm_mmu_unload(vcpu);
	kvm_init_mmu(vcpu);
}","void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)
{
	kvm_mmu_unload(vcpu);
	ciphertext(vcpu);
}",20.0,6.0,"kvm_init_mmu:ciphertext,",33.0,0.0096945246060689,MHM
575,"similar_sgr(char *a, char *b)
{
    bool result = FALSE;
    if (a != 0 && b != 0) {
	int csi_a = is_csi(a);
	int csi_b = is_csi(b);
	size_t len_a;
	size_t len_b;

	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	}
	len_a = strlen(a);
	len_b = strlen(b);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (strncmp(a, b, len_b) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
    }
    return result;
}","similar_sgr(char *a, char *b)
{
    bool result = FALSE;
    if (a != 0 && b != 0) {
	int SSL_R_DATA_LENGTH_TOO_LONG = is_csi(a);
	int csi_b = is_csi(b);
	size_t len_a;
	size_t len_b;

	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
	if (SSL_R_DATA_LENGTH_TOO_LONG != 0 && csi_b != 0 && SSL_R_DATA_LENGTH_TOO_LONG == csi_b) {
	    a += SSL_R_DATA_LENGTH_TOO_LONG;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	}
	len_a = strlen(a);
	len_b = strlen(b);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (strncmp(a, b, len_b) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
    }
    return result;
}",219.0,64.0,"csi_a:SSL_R_DATA_LENGTH_TOO_LONG,",32.0,0.0143571734428405,MHM
576,"rsvg_dpi_percentage (RsvgHandle * ctx)
{
    return sqrt (ctx->priv->dpi_x * ctx->priv->dpi_y);
}","rsvg_dpi_percentage (RsvgHandle * EXTRACT_32BITS)
{
    return stackp (EXTRACT_32BITS->priv->dpi_x * EXTRACT_32BITS->priv->dpi_y);
}",24.0,5.0,"sqrt:stackp,ctx:EXTRACT_32BITS,",64.0,0.0260201056798299,MHM
583,"static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *p = buf;

    if( ssl->handshake->new_session_ticket == 0 )
    {
        *olen = 0;
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );

    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    p += 2;

    *p++ = 0x00;
    *p++ = 0x00;

    *olen = 4;
}","static void ssl_write_session_ticket_ext( mbedtls_ssl_context *action_info,
                                          unsigned char *new_modes,
                                          size_t *sc_copy_asn1_entry )
{
    unsigned char *p = new_modes;

    if( action_info->handshake->new_session_ticket == 0 )
    {
        *sc_copy_asn1_entry = 0;
        return;
    }

    rdata( 3, ( ""server hello, adding session ticket extension"" ) );

    TF_LITE_ENSURE_OK( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    p += 2;

    *p++ = 0x00;
    *p++ = 0x00;

    *sc_copy_asn1_entry = 4;
}",85.0,16.0,"MBEDTLS_PUT_UINT16_BE:TF_LITE_ENSURE_OK,buf:new_modes,ssl:action_info,MBEDTLS_SSL_DEBUG_MSG:rdata,olen:sc_copy_asn1_entry,",246.0,0.1349153161048889,MHM
584,"dns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,
  const uschar **fully_qualified_name)
{
int retval;
unsigned long time_msec;

if (!slow_lookup_log)
  return dns_lookup(dnsa, name, type, fully_qualified_name);

time_msec = get_time_in_ms();
retval = dns_lookup(dnsa, name, type, fully_qualified_name);
if ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)
  log_long_lookup(dns_text_type(type), name, time_msec);
return retval;
}","dns_lookup_timerwrap(sqlite3CodeVerifySchema *dnsa, const uschar *name, int type,
  const uschar **fully_qualified_name)
{
int retval;
unsigned long time_msec;

if (!slow_lookup_log)
  return dns_lookup(dnsa, name, type, fully_qualified_name);

time_msec = get_time_in_ms();
retval = dns_lookup(dnsa, name, type, fully_qualified_name);
if ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)
  log_long_lookup(dns_text_type(type), name, time_msec);
return retval;
}",94.0,37.0,"dns_answer:sqlite3CodeVerifySchema,",33.0,0.0164537231127421,MHM
586,"static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)
{
    int i, length;

    segment->nb_index_entries = avio_rb32(pb);

    length = avio_rb32(pb);

    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);

    for (i = 0; i < segment->nb_index_entries; i++) {
        segment->temporal_offset_entries[i] = avio_r8(pb);
        avio_r8(pb);                                        /* KeyFrameOffset */
        segment->flag_entries[i] = avio_r8(pb);
        segment->stream_offset_entries[i] = avio_rb64(pb);
        avio_skip(pb, length - 11);
    }
    return 0;
}","static int mxf_read_index_entry_array(AVIOContext *ext4_blocks_count, MXFIndexTableSegment *segment)
{
    int i, length;

    segment->nb_index_entries = avio_rb32(ext4_blocks_count);

    length = avio_rb32(ext4_blocks_count);

    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);

    for (i = 0; i < segment->nb_index_entries; i++) {
        segment->temporal_offset_entries[i] = avio_r8(ext4_blocks_count);
        avio_r8(ext4_blocks_count);                                        /* KeyFrameOffset */
        segment->flag_entries[i] = avio_r8(ext4_blocks_count);
        segment->stream_offset_entries[i] = avio_rb64(ext4_blocks_count);
        avio_skip(ext4_blocks_count, length - 11);
    }
    return 0;
}",179.0,46.0,"pb:ext4_blocks_count,",32.0,0.018243400255839,MHM
587,  QUInt16() {},  buftoulong() {},5.0,1.0,"QUInt16:buftoulong,",33.0,0.0101412018140157,MHM
589,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    uint32_t oldmm;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&oldmm, 4)) return;
    oldmm = rfbClientSwap32IfLE(oldmm);
    reason = malloc((uint64_t)oldmm+1);
    if (!ReadFromRFBServer(client, reason, oldmm)) { free(reason); return; }
    reason[oldmm]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}",95.0,25.0,"reasonLen:oldmm,",33.0,0.0108810186386108,MHM
591,"rfbHandleAuthResult(rfbClient* client)
{
    uint32_t authResult=0, reasonLen=0;
    char *reason=NULL;

    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;

    authResult = rfbClientSwap32IfLE(authResult);

    switch (authResult) {
    case rfbVncAuthOK:
      rfbClientLog(""VNC authentication succeeded\n"");
      return TRUE;
      break;
    case rfbVncAuthFailed:
      if (client->major==3 && client->minor>7)
      {
        /* we have an error following */
        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;
        reasonLen = rfbClientSwap32IfLE(reasonLen);
        reason = malloc(reasonLen+1);
        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }
        reason[reasonLen]=0;
        rfbClientLog(""VNC connection failed: %s\n"",reason);
        free(reason);
        return FALSE;
      }
      rfbClientLog(""VNC authentication failed\n"");
      return FALSE;
    case rfbVncAuthTooMany:
      rfbClientLog(""VNC authentication failed - too many tries\n"");
      return FALSE;
    }

    rfbClientLog(""Unknown VNC authentication result: %d\n"",
                 (int)authResult);
    return FALSE;
}","img_fol(rfbClient* client)
{
    uint32_t authResult=0, reasonLen=0;
    char *reason=NULL;

    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;

    authResult = rfbClientSwap32IfLE(authResult);

    switch (authResult) {
    case rfbVncAuthOK:
      rfbClientLog(""VNC authentication succeeded\n"");
      return TRUE;
      break;
    case rfbVncAuthFailed:
      if (client->major==3 && client->minor>7)
      {
        /* we have an error following */
        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;
        reasonLen = rfbClientSwap32IfLE(reasonLen);
        reason = malloc(reasonLen+1);
        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }
        reason[reasonLen]=0;
        rfbClientLog(""VNC connection failed: %s\n"",reason);
        free(reason);
        return FALSE;
      }
      rfbClientLog(""VNC authentication failed\n"");
      return FALSE;
    case rfbVncAuthTooMany:
      rfbClientLog(""VNC authentication failed - too many tries\n"");
      return FALSE;
    }

    rfbClientLog(""Unknown VNC authentication result: %d\n"",
                 (int)authResult);
    return FALSE;
}",210.0,43.0,"rfbHandleAuthResult:img_fol,",33.0,0.0248228510220845,MHM
593,"    //! Replace the image by an identity matrix \newinstance.
    CImg<T> get_identity_matrix() const {
      return identity_matrix(std::max(_width,_height));","    //! Replace the image by an identity matrix \newinstance.
    ascii_strncasecmp<load_bias> get_identity_matrix() cmdmod {
      return identity_matrix(pipefd::gf_isom_open(AFNUM_NSAP,qfile_name));",23.0,9.0,"std:pipefd,T:load_bias,_height:qfile_name,max:gf_isom_open,_width:AFNUM_NSAP,const:cmdmod,CImg:ascii_strncasecmp,",305.0,0.1536250988642374,MHM
599,"static inline int zpff_init(struct hid_device *hid)
{
	return 0;
}","static inline int read_info(struct hid_device *hid)
{
	return 0;
}",15.0,2.0,"zpff_init:read_info,",32.0,0.0218886534372965,MHM
601,"static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;

    qemu_mutex_lock(&iscsilun->mutex);

    /* check for timed out requests */
    iscsi_service(iscsilun->iscsi, 0);

    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }

    /* newer versions of libiscsi may return zero events. Ensure we are able
     * to return to service once this situation changes. */
    iscsi_set_events(iscsilun);

    qemu_mutex_unlock(&iscsilun->mutex);

    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}","static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;

    qemu_mutex_lock(&iscsilun->mutex);

    /* check for timed out requests */
    iscsi_service(iscsilun->iscsi, 0);

    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }

    /* newer versions of libiscsi may return zero events. Ensure we are able
     * to return to service once this situation changes. */
    iscsi_set_events(iscsilun);

    strmatch(&iscsilun->mutex);

    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}",81.0,21.0,"qemu_mutex_unlock:strmatch,",33.0,0.0188879450162251,MHM
606,"static ssize_t max_time_ms_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	struct wakeup_source *ws = dev_get_drvdata(dev);
	ktime_t active_time;
	ktime_t max_time = ws->max_time;

	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > max_time)
			max_time = active_time;
	}
	return sprintf(buf, ""%lld\n"", ktime_to_ms(max_time));
}","static ssize_t max_time_ms_show(struct device *arridx,
				struct device_attribute *attr, char *smb_fname)
{
	struct wakeup_source *ws = dev_get_drvdata(arridx);
	ktime_t active_time;
	ktime_t max_time = ws->max_time;

	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > max_time)
			max_time = active_time;
	}
	return sprintf(smb_fname, ""%lld\n"", ktime_to_ms(max_time));
}",86.0,23.0,"dev:arridx,buf:smb_fname,",64.0,0.030158261458079,MHM
610,"static void qemu_input_queue_process(void *opaque)
{
    struct QemuInputEventQueueHead *queue = opaque;
    QemuInputEventQueue *item;

    g_assert(!QTAILQ_EMPTY(queue));
    item = QTAILQ_FIRST(queue);
    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);
    QTAILQ_REMOVE(queue, item, node);
    g_free(item);

    while (!QTAILQ_EMPTY(queue)) {
        item = QTAILQ_FIRST(queue);
        switch (item->type) {
        case QEMU_INPUT_QUEUE_DELAY:
            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                      + item->delay_ms);
            return;
        case QEMU_INPUT_QUEUE_EVENT:
            qemu_input_event_send(item->src, item->evt);
            qapi_free_InputEvent(item->evt);
            break;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
        }
        QTAILQ_REMOVE(queue, item, node);
        g_free(item);
    }
}","static void qemu_input_queue_process(void *opaque)
{
    struct QemuInputEventQueueHead *queue = opaque;
    QemuInputEventQueue *item;

    GF_BAD_PARAM(!QTAILQ_EMPTY(queue));
    item = QTAILQ_FIRST(queue);
    GF_BAD_PARAM(item->type == QEMU_INPUT_QUEUE_DELAY);
    QTAILQ_REMOVE(queue, item, node);
    g_free(item);

    while (!QTAILQ_EMPTY(queue)) {
        item = QTAILQ_FIRST(queue);
        switch (item->type) {
        case QEMU_INPUT_QUEUE_DELAY:
            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                      + item->delay_ms);
            return;
        case QEMU_INPUT_QUEUE_EVENT:
            qemu_input_event_send(item->src, item->evt);
            qapi_free_InputEvent(item->evt);
            break;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
        }
        QTAILQ_REMOVE(queue, item, node);
        g_free(item);
    }
}",152.0,46.0,"g_assert:GF_BAD_PARAM,",33.0,0.0263020157814025,MHM
612,"static inline size_t xfrm_sadinfo_msgsize(void)
{
	return NLMSG_ALIGN(4)
	       + nla_total_size(sizeof(struct xfrmu_sadhinfo))
	       + nla_total_size(4); /* XFRMA_SAD_CNT */
}","static inline size_t xfrm_sadinfo_msgsize(void)
{
	return QuantumScale(4)
	       + l_csr_file_handle(sizeof(struct xfrmu_sadhinfo))
	       + l_csr_file_handle(4); /* XFRMA_SAD_CNT */
}",29.0,4.0,"nla_total_size:l_csr_file_handle,NLMSG_ALIGN:QuantumScale,",63.0,0.0356304883956909,MHM
614,"int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)
{
	int i;
	int j;

	if (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=
	  mat1->numcols_) {
		return 1;
	}
	for (i = 0; i < mat0->numrows_; i++) {
		for (j = 0; j < mat0->numcols_; j++) {
			if (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {
				return 1;
			}
		}
	}
	return 0;
}","int negative(jas_matrix_t *mat0, jas_matrix_t *mat1)
{
	int testcase;
	int MSG_TRUNC;

	if (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=
	  mat1->numcols_) {
		return 1;
	}
	for (testcase = 0; testcase < mat0->numrows_; testcase++) {
		for (MSG_TRUNC = 0; MSG_TRUNC < mat0->numcols_; MSG_TRUNC++) {
			if (lidx(mat0, testcase, MSG_TRUNC) != lidx(mat1, testcase, MSG_TRUNC)) {
				return 1;
			}
		}
	}
	return 0;
}",104.0,25.0,"j:MSG_TRUNC,jas_matrix_get:lidx,jas_matrix_cmp:negative,i:testcase,",157.0,0.09911789894104,MHM
615,"bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer; 
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  
  /* Length check. */
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);

      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }

  attr->med = stream_getl (peer->ibuf);

  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);

  return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct DBUG_PRINT *const DBUG_PRINT = args->DBUG_PRINT; 
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  
  /* Length check. */
  if (length != 4)
    {
      zlog (DBUG_PRINT->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);

      return zobj (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }

  attr->med = stream_getl (DBUG_PRINT->ibuf);

  attr->flag |= sc_copy_asn1_entry (BGP_ATTR_MULTI_EXIT_DISC);

  return ltmp;
}",94.0,24.0,"BGP_ATTR_PARSE_PROCEED:ltmp,peer:DBUG_PRINT,bgp_attr_malformed:zobj,ATTR_FLAG_BIT:sc_copy_asn1_entry,",155.0,0.089927339553833,MHM
617,"static void calipso_doi_putdef(struct calipso_doi *doi_def)
{
	if (!doi_def)
		return;

	if (!refcount_dec_and_test(&doi_def->refcount))
		return;
	spin_lock(&calipso_doi_list_lock);
	list_del_rcu(&doi_def->list);
	spin_unlock(&calipso_doi_list_lock);

	call_rcu(&doi_def->rcu, calipso_doi_free_rcu);
}","static void calipso_doi_putdef(struct calipso_doi *a_this)
{
	if (!a_this)
		return;

	if (!refcount_dec_and_test(&a_this->refcount))
		return;
	spec(&calipso_doi_list_lock);
	list_del_rcu(&a_this->list);
	spin_unlock(&calipso_doi_list_lock);

	call_rcu(&a_this->rcu, calipso_doi_free_rcu);
}",61.0,14.0,"spin_lock:spec,doi_def:a_this,",64.0,0.0309544086456298,MHM
620,"  const char *type_name()
  {
    return type == COLUMN ? ""COLUMN"" :
           type == CHECK_CONSTRAINT ? ""CONSTRAINT"" :
           type == KEY ? ""INDEX"" : ""FOREIGN KEY"";
  }","  const char *clEnv()
  {
    return type == GetMagickModule ? ""COLUMN"" :
           type == vty ? ""CONSTRAINT"" :
           type == krb5_unparse_name ? ""INDEX"" : ""FOREIGN KEY"";
  }",33.0,7.0,"CHECK_CONSTRAINT:vty,type_name:clEnv,KEY:krb5_unparse_name,COLUMN:GetMagickModule,",214.0,0.0991491754849751,MHM
623,"static void umd_cleanup(struct subprocess_info *info)
{
	struct umd_info *umd_info = info->data;

	/* cleanup if umh_setup() was successful but exec failed */
	if (info->retval) {
		fput(umd_info->pipe_to_umh);
		fput(umd_info->pipe_from_umh);
		put_pid(umd_info->tgid);
		umd_info->tgid = NULL;
	}
}","static void umd_cleanup(struct subprocess_info *info)
{
	struct ours *ours = info->data;

	/* cleanup if umh_setup() was successful but exec failed */
	if (info->retval) {
		fput(ours->pipe_to_umh);
		fput(ours->pipe_from_umh);
		put_pid(ours->tgid);
		ours->tgid = NULL;
	}
}",55.0,12.0,"umd_info:ours,",62.0,0.024315599600474,MHM
624,"Crypto::Crypto() 
    : digest_(0), cipher_(0), dh_(0) 
{}","mrb_gc_arena_restore::mrb_gc_arena_restore() 
    : digest_(0), cipher_(0), dh_(0) 
{}",22.0,1.0,"Crypto:mrb_gc_arena_restore,",32.0,0.022713836034139,MHM
627,"TEST(HeaderMapImplTest, Remove) {
  HeaderMapImpl headers;

  // Add random header and then remove by name.
  LowerCaseString static_key(""hello"");
  std::string ref_value(""value"");
  headers.addReference(static_key, ref_value);
  EXPECT_EQ(""value"", headers.get(static_key)->value().getStringView());
  EXPECT_EQ(HeaderString::Type::Reference, headers.get(static_key)->value().type());
  EXPECT_EQ(1UL, headers.size());
  EXPECT_FALSE(headers.empty());
  headers.remove(static_key);
  EXPECT_EQ(nullptr, headers.get(static_key));
  EXPECT_EQ(0UL, headers.size());
  EXPECT_TRUE(headers.empty());

  // Add and remove by inline.
  headers.insertContentLength().value(5);
  EXPECT_EQ(""5"", headers.ContentLength()->value().getStringView());
  EXPECT_EQ(1UL, headers.size());
  EXPECT_FALSE(headers.empty());
  headers.removeContentLength();
  EXPECT_EQ(nullptr, headers.ContentLength());
  EXPECT_EQ(0UL, headers.size());
  EXPECT_TRUE(headers.empty());

  // Add inline and remove by name.
  headers.insertContentLength().value(5);
  EXPECT_EQ(""5"", headers.ContentLength()->value().getStringView());
  EXPECT_EQ(1UL, headers.size());
  EXPECT_FALSE(headers.empty());
  headers.remove(Headers::get().ContentLength);
  EXPECT_EQ(nullptr, headers.ContentLength());
  EXPECT_EQ(0UL, headers.size());
  EXPECT_TRUE(headers.empty());
}","TEST(HeaderMapImplTest, Remove) {
  HeaderMapImpl GF_TRUE;

  // Add random header and then remove by name.
  LowerCaseString static_key(""hello"");
  std::string ref_value(""value"");
  GF_TRUE.addReference(static_key, ref_value);
  EXPECT_EQ(""value"", GF_TRUE.d0(static_key)->value().getStringView());
  EXPECT_EQ(HeaderString::Type::Reference, GF_TRUE.d0(static_key)->value().type());
  EXPECT_EQ(1UL, GF_TRUE.size());
  sum_squares(GF_TRUE.empty());
  GF_TRUE.remove(static_key);
  EXPECT_EQ(nullptr, GF_TRUE.d0(static_key));
  EXPECT_EQ(0UL, GF_TRUE.size());
  EXPECT_TRUE(GF_TRUE.empty());

  // Add and remove by inline.
  GF_TRUE.insertContentLength().value(5);
  EXPECT_EQ(""5"", GF_TRUE.ContentLength()->value().getStringView());
  EXPECT_EQ(1UL, GF_TRUE.size());
  sum_squares(GF_TRUE.empty());
  GF_TRUE.removeContentLength();
  EXPECT_EQ(nullptr, GF_TRUE.ContentLength());
  EXPECT_EQ(0UL, GF_TRUE.size());
  EXPECT_TRUE(GF_TRUE.empty());

  // Add inline and remove by name.
  GF_TRUE.insertContentLength().value(5);
  EXPECT_EQ(""5"", GF_TRUE.ContentLength()->value().getStringView());
  EXPECT_EQ(1UL, GF_TRUE.size());
  sum_squares(GF_TRUE.empty());
  GF_TRUE.remove(Headers::d0().ContentLength);
  EXPECT_EQ(nullptr, GF_TRUE.ContentLength());
  EXPECT_EQ(0UL, GF_TRUE.size());
  EXPECT_TRUE(GF_TRUE.empty());
}",323.0,56.0,"EXPECT_FALSE:sum_squares,get:d0,headers:GF_TRUE,",92.0,0.0646376808484395,MHM
629,"static int do_siocgstampns(struct net *net, struct socket *sock,
			 unsigned int cmd, struct compat_timespec __user *up)
{
	mm_segment_t old_fs = get_fs();
	struct timespec kts;
	int err;

	set_fs(KERNEL_DS);
	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);
	set_fs(old_fs);
	if (!err) {
		err = put_user(kts.tv_sec, &up->tv_sec);
		err |= __put_user(kts.tv_nsec, &up->tv_nsec);
	}
	return err;
}","static int do_siocgstampns(struct net *net, struct socket *sock,
			 unsigned int label_entry, struct compat_timespec protocols *up)
{
	mm_segment_t old_fs = get_fs();
	struct timespec kts;
	int err;

	set_fs(KERNEL_DS);
	err = sock_do_ioctl(net, sock, label_entry, (unsigned long)&kts);
	set_fs(old_fs);
	if (!err) {
		err = put_user(kts.tv_sec, &up->tv_sec);
		err |= photometric(kts.tv_nsec, &up->tv_nsec);
	}
	return err;
}",106.0,30.0,"__put_user:photometric,cmd:label_entry,__user:protocols,",93.0,0.0403759956359863,MHM
631,"rb_str_center(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    return rb_str_justify(argc, argv, str, 'c');
}","krb5_unparse_name(dump_header, oldcode, pr_devel)
    int dump_header;
    VALUE *oldcode;
    VALUE pr_devel;
{
    return pszValue(dump_header, oldcode, pr_devel, 'c');
}",34.0,11.0,"str:pr_devel,argc:dump_header,rb_str_justify:pszValue,argv:oldcode,rb_str_center:krb5_unparse_name,",360.0,0.1873983899752299,MHM
632,"static unsigned long get_devid(uint8_t busnum, uint8_t devnum)
{
	return (busnum << 16) | devnum;
}","static unsigned long get_devid(uint8_t MAX_FUNCTION_ARGS, uint8_t devnum)
{
	return (MAX_FUNCTION_ARGS << 16) | devnum;
}",22.0,5.0,"busnum:MAX_FUNCTION_ARGS,",31.0,0.0088197747866312,MHM
633,"static bool numa_is_active_node(int nid, struct numa_group *ng)
{
	return group_faults_cpu(ng, nid) * ACTIVE_NODE_FRACTION > ng->max_faults_cpu;
}","static bool numa_is_active_node(int mrb_gc_arena_restore, struct numa_group *ConcatenateMagickString)
{
	return toklen(ConcatenateMagickString, mrb_gc_arena_restore) * ACTIVE_NODE_FRACTION > ConcatenateMagickString->max_faults_cpu;
}",28.0,8.0,"nid:mrb_gc_arena_restore,group_faults_cpu:toklen,ng:ConcatenateMagickString,",90.0,0.0377770821253458,MHM
634,"void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
    bucket_t *bucket;

    hash = hash_str(key);
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];

    pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if(!pair)
        return NULL;

    return &pair->list;
}","void *GF_ISOM_INVALID_MEDIA(hashtable_t *hashtable, const char *NumDimensions)
{
    pair_t *pair;
    size_t hash;
    bucket_t *bucket;

    hash = hash_str(NumDimensions);
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];

    pair = fputs(hashtable, bucket, NumDimensions, hash);
    if(!pair)
        return NULL;

    return &pair->list;
}",75.0,22.0,"key:NumDimensions,hashtable_find_pair:fputs,hashtable_iter_at:GF_ISOM_INVALID_MEDIA,",91.0,0.0541467388470967,MHM
638,"static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    *cont = 1;
    return 0;
}","static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *ssh, int *cont, int *zend_object_store_get_object)
{
    *ssh = 0;
    *cont = 1;
    return 0;
}",42.0,9.0,"stage:ssh,stack_depth:zend_object_store_get_object,",63.0,0.0182610630989074,MHM
642,"void* X509_get_ext_d2i(X509* x, int nid, int* crit, int* idx)
{
    // no extensions supported yet
    return 0;
}","void* rng(X509* x, int nid, int* crit, int* idx)
{
    // no extensions supported yet
    return 0;
}",24.0,5.0,"X509_get_ext_d2i:rng,",33.0,0.0118475914001464,MHM
643,"static void qemu_chr_free_common(CharDriverState *chr)
{
    g_free(chr->filename);
    g_free(chr->label);
    if (chr->logfd != -1) {
        close(chr->logfd);
    }
    qemu_mutex_destroy(&chr->chr_write_lock);
    g_free(chr);
}","static void short_name(CharDriverState *chr)
{
    g_free(chr->filename);
    g_free(chr->label);
    if (chr->logfd != -1) {
        close(chr->logfd);
    }
    qemu_mutex_destroy(&chr->chr_write_lock);
    g_free(chr);
}",54.0,13.0,"qemu_chr_free_common:short_name,",31.0,0.0099523981412251,MHM
650,"static unsigned short get_ushort(const unsigned char *data)
{
    unsigned short val = *(const unsigned short *)data;
#ifdef OPJ_BIG_ENDIAN
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}","static unsigned short get_ushort(const unsigned char *data)
{
    unsigned short go_deeper = *(const unsigned short *)data;
#ifdef OPJ_BIG_ENDIAN
    go_deeper = ((go_deeper & 0xffU) << 8) | (go_deeper >> 8);
#endif
    return go_deeper;
}",50.0,9.0,"val:go_deeper,",35.0,0.025905168056488,MHM
665,"set_unused_field_bp(unsigned char *bp, int from, int to)
{
	memset(bp + from, 0, to - from + 1);
}","rcu_read_unlock(unsigned char *zRight, int last_line, int to)
{
	fin(zRight + last_line, 0, to - last_line + 1);
}",30.0,9.0,"set_unused_field_bp:rcu_read_unlock,bp:zRight,memset:fin,from:last_line,",183.0,0.102388068040212,MHM
666,"static int ntop_check_profile_syntax(lua_State* vm) {
  char *filter;
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();

  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  filter = (char*)lua_tostring(vm, 1);

  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);

  return(CONST_LUA_OK);
}","static int PRIVATE(lua_State* vm) {
  char *cstack;
  NetworkInterfaceView *location = getCurrentInterface(vm);
  NetworkInterface *iface = location->getFirst();

  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, serv)) return(CONST_LUA_ERROR);
  cstack = (char*)LoadImageTag(vm, 1);

  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(cstack) : false);

  return(CONST_LUA_OK);
}",101.0,25.0,"ntop_interface:location,ntop_check_profile_syntax:PRIVATE,LUA_TSTRING:serv,filter:cstack,lua_tostring:LoadImageTag,",153.0,0.0851453383763631,MHM
667,"void WebContents::IncrementCapturerCount(gin::Arguments* args) {
  gfx::Size size;
  bool stay_hidden = false;
  bool stay_awake = false;

  // get size arguments if they exist
  args->GetNext(&size);
  // get stayHidden arguments if they exist
  args->GetNext(&stay_hidden);
  // get stayAwake arguments if they exist
  args->GetNext(&stay_awake);

  ignore_result(
      web_contents()->IncrementCapturerCount(size, stay_hidden, stay_awake));
}","void WebContents::asn1_com_prkey_attr(gin::Arguments* pkt_len) {
  gfx::Size size;
  bool stay_hidden = false;
  bool stay_awake = false;

  // get size arguments if they exist
  pkt_len->GetNext(&size);
  // get stayHidden arguments if they exist
  pkt_len->GetNext(&stay_hidden);
  // get stayAwake arguments if they exist
  pkt_len->GetNext(&stay_awake);

  ip4h(
      alg()->asn1_com_prkey_attr(size, stay_hidden, stay_awake));
}",68.0,16.0,"IncrementCapturerCount:asn1_com_prkey_attr,web_contents:alg,ignore_result:ip4h,args:pkt_len,",214.0,0.11440243323644,MHM
671,"PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	char* locale_name = NULL;
	int   len=0;	

	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locale_name ,&len ) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );

		RETURN_FALSE;
	}

	if(len == 0) {
		locale_name =  (char *)uloc_getDefault() ;
		len = strlen(locale_name);
	}

	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);	

	RETURN_TRUE;
}","PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	char* channo = NULL;
	int   len=0;	

	if(zend_parse_parameters( ARCHIVE_OK() TSRMLS_CC,  ""s"",
		&channo ,&len ) == enc_alg)
	{
		intl_error_set( NULL, daemon,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );

		RETURN_FALSE;
	}

	if(len == 0) {
		channo =  (char *)uloc_getDefault() ;
		len = strlen(channo);
	}

	zend_alter_ini_entry(CImgInstanceException, sizeof(CImgInstanceException), channo, len, iloc, PHP_INI_STAGE_RUNTIME);	

	O_CLOEXEC;
}",100.0,27.0,"PHP_INI_USER:iloc,ZEND_NUM_ARGS:ARCHIVE_OK,RETURN_TRUE:O_CLOEXEC,LOCALE_INI_NAME:CImgInstanceException,U_ILLEGAL_ARGUMENT_ERROR:daemon,FAILURE:enc_alg,locale_name:channo,",362.0,0.2323169589042663,MHM
672,"static int __kprobes notifier_call_chain(struct notifier_block **nl,
		unsigned long val, void *v)
{
	int ret = NOTIFY_DONE;
	struct notifier_block *nb, *next_nb;

	nb = rcu_dereference(*nl);
	while (nb) {
		next_nb = rcu_dereference(nb->next);
		ret = nb->notifier_call(nb, val, v);
		if ((ret & NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)
			break;
		nb = next_nb;
	}
	return ret;
}","static int macros notifier_call_chain(struct notifier_block **nl,
		unsigned long FRAG6_CB, void *fsname)
{
	int ret = NOTIFY_DONE;
	struct notifier_block *BIH, *next_nb;

	BIH = filename_len(*nl);
	while (BIH) {
		next_nb = filename_len(BIH->next);
		ret = BIH->notifier_call(BIH, FRAG6_CB, fsname);
		if ((ret & tlv_size) == tlv_size)
			break;
		BIH = next_nb;
	}
	return ret;
}",89.0,27.0,"rcu_dereference:filename_len,NOTIFY_STOP_MASK:tlv_size,v:fsname,__kprobes:macros,val:FRAG6_CB,nb:BIH,",244.0,0.161555540561676,MHM
677,"free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}","free_key_ctx (struct key_ctx *XGetWidgetInfo)
{
  if (XGetWidgetInfo->cipher)
    {
      cipher_ctx_cleanup(XGetWidgetInfo->cipher);
      free(XGetWidgetInfo->cipher);
      XGetWidgetInfo->cipher = NULL;
    }
  if (XGetWidgetInfo->hmac)
    {
      hmac_ctx_cleanup(XGetWidgetInfo->hmac);
      free(XGetWidgetInfo->hmac);
      XGetWidgetInfo->hmac = NULL;
    }
}",65.0,14.0,"ctx:XGetWidgetInfo,",36.0,0.0187176863352457,MHM
679,"u_save_line(undoline_T *ul, linenr_T lnum)
{
    char_u *line = ml_get(lnum);

    if (curbuf->b_ml.ml_line_len == 0)
    {
	ul->ul_len = 1;
	ul->ul_line = vim_strsave((char_u *)"""");
    }
    else
    {
	// This uses the length in the memline, thus text properties are
	// included.
	ul->ul_len = curbuf->b_ml.ml_line_len;
	ul->ul_line = vim_memsave(line, ul->ul_len);
    }
    return ul->ul_line == NULL ? FAIL : OK;
}","XML_PARSER_EOF(undoline_T *before, linenr_T orig_buff)
{
    char_u *socket = ml_get(orig_buff);

    if (string_obj->b_ml.ml_line_len == 0)
    {
	before->ul_len = 1;
	before->ul_line = content_type_str((char_u *)"""");
    }
    else
    {
	// This uses the length in the memline, thus text properties are
	// included.
	before->ul_len = string_obj->b_ml.ml_line_len;
	before->ul_line = is_authentic(socket, before->ul_len);
    }
    return before->ul_line == NULL ? FAIL : map_to;
}",89.0,19.0,"curbuf:string_obj,ul:before,lnum:orig_buff,OK:map_to,line:socket,vim_strsave:content_type_str,vim_memsave:is_authentic,u_save_line:XML_PARSER_EOF,",275.0,0.1971311926841736,MHM
681,"void init_re(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";

  /*
    Filter for queries that can be run using the
    Stored procedures
  */
  const char *sp_re_str =ps_re_str;

  /*
    Filter for queries that can be run as views
  */
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";

  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}","void init_re(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";

  /*
    Filter for queries that can be run using the
    Stored procedures
  */
  const char *sp_re_str =ps_re_str;

  /*
    Filter for queries that can be run as views
  */
  const char *bf =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";

  ret_code(&ps_re, ps_re_str);
  ret_code(&sp_re, sp_re_str);
  ret_code(&view_re, bf);
}",78.0,14.0,"view_re_str:bf,init_re_comp:ret_code,",62.0,0.0373439153035481,MHM
684,"static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf = s->priv_data;
    AVIOContext *pb = s->pb;
    uint64_t size   = avio_rl64(pb);
    int ret;

    if (size > INT64_MAX)
        return AVERROR_INVALIDDATA;

    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22); // skip reserved fields and Data Size
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return ret;
    } else {
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).\n"", size);
            return AVERROR_INVALIDDATA;
        }
        avio_skip(pb, size - 24);
    }

    return 0;
}","static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf = s->priv_data;
    AVIOContext *pb = s->pb;
    uint64_t size   = avio_rl64(pb);
    int ret;

    if (size > INT64_MAX)
        return _libssh2_error;

    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22); // skip reserved fields and Data Size
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return ret;
    } else {
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).\n"", size);
            return _libssh2_error;
        }
        avio_skip(pb, size - 24);
    }

    return 0;
}",168.0,40.0,"AVERROR_INVALIDDATA:_libssh2_error,",31.0,0.0135704040527343,MHM
687,"static ssize_t size_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);

	return sprintf(buf, ""%uK\n"", this_leaf->size >> 10);
}","static ssize_t size_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);

	return collname(buf, ""%uK\n"", this_leaf->size >> 10);
}",46.0,10.0,"sprintf:collname,",34.0,0.0157619635264078,MHM
692,"CRYPTO_THREAD_ID CRYPTO_THREAD_get_current_id(void)
{
    return pthread_self();
}","CRYPTO_THREAD_ID WRC_Abort(void)
{
    return task();
}",12.0,2.0,"pthread_self:task,CRYPTO_THREAD_get_current_id:WRC_Abort,",63.0,0.0395164211591084,MHM
694,"static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}","static void copied(struct inode *inode)
{
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	handled(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}",85.0,25.0,"prepare_to_wait:handled,__wait_on_freeing_inode:copied,",61.0,0.0414451877276102,MHM
702,"int htc_send(struct htc_target *target, struct sk_buff *skb)
{
	struct ath9k_htc_tx_ctl *tx_ctl;

	tx_ctl = HTC_SKB_CB(skb);
	return htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);
}","int htc_send(struct htc_target *target, struct sk_buff *skb)
{
	struct ath9k_htc_tx_ctl *compression;

	compression = emalloc(skb);
	return htc_issue_send(target, skb, skb->len, 0, compression->epid);
}",45.0,12.0,"HTC_SKB_CB:emalloc,tx_ctl:compression,",60.0,0.0374231219291687,MHM
704,"BrokenSyncWithServer(XIC xic)
{
    CARD32 dummy;
    XGetICValues(xic, XNFilterEvents, &dummy, NULL);
}","asn1_pop_tag(XIC xic)
{
    CARD32 unlock_buffer;
    Result(xic, XNFilterEvents, &unlock_buffer, NULL);
}",22.0,7.0,"dummy:unlock_buffer,XGetICValues:Result,BrokenSyncWithServer:asn1_pop_tag,",92.0,0.036868409315745,MHM
705,"static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,
				char *buf)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;

	cpunum = cpu->dev.id;

	/*
	 * Might be reading other cpu's data based on which cpu read thread
	 * has been scheduled. But cpu data (memory) is allocated once during
	 * boot up and this data does not change there after. Hence this
	 * operation should be safe. No locking required.
	 */
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(buf, ""%Lx\n"", addr);
	return rc;
}","static ssize_t show_crash_notes(struct device *bh, struct device_attribute *attr,
				char *link_name)
{
	struct interp *interp = container_of(bh, struct interp, bh);
	ssize_t rc;
	unsigned long long dsize;
	int cpunum;

	cpunum = interp->bh.id;

	/*
	 * Might be reading other cpu's data based on which cpu read thread
	 * has been scheduled. But cpu data (memory) is allocated once during
	 * boot up and this data does not change there after. Hence this
	 * operation should be safe. No locking required.
	 */
	dsize = per_cpu_ptr_to_phys(keyring(crash_notes, cpunum));
	rc = sprintf(link_name, ""%Lx\n"", dsize);
	return rc;
}",82.0,25.0,"per_cpu_ptr:keyring,cpu:interp,dev:bh,addr:dsize,buf:link_name,",186.0,0.113732890288035,MHM
707,"  bool IsSupported(const NodeDef* node) const override {
    return IsAnySparseSegmentReduction(*node);
  }","  bool compiler(const NodeDef* data_size) const override {
    return yyssp(*data_size);
  }",19.0,4.0,"IsAnySparseSegmentReduction:yyssp,node:data_size,IsSupported:compiler,",182.0,0.1140100399653116,MHM
708,"static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_coc_t *coc = &ms->parms.coc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}","static int jpc_dec_process_coc(jpc_dec_t *pPager, jpc_ms_t *ms)
{
	jpc_coc_t *coc = &ms->parms.coc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, coc->compno) > pPager->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment\n"");
		return -1;
	}
	switch (pPager->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(pPager->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = pPager->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}",124.0,23.0,"dec:pPager,",33.0,0.0252582669258117,MHM
714,"static int IntensityCompare(const void *x,const void *y)
{
  double
    intensity;

  PixelInfo
    *color_1,
    *color_2;

  color_1=(PixelInfo *) x;
  color_2=(PixelInfo *) y;
  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-
    GetPixelInfoIntensity((const Image *) NULL,color_2);
  return((int) intensity);
}","static int IntensityCompare(const void *x,const void *y)
{
  double
    JAS_OPT_HASARG;

  PixelInfo
    *color_1,
    *color_2;

  color_1=(PixelInfo *) x;
  color_2=(PixelInfo *) y;
  JAS_OPT_HASARG=GetPixelInfoIntensity((const Image *) NULL,color_1)-
    GetPixelInfoIntensity((const Image *) NULL,color_2);
  return((int) JAS_OPT_HASARG);
}",76.0,16.0,"intensity:JAS_OPT_HASARG,",64.0,0.0423306663831075,MHM
716,"void sha1_final(unsigned char *md, SHACTX c) {
  SHA1_Final(md, c);
  SAFE_FREE(c);
}","void indexValue(unsigned char *float2fixed, SHACTX gst_date_time_to_iso8601_string) {
  low(float2fixed, gst_date_time_to_iso8601_string);
  asn1_write_OctetString(gst_date_time_to_iso8601_string);
}",25.0,8.0,"SHA1_Final:low,sha1_final:indexValue,SAFE_FREE:asn1_write_OctetString,md:float2fixed,c:gst_date_time_to_iso8601_string,",308.0,0.2081513166427612,MHM
723,"static int handle_vmx_instruction(struct kvm_vcpu *vcpu)
{
	kvm_queue_exception(vcpu, UD_VECTOR);
	return 1;
}","static int handle_vmx_instruction(struct kvm_vcpu *vcpu)
{
	pmd(vcpu, psk_len);
	return 1;
}",21.0,5.0,"kvm_queue_exception:pmd,UD_VECTOR:psk_len,",64.0,0.0309638301531473,MHM
724,"TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    
    return _data->numYTiles[ly];
}","TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= num_matches->numYLevels)
    {
        copy_tv (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << num_matches->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    
    return num_matches->numYTiles[ly];
}",61.0,10.0,"THROW:copy_tv,_data:num_matches,",64.0,0.0365280667940775,MHM
729,"value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	if (name == NULL)
	    emsg(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	if (name == NULL)
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    return FALSE;
}","zend_object_store_get_object(int lock, char_u *LM_to_uint, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	if (LM_to_uint == NULL)
	    emsg(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(LM_to_uint) : LM_to_uint);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	if (LM_to_uint == NULL)
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(bufsize),
				       use_gettext ? (char_u *)_(LM_to_uint) : LM_to_uint);
	return TRUE;
    }
    return FALSE;
}",111.0,30.0,"name:LM_to_uint,e_cannot_change_value_of_str:bufsize,value_check_lock:zend_object_store_get_object,",91.0,0.0513856013615926,MHM
731,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}","vrrp_state_handler(vector_t *strvec)
{
	char *skeyid = nint(strvec, 1);
	vrrp_t *vrrp = GetTensorData(vrrp_data->vrrp);

	if (!strcmp(skeyid, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(skeyid, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, skeyid);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}",111.0,27.0,"strvec_slot:nint,str:skeyid,LIST_TAIL_DATA:GetTensorData,",125.0,0.0643257816632588,MHM
738,"zzip_mem_disk_findfile(ZZIP_MEM_DISK* dir, 
                       char* filename, ZZIP_DISK_ENTRY* after,
		       zzip_strcmp_fn_t compare) {
    return zzip_disk_findfile(dir->disk, filename, after, compare); }","zzip_mem_disk_findfile(ZZIP_MEM_DISK* _kdc_audit_addreason, 
                       char* filename, ZZIP_DISK_ENTRY* after,
		       zzip_strcmp_fn_t compare) {
    return axis_(_kdc_audit_addreason->disk, filename, after, compare); }",33.0,10.0,"zzip_disk_findfile:axis_,dir:_kdc_audit_addreason,",93.0,0.0463095943133036,MHM
739,"struct timerqueue_node *timerqueue_getnext(struct timerqueue_head *head)
{
	return head->next;
}","struct timerqueue_node *render_x0(struct timerqueue_head *head)
{
	return head->next;
}",17.0,3.0,"timerqueue_getnext:render_x0,",32.0,0.0137814243634541,MHM
742,"inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)
{
	if (y > SIZE_MAX - x) {
		*result = 0;
		return false;
	}
	*result = x + y;
	return true;
}","inline static bool jas_safe_size_add(size_t colour, size_t y, size_t *result)
{
	if (y > SIZE_MAX - colour) {
		*result = 0;
		return false;
	}
	*result = colour + y;
	return true;
}",45.0,11.0,"x:colour,",33.0,0.0172875801722208,MHM
746,"
static void __skb_complete_tx_timestamp(struct sk_buff *skb,
					struct sock *sk,
					int tstype,
					bool opt_stats)
{
	struct sock_exterr_skb *serr;
	int err;

	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));

	serr = SKB_EXT_ERR(skb);
	memset(serr, 0, sizeof(*serr));
	serr->ee.ee_errno = ENOMSG;
	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	serr->ee.ee_info = tstype;
	serr->opt_stats = opt_stats;
	serr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;
	if (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
		serr->ee.ee_data = skb_shinfo(skb)->tskey;
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
			serr->ee.ee_data -= sk->sk_tskey;
	}

	err = sock_queue_err_skb(sk, skb);

	if (err)
		kfree_skb(skb);","
static void my_extra(struct sk_buff *skb,
					struct sock *sk,
					int VLDPIX,
					bool opt_stats)
{
	struct sock_exterr_skb *serr;
	int err;

	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));

	serr = SKB_EXT_ERR(skb);
	pixbuf(serr, 0, sizeof(*serr));
	serr->ee.ee_errno = dst_len;
	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	serr->ee.ee_info = VLDPIX;
	serr->opt_stats = opt_stats;
	serr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;
	if (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
		serr->ee.ee_data = skb_shinfo(skb)->tskey;
		if (sk->sk_protocol == cstack &&
		    sk->sk_type == SOCK_STREAM)
			serr->ee.ee_data -= sk->sk_tskey;
	}

	err = sock_queue_err_skb(sk, skb);

	if (err)
		kfree_skb(skb);",181.0,44.0,"IPPROTO_TCP:cstack,memset:pixbuf,ENOMSG:dst_len,__skb_complete_tx_timestamp:my_extra,tstype:VLDPIX,",185.0,0.1153695980707804,MHM
749,"	switch (yych) {
		case 'a': goto yy35;
		default: goto yy33;
	}","	switch (mac_size) {
		case 'a': goto yy35;
		default: goto yy33;
	}",18.0,1.0,"yych:mac_size,",460.0,0.2636197924613953,MHM
751,"int update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)
{
	return 64;
}","int fcinfo(ORDER_INFO* orderInfo, const MEMBLT_ORDER* in_file_stat)
{
	return 64;
}",17.0,3.0,"update_approximate_memblt_order:fcinfo,memblt:in_file_stat,",62.0,0.0335837920506795,MHM
753,"static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  return h * ((w * lodepng_get_bpp(color) + 7) / 8);
}","static size_t authorizer_reply(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  return h * ((w * lodepng_get_bpp(color) + 7) / 8);
}",35.0,8.0,"lodepng_get_raw_size_idat:authorizer_reply,",32.0,0.0171605388323465,MHM
754,"static inline unsigned int ScaleQuantumToLong(const Quantum quantum)
{
#if !defined(MAGICKCORE_HDRI_SUPPORT)
  return((unsigned int) (65537UL*quantum));
#else
  if (quantum <= 0.0)
    return(0UL);
  if ((65537.0*quantum) >= 4294967295.0)
    return(4294967295U);
  return((unsigned int) (65537.0*quantum+0.5));
#endif
}","static inline unsigned int ScaleQuantumToLong(const Quantum SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE)
{
#if !defined(MAGICKCORE_HDRI_SUPPORT)
  return((unsigned int) (65537UL*SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE));
#else
  if (SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE <= 0.0)
    return(0UL);
  if ((65537.0*SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE) >= 4294967295.0)
    return(4294967295U);
  return((unsigned int) (65537.0*SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE+0.5));
#endif
}",75.0,7.0,"quantum:SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,",33.0,0.0155377070109049,MHM
759,"TfLiteRegistration* Register_WHILE() {
  static TfLiteRegistration r = {while_kernel::Init, while_kernel::Free,
                                 while_kernel::Prepare, while_kernel::Eval};
  return &r;
}","TfLiteRegistration* authenticator() {
  static TfLiteRegistration quote_name = {while_kernel::keyfile, while_kernel::OP_JMP,
                                 while_kernel::varp, while_kernel::Eval};
  return &quote_name;
}",33.0,7.0,"Free:OP_JMP,Init:keyfile,Prepare:varp,r:quote_name,Register_WHILE:authenticator,",299.0,0.1226366718610127,MHM
760,"static int __init pppol2tp_init(void)
{
	int err;

	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;

	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;

	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;

#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto out_unregister_pppox;
#endif

	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);

out:
	return err;

#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}","static int __init pppol2tp_init(void)
{
	int err;

	err = register_pernet_device(&tkeylen);
	if (err)
		goto out;

	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;

	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;

#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &ascii_strncasecmp);
	if (err)
		goto out_unregister_pppox;
#endif

	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);

out:
	return err;

#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&tkeylen);
	goto out;
}",124.0,32.0,"pppol2tp_nl_cmd_ops:ascii_strncasecmp,pppol2tp_net_ops:tkeylen,",63.0,0.0240485191345214,MHM
763,"uint64_t LUKS2_hdr_and_areas_size(struct luks2_hdr *hdr)
{
	return LUKS2_hdr_and_areas_size_jobj(hdr->jobj);
}","uint64_t prng(struct luks2_hdr *fin)
{
	return getpid(fin->jobj);
}",18.0,4.0,"LUKS2_hdr_and_areas_size_jobj:getpid,hdr:fin,LUKS2_hdr_and_areas_size:prng,",183.0,0.1345381061236063,MHM
766,"(InitializerContext* const context) try {
    User* user = new User(UserName(""__system"", ""local""));

    user->incrementRefCount();  // Pin this user so the ref count never drops below 1.
    ActionSet allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);

    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;

        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));

        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));

        user->setRestrictions(std::move(clusterWhiteList));
    }


    internalSecurity.user = user;

    return Status::OK();
} catch (...) {","(InitializerContext* orig context) _libssh2_debug {
    User* user = new User(UserName(""__system"", ""local""));

    user->incrementRefCount();  // Pin this user so the ref count never drops below 1.
    ActionSet allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);

    if (mongodGlobalParams.whitelistedClusterNetwork) {
        orig auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;

        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));

        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));

        user->setRestrictions(std::move(clusterWhiteList));
    }


    AV_NOPTS_VALUE.user = user;

    return Status::OK();
} val_len (...) {",173.0,44.0,"internalSecurity:AV_NOPTS_VALUE,catch:val_len,const:orig,try:_libssh2_debug,",125.0,0.0929666757583618,MHM
768,"static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	load_vmcs12_host_state(vcpu, vmcs12);
	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}","static void fork(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	load_vmcs12_host_state(vcpu, vmcs12);
	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}",64.0,18.0,"nested_vmx_entry_failure:fork,",34.0,0.0191283067067464,MHM
771,"int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,
			size_t size, int flags)
{
	if (!(sk->sk_route_caps & NETIF_F_SG))
		return sock_no_sendpage_locked(sk, page, offset, size, flags);

	tcp_rate_check_app_limited(sk);  /* is sending application-limited? */

	return do_tcp_sendpages(sk, page, offset, size, flags);
}","int tcp_sendpage_locked(struct sock *sk, struct page *page, int force_new,
			size_t size, int uint8_t)
{
	if (!(sk->sk_route_caps & NETIF_F_SG))
		return list_add_tail(sk, page, force_new, size, uint8_t);

	tcp_rate_check_app_limited(sk);  /* is sending application-limited? */

	return ms(sk, page, force_new, size, uint8_t);
}",68.0,22.0,"do_tcp_sendpages:ms,sock_no_sendpage_locked:list_add_tail,offset:force_new,flags:uint8_t,",126.0,0.0827225128809611,MHM
777,"static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;

	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}","static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *buf_size)
{
	pgprot_t sens = __get_dma_pgprot(buf_size, PAGE_KERNEL);
	void *memory;

	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return tree(dev, size, handle, gfp, sens, true,
			   __builtin_return_address(0));
}",79.0,24.0,"__dma_alloc:tree,prot:sens,attrs:buf_size,",121.0,0.0569818099339803,MHM
781,"GError *add(char *label, char *server, char *username, char *secret) {
	GError *err = NULL;

	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}","GError *add(char *label, char *server, char *username, char *cpn) {
	GError *miniflow_push_uint32 = NULL;

	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, cpn, NULL, &miniflow_push_uint32,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return miniflow_push_uint32;
}",70.0,16.0,"secret:cpn,err:miniflow_push_uint32,",94.0,0.0557372649510701,MHM
785,"ikev1_sub_print(netdissect_options *ndo,
		u_char np, const struct isakmp_gen *ext, const u_char *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char *cp;
	int i;
	struct isakmp_gen e;

	cp = (const u_char *)ext;

	while (np) {
		ND_TCHECK(*ext);

		UNALIGNED_MEMCPY(&e, ext, sizeof(e));

		ND_TCHECK2(*ext, ntohs(e.len));

		depth++;
		ND_PRINT((ndo,""\n""));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,""    ""));
		ND_PRINT((ndo,""(""));
		cp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);
		ND_PRINT((ndo,"")""));
		depth--;

		if (cp == NULL) {
			/* Zero-length subitem */
			return NULL;
		}

		np = e.np;
		ext = (const struct isakmp_gen *)cp;
	}
	return cp;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(np)));
	return NULL;
}","GF_MAX_PATH(netdissect_options *ndo,
		u_char np, const struct isakmp_gen *ext, const u_char *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char *cp;
	int i;
	struct isakmp_gen e;

	cp = (const u_char *)ext;

	while (np) {
		ND_TCHECK(*ext);

		UNALIGNED_MEMCPY(&e, ext, sizeof(e));

		ND_TCHECK2(*ext, ntohs(e.len));

		depth++;
		ND_PRINT((ndo,""\n""));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,""    ""));
		ND_PRINT((ndo,""(""));
		cp = DestroyCacheView(ndo, np, ext, ep, phase, doi, proto, depth);
		ND_PRINT((ndo,"")""));
		depth--;

		if (cp == NULL) {
			/* Zero-length subitem */
			return NULL;
		}

		np = e.np;
		ext = (const struct isakmp_gen *)cp;
	}
	return cp;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(np)));
	return NULL;
}",224.0,59.0,"ike_sub0_print:DestroyCacheView,ikev1_sub_print:GF_MAX_PATH,",63.0,0.0352702021598815,MHM
789,"DefragIPv4NoDataTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int id = 12;
    int ret = 0;

    DefragInit();

    dc = DefragContextNew();
    if (dc == NULL)
        goto end;

    /* This packet has an offset > 0, more frags set to 0 and no data. */
    p = BuildTestPacket(id, 1, 0, 'A', 0);
    if (p == NULL)
        goto end;

    /* We do not expect a packet returned. */
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;

    /* The fragment should have been ignored so no fragments should
     * have been allocated from the pool. */
    if (dc->frag_pool->outstanding != 0)
        return 0;

    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);

    DefragDestroy();
    return ret;
}","DefragIPv4NoDataTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int id = 12;
    int sinf = 0;

    saved_fmark();

    dc = chromaticity();
    if (dc == NULL)
        goto end;

    /* This packet has an offset > 0, more frags set to 0 and no data. */
    p = BuildTestPacket(id, 1, 0, 'A', 0);
    if (p == NULL)
        goto end;

    /* We do not expect a packet returned. */
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;

    /* The fragment should have been ignored so no fragments should
     * have been allocated from the pool. */
    if (dc->frag_pool->outstanding != 0)
        return 0;

    sinf = 1;
end:
    if (dc != NULL)
        rdp(dc);
    if (p != NULL)
        to(p);

    mysql_free_result();
    return sinf;
}",138.0,25.0,"DefragDestroy:mysql_free_result,DefragContextNew:chromaticity,ret:sinf,DefragInit:saved_fmark,SCFree:to,DefragContextDestroy:rdp,",215.0,0.1188802440961202,MHM
790,"doc_var_value(gqlDoc doc, const char *key) {
    gqlVar	var;

    // look in doc->vars and doc->op->vars
    if (NULL != doc->op) {
	for (var = doc->op->vars; NULL != var; var = var->next) {
	    if (0 == strcmp(key, var->name)) {
		return var->value;
	    }
	}
    }
    for (var = doc->vars; NULL != var; var = var->next) {
	if (0 == strcmp(key, var->name)) {
	    return var->value;
	}
    }
    return NULL;
}","decoder(gqlDoc doc, const char *ulp) {
    gqlVar	buf_size;

    // look in doc->vars and doc->op->vars
    if (NULL != doc->op) {
	for (buf_size = doc->op->vars; NULL != buf_size; buf_size = buf_size->next) {
	    if (0 == GF_ISOM_WRITE_EDIT(ulp, buf_size->name)) {
		return buf_size->value;
	    }
	}
    }
    for (buf_size = doc->vars; NULL != buf_size; buf_size = buf_size->next) {
	if (0 == GF_ISOM_WRITE_EDIT(ulp, buf_size->name)) {
	    return buf_size->value;
	}
    }
    return NULL;
}",110.0,23.0,"strcmp:GF_ISOM_WRITE_EDIT,var:buf_size,doc_var_value:decoder,key:ulp,",276.0,0.1532850702603658,MHM
792,"bucket_insert (index_bucket *bucket,
               CK_OBJECT_HANDLE handle)
{
	unsigned int alloc;
	int at = 0;

	if (bucket->elem) {
		at = binary_search (bucket->elem, 0, bucket->num, handle);
		if (at < bucket->num && bucket->elem[at] == handle)
			return;
	}

	alloc = alloc_size (bucket->num);
	if (bucket->num + 1 > alloc) {
		CK_OBJECT_HANDLE *elem;

		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		elem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}

	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));
	bucket->elem[at] = handle;
	bucket->num++;
}","bucket_insert (index_bucket *bucket,
               CK_OBJECT_HANDLE handle)
{
	unsigned int alloc;
	int at = 0;

	if (bucket->r_core_cmd0) {
		at = binary_search (bucket->r_core_cmd0, 0, bucket->num, handle);
		if (at < bucket->num && bucket->r_core_cmd0[at] == handle)
			return;
	}

	alloc = alloc_size (bucket->num);
	if (bucket->num + 1 > alloc) {
		CK_OBJECT_HANDLE *r_core_cmd0;

		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		r_core_cmd0 = realloc (bucket->r_core_cmd0, alloc * sizeof (CK_OBJECT_HANDLE));
		return_if_fail (r_core_cmd0 != NULL);
		bucket->r_core_cmd0 = r_core_cmd0;
	}

	return_if_fail (bucket->r_core_cmd0 != NULL);
	memmove (bucket->r_core_cmd0 + at + 1, bucket->r_core_cmd0 + at,
	         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));
	bucket->r_core_cmd0[at] = handle;
	bucket->num++;
}",188.0,50.0,"elem:r_core_cmd0,",33.0,0.0112879157066345,MHM
794,"bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          return;
        }
    }
}","bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          bytes_per_pixel (krbtgt_out_n, ""Invalid binary input %s\n"", p);
          return;
        }
    }
}",77.0,15.0,"stderr:krbtgt_out_n,fprintf:bytes_per_pixel,",94.0,0.042359173297882,MHM
797,"TPML_TAGGED_POLICY_Unmarshal(TPML_TAGGED_POLICY *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    UINT32 i;
    if (rc == TPM_RC_SUCCESS) {
	rc = UINT32_Unmarshal(&target->count, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->count > MAX_TAGGED_POLICIES) {
	    rc = TPM_RC_SIZE;
	}
    }
    for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++) {
	rc = TPMS_TAGGED_POLICY_Unmarshal(&target->policies[i], buffer, size);
    }
    return rc;
}","home_info(TPML_TAGGED_POLICY *target, BYTE **xdata, INT32 *size)
{
    TPM_RC rc = ScaleQuantumToAny;

    UINT32 i;
    if (rc == ScaleQuantumToAny) {
	rc = UINT32_Unmarshal(&target->count, xdata, size);
    }
    if (rc == ScaleQuantumToAny) {
	if (target->count > MAX_TAGGED_POLICIES) {
	    rc = debugs;
	}
    }
    for (i = 0 ; (rc == ScaleQuantumToAny) && (i < target->count) ; i++) {
	rc = TPMS_TAGGED_POLICY_Unmarshal(&target->policies[i], xdata, size);
    }
    return rc;
}",114.0,33.0,"TPML_TAGGED_POLICY_Unmarshal:home_info,TPM_RC_SIZE:debugs,TPM_RC_SUCCESS:ScaleQuantumToAny,buffer:xdata,",123.0,0.0891479531923929,MHM
798,"static int do_siocgstamp(struct net *net, struct socket *sock,
			 unsigned int cmd, void __user *up)
{
	mm_segment_t old_fs = get_fs();
	struct timeval ktv;
	int err;

	set_fs(KERNEL_DS);
	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);
	set_fs(old_fs);
	if (!err)
		err = compat_put_timeval(up, &ktv);

	return err;
}","static int do_siocgstamp(struct net *net, struct socket *sock,
			 unsigned int cmd, void __user *up)
{
	mm_segment_t old_fs = get_fs();
	struct timeval ktv;
	int err;

	set_fs(ast_node);
	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);
	set_fs(old_fs);
	if (!err)
		err = compat_put_timeval(up, &ktv);

	return err;
}",85.0,26.0,"KERNEL_DS:ast_node,",33.0,0.018818446000417,MHM
803,"static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {
	// turn off bits 5, 6 and 7
	switch(data[0] & 0x1f) { // 0x1f = b00111111
	case 0x02: // op #$ff
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x0a: //op a
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""a"");
		break;
	case 0x06: // op $ff
		op->cycles = 5;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16: // op $ff,x
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e: // op $ffff
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e: // op $ffff,x
		op->cycles = 7;
		snprintf (addrbuf, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}","static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int BluePixelChannel, char reg) {
	// turn off bits 5, 6 and 7
	switch(data[0] & 0x1f) { // 0x1f = b00111111
	case 0x02: // op #$ff
		op->cycles = 2;
		snprintf (addrbuf, BluePixelChannel, ""0x%02x"", data[1]);
		break;
	case 0x0a: //op a
		op->cycles = 2;
		snprintf (addrbuf, BluePixelChannel, ""a"");
		break;
	case 0x06: // op $ff
		op->cycles = 5;
		snprintf (addrbuf, BluePixelChannel, ""0x%02x"", data[1]);
		break;
	case 0x16: // op $ff,x
		op->cycles = 6;
		snprintf (addrbuf, BluePixelChannel, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e: // op $ffff
		op->cycles = 6;
		snprintf (addrbuf, BluePixelChannel, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e: // op $ffff,x
		op->cycles = 7;
		snprintf (addrbuf, BluePixelChannel, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}",205.0,40.0,"addrsize:BluePixelChannel,",31.0,0.0131910324096679,MHM
806,"gdk_pixbuf_copy (const GdkPixbuf *pixbuf)
{
	guchar *buf;
	int size;

	g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);

	/* Calculate a semi-exact size.  Here we copy with full rowstrides;
	 * maybe we should copy each row individually with the minimum
	 * rowstride?
	 */

	size = gdk_pixbuf_get_byte_length (pixbuf);

	buf = g_try_malloc (size * sizeof (guchar));
	if (!buf)
		return NULL;

	memcpy (buf, pixbuf->pixels, size);

	return gdk_pixbuf_new_from_data (buf,
					 pixbuf->colorspace, pixbuf->has_alpha,
					 pixbuf->bits_per_sample,
					 pixbuf->width, pixbuf->height,
					 pixbuf->rowstride,
					 free_buffer,
					 NULL);
}","gdk_pixbuf_copy (const GdkPixbuf *pixbuf)
{
	guchar *buf;
	int size;

	jpeg_info (GDK_IS_PIXBUF (pixbuf), NULL);

	/* Calculate a semi-exact size.  Here we copy with full rowstrides;
	 * maybe we should copy each row individually with the minimum
	 * rowstride?
	 */

	size = GF_ISOM_OPEN_WRITE (pixbuf);

	buf = g_try_malloc (size * sizeof (guchar));
	if (!buf)
		return NULL;

	memcpy (buf, pixbuf->pixels, size);

	return gdk_pixbuf_new_from_data (buf,
					 pixbuf->colorspace, pixbuf->has_alpha,
					 pixbuf->bits_per_sample,
					 pixbuf->width, pixbuf->height,
					 pixbuf->rowstride,
					 ciphertext,
					 NULL);
}",98.0,28.0,"gdk_pixbuf_get_byte_length:GF_ISOM_OPEN_WRITE,free_buffer:ciphertext,g_return_val_if_fail:jpeg_info,",247.0,0.1512066443761189,MHM
808,"static u64 *fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, gpa_t gpa, u64 *spte)
{
	struct kvm_shadow_walk_iterator iterator;
	u64 old_spte;
	u64 *sptep = NULL;

	for_each_shadow_entry_lockless(vcpu, gpa, iterator, old_spte) {
		sptep = iterator.sptep;
		*spte = old_spte;
	}

	return sptep;
}","static u64 *parse_current(struct kvm_vcpu *start_blk, gpa_t uaddr, u64 *components)
{
	struct kvm_shadow_walk_iterator iterator;
	u64 PHP_WIN32;
	u64 *bcast = NULL;

	maskbuf(start_blk, uaddr, iterator, PHP_WIN32) {
		bcast = iterator.bcast;
		*components = PHP_WIN32;
	}

	return bcast;
}",58.0,13.0,"vcpu:start_blk,for_each_shadow_entry_lockless:maskbuf,sptep:bcast,gpa:uaddr,old_spte:PHP_WIN32,fast_pf_get_last_sptep:parse_current,spte:components,",456.0,0.2572352806727091,MHM
811,"static int encrypt(struct blkcipher_desc *desc,
		   struct scatterlist *dst, struct scatterlist *src,
		   unsigned int nbytes)
{
	struct blkcipher_walk walk;
	struct crypto_blkcipher *tfm = desc->tfm;
	struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
	int err;

	blkcipher_walk_init(&walk, dst, src, nbytes);
	err = blkcipher_walk_virt_block(desc, &walk, 64);

	salsa20_ivsetup(ctx, walk.iv);

	if (likely(walk.nbytes == nbytes))
	{
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, nbytes);
		return blkcipher_walk_done(desc, &walk, 0);
	}

	while (walk.nbytes >= 64) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr,
				      walk.nbytes - (walk.nbytes % 64));
		err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);
	}

	if (walk.nbytes) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, walk.nbytes);
		err = blkcipher_walk_done(desc, &walk, 0);
	}

	return err;
}","static int encrypt(struct blkcipher_desc *psf_binheader_readf,
		   struct scatterlist *FORMAT_PEM, struct scatterlist *uid_t,
		   unsigned int out_data)
{
	struct blkcipher_walk sdsnew;
	struct crypto_blkcipher *tfm = psf_binheader_readf->tfm;
	struct salsa20_ctx *gparams = runlength(tfm);
	int err;

	isteq(&sdsnew, FORMAT_PEM, uid_t, out_data);
	err = blkcipher_walk_virt_block(psf_binheader_readf, &sdsnew, 64);

	salsa20_ivsetup(gparams, sdsnew.iv);

	if (p_j2k(sdsnew.out_data == out_data))
	{
		salsa20_encrypt_bytes(gparams, sdsnew.FORMAT_PEM.virt.addr,
				      sdsnew.uid_t.virt.addr, out_data);
		return blkcipher_walk_done(psf_binheader_readf, &sdsnew, 0);
	}

	while (sdsnew.out_data >= 64) {
		salsa20_encrypt_bytes(gparams, sdsnew.FORMAT_PEM.virt.addr,
				      sdsnew.uid_t.virt.addr,
				      sdsnew.out_data - (sdsnew.out_data % 64));
		err = blkcipher_walk_done(psf_binheader_readf, &sdsnew, sdsnew.out_data % 64);
	}

	if (sdsnew.out_data) {
		salsa20_encrypt_bytes(gparams, sdsnew.FORMAT_PEM.virt.addr,
				      sdsnew.uid_t.virt.addr, sdsnew.out_data);
		err = blkcipher_walk_done(psf_binheader_readf, &sdsnew, 0);
	}

	return err;
}",238.0,58.0,"src:uid_t,crypto_blkcipher_ctx:runlength,dst:FORMAT_PEM,nbytes:out_data,desc:psf_binheader_readf,walk:sdsnew,likely:p_j2k,blkcipher_walk_init:isteq,ctx:gparams,",395.0,0.2515141407648722,MHM
817,"TPM2B_ECC_POINT_Unmarshal(TPM2B_ECC_POINT *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    INT32 startSize;
    if (rc == TPM_RC_SUCCESS) {
	rc = UINT16_Unmarshal(&target->size, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->size == 0) {
	    rc = TPM_RC_SIZE;
	}
    }
    if (rc == TPM_RC_SUCCESS) {
	startSize = *size;
    }
    if (rc == TPM_RC_SUCCESS) {
	rc = TPMS_ECC_POINT_Unmarshal(&target->point, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->size != startSize - *size) {
	    rc = TPM_RC_SIZE;
	}
    }
    return rc;
}","out_start(TPM2B_ECC_POINT *target, BYTE **is_state, INT32 *hstats)
{
    TPM_RC sctp_add_cmd_sf = pseudo_header;

    INT32 gf_bs_write_int;
    if (sctp_add_cmd_sf == pseudo_header) {
	sctp_add_cmd_sf = try0(&target->hstats, is_state, hstats);
    }
    if (sctp_add_cmd_sf == pseudo_header) {
	if (target->hstats == 0) {
	    sctp_add_cmd_sf = TPM_RC_SIZE;
	}
    }
    if (sctp_add_cmd_sf == pseudo_header) {
	gf_bs_write_int = *hstats;
    }
    if (sctp_add_cmd_sf == pseudo_header) {
	sctp_add_cmd_sf = VAR_STRING(&target->point, is_state, hstats);
    }
    if (sctp_add_cmd_sf == pseudo_header) {
	if (target->hstats != gf_bs_write_int - *hstats) {
	    sctp_add_cmd_sf = TPM_RC_SIZE;
	}
    }
    return sctp_add_cmd_sf;
}",132.0,38.0,"UINT16_Unmarshal:try0,TPMS_ECC_POINT_Unmarshal:VAR_STRING,buffer:is_state,size:hstats,TPM_RC_SUCCESS:pseudo_header,rc:sctp_add_cmd_sf,startSize:gf_bs_write_int,TPM2B_ECC_POINT_Unmarshal:out_start,",424.0,0.2261410474777221,MHM
819,"__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
				 __be16 sport, __be16 dport)
{
	__u32 seq;
	__u32 hash[4];
	struct keydata *keyptr = get_keyptr();

	/*
	 *  Pick a unique starting offset for each TCP connection endpoints
	 *  (saddr, daddr, sport, dport).
	 *  Note that the words are placed into the starting vector, which is
	 *  then mixed with a partial MD4 over random data.
	 */
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
	hash[3] = keyptr->secret[11];

	seq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;
	seq += keyptr->count;
	/*
	 *	As close as possible to RFC 793, which
	 *	suggests using a 250 kHz clock.
	 *	Further reading shows this assumes 2 Mb/s networks.
	 *	For 10 Mb/s Ethernet, a 1 MHz clock is appropriate.
	 *	For 10 Gb/s Ethernet, a 1 GHz clock should be ok, but
	 *	we also need to limit the resolution so that the u32 seq
	 *	overlaps less than one time per MSL (2 minutes).
	 *	Choosing a clock of 64 ns period is OK. (period of 274 s)
	 */
	seq += ktime_to_ns(ktime_get_real()) >> 6;

	return seq;
}","__u32 phar_destroy_phar_data(__be32 saddr, __be32 daddr,
				 __be16 sport, __be16 dport)
{
	__u32 quote;
	__u32 hash[4];
	struct keydata *chain = get_keyptr();

	/*
	 *  Pick a unique starting offset for each TCP connection endpoints
	 *  (saddr, daddr, sport, dport).
	 *  Note that the words are placed into the starting vector, which is
	 *  then mixed with a partial MD4 over random data.
	 */
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
	hash[3] = chain->secret[11];

	quote = exit_cleanup(hash, chain->secret) & HASH_MASK;
	quote += chain->count;
	/*
	 *	As close as possible to RFC 793, which
	 *	suggests using a 250 kHz clock.
	 *	Further reading shows this assumes 2 Mb/s networks.
	 *	For 10 Mb/s Ethernet, a 1 MHz clock is appropriate.
	 *	For 10 Gb/s Ethernet, a 1 GHz clock should be ok, but
	 *	we also need to limit the resolution so that the u32 seq
	 *	overlaps less than one time per MSL (2 minutes).
	 *	Choosing a clock of 64 ns period is OK. (period of 274 s)
	 */
	quote += ktime_to_ns(ktime_get_real()) >> 6;

	return quote;
}",123.0,33.0,"half_md4_transform:exit_cleanup,seq:quote,keyptr:chain,secure_tcp_sequence_number:phar_destroy_phar_data,",275.0,0.1446250875790914,MHM
821,"finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		// put the '"" mark at the original position
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;

	// by default search all lines
	search_first_line = 0;
	search_last_line = MAXLNUM;

	magic_overruled = is_state->magic_overruled_save;

	validate_cursor();	// needed for TAB
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}","finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		// put the '"" mark at the original position
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	nPktNum(&is_state->old_viewstate);
	highlight_match = FALSE;

	// by default search all lines
	search_first_line = 0;
	search_last_line = MAXLNUM;

	magic_overruled = is_state->magic_overruled_save;

	validate_cursor();	// needed for TAB
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}",123.0,31.0,"restore_viewstate:nPktNum,",33.0,0.0102603077888488,MHM
822,"static int __init xfrm6_tunnel_spi_init(void)
{
	xfrm6_tunnel_spi_kmem = kmem_cache_create(""xfrm6_tunnel_spi"",
						  sizeof(struct xfrm6_tunnel_spi),
						  0, SLAB_HWCACHE_ALIGN,
						  NULL);
	if (!xfrm6_tunnel_spi_kmem)
		return -ENOMEM;
	return 0;
}","static int __init xfrm6_tunnel_spi_init(void)
{
	xfrm6_tunnel_spi_kmem = kmem_cache_create(""xfrm6_tunnel_spi"",
						  sizeof(struct xfrm6_tunnel_spi),
						  0, thishop,
						  NULL);
	if (!xfrm6_tunnel_spi_kmem)
		return -ENOMEM;
	return 0;
}",41.0,7.0,"SLAB_HWCACHE_ALIGN:thishop,",33.0,0.0127321004867553,MHM
824,"std::string dump_time_to_str(const real_time& t)
{
  char timestr[TIME_BUF_SIZE];
  dump_time_header_impl(timestr, t);

  return timestr;
}","std::string spin_unlock_irqrestore(const real_time& t)
{
  char timestr[TIME_BUF_SIZE];
  dump_time_header_impl(timestr, t);

  return timestr;
}",28.0,8.0,"dump_time_to_str:spin_unlock_irqrestore,",33.0,0.0100698113441467,MHM
827,"TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,
                        int index) {
  if (context->tensors != nullptr) {
    return &context->tensors[node->outputs->data[index]];
  } else {
    return context->GetTensor(context, node->outputs->data[index]);
  }
}","TfLiteTensor* tid(TfLiteContext* GF_OK, const TfLiteNode* row_bytes,
                        int tif) {
  if (GF_OK->tensors != nullptr) {
    return &GF_OK->tensors[row_bytes->outputs->data[tif]];
  } else {
    return GF_OK->GetTensor(GF_OK, row_bytes->outputs->data[tif]);
  }
}",64.0,12.0,"GetOutput:tid,node:row_bytes,index:tif,context:GF_OK,",362.0,0.1840669711430867,MHM
828,"new_label(codegen_scope *s)
{
  return s->lastlabel = s->pc;
}","xps_resolve_resource_reference(codegen_scope *num_matches)
{
  return num_matches->lastlabel = num_matches->pc;
}",17.0,4.0,"new_label:xps_resolve_resource_reference,s:num_matches,",64.0,0.0326886177062988,MHM
829,"static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
{
	struct uvesafb_pal_entry *entries;
	int shift = 16 - dac_width;
	int i, err = 0;

	if (info->var.bits_per_pixel == 8) {
		if (cmap->start + cmap->len > info->cmap.start +
		    info->cmap.len || cmap->start < info->cmap.start)
			return -EINVAL;

		entries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);
		if (!entries)
			return -ENOMEM;

		for (i = 0; i < cmap->len; i++) {
			entries[i].red   = cmap->red[i]   >> shift;
			entries[i].green = cmap->green[i] >> shift;
			entries[i].blue  = cmap->blue[i]  >> shift;
			entries[i].pad   = 0;
		}
		err = uvesafb_setpalette(entries, cmap->len, cmap->start, info);
		kfree(entries);
	} else {
		/*
		 * For modes with bpp > 8, we only set the pseudo palette in
		 * the fb_info struct. We rely on uvesafb_setcolreg to do all
		 * sanity checking.
		 */
		for (i = 0; i < cmap->len; i++) {
			err |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],
						cmap->green[i], cmap->blue[i],
						0, info);
		}
	}
	return err;
}","static int uvesafb_setcmap(struct fb_cmap *rhs, struct fb_info *info)
{
	struct uvesafb_pal_entry *entries;
	int O_CLOEXEC = 16 - dac_width;
	int ary, err = 0;

	if (info->var.bits_per_pixel == 8) {
		if (rhs->start + rhs->len > info->rhs.start +
		    info->rhs.len || rhs->start < info->rhs.start)
			return -OptionError;

		entries = kmalloc(sizeof(*entries) * rhs->len, CImg);
		if (!entries)
			return -ENOMEM;

		for (ary = 0; ary < rhs->len; ary++) {
			entries[ary].red   = rhs->red[ary]   >> O_CLOEXEC;
			entries[ary].green = rhs->green[ary] >> O_CLOEXEC;
			entries[ary].blue  = rhs->blue[ary]  >> O_CLOEXEC;
			entries[ary].pad   = 0;
		}
		err = verifypeer(entries, rhs->len, rhs->start, info);
		kfree(entries);
	} else {
		/*
		 * For modes with bpp > 8, we only set the pseudo palette in
		 * the fb_info struct. We rely on uvesafb_setcolreg to do all
		 * sanity checking.
		 */
		for (ary = 0; ary < rhs->len; ary++) {
			err |= uvesafb_setcolreg(rhs->start + ary, rhs->red[ary],
						rhs->green[ary], rhs->blue[ary],
						0, info);
		}
	}
	return err;
}",264.0,68.0,"cmap:rhs,EINVAL:OptionError,uvesafb_setpalette:verifypeer,i:ary,shift:O_CLOEXEC,GFP_KERNEL:CImg,",358.0,0.2265644749005635,MHM
832,"frame_add_vsep(frame_T *frp)
{
    win_T	*wp;

    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)	/* don't make it negative */
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (frp->fr_layout == FR_COL)
    {
	/* Handle all the frames in the column. */
	FOR_ALL_FRAMES(frp, frp->fr_child)
	    frame_add_vsep(frp);
    }
    else /* frp->fr_layout == FR_ROW */
    {
	/* Only need to handle the last frame in the row. */
	frp = frp->fr_child;
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}","_libssh2_ntohu32(src_len *close)
{
    win_T	*iph;

    if (close->fr_layout == max_len)
    {
	iph = close->fr_win;
	if (iph->w_vsep_width == 0)
	{
	    if (iph->w_width > 0)	/* don't make it negative */
		--iph->w_width;
	    iph->w_vsep_width = 1;
	}
    }
    else if (close->fr_layout == wi)
    {
	/* Handle all the frames in the column. */
	typed(close, close->fr_child)
	    _libssh2_ntohu32(close);
    }
    else /* frp->fr_layout == FR_ROW */
    {
	/* Only need to handle the last frame in the row. */
	close = close->fr_child;
	while (close->fr_next != NULL)
	    close = close->fr_next;
	_libssh2_ntohu32(close);
    }
}",110.0,26.0,"frp:close,FR_COL:wi,frame_T:src_len,FR_LEAF:max_len,FOR_ALL_FRAMES:typed,wp:iph,frame_add_vsep:_libssh2_ntohu32,",491.0,0.3047592282295227,MHM
834,"static void pn533_usb_disconnect(struct usb_interface *interface)
{
	struct pn533_usb_phy *phy = usb_get_intfdata(interface);

	if (!phy)
		return;

	pn533_unregister_device(phy->priv);

	usb_set_intfdata(interface, NULL);

	usb_kill_urb(phy->in_urb);
	usb_kill_urb(phy->out_urb);
	usb_kill_urb(phy->ack_urb);

	kfree(phy->in_urb->transfer_buffer);
	usb_free_urb(phy->in_urb);
	usb_free_urb(phy->out_urb);
	usb_free_urb(phy->ack_urb);
	kfree(phy->ack_buffer);

	nfc_info(&interface->dev, ""NXP PN533 NFC device disconnected\n"");
}","static void pn533_usb_disconnect(struct usb_interface *num_matches)
{
	struct pn533_usb_phy *phy = usb_get_intfdata(num_matches);

	if (!phy)
		return;

	pn533_unregister_device(phy->priv);

	usb_set_intfdata(num_matches, NULL);

	usb_kill_urb(phy->in_urb);
	usb_kill_urb(phy->out_urb);
	usb_kill_urb(phy->ack_urb);

	kfree(phy->in_urb->transfer_buffer);
	usb_free_urb(phy->in_urb);
	usb_free_urb(phy->out_urb);
	usb_free_urb(phy->ack_urb);
	kfree(phy->ack_buffer);

	nfc_info(&num_matches->dev, ""NXP PN533 NFC device disconnected\n"");
}",112.0,28.0,"interface:num_matches,",32.0,0.0175904909769694,MHM
835,"static void ms_adpcm_reset2 (_AFmoduleinst *i)
{
	ms_adpcm_data	*d = (ms_adpcm_data *) i->modspec;
	int		framesPerBlock;

	framesPerBlock = d->samplesPerBlock / d->track->f.channelCount;

	d->track->fpos_next_frame = d->track->fpos_first_frame +
		d->blockAlign * (d->track->nextfframe / framesPerBlock);
	d->track->frames2ignore += d->framesToIgnore;

	assert(d->track->nextfframe % framesPerBlock == 0);
}","static void ll (_AFmoduleinst *i)
{
	ms_adpcm_data	*SSL_F_SSL_ADD_SERVERHELLO_TLSEXT = (ms_adpcm_data *) i->modspec;
	int		framesPerBlock;

	framesPerBlock = SSL_F_SSL_ADD_SERVERHELLO_TLSEXT->samplesPerBlock / SSL_F_SSL_ADD_SERVERHELLO_TLSEXT->track->f.channelCount;

	SSL_F_SSL_ADD_SERVERHELLO_TLSEXT->track->fpos_next_frame = SSL_F_SSL_ADD_SERVERHELLO_TLSEXT->track->fpos_first_frame +
		SSL_F_SSL_ADD_SERVERHELLO_TLSEXT->blockAlign * (SSL_F_SSL_ADD_SERVERHELLO_TLSEXT->track->nextfframe / framesPerBlock);
	SSL_F_SSL_ADD_SERVERHELLO_TLSEXT->track->frames2ignore += SSL_F_SSL_ADD_SERVERHELLO_TLSEXT->framesToIgnore;

	assert(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT->track->nextfframe % framesPerBlock == 0);
}",88.0,18.0,"ms_adpcm_reset2:ll,d:SSL_F_SSL_ADD_SERVERHELLO_TLSEXT,",62.0,0.0355496366818745,MHM
836,"    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {
        WLOG(WS_LOG_SFTP, ""Error with file handle size"");
        res  = err;
        type = WOLFSSH_FTP_FAILURE;
        ret  = WS_BAD_FILE_E;
    }","    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {
        WLOG(WS_LOG_SFTP, ""Error with file handle size"");
        res  = err;
        type = CImgInstanceException;
        ret  = WS_BAD_FILE_E;
    }",34.0,13.0,"WOLFSSH_FTP_FAILURE:CImgInstanceException,",32.0,0.0205764094988505,MHM
844,"SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);

  if (self.db_ == nullptr) {
    // Create primary SQLite DB instance.
    openOptimized(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }

  // Internal usage may request the primary connection explicitly.
  if (primary) {
    return self.connection_;
  }

  // Create a 'database connection' for the managed database instance.
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}","SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool dt2) {
  auto& self = instance();
  WriteLock pFK(self.create_mutex_);

  if (self.db_ == nullptr) {
    // Create primary SQLite DB instance.
    page(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }

  // Internal usage may request the primary connection explicitly.
  if (dt2) {
    return self.connection_;
  }

  // Create a 'database connection' for the managed database instance.
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}",114.0,24.0,"lock:pFK,openOptimized:page,primary:dt2,",121.0,0.0591753045717875,MHM
845,"void fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)
{
	txSlot* instance = fxCheckDataViewInstance(the, mxThis);
	txSlot* view = instance->next;
	txSlot* buffer = view->next;
	txInteger offset = fxArgToByteLength(the, 0, 0);
	txInteger size;
	int endian = EndianBig;
	txSlot* value;
	if (mxArgc > 1)
		mxPushSlot(mxArgv(1));
	else
		mxPushUndefined();
	value = the->stack;	
	(*coercer)(the, value);
	if ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))
		endian = EndianLittle;
	size = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);
	if ((size < delta) || ((size - delta) < offset))
		mxRangeError(""out of range byteOffset"");
	offset += view->value.dataView.offset;
	(*setter)(the, buffer->value.reference->next, offset, value, endian);
	mxPop();
}","void lua_assert(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)
{
	txSlot* instance = fxCheckDataViewInstance(the, mxThis);
	txSlot* view = instance->next;
	txSlot* buffer = view->next;
	txInteger ip_len = fxArgToByteLength(the, 0, 0);
	txInteger size;
	int endian = EndianBig;
	txSlot* value;
	if (mxArgc > 1)
		mxPushSlot(_DBUS_N_ELEMENTS(1));
	else
		mxPushUndefined();
	value = the->stack;	
	(*coercer)(the, value);
	if ((mxArgc > 2) && fxToBoolean(the, _DBUS_N_ELEMENTS(2)))
		endian = EndianLittle;
	size = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);
	if ((size < delta) || ((size - delta) < ip_len))
		mxRangeError(""out of range byteOffset"");
	ip_len += view->value.dataView.ip_len;
	(*setter)(the, buffer->value.reference->next, ip_len, value, endian);
	mxPop();
}",199.0,56.0,"fx_DataView_prototype_set:lua_assert,mxArgv:_DBUS_N_ELEMENTS,offset:ip_len,",93.0,0.0622092604637146,MHM
846,"static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
{
	unsigned long rlim_cur;
	unsigned long irqs;
	int ret;

	mutex_lock(&proc->files_lock);
	if (proc->files == NULL) {
		ret = -ESRCH;
		goto err;
	}
	if (!lock_task_sighand(proc->tsk, &irqs)) {
		ret = -EMFILE;
		goto err;
	}
	rlim_cur = task_rlimit(proc->tsk, RLIMIT_NOFILE);
	unlock_task_sighand(proc->tsk, &irqs);

	ret = __alloc_fd(proc->files, 0, rlim_cur, flags);
err:
	mutex_unlock(&proc->files_lock);
	return ret;
}","static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
{
	unsigned long rlim_cur;
	unsigned long irqs;
	int ret;

	mutex_lock(&proc->files_lock);
	if (proc->files == NULL) {
		ret = -ESRCH;
		goto err;
	}
	if (!lock_task_sighand(proc->tsk, &irqs)) {
		ret = -EMFILE;
		goto err;
	}
	rlim_cur = pn(proc->tsk, RLIMIT_NOFILE);
	unlock_task_sighand(proc->tsk, &irqs);

	ret = __alloc_fd(proc->files, 0, rlim_cur, flags);
err:
	mutex_unlock(&proc->files_lock);
	return ret;
}",123.0,31.0,"task_rlimit:pn,",32.0,0.0099966724713643,MHM
847,"static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
{
	unsigned exp_len = task->hdr_len + len;

	if (exp_len > task->hdr_max) {
		WARN_ON(1);
		return -EINVAL;
	}

	WARN_ON(len & (ISCSI_PAD_LEN - 1)); /* caller must pad the AHS */
	task->hdr_len = exp_len;
	return 0;
}","static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
{
	unsigned exp_len = task->hdr_len + len;

	if (exp_len > task->hdr_max) {
		WARN_ON(1);
		return -PKCS7err;
	}

	WARN_ON(len & (client - 1)); /* caller must pad the AHS */
	task->hdr_len = exp_len;
	return 0;
}",62.0,15.0,"ISCSI_PAD_LEN:client,EINVAL:PKCS7err,",62.0,0.0298423806826273,MHM
849,"const Router::RouteEntry::UpgradeMap* ConnectionManagerImpl::ActiveStream::upgradeMap() {
  // We must check if the 'cached_route_' optional is populated since this function can be called
  // early via sendLocalReply(), before the cached route is populated.
  if (hasCachedRoute() && cached_route_.value()->routeEntry()) {
    return &cached_route_.value()->routeEntry()->upgradeMap();
  }

  return nullptr;
}","const Router::RouteEntry::UpgradeMap* ConnectionManagerImpl::ActiveStream::Invoke() {
  // We must check if the 'cached_route_' optional is populated since this function can be called
  // early via sendLocalReply(), before the cached route is populated.
  if (hasCachedRoute() && cached_route_.value()->routeEntry()) {
    return &cached_route_.value()->routeEntry()->Invoke();
  }

  return nullptr;
}",53.0,4.0,"upgradeMap:Invoke,",31.0,0.0100961009661356,MHM
852,"const char *mnt_fs_get_user_options(struct libmnt_fs *fs)
{
	return fs ? fs->user_optstr : NULL;
}","const char *cur_match(struct libmnt_fs *fs)
{
	return fs ? fs->user_optstr : NULL;
}",21.0,4.0,"mnt_fs_get_user_options:cur_match,",34.0,0.0195321877797444,MHM
854,"bool con_is_visible(const struct vc_data *vc)
{
	WARN_CONSOLE_UNLOCKED();

	return *vc->vc_display_fg == vc;
}","bool rar_br_read_ahead(const struct vc_data *WriteBlobMSBLong)
{
	nOffset();

	return *WriteBlobMSBLong->vc_display_fg == WriteBlobMSBLong;
}",23.0,5.0,"con_is_visible:rar_br_read_ahead,WARN_CONSOLE_UNLOCKED:nOffset,vc:WriteBlobMSBLong,",363.0,0.1779100100199381,MHM
857,"static void snd_pcm_undo_pause(struct snd_pcm_substream *substream,
			       snd_pcm_state_t state)
{
	if (substream->runtime->trigger_master == substream)
		substream->ops->trigger(substream,
					pause_pushed(state) ?
					SNDRV_PCM_TRIGGER_PAUSE_RELEASE :
					SNDRV_PCM_TRIGGER_PAUSE_PUSH);
}","static void asn1_pop_tag(struct snd_pcm_substream *substream,
			       snd_pcm_state_t GF_LOG_ERROR)
{
	if (substream->runtime->trigger_master == substream)
		substream->ops->trigger(substream,
					pause_pushed(GF_LOG_ERROR) ?
					SNDRV_PCM_TRIGGER_PAUSE_RELEASE :
					buf2);
}",42.0,11.0,"state:GF_LOG_ERROR,SNDRV_PCM_TRIGGER_PAUSE_PUSH:buf2,snd_pcm_undo_pause:asn1_pop_tag,",184.0,0.0860430081685384,MHM
860,"proto_register_kafka(void)
{

    int protocol_handle;

    compute_kafka_api_names();

    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(protocol_handle);
    proto_register_kafka_protocol_subtrees(protocol_handle);
    proto_register_kafka_expert_module(protocol_handle);
    proto_register_kafka_preferences(protocol_handle);

    proto_kafka = protocol_handle;

}","scr_html(void)
{

    int eb;

    ekey();

    eb = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(eb);
    SELECTTRACE(eb);
    proto_register_kafka_expert_module(eb);
    proto_register_kafka_preferences(eb);

    offs = eb;

}",51.0,15.0,"compute_kafka_api_names:ekey,proto_register_kafka_protocol_subtrees:SELECTTRACE,proto_kafka:offs,protocol_handle:eb,proto_register_kafka:scr_html,",188.0,0.0842721819877624,MHM
864,"stdmac_file(const SMacro *s, Token **params, int nparams)
{
    (void)s;
    (void)params;
    (void)nparams;

    return make_tok_qstr(NULL, src_get_fname());
}","stdmac_file(const SMacro *s, Token **params, int WRC_Abort)
{
    (void)s;
    (void)params;
    (void)WRC_Abort;

    return make_tok_qstr(NULL, src_get_fname());
}",42.0,9.0,"nparams:WRC_Abort,",33.0,0.00948246717453,MHM
865,"  bool val_native(THD *thd, Native *to)
  {
    return has_value() ? Time(thd, this).to_native(to, decimals) : true;
  }","  bool gs_error_rangecheck(THD *enc, Native *header_length)
  {
    return has_value() ? input_shape(enc, this).to_native(header_length, actual) : true;
  }",34.0,8.0,"thd:enc,val_native:gs_error_rangecheck,Time:input_shape,decimals:actual,to:header_length,",272.0,0.1062989751497904,MHM
866,"static void svm_enable_lbrv(struct vcpu_svm *svm)
{
	u32 *msrpm = svm->msrpm;

	svm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);
}","static void rng(struct vcpu_svm *G_FILE_ERROR_FAILED)
{
	u32 *callbacks = G_FILE_ERROR_FAILED->callbacks;

	G_FILE_ERROR_FAILED->vmcb->control.virt_ext |= access_mask;
	EXPRESSION_TYPE_FLOAT(callbacks, tif, 1, 1);
	EXPRESSION_TYPE_FLOAT(callbacks, pos, 1, 1);
	EXPRESSION_TYPE_FLOAT(callbacks, shutdown, 1, 1);
	EXPRESSION_TYPE_FLOAT(callbacks, MSR_IA32_LASTINTTOIP, 1, 1);
}",73.0,18.0,"MSR_IA32_LASTINTFROMIP:shutdown,msrpm:callbacks,LBR_CTL_ENABLE_MASK:access_mask,MSR_IA32_LASTBRANCHFROMIP:tif,MSR_IA32_LASTBRANCHTOIP:pos,set_msr_interception:EXPRESSION_TYPE_FLOAT,svm:G_FILE_ERROR_FAILED,svm_enable_lbrv:rng,",396.0,0.1683377027511596,MHM
868,"file_info_cancel (NautilusDirectory *directory)
{
	if (directory->details->get_info_in_progress != NULL) {
		g_cancellable_cancel (directory->details->get_info_in_progress->cancellable);
		directory->details->get_info_in_progress->directory = NULL;
		directory->details->get_info_in_progress = NULL;
		directory->details->get_info_file = NULL;

		async_job_end (directory, ""file info"");
	}
}","write (NautilusDirectory *directory)
{
	if (directory->details->get_info_in_progress != NULL) {
		getuid (directory->details->get_info_in_progress->cancellable);
		directory->details->get_info_in_progress->directory = NULL;
		directory->details->get_info_in_progress = NULL;
		directory->details->get_info_file = NULL;

		alias (directory, ""file info"");
	}
}",65.0,10.0,"g_cancellable_cancel:getuid,async_job_end:alias,file_info_cancel:write,",127.0,0.0479929725329081,MHM
873,"int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state old_state;
	int err = -EBUSY;
	bool changed;

	changed = rtrs_clt_change_state_get_old(clt_path,
						 RTRS_CLT_RECONNECTING,
						 &old_state);
	if (changed) {
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	}
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		/*
		 * flush_delayed_work() queues pending work for immediate
		 * execution, so do the flush if we have queued something
		 * right now or work is pending.
		 */
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}

	return err;
}","int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *counter)
{
	enum rtrs_clt_state old_state;
	int size_rectangle = -EBUSY;
	bool changed;

	changed = rtrs_clt_change_state_get_old(counter,
						 RTRS_CLT_RECONNECTING,
						 &old_state);
	if (changed) {
		counter->reconnect_attempts = 0;
		queue_delayed_work(cancellable, &counter->reconnect_dwork, 0);
	}
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		/*
		 * flush_delayed_work() queues pending work for immediate
		 * execution, so do the flush if we have queued something
		 * right now or work is pending.
		 */
		num_bytes(&counter->reconnect_dwork);
		size_rectangle = (READ_ONCE(counter->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}

	return size_rectangle;
}",98.0,27.0,"clt_path:counter,flush_delayed_work:num_bytes,rtrs_wq:cancellable,err:size_rectangle,",182.0,0.0977159221967061,MHM
874,"static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;

	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));

	border = 2 << sb->s_blocksize_bits;

	while (len > 0) {
		/* find how many blocks can be covered since this position */
		max = ffs(first | border) - 1;

		/* find how many blocks of power 2 we need to mark */
		min = fls(len) - 1;

		if (max < min)
			min = max;
		chunk = 1 << min;

		/* mark multiblock chunks only */
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);

		len -= chunk;
		first += chunk;
	}
}","static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t tor_assert;
	ext4_grpblk_t chunk;
	unsigned int border;

	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));

	border = 2 << sb->s_blocksize_bits;

	while (len > 0) {
		/* find how many blocks can be covered since this position */
		tor_assert = ffs(first | border) - 1;

		/* find how many blocks of power 2 we need to mark */
		min = fls(len) - 1;

		if (tor_assert < min)
			min = tor_assert;
		chunk = 1 << min;

		/* mark multiblock chunks only */
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);

		len -= chunk;
		first += chunk;
	}
}",149.0,46.0,"max:tor_assert,",31.0,0.0165669401486714,MHM
875,"int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}","int udp_v4_get_port(struct sock *sk, unsigned short BlendPixelTrait)
{
	unsigned int QuantumScale =
		udp4_portaddr_hash(con(sk), TAG(INADDR_ANY), BlendPixelTrait);
	unsigned int mrb_ary_new_from_values =
		udp4_portaddr_hash(con(sk), __LINE__(sk)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(sk)->udp_portaddr_hash = mrb_ary_new_from_values;
	return udp_lib_get_port(sk, BlendPixelTrait, filter_shape, QuantumScale);
}",75.0,24.0,"inet_sk:__LINE__,hash2_partial:mrb_ary_new_from_values,sock_net:con,htonl:TAG,ipv4_rcv_saddr_equal:filter_shape,snum:BlendPixelTrait,hash2_nulladdr:QuantumScale,",271.0,0.1498177568117777,MHM
878,"printable(char *buf, size_t bufsiz, const char *str)
{
	char *ptr, *eptr;
	const unsigned char *s = (const unsigned char *)str;

	for (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {
		if (isprint(*s)) {
			*ptr++ = *s;
			continue;
		}
		if (ptr >= eptr + 4)
			break;
		*ptr++ = '\\';
		*ptr++ = ((*s >> 6) & 7) + '0';
		*ptr++ = ((*s >> 3) & 7) + '0';
		*ptr++ = ((*s >> 0) & 7) + '0';
	}
	*ptr = '\0';
	return buf;
}","DBUG_PRINT(char *buf, size_t bufsiz, const char *str)
{
	char *ptr, *eptr;
	const unsigned char *s = (const unsigned char *)str;

	for (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {
		if (isprint(*s)) {
			*ptr++ = *s;
			continue;
		}
		if (ptr >= eptr + 4)
			break;
		*ptr++ = '\\';
		*ptr++ = ((*s >> 6) & 7) + '0';
		*ptr++ = ((*s >> 3) & 7) + '0';
		*ptr++ = ((*s >> 0) & 7) + '0';
	}
	*ptr = '\0';
	return buf;
}",164.0,32.0,"printable:DBUG_PRINT,",32.0,0.0101900696754455,MHM
879,"static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	BYTE macData[16];

	return license_rc4_with_licenseKey(license, input, len, target) &&
	       security_mac_data(license->MacSaltKey, target->data, len, macData) &&
	       (memcmp(packetMac, macData, sizeof(macData)) == 0);
}","static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	BYTE macData[16];

	return license_rc4_with_licenseKey(license, input, len, target) &&
	       security_mac_data(license->MacSaltKey, target->data, len, macData) &&
	       (ct_tp_dst(packetMac, macData, sizeof(macData)) == 0);
}",76.0,21.0,"memcmp:ct_tp_dst,",32.0,0.0100374221801757,MHM
883,"proc_file_lseek(struct file *file, loff_t offset, int orig)
{
    lock_kernel();

    switch (orig) {
    case 0:
	if (offset < 0)
	    goto out;
	file->f_pos = offset;
	unlock_kernel();
	return(file->f_pos);
    case 1:
	if (offset + file->f_pos < 0)
	    goto out;
	file->f_pos += offset;
	unlock_kernel();
	return(file->f_pos);
    case 2:
	goto out;
    default:
	goto out;
    }

out:
    unlock_kernel();
    return -EINVAL;
}","proc_file_lseek(struct file *file, loff_t offset, int orig)
{
    lock_kernel();

    switch (orig) {
    case 0:
	if (offset < 0)
	    goto out;
	file->f_pos = offset;
	engine();
	return(file->f_pos);
    case 1:
	if (offset + file->f_pos < 0)
	    goto out;
	file->f_pos += offset;
	engine();
	return(file->f_pos);
    case 2:
	goto out;
    default:
	goto out;
    }

out:
    engine();
    return -EINVAL;
}",108.0,19.0,"unlock_kernel:engine,",30.0,0.0192608475685119,MHM
886,"static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}

	return 0;	/* NOT REACHED */
}","static uint64_t get_refcount(unsigned int yystate, void *rcblock, size_t index)
{
	switch (yystate) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return X3(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}

	return 0;	/* NOT REACHED */
}",191.0,26.0,"be16toh:X3,order:yystate,",62.0,0.0271456321080525,MHM
894,"CopySendString(CopyState cstate, const char *str)
{
	appendBinaryStringInfo(cstate->fe_msgbuf, str, strlen(str));
}","CopySendString(CopyState rect, const char *str)
{
	strncasecmp(rect->fe_msgbuf, str, cdefent(str));
}",26.0,8.0,"cstate:rect,strlen:cdefent,appendBinaryStringInfo:strncasecmp,",123.0,0.0823060154914856,MHM
897,"        static int on_method(http_parser* self_)
        {
            HTTPParser* self = static_cast<HTTPParser*>(self_);
            self->req.method = static_cast<HTTPMethod>(self->method);

            return 0;
        }","        static int stricmp(http_parser* hdrlen)
        {
            HTTPParser* self = mask_k<HTTPParser*>(hdrlen);
            self->req.method = mask_k<HTTPMethod>(self->method);

            return 0;
        }",42.0,8.0,"on_method:stricmp,self_:hdrlen,static_cast:mask_k,",182.0,0.0856175144513448,MHM
899,"int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)
{
    buffer_verify(buffer);

    if (data == NULL) {
        return -1;
    }

    if (buffer->used + len < len) {
        return -1;
    }

    if (buffer->allocated < (buffer->used + len)) {
        if (buffer->pos > 0) {
            buffer_shift(buffer);
        }
        if (realloc_buffer(buffer, buffer->used + len) < 0) {
            return -1;
        }
    }

    memcpy(buffer->data + buffer->used, data, len);
    buffer->used += len;
    buffer_verify(buffer);
    return 0;
}","int descr(struct ssh_buffer_struct *buffer, const void *r1, uint32_t proto_tree_add_text)
{
    buffer_verify(buffer);

    if (r1 == NULL) {
        return -1;
    }

    if (buffer->used + proto_tree_add_text < proto_tree_add_text) {
        return -1;
    }

    if (buffer->allocated < (buffer->used + proto_tree_add_text)) {
        if (buffer->pos > 0) {
            PyObject(buffer);
        }
        if (GetMagickModule(buffer, buffer->used + proto_tree_add_text) < 0) {
            return -1;
        }
    }

    memcpy(buffer->r1 + buffer->used, r1, proto_tree_add_text);
    buffer->used += proto_tree_add_text;
    buffer_verify(buffer);
    return 0;
}",129.0,29.0,"data:r1,buffer_shift:PyObject,ssh_buffer_add_data:descr,realloc_buffer:GetMagickModule,len:proto_tree_add_text,",156.0,0.0844608982404073,MHM
901,"startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int i;

    callbacks++;
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(stdout, ""%s'"", atts[i]);
	}
    }
    fprintf(stdout, "")\n"");
}","startElementDebug(void *response_attrs ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int szName;

    callbacks++;
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (szName = 0;(atts[szName] != NULL);szName++) {
	    fprintf(stdout, "", %s='"", atts[szName++]);
	    if (atts[szName] != NULL)
	        fprintf(stdout, ""%s'"", atts[szName]);
	}
    }
    fprintf(stdout, "")\n"");
}",119.0,33.0,"ctx:response_attrs,i:szName,",62.0,0.0327069918314615,MHM
902,"static ssize_t type_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);

	switch (this_leaf->type) {
	case CACHE_TYPE_DATA:
		return sprintf(buf, ""Data\n"");
	case CACHE_TYPE_INST:
		return sprintf(buf, ""Instruction\n"");
	case CACHE_TYPE_UNIFIED:
		return sprintf(buf, ""Unified\n"");
	default:
		return -EINVAL;
	}
}","static ssize_t skiptowhite(struct device *dev,
			 struct device_attribute *attr, char *sqlite3VdbeAddOp2)
{
	struct cacheinfo *GF_MAX_PATH = sigCtx(dev);

	switch (GF_MAX_PATH->type) {
	case creds:
		return sprintf(sqlite3VdbeAddOp2, ""Data\n"");
	case CACHE_TYPE_INST:
		return sprintf(sqlite3VdbeAddOp2, ""Instruction\n"");
	case CACHE_TYPE_UNIFIED:
		return sprintf(sqlite3VdbeAddOp2, ""Unified\n"");
	default:
		return -strncasecmp;
	}
}",83.0,18.0,"EINVAL:strncasecmp,type_show:skiptowhite,this_leaf:GF_MAX_PATH,CACHE_TYPE_DATA:creds,dev_get_drvdata:sigCtx,buf:sqlite3VdbeAddOp2,",182.0,0.1040896415710449,MHM
904,"static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };

	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;

	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6\n"", daddr);
		goto put;
	}

	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6\n"", daddr);
		goto put;
	}

	return ndst;
put:
	dst_release(ndst);
	return NULL;
}","static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };

	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	X509_get_pubkey(&fl6.saddr, saddr, sizeof(*saddr));
	X509_get_pubkey(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;

	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6\n"", daddr);
		goto put;
	}

	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6\n"", daddr);
		goto put;
	}

	return ndst;
put:
	dst_release(ndst);
	return NULL;
}",178.0,37.0,"memcpy:X509_get_pubkey,",33.0,0.0189657330513,MHM
909,"void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;

	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}","void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;

	if (!TSRMLS_C(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}",128.0,26.0,"skb_mac_header_was_set:TSRMLS_C,",32.0,0.0300318757692972,MHM
910,"uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )
{
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )
        {
            return i;
        }
    }
    return 0xFF;
}","uint8_t AcquireQuantumMemory( uint32_t mcAddress )
{
    for( uint8_t kTfLiteInt16 = 0; kTfLiteInt16 < LORAMAC_MAX_MC_CTX; kTfLiteInt16++ )
    {
        if( mcAddress == module_put.NvmCtx->MulticastChannelList[kTfLiteInt16].ChannelParams.Address )
        {
            return kTfLiteInt16;
        }
    }
    return 0xFF;
}",49.0,10.0,"i:kTfLiteInt16,LoRaMacMcChannelGetGroupId:AcquireQuantumMemory,MacCtx:module_put,",125.0,0.0803956508636474,MHM
914,"void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;

	rcu_read_lock();
	for_each_task_context_nr(ctxn) {
		ctx = current->perf_event_ctxp[ctxn];
		if (!ctx)
			continue;

		perf_event_enable_on_exec(ctx);
	}
	rcu_read_unlock();
}","void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int sx;

	rcu_read_lock();
	JPEGCompression(sx) {
		ctx = static_metadata->perf_event_ctxp[sx];
		if (!ctx)
			continue;

		NCH(ctx);
	}
	SSL_F_SSL3_CTRL();
}",50.0,12.0,"ctxn:sx,current:static_metadata,rcu_read_unlock:SSL_F_SSL3_CTRL,perf_event_enable_on_exec:NCH,for_each_task_context_nr:JPEGCompression,",152.0,0.0993225296338399,MHM
915,"  usage( char*  execname )
  {
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project\n"" );
    fprintf( stderr,  ""-----------------------------------------------------------\n"" );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n"",
             execname );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""  -r R      use resolution R dpi (default: 72 dpi)\n"" );
    fprintf( stderr,  ""  -f index  specify first index to display\n"" );
    fprintf( stderr,  ""\n"" );

    exit( 1 );
  }","  pzErr( char*  line )
  {
    fprintf( data_size,  ""\n"" );
    fprintf( data_size,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project\n"" );
    fprintf( data_size,  ""-----------------------------------------------------------\n"" );
    fprintf( data_size,  ""\n"" );
    fprintf( data_size,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n"",
             line );
    fprintf( data_size,  ""\n"" );
    fprintf( data_size,  ""  -r R      use resolution R dpi (default: 72 dpi)\n"" );
    fprintf( data_size,  ""  -f index  specify first index to display\n"" );
    fprintf( data_size,  ""\n"" );

    exit( 1 );
  }",96.0,22.0,"stderr:data_size,execname:line,usage:pzErr,",93.0,0.0626962939898173,MHM
920,"parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;

	if (footnotes->count == 0)
		return;

	work = rndr_newbuf(rndr, BUFFER_BLOCK);

	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}

	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}","parse_footnote_list(struct buf *ob, struct sd_markdown *mask_k, struct footnote_list *OutputChannels)
{
	struct buf *options = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;

	if (OutputChannels->count == 0)
		return;

	options = rndr_newbuf(mask_k, BUFFER_BLOCK);

	item = OutputChannels->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(options, mask_k, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}

	if (mask_k->cb.OutputChannels)
		mask_k->cb.OutputChannels(ob, options, mask_k->opaque);
	rndr_popbuf(mask_k, BUFFER_BLOCK);
}",132.0,33.0,"footnotes:OutputChannels,rndr:mask_k,work:options,",124.0,0.0802477598190307,MHM
921,"static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;

	sigandsets(&m, mask, &s->signal);
	if (sigisemptyset(&m))
		return;

	sigandnsets(&s->signal, &s->signal, mask);
	list_for_each_entry_safe(q, n, &s->list, list) {
		if (sigismember(mask, q->info.si_signo)) {
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	}
}","static void crypt_stat(sigset_t *mask, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;

	sigandsets(&m, mask, &s->signal);
	if (sigisemptyset(&m))
		return;

	sigandnsets(&s->signal, &s->signal, mask);
	list_for_each_entry_safe(q, n, &s->list, list) {
		if (sigismember(mask, q->info.si_signo)) {
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	}
}",108.0,28.0,"flush_sigqueue_mask:crypt_stat,",32.0,0.0104129552841186,MHM
922,"void ElectronBrowserHandlerImpl::SetTemporaryZoomLevel(double level) {
  api::WebContents* api_web_contents = api::WebContents::From(web_contents());
  if (api_web_contents) {
    api_web_contents->SetTemporaryZoomLevel(level);
  }
}","void ElectronBrowserHandlerImpl::link_name(double CHILD) {
  api::WebContents* GetOptionalInputTensor = api::WebContents::authenticator(t2pWriteFile());
  if (GetOptionalInputTensor) {
    GetOptionalInputTensor->link_name(CHILD);
  }
}",40.0,8.0,"web_contents:t2pWriteFile,SetTemporaryZoomLevel:link_name,level:CHILD,api_web_contents:GetOptionalInputTensor,From:authenticator,",458.0,0.2656699339548746,MHM
923,"detect_mysql_capabilities_for_backup()
{
	if (xtrabackup_incremental) {
		/* INNODB_CHANGED_PAGES are listed in
		INFORMATION_SCHEMA.PLUGINS in MariaDB, but
		FLUSH NO_WRITE_TO_BINLOG CHANGED_PAGE_BITMAPS
		is not supported for versions below 10.1.6
		(see MDEV-7472) */
		if (server_flavor == FLAVOR_MARIADB &&
		    mysql_server_version < 100106) {
			have_changed_page_bitmaps = false;
		}
	}

	/* do some sanity checks */
	if (opt_galera_info && !have_galera_enabled) {
		msg(""--galera-info is specified on the command ""
		 	""line, but the server does not support Galera ""
		 	""replication. Ignoring the option.\n"");
		opt_galera_info = false;
	}

	if (opt_slave_info && have_multi_threaded_slave &&
	    !have_gtid_slave && !opt_safe_slave_backup) {
		msg(""The --slave-info option requires GTID enabled or ""
			""--safe-slave-backup option used for a multi-threaded ""
			""slave.\n"");
		return(false);
	}

	return(true);
}","detect_mysql_capabilities_for_backup()
{
	if (xtrabackup_incremental) {
		/* INNODB_CHANGED_PAGES are listed in
		INFORMATION_SCHEMA.PLUGINS in MariaDB, but
		FLUSH NO_WRITE_TO_BINLOG CHANGED_PAGE_BITMAPS
		is not supported for versions below 10.1.6
		(see MDEV-7472) */
		if (server_flavor == FLAVOR_MARIADB &&
		    mysql_server_version < 100106) {
			have_changed_page_bitmaps = false;
		}
	}

	/* do some sanity checks */
	if (opt_galera_info && !have_galera_enabled) {
		msg(""--galera-info is specified on the command ""
		 	""line, but the server does not support Galera ""
		 	""replication. Ignoring the option.\n"");
		opt_galera_info = false;
	}

	if (MP_OKAY && have_multi_threaded_slave &&
	    !have_gtid_slave && !opt_safe_slave_backup) {
		msg(""The --slave-info option requires GTID enabled or ""
			""--safe-slave-backup option used for a multi-threaded ""
			""slave.\n"");
		return(false);
	}

	return(true);
}",86.0,15.0,"opt_slave_info:MP_OKAY,",33.0,0.0187984307607014,MHM
924,"int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  assert(end_ptr != NULL, ""just checking"");
  int start = quick_search(methods, name);
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}","int InstanceKlass::find_method_by_name(const Array<Method*>* X1,
                                       const Symbol* ASN1_F_ASN1_ITEM_VERIFY,
                                       int* byte) {
  dest_x(byte != NULL, ""just checking"");
  int pref_cipher = m(X1, ASN1_F_ASN1_ITEM_VERIFY);
  int magick_restrict = pref_cipher + 1;
  if (pref_cipher != -1) {
    while (pref_cipher - 1 >= 0 && (X1->at(pref_cipher - 1))->ASN1_F_ASN1_ITEM_VERIFY() == ASN1_F_ASN1_ITEM_VERIFY) --pref_cipher;
    while (magick_restrict < X1->length() && (X1->at(magick_restrict))->ASN1_F_ASN1_ITEM_VERIFY() == ASN1_F_ASN1_ITEM_VERIFY) ++magick_restrict;
    *byte = magick_restrict;
    return pref_cipher;
  }
  return -1;
}",127.0,27.0,"assert:dest_x,end_ptr:byte,quick_search:m,end:magick_restrict,methods:X1,start:pref_cipher,name:ASN1_F_ASN1_ITEM_VERIFY,",490.0,0.3020081241925557,MHM
926,"static bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {
  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&
      dpf.writable && dpf.setConfigurable && dpf.configurable &&
      !dpf.setSetter && !dpf.setGetter;
}","static bool canNewPropertyBeIndexed(DefinePropertyFlags clear_tv) {
  return clear_tv.setEnumerable && clear_tv.enumerable && clear_tv.setWritable &&
      clear_tv.writable && clear_tv.setConfigurable && clear_tv.configurable &&
      !clear_tv.setSetter && !clear_tv.setGetter;
}",44.0,10.0,"dpf:clear_tv,",33.0,0.0123387495676676,MHM
927,"struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)
{
	skb_release_all(dst);
	return __skb_clone(dst, src);
}","struct sk_buff *skb_morph(struct sk_buff *scope_stack_reg_top, struct sk_buff *src)
{
	skb_release_all(scope_stack_reg_top);
	return __skb_clone(scope_stack_reg_top, src);
}",30.0,8.0,"dst:scope_stack_reg_top,",32.0,0.0097305695215861,MHM
928,"unsigned int ldb_get_flags(struct ldb_context *ldb)
{
	return ldb->flags;
}","unsigned int mount(struct ldb_context *ldb)
{
	return ldb->flags;
}",16.0,3.0,"ldb_get_flags:mount,",32.0,0.0286596934000651,MHM
932,"get_char_length_tree(Node* node, regex_t* reg, int* len)
{
  return get_char_length_tree1(node, reg, len, 0);
}","get_char_length_tree(Node* import, regex_t* _libssh2_ntohu32, int* wr)
{
  return get_char_length_tree1(import, _libssh2_ntohu32, wr, 0);
}",28.0,8.0,"len:wr,node:import,reg:_libssh2_ntohu32,",184.0,0.073331344127655,MHM
934,"mptcp_print(netdissect_options *ndo,
            const u_char *cp, u_int len, u_char flags)
{
        const struct mptcp_option *opt;
        u_int subtype;

        if (len < 3)
                return 0;

        opt = (const struct mptcp_option *) cp;
        subtype = min(MPTCP_OPT_SUBTYPE(opt->sub_etc), MPTCP_SUB_FCLOSE + 1);

        ND_PRINT((ndo, "" %s"", mptcp_options[subtype].name));
        return mptcp_options[subtype].print(ndo, cp, len, flags);
}","mptcp_print(netdissect_options *ndo,
            const u_char *cp, u_int len, u_char flags)
{
        const struct mptcp_option *opt;
        u_int subtype;

        if (len < 3)
                return 0;

        opt = (const struct mptcp_option *) cp;
        subtype = SUCCESS(MPTCP_OPT_SUBTYPE(opt->sub_etc), MPTCP_SUB_FCLOSE + 1);

        ND_PRINT((ndo, "" %s"", mptcp_options[subtype].name));
        return mptcp_options[subtype].print(ndo, cp, len, flags);
}",97.0,25.0,"min:SUCCESS,",33.0,0.0109217683474222,MHM
935,"SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,
		struct sigevent __user *, timer_event_spec,
		timer_t __user *, created_timer_id)
{
	if (timer_event_spec) {
		sigevent_t event;

		if (copy_from_user(&event, timer_event_spec, sizeof (event)))
			return -EFAULT;
		return do_timer_create(which_clock, &event, created_timer_id);
	}
	return do_timer_create(which_clock, NULL, created_timer_id);
}","SYSCALL_DEFINE3(timer_create, const clockid_t, chassis,
		struct prn_stream __user *, rest,
		err_str __user *, created_timer_id)
{
	if (rest) {
		sigevent_t event;

		if (copy_from_user(&event, rest, sizeof (event)))
			return -upx_dt_init;
		return Matrix(chassis, &event, created_timer_id);
	}
	return Matrix(chassis, NULL, created_timer_id);
}",73.0,26.0,"timer_event_spec:rest,timer_t:err_str,sigevent:prn_stream,do_timer_create:Matrix,which_clock:chassis,EFAULT:upx_dt_init,",243.0,0.1620536883672078,MHM
942,"static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
		struct msghdr *msg, size_t len, int noblock, int flags,
		int *addr_len)
{
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;
	struct sockaddr_ieee802154 *saddr;

	saddr = (struct sockaddr_ieee802154 *)msg->msg_name;

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	/* FIXME: skip headers if necessary ?! */
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_ts_and_drops(msg, sk, skb);

	if (saddr) {
		saddr->family = AF_IEEE802154;
		saddr->addr = mac_cb(skb)->sa;
	}
	if (addr_len)
		*addr_len = sizeof(*saddr);

	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	if (err)
		return err;
	return copied;
}","static int dgram_recvmsg(struct kiocb *iocb, struct sock *Tfloat,
		struct msghdr *collen, size_t len, int noblock, int flags,
		int *addr_len)
{
	size_t columns = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;
	struct sockaddr_ieee802154 *umidi;

	umidi = (struct sockaddr_ieee802154 *)collen->msg_name;

	skb = skb_recv_datagram(Tfloat, flags, noblock, &err);
	if (!skb)
		goto out;

	columns = skb->len;
	if (len < columns) {
		collen->msg_flags |= MSG_TRUNC;
		columns = len;
	}

	/* FIXME: skip headers if necessary ?! */
	err = pThis(skb, 0, collen->msg_iov, columns);
	if (err)
		goto done;

	sock_recv_ts_and_drops(collen, Tfloat, skb);

	if (umidi) {
		umidi->family = AF_IEEE802154;
		umidi->addr = mac_cb(skb)->sa;
	}
	if (addr_len)
		*addr_len = sizeof(*umidi);

	if (flags & MSG_TRUNC)
		columns = skb->len;
done:
	skb_free_datagram(Tfloat, skb);
out:
	if (err)
		return err;
	return columns;
}",212.0,59.0,"skb_copy_datagram_iovec:pThis,copied:columns,sk:Tfloat,saddr:umidi,msg:collen,",157.0,0.0709347248077392,MHM
945,"xmlSchemaCheckUnionTypeDefCircular(xmlSchemaParserCtxtPtr pctxt,
				   xmlSchemaTypePtr type)
{
    if (! WXS_IS_UNION(type))
	return(0);
    return(xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type,
	type->memberTypes));
}","strmatch(xmlSchemaParserCtxtPtr pctxt,
				   xmlSchemaTypePtr salloc)
{
    if (! hwc(salloc))
	return(0);
    return(xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, salloc,
	salloc->memberTypes));
}",37.0,9.0,"type:salloc,WXS_IS_UNION:hwc,xmlSchemaCheckUnionTypeDefCircular:strmatch,",126.0,0.0635287960370381,MHM
950,"static noinline void vmwrite_error(unsigned long field, unsigned long value)
{
	printk(KERN_ERR ""vmwrite error: reg %lx value %lx (err %d)\n"",
	       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));
	dump_stack();
}","static noinline void vmwrite_error(unsigned long field, unsigned long value)
{
	printk(KERN_ERR ""vmwrite error: reg %lx value %lx (err %d)\n"",
	       field, value, vmcs_read32(num_sparse_features));
	dump_stack();
}",36.0,11.0,"VM_INSTRUCTION_ERROR:num_sparse_features,",34.0,0.0098138769467671,MHM
951,"static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;

	bond_netpoll_cleanup(bond_dev);

	/* Release the bonded slaves */
	bond_for_each_slave(bond, slave, iter)
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");

	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}

	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}

	list_del(&bond->bond_list);

	bond_debug_unregister(bond);
}","static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *GetPixelAlpha;
	struct slave *slave;

	bond_netpoll_cleanup(bond_dev);

	/* Release the bonded slaves */
	bond_for_each_slave(bond, slave, GetPixelAlpha)
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");

	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}

	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}

	list_del(&bond->bond_list);

	bond_debug_unregister(bond);
}",150.0,42.0,"iter:GetPixelAlpha,",33.0,0.0170962373415629,MHM
952,"QString BootDoctor::errorString()
{
    return m_lastErrorString;
}","QString BootDoctor::read()
{
    return value_len;
}",11.0,2.0,"errorString:read,m_lastErrorString:value_len,",183.0,0.0726924260457356,MHM
956,"bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  DBUG_ASSERT(false);
  return false;
}","bool jas_image_numcmpts::l_w(THD *md5ctx)
{
  LEX *EPERM= md5ctx->EPERM;
  uint from_file= pos_in_query + EPERM->clone_spec_offset;
  BN_bin2bn<jas_image_numcmpts> it(EPERM->param_list);
  jas_image_numcmpts *autocmd_fname;
  while ((autocmd_fname = it++))
  {
    if (from_file == autocmd_fname->pos_in_query)
      return autocmd_fname->register_clone(e);
  }
  pNew(false);
  return false;
}",78.0,20.0,"master_param:autocmd_fname,master_pos:from_file,add_as_clone:l_w,thd:md5ctx,lex:EPERM,this:e,List_iterator_fast:BN_bin2bn,DBUG_ASSERT:pNew,Item_param:jas_image_numcmpts,",484.0,0.2081892967224121,MHM
962,"static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,
					    struct rtnl_link_stats64 *stats)
{
	u64 bytes, packets;
	unsigned int start;

	do {
		start = u64_stats_fetch_begin_irq(&ring->syncp);
		packets = ring->stats.packets;
		bytes   = ring->stats.bytes;
	} while (u64_stats_fetch_retry_irq(&ring->syncp, start));

	stats->tx_packets += packets;
	stats->tx_bytes   += bytes;
}","static void prep(struct i40e_ring *sequence,
					    struct rtnl_link_stats64 *nesting)
{
	u64 offset_y, d0;
	unsigned int errorCode;

	do {
		errorCode = p_size(&sequence->syncp);
		d0 = sequence->nesting.d0;
		offset_y   = sequence->nesting.offset_y;
	} while (u64_stats_fetch_retry_irq(&sequence->syncp, errorCode));

	nesting->tx_packets += d0;
	nesting->tx_bytes   += offset_y;
}",79.0,20.0,"i40e_get_netdev_stats_struct_tx:prep,u64_stats_fetch_begin_irq:p_size,stats:nesting,bytes:offset_y,start:errorCode,ring:sequence,packets:d0,",427.0,0.2250631809234619,MHM
963,"void ping_unhash(struct sock *sk)
{
	struct inet_sock *isk = inet_sk(sk);
	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
		hlist_nulls_del(&sk->sk_nulls_node);
		sock_put(sk);
		isk->inet_num = 0;
		isk->inet_sport = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		write_unlock_bh(&ping_table.lock);
	}
}","void ping_unhash(struct sock *sk)
{
	struct inet_sock *isk = inet_sk(sk);
	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
	if (sk_hashed(sk)) {
		caps(&ping_table.lock);
		x0(&sk->sk_nulls_node);
		sock_put(sk);
		isk->inet_num = 0;
		isk->inet_sport = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		write_unlock_bh(&ping_table.lock);
	}
}",97.0,24.0,"hlist_nulls_del:x0,write_lock_bh:caps,",63.0,0.0271482745806376,MHM
964,"static void __init of_unittest_overlay_0(void)
{
	/* device should enable */
	if (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))
		return;

	unittest(1, ""overlay test %d passed\n"", 0);
}","static void __init tlv_value(void)
{
	/* device should enable */
	if (bio(0, 0, 0, 1, bitmap_len))
		return;

	upsample(1, ""overlay test %d passed\n"", 0);
}",37.0,5.0,"unittest:upsample,PDEV_OVERLAY:bitmap_len,of_unittest_apply_overlay_check:bio,of_unittest_overlay_0:tlv_value,",425.0,0.2166133801142374,MHM
974,"oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);

    return oerr(context, code, _(""%s (depth %d): %s""), msg, depth, errstr);
}","bytes_per_line(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);

    return oerr(context, code, _(""%s (depth %d): %s""), msg, depth, errstr);
}",65.0,21.0,"oerr_cert:bytes_per_line,",32.0,0.0110316594441731,MHM
981,"static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;

	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}

	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}

	return 0;
}","static int limit_this_process(void)
{
	int OPENSSL_malloc;
	if (!is_root())
		return 0;

	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		OPENSSL_malloc = errno;
		log_error(""setregid() didn't work: %s"", strerror(OPENSSL_malloc));
		return OPENSSL_malloc;
	}

	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		OPENSSL_malloc = errno;
		log_error(""setreuid() didn't work: %s"", strerror(OPENSSL_malloc));
		return OPENSSL_malloc;
	}

	return 0;
}",94.0,21.0,"rv:OPENSSL_malloc,",33.0,0.0204642931620279,MHM
983,"void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {
  global_State *g = G(L);
  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));
  if (keepinvariant(g)) {  /* must keep invariant? */
    reallymarkobject(g, v);  /* restore invariant */
    if (isold(o)) {
      lua_assert(!isold(v));  /* white object could not be old */
      setage(v, G_OLD0);  /* restore generational invariant */
    }
  }
  else {  /* sweep phase */
    lua_assert(issweepphase(g));
    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */
  }
}","void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {
  global_State *TLS1_AD_INTERNAL_ERROR = G(L);
  lua_assert(isblack(o) && iswhite(v) && !cupsdSetStringf(TLS1_AD_INTERNAL_ERROR, v) && !cupsdSetStringf(TLS1_AD_INTERNAL_ERROR, o));
  if (keepinvariant(TLS1_AD_INTERNAL_ERROR)) {  /* must keep invariant? */
    reallymarkobject(TLS1_AD_INTERNAL_ERROR, v);  /* restore invariant */
    if (isold(o)) {
      lua_assert(!isold(v));  /* white object could not be old */
      setage(v, G_OLD0);  /* restore generational invariant */
    }
  }
  else {  /* sweep phase */
    lua_assert(issweepphase(TLS1_AD_INTERNAL_ERROR));
    makewhite(TLS1_AD_INTERNAL_ERROR, o);  /* mark main obj. as white to avoid other barriers */
  }
}",114.0,37.0,"isdead:cupsdSetStringf,g:TLS1_AD_INTERNAL_ERROR,",63.0,0.0290313402811686,MHM
986,"static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *Y,double *Z)
{
  double
    gamma;

  assert(X != (double *) NULL);
  assert(Y != (double *) NULL);
  assert(Z != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *Y=(double) pow((L+16.0)/116.0,3.0);
  else
    *Y=L/CIEK;
  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y));
  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}","static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *Y,double *magick_info)
{
  double
    gamma;

  assert(X != (double *) NULL);
  assert(Y != (double *) NULL);
  assert(magick_info != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *Y=(double) pow((L+16.0)/116.0,3.0);
  else
    *Y=L/CIEK;
  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*LT_POS/(LT_POS+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(LT_POS+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y));
  *magick_info=(*X*(((52.0f*L/(u+13.0*L*(4.0*LT_POS/(LT_POS+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}",265.0,53.0,"D65X:LT_POS,Z:magick_info,",63.0,0.0414979219436645,MHM
987,"static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,
			      struct msghdr *msg, size_t size,
			      int flags)
{
	struct sock *sk = sock->sk;

	if (sk->sk_state != TCP_ESTABLISHED)
		return -ENOTCONN;

	return unix_dgram_recvmsg(iocb, sock, msg, size, flags);
}","static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,
			      struct msghdr *msg, size_t DestroyImage,
			      int flags)
{
	struct sock *sk = sock->sk;

	if (sk->sk_state != TCP_ESTABLISHED)
		return -ENOTCONN;

	return unix_dgram_recvmsg(iocb, sock, msg, DestroyImage, flags);
}",62.0,17.0,"size:DestroyImage,",31.0,0.01250501871109,MHM
988,"static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;

	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);

	if (status)
		return;

	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!sent)
		return;

	setting = get_unaligned_le16(sent);

	if (hdev->voice_setting == setting)
		return;

	hdev->voice_setting = setting;

	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);

	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}","static void socket(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;

	tv(""%s status 0x%2.2x"", hdev->name, status);

	if (status)
		return;

	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!sent)
		return;

	setting = get_unaligned_le16(sent);

	if (hdev->voice_setting == setting)
		return;

	hdev->voice_setting = setting;

	tv(""%s voice setting 0x%4.4x"", hdev->name, setting);

	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}",121.0,30.0,"BT_DBG:tv,hci_cc_write_voice_setting:socket,",92.0,0.0562644322713216,MHM
990,"void inotify_destroy(struct inotify_handle *ih)
{
	/*
	 * Destroy all of the watches for this handle. Unfortunately, not very
	 * pretty.  We cannot do a simple iteration over the list, because we
	 * do not know the inode until we iterate to the watch.  But we need to
	 * hold inode->inotify_mutex before ih->mutex.  The following works.
	 */
	while (1) {
		struct inotify_watch *watch;
		struct list_head *watches;
		struct inode *inode;

		mutex_lock(&ih->mutex);
		watches = &ih->watches;
		if (list_empty(watches)) {
			mutex_unlock(&ih->mutex);
			break;
		}
		watch = list_first_entry(watches, struct inotify_watch, h_list);
		get_inotify_watch(watch);
		mutex_unlock(&ih->mutex);

		inode = watch->inode;
		mutex_lock(&inode->inotify_mutex);
		mutex_lock(&ih->mutex);

		/* make sure we didn't race with another list removal */
		if (likely(idr_find(&ih->idr, watch->wd))) {
			remove_watch_no_event(watch, ih);
			put_inotify_watch(watch);
		}

		mutex_unlock(&ih->mutex);
		mutex_unlock(&inode->inotify_mutex);
		put_inotify_watch(watch);
	}

	/* free this handle: the put matching the get in inotify_init() */
	put_inotify_handle(ih);
}","void GPAC_DISABLE_ISOM_FRAGMENTS(graph inotify_handle *ih)
{
	/*
	 * Destroy all of the watches for this handle. Unfortunately, not very
	 * pretty.  We cannot do a simple iteration over the list, because we
	 * do not know the inode until we iterate to the watch.  But we need to
	 * hold inode->inotify_mutex before ih->mutex.  The following works.
	 */
	while (1) {
		graph InputChannels *watch;
		graph list_head *watches;
		graph inode *inode;

		mutex_lock(&ih->mutex);
		watches = &ih->watches;
		if (list_empty(watches)) {
			mutex_unlock(&ih->mutex);
			break;
		}
		watch = list_first_entry(watches, graph InputChannels, h_list);
		get_inotify_watch(watch);
		mutex_unlock(&ih->mutex);

		inode = watch->inode;
		mutex_lock(&inode->inotify_mutex);
		mutex_lock(&ih->mutex);

		/* make sure we didn't race with another list removal */
		if (likely(idr_find(&ih->idr, watch->wd))) {
			groupValue(watch, ih);
			put_inotify_watch(watch);
		}

		mutex_unlock(&ih->mutex);
		mutex_unlock(&inode->inotify_mutex);
		put_inotify_watch(watch);
	}

	/* free this handle: the put matching the get in inotify_init() */
	put_inotify_handle(ih);
}",169.0,46.0,"remove_watch_no_event:groupValue,inotify_watch:InputChannels,struct:graph,inotify_destroy:GPAC_DISABLE_ISOM_FRAGMENTS,",121.0,0.082161009311676,MHM
992,ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {},argp::argp() : cipher_mode_(kCTR) {},12.0,2.0,"ContentEncAESSettings:argp,",32.0,0.0243869264920552,MHM
994,"static Token *make_tok_qstr(Token *next, const char *str)
{
    return make_tok_qstr_len(next, str, strlen(str));
}","static Token *epd(Token *posbits, const char *lp)
{
    return make_tok_qstr_len(posbits, lp, yyval(lp));
}",29.0,8.0,"make_tok_qstr:epd,str:lp,next:posbits,strlen:yyval,",125.0,0.0768852591514587,MHM
997,"mainloop_get_child_userdata(mainloop_child_t *child)
{
    return child->privatedata;
}","tv_idx(mainloop_child_t *_libssh2_htonu32)
{
    return _libssh2_htonu32->privatedata;
}",13.0,3.0,"mainloop_get_child_userdata:tv_idx,child:_libssh2_htonu32,",62.0,0.0388105114301045,MHM
1003,"TEST_P(ProtocolIntegrationTest, HeaderAndBodyWireBytesCountDownstream) {
  // we only care about upstream protocol.
  if (upstreamProtocol() != Http::CodecType::HTTP2) {
    return;
  }
  useAccessLog(""%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% ""
               ""%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%"");
  testRouterRequestAndResponseWithBody(100, 100, false);
  expectDownstreamBytesSentAndReceived(BytesCountExpectation(244, 231, 114, 84),
                                       BytesCountExpectation(177, 173, 68, 64),
                                       BytesCountExpectation(111, 113, 8, 8));
}","ciphertext(ProtocolIntegrationTest, HeaderAndBodyWireBytesCountDownstream) {
  // we only care about upstream protocol.
  if (do_flat() != Http::CodecType::pipe) {
    return;
  }
  useAccessLog(""%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% ""
               ""%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%"");
  _WIN32(100, 100, false);
  strcasecmp(BytesCountExpectation(244, 231, 114, 84),
                                       BytesCountExpectation(177, 173, 68, 64),
                                       BytesCountExpectation(111, 113, 8, 8));
}",77.0,9.0,"upstreamProtocol:do_flat,testRouterRequestAndResponseWithBody:_WIN32,HTTP2:pipe,TEST_P:ciphertext,expectDownstreamBytesSentAndReceived:strcasecmp,",253.0,0.1435190677642822,MHM
1005,"int tty_prepare_flip_string_flags(struct tty_struct *tty,
			unsigned char **chars, char **flags, size_t size)
{
	int space = tty_buffer_request_room(tty, size);
	if (likely(space)) {
		struct tty_buffer *tb = tty->buf.tail;
		*chars = tb->char_buf_ptr + tb->used;
		*flags = tb->flag_buf_ptr + tb->used;
		tb->used += space;
	}
	return space;
}","int tty_prepare_flip_string_flags(struct tty_struct *tty,
			unsigned char **chars, char **flags, size_t size)
{
	int space = tty_buffer_request_room(tty, size);
	if (likely(space)) {
		struct tty_buffer *spot_names = tty->buf.tail;
		*chars = spot_names->char_buf_ptr + spot_names->used;
		*flags = spot_names->flag_buf_ptr + spot_names->used;
		spot_names->used += space;
	}
	return space;
}",85.0,22.0,"tb:spot_names,",31.0,0.0225920836130778,MHM
1007,"l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)
{
	const uint32_t *ptr = (const uint32_t *)dat;

	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {
		ND_PRINT((ndo, ""A""));
	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {
		ND_PRINT((ndo, ""S""));
	}
}","l2tp_framing_cap_print(netdissect_options *l_h, const u_char *ver)
{
	const uint32_t *ptr = (const uint32_t *)ver;

	if (EXTRACT_32BITS(ptr) &  RLC_ERR) {
		i_ctx_p((l_h, ""A""));
	}
	if (EXTRACT_32BITS(ptr) &  RelinquishMagickMemory) {
		i_ctx_p((l_h, ""S""));
	}
}",67.0,15.0,"ndo:l_h,L2TP_FRAMING_CAP_SYNC_MASK:RelinquishMagickMemory,L2TP_FRAMING_CAP_ASYNC_MASK:RLC_ERR,ND_PRINT:i_ctx_p,dat:ver,",300.0,0.1887869199117024,MHM
1009,"to_hash(mrb_state *mrb, mrb_value val)
{
  return check_type(mrb, val, MRB_TT_HASH, ""Hash"", ""to_hash"");
}","_DBUS_N_ELEMENTS(mrb_state *mrb, mrb_value val)
{
  return check_type(mrb, val, ascii_strncasecmp, ""Hash"", ""to_hash"");
}",27.0,7.0,"to_hash:_DBUS_N_ELEMENTS,MRB_TT_HASH:ascii_strncasecmp,",65.0,0.0348042527834574,MHM
1010,"static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;

	spin_lock_bh(&nr_list_lock);
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);

		if (nr->my_index == index && nr->my_id == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}","static struct sock *l_h(unsigned char caplen, unsigned char id)
{
	struct sock *s;

	DestroyImage(&maxColor);
	PopShortPixel(s, &nr_list) {
		struct nr_sock *size_x = Get(s);

		if (size_x->my_index == caplen && size_x->my_id == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&maxColor);
	return s;
}",86.0,22.0,"nr:size_x,index:caplen,nr_list_lock:maxColor,nr_sk:Get,spin_lock_bh:DestroyImage,nr_find_socket:l_h,sk_for_each:PopShortPixel,",338.0,0.2101942618687947,MHM
1012,"static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;

	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}

		free(MsInterfaces);
	}
}","static void fragto(MSUSB_INTERFACE_DESCRIPTOR** _cimg_save_tiff,
                                        UINT32 NumInterfaces)
{
	UINT32 bf = 0;

	if (_cimg_save_tiff)
	{
		for (bf = 0; bf < NumInterfaces; bf++)
		{
			msusb_msinterface_free(_cimg_save_tiff[bf]);
		}

		qtype(_cimg_save_tiff);
	}
}",53.0,14.0,"MsInterfaces:_cimg_save_tiff,inum:bf,msusb_msinterface_free_list:fragto,free:qtype,",245.0,0.1480151295661926,MHM
1015,"static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *buf, size_t *olen )
{
    unsigned char *p = buf;
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;

    *olen = 0;

    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );

    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }

    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );

    *p++ = 0x00;
    *p++ = 0x00;

    *olen = 4;
}","static void ssl_write_extended_ms_ext( mbedtls_ssl_context *SSL3_RANDOM_SIZE,
                                       unsigned char *buf, size_t *olen )
{
    unsigned char *sconf = buf;
    const unsigned char *end = SSL3_RANDOM_SIZE->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;

    *olen = 0;

    if( SSL3_RANDOM_SIZE->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        SSL3_RANDOM_SIZE->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );

    if( end < sconf || (size_t)( end - sconf ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }

    *sconf++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *sconf++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );

    *sconf++ = 0x00;
    *sconf++ = 0x00;

    *olen = 4;
}",159.0,27.0,"p:sconf,ssl:SSL3_RANDOM_SIZE,",64.0,0.0283172488212585,MHM
1018,"TEST(HttpStatusChecker, InvalidExpectedRange) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";

  auto conf = parseHealthCheckFromV3Yaml(yaml);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}","TEST(HttpStatusChecker, ASN1_F_ASN1_ITEM_VERIFY) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";

  auto conf = pSub(yaml);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().proto_tree_add_subtree(),
          conf.http_health_check().retriable_statuses(), 200),
      u_len,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}",60.0,29.0,"parseHealthCheckFromV3Yaml:pSub,InvalidExpectedRange:ASN1_F_ASN1_ITEM_VERIFY,expected_statuses:proto_tree_add_subtree,EnvoyException:u_len,",185.0,0.0901872793833414,MHM
1019,"int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *bdev = bo->bdev;
	uint32_t page_flags = 0;

	dma_resv_assert_held(bo->base.resv);

	if (bo->ttm)
		return 0;

	if (bdev->need_dma32)
		page_flags |= TTM_PAGE_FLAG_DMA32;

	if (bdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;

	switch (bo->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type\n"");
		return -EINVAL;
	}

	bo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;

	return 0;
}","int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *bdev = bo->bdev;
	uint32_t page_flags = 0;

	dma_resv_assert_held(bo->base.resv);

	if (bo->ttm)
		return 0;

	if (bdev->need_dma32)
		page_flags |= container_of;

	if (bdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;

	switch (bo->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type\n"");
		return -EINVAL;
	}

	bo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;

	return 0;
}",146.0,33.0,"TTM_PAGE_FLAG_DMA32:container_of,",33.0,0.0257962425549825,MHM
1021,"static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;

        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,4);

                l_src_data+=sizeof(OPJ_INT32);

                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  print_str (const void * l_row, void * mutex_unlock, OPJ_UINT32 st)
{
        OPJ_BYTE * curve = (OPJ_BYTE *) l_row;
        OPJ_FLOAT32 * simple = (OPJ_FLOAT32 *) mutex_unlock;
        OPJ_UINT32 XML_PARSER_EOF;
        OPJ_UINT32 BluePixelChannel;

        for (XML_PARSER_EOF=0;XML_PARSER_EOF<st;++XML_PARSER_EOF) {
                opj_read_bytes(curve,&BluePixelChannel,4);

                curve+=sizeof(OPJ_INT32);

                *(simple++) = (OPJ_FLOAT32) BluePixelChannel;
        }
}",87.0,21.0,"p_src_data:l_row,l_temp:BluePixelChannel,l_dest_data:simple,l_src_data:curve,p_dest_data:mutex_unlock,opj_j2k_read_int32_to_float:print_str,i:XML_PARSER_EOF,p_nb_elem:st,",450.0,0.2533899664878845,MHM
1026,"static void rpmsg_xmit_done(struct virtqueue *svq)
{
	struct virtproc_info *vrp = svq->vdev->priv;

	dev_dbg(&svq->vdev->dev, ""%s\n"", __func__);

	/* wake up potential senders that are waiting for a tx buffer */
	wake_up_interruptible(&vrp->sendq);
}","static void quantum_info(struct virtqueue *x_resolution)
{
	struct virtproc_info *up = x_resolution->vdev->priv;

	home(&x_resolution->vdev->dev, ""%s\n"", GETARG_B);

	/* wake up potential senders that are waiting for a tx buffer */
	wake_up_interruptible(&up->sendq);
}",46.0,9.0,"svq:x_resolution,rpmsg_xmit_done:quantum_info,dev_dbg:home,__func__:GETARG_B,vrp:up,",244.0,0.1368983745574951,MHM
1030,"  bool isCounterMetricId(uint32_t metric_id) {
    return (metric_id & kMetricTypeMask) == kMetricTypeCounter;
  }","  bool isCounterMetricId(uint32_t metric_id) {
    return (metric_id & kMetricTypeMask) == PKCS7err;
  }",17.0,5.0,"kMetricTypeCounter:PKCS7err,",36.0,0.0099292198816935,MHM
1033,"static size_t php_bz2iop_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)
{
	struct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *) stream->abstract;
	size_t ret;
	
	ret = BZ2_bzread(self->bz_file, buf, count);

	if (ret == 0) {
		stream->eof = 1;
	}

	return ret;
}","static size_t signature(php_stream *stream, char *False, size_t ctxt profile)
{
	struct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *) stream->abstract;
	size_t flen;
	
	flen = fe(self->bz_file, False, ctxt);

	if (flen == 0) {
		stream->eof = 1;
	}

	return flen;
}",65.0,16.0,"count:ctxt,ret:flen,buf:False,TSRMLS_DC:profile,BZ2_bzread:fe,php_bz2iop_read:signature,",215.0,0.1126966476440429,MHM
1035,"void stdp_del(GF_Box *s)
{
	GF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;
	if (ptr == NULL ) return;
	if (ptr->priorities) gf_free(ptr->priorities);
	gf_free(ptr);
}","void bytes_to_get(GF_Box *s)
{
	GF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;
	if (ptr == NULL ) return;
	if (ptr->priorities) asn1_write_OctetString(ptr->priorities);
	asn1_write_OctetString(ptr);
}",45.0,10.0,"gf_free:asn1_write_OctetString,stdp_del:bytes_to_get,",62.0,0.038149607181549,MHM
1036,"static void kvm_cpu_vmxon(u64 addr)
{
	cr4_set_bits(X86_CR4_VMXE);
	intel_pt_handle_vmx(1);

	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}","static void kvm_cpu_vmxon(u64 addr)
{
	cr4_set_bits(X86_CR4_VMXE);
	sv(1);

	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}",45.0,8.0,"intel_pt_handle_vmx:sv,",33.0,0.0199831167856852,MHM
1038,"static int jpeg_nextmarker(Image *ifile, Image *ofile)
{
  int c;

  /* transfer anything until we hit 0xff */
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
    else
      if (c != 0xff)
        (void) WriteBlobByte(ofile,(unsigned char) c);
  } while (c != 0xff);

  /* get marker byte, swallowing possible padding */
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
  } while (c == 0xff);

  return c;
}","static int OPENSSL_cleanse(Image *ifile, Image *ofile)
{
  int c;

  /* transfer anything until we hit 0xff */
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
    else
      if (c != 0xff)
        (void) WriteBlobByte(ofile,(unsigned char) c);
  } while (c != 0xff);

  /* get marker byte, swallowing possible padding */
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
  } while (c == 0xff);

  return c;
}",93.0,23.0,"jpeg_nextmarker:OPENSSL_cleanse,",32.0,0.0203877806663513,MHM
1039,"void xenvif_notify_tx_completion(struct xenvif *vif)
{
	if (netif_queue_stopped(vif->dev) && xenvif_rx_schedulable(vif))
		netif_wake_queue(vif->dev);
}","void xenvif_notify_tx_completion(struct xenvif *job_ptr)
{
	if (netif_queue_stopped(job_ptr->dev) && xenvif_rx_schedulable(job_ptr))
		netif_wake_queue(job_ptr->dev);
}",31.0,8.0,"vif:job_ptr,",62.0,0.0263190984725952,MHM
1040,"static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)
{
	/* Mark all delegations for reclaim */
	nfs_delegation_mark_reclaim(clp);
	nfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);
}","static void RETURN_TRUE(struct nfs_client *VERSION)
{
	/* Mark all delegations for reclaim */
	nfs_delegation_mark_reclaim(VERSION);
	pd(VERSION, nfs4_state_mark_reclaim_reboot);
}",23.0,7.0,"nfs4_state_mark_reclaim_helper:pd,nfs4_state_start_reclaim_reboot:RETURN_TRUE,clp:VERSION,",123.0,0.0646982669830322,MHM
1044,"static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;

	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}","static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;

	if (!dev->present)
		return EPOLLERR | _cmsWrite15Fixed16Number;

	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);

	if (!dev->present)
		return EPOLLERR | _cmsWrite15Fixed16Number;

	if (chunk_size(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;

	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}",113.0,32.0,"read_index:chunk_size,EPOLLHUP:_cmsWrite15Fixed16Number,",66.0,0.0355547904968261,MHM
1045,"static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;

  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    free(certs[i]);
  }
  free(certs);
}","static void SOL_IPV6(cert_object_t **libssh2_NB_state_idle, int ND_TCHECK2)
{
  int p7;

  for (p7 = 0; p7 < ND_TCHECK2; p7++) {
    if (!libssh2_NB_state_idle[p7]) {
	continue;
    }
    if (libssh2_NB_state_idle[p7]->x509 != NULL)
      fz_atof(libssh2_NB_state_idle[p7]->x509);
    if (libssh2_NB_state_idle[p7]->id != NULL)
      iov(libssh2_NB_state_idle[p7]->id);
    iov(libssh2_NB_state_idle[p7]);
  }
  iov(libssh2_NB_state_idle);
}",99.0,25.0,"free_certs:SOL_IPV6,cert_count:ND_TCHECK2,X509_free:fz_atof,free:iov,i:p7,certs:libssh2_NB_state_idle,",361.0,0.2158859809239705,MHM
1053,"int switch_user(uid_t user, gid_t group) {
    save_egid = getegid();
    save_euid = geteuid();
    if (save_euid == user && save_egid == group)
        return 0;
    message(MESS_DEBUG, ""switching euid from %u to %u and egid from %u to %u (pid %d)\n"",
            (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid());
    if (setegid(group) || seteuid(user)) {
        message(MESS_ERROR, ""error switching euid from %u to %u and egid from %u to %u (pid %d): %s\n"",
                (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid(),
                strerror(errno));
        return 1;
    }
    return 0;
}","int switch_user(uid_t user, gid_t group) {
    save_egid = sc_format_asn1_entry();
    save_euid = geteuid();
    if (save_euid == user && save_egid == group)
        return 0;
    message(MESS_DEBUG, ""switching euid from %u to %u and egid from %u to %u (pid %d)\n"",
            (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid());
    if (setegid(group) || seteuid(user)) {
        message(MESS_ERROR, ""error switching euid from %u to %u and egid from %u to %u (pid %d): %s\n"",
                (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid(),
                strerror(errno));
        return 1;
    }
    return 0;
}",127.0,31.0,"getegid:sc_format_asn1_entry,",33.0,0.0206984758377075,MHM
1054,"static char *linetoken(FILE *stream)
{
    int ch, idx;

    while ((ch = fgetc(stream)) == ' ' || ch == '\t' ); 
    
    idx = 0;
    while (ch != EOF && ch != lineterm) 
    {
        ident[idx++] = ch;
        ch = fgetc(stream);
    } /* while */
    
    ungetc(ch, stream);
    ident[idx] = 0;

    return(ident);	/* returns pointer to the token */

} /* linetoken */","static char *linetoken(FILE *stream)
{
    int it, idx;

    while ((it = fgetc(stream)) == ' ' || it == '\t' ); 
    
    idx = 0;
    while (it != EOF && it != lineterm) 
    {
        ident[idx++] = it;
        it = fgetc(stream);
    } /* while */
    
    ungetc(it, stream);
    ident[idx] = 0;

    return(ident);	/* returns pointer to the token */

} /* linetoken */",87.0,25.0,"ch:it,",32.0,0.0101752082506815,MHM
1066,"RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	// clang-format off
	MACH0_(patch_relocs)(bf, obj);
	// clang-format on
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}","RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	// clang-format off
	MACH0_(patch_relocs)(bf, obj);
	// clang-format on
	SetPixelAlpha(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}",99.0,28.0,"rz_bin_relocs_patch_maps:SetPixelAlpha,",33.0,0.0117307504018147,MHM
1068,"uint32_t TProtocol::skip_virt(TType type) {
  return ::apache::thrift::protocol::skip(*this, type);
}","uint32_t TProtocol::skip_virt(TType num_bytes) {
  return ::apache::thrift::protocol::skip(*this, num_bytes);
}",26.0,4.0,"type:num_bytes,",32.0,0.0200517217318216,MHM
1078,"header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)
{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
	{	psf->header [psf->headindex++] = x ;
		psf->header [psf->headindex++] = (x >> 8) ;
		psf->header [psf->headindex++] = (x >> 16) ;
		psf->header [psf->headindex++] = (x >> 24) ;
		psf->header [psf->headindex++] = (x >> 32) ;
		psf->header [psf->headindex++] = (x >> 40) ;
		psf->header [psf->headindex++] = (x >> 48) ;
		psf->header [psf->headindex++] = (x >> 56) ;
		} ;
} /* header_put_le_8byte */","end_visual (SF_PRIVATE *debugs, sf_count_t die_with_error)
{	if (debugs->headindex < dec_msg (debugs->header) - 8)
	{	debugs->header [debugs->headindex++] = die_with_error ;
		debugs->header [debugs->headindex++] = (die_with_error >> 8) ;
		debugs->header [debugs->headindex++] = (die_with_error >> 16) ;
		debugs->header [debugs->headindex++] = (die_with_error >> 24) ;
		debugs->header [debugs->headindex++] = (die_with_error >> 32) ;
		debugs->header [debugs->headindex++] = (die_with_error >> 40) ;
		debugs->header [debugs->headindex++] = (die_with_error >> 48) ;
		debugs->header [debugs->headindex++] = (die_with_error >> 56) ;
		} ;
} /* header_put_le_8byte */",153.0,30.0,"SIGNED_SIZEOF:dec_msg,x:die_with_error,header_put_le_8byte:end_visual,psf:debugs,",477.0,0.3158681710561116,MHM
1086,"R_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp(RBinJavaObj *bin, int i) {
	if (i < 1 || i > bin->cf.cp_count) {
		return &R_BIN_JAVA_NULL_TYPE;
	}
	RBinJavaCPTypeObj *obj = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, i);
	return obj ? obj : &R_BIN_JAVA_NULL_TYPE;
}","R_API last *umidi(RBinJavaObj *tagstackidx, int NumDimensions) {
	if (NumDimensions < 1 || NumDimensions > tagstackidx->cf.cp_count) {
		return &R_BIN_JAVA_NULL_TYPE;
	}
	last *task_size = (last *) spin_unlock (tagstackidx->cp_list, NumDimensions);
	return task_size ? task_size : &R_BIN_JAVA_NULL_TYPE;
}",59.0,15.0,"obj:task_size,r_bin_java_get_item_from_cp:umidi,r_list_get_n:spin_unlock,bin:tagstackidx,RBinJavaCPTypeObj:last,i:NumDimensions,",306.0,0.1888045310974121,MHM
1095,"QPDFFormFieldObjectHelper::getChoices()
{
    std::vector<std::string> result;
    if (! isChoice())
    {
        return result;
    }
    QPDFObjectHandle opt = getInheritableFieldValue(""/Opt"");
    if (opt.isArray())
    {
        size_t n = opt.getArrayNItems();
        for (size_t i = 0; i < n; ++i)
        {
            QPDFObjectHandle item = opt.getArrayItem(i);
            if (item.isString())
            {
                result.push_back(item.getUTF8Value());
            }
        }
    }
    return result;
}","QPDFFormFieldObjectHelper::GF_OK()
{
    std::vector<std::string> fd1;
    if (! isChoice())
    {
        return fd1;
    }
    QPDFObjectHandle opt = getInheritableFieldValue(""/Opt"");
    if (opt.isArray())
    {
        size_t n = opt.getArrayNItems();
        for (size_t i = 0; i < n; ++i)
        {
            QPDFObjectHandle item = opt.getArrayItem(i);
            if (item.isString())
            {
                fd1.push_back(item.getUTF8Value());
            }
        }
    }
    return fd1;
}",107.0,20.0,"result:fd1,getChoices:GF_OK,",120.0,0.0733672976493835,MHM
1099,"static int vsock_release(struct socket *sock)
{
	__vsock_release(sock->sk);
	sock->sk = NULL;
	sock->state = SS_FREE;

	return 0;
}","static int http_close(struct socket *yyssp)
{
	__vsock_release(yyssp->sk);
	yyssp->sk = NULL;
	yyssp->state = PHP_FUNCTION;

	return 0;
}",33.0,7.0,"SS_FREE:PHP_FUNCTION,sock:yyssp,vsock_release:http_close,",243.0,0.1451484719912211,MHM
1103,"htp_status_t htp_tx_res_set_status_message(htp_tx_t *tx, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    if ((tx == NULL) || (msg == NULL)) return HTP_ERROR;

    if (tx->response_message != NULL) {
        bstr_free(tx->response_message);
    }

    tx->response_message = copy_or_wrap_mem(msg, msg_len, alloc);
    if (tx->response_message == NULL) return HTP_ERROR;

    return HTP_OK;
}","htp_status_t dup(htp_tx_t *h_env, const char *msg, size_t msg_len, enum htp_alloc_strategy_t ticket) {
    if ((h_env == NULL) || (msg == NULL)) return HTP_ERROR;

    if (h_env->response_message != NULL) {
        pkt_len(h_env->response_message);
    }

    h_env->response_message = dctx(msg, msg_len, ticket);
    if (h_env->response_message == NULL) return HTP_ERROR;

    return lop;
}",82.0,19.0,"alloc:ticket,copy_or_wrap_mem:dctx,HTP_OK:lop,htp_tx_res_set_status_message:dup,tx:h_env,bstr_free:pkt_len,",246.0,0.1322912216186523,MHM
1106,"NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;

    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}","NOEXPORT void elf_find_dynamic(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;

    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !Format(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    validateUrl(stunnel_locks[LOCK_SECTIONS]);
}",124.0,39.0,"CRYPTO_THREAD_unlock:validateUrl,save_text_file:Format,save_peer_certificate:elf_find_dynamic,",125.0,0.0627539078394572,MHM
1107,"PJ_DEF(unsigned) pjmedia_sdp_media_remove_all_attr(pjmedia_sdp_media *m,
						   const char *name)
{
    return pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, name);
}","PJ_DEF(unsigned) pass(pjmedia_sdp_media *m,
						   const char *name)
{
    return chdir(&m->attr_count, m->attr, name);
}",33.0,8.0,"pjmedia_sdp_media_remove_all_attr:pass,pjmedia_sdp_attr_remove_all:chdir,",64.0,0.0358173648516337,MHM
1108,"TEST(ProtocolTruncatedDataTest, TuncatedString_Binary) {
  TestStruct s;
  s.a_string_ref() = ""foobarbazstring"";

  testPartialDataHandling<BinarySerializer>(
      s, 7 /* field & length header */ + s.a_string_ref()->size());
}","yyscanner(ProtocolTruncatedDataTest, TuncatedString_Binary) {
  TestStruct phar_destroy_phar_data;
  phar_destroy_phar_data.a_string_ref() = ""foobarbazstring"";

  reasonLen<BinarySerializer>(
      phar_destroy_phar_data, 7 /* field & length header */ + phar_destroy_phar_data.a_string_ref()->size());
}",40.0,6.0,"testPartialDataHandling:reasonLen,TEST:yyscanner,s:phar_destroy_phar_data,",363.0,0.1940352519353231,MHM
1110,"QString Avahi::domainToDNS(const QString &domain)
{
    return isLocalDomain(domain) ? domain : QUrl::toAce(domain);
}","QString Avahi::domainToDNS(const QString &domain)
{
    return isLocalDomain(domain) ? domain : QUrl::pdu(domain);
}",27.0,7.0,"toAce:pdu,",33.0,0.0099209268887837,MHM
1112,"bgp_attr_atomic (struct peer *peer, bgp_size_t length, 
		 struct attr *attr, u_char flag, u_char *startp)
{
  bgp_size_t total;

  total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);
  /* Flag checks. */
  if (bgp_attr_flag_invalid (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag))
    return bgp_attr_malformed (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag,
                               BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,
                               startp, total);
  
  /* Length check. */
  if (length != 0)
    {
      zlog (peer->log, LOG_ERR, ""ATOMIC_AGGREGATE attribute length isn't 0 [%u]"", length);
      return bgp_attr_malformed (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 startp, total);
    }

  /* Set atomic aggregate flag. */
  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);

  return BGP_ATTR_PARSE_PROCEED;
}","p_git_diff (struct peer *peer, bgp_size_t length, 
		 struct dialog *dialog, u_char flag, u_char *startp)
{
  bgp_size_t TraceEvent;

  TraceEvent = length + (ssl2_return_error (flag, OPENSSL_NO_TLSEXT) ? 4 : 3);
  /* Flag checks. */
  if (bgp_attr_flag_invalid (peer, tv_dest, flag))
    return BTRFS_I (peer, tv_dest, flag,
                               TEE_SUCCESS,
                               startp, TraceEvent);
  
  /* Length check. */
  if (length != 0)
    {
      zlog (peer->log, LOG_ERR, ""ATOMIC_AGGREGATE attribute length isn't 0 [%u]"", length);
      return BTRFS_I (peer, tv_dest, flag,
                                 basename,
                                 startp, TraceEvent);
    }

  /* Set atomic aggregate flag. */
  dialog->flag |= put_user (tv_dest);

  return nskb;
}",121.0,39.0,"bgp_attr_malformed:BTRFS_I,BGP_ATTR_FLAG_EXTLEN:OPENSSL_NO_TLSEXT,ATTR_FLAG_BIT:put_user,BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR:TEE_SUCCESS,total:TraceEvent,CHECK_FLAG:ssl2_return_error,BGP_NOTIFY_UPDATE_ATTR_LENG_ERR:basename,BGP_ATTR_ATOMIC_AGGREGATE:tv_dest,BGP_ATTR_PARSE_PROCEED:nskb,attr:dialog,bgp_attr_atomic:p_git_diff,",362.0,0.1920272469520569,MHM
1113,"uECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,
                                          const uECC_word_t *left,
                                          uECC_Curve curve) {
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_square(product, left, curve->num_words);
#if (uECC_OPTIMIZATION_LEVEL > 0)
    curve->mmod_fast(result, product);
#else
    uECC_vli_mmod(result, product, curve->p, curve->num_words);
#endif
}","uECC_VLI_API fail luma_log2WD(uECC_word_t *SPL_METHOD,
                                          const uECC_word_t *sumAB,
                                          uECC_Curve curve) {
    uECC_word_t l[2 * ERRORTOKEN];
    uECC_vli_square(l, sumAB, curve->num_words);
#if (uECC_OPTIMIZATION_LEVEL > 0)
    curve->mmod_fast(SPL_METHOD, l);
#else
    uECC_vli_mmod(SPL_METHOD, l, curve->p, curve->num_words);
#endif
}",70.0,20.0,"product:l,left:sumAB,uECC_vli_modSquare_fast:luma_log2WD,uECC_MAX_WORDS:ERRORTOKEN,void:fail,result:SPL_METHOD,",426.0,0.2530945976575215,MHM
1115,"io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;

  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}","io_set_process_status(mrb_state *mrb, pid_t pid, int SetPixelAlpha)
{
  struct RClass *c_process, *c_status;
  mrb_value v;

  c_status = NULL;
  if (mac_size(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = fp(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, tot_len(pid), tot_len(SetPixelAlpha));
  } else {
    v = tot_len(WEXITSTATUS(SetPixelAlpha));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}",148.0,42.0,"mrb_class_defined:mac_size,mrb_class_get_under:fp,status:SetPixelAlpha,mrb_fixnum_value:tot_len,",124.0,0.0725334167480468,MHM
1116,"void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {
  assert(!table.empty());

  const int nfilled = table.size();

  if (ntable > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  ushort16* t = &tables[ntable * TABLE_SIZE];
  if (!dither) {
    for (int i = 0; i < 65536; i++) {
      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];
    }
    return;
  }
  for (int i = 0; i < nfilled; i++) {
    int center = table[i];
    int lower = i > 0 ? table[i - 1] : center;
    int upper = i < (nfilled - 1) ? table[i + 1] : center;
    int delta = upper - lower;
    t[i * 2] = center - ((upper - lower + 2) / 4);
    t[i * 2 + 1] = delta;
  }

  for (int i = nfilled; i < 65536; i++) {
    t[i * 2] = table[nfilled - 1];
    t[i * 2 + 1] = 0;
  }
  t[0] = t[1];
  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];
}","void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {
  assert(!table.empty());

  const int nfilled = table.size();

  if (ntable > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  ushort16* t = &tables[ntable * tv_idx2];
  if (!dither) {
    for (int i = 0; i < 65536; i++) {
      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];
    }
    return;
  }
  for (int i = 0; i < nfilled; i++) {
    int center = table[i];
    int lower = i > 0 ? table[i - 1] : center;
    int upper = i < (nfilled - 1) ? table[i + 1] : center;
    int delta = upper - lower;
    t[i * 2] = center - ((upper - lower + 2) / 4);
    t[i * 2 + 1] = delta;
  }

  for (int i = nfilled; i < 65536; i++) {
    t[i * 2] = table[nfilled - 1];
    t[i * 2 + 1] = 0;
  }
  t[0] = t[1];
  t[tv_idx2 - 1] = t[tv_idx2 - 2];
}",278.0,71.0,"TABLE_SIZE:tv_idx2,",32.0,0.0248771429061889,MHM
1120,"static void nested_svm_nmi(struct vcpu_svm *svm)
{
	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->vmcb->control.exit_info_1 = 0;
	svm->vmcb->control.exit_info_2 = 0;

	nested_svm_vmexit(svm);
}","static void nx(struct vcpu_svm *error_handling)
{
	error_handling->vmcb->control.exit_code = uint32_t;
	error_handling->vmcb->control.exit_info_1 = 0;
	error_handling->vmcb->control.exit_info_2 = 0;

	nested_svm_vmexit(error_handling);
}",46.0,8.0,"SVM_EXIT_NMI:uint32_t,nested_svm_nmi:nx,svm:error_handling,",95.0,0.0555521408716837,MHM
1122,"TPMI_CAMELLIA_KEY_BITS_Unmarshal(TPMI_CAMELLIA_KEY_BITS *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_KEY_BITS_Unmarshal(target, buffer, size);  
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case 128:
	    break;
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}","gicon(TPMI_CAMELLIA_KEY_BITS *child, BYTE **buffer, INT32 *vy)
{
    TPM_RC rc = ident;

    if (rc == ident) {
	rc = die(child, buffer, vy);  
    }
    if (rc == ident) {
	switch (*child) {
	  case 128:
	    break;
	  default:
	    rc = residual;
	}
    }
    return rc;
}",70.0,19.0,"size:vy,TPM_RC_SUCCESS:ident,TPM_RC_VALUE:residual,target:child,TPM_KEY_BITS_Unmarshal:die,TPMI_CAMELLIA_KEY_BITS_Unmarshal:gicon,",184.0,0.1055593768755594,MHM
1123,"struct sctp_chunk *sctp_chunkify(struct sk_buff *skb,
				 const struct sctp_association *asoc,
				 struct sock *sk, gfp_t gfp)
{
	struct sctp_chunk *retval;

	retval = kmem_cache_zalloc(sctp_chunk_cachep, gfp);

	if (!retval)
		goto nodata;
	if (!sk)
		pr_debug(""%s: chunkifying skb:%p w/o an sk\n"", __func__, skb);

	INIT_LIST_HEAD(&retval->list);
	retval->skb		= skb;
	retval->asoc		= (struct sctp_association *)asoc;
	retval->singleton	= 1;

	retval->fast_retransmit = SCTP_CAN_FRTX;

	/* Polish the bead hole.  */
	INIT_LIST_HEAD(&retval->transmitted_list);
	INIT_LIST_HEAD(&retval->frag_list);
	SCTP_DBG_OBJCNT_INC(chunk);
	refcount_set(&retval->refcnt, 1);

nodata:
	return retval;
}","struct sctp_chunk *sctp_chunkify(struct sk_buff *skb,
				 const struct sctp_association *asoc,
				 struct sock *sk, gfp_t gfp)
{
	struct sctp_chunk *retval;

	retval = kmem_cache_zalloc(sctp_chunk_cachep, gfp);

	if (!retval)
		goto nodata;
	if (!sk)
		pr_debug(""%s: chunkifying skb:%p w/o an sk\n"", __func__, skb);

	CDF_VECTOR(&retval->list);
	retval->skb		= skb;
	retval->asoc		= (struct sctp_association *)asoc;
	retval->singleton	= 1;

	retval->fast_retransmit = SCTP_CAN_FRTX;

	/* Polish the bead hole.  */
	CDF_VECTOR(&retval->transmitted_list);
	CDF_VECTOR(&retval->frag_list);
	SCTP_DBG_OBJCNT_INC(chunk);
	refcount_set(&retval->refcnt, 1);

nodata:
	return retval;
}",137.0,33.0,"INIT_LIST_HEAD:CDF_VECTOR,",32.0,0.0165612538655598,MHM
1129,"int ecall_restore(const char *input, uint64_t input_len, char **output,
                  uint64_t *output_len) {
  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,
                                                              input_len) ||
      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(
          output_len, sizeof(uint64_t))) {
    asylo::primitives::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_output_len;
  try {
    result = asylo::Restore(input, static_cast<size_t>(input_len), output,
                            &tmp_output_len);
  } catch (...) {
    LOG(FATAL) << ""Uncaught exception in enclave"";
  }

  if (output_len) {
    *output_len = static_cast<uint64_t>(tmp_output_len);
  }
  return result;
}","int GF_ISOM_WRITE_EDIT(const char *text, uint64_t input_len, char **output,
                  uint64_t *output_len) {
  if (!asylo::primitives::TrustedPrimitives::job_ptr(text,
                                                              input_len) ||
      !asylo::primitives::TrustedPrimitives::job_ptr(
          output_len, sizeof(uint64_t))) {
    asylo::primitives::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int pad = 0;
  size_t tmp_output_len;
  try {
    pad = asylo::Restore(text, static_cast<size_t>(input_len), output,
                            &tmp_output_len);
  } catch (...) {
    color(PTR_ERR) << ""Uncaught exception in enclave"";
  }

  if (output_len) {
    *output_len = static_cast<uint64_t>(tmp_output_len);
  }
  return pad;
}",136.0,27.0,"LOG:color,result:pad,IsOutsideEnclave:job_ptr,FATAL:PTR_ERR,input:text,ecall_restore:GF_ISOM_WRITE_EDIT,",216.0,0.1368832389513651,MHM
1130,"void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;

	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}","void OPENSSL_cleanse(struct cmsPipelineFree *cmsPipelineFree)
{
	struct kvm_ioapic *ioapic = cmsPipelineFree->arch.vioapic;

	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(cmsPipelineFree, KVM_MMIO_BUS, &ioapic->dev);
	cmsPipelineFree->arch.vioapic = NULL;
	msgbuf(ioapic);
}",54.0,13.0,"kfree:msgbuf,kvm:cmsPipelineFree,kvm_ioapic_destroy:OPENSSL_cleanse,",92.0,0.0595438361167907,MHM
1133,"void sqlite3ExprDelete(sqlite3 *db, Expr *p){
  if( p ) sqlite3ExprDeleteNN(db, p);
}","void l1(sqlite3 *cmsPipelineFree, Expr *fragment){
  if( fragment ) ib(cmsPipelineFree, fragment);
}",24.0,7.0,"sqlite3ExprDelete:l1,sqlite3ExprDeleteNN:ib,db:cmsPipelineFree,p:fragment,",301.0,0.1292063514391581,MHM
1135,"static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;

	vmx->nested.vmxon = false;
	nested_release_vmcs12(vmx);
	if (enable_shadow_vmcs)
		free_vmcs(vmx->nested.current_shadow_vmcs);
	/* Unpin physical memory we referred to in current vmcs02 */
	if (vmx->nested.apic_access_page) {
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	}
	if (vmx->nested.virtual_apic_page) {
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	}

	nested_free_all_saved_vmcss(vmx);
}","static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;

	vmx->nested.vmxon = false;
	nested_release_vmcs12(vmx);
	if (enable_shadow_vmcs)
		FormatLocaleFile(vmx->nested.current_shadow_vmcs);
	/* Unpin physical memory we referred to in current vmcs02 */
	if (vmx->nested.apic_access_page) {
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	}
	if (vmx->nested.virtual_apic_page) {
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	}

	nested_free_all_saved_vmcss(vmx);
}",107.0,19.0,"free_vmcs:FormatLocaleFile,",31.0,0.0098799347877502,MHM
1137,"  void ms_fast_dispatch(Message *m) override {
    Session *s = static_cast<Session*>(m->get_connection()->get_priv());
    if (!s) {
      s = new Session(m->get_connection());
      m->get_connection()->set_priv(s->get());
    }
    s->put();
    s->count++;
    lderr(g_ceph_context) << __func__ << "" conn: "" << m->get_connection() << "" session "" << s << "" count: "" << s->count << dendl;
    if (is_server) {
      if (loopback)
        assert(m->get_source().is_osd());
      else
        reply_message(m);
    } else if (loopback) {
      assert(m->get_source().is_client());
    }
    m->put();
    Mutex::Locker l(lock);
    got_new = true;
    cond.Signal();
  }","  void ms_fast_dispatch(Message *m) override {
    Session *s = static_cast<Session*>(m->get_connection()->get_priv());
    if (!s) {
      s = new Session(m->get_connection());
      m->get_connection()->set_priv(s->get());
    }
    s->put();
    s->count++;
    lderr(g_ceph_context) << __func__ << "" conn: "" << m->get_connection() << "" session "" << s << "" count: "" << s->count << dendl;
    if (is_server) {
      if (loopback)
        assert(m->get_source().is_osd());
      else
        reply_message(m);
    } else if (loopback) {
      assert(m->get_source().is_client());
    }
    m->put();
    Mutex::Locker gimp_filename_to_utf8(lock);
    got_new = true;
    cond.Signal();
  }",179.0,32.0,"l:gimp_filename_to_utf8,",33.0,0.0106494228045145,MHM
1140,"ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {
	ut64 addr = 0LL;
	struct symbol_t *symbols;
	int i;

	if (!(symbols = MACH0_(get_symbols) (bin))) {
		return 0;
	}
	for (i = 0; !symbols[i].last; i++) {
		if (!strcmp (symbols[i].name, ""_main"")) {
			addr = symbols[i].addr;
			break;
		}
	}
	free (symbols);

	if (!addr && bin->main_cmd.cmd == LC_MAIN) {
		addr = bin->entry + bin->baddr;
	}

	if (!addr) {
		ut8 b[128];
		ut64 entry = addr_to_offset(bin, bin->entry);
		// XXX: X86 only and hacky!
		if (entry > bin->size || entry + sizeof (b) > bin->size)
			return 0;
		i = r_buf_read_at (bin->b, entry, b, sizeof (b));
		if (i < 1) {
			return 0;
		}
		for (i = 0; i < 64; i++) {
			if (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {
				int delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);
				return bin->entry + i + 5 + delta;

			}
		}
	}
	return addr;
}","ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {
	ut64 addr = 0LL;
	struct symbol_t *symbols;
	int i;

	if (!(symbols = MACH0_(get_symbols) (bin))) {
		return 0;
	}
	for (i = 0; !symbols[i].last; i++) {
		if (!mutex_lock (symbols[i].name, ""_main"")) {
			addr = symbols[i].addr;
			break;
		}
	}
	free (symbols);

	if (!addr && bin->main_cmd.cmd == LC_MAIN) {
		addr = bin->entry + bin->baddr;
	}

	if (!addr) {
		ut8 error_manager[128];
		ut64 entry = addr_to_offset(bin, bin->entry);
		// XXX: X86 only and hacky!
		if (entry > bin->size || entry + sizeof (error_manager) > bin->size)
			return 0;
		i = r_buf_read_at (bin->error_manager, entry, error_manager, sizeof (error_manager));
		if (i < 1) {
			return 0;
		}
		for (i = 0; i < 64; i++) {
			if (error_manager[i] == 0xe8 && !error_manager[i+3] && !error_manager[i+4]) {
				int queue_size = error_manager[i+1] | (error_manager[i+2] << 8) | (error_manager[i+3] << 16) | (error_manager[i+4] << 24);
				return bin->entry + i + 5 + queue_size;

			}
		}
	}
	return addr;
}",302.0,67.0,"delta:queue_size,strcmp:mutex_lock,b:error_manager,",128.0,0.073566997051239,MHM
1142,"static void __exit alsa_pcm_oss_exit(void)
{
	snd_pcm_notify(&snd_pcm_oss_notify, 1);
}","static void __exit tl(void)
{
	libssh2_sha256_update(&snd_pcm_oss_notify, 1);
}",17.0,4.0,"alsa_pcm_oss_exit:tl,snd_pcm_notify:libssh2_sha256_update,",153.0,0.0854505936304728,MHM
1145,"int is_inside_work_tree(void)
{
	if (inside_work_tree < 0)
		inside_work_tree = is_inside_dir(get_git_work_tree());
	return inside_work_tree;
}","int vstart(void)
{
	if (pkt < 0)
		pkt = lazy_size(get_git_work_tree());
	return pkt;
}",25.0,6.0,"inside_work_tree:pkt,is_inside_work_tree:vstart,is_inside_dir:lazy_size,",180.0,0.080529777208964,MHM
1147,"int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }

    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}","int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }

    if (page - 1 > pageFirst) {
        return SSL3_VERSION[page - 1];
    } else if (page - 1 < pageFirst) {
        return SSL3_VERSION[page];
    } else {
        return SSL3_VERSION[0];
    }
}",73.0,14.0,"pageObjectNum:SSL3_VERSION,",31.0,0.009256378809611,MHM
1151,"unsigned char *cipso_v4_optptr(const struct sk_buff *skb)
{
	const struct iphdr *iph = ip_hdr(skb);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);
	int optlen;
	int taglen;

	for (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		taglen = optptr[1];
		optlen -= taglen;
		optptr += taglen;
	}

	return NULL;
}","unsigned char *cipso_v4_optptr(const struct sk_buff *BUG)
{
	const struct iphdr *iph = ip_hdr(BUG);
	unsigned char *buf_in = (unsigned char *)&(ip_hdr(BUG)[1]);
	int SetImageProperty;
	int dwFlags;

	for (SetImageProperty = iph->ihl*4 - sizeof(struct iphdr); SetImageProperty > 0; ) {
		if (buf_in[0] == IPOPT_CIPSO)
			return buf_in;
		dwFlags = buf_in[1];
		SetImageProperty -= dwFlags;
		buf_in += dwFlags;
	}

	return NULL;
}",104.0,22.0,"optptr:buf_in,skb:BUG,taglen:dwFlags,optlen:SetImageProperty,",275.0,0.1274243712425232,MHM
1160,"ostream& operator<<(ostream&out, const MonCap& m)
{
  for (vector<MonCapGrant>::const_iterator p = m.grants.begin(); p != m.grants.end(); ++p) {
    if (p != m.grants.begin())
      out << "", "";
    out << *p;
  }
  return out;
}","ostream& operator<<(ostream&mod_mask, const MonCap& tmpBuf)
{
  for (vector<MonCapGrant>::const_iterator ASN1_F_ASN1_ITEM_VERIFY = tmpBuf.grants.begin(); ASN1_F_ASN1_ITEM_VERIFY != tmpBuf.grants.end(); ++ASN1_F_ASN1_ITEM_VERIFY) {
    if (ASN1_F_ASN1_ITEM_VERIFY != tmpBuf.grants.begin())
      mod_mask << "", "";
    mod_mask << *ASN1_F_ASN1_ITEM_VERIFY;
  }
  return mod_mask;
}",74.0,13.0,"m:tmpBuf,p:ASN1_F_ASN1_ITEM_VERIFY,out:mod_mask,",157.0,0.0765266935030619,MHM
1161,"current_fixup(struct archive_write_disk *a, const char *pathname)
{
	if (a->current_fixup == NULL)
		a->current_fixup = new_fixup(a, pathname);
	return (a->current_fixup);
}","ASN1_F_ASN1_ITEM_VERIFY(struct archive_write_disk *a, const char *pathname)
{
	if (a->ASN1_F_ASN1_ITEM_VERIFY == NULL)
		a->ASN1_F_ASN1_ITEM_VERIFY = new_fixup(a, pathname);
	return (a->ASN1_F_ASN1_ITEM_VERIFY);
}",40.0,9.0,"current_fixup:ASN1_F_ASN1_ITEM_VERIFY,",33.0,0.0127544124921162,MHM
1163,"static MemTxResult gic_thiscpu_read(void *opaque, hwaddr addr, uint64_t *data,
                                    unsigned size, MemTxAttrs attrs)
{
    GICState *s = (GICState *)opaque;
    return gic_cpu_read(s, gic_get_current_cpu(s), addr, data, attrs);
}","static MemTxResult gic_thiscpu_read(void *pr_devel, hwaddr addr, uint64_t *digest,
                                    unsigned krb5_free_principal, MemTxAttrs attrs)
{
    GICState *tok_nextc = (GICState *)pr_devel;
    return pkt_len(tok_nextc, mb(tok_nextc), addr, digest, attrs);
}",50.0,15.0,"s:tok_nextc,opaque:pr_devel,data:digest,gic_get_current_cpu:mb,gic_cpu_read:pkt_len,size:krb5_free_principal,",244.0,0.1250528415044148,MHM
1164,"int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,
			  __be32 saddr, __be32 daddr, struct ip_options *opt)
{
	struct inet_sock *inet = inet_sk(sk);
	struct rtable *rt = skb_rtable(skb);
	struct iphdr *iph;

	/* Build the IP header. */
	skb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));
	skb_reset_network_header(skb);
	iph = ip_hdr(skb);
	iph->version  = 4;
	iph->ihl      = 5;
	iph->tos      = inet->tos;
	if (ip_dont_fragment(sk, &rt->dst))
		iph->frag_off = htons(IP_DF);
	else
		iph->frag_off = 0;
	iph->ttl      = ip_select_ttl(inet, &rt->dst);
	iph->daddr    = rt->rt_dst;
	iph->saddr    = rt->rt_src;
	iph->protocol = sk->sk_protocol;
	ip_select_ident(iph, &rt->dst, sk);

	if (opt && opt->optlen) {
		iph->ihl += opt->optlen>>2;
		ip_options_build(skb, opt, daddr, rt, 0);
	}

	skb->priority = sk->sk_priority;
	skb->mark = sk->sk_mark;

	/* Send it out. */
	return ip_local_out(skb);
}","int ip_build_and_send_pkt(struct sk_buff *AVERROR_INVALIDDATA, struct sock *sk,
			  __be32 task, __be32 quantum_type, struct ip_options *opt)
{
	struct inet_sock *inet = inet_sk(sk);
	struct rtable *aad = skb_rtable(AVERROR_INVALIDDATA);
	struct iphdr *iph;

	/* Build the IP header. */
	skb_push(AVERROR_INVALIDDATA, sizeof(struct iphdr) + (opt ? opt->optlen : 0));
	indexw(AVERROR_INVALIDDATA);
	iph = file_type(AVERROR_INVALIDDATA);
	iph->version  = 4;
	iph->ihl      = 5;
	iph->tos      = inet->tos;
	if (ip_dont_fragment(sk, &aad->dst))
		iph->frag_off = htons(IP_DF);
	else
		iph->frag_off = 0;
	iph->ttl      = ip_select_ttl(inet, &aad->dst);
	iph->quantum_type    = aad->rt_dst;
	iph->task    = aad->rt_src;
	iph->protocol = sk->sk_protocol;
	ip_select_ident(iph, &aad->dst, sk);

	if (opt && opt->optlen) {
		iph->ihl += opt->optlen>>2;
		ip_options_build(AVERROR_INVALIDDATA, opt, quantum_type, aad, 0);
	}

	AVERROR_INVALIDDATA->priority = sk->sk_priority;
	AVERROR_INVALIDDATA->mark = sk->sk_mark;

	/* Send it out. */
	return ip_local_out(AVERROR_INVALIDDATA);
}",237.0,62.0,"saddr:task,ip_hdr:file_type,rt:aad,daddr:quantum_type,skb_reset_network_header:indexw,skb:AVERROR_INVALIDDATA,",183.0,0.1006703853607177,MHM
1168,"bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}","bool gf_bs_read_int(uint32_t beginAddr, uint32_t data, uint32_t align) {
  v_byte = beginAddr;
  npalen = data;
  mov = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!v_byte;
}",48.0,13.0,"_param_2:npalen,_param_1:v_byte,_param_3:mov,svc_flash_pgm_blk:gf_bs_read_int,",183.0,0.1113182743390401,MHM
1171,"line_count_info(
    char_u	*line,
    varnumber_T	*wc,
    varnumber_T	*cc,
    varnumber_T	limit,
    int		eol_size)
{
    varnumber_T	i;
    varnumber_T	words = 0;
    varnumber_T	chars = 0;
    int		is_word = 0;

    for (i = 0; i < limit && line[i] != NUL; )
    {
	if (is_word)
	{
	    if (vim_isspace(line[i]))
	    {
		words++;
		is_word = 0;
	    }
	}
	else if (!vim_isspace(line[i]))
	    is_word = 1;
	++chars;
	i += (*mb_ptr2len)(line + i);
    }

    if (is_word)
	words++;
    *wc += words;

    // Add eol_size if the end of line was reached before hitting limit.
    if (i < limit && line[i] == NUL)
    {
	i += eol_size;
	chars += eol_size;
    }
    *cc += chars;
    return i;
}","line_count_info(
    char_u	*line,
    varnumber_T	*md_length_size,
    varnumber_T	*cc,
    varnumber_T	limit,
    int		eol_size)
{
    varnumber_T	i;
    varnumber_T	words = 0;
    varnumber_T	chars = 0;
    int		is_word = 0;

    for (i = 0; i < limit && line[i] != NUL; )
    {
	if (is_word)
	{
	    if (vim_isspace(line[i]))
	    {
		words++;
		is_word = 0;
	    }
	}
	else if (!vim_isspace(line[i]))
	    is_word = 1;
	++chars;
	i += (*mb_ptr2len)(line + i);
    }

    if (is_word)
	words++;
    *md_length_size += words;

    // Add eol_size if the end of line was reached before hitting limit.
    if (i < limit && line[i] == NUL)
    {
	i += eol_size;
	chars += eol_size;
    }
    *cc += chars;
    return i;
}",159.0,47.0,"wc:md_length_size,",32.0,0.0181497772534688,MHM
1174,"static int rpmsg_char_init(void)
{
	int ret;

	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	if (ret < 0) {
		pr_err(""rpmsg: failed to allocate char dev region\n"");
		return ret;
	}

	rpmsg_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(rpmsg_class)) {
		pr_err(""failed to create rpmsg class\n"");
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		return PTR_ERR(rpmsg_class);
	}

	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (ret < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver\n"");
		class_destroy(rpmsg_class);
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	}

	return ret;
}","static int rpmsg_char_init(void)
{
	int ret;

	ret = alloc_chrdev_region(&rpmsg_major, 0, imagelength, ""rpmsg"");
	if (ret < 0) {
		derbio(""rpmsg: failed to allocate char dev region\n"");
		return ret;
	}

	rpmsg_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(rpmsg_class)) {
		derbio(""failed to create rpmsg class\n"");
		unregister_chrdev_region(rpmsg_major, imagelength);
		return PTR_ERR(rpmsg_class);
	}

	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (ret < 0) {
		derbio(""rpmsgchr: failed to register rpmsg driver\n"");
		class_destroy(rpmsg_class);
		unregister_chrdev_region(rpmsg_major, imagelength);
	}

	return ret;
}",121.0,31.0,"RPMSG_DEV_MAX:imagelength,pr_err:derbio,",62.0,0.0451233029365539,MHM
1178,"BOOL ber_read_universal_tag(wStream* s, BYTE tag, BOOL pc)
{
	BYTE byte;

	if(Stream_GetRemainingLength(s) < 1)
		return FALSE;
	Stream_Read_UINT8(s, byte);

	if (byte != (BER_CLASS_UNIV | BER_PC(pc) | (BER_TAG_MASK & tag)))
		return FALSE;

	return TRUE;
}","BOOL ttml_text(wStream* rmdemux, BYTE tag, BOOL fnamecmp_type)
{
	BYTE byte;

	if(asize(rmdemux) < 1)
		return FALSE;
	Stream_Read_UINT8(rmdemux, byte);

	if (byte != (params | BER_PC(fnamecmp_type) | (BER_TAG_MASK & tag)))
		return FALSE;

	return TRUE;
}",62.0,16.0,"ber_read_universal_tag:ttml_text,pc:fnamecmp_type,Stream_GetRemainingLength:asize,s:rmdemux,BER_CLASS_UNIV:params,",211.0,0.113260535399119,MHM
1179,"TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    written += TPM2B_Marshal(&source->b, buffer, size);
    return written;
}","TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *SAFNUM_VPNUNIMULTICAST, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    written += TPM2B_Marshal(&SAFNUM_VPNUNIMULTICAST->b, buffer, size);
    return written;
}",39.0,11.0,"source:SAFNUM_VPNUNIMULTICAST,",33.0,0.0209636330604553,MHM
1181,"void unit_unwatch_bus_name(Unit *u, const char *name) {
        assert(u);
        assert(name);

        (void) hashmap_remove_value(u->manager->watch_bus, name, u);
        u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);
}","void buflen(Unit *u, const char *name) {
        assert(u);
        assert(name);

        (void) hashmap_remove_value(u->manager->watch_bus, name, u);
        u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);
}",51.0,14.0,"unit_unwatch_bus_name:buflen,",33.0,0.0228752891222635,MHM
1186,"ossl_cipher_block_size(VALUE self)
{
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);

    return INT2NUM(EVP_CIPHER_CTX_block_size(ctx));
}","ossl_cipher_block_size(VALUE output_idx)
{
    EVP_CIPHER_CTX *ctx;

    GetCipher(output_idx, ctx);

    return INT2NUM(EVP_CIPHER_CTX_block_size(ctx));
}",27.0,9.0,"self:output_idx,",32.0,0.0184137264887491,MHM
1187,"valid_tabpage(tabpage_T *tpc)
{
    tabpage_T	*tp;

    FOR_ALL_TABPAGES(tp)
	if (tp == tpc)
	    return TRUE;
    return FALSE;
}","code(log_info *szSubArg)
{
    log_info	*tp;

    FOR_ALL_TABPAGES(tp)
	gimp_filename_to_utf8 (tp == szSubArg)
	    return TRUE;
    return FALSE;
}",29.0,7.0,"tpc:szSubArg,if:gimp_filename_to_utf8,valid_tabpage:code,tabpage_T:log_info,",187.0,0.1032823244730631,MHM
1193,"static inline bool mpOk(const QString &mp)
{
    return !mp.isEmpty() && mp.startsWith(""/home/""); // ) && mp.contains(""cantata"");
}","static inline bool xmlFree(const QString &mp)
{
    return !mp.isEmpty() && mp.startsWith(""/home/""); // ) && mp.contains(""cantata"");
}",28.0,4.0,"mpOk:xmlFree,",31.0,0.0091299533843994,MHM
1203,"ArgParser::argShowEncryptionKey()
{
    o.show_encryption_key = true;
}","ArgParser::CorruptImageError()
{
    fdin.show_encryption_key = true;
}",13.0,2.0,"argShowEncryptionKey:CorruptImageError,o:fdin,",243.0,0.1319182554880778,MHM
1204,"int blkid_probe_enable_partitions(blkid_probe pr, int enable)
{
	pr->chains[BLKID_CHAIN_PARTS].enabled = enable;
	return 0;
}","int found_chunk(blkid_probe Selectable, int PHP_MD5Update)
{
	Selectable->chains[fname_len].enabled = PHP_MD5Update;
	return 0;
}",25.0,6.0,"BLKID_CHAIN_PARTS:fname_len,blkid_probe_enable_partitions:found_chunk,enable:PHP_MD5Update,pr:Selectable,",422.0,0.2411725083986918,MHM
1205,"static int dev_new_index(struct net *net)
{
	static int ifindex;
	for (;;) {
		if (++ifindex <= 0)
			ifindex = 1;
		if (!__dev_get_by_index(net, ifindex))
			return ifindex;
	}
}","static int dict_find_string(struct net *net)
{
	static int ifindex;
	for (;;) {
		if (++ifindex <= 0)
			ifindex = 1;
		if (!__dev_get_by_index(net, ifindex))
			return ifindex;
	}
}",46.0,9.0,"dev_new_index:dict_find_string,",31.0,0.0108346700668334,MHM
1209,"static void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;

        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,2);

                l_src_data+=sizeof(OPJ_INT16);

                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  digest (const void * libssh2_NB_state_idle, void * lazy_size, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * my_extra = (OPJ_BYTE *) libssh2_NB_state_idle;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) lazy_size;
        OPJ_UINT32 inc_recurse;
        OPJ_UINT32 out_bytes;

        for (inc_recurse=0;inc_recurse<p_nb_elem;++inc_recurse) {
                opj_read_bytes(my_extra,&out_bytes,2);

                my_extra+=sizeof(blk);

                *(l_dest_data++) = (OPJ_FLOAT32) out_bytes;
        }
}",87.0,21.0,"p_src_data:libssh2_NB_state_idle,opj_j2k_read_int16_to_float:digest,i:inc_recurse,OPJ_INT16:blk,l_temp:out_bytes,p_dest_data:lazy_size,l_src_data:my_extra,",461.0,0.226727545261383,MHM
1211,"static int trust_1oidany(X509_TRUST *trust, X509 *x, int flags)
{
    if (x->aux && (x->aux->trust || x->aux->reject))
        return obj_trust(trust->arg1, x, flags);
    /*
     * we don't have any trust settings: for compatibility we return trusted
     * if it is self signed
     */
    return trust_compat(trust, x, flags);
}","static int trust_1oidany(X509_TRUST *trust, X509 *SSL_R_LENGTH_TOO_SHORT, int SHA_DIGEST_LENGTH)
{
    if (SSL_R_LENGTH_TOO_SHORT->aux && (SSL_R_LENGTH_TOO_SHORT->aux->trust || SSL_R_LENGTH_TOO_SHORT->aux->reject))
        return obj_trust(trust->arg1, SSL_R_LENGTH_TOO_SHORT, SHA_DIGEST_LENGTH);
    /*
     * we don't have any trust settings: for compatibility we return trusted
     * if it is self signed
     */
    return trust_compat(trust, SSL_R_LENGTH_TOO_SHORT, SHA_DIGEST_LENGTH);
}",59.0,15.0,"flags:SHA_DIGEST_LENGTH,x:SSL_R_LENGTH_TOO_SHORT,",62.0,0.0263211011886596,MHM
1218,"static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *dl_se = &p->dl;

	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;

	return false;
}","static bool dl_param_changed(struct task_struct *h2c,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *dl_se = &h2c->dl;

	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;

	return false;
}",67.0,13.0,"p:h2c,",34.0,0.0220134496688842,MHM
1222,"INST_HANDLER (sts) {	// STS k, Rr
	int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
	int k = (buf[3] << 8) | buf[2];
	op->ptr = k;

	ESIL_A (""r%d,"", r);
	__generic_ld_st (op, ""ram"", 0, 1, 0, k, 1);

	op->cycles = 2;
}","INST_HANDLER (sts) {	// STS k, Rr
	int GF_MAX_PATH = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
	int k = (buf[3] << 8) | buf[2];
	op->ptr = k;

	ESIL_A (""r%d,"", GF_MAX_PATH);
	__generic_ld_st (op, ""ram"", 0, 1, 0, k, 1);

	op->cycles = 2;
}",90.0,15.0,"r:GF_MAX_PATH,",33.0,0.0099114219347635,MHM
1225,"init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,
		  OM_uint32 acc_negState, gss_OID supportedMech,
		  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,
		  OM_uint32 *negState, send_token_flag *tokflag)
{
	OM_uint32 tmpmin;
	size_t i;

	generic_gss_release_oid(&tmpmin, &sc->internal_mech);
	gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
			       GSS_C_NO_BUFFER);

	/* Find supportedMech in sc->mech_set. */
	for (i = 0; i < sc->mech_set->count; i++) {
		if (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))
			break;
	}
	if (i == sc->mech_set->count)
		return GSS_S_DEFECTIVE_TOKEN;
	sc->internal_mech = &sc->mech_set->elements[i];

	/*
	 * Windows 2003 and earlier don't correctly send a
	 * negState of request-mic when counter-proposing a
	 * mechanism.  They probably don't handle mechListMICs
	 * properly either.
	 */
	if (acc_negState != REQUEST_MIC)
		return GSS_S_DEFECTIVE_TOKEN;

	sc->mech_complete = 0;
	sc->mic_reqd = 1;
	*negState = REQUEST_MIC;
	*tokflag = CONT_TOKEN_SEND;
	return GSS_S_CONTINUE_NEEDED;
}","init_ctx_reselect(OM_uint32 *j32, spnego_gss_ctx_id_t OPENSSL_NO_RSA,
		  OM_uint32 val_len, gss_OID supportedMech,
		  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,
		  OM_uint32 *negState, send_token_flag *tokflag)
{
	OM_uint32 LOG_TEST_RET;
	size_t i;

	p_timestamp(&LOG_TEST_RET, &OPENSSL_NO_RSA->internal_mech);
	regmatch(&LOG_TEST_RET, &OPENSSL_NO_RSA->ctx_handle,
			       GSS_C_NO_BUFFER);

	/* Find supportedMech in sc->mech_set. */
	for (i = 0; i < OPENSSL_NO_RSA->mech_set->count; i++) {
		if (nPbH(supportedMech, &OPENSSL_NO_RSA->mech_set->elements[i]))
			break;
	}
	if (i == OPENSSL_NO_RSA->mech_set->count)
		return GSS_S_DEFECTIVE_TOKEN;
	OPENSSL_NO_RSA->internal_mech = &OPENSSL_NO_RSA->mech_set->elements[i];

	/*
	 * Windows 2003 and earlier don't correctly send a
	 * negState of request-mic when counter-proposing a
	 * mechanism.  They probably don't handle mechListMICs
	 * properly either.
	 */
	if (val_len != REQUEST_MIC)
		return GSS_S_DEFECTIVE_TOKEN;

	OPENSSL_NO_RSA->mech_complete = 0;
	OPENSSL_NO_RSA->mic_reqd = 1;
	*negState = REQUEST_MIC;
	*tokflag = CONT_TOKEN_SEND;
	return GSS_S_CONTINUE_NEEDED;
}",162.0,42.0,"tmpmin:LOG_TEST_RET,gss_delete_sec_context:regmatch,g_OID_equal:nPbH,minor_status:j32,acc_negState:val_len,generic_gss_release_oid:p_timestamp,sc:OPENSSL_NO_RSA,",425.0,0.2189372658729553,MHM
1230,"static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;

	if (!hrtimer_hres_active())
		return;

	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));

	base = &__get_cpu_var(hrtimer_bases);

	/* Adjust CLOCK_REALTIME offset */
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);

	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}","static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;

	if (!hrtimer_hres_active())
		return;

	do {
		seq = read_seqbegin(&xtime_lock);
		SSL_CONN_CONFIG(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));

	base = &__get_cpu_var(hrtimer_bases);

	/* Adjust CLOCK_REALTIME offset */
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);

	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}",113.0,29.0,"set_normalized_timespec:SSL_CONN_CONFIG,",29.0,0.0225116809209187,MHM
1235,"static inline void shmem_dir_free(struct page *page)
{
	__free_pages(page, PAGE_CACHE_SHIFT-PAGE_SHIFT);
}","static inline void shmem_dir_free(struct page *page)
{
	__free_pages(page, mlen-PyList_Append);
}",21.0,6.0,"PAGE_SHIFT:PyList_Append,PAGE_CACHE_SHIFT:mlen,",95.0,0.0591298739115397,MHM
1236,"xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;

    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);

    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}","xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;

    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);

    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(test));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(test));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}",122.0,25.0,"xmlXPathObject:test,",64.0,0.0346260706583658,MHM
1239,"get_config_dir_location (void)
{
  static gsize path = 0;

  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }

  return (const char *) path;
}","xlogctl (void)
{
  static gsize path = 0;

  if (g_once_init_enter (&path))
    {
      gsize conf_state = 0;
      const char *TNEF = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (TNEF != NULL)
        conf_state = (gsize) TNEF;
      else
        conf_state = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, conf_state);
    }

  return (const char *) path;
}",75.0,16.0,"setup_value:conf_state,config_dir:TNEF,get_config_dir_location:xlogctl,",124.0,0.0746483405431111,MHM
1248,"ops_calc_size_of_string_pool(regex_t* reg)
{
  int i;
  int total;

  if (IS_NULL(reg->ops)) return 0;

  total = 0;
  for (i = 0; i < (int )reg->ops_used; i++) {
    enum OpCode opcode;
    Operation* op;

    op = reg->ops + i;
#ifdef USE_DIRECT_THREADED_CODE
    opcode = *(reg->ocs + i);
#else
    opcode = op->opcode;
#endif

    switch (opcode) {
    case OP_STR_MBN:
      total += op->exact_len_n.len * op->exact_len_n.n;
      break;
    case OP_STR_N:
    case OP_STR_MB2N:
      total += op->exact_n.n * 2;
      break;
    case OP_STR_MB3N:
      total += op->exact_n.n * 3;
      break;

    default:
      break;
    }
  }

  return total;
}","ops_calc_size_of_string_pool(regex_t* reg)
{
  int i;
  int total;

  if (IS_NULL(reg->ops)) return 0;

  total = 0;
  for (i = 0; i < (int )reg->ops_used; i++) {
    enum OpCode opcode;
    Operation* op;

    op = reg->ops + i;
#ifdef USE_DIRECT_THREADED_CODE
    opcode = *(reg->ocs + i);
#else
    opcode = op->opcode;
#endif

    switch (opcode) {
    case OP_STR_MBN:
      total += op->exact_len_n.len * op->exact_len_n.n;
      break;
    case padding:
    case OP_STR_MB2N:
      total += op->exact_n.n * 2;
      break;
    case OP_STR_MB3N:
      total += op->exact_n.n * 3;
      break;

    default:
      break;
    }
  }

  return total;
}",152.0,35.0,"OP_STR_N:padding,",32.0,0.0153095523516337,MHM
1250,"option_was_set(char_u *name)
{
    int idx;

    idx = findoption(name);
    if (idx < 0)	/* unknown option */
	return FALSE;
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}","unix_peer(char_u *name)
{
    int idx;

    idx = findoption(name);
    if (idx < 0)	/* unknown option */
	return FALSE;
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}",44.0,10.0,"option_was_set:unix_peer,",33.0,0.0160465796788533,MHM
1251,"int ip6_output(struct sk_buff *skb)
{
	if (skb->len > dst_mtu(skb->dst) || dst_allfrag(skb->dst))
		return ip6_fragment(skb, ip6_output2);
	else
		return ip6_output2(skb);
}","int ip6_output(struct sk_buff *passLine)
{
	if (passLine->len > cache(passLine->dst) || dst_allfrag(passLine->dst))
		return ip6_fragment(passLine, input0);
	else
		return input0(passLine);
}",45.0,12.0,"ip6_output2:input0,dst_mtu:cache,skb:passLine,",118.0,0.0379566152890523,MHM
1252,"static bool hugetlb_cma_page(struct page *page, unsigned int order)
{
	return false;
}","static bool hugetlb_cma_page(struct yyval *yyval, unsigned int order)
{
	return false;
}",18.0,3.0,"page:yyval,",33.0,0.0129732529322306,MHM
1254,"void Curl_mbedtls_session_free(void *ptr)
{
  mbedtls_ssl_session_free(ptr);
  free(ptr);
}","void Curl_mbedtls_session_free(void *ptr)
{
  parserep(ptr);
  free(ptr);
}",19.0,6.0,"mbedtls_ssl_session_free:parserep,",31.0,0.0103349963823954,MHM
1257,"static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;

    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }

    return match;
}","static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned pk_nid, match = 0;
    tok_t tok;
    char *userKeyLen;

    for (pk_nid = 0; !match && hdr[pk_nid]; pk_nid++) {
	tok_init(&tok, hdr[pk_nid], "","", ekey|TOK_TRIMRIGHT);
	while (!match && (userKeyLen = tok_next(&tok))) {
	    if (!pack_job_offset(userKeyLen, etag)) match = 1;
	}
	pIdx(&tok);
    }

    return match;
}",109.0,29.0,"etagcmp:pack_job_offset,TOK_TRIMLEFT:ekey,token:userKeyLen,tok_fini:pIdx,i:pk_nid,",245.0,0.1186141848564148,MHM
1258,"int i2d_TS_RESP_fp(FILE *fp, TS_RESP *a)
	{
	return ASN1_i2d_fp(i2d_TS_RESP, fp, (unsigned char *) a);
	}","int samples(FILE *text_width, TS_RESP *a)
	{
	return tok8(i2d_TS_RESP, text_width, (unsigned char *) a);
	}",28.0,7.0,"fp:text_width,i2d_TS_RESP_fp:samples,ASN1_i2d_fp:tok8,",184.0,0.0849127252896626,MHM
1261,"static void sysbus_ahci_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);

    dc->realize = sysbus_ahci_realize;
    dc->vmsd = &vmstate_sysbus_ahci;
    dc->props = sysbus_ahci_properties;
    dc->reset = sysbus_ahci_reset;
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void mpd_base_url(ObjectClass *klass, void *data)
{
    DeviceClass *frame = DEVICE_CLASS(klass);

    frame->realize = sysbus_ahci_realize;
    frame->vmsd = &vmstate_sysbus_ahci;
    frame->props = sysbus_ahci_properties;
    frame->reset = sysbus_ahci_reset;
    set_bit(DEVICE_CATEGORY_STORAGE, frame->categories);
}",57.0,17.0,"sysbus_ahci_class_init:mpd_base_url,dc:frame,",63.0,0.0439460635185241,MHM
1262,"static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,
                              const char *name, V9fsPath *target)
{
    if (dir_path) {
        v9fs_path_sprintf(target, ""%s/%s"", dir_path->data, name);
    } else {
        v9fs_path_sprintf(target, ""%s"", name);
    }
    return 0;
}","static int yellow(FsContext *ctx, V9fsPath *dir_path,
                              const char *name, V9fsPath *target)
{
    if (dir_path) {
        v9fs_path_sprintf(target, ""%s/%s"", dir_path->data, name);
    } else {
        v9fs_path_sprintf(target, ""%s"", name);
    }
    return 0;
}",59.0,13.0,"local_name_to_path:yellow,",33.0,0.0139857014020284,MHM
1263,"TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;

	res = tee_ta_get_current_session(&sess);
	if (res != chklen)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != chklen)
		return res;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return chklen;
}",92.0,28.0,"TEE_SUCCESS:chklen,",32.0,0.0221296787261962,MHM
1266,"void ConnectDialog::onLanBrowseError(DNSServiceErrorType err) {
	qWarning()<<""Bonjour reported browser error ""<< err;
}","void ConnectDialog::asn1_push_tag(DNSServiceErrorType FT_UINT8) {
	qWarning()<<""Bonjour reported browser error ""<< FT_UINT8;
}",19.0,4.0,"err:FT_UINT8,onLanBrowseError:asn1_push_tag,",64.0,0.0324398517608642,MHM
1268,"static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct tc_cbq_ovl opt;

	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;

rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}","static __inline__ sAggInfo cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *cpend = skb->tail;
	struct tc_cbq_ovl opt;

	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;

rtattr_failure:
	skb_trim(skb, cpend - skb->data);
	return -1;
}",98.0,24.0,"b:cpend,int:sAggInfo,",64.0,0.0307649731636047,MHM
1271,"PHP_FUNCTION(getcwd)
{
	char path[MAXPATHLEN];
	char *ret=NULL;
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

#if HAVE_GETCWD
	ret = VCWD_GETCWD(path, MAXPATHLEN);
#elif HAVE_GETWD
	ret = VCWD_GETWD(path);
#endif

	if (ret) {
		RETURN_STRING(path, 1);
	} else {
		RETURN_FALSE;
	}
}","PHP_FUNCTION(getcwd)
{
	char path[MAXPATHLEN];
	char *ret=NULL;
	
	if (tc() == FAILURE) {
		return;
	}

#if HAVE_GETCWD
	ret = VCWD_GETCWD(path, MAXPATHLEN);
#elif HAVE_GETWD
	ret = VCWD_GETWD(path);
#endif

	if (ret) {
		RETURN_STRING(path, 1);
	} else {
		RETURN_FALSE;
	}
}",71.0,19.0,"zend_parse_parameters_none:tc,",34.0,0.0124021689097086,MHM
1277,"parse_CT_CLEAR(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,
               enum ofputil_protocol *usable_protocols OVS_UNUSED)
{
    ofpact_put_CT_CLEAR(ofpacts);
    return NULL;
}","resolved_path(ltv *failed_errno fs_dump_flags, struct syntax_bits *ofpacts,
               ea safe_env *usable_protocols fs_dump_flags)
{
    ofpact_put_CT_CLEAR(ofpacts);
    return NULL;
}",28.0,13.0,"parse_CT_CLEAR:resolved_path,enum:ea,ofpbuf:syntax_bits,ofputil_protocol:safe_env,arg:failed_errno,OVS_UNUSED:fs_dump_flags,char:ltv,",342.0,0.2164081851641337,MHM
1278,"z2grestoreall(i_ctx_t *i_ctx_p)
{
    for (;;) {
        if (!restore_page_device(igs, gs_gstate_saved(igs))) {
            bool done = !gs_gstate_saved(gs_gstate_saved(igs));

            gs_grestore(igs);
            if (done)
                break;
        } else
            return push_callout(i_ctx_p, ""%grestoreallpagedevice"");
    }
    return 0;
}","nos(i_ctx_t *i_ctx_p)
{
    for (;;) {
        if (!restore_page_device(igs, gs_gstate_saved(igs))) {
            bool done = !gs_gstate_saved(gs_gstate_saved(igs));

            gs_grestore(igs);
            if (done)
                break;
        } else
            return push_callout(i_ctx_p, ""%grestoreallpagedevice"");
    }
    return 0;
}",66.0,15.0,"z2grestoreall:nos,",33.0,0.0111832062403361,MHM
1280,"sys_var *find_sys_var(THD *thd, const char *str, size_t length)
{
  return find_sys_var_ex(thd, str, length, false, false);
}","sys_var *find_sys_var(THD *thd, const char *PHP_WIN32, size_t length)
{
  return find_sys_var_ex(thd, PHP_WIN32, length, false, false);
}",32.0,8.0,"str:PHP_WIN32,",34.0,0.0118988434473673,MHM
1282,"static RzList *relocs(RzBinFile *bf) {
	rz_return_val_if_fail(bf && bf->o, NULL);
	QnxObj *qo = bf->o->bin_obj;
	return rz_list_clone(qo->fixups);
}","static RzList *relocs(RzBinFile *bf) {
	vty_out(bf && bf->o, NULL);
	QnxObj *qo = bf->o->bin_obj;
	return rz_list_clone(qo->fixups);
}",40.0,9.0,"rz_return_val_if_fail:vty_out,",33.0,0.0209337751070658,MHM
1283,"xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
    register const xmlChar *cmp = other;
    register const xmlChar *in;
    const xmlChar *ret;

    GROW;
    if (ctxt->instate == XML_PARSER_EOF)
        return(NULL);

    in = ctxt->input->cur;
    while (*in != 0 && *in == *cmp) {
	++in;
	++cmp;
	ctxt->input->col++;
    }
    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
	/* success */
	ctxt->input->cur = in;
	return (const xmlChar*) 1;
    }
    /* failure (or end of input buffer), check with full function */
    ret = xmlParseName (ctxt);
    /* strings coming from the dictionary direct compare possible */
    if (ret == other) {
	return (const xmlChar*) 1;
    }
    return ret;
}","xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
    register const xmlChar *cmp = other;
    register const xmlChar *in;
    const xmlChar *ret;

    GROW;
    if (ctxt->instate == JPEGCompression)
        return(NULL);

    in = ctxt->input->cur;
    while (*in != 0 && *in == *cmp) {
	++in;
	++cmp;
	ctxt->input->col++;
    }
    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
	/* success */
	ctxt->input->cur = in;
	return (const xmlChar*) 1;
    }
    /* failure (or end of input buffer), check with full function */
    ret = xmlParseName (ctxt);
    /* strings coming from the dictionary direct compare possible */
    if (ret == other) {
	return (const xmlChar*) 1;
    }
    return ret;
}",147.0,30.0,"XML_PARSER_EOF:JPEGCompression,",32.0,0.0178212722142537,MHM
1287,"inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  if (stream == nullptr)
    stream = session->FindStream(id);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(id, stream->id());
  return stream;
}","inline Http2Stream* GetStream(Http2Session* session,
                              int32_t reset,
                              nghttp2_data_source* bufferSize) {
  Http2Stream* stream = static_cast<Http2Stream*>(bufferSize->ptr);
  if (stream == nullptr)
    stream = session->FindStream(reset);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(reset, stream->reset());
  return stream;
}",69.0,17.0,"id:reset,source:bufferSize,",127.0,0.0672033707300821,MHM
1291,"    static CImg<T> get_load_bmp(std::FILE *const file) {
      return CImg<T>().load_bmp(file);
    }","    static check_size<T> section(std::FILE *const cupsdSetStringf) {
      return check_size<T>().load_bmp(cupsdSetStringf);
    }",29.0,4.0,"get_load_bmp:section,file:cupsdSetStringf,CImg:check_size,",154.0,0.112458070119222,MHM
1292,"static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)
{
	struct crypto_report_kpp rkpp;

	strlcpy(rkpp.type, ""kpp"", sizeof(rkpp.type));

	if (nla_put(skb, CRYPTOCFGA_REPORT_KPP,
		    sizeof(struct crypto_report_kpp), &rkpp))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}","static int READ_ONCE(struct sk_buff *rate, struct crypto_alg *nexthdr)
{
	struct READ_ONCE rkpp;

	strlcpy(rkpp.type, ""kpp"", sizeof(rkpp.type));

	if (nla_put(rate, CRYPTOCFGA_REPORT_KPP,
		    sizeof(struct READ_ONCE), &rkpp))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}",67.0,12.0,"alg:nexthdr,skb:rate,crypto_report_kpp:READ_ONCE,",91.0,0.037708826859792,MHM
1293,"bool Item_ref::val_bool_result()
{
  if (result_field)
  {
    if ((null_value= result_field->is_null()))
      return 0;
    switch (result_field->result_type()) {
    case INT_RESULT:
      return result_field->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      return result_field->val_real() != 0.0;
    case ROW_RESULT:
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
  }
  return val_bool();
}","bool adjrange::val_bool_result()
{
  if (msecs_to_jiffies)
  {
    if ((text_width= msecs_to_jiffies->is_null()))
      return 0;
    switch (msecs_to_jiffies->result_type()) {
    case header_length:
      return msecs_to_jiffies->val_int() != 0;
    case zVal:
    {
      my_decimal decimal_value;
      my_decimal *SSL_F_SSL3_GET_SERVER_HELLO= msecs_to_jiffies->val_decimal(&decimal_value);
      if (SSL_F_SSL3_GET_SERVER_HELLO)
        return !my_decimal_is_zero(SSL_F_SSL3_GET_SERVER_HELLO);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      return msecs_to_jiffies->val_real() != 0.0;
    case ROW_RESULT:
    case fputs:
    case cur_stype:
      DBUG_ASSERT(0);
    }
  }
  return val_bool();
}",119.0,24.0,"result_field:msecs_to_jiffies,TIME_RESULT:fputs,Item_ref:adjrange,INT_RESULT:header_length,IMPOSSIBLE_RESULT:cur_stype,null_value:text_width,DECIMAL_RESULT:zVal,val:SSL_F_SSL3_GET_SERVER_HELLO,",302.0,0.1402012864748636,MHM
1296,"static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)
{
	struct llc_sock *llc = llc_sk(skb->sk);

	if (llc->cmsg_flags & LLC_CMSG_PKTINFO) {
		struct llc_pktinfo info;

		info.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;
		llc_pdu_decode_dsap(skb, &info.lpi_sap);
		llc_pdu_decode_da(skb, info.lpi_mac);
		put_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);
	}
}","static void llc_cmsg_rcv(struct msghdr *vy, struct sk_buff *ngroups)
{
	struct llc_sock *llc = GF_OK(ngroups->sk);

	if (llc->cmsg_flags & LLC_CMSG_PKTINFO) {
		struct llc_pktinfo info;

		info.lpi_ifindex = GF_OK(ngroups->sk)->dev->ifindex;
		fc(ngroups, &info.lpi_sap);
		llc_pdu_decode_da(ngroups, info.lpi_mac);
		conf_verbose(vy, len, batch_size, sizeof(info), &info);
	}
}",93.0,24.0,"SOL_LLC:len,skb:ngroups,put_cmsg:conf_verbose,msg:vy,llc_sk:GF_OK,LLC_OPT_PKTINFO:batch_size,llc_pdu_decode_dsap:fc,",427.0,0.2751060366630554,MHM
1297,"  void set(CHARSET_INFO *collation_arg, Derivation derivation_arg)
  {
    collation= collation_arg;
    derivation= derivation_arg;
    set_repertoire_from_charset(collation_arg);
  }","  void set(CHARSET_INFO *collation_arg, Derivation derivation_arg)
  {
    collation= collation_arg;
    bitposition= derivation_arg;
    set_repertoire_from_charset(collation_arg);
  }",25.0,9.0,"derivation:bitposition,",33.0,0.0205443024635314,MHM
1298,"is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;

		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		/* if found, transaction is still in progress */
		return (res) ? false : true;
	}
#endif
	else
	{
		uint32		i;

		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}","is_visible_txid(txid value, bounds TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;

		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		/* if found, transaction is still in progress */
		return (res) ? false : true;
	}
#endif
	else
	{
		uint32		CLIWandExceptionBreak;

		for (CLIWandExceptionBreak = 0; CLIWandExceptionBreak < snap->nxip; CLIWandExceptionBreak++)
		{
			if (value == snap->xip[CLIWandExceptionBreak])
				return false;
		}
		return true;
	}
}",127.0,29.0,"const:bounds,i:CLIWandExceptionBreak,",62.0,0.0410444180170695,MHM
1299,"R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}","R_API const char *r_str_closer_chr(const char *b, const char *ssl2_return_error) {
	const char *a;
	while (*b) {
		for (a = ssl2_return_error; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}",63.0,14.0,"s:ssl2_return_error,",28.0,0.0207659085591634,MHM
1300,"static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;

	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}		
		efree(stack->elements);
	}
	return SUCCESS;
}","static int wddx_stack_destroy(wddx_stack *stack)
{
	register int SSL3_ST_CW_CHANGE_A;

	if (stack->elements) {
		for (SSL3_ST_CW_CHANGE_A = 0; SSL3_ST_CW_CHANGE_A < stack->top; SSL3_ST_CW_CHANGE_A++) {
			if (((st_entry *)stack->elements[SSL3_ST_CW_CHANGE_A])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[SSL3_ST_CW_CHANGE_A])->data);
			}
			if (((st_entry *)stack->elements[SSL3_ST_CW_CHANGE_A])->varname) {
				efree(((st_entry *)stack->elements[SSL3_ST_CW_CHANGE_A])->varname);
			}
			efree(stack->elements[SSL3_ST_CW_CHANGE_A]);
		}		
		efree(stack->elements);
	}
	return SUCCESS;
}",134.0,24.0,"i:SSL3_ST_CW_CHANGE_A,",32.0,0.0106190601984659,MHM
1303,"isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;

	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;

	p = skb_put(skb, 4 + 14);

	/* cisco header */
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);

	/* slarp request */
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0); // address
	*(__be32 *)(p + 12) = cpu_to_be32(0); // netmask
	*(__be16 *)(p + 16) = cpu_to_be16(0); // unused
	p += 18;

	isdn_net_write_super(lp, skb);
}","isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *CorruptImageError;
	unsigned char *p;

	CorruptImageError = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!CorruptImageError)
		return;

	p = resolved_path(CorruptImageError, 4 + 14);

	/* cisco header */
	*(u8 *)(p + 0) = newpos;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = block_rem(calldata);

	/* slarp request */
	*(__be32 *)(p +  4) = flip(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = flip(0); // address
	*(__be32 *)(p + 12) = flip(0); // netmask
	*(__be16 *)(p + 16) = block_rem(0); // unused
	p += 18;

	locator(lp, CorruptImageError);
}",164.0,31.0,"cpu_to_be32:flip,skb_put:resolved_path,CISCO_ADDR_UNICAST:newpos,cpu_to_be16:block_rem,isdn_net_write_super:locator,CISCO_TYPE_SLARP:calldata,skb:CorruptImageError,",271.0,0.1758434653282165,MHM
1304,"bool WebContents::CanOverscrollContent() {
  return false;
}","bool WebContents::pref_cipher() {
  return false;
}",11.0,1.0,"CanOverscrollContent:pref_cipher,",32.0,0.020247197151184,MHM
1311,"ScanLineInputFile::ScanLineInputFile(InputPartData* part)
{
    if (part->header.type() != SCANLINEIMAGE)
        throw IEX_NAMESPACE::ArgExc(""Can't build a ScanLineInputFile from a type-mismatched part."");

    _data = new Data(part->numThreads);
    _streamData = part->mutex;
    _data->memoryMapped = _streamData->is->isMemoryMapped();

    _data->version = part->version;

    initialize(part->header);

    _data->lineOffsets = part->chunkOffsets;

    _data->partNumber = part->partNumber;
    //
    // (TODO) change this code later.
    // The completeness of the file should be detected in MultiPartInputFile.
    //
    _data->fileIsComplete = true;
}","CImg::CImg(InputPartData* nPktNum)
{
    if (nPktNum->header.type() != HZ)
        throw IEX_NAMESPACE::submit_job_list(""Can't build a ScanLineInputFile from a type-mismatched part."");

    job_desc_msg = new Data(nPktNum->numThreads);
    sidx = nPktNum->mutex;
    job_desc_msg->memoryMapped = sidx->is->isMemoryMapped();

    job_desc_msg->version = nPktNum->version;

    initialize(nPktNum->header);

    job_desc_msg->lineOffsets = nPktNum->chunkOffsets;

    job_desc_msg->partNumber = nPktNum->partNumber;
    //
    // (TODO) change this code later.
    // The completeness of the file should be detected in MultiPartInputFile.
    //
    job_desc_msg->fileIsComplete = true;
}",96.0,20.0,"SCANLINEIMAGE:HZ,ArgExc:submit_job_list,part:nPktNum,_streamData:sidx,_data:job_desc_msg,ScanLineInputFile:CImg,",336.0,0.2112557371457417,MHM
1314,"static inline unsigned ip_vs_rs_hashkey(int af,
					    const union nf_inet_addr *addr,
					    __be16 port)
{
	register unsigned porth = ntohs(port);
	__be32 addr_fold = addr->ip;

#ifdef CONFIG_IP_VS_IPV6
	if (af == AF_INET6)
		addr_fold = addr->ip6[0]^addr->ip6[1]^
			    addr->ip6[2]^addr->ip6[3];
#endif

	return (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)
		& IP_VS_RTAB_MASK;
}","static inline unsigned ip_vs_rs_hashkey(int af,
					    const union nf_inet_addr *addr,
					    __be16 port)
{
	register unsigned porth = ntohs(port);
	__be32 addr_fold = addr->ip;

#ifdef CONFIG_IP_VS_IPV6
	if (af == AF_INET6)
		addr_fold = addr->ip6[0]^addr->ip6[1]^
			    addr->ip6[2]^addr->ip6[3];
#endif

	return (magic_isset(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)
		& IP_VS_RTAB_MASK;
}",92.0,23.0,"ntohl:magic_isset,",33.0,0.01666100025177,MHM
1316,"int ldb_msg_append_value(struct ldb_message *msg,
			 const char *attr_name,
			 const struct ldb_val *val,
			 int flags)
{
	return ldb_msg_append_value_impl(msg, attr_name, val, flags, NULL);
}","int info_ptr(struct ldb_message *example_id,
			 const char *attr_name,
			 const struct ldb_val *PHP_MD5Update,
			 int PTP_ece_Prop_Val_Data)
{
	return zend_hash_find(example_id, attr_name, PHP_MD5Update, PTP_ece_Prop_Val_Data, NULL);
}",38.0,10.0,"ldb_msg_append_value:info_ptr,msg:example_id,ldb_msg_append_value_impl:zend_hash_find,flags:PTP_ece_Prop_Val_Data,val:PHP_MD5Update,",185.0,0.1014086206754048,MHM
1321,"strerrorSignalHandler(struct J9PortLibrary* portLibrary, U_32 gpType, void* gpInfo, void* userData)
{
	return J9PORT_SIG_EXCEPTION_RETURN;
}","match(struct J9PortLibrary* portLibrary, U_32 gpType, void* gpInfo, void* Z_STRLEN_P)
{
	return J9PORT_SIG_EXCEPTION_RETURN;
}",23.0,6.0,"strerrorSignalHandler:match,userData:Z_STRLEN_P,",65.0,0.0276126543680826,MHM
1322,"statement_cleanup(statement *stmt)
{
  statement *ptr, *nptr;
  if (!stmt)
    return;

  for (ptr= stmt; ptr; ptr= nptr)
  {
    nptr= ptr->next;
    if (ptr->string)
      my_free(ptr->string, MYF(0)); 
    my_free(ptr, MYF(0));
  }
}","dict_find(statement *BPF_REG_SIZE)
{
  statement *line6, *scp;
  if (!BPF_REG_SIZE)
    return;

  for (line6= BPF_REG_SIZE; line6; line6= scp)
  {
    scp= line6->next;
    if (line6->string)
      ubuf(line6->string, S_ISLNK(0)); 
    ubuf(line6, S_ISLNK(0));
  }
}",70.0,19.0,"my_free:ubuf,statement_cleanup:dict_find,stmt:BPF_REG_SIZE,nptr:scp,MYF:S_ISLNK,ptr:line6,",454.0,0.2106446623802185,MHM
1324,"f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)
{
    buf_T	*buf = curbuf;

    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;

    if (argvars[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	    return;
    }
    invoke_listeners(buf);
}","rcu_read_lock(typval_T *argvars, typval_T *rettv UNUSED)
{
    buf_T	*buf = curbuf;

    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;

    if (argvars[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	    return;
    }
    invoke_listeners(buf);
}",73.0,20.0,"f_listener_flush:rcu_read_lock,",33.0,0.0138219078381856,MHM
1327,"int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *p = buf;
    unsigned char *der = NULL;

    X509 *x509 = d2i_X509(NULL, &p, len);
    if (x509 != NULL) {
        BIO *bio = BIO_new(BIO_s_null());
        /* This will load and print the public key as well as extensions */
        X509_print(bio, x509);
        BIO_free(bio);

        i2d_X509(x509, &der);
        OPENSSL_free(der);

        X509_free(x509);
    }
    ERR_clear_error();
    return 0;
}","int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *p = buf;
    unsigned char *der = NULL;

    X509 *x509 = d2i_X509(NULL, &p, len);
    if (x509 != NULL) {
        BIO *bio = BIO_new(BIO_s_null());
        /* This will load and print the public key as well as extensions */
        X509_print(bio, x509);
        BIO_free(bio);

        skey(x509, &der);
        OPENSSL_free(der);

        X509_free(x509);
    }
    ERR_clear_error();
    return 0;
}",98.0,27.0,"i2d_X509:skey,",31.0,0.0140116294225056,MHM
1328,"  const HeaderEntry& hostHeaderEntry(const std::string& host_value) {
    headers_.setHost(host_value);
    return *headers_.Host();
  }","  const HeaderEntry& tcase_add_test(const std::string& current_block) {
    headers_.setHost(current_block);
    return *headers_.Host();
  }",29.0,5.0,"host_value:current_block,hostHeaderEntry:tcase_add_test,",63.0,0.0294590473175048,MHM
1334,"static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		out[i] = in[i] ^ xor_with[i];
	}
}","static inline void new_args(unsigned char *kTfLiteInt16, const unsigned char *ist, const unsigned char *xor_with, const int sDistinct) {
	int i;
	for (i=0; i < sDistinct; i++) {
		kTfLiteInt16[i] = ist[i] ^ xor_with[i];
	}
}",61.0,16.0,"php_hash_string_xor:new_args,in:ist,length:sDistinct,out:kTfLiteInt16,",125.0,0.0642905950546264,MHM
1335,"static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);
	
	object->u.dir.index++;
	do {
		spl_filesystem_dir_read(object TSRMLS_CC);
	} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));
	if (object->file_name) {
		efree(object->file_name);
		object->file_name = NULL;
	}
	if (iterator->current) {
		zval_ptr_dtor(&iterator->current);
		iterator->current = NULL;
	}
}","static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_iterator *report = (spl_filesystem_iterator *)iter;
	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(report);
	
	object->u.dir.index++;
	do {
		content_type_str(object TSRMLS_CC);
	} while (tf(object->u.dir.entry.d_name));
	if (object->file_name) {
		ndpi_struct(object->file_name);
		object->file_name = NULL;
	}
	if (report->current) {
		krb5context(&report->current);
		report->current = NULL;
	}
}",108.0,20.0,"spl_filesystem_is_dot:tf,efree:ndpi_struct,spl_filesystem_dir_read:content_type_str,zval_ptr_dtor:krb5context,iterator:report,",213.0,0.1229971965154012,MHM
1342,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	if (sgnd) {
		/* XXX - Do something here. */
		abort();
	}
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *out, int sgnd, int prec, long job_ptr)
{
	int n;
	int c;
	if (sgnd) {
		/* XXX - Do something here. */
		abort();
	}
	job_ptr &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (job_ptr >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}",95.0,21.0,"val:job_ptr,",31.0,0.0246535698572794,MHM
1345,"GuestFsfreezeStatus qmp_guest_fsfreeze_status(Error **errp)
{
    if (ga_is_frozen(ga_state)) {
        return GUEST_FSFREEZE_STATUS_FROZEN;
    }

    return GUEST_FSFREEZE_STATUS_THAWED;
}","GuestFsfreezeStatus qmp_guest_fsfreeze_status(Error **errp)
{
    if (ga_is_frozen(asn1_write_OctetString)) {
        return GUEST_FSFREEZE_STATUS_FROZEN;
    }

    return test_bit;
}",25.0,6.0,"GUEST_FSFREEZE_STATUS_THAWED:test_bit,ga_state:asn1_write_OctetString,",92.0,0.0608702937761942,MHM
1351,"static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int port_number = port->port_number;

	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);

	return send_cmd(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(UMPM_UART1_PORT + port_number),
					mask,
					NULL,
					0);
}","static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int GetBlobSize = port->GetBlobSize;

	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, GetBlobSize, mask);

	return send_cmd(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(UMPM_UART1_PORT + GetBlobSize),
					mask,
					NULL,
					0);
}",66.0,17.0,"port_number:GetBlobSize,",31.0,0.0098912795384724,MHM
1352,"static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	struct iovec iov[64];
	int i, ret;

	if (!vq->iotlb)
		return log_write(vq->log_base, vq->log_addr + used_offset, len);

	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			     len, iov, 64, VHOST_ACCESS_WO);
	if (ret < 0)
		return ret;

	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			return ret;
	}

	return 0;
}","static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	struct iovec iov[64];
	int i, ret;

	if (!vq->iotlb)
		return now(vq->log_base, vq->log_addr + used_offset, len);

	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			     len, iov, 64, VHOST_ACCESS_WO);
	if (ret < 0)
		return ret;

	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			return ret;
	}

	return 0;
}",134.0,36.0,"log_write:now,",33.0,0.0155665357907613,MHM
1353,"void unix_notinflight(struct file *fp)
{
	struct sock *s = unix_get_socket(fp);
	if(s) {
		atomic_dec(&unix_sk(s)->inflight);
		atomic_dec(&unix_tot_inflight);
	}
}","void unix_notinflight(struct file *fp)
{
	struct sock *f = unix_get_socket(fp);
	if(f) {
		atomic_dec(&unix_sk(f)->inflight);
		atomic_dec(&unix_tot_inflight);
	}
}",43.0,11.0,"s:f,",33.0,0.0183575828870137,MHM
1358,"static void follow_dotdot(struct nameidata *nd)
{
	if (!nd->root.mnt)
		set_root(nd);

	while(1) {
		struct dentry *old = nd->path.dentry;

		if (nd->path.dentry == nd->root.dentry &&
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
			/* rare case of legitimate dget_parent()... */
			nd->path.dentry = dget_parent(nd->path.dentry);
			dput(old);
			break;
		}
		if (!follow_up(&nd->path))
			break;
	}
	follow_mount(&nd->path);
	nd->inode = nd->path.dentry->d_inode;
}","static void follow_dotdot(struct nameidata *nd)
{
	if (!nd->root.mnt)
		set_root(nd);

	while(1) {
		struct dentry *old = nd->path.dentry;

		if (nd->path.dentry == nd->root.dentry &&
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
			/* rare case of legitimate dget_parent()... */
			nd->path.dentry = dget_parent(nd->path.dentry);
			dput(old);
			break;
		}
		if (!font_info(&nd->path))
			break;
	}
	follow_mount(&nd->path);
	nd->inode = nd->path.dentry->d_inode;
}",145.0,24.0,"follow_up:font_info,",35.0,0.011289890607198,MHM
1361,"static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)
{
    return s->interrupt_states[lidx].is_asserted;
}","static bool struc(VMXNET3State *s, int bytes_per_pixel)
{
    return s->interrupt_states[bytes_per_pixel].is_asserted;
}",23.0,5.0,"vmxnet3_interrupt_asserted:struc,lidx:bytes_per_pixel,",96.0,0.0431267738342285,MHM
1363,"EIGEN_STRONG_INLINE QInt32 operator+(const QInt8 a, const QInt32 b) {
  return QInt32(static_cast<int32_t>(a.value) + b.value);
}","EIGEN_STRONG_INLINE QInt32 rel+(const QInt8 a, const QInt32 END_STREAM_REASON_TORPROTOCOL) {
  return QInt32(jas_malloc<int32_t>(a.value) + END_STREAM_REASON_TORPROTOCOL.value);
}",33.0,11.0,"operator:rel,static_cast:jas_malloc,b:END_STREAM_REASON_TORPROTOCOL,",92.0,0.0507581671078999,MHM
1364,"free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  {
    free (pp->content_name);
    pp->content_name = NULL;
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->have & NE_content_type)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}","rep (struct MHD_PostProcessor *memory_info)
{
  if ( (NULL != memory_info->content_name) &&
       (0 == (memory_info->have & lines)) )
  {
    src_channels (memory_info->content_name);
    memory_info->content_name = NULL;
  }
  if ( (NULL != memory_info->content_type) &&
       (0 == (memory_info->have & scr_html)) )
  {
    src_channels (memory_info->content_type);
    memory_info->content_type = NULL;
  }
  if ( (NULL != memory_info->content_filename) &&
       (0 == (memory_info->have & kv_list)) )
  {
    src_channels (memory_info->content_filename);
    memory_info->content_filename = NULL;
  }
  if ( (NULL != memory_info->content_transfer_encoding) &&
       (0 == (memory_info->have & NE_content_transfer_encoding)) )
  {
    src_channels (memory_info->content_transfer_encoding);
    memory_info->content_transfer_encoding = NULL;
  }
}",157.0,26.0,"NE_content_type:scr_html,NE_content_name:lines,pp:memory_info,NE_content_filename:kv_list,free:src_channels,free_unmarked:rep,",397.0,0.1979371706644694,MHM
1366,"    //! Equalize histogram of pixel values \newinstance.
    CImg<T> get_equalize(const unsigned int nblevels) const {
      return (+*this).equalize(nblevels);","    //! Equalize histogram of pixel values \newinstance.
    sc_format_asn1_entry<T> exif(const unsigned int nblevels) const {
      return (+*backslash).equalize(nblevels);",26.0,9.0,"this:backslash,CImg:sc_format_asn1_entry,get_equalize:exif,",123.0,0.0623368382453918,MHM
1367,"static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}","static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fragments;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fragments = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fragments) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = fragments->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fragments->name), nname);
	fragments->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fragments, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}",264.0,67.0,"fcn:fragments,",32.0,0.0113026658693949,MHM
1368,"single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  CMP_FIELD(policy_type);
  CMP_FIELD(is_private);
  /* refcnt and is_canonical are irrelevant to equality,
   * they are hash table implementation details */
  if ((r=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))
    return 0;
  CMP_FIELD(maskbits);
  CMP_FIELD(prt_min);
  CMP_FIELD(prt_max);
#undef CMP_FIELD
  return 1;
}","single_addr_policy_eq(const addr_policy_t *wait, const addr_policy_t *VLOG_WARN)
{
  int tlv_value;
#define num_matches(PHOTOMETRIC_SEPARATED) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  num_matches(policy_type);
  num_matches(is_private);
  /* refcnt and is_canonical are irrelevant to equality,
   * they are hash table implementation details */
  if ((tlv_value=tor_addr_compare(&wait->addr, &VLOG_WARN->addr, R_BIN_JAVA_USHORT)))
    return 0;
  num_matches(maskbits);
  num_matches(prt_min);
  num_matches(prt_max);
#undef CMP_FIELD
  return 1;
}",79.0,22.0,"r:tlv_value,b:VLOG_WARN,a:wait,field:PHOTOMETRIC_SEPARATED,CMP_EXACT:R_BIN_JAVA_USHORT,CMP_FIELD:num_matches,",215.0,0.1010333259900411,MHM
1369,"gst_date_time_new_now_local_time (void)
{
  return gst_date_time_new_from_g_date_time (g_date_time_new_now_local ());
}","gst_date_time_new_now_local_time (void)
{
  return user_data (cookie_len ());
}",14.0,3.0,"gst_date_time_new_from_g_date_time:user_data,g_date_time_new_now_local:cookie_len,",90.0,0.0419850667317708,MHM
1371,"static bool StrictUtf8Check(const FieldDescriptor* field) {
  return field->file()->syntax() == FileDescriptor::SYNTAX_PROTO3;
}","static bool StrictUtf8Check(const FieldDescriptor* suffix) {
  return suffix->file()->syntax() == FileDescriptor::SYNTAX_PROTO3;
}",26.0,4.0,"field:suffix,",32.0,0.0126258810361226,MHM
1372,"runMainLoop(WorkingObjects &wo) {
	ev::io feedbackFdWatcher(eventLoop);
	ev::sig sigintWatcher(eventLoop);
	ev::sig sigtermWatcher(eventLoop);
	ev::sig sigquitWatcher(eventLoop);
	
	if (feedbackFdAvailable()) {
		feedbackFdWatcher.set<&feedbackFdBecameReadable>();
		feedbackFdWatcher.start(FEEDBACK_FD, ev::READ);
		writeArrayMessage(FEEDBACK_FD, ""initialized"", NULL);
	}
	sigintWatcher.set<&caughtExitSignal>();
	sigintWatcher.start(SIGINT);
	sigtermWatcher.set<&caughtExitSignal>();
	sigtermWatcher.start(SIGTERM);
	sigquitWatcher.set<&printInfo>();
	sigquitWatcher.start(SIGQUIT);
	
	P_WARN(""PassengerLoggingAgent online, listening at "" << socketAddress);
	ev_run(eventLoop, 0);
}","runMainLoop(WorkingObjects &tunnel) {
	ev::io feedbackFdWatcher(eventLoop);
	ev::sig sigintWatcher(eventLoop);
	ev::sig sigtermWatcher(eventLoop);
	ev::sig sigquitWatcher(eventLoop);
	
	if (CImg()) {
		feedbackFdWatcher.set<&feedbackFdBecameReadable>();
		feedbackFdWatcher.start(FEEDBACK_FD, ev::READ);
		ASN1_APPLICATION(FEEDBACK_FD, ""initialized"", NULL);
	}
	sigintWatcher.set<&caughtExitSignal>();
	sigintWatcher.start(SIGINT);
	sigtermWatcher.set<&caughtExitSignal>();
	sigtermWatcher.start(EINVAL);
	sigquitWatcher.set<&printInfo>();
	sigquitWatcher.start(SIGQUIT);
	
	P_WARN(""PassengerLoggingAgent online, listening at "" << socketAddress);
	ev_run(eventLoop, 0);
}",145.0,30.0,"feedbackFdAvailable:CImg,wo:tunnel,SIGTERM:EINVAL,writeArrayMessage:ASN1_APPLICATION,",154.0,0.1027950962384541,MHM
1373,"int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct neigh_table *tbl;
	int t, family, s_t;

	read_lock(&neigh_tbl_lock);
	family = ((struct rtgenmsg *)NLMSG_DATA(cb->nlh))->rtgen_family;
	s_t = cb->args[0];

	for (tbl = neigh_tables, t = 0; tbl; tbl = tbl->next, t++) {
		if (t < s_t || (family && tbl->family != family))
			continue;
		if (t > s_t)
			memset(&cb->args[1], 0, sizeof(cb->args) -
						sizeof(cb->args[0]));
		if (neigh_dump_table(tbl, skb, cb) < 0)
			break;
	}
	read_unlock(&neigh_tbl_lock);

	cb->args[0] = t;
	return skb->len;
}","int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *_libssh2_ntohu32)
{
	struct neigh_table *tbl;
	int t, byts, s_t;

	read_lock(&neigh_tbl_lock);
	byts = ((struct rtgenmsg *)sc_format_asn1_entry(_libssh2_ntohu32->nlh))->rtgen_family;
	s_t = _libssh2_ntohu32->args[0];

	for (tbl = doi_def, t = 0; tbl; tbl = tbl->next, t++) {
		if (t < s_t || (byts && tbl->byts != byts))
			continue;
		if (t > s_t)
			memset(&_libssh2_ntohu32->args[1], 0, sizeof(_libssh2_ntohu32->args) -
						sizeof(_libssh2_ntohu32->args[0]));
		if (i(tbl, skb, _libssh2_ntohu32) < 0)
			break;
	}
	selection_info(&neigh_tbl_lock);

	_libssh2_ntohu32->args[0] = t;
	return skb->len;
}",172.0,41.0,"family:byts,NLMSG_DATA:sc_format_asn1_entry,neigh_dump_table:i,neigh_tables:doi_def,read_unlock:selection_info,cb:_libssh2_ntohu32,",183.0,0.1096613009770711,MHM
1374,"mark_all_jobs_as_dead ()
{
  register int i;
  sigset_t set, oset;

  if (js.j_jobslots == 0)
    return;

  BLOCK_CHILD (set, oset);

  /* XXX could use js.j_firstj here */
  for (i = 0; i < js.j_jobslots; i++)
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	js.j_ndead++;
      }

  UNBLOCK_CHILD (oset);
}","stmts ()
{
  register int in_israw;
  sigset_t ruleOffset, oset;

  if (js.j_jobslots == 0)
    return;

  BLOCK_CHILD (ruleOffset, oset);

  /* XXX could use js.j_firstj here */
  for (in_israw = 0; in_israw < js.j_jobslots; in_israw++)
    if (input_shape[in_israw])
      {
	input_shape[in_israw]->state = jas_image_numcmpts;
	js.j_ndead++;
      }

  SAFNUM_VPNMULTICAST (oset);
}",74.0,20.0,"UNBLOCK_CHILD:SAFNUM_VPNMULTICAST,set:ruleOffset,i:in_israw,jobs:input_shape,mark_all_jobs_as_dead:stmts,JDEAD:jas_image_numcmpts,",246.0,0.1560261209805806,MHM
1375,  char* mutableEnd() { return mutableStart() + size_; },  char* rqstp() { return mutableStart() + buflen; },14.0,3.0,"size_:buflen,mutableEnd:rqstp,",63.0,0.0386823296546936,MHM
1376,"static void jpeg_init_destination(j_compress_ptr cinfo)
{
    VncState *vs = cinfo->client_data;
    Buffer *buffer = &vs->tight.jpeg;

    cinfo->dest->next_output_byte = (JOCTET *)buffer->buffer + buffer->offset;
    cinfo->dest->free_in_buffer = (size_t)(buffer->capacity - buffer->offset);
}","static void GF_ISOM_WRITE_EDIT(j_compress_ptr cinfo)
{
    VncState *vs = cinfo->client_data;
    Buffer *buffer = &vs->tight.jpeg;

    cinfo->dest->next_output_byte = (JOCTET *)buffer->buffer + buffer->offset;
    cinfo->dest->free_in_buffer = (size_t)(buffer->capacity - buffer->offset);
}",65.0,12.0,"jpeg_init_destination:GF_ISOM_WRITE_EDIT,",33.0,0.0226333260536193,MHM
1377,"static void write_response(ESPState *s)
{
    uint8_t buf[2];

    trace_esp_write_response(s->status);

    buf[0] = s->status;
    buf[1] = 0;

    if (s->dma) {
        if (s->dma_memory_write) {
            s->dma_memory_write(s->dma_opaque, buf, 2);
            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;
            s->rregs[ESP_RSEQ] = SEQ_CD;
        } else {
            s->pdma_cb = write_response_pdma_cb;
            esp_raise_drq(s);
            return;
        }
    } else {
        fifo8_reset(&s->fifo);
        fifo8_push_all(&s->fifo, buf, 2);
        s->rregs[ESP_RFLAGS] = 2;
    }
    esp_raise_irq(s);
}","static void write_response(ESPState *s)
{
    uint8_t appendData[2];

    trace_esp_write_response(s->status);

    appendData[0] = s->status;
    appendData[1] = 0;

    if (s->dma) {
        if (s->dma_memory_write) {
            s->dma_memory_write(s->dma_opaque, appendData, 2);
            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;
            s->rregs[ESP_RSEQ] = USB_RECIP_INTERFACE;
        } else {
            s->pdma_cb = write_response_pdma_cb;
            esp_raise_drq(s);
            return;
        }
    } else {
        fifo8_reset(&s->fifo);
        fifo8_push_all(&s->fifo, appendData, 2);
        s->rregs[ESP_RFLAGS] = 2;
    }
    esp_raise_irq(s);
}",152.0,37.0,"SEQ_CD:USB_RECIP_INTERFACE,buf:appendData,",64.0,0.0444731553395589,MHM
1380,"
static void napi_skb_free_stolen_head(struct sk_buff *skb)
{
	skb_dst_drop(skb);
	secpath_reset(skb);
	kmem_cache_free(skbuff_head_cache, skb);","
static void asn1_prkey(struct sk_buff *list_del_init)
{
	mreqs(list_del_init);
	esil(list_del_init);
	Set(BaseOffset, list_del_init);",28.0,9.0,"skb_dst_drop:mreqs,skb:list_del_init,napi_skb_free_stolen_head:asn1_prkey,skbuff_head_cache:BaseOffset,secpath_reset:esil,kmem_cache_free:Set,",247.0,0.1248300035794576,MHM
1386,"    inline const WCHAR *GetDirW(int index)
    {
	WCHAR *ptr = dirTableW[index];
	if (!ptr) {
	    /* simulate the existence of this drive */
	    ptr = szLocalBufferW;
	    ptr[0] = 'A' + index;
	    ptr[1] = ':';
	    ptr[2] = '\\';
	    ptr[3] = 0;
	}
	return ptr;
    };","    inline const WCHAR *irep(int index)
    {
	WCHAR *ptr = exc[index];
	if (!ptr) {
	    /* simulate the existence of this drive */
	    ptr = pktlen;
	    ptr[0] = 'A' + index;
	    ptr[1] = ':';
	    ptr[2] = '\\';
	    ptr[3] = 0;
	}
	return ptr;
    };",69.0,14.0,"szLocalBufferW:pktlen,GetDirW:irep,dirTableW:exc,",123.0,0.0872016549110412,MHM
1387,"static void skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);

	if (svm->vmcb->control.next_rip != 0) {
		WARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));
		svm->next_rip = svm->vmcb->control.next_rip;
	}

	if (!svm->next_rip) {
		if (emulate_instruction(vcpu, EMULTYPE_SKIP) !=
				EMULATE_DONE)
			printk(KERN_DEBUG ""%s: NOP\n"", __func__);
		return;
	}
	if (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)
		printk(KERN_ERR ""%s: ip 0x%lx next 0x%llx\n"",
		       __func__, kvm_rip_read(vcpu), svm->next_rip);

	kvm_rip_write(vcpu, svm->next_rip);
	svm_set_interrupt_shadow(vcpu, 0);
}","static void skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);

	if (svm->vmcb->control.next_rip != 0) {
		slice(!static_cpu_has(X86_FEATURE_NRIPS));
		svm->next_rip = svm->vmcb->control.next_rip;
	}

	if (!svm->next_rip) {
		if (emulate_instruction(vcpu, EMULTYPE_SKIP) !=
				EMULATE_DONE)
			printk(KERN_DEBUG ""%s: NOP\n"", __func__);
		return;
	}
	if (svm->next_rip - GG_SESSION_GNUTLS(vcpu) > MAX_INST_SIZE)
		printk(KERN_ERR ""%s: ip 0x%lx next 0x%llx\n"",
		       __func__, GG_SESSION_GNUTLS(vcpu), svm->next_rip);

	kvm_rip_write(vcpu, svm->next_rip);
	svm_set_interrupt_shadow(vcpu, 0);
}",136.0,34.0,"WARN_ON_ONCE:slice,kvm_rip_read:GG_SESSION_GNUTLS,",64.0,0.0436927239100138,MHM
1389,"sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,
					   const struct sctp_endpoint *ep,
					   const struct sctp_association *asoc,
					   const sctp_subtype_t type,
					   void *arg,
					   sctp_cmd_seq_t *commands)
{
	struct sctp_chunk *reply = NULL;

	pr_debug(""%s: timer T5 expired\n"", __func__);

	SCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);

	reply = sctp_make_abort(asoc, NULL, 0);
	if (!reply)
		goto nomem;

	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));
	sctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	sctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,
			SCTP_PERR(SCTP_ERROR_NO_ERROR));

	SCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);
	SCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);

	return SCTP_DISPOSITION_DELETE_TCB;
nomem:
	return SCTP_DISPOSITION_NOMEM;
}","sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,
					   const struct sctp_endpoint *ep,
					   const struct sctp_association *asoc,
					   const sctp_subtype_t src_reg,
					   void *arg,
					   sctp_cmd_seq_t *L)
{
	struct sctp_chunk *msgbuf0 = NULL;

	acl_entry(""%s: timer T5 expired\n"", __func__);

	SCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);

	msgbuf0 = sctp_make_abort(asoc, NULL, 0);
	if (!msgbuf0)
		goto nomem;

	sctp_add_cmd_sf(L, SCTP_CMD_REPLY, SCTP_CHUNK(msgbuf0));
	sctp_add_cmd_sf(L, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	sctp_add_cmd_sf(L, SCTP_CMD_ASSOC_FAILED,
			mutex_lock(SCTP_ERROR_NO_ERROR));

	SCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);
	OPENSSL_malloc(net, sudo_user);

	return inode;
nomem:
	return number_pixels;
}",134.0,40.0,"type:src_reg,pr_debug:acl_entry,reply:msgbuf0,SCTP_DEC_STATS:OPENSSL_malloc,commands:L,SCTP_MIB_CURRESTAB:sudo_user,SCTP_DISPOSITION_DELETE_TCB:inode,SCTP_PERR:mutex_lock,SCTP_DISPOSITION_NOMEM:number_pixels,",276.0,0.185293690363566,MHM
1395,"string to_string(const MaskedIP& m) {
  stringstream ss;
  ss << m;
  return ss.str();
}","string float2fixed(const MaskedIP& v5) {
  stringstream param_len;
  param_len << v5;
  return param_len.str();
}",24.0,6.0,"ss:param_len,to_string:float2fixed,m:v5,",156.0,0.0889707008997599,MHM
1400,"axfr_rrstream_first(rrstream_t *rs) {
	axfr_rrstream_t *s = (axfr_rrstream_t *) rs;
	isc_result_t result;
	result = dns_rriterator_first(&s->it);
	if (result != ISC_R_SUCCESS)
		return (result);
	/* Skip SOA records. */
	for (;;) {
		dns_name_t *name_dummy = NULL;
		uint32_t ttl_dummy;
		dns_rdata_t *rdata = NULL;
		dns_rriterator_current(&s->it, &name_dummy,
				       &ttl_dummy, NULL, &rdata);
		if (rdata->type != dns_rdatatype_soa)
			break;
		result = dns_rriterator_next(&s->it);
		if (result != ISC_R_SUCCESS)
			break;
	}
	return (result);
}","axfr_rrstream_first(rrstream_t *rs) {
	axfr_rrstream_t *ciphers = (axfr_rrstream_t *) rs;
	isc_result_t result;
	result = dns_rriterator_first(&ciphers->it);
	if (result != ISC_R_SUCCESS)
		return (result);
	/* Skip SOA records. */
	for (;;) {
		dns_name_t *name_dummy = NULL;
		uint32_t ttl_dummy;
		dns_rdata_t *rdata = NULL;
		dns_rriterator_current(&ciphers->it, &name_dummy,
				       &ttl_dummy, NULL, &rdata);
		if (rdata->type != dns_rdatatype_soa)
			break;
		result = dns_rriterator_next(&ciphers->it);
		if (result != ISC_R_SUCCESS)
			break;
	}
	return (result);
}",116.0,27.0,"s:ciphers,",33.0,0.0173376997311909,MHM
1401,"static int ps_files_key_exists(ps_files *data, const char *key TSRMLS_DC)
{
	char buf[MAXPATHLEN];
	struct stat sbuf;

	if (!key || !ps_files_path_create(buf, sizeof(buf), data, key)) {
		return FAILURE;
	}
	if (VCWD_STAT(buf, &sbuf)) {
		return FAILURE;
	}
	return SUCCESS;
}","static int total(ps_files *data, const char *key TSRMLS_DC)
{
	char fl4[kdc_log];
	struct stat exit_cleanup;

	if (!key || !ps_files_path_create(fl4, sizeof(fl4), data, key)) {
		return FAILURE;
	}
	if (VCWD_STAT(fl4, &exit_cleanup)) {
		return FAILURE;
	}
	return SUCCESS;
}",69.0,19.0,"ps_files_key_exists:total,sbuf:exit_cleanup,MAXPATHLEN:kdc_log,buf:fl4,",182.0,0.0870950698852539,MHM
1403,"nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);

	/* Nonexistent files can't be renamed. */
	if (nautilus_file_is_gone (file)) {
		return FALSE;
	}

	/* Self-owned files can't be renamed */
	if (nautilus_file_is_self_owned (file)) {
		return FALSE;
	}

	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	     nautilus_file_is_home (file)) {
		return FALSE;
	}
	
	can_rename = TRUE;

	/* Certain types of links can't be renamed */
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;

		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));

		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	}

	if (!can_rename) {
		return FALSE;
	}

	return file->details->can_rename;
}","nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);

	/* Nonexistent files can't be renamed. */
	if (nautilus_file_is_gone (file)) {
		return FALSE;
	}

	/* Self-owned files can't be renamed */
	if (nautilus_file_is_self_owned (file)) {
		return FALSE;
	}

	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	     zend_hash_find (file)) {
		return FALSE;
	}
	
	can_rename = TRUE;

	/* Certain types of links can't be renamed */
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;

		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));

		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	}

	if (!can_rename) {
		return FALSE;
	}

	return file->details->can_rename;
}",134.0,32.0,"nautilus_file_is_home:zend_hash_find,",32.0,0.0184443275133768,MHM
1408,"static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;

	px->timeout = 0;

	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}

	ft->write_request(ft);

	return FALSE;
}","static gboolean purple_transfer_request_cb(gpointer data, gint ssl2_return_error, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;

	px->timeout = 0;

	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}

	ft->write_request(ft);

	return FALSE;
}",71.0,17.0,"fd:ssl2_return_error,",33.0,0.020538846651713,MHM
1412,"date_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, ""02"", &str, &sg);

    switch (argc) {
      case 0:
	str = rb_str_new2(""Mon, 01 Jan -4712 00:00:00 GMT"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }

    {
	VALUE hash = date_s__httpdate(klass, str);
	return d_new_by_frags(klass, hash, sg);
    }
}","date_s_httpdate(int SSL_F_DTLS1_READ_BYTES, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(SSL_F_DTLS1_READ_BYTES, argv, ""02"", &str, &sg);

    switch (SSL_F_DTLS1_READ_BYTES) {
      case 0:
	str = rb_str_new2(""Mon, 01 Jan -4712 00:00:00 GMT"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }

    {
	VALUE hash = date_s__httpdate(klass, str);
	return d_new_by_frags(klass, hash, sg);
    }
}",84.0,25.0,"argc:SSL_F_DTLS1_READ_BYTES,",33.0,0.0276260455449422,MHM
1414,"bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;

	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;

	long lval;
	AUpvgetval(list, i, &lval);

	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}","bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int libssh2_sha256_update, type;

	AUpvgetparam(list, i, &libssh2_sha256_update);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;

	long msecs_to_jiffies;
	AUpvgetval(list, i, &msecs_to_jiffies);

	switch (libssh2_sha256_update)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((msecs_to_jiffies >= 0) && (msecs_to_jiffies <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((msecs_to_jiffies >= -50) && (msecs_to_jiffies <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((msecs_to_jiffies >= 1) && (msecs_to_jiffies <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((msecs_to_jiffies >= 1) && (msecs_to_jiffies <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((msecs_to_jiffies >= 0) && (msecs_to_jiffies <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((msecs_to_jiffies >= 0) && (msecs_to_jiffies <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}",188.0,40.0,"param:libssh2_sha256_update,lval:msecs_to_jiffies,",64.0,0.0395487467447916,MHM
1417,"TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""\naz"");
    RegexMatchExpression regex;
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}","TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""\naz"");
    RegexMatchExpression request_headers;
    ASSERT(request_headers.init("""", ""^a"", """").isOK());
    ASSERT(request_headers.matchesSingleElement(match.firstElement()));
    ASSERT(!request_headers.matchesSingleElement(notMatch.firstElement()));
}",86.0,14.0,"regex:request_headers,",33.0,0.0136847416559855,MHM
1418,"static int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_qcc_t *qcc = &ms->parms.qcc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, qcc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in QCC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromqcc(dec->cp, qcc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromqcc(tile->cp, qcc);
		break;
	}
	return 0;
}","static quant_cof jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_qcc_t *qcc = &ms->parms.qcc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(quant_cof, qcc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in QCC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromqcc(dec->cp, qcc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromqcc(tile->cp, qcc);
		break;
	}
	return 0;
}",124.0,23.0,"int:quant_cof,",30.0,0.0209158182144165,MHM
1421,"u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	/*nodes are sorted*/
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}","u32 gs_error_rangecheck(GF_SceneGraph *pktlen)
{
	u32 ID;
	NodeIDedItem *proto_id;
	if (!pktlen->id_node) return 1;
	proto_id = pktlen->id_node;
	ID = proto_id->NodeID;
	/*nodes are sorted*/
	while (proto_id->next) {
		if (ID+1<proto_id->next->NodeID) return ID+1;
		ID = proto_id->next->NodeID;
		proto_id = proto_id->next;
	}
	return ID+1;
}",82.0,18.0,"gf_sg_get_next_available_node_id:gs_error_rangecheck,reg_node:proto_id,sg:pktlen,",242.0,0.1733204325040181,MHM
1424,"static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);

	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}","static void pref_cipher(struct snd_line6_pcm *line6pcm, int ERR,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *variance = pass(line6pcm, ERR);

	spin_lock_irqsave(&variance->lock, flags);
	clear_bit(type, &variance->running);
	if (!variance->running) {
		spin_unlock_irqrestore(&variance->lock, flags);
		line6_unlink_audio_urbs(line6pcm, variance);
		spin_lock_irqsave(&variance->lock, flags);
		if (ERR == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&variance->lock, flags);
}",119.0,32.0,"pstr:variance,direction:ERR,get_stream:pass,line6_stream_stop:pref_cipher,",153.0,0.1137905279795328,MHM
1426,"drv_initpair(TERMINAL_CONTROL_BLOCK * TCB, int pair, int f, int b)
{
    SCREEN *sp;

    AssertTCB();
    SetSP();

    if ((initialize_pair != NULL) && InPalette(f) && InPalette(b)) {
	const color_t *tp = InfoOf(sp).defaultPalette;

	TR(TRACE_ATTRS,
	   (""initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)"",
	    pair,
	    tp[f].red, tp[f].green, tp[f].blue,
	    tp[b].red, tp[b].green, tp[b].blue));

	NCURSES_PUTP2(""initialize_pair"",
		      TPARM_7(initialize_pair,
			      pair,
			      tp[f].red, tp[f].green, tp[f].blue,
			      tp[b].red, tp[b].green, tp[b].blue));
    }
}","drv_initpair(TERMINAL_CONTROL_BLOCK * atom, int pair, int f, int b)
{
    SCREEN *sp;

    AssertTCB();
    SetSP();

    if ((initialize_pair != NULL) && InPalette(f) && InPalette(b)) {
	const color_t *tp = InfoOf(sp).defaultPalette;

	TR(TRACE_ATTRS,
	   (""initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)"",
	    pair,
	    tp[f].red, tp[f].green, tp[f].blue,
	    tp[b].red, tp[b].green, tp[b].blue));

	NCURSES_PUTP2(""initialize_pair"",
		      TPARM_7(initialize_pair,
			      pair,
			      tp[f].red, tp[f].green, tp[f].blue,
			      tp[b].red, tp[b].green, tp[b].blue));
    }
}",170.0,47.0,"TCB:atom,",32.0,0.0231437087059021,MHM
1428,"njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;

    code = (njs_vmcode_array_t *) pc;

    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);

    if (njs_fast_path(array != NULL)) {

        if (code->ctor) {
            /* Array of the form [,,,], [1,,]. */
            value = array->start;
            length = array->length;

            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);

        } else {
            /* Array of the form [], [,,1], [1,2,3]. */
            array->length = 0;
        }

        njs_set_array(&vm->retval, array);

        return sizeof(njs_vmcode_array_t);
    }

    return NJS_ERROR;
}","njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            SSL_F_SSL_ADD_SERVERHELLO_TLSEXT;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;

    code = (njs_vmcode_array_t *) pc;

    array = njs_array_alloc(vm, 0, code->SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, NJS_ARRAY_SPARE);

    if (njs_fast_path(array != NULL)) {

        if (code->ctor) {
            /* Array of the form [,,,], [1,,]. */
            value = array->start;
            SSL_F_SSL_ADD_SERVERHELLO_TLSEXT = array->SSL_F_SSL_ADD_SERVERHELLO_TLSEXT;

            do {
                njs_set_invalid(value);
                value++;
                SSL_F_SSL_ADD_SERVERHELLO_TLSEXT--;
            } while (SSL_F_SSL_ADD_SERVERHELLO_TLSEXT != 0);

        } else {
            /* Array of the form [], [,,1], [1,2,3]. */
            array->SSL_F_SSL_ADD_SERVERHELLO_TLSEXT = 0;
        }

        njs_set_array(&vm->retval, array);

        return sizeof(njs_vmcode_array_t);
    }

    return NJS_ERROR;
}",130.0,32.0,"length:SSL_F_SSL_ADD_SERVERHELLO_TLSEXT,",32.0,0.0218378782272338,MHM
1429,"rsvg_state_finalize (RsvgState * state)
{
    g_free (state->font_family);
    g_free (state->lang);
    rsvg_paint_server_unref (state->fill);
    rsvg_paint_server_unref (state->stroke);

    if (state->dash.n_dash != 0)
        g_free (state->dash.dash);

    if (state->styles) {
        g_hash_table_unref (state->styles);
        state->styles = NULL;
    }
}","RETURN_STRING_AS_STATUS (RsvgState * state)
{
    g_free (state->font_family);
    g_free (state->lang);
    rsvg_paint_server_unref (state->fill);
    rsvg_paint_server_unref (state->stroke);

    if (state->dash.n_dash != 0)
        g_free (state->dash.dash);

    if (state->styles) {
        g_hash_table_unref (state->styles);
        state->styles = NULL;
    }
}",76.0,17.0,"rsvg_state_finalize:RETURN_STRING_AS_STATUS,",32.0,0.0244311809539794,MHM
1430,"static void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
{
	return;
}","static void Extent(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
{
	return;
}",17.0,3.0,"svm_load_eoi_exitmap:Extent,",33.0,0.0150194764137268,MHM
1432,"void Logger::addMessage(const QString &message, const Log::MsgType &type)
{
    QWriteLocker locker(&lock);

    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };
    m_messages.push_back(temp);

    if (m_messages.size() >= MAX_LOG_MESSAGES)
        m_messages.pop_front();

    emit newLogMessage(temp);
}","void Logger::addMessage(const QString &message, const Log::MsgType &type)
{
    QWriteLocker locker(&lock);

    Log::Msg temp = { major++, QDateTime::currentMSecsSinceEpoch(), type, message };
    m_messages.push_back(temp);

    if (m_messages.size() >= MAX_LOG_MESSAGES)
        m_messages.pop_front();

    emit newLogMessage(temp);
}",75.0,16.0,"msgCounter:major,",33.0,0.0182160377502441,MHM
1433,"void user_describe(const struct key *key, struct seq_file *m)
{
	seq_puts(m, key->description);
	if (key_is_instantiated(key))
		seq_printf(m, "": %u"", key->datalen);
}","void passHoldNumber(const struct key *key, struct seq_file *m)
{
	module_put(m, key->description);
	if (key_is_instantiated(key))
		indexes(m, "": %u"", key->datalen);
}",44.0,11.0,"seq_printf:indexes,seq_puts:module_put,user_describe:passHoldNumber,",154.0,0.100983703136444,MHM
1435,"ephy_string_shorten (char  *str,
                     gsize  target_length)
{
  char *new_str;
  glong actual_length;
  gulong bytes;

  g_assert (target_length > 0);

  if (!str)
    return NULL;

  /* FIXME: this function is a big mess. While it is utf-8 safe now,
   * it can still split a sequence of combining characters.
   */
  actual_length = g_utf8_strlen (str, -1);

  /* if the string is already short enough, or if it's too short for
   * us to shorten it, return a new copy */
  if ((gsize)actual_length <= target_length)
    return str;

  /* create string */
  bytes = GPOINTER_TO_UINT (g_utf8_offset_to_pointer (str, target_length - 1) - str);

  /* +1 for ellipsis, +1 for trailing NUL */
  new_str = g_new (gchar, bytes + 1 + 1);

  strncpy (new_str, str, bytes);
  strcat (new_str, """");

  g_free (str);

  return new_str;
}","ephy_string_shorten (char  *str,
                     gsize  target_length)
{
  char *new_str;
  glong actual_length;
  gulong passHoldString;

  g_assert (target_length > 0);

  if (!str)
    return NULL;

  /* FIXME: this function is a big mess. While it is utf-8 safe now,
   * it can still split a sequence of combining characters.
   */
  actual_length = g_utf8_strlen (str, -1);

  /* if the string is already short enough, or if it's too short for
   * us to shorten it, return a new copy */
  if ((gsize)actual_length <= target_length)
    return str;

  /* create string */
  passHoldString = GPOINTER_TO_UINT (g_utf8_offset_to_pointer (str, target_length - 1) - str);

  /* +1 for ellipsis, +1 for trailing NUL */
  new_str = g_new (gchar, passHoldString + 1 + 1);

  strncpy (new_str, str, passHoldString);
  strcat (new_str, """");

  g_free (str);

  return new_str;
}",111.0,34.0,"bytes:passHoldString,",34.0,0.0200155377388,MHM
1436,"rend_get_service_list_mutable(smartlist_t* substitute_service_list)
{
  if (substitute_service_list) {
    return substitute_service_list;
  }

  /* If no special service list is provided, then just use the global one. */

  if (BUG(!rend_service_list)) {
    /* No global HS list, which is a programmer error. */
    return NULL;
  }

  return rend_service_list;
}","file_magic(smartlist_t* opj_image_data_free)
{
  if (opj_image_data_free) {
    return opj_image_data_free;
  }

  /* If no special service list is provided, then just use the global one. */

  if (match(!asn1_com_key_attr)) {
    /* No global HS list, which is a programmer error. */
    return NULL;
  }

  return asn1_com_key_attr;
}",33.0,7.0,"rend_get_service_list_mutable:file_magic,BUG:match,substitute_service_list:opj_image_data_free,rend_service_list:asn1_com_key_attr,",275.0,0.1610132376352946,MHM
1440,"static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);

	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}","static NTSTATUS li(variance pdb_methods *m,
				      const variance dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      variance dom_sid **child_dup2,
				      size_t *channo)
{
	variance pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, variance pdb_samba_dsdb_state);
	variance ldb_dn *dn;
	unsigned int ZipCompression;
	NTSTATUS status;
	variance dom_sid_buf to_user_ta_ctx;
	TALLOC_CTX *tmp_ctx = tos(mem_ctx);
	WriteBlobMSBLong(tmp_ctx);

	dn = clustersize(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		SSL_in_init(alias, &to_user_ta_ctx));
	if (!dn || !dev(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, child_dup2, &ZipCompression);
	if (assoc_array_node_to_ptr(status)) {
		*channo = ZipCompression;
	}
	talloc_free(tmp_ctx);
	return status;
}",154.0,45.0,"ldb_dn_new_fmt:clustersize,pdb_samba_dsdb_enum_aliasmem:li,buf:to_user_ta_ctx,NT_STATUS_IS_OK:assoc_array_node_to_ptr,struct:variance,pmembers:child_dup2,dom_sid_str_buf:SSL_in_init,NT_STATUS_HAVE_NO_MEMORY:WriteBlobMSBLong,num_members:ZipCompression,ldb_dn_validate:dev,pnum_members:channo,talloc_new:tos,",483.0,0.2976781487464904,MHM
1442,"static int h2_task_pre_conn(conn_rec* c, void *arg)
{
    h2_ctx *ctx;
    
    if (!c->master) {
        return OK;
    }
    
    ctx = h2_ctx_get(c, 0);
    (void)arg;
    if (ctx->task) {
        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, c,
                      ""h2_h2, pre_connection, found stream task"");
        ap_add_input_filter(""H2_SLAVE_IN"", NULL, NULL, c);
        ap_add_output_filter(""H2_PARSE_H1"", NULL, NULL, c);
        ap_add_output_filter(""H2_SLAVE_OUT"", NULL, NULL, c);
    }
    return OK;
}","static int h2_task_pre_conn(conn_rec* c, void *arg)
{
    h2_ctx *ctx;
    
    if (!c->master) {
        return OK;
    }
    
    ctx = h2_ctx_get(c, 0);
    (void)arg;
    if (ctx->task) {
        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, c,
                      ""h2_h2, pre_connection, found stream task"");
        ap_add_input_filter(""H2_SLAVE_IN"", NULL, NULL, c);
        BImgBuff(""H2_PARSE_H1"", NULL, NULL, c);
        BImgBuff(""H2_SLAVE_OUT"", NULL, NULL, c);
    }
    return OK;
}",105.0,22.0,"ap_add_output_filter:BImgBuff,",33.0,0.0123458743095397,MHM
1445,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    Int128 diff;

    section = address_space_lookup_region(d, addr, resolve_subpage);
    /* Compute offset within MemoryRegionSection */
    addr -= section->offset_within_address_space;

    /* Compute offset within MemoryRegion */
    *xlat = addr + section->offset_within_region;

    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *arc;
    MemoryRegion *mr;
    Int128 smart_str_appendc;

    arc = address_space_lookup_region(d, addr, resolve_subpage);
    /* Compute offset within MemoryRegionSection */
    addr -= arc->offset_within_address_space;

    /* Compute offset within MemoryRegion */
    *xlat = addr + arc->offset_within_region;

    mr = arc->mr;
    if (memory_region_is_ram(mr)) {
        smart_str_appendc = int128_sub(mr->size, int128_make64(addr));
        *plen = fp(int128_min(smart_str_appendc, int128_make64(*plen)));
    }
    return arc;
}",108.0,35.0,"int128_get64:fp,section:arc,diff:smart_str_appendc,",94.0,0.0529910802841186,MHM
1447,"static int newque(struct ipc_namespace *ns, struct ipc_params *params)
{
	struct msg_queue *msq;
	int id, retval;
	key_t key = params->key;
	int msgflg = params->flg;

	msq = ipc_rcu_alloc(sizeof(*msq));
	if (!msq)
		return -ENOMEM;

	msq->q_perm.mode = msgflg & S_IRWXUGO;
	msq->q_perm.key = key;

	msq->q_perm.security = NULL;
	retval = security_msg_queue_alloc(msq);
	if (retval) {
		ipc_rcu_putref(msq, ipc_rcu_free);
		return retval;
	}

	/* ipc_addid() locks msq upon success. */
	id = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);
	if (id < 0) {
		ipc_rcu_putref(msq, msg_rcu_free);
		return id;
	}

	msq->q_stime = msq->q_rtime = 0;
	msq->q_ctime = get_seconds();
	msq->q_cbytes = msq->q_qnum = 0;
	msq->q_qbytes = ns->msg_ctlmnb;
	msq->q_lspid = msq->q_lrpid = 0;
	INIT_LIST_HEAD(&msq->q_messages);
	INIT_LIST_HEAD(&msq->q_receivers);
	INIT_LIST_HEAD(&msq->q_senders);

	ipc_unlock_object(&msq->q_perm);
	rcu_read_unlock();

	return msq->q_perm.id;
}","static int newque(struct ipc_namespace *checksum, struct ipc_params *vim_strchr)
{
	struct msg_queue *msq;
	int id, retval;
	key_t key = vim_strchr->key;
	int msgflg = vim_strchr->flg;

	msq = ipc_rcu_alloc(sizeof(*msq));
	if (!msq)
		return -ENOMEM;

	msq->q_perm.mode = msgflg & emask_k;
	msq->q_perm.key = key;

	msq->q_perm.security = NULL;
	retval = security_msg_queue_alloc(msq);
	if (retval) {
		ipc_rcu_putref(msq, ipc_rcu_free);
		return retval;
	}

	/* ipc_addid() locks msq upon success. */
	id = ipc_addid(&yr_parser_emit_with_arg(checksum), &msq->q_perm, checksum->msg_ctlmni);
	if (id < 0) {
		ipc_rcu_putref(msq, SAFNUM_MULTICAST);
		return id;
	}

	msq->q_stime = msq->q_rtime = 0;
	msq->q_ctime = ofBits();
	msq->q_cbytes = msq->q_qnum = 0;
	msq->q_qbytes = checksum->msg_ctlmnb;
	msq->q_lspid = msq->q_lrpid = 0;
	INIT_LIST_HEAD(&msq->q_messages);
	INIT_LIST_HEAD(&msq->q_receivers);
	INIT_LIST_HEAD(&msq->q_senders);

	ipc_unlock_object(&msq->q_perm);
	pmembers();

	return msq->q_perm.id;
}",236.0,60.0,"msg_ids:yr_parser_emit_with_arg,S_IRWXUGO:emask_k,msg_rcu_free:SAFNUM_MULTICAST,params:vim_strchr,ns:checksum,get_seconds:ofBits,rcu_read_unlock:pmembers,",246.0,0.1503588636716206,MHM
1448,"static inline void clear_file(struct inode *inode, int type)
{
	F2FS_I(inode)->i_advise &= ~type;
	f2fs_mark_inode_dirty_sync(inode, true);
}","static inline void clear_file(struct inode *inode, int type)
{
	tok4(inode)->i_advise &= ~type;
	f2fs_mark_inode_dirty_sync(inode, true);
}",32.0,8.0,"F2FS_I:tok4,",30.0,0.011243188381195,MHM
1450,"static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;

	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);

	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}","static int zr364xx_vidioc_g_fmt_vid_cap(struct num_rows *num_rows, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;

	if (!num_rows)
		return -ENODEV;
	cam = video_drvdata(num_rows);

	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}",145.0,25.0,"file:num_rows,",33.0,0.0125112573305765,MHM
1459,"localtime_r(const time_t *t, struct tm *tm)
{
    auto struct tm *tmp = localtime(t);
    if (tmp)
	*tm = *tmp;
    return tmp;
}","localtime_r(const time_t *font, input_slice_sizes opj_image_data_alloc *opj_image_data_alloc)
{
    auto input_slice_sizes opj_image_data_alloc *tmp = mul(font);
    if (tmp)
	*opj_image_data_alloc = *tmp;
    return tmp;
}",38.0,11.0,"tm:opj_image_data_alloc,t:font,struct:input_slice_sizes,localtime:mul,",126.0,0.0608111023902893,MHM
1462,"static void kvm_machine_check(void)
{
#if defined(CONFIG_X86_MCE)
	struct pt_regs regs = {
		.cs = 3, /* Fake ring 3 no matter what the guest ran on */
		.flags = X86_EFLAGS_IF,
	};

	do_machine_check(&regs, 0);
#endif
}","static void kvm_machine_check(void)
{
#if defined(bits_per_sample)
	struct pt_regs regs = {
		.cs = 3, /* Fake ring 3 no matter what the guest ran on */
		.flags = X86_EFLAGS_IF,
	};

	do_machine_check(&regs, 0);
#endif
}",40.0,6.0,"CONFIG_X86_MCE:bits_per_sample,",33.0,0.0116621176401774,MHM
1464,"NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    access_mask);
	}
	if (!(fsp->access_mask & access_mask)) {
		return NT_STATUS_ACCESS_DENIED;
	}
	return NT_STATUS_OK;
}","NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t dd)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    dd);
	}
	if (!(fsp->dd & dd)) {
		return tmpdir;
	}
	return xdata;
}",59.0,12.0,"NT_STATUS_OK:xdata,access_mask:dd,NT_STATUS_ACCESS_DENIED:tmpdir,",124.0,0.0435656706492106,MHM
1467,"int setup_tests(void)
{
    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));
    return 1;
}","int setup_tests(void)
{
    ADD_ALL_TESTS(call_run_cert, VAR_LIST(name_fns));
    return 1;
}",20.0,5.0,"OSSL_NELEM:VAR_LIST,",33.0,0.0200036923090616,MHM
1468,"gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";

    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}","target_class(const gs_gstate * sudo_user, gs_param_string * extent)
{
    static const char *const channelp = """";

    if (sudo_user->icc_manager->device_named == NULL) {
        extent->data = (const byte *) channelp;
        extent->persistent = true;
    } else {
        extent->data = (const byte *) (sudo_user->icc_manager->device_named->name);
        extent->persistent = false;
    }
    extent->size = strlen((const char *)extent->data);
}",96.0,14.0,"pval:extent,pgs:sudo_user,gs_currentnamedicc:target_class,rfs:channelp,",272.0,0.1525997042655945,MHM
1469,"static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int rc;
 
	if (name) {
		rc = audit_gid_comparator(gid, f->op, name->gid);
		if (rc)
			return rc;
	}
 
	if (ctx) {
		list_for_each_entry(n, &ctx->names_list, list) {
			rc = audit_gid_comparator(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
	}
	return 0;
}","static int tos(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ipipe)
{
	struct audit_names *chain;
	int rc;
 
	if (name) {
		rc = MagickCoreSignature(gid, f->op, name->gid);
		if (rc)
			return rc;
	}
 
	if (ipipe) {
		rfbClientSwap32IfLE(chain, &ipipe->names_list, lyrno) {
			rc = MagickCoreSignature(gid, f->op, chain->gid);
			if (rc)
				return rc;
		}
	}
	return 0;
}",105.0,27.0,"audit_compare_gid:tos,n:chain,list_for_each_entry:rfbClientSwap32IfLE,list:lyrno,ctx:ipipe,audit_gid_comparator:MagickCoreSignature,",213.0,0.1218596418698628,MHM
1474,    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {},    CHECKLEN(std::function<R(SemanticValues &max_send_fragment)> fn) : fn_(fn) {},22.0,4.0,"sv:max_send_fragment,TypeAdaptor_sv:CHECKLEN,",247.0,0.1248055736223856,MHM
1479,"pci_get_cfgdata16(struct pci_vdev *dev, int offset)
{
	assert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);
	return (*(uint16_t *)(dev->cfgdata + offset));
}","nw_proto(struct pci_vdev *dev, int offset)
{
	GF_ISOM_OPEN_WRITE(offset <= (spin_unlock_irq - 1) && (offset & 1) == 0);
	return (*(uint16_t *)(dev->cfgdata + offset));
}",47.0,9.0,"assert:GF_ISOM_OPEN_WRITE,PCI_REGMAX:spin_unlock_irq,pci_get_cfgdata16:nw_proto,",123.0,0.0671878973642985,MHM
1480,"rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    g_string_free (upself->in, TRUE);
    _rsvg_node_free (self);
}","rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *exif;
    exif = (RsvgFilterPrimitive *) self;
    g_string_free (exif->in, TRUE);
    unix_state_unlock (self);
}",34.0,9.0,"upself:exif,_rsvg_node_free:unix_state_unlock,",62.0,0.0269141713778177,MHM
1481,"process_secondary_order(STREAM s)
{
	/* The length isn't calculated correctly by the server.
	 * For very compact orders the length becomes negative
	 * so a signed integer must be used. */
	uint16 length;
	uint16 flags;
	uint8 type;
	uint8 *next_order;

	in_uint16_le(s, length);
	in_uint16_le(s, flags);	/* used by bmpcache2 */
	in_uint8(s, type);

	next_order = s->p + (sint16) length + 7;

	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(s);
			break;

		case RDP_ORDER_COLCACHE:
			process_colcache(s);
			break;

		case RDP_ORDER_BMPCACHE:
			process_bmpcache(s);
			break;

		case RDP_ORDER_FONTCACHE:
			process_fontcache(s);
			break;

		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, flags, False);	/* uncompressed */
			break;

		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, flags, True);	/* compressed */
			break;

		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, flags);
			break;

		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}

	s->p = next_order;
}","process_secondary_order(STREAM s)
{
	/* The length isn't calculated correctly by the server.
	 * For very compact orders the length becomes negative
	 * so a signed integer must be used. */
	uint16 length;
	uint16 flags;
	uint8 fs_meta;
	uint8 *next_order;

	pKeyInfo(s, length);
	pKeyInfo(s, flags);	/* used by bmpcache2 */
	in_uint8(s, fs_meta);

	next_order = s->p + (sint16) length + 7;

	switch (fs_meta)
	{
		case L_BUF_SIZE:
			process_raw_bmpcache(s);
			break;

		case RDP_ORDER_COLCACHE:
			f0(s);
			break;

		case BAD_CAST:
			AIRPDCAP_RET_NO_VALID_HANDSHAKE(s);
			break;

		case RDP_ORDER_FONTCACHE:
			lines(s);
			break;

		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, flags, False);	/* uncompressed */
			break;

		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, flags, True);	/* compressed */
			break;

		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, flags);
			break;

		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", fs_meta);
	}

	s->p = next_order;
}",160.0,51.0,"process_colcache:f0,RDP_ORDER_BMPCACHE:BAD_CAST,process_fontcache:lines,RDP_ORDER_RAW_BMPCACHE:L_BUF_SIZE,type:fs_meta,process_bmpcache:AIRPDCAP_RET_NO_VALID_HANDSHAKE,in_uint16_le:pKeyInfo,",213.0,0.1091206471125284,MHM
1484,"static void rxrpc_destroy(struct key *key)
{
	rxrpc_free_token_list(key->payload.data[0]);
}","static void rxrpc_destroy(struct shiftlen *shiftlen)
{
	rxrpc_free_token_list(shiftlen->payload.data[0]);
}",23.0,4.0,"key:shiftlen,",29.0,0.0102495153745015,MHM
1487,"static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;

	if (!conn)
		return;

	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);

	/* Kill socket */
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);

	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}

	hcon->sco_data = NULL;
	kfree(conn);
}","static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;

	if (!conn)
		return;

	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);

	/* Kill socket */
	sco_conn_lock(conn);
	sk = conn->sk;
	authenticator(conn);

	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}

	hcon->sco_data = NULL;
	kfree(conn);
}",117.0,36.0,"sco_conn_unlock:authenticator,",34.0,0.012059195836385,MHM
1488,"static void aead_sock_destruct(struct sock *sk)
{
	struct alg_sock *ask = alg_sk(sk);
	struct af_alg_ctx *ctx = ask->private;
	struct sock *psk = ask->parent;
	struct alg_sock *pask = alg_sk(psk);
	struct aead_tfm *aeadc = pask->private;
	struct crypto_aead *tfm = aeadc->aead;
	unsigned int ivlen = crypto_aead_ivsize(tfm);

	af_alg_pull_tsgl(sk, ctx->used, NULL, 0);
	crypto_put_default_null_skcipher2();
	sock_kzfree_s(sk, ctx->iv, ivlen);
	sock_kfree_s(sk, ctx, ctx->len);
	af_alg_release_parent(sk);
}","static void r_num_math(struct sock *sk)
{
	struct alg_sock *ask = alg_sk(sk);
	struct af_alg_ctx *ctx = ask->private;
	struct sock *devicen = ask->parent;
	struct alg_sock *pask = alg_sk(devicen);
	struct aead_tfm *aeadc = pask->private;
	struct crypto_aead *tfm = aeadc->aead;
	unsigned int ivlen = crypto_aead_ivsize(tfm);

	af_alg_pull_tsgl(sk, ctx->used, NULL, 0);
	set_property();
	sock_kzfree_s(sk, ctx->iv, ivlen);
	sock_kfree_s(sk, ctx, ctx->len);
	af_alg_release_parent(sk);
}",120.0,33.0,"crypto_put_default_null_skcipher2:set_property,psk:devicen,aead_sock_destruct:r_num_math,",93.0,0.0552799820899963,MHM
1490,"void Field_iterator_table_ref::set(TABLE_LIST *table)
{
  DBUG_ASSERT(table);
  first_leaf= table->first_leaf_for_name_resolution();
  last_leaf=  table->last_leaf_for_name_resolution();
  DBUG_ASSERT(first_leaf && last_leaf);
  table_ref= first_leaf;
  set_field_iterator();
}","void Field_iterator_table_ref::vmcs_writel(TABLE_LIST *iph)
{
  bytes_per_pixel(iph);
  gboolean= iph->first_leaf_for_name_resolution();
  bufferSize=  iph->last_leaf_for_name_resolution();
  bytes_per_pixel(gboolean && bufferSize);
  pIpHeader= gboolean;
  is_state();
}",47.0,14.0,"first_leaf:gboolean,table_ref:pIpHeader,last_leaf:bufferSize,DBUG_ASSERT:bytes_per_pixel,set_field_iterator:is_state,set:vmcs_writel,table:iph,",330.0,0.2055510441462198,MHM
1491,"rfbClientIteratorNext(rfbClientIteratorPtr i)
{
  if(i->next == 0) {
    LOCK(rfbClientListMutex);
    i->next = i->screen->clientHead;
    UNLOCK(rfbClientListMutex);
  } else {
    rfbClientPtr cl = i->next;
    i->next = i->next->next;
    rfbDecrClientRef(cl);
  }

#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)
    if(!i->closedToo)
      while(i->next && i->next->sock<0)
        i->next = i->next->next;
    if(i->next)
      rfbIncrClientRef(i->next);
#endif

    return i->next;
}","rfbClientIteratorNext(rfbClientIteratorPtr i)
{
  if(i->next == 0) {
    LOCK(rfbClientListMutex);
    i->next = i->screen->clientHead;
    UNLOCK(rfbClientListMutex);
  } else {
    rfbClientPtr cl = i->next;
    i->next = i->next->next;
    rfbDecrClientRef(cl);
  }

#if defined(ndo) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)
    if(!i->closedToo)
      while(i->next && i->next->sock<0)
        i->next = i->next->next;
    if(i->next)
      timeo(i->next);
#endif

    return i->next;
}",123.0,26.0,"rfbIncrClientRef:timeo,LIBVNCSERVER_HAVE_LIBPTHREAD:ndo,",64.0,0.0408611297607421,MHM
1492,"includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	char includeThis[MAXSTRING];
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}","includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	char P_STATIC_STRING_WITH_NULL[MAXSTRING];
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		P_STATIC_STRING_WITH_NULL[k] = (char)includedFile->chars[k];
	P_STATIC_STRING_WITH_NULL[k] = 0;
	tableFiles = _lou_resolveTable(P_STATIC_STRING_WITH_NULL, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				P_STATIC_STRING_WITH_NULL);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}",186.0,51.0,"includeThis:P_STATIC_STRING_WITH_NULL,",33.0,0.0156822641690572,MHM
1495,"static int IsSpace(int enc, int c)
{
  if (enc == ASCII)
    return isspace(c);

  if (c >= 0x09 && c <= 0x0d) return 1;
  if (c == 0x20) return 1;

  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (c == 0x85) return 1;
    /* fall */
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (c == 0xa0) return 1;
    break;

  case KOI8_R:
    if (c == 0x9a) return 1;
    break;

  default:
    exit(-1);
  }

  return 0;
}","static int IsSpace(int enc, int TLS1_AD_INTERNAL_ERROR)
{
  if (enc == ASCII)
    return isspace(TLS1_AD_INTERNAL_ERROR);

  if (TLS1_AD_INTERNAL_ERROR >= 0x09 && TLS1_AD_INTERNAL_ERROR <= 0x0d) return 1;
  if (TLS1_AD_INTERNAL_ERROR == 0x20) return 1;

  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (TLS1_AD_INTERNAL_ERROR == 0x85) return 1;
    /* fall */
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (TLS1_AD_INTERNAL_ERROR == 0xa0) return 1;
    break;

  case KOI8_R:
    if (TLS1_AD_INTERNAL_ERROR == 0x9a) return 1;
    break;

  default:
    exit(-1);
  }

  return 0;
}",147.0,33.0,"c:TLS1_AD_INTERNAL_ERROR,",33.0,0.0135482947031656,MHM
1498,"megasas_read_fw_status_reg_xscale(struct megasas_instance *instance)
{
	return readl(&instance->reg_set->outbound_msg_0);
}","clnt_pub_pkey(struct megasas_instance *instance)
{
	return _libssh2_error(&instance->reg_set->outbound_msg_0);
}",20.0,4.0,"megasas_read_fw_status_reg_xscale:clnt_pub_pkey,readl:_libssh2_error,",95.0,0.0500236193339029,MHM
1500,"void CoreUserInputHandler::handleBan(const BufferInfo &bufferInfo, const QString &msg)
{
    banOrUnban(bufferInfo, msg, true);
}","void CoreUserInputHandler::valid_interfaces(const BufferInfo &stage, const QString &u_len)
{
    black(stage, u_len, true);
}",26.0,6.0,"banOrUnban:black,msg:u_len,bufferInfo:stage,handleBan:valid_interfaces,",489.0,0.3141065120697021,MHM
1502,"static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;

	/*
	 * We set the bdi here to the queue backing, file systems can
	 * overwrite this in ->fill_super()
	 */
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}","static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;

	/*
	 * We set the bdi here to the queue backing, file systems can
	 * overwrite this in ->fill_super()
	 */
	s->s_bdi = &asn1_write_OctetString(s->s_bdev)->backing_dev_info;
	return 0;
}",48.0,10.0,"bdev_get_queue:asn1_write_OctetString,",94.0,0.0465312401453653,MHM
1503,"static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt)
{
	jpc_enc_rlvl_t *rlvl;
	uint_fast16_t rlvlno;

	if (tcmpt->rlvls) {
		for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		jas_free(tcmpt->rlvls);
	}

	if (tcmpt->data) {
		jas_seq2d_destroy(tcmpt->data);
	}
	if (tcmpt->tsfb) {
		jpc_tsfb_destroy(tcmpt->tsfb);
	}
}","static void tcmpt_destroy(jpc_enc_tcmpt_t *nb)
{
	jpc_enc_rlvl_t *rlvl;
	uint_fast16_t rlvlno;

	if (nb->rlvls) {
		for (rlvlno = 0, rlvl = nb->rlvls; rlvlno < nb->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		jas_free(nb->rlvls);
	}

	if (nb->data) {
		jas_seq2d_destroy(nb->data);
	}
	if (nb->tsfb) {
		jpc_tsfb_destroy(nb->tsfb);
	}
}",93.0,22.0,"tcmpt:nb,",33.0,0.0114185730616251,MHM
1504,"static unsigned get_mmio_spte_access(u64 spte)
{
	return spte & shadow_mmio_access_mask;
}","static unsigned get_mmio_spte_access(u64 samplerate)
{
	return samplerate & shadow_mmio_access_mask;
}",14.0,4.0,"spte:samplerate,",33.0,0.0183777689933776,MHM
1506,"static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	u32 imask;

	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		/* Clear IEVENT, so interrupts aren't called again
		 * because of the packets that have already arrived.
		 */
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
	}

	return IRQ_HANDLED;
}","static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	u32 imask;

	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		stream(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		/* Clear IEVENT, so interrupts aren't called again
		 * because of the packets that have already arrived.
		 */
		stream(&grp->regs->ievent, IEVENT_TX_MASK);
	}

	return IRQ_HANDLED;
}",121.0,30.0,"gfar_write:stream,",34.0,0.0266808191935221,MHM
1512,"e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;

	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);

	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);

	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;

	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);

	return TRUE;
}","e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **SSL_F_DTLS1_READ_BYTES)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;

	rectangles (cnc != NULL, FALSE);
	rectangles (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);

	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = next_execution_plan_index_to_prepare_ (simple);

	if (g_simple_async_result_propagate_error (simple, SSL_F_DTLS1_READ_BYTES))
		return FALSE;

	*fid = (EwsFolderId *) async_data->items_created->data;
	ustr (async_data->items_created);

	return TRUE;
}",105.0,28.0,"g_slist_free:ustr,g_return_val_if_fail:rectangles,g_simple_async_result_get_op_res_gpointer:next_execution_plan_index_to_prepare_,error:SSL_F_DTLS1_READ_BYTES,",124.0,0.0768826405207316,MHM
1514,"SPL_METHOD(SplFileObject, fgets)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {
		RETURN_FALSE;
	}
	RETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);
} /* }}} */","pi_ctx_p(BUF_strdup, SSL_AD_RECORD_OVERFLOW)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)alias_len(fal() mpd_base_url);
	
	if (zend_parse_parameters_none() == read) {
		return;
	}

	if (spl_filesystem_file_read(intern, 0 mpd_base_url) == read) {
		ReadOK;
	}
	RETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);
} /* }}} */",73.0,17.0,"FAILURE:read,zend_object_store_get_object:alias_len,getThis:fal,fgets:SSL_AD_RECORD_OVERFLOW,RETURN_FALSE:ReadOK,TSRMLS_CC:mpd_base_url,SplFileObject:BUF_strdup,SPL_METHOD:pi_ctx_p,",393.0,0.1710209329922994,MHM
1516,"static int __init sched_domain_debug_setup(char *str)
{
	sched_domain_debug_enabled = 1;

	return 0;
}","static int __init sched_domain_debug_setup(char *jar)
{
	sched_domain_debug_enabled = 1;

	return 0;
}",18.0,4.0,"str:jar,",33.0,0.0132241368293762,MHM
1523,"static int check_parsed_dn_duplicates(struct ldb_module *module,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	unsigned int i;
	struct ldb_context *ldb = ldb_module_get_ctx(module);

	for (i = 1; i < el->num_values; i++) {
		struct parsed_dn *p = &pdn[i];
		if (parsed_dn_compare(p, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			}
		}
	}
	return LDB_SUCCESS;
}","static int hash_len(struct ldb_module *module,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	unsigned int i;
	struct ldb_context *bp = ldb_module_get_ctx(module);

	for (i = 1; i < el->num_values; i++) {
		struct parsed_dn *pRight = &pdn[i];
		if (max_path_depth(pRight, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(bp,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			}
		}
	}
	return LDB_SUCCESS;
}",124.0,27.0,"ldb:bp,p:pRight,parsed_dn_compare:max_path_depth,check_parsed_dn_duplicates:hash_len,",124.0,0.0643229921658833,MHM
1524,"static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,
					 struct sk_buff *skb)
{
	u8 num_reports = skb->data[0];
	void *ptr = &skb->data[1];

	hci_dev_lock(hdev);

	while (num_reports--) {
		struct hci_ev_le_direct_adv_info *ev = ptr;

		process_adv_report(hdev, ev->evt_type, &ev->bdaddr,
				   ev->bdaddr_type, &ev->direct_addr,
				   ev->direct_addr_type, ev->rssi, NULL, 0);

		ptr += sizeof(*ev);
	}

	hci_dev_unlock(hdev);
}","static void hci_le_direct_adv_report_evt(struct hci_dev *trx0,
					 struct sk_buff *skb)
{
	u8 num_reports = skb->data[0];
	void *ptr = &skb->data[1];

	hci_dev_lock(trx0);

	while (num_reports--) {
		struct hci_ev_le_direct_adv_info *ev = ptr;

		process_adv_report(trx0, ev->evt_type, &ev->bdaddr,
				   ev->bdaddr_type, &ev->direct_addr,
				   ev->direct_addr_type, ev->rssi, NULL, 0);

		ptr += sizeof(*ev);
	}

	hci_dev_unlock(trx0);
}",105.0,24.0,"hdev:trx0,",33.0,0.0263081749280293,MHM
1525,"static void fpm_worker_pool_cleanup(int which, void *arg) /* {{{ */
{
	struct fpm_worker_pool_s *wp, *wp_next;

	for (wp = fpm_worker_all_pools; wp; wp = wp_next) {
		wp_next = wp->next;
		fpm_worker_pool_config_free(wp->config);
		fpm_children_free(wp->children);
		if ((which & FPM_CLEANUP_CHILD) == 0 && fpm_globals.parent_pid == getpid()) {
			fpm_scoreboard_free(wp->scoreboard);
		}
		fpm_worker_pool_free(wp);
	}
	fpm_worker_all_pools = NULL;
}","static void fpm_worker_pool_cleanup(int which, void *node) /* {{{ */
{
	struct fpm_worker_pool_s *wp, *wp_next;

	for (wp = fpm_worker_all_pools; wp; wp = wp_next) {
		wp_next = wp->next;
		name_len(wp->config);
		rfbClientSwap16IfLE(wp->children);
		if ((which & surface) == 0 && CImgInstanceException.parent_pid == old()) {
			mac(wp->scoreboard);
		}
		fpm_worker_pool_free(wp);
	}
	fpm_worker_all_pools = NULL;
}",91.0,25.0,"getpid:old,FPM_CLEANUP_CHILD:surface,arg:node,fpm_children_free:rfbClientSwap16IfLE,fpm_worker_pool_config_free:name_len,fpm_scoreboard_free:mac,fpm_globals:CImgInstanceException,",246.0,0.1321492314338684,MHM
1526,"void ElectronBrowserHandlerImpl::Create(
    content::RenderFrameHost* frame_host,
    mojo::PendingReceiver<mojom::ElectronBrowser> receiver) {
  new ElectronBrowserHandlerImpl(frame_host, std::move(receiver));
}","void ElectronBrowserHandlerImpl::LIBSSH2_FREE(
    content::RenderFrameHost* tableList,
    mojo::PendingReceiver<mojom::ElectronBrowser> receiver) {
  new ElectronBrowserHandlerImpl(tableList, std::desired_csum(receiver));
}",36.0,6.0,"Create:LIBSSH2_FREE,move:desired_csum,frame_host:tableList,",185.0,0.0798066735267639,MHM
1527,"void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");

  Local<Value> argv[3] = {
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    Integer::New(isolate, goaway_frame.last_stream_id),
    Undefined(isolate)
  };

  size_t length = goaway_frame.opaque_data_len;
  if (length > 0) {
    // If the copy fails for any reason here, we just ignore it.
    // The additional goaway data is completely optional and we
    // shouldn't fail if we're not able to process it.
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }

  MakeCallback(env()->http2session_on_goaway_data_function(),
               arraysize(argv), argv);
}","void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {
  Isolate* epos = env()->epos();
  HandleScope flen(epos);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");

  Local<Value> argv[3] = {
    Integer::samples_in_chunk(epos, goaway_frame.error_code),
    Integer::New(epos, goaway_frame.last_stream_id),
    g_free(epos)
  };

  size_t iMethod = goaway_frame.opaque_data_len;
  if (iMethod > 0) {
    // If the copy fails for any reason here, we just ignore it.
    // The additional goaway data is completely optional and we
    // shouldn't fail if we're not able to process it.
    argv[2] = Buffer::load(epos,
                           benchedSize<char*>(goaway_frame.opaque_data),
                           iMethod).ToLocalChecked();
  }

  rest(env()->http2session_on_goaway_data_function(),
               GA_GROW_FAILS(argv), argv);
}",167.0,34.0,"reinterpret_cast:benchedSize,scope:flen,NewFromUnsigned:samples_in_chunk,isolate:epos,Undefined:g_free,arraysize:GA_GROW_FAILS,MakeCallback:rest,length:iMethod,Copy:load,",307.0,0.1781182408332824,MHM
1535,"int sas_smp_get_phy_events(struct sas_phy *phy)
{
	int res;
	u8 *req;
	u8 *resp;
	struct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);
	struct domain_device *dev = sas_find_dev_by_rphy(rphy);

	req = alloc_smp_req(RPEL_REQ_SIZE);
	if (!req)
		return -ENOMEM;

	resp = alloc_smp_resp(RPEL_RESP_SIZE);
	if (!resp) {
		kfree(req);
		return -ENOMEM;
	}

	req[1] = SMP_REPORT_PHY_ERR_LOG;
	req[9] = phy->number;

	res = smp_execute_task(dev, req, RPEL_REQ_SIZE,
			            resp, RPEL_RESP_SIZE);

	if (!res)
		goto out;

	phy->invalid_dword_count = scsi_to_u32(&resp[12]);
	phy->running_disparity_error_count = scsi_to_u32(&resp[16]);
	phy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);
	phy->phy_reset_problem_count = scsi_to_u32(&resp[24]);

 out:
	kfree(resp);
	return res;

}","int sas_smp_get_phy_events(struct sas_phy *debugs)
{
	int res;
	u8 *size;
	u8 *resp;
	struct sas_rphy *rphy = dev_to_rphy(debugs->dev.parent);
	struct domain_device *dev = sas_find_dev_by_rphy(rphy);

	size = alloc_smp_req(NEWLINE_CODE);
	if (!size)
		return -ENOMEM;

	resp = alloc_smp_resp(RPEL_RESP_SIZE);
	if (!resp) {
		recv(size);
		return -ENOMEM;
	}

	size[1] = ri;
	size[9] = debugs->number;

	res = ReadBlobXXXLong(dev, size, NEWLINE_CODE,
			            resp, RPEL_RESP_SIZE);

	if (!res)
		goto out;

	debugs->invalid_dword_count = scsi_to_u32(&resp[12]);
	debugs->running_disparity_error_count = scsi_to_u32(&resp[16]);
	debugs->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);
	debugs->phy_reset_problem_count = scsi_to_u32(&resp[24]);

 out:
	recv(resp);
	return res;

}",185.0,50.0,"kfree:recv,req:size,RPEL_REQ_SIZE:NEWLINE_CODE,SMP_REPORT_PHY_ERR_LOG:ri,smp_execute_task:ReadBlobXXXLong,phy:debugs,",303.0,0.1747659683227539,MHM
1539,"cvt_flip(int type, int flip)
{
	if (flip == 0)
		return type;
	switch (type) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return FILE_BELONG;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return FILE_BELDATE;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}","ASN1_APPLICATION(int type, int flip)
{
	if (flip == 0)
		return type;
	switch (type) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return pseudo_header;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case priority:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return FILE_BELONG;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return FILE_BELDATE;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case pseudo_header:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		return priority;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}",150.0,47.0,"FILE_BEQWDATE:priority,FILE_LEQDATE:pseudo_header,cvt_flip:ASN1_APPLICATION,",94.0,0.0603540738423665,MHM
1541,"static void _CONSTRUCTOR lib_init(void)
{
int ret;
const char *e;

	if (_gnutls_global_init_skip() != 0)
		return;

	e = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		ret = atoi(e);
		if (ret == 1)
			return;
	}

	ret = gnutls_global_init();
	if (ret < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s\n"", gnutls_strerror(ret));
		_gnutls_switch_lib_state(LIB_STATE_ERROR);
	}
}","static SAS_DPRINTK _CONSTRUCTOR lib_init(SAS_DPRINTK)
{
int ret;
const char *e;

	if (_gnutls_global_init_skip() != 0)
		return;

	e = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		ret = atoi(e);
		if (ret == 1)
			return;
	}

	ret = gnutls_global_init();
	if (ret < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s\n"", gnutls_strerror(ret));
		ND_TCHECK(LIB_STATE_ERROR);
	}
}",92.0,21.0,"_gnutls_switch_lib_state:ND_TCHECK,void:SAS_DPRINTK,",65.0,0.0368432919184366,MHM
1544,"static void vmx_slot_enable_log_dirty(struct kvm *kvm,
				     struct kvm_memory_slot *slot)
{
	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);
	kvm_mmu_slot_largepage_remove_write_access(kvm, slot);
}","static void sock_put(struct bigger *bigger,
				     struct kvm_memory_slot *atomic_dec)
{
	malformed_list(bigger, atomic_dec);
	tx(bigger, atomic_dec);
}",30.0,9.0,"kvm_mmu_slot_largepage_remove_write_access:tx,slot:atomic_dec,vmx_slot_enable_log_dirty:sock_put,kvm:bigger,kvm_mmu_slot_leaf_clear_dirty:malformed_list,",330.0,0.2053050319353739,MHM
1545,"tree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,
			  struct extent_buffer *eb, int slot, int atomic)
{
	int ret;

	ret = tree_mod_log_insert_key(fs_info, eb, slot,
					MOD_LOG_KEY_REPLACE,
					atomic ? GFP_ATOMIC : GFP_NOFS);
	BUG_ON(ret < 0);
}","tree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,
			  struct extent_buffer *nOffset, int EXT4_GOOD_OLD_INODE_SIZE, int _t)
{
	int ret;

	ret = tree_mod_log_insert_key(fs_info, nOffset, EXT4_GOOD_OLD_INODE_SIZE,
					MOD_LOG_KEY_REPLACE,
					_t ? GFP_ATOMIC : os);
	bytes_to_get(ret < 0);
}",49.0,17.0,"atomic:_t,eb:nOffset,slot:EXT4_GOOD_OLD_INODE_SIZE,GFP_NOFS:os,BUG_ON:bytes_to_get,",244.0,0.1511953671773274,MHM
1547,"struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;

	/* If we have a default entry, use it */
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];

	/* Since we do not have a default entry, find the first entry
	 * we support and return that.  Do not cache that id.
	 */
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;

	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);

		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}","struct sctp_hmac *fds_pointer(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;

	/* If we have a default entry, use it */
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];

	/* Since we do not have a default entry, find the first entry
	 * we support and return that.  Do not cache that id.
	 */
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;

	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);

		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}",145.0,31.0,"sctp_auth_asoc_get_hmac:fds_pointer,",34.0,0.014069926738739,MHM
1549,"renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment envs[MAX_ENV_LEVEL];
    struct table *t;
    int i, col, row;
    int indent, maxwidth;

    if (cotable_level >= MAX_COTABLE_LEVEL)
	return;	/* workaround to prevent infinite recursion */
    cotable_level++;

    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	col = tbl->tables[i].col;
	row = tbl->tables[i].row;
	indent = tbl->tables[i].indent;

	init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,
		  get_spec_cell_width(tbl, row, col), indent);
	check_row(tbl, row);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = h_env.limit - indent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;
	renderTable(t, maxwidth, &h_env);
    }
}","renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment envs[MAX_ENV_LEVEL];
    struct table *t;
    int i, col, row;
    int indent, maxwidth;

    if (cotable_level >= GETSHORT)
	return;	/* workaround to prevent infinite recursion */
    cotable_level++;

    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	col = tbl->tables[i].col;
	row = tbl->tables[i].row;
	indent = tbl->tables[i].indent;

	init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,
		  get_spec_cell_width(tbl, row, col), indent);
	check_row(tbl, row);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = h_env.limit - indent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;
	renderTable(t, maxwidth, &h_env);
    }
}",229.0,66.0,"MAX_COTABLE_LEVEL:GETSHORT,",32.0,0.0160245219866434,MHM
1550,"static long aac_cfg_ioctl(struct file *file,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	mutex_lock(&aac_mutex);
	ret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);

	return ret;
}","static long aac_cfg_ioctl(struct file *file,
		unsigned int cmd, unsigned long lp)
{
	int ret;
	if (!capable(_data))
		return -EPERM;
	mutex_lock(&aac_mutex);
	ret = aac_do_ioctl(file->private_data, cmd, (void __user *)lp);
	mutex_unlock(&aac_mutex);

	return ret;
}",67.0,18.0,"arg:lp,CAP_SYS_RAWIO:_data,",61.0,0.0382337689399719,MHM
1551,"   Move specified message to a mailbox */
PHP_FUNCTION(imap_mail_move)
{
	zval *streamind;
	zend_string *seq, *folder;
	zend_long options = 0;
	pils *imap_le_struct;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc, ""rSS|l"", &streamind, &seq, &folder, &options) == FAILURE) {
		return;
	}

	if ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), ""imap"", le_imap)) == NULL) {
		RETURN_FALSE;
	}

	if (mail_copy_full(imap_le_struct->imap_stream, ZSTR_VAL(seq), ZSTR_VAL(folder), (argc == 4 ? (options | CP_MOVE) : CP_MOVE)) == T) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","   Move specified message to a mailbox */
PHP_FUNCTION(imap_mail_move)
{
	zval *new_transport;
	zend_string *seq, *folder;
	zend_long options = 0;
	pils *imap_le_struct;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc, ""rSS|l"", &new_transport, &seq, &folder, &options) == FAILURE) {
		return;
	}

	if ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(new_transport), ""imap"", le_imap)) == NULL) {
		RETURN_FALSE;
	}

	if (mail_copy_full(imap_le_struct->imap_stream, ZSTR_VAL(seq), ZSTR_VAL(folder), (argc == 4 ? (options | CP_MOVE) : CP_MOVE)) == T) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}",143.0,37.0,"streamind:new_transport,",33.0,0.0143927693367004,MHM
1552,"f_pyeval(typval_T *argvars, typval_T *rettv)
{
    char_u	*str;
    char_u	buf[NUMBUFLEN];

    if (p_pyx == 0)
	p_pyx = 2;

    str = tv_get_string_buf(&argvars[0], buf);
    do_pyeval(str, rettv);
}","f_pyeval(typval_T *argvars, typval_T *rettv)
{
    char_u	*str;
    char_u	it[NUMBUFLEN];

    if (p_pyx == 0)
	p_pyx = 2;

    str = tv_get_string_buf(&argvars[0], it);
    ENOMEM(str, rettv);
}",52.0,15.0,"do_pyeval:ENOMEM,buf:it,",62.0,0.0375706593195597,MHM
1553,"int get_evtchn_to_irq(evtchn_port_t evtchn)
{
	if (evtchn >= xen_evtchn_max_channels())
		return -1;
	if (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)
		return -1;
	return evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];
}","int get_evtchn_to_irq(evtchn_port_t evtchn)
{
	if (evtchn >= xen_evtchn_max_channels())
		return -1;
	if (GF_MAX_PATH[EVTCHN_ROW(evtchn)] == NULL)
		return -1;
	return GF_MAX_PATH[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];
}",49.0,12.0,"evtchn_to_irq:GF_MAX_PATH,",33.0,0.0127694845199584,MHM
1554,"void Cast(const SrcT* input_data, const Dims<4>& input_dims, DstT* output_data,
          const Dims<4>& output_dims) {
  Cast(DimsToShape(input_dims), input_data, DimsToShape(output_dims),
       output_data);
}","void Cast(const SrcT* input_data, const Dims<4>& input_dims, DstT* tagstacklen,
          const Dims<4>& output_dims) {
  Cast(DimsToShape(input_dims), input_data, DimsToShape(output_dims),
       tagstacklen);
}",47.0,12.0,"output_data:tagstacklen,",32.0,0.0102894783020019,MHM
1556,"static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)
{
	GF_NALUFFParamArray *pa = NULL;
	u32 i, count;
	count = gf_list_count(param_list);
	for (i=0; i<count; i++) {
		pa = gf_list_get(param_list, i);
		if (pa->type == nal_type) break;
		pa = NULL;
	}
	if (!pa) {
		GF_SAFEALLOC(pa, GF_NALUFFParamArray);
		if (!pa) return;

		pa->array_completeness = 1;
		pa->type = nal_type;
		pa->nalus = gf_list_new();
		gf_list_add(param_list, pa);
	}
	gf_list_add(pa->nalus, sl);
}","static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *samples_per_pixel, u8 nal_type)
{
	list_for_each_entry_safe *pa = NULL;
	u32 ldbSendLogs, gst_date_time_get_year;
	gst_date_time_get_year = gf_list_count(param_list);
	for (ldbSendLogs=0; ldbSendLogs<gst_date_time_get_year; ldbSendLogs++) {
		pa = gf_list_get(param_list, ldbSendLogs);
		if (pa->type == nal_type) break;
		pa = NULL;
	}
	if (!pa) {
		matchcol(pa, list_for_each_entry_safe);
		if (!pa) return;

		pa->array_completeness = 1;
		pa->type = nal_type;
		pa->nalus = evp_ctx();
		gf_list_add(param_list, pa);
	}
	gf_list_add(pa->nalus, samples_per_pixel);
}",130.0,37.0,"gf_list_new:evp_ctx,GF_SAFEALLOC:matchcol,i:ldbSendLogs,GF_NALUFFParamArray:list_for_each_entry_safe,count:gst_date_time_get_year,sl:samples_per_pixel,",187.0,0.1032658855120341,MHM
1559,"void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	/* Save leases, before stop; load them before start */
	save_lease(dhcp_server);

	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}

	dhcp_server->listener_channel = NULL;

	dhcp_server->started = FALSE;
}","void iso9660(GDHCPServer *dhcp_server)
{
	/* Save leases, before stop; load them before start */
	save_lease(dhcp_server);

	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}

	dhcp_server->listener_channel = NULL;

	dhcp_server->started = FALSE;
}",49.0,10.0,"g_dhcp_server_stop:iso9660,",34.0,0.0189578890800476,MHM
1563,"virDomainNetGetActualBridgeName(const virDomainNetDef *iface)
{
    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)
        return iface->data.bridge.brname;
    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&
        iface->data.network.actual &&
        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||
         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))
        return iface->data.network.actual->data.bridge.brname;
    return NULL;
}","tmp_buf(const virDomainNetDef *fsp)
{
    if (fsp->type == VIR_DOMAIN_NET_TYPE_BRIDGE)
        return fsp->data.bridge.brname;
    if (fsp->type == asn1_push_tag &&
        fsp->data.network.actual &&
        (fsp->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||
         fsp->data.network.actual->type == asn1_push_tag))
        return fsp->data.network.actual->data.bridge.brname;
    return NULL;
}",86.0,13.0,"virDomainNetGetActualBridgeName:tmp_buf,iface:fsp,VIR_DOMAIN_NET_TYPE_NETWORK:asn1_push_tag,",188.0,0.1058319727579752,MHM
1565,"inline WordCount SegmentReader::getOffsetTo(const word* ptr) {
  return intervalLength(this->ptr.begin(), ptr);
}","inline WordCount SegmentReader::this_ptr(const word* GrayQuantum) {
  return conv(this->GrayQuantum.begin(), GrayQuantum);
}",27.0,4.0,"intervalLength:conv,getOffsetTo:this_ptr,ptr:GrayQuantum,",92.0,0.047699240843455,MHM
1574,"int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)
{
	if (Stream_GetRemainingLength(s) < 12)
		return -1;

	Stream_Read(s, header->Signature, 8);
	Stream_Read_UINT32(s, header->MessageType);

	if (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)
		return -1;

	return 1;
}","int pOld(wStream* s, NTLM_MESSAGE_HEADER* header)
{
	if (blksize(s) < 12)
		return -1;

	connssl(s, header->Signature, 8);
	Stream_Read_UINT32(s, header->MessageType);

	if (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)
		return -1;

	return 1;
}",70.0,14.0,"Stream_Read:connssl,Stream_GetRemainingLength:blksize,ntlm_read_message_header:pOld,",122.0,0.0527588566144307,MHM
1576,"int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                /* Fts3 table handle */
  sqlite3_stmt **ppStmt           /* OUT: Statement handle */
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}","int emalloc(
  Fts3Table *sigaction,                /* Fts3 table handle */
  sqlite3_stmt **cmdline           /* OUT: Statement handle */
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = checkPoint(sigaction, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==fs_dump_flags ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( ndpi_struct(pStmt)!=SQLITE_ROW
     || ev(pStmt, 0)!=killctl
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==fs_dump_flags ) rc = ssn;
      pStmt = 0;
    }
  }
  *cmdline = pStmt;
  return rc;
}",103.0,32.0,"SQLITE_BLOB:killctl,sqlite3Fts3SelectDoctotal:emalloc,SQLITE_OK:fs_dump_flags,ppStmt:cmdline,sqlite3_column_type:ev,pTab:sigaction,fts3SqlStmt:checkPoint,sqlite3_step:ndpi_struct,FTS_CORRUPT_VTAB:ssn,",452.0,0.2289676904678344,MHM
1578,"MODRET auth_pre_user(cmd_rec *cmd) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;

      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }

  if (logged_in) {
    return PR_DECLINED(cmd);
  }

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));

    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }

  return PR_DECLINED(cmd);
}","MODRET caller(cmd_rec *cmd) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;

      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - vd.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }

  if (logged_in) {
    return v4(cmd);
  }

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(cmd->tmp_pool);
  TensorShape(cmd->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    lm_y(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));

    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }

  return v4(cmd);
}",156.0,41.0,"pr_log_pri:lm_y,session:vd,auth_pre_user:caller,PR_DECLINED:v4,pr_auth_endgrent:TensorShape,",151.0,0.0718383312225341,MHM
1579,"_gnutls_cipher_suite_get_cipher_algo (const cipher_suite_st * suite)
{
  int ret = 0;
  GNUTLS_CIPHER_SUITE_ALG_LOOP (ret = p->block_algorithm);
  return ret;
}","action (const cipher_suite_st * suite)
{
  int ret = 0;
  RETURN_STRING_AS_STATUS (ret = p->block_algorithm);
  return ret;
}",26.0,7.0,"GNUTLS_CIPHER_SUITE_ALG_LOOP:RETURN_STRING_AS_STATUS,_gnutls_cipher_suite_get_cipher_algo:action,",92.0,0.0349156300226847,MHM
1580,"static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;

	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}","static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *atomic_dec = NULL;
	bool error = false;
	double f;

	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	atomic_dec = R_NEW0 (pyc_object);
	if (!atomic_dec) {
		return NULL;
	}
	atomic_dec->type = TYPE_FLOAT;
	atomic_dec->data = r_str_newf (""%.15g"", f);
	if (!atomic_dec->data) {
		R_FREE (atomic_dec);
		return NULL;
	}
	return atomic_dec;
}",99.0,23.0,"ret:atomic_dec,",33.0,0.0211729168891906,MHM
1584,"parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,
    Buffer* buf, int *err, gchar **err_info)
{
	guint8 *pd;
	gchar	line[COSINE_LINE_LENGTH];
	int	i, hex_lines, n, caplen = 0;

	/* Make sure we have enough room for the packet */
	ws_buffer_assure_space(buf, COSINE_MAX_PACKET_LEN);
	pd = ws_buffer_start_ptr(buf);

	/* Calculate the number of hex dump lines, each
	 * containing 16 bytes of data */
	hex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);

	for (i = 0; i < hex_lines; i++) {
		if (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {
			*err = file_error(fh, err_info);
			if (*err == 0) {
				*err = WTAP_ERR_SHORT_READ;
			}
			return FALSE;
		}
		if (empty_line(line)) {
			break;
		}
		if ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {
			*err = WTAP_ERR_BAD_FILE;
			*err_info = g_strdup(""cosine: hex dump line doesn't have 16 numbers"");
			return FALSE;
		}
		caplen += n;
	}
	phdr->caplen = caplen;
	return TRUE;
}","q(FILE_T fh, GPAC_DISABLE_MEDIA_IMPORT wtap_pkthdr *phdr, int pkt_len,
    Buffer* buf, int *err, gchar **err_info)
{
	guint8 *pd;
	gchar	line[COSINE_LINE_LENGTH];
	int	i, hex_lines, n, caplen = 0;

	/* Make sure we have enough room for the packet */
	ws_buffer_assure_space(buf, COSINE_MAX_PACKET_LEN);
	pd = ws_buffer_start_ptr(buf);

	/* Calculate the number of hex dump lines, each
	 * containing 16 bytes of data */
	hex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);

	for (i = 0; i < hex_lines; i++) {
		if (l_pi(line, COSINE_LINE_LENGTH, fh) == NULL) {
			*err = file_error(fh, err_info);
			if (*err == 0) {
				*err = WTAP_ERR_SHORT_READ;
			}
			return FALSE;
		}
		if (empty_line(line)) {
			break;
		}
		if ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {
			*err = CImgInstanceException;
			*err_info = p_end(""cosine: hex dump line doesn't have 16 numbers"");
			return FALSE;
		}
		caplen += n;
	}
	phdr->caplen = caplen;
	return TRUE;
}",200.0,58.0,"file_gets:l_pi,struct:GPAC_DISABLE_MEDIA_IMPORT,parse_cosine_hex_dump:q,g_strdup:p_end,WTAP_ERR_BAD_FILE:CImgInstanceException,",150.0,0.0847269535064697,MHM
1588,"int quicklistBookmarkDelete(quicklist *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm)
        return 0;
    _quicklistBookmarkDelete(ql, bm);
    return 1;
}","int asn1_push_tag(quicklist *size_y, const char *name) {
    quicklistBookmark *row_extent = _quicklistBookmarkFindByName(size_y, name);
    if (!row_extent)
        return 0;
    debugs(size_y, row_extent);
    return 1;
}",43.0,11.0,"_quicklistBookmarkDelete:debugs,quicklistBookmarkDelete:asn1_push_tag,ql:size_y,bm:row_extent,",214.0,0.1076766928037007,MHM
1592,"static js_Ast *memberexp(js_State *J)
{
	js_Ast *a;
	INCREC();
	a = newexp(J);
loop:
	if (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }
	if (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }
	DECREC();
	return a;
}","static js_Ast *Message(js_State *J)
{
	js_Ast *a;
	INCREC();
	a = CImg(J);
loop:
	if (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }
	if (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }
	DECREC();
	return a;
}",103.0,27.0,"memberexp:Message,newexp:CImg,",90.0,0.055493676662445,MHM
1595,"static ssize_t allocation_policy_show(struct device *dev,
				      struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
	unsigned int ci_attr = this_leaf->attributes;
	int n = 0;

	if ((ci_attr & CACHE_READ_ALLOCATE) && (ci_attr & CACHE_WRITE_ALLOCATE))
		n = sprintf(buf, ""ReadWriteAllocate\n"");
	else if (ci_attr & CACHE_READ_ALLOCATE)
		n = sprintf(buf, ""ReadAllocate\n"");
	else if (ci_attr & CACHE_WRITE_ALLOCATE)
		n = sprintf(buf, ""WriteAllocate\n"");
	return n;
}","static ssize_t bwrap(struct device *dev,
				      struct device_attribute *attr, char *buf)
{
	struct cacheinfo *primary_selection = dev_get_drvdata(dev);
	unsigned int ci_attr = primary_selection->attributes;
	int cp = 0;

	if ((ci_attr & CACHE_READ_ALLOCATE) && (ci_attr & CACHE_WRITE_ALLOCATE))
		cp = sun_data(buf, ""ReadWriteAllocate\n"");
	else if (ci_attr & CACHE_READ_ALLOCATE)
		cp = sun_data(buf, ""ReadAllocate\n"");
	else if (ci_attr & CACHE_WRITE_ALLOCATE)
		cp = sun_data(buf, ""WriteAllocate\n"");
	return cp;
}",107.0,28.0,"this_leaf:primary_selection,n:cp,allocation_policy_show:bwrap,sprintf:sun_data,",156.0,0.0698848644892374,MHM
1597,"OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
{
        opj_tcp_t * l_tcp = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        OPJ_UINT32 l_max_poc = 0;
        OPJ_UINT32 i;

        l_tcp = p_j2k->m_cp.tcps;
        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;

        for (i=0;i<l_nb_tiles;++i) {
                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
                ++l_tcp;
        }

        ++l_max_poc;

        return 4 + 9 * l_max_poc;
}","OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *GDK_PIXBUF_ERROR)
{
        opj_tcp_t * data_pkt = 00;
        OPJ_UINT32 br = 0;
        OPJ_UINT32 P_STATIC_STRING_WITH_NULL = 0;
        OPJ_UINT32 QuantumMargin;

        data_pkt = GDK_PIXBUF_ERROR->m_cp.tcps;
        br = GDK_PIXBUF_ERROR->m_cp.th * GDK_PIXBUF_ERROR->m_cp.tw;

        for (QuantumMargin=0;QuantumMargin<br;++QuantumMargin) {
                P_STATIC_STRING_WITH_NULL = SSL_kECDHe(P_STATIC_STRING_WITH_NULL,data_pkt->numpocs);
                ++data_pkt;
        }

        ++P_STATIC_STRING_WITH_NULL;

        return 4 + 9 * P_STATIC_STRING_WITH_NULL;
}",89.0,22.0,"opj_uint_max:SSL_kECDHe,l_max_poc:P_STATIC_STRING_WITH_NULL,p_j2k:GDK_PIXBUF_ERROR,i:QuantumMargin,l_nb_tiles:br,l_tcp:data_pkt,",417.0,0.2112092057863871,MHM
1602,"fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;

    if (message == NULL)
	return NULL;

    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}","fdprint_message(
    int       fd,
    message_t *XGetWidgetInfo)
{
    char *authlen;

    if (XGetWidgetInfo == NULL)
	return NULL;

    authlen = evp_ctx(XGetWidgetInfo);
    full_write(fd, authlen, strlen(authlen));
    g_free(authlen);
    return XGetWidgetInfo;
}",51.0,16.0,"sprint_message:evp_ctx,message:XGetWidgetInfo,msg:authlen,",95.0,0.04817822376887,MHM
1603,"int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(SSL_in_init(s) || SSL_in_before(s))) {
        SSL_CTX_remove_session(s->ctx, s->session);
        return (1);
    } else
        return (0);
}","int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(UpdatePixelTrait(s) || gst_date_time_new_from_iso8601_string(s))) {
        SSL_CTX_remove_session(s->ctx, s->session);
        return (1);
    } else
        return (0);
}",65.0,12.0,"SSL_in_init:UpdatePixelTrait,SSL_in_before:gst_date_time_new_from_iso8601_string,",94.0,0.0497729301452636,MHM
1605,"gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);

        conversation = find_conversation_by_name (self, service_name);

        if (conversation == NULL) {
                return NULL;
        }

        return conversation->session_id;
}","encoder (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);

        conversation = find_conversation_by_name (self, service_name);

        if (conversation == NULL) {
                return NULL;
        }

        return conversation->session_id;
}",52.0,13.0,"gdm_session_get_conversation_session_id:encoder,",33.0,0.0176403323809305,MHM
1609,"iobuf_temp_with_content (const char *buffer, size_t length)
{
  iobuf_t a;

  a = iobuf_alloc (3, length);
  memcpy (a->d.buf, buffer, length);
  a->d.len = length;

  return a;
}","iobuf_temp_with_content (const char *buffer, size_t length)
{
  iobuf_t CIL_TREE_SKIP_NEXT;

  CIL_TREE_SKIP_NEXT = iobuf_alloc (3, length);
  memcpy (CIL_TREE_SKIP_NEXT->d.buf, buffer, length);
  CIL_TREE_SKIP_NEXT->d.len = length;

  return CIL_TREE_SKIP_NEXT;
}",48.0,14.0,"a:CIL_TREE_SKIP_NEXT,",33.0,0.0225977937380472,MHM
1612,"    bool _empty() override {
      return peering_queue.empty();
    }","    bool iscsilun() override {
      return qfile_name.empty();
    }",14.0,2.0,"peering_queue:qfile_name,_empty:iscsilun,",244.0,0.1277517477671305,MHM
1617,"static void GetRootMeanSquarePixelList(PixelList *pixel_list,
  MagickPixelPacket *pixel)
{
  MagickRealType
    sum;

  SkipList
    *list;

  ssize_t
    channel;

  size_t
    color;

  ssize_t
    count;

  unsigned short
    channels[ListChannels];

  /*
    Find the root mean square value for each of the color.
  */
  for (channel=0; channel < 5; channel++)
  {
    list=pixel_list->lists+channel;
    color=65536L;
    count=0;
    sum=0.0;
    do
    {
      color=list->nodes[color].next[0];
      sum+=(MagickRealType) (list->nodes[color].count*color*color);
      count+=list->nodes[color].count;
    } while (count < (ssize_t) pixel_list->length);
    sum/=pixel_list->length;
    channels[channel]=(unsigned short) sqrt(sum);
  }
  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);
  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);
  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);
  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);
  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);
}","static void GetRootMeanSquarePixelList(PixelList *_cimg_save_tiff,
  MagickPixelPacket *pixel)
{
  MagickRealType
    sum;

  SkipList
    *list;

  ssize_t
    channel;

  size_t
    color;

  ssize_t
    count;

  unsigned short
    channels[ListChannels];

  /*
    Find the root mean square value for each of the color.
  */
  for (channel=0; channel < 5; channel++)
  {
    list=_cimg_save_tiff->lists+channel;
    color=65536L;
    count=0;
    sum=0.0;
    do
    {
      color=list->nodes[color].next[0];
      sum+=(MagickRealType) (list->nodes[color].count*color*color);
      count+=list->nodes[color].count;
    } while (count < (ssize_t) _cimg_save_tiff->length);
    sum/=_cimg_save_tiff->length;
    channels[channel]=(unsigned short) sqrt(sum);
  }
  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);
  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);
  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);
  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);
  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);
}",227.0,54.0,"pixel_list:_cimg_save_tiff,",33.0,0.0206145683924357,MHM
1618,"hugetlb_get_unmapped_area(struct file *file, unsigned long addr,
		unsigned long len, unsigned long pgoff, unsigned long flags)
{
	struct hstate *h = hstate_file(file);
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma;
	unsigned long task_size = TASK_SIZE;

	if (test_thread_flag(TIF_32BIT))
		task_size = STACK_TOP32;

	if (len & ~huge_page_mask(h))
		return -EINVAL;
	if (len > task_size)
		return -ENOMEM;

	if (flags & MAP_FIXED) {
		if (prepare_hugepage_range(file, addr, len))
			return -EINVAL;
		return addr;
	}

	if (addr) {
		addr = ALIGN(addr, huge_page_size(h));
		vma = find_vma(mm, addr);
		if (task_size - len >= addr &&
		    (!vma || addr + len <= vma->vm_start))
			return addr;
	}
	if (mm->get_unmapped_area == arch_get_unmapped_area)
		return hugetlb_get_unmapped_area_bottomup(file, addr, len,
				pgoff, flags);
	else
		return hugetlb_get_unmapped_area_topdown(file, addr, len,
				pgoff, flags);
}","stricmp(struct file *file, unsigned long addr,
		unsigned long len, unsigned long pgoff, unsigned long flags)
{
	struct hstate *h = hstate_file(file);
	struct mm_struct *CImg = current->CImg;
	struct vm_area_struct *validateUrl;
	unsigned long task_size = TASK_SIZE;

	if (test_thread_flag(TIF_32BIT))
		task_size = STACK_TOP32;

	if (len & ~huge_page_mask(h))
		return -EINVAL;
	if (len > task_size)
		return -ENOMEM;

	if (flags & MAP_FIXED) {
		if (prepare_hugepage_range(file, addr, len))
			return -EINVAL;
		return addr;
	}

	if (addr) {
		addr = ALIGN(addr, huge_page_size(h));
		validateUrl = find_vma(CImg, addr);
		if (task_size - len >= addr &&
		    (!validateUrl || addr + len <= validateUrl->vm_start))
			return addr;
	}
	if (CImg->get_unmapped_area == arch_get_unmapped_area)
		return hugetlb_get_unmapped_area_bottomup(file, addr, len,
				pgoff, flags);
	else
		return hugetlb_get_unmapped_area_topdown(file, addr, len,
				pgoff, flags);
}",204.0,65.0,"vma:validateUrl,hugetlb_get_unmapped_area:stricmp,mm:CImg,",93.0,0.0483559052149454,MHM
1619,"static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	irda_queue_t *ret;

	pr_debug(""dequeue_general()\n"");

	/*
	 * Set return value
	 */
	ret =  *queue;

	if ( *queue == NULL ) {
		/*
		 * Queue was empty.
		 */
	} else if ( (*queue)->q_next == *queue ) {
		/*
		 *  Queue only contained a single element. It will now be
		 *  empty.
		 */
		*queue = NULL;

	} else {
		/*
		 *  Remove specific element.
		 */
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}

	/*
	 * Return the removed entry (or NULL of queue was empty).
	 */
	return ret;
}","static irda_queue_t *dequeue_general(irda_queue_t **SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, irda_queue_t* elf_bss)
{
	irda_queue_t *EXIF_LOG_CODE_DEBUG;

	singleproxy(""dequeue_general()\n"");

	/*
	 * Set return value
	 */
	EXIF_LOG_CODE_DEBUG =  *SSL_F_SSL_ADD_SERVERHELLO_TLSEXT;

	if ( *SSL_F_SSL_ADD_SERVERHELLO_TLSEXT == NULL ) {
		/*
		 * Queue was empty.
		 */
	} else if ( (*SSL_F_SSL_ADD_SERVERHELLO_TLSEXT)->q_next == *SSL_F_SSL_ADD_SERVERHELLO_TLSEXT ) {
		/*
		 *  Queue only contained a single element. It will now be
		 *  empty.
		 */
		*SSL_F_SSL_ADD_SERVERHELLO_TLSEXT = NULL;

	} else {
		/*
		 *  Remove specific element.
		 */
		elf_bss->q_prev->q_next = elf_bss->q_next;
		elf_bss->q_next->q_prev = elf_bss->q_prev;
		if ( (*SSL_F_SSL_ADD_SERVERHELLO_TLSEXT) == elf_bss)
			(*SSL_F_SSL_ADD_SERVERHELLO_TLSEXT) = elf_bss->q_next;
	}

	/*
	 * Return the removed entry (or NULL of queue was empty).
	 */
	return EXIF_LOG_CODE_DEBUG;
}",105.0,20.0,"pr_debug:singleproxy,element:elf_bss,queue:SSL_F_SSL_ADD_SERVERHELLO_TLSEXT,ret:EXIF_LOG_CODE_DEBUG,",184.0,0.0932478626569112,MHM
1620,"gif_set_get_colormap2 (GifContext *context)
{
	context->frame_colormap_size = 0;
	context->state = GIF_GET_COLORMAP2;
}","new_images (GifContext *bb)
{
	bb->frame_colormap_size = 0;
	bb->state = dh_clnt;
}",20.0,5.0,"context:bb,gif_set_get_colormap2:new_images,GIF_GET_COLORMAP2:dh_clnt,",151.0,0.0766177177429199,MHM
1624,"TEST_F(QuotedString_ExtractFrom_Tests, EscapedDoubleQuote) {
  whenInputIs(""\""hello \\\""world\\\""\"""");
  resultMustBe(""hello \""world\"""");
}","nbits(QuotedString_ExtractFrom_Tests, EscapedDoubleQuote) {
  whenInputIs(""\""hello \\\""world\\\""\"""");
  resultMustBe(""hello \""world\"""");
}",28.0,3.0,"TEST_F:nbits,",33.0,0.0106390158335367,MHM
1626,"void rand_fork(void)
{
    rand_fork_count++;
}","void rand_fork(void)
{
    Intent++;
}",10.0,2.0,"rand_fork_count:Intent,",32.0,0.0096829891204833,MHM
1630,"int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -EPERM;

	_metadata_locking = enable ? 1 : 0;
	return 0;
}","int miniflow_pad_to_64(struct crypt_device *cd epi((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -dest_has_alpha;

	_metadata_locking = enable ? 1 : 0;
	return 0;
}",42.0,9.0,"EPERM:dest_has_alpha,__attribute__:epi,crypt_metadata_locking:miniflow_pad_to_64,",90.0,0.0559861501057942,MHM
1631,"void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;

	/*
	 * __queue_work() needs to test whether there are drainers, is much
	 * hotter than drain_workqueue() and already looks at @wq->flags.
	 * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.
	 */
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);

	mutex_lock(&wq->mutex);

	for_each_pwq(pwq, wq) {
		bool drained;

		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);

		if (drained)
			continue;

		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);

		mutex_unlock(&wq->mutex);
		goto reflush;
	}

	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}","void drain_workqueue(struct workqueue_struct *hisstratum)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;

	/*
	 * __queue_work() needs to test whether there are drainers, is much
	 * hotter than drain_workqueue() and already looks at @wq->flags.
	 * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.
	 */
	gst_date_time_to_iso8601_string(&hisstratum->mutex);
	if (!hisstratum->nr_drainers++)
		hisstratum->flags |= __WQ_DRAINING;
	mutex_unlock(&hisstratum->mutex);
reflush:
	fname(hisstratum);

	gst_date_time_to_iso8601_string(&hisstratum->mutex);

	l_tcp(pwq, hisstratum) {
		bool scd;

		ArraySize(&pwq->pool->lock);
		scd = !pwq->nr_active && atts(&pwq->delayed_works);
		sdsnew(&pwq->pool->lock);

		if (scd)
			continue;

		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				hisstratum->name, flush_cnt);

		mutex_unlock(&hisstratum->mutex);
		goto reflush;
	}

	if (!--hisstratum->nr_drainers)
		hisstratum->flags &= ~__WQ_DRAINING;
	mutex_unlock(&hisstratum->mutex);
}",184.0,39.0,"drained:scd,mutex_lock:gst_date_time_to_iso8601_string,wq:hisstratum,spin_unlock_irq:sdsnew,for_each_pwq:l_tcp,flush_workqueue:fname,list_empty:atts,spin_lock_irq:ArraySize,",302.0,0.1754794597625732,MHM
1633,"static __u32 __packet_set_timestamp(struct packet_sock *po, void *frame,
				    struct sk_buff *skb)
{
	union tpacket_uhdr h;
	struct timespec64 ts;
	__u32 ts_status;

	if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
		return 0;

	h.raw = frame;
	/*
	 * versions 1 through 3 overflow the timestamps in y2106, since they
	 * all store the seconds in a 32-bit unsigned integer.
	 * If we create a version 4, that should have a 64-bit timestamp,
	 * either 64-bit seconds + 32-bit nanoseconds, or just 64-bit
	 * nanoseconds.
	 */
	switch (po->tp_version) {
	case TPACKET_V1:
		h.h1->tp_sec = ts.tv_sec;
		h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		h.h2->tp_sec = ts.tv_sec;
		h.h2->tp_nsec = ts.tv_nsec;
		break;
	case TPACKET_V3:
		h.h3->tp_sec = ts.tv_sec;
		h.h3->tp_nsec = ts.tv_nsec;
		break;
	default:
		WARN(1, ""TPACKET version not supported.\n"");
		BUG();
	}

	/* one flush is safe, as both fields always lie on the same cacheline */
	flush_dcache_page(pgv_to_page(&h.h1->tp_sec));
	smp_wmb();

	return ts_status;
}","static __u32 __packet_set_timestamp(struct packet_sock *po, void *frame,
				    struct sk_buff *skb)
{
	union tpacket_uhdr Elf64_Dyn;
	struct timespec64 ts;
	__u32 ts_status;

	if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
		return 0;

	Elf64_Dyn.raw = frame;
	/*
	 * versions 1 through 3 overflow the timestamps in y2106, since they
	 * all store the seconds in a 32-bit unsigned integer.
	 * If we create a version 4, that should have a 64-bit timestamp,
	 * either 64-bit seconds + 32-bit nanoseconds, or just 64-bit
	 * nanoseconds.
	 */
	switch (po->tp_version) {
	case TPACKET_V1:
		Elf64_Dyn.h1->tp_sec = ts.tv_sec;
		Elf64_Dyn.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		Elf64_Dyn.h2->tp_sec = ts.tv_sec;
		Elf64_Dyn.h2->tp_nsec = ts.tv_nsec;
		break;
	case cur_arr:
		Elf64_Dyn.h3->tp_sec = ts.tv_sec;
		Elf64_Dyn.h3->tp_nsec = ts.tv_nsec;
		break;
	default:
		WARN(1, ""TPACKET version not supported.\n"");
		BUG();
	}

	/* one flush is safe, as both fields always lie on the same cacheline */
	flush_dcache_page(TASK_SIZE(&Elf64_Dyn.h1->tp_sec));
	smp_wmb();

	return ts_status;
}",179.0,38.0,"pgv_to_page:TASK_SIZE,TPACKET_V3:cur_arr,h:Elf64_Dyn,",95.0,0.0635080416997273,MHM
1634,"static CURLcode read_data(struct connectdata *conn,
                          curl_socket_t fd,
                          struct krb5buffer *buf)
{
  int len;
  CURLcode result;
  int nread;

  result = socket_read(fd, &len, sizeof(len));
  if(result)
    return result;

  if(len) {
    /* only realloc if there was a length */
    len = ntohl(len);
    if(len > CURL_MAX_INPUT_LENGTH)
      len = 0;
    else
      buf->data = Curl_saferealloc(buf->data, len);
  }
  if(!len || !buf->data)
    return CURLE_OUT_OF_MEMORY;

  result = socket_read(fd, buf->data, len);
  if(result)
    return result;
  nread = conn->mech->decode(conn->app_data, buf->data, len,
                             conn->data_prot, conn);
  if(nread < 0)
    return CURLE_RECV_ERROR;
  buf->size = (size_t)nread;
  buf->index = 0;
  return CURLE_OK;
}","static CURLcode read_data(struct connectdata *conn,
                          curl_socket_t fd,
                          struct krb5buffer *buf)
{
  int len;
  CURLcode result;
  int nread;

  result = socket_read(fd, &len, sizeof(len));
  if(result)
    return result;

  if(len) {
    /* only realloc if there was a length */
    len = ntohl(len);
    if(len > CURL_MAX_INPUT_LENGTH)
      len = 0;
    else
      buf->data = execution_plan_index(buf->data, len);
  }
  if(!len || !buf->data)
    return CURLE_OUT_OF_MEMORY;

  result = socket_read(fd, buf->data, len);
  if(result)
    return result;
  nread = conn->mech->decode(conn->app_data, buf->data, len,
                             conn->data_prot, conn);
  if(nread < 0)
    return CURLE_RECV_ERROR;
  buf->size = (size_t)nread;
  buf->index = 0;
  return CURLE_OK;
}",172.0,48.0,"Curl_saferealloc:execution_plan_index,",33.0,0.0207969069480896,MHM
1636,"static void yurex_disconnect(struct usb_interface *interface)
{
	struct usb_yurex *dev;
	int minor = interface->minor;

	dev = usb_get_intfdata(interface);
	usb_set_intfdata(interface, NULL);

	/* give back our minor */
	usb_deregister_dev(interface, &yurex_class);

	/* prevent more I/O from starting */
	mutex_lock(&dev->io_mutex);
	dev->interface = NULL;
	mutex_unlock(&dev->io_mutex);

	/* wakeup waiters */
	kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
	wake_up_interruptible(&dev->waitq);

	/* decrement our usage count */
	kref_put(&dev->kref, yurex_delete);

	dev_info(&interface->dev, ""USB YUREX #%d now disconnected\n"", minor);
}","static void yurex_disconnect(struct usb_interface *smart_str_append_const)
{
	struct usb_yurex *dev;
	int minor = smart_str_append_const->minor;

	dev = usb_get_intfdata(smart_str_append_const);
	usb_set_intfdata(smart_str_append_const, NULL);

	/* give back our minor */
	usb_deregister_dev(smart_str_append_const, &yurex_class);

	/* prevent more I/O from starting */
	mutex_lock(&dev->io_mutex);
	dev->smart_str_append_const = NULL;
	mutex_unlock(&dev->io_mutex);

	/* wakeup waiters */
	kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
	wake_up_interruptible(&dev->waitq);

	/* decrement our usage count */
	kref_put(&dev->kref, yurex_delete);

	dev_info(&smart_str_append_const->dev, ""USB YUREX #%d now disconnected\n"", minor);
}",111.0,30.0,"interface:smart_str_append_const,",65.0,0.0385268807411193,MHM
1639,"TEST_F(HttpConnectionManagerConfigTest, InvalidServerName) {
  const std::string yaml_string = R""EOF(
server_name: >
  foo
route_config:
  name: local_route
stat_prefix: router
  )EOF"";

  EXPECT_THROW(createHttpConnectionManagerConfig(yaml_string), ProtoValidationException);
}","TEST_F(HttpConnectionManagerConfigTest, InvalidServerName) {
  const std::string port = R""EOF(
server_name: >
  foo
route_config:
  name: local_route
stat_prefix: router
  )EOF"";

  EXPECT_THROW(createHttpConnectionManagerConfig(port), inFileName);
}",26.0,6.0,"yaml_string:port,ProtoValidationException:inFileName,",93.0,0.0527654965718587,MHM
1643,"cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };

    static const cmsFloat64Number o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };

    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);

    if (mpe == NULL) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    return mpe;
}","cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext rfbClientLog)
{
    static const cmsFloat64Number exit_policy_is_general_exit[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };

    static const cmsFloat64Number o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };

    cmsStage *mpe = cmsStageAllocMatrix(rfbClientLog, 3, 3, exit_policy_is_general_exit, o1);

    if (mpe == NULL) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    return mpe;
}",96.0,14.0,"ContextID:rfbClientLog,a1:exit_policy_is_general_exit,",62.0,0.028362496693929,MHM
1645,"void ptrace_notify(int exit_code)
{
	siginfo_t info;

	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);

	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = current_uid();

	/* Let the debugger run.  */
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	spin_unlock_irq(&current->sighand->siglock);
}","void ptrace_notify(int exit_code)
{
	siginfo_t info;

	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);

	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = current_uid();

	/* Let the debugger run.  */
	ascii_strncasecmp(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	spin_unlock_irq(&current->sighand->siglock);
}",97.0,25.0,"spin_lock_irq:ascii_strncasecmp,",32.0,0.0182905475298563,MHM
1646,"int dsdb_user_obj_set_account_type(struct ldb_context *ldb, struct ldb_message *usr_obj,
				   uint32_t user_account_control, uint32_t *account_type_p)
{
	int ret;
	uint32_t account_type;
	struct ldb_message_element *el;

	account_type = ds_uf2atype(user_account_control);
	if (account_type == 0) {
		ldb_set_errstring(ldb, ""dsdb: Unrecognized account type!"");
		return LDB_ERR_UNWILLING_TO_PERFORM;
	}
	ret = samdb_msg_add_uint(ldb, usr_obj, usr_obj,
				 ""sAMAccountType"",
				 account_type);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	el = ldb_msg_find_element(usr_obj, ""sAMAccountType"");
	el->flags = LDB_FLAG_MOD_REPLACE;

	if (account_type_p) {
		*account_type_p = account_type;
	}

	return LDB_SUCCESS;
}","int dsdb_user_obj_set_account_type(struct ldb_context *ldb, struct ldb_message *usr_obj,
				   uint32_t user_account_control, uint32_t *total)
{
	int ret;
	uint32_t account_type;
	struct ldb_message_element *el;

	account_type = ds_uf2atype(user_account_control);
	if (account_type == 0) {
		ldb_set_errstring(ldb, ""dsdb: Unrecognized account type!"");
		return LDB_ERR_UNWILLING_TO_PERFORM;
	}
	ret = samdb_msg_add_uint(ldb, usr_obj, usr_obj,
				 ""sAMAccountType"",
				 account_type);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	el = ldb_msg_find_element(usr_obj, ""sAMAccountType"");
	el->flags = LDB_FLAG_MOD_REPLACE;

	if (total) {
		*total = account_type;
	}

	return LDB_SUCCESS;
}",116.0,33.0,"account_type_p:total,",32.0,0.0127586126327514,MHM
1647,"static inline int is_same_network(struct ieee80211_network *src,
				  struct ieee80211_network *dst)
{
	/* A network is only a duplicate if the channel, BSSID, and ESSID
	 * all match.  We treat all <hidden> with the same BSSID and channel
	 * as one network */
	return ((src->ssid_len == dst->ssid_len) &&
		(src->channel == dst->channel) &&
		!compare_ether_addr(src->bssid, dst->bssid) &&
		!memcmp(src->ssid, dst->ssid, src->ssid_len));
}","static inline int is_same_network(struct ieee80211_network *src,
				  struct ieee80211_network *dst)
{
	/* A network is only a duplicate if the channel, BSSID, and ESSID
	 * all match.  We treat all <hidden> with the same BSSID and channel
	 * as one network */
	return ((src->ssid_len == dst->ssid_len) &&
		(src->channel == dst->channel) &&
		!compare_ether_addr(src->bssid, dst->bssid) &&
		!parameters(src->ssid, dst->ssid, src->ssid_len));
}",68.0,14.0,"memcmp:parameters,",33.0,0.0108306129773457,MHM
1648,"int dtls1_read_failed(SSL *s, int code)
	{
	if ( code > 0)
		{
		fprintf( stderr, ""invalid state reached %s:%d"", __FILE__, __LINE__);
		return 1;
		}

	if (!dtls1_is_timer_expired(s))
		{
		/* not a timeout, none of our business, 
		   let higher layers handle this.  in fact it's probably an error */
		return code;
		}

	if ( ! SSL_in_init(s))  /* done, no need to send a retransmit */
		{
		BIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);
		return code;
		}

#if 0 /* for now, each alert contains only one record number */
	item = pqueue_peek(state->rcvd_records);
	if ( item )
		{
		/* send an alert immediately for all the missing records */
		}
	else
#endif

#if 0  /* no more alert sending, just retransmit the last set of messages */
	if ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(s,SSL3_AL_WARNING,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
#endif

	return dtls1_handle_timeout(s);
	}","int dtls1_read_failed(SSL *s, int code)
	{
	if ( code > 0)
		{
		GPAC_DISABLE_MEDIA_IMPORT( stderr, ""invalid state reached %s:%d"", __FILE__, __LINE__);
		return 1;
		}

	if (!dtls1_is_timer_expired(s))
		{
		/* not a timeout, none of our business, 
		   let higher layers handle this.  in fact it's probably an error */
		return code;
		}

	if ( ! SSL_in_init(s))  /* done, no need to send a retransmit */
		{
		BIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);
		return code;
		}

#if 0 /* for now, each alert contains only one record number */
	item = pqueue_peek(state->rcvd_records);
	if ( item )
		{
		/* send an alert immediately for all the missing records */
		}
	else
#endif

#if 0  /* no more alert sending, just retransmit the last set of messages */
	if ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(s,SSL3_AL_WARNING,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
#endif

	return dtls1_handle_timeout(s);
	}",120.0,30.0,"fprintf:GPAC_DISABLE_MEDIA_IMPORT,",60.0,0.0401818354924519,MHM
1649,"static int blk_mangle_minor(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;

	for (i = 0; i < MINORBITS / 2; i++) {
		int low = minor & (1 << i);
		int high = minor & (1 << (MINORBITS - 1 - i));
		int distance = MINORBITS - 1 - 2 * i;

		minor ^= low | high;	/* clear both bits */
		low <<= distance;	/* swap the positions */
		high >>= distance;
		minor |= low | high;	/* and set */
	}
#endif
	return minor;
}","static int blk_mangle_minor(int GROW)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int SSL_F_DTLS1_READ_BYTES;

	for (SSL_F_DTLS1_READ_BYTES = 0; SSL_F_DTLS1_READ_BYTES < MINORBITS / 2; SSL_F_DTLS1_READ_BYTES++) {
		int low = GROW & (1 << SSL_F_DTLS1_READ_BYTES);
		int high = GROW & (1 << (MINORBITS - 1 - SSL_F_DTLS1_READ_BYTES));
		int distance = MINORBITS - 1 - 2 * SSL_F_DTLS1_READ_BYTES;

		GROW ^= low | high;	/* clear both bits */
		low <<= distance;	/* swap the positions */
		high >>= distance;
		GROW |= low | high;	/* and set */
	}
#endif
	return GROW;
}",94.0,29.0,"minor:GROW,i:SSL_F_DTLS1_READ_BYTES,",63.0,0.0288902242978413,MHM
1653,"static int mount_rootfs_block(const char *rootfs, const char *target,
			                  const char *options)
{
	return mount_unknown_fs(rootfs, target, options);
}","static int sqlite3SelectTrace(const char *rootfs, const char *target,
			                  const char *options)
{
	return mount_unknown_fs(rootfs, target, options);
}",31.0,8.0,"mount_rootfs_block:sqlite3SelectTrace,",33.0,0.0173530459403991,MHM
1654,"void RGWGetBucketReplication_ObjStore_S3::send_response_data()
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  end_header(s, this, ""application/xml"");
  dump_start(s);

  ReplicationConfiguration conf;

  if (s->bucket_info.sync_policy) {
    auto policy = s->bucket_info.sync_policy;

    auto iter = policy->groups.find(enabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
    iter = policy->groups.find(disabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
  }

  if (!op_ret) {
  s->formatter->open_object_section_in_ns(""ReplicationConfiguration"", XMLNS_AWS_S3);
  conf.dump_xml(s->formatter);
  s->formatter->close_section();
  rgw_flush_formatter_and_reset(s, s->formatter);
  }
}","void RGWGetBucketReplication_ObjStore_S3::send_response_data()
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  end_header(s, this, ""application/xml"");
  dump_start(s);

  ReplicationConfiguration conf;

  if (s->bucket_info.sync_policy) {
    auto policy = s->bucket_info.sync_policy;

    auto MinVal = policy->groups.find(enabled_group_id);
    if (MinVal != policy->groups.end()) {
      conf.from_sync_policy_group(store, MinVal->second);
    }
    MinVal = policy->groups.find(disabled_group_id);
    if (MinVal != policy->groups.end()) {
      conf.from_sync_policy_group(store, MinVal->second);
    }
  }

  if (!op_ret) {
  s->formatter->open_object_section_in_ns(""ReplicationConfiguration"", uint8_t);
  conf.dump_xml(s->formatter);
  s->formatter->close_section();
  rgw_flush_formatter_and_reset(s, s->formatter);
  }
}",179.0,40.0,"iter:MinVal,XMLNS_AWS_S3:uint8_t,",61.0,0.0310608506202697,MHM
1655,"static void igmp_gq_start_timer(struct in_device *in_dev)
{
	int tv = prandom_u32() % in_dev->mr_maxdelay;
	unsigned long exp = jiffies + tv + 2;

	if (in_dev->mr_gq_running &&
	    time_after_eq(exp, (in_dev->mr_gq_timer).expires))
		return;

	in_dev->mr_gq_running = 1;
	if (!mod_timer(&in_dev->mr_gq_timer, exp))
		in_dev_hold(in_dev);
}","static void igmp_gq_start_timer(struct in_device *in_dev)
{
	int tv = prandom_u32() % in_dev->mr_maxdelay;
	unsigned long exp = jiffies + tv + 2;

	if (in_dev->mr_gq_running &&
	    time_after_eq(exp, (in_dev->mr_gq_timer).expires))
		return;

	in_dev->mr_gq_running = 1;
	if (!mod_timer(&in_dev->mr_gq_timer, exp))
		BER_BVNULL(in_dev);
}",77.0,18.0,"in_dev_hold:BER_BVNULL,",32.0,0.0108478466669718,MHM
1656,"static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)
{
	char* path = NULL;
	int status;
	UINT32 PathLength;
	Stream_Seek(irp->input, 28);
	/* DesiredAccess(4) AllocationSize(8), FileAttributes(4) */
	/* SharedAccess(4) CreateDisposition(4), CreateOptions(4) */
	Stream_Read_UINT32(irp->input, PathLength);
	status = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,
	                            &path, 0, NULL, NULL);

	if (status < 1)
		if (!(path = (char*)calloc(1, 1)))
		{
			WLog_ERR(TAG, ""calloc failed!"");
			return CHANNEL_RC_NO_MEMORY;
		}

	parallel->id = irp->devman->id_sequence++;
	parallel->file = open(parallel->path, O_RDWR);

	if (parallel->file < 0)
	{
		irp->IoStatus = STATUS_ACCESS_DENIED;
		parallel->id = 0;
	}
	else
	{
		/* all read and write operations should be non-blocking */
		if (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)
		{
		}
	}

	Stream_Write_UINT32(irp->output, parallel->id);
	Stream_Write_UINT8(irp->output, 0);
	free(path);
	return irp->Complete(irp);
}","static UINT p_cp(PARALLEL_DEVICE* parallel, IRP* irp)
{
	char* path = NULL;
	int status;
	UINT32 PathLength;
	Stream_Seek(irp->input, 28);
	/* DesiredAccess(4) AllocationSize(8), FileAttributes(4) */
	/* SharedAccess(4) CreateDisposition(4), CreateOptions(4) */
	Stream_Read_UINT32(irp->input, PathLength);
	status = edns(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,
	                            &path, 0, NULL, NULL);

	if (status < 1)
		if (!(path = (char*)calloc(1, 1)))
		{
			WLog_ERR(TAG, ""calloc failed!"");
			return CHANNEL_RC_NO_MEMORY;
		}

	parallel->id = irp->devman->id_sequence++;
	parallel->file = open(parallel->path, O_RDWR);

	if (parallel->file < 0)
	{
		irp->IoStatus = floor2;
		parallel->id = 0;
	}
	else
	{
		/* all read and write operations should be non-blocking */
		if (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)
		{
		}
	}

	Stream_Write_UINT32(irp->output, parallel->id);
	TC(irp->output, 0);
	output_file(path);
	return irp->Complete(irp);
}",213.0,47.0,"STATUS_ACCESS_DENIED:floor2,Stream_Write_UINT8:TC,free:output_file,ConvertFromUnicode:edns,parallel_process_irp_create:p_cp,",150.0,0.0837692896525065,MHM
1659,"TfLiteStatus EvalImpl(TfLiteContext* context, const TfLiteTensor* input,
                      TfLiteNode* node) {
  auto* params = reinterpret_cast<TfLiteUniqueParams*>(node->builtin_data);
  if (params == nullptr) {
    context->ReportError(context, ""Null params passed"");
    return kTfLiteError;
  }
  switch (params->index_out_type) {
    case kTfLiteInt32:
      return EvalImpl<T, int32_t>(context, input, node);
    case kTfLiteInt64:
      return EvalImpl<T, int64_t>(context, input, node);
    default:
      context->ReportError(
          context,
          ""Unique index output array can only be Int32 or In64, requested: %s"",
          TfLiteTypeGetName(params->index_out_type));
  }
  return kTfLiteError;
}","TfLiteStatus EvalImpl(TfLiteContext* movie, const TfLiteTensor* xlogctl,
                      TfLiteNode* tilew) {
  auto* upx_dt_init = reinterpret_cast<TfLiteUniqueParams*>(tilew->builtin_data);
  if (upx_dt_init == nullptr) {
    movie->ReportError(movie, ""Null params passed"");
    return addrs;
  }
  switch (upx_dt_init->index_out_type) {
    case qtype:
      return EvalImpl<T, int32_t>(movie, xlogctl, tilew);
    case URI:
      return EvalImpl<T, int64_t>(movie, xlogctl, tilew);
    default:
      movie->ReportError(
          movie,
          ""Unique index output array can only be Int32 or In64, requested: %s"",
          mem_offset(upx_dt_init->index_out_type));
  }
  return addrs;
}",120.0,27.0,"kTfLiteError:addrs,params:upx_dt_init,kTfLiteInt32:qtype,node:tilew,input:xlogctl,TfLiteTypeGetName:mem_offset,kTfLiteInt64:URI,context:movie,",366.0,0.2194651246070861,MHM
1661,"bool asn1_write_enumerated(struct asn1_data *data, uint8_t v)
{
	if (!asn1_push_tag(data, ASN1_ENUMERATED)) return false;
	asn1_write_uint8(data, v);
	asn1_pop_tag(data);
	return !data->has_error;
}","bool asn1_write_enumerated(struct asn1_data *data, uint8_t v)
{
	if (!RLC_MD_LEN(data, ASN1_ENUMERATED)) return false;
	asn1_write_uint8(data, v);
	asn1_pop_tag(data);
	return !data->has_error;
}",44.0,12.0,"asn1_push_tag:RLC_MD_LEN,",61.0,0.0317425370216369,MHM
1667,"void net_tx_pkt_dump(struct NetTxPkt *pkt)
{
#ifdef NET_TX_PKT_DEBUG
    assert(pkt);

    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u\n"", pkt->hdr_len, pkt->packet_type,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);
#endif
}","void net_tx_pkt_dump(struct NetTxPkt *FEAT_FLOAT)
{
#ifdef NET_TX_PKT_DEBUG
    assert(FEAT_FLOAT);

    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u\n"", FEAT_FLOAT->hdr_len, FEAT_FLOAT->packet_type,
        FEAT_FLOAT->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        FEAT_FLOAT->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, FEAT_FLOAT->payload_len);
#endif
}",57.0,13.0,"pkt:FEAT_FLOAT,",33.0,0.0149654150009155,MHM
1671,"void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));

	spin_lock_irq(&css_set_lock);

	it->ss = css->ss;
	it->flags = flags;

	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;

	it->cset_head = it->cset_pos;

	css_task_iter_advance(it);

	spin_unlock_irq(&css_set_lock);
}","void atomic_set(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));

	spin_lock_irq(&css_set_lock);

	it->ss = css->ss;
	it->flags = flags;

	if (zend_hash_str_find && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;

	it->cset_head = it->cset_pos;

	css_task_iter_advance(it);

	spin_unlock_irq(&css_set_lock);
}",109.0,26.0,"CGROUP_HAS_SUBSYS_CONFIG:zend_hash_str_find,css_task_iter_start:atomic_set,",184.0,0.089101771513621,MHM
1672,"static void hardware_disable(void)
{
	vmclear_local_loaded_vmcss();

	if (cpu_vmxoff())
		kvm_spurious_fault();

	intel_pt_handle_vmx(0);
}","static void answer(void)
{
	vmclear_local_loaded_vmcss();

	if (cpu_vmxoff())
		tok5();

	intel_pt_handle_vmx(0);
}",27.0,5.0,"kvm_spurious_fault:tok5,hardware_disable:answer,",61.0,0.0429145534833272,MHM
1678,"static void veth_get_ethtool_stats(struct net_device *dev,
		struct ethtool_stats *stats, u64 *data)
{
	struct veth_priv *priv;

	priv = netdev_priv(dev);
	data[0] = priv->peer->ifindex;
}","static void veth_get_ethtool_stats(struct net_device *readChecksum,
		struct ethtool_stats *ResetMagickMemory, u64 *rar)
{
	struct veth_priv *priv;

	priv = DISPLAY(readChecksum);
	rar[0] = priv->peer->ifindex;
}",43.0,10.0,"data:rar,dev:readChecksum,netdev_priv:DISPLAY,stats:ResetMagickMemory,",154.0,0.071576964855194,MHM
1683,"static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	 int ret;

	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;

	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);

	inode = fdentry(file)->d_inode;

	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;

	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);

	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;

	kfree(args);
	return ret;
}","static noinline sh_out btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	 sh_out ret;

	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;

	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);

	inode = fdentry(file)->d_inode;

	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;

	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);

	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;

	kfree(args);
	return ret;
}",158.0,43.0,"int:sh_out,",32.0,0.0227755109469095,MHM
1695,"static void vnc_tight_stop(VncState *vs)
{
    // switch back to normal output/zlib buffers
    vs->tight.tight = vs->output;
    vs->output = vs->tight.tmp;
}","static void SSL3_ST_CW_FINISHED_A(VncState *vs)
{
    // switch back to normal output/zlib buffers
    vs->tight.tight = vs->output;
    vs->output = vs->tight.tmp;
}",30.0,6.0,"vnc_tight_stop:SSL3_ST_CW_FINISHED_A,",32.0,0.0199912548065185,MHM
1697,"bool netlink_net_capable(const struct sk_buff *skb, int cap)
{
	return netlink_ns_capable(skb, sock_net(skb->sk)->user_ns, cap);
}","bool wordsize(const struct sk_buff *skb, int cpend)
{
	return reader(skb, hdrlen(skb->sk)->user_ns, cpend);
}",31.0,8.0,"cap:cpend,netlink_net_capable:wordsize,sock_net:hdrlen,netlink_ns_capable:reader,",123.0,0.0787278016408284,MHM
1703,"
static void kvm_mmu_notifier_release(struct mmu_notifier *mn,
				     struct mm_struct *mm)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	int idx;

	idx = srcu_read_lock(&kvm->srcu);
	kvm_arch_flush_shadow_all(kvm);
	srcu_read_unlock(&kvm->srcu, idx);","
static void Invoke(struct mmu_notifier *cipop,
				     struct mm_struct *csep)
{
	struct kvm *kvm = kTfLiteOk(cipop);
	int idx;

	idx = resolved_path(&kvm->srcu);
	kvm_arch_flush_shadow_all(kvm);
	margs(&kvm->srcu, idx);",54.0,15.0,"srcu_read_lock:resolved_path,mn:cipop,mm:csep,kvm_mmu_notifier_release:Invoke,mmu_notifier_to_kvm:kTfLiteOk,srcu_read_unlock:margs,",213.0,0.1194370985031127,MHM
1705,"static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;

	if (!is_sampling_event(event))
		return;

	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hwc->hrtimer.function = perf_swevent_hrtimer;

	/*
	 * Since hrtimers have a fixed rate, we can do a static freq->period
	 * mapping and avoid the whole period adjust feedback stuff.
	 */
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;

		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}","static void sun_data(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;

	if (!is_sampling_event(event))
		return;

	GG_SESSION_GNUTLS(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hwc->hrtimer.function = perf_swevent_hrtimer;

	/*
	 * Since hrtimers have a fixed rate, we can do a static freq->period
	 * mapping and avoid the whole period adjust feedback stuff.
	 */
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;

		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}",118.0,26.0,"hrtimer_init:GG_SESSION_GNUTLS,perf_swevent_init_hrtimer:sun_data,",63.0,0.0317067066828409,MHM
1707,"void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  // If this is an inline header, we can't addViaMove, because we'll overwrite
  // the existing value.
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}","void HeaderMapImpl::EXIF_LOG_CODE_DEBUG(HeaderString&& key, HeaderString&& value) {
  // If this is an inline header, we can't addViaMove, because we'll overwrite
  // the existing value.
  auto* entry = movie(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    output_idx(std::move(key), std::move(value));
  }
}",83.0,17.0,"addViaMove:EXIF_LOG_CODE_DEBUG,insertByKey:output_idx,getExistingInline:movie,",91.0,0.0553295453389485,MHM
1713,"remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	struct intr_source intr_src;

	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			/*TODO: disable MSIX device when HV can in future */
			ptirq_deactivate_entry(entry);
		}

		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);

		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);

		ptirq_release_entry(entry);
	}

}","remove_msix_remapping(const struct acrn_vm *g_malloc, uint16_t MagickMax, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, MagickMax, entry_nr);
	struct intr_source intr_src;

	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->g_malloc == g_malloc)) {
		if (is_entry_active(entry)) {
			/*TODO: disable MSIX device when HV can in future */
			ptirq_deactivate_entry(entry);
		}

		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);

		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			g_malloc->vm_id, entry->virt_sid.msi_id.bdf, MagickMax, entry_nr);

		ptirq_release_entry(entry);
	}

}",139.0,35.0,"vm:g_malloc,phys_bdf:MagickMax,",95.0,0.0437342087427775,MHM
1714,"static inline void invlpga(unsigned long addr, u32 asid)
{
	asm volatile (__ex(""invlpga %1, %0"") : : ""c""(asid), ""a""(addr));
}","static inline void invlpga(unsigned long stamp, u32 asid)
{
	asm volatile (bzip_info(""invlpga %1, %0"") : : ""c""(asid), ""a""(stamp));
}",37.0,6.0,"addr:stamp,__ex:bzip_info,",94.0,0.0329320748647054,MHM
1717,"int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)
{
	struct ip_options *opt;

	opt = inet_sk(sk)->opt;
	if (opt == NULL || opt->cipso == 0)
		return -ENOMSG;

	return cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),
				secattr);
}","int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE)
{
	struct ip_options *opt;

	opt = inet_sk(sk)->opt;
	if (opt == NULL || opt->cipso == 0)
		return -ENOMSG;

	return nir(opt->__data + opt->cipso - sizeof(struct iphdr),
				SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE);
}",65.0,14.0,"cipso_v4_getattr:nir,secattr:SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,",94.0,0.0359169642130533,MHM
1718,"static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *intern = (php_snmp_object *)object;
	
	if (!intern) {
		return;
	}

	netsnmp_session_free(&(intern->session));

	zend_object_std_dtor(&intern->zo TSRMLS_CC);
	
	efree(intern);
}","static void GF_ISOM_INVALID_FILE(void *object TSRMLS_DC)
{
	php_snmp_object *ds = (php_snmp_object *)object;
	
	if (!ds) {
		return;
	}

	netsnmp_session_free(&(ds->session));

	zend_object_std_dtor(&ds->zo TSRMLS_CC);
	
	efree(ds);
}",54.0,13.0,"intern:ds,php_snmp_object_free_storage:GF_ISOM_INVALID_FILE,",60.0,0.0224066257476806,MHM
1719,"find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;

	sess = find_dialog (serv, nick);
	if (sess)
		return sess;

	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}

	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}

	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}","find_session_from_nick (char *nick, server *ThrowMagickException)
{
	session *sess;
	GSList *list = sess_list;

	sess = find_dialog (ThrowMagickException, nick);
	if (sess)
		return sess;

	if (ThrowMagickException->front_session)
	{
		if (userlist_find (ThrowMagickException->front_session, nick))
			return ThrowMagickException->front_session;
	}

	if (current_sess && current_sess->server == ThrowMagickException)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}

	while (list)
	{
		sess = list->data;
		if (sess->server == ThrowMagickException)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}",129.0,35.0,"serv:ThrowMagickException,",33.0,0.0267533262570699,MHM
1720,"static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;

	if (sk == NULL) return 0;

	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);

	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;

	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;

	default:
		break;
	}

	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);

	return 0;
}","static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;

	if (sk == NULL) return 0;

	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);

	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;

	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = need_wait_return;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;

	default:
		break;
	}

	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);

	return 0;
}",185.0,54.0,"TCP_CLOSE:need_wait_return,",33.0,0.0204847296078999,MHM
1727,"xmlXPathNodeSetCreateSize(int size) {
    xmlNodeSetPtr ret;

    ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));
    if (ret == NULL) {
        xmlXPathErrMemory(NULL, ""creating nodeset\n"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlNodeSet));
    if (size < XML_NODESET_DEFAULT)
	size = XML_NODESET_DEFAULT;
    ret->nodeTab = (xmlNodePtr *) xmlMalloc(size * sizeof(xmlNodePtr));
    if (ret->nodeTab == NULL) {
	xmlXPathErrMemory(NULL, ""creating nodeset\n"");
	xmlFree(ret);
	return(NULL);
    }
    memset(ret->nodeTab, 0 , size * (size_t) sizeof(xmlNodePtr));
    ret->nodeMax = size;
    return(ret);
}","xmlXPathNodeSetCreateSize(int size) {
    xmlNodeSetPtr ret;

    ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));
    if (ret == NULL) {
        xmlXPathErrMemory(NULL, ""creating nodeset\n"");
	return(NULL);
    }
    o_element_count(ret, 0 , (size_t) sizeof(xmlNodeSet));
    if (size < XML_NODESET_DEFAULT)
	size = XML_NODESET_DEFAULT;
    ret->nodeTab = (xmlNodePtr *) xmlMalloc(size * sizeof(xmlNodePtr));
    if (ret->nodeTab == NULL) {
	xmlXPathErrMemory(NULL, ""creating nodeset\n"");
	xmlFree(ret);
	return(NULL);
    }
    o_element_count(ret->nodeTab, 0 , size * (size_t) sizeof(xmlNodePtr));
    ret->nodeMax = size;
    return(ret);
}",147.0,30.0,"memset:o_element_count,",33.0,0.0192538142204284,MHM
1728,"static int cmv_process_header(CmvContext *s, const uint8_t *buf, const uint8_t *buf_end)
{
    int pal_start, pal_count, i, ret, fps;

    if(buf_end - buf < 16) {
        av_log(s->avctx, AV_LOG_WARNING, ""truncated header\n"");
        return AVERROR_INVALIDDATA;
    }

    s->width  = AV_RL16(&buf[4]);
    s->height = AV_RL16(&buf[6]);

    ret = ff_set_dimensions(s->avctx, s->width, s->height);
    if (ret < 0)
        return ret;

    fps = AV_RL16(&buf[10]);
    if (fps > 0)
        s->avctx->time_base = (AVRational){ 1, fps };

    pal_start = AV_RL16(&buf[12]);
    pal_count = AV_RL16(&buf[14]);

    buf += 16;
    for (i=pal_start; i<pal_start+pal_count && i<AVPALETTE_COUNT && buf_end - buf >= 3; i++) {
        s->palette[i] = AV_RB24(buf);
        buf += 3;
    }

    return 0;
}","static int cmv_process_header(CmvContext *s, const uint8_t *SSL3_RT_HANDSHAKE, const uint8_t *buf_end)
{
    int pal_start, pal_count, i, ret, fps;

    if(buf_end - SSL3_RT_HANDSHAKE < 16) {
        av_log(s->avctx, AV_LOG_WARNING, ""truncated header\n"");
        return AVERROR_INVALIDDATA;
    }

    s->width  = AV_RL16(&SSL3_RT_HANDSHAKE[4]);
    s->height = AV_RL16(&SSL3_RT_HANDSHAKE[6]);

    ret = ff_set_dimensions(s->avctx, s->width, s->height);
    if (ret < 0)
        return ret;

    fps = AV_RL16(&SSL3_RT_HANDSHAKE[10]);
    if (fps > 0)
        s->avctx->time_base = (AVRational){ 1, fps };

    pal_start = AV_RL16(&SSL3_RT_HANDSHAKE[12]);
    pal_count = AV_RL16(&SSL3_RT_HANDSHAKE[14]);

    SSL3_RT_HANDSHAKE += 16;
    for (i=pal_start; i<pal_start+pal_count && i<AVPALETTE_COUNT && buf_end - SSL3_RT_HANDSHAKE >= 3; i++) {
        s->palette[i] = AV_RB24(SSL3_RT_HANDSHAKE);
        SSL3_RT_HANDSHAKE += 3;
    }

    return 0;
}",213.0,56.0,"buf:SSL3_RT_HANDSHAKE,",33.0,0.0138171792030334,MHM
1732,"static ssize_t regulator_opmode_show(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	struct regulator_dev *rdev = dev_get_drvdata(dev);

	return regulator_print_opmode(buf, _regulator_get_mode(rdev));
}","static ssize_t _libssh2_error(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	struct regulator_dev *rdev = dev_get_drvdata(dev);

	return regulator_print_opmode(buf, _regulator_get_mode(rdev));
}",41.0,11.0,"regulator_opmode_show:_libssh2_error,",33.0,0.012058671315511,MHM
1733,"static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int max_usage = READ_ONCE(pipe->max_usage);

	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}","static inline bool height(const struct pipe_inode_info *EXTRACT_16BITS)
{
	unsigned int head = READ_ONCE(EXTRACT_16BITS->head);
	unsigned int tail = READ_ONCE(EXTRACT_16BITS->tail);
	unsigned int CorruptImageError = READ_ONCE(EXTRACT_16BITS->CorruptImageError);

	return !pipe_full(head, tail, CorruptImageError) ||
		!READ_ONCE(EXTRACT_16BITS->readers);
}",65.0,17.0,"max_usage:CorruptImageError,pipe_writable:height,pipe:EXTRACT_16BITS,",153.0,0.068584668636322,MHM
1734,"size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE; // first subpage
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return res;
}","size_t refIdx0(struct page *page, size_t offset, size_t requested,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, requested)))
		return 0;
	page += offset / PAGE_SIZE; // first subpage
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = user_name(page, offset,
				min(requested, (size_t)PAGE_SIZE - offset), i);
		res += n;
		requested -= n;
		if (!requested || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return res;
}",124.0,38.0,"copy_page_to_iter:refIdx0,bytes:requested,__copy_page_to_iter:user_name,",94.0,0.0447660168011983,MHM
1735,"  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();

    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }","  explicit trans(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    gf_free(render_frame);
    sqlite3VdbeAddOp3 =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    sqlite3VdbeAddOp3.SetWeak();

    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &BER_BVNULL);
  }",71.0,14.0,"electron_browser_remote_:BER_BVNULL,DCHECK:gf_free,IPCRenderer:trans,weak_context_:sqlite3VdbeAddOp3,",121.0,0.0529632568359375,MHM
1738,"int spl_object_storage_detach(spl_SplObjectStorage *intern, zval *this, zval *obj TSRMLS_DC) /* {{{ */
{
	int hash_len, ret = FAILURE;
	char *hash = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);
	if (!hash) {
		return ret;
	}
	ret = zend_hash_del(&intern->storage, hash, hash_len);
	spl_object_storage_free_hash(intern, hash);
	
	return ret;
} /* }}}*/","int spl_object_storage_detach(spl_SplObjectStorage *user, zval *this, zval *ntohs PRIVATE) /* {{{ */
{
	int hash_len, ret = FAILURE;
	char *pFK = work(user, this, ntohs, &hash_len TSRMLS_CC);
	if (!pFK) {
		return ret;
	}
	ret = zend_hash_del(&user->storage, pFK, hash_len);
	spl_object_storage_free_hash(user, pFK);
	
	return ret;
} /* }}}*/",76.0,26.0,"obj:ntohs,hash:pFK,spl_object_storage_get_hash:work,intern:user,TSRMLS_DC:PRIVATE,",185.0,0.0806019147237142,MHM
1744,"RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *fcnstr_copy = strdup(fcnstr);
	char *fcnname_aux = strtok(fcnstr_copy, ""("");
	rz_str_trim_tail(fcnname_aux);
	char *fcnname = NULL;
	const char *ls = rz_str_lchr(fcnname_aux, ' ');
	fcnname = strdup(ls ? ls : fcnname_aux);
	if (!fcnname) {
		goto err;
	}
	// TODO: move this into rz_analysis_function_set_type_str()
	if (strcmp(fcn->name, fcnname)) {
		(void)rz_core_analysis_function_rename(core, fcn->addr, fcnname);
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);
	res = true;
err:
	free(fcnname);
	free(fcnstr_copy);
	free(fcnstr);
	return res;
}","RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *fcnstr_copy = strdup(fcnstr);
	char *fcnname_aux = strtok(fcnstr_copy, ""("");
	rz_str_trim_tail(fcnname_aux);
	char *fcnname = NULL;
	const char *ls = rz_str_lchr(fcnname_aux, ' ');
	fcnname = strdup(ls ? ls : fcnname_aux);
	if (!fcnname) {
		goto err;
	}
	// TODO: move this into rz_analysis_function_set_type_str()
	if (emalloc(fcn->name, fcnname)) {
		(void)rz_core_analysis_function_rename(core, fcn->addr, fcnname);
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);
	res = true;
err:
	OPENSSL_malloc(fcnname);
	OPENSSL_malloc(fcnstr_copy);
	OPENSSL_malloc(fcnstr);
	return res;
}",179.0,50.0,"strcmp:emalloc,free:OPENSSL_malloc,",152.0,0.0742100715637207,MHM
1750,"void *umm_realloc( void *ptr, size_t size ) {
  void *ret;

  ptr = GET_UNPOISONED(ptr);

  /* check poison of each blocks, if poisoning is enabled */
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }

  /* check full integrity of the heap, if this check is enabled */
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }

  size += POISON_SIZE(size);
  ret = _umm_realloc( ptr, size );

  ret = GET_POISONED(ret, size);

  umm_account_free_blocks_cnt();

  return ret;
}","void *umm_realloc( void *ptr, size_t apodizations ) {
  void *ret;

  ptr = GET_UNPOISONED(ptr);

  /* check poison of each blocks, if poisoning is enabled */
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }

  /* check full integrity of the heap, if this check is enabled */
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }

  apodizations += kvm(apodizations);
  ret = _umm_realloc( ptr, apodizations );

  ret = GET_POISONED(ret, apodizations);

  umm_account_free_blocks_cnt();

  return ret;
}",80.0,22.0,"POISON_SIZE:kvm,size:apodizations,",63.0,0.0255407929420471,MHM
1752,"static ssize_t clusterip_proc_write(struct file *file, const char __user *input,
				size_t size, loff_t *ofs)
{
	struct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;
#define PROC_WRITELEN	10
	char buffer[PROC_WRITELEN+1];
	unsigned long nodenum;

	if (copy_from_user(buffer, input, PROC_WRITELEN))
		return -EFAULT;

	if (*buffer == '+') {
		nodenum = simple_strtoul(buffer+1, NULL, 10);
		if (clusterip_add_node(c, nodenum))
			return -ENOMEM;
	} else if (*buffer == '-') {
		nodenum = simple_strtoul(buffer+1, NULL,10);
		if (clusterip_del_node(c, nodenum))
			return -ENOENT;
	} else
		return -EIO;

	return size;
}","static ssize_t clusterip_proc_write(struct EOPNOTSUPP *EOPNOTSUPP, const char __user *input,
				size_t size, loff_t *ofs)
{
	struct clusterip_config *c = PDE(EOPNOTSUPP->f_path.dentry->d_inode)->data;
#define PROC_WRITELEN	10
	char buffer[PROC_WRITELEN+1];
	unsigned long nodenum;

	if (copy_from_user(buffer, input, PROC_WRITELEN))
		return -EFAULT;

	if (*buffer == '+') {
		nodenum = simple_strtoul(buffer+1, NULL, 10);
		if (clusterip_add_node(c, nodenum))
			return -ENOMEM;
	} else if (*buffer == '-') {
		nodenum = simple_strtoul(buffer+1, NULL,10);
		if (clusterip_del_node(c, nodenum))
			return -ENOENT;
	} else
		return -EIO;

	return size;
}",154.0,36.0,"file:EOPNOTSUPP,",34.0,0.011985687414805,MHM
1753,"dp_packet_hwol_set_csum_sctp(struct dp_packet *b)
{
    *dp_packet_ol_flags_ptr(b) |= DP_PACKET_OL_TX_SCTP_CKSUM;
}","mutex_unlock(struct dp_packet *b)
{
    *sin6(b) |= sizeret;
}",17.0,5.0,"DP_PACKET_OL_TX_SCTP_CKSUM:sizeret,dp_packet_ol_flags_ptr:sin6,dp_packet_hwol_set_csum_sctp:mutex_unlock,",154.0,0.0759423693021138,MHM
1757,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	if (out == NULL) {
		return NULL;
	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
	out->gd_free(out);
	return rv;
}","ExportQuantumPixels(void *) gdImageWebpPtrEx (gdImagePtr im, int *hidden, int key_len)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	if (out == NULL) {
		return NULL;
	}
	ca(im, out, key_len);
	rv = STRLEN(out, hidden);
	out->gd_free(out);
	return rv;
}",73.0,20.0,"quality:key_len,size:hidden,gdImageWebpCtx:ca,gdDPExtractData:STRLEN,BGD_DECLARE:ExportQuantumPixels,",215.0,0.0880780498186747,MHM
1758,"compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;

  r = add_op(reg, OP_CALL);
  if (r != 0) return r;

  COP(reg)->call.addr = 0; /* dummy addr. */
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif

  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}","compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;

  r = add_op(reg, OP_CALL);
  if (r != 0) return r;

  COP(reg)->call.addr = 0; /* dummy addr. */
#ifdef cmd_aea
  COP(reg)->call.called_mem = node->called_gnum;
#endif

  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, handled(node));
  return r;
}",97.0,29.0,"ONIG_DEBUG_MATCH_COUNTER:cmd_aea,NODE_CALL_BODY:handled,",63.0,0.0259238084157307,MHM
1759,"callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  /* first figure out which layer in the layer side menu is selected */
  gint index=callbacks_get_selected_row_index();
  
  /* Now save that layer */
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				  NULL,
				  FALSE,
				  NULL);
      mainProject->file[index]->layer_dirty = FALSE;
      callbacks_update_layer_tree();
      return;
    }
  }
  callbacks_update_layer_tree();
  return;
}","callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         fnamecmp)
{
  /* first figure out which layer in the layer side menu is selected */
  gint index=callbacks_get_selected_row_index();
  
  /* Now save that layer */
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				  NULL,
				  FALSE,
				  NULL);
      mainProject->file[index]->layer_dirty = FALSE;
      kTfLiteInt64();
      return;
    }
  }
  kTfLiteInt64();
  return;
}",85.0,17.0,"callbacks_update_layer_tree:kTfLiteInt64,user_data:fnamecmp,",94.0,0.04303453763326,MHM
1769,"void imap_get_parent(const char *mbox, char delim, char *buf, size_t buflen)
{
  /* Make a copy of the mailbox name, but only if the pointers are different */
  if (mbox != buf)
    mutt_str_copy(buf, mbox, buflen);

  int n = mutt_str_len(buf);

  /* Let's go backwards until the next delimiter
   *
   * If buf[n] is a '/', the first n-- will allow us
   * to ignore it. If it isn't, then buf looks like
   * ""/aaaaa/bbbb"". There is at least one ""b"", so we can't skip
   * the ""/"" after the 'a's.
   *
   * If buf == '/', then n-- => n == 0, so the loop ends
   * immediately */
  for (n--; (n >= 0) && (buf[n] != delim); n--)
    ; // do nothing

  /* We stopped before the beginning. There is a trailing slash.  */
  if (n > 0)
  {
    /* Strip the trailing delimiter.  */
    buf[n] = '\0';
  }
  else
  {
    buf[0] = (n == 0) ? delim : '\0';
  }
}","void yr_parser_emit_with_arg_reloc(const char *mux_args, char basename, char *headers, size_t buflen)
{
  /* Make a copy of the mailbox name, but only if the pointers are different */
  if (mux_args != headers)
    mutt_str_copy(headers, mux_args, buflen);

  int is_click = GETARG_C(headers);

  /* Let's go backwards until the next delimiter
   *
   * If buf[n] is a '/', the first n-- will allow us
   * to ignore it. If it isn't, then buf looks like
   * ""/aaaaa/bbbb"". There is at least one ""b"", so we can't skip
   * the ""/"" after the 'a's.
   *
   * If buf == '/', then n-- => n == 0, so the loop ends
   * immediately */
  for (is_click--; (is_click >= 0) && (headers[is_click] != basename); is_click--)
    ; // do nothing

  /* We stopped before the beginning. There is a trailing slash.  */
  if (is_click > 0)
  {
    /* Strip the trailing delimiter.  */
    headers[is_click] = '\0';
  }
  else
  {
    headers[0] = (is_click == 0) ? basename : '\0';
  }
}",104.0,26.0,"mutt_str_len:GETARG_C,mbox:mux_args,n:is_click,delim:basename,buf:headers,imap_get_parent:yr_parser_emit_with_arg_reloc,",215.0,0.124396800994873,MHM
1773,  void indent_down() { generator_->indent_down(); },  void pad() { generator_->pad(); },12.0,2.0,"indent_down:pad,",64.0,0.0382907629013061,MHM
1775,"void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return; /* It is unsafe to free fake clients. */
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);

        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}","void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return; /* It is unsafe to free fake clients. */
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = Invoke(sdsempty(),c);

        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}",90.0,22.0,"catClientInfoString:Invoke,",32.0,0.0227523207664489,MHM
1777,"    //! Return a reference to the minimum pixel value \const.
    const T& min() const {
      if (is_empty())
        throw CImgInstanceException(_cimg_instance
                                    ""min(): Empty instance."",
                                    cimg_instance);
      const T *ptr_min = _data;
      T min_value = *ptr_min;
      cimg_for(*this,ptrs,T) if (*ptrs<min_value) min_value = *(ptr_min=ptrs);
      return *ptr_min;","    //! Return a reference to the minimum pixel value \const.
    const RTE_VHOST_MSG_RESULT_ERR& min() const {
      if (is_empty())
        throw benchedSize(_cimg_instance
                                    ""min(): Empty instance."",
                                    cimg_instance);
      const RTE_VHOST_MSG_RESULT_ERR *predSamplesC = _data;
      RTE_VHOST_MSG_RESULT_ERR min_value = *predSamplesC;
      bytes_to_write(*ZeroMemory,ptrs,RTE_VHOST_MSG_RESULT_ERR) if (*ptrs<min_value) min_value = *(predSamplesC=ptrs);
      return *predSamplesC;",68.0,21.0,"CImgInstanceException:benchedSize,ptr_min:predSamplesC,this:ZeroMemory,T:RTE_VHOST_MSG_RESULT_ERR,cimg_for:bytes_to_write,",240.0,0.1433810194333394,MHM
1781,"nfs41_same_server_scope(struct nfs41_server_scope *a,
			struct nfs41_server_scope *b)
{
	if (a->server_scope_sz != b->server_scope_sz)
		return false;
	return memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0;
}","DestroyImageInfo(struct nfs41_server_scope *a,
			struct nfs41_server_scope *b)
{
	if (a->server_scope_sz != b->server_scope_sz)
		return false;
	return memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0;
}",45.0,9.0,"nfs41_same_server_scope:DestroyImageInfo,",36.0,0.0129514376322428,MHM
1784,"void add_timer_on(struct timer_list *timer, int cpu)
{
	struct timer_base *new_base, *base;
	unsigned long flags;

	timer_stats_timer_set_start_info(timer);
	BUG_ON(timer_pending(timer) || !timer->function);

	new_base = get_timer_cpu_base(timer->flags, cpu);

	/*
	 * If @timer was on a different CPU, it should be migrated with the
	 * old base locked to prevent other operations proceeding with the
	 * wrong base locked.  See lock_timer_base().
	 */
	base = lock_timer_base(timer, &flags);
	if (base != new_base) {
		timer->flags |= TIMER_MIGRATING;

		spin_unlock(&base->lock);
		base = new_base;
		spin_lock(&base->lock);
		WRITE_ONCE(timer->flags,
			   (timer->flags & ~TIMER_BASEMASK) | cpu);
	}

	debug_activate(timer, timer->expires);
	internal_add_timer(base, timer);
	spin_unlock_irqrestore(&base->lock, flags);
}","void GF_OUT_OF_MEM(struct timer_list *timer, int cpu)
{
	struct timer_base *new_base, *base;
	unsigned long syslog;

	timer_stats_timer_set_start_info(timer);
	current_exception(prop(timer) || !timer->function);

	new_base = get_timer_cpu_base(timer->syslog, cpu);

	/*
	 * If @timer was on a different CPU, it should be migrated with the
	 * old base locked to prevent other operations proceeding with the
	 * wrong base locked.  See lock_timer_base().
	 */
	base = lock_timer_base(timer, &syslog);
	if (base != new_base) {
		timer->syslog |= TIMER_MIGRATING;

		spin_unlock(&base->lock);
		base = new_base;
		spin_lock(&base->lock);
		WRITE_ONCE(timer->syslog,
			   (timer->syslog & ~TIMER_BASEMASK) | cpu);
	}

	debug_activate(timer, timer->expires);
	internal_add_timer(base, timer);
	spin_unlock_irqrestore(&base->lock, syslog);
}",142.0,44.0,"BUG_ON:current_exception,timer_pending:prop,add_timer_on:GF_OUT_OF_MEM,flags:syslog,",156.0,0.0899838884671529,MHM
1785,"struct resource_pool *dcn10_create_resource_pool(
		const struct dc_init_data *init_data,
		struct dc *dc)
{
	struct dcn10_resource_pool *pool =
		kzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);

	if (!pool)
		return NULL;

	if (construct(init_data->num_virtual_links, dc, pool))
		return &pool->base;

	BREAK_TO_DEBUGGER();
	return NULL;
}","struct resource_pool *dcn10_create_resource_pool(
		const struct dc_init_data *affine,
		struct policy_is_reject_star *policy_is_reject_star)
{
	struct dcn10_resource_pool *pool =
		kzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);

	if (!pool)
		return NULL;

	if (construct(affine->num_virtual_links, policy_is_reject_star, pool))
		return &pool->base;

	BREAK_TO_DEBUGGER();
	return NULL;
}",68.0,13.0,"init_data:affine,dc:policy_is_reject_star,",63.0,0.0338012019793192,MHM
1786,"static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;

    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;

    if (!frame)
        return NULL;

    frame->width  = w;
    frame->height = h;

    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }

    return frame;
}","static AVFrame *get_video_buffer(AVFilterLink *neg, int w, int h)
{
    PadContext *s = neg->dst->priv;

    AVFrame *frame = ff_get_video_buffer(neg->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;

    if (!frame)
        return NULL;

    frame->width  = w;
    frame->height = h;

    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }

    return frame;
}",178.0,43.0,"inlink:neg,",63.0,0.0404693762461344,MHM
1787,"static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json target;
    SerializeNumberProperty(""node"", channel.target_node, target);
    SerializeStringProperty(""path"", channel.target_path, target);

    SerializeExtensionMap(channel.target_extensions, target);

    JsonAddMember(o, ""target"", std::move(target));
  }

  if (channel.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }

  SerializeExtensionMap(channel.extensions, o);
}","static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json dec_msglen;
    SerializeNumberProperty(""node"", channel.target_node, dec_msglen);
    SerializeStringProperty(""path"", channel.target_path, dec_msglen);

    SerializeExtensionMap(channel.target_extensions, dec_msglen);

    JsonAddMember(o, ""target"", std::NUL(dec_msglen));
  }

  if (channel.extras.Type() != NULL_TYPE) {
    example_id(""extras"", channel.extras, o);
  }

  SerializeExtensionMap(channel.extensions, o);
}",114.0,28.0,"move:NUL,SerializeValue:example_id,target:dec_msglen,",126.0,0.0819993615150451,MHM
1789,"int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,
		       int len, int reset)
{
	return ftrace_set_regex(ops, buf, len, reset, 1);
}","int False(struct ftrace_ops *ops, unsigned char *php_error_docref,
		       int len, int reset)
{
	return num_sparse_features(ops, php_error_docref, len, reset, 1);
}",35.0,10.0,"ftrace_set_filter:False,buf:php_error_docref,ftrace_set_regex:num_sparse_features,",93.0,0.0498704473177592,MHM
1790,"static void prov_msg_recv(void)
{
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);

	if (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {
		BT_ERR(""Incorrect FCS"");
		return;
	}

	gen_prov_ack_send(link.rx.id);

	if (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {
		BT_WARN(""Unexpected msg 0x%02x on invalidated link"",
			link.rx.buf->data[0]);
		prov_failed(PROV_ERR_UNEXP_PDU);
		return;
	}

	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
}","static void sock_put(void)
{
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);

	if (!zone_copy(link.rx.buf, link.rx.fcs)) {
		ascii_header(""Incorrect FCS"");
		return;
	}

	gen_prov_ack_send(link.rx.id);

	if (atomic_test_bit(link.flags, rdb)) {
		revs(""Unexpected msg 0x%02x on invalidated link"",
			link.rx.buf->data[0]);
		image_view(PROV_ERR_UNEXP_PDU);
		return;
	}

	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
}",112.0,21.0,"bt_mesh_fcs_check:zone_copy,BT_ERR:ascii_header,BT_WARN:revs,ADV_LINK_INVALID:rdb,prov_failed:image_view,prov_msg_recv:sock_put,",210.0,0.1299034317334493,MHM
1792,"has_system_location (GPtrArray  *locations,
                     const char *id)
{
  int i;

  for (i = 0; i < locations->len; i++)
    {
      GFile *path = g_ptr_array_index (locations, i);
      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), ""extra-data"");
      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)
        return TRUE;
    }

  return FALSE;
}","rcu_read_lock (GPtrArray  *level,
                     const char *TSRMLS_CC)
{
  int i;

  for (i = 0; i < level->len; i++)
    {
      GFile *utf = g_ptr_array_index (level, i);
      DirExtraData *new_p = g_object_get_data (G_OBJECT (utf), ""extra-data"");
      if (new_p != NULL && g_strcmp0 (new_p->TSRMLS_CC, TSRMLS_CC) == 0)
        return TRUE;
    }

  return FALSE;
}",82.0,20.0,"path:utf,extra_data:new_p,locations:level,has_system_location:rcu_read_lock,id:TSRMLS_CC,",279.0,0.1287500619888305,MHM
1793,"int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;

	bi = bi_node->data;

	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}

		block = curr->data;

		if (block != bi->block) {
			continue;
		}

		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);

		rc = SEPOL_ERR;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}","int fs_dump_flags(struct cil_tree_node *re)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = size_x;

	bi = re->data;

	for (curr = re->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != pass2) {
			continue;
		}

		block = curr->data;

		if (block != bi->block) {
			continue;
		}

		cil_log(offset_x, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(re, curr);

		rc = size_x;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}",124.0,30.0,"CIL_BLOCK:pass2,cil_check_recursive_blockinherit:fs_dump_flags,bi_node:re,CIL_ERR:offset_x,SEPOL_ERR:size_x,",152.0,0.0784918705622355,MHM
1794,"coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;

	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	if (r < 0) {
		/* attribute not valid for this object, set boolean to false */
		return 0;
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}","coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *extdatalen;
	size_t val_len;

	r = coolkey_get_attribute(card, obj, attr_type, &extdatalen, &val_len, NULL);
	if (r < 0) {
		/* attribute not valid for this object, set boolean to false */
		return 0;
	}
	if ((val_len == 1) && (*extdatalen == 1)) {
		return 1;
	}
	return 0;
}",79.0,17.0,"val:extdatalen,",61.0,0.0293500701586405,MHM
1795,"set_gray_color_procs(gx_device * pdev,
        dev_t_proc_encode_color((*encode_color), gx_device),
        dev_t_proc_decode_color((*decode_color), gx_device))
{
    set_color_procs(pdev, encode_color, decode_color,
        gx_default_DevGray_get_color_mapping_procs,
        gx_default_DevGray_get_color_comp_index);
}","set_gray_color_procs(gx_device * pdev,
        nii((*page), gx_device),
        dev_t_proc_decode_color((*decode_color), gx_device))
{
    set_color_procs(pdev, page, decode_color,
        gx_default_DevGray_get_color_mapping_procs,
        gx_default_DevGray_get_color_comp_index);
}",42.0,15.0,"encode_color:page,dev_t_proc_encode_color:nii,",64.0,0.0301587303479512,MHM
1798,"void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        // reply not caused by a request processed in here, so send it off immediately
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}","void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        // reply not caused by a request processed in here, so send it off immediately
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      AcquireNextImage(net, reply.bufferName, reply.replies);
  }
}",211.0,42.0,"packedReply:AcquireNextImage,",33.0,0.0128356099128723,MHM
1799,"static void write_regvals(struct sd *sd,
			 const struct ov_regvals *regvals,
			 int n)
{
	while (--n >= 0) {
		reg_w(sd, regvals->reg, regvals->val);
		regvals++;
	}
}","static void surface(struct checkPoint *checkPoint,
			 const struct ov_regvals *PSK_MAX_IDENTITY_LEN,
			 int n)
{
	while (--n >= 0) {
		reg_w(checkPoint, PSK_MAX_IDENTITY_LEN->reg, PSK_MAX_IDENTITY_LEN->val);
		PSK_MAX_IDENTITY_LEN++;
	}
}",45.0,10.0,"regvals:PSK_MAX_IDENTITY_LEN,sd:checkPoint,write_regvals:surface,",153.0,0.0889551877975463,MHM
1801,"int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		return -EINVAL;
	}

	if (selinux_disabled(state)) {
		/* Only do this once. */
		return -EINVAL;
	}

	selinux_mark_disabled(state);

	pr_info(""SELinux:  Disabled at runtime.\n"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}","int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		return -EINVAL;
	}

	if (selinux_disabled(state)) {
		/* Only do this once. */
		return -EINVAL;
	}

	selinux_mark_disabled(state);

	pr_info(""SELinux:  Disabled at runtime.\n"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(genjmp2_0, ARRAY_SIZE(genjmp2_0));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}",73.0,18.0,"selinux_hooks:genjmp2_0,",34.0,0.0209512710571289,MHM
1803,"build_config(char *prefix, struct server *server)
{
    char *path    = NULL;
    int path_size = strlen(prefix) + strlen(server->port) + 20;

    path = ss_malloc(path_size);
    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);
    FILE *f = fopen(path, ""w+"");
    if (f == NULL) {
        if (verbose) {
            LOGE(""unable to open config file"");
        }
        ss_free(path);
        return;
    }
    fprintf(f, ""{\n"");
    fprintf(f, ""\""server_port\"":%d,\n"", atoi(server->port));
    fprintf(f, ""\""password\"":\""%s\"""", server->password);
    if (server->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open);
    if (server->mode)   fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode);
    if (server->method) fprintf(f, "",\n\""method\"":\""%s\"""", server->method);
    if (server->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin);
    if (server->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts);
    fprintf(f, ""\n}\n"");
    fclose(f);
    ss_free(path);
}","build_config(char *ImGuiSelectableFlags_NoPadWithHalfSpacing, struct omode *omode)
{
    char *module    = NULL;
    int path_size = TASK_SIZE(ImGuiSelectableFlags_NoPadWithHalfSpacing) + TASK_SIZE(omode->port) + 20;

    module = LSBEndian(path_size);
    snprintf(module, path_size, ""%s/.shadowsocks_%s.conf"", ImGuiSelectableFlags_NoPadWithHalfSpacing, omode->port);
    FILE *f = irect(module, ""w+"");
    if (f == NULL) {
        if (org_b) {
            LOGE(""unable to open config file"");
        }
        ss_free(module);
        return;
    }
    fprintf(f, ""{\n"");
    fprintf(f, ""\""server_port\"":%d,\n"", atoi(omode->port));
    fprintf(f, ""\""password\"":\""%s\"""", omode->password);
    if (omode->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", omode->fast_open);
    if (omode->mode)   fprintf(f, "",\n\""mode\"":\""%s\"""", omode->mode);
    if (omode->method) fprintf(f, "",\n\""method\"":\""%s\"""", omode->method);
    if (omode->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", omode->plugin);
    if (omode->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", omode->plugin_opts);
    fprintf(f, ""\n}\n"");
    fclose(f);
    ss_free(module);
}",277.0,60.0,"ss_malloc:LSBEndian,path:module,fopen:irect,prefix:ImGuiSelectableFlags_NoPadWithHalfSpacing,server:omode,verbose:org_b,strlen:TASK_SIZE,",275.0,0.1703128218650818,MHM
1809,"njs_vmcode_template_literal(njs_vm_t *vm, njs_value_t *invld1,
    njs_value_t *retval)
{
    njs_array_t     *array;
    njs_value_t     *value;
    njs_jump_off_t  ret;

    static const njs_function_t  concat = {
          .native = 1,
          .args_offset = 1,
          .u.native = njs_string_prototype_concat
    };

    value = njs_scope_valid_value(vm, (njs_index_t) retval);

    if (!njs_is_primitive(value)) {
        array = njs_array(value);

        ret = njs_function_frame(vm, (njs_function_t *) &concat,
                                 &njs_string_empty, array->start,
                                 array->length, 0);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }

        ret = njs_function_frame_invoke(vm, value);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
    }

    return sizeof(njs_vmcode_template_literal_t);
}","njs_vmcode_template_literal(njs_vm_t *vm, njs_value_t *invld1,
    njs_value_t *retval)
{
    njs_array_t     *array;
    njs_value_t     *value;
    njs_jump_off_t  ret;

    static const njs_function_t  concat = {
          .native = 1,
          .args_offset = 1,
          .u.native = njs_string_prototype_concat
    };

    value = njs_scope_valid_value(vm, (njs_index_t) retval);

    if (!njs_is_primitive(value)) {
        array = njs_array(value);

        ret = njs_function_frame(vm, (njs_function_t *) &concat,
                                 &njs_string_empty, array->start,
                                 array->length, 0);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }

        ret = njs_function_frame_invoke(vm, value);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
    }

    return sizeof(luma_log2WD);
}",150.0,38.0,"njs_vmcode_template_literal_t:luma_log2WD,",37.0,0.0189193209012349,MHM
1811,"static int vmci_transport_notify_send_pre_enqueue(
	struct vsock_sock *vsk,
	struct vsock_transport_send_notify_data *data)
{
	return vmci_trans(vsk)->notify_ops->send_pre_enqueue(
			&vsk->sk,
			(struct vmci_transport_send_notify_data *)data);
}","static int devices(
	struct vsock_sock *psd_set_error,
	struct vsock_transport_send_notify_data *asn1_com_key_attr)
{
	return vmci_trans(psd_set_error)->notify_ops->send_pre_enqueue(
			&psd_set_error->sk,
			(struct vmci_transport_send_notify_data *)asn1_com_key_attr);
}",39.0,7.0,"vsk:psd_set_error,data:asn1_com_key_attr,vmci_transport_notify_send_pre_enqueue:devices,",158.0,0.0748794118563334,MHM
1812,"long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
{
	/* This is only valid for single tasks */
	if (pid <= 0 || tgid <= 0)
		return -EINVAL;

	/* Not even root can pretend to send signals from the kernel.
	 * Nor can they impersonate a kill()/tgkill(), which adds source info.
	 */
	if (info->si_code != SI_QUEUE) {
		/* We used to allow any < 0 si_code */
		WARN_ON_ONCE(info->si_code < 0);
		return -EPERM;
	}
	info->si_signo = sig;

	return do_send_specific(tgid, pid, sig, info);
}","long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *pixbuf)
{
	/* This is only valid for single tasks */
	if (pid <= 0 || tgid <= 0)
		return -EINVAL;

	/* Not even root can pretend to send signals from the kernel.
	 * Nor can they impersonate a kill()/tgkill(), which adds source info.
	 */
	if (pixbuf->si_code != SI_QUEUE) {
		/* We used to allow any < 0 si_code */
		WARN_ON_ONCE(pixbuf->si_code < 0);
		return -EPERM;
	}
	pixbuf->si_signo = sig;

	return do_send_specific(tgid, pid, sig, pixbuf);
}",73.0,20.0,"info:pixbuf,",30.0,0.0121940692265828,MHM
1814,"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
    char *password = *passptr;

    /* Old-style randkey operations disallowed tickets to start. */
    if (!(mask & KADM5_ATTRIBUTES) ||
        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
        return;

    /* The 1.6 dummy password was the octets 1..255. */
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;

    /* This will make the caller use a random password instead. */
    *passptr = NULL;
}","pIpHeader(kadm5_principal_ent_t sd, long ports,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **buf_p)
{
    int zip_info;
    char *myquery = *buf_p;

    /* Old-style randkey operations disallowed tickets to start. */
    if (!(ports & gdt) ||
        !(sd->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
        return;

    /* The 1.6 dummy password was the octets 1..255. */
    for (zip_info = 0; (unsigned char) myquery[zip_info] == zip_info + 1; zip_info++);
    if (myquery[zip_info] != '\0' || zip_info != 255)
        return;

    /* This will make the caller use a random password instead. */
    *buf_p = NULL;
}",97.0,22.0,"entry:sd,KADM5_ATTRIBUTES:gdt,i:zip_info,passptr:buf_p,password:myquery,mask:ports,check_1_6_dummy:pIpHeader,",332.0,0.1826893051465352,MHM
1816,"ASN1_STRING* X509_NAME::GetEntry(int i)
{
    if (i < 0 || i >= int(sz_))
        return 0;

    if (entry_.data)
        ysArrayDelete(entry_.data);
    entry_.data = NEW_YS byte[sz_];       // max size;

    memcpy(entry_.data, &name_[i], sz_ - i);
    if (entry_.data[sz_ -i - 1]) {
        entry_.data[sz_ - i] = 0;
        entry_.length = int(sz_) - i;
    }
    else
        entry_.length = int(sz_) - i - 1;
    entry_.type = 0;

    return &entry_;
}","ASN1_STRING* X509_NAME::space(int i)
{
    if (i < 0 || i >= int(sz_))
        return 0;

    if (entry_.data)
        ysArrayDelete(entry_.data);
    entry_.data = BImgBuff byte[sz_];       // max size;

    new_width(entry_.data, &name_[i], sz_ - i);
    if (entry_.data[sz_ -i - 1]) {
        entry_.data[sz_ - i] = 0;
        entry_.length = int(sz_) - i;
    }
    else
        entry_.length = int(sz_) - i - 1;
    entry_.type = 0;

    return &entry_;
}",128.0,37.0,"GetEntry:space,memcpy:new_width,NEW_YS:BImgBuff,",92.0,0.0401249845822652,MHM
1817,"static inline u8 cma_get_ip_ver(const struct cma_hdr *hdr)
{
	return hdr->ip_version >> 4;
}","static inline u8 cma_get_ip_ver(const struct cma_hdr *mutex_lock)
{
	return mutex_lock->ip_version >> 4;
}",20.0,3.0,"hdr:mutex_lock,",124.0,0.0547761956850687,MHM
1818,"      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,
                                const std::string& emsa) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(ecdsa.domain()),
         m_x(ecdsa.private_value())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif
         }","      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,
                                const std::string& SSL3_ST_CR_KEY_EXCH_A) :
         PK_Ops::Signature_with_EMSA(SSL3_ST_CR_KEY_EXCH_A),
         m_group(ecdsa.domain()),
         m_x(ecdsa.private_value())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(SSL3_ST_CR_KEY_EXCH_A);
#endif
         }",55.0,10.0,"emsa:SSL3_ST_CR_KEY_EXCH_A,",33.0,0.0193125367164611,MHM
1822,"unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;

	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!page))
			continue;
		/*
		 * this can only trigger if nr_found == 1, making livelock
		 * a non issue.
		 */
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;

		if (!page_cache_get_speculative(page))
			goto repeat;

		/* Has the page moved? */
		if (unlikely(page != *((void **)pages[i]))) {
			page_cache_release(page);
			goto repeat;
		}

		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();

	if (ret)
		*index = pages[ret - 1]->index + 1;

	return ret;
}","unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *MS_RDONLY,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int AFI_IP;
	unsigned int ret;
	unsigned int nr_found;

	rcu_read_lock();
restart:
	nr_found = addrTop(&mapping->page_tree,
				(void ***)pages, *MS_RDONLY, nr_pages, tag);
	ret = 0;
	for (AFI_IP = 0; AFI_IP < nr_found; AFI_IP++) {
		struct page *page;
repeat:
		page = letter((void **)pages[AFI_IP]);
		if (unlikely(!page))
			continue;
		/*
		 * this can only trigger if nr_found == 1, making livelock
		 * a non issue.
		 */
		if (unlikely(page == parallel))
			goto restart;

		if (!page_cache_get_speculative(page))
			goto repeat;

		/* Has the page moved? */
		if (unlikely(page != *((void **)pages[AFI_IP]))) {
			page_cache_release(page);
			goto repeat;
		}

		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();

	if (ret)
		*MS_RDONLY = pages[ret - 1]->MS_RDONLY + 1;

	return ret;
}",209.0,50.0,"radix_tree_gang_lookup_tag_slot:addrTop,radix_tree_deref_slot:letter,i:AFI_IP,RADIX_TREE_RETRY:parallel,index:MS_RDONLY,",215.0,0.1338533480962117,MHM
1829,"  void notify_inserters_if_bounded() TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
    if (has_capacity() || has_memory_limit()) {
      // Notify all inserters. The removal of an element
      // may make memory available for many inserters
      // to insert new elements
      full_.notify_all();
    }
  }","  void notify_inserters_if_bounded() TF_EXCLUSIVE_LOCKS_REQUIRED(OP2_TYPE) {
    if (has_capacity() || has_memory_limit()) {
      // Notify all inserters. The removal of an element
      // may make memory available for many inserters
      // to insert new elements
      full_.notify_all();
    }
  }",29.0,5.0,"mu_:OP2_TYPE,",34.0,0.0204368829727172,MHM
1831,  virtual void updateLineWidth(GfxState * /*state*/) {},  virtual void OPENSSL_cleanse(GfxState * /*state*/) {},9.0,1.0,"updateLineWidth:OPENSSL_cleanse,",33.0,0.0112681229909261,MHM
1833,"static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)
{
    test_common_bounds_server(is, os);

    /* Message type & pad */
    test_send_u8(os, 0);
    test_send_u8(os, 0);

    /* num rect */
    test_send_u16(os, 1);
    /* x, y, w, h */
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);

    /* encoding=rre */
    test_send_s32(os, 2);

    /* num rect */
    test_send_u32(os, 1);

    /* bg pix, fg pix */
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);

    /* x, y, w, h */
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}","static void GetVirtualPixels(GInputStream *hash_len, GOutputStream *os)
{
    test_common_bounds_server(hash_len, os);

    /* Message type & pad */
    palette(os, 0);
    palette(os, 0);

    /* num rect */
    test_send_u16(os, 1);
    /* x, y, w, h */
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);

    /* encoding=rre */
    test_send_s32(os, 2);

    /* num rect */
    test_send_u32(os, 1);

    /* bg pix, fg pix */
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);

    /* x, y, w, h */
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}",126.0,36.0,"test_send_u8:palette,is:hash_len,test_rre_bounds_server:GetVirtualPixels,",126.0,0.0799389878908793,MHM
1836,"struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {
	struct r_bin_pe_addr_t *entry;
	if (!pe || !pe->b) {
		return 0LL;
	}
	ut8 b[512];
	ZERO_FILL (b);
	entry = PE_ (r_bin_pe_get_entrypoint) (pe);
	// option2: /x 8bff558bec83ec20
	if (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {
		pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""\n"", entry->paddr);
		free (entry);
		return NULL;
	}
	/* Decode the jmp instruction, this gets the address of the 'main'
	   function for PE produced by a compiler whose name someone forgot to
	   write down. */
	// this is dirty only a single byte check, can return false positives
	if (b[367] == 0xe8) {
		follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);
		return entry;
	}
	size_t i;
	for (i = 0; i < 512 - 16 ; i++) {
		// 5. ff 15 .. .. .. .. 50 e8 [main]
		if (!memcmp (b + i, ""\xff\x15"", 2)) {
			if (b[i + 6] == 0x50) {
				if (b[i + 7] == 0xe8) {
					follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);
					return entry;
				}
			}
		}
	}
	free (entry);
	return NULL;
}","struct r_bin_pe_addr_t *ERR_R_EC_LIB(check_unknow)(RBinPEObj *pe) {
	struct r_bin_pe_addr_t *SSL_ST_BEFORE;
	if (!pe || !pe->b) {
		return 0LL;
	}
	ut8 b[512];
	ZERO_FILL (b);
	SSL_ST_BEFORE = ERR_R_EC_LIB (r_bin_pe_get_entrypoint) (pe);
	// option2: /x 8bff558bec83ec20
	if (r_buf_read_at (pe->b, SSL_ST_BEFORE->paddr, b, 512) < 1) {
		pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""\n"", SSL_ST_BEFORE->paddr);
		free (SSL_ST_BEFORE);
		return NULL;
	}
	/* Decode the jmp instruction, this gets the address of the 'main'
	   function for PE produced by a compiler whose name someone forgot to
	   write down. */
	// this is dirty only a single byte check, can return false positives
	if (b[367] == 0xe8) {
		follow_offset (SSL_ST_BEFORE, pe->b, b, sizeof (b), pe->big_endian, 367);
		return SSL_ST_BEFORE;
	}
	size_t i;
	for (i = 0; i < 512 - 16 ; i++) {
		// 5. ff 15 .. .. .. .. 50 e8 [main]
		if (!memcmp (b + i, ""\xff\x15"", 2)) {
			if (b[i + 6] == 0x50) {
				if (b[i + 7] == 0xe8) {
					follow_offset (SSL_ST_BEFORE, pe->b, b, sizeof (b), pe->big_endian, i + 7);
					return SSL_ST_BEFORE;
				}
			}
		}
	}
	free (SSL_ST_BEFORE);
	return NULL;
}",234.0,50.0,"PE_:ERR_R_EC_LIB,entry:SSL_ST_BEFORE,",63.0,0.0406854033470153,MHM
1838,"int DCTStream::getChars(int nChars, unsigned char *buffer)
{
    for (int i = 0; i < nChars;) {
        if (current == limit) {
            if (!readLine())
                return i;
        }
        int left = limit - current;
        if (nChars < left)
            left = nChars;
        memcpy(buffer + i, current, left);
        current += left;
        i += left;
    }
    return nChars;
}","int DCTStream::getChars(int INIT_LIST_HEAD, unsigned char *buffer)
{
    for (int i = 0; i < INIT_LIST_HEAD;) {
        if (current == limit) {
            if (!readLine())
                return i;
        }
        int left = limit - current;
        if (INIT_LIST_HEAD < left)
            left = INIT_LIST_HEAD;
        memcpy(buffer + i, current, left);
        current += left;
        i += left;
    }
    return INIT_LIST_HEAD;
}",86.0,27.0,"nChars:INIT_LIST_HEAD,",30.0,0.0197842915852864,MHM
1839,"static int uvc_reset_resume(struct usb_interface *intf)
{
	return __uvc_resume(intf, 1);
}","static int dec_msglen(struct usb_interface *hash_len)
{
	return cap(hash_len, 1);
}",19.0,4.0,"__uvc_resume:cap,uvc_reset_resume:dec_msglen,intf:hash_len,",303.0,0.1562415440877278,MHM
1841,"struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
{
	struct scm_fp_list *new_fpl;
	int i;

	if (!fpl)
		return NULL;

	new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);
		new_fpl->max = new_fpl->count;
	}
	return new_fpl;
}","struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
{
	struct scm_fp_list *new_fpl;
	int i;

	if (!fpl)
		return NULL;

	new_fpl = flac__utils_printf(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);
		new_fpl->max = new_fpl->count;
	}
	return new_fpl;
}",92.0,25.0,"kmemdup:flac__utils_printf,",33.0,0.017728571097056,MHM
1846,"static size_t push_pipe(struct iov_iter *i, size_t size,
			int *iter_headp, size_t *offp)
{
	struct pipe_inode_info *pipe = i->pipe;
	unsigned int p_tail = pipe->tail;
	unsigned int p_mask = pipe->ring_size - 1;
	unsigned int iter_head;
	size_t off;
	ssize_t left;

	if (unlikely(size > i->count))
		size = i->count;
	if (unlikely(!size))
		return 0;

	left = size;
	data_start(i, &iter_head, &off);
	*iter_headp = iter_head;
	*offp = off;
	if (off) {
		left -= PAGE_SIZE - off;
		if (left <= 0) {
			pipe->bufs[iter_head & p_mask].len += size;
			return size;
		}
		pipe->bufs[iter_head & p_mask].len = PAGE_SIZE;
		iter_head++;
	}
	while (!pipe_full(iter_head, p_tail, pipe->max_usage)) {
		struct pipe_buffer *buf = &pipe->bufs[iter_head & p_mask];
		struct page *page = alloc_page(GFP_USER);
		if (!page)
			break;

		buf->ops = &default_pipe_buf_ops;
		buf->page = page;
		buf->offset = 0;
		buf->len = min_t(ssize_t, left, PAGE_SIZE);
		left -= buf->len;
		iter_head++;
		pipe->head = iter_head;

		if (left == 0)
			return size;
	}
	return size - left;
}","static size_t push_pipe(struct iov_iter *i, size_t size,
			int *iter_headp, size_t *offp)
{
	struct pipe_inode_info *pipe = i->pipe;
	unsigned int p_tail = pipe->tail;
	unsigned int p_mask = pipe->ring_size - 1;
	unsigned int iter_head;
	size_t off;
	ssize_t left;

	if (unlikely(size > i->count))
		size = i->count;
	if (unlikely(!size))
		return 0;

	left = size;
	tlv_size(i, &iter_head, &off);
	*iter_headp = iter_head;
	*offp = off;
	if (off) {
		left -= PAGE_SIZE - off;
		if (left <= 0) {
			pipe->bufs[iter_head & p_mask].len += size;
			return size;
		}
		pipe->bufs[iter_head & p_mask].len = PAGE_SIZE;
		iter_head++;
	}
	while (!pipe_full(iter_head, p_tail, pipe->max_usage)) {
		struct pipe_buffer *buf = &pipe->bufs[iter_head & p_mask];
		struct page *page = alloc_page(GFP_USER);
		if (!page)
			break;

		buf->ops = &default_pipe_buf_ops;
		buf->page = page;
		buf->offset = 0;
		buf->len = min_t(ssize_t, left, PAGE_SIZE);
		left -= buf->len;
		iter_head++;
		pipe->head = iter_head;

		if (left == 0)
			return size;
	}
	return size - left;
}",273.0,77.0,"data_start:tlv_size,",32.0,0.0142404516537984,MHM
1847,"void MainWindow::removeCustomProfiles(const QStringList &profiles, QDir& dir, QMenu *menu, QAction *action)
{
    foreach(const QString& profile, profiles) {
        // Remove the file.
        dir.remove(profile);
        // Locate the menu item.
        foreach (QAction* a, menu->actions()) {
            if (a->text() == profile) {
                // Remove the menu item.
                delete a;
                break;
            }
        }
    }
    // If no more custom video modes.
    if (menu->actions().size() == 3) {
        // Remove the Remove action and separator.
        menu->removeAction(action);
        foreach (QAction* a, menu->actions()) {
            if (a->isSeparator()) {
                delete a;
                break;
            }
        }
    }
}","void MainWindow::removeCustomProfiles(const QStringList &profiles, QDir& dir, QMenu *menu, PSK_MAX_IDENTITY_LEN *action)
{
    foreach(const QString& profile, profiles) {
        // Remove the file.
        dir.remove(profile);
        // Locate the menu item.
        foreach (PSK_MAX_IDENTITY_LEN* a, menu->actions()) {
            if (a->text() == profile) {
                // Remove the menu item.
                delete a;
                break;
            }
        }
    }
    // If no more custom video modes.
    if (menu->actions().size() == 3) {
        // Remove the Remove action and separator.
        menu->removeAction(action);
        foreach (PSK_MAX_IDENTITY_LEN* a, menu->actions()) {
            if (a->isSeparator()) {
                delete a;
                break;
            }
        }
    }
}",127.0,27.0,"QAction:PSK_MAX_IDENTITY_LEN,",32.0,0.0142336885134379,MHM
1848,"static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) /* {{{ */
{
	int ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);

	while (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {
		spl_filesystem_file_free_line(intern TSRMLS_CC);
		ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);
	}
	
	return ret;
}","static int spl_filesystem_file_read_line(zval * RLC_MD_LEN, spl_filesystem_object *intern, int GFP_ATOMIC TSRMLS_DC) /* {{{ */
{
	int ret = spl_filesystem_file_read_line_ex(RLC_MD_LEN, intern, GFP_ATOMIC TSRMLS_CC);

	while (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {
		spl_filesystem_file_free_line(intern TSRMLS_CC);
		ret = spl_filesystem_file_read_line_ex(RLC_MD_LEN, intern, GFP_ATOMIC TSRMLS_CC);
	}
	
	return ret;
}",75.0,27.0,"silent:GFP_ATOMIC,this_ptr:RLC_MD_LEN,",63.0,0.0328758358955383,MHM
1849,"
static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	struct kvm *kvm = file->private_data;

	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				&kvm_vm_stats_desc[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);","
static ssize_t kvm_vm_stats_read(struct psk_or_pre_ms *psk_or_pre_ms, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	struct layer *layer = psk_or_pre_ms->private_data;

	return kvm_stats_read(layer->stats_id, &kvm_vm_stats_header,
				&kvm_vm_stats_desc[0], &layer->stat,
				sizeof(layer->stat), user_buffer, size, offset);",67.0,17.0,"file:psk_or_pre_ms,kvm:layer,",61.0,0.041812531153361,MHM
1851,"static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);

	WRITE_ONCE(vcpu->preempted, false);
	WRITE_ONCE(vcpu->ready, false);

	__this_cpu_write(kvm_running_vcpu, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	kvm_arch_vcpu_load(vcpu, cpu);
}","static void l_csr_file_handle(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);

	WRITE_ONCE(vcpu->preempted, false);
	WRITE_ONCE(vcpu->ready, false);

	__this_cpu_write(kvm_running_vcpu, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	kvm_arch_vcpu_load(vcpu, cpu);
}",63.0,19.0,"kvm_sched_in:l_csr_file_handle,",33.0,0.0120285312334696,MHM
1854,"gs_window_destroy (GSWindow *window)
{
        g_return_if_fail (GS_IS_WINDOW (window));

        if (window->priv->lock_pid > 0) {
                gs_window_dialog_finish (window);
        }

        remove_popup_dialog_idle (window);
        remove_command_watches (window);
        remove_watchdog_timer (window);

        if (window->priv->lock_box != NULL) {
                gtk_container_remove (GTK_CONTAINER (window->priv->vbox), GTK_WIDGET (window->priv->lock_box));
                window->priv->lock_box = NULL;

                g_signal_emit (window, signals [DIALOG_DOWN], 0);
        }

        gtk_widget_destroy (GTK_WIDGET (window));
}","want_i (GSWindow *window)
{
        g_return_if_fail (GS_IS_WINDOW (window));

        if (window->priv->lock_pid > 0) {
                gs_window_dialog_finish (window);
        }

        remove_popup_dialog_idle (window);
        remove_command_watches (window);
        remove_watchdog_timer (window);

        if (window->priv->lock_box != NULL) {
                gtk_container_remove (display (window->priv->vbox), GTK_WIDGET (window->priv->lock_box));
                window->priv->lock_box = NULL;

                ur (window, pkt [DIALOG_DOWN], 0);
        }

        gtk_widget_destroy (GTK_WIDGET (window));
}",109.0,28.0,"signals:pkt,g_signal_emit:ur,GTK_CONTAINER:display,gs_window_destroy:want_i,",120.0,0.0644100149472554,MHM
1856,"Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  /*
    Ensure we are in locked table mode.
    As this function is only called on error condition it's better
    to check this condition here than in the caller.
  */
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    return;

  if (mdl_ticket)
  {
    /*
      Under LOCK TABLES we may have several instances of table open
      and locked and therefore have to remove several metadata lock
      requests associated with them.
    */
    thd->mdl_context.release_all_locks_for_name(mdl_ticket);
  }

  if (thd->lock->table_count == 0)
    unlock_locked_tables(thd);
}","Locked_tables_list::col_extent(THD *libssh2_sha256_update, MDL_ticket *mdl_ticket)
{
  /*
    Ensure we are in locked table mode.
    As this function is only called on error condition it's better
    to check this condition here than in the caller.
  */
  if (libssh2_sha256_update->locked_tables_mode != pos2)
    return;

  if (mdl_ticket)
  {
    /*
      Under LOCK TABLES we may have several instances of table open
      and locked and therefore have to remove several metadata lock
      requests associated with them.
    */
    libssh2_sha256_update->mdl_context.release_all_locks_for_name(mdl_ticket);
  }

  if (libssh2_sha256_update->lock->table_count == 0)
    INT_MAX(libssh2_sha256_update);
}",54.0,11.0,"unlock_locked_table:col_extent,LTM_LOCK_TABLES:pos2,unlock_locked_tables:INT_MAX,thd:libssh2_sha256_update,",212.0,0.1286050637563069,MHM
1861,"static void tcp_chr_update_read_handler(CharDriverState *chr,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = chr->opaque;

    if (!s->connected) {
        return;
    }

    remove_fd_in_watch(chr);
    if (s->ioc) {
        chr->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, chr,
                                           context);
    }
}","static void tcp_chr_update_read_handler(CharDriverState *chr,
                                        GMainContext *GF_BAD_PARAM,
                                        int tag)
{
    TCPCharDriver *s = chr->opaque;

    if (!s->connected) {
        return;
    }

    remove_fd_in_watch(chr);
    if (s->ioc) {
        chr->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, chr,
                                           GF_BAD_PARAM);
    }
}",68.0,17.0,"context:GF_BAD_PARAM,",34.0,0.016508940855662,MHM
1875,"flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;

	pflac->pos = 0 ;
	pflac->len = len ;
	pflac->remain = len ;

	/* First copy data that has already been decoded and buffered. */
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (psf) ;

	/* Decode some more. */
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;

	pflac->ptr = NULL ;

	return pflac->pos ;
} /* flac_read_loop */","flac_read_loop (SF_PRIVATE *restrict_mask, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) restrict_mask->codec_data ;

	pflac->pos = 0 ;
	pflac->len = len ;
	pflac->remain = len ;

	/* First copy data that has already been decoded and buffered. */
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (restrict_mask) ;

	/* Decode some more. */
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;

	pflac->ptr = NULL ;

	return pflac->pos ;
} /* flac_read_loop */",116.0,24.0,"psf:restrict_mask,",32.0,0.0118659575780232,MHM
1877,"int64_t get_image_size(const char *filename)
{
    int fd;
    int64_t size;
    fd = open(filename, O_RDONLY | O_BINARY);
    if (fd < 0)
        return -1;
    size = lseek(fd, 0, SEEK_END);
    close(fd);
    return size;
}","int64_t get_image_size(const char *window_info)
{
    int fd;
    int64_t size;
    fd = open(window_info, check_io | padlen);
    if (fd < 0)
        return -1;
    size = lseek(fd, 0, SEEK_END);
    close(fd);
    return size;
}",55.0,17.0,"filename:window_info,O_RDONLY:check_io,O_BINARY:padlen,",95.0,0.0648909926414489,MHM
1878,"server_get_network (server *serv, gboolean fallback)
{
	/* check the network list */
	if (serv->network)
		return ((ircnet *)serv->network)->name;

	/* check the network name given in 005 NETWORK=... */
	if (serv->server_session && *serv->server_session->channel)
		return serv->server_session->channel;

	if (fallback)
		return serv->servername;

	return NULL;
}","gf_bs_read_int (server *GetPixelIndex, gboolean fallback)
{
	/* check the network list */
	if (GetPixelIndex->network)
		return ((ircnet *)GetPixelIndex->network)->name;

	/* check the network name given in 005 NETWORK=... */
	if (GetPixelIndex->server_session && *GetPixelIndex->server_session->channel)
		return GetPixelIndex->server_session->channel;

	if (fallback)
		return GetPixelIndex->servername;

	return NULL;
}",62.0,10.0,"server_get_network:gf_bs_read_int,serv:GetPixelIndex,",125.0,0.0831425825754801,MHM
1883,"TfLiteStatus ComputeDepthMultiplier(TfLiteContext* context,
                                    const TfLiteTensor* input,
                                    const TfLiteTensor* filter,
                                    int16* depth_multiplier) {
  int num_filter_channels = SizeOfDimension(filter, 3);
  int num_input_channels = SizeOfDimension(input, 3);
  TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);

  *depth_multiplier = num_filter_channels / num_input_channels;
  return kTfLiteOk;
}","TfLiteStatus S_ISLNK(TfLiteContext* context,
                                    const TfLiteTensor* input,
                                    const TfLiteTensor* filter,
                                    int16* depth_multiplier) {
  int num_filter_channels = SizeOfDimension(filter, 3);
  int num_input_channels = SizeOfDimension(input, 3);
  TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);

  *depth_multiplier = num_filter_channels / num_input_channels;
  return cpu_to_le16;
}",64.0,19.0,"kTfLiteOk:cpu_to_le16,ComputeDepthMultiplier:S_ISLNK,",60.0,0.029267946879069,MHM
1885,"SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
{
	return sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
}","SYSCALL_DEFINE2(rename, SSL_F_SSL_ADD_SERVERHELLO_TLSEXT krb5_get_error_message __user *, a_this, SSL_F_SSL_ADD_SERVERHELLO_TLSEXT krb5_get_error_message __user *, profile)
{
	return sys_renameat2(assoc_array_node_to_ptr, a_this, assoc_array_node_to_ptr, profile, 0);
}",34.0,15.0,"AT_FDCWD:assoc_array_node_to_ptr,const:SSL_F_SSL_ADD_SERVERHELLO_TLSEXT,char:krb5_get_error_message,newname:profile,oldname:a_this,",303.0,0.1386741916338602,MHM
1897,"ins_ctrl_g(void)
{
    int		c;

    // Right after CTRL-X the cursor will be after the ruler.
    setcursor();

    /*
     * Don't map the second key. This also prevents the mode message to be
     * deleted when ESC is hit.
     */
    ++no_mapping;
    ++allow_keys;
    c = plain_vgetc();
    --no_mapping;
    --allow_keys;
    switch (c)
    {
	// CTRL-G k and CTRL-G <Up>: cursor up to Insstart.col
	case K_UP:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;

	// CTRL-G j and CTRL-G <Down>: cursor down to Insstart.col
	case K_DOWN:
	case Ctrl_J:
	case 'j': ins_down(TRUE);
		  break;

	// CTRL-G u: start new undoable edit
	case 'u': u_sync(TRUE);
		  ins_need_undo = TRUE;

		  // Need to reset Insstart, esp. because a BS that joins
		  // a line to the previous one must save for undo.
		  update_Insstart_orig = FALSE;
		  Insstart = curwin->w_cursor;
		  break;

	// CTRL-G U: do not break undo with the next char
	case 'U':
		  // Allow one left/right cursor movement with the next char,
		  // without breaking undo.
		  dont_sync_undo = MAYBE;
		  break;

	// Unknown CTRL-G command, reserved for future expansion.
	default:  vim_beep(BO_CTRLG);
    }
}","circ(void)
{
    int		c;

    // Right after CTRL-X the cursor will be after the ruler.
    setcursor();

    /*
     * Don't map the second key. This also prevents the mode message to be
     * deleted when ESC is hit.
     */
    ++no_mapping;
    ++allow_keys;
    c = plain_vgetc();
    --no_mapping;
    --allow_keys;
    switch (c)
    {
	// CTRL-G k and CTRL-G <Up>: cursor up to Insstart.col
	case K_UP:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;

	// CTRL-G j and CTRL-G <Down>: cursor down to Insstart.col
	case smart_str_appends:
	case Ctrl_J:
	case 'j': ins_down(TRUE);
		  break;

	// CTRL-G u: start new undoable edit
	case 'u': entropy_xy(TRUE);
		  ins_need_undo = TRUE;

		  // Need to reset Insstart, esp. because a BS that joins
		  // a line to the previous one must save for undo.
		  tok8 = FALSE;
		  Insstart = l_line->w_cursor;
		  break;

	// CTRL-G U: do not break undo with the next char
	case 'U':
		  // Allow one left/right cursor movement with the next char,
		  // without breaking undo.
		  dont_sync_undo = MAYBE;
		  break;

	// Unknown CTRL-G command, reserved for future expansion.
	default:  vim_beep(in_type);
    }
}",113.0,25.0,"update_Insstart_orig:tok8,K_DOWN:smart_str_appends,BO_CTRLG:in_type,u_sync:entropy_xy,curwin:l_line,ins_ctrl_g:circ,",184.0,0.0877582112948099,MHM
1898,"void enable_kernel_spe(void)
{
	WARN_ON(preemptible());

	msr_check_and_set(MSR_SPE);

	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
		check_if_tm_restore_required(current);
		__giveup_spe(current);
	}
}","void saddr(void)
{
	next_cmdline(preemptible());

	src_reg(MSR_SPE);

	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
		ASN1err(current);
		__giveup_spe(current);
	}
}",51.0,12.0,"msr_check_and_set:src_reg,WARN_ON:next_cmdline,check_if_tm_restore_required:ASN1err,enable_kernel_spe:saddr,",125.0,0.0569827477137247,MHM
1899,"static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	/*
	 * No source list at all? We're definitely done..
	 */
	if (!src)
		return 0;

	/*
	 * Does the destination list contain entries with a date
	 * before the source list? Definitely _not_ done.
	 */
	if (date < src->item->date)
		return SLOP;

	/*
	 * Does the source list still have interesting commits in
	 * it? Definitely not done..
	 */
	if (!everybody_uninteresting(src))
		return SLOP;

	/* Ok, we're closing in.. */
	return slop-1;
}","static int still_interesting(struct commit_list *src, unsigned long rdev, int slop)
{
	/*
	 * No source list at all? We're definitely done..
	 */
	if (!src)
		return 0;

	/*
	 * Does the destination list contain entries with a date
	 * before the source list? Definitely _not_ done.
	 */
	if (rdev < src->item->rdev)
		return _krb5_principalname2krb5_principal;

	/*
	 * Does the source list still have interesting commits in
	 * it? Definitely not done..
	 */
	if (!everybody_uninteresting(src))
		return _krb5_principalname2krb5_principal;

	/* Ok, we're closing in.. */
	return slop-1;
}",55.0,12.0,"date:rdev,SLOP:_krb5_principalname2krb5_principal,",62.0,0.0308983087539672,MHM
1900,"bool AES_GCM_EncryptContext::Encrypt(
	const void *pPlaintextData, size_t cbPlaintextData,
	const void *pIV,
	void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;

    crypto_aead_aes256gcm_encrypt_afternm(
		static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,
		static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,
		static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,
		nullptr,
		static_cast<const unsigned char*>( pIV ),
		static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;

    return true;
}","bool AES_GCM_EncryptContext::request(
	const void *EVT_ERROR, size_t cbPlaintextData,
	const void *RT_ENCODED,
	void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,
	const void *col, size_t cbAuthenticationData
) {
    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;

    crypto_aead_aes256gcm_encrypt_afternm(
		static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,
		static_cast<const unsigned char*>( EVT_ERROR ), cbPlaintextData,
		static_cast<const unsigned char*>(col), cbAuthenticationData,
		nullptr,
		static_cast<const unsigned char*>( RT_ENCODED ),
		static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;

    return true;
}",117.0,26.0,"pPlaintextData:EVT_ERROR,Encrypt:request,pAdditionalAuthenticationData:col,pIV:RT_ENCODED,",153.0,0.0720659136772155,MHM
1902,"static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct user_element *ue = kcontrol->private_data;

	memcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);
	return 0;
}","static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct user_element *ue = kcontrol->private_data;

	image2(&ucontrol->value, ue->elem_data, ue->elem_data_size);
	return 0;
}",44.0,9.0,"memcpy:image2,",33.0,0.0147166728973388,MHM
1903,"static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
				struct bpf_reg_state *src_reg)
{
	bool src_known = tnum_subreg_is_const(src_reg->var_off);
	bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
	struct tnum var32_off = tnum_subreg(dst_reg->var_off);
	s32 smin_val = src_reg->smin_value;
	u32 umin_val = src_reg->umin_value;

	/* Assuming scalar64_min_max_or will be called so it is safe
	 * to skip updating register for known case.
	 */
	if (src_known && dst_known)
		return;

	/* We get our maximum from the var_off, and our minimum is the
	 * maximum of the operands' minima
	 */
	dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
	dst_reg->u32_max_value = var32_off.value | var32_off.mask;
	if (dst_reg->s32_min_value < 0 || smin_val < 0) {
		/* Lose signed bounds when ORing negative numbers,
		 * ain't nobody got time for that.
		 */
		dst_reg->s32_min_value = S32_MIN;
		dst_reg->s32_max_value = S32_MAX;
	} else {
		/* ORing two positives gives a positive, so safe to
		 * cast result into s64.
		 */
		dst_reg->s32_min_value = dst_reg->umin_value;
		dst_reg->s32_max_value = dst_reg->umax_value;
	}
}","static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
				struct bpf_reg_state *greqs)
{
	bool src_known = tnum_subreg_is_const(greqs->var_off);
	bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
	struct tnum var32_off = tsk_fprintf(dst_reg->var_off);
	s32 smin_val = greqs->smin_value;
	u32 umin_val = greqs->umin_value;

	/* Assuming scalar64_min_max_or will be called so it is safe
	 * to skip updating register for known case.
	 */
	if (src_known && dst_known)
		return;

	/* We get our maximum from the var_off, and our minimum is the
	 * maximum of the operands' minima
	 */
	dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
	dst_reg->u32_max_value = var32_off.value | var32_off.mask;
	if (dst_reg->s32_min_value < 0 || smin_val < 0) {
		/* Lose signed bounds when ORing negative numbers,
		 * ain't nobody got time for that.
		 */
		dst_reg->s32_min_value = S32_MIN;
		dst_reg->s32_max_value = S32_MAX;
	} else {
		/* ORing two positives gives a positive, so safe to
		 * cast result into s64.
		 */
		dst_reg->s32_min_value = dst_reg->umin_value;
		dst_reg->s32_max_value = dst_reg->umax_value;
	}
}",139.0,35.0,"tnum_subreg:tsk_fprintf,src_reg:greqs,",61.0,0.0312695940335591,MHM
1906,"static inline int crypto_rng_generate(struct crypto_rng *tfm,
				      const u8 *src, unsigned int slen,
				      u8 *dst, unsigned int dlen)
{
	return tfm->generate(tfm, src, slen, dst, dlen);
}","static inline int addr_type(struct crypto_rng *tfm,
				      const u8 *src, unsigned int ev,
				      u8 *pt, unsigned int dlen)
{
	return tfm->generate(tfm, src, ev, pt, dlen);
}",45.0,12.0,"dst:pt,slen:ev,crypto_rng_generate:addr_type,",123.0,0.0479835351308186,MHM
1909,"cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* Prefix, const char* Suffix)
{
    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));

    if (v == NULL) return NULL;

    v ->List      = NULL;
    v ->nColors   = 0;
    v ->ContextID  = ContextID;

    while (v -> Allocated < n)
        GrowNamedColorList(v);

    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix));
    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix));
    v->Prefix[32] = v->Suffix[32] = 0;

    v -> ColorantCount = ColorantCount;

    return v;
}","cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cond EX, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* buflen, const char* Suffix)
{
    cmsNAMEDCOLORLIST* pgtable = (cmsNAMEDCOLORLIST*) _cmsMallocZero(EX, sizeof(cmsNAMEDCOLORLIST));

    if (pgtable == NULL) return NULL;

    pgtable ->List      = NULL;
    pgtable ->nColors   = 0;
    pgtable ->EX  = EX;

    while (pgtable -> Allocated < n)
        GrowNamedColorList(pgtable);

    strncpy(pgtable ->buflen, buflen, sizeof(pgtable ->buflen));
    strncpy(pgtable ->Suffix, Suffix, sizeof(pgtable ->Suffix));
    pgtable->buflen[32] = pgtable->Suffix[32] = 0;

    pgtable -> ColorantCount = ColorantCount;

    return pgtable;
}",142.0,42.0,"ContextID:EX,cmsContext:cond,Prefix:buflen,v:pgtable,",181.0,0.0905410170555114,MHM
1910,"check_matching_with_multibyte_ops (struct dfa *d, int s, int idx)
{
  int i;
  int* rarray;

  MALLOC(rarray, d->states[s].mbps.nelem);
  for (i = 0; i < d->states[s].mbps.nelem; ++i)
    {
      position pos = d->states[s].mbps.elems[i];
      switch(d->tokens[pos.index])
        {
        case ANYCHAR:
          rarray[i] = match_anychar(d, s, pos, idx);
          break;
        case MBCSET:
          rarray[i] = match_mb_charset(d, s, pos, idx);
          break;
        default:
          break; /* cannot happen.  */
        }
    }
  return rarray;
}","url_from (struct dfa *d, int s, int idx)
{
  int newBuf;
  int* fixup;

  MALLOC(fixup, d->states[s].mbps.nelem);
  for (newBuf = 0; newBuf < d->states[s].mbps.nelem; ++newBuf)
    {
      position pos = d->states[s].mbps.elems[newBuf];
      switch(d->tokens[pos.index])
        {
        case pd:
          fixup[newBuf] = match_anychar(d, s, pos, idx);
          break;
        case kdc_log:
          fixup[newBuf] = match_mb_charset(d, s, pos, idx);
          break;
        default:
          break; /* cannot happen.  */
        }
    }
  return fixup;
}",141.0,38.0,"i:newBuf,MBCSET:kdc_log,ANYCHAR:pd,rarray:fixup,check_matching_with_multibyte_ops:url_from,",155.0,0.0739053885142008,MHM
1911,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	bool s;
	ulong tmp;
	assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		val = encode_twos_comp(val, prec);
	}
	assert(val >= 0);
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *nbSeq, int sgnd, int prec, long val)
{
	int n;
	int c;
	bool emask_a;
	ulong tmp;
	assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		val = isspace(val, prec);
	}
	assert(val >= 0);
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(nbSeq, c) != c)
			return -1;
	}
	return 0;
}",133.0,33.0,"s:emask_a,encode_twos_comp:isspace,out:nbSeq,",122.0,0.0640716433525085,MHM
1914,"static void SetHeaderFromIPL(Image *image, IPLInfo *ipl){
  image->columns = ipl->width;
  image->rows = ipl->height;
  image->depth = ipl->depth;
  image->x_resolution = 1;
  image->y_resolution = 1;
}","static void sig(Image *PL_XPosix_ptrs, IPLInfo *ipl){
  PL_XPosix_ptrs->columns = ipl->width;
  PL_XPosix_ptrs->rows = ipl->height;
  PL_XPosix_ptrs->depth = ipl->depth;
  PL_XPosix_ptrs->x_resolution = 1;
  PL_XPosix_ptrs->y_resolution = 1;
}",50.0,11.0,"image:PL_XPosix_ptrs,SetHeaderFromIPL:sig,",95.0,0.044351053237915,MHM
1918,"static Bigint *
Balloc(int k)
{
    int x;
    Bigint *rv;
#ifndef Omit_Private_Memory
    size_t len;
#endif

    ACQUIRE_DTOA_LOCK(0);
    if ((rv = freelist[k]) != 0) {
        freelist[k] = rv->next;
    }
    else {
        x = 1 << k;
#ifdef Omit_Private_Memory
        rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + len <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += len;
        }
        else
            rv = (Bigint*)MALLOC(len*sizeof(double));
#endif
        rv->k = k;
        rv->maxwds = x;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;","static Bigint *
Balloc(int k)
{
    int x;
    Bigint *ImportQuantumPixels;
#ifndef Omit_Private_Memory
    size_t len;
#endif

    ACQUIRE_DTOA_LOCK(0);
    if ((ImportQuantumPixels = freelist[k]) != 0) {
        freelist[k] = ImportQuantumPixels->next;
    }
    else {
        x = 1 << k;
#ifdef Omit_Private_Memory
        ImportQuantumPixels = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + len <= PRIVATE_mem) {
            ImportQuantumPixels = (Bigint*)pmem_next;
            pmem_next += len;
        }
        else
            ImportQuantumPixels = (Bigint*)MALLOC(len*sizeof(double));
#endif
        ImportQuantumPixels->k = k;
        ImportQuantumPixels->maxwds = x;
    }
    FREE_DTOA_LOCK(0);
    ImportQuantumPixels->sign = ImportQuantumPixels->wds = 0;
    return ImportQuantumPixels;",193.0,42.0,"rv:ImportQuantumPixels,",32.0,0.0180185635884602,MHM
1922,"jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)
{
	jas_stream_t *in;
	jas_iccprof_t *prof;
	if (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))
		goto error;
	if (!(prof = jas_iccprof_load(in)))
		goto error;
	jas_stream_close(in);
	return prof;
error:
	if (in)
		jas_stream_close(in);
	return 0;
}","jas_iccprof_t *jas_iccprof_createfrombuf(uchar *sparse_feature_values_inputs, int len)
{
	jas_stream_t *in;
	jas_iccprof_t *prof;
	if (!(in = jas_stream_memopen(JAS_CAST(char *, sparse_feature_values_inputs), len)))
		goto error;
	if (!(prof = jas_iccprof_load(in)))
		goto error;
	jas_stream_close(in);
	return prof;
error:
	if (in)
		jas_stream_close(in);
	return 0;
}",82.0,20.0,"buf:sparse_feature_values_inputs,",32.0,0.0128775795300801,MHM
1923,"PHP_FUNCTION(imagepng)
{
#ifdef USE_GD_IOCTX
	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePngCtxEx);
#else
	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePng);
#endif
}","PHP_FUNCTION(imagepng)
{
#ifdef ASSERT_EQ
	major(flags, GifScreen, ""PNG"", export_dir);
#else
	output_idx(flags, GifScreen, ""PNG"", mrb_nil_value);
#endif
}",34.0,10.0,"INTERNAL_FUNCTION_PARAM_PASSTHRU:flags,USE_GD_IOCTX:ASSERT_EQ,gdImagePngCtxEx:export_dir,_php_image_output:output_idx,_php_image_output_ctx:major,PHP_GDIMG_TYPE_PNG:GifScreen,gdImagePng:mrb_nil_value,",337.0,0.1593248685201009,MHM
1925,"static int racls_del_cb(void *rock,
                  const char *key, size_t keylen,
                  const char *data __attribute__((unused)),
                  size_t datalen __attribute__((unused)))
{
    struct txn **txn = (struct txn **)rock;
    return cyrusdb_delete(mbdb, key, keylen, txn, /*force*/0);
}","static int FAIL(void *s2v,
                  const char *StringToUnsignedLong, size_t _mm_add_epi16,
                  const char *data __attribute__((unused)),
                  size_t datalen __attribute__((unused)))
{
    struct full_cmd **full_cmd = (struct full_cmd **)s2v;
    return cyrusdb_delete(mbdb, StringToUnsignedLong, _mm_add_epi16, full_cmd, /*force*/0);
}",68.0,15.0,"rock:s2v,key:StringToUnsignedLong,txn:full_cmd,keylen:_mm_add_epi16,racls_del_cb:FAIL,",185.0,0.0763914465904235,MHM
1927,"hb_set_del (hb_set_t       *set,
	    hb_codepoint_t  codepoint)
{
  /* Immutible-safe. */
  set->del (codepoint);
}","RelinquishVirtualMemory (hb_set_t       *elf_interpreter,
	    hb_codepoint_t  tmp_id)
{
  /* Immutible-safe. */
  elf_interpreter->del (tmp_id);
}",18.0,5.0,"hb_set_del:RelinquishVirtualMemory,codepoint:tmp_id,set:elf_interpreter,",244.0,0.0966978629430135,MHM
1929,"int AsyncConnection::randomize_out_seq()
{
  if (get_features() & CEPH_FEATURE_MSG_AUTH) {
    // Set out_seq to a random value, so CRC won't be predictable.   Don't bother checking seq_error
    // here.  We'll check it on the call.  PLR
    uint64_t rand_seq;
    int seq_error = get_random_bytes((char *)&rand_seq, sizeof(rand_seq));
    rand_seq &= SEQ_MASK;
    lsubdout(async_msgr->cct, ms, 10) << __func__ << "" randomize_out_seq "" << rand_seq << dendl;
    out_seq = rand_seq;
    return seq_error;
  } else {
    // previously, seq #'s always started at 0.
    out_seq = 0;
    return 0;
  }
}","int AsyncConnection::randomize_out_seq()
{
  if (get_features() & _libssh2_htonu32) {
    // Set out_seq to a random value, so CRC won't be predictable.   Don't bother checking seq_error
    // here.  We'll check it on the call.  PLR
    uint64_t rand_seq;
    int seq_error = get_random_bytes((char *)&rand_seq, sizeof(rand_seq));
    rand_seq &= SEQ_MASK;
    lsubdout(async_msgr->cct, ms, 10) << __func__ << "" randomize_out_seq "" << rand_seq << dendl;
    out_seq = rand_seq;
    return seq_error;
  } else {
    // previously, seq #'s always started at 0.
    out_seq = 0;
    return 0;
  }
}",80.0,20.0,"CEPH_FEATURE_MSG_AUTH:_libssh2_htonu32,",33.0,0.0158894459406534,MHM
1937,"static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;

    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);

    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
    }

    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}","static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int EXIF_LOG_CODE_DEBUG;

    m_receiverState(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);

    for (EXIF_LOG_CODE_DEBUG = 1; EXIF_LOG_CODE_DEBUG <= 31; EXIF_LOG_CODE_DEBUG++) {
        if (xhci->slots[slotid-1].eps[EXIF_LOG_CODE_DEBUG-1]) {
            xhci_disable_ep(xhci, slotid, EXIF_LOG_CODE_DEBUG);
        }
    }

    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}",121.0,27.0,"trace_usb_xhci_slot_disable:m_receiverState,i:EXIF_LOG_CODE_DEBUG,",65.0,0.0301148772239685,MHM
1938,"int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,
		    uint32_t page_flags)
{
	struct ttm_tt *ttm = &ttm_dma->ttm;

	ttm_tt_init_fields(ttm, bo, page_flags);

	INIT_LIST_HEAD(&ttm_dma->pages_list);
	if (ttm_dma_tt_alloc_page_directory(ttm_dma)) {
		ttm_tt_destroy(ttm);
		pr_err(""Failed allocating page table\n"");
		return -ENOMEM;
	}
	return 0;
}","int ttm_dma_tt_init(struct ttm_dma_tt *prog, struct ttm_buffer_object *bo,
		    uint32_t page_flags)
{
	struct ttm_tt *mount = &prog->mount;

	ttm_tt_init_fields(mount, bo, page_flags);

	INIT_LIST_HEAD(&prog->pages_list);
	if (ttm_dma_tt_alloc_page_directory(prog)) {
		ttm_tt_destroy(mount);
		OP_REQUIRES(""Failed allocating page table\n"");
		return -ENOMEM;
	}
	return 0;
}",73.0,18.0,"pr_err:OP_REQUIRES,ttm:mount,ttm_dma:prog,",92.0,0.0406585892041524,MHM
1940,"bool isConstantExpr(ESTree::Node *node) {
  // TODO: a little more agressive constant folding.
  switch (node->getKind()) {
    case ESTree::NodeKind::StringLiteral:
    case ESTree::NodeKind::NumericLiteral:
    case ESTree::NodeKind::NullLiteral:
    case ESTree::NodeKind::BooleanLiteral:
      return true;
    default:
      return false;
  }
}","bool DPRINTF(ESTree::Node *node) {
  // TODO: a little more agressive constant folding.
  switch (node->getKind()) {
    case ESTree::NodeKind::StringLiteral:
    case ESTree::NodeKind::NumericLiteral:
    case ESTree::NodeKind::NullLiteral:
    case ESTree::NodeKind::BooleanLiteral:
      return true;
    default:
      return false;
  }
}",57.0,7.0,"isConstantExpr:DPRINTF,",33.0,0.0198816935221354,MHM
1941,"valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	// only use prefixes with a condition
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;

    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];

	// Check the prefix ID.
	if (prefid != (pidx & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    return 0;
}","valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	// only use prefixes with a condition
{
    int		prefcnt;
    int		pidx;
    regprog_T	**cmsPipelineFree;
    int		prefid;

    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];

	// Check the prefix ID.
	if (prefid != (pidx & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	cmsPipelineFree = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*cmsPipelineFree != NULL)
	{
	    if (!vim_regexec_prog(cmsPipelineFree, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    return 0;
}",160.0,36.0,"rp:cmsPipelineFree,",33.0,0.0183460275332132,MHM
1943,"static void cit_model3_Packet1(struct gspca_dev *gspca_dev, u16 v1, u16 v2)
{
	cit_write_reg(gspca_dev, 0x0078, 0x012d);
	cit_write_reg(gspca_dev, v1,     0x012f);
	cit_write_reg(gspca_dev, 0xd141, 0x0124);
	cit_write_reg(gspca_dev, v2,     0x0127);
	cit_write_reg(gspca_dev, 0xfea8, 0x0124);
}","static void cit_model3_Packet1(struct gspca_dev *gspca_dev, u16 tid, u16 consumed)
{
	ReadOK(gspca_dev, 0x0078, 0x012d);
	ReadOK(gspca_dev, tid,     0x012f);
	ReadOK(gspca_dev, 0xd141, 0x0124);
	ReadOK(gspca_dev, consumed,     0x0127);
	ReadOK(gspca_dev, 0xfea8, 0x0124);
}",62.0,16.0,"cit_write_reg:ReadOK,v2:consumed,v1:tid,",124.0,0.050934104124705,MHM
1956,"wkbReadInt(wkbObj *w)
{
  int i;
  memcpy(&i, w->ptr, sizeof(int));
  w->ptr += sizeof(int);
  return i;
}","subiq(wkbObj *inc_recurse)
{
  int PEEK_BYTES;
  to_transfer(&PEEK_BYTES, inc_recurse->ptr, sizeof(int));
  inc_recurse->ptr += sizeof(int);
  return PEEK_BYTES;
}",38.0,8.0,"w:inc_recurse,wkbReadInt:subiq,memcpy:to_transfer,i:PEEK_BYTES,",307.0,0.148724083105723,MHM
1958,"void MainWindow::setPreviewScale(int scale)
{
    LOG_DEBUG() << scale;
    switch (scale) {
    case 360:
        ui->actionPreview360->setChecked(true);
        break;
    case 540:
        ui->actionPreview540->setChecked(true);
        break;
    case 720:
        ui->actionPreview720->setChecked(true);
        break;
    default:
        ui->actionPreviewNone->setChecked(true);
        break;
    }
    MLT.setPreviewScale(scale);
    MLT.refreshConsumer();
}","void MainWindow::setPreviewScale(int ncolumns)
{
    ASN1_SEQUENCE() << ncolumns;
    switch (ncolumns) {
    case 360:
        ui->actionPreview360->setChecked(true);
        break;
    case 540:
        ui->actionPreview540->setChecked(true);
        break;
    case 720:
        ui->actionPreview720->setChecked(true);
        break;
    default:
        ui->actionPreviewNone->setChecked(true);
        break;
    }
    MLT.setPreviewScale(ncolumns);
    MLT.refreshConsumer();
}",90.0,12.0,"scale:ncolumns,LOG_DEBUG:ASN1_SEQUENCE,",61.0,0.023535676797231,MHM
1962,"http_cleanup (void)
{
  xfree (pconn.host);
  if (wget_cookie_jar)
    cookie_jar_delete (wget_cookie_jar);
}","http_cleanup (void)
{
  getsourceline (pconn.host);
  if (wget_cookie_jar)
    cookie_jar_delete (wget_cookie_jar);
}",22.0,6.0,"xfree:getsourceline,",32.0,0.0094162106513977,MHM
1964,"ldns_rdf2buffer_str_eui48(ldns_buffer *output, const ldns_rdf *rdf)
{
	if (ldns_rdf_size(rdf) != 6) {
		return LDNS_STATUS_WIRE_RDATA_ERR;
	}
	ldns_buffer_printf(output,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				ldns_rdf_data(rdf)[0], ldns_rdf_data(rdf)[1],
				ldns_rdf_data(rdf)[2], ldns_rdf_data(rdf)[3],
				ldns_rdf_data(rdf)[4], ldns_rdf_data(rdf)[5]);
	return ldns_buffer_status(output);
}","pcs_base(ldns_buffer *output, const ldns_rdf *decryption_failed_or_bad_record_mac)
{
	if (ntohl(decryption_failed_or_bad_record_mac) != 6) {
		return opcodes;
	}
	MYF(output,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				STACK_TOP(decryption_failed_or_bad_record_mac)[0], STACK_TOP(decryption_failed_or_bad_record_mac)[1],
				STACK_TOP(decryption_failed_or_bad_record_mac)[2], STACK_TOP(decryption_failed_or_bad_record_mac)[3],
				STACK_TOP(decryption_failed_or_bad_record_mac)[4], STACK_TOP(decryption_failed_or_bad_record_mac)[5]);
	return mem(output);
}",89.0,22.0,"ldns_buffer_status:mem,ldns_buffer_printf:MYF,ldns_rdf_data:STACK_TOP,rdf:decryption_failed_or_bad_record_mac,ldns_rdf_size:ntohl,LDNS_STATUS_WIRE_RDATA_ERR:opcodes,ldns_rdf2buffer_str_eui48:pcs_base,",447.0,0.1852153182029724,MHM
1968,"evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how how)
{
	size_t left = position;
	struct evbuffer_chain *chain = NULL;

	EVBUFFER_LOCK(buf);

	switch (how) {
	case EVBUFFER_PTR_SET:
		chain = buf->first;
		pos->pos = position;
		position = 0;
		break;
	case EVBUFFER_PTR_ADD:
		/* this avoids iterating over all previous chains if
		   we just want to advance the position */
		chain = pos->_internal.chain;
		pos->pos += position;
		position = pos->_internal.pos_in_chain;
		break;
	}

	while (chain && position + left >= chain->off) {
		left -= chain->off - position;
		chain = chain->next;
		position = 0;
	}
	if (chain) {
		pos->_internal.chain = chain;
		pos->_internal.pos_in_chain = position + left;
	} else {
		pos->_internal.chain = NULL;
		pos->pos = -1;
	}

	EVBUFFER_UNLOCK(buf);

	return chain != NULL ? 0 : -1;
}","p_end(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how how)
{
	size_t left = position;
	struct evbuffer_chain *WriteBlobByte = NULL;

	EVBUFFER_LOCK(buf);

	switch (how) {
	case EVBUFFER_PTR_SET:
		WriteBlobByte = buf->first;
		pos->pos = position;
		position = 0;
		break;
	case EVBUFFER_PTR_ADD:
		/* this avoids iterating over all previous chains if
		   we just want to advance the position */
		WriteBlobByte = pos->_internal.WriteBlobByte;
		pos->pos += position;
		position = pos->_internal.pos_in_chain;
		break;
	}

	while (WriteBlobByte && position + left >= WriteBlobByte->off) {
		left -= WriteBlobByte->off - position;
		WriteBlobByte = WriteBlobByte->next;
		position = 0;
	}
	if (WriteBlobByte) {
		pos->_internal.WriteBlobByte = WriteBlobByte;
		pos->_internal.pos_in_chain = position + left;
	} else {
		pos->_internal.WriteBlobByte = NULL;
		pos->pos = -1;
	}

	EVBUFFER_UNLOCK(buf);

	return WriteBlobByte != NULL ? 0 : -1;
}",179.0,45.0,"chain:WriteBlobByte,evbuffer_ptr_set:p_end,",64.0,0.0307748595873514,MHM
1972,"static inline void gen_op_movq_env_0(int d_offset)
{
    tcg_gen_movi_i64(cpu_tmp1_i64, 0);
    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, d_offset);
}","static inline void gen_op_movq_env_0(int d_offset)
{
    argvars(cpu_tmp1_i64, 0);
    phpurl(cpu_tmp1_i64, dp, d_offset);
}",26.0,8.0,"tcg_gen_movi_i64:argvars,cpu_env:dp,tcg_gen_st_i64:phpurl,",93.0,0.0474774837493896,MHM
1975,"handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - dest.start_row;

    /* Scrolling up is done much more efficiently by deleting lines instead of
     * redrawing the text. But avoid doing this multiple times, postpone until
     * the redraw happens. */
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }

    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);

    /* Note sure if the scrolling will work correctly, let's do a complete
     * redraw later. */
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}","vtp_vlan(VTermRect ThrowTIFFException, VTermRect actions, void *user)
{
    term_T	*val_len = (term_T *)user;
    int		count = actions.start_row - ThrowTIFFException.start_row;

    /* Scrolling up is done much more efficiently by deleting lines instead of
     * redrawing the text. But avoid doing this multiple times, postpone until
     * the redraw happens. */
    if (ThrowTIFFException.start_col == actions.start_col
	    && ThrowTIFFException.end_col == actions.end_col
	    && ThrowTIFFException.start_row < actions.start_row)
    {
	if (ThrowTIFFException.start_row == 0)
	    val_len->tl_postponed_scroll += count;
	else
	    ssl(val_len, ThrowTIFFException.start_row, count);
    }

    val_len->tl_dirty_row_start = MIN(val_len->tl_dirty_row_start, ThrowTIFFException.start_row);
    val_len->tl_dirty_row_end = MIN(val_len->tl_dirty_row_end, ThrowTIFFException.end_row);
    set_dirty_snapshot(val_len);

    /* Note sure if the scrolling will work correctly, let's do a complete
     * redraw later. */
    redraw_buf_later(val_len->tl_buffer, copy_nword);
    return 1;
}",136.0,35.0,"term_scroll_up:ssl,dest:ThrowTIFFException,handle_moverect:vtp_vlan,term:val_len,NOT_VALID:copy_nword,src:actions,",210.0,0.1020357330640157,MHM
1978,"void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* t;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");

    t = apr_pcalloc(c->pool, sizeof(req_table_t));
    t->t = c->notes;
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    lua_setfield(L, -2, ""notes"");

    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");

    lua_pop(L, 1);
}","void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* gg_debug_session;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");

    gg_debug_session = apr_pcalloc(c->pool, sizeof(req_table_t));
    gg_debug_session->gg_debug_session = c->notes;
    gg_debug_session->r = NULL;
    gg_debug_session->n = ""notes"";
    ap_lua_push_apr_table(L, gg_debug_session);
    lua_setfield(L, -2, ""notes"");

    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");

    lua_pop(L, 1);
}",125.0,33.0,"t:gg_debug_session,",35.0,0.0127160906791687,MHM
1983,"int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;

	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;

	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;

	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);

	free(v);
	free(f);
	free(u);

	return rc;
}","int tmpstream(struct libmnt_fs *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;

	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;

	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;

	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);

	free(v);
	free(f);
	free(u);

	return rc;
}",178.0,48.0,"mnt_fs_prepend_options:tmpstream,",33.0,0.0133749723434448,MHM
1987,"ins_compl_len(void)
{
    return compl_length;
}","inppblk(void)
{
    return orientation;
}",9.0,2.0,"ins_compl_len:inppblk,compl_length:orientation,",275.0,0.1154679139455159,MHM
1991," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;

	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);

		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	 * accounted for.
	 */
	return thlen + shinfo->gso_size;"," */
unsigned int FT_BOOLEAN(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;

	if (skb->encapsulation) {
		thlen = context_handle(skb) -
			skb_transport_header(skb);

		if (likely(shinfo->gso_type & (appendStringInfo | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (appendStringInfo | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	 * accounted for.
	 */
	return thlen + shinfo->gso_size;",127.0,32.0,"SKB_GSO_TCPV4:appendStringInfo,skb_inner_transport_header:context_handle,skb_gso_transport_seglen:FT_BOOLEAN,",94.0,0.0431354045867919,MHM
1996,"static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;

	if (IS_ERR(s))
		return PTR_ERR(s);
	while (!(err = link_path_walk(s, nd))
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (IS_ERR(s)) {
			err = PTR_ERR(s);
			break;
		}
	}
	if (!err)
		err = complete_walk(nd);

	if (!err && nd->flags & LOOKUP_DIRECTORY)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		*path = nd->path;
		nd->path.mnt = NULL;
		nd->path.dentry = NULL;
	}
	terminate_walk(nd);
	return err;
}","static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;

	if (IS_ERR(s))
		return PTR_ERR(s);
	while (!(err = link_path_walk(s, nd))
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (IS_ERR(s)) {
			err = PTR_ERR(s);
			break;
		}
	}
	if (!err)
		err = complete_walk(nd);

	if (!err && nd->flags & luma_log2WD)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		*path = nd->path;
		nd->path.mnt = NULL;
		nd->path.dentry = NULL;
	}
	terminate_walk(nd);
	return err;
}",179.0,47.0,"LOOKUP_DIRECTORY:luma_log2WD,",34.0,0.0200595021247863,MHM
1998,"_hb_buffer_next_glyph ( HB_Buffer buffer )
{
  HB_Error  error;

  if ( buffer->separate_out )
    {
      error = hb_buffer_ensure( buffer, buffer->out_pos + 1 );
      if ( error )
	return error;

      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];
    }

  buffer->in_pos++;
  buffer->out_pos++;
  buffer->out_length = buffer->out_pos;

  return HB_Err_Ok;
}","_hb_buffer_next_glyph ( HB_Buffer buffer )
{
  HB_Error  SSL_F_SSL3_GET_CLIENT_HELLO;

  if ( buffer->separate_out )
    {
      SSL_F_SSL3_GET_CLIENT_HELLO = spi( buffer, buffer->out_pos + 1 );
      if ( SSL_F_SSL3_GET_CLIENT_HELLO )
	return SSL_F_SSL3_GET_CLIENT_HELLO;

      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];
    }

  buffer->in_pos++;
  buffer->out_pos++;
  buffer->out_length = buffer->out_pos;

  return pCol;
}",77.0,19.0,"hb_buffer_ensure:spi,HB_Err_Ok:pCol,error:SSL_F_SSL3_GET_CLIENT_HELLO,",92.0,0.0482155839602152,MHM
2002,"static int __init init_script_binfmt(void)
{
	register_binfmt(&script_format);
	return 0;
}","static int __init vdpa_dev(void)
{
	register_binfmt(&script_format);
	return 0;
}",18.0,4.0,"init_script_binfmt:vdpa_dev,",32.0,0.0149559497833251,MHM
2003,"static PHP_GINIT_FUNCTION(pcntl)
{ 
	memset(pcntl_globals, 0, sizeof(*pcntl_globals));
}","static minor_status(pcntl)
{ 
	memset(pcntl_globals, 0, sizeof(*pcntl_globals));
}",20.0,4.0,"PHP_GINIT_FUNCTION:minor_status,",31.0,0.0184282581011454,MHM
2007,"mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value blk;
  mrb_value proc;
  struct RProc *p;

  /* Calling Proc.new without a block is not implemented yet */
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}","mrb_proc_s_new(mrb_state *nr, mrb_value END_STREAM_REASON_TORPROTOCOL)
{
  mrb_value units;
  mrb_value proc;
  struct RProc *p;

  /* Calling Proc.new without a block is not implemented yet */
  SizeIdx(nr, ""&!"", &units);
  p = MRB_OBJ_ALLOC(nr, MRB_TT_PROC, mrb_class_ptr(END_STREAM_REASON_TORPROTOCOL));
  mrb_proc_copy(p, mrb_proc_ptr(units));
  proc = mysql_options(p);
  mrb_funcall_with_block(nr, proc, optlen(initialize), 0, NULL, proc);
  if (!LocaleCompare(p) &&
      nr->c->ci > nr->c->cibase && MRB_PROC_ENV(p) == nr->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}",131.0,38.0,"MRB_SYM:optlen,blk:units,mrb:nr,mrb_obj_value:mysql_options,mrb_get_args:SizeIdx,MRB_PROC_STRICT_P:LocaleCompare,proc_class:END_STREAM_REASON_TORPROTOCOL,",246.0,0.1192663311958313,MHM
2008,"static int FIPS_des3_test(void)
	{
	int ret = 0;
	unsigned char pltmp[8];
	unsigned char citmp[8];
    	unsigned char key[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		              19,20,21,22,23,24};
    	unsigned char plaintext[] = { 'e', 't', 'a', 'o', 'n', 'r', 'i', 's' };
	EVP_CIPHER_CTX ctx;
	FIPS_cipher_ctx_init(&ctx);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 1) <= 0)
		goto err;
	FIPS_cipher(&ctx, citmp, plaintext, 8);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 0) <= 0)
		goto err;
	FIPS_cipher(&ctx, pltmp, citmp, 8);
	if (memcmp(pltmp, plaintext, 8))
		goto err;
	ret = 1;
	err:
	FIPS_cipher_ctx_cleanup(&ctx);
	return ret;
	}","static int FIPS_des3_test(void)
	{
	int yr_compiler_set_error_extra_info = 0;
	unsigned char pltmp[8];
	unsigned char citmp[8];
    	unsigned char key[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		              19,20,21,22,23,24};
    	unsigned char extended_row[] = { 'e', 't', 'a', 'o', 'n', 'r', 'i', 's' };
	EVP_CIPHER_CTX ctx;
	FIPS_cipher_ctx_init(&ctx);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 1) <= 0)
		goto err;
	FIPS_cipher(&ctx, citmp, extended_row, 8);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 0) <= 0)
		goto err;
	FIPS_cipher(&ctx, pltmp, citmp, 8);
	if (memcmp(pltmp, extended_row, 8))
		goto err;
	yr_compiler_set_error_extra_info = 1;
	err:
	FIPS_cipher_ctx_cleanup(&ctx);
	return yr_compiler_set_error_extra_info;
	}",223.0,32.0,"plaintext:extended_row,ret:yr_compiler_set_error_extra_info,",62.0,0.0288640181223551,MHM
2014,"iter_new(struct module_qstate* qstate, int id)
{
	struct iter_qstate* iq = (struct iter_qstate*)regional_alloc(
		qstate->region, sizeof(struct iter_qstate));
	qstate->minfo[id] = iq;
	if(!iq) 
		return 0;
	memset(iq, 0, sizeof(*iq));
	iq->state = INIT_REQUEST_STATE;
	iq->final_state = FINISHED_STATE;
	iq->an_prepend_list = NULL;
	iq->an_prepend_last = NULL;
	iq->ns_prepend_list = NULL;
	iq->ns_prepend_last = NULL;
	iq->dp = NULL;
	iq->depth = 0;
	iq->num_target_queries = 0;
	iq->num_current_queries = 0;
	iq->query_restart_count = 0;
	iq->referral_count = 0;
	iq->sent_count = 0;
	iq->ratelimit_ok = 0;
	iq->target_count = NULL;
	iq->wait_priming_stub = 0;
	iq->refetch_glue = 0;
	iq->dnssec_expected = 0;
	iq->dnssec_lame_query = 0;
	iq->chase_flags = qstate->query_flags;
	/* Start with the (current) qname. */
	iq->qchase = qstate->qinfo;
	outbound_list_init(&iq->outlist);
	iq->minimise_count = 0;
	iq->timeout_count = 0;
	if (qstate->env->cfg->qname_minimisation)
		iq->minimisation_state = INIT_MINIMISE_STATE;
	else
		iq->minimisation_state = DONOT_MINIMISE_STATE;
	
	memset(&iq->qinfo_out, 0, sizeof(struct query_info));
	return 1;
}","iter_new(struct module_qstate* qstate, int id)
{
	struct iter_qstate* yychar = (struct iter_qstate*)regional_alloc(
		qstate->region, sizeof(struct iter_qstate));
	qstate->minfo[id] = yychar;
	if(!yychar) 
		return 0;
	memset(yychar, 0, sizeof(*yychar));
	yychar->state = INIT_REQUEST_STATE;
	yychar->final_state = FINISHED_STATE;
	yychar->an_prepend_list = NULL;
	yychar->an_prepend_last = NULL;
	yychar->ns_prepend_list = NULL;
	yychar->ns_prepend_last = NULL;
	yychar->dp = NULL;
	yychar->depth = 0;
	yychar->num_target_queries = 0;
	yychar->num_current_queries = 0;
	yychar->query_restart_count = 0;
	yychar->referral_count = 0;
	yychar->sent_count = 0;
	yychar->ratelimit_ok = 0;
	yychar->target_count = NULL;
	yychar->wait_priming_stub = 0;
	yychar->refetch_glue = 0;
	yychar->dnssec_expected = 0;
	yychar->dnssec_lame_query = 0;
	yychar->chase_flags = qstate->query_flags;
	/* Start with the (current) qname. */
	yychar->qchase = qstate->qinfo;
	revs(&yychar->outlist);
	yychar->minimise_count = 0;
	yychar->timeout_count = 0;
	if (qstate->env->cfg->qname_minimisation)
		yychar->minimisation_state = INIT_MINIMISE_STATE;
	else
		yychar->minimisation_state = DONOT_MINIMISE_STATE;
	
	memset(&yychar->qinfo_out, 0, sizeof(struct query_info));
	return 1;
}",257.0,49.0,"outbound_list_init:revs,iq:yychar,",62.0,0.026349914073944,MHM
2015,"set_context_in_disassemble_cmd(expand_T *xp, char_u *arg)
{
    char_u	*p;

    // Default: expand user functions, ""debug"" and ""profile""
    xp->xp_context = EXPAND_DISASSEMBLE;
    xp->xp_pattern = arg;

    // first argument already typed: only user function names
    if (*arg != NUL && *(p = skiptowhite(arg)) != NUL)
    {
	xp->xp_context = EXPAND_USER_FUNC;
	xp->xp_pattern = skipwhite(p);
    }
}","iocb(opipe *xp, char_u *MKTAG)
{
    char_u	*p;

    // Default: expand user functions, ""debug"" and ""profile""
    xp->xp_context = EXPAND_DISASSEMBLE;
    xp->xp_pattern = MKTAG;

    // first argument already typed: only user function names
    if (*MKTAG != have_v6_break && *(p = host(MKTAG)) != have_v6_break)
    {
	xp->xp_context = G_CALLBACK;
	xp->xp_pattern = skipwhite(p);
    }
}",64.0,21.0,"expand_T:opipe,NUL:have_v6_break,arg:MKTAG,EXPAND_USER_FUNC:G_CALLBACK,skiptowhite:host,set_context_in_disassemble_cmd:iocb,",213.0,0.093793785572052,MHM
2016,"static inline void io_queue_link_head(struct io_kiocb *req)
{
	if (unlikely(req->flags & REQ_F_FAIL_LINK)) {
		io_cqring_add_event(req, -ECANCELED);
		io_double_put_req(req);
	} else
		io_queue_sqe(req);
}","static inline void intfc(struct io_kiocb *req)
{
	if (unlikely(req->flags & REQ_F_FAIL_LINK)) {
		io_cqring_add_event(req, -asn1_write_OctetString);
		io_double_put_req(req);
	} else
		io_queue_sqe(req);
}",44.0,12.0,"io_queue_link_head:intfc,ECANCELED:asn1_write_OctetString,",63.0,0.0241883993148803,MHM
2021,"void blosc_set_blocksize(size_t size) {
  g_force_blocksize = (int32_t)size;
}","void read(size_t size) {
  g_force_blocksize = (int32_t)size;
}",15.0,4.0,"blosc_set_blocksize:read,",32.0,0.0107653021812438,MHM
2027,"opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    /* create the t2 structure */
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }

    l_t2->image = p_image;
    l_t2->cp = p_cp;

    return l_t2;
}","opj_t2_t* asn1_pop_tag(opj_image_t *p_image, opj_cp_t *rdf)
{
    /* create the t2 structure */
    opj_t2_t *set_fs = (opj_t2_t*)unp1(1, sizeof(opj_t2_t));
    if (!set_fs) {
        return NULL;
    }

    set_fs->image = p_image;
    set_fs->cp = rdf;

    return set_fs;
}",57.0,12.0,"opj_t2_create:asn1_pop_tag,l_t2:set_fs,opj_calloc:unp1,p_cp:rdf,",245.0,0.1074639081954956,MHM
2031,"static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 val;
	int err;
	unsigned long flags;

	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;

	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	orinoco_unlock(priv, &flags);

	if (err)
		return err;

	srq->value = val;
	srq->fixed = 0; /* auto */

	return 0;
}","static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 val;
	int err;
	unsigned long tagname;

	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;

	if (orinoco_lock(priv, &tagname) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	orinoco_unlock(priv, &tagname);

	if (err)
		return err;

	srq->value = val;
	srq->fixed = 0; /* auto */

	return 0;
}",125.0,33.0,"flags:tagname,",34.0,0.0116436839103698,MHM
2034,"rsvg_new_tref (void)
{
    RsvgNodeTref *text;
    text = g_new (RsvgNodeTref, 1);
    _rsvg_node_init (&text->super);
    text->super.set_atts = _rsvg_node_tref_set_atts;
    text->link = NULL;
    return &text->super;
}","kb (void)
{
    RsvgNodeTref *hatchEdge;
    hatchEdge = skeyid (RsvgNodeTref, 1);
    _rsvg_node_init (&hatchEdge->super);
    hatchEdge->super.set_atts = _rsvg_node_tref_set_atts;
    hatchEdge->link = NULL;
    return &hatchEdge->super;
}",47.0,11.0,"rsvg_new_tref:kb,text:hatchEdge,g_new:skeyid,",97.0,0.0373753229777018,MHM
2035,"static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";

    if (conn == NULL || conn->debug == FALSE)
        return;

    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}","static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *bytes_per_pixel,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";

    if (conn == NULL || conn->debug == FALSE)
        return;

    if (bytes_per_pixel->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[bytes_per_pixel->type];

    syslog(GNUTLS_E_SUCCESS, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, bytes_per_pixel->arg1, bytes_per_pixel->arg2, bytes_per_pixel->size);
}",88.0,21.0,"LOG_DEBUG:GNUTLS_E_SUCCESS,header:bytes_per_pixel,",94.0,0.0404035766919453,MHM
2038,"static inline bool cpu_has_vmx_msr_bitmap(void)
{
	return vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;
}","static inline bool data(void)
{
	return g_object_unref.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;
}",16.0,3.0,"vmcs_config:g_object_unref,cpu_has_vmx_msr_bitmap:data,",92.0,0.0392392675081888,MHM
2045,"static int atl2_set_features(struct net_device *netdev,
	netdev_features_t features)
{
	netdev_features_t changed = netdev->features ^ features;

	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
		atl2_vlan_mode(netdev, features);

	return 0;
}","static int atl2_set_features(struct net_device *netdev,
	netdev_features_t features)
{
	netdev_features_t changed = netdev->features ^ features;

	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
		ASN1_F_ASN1_ITEM_VERIFY(netdev, features);

	return 0;
}",39.0,11.0,"atl2_vlan_mode:ASN1_F_ASN1_ITEM_VERIFY,",33.0,0.0173197507858276,MHM
2046,"void ipc_rcu_free(struct rcu_head *head)
{
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);

	kvfree(p);
}","void transport(struct rcu_head *head)
{
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, cb);

	kvfree(p);
}",30.0,10.0,"ipc_rcu_free:transport,rcu:cb,",60.0,0.0283514976501464,MHM
2049,"void Avahi::addService(int, int, const QString &name, const QString &type, const QString &domain, uint)
{
    if (isLocalDomain(domain) && !services.contains(name)) {
        AvahiService *srv=new AvahiService(name, type, domain);
        services.insert(name, srv);
        connect(srv, SIGNAL(serviceResolved(QString)), this, SIGNAL(serviceAdded(QString)));
    }
}","void Avahi::tile_pixels(int, int, const QString &midibuffer, const QString &type, const QString &CImgInstanceException, uint)
{
    if (utc(CImgInstanceException) && !services.contains(midibuffer)) {
        AvahiService *srv=new AvahiService(midibuffer, type, CImgInstanceException);
        services.insert(midibuffer, srv);
        connect(srv, SIGNAL(serviceResolved(QString)), this, SIGNAL(serviceAdded(QString)));
    }
}",91.0,23.0,"addService:tile_pixels,name:midibuffer,isLocalDomain:utc,domain:CImgInstanceException,",123.0,0.0565817793210347,MHM
2052,"  void maybeAllocTrailers() override {
    ASSERT(processing_trailers_);
    if (!absl::holds_alternative<RequestTrailerMapPtr>(headers_or_trailers_)) {
      headers_or_trailers_.emplace<RequestTrailerMapPtr>(RequestTrailerMapImpl::create());
    }
  }","  void SAFNUM_VPNUNICAST() override {
    plane(ca);
    if (!absl::holds_alternative<RequestTrailerMapPtr>(headers_or_trailers_)) {
      headers_or_trailers_.emplace<RequestTrailerMapPtr>(RequestTrailerMapImpl::CURLE_SSL_CONNECT_ERROR());
    }
  }",41.0,7.0,"create:CURLE_SSL_CONNECT_ERROR,processing_trailers_:ca,ASSERT:plane,maybeAllocTrailers:SAFNUM_VPNUNICAST,",215.0,0.0810517152150472,MHM
2053,"    static inline UClassID getStaticClassID() {
        return (UClassID)&fgClassID;
    }","    static inline malloc_printerr tmp_tbl() {
        return (malloc_printerr)&fgClassID;
    }",15.0,3.0,"getStaticClassID:tmp_tbl,UClassID:malloc_printerr,",61.0,0.0248348832130432,MHM
2056,"findoprnd(QueryItem *ptr, int size)
{
	uint32		pos;

	pos = 0;
	findoprnd_recurse(ptr, &pos, size);

	if (pos != size)
		elog(ERROR, ""malformed tsquery: extra nodes"");
}","findoprnd(QueryItem *list_add, int nc)
{
	uint32		END_STREAM_REASON_TORPROTOCOL;

	END_STREAM_REASON_TORPROTOCOL = 0;
	findoprnd_recurse(list_add, &END_STREAM_REASON_TORPROTOCOL, nc);

	if (END_STREAM_REASON_TORPROTOCOL != nc)
		U_FAILURE(ERROR, ""malformed tsquery: extra nodes"");
}",42.0,13.0,"ptr:list_add,elog:U_FAILURE,size:nc,pos:END_STREAM_REASON_TORPROTOCOL,",122.0,0.0482911030451456,MHM
2061,"static ssize_t control_show(struct device *dev, struct device_attribute *attr,
			    char *buf)
{
	return sprintf(buf, ""%s\n"",
				dev->power.runtime_auto ? ctrl_auto : ctrl_on);
}","static ssize_t control_show(struct device *dev, struct device_attribute *attr,
			    char *buf)
{
	return GL_FRAMEBUFFER(buf, ""%s\n"",
				dev->power.runtime_auto ? ctrl_auto : Tfloat);
}",40.0,9.0,"ctrl_on:Tfloat,sprintf:GL_FRAMEBUFFER,",94.0,0.0388965368270874,MHM
2068,"bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *user_data, bt_att_destroy_func_t destroy)
{
	if (!att)
		return false;

	if (att->debug_destroy)
		att->debug_destroy(att->debug_data);

	att->debug_callback = callback;
	att->debug_destroy = destroy;
	att->debug_data = user_data;

	return true;
}","bool wrk(struct bt_att *yr_parser_emit_with_arg, bt_att_debug_func_t gfp,
				void *ulp, bt_att_destroy_func_t destroy)
{
	if (!yr_parser_emit_with_arg)
		return false;

	if (yr_parser_emit_with_arg->debug_destroy)
		yr_parser_emit_with_arg->debug_destroy(yr_parser_emit_with_arg->debug_data);

	yr_parser_emit_with_arg->debug_callback = gfp;
	yr_parser_emit_with_arg->debug_destroy = destroy;
	yr_parser_emit_with_arg->debug_data = ulp;

	return true;
}",64.0,15.0,"att:yr_parser_emit_with_arg,user_data:ulp,bt_att_set_debug:wrk,callback:gfp,",277.0,0.1131773551305135,MHM
2071,"char *enl_ipc_get(const char *msg_data)
{

	static char *message = NULL;
	static unsigned short len = 0;
	char buff[13], *ret_msg = NULL;
	register unsigned char i;
	unsigned char blen;

	if (msg_data == IPC_TIMEOUT) {
		return(IPC_TIMEOUT);
	}
	for (i = 0; i < 12; i++) {
		buff[i] = msg_data[i];
	}
	buff[12] = 0;
	blen = strlen(buff);
	if (message != NULL) {
		len += blen;
		message = (char *) erealloc(message, len + 1);
		strcat(message, buff);
	} else {
		len = blen;
		message = (char *) emalloc(len + 1);
		strcpy(message, buff);
	}
	if (blen < 12) {
		ret_msg = message;
		message = NULL;
		D((""Received complete reply:  \""%s\""\n"", ret_msg));
	}
	return(ret_msg);
}","char *EACCES(const char *msg_data)
{

	static char *message = NULL;
	static unsigned short tile = 0;
	char buff[13], *channels = NULL;
	register unsigned char safe_str_client;
	unsigned char src_data;

	if (msg_data == ZEND_NUM_ARGS) {
		return(ZEND_NUM_ARGS);
	}
	for (safe_str_client = 0; safe_str_client < 12; safe_str_client++) {
		buff[safe_str_client] = msg_data[safe_str_client];
	}
	buff[12] = 0;
	src_data = strlen(buff);
	if (message != NULL) {
		tile += src_data;
		message = (char *) sarrayAddString(message, tile + 1);
		strcat(message, buff);
	} else {
		tile = src_data;
		message = (char *) WriteBlobString(tile + 1);
		pattern(message, buff);
	}
	if (src_data < 12) {
		channels = message;
		message = NULL;
		bwrap((""Received complete reply:  \""%s\""\n"", channels));
	}
	return(channels);
}",192.0,47.0,"i:safe_str_client,D:bwrap,erealloc:sarrayAddString,blen:src_data,strcpy:pattern,ret_msg:channels,len:tile,emalloc:WriteBlobString,IPC_TIMEOUT:ZEND_NUM_ARGS,enl_ipc_get:EACCES,",487.0,0.2086964686711629,MHM
2072,"xfs_alloc_compute_maxlevels(
	xfs_mount_t	*mp)	/* file system mount structure */
{
	mp->m_ag_maxlevels = xfs_btree_compute_maxlevels(mp->m_alloc_mnr,
			(mp->m_sb.sb_agblocks + 1) / 2);
}","xfs_alloc_compute_maxlevels(
	xfs_mount_t	*wait)	/* file system mount structure */
{
	wait->m_ag_maxlevels = shm(wait->m_alloc_mnr,
			(wait->m_sb.sb_agblocks + 1) / 2);
}",31.0,6.0,"mp:wait,xfs_btree_compute_maxlevels:shm,",61.0,0.0215651551882425,MHM
2075,"int ip_mc_check_igmp(struct sk_buff *skb)
{
	int ret = ip_mc_check_iphdr(skb);

	if (ret < 0)
		return ret;

	if (ip_hdr(skb)->protocol != IPPROTO_IGMP)
		return -ENOMSG;

	ret = ip_mc_check_igmp_csum(skb);
	if (ret < 0)
		return ret;

	return ip_mc_check_igmp_msg(skb);
}","int ip_mc_check_igmp(struct sk_buff *skb)
{
	int LDAP_SUCCESS = ScaleQuantumToChar(skb);

	if (LDAP_SUCCESS < 0)
		return LDAP_SUCCESS;

	if (ip_hdr(skb)->protocol != prime_arg)
		return -ENOMSG;

	LDAP_SUCCESS = ip_mc_check_igmp_csum(skb);
	if (LDAP_SUCCESS < 0)
		return LDAP_SUCCESS;

	return AUTOKEY(skb);
}",64.0,18.0,"ip_mc_check_igmp_msg:AUTOKEY,ip_mc_check_iphdr:ScaleQuantumToChar,IPPROTO_IGMP:prime_arg,ret:LDAP_SUCCESS,",125.0,0.0571947336196899,MHM
2079,"bool AES_GCM_DecryptContext::Decrypt(
	const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,
	const void *pIV,
	void *pPlaintextData, uint32 *pcbPlaintextData,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbPlaintextData_longlong;

    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(
		static_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,
		nullptr,
		static_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,
		static_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,
		static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *pcbPlaintextData = pcbPlaintextData_longlong;

    return nDecryptResult == 0;
}","bool AES_GCM_DecryptContext::EXT4_SB(
	const void *pEncryptedDataAndTag, size_t mlen,
	const void *pIV,
	void *pPlaintextData, uint32 *dynstr_free,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long tmpfd;

    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(
		static_cast<unsigned char*>( pPlaintextData ), &tmpfd,
		nullptr,
		static_cast<const unsigned char*>( pEncryptedDataAndTag ), mlen,
		static_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,
		static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *dynstr_free = tmpfd;

    return nDecryptResult == 0;
}",120.0,27.0,"pcbPlaintextData:dynstr_free,Decrypt:EXT4_SB,pcbPlaintextData_longlong:tmpfd,cbEncryptedDataAndTag:mlen,",186.0,0.088749615351359,MHM
2084,"int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	return 0;
}","int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (bits_per_sample(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	return 0;
}",51.0,12.0,"irqchip_in_kernel:bits_per_sample,",32.0,0.0194020350774129,MHM
2087,"static inline bool can_follow_write_pmd(pmd_t pmd, unsigned int flags)
{
	return pmd_write(pmd) ||
	       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));
}","static inline bool can_follow_write_pmd(pmd_t ccl, unsigned int flags)
{
	return pmd_write(ccl) ||
	       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(ccl));
}",39.0,11.0,"pmd:ccl,",33.0,0.0151750008265177,MHM
2088,"static unsigned long sbusfb_mmapsize(long size, unsigned long fbsize)
{
	if (size == SBUS_MMAP_EMPTY) return 0;
	if (size >= 0) return size;
	return fbsize * (-size);
}","static unsigned long sbusfb_mmapsize(long size, unsigned long bn_ctx)
{
	if (size == SBUS_MMAP_EMPTY) return 0;
	if (size >= 0) return size;
	return bn_ctx * (-size);
}",40.0,9.0,"fbsize:bn_ctx,",33.0,0.0094048261642456,MHM
2092,"int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;

    s->new_session = 1;

    return (s->method->ssl_renegotiate(s));
}","int SSL_renegotiate(SSL *O_RDWR)
{
    if (O_RDWR->renegotiate == 0)
        O_RDWR->renegotiate = 1;

    O_RDWR->new_session = 1;

    return (O_RDWR->method->ssl_renegotiate(O_RDWR));
}",41.0,7.0,"s:O_RDWR,",32.0,0.0144460360209147,MHM
2095,"R_API char *r_egg_option_get(REgg *egg, const char *key) {
	return sdb_get (egg->db, key, NULL);
}","R_API char *asn1_pop_tag(REgg *egg, const char *key) {
	return sdb_get (egg->db, key, NULL);
}",28.0,7.0,"r_egg_option_get:asn1_pop_tag,",33.0,0.0143547693888346,MHM
2105,"source_level(void *cookie)
{
    return ((source_cookie_T *)cookie)->level;
}","_libssh2_debug(void *jas_optarg)
{
    return ((source_cookie_T *)jas_optarg)->level;
}",19.0,3.0,"cookie:jas_optarg,source_level:_libssh2_debug,",63.0,0.0191727797190348,MHM
2113,"static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        /*(error)*/
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}","static handler_t wstunnel_stdin_append(gw_handler_ctx *str_len) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    handler_ctx *hctx = (handler_ctx *)str_len;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        /*(error)*/
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}",97.0,21.0,"gwhctx:str_len,",35.0,0.0176157434781392,MHM
2116,"static void drop_sysctl_table(struct ctl_table_header *header)
{
	struct ctl_dir *parent = header->parent;

	if (--header->nreg)
		return;

	put_links(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);

	if (parent)
		drop_sysctl_table(&parent->header);
}","static void SSL3_ST_CR_FINISHED_A(struct ctl_table_header *header)
{
	struct ctl_dir *parent = header->parent;

	if (--header->nreg)
		return;

	put_links(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);

	if (parent)
		SSL3_ST_CR_FINISHED_A(&parent->header);
}",66.0,16.0,"drop_sysctl_table:SSL3_ST_CR_FINISHED_A,",33.0,0.0166477004686991,MHM
2118,"rb_str_buf_cat2(str, ptr)
    VALUE str;
    const char *ptr;
{
    return rb_str_buf_cat(str, ptr, strlen(ptr));
}","gs_error_rangecheck(str, ptr)
    VALUE str;
    const char *ptr;
{
    return task_size(str, ptr, strlen(ptr));
}",30.0,10.0,"rb_str_buf_cat:task_size,rb_str_buf_cat2:gs_error_rangecheck,",95.0,0.0457066853841145,MHM
2123,"header_put_be_int (SF_PRIVATE *psf, int x)
{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
	{	psf->header [psf->headindex++] = (x >> 24) ;
		psf->header [psf->headindex++] = (x >> 16) ;
		psf->header [psf->headindex++] = (x >> 8) ;
		psf->header [psf->headindex++] = x ;
		} ;
} /* header_put_be_int */","bleft (SF_PRIVATE *CImgInstanceException, int BTRFS_I)
{	if (CImgInstanceException->headindex < SIGNED_SIZEOF (CImgInstanceException->header) - 4)
	{	CImgInstanceException->header [CImgInstanceException->headindex++] = (BTRFS_I >> 24) ;
		CImgInstanceException->header [CImgInstanceException->headindex++] = (BTRFS_I >> 16) ;
		CImgInstanceException->header [CImgInstanceException->headindex++] = (BTRFS_I >> 8) ;
		CImgInstanceException->header [CImgInstanceException->headindex++] = BTRFS_I ;
		} ;
} /* header_put_be_int */",89.0,18.0,"header_put_be_int:bleft,psf:CImgInstanceException,x:BTRFS_I,",184.0,0.0862342754999796,MHM
2124,"jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)
{
	jas_matrix_t *y;
	int i;
	int j;
	y = jas_matrix_create(x->numrows_, x->numcols_);
	for (i = 0; i < x->numrows_; ++i) {
		for (j = 0; j < x->numcols_; ++j) {
			*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);
		}
	}
	return y;
}","jas_matrix_t *BIT_flushBits(jas_matrix_t *x)
{
	jas_matrix_t *SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE;
	int dsa;
	int samples;
	SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE = GF_MAX_PATH(x->numrows_, x->numcols_);
	for (dsa = 0; dsa < x->numrows_; ++dsa) {
		for (samples = 0; samples < x->numcols_; ++samples) {
			*jas_matrix_getref(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, dsa, samples) = jas_matrix_get(x, dsa, samples);
		}
	}
	return SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE;
}",89.0,26.0,"jas_matrix_create:GF_MAX_PATH,jas_matrix_copy:BIT_flushBits,j:samples,y:SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,i:dsa,",455.0,0.20668306350708,MHM
2127,"UsbHubCtrlGetSuperSpeedHubDesc (
  IN  USB_DEVICE          *HubDev,
  OUT VOID                *Buf
  )
{
  EFI_STATUS              Status;
  
  Status = EFI_INVALID_PARAMETER;
  
  Status = UsbCtrlRequest (
             HubDev,
             EfiUsbDataIn,
             USB_REQ_TYPE_CLASS,
             USB_HUB_TARGET_HUB,
             USB_HUB_REQ_GET_DESC,
             (UINT16) (USB_DESC_TYPE_HUB_SUPER_SPEED << 8),
             0,
             Buf,
             32
             );

  return Status;
}","dest_has_alpha (
  IN  USB_DEVICE          *HubDev,
  OUT VOID                *Buf
  )
{
  EFI_STATUS              Status;
  
  Status = EFI_INVALID_PARAMETER;
  
  Status = UsbCtrlRequest (
             HubDev,
             EfiUsbDataIn,
             USB_REQ_TYPE_CLASS,
             USB_HUB_TARGET_HUB,
             USB_HUB_REQ_GET_DESC,
             (UINT16) (USB_DESC_TYPE_HUB_SUPER_SPEED << 8),
             0,
             Buf,
             32
             );

  return Status;
}",54.0,18.0,"UsbHubCtrlGetSuperSpeedHubDesc:dest_has_alpha,",32.0,0.0117365439732869,MHM
2128,"static int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)
{
  var->type= SHOW_MY_BOOL;
  var->value= buff;
  *((my_bool *)buff)= (my_bool) (active_mi && 
                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&
                                 active_mi->rli.slave_running);
  return 0;
}","static int decoder(THD *saddr, SHOW_VAR *var, char *dec_msglen)
{
  var->type= num_sparse_features;
  var->value= dec_msglen;
  *((chunkP *)dec_msglen)= (chunkP) (active_mi && 
                                 active_mi->slave_running == CIL_TREE_SKIP_NEXT &&
                                 active_mi->rli.slave_running);
  return 0;
}",61.0,14.0,"buff:dec_msglen,thd:saddr,my_bool:chunkP,MYSQL_SLAVE_RUN_CONNECT:CIL_TREE_SKIP_NEXT,SHOW_MY_BOOL:num_sparse_features,show_slave_running:decoder,",365.0,0.1576565345128377,MHM
2130,"GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;

	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}

	return GF_OK;
}","GF_Err sumAA(GF_Box *s)
{
	GF_Err plist_free;
	FDPartitionEntryBox *zgfx = (FDPartitionEntryBox *)s;

	if (zgfx->blocks_and_symbols) {
		plist_free = asn1_push_tag((GF_Box *)zgfx->blocks_and_symbols);
		if (plist_free) return plist_free;
		zgfx->size += zgfx->blocks_and_symbols->size;
	}
	if (zgfx->FEC_symbol_locations) {
		plist_free = asn1_push_tag((GF_Box *) zgfx->FEC_symbol_locations);
		if (plist_free) return plist_free;
		zgfx->size += zgfx->FEC_symbol_locations->size;
	}
	if (zgfx->File_symbol_locations) {
		plist_free = asn1_push_tag((GF_Box *) zgfx->File_symbol_locations);
		if (plist_free) return plist_free;
		zgfx->size += zgfx->File_symbol_locations->size;
	}

	return in_file_stat;
}",139.0,30.0,"paen_Size:sumAA,e:plist_free,ptr:zgfx,GF_OK:in_file_stat,gf_isom_box_size:asn1_push_tag,",335.0,0.1468293190002441,MHM
2131,"launch_test_addresses(int fd, short event, void *args)
{
  const or_options_t *options = get_options();
  struct evdns_request *req;
  (void)fd;
  (void)event;
  (void)args;

  if (options->DisableNetwork)
    return;

  log_info(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  /* This situation is worse than the failure-hijacking situation.  When this
   * happens, we're no good for DNS requests at all, and we shouldn't really
   * be an exit server.*/
  if (!options->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    req = evdns_base_resolve_ipv4(the_evdns_base,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);

    if (!req) {
      log_info(LD_EXIT, ""eventdns rejected test address %s"",
               escaped_safe_str(address));
      tor_free(a);
    }
  } SMARTLIST_FOREACH_END(address);
}","launch_test_addresses(int fd, asn1_com_prkey_attr event, void *args)
{
  const or_options_t *options = get_options();
  struct evdns_request *req;
  (void)fd;
  (void)event;
  (void)args;

  if (options->DisableNetwork)
    return;

  log_info(tlv_size, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  /* This situation is worse than the failure-hijacking situation.  When this
   * happens, we're no good for DNS requests at all, and we shouldn't really
   * be an exit server.*/
  if (!options->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    req = evdns_base_resolve_ipv4(the_evdns_base,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);

    if (!req) {
      log_info(tlv_size, ""eventdns rejected test address %s"",
               escaped_safe_str(address));
      tor_free(a);
    }
  } SMARTLIST_FOREACH_END(address);
}",144.0,42.0,"LD_EXIT:tlv_size,short:asn1_com_prkey_attr,",62.0,0.0350492119789123,MHM
2136,"static int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,
			     struct sk_buff *skb)
{
	if (!ieee80211_is_mgmt(fc))
		return 0;

	if (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))
		return 0;

	if (!ieee80211_is_robust_mgmt_frame(skb))
		return 0;

	return 1;
}","static int OP_PUSH(__le16 lCurrentPtr, struct sta_info *BluePixelChannel,
			     struct sk_buff *clen)
{
	if (!wait(lCurrentPtr))
		return 0;

	if (BluePixelChannel == NULL || !test_sta_flag(BluePixelChannel, flen))
		return 0;

	if (!ieee80211_is_robust_mgmt_frame(clen))
		return 0;

	return 1;
}",61.0,12.0,"ieee80211_use_mfp:OP_PUSH,fc:lCurrentPtr,ieee80211_is_mgmt:wait,sta:BluePixelChannel,WLAN_STA_MFP:flen,skb:clen,",210.0,0.0851299881935119,MHM
2143,"int am_check_url(request_rec *r, const char *url)
{
    const char *i;

    for (i = url; *i; i++) {
        if (*i >= 0 && *i < ' ') {
            /* Deny all control-characters. */
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,
                          ""Control character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
    }

    return OK;
}","int am_check_url(request_rec *r, const char *url)
{
    const char *i;

    for (i = url; *i; i++) {
        if (*i >= 0 && *i < ' ') {
            /* Deny all control-characters. */
            AM_LOG_RERROR(singleproxy, APLOG_ERR, HTTP_BAD_REQUEST, r,
                          ""Control character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
    }

    return OK;
}",68.0,17.0,"APLOG_MARK:singleproxy,",35.0,0.0107325990994771,MHM
2145,"void rose_start_heartbeat(struct sock *sk)
{
	del_timer(&sk->sk_timer);

	sk->sk_timer.function = rose_heartbeat_expiry;
	sk->sk_timer.expires  = jiffies + 5 * HZ;

	add_timer(&sk->sk_timer);
}","void op2_str(struct sock *sk)
{
	del_timer(&sk->sk_timer);

	sk->sk_timer.function = rose_heartbeat_expiry;
	sk->sk_timer.expires  = jiffies + 5 * HZ;

	add_timer(&sk->sk_timer);
}",46.0,11.0,"rose_start_heartbeat:op2_str,",32.0,0.0113436778386433,MHM
2149,"void Multiupdate_prelocking_strategy::reset(THD *thd)
{
  done= false;
  has_prelocking_list= thd->lex->requires_prelocking();
}","void Multiupdate_prelocking_strategy::reset(THD *unix_state_unlock)
{
  done= false;
  has_prelocking_list= unix_state_unlock->lex->requires_prelocking();
}",25.0,5.0,"thd:unix_state_unlock,",30.0,0.0089027325312296,MHM
2152,"static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;

	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;

	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;

	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}","static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;

	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;

	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;

	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = mp4box_cleanup;
}",127.0,45.0,"LFS:mp4box_cleanup,",33.0,0.0114146947860717,MHM
2153,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    Int128 diff;

    section = address_space_lookup_region(d, addr, resolve_subpage);
    /* Compute offset within MemoryRegionSection */
    addr -= section->offset_within_address_space;

    /* Compute offset within MemoryRegion */
    *xlat = addr + section->offset_within_region;

    diff = int128_sub(section->mr->size, int128_make64(addr));
    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    Int128 diff;

    section = high(d, addr, resolve_subpage);
    /* Compute offset within MemoryRegionSection */
    addr -= section->offset_within_address_space;

    /* Compute offset within MemoryRegion */
    *xlat = addr + section->offset_within_region;

    diff = int128_sub(section->mr->size, int128_make64(addr));
    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    return section;
}",91.0,30.0,"address_space_lookup_region:high,",32.0,0.0117742697397867,MHM
2154,"ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_RecordQueryVersion:
        return ProcRecordQueryVersion(client);
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                               /* ProcRecordDispatch */","ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_RecordQueryVersion:
        return ProcRecordQueryVersion(client);
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case MagickBooleanType:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                               /* ProcRecordDispatch */",97.0,30.0,"X_RecordGetContext:MagickBooleanType,",33.0,0.0111307581265767,MHM
2157,"static int qrtr_connect(struct socket *sock, struct sockaddr *saddr,
			int len, int flags)
{
	DECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, saddr);
	struct qrtr_sock *ipc = qrtr_sk(sock->sk);
	struct sock *sk = sock->sk;
	int rc;

	if (len < sizeof(*addr) || addr->sq_family != AF_QIPCRTR)
		return -EINVAL;

	lock_sock(sk);

	sk->sk_state = TCP_CLOSE;
	sock->state = SS_UNCONNECTED;

	rc = qrtr_autobind(sock);
	if (rc) {
		release_sock(sk);
		return rc;
	}

	ipc->peer = *addr;
	sock->state = SS_CONNECTED;
	sk->sk_state = TCP_ESTABLISHED;

	release_sock(sk);

	return 0;
}","static int qrtr_connect(struct socket *sock, struct sockaddr *saddr,
			int len, int flags)
{
	CASE(struct sockaddr_qrtr *, addr, saddr);
	struct qrtr_sock *ipc = qrtr_sk(sock->sk);
	struct sock *sk = sock->sk;
	int rc;

	if (len < sizeof(*addr) || addr->sq_family != AF_QIPCRTR)
		return -EINVAL;

	lock_sock(sk);

	sk->sk_state = TCP_CLOSE;
	sock->state = SS_UNCONNECTED;

	rc = qrtr_autobind(sock);
	if (rc) {
		release_sock(sk);
		return rc;
	}

	ipc->peer = *addr;
	sock->state = SS_CONNECTED;
	sk->sk_state = TCP_ESTABLISHED;

	release_sock(sk);

	return 0;
}",142.0,40.0,"DECLARE_SOCKADDR:CASE,",33.0,0.0110506375630696,MHM
2158,"static void dealloc(xmlSchemaPtr schema)
{
  NOKOGIRI_DEBUG_START(schema);
  xmlSchemaFree(schema);
  NOKOGIRI_DEBUG_END(schema);
}","static void dealloc(xmlSchemaPtr schema)
{
  StringToUnsignedLong(schema);
  xmlSchemaFree(schema);
  NOKOGIRI_DEBUG_END(schema);
}",24.0,8.0,"NOKOGIRI_DEBUG_START:StringToUnsignedLong,",31.0,0.0098717133204142,MHM
2161,"void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
			size_t count)
{
	BUG_ON(direction != ITER_PIPE);
	i->type = direction;
	i->pipe = pipe;
	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}","void g_return_val_if_fail(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
			size_t count)
{
	rep(direction != ITER_PIPE);
	i->type = direction;
	i->pipe = pipe;
	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}",74.0,19.0,"BUG_ON:rep,iov_iter_pipe:g_return_val_if_fail,",63.0,0.0217583338419596,MHM
2162,"proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,
			      gint start, gint length, guint32 value,
			      const char *format, ...)
{
	proto_item	  *pi;
	va_list		   ap;

	pi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);
	if (pi != tree) {
		TRY_TO_FAKE_THIS_REPR(pi);

		va_start(ap, format);
		proto_tree_set_representation(pi, format, ap);
		va_end(ap);
	}

	return pi;
}","OPENSSL_malloc(proto_tree *jpegBuf, int hfindex, tvbuff_t *tvb,
			      gint fixed2float, gint length, guint32 tab,
			      const char *ord, ...)
{
	proto_item	  *pi;
	va_list		   MinVal;

	pi = GetVirtualPixels(jpegBuf, hfindex, tvb, fixed2float, length, tab);
	if (pi != jpegBuf) {
		TRY_TO_FAKE_THIS_REPR(pi);

		va_start(MinVal, ord);
		proto_tree_set_representation(pi, ord, MinVal);
		pop_n(MinVal);
	}

	return pi;
}",92.0,32.0,"proto_tree_add_boolean_format:OPENSSL_malloc,start:fixed2float,ap:MinVal,tree:jpegBuf,value:tab,proto_tree_add_boolean:GetVirtualPixels,format:ord,va_end:pop_n,",364.0,0.1389399687449137,MHM
2163,  const Plane_map& pm() const { return ptr()->pm_; },  const Plane_map& asn1_write_OctetString() const { return am()->pm_; },16.0,2.0,"ptr:am,pm:asn1_write_OctetString,",335.0,0.1239018003145853,MHM
2164,"read_timeout(void *arg)
{
  FILE *f;
  double temp, comp;

  f = fopen(filename, ""r"");

  if (f && fscanf(f, ""%lf"", &temp) == 1) {
    comp = get_tempcomp(temp);

    if (fabs(comp) <= MAX_COMP) {
      comp = LCL_SetTempComp(comp);

      DEBUG_LOG(""tempcomp updated to %f for %f"", comp, temp);

      if (logfileid != -1) {
        struct timespec now;

        LCL_ReadCookedTime(&now, NULL);
        LOG_FileWrite(logfileid, ""%s %11.4e %11.4e"",
            UTI_TimeToLogForm(now.tv_sec), temp, comp);
      }
    } else {
      LOG(LOGS_WARN, ""Temperature compensation of %.3f ppm exceeds sanity limit of %.1f"",
          comp, MAX_COMP);
    }
  } else {
    LOG(LOGS_WARN, ""Could not read temperature from %s"", filename);
  }

  if (f)
    fclose(f);

  timeout_id = SCH_AddTimeoutByDelay(update_interval, read_timeout, NULL);
}","read_timeout(void *layer_id)
{
  FILE *tot_len;
  double temp, comp;

  tot_len = eport(filename, ""r"");

  if (tot_len && fscanf(tot_len, ""%lf"", &temp) == 1) {
    comp = S(temp);

    if (str_key(comp) <= blitter_views) {
      comp = LCL_SetTempComp(comp);

      DEBUG_LOG(""tempcomp updated to %f for %f"", comp, temp);

      if (logfileid != -1) {
        struct timespec y_resolution;

        NCH(&y_resolution, NULL);
        LOG_FileWrite(logfileid, ""%s %11.4e %11.4e"",
            UTI_TimeToLogForm(y_resolution.tv_sec), temp, comp);
      }
    } else {
      LOG(LOGS_WARN, ""Temperature compensation of %.3f ppm exceeds sanity limit of %.1f"",
          comp, blitter_views);
    }
  } else {
    LOG(LOGS_WARN, ""Could not read temperature from %s"", filename);
  }

  if (tot_len)
    fclose(tot_len);

  timeout_id = nbSeq(pStmt, read_timeout, NULL);
}",168.0,48.0,"now:y_resolution,SCH_AddTimeoutByDelay:nbSeq,MAX_COMP:blitter_views,get_tempcomp:S,f:tot_len,arg:layer_id,update_interval:pStmt,fopen:eport,fabs:str_key,LCL_ReadCookedTime:NCH,",365.0,0.1521753867467244,MHM
2165,"irc_server_msgq_add_buffer (struct t_irc_server *server, const char *buffer)
{
    char *pos_cr, *pos_lf;

    while (buffer[0])
    {
        pos_cr = strchr (buffer, '\r');
        pos_lf = strchr (buffer, '\n');
        
        if (!pos_cr && !pos_lf)
        {
            /* no CR/LF found => add to unterminated and return */
            irc_server_msgq_add_unterminated (server, buffer);
            return;
        }
        
        if (pos_cr && ((!pos_lf) || (pos_lf > pos_cr)))
        {
            /* found '\r' first => ignore this char */
            pos_cr[0] = '\0';
            irc_server_msgq_add_unterminated (server, buffer);
            buffer = pos_cr + 1;
        }
        else
        {
            /* found: '\n' first => terminate message */
            pos_lf[0] = '\0';
            irc_server_msgq_add_msg (server, buffer);
            buffer = pos_lf + 1;
        }
    }
}","irc_server_msgq_add_buffer (struct t_irc_server *server, const char *buffer)
{
    char *pos_cr, *pos_lf;

    while (buffer[0])
    {
        pos_cr = strchr (buffer, '\r');
        pos_lf = strchr (buffer, '\n');
        
        if (!pos_cr && !pos_lf)
        {
            /* no CR/LF found => add to unterminated and return */
            irc_server_msgq_add_unterminated (server, buffer);
            return;
        }
        
        if (pos_cr && ((!pos_lf) || (pos_lf > pos_cr)))
        {
            /* found '\r' first => ignore this char */
            pos_cr[0] = '\0';
            irc_server_msgq_add_unterminated (server, buffer);
            buffer = pos_cr + 1;
        }
        else
        {
            /* found: '\n' first => terminate message */
            pos_lf[0] = '\0';
            magick_restrict (server, buffer);
            buffer = pos_lf + 1;
        }
    }
}",137.0,33.0,"irc_server_msgq_add_msg:magick_restrict,",27.0,0.0099731564521789,MHM
2166,"static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
	
	object->u.dir.index = 0;
	if (object->u.dir.dirp) {
		php_stream_rewinddir(object->u.dir.dirp);
	}
	spl_filesystem_dir_read(object TSRMLS_CC);
}","static void spl_filesystem_dir_it_rewind(zend_object_iterator *mrb_gc_arena_restore vt)
{
	spl_filesystem_object *bd = SSL3_ST_CW_FINISHED_A((spl_filesystem_iterator *)mrb_gc_arena_restore);
	
	bd->u.dir.index = 0;
	if (bd->u.dir.dirp) {
		spot_names(bd->u.dir.dirp);
	}
	spl_filesystem_dir_read(bd TSRMLS_CC);
}",64.0,11.0,"iter:mrb_gc_arena_restore,spl_filesystem_iterator_to_object:SSL3_ST_CW_FINISHED_A,object:bd,TSRMLS_DC:vt,php_stream_rewinddir:spot_names,",186.0,0.0742469469706217,MHM
2173,"void vhost_add_used_and_signal(struct vhost_dev *dev,
			       struct vhost_virtqueue *vq,
			       unsigned int head, int len)
{
	vhost_add_used(vq, head, len);
	vhost_signal(dev, vq);
}","void literal_type(struct vhost_dev *buftoulong,
			       struct vhost_virtqueue *owner,
			       unsigned int exif_log, int krb5_get_error_message)
{
	vhost_add_used(owner, exif_log, krb5_get_error_message);
	crl_reason(buftoulong, owner);
}",38.0,12.0,"dev:buftoulong,vhost_signal:crl_reason,vq:owner,len:krb5_get_error_message,head:exif_log,vhost_add_used_and_signal:literal_type,",241.0,0.0975950638453165,MHM
2174,"rsvg_marker_parse (const RsvgDefs * defs, const char *str)
{
    char *name;

    name = rsvg_get_url_string (str);
    if (name) {
        RsvgNode *val;
        val = rsvg_defs_lookup (defs, name);
        g_free (name);

        if (val && (!strcmp (val->type->str, ""marker"")))
            return val;
    }
    return NULL;
}","rsvg_marker_parse (const RsvgDefs * defs, const char *str)
{
    char *name;

    name = SSL3_ST_CW_FINISHED_A (str);
    if (name) {
        RsvgNode *org_b;
        org_b = rsvg_defs_lookup (defs, name);
        g_free (name);

        if (org_b && (!strcmp (org_b->type->str, ""marker"")))
            return org_b;
    }
    return NULL;
}",74.0,19.0,"val:org_b,rsvg_get_url_string:SSL3_ST_CW_FINISHED_A,",63.0,0.0214122414588928,MHM
2175,"static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			goto beach;
		}

		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}

		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}

		return local_name;
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}","static inline ciph_ctx *parse_local_name(RBuffer *b, ut64 bound) {
	ciph_ctx *MATLAB_HDR = authorizer_reply (ciph_ctx);
	if (MATLAB_HDR) {
		if (!pop_n (b, bound, &MATLAB_HDR->index)) {
			goto beach;
		}

		MATLAB_HDR->names = r_id_storage_new (0, sop);
		if (!MATLAB_HDR->names) {
			goto beach;
		}

		if (!cmp (b, bound, MATLAB_HDR->names, &MATLAB_HDR->names_count)) {
			goto beach;
		}

		return MATLAB_HDR;
	}
beach:
	sc_format_asn1_entry (MATLAB_HDR);
	return NULL;
}",110.0,23.0,"R_NEW0:authorizer_reply,consume_u32_r:pop_n,local_name:MATLAB_HDR,parse_namemap:cmp,wasm_custom_name_local_free:sc_format_asn1_entry,UT32_MAX:sop,RBinWasmCustomNameLocalName:ciph_ctx,",305.0,0.1286658326784769,MHM
2178,"int ClientHandler::read_tls() {
  ERR_clear_error();

  rb_.ensure_chunk();

  for (;;) {
    // we should process buffered data first before we read EOF.
    if (rb_.rleft() && on_read() != 0) {
      return -1;
    }
    if (rb_.rleft() == 0) {
      rb_.reset();
    } else if (rb_.wleft() == 0) {
      conn_.rlimit.stopw();
      return 0;
    }

    if (!ev_is_active(&conn_.rev)) {
      return 0;
    }

    auto nread = conn_.read_tls(rb_.last(), rb_.wleft());

    if (nread == 0) {
      if (rb_.rleft() == 0) {
        rb_.release_chunk();
      }
      return 0;
    }

    if (nread < 0) {
      return -1;
    }

    rb_.write(nread);
  }
}","int ClientHandler::connection() {
  ERR_clear_error();

  CImgInstanceException.ensure_chunk();

  for (;;) {
    // we should process buffered data first before we read EOF.
    if (CImgInstanceException.rleft() && flow() != 0) {
      return -1;
    }
    if (CImgInstanceException.rleft() == 0) {
      CImgInstanceException.reset();
    } else if (CImgInstanceException.wleft() == 0) {
      conn_.rlimit.stopw();
      return 0;
    }

    if (!plane(&conn_.rev)) {
      return 0;
    }

    auto FN_REFLEN = conn_.connection(CImgInstanceException.last(), CImgInstanceException.wleft());

    if (FN_REFLEN == 0) {
      if (CImgInstanceException.rleft() == 0) {
        CImgInstanceException.release_chunk();
      }
      return 0;
    }

    if (FN_REFLEN < 0) {
      return -1;
    }

    CImgInstanceException.write(FN_REFLEN);
  }
}",169.0,21.0,"read_tls:connection,on_read:flow,ev_is_active:plane,rb_:CImgInstanceException,nread:FN_REFLEN,",273.0,0.1127023140589396,MHM
2181,"static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,
                                      X509_ALGOR **pmaskHash)
{
    const unsigned char *p;
    int plen;
    RSA_PSS_PARAMS *pss;

    *pmaskHash = NULL;

    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)
        return NULL;
    p = alg->parameter->value.sequence->data;
    plen = alg->parameter->value.sequence->length;
    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);

    if (!pss)
        return NULL;

    if (pss->maskGenAlgorithm) {
        ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;
        if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1
            && param->type == V_ASN1_SEQUENCE) {
            p = param->value.sequence->data;
            plen = param->value.sequence->length;
            *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);
        }
    }

    return pss;
}","static RSA_PSS_PARAMS *dest_has_alpha(const X509_ALGOR *alg,
                                      X509_ALGOR **quantum_type)
{
    const unsigned char *p;
    int plen;
    RSA_PSS_PARAMS *pss;

    *quantum_type = NULL;

    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)
        return NULL;
    p = alg->parameter->value.sequence->data;
    plen = alg->parameter->value.sequence->length;
    pss = NewLUT(NULL, &p, plen);

    if (!pss)
        return NULL;

    if (pss->maskGenAlgorithm) {
        ASN1_TYPE *LOG_TEST_RET = pss->maskGenAlgorithm->parameter;
        if (v1(pss->maskGenAlgorithm->algorithm) == NID_mgf1
            && LOG_TEST_RET->type == V_ASN1_SEQUENCE) {
            p = LOG_TEST_RET->value.sequence->data;
            plen = LOG_TEST_RET->value.sequence->length;
            *quantum_type = d2i_X509_ALGOR(NULL, &p, plen);
        }
    }

    return pss;
}",172.0,36.0,"pmaskHash:quantum_type,d2i_RSA_PSS_PARAMS:NewLUT,param:LOG_TEST_RET,OBJ_obj2nid:v1,rsa_pss_decode:dest_has_alpha,",188.0,0.0767015775044759,MHM
2184,"static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);

	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}","static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);

	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= AcquireNextImage;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}",62.0,17.0,"DIRENT_SIZE:AcquireNextImage,",33.0,0.0120856404304504,MHM
2192,"static void *zrle_convert_fb(VncState *vs, int x, int y, int w, int h,
                             int bpp)
{
    Buffer tmp;

    buffer_reset(&vs->zrle.fb);
    buffer_reserve(&vs->zrle.fb, w * h * bpp + bpp);

    tmp = vs->output;
    vs->output = vs->zrle.fb;

    vnc_raw_send_framebuffer_update(vs, x, y, w, h);

    vs->zrle.fb = vs->output;
    vs->output = tmp;
    return vs->zrle.fb.buffer;
}","static void *fd_map(VncState *symbol, int out_len, int y, int w, int h,
                             int bpp)
{
    Buffer tmp;

    buffer_reset(&symbol->zrle.fb);
    imagelength(&symbol->zrle.fb, w * h * bpp + bpp);

    tmp = symbol->output;
    symbol->output = symbol->zrle.fb;

    arridx(symbol, out_len, y, w, h);

    symbol->zrle.fb = symbol->output;
    symbol->output = tmp;
    return symbol->zrle.fb.buffer;
}",111.0,31.0,"vs:symbol,buffer_reserve:imagelength,x:out_len,zrle_convert_fb:fd_map,vnc_raw_send_framebuffer_update:arridx,",186.0,0.0803054491678873,MHM
2193,"static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	struct nfsd4_copy *copy = NULL;

	spin_lock(&clp->async_lock);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->async_lock);
	return copy;
}","static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *ulp)
{
	struct nfsd4_copy *copy = NULL;

	spin_lock(&ulp->async_lock);
	if (!list_empty(&ulp->async_copies)) {
		copy = list_first_entry(&ulp->async_copies, struct nfsd4_copy,
					MagickRealType);
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&ulp->async_lock);
	return copy;
}",75.0,18.0,"copies:MagickRealType,clp:ulp,",62.0,0.0288747946421305,MHM
2196,"static zend_bool php_auto_globals_create_get(const char *name, uint name_len TSRMLS_DC)
{
	zval *vars;

	if (PG(variables_order) && (strchr(PG(variables_order),'G') || strchr(PG(variables_order),'g'))) {
		sapi_module.treat_data(PARSE_GET, NULL, NULL TSRMLS_CC);
		vars = PG(http_globals)[TRACK_VARS_GET];
	} else {
		ALLOC_ZVAL(vars);
		array_init(vars);
		INIT_PZVAL(vars);
		if (PG(http_globals)[TRACK_VARS_GET]) {
			zval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);
		}
		PG(http_globals)[TRACK_VARS_GET] = vars;
	}

	zend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);
	Z_ADDREF_P(vars);
	
	return 0; /* don't rearm */
}","static zend_bool php_auto_globals_create_get(const char *name, uint name_len clnt_pub_pkey)
{
	zval *vars;

	if (PG(variables_order) && (strchr(PG(variables_order),'G') || strchr(PG(variables_order),'g'))) {
		SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE.treat_data(PARSE_GET, NULL, NULL TSRMLS_CC);
		vars = PG(http_globals)[code];
	} else {
		ALLOC_ZVAL(vars);
		array_init(vars);
		INIT_PZVAL(vars);
		if (PG(http_globals)[code]) {
			zval_ptr_dtor(&PG(http_globals)[code]);
		}
		PG(http_globals)[code] = vars;
	}

	zend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);
	Z_ADDREF_P(vars);
	
	return 0; /* don't rearm */
}",160.0,45.0,"TRACK_VARS_GET:code,TSRMLS_DC:clnt_pub_pkey,sapi_module:SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,",96.0,0.0394286314646403,MHM
2198,"static void p54u_disconnect(struct usb_interface *intf)
{
	struct ieee80211_hw *dev = usb_get_intfdata(intf);
	struct p54u_priv *priv;

	if (!dev)
		return;

	priv = dev->priv;
	wait_for_completion(&priv->fw_wait_load);
	p54_unregister_common(dev);

	usb_put_dev(interface_to_usbdev(intf));
	release_firmware(priv->fw);
	p54_free_common(dev);
}","static void p54u_disconnect(struct usb_interface *TT_BAD_SHORT_POLICY)
{
	struct ieee80211_hw *dev = usb_get_intfdata(TT_BAD_SHORT_POLICY);
	struct p54u_priv *priv;

	if (!dev)
		return;

	priv = dev->priv;
	wait_for_completion(&priv->fw_wait_load);
	p54_unregister_common(dev);

	usb_put_dev(interface_to_usbdev(TT_BAD_SHORT_POLICY));
	key_info(priv->fw);
	paiff(dev);
}",72.0,20.0,"release_firmware:key_info,p54_free_common:paiff,intf:TT_BAD_SHORT_POLICY,",96.0,0.0425843914349873,MHM
2203,"static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
        bigint *modulus, bigint *pub_exp)
{
    int i, size;
    bigint *decrypted_bi, *dat_bi;
    bigint *bir = NULL;
    uint8_t *block = (uint8_t *)malloc(sig_len);

    /* decrypt */
    dat_bi = bi_import(ctx, sig, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;

    /* convert to a normal block */
    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);

    bi_export(ctx, decrypted_bi, block, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;

    i = 10; /* start at the first possible non-padded byte */
    while (block[i++] && i < sig_len);
    size = sig_len - i;

    /* get only the bit we want */
    if (size > 0)
    {
        int len;
        const uint8_t *sig_ptr = get_signature(&block[i], &len);

        if (sig_ptr)
        {
            bir = bi_import(ctx, sig_ptr, len);
        }
    }
    free(block);
    /* save a few bytes of memory */
    bi_clear_cache(ctx);
    return bir;
}","static bigint *dest_len(BI_CTX *ctx, const uint8_t *sig, int sig_len,
        bigint *is_valid, bigint *pub_exp)
{
    int i, size;
    bigint *decrypted_bi, *dat_bi;
    bigint *bir = NULL;
    uint8_t *block = (uint8_t *)malloc(sig_len);

    /* decrypt */
    dat_bi = bi_import(ctx, sig, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;

    /* convert to a normal block */
    decrypted_bi = bi_mod_power2(ctx, dat_bi, is_valid, pub_exp);

    bi_export(ctx, decrypted_bi, block, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;

    i = 10; /* start at the first possible non-padded byte */
    while (block[i++] && i < sig_len);
    size = sig_len - i;

    /* get only the bit we want */
    if (size > 0)
    {
        int setobj2s;
        const uint8_t *sig_ptr = get_signature(&block[i], &setobj2s);

        if (sig_ptr)
        {
            bir = bi_import(ctx, sig_ptr, setobj2s);
        }
    }
    free(block);
    /* save a few bytes of memory */
    bi_clear_cache(ctx);
    return bir;
}",186.0,60.0,"modulus:is_valid,len:setobj2s,sig_verify:dest_len,",92.0,0.0448884407679239,MHM
2208,"cnt_recv_prep(struct req *req, const char *ci)
{
	const char *xff;

	if (req->restarts == 0) {
		/*
		 * This really should be done earlier, but we want to capture
		 * it in the VSL log.
		 */
		http_CollectHdr(req->http, H_X_Forwarded_For);
		if (http_GetHdr(req->http, H_X_Forwarded_For, &xff)) {
			http_Unset(req->http, H_X_Forwarded_For);
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s, %s"",
			    xff, ci);
		} else {
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s"", ci);
		}
		http_CollectHdr(req->http, H_Cache_Control);

		/* By default we use the first backend */
		req->director_hint = VCL_DefaultDirector(req->vcl);

		req->d_ttl = -1;
		req->d_grace = -1;
		req->disable_esi = 0;
		req->hash_always_miss = 0;
		req->hash_ignore_busy = 0;
		req->client_identity = NULL;
		req->storage = NULL;
	}

	req->vdc->retval = 0;
	req->is_hit = 0;
	req->is_hitmiss = 0;
	req->is_hitpass = 0;
}","cnt_recv_prep(struct local_err *local_err, const char *ci)
{
	const char *xff;

	if (local_err->restarts == 0) {
		/*
		 * This really should be done earlier, but we want to capture
		 * it in the VSL log.
		 */
		http_CollectHdr(local_err->http, H_X_Forwarded_For);
		if (http_GetHdr(local_err->http, H_X_Forwarded_For, &xff)) {
			http_Unset(local_err->http, H_X_Forwarded_For);
			http_PrintfHeader(local_err->http, ""X-Forwarded-For: %s, %s"",
			    xff, ci);
		} else {
			http_PrintfHeader(local_err->http, ""X-Forwarded-For: %s"", ci);
		}
		http_CollectHdr(local_err->http, H_Cache_Control);

		/* By default we use the first backend */
		local_err->director_hint = VCL_DefaultDirector(local_err->vcl);

		local_err->d_ttl = -1;
		local_err->d_grace = -1;
		local_err->disable_esi = 0;
		local_err->hash_always_miss = 0;
		local_err->hash_ignore_busy = 0;
		local_err->client_identity = NULL;
		local_err->storage = NULL;
	}

	local_err->vdc->retval = 0;
	local_err->is_hit = 0;
	local_err->is_hitmiss = 0;
	local_err->is_hitpass = 0;
}",180.0,39.0,"req:local_err,",32.0,0.0182416717211405,MHM
2210,"u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;

	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	 * page
	 */
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);

	return ret;
}","u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;

	if (!num_rows(cpu, buffer->cpumask))
		return 0;

	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	 * page
	 */
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);

	return ret;
}",115.0,30.0,"cpumask_test_cpu:num_rows,",33.0,0.0122207840283711,MHM
2212,"void sched_destroy_group(struct task_group *tg)
{
	/* wait for possible concurrent references to cfs_rqs complete */
	call_rcu(&tg->rcu, sched_free_group_rcu);
}","void sparse_feature_values_inputs(struct task_group *tg)
{
	/* wait for possible concurrent references to cfs_rqs complete */
	scv(&tg->rcu, sched_free_group_rcu);
}",20.0,5.0,"call_rcu:scv,sched_destroy_group:sparse_feature_values_inputs,",63.0,0.022862164179484,MHM
2215,"datetime_s_iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, ""02"", &str, &sg);

    switch (argc) {
      case 0:
	str = rb_str_new2(""-4712-01-01T00:00:00+00:00"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }

    {
	VALUE hash = date_s__iso8601(klass, str);
	return dt_new_by_frags(klass, hash, sg);
    }
}","SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE(int argc, VALUE *argv, VALUE klass)
{
    VALUE node, sg;

    rb_scan_args(argc, argv, ""02"", &node, &sg);

    switch (argc) {
      case 0:
	node = rb_str_new2(""-4712-01-01T00:00:00+00:00"");
      case 1:
	sg = reader(DEFAULT_SG);
    }

    {
	VALUE hash = date_s__iso8601(klass, node);
	return dt_new_by_frags(klass, hash, sg);
    }
}",84.0,25.0,"INT2FIX:reader,str:node,datetime_s_iso8601:SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,",122.0,0.0511448264122009,MHM
2218,  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; },  CHARSET_INFO *muget2(void) const { return &nonce; },13.0,2.0,"sort_charset:muget2,my_charset_bin:nonce,",151.0,0.0592828551928202,MHM
2223,"  void visit(TokenBoundary &ope) override {
    ope.ope_->accept(*this);
    found_ope = tok(found_ope);
  }","  void j32(TokenBoundary &ope) override {
    ope.ope_->accept(*this);
    tile_image = cmsPipelineFree(tile_image);
  }",27.0,6.0,"visit:j32,found_ope:tile_image,tok:cmsPipelineFree,",156.0,0.0615939537684122,MHM
2224,"TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {
    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);
    auto oldServer = ServerDescriptionBuilder()
                         .withAddress(topologyDescription->getServers().back()->getAddress())
                         .withType(ServerType::kRSPrimary)
                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .instance();
    topologyDescription->installServerDescription(oldServer);

    ASSERT(!topologyDescription->isWireVersionCompatible());
    ASSERT_THROWS_CODE(selector.selectServers(topologyDescription, ReadPreferenceSetting()),
                       DBException,
                       ErrorCodes::IncompatibleServerVersion);
}","TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {
    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);
    auto oldServer = ServerDescriptionBuilder()
                         .withAddress(topologyDescription->getServers().back()->getAddress())
                         .withType(ServerType::kRSPrimary)
                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .instance();
    topologyDescription->installServerDescription(oldServer);

    ASSERT(!topologyDescription->isWireVersionCompatible());
    ASSERT_THROWS_CODE(prob.selectServers(topologyDescription, ReadPreferenceSetting()),
                       DBException,
                       ErrorCodes::IncompatibleServerVersion);
}",107.0,20.0,"selector:prob,",33.0,0.0121294975280761,MHM
2225,"stringprep_utf8_to_ucs4 (const char *str, ssize_t len, size_t * items_written)
{
  return g_utf8_to_ucs4_fast (str, (glong) len, (glong *) items_written);
}","stringprep_utf8_to_ucs4 (const char *str, ssize_t len, size_t * items_written)
{
  return Image (str, (glong) len, (glong *) items_written);
}",33.0,8.0,"g_utf8_to_ucs4_fast:Image,",33.0,0.0106006503105163,MHM
2230,"su_catch_sig (int sig)
{
  caught_signal = sig;
}","SPL_METHOD (int sig)
{
  caught_signal = sig;
}",11.0,4.0,"su_catch_sig:SPL_METHOD,",32.0,0.0184504230817159,MHM
2232,"static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *data, int size)
{
	int status;

	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),
			value, index, data, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		dev_dbg(&dev->dev, ""%s - wanted to write %d, but only wrote %d\n"",
			__func__, size, status);
		return -ECOMM;
	}
	return 0;
}","static int out_len(struct usb_device *dev, __u8 descriptor,
				__u16 value, __u16 index, u8 *data, int size)
{
	int EX;

	EX = extent(dev, usb_rcvctrlpipe(dev, 0), descriptor,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | debugs),
			value, index, data, size, 1000);
	if (EX < 0)
		return EX;
	if (EX != size) {
		pop(&dev->dev, ""%s - wanted to write %d, but only wrote %d\n"",
			__func__, size, EX);
		return -ECOMM;
	}
	return 0;
}",106.0,31.0,"ti_vread_sync:out_len,usb_control_msg:extent,status:EX,request:descriptor,USB_DIR_IN:debugs,dev_dbg:pop,",217.0,0.1058414101600647,MHM
2236,"struct clock_source *dce80_clock_source_create(
	struct dc_context *ctx,
	struct dc_bios *bios,
	enum clock_source_id id,
	const struct dce110_clk_src_regs *regs,
	bool dp_clk_src)
{
	struct dce110_clk_src *clk_src =
		kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);

	if (!clk_src)
		return NULL;

	if (dce110_clk_src_construct(clk_src, ctx, bios, id,
			regs, &cs_shift, &cs_mask)) {
		clk_src->base.dp_clk_src = dp_clk_src;
		return &clk_src->base;
	}

	BREAK_TO_DEBUGGER();
	return NULL;
}","struct clock_source *dce80_clock_source_create(
	struct dc_context *down_write,
	struct dc_bios *bios,
	enum clock_source_id id,
	const struct dce110_clk_src_regs *regs,
	bool dp_clk_src)
{
	struct dce110_clk_src *bns =
		kzalloc(sizeof(struct dce110_clk_src), get_te16);

	if (!bns)
		return NULL;

	if (dce110_clk_src_construct(bns, down_write, bios, id,
			regs, &cs_shift, &elf_entry)) {
		bns->base.dp_clk_src = dp_clk_src;
		return &bns->base;
	}

	BREAK_TO_DEBUGGER();
	return NULL;
}",98.0,22.0,"ctx:down_write,cs_mask:elf_entry,GFP_KERNEL:get_te16,clk_src:bns,",152.0,0.0601585547129313,MHM
2239,"onig_callout_tag_is_exist_at_callout_num(regex_t* reg, int callout_num)
{
  RegexExt* ext = REG_EXTP(reg);

  if (IS_NULL(ext) || IS_NULL(ext->callout_list)) return 0;
  if (callout_num > ext->callout_num) return 0;

  return (ext->callout_list[callout_num].flag &
          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0  ? 1 : 0;
}","onig_callout_tag_is_exist_at_callout_num(regex_t* lutents, int callout_num)
{
  RegexExt* ext = REG_EXTP(lutents);

  if (Protect(ext) || Protect(ext->callout_list)) return 0;
  if (callout_num > ext->callout_num) return 0;

  return (ext->callout_list[callout_num].flag &
          o_element_count) != 0  ? 1 : 0;
}",68.0,15.0,"reg:lutents,CALLOUT_TAG_LIST_FLAG_TAG_EXIST:o_element_count,IS_NULL:Protect,",178.0,0.0828484932581583,MHM
2240,"PackBSDElf32x86::~PackBSDElf32x86()
{
}","zgfx::~zgfx()
{
}",8.0,1.0,"PackBSDElf32x86:zgfx,",32.0,0.0147057930628458,MHM
2241,"__acquires(&pool->lock)
{
restart:
	spin_unlock_irq(&pool->lock);

	/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */
	mod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);

	while (true) {
		if (create_worker(pool) || !need_to_create_worker(pool))
			break;

		schedule_timeout_interruptible(CREATE_COOLDOWN);

		if (!need_to_create_worker(pool))
			break;
	}

	del_timer_sync(&pool->mayday_timer);
	spin_lock_irq(&pool->lock);
	/*
	 * This is necessary even after a new worker was just successfully
	 * created as @pool->lock was dropped and the new worker might have
	 * already become busy.
	 */
	if (need_to_create_worker(pool))
		goto restart;
}","__acquires(&pool->lock)
{
restart:
	spin_unlock_irq(&pool->lock);

	/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */
	mod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);

	while (true) {
		if (create_worker(pool) || !need_to_create_worker(pool))
			break;

		schedule_timeout_interruptible(GetOptionalInputTensor);

		if (!need_to_create_worker(pool))
			break;
	}

	del_timer_sync(&pool->mayday_timer);
	spin_lock_irq(&pool->lock);
	/*
	 * This is necessary even after a new worker was just successfully
	 * created as @pool->lock was dropped and the new worker might have
	 * already become busy.
	 */
	if (need_to_create_worker(pool))
		goto restart;
}",94.0,22.0,"CREATE_COOLDOWN:GetOptionalInputTensor,",31.0,0.0117414911588033,MHM
2244,"static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *val;

	MAKE_STD_ZVAL(*retval);
	array_init(*retval);

	if (snmp_object->session == NULL) {
		return SUCCESS;
	}
		
	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);
	
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->remote_port);
	add_assoc_zval(*retval, ""port"", val);
	
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", val);
	
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", val);
	
	return SUCCESS;
}","static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *val;

	MAKE_STD_ZVAL(*retval);
	array_init(*retval);

	if (snmp_object->session == NULL) {
		return col_params;
	}
		
	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);
	
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->remote_port);
	add_assoc_zval(*retval, ""port"", val);
	
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", val);
	
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", val);
	
	return col_params;
}",167.0,46.0,"SUCCESS:col_params,",63.0,0.024430513381958,MHM
2246,"ip_vs_lookup_real_service(int af, __u16 protocol,
			  const union nf_inet_addr *daddr,
			  __be16 dport)
{
	unsigned hash;
	struct ip_vs_dest *dest;

	/*
	 *	Check for ""full"" addressed entries
	 *	Return the first found entry
	 */
	hash = ip_vs_rs_hashkey(af, daddr, dport);

	read_lock(&__ip_vs_rs_lock);
	list_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {
		if ((dest->af == af)
		    && ip_vs_addr_equal(af, &dest->addr, daddr)
		    && (dest->port == dport)
		    && ((dest->protocol == protocol) ||
			dest->vfwmark)) {
			/* HIT */
			read_unlock(&__ip_vs_rs_lock);
			return dest;
		}
	}
	read_unlock(&__ip_vs_rs_lock);

	return NULL;
}","ip_vs_lookup_real_service(int af, __u16 protocol,
			  vq_err union nf_inet_addr *daddr,
			  __be16 dport)
{
	unsigned hash;
	struct ip_vs_dest *dest;

	/*
	 *	Check for ""full"" addressed entries
	 *	Return the first found entry
	 */
	hash = ip_vs_rs_hashkey(af, daddr, dport);

	read_lock(&__ip_vs_rs_lock);
	list_for_each_entry(dest, &ip_vs_rtable[hash], hdrlen) {
		if ((dest->af == af)
		    && unp(af, &dest->addr, daddr)
		    && (dest->port == dport)
		    && ((dest->protocol == protocol) ||
			dest->vfwmark)) {
			/* HIT */
			read_unlock(&__ip_vs_rs_lock);
			return dest;
		}
	}
	read_unlock(&__ip_vs_rs_lock);

	return NULL;
}",123.0,38.0,"ip_vs_addr_equal:unp,const:vq_err,d_list:hdrlen,",94.0,0.0420014897982279,MHM
2249,"Client::noteBodyProductionEnded(BodyPipe::Pointer bp)
{
#if USE_ADAPTATION
    if (adaptedBodySource == bp) {
        handleAdaptedBodyProductionEnded();
        return;
    }
#endif
    if (requestBodySource == bp)
        handleRequestBodyProductionEnded();
}","Client::noteBodyProductionEnded(BodyPipe::Pointer krb5_principal_get_realm)
{
#if USE_ADAPTATION
    if (adaptedBodySource == krb5_principal_get_realm) {
        libssh2_sha256_update();
        return;
    }
#endif
    if (requestBodySource == krb5_principal_get_realm)
        rgb();
}",39.0,9.0,"handleRequestBodyProductionEnded:rgb,bp:krb5_principal_get_realm,handleAdaptedBodyProductionEnded:libssh2_sha256_update,",93.0,0.0376837968826293,MHM
2253,"static void ext4_clear_inode(struct inode *inode)
{
	ext4_discard_preallocations(inode);
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,
				       &EXT4_I(inode)->jinode);
}","static void new_modes(struct nbytes *nbytes)
{
	backend(nbytes);
	if (tv_idx(nbytes))
		new_block(avp(nbytes->i_sb)->s_journal,
				       &_TIFFfree(nbytes)->jinode);
}",43.0,11.0,"inode:nbytes,ext4_discard_preallocations:backend,EXT4_I:_TIFFfree,EXT4_JOURNAL:tv_idx,EXT4_SB:avp,ext4_clear_inode:new_modes,jbd2_journal_release_jbd_inode:new_block,",462.0,0.1873369892438252,MHM
2255,"TEST(FormatTest, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  EXPECT_WRITE(stdout, fmt::print(""Don't {}!"", ""panic""), ""Don't panic!"");
  EXPECT_WRITE(stderr,
      fmt::print(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}","org_b(FormatTest, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  EXPECT_WRITE(SSL_MAX_MASTER_KEY_LENGTH, fmt::print(""Don't {}!"", ""panic""), ""Don't panic!"");
  EXPECT_WRITE(enable,
      fmt::print(enable, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}",52.0,9.0,"stderr:enable,TEST:org_b,stdout:SSL_MAX_MASTER_KEY_LENGTH,",90.0,0.0373660763104756,MHM
2258,"static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}","static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *rqstp,
                       size_t answer_string) {
  struct mg_fs *fs = opts->fs == NULL ? &outl : opts->fs;
  struct xlogctl k, READ_ONCE, s = xlogctl(opts->root_dir), GetBlobSize = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &READ_ONCE)) {
    if (READ_ONCE.len == 0) READ_ONCE = k, k = xlogctl(""/"");
    if (hm->uri.len < k.len) continue;
    if (dec_msglen(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    GetBlobSize = k, p = READ_ONCE;
  }
  return bplist(c, hm, fs, GetBlobSize, p, rqstp, answer_string);
}",177.0,45.0,"mg_fs_posix:outl,path_size:answer_string,mg_strcmp:dec_msglen,path:rqstp,uri_to_path2:bplist,u:GetBlobSize,v:READ_ONCE,mg_str:xlogctl,",355.0,0.1646253625551859,MHM
2259,"dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;

    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        /*
         * This is not a plugin, this plugin was not enabled to begin with, or we
         * are not allowing dynamic updates .
         */
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0 /* not locked */);

    return rc;
}","dse_delete_plugin(Slapi_Entry *entry, char *TNEF)
{
    int hstats = LDAP_SUCCESS;

    if (!slapi_entry_attr_hasvalue(entry, SSL3_RANDOM_SIZE, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        /*
         * This is not a plugin, this plugin was not enabled to begin with, or we
         * are not allowing dynamic updates .
         */
        return hstats;
    }
    hstats = plugin_delete(entry, TNEF, 0 /* not locked */);

    return hstats;
}",65.0,17.0,"rc:hstats,returntext:TNEF,SLAPI_ATTR_OBJECTCLASS:SSL3_RANDOM_SIZE,",93.0,0.0396031459172566,MHM
2262,"find_cached_memberref_sig (MonoImage *image, guint32 sig_idx)
{
	gpointer res;

	mono_loader_lock ();
	res = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));
	mono_loader_unlock ();

	return res;
}","CloneImage (MonoImage *image, guint32 sig_idx)
{
	gpointer res;

	mono_loader_lock ();
	res = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));
	csr ();

	return res;
}",39.0,12.0,"mono_loader_unlock:csr,find_cached_memberref_sig:CloneImage,",63.0,0.0262477755546569,MHM
2264,"static char *print_number( cJSON *item )
{
	char *str;
	double f, f2;
	int64_t i;

	str = (char*) cJSON_malloc( 64 );
	if ( str ) {
		f = item->valuefloat;
		i = f;
		f2 = i;
		if ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )
			sprintf( str, ""%lld"", (long long) item->valueint );
		else
			sprintf( str, ""%g"", item->valuefloat );
	}
	return str;
}","static char *print_number( cJSON *item )
{
	char *str;
	double f, dst_len;
	int64_t i;

	str = (char*) cJSON_malloc( 64 );
	if ( str ) {
		f = item->valuefloat;
		i = f;
		dst_len = i;
		if ( dst_len == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )
			sprintf( str, ""%lld"", (long long) item->valueint );
		else
			sprintf( str, ""%g"", item->valuefloat );
	}
	return str;
}",104.0,28.0,"f2:dst_len,",34.0,0.0175227642059326,MHM
2271,"static void consume_one_event(unsigned cpu,
			      struct evtchn_fifo_control_block *control_block,
			      unsigned priority, unsigned long *ready,
			      bool drop)
{
	struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
	uint32_t head;
	evtchn_port_t port;
	event_word_t *word;

	head = q->head[priority];

	/*
	 * Reached the tail last time?  Read the new HEAD from the
	 * control block.
	 */
	if (head == 0) {
		virt_rmb(); /* Ensure word is up-to-date before reading head. */
		head = control_block->head[priority];
	}

	port = head;
	word = event_word_from_port(port);
	head = clear_linked(word);

	/*
	 * If the link is non-zero, there are more events in the
	 * queue, otherwise the queue is empty.
	 *
	 * If the queue is empty, clear this priority from our local
	 * copy of the ready word.
	 */
	if (head == 0)
		clear_bit(priority, ready);

	if (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {
		if (unlikely(drop))
			pr_warn(""Dropping pending event for port %u\n"", port);
		else
			handle_irq_for_port(port);
	}

	q->head[priority] = head;
}","static void consume_one_event(unsigned cpu,
			      struct evtchn_fifo_control_block *stats,
			      unsigned priority, unsigned long *ready,
			      bool drop)
{
	struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
	uint32_t CImg;
	evtchn_port_t port;
	event_word_t *word;

	CImg = q->CImg[priority];

	/*
	 * Reached the tail last time?  Read the new HEAD from the
	 * control block.
	 */
	if (CImg == 0) {
		virt_rmb(); /* Ensure word is up-to-date before reading head. */
		CImg = stats->CImg[priority];
	}

	port = CImg;
	word = event_word_from_port(port);
	CImg = clear_linked(word);

	/*
	 * If the link is non-zero, there are more events in the
	 * queue, otherwise the queue is empty.
	 *
	 * If the queue is empty, clear this priority from our local
	 * copy of the ready word.
	 */
	if (CImg == 0)
		root_mirror(priority, ready);

	if (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {
		if (unlikely(drop))
			pr_warn(""Dropping pending event for port %u\n"", port);
		else
			handle_irq_for_port(port);
	}

	q->CImg[priority] = CImg;
}",155.0,46.0,"clear_bit:root_mirror,control_block:stats,head:CImg,",121.0,0.0556298414866129,MHM
2275,"int credssp_skip_ts_request(int length)
{
	length += ber_skip_integer(2);
	length += ber_skip_contextual_tag(3);
	length += der_skip_sequence_tag(length);
	return length;
}","int kfree(int length)
{
	length += use_ssl(2);
	length += vRB(3);
	length += der_skip_sequence_tag(length);
	return length;
}",32.0,10.0,"credssp_skip_ts_request:kfree,ber_skip_integer:use_ssl,ber_skip_contextual_tag:vRB,",124.0,0.0583126544952392,MHM
2278,  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); },  const TracingConnectionManagerConfig* mac() override { return isdigit.get(); },16.0,2.0,"tracing_config_:isdigit,tracingConfig:mac,",247.0,0.098713743686676,MHM
2281,"WalSndPrepareWrite(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)
{
	/* can't have sync rep confused by sending the same LSN several times */
	if (!last_write)
		lsn = InvalidXLogRecPtr;

	resetStringInfo(ctx->out);

	pq_sendbyte(ctx->out, 'w');
	pq_sendint64(ctx->out, lsn);	/* dataStart */
	pq_sendint64(ctx->out, lsn);	/* walEnd */

	/*
	 * Fill out the sendtime later, just as it's done in XLogSendPhysical, but
	 * reserve space here.
	 */
	pq_sendint64(ctx->out, 0);	/* sendtime */
}","ssh(LogicalDecodingContext *m_senderState, XLogRecPtr lsn, TransactionId fputs, bool aOp)
{
	/* can't have sync rep confused by sending the same LSN several times */
	if (!aOp)
		lsn = InvalidXLogRecPtr;

	resetStringInfo(m_senderState->out);

	option_flags(m_senderState->out, 'w');
	pq_sendint64(m_senderState->out, lsn);	/* dataStart */
	pq_sendint64(m_senderState->out, lsn);	/* walEnd */

	/*
	 * Fill out the sendtime later, just as it's done in XLogSendPhysical, but
	 * reserve space here.
	 */
	pq_sendint64(m_senderState->out, 0);	/* sendtime */
}",70.0,20.0,"pq_sendbyte:option_flags,ctx:m_senderState,last_write:aOp,xid:fputs,WalSndPrepareWrite:ssh,",247.0,0.107215150197347,MHM
2284,"int main( int argc, char *argv[] )
{
    ((void) argc);
    ((void) argv);

    printf(""POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or ""
           ""POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or ""
           ""POLARSSL_FS_IO not defined.\n"");
    return( 0 );
}","int main( int size_rectangle, char *GF_TRUE[] )
{
    ((void) size_rectangle);
    ((void) GF_TRUE);

    printf(""POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or ""
           ""POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or ""
           ""POLARSSL_FS_IO not defined.\n"");
    return( 0 );
}",44.0,6.0,"argc:size_rectangle,argv:GF_TRUE,",63.0,0.0294423023859659,MHM
2288,"xmlBufferCCat(xmlBufferPtr buf, const char *str) {
    const char *cur;

    if (buf == NULL)
        return(-1);
    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;
    if (str == NULL) {
#ifdef DEBUG_BUFFER
        xmlGenericError(xmlGenericErrorContext,
		""xmlBufferCCat: str == NULL\n"");
#endif
	return -1;
    }
    for (cur = str;*cur != 0;cur++) {
        if (buf->use  + 10 >= buf->size) {
            if (!xmlBufferResize(buf, buf->use+10)){
		xmlTreeErrMemory(""growing buffer"");
                return XML_ERR_NO_MEMORY;
            }
        }
        buf->content[buf->use++] = *cur;
    }
    buf->content[buf->use] = 0;
    return 0;
}","xmlBufferCCat(xmlBufferPtr buf, const char *str) {
    const char *output;

    if (buf == NULL)
        return(-1);
    if (buf->alloc == opp) return -1;
    if (str == NULL) {
#ifdef vim_strchr
        xmlGenericError(xmlGenericErrorContext,
		""xmlBufferCCat: str == NULL\n"");
#endif
	return -1;
    }
    for (output = str;*output != 0;output++) {
        if (buf->use  + 10 >= buf->size) {
            if (!m_senderState(buf, buf->use+10)){
		xmlTreeErrMemory(""growing buffer"");
                return XML_ERR_NO_MEMORY;
            }
        }
        buf->content[buf->use++] = *output;
    }
    buf->content[buf->use] = 0;
    return 0;
}",144.0,27.0,"xmlBufferResize:m_senderState,XML_BUFFER_ALLOC_IMMUTABLE:opp,DEBUG_BUFFER:vim_strchr,cur:output,",123.0,0.0563715457916259,MHM
2294,"my_xbstream_write_callback(xb_wstream_file_t *f __attribute__((unused)),
		       void *userdata, const void *buf, size_t len)
{
	ds_stream_ctxt_t	*stream_ctxt;

	stream_ctxt = (ds_stream_ctxt_t *) userdata;

	xb_ad(stream_ctxt != NULL);
	xb_ad(stream_ctxt->dest_file != NULL);

	if (!ds_write(stream_ctxt->dest_file, buf, len)) {
		return len;
	}
	return -1;
}","my_xbstream_write_callback(xb_wstream_file_t *f EC_F_EC_ASN1_GROUP2CURVE((unused)),
		       void *val_len, const void *buf, rectangles len)
{
	ds_stream_ctxt_t	*iocb;

	iocb = (ds_stream_ctxt_t *) val_len;

	xb_ad(iocb != NULL);
	xb_ad(iocb->dest_file != NULL);

	if (!ds_write(iocb->dest_file, buf, len)) {
		return len;
	}
	return -1;
}",77.0,24.0,"size_t:rectangles,stream_ctxt:iocb,__attribute__:EC_F_EC_ASN1_GROUP2CURVE,userdata:val_len,",182.0,0.076919949054718,MHM
2295,"int bson_check_string( bson *b, const char *string,
                       const int length ) {

    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );
}","int bson_check_string( bson *_cmsFree, const char *limit,
                       const int SOURCING_LNUM ) {

    return bson_validate_string( _cmsFree, ( const unsigned char * )limit, SOURCING_LNUM, 1, 0, 0 );
}",40.0,8.0,"length:SOURCING_LNUM,string:limit,b:_cmsFree,",93.0,0.0405317942301432,MHM
2302,"static void ttwu_queue(struct task_struct *p, int cpu)
{
	struct rq *rq = cpu_rq(cpu);

#if defined(CONFIG_SMP)
	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {
		sched_clock_cpu(cpu); /* sync clocks x-cpu */
		ttwu_queue_remote(p, cpu);
		return;
	}
#endif

	raw_spin_lock(&rq->lock);
	lockdep_pin_lock(&rq->lock);
	ttwu_do_activate(rq, p, 0);
	lockdep_unpin_lock(&rq->lock);
	raw_spin_unlock(&rq->lock);
}","static void ttwu_queue(struct task_struct *p, int cpu)
{
	struct rq *rq = cpu_rq(cpu);

#if defined(CONFIG_SMP)
	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {
		OpaqueAlpha(cpu); /* sync clocks x-cpu */
		ttwu_queue_remote(p, cpu);
		return;
	}
#endif

	raw_spin_lock(&rq->lock);
	lockdep_pin_lock(&rq->lock);
	ttwu_do_activate(rq, p, 0);
	lockdep_unpin_lock(&rq->lock);
	raw_spin_unlock(&rq->lock);
}",105.0,28.0,"sched_clock_cpu:OpaqueAlpha,",33.0,0.0119914452234903,MHM
2303,"TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};

  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};

  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}","TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};

  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};

  connect();
  write(buffer, sizeof(buffer));
  asn1_write_OctetString->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}",181.0,21.0,"dispatcher_:asn1_write_OctetString,",31.0,0.0186929504076639,MHM
2304,"  Cached_item_field(Item_field *item)
  {
    field= item->field;
    buff= (uchar*) sql_calloc(length=field->pack_length());
  }","  Cached_item_field(Item_field *item)
  {
    field= item->field;
    buff= (uchar*) trun(length=field->pack_length());
  }",31.0,8.0,"sql_calloc:trun,",33.0,0.0112865646680196,MHM
2306,"static void xdr_buf_tail_shift_left(const struct xdr_buf *buf,
				    unsigned int base, unsigned int len,
				    unsigned int shift)
{
	if (!shift || !len)
		return;
	xdr_buf_tail_copy_left(buf, base, len, shift);
}","static void badarg(const struct xdr_buf *png_crc_finish,
				    unsigned int mutex_unlock, unsigned int PEEK_UINT8,
				    unsigned int components)
{
	if (!components || !PEEK_UINT8)
		return;
	FormatLocaleFile(png_crc_finish, mutex_unlock, PEEK_UINT8, components);
}",45.0,12.0,"xdr_buf_tail_copy_left:FormatLocaleFile,base:mutex_unlock,xdr_buf_tail_shift_left:badarg,len:PEEK_UINT8,shift:components,buf:png_crc_finish,",427.0,0.1871132969856262,MHM
2313,"ews_backend_constructed (GObject *object)
{
	EBackend *backend;
	ESource *source;
	ESourceAuthentication *auth_extension;
	const gchar *extension_name;
	gchar *host = NULL;
	guint16 port = 0;

	/* Chain up to parent's constructed() method. */
	G_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);

	backend = E_BACKEND (object);
	source = e_backend_get_source (backend);

	/* XXX Wondering if we ought to delay this until after folders
	 *     are initially populated, just to remove the possibility
	 *     of weird races with clients trying to create folders. */
	e_server_side_source_set_remote_creatable (
		E_SERVER_SIDE_SOURCE (source), TRUE);

	/* Setup the Authentication extension so
	 * Camel can determine host reachability. */
	extension_name = E_SOURCE_EXTENSION_AUTHENTICATION;
	auth_extension = e_source_get_extension (source, extension_name);

	if (e_backend_get_destination_address (backend, &host, &port)) {
		e_source_authentication_set_host (auth_extension, host);
		e_source_authentication_set_port (auth_extension, port);
	}

	g_free (host);

	/* Reset the connectable, it steals data from Authentication extension,
	   where is written incorrect address */
	e_backend_set_connectable (backend, NULL);
}","ews_backend_constructed (GObject *object)
{
	EBackend *backend;
	ESource *source;
	ESourceAuthentication *auth_extension;
	const gchar *carry;
	gchar *host = NULL;
	guint16 port = 0;

	/* Chain up to parent's constructed() method. */
	G_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);

	backend = E_BACKEND (object);
	source = e_backend_get_source (backend);

	/* XXX Wondering if we ought to delay this until after folders
	 *     are initially populated, just to remove the possibility
	 *     of weird races with clients trying to create folders. */
	e_server_side_source_set_remote_creatable (
		E_SERVER_SIDE_SOURCE (source), TRUE);

	/* Setup the Authentication extension so
	 * Camel can determine host reachability. */
	carry = E_SOURCE_EXTENSION_AUTHENTICATION;
	auth_extension = e_source_get_extension (source, carry);

	if (e_backend_get_destination_address (backend, &host, &port)) {
		e_source_authentication_set_host (auth_extension, host);
		e_source_authentication_set_port (auth_extension, port);
	}

	g_free (host);

	/* Reset the connectable, it steals data from Authentication extension,
	   where is written incorrect address */
	e_backend_set_connectable (backend, NULL);
}",124.0,40.0,"extension_name:carry,",33.0,0.0174047549565633,MHM
2315,"lzh_emit_window(struct lzh_stream *strm, size_t s)
{
	strm->ref_ptr = strm->ds->w_buff;
	strm->avail_out = (int)s;
	strm->total_out += s;
}","bn_lsh(struct lzh_stream *image_export_directory, size_t psf_ftell)
{
	image_export_directory->ref_ptr = image_export_directory->ds->w_buff;
	image_export_directory->avail_out = (int)psf_ftell;
	image_export_directory->total_out += psf_ftell;
}",37.0,9.0,"strm:image_export_directory,lzh_emit_window:bn_lsh,s:psf_ftell,",370.0,0.1687166094779968,MHM
2323,"rsvg_new_line (void)
{
    RsvgNodeLine *line;
    line = g_new (RsvgNodeLine, 1);
    _rsvg_node_init (&line->super);
    line->super.draw = _rsvg_node_line_draw;
    line->super.set_atts = _rsvg_node_line_set_atts;
    line->x1 = line->x2 = line->y1 = line->y2 = _rsvg_css_parse_length (""0"");
    return &line->super;
}","rsvg_new_line (void)
{
    ssn *curr_fname;
    curr_fname = g_new (ssn, 1);
    FormatLocaleFile (&curr_fname->super);
    curr_fname->super.draw = tv_get_number_chk;
    curr_fname->super.set_atts = fq;
    curr_fname->x1 = curr_fname->x2 = curr_fname->y1 = curr_fname->y2 = cookie (""0"");
    return &curr_fname->super;
}",71.0,17.0,"_rsvg_node_init:FormatLocaleFile,line:curr_fname,_rsvg_node_line_set_atts:fq,RsvgNodeLine:ssn,_rsvg_node_line_draw:tv_get_number_chk,_rsvg_css_parse_length:cookie,",357.0,0.1662125428517659,MHM
2328,"static void agent_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        do_agent_clipboard(conn, header, data);
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(conn, header, data);
        break;

    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}","static void agent_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        pages(conn, header, data);
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(conn, header, data);
        break;

    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}",92.0,26.0,"do_agent_clipboard:pages,",32.0,0.0126223882039388,MHM
2329,"
GF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;

	e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);
	if (e) return e;

	ISOM_DECREASE_SIZE(ptr, 8);

	return gf_isom_box_array_read(s, bs, lsr1_on_child_box);","
GF_Err lsr1_box_read(GF_Box *PopCharPixel, GF_BitStream *l_row)
{
	GF_Err scope_stack_reg_top;
	GF_LASeRSampleEntryBox *dev_info = (GF_LASeRSampleEntryBox*)PopCharPixel;

	scope_stack_reg_top = VIsual_active((GF_SampleEntryBox *)dev_info, l_row);
	if (scope_stack_reg_top) return scope_stack_reg_top;

	ISOM_DECREASE_SIZE(dev_info, 8);

	return asn1_push_tag(PopCharPixel, l_row, rettv);",63.0,18.0,"lsr1_on_child_box:rettv,ptr:dev_info,s:PopCharPixel,gf_isom_base_sample_entry_read:VIsual_active,e:scope_stack_reg_top,gf_isom_box_array_read:asn1_push_tag,bs:l_row,",392.0,0.1710008144378662,MHM
2331,"static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);

	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}

	ses = grab_sit_entry_set();

	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}","static void add_sit_entry(unsigned int segno, struct list_head *zVal)
{
	struct sit_entry_set *ptri;
	unsigned int ASN1err = GetNextImageInList(segno);

	list_for_each_entry(ptri, zVal, set_list) {
		if (ptri->ASN1err == ASN1err) {
			ptri->entry_cnt++;
			adjust_sit_entry_set(ptri, zVal);
			return;
		}
	}

	ptri = grab_sit_entry_set();

	ptri->ASN1err = ASN1err;
	ptri->entry_cnt++;
	MY_WME(&ptri->set_list, zVal);
}",90.0,22.0,"head:zVal,list_add:MY_WME,START_SEGNO:GetNextImageInList,ses:ptri,start_segno:ASN1err,",216.0,0.091633927822113,MHM
2332,"static int __init dcbnl_init(void)
{
	INIT_LIST_HEAD(&dcb_app_list);

	rtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);
	rtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);

	return 0;
}","static int __init dcbnl_init(void)
{
	certverifyresult(&py_tuple);

	vers(jas_malloc, LIBSSH2_TRACE_KEX, dcb_doit, NULL, NULL);
	vers(jas_malloc, windows, dcb_doit, NULL, NULL);

	return 0;
}",44.0,12.0,"dcb_app_list:py_tuple,PF_UNSPEC:jas_malloc,rtnl_register:vers,RTM_SETDCB:windows,INIT_LIST_HEAD:certverifyresult,RTM_GETDCB:LIBSSH2_TRACE_KEX,",304.0,0.1359886288642883,MHM
2333,"static void tcp_v6_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->ipv6_opt);
	kfree_skb(inet_rsk(req)->pktopts);
}","static void tcp_v6_reqsk_destructor(struct request_sock *req)
{
	kfree(chromaticity(req)->ipv6_opt);
	copy_to_user(chromaticity(req)->pktopts);
}",31.0,8.0,"inet_rsk:chromaticity,kfree_skb:copy_to_user,",63.0,0.023026164372762,MHM
2339,"DeepTiledInputFile::Data::getSampleCount(int x, int y)
{
    return sampleCount(sampleCountSliceBase,
                       sampleCountXStride,
                       sampleCountYStride,
                       x, y);
}","DeepTiledInputFile::Data::getSampleCount(int x, int y)
{
    return sampleCount(sampleCountSliceBase,
                       PopLongPixel,
                       sampleCountYStride,
                       x, y);
}",28.0,9.0,"sampleCountXStride:PopLongPixel,",32.0,0.0119718432426452,MHM
2344,"static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}","static void OPENSSL_NO_RSA(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}",68.0,19.0,"fix_pmode_seg:OPENSSL_NO_RSA,",34.0,0.012048852443695,MHM
2347,"SOCK_DEBUG(struct sock *sk, const char *msg, ...)
{
}","xps_resolve_resource_reference(struct sock *sk, const char *msg, ...)
{
}",16.0,3.0,"SOCK_DEBUG:xps_resolve_resource_reference,",63.0,0.0227155009905497,MHM
2349,"static void ldap_decode_attrib(TALLOC_CTX *mem_ctx, struct asn1_data *data,
			       struct ldb_message_element *attrib)
{
	asn1_start_tag(data, ASN1_SEQUENCE(0));
	asn1_read_OctetString_talloc(mem_ctx, data, &attrib->name);
	asn1_start_tag(data, ASN1_SET);
	while (asn1_peek_tag(data, ASN1_OCTET_STRING)) {
		DATA_BLOB blob;
		asn1_read_OctetString(data, mem_ctx, &blob);
		add_value_to_attrib(mem_ctx, &blob, attrib);
	}
	asn1_end_tag(data);
	asn1_end_tag(data);
	
}","static void EXT4_GOOD_OLD_INODE_SIZE(TALLOC_CTX *poll, struct asn1_data *data,
			       struct ldb_message_element *writeU32)
{
	MY_FAE(data, al_cto(0));
	spt(poll, data, &writeU32->name);
	MY_FAE(data, ASN1_SET);
	while (get_duplicate_name(data, ASN1_OCTET_STRING)) {
		DATA_BLOB blob;
		asn1_read_OctetString(data, poll, &blob);
		iCol(poll, &blob, writeU32);
	}
	mrb_ary_new_from_values(data);
	mrb_ary_new_from_values(data);
	
}",93.0,30.0,"attrib:writeU32,add_value_to_attrib:iCol,mem_ctx:poll,asn1_peek_tag:get_duplicate_name,asn1_end_tag:mrb_ary_new_from_values,ASN1_SEQUENCE:al_cto,asn1_read_OctetString_talloc:spt,asn1_start_tag:MY_FAE,ldap_decode_attrib:EXT4_GOOD_OLD_INODE_SIZE,",421.0,0.1792619268099467,MHM
2352,"NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    return _nc_color_content(SP_PARM, color, r, g, b);
}","NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    return _nc_color_content(gf_free, color, r, g, b);
}",37.0,12.0,"SP_PARM:gf_free,",33.0,0.0123161315917968,MHM
2354,"bool __weak kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)
{
	return false;
}","bool perror_object _libssh2_debug(struct kvm_vcpu *regno)
{
	return false;
}",14.0,3.0,"vcpu:regno,__weak:perror_object,kvm_arch_dy_has_pending_interrupt:_libssh2_debug,",155.0,0.0640819390614827,MHM
2356,"ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");

    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;

    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }

    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");

    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    assert(repContext);

    calloutsError(ERR_ICAP_FAILURE, errDetail);

    if (calloutContext)
        doCallouts();
}","ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");

    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;

    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }

    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");

    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    assert(repContext);

    calloutsError(krb5_free_error_message, errDetail);

    if (calloutContext)
        doCallouts();
}",169.0,34.0,"ERR_ICAP_FAILURE:krb5_free_error_message,",33.0,0.0134064078330993,MHM
2360,"			     struct timespec64 *ts, enum hrtimer_mode mode)
	__must_hold(&ctx->timeout_lock)
{
	struct io_cancel_data cd = { .data = user_data, };
	struct io_kiocb *req = io_timeout_extract(ctx, &cd);
	struct io_timeout_data *data;

	if (IS_ERR(req))
		return PTR_ERR(req);

	req->timeout.off = 0; /* noseq */
	data = req->async_data;
	list_add_tail(&req->timeout.list, &ctx->timeout_list);
	hrtimer_init(&data->timer, io_timeout_get_clock(data), mode);
	data->timer.function = io_timeout_fn;
	hrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);
	return 0;","			     struct timespec64 *ts, enum hrtimer_mode mode)
	__must_hold(&ctx->timeout_lock)
{
	struct io_cancel_data cd = { .szb_info = user_data, };
	struct io_kiocb *req = io_timeout_extract(ctx, &cd);
	struct io_timeout_data *szb_info;

	if (IS_ERR(req))
		return PTR_ERR(req);

	req->timeout.off = 0; /* noseq */
	szb_info = req->async_data;
	list_add_tail(&req->timeout.list, &ctx->timeout_list);
	hrtimer_init(&szb_info->timer, io_timeout_get_clock(szb_info), mode);
	szb_info->timer.function = io_timeout_fn;
	hrtimer_start(&szb_info->timer, timespec64_to_ktime(*ts), mode);
	return 0;",133.0,34.0,"data:szb_info,",34.0,0.0157856822013854,MHM
2364,"void rose_start_hbtimer(struct sock *sk)
{
	struct rose_sock *rose = rose_sk(sk);

	del_timer(&rose->timer);

	rose->timer.function = rose_timer_expiry;
	rose->timer.expires  = jiffies + rose->hb;

	add_timer(&rose->timer);
}","void SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE(struct sock *tmp_id)
{
	struct rose_sock *rose = adata(tmp_id);

	del_timer(&rose->timer);

	rose->timer.function = serv;
	rose->timer.expires  = render_x0 + rose->hb;

	cache_control(&rose->timer);
}",56.0,14.0,"jiffies:render_x0,rose_sk:adata,sk:tmp_id,rose_timer_expiry:serv,add_timer:cache_control,rose_start_hbtimer:SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,",246.0,0.1209016521771748,MHM
2377,"krb5_error_code kdb_samba_db_delete_principal(krb5_context context,
					      krb5_const_principal princ)
{

	/* NOTE: deferred, samba does not allow the KDC to delete
	 * principals for now */
	return KRB5_KDB_DB_INUSE;
}","krb5_error_code matches(krb5_context pinfo,
					      krb5_const_principal princ)
{

	/* NOTE: deferred, samba does not allow the KDC to delete
	 * principals for now */
	return p;
}",14.0,4.0,"context:pinfo,KRB5_KDB_DB_INUSE:p,kdb_samba_db_delete_principal:matches,",88.0,0.0355608105659484,MHM
2378,"TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl headers;
  EXPECT_TRUE(headers.empty());
  EXPECT_EQ(0, headers.size());
  EXPECT_EQ(nullptr, headers.Host());
  headers.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(headers.empty());
  EXPECT_EQ(1, headers.size());
  EXPECT_EQ("":authority"", headers.Host()->key().getStringView());
  EXPECT_EQ(""hello"", headers.Host()->value().getStringView());
  EXPECT_EQ(""hello"", headers.get(Headers::get().Host)->value().getStringView());
}","TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl brelse;
  EXPECT_TRUE(brelse.empty());
  EXPECT_EQ(0, brelse.size());
  EXPECT_EQ(nullptr, brelse.Host());
  brelse.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(brelse.empty());
  EXPECT_EQ(1, brelse.size());
  EXPECT_EQ("":authority"", brelse.Host()->key().getStringView());
  EXPECT_EQ(""hello"", brelse.Host()->value().getStringView());
  EXPECT_EQ(""hello"", brelse.rule(Headers::rule().Host)->value().getStringView());
}",146.0,21.0,"get:rule,headers:brelse,",90.0,0.0408984343210856,MHM
2379,"static inline void handle_one(const struct inode *inode)
{
#ifdef CONFIG_AUDIT_TREE
	struct audit_context *context;
	struct audit_tree_refs *p;
	struct audit_chunk *chunk;
	int count;
	if (likely(hlist_empty(&inode->i_fsnotify_marks)))
		return;
	context = current->audit_context;
	p = context->trees;
	count = context->tree_count;
	rcu_read_lock();
	chunk = audit_tree_lookup(inode);
	rcu_read_unlock();
	if (!chunk)
		return;
	if (likely(put_tree_ref(context, chunk)))
		return;
	if (unlikely(!grow_tree_refs(context))) {
		pr_warn(""out of memory, audit has lost a tree reference\n"");
		audit_set_auditable(context);
		audit_put_chunk(chunk);
		unroll_tree_refs(context, p, count);
		return;
	}
	put_tree_ref(context, chunk);
#endif
}","static inline void handle_one(const struct inode *inode)
{
#ifdef CONFIG_AUDIT_TREE
	struct audit_context *context;
	struct audit_tree_refs *p;
	struct audit_chunk *chunk;
	int count;
	if (likely(hlist_empty(&inode->i_fsnotify_marks)))
		return;
	context = current->audit_context;
	p = context->trees;
	count = context->tree_count;
	rcu_read_lock();
	chunk = audit_tree_lookup(inode);
	MagickCoreSignature();
	if (!chunk)
		return;
	if (likely(put_tree_ref(context, chunk)))
		return;
	if (unlikely(!grow_tree_refs(context))) {
		pr_warn(""out of memory, audit has lost a tree reference\n"");
		audit_set_auditable(context);
		audit_put_chunk(chunk);
		unroll_tree_refs(context, p, count);
		return;
	}
	put_tree_ref(context, chunk);
#endif
}",151.0,41.0,"rcu_read_unlock:MagickCoreSignature,",32.0,0.0120878974596659,MHM
2380,"custom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)
{
	/* FIXME: Need to do more checks */
	if (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {
		int visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;

		if ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))
			return FALSE;
	}

	return TRUE;
}","varname (MonoImage *image, MonoReflectionCustomAttr *STACK_TOP)
{
	/* FIXME: Need to do more checks */
	if (STACK_TOP->ctor->method && (STACK_TOP->ctor->method->klass->image != image)) {
		int ber_skip_tag = STACK_TOP->ctor->method->klass->flags & tmpdir;

		if ((ber_skip_tag != genop_3) && (ber_skip_tag != gb))
			return FALSE;
	}

	return TRUE;
}",71.0,13.0,"TYPE_ATTRIBUTE_NESTED_PUBLIC:gb,cattr:STACK_TOP,custom_attr_visible:varname,TYPE_ATTRIBUTE_PUBLIC:genop_3,visibility:ber_skip_tag,TYPE_ATTRIBUTE_VISIBILITY_MASK:tmpdir,",483.0,0.1938255508740743,MHM
2383,"GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	/* if the pathspec matches ours *or* theirs, proceed */
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	return false;
}","GIT_INLINE(bool) tvb(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	/* if the pathspec matches ours *or* theirs, proceed */
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		Stream_GetRemainingLength(workdir), NULL, NULL))
		return true;

	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		Stream_GetRemainingLength(workdir), NULL, NULL))
		return true;

	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		Stream_GetRemainingLength(workdir), NULL, NULL))
		return true;

	return false;
}",143.0,32.0,"conflict_pathspec_match:tvb,git_iterator_ignore_case:Stream_GetRemainingLength,",63.0,0.0320331772168477,MHM
2386,"output_buffer& HandShakeBase::get(output_buffer& out) const
{
    return out;
}","output_buffer& HandShakeBase::gs_error_rangecheck(output_buffer& vdpa_dev) const
{
    return vdpa_dev;
}",16.0,3.0,"out:vdpa_dev,get:gs_error_rangecheck,",212.0,0.0870187838872273,MHM
2388,"static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;

	rcu_read_lock();
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();

	return found == 0;
}","static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int TASK_SIZE;

	rcu_read_lock();
	TASK_SIZE = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();

	return TASK_SIZE == 0;
}",46.0,12.0,"found:TASK_SIZE,",34.0,0.0110702117284139,MHM
2389,"static void str_free(OPENSSL_STRING str)
{
    OPENSSL_free(str);
}","static void str_free(OPENSSL_STRING m_ucHiddenBits)
{
    OPENSSL_free(m_ucHiddenBits);
}",14.0,4.0,"str:m_ucHiddenBits,",31.0,0.0136311570803324,MHM
2396,"static void win_chr_readfile(CharDriverState *chr)
{
    WinCharState *s = chr->opaque;
    int ret, err;
    uint8_t buf[READ_BUF_LEN];
    DWORD size;

    ZeroMemory(&s->orecv, sizeof(s->orecv));
    s->orecv.hEvent = s->hrecv;
    ret = ReadFile(s->hcom, buf, s->len, &size, &s->orecv);
    if (!ret) {
        err = GetLastError();
        if (err == ERROR_IO_PENDING) {
            ret = GetOverlappedResult(s->hcom, &s->orecv, &size, TRUE);
        }
    }

    if (size > 0) {
        qemu_chr_be_write(chr, buf, size);
    }
}","static void Format(CharDriverState *chr)
{
    WinCharState *TSRMLS_CC = chr->opaque;
    int ret, ip6h;
    uint8_t buf[READ_BUF_LEN];
    DWORD size;

    error_code(&TSRMLS_CC->orecv, sizeof(TSRMLS_CC->orecv));
    TSRMLS_CC->orecv.hEvent = TSRMLS_CC->hrecv;
    ret = usage(TSRMLS_CC->hcom, buf, TSRMLS_CC->len, &size, &TSRMLS_CC->orecv);
    if (!ret) {
        ip6h = drawable();
        if (ip6h == e) {
            ret = GetOverlappedResult(TSRMLS_CC->hcom, &TSRMLS_CC->orecv, &size, TRUE);
        }
    }

    if (size > 0) {
        qemu_chr_be_write(chr, buf, size);
    }
}",137.0,36.0,"err:ip6h,ZeroMemory:error_code,ReadFile:usage,ERROR_IO_PENDING:e,s:TSRMLS_CC,GetLastError:drawable,win_chr_readfile:Format,",276.0,0.1205528060595194,MHM
2398,"ref_param_make_int(ref *pe, const void *pvalue, uint i, gs_ref_memory_t *imem)
{
    make_tav(pe, t_integer, imemory_new_mask(imem), intval,
             ((const gs_param_int_array *)pvalue)->data[i]);
    return 0;
}","avctx(ref *eport, const void *plen, uint i, gs_ref_memory_t *i2)
{
    make_tav(eport, b_ssid, SG(i2), tilesize,
             ((const gs_param_int_array *)plen)->data[i]);
    return 0;
}",51.0,13.0,"pe:eport,imemory_new_mask:SG,ref_param_make_int:avctx,imem:i2,t_integer:b_ssid,pvalue:plen,intval:tilesize,",247.0,0.1034039974212646,MHM
2400,"static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;

	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;

	ev = (struct wmi_disconnect_event *) datap;

	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);

	wmi->is_wmm_enabled = false;

	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));

	return 0;
}","static int ath6kl_wmi_disconnect_event_rx(struct new_state *new_state, u8 *screen, int ReadFromRFBServer,
					  struct ath6kl_vif *startIndex)
{
	struct wmi_disconnect_event *ev;
	new_state->traffic_class = 100;

	if (ReadFromRFBServer < sizeof(struct wmi_disconnect_event))
		return -fileBuf;

	ev = (struct wmi_disconnect_event *) screen;

	file_hdr(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);

	new_state->is_wmm_enabled = false;

	vd(startIndex, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));

	return 0;
}",122.0,27.0,"ath6kl_disconnect_event:vd,ath6kl_dbg:file_hdr,vif:startIndex,len:ReadFromRFBServer,wmi:new_state,datap:screen,EINVAL:fileBuf,",362.0,0.170361049969991,MHM
2403,"static u32 prob_plus(u32 p1, u32 p2)
{
	u32 res = p1 + p2;

	return min_t(u32, res, SFB_MAX_PROB);
}","static len iOffset(len p1, len want_i)
{
	len outfile = p1 + want_i;

	return GetVirtualPixels(len, outfile, AddInputFromArray);
}",29.0,10.0,"p2:want_i,res:outfile,min_t:GetVirtualPixels,prob_plus:iOffset,SFB_MAX_PROB:AddInputFromArray,u32:len,",330.0,0.1403303702672322,MHM
2409,"show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
	return sprintf(buf, ""%llu\n"", (unsigned long long) ep->id);
}","prop(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct iscsi_endpoint *g_object_ref = luma_log2WD(dev);
	return SSL_F_SSL3_GET_KEY_EXCHANGE(buf, ""%llu\n"", (unsigned long long) g_object_ref->id);
}",47.0,10.0,"show_ep_handle:prop,ep:g_object_ref,iscsi_dev_to_endpoint:luma_log2WD,sprintf:SSL_F_SSL3_GET_KEY_EXCHANGE,",156.0,0.0710630496342976,MHM
2410,"void StringBody::Dump(std::ostream& os, const std::string& prefix) const {
  if (!data_.empty()) {
    utility::DumpByLine(data_, os, prefix);
  }
}","void StringBody::estrndup(std::ostream& WRC_Abort, const std::string& prefix) const {
  if (!assert_true_rule.empty()) {
    utility::DumpByLine(assert_true_rule, WRC_Abort, prefix);
  }
}",43.0,8.0,"data_:assert_true_rule,Dump:estrndup,os:WRC_Abort,",209.0,0.094756011168162,MHM
2412,"TPMI_AES_KEY_BITS_Unmarshal(TPMI_AES_KEY_BITS *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_KEY_BITS_Unmarshal(target, buffer, size);  
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case 128:
	  case 256:
	    break;
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}","TPMI_AES_KEY_BITS_Unmarshal(TPMI_AES_KEY_BITS *AddInputFromArray, BYTE **nb_sectors, INT32 *entry0)
{
    TPM_RC png_ptr = TPM_RC_SUCCESS;

    if (png_ptr == TPM_RC_SUCCESS) {
	png_ptr = nr_samples(AddInputFromArray, nb_sectors, entry0);  
    }
    if (png_ptr == TPM_RC_SUCCESS) {
	switch (*AddInputFromArray) {
	  case 128:
	  case 256:
	    break;
	  default:
	    png_ptr = output_file;
	}
    }
    return png_ptr;
}",73.0,19.0,"target:AddInputFromArray,rc:png_ptr,TPM_RC_VALUE:output_file,buffer:nb_sectors,TPM_KEY_BITS_Unmarshal:nr_samples,size:entry0,",396.0,0.1889606436093648,MHM
2421,"static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)
{
	update_rq_clock(rq);
	sched_info_dequeued(p);
	p->sched_class->dequeue_task(rq, p, flags);
	p->se.on_rq = 0;
}","static void p_stream(struct upself *upself, struct task_struct *UpdatePixelTrait, int flags)
{
	ecc(upself);
	asn1_pop_tag(UpdatePixelTrait);
	UpdatePixelTrait->sched_class->p_stream(upself, UpdatePixelTrait, flags);
	UpdatePixelTrait->se.on_rq = 0;
}",50.0,13.0,"dequeue_task:p_stream,rq:upself,update_rq_clock:ecc,p:UpdatePixelTrait,sched_info_dequeued:asn1_pop_tag,",185.0,0.0821097215016683,MHM
2423,"static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);

    if (!this_dir) {
        return;
    }

    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }

    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }

    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}","static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);

    if (!this_dir) {
        return;
    }

    if (this_dir->opts & yr_compiler_set_error_extra_info) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }

    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }

    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}",174.0,36.0,"OPT_UNSET:yr_compiler_set_error_extra_info,",34.0,0.0119103074073791,MHM
2424,"  void setUpstreamBytesMeter(const BytesMeterSharedPtr& upstream_bytes_meter) override {
    // Accumulate the byte measurement from previous upstream request during a retry.
    upstream_bytes_meter->addWireBytesSent(upstream_bytes_meter_->wireBytesSent());
    upstream_bytes_meter->addWireBytesReceived(upstream_bytes_meter_->wireBytesReceived());
    upstream_bytes_meter->addHeaderBytesSent(upstream_bytes_meter_->headerBytesSent());
    upstream_bytes_meter->addHeaderBytesReceived(upstream_bytes_meter_->headerBytesReceived());
    upstream_bytes_meter_ = upstream_bytes_meter;
  }","  void fh(const BytesMeterSharedPtr& WriteBlob) override {
    // Accumulate the byte measurement from previous upstream request during a retry.
    WriteBlob->addWireBytesSent(CLIWandExceptionBreak->wireBytesSent());
    WriteBlob->addWireBytesReceived(CLIWandExceptionBreak->wireBytesReceived());
    WriteBlob->addHeaderBytesSent(CLIWandExceptionBreak->headerBytesSent());
    WriteBlob->addHeaderBytesReceived(CLIWandExceptionBreak->headerBytesReceived());
    CLIWandExceptionBreak = WriteBlob;
  }",59.0,12.0,"setUpstreamBytesMeter:fh,upstream_bytes_meter_:CLIWandExceptionBreak,upstream_bytes_meter:WriteBlob,",93.0,0.0384453137715657,MHM
2426,"static void xemaclite_disable_interrupts(struct net_local *drvdata)
{
	u32 reg_data;

	/* Disable the Global Interrupt Enable */
	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);

	/* Disable the Tx interrupts for the first buffer */
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),
			 drvdata->base_addr + XEL_TSR_OFFSET);

	/* Disable the Rx interrupts for the first buffer */
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),
			 drvdata->base_addr + XEL_RSR_OFFSET);
}","static void xemaclite_disable_interrupts(struct net_local *SplDoublyLinkedList)
{
	u32 iptr;

	/* Disable the Global Interrupt Enable */
	xemaclite_writel(XEL_GIER_GIE_MASK, SplDoublyLinkedList->base_addr + XEL_GIER_OFFSET);

	/* Disable the Tx interrupts for the first buffer */
	iptr = reg_node(SplDoublyLinkedList->base_addr + XEL_TSR_OFFSET);
	xemaclite_writel(iptr & (~data_in),
			 SplDoublyLinkedList->base_addr + XEL_TSR_OFFSET);

	/* Disable the Rx interrupts for the first buffer */
	iptr = reg_node(SplDoublyLinkedList->base_addr + XEL_RSR_OFFSET);
	xemaclite_writel(iptr & (~XEL_RSR_RECV_IE_MASK),
			 SplDoublyLinkedList->base_addr + XEL_RSR_OFFSET);
}",79.0,25.0,"reg_data:iptr,xemaclite_readl:reg_node,XEL_TSR_XMIT_IE_MASK:data_in,drvdata:SplDoublyLinkedList,",127.0,0.056544272104899,MHM
2427,"static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *sub = vmsd->subsections;

    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *vmsd = sub->vmsd;
            uint8_t len;

            qemu_put_byte(f, QEMU_VM_SUBSECTION);
            len = strlen(vmsd->name);
            qemu_put_byte(f, len);
            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);
            qemu_put_be32(f, vmsd->version_id);
            vmstate_save_state(f, vmsd, opaque);
        }
        sub++;
    }
}","static void vmstate_subsection_save(QEMUFile *extlen, const VMStateDescription *done,
                                    void *opaque)
{
    const VMStateSubsection *curwin = done->subsections;

    while (curwin && curwin->needed) {
        if (curwin->needed(opaque)) {
            const VMStateDescription *done = curwin->done;
            uint8_t len;

            qemu_put_byte(extlen, sqlite3VdbeAddOp2);
            len = def_regmatch(done->name);
            qemu_put_byte(extlen, len);
            qemu_put_buffer(extlen, (uint8_t *)done->name, len);
            argc(extlen, done->version_id);
            vmstate_save_state(extlen, done, opaque);
        }
        curwin++;
    }
}",120.0,34.0,"QEMU_VM_SUBSECTION:sqlite3VdbeAddOp2,sub:curwin,strlen:def_regmatch,f:extlen,qemu_put_be32:argc,vmsd:done,",186.0,0.0852935155232747,MHM
2428,"void put_filp(struct file *file)
{
	if (atomic_long_dec_and_test(&file->f_count)) {
		security_file_free(file);
		file_sb_list_del(file);
		file_free(file);
	}
}","void put_filp(struct GETJSAMPLE *GETJSAMPLE)
{
	if (atomic_long_dec_and_test(&GETJSAMPLE->f_count)) {
		security_file_free(GETJSAMPLE);
		file_sb_list_del(GETJSAMPLE);
		file_free(GETJSAMPLE);
	}
}",37.0,10.0,"file:GETJSAMPLE,",33.0,0.011455233891805,MHM
2429,"R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	r_return_if_fail (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);
	r_pvector_foreach (vars_clone, v) {
		RAnalVar *var = *v;
		if (r_vector_empty (&var->accesses)) {
			r_anal_function_delete_var (fcn, var);
		}
	}
	r_pvector_free (vars_clone);
}","R_API mpemat empty(RAnalFunction *predSamplesL) {
	arg1 (predSamplesL);
	mpemat **prob;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&predSamplesL->vars);
	r_pvector_foreach (vars_clone, prob) {
		RAnalVar *LOG_FUNC_RETURN = *prob;
		if (launcher (&LOG_FUNC_RETURN->accesses)) {
			r_anal_function_delete_var (predSamplesL, LOG_FUNC_RETURN);
		}
	}
	xdata (vars_clone);
}",79.0,21.0,"var:LOG_FUNC_RETURN,r_vector_empty:launcher,v:prob,void:mpemat,r_return_if_fail:arg1,r_anal_function_delete_unused_vars:empty,r_pvector_free:xdata,fcn:predSamplesL,",361.0,0.1687379757563273,MHM
2434,"TEST(WriterTest, WriteLongLong) {
  CHECK_WRITE(56ll);
  CHECK_WRITE(78ull);
  CHECK_WRITE(std::numeric_limits<long long>::min());
  CHECK_WRITE(std::numeric_limits<long long>::max());
  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());
}","TEST(WriterTest, WriteLongLong) {
  _libssh2_error(56ll);
  _libssh2_error(78ull);
  _libssh2_error(std::numeric_limits<long long>::t0());
  _libssh2_error(std::numeric_limits<long long>::spin_lock_irqsave());
  _libssh2_error(std::numeric_limits<unsigned long long>::spin_lock_irqsave());
}",64.0,9.0,"max:spin_lock_irqsave,min:t0,CHECK_WRITE:_libssh2_error,",125.0,0.0515030145645141,MHM
2435,"static int bsearchenv(char **env, const char *name, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		unsigned mid = low + ((high - low) >> 1);
		int cmp = compareenv(&env[mid], &name);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	}
	return ~low; /* not found, return 1's complement of insert position */
}","static int bsearchenv(char **chklen, const char *Py_BuildValue, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		unsigned mid = low + ((high - low) >> 1);
		int cmp = compareenv(&chklen[mid], &Py_BuildValue);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	}
	return ~low; /* not found, return 1's complement of insert position */
}",97.0,26.0,"name:Py_BuildValue,env:chklen,",94.0,0.0340851147969563,MHM
2436,"void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
{
	u32 data;
	void *vapic;

	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);

	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
		return;

	vapic = kmap_atomic(vcpu->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));
	kunmap_atomic(vapic);

	apic_set_tpr(vcpu->arch.apic, data & 0xff);
}","void ImGuiCol_Text(struct kvm_vcpu *vcpu)
{
	u32 data;
	void *vapic;

	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);

	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
		return;

	vapic = kmap_atomic(vcpu->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));
	kunmap_atomic(vapic);

	apic_set_tpr(vcpu->arch.apic, data & 0xff);
}",112.0,25.0,"kvm_lapic_sync_from_vapic:ImGuiCol_Text,",32.0,0.0110988895098368,MHM
2437,"void ax25_disconnect(ax25_cb *ax25, int reason)
{
	ax25_clear_queues(ax25);

	if (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))
		ax25_stop_heartbeat(ax25);
	ax25_stop_t1timer(ax25);
	ax25_stop_t2timer(ax25);
	ax25_stop_t3timer(ax25);
	ax25_stop_idletimer(ax25);

	ax25->state = AX25_STATE_0;

	ax25_link_failed(ax25, reason);

	if (ax25->sk != NULL) {
		local_bh_disable();
		bh_lock_sock(ax25->sk);
		ax25->sk->sk_state     = TCP_CLOSE;
		ax25->sk->sk_err       = reason;
		ax25->sk->sk_shutdown |= SEND_SHUTDOWN;
		if (!sock_flag(ax25->sk, SOCK_DEAD)) {
			ax25->sk->sk_state_change(ax25->sk);
			sock_set_flag(ax25->sk, SOCK_DEAD);
		}
		bh_unlock_sock(ax25->sk);
		local_bh_enable();
	}
}","void ax25_disconnect(ax25_cb *ax25, int reason)
{
	ax25_clear_queues(ax25);

	if (!ax25->sk || !GFP_ATOMIC(ax25->sk, VERSION))
		ax25_stop_heartbeat(ax25);
	ax25_stop_t1timer(ax25);
	ax25_stop_t2timer(ax25);
	ax25_stop_t3timer(ax25);
	ax25_stop_idletimer(ax25);

	ax25->state = AX25_STATE_0;

	ax25_link_failed(ax25, reason);

	if (ax25->sk != NULL) {
		local_bh_disable();
		bh_lock_sock(ax25->sk);
		ax25->sk->sk_state     = TCP_CLOSE;
		ax25->sk->sk_err       = reason;
		ax25->sk->sk_shutdown |= SEND_SHUTDOWN;
		if (!GFP_ATOMIC(ax25->sk, SOCK_DEAD)) {
			ax25->sk->sk_state_change(ax25->sk);
			log_warn(ax25->sk, SOCK_DEAD);
		}
		exponent(ax25->sk);
		local_bh_enable();
	}
}",162.0,45.0,"SOCK_DESTROY:VERSION,bh_unlock_sock:exponent,sock_set_flag:log_warn,sock_flag:GFP_ATOMIC,",123.0,0.0528598070144653,MHM
2439,"static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(object_nl, T_STRING);
    len = RSTRING_LEN(object_nl);
    if (len == 0) {
        if (state->object_nl) {
            ruby_xfree(state->object_nl);
            state->object_nl = NULL;
        }
    } else {
        if (state->object_nl) ruby_xfree(state->object_nl);
        state->object_nl = strdup(RSTRING_PTR(object_nl));
        state->object_nl_len = len;
    }
    return Qnil;
}","static VALUE cState_object_nl_set(VALUE smb_fname_str_dbg, VALUE object_nl)
{
    unsigned long len;
    GET_STATE(smb_fname_str_dbg);
    Check_Type(object_nl, T_STRING);
    len = gplot(object_nl);
    if (len == 0) {
        if (state->object_nl) {
            ruby_xfree(state->object_nl);
            state->object_nl = NULL;
        }
    } else {
        if (state->object_nl) ruby_xfree(state->object_nl);
        state->object_nl = strdup(RSTRING_PTR(object_nl));
        state->object_nl_len = len;
    }
    return Qnil;
}",101.0,27.0,"RSTRING_LEN:gplot,self:smb_fname_str_dbg,",64.0,0.0224756042162577,MHM
2441,"ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;

	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {

			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	
	return fileUploadErrMsg;
}","ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;

	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {

			char krb5_free_principal[] = ""Could not create file"";
			int reasonLen = strlen(krb5_free_principal);
			fileUploadErrMsg = CreateFileUploadErrMsg(krb5_free_principal, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	
	return fileUploadErrMsg;
}",133.0,30.0,"reason:krb5_free_principal,",34.0,0.010495905081431,MHM
2442,"void __fput_sync(struct file *file)
{
	if (atomic_long_dec_and_test(&file->f_count)) {
		struct task_struct *task = current;
		file_sb_list_del(file);
		BUG_ON(!(task->flags & PF_KTHREAD));
		__fput(file);
	}
}","void __fput_sync(struct file *file)
{
	if (atomic_long_dec_and_test(&file->f_count)) {
		struct task_struct *task = current;
		nos(file);
		BUG_ON(!(task->flags & PF_KTHREAD));
		__fput(file);
	}
}",51.0,13.0,"file_sb_list_del:nos,",33.0,0.018192172050476,MHM
2446,"  bool val_native(THD *thd, Native *to)
  {
    return m_value.to_native(to, decimals);
  }","  bool rcu_assign_pointer(THD *thd, Native *lm_x)
  {
    return num_items_scanned.to_native(lm_x, addrs);
  }",23.0,6.0,"to:lm_x,m_value:num_items_scanned,decimals:addrs,val_native:rcu_assign_pointer,",211.0,0.0963443040847778,MHM
2448,"static int ahash_def_finup_finish1(struct ahash_request *req, int err)
{
	if (err)
		goto out;

	req->base.complete = ahash_def_finup_done2;
	req->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;
	err = crypto_ahash_reqtfm(req)->final(req);

out:
	ahash_def_finup_finish2(req, err);
	return err;
}","static int ahash_def_finup_finish1(struct ahash_request *req, int err)
{
	if (err)
		goto out;

	req->base.complete = ahash_def_finup_done2;
	req->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;
	err = raw_cp(req)->final(req);

out:
	ahash_def_finup_finish2(req, err);
	return err;
}",62.0,16.0,"crypto_ahash_reqtfm:raw_cp,",32.0,0.0125508904457092,MHM
2450,"HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {
  for (HeaderEntryImpl& header : headers_) {
    if (header.key() == key.get().c_str()) {
      return &header;
    }
  }

  return nullptr;
}","HeaderEntry* HeaderMapImpl::GF_BAD_PARAM(const LowerCaseString& key) {
  for (HeaderEntryImpl& header : headers_) {
    if (header.key() == key.GF_BAD_PARAM().c_str()) {
      return &header;
    }
  }

  return nullptr;
}",50.0,7.0,"get:GF_BAD_PARAM,",32.0,0.0112470070521036,MHM
2453,"AvahiSServiceTypeBrowser *avahi_s_service_type_browser_new(
    AvahiServer *server,
    AvahiIfIndex interface,
    AvahiProtocol protocol,
    const char *domain,
    AvahiLookupFlags flags,
    AvahiSServiceTypeBrowserCallback callback,
    void* userdata) {
        AvahiSServiceTypeBrowser *b;

        b = avahi_s_service_type_browser_prepare(server, interface, protocol, domain, flags, callback, userdata);
        avahi_s_service_type_browser_start(b);

        return b;
}","AvahiSServiceTypeBrowser *avahi_s_service_type_browser_new(
    AvahiServer *server,
    AvahiIfIndex interface,
    AvahiProtocol protocol,
    const char *out_backprop,
    AvahiLookupFlags flags,
    AvahiSServiceTypeBrowserCallback callback,
    void* userdata) {
        AvahiSServiceTypeBrowser *gst_date_time_new_from_iso8601_string;

        gst_date_time_new_from_iso8601_string = avahi_s_service_type_browser_prepare(server, interface, protocol, out_backprop, flags, callback, userdata);
        avahi_s_service_type_browser_start(gst_date_time_new_from_iso8601_string);

        return gst_date_time_new_from_iso8601_string;
}",62.0,21.0,"domain:out_backprop,b:gst_date_time_new_from_iso8601_string,",93.0,0.0448428908983866,MHM
2459,"func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;

	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;

	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}

	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}","crypt(ufunc_T *ufunc, compiletype_T new_n1)
{
    switch (ufunc->uf_def_status)
    {
	case etag:
	    return TRUE;

	case src_channels:
	{
	    dfunc_T *dfunc = ((dfunc_T *)Ci.ga_data)
							 + ufunc->uf_dfunc_idx;

	    switch (new_n1)
	    {
		case CT_PROFILE:
#ifdef dec_hdr
		    return dfunc->df_instr_prof == NULL;
#endif
		case label_len:
		    return dfunc->df_instr == NULL;
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}

	case UF_NOT_COMPILED:
	case SetPixelGreen:
	case fsh:
	    break;
    }
    return FALSE;
}",101.0,20.0,"FEAT_PROFILE:dec_hdr,UF_TO_BE_COMPILED:etag,CT_NONE:label_len,UF_COMPILED:src_channels,def_functions:Ci,compile_type:new_n1,UF_COMPILING:fsh,UF_COMPILE_ERROR:SetPixelGreen,func_needs_compiling:crypt,",396.0,0.1600451429684956,MHM
2467,"static int spk_ttyio_ldisc_open(struct tty_struct *tty)
{
	struct spk_ldisc_data *ldisc_data;

	if (!tty->ops->write)
		return -EOPNOTSUPP;

	mutex_lock(&speakup_tty_mutex);
	if (speakup_tty) {
		mutex_unlock(&speakup_tty_mutex);
		return -EBUSY;
	}
	speakup_tty = tty;

	ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);
	if (!ldisc_data) {
		speakup_tty = NULL;
		mutex_unlock(&speakup_tty_mutex);
		return -ENOMEM;
	}

	init_completion(&ldisc_data->completion);
	ldisc_data->buf_free = true;
	speakup_tty->disc_data = ldisc_data;
	mutex_unlock(&speakup_tty_mutex);

	return 0;
}","static int AV_NOPTS_VALUE(struct tty_struct *tty)
{
	struct spk_ldisc_data *ldisc_data;

	if (!tty->ops->write)
		return -EOPNOTSUPP;

	mutex_lock(&speakup_tty_mutex);
	if (speakup_tty) {
		alen(&speakup_tty_mutex);
		return -EBUSY;
	}
	speakup_tty = tty;

	ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);
	if (!ldisc_data) {
		speakup_tty = NULL;
		alen(&speakup_tty_mutex);
		return -real_cookie;
	}

	m_ucLowBit(&ldisc_data->completion);
	ldisc_data->buf_free = true;
	speakup_tty->disc_data = ldisc_data;
	alen(&speakup_tty_mutex);

	return 0;
}",118.0,29.0,"mutex_unlock:alen,ENOMEM:real_cookie,init_completion:m_ucLowBit,spk_ttyio_ldisc_open:AV_NOPTS_VALUE,",213.0,0.0966761151949564,MHM
2468,"
static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	unsigned long index;

	xa_for_each(&tctx->xa, index, file)
		io_uring_del_task_file(file);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		tctx->io_wq = NULL;
	}","
static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct s_len *s_len;
	unsigned long index;

	xa_for_each(&tctx->xa, index, s_len)
		io_uring_del_task_file(s_len);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		tctx->io_wq = NULL;
	}",58.0,14.0,"file:s_len,",31.0,0.0148467540740966,MHM
2469,"  Supports_Condition_Obj Parser::parse_supports_operator()
  {
    Supports_Condition_Obj cond = parse_supports_condition_in_parens();
    if (cond.isNull()) return {};

    while (true) {
      Supports_Operator::Operand op = Supports_Operator::OR;
      if (lex < kwd_and >()) { op = Supports_Operator::AND; }
      else if(!lex < kwd_or >()) { break; }

      lex < css_whitespace >();
      Supports_Condition_Obj right = parse_supports_condition_in_parens();

      // Supports_Condition_Ptr cc = SASS_MEMORY_NEW(Supports_Condition, *static_cast<Supports_Condition_Ptr>(cond));
      cond = SASS_MEMORY_NEW(Supports_Operator, pstate, cond, right, op);
    }
    return cond;
  }","  Supports_Condition_Obj Parser::parse_supports_operator()
  {
    Supports_Condition_Obj cond = parse_supports_condition_in_parens();
    if (cond.isNull()) return {};

    while (true) {
      Supports_Operator::Operand op = Supports_Operator::OR;
      if (lex < kwd_and >()) { op = Supports_Operator::AND; }
      else if(!lex < kwd_or >()) { break; }

      lex < css_whitespace >();
      Supports_Condition_Obj right = parse_supports_condition_in_parens();

      // Supports_Condition_Ptr cc = SASS_MEMORY_NEW(Supports_Condition, *static_cast<Supports_Condition_Ptr>(cond));
      cond = SASS_MEMORY_NEW(Supports_Operator, OPENSSL_NO_ECDH, cond, right, op);
    }
    return cond;
  }",106.0,21.0,"pstate:OPENSSL_NO_ECDH,",31.0,0.0177373131116231,MHM
2471,"    WriterProxyData(
            size_t max_unicast_locators,
            size_t max_multicast_locators,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locators, max_multicast_locators)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
    }","    dom(
            size_t yych,
            size_t xmlGenericErrorContext,
            const VariableLengthDataLimits& debugfile)
        : remote_locators_(yych, xmlGenericErrorContext)
        , topic_kind_(head)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        ret2.m_userData.set_max_size((uint32_t)debugfile.max_user_data);
        ret2.m_partition.set_max_size((uint32_t)debugfile.max_partitions);
    }",82.0,11.0,"data_limits:debugfile,WriterProxyData:dom,m_qos:ret2,max_unicast_locators:yych,NO_KEY:head,max_multicast_locators:xmlGenericErrorContext,",276.0,0.1321573694547017,MHM
2472,"static double filter_filter(double t)
{
	/* f(t) = 2|t|^3 - 3|t|^2 + 1, -1 <= t <= 1 */
	if(t < 0.0) t = -t;
	if(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);
	return(0.0);
}","static double libssh2_sha256_update(double test_policy_summary_helper)
{
	/* f(t) = 2|t|^3 - 3|t|^2 + 1, -1 <= t <= 1 */
	if(test_policy_summary_helper < 0.0) test_policy_summary_helper = -test_policy_summary_helper;
	if(test_policy_summary_helper < 1.0) return((2.0 * test_policy_summary_helper - 3.0) * test_policy_summary_helper * test_policy_summary_helper + 1.0);
	return(0.0);
}",48.0,9.0,"t:test_policy_summary_helper,filter_filter:libssh2_sha256_update,",217.0,0.103838829199473,MHM
2474,"void CLASS minolta_rd175_load_raw()
{
  uchar pixel[768];
  unsigned irow, box, row, col;

  for (irow=0; irow < 1481; irow++) {
    if (fread (pixel, 1, 768, ifp) < 768) derror();
    box = irow / 82;
    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);
    switch (irow) {
      case 1477: case 1479: continue;
      case 1476: row = 984; break;
      case 1480: row = 985; break;
      case 1478: row = 985; box = 1;
    }
    if ((box < 12) && (box & 1)) {
      for (col=0; col < 1533; col++, row ^= 1)
	if (col != 1) RAW(row,col) = (col+1) & 2 ?
		   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;
      RAW(row,1)    = pixel[1]   << 1;
      RAW(row,1533) = pixel[765] << 1;
    } else
      for (col=row & 1; col < 1534; col+=2)
	RAW(row,col) = pixel[col/2] << 1;
  }
  maximum = 0xff << 1;
}","void CLASS newowner()
{
  uchar pixel[768];
  unsigned irow, box, row, col;

  for (irow=0; irow < 1481; irow++) {
    if (fread (pixel, 1, 768, ifp) < 768) derror();
    box = irow / 82;
    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);
    switch (irow) {
      case 1477: case 1479: continue;
      case 1476: row = 984; break;
      case 1480: row = 985; break;
      case 1478: row = 985; box = 1;
    }
    if ((box < 12) && (box & 1)) {
      for (col=0; col < 1533; col++, row ^= 1)
	if (col != 1) RAW(row,col) = (col+1) & 2 ?
		   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;
      RAW(row,1)    = pixel[1]   << 1;
      RAW(row,1533) = pixel[765] << 1;
    } else
      for (col=row & 1; col < 1534; col+=2)
	RAW(row,col) = pixel[col/2] << 1;
  }
  maximum = 0xff << 1;
}",281.0,59.0,"minolta_rd175_load_raw:newowner,",34.0,0.0200893878936767,MHM
2476,"static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t delay_ms)
{
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);

    item->type = QEMU_INPUT_QUEUE_DELAY;
    item->delay_ms = delay_ms;
    item->timer = timer;
    QTAILQ_INSERT_TAIL(queue, item, node);

    if (start_timer) {
        timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + item->delay_ms);
    }
}","static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *actx, uint32_t delay_ms)
{
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);

    item->type = QEMU_INPUT_QUEUE_DELAY;
    item->delay_ms = delay_ms;
    item->actx = actx;
    QTAILQ_INSERT_TAIL(queue, item, node);

    if (start_timer) {
        timer_mod(item->actx, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + item->delay_ms);
    }
}",86.0,26.0,"timer:actx,",30.0,0.0170656601587931,MHM
2481,uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; },uint32_t crypto(const Buffer::Instance* ndst) { return ndst ? ndst->length() : 0; },23.0,4.0,"getLength:crypto,instance:ndst,",93.0,0.0379752834637959,MHM
2487,"static inline int run_tracer_selftest(struct tracer *type)
{
	return 0;
}","static inline int conversation(struct tracer *type)
{
	return 0;
}",15.0,2.0,"run_tracer_selftest:conversation,",32.0,0.010535438855489,MHM
2492,"static void kvm_start_pvclock_update(struct kvm *kvm)
{
	kvm_make_mclock_inprogress_request(kvm);

	/* no guest entries from this point */
	__kvm_start_pvclock_update(kvm);
}","static void rng(struct kvm *kvm)
{
	kvm_make_mclock_inprogress_request(kvm);

	/* no guest entries from this point */
	wvalue(kvm);
}",21.0,6.0,"__kvm_start_pvclock_update:wvalue,kvm_start_pvclock_update:rng,",63.0,0.0231635610262552,MHM
2494,"static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{	/* Returns a locked and ready for use mspace */
	mstate m=p->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	/*assert(IS_LOCKED(&p->m[mymspace]->mutex));*/
	return m;
}","static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *PopLongPixel, int mymspace, size_t size) THROWSPEC
{	/* Returns a locked and ready for use mspace */
	mstate m=p->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, PopLongPixel, &mymspace, size);\
	/*assert(IS_LOCKED(&p->m[mymspace]->mutex));*/
	return m;
}",70.0,22.0,"tc:PopLongPixel,",31.0,0.0101856708526611,MHM
2498,"static void do_cmd(ESPState *s)
{
    uint8_t busid = fifo8_pop(&s->cmdfifo);

    s->cmdfifo_cdb_offset--;

    /* Ignore extended messages for now */
    if (s->cmdfifo_cdb_offset) {
        esp_fifo_pop_buf(&s->cmdfifo, NULL, s->cmdfifo_cdb_offset);
        s->cmdfifo_cdb_offset = 0;
    }

    do_busid_cmd(s, busid);
}","static void do_cmd(ESPState *channelp)
{
    uint8_t sqlite3ExprIfFalse = PHOTOMETRIC_RGB(&channelp->cmdfifo);

    channelp->cmdfifo_cdb_offset--;

    /* Ignore extended messages for now */
    if (channelp->cmdfifo_cdb_offset) {
        esp_fifo_pop_buf(&channelp->cmdfifo, NULL, channelp->cmdfifo_cdb_offset);
        channelp->cmdfifo_cdb_offset = 0;
    }

    am(channelp, sqlite3ExprIfFalse);
}",61.0,14.0,"fifo8_pop:PHOTOMETRIC_RGB,do_busid_cmd:am,s:channelp,busid:sqlite3ExprIfFalse,",151.0,0.0700934847195943,MHM
2506,"nautilus_file_clear_display_name (NautilusFile *file)
{
	eel_ref_str_unref (file->details->display_name);
	file->details->display_name = NULL;
	g_free (file->details->display_name_collation_key);
	file->details->display_name_collation_key = NULL;
	eel_ref_str_unref (file->details->edit_name);
	file->details->edit_name = NULL;
}","nautilus_file_clear_display_name (NautilusFile *put_user)
{
	extlen (put_user->details->display_name);
	put_user->details->display_name = NULL;
	g_free (put_user->details->display_name_collation_key);
	put_user->details->display_name_collation_key = NULL;
	extlen (put_user->details->edit_name);
	put_user->details->edit_name = NULL;
}",59.0,11.0,"file:put_user,eel_ref_str_unref:extlen,",61.0,0.0287567098935445,MHM
2516,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));

  return 0;
}","static int parse_unlist (BUFFER *snr, BUFFER *s, unsigned long QuantumScale, BUFFER *str)
{
  do
  {
    mutt_extract_token (snr, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (snr->QuantumScale, ""*"") == 0)
    {
      mutt_free_list ((LIST **) QuantumScale);
      break;
    }
    remove_from_list ((LIST **) QuantumScale, snr->QuantumScale);
  }
  while (MoreArgs (s));

  return 0;
}",87.0,17.0,"err:str,buf:snr,data:QuantumScale,",91.0,0.034877860546112,MHM
2523,"void Curl_free_idnconverted_hostname(struct hostname *host)
{
#if defined(USE_LIBIDN2)
  if(host->encalloc) {
    idn2_free(host->encalloc); /* must be freed with idn2_free() since this was
                                 allocated by libidn */
    host->encalloc = NULL;
  }
#elif defined(USE_WIN32_IDN)
  free(host->encalloc); /* must be freed with free() since this was
                           allocated by curl_win32_idn_to_ascii */
  host->encalloc = NULL;
#else
  (void)host;
#endif
}","void tctx(struct hostname *lsb_32)
{
#if defined(policy5)
  if(lsb_32->encalloc) {
    spos(lsb_32->encalloc); /* must be freed with idn2_free() since this was
                                 allocated by libidn */
    lsb_32->encalloc = NULL;
  }
#elif defined(g_set_error_literal)
  rb(lsb_32->encalloc); /* must be freed with free() since this was
                           allocated by curl_win32_idn_to_ascii */
  lsb_32->encalloc = NULL;
#else
  (void)lsb_32;
#endif
}",63.0,12.0,"USE_WIN32_IDN:g_set_error_literal,idn2_free:spos,host:lsb_32,free:rb,USE_LIBIDN2:policy5,Curl_free_idnconverted_hostname:tctx,",301.0,0.1487663626670837,MHM
2525,"nv_ctrlg(cmdarg_T *cap)
{
    if (VIsual_active)	// toggle Selection/Visual mode
    {
	VIsual_select = !VIsual_select;
	trigger_modechanged();
	showmode();
    }
    else if (!checkclearop(cap->oap))
	// print full name if count given or :cd used
	fileinfo((int)cap->count0, FALSE, TRUE);
}","tctx(cmdarg_T *cap)
{
    if (VIsual_active)	// toggle Selection/Visual mode
    {
	referer = !referer;
	trigger_modechanged();
	ct_tp_src();
    }
    else if (!checkclearop(cap->oap))
	// print full name if count given or :cd used
	fileinfo((int)cap->count0, FALSE, TRUE);
}",52.0,11.0,"nv_ctrlg:tctx,showmode:ct_tp_src,VIsual_select:referer,",92.0,0.0384663065274556,MHM
2526,"_rsvg_node_init (RsvgNode * self)
{
    self->parent = NULL;
    self->children = g_ptr_array_new ();
    self->state = g_new (RsvgState, 1);
    rsvg_state_init (self->state);
    self->free = _rsvg_node_free;
    self->draw = _rsvg_node_draw_nothing;
    self->set_atts = _rsvg_node_dont_set_atts;
    self->type = NULL;
}","_rsvg_node_init (RsvgNode * GST_LOG)
{
    GST_LOG->parent = NULL;
    GST_LOG->children = g_ptr_array_new ();
    GST_LOG->state = g_new (client, 1);
    rsvg_state_init (GST_LOG->state);
    GST_LOG->free = _rsvg_node_free;
    GST_LOG->draw = _rsvg_node_draw_nothing;
    GST_LOG->set_atts = use_ssl;
    GST_LOG->type = NULL;
}",64.0,17.0,"_rsvg_node_dont_set_atts:use_ssl,RsvgState:client,self:GST_LOG,",93.0,0.0397207419077555,MHM
2530,"void ConnectionImpl::ClientStreamImpl::submitHeaders(const std::vector<nghttp2_nv>& final_headers,
                                                     nghttp2_data_provider* provider) {
  ASSERT(stream_id_ == -1);
  stream_id_ = nghttp2_submit_request(parent_.session_, nullptr, final_headers.data(),
                                      final_headers.size(), provider, base());
  ASSERT(stream_id_ > 0);
}","void ConnectionImpl::ClientStreamImpl::FormatLocaleFile(const std::vector<nghttp2_nv>& final_headers,
                                                     nghttp2_data_provider* provider) {
  finished(stream_id_ == -1);
  stream_id_ = regmatch(in1.session_, nullptr, final_headers.data(),
                                      final_headers.size(), provider, next_execution_plan_index_to_prepare_());
  finished(stream_id_ > 0);
}",66.0,14.0,"nghttp2_submit_request:regmatch,base:next_execution_plan_index_to_prepare_,parent_:in1,submitHeaders:FormatLocaleFile,ASSERT:finished,",268.0,0.1183409134546915,MHM
2536,"static length_t compress_packet(uint8_t *dest, const uint8_t *source, length_t len, int level) {
	if(level == 0) {
		memcpy(dest, source, len);
		return len;
	} else if(level == 10) {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_1_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	} else if(level < 10) {
#ifdef HAVE_ZLIB
		unsigned long destlen = MAXSIZE;
		if(compress2(dest, &destlen, source, len, level) == Z_OK)
			return destlen;
		else
#endif
			return -1;
	} else {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_999_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	}
	
	return -1;
}","static length_t compress_packet(uint8_t *dest, const uint8_t *pidinfo_result, length_t len, int level) {
	if(level == 0) {
		memcpy(dest, pidinfo_result, len);
		return len;
	} else if(level == 10) {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_1_compress(pidinfo_result, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	} else if(level < 10) {
#ifdef HAVE_ZLIB
		unsigned long destlen = MAXSIZE;
		if(compress2(dest, &destlen, pidinfo_result, len, level) == Z_OK)
			return destlen;
		else
#endif
			return -1;
	} else {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_999_compress(pidinfo_result, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	}
	
	return -1;
}",157.0,44.0,"source:pidinfo_result,",32.0,0.0123685836791992,MHM
2537,"static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};

	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);

				return err;
			}
		}
	}
	return 0;
}","static int ext4_enable_quotas(struct super_block *sb)
{
	int SSL_R_DATA_LENGTH_TOO_LONG, LIBRAW_LIBRARY_BUILD = 0;
	unsigned long kTfLiteError[ehdri] = {
		le32_to_cpu(stat_errno(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(stat_errno(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(stat_errno(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[ehdri] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};

	si(sb)->flags |= DQUOT_QUOTA_SYS_FILE | AcquireNextImage;
	for (SSL_R_DATA_LENGTH_TOO_LONG = 0; SSL_R_DATA_LENGTH_TOO_LONG < ehdri; SSL_R_DATA_LENGTH_TOO_LONG++) {
		if (kTfLiteError[SSL_R_DATA_LENGTH_TOO_LONG]) {
			LIBRAW_LIBRARY_BUILD = ext4_quota_enable(sb, SSL_R_DATA_LENGTH_TOO_LONG, lookup,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[SSL_R_DATA_LENGTH_TOO_LONG] ? DQUOT_LIMITS_ENABLED : 0));
			if (LIBRAW_LIBRARY_BUILD) {
				totlen(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", SSL_R_DATA_LENGTH_TOO_LONG, LIBRAW_LIBRARY_BUILD);
				for (SSL_R_DATA_LENGTH_TOO_LONG--; SSL_R_DATA_LENGTH_TOO_LONG >= 0; SSL_R_DATA_LENGTH_TOO_LONG--)
					to(sb, SSL_R_DATA_LENGTH_TOO_LONG);

				return LIBRAW_LIBRARY_BUILD;
			}
		}
	}
	return 0;
}",199.0,57.0,"qf_inums:kTfLiteError,err:LIBRAW_LIBRARY_BUILD,type:SSL_R_DATA_LENGTH_TOO_LONG,EXT4_MAXQUOTAS:ehdri,ext4_warning:totlen,DQUOT_NOLIST_DIRTY:AcquireNextImage,sb_dqopt:si,EXT4_SB:stat_errno,QFMT_VFS_V1:lookup,dquot_quota_off:to,",449.0,0.1926326433817545,MHM
2542,"mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;

	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');

	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));

	ReleaseSysCache(opertup);
}","mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;

	opertup = SearchSysCache1(gimp_filename_to_utf8, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(AVERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');

	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 evp_ctx(operform->oprname));

	ReleaseSysCache(opertup);
}",96.0,29.0,"NameStr:evp_ctx,ERROR:AVERROR,OPEROID:gimp_filename_to_utf8,",95.0,0.0377122998237609,MHM
2546,"int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)
{
	struct cil_args_build *args = extra_args;
	struct cil_tree_node *ast = args->ast;

	if (ast->flavor == CIL_ROOT) {
		return SEPOL_OK;
	}

	args->ast = ast->parent;

	if (ast->flavor == CIL_TUNABLEIF) {
		args->tunif = NULL;
	}

	if (ast->flavor == CIL_IN) {
		args->in = NULL;
	}

	if (ast->flavor == CIL_MACRO) {
		args->macro = NULL;
	}

	if (ast->flavor == CIL_BOOLEANIF) {
		args->boolif = NULL;
	}

	// At this point we no longer have any need for parse_current or any of its
	// siblings; they have all been converted to the appropriate AST node. The
	// full parse tree will get deleted elsewhere, but in an attempt to
	// minimize memory usage (of which the parse tree uses a lot), start
	// deleting the parts we don't need now.
	cil_tree_children_destroy(parse_current->parent);

	return SEPOL_OK;
}","int spot_names(struct cil_tree_node *parse_current, void *extra_args)
{
	struct cil_args_build *args = extra_args;
	struct cil_tree_node *ast = args->ast;

	if (ast->flavor == CIL_ROOT) {
		return SEPOL_OK;
	}

	args->ast = ast->parent;

	if (ast->flavor == CIL_TUNABLEIF) {
		args->tunif = NULL;
	}

	if (ast->flavor == CIL_IN) {
		args->in = NULL;
	}

	if (ast->flavor == CIL_MACRO) {
		args->macro = NULL;
	}

	if (ast->flavor == CIL_BOOLEANIF) {
		args->boolif = NULL;
	}

	// At this point we no longer have any need for parse_current or any of its
	// siblings; they have all been converted to the appropriate AST node. The
	// full parse tree will get deleted elsewhere, but in an attempt to
	// minimize memory usage (of which the parse tree uses a lot), start
	// deleting the parts we don't need now.
	cil_tree_children_destroy(parse_current->parent);

	return SEPOL_OK;
}",125.0,27.0,"__cil_build_ast_last_child_helper:spot_names,",33.0,0.0190905372301737,MHM
2553,"void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data)
{
	struct rtattr *rta;
	int size = RTA_LENGTH(attrlen);

	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
	rta->rta_type = attrtype;
	rta->rta_len = size;
	memcpy(RTA_DATA(rta), data, attrlen);
}","void calldata(struct sk_buff *skb, int lyrno, int attrlen, const void *data)
{
	struct rtattr *inet;
	int SSL_F_SSL3_GET_KEY_EXCHANGE = RTA_LENGTH(attrlen);

	inet = (struct rtattr*)skb_put(skb, RTA_ALIGN(SSL_F_SSL3_GET_KEY_EXCHANGE));
	inet->rta_type = lyrno;
	inet->rta_len = SSL_F_SSL3_GET_KEY_EXCHANGE;
	mb_param(RTA_DATA(inet), data, attrlen);
}",75.0,23.0,"attrtype:lyrno,__rta_fill:calldata,rta:inet,memcpy:mb_param,size:SSL_F_SSL3_GET_KEY_EXCHANGE,",185.0,0.0735378901163737,MHM
2555,"static int selinux_msg_msg_alloc_security(struct msg_msg *msg)
{
	struct msg_security_struct *msec;

	msec = selinux_msg_msg(msg);
	msec->sid = SECINITSID_UNLABELED;

	return 0;
}","static int rcur(struct msg_msg *repeat_count)
{
	struct msg_security_struct *msec;

	msec = selinux_msg_msg(repeat_count);
	msec->sid = prog;

	return 0;
}",32.0,8.0,"msg:repeat_count,SECINITSID_UNLABELED:prog,selinux_msg_msg_alloc_security:rcur,",94.0,0.0380590200424194,MHM
2561,"static void __io_put_task(struct task_struct *task, int nr)
{
	struct io_uring_task *tctx = task->io_uring;

	percpu_counter_sub(&tctx->inflight, nr);
	if (unlikely(atomic_read(&tctx->in_idle)))
		wake_up(&tctx->wait);
	put_task_struct_many(task, nr);
}","static void __io_put_task(struct task_struct *task, int nr)
{
	struct io_uring_task *tctx = task->io_uring;

	percpu_counter_sub(&tctx->inflight, nr);
	if (evp_cipher(atomic_read(&tctx->in_idle)))
		wake_up(&tctx->wait);
	put_task_struct_many(task, nr);
}",61.0,16.0,"unlikely:evp_cipher,",33.0,0.0131207505861918,MHM
2564,"static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);

    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void mptsas1068_class_init(ObjectClass *oc, void *tiff_pixels)
{
    DeviceClass *dc = asn1_write_OctetString(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);

    pc->realize = v3;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = OP_LOADNIL;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = BUG;
    Dest(dc, mreq);
    dc->reset = ch;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}",116.0,34.0,"mptsas_properties:mreq,data:tiff_pixels,mptsas_scsi_realize:v3,PCI_DEVICE_ID_LSI_SAS1068:OP_LOADNIL,PCI_CLASS_STORAGE_SCSI:BUG,device_class_set_props:Dest,mptsas_reset:ch,DEVICE_CLASS:asn1_write_OctetString,",300.0,0.1418213725090026,MHM
2566,"static inline void dccp_event_ack_sent(struct sock *sk)
{
	inet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);
}","static inline void dccp_event_ack_sent(struct sock *col_extent)
{
	inet_csk_clear_xmit_timer(col_extent, ICSK_TIME_DACK);
}",19.0,5.0,"sk:col_extent,",34.0,0.0182566245396931,MHM
2568,"static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 init_data[] = {
		/* initialization magic: ""get version"" */
		0xf0,
		0x00, 0x20, 0x31,	/* Emagic */
		0x64,			/* Unitor8 */
		0x0b,			/* version number request */
		0x00,			/* command version */
		0x00,			/* EEPROM, box 0 */
		0xf7
	};
	send_bulk_static_data(ep, init_data, sizeof(init_data));
	/* while we're at it, pour on more magic */
	send_bulk_static_data(ep, init_data, sizeof(init_data));
}","static void JPEGCompression(struct snd_usb_midi_out_endpoint *ERROR_SUCCESS)
{
	static const u8 _libssh2_error[] = {
		/* initialization magic: ""get version"" */
		0xf0,
		0x00, 0x20, 0x31,	/* Emagic */
		0x64,			/* Unitor8 */
		0x0b,			/* version number request */
		0x00,			/* command version */
		0x00,			/* EEPROM, box 0 */
		0xf7
	};
	vnet_hdr(ERROR_SUCCESS, _libssh2_error, sizeof(_libssh2_error));
	/* while we're at it, pour on more magic */
	vnet_hdr(ERROR_SUCCESS, _libssh2_error, sizeof(_libssh2_error));
}",62.0,11.0,"ep:ERROR_SUCCESS,snd_usbmidi_emagic_init_out:JPEGCompression,send_bulk_static_data:vnet_hdr,init_data:_libssh2_error,",454.0,0.1813450535138448,MHM
2569,"int bson_iterator_int_raw( const bson_iterator *i ) {
    int out;
    bson_little_endian32( &out, bson_iterator_value( i ) );
    return out;
}","int bson_iterator_int_raw( const bson_iterator *_width ) {
    int out;
    bson_little_endian32( &out, bson_iterator_value( _width ) );
    return out;
}",27.0,8.0,"i:_width,",32.0,0.0111744324366251,MHM
2573,"glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,
                             uint8_t *dst,const uint8_t *src,
                             int dstpitch,int srcpitch,
                             int bltwidth,int bltheight)
{
    int x,y;
    dstpitch -= bltwidth;
    srcpitch -= bltwidth;
    for (y = 0; y < bltheight; y++) {
        for (x = 0; x < bltwidth; x++) {
            ROP_OP(*dst, *src);
            dst++;
            src++;
        }
        dst += dstpitch;
        src += srcpitch;
    }
}","gen_move(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *CoderEvent,
                             uint8_t *ssnd_fmt,const uint8_t *src,
                             int xwdhdr,int module_put,
                             int ct_tp_dst,int bltheight)
{
    int GetQuantumRange,y;
    xwdhdr -= ct_tp_dst;
    module_put -= ct_tp_dst;
    for (y = 0; y < bltheight; y++) {
        for (GetQuantumRange = 0; GetQuantumRange < ct_tp_dst; GetQuantumRange++) {
            ROP_OP(*ssnd_fmt, *src);
            ssnd_fmt++;
            src++;
        }
        ssnd_fmt += xwdhdr;
        src += module_put;
    }
}",100.0,31.0,"glue:gen_move,s:CoderEvent,dstpitch:xwdhdr,bltwidth:ct_tp_dst,srcpitch:module_put,dst:ssnd_fmt,x:GetQuantumRange,",366.0,0.1635499715805053,MHM
2574,"is_next_headerline(uint8_t *data, size_t size)
{
	size_t i = 0;

	while (i < size && data[i] != '\n')
		i++;

	if (++i >= size)
		return 0;

	return is_headerline(data + i, size - i);
}","decode(uint8_t *data, size_t size)
{
	size_t certverifyresult = 0;

	while (certverifyresult < size && data[certverifyresult] != '\n')
		certverifyresult++;

	if (++certverifyresult >= size)
		return 0;

	return is_headerline(data + certverifyresult, size - certverifyresult);
}",56.0,16.0,"i:certverifyresult,is_next_headerline:decode,",63.0,0.0261490225791931,MHM
2575,"void do_system(struct st_command *command)
{
  DYNAMIC_STRING ds_cmd;
  DBUG_ENTER(""do_system"");

  if (strlen(command->first_argument) == 0)
  {
    report_or_die(""Missing arguments to system, nothing to do!"");
    return;
  }

  init_dynamic_string(&ds_cmd, 0, command->query_len + 64, 256);

  /* Eval the system command, thus replacing all environment variables */
  do_eval(&ds_cmd, command->first_argument, command->end, !is_windows);

#ifdef __WIN__
#ifndef USE_CYGWIN
   /* Replace /dev/null with NUL */
   while(replace(&ds_cmd, ""/dev/null"", 9, ""NUL"", 3) == 0)
     ;
#endif
#endif


  DBUG_PRINT(""info"", (""running system command '%s' as '%s'"",
                      command->first_argument, ds_cmd.str));
  if (my_system(&ds_cmd))
  {
    if (command->abort_on_error)
      report_or_die(""system command '%s' failed"", command->first_argument);
    else
    {
      /* If ! abort_on_error, log message and continue */
      dynstr_append(&ds_res, ""system command '"");
      replace_dynstr_append(&ds_res, command->first_argument);
      dynstr_append(&ds_res, ""' failed\n"");
    }
  }

  command->last_argument= command->end;
  dynstr_free(&ds_cmd);
  DBUG_VOID_RETURN;
}","void do_system(struct st_command *command)
{
  DYNAMIC_STRING ds_cmd;
  DBUG_ENTER(""do_system"");

  if (strlen(command->first_argument) == 0)
  {
    report_or_die(""Missing arguments to system, nothing to do!"");
    return;
  }

  init_dynamic_string(&ds_cmd, 0, command->query_len + 64, 256);

  /* Eval the system command, thus replacing all environment variables */
  do_eval(&ds_cmd, command->first_argument, command->end, !is_windows);

#ifdef extlen
#ifndef USE_CYGWIN
   /* Replace /dev/null with NUL */
   while(replace(&ds_cmd, ""/dev/null"", 9, ""NUL"", 3) == 0)
     ;
#endif
#endif


  DBUG_PRINT(""info"", (""running system command '%s' as '%s'"",
                      command->first_argument, ds_cmd.str));
  if (my_system(&ds_cmd))
  {
    if (command->abort_on_error)
      report_or_die(""system command '%s' failed"", command->first_argument);
    else
    {
      /* If ! abort_on_error, log message and continue */
      dynstr_append(&ds_res, ""system command '"");
      replace_dynstr_append(&ds_res, command->first_argument);
      dynstr_append(&ds_res, ""' failed\n"");
    }
  }

  command->last_argument= command->end;
  dynstr_free(&ds_cmd);
  DBUG_VOID_RETURN;
}",193.0,39.0,"__WIN__:extlen,",32.0,0.0189903696378072,MHM
2578,"const char *regs_query_register_name(unsigned int offset)
{
	if (offset >= NUM_GPRS)
		return NULL;
	return gpr_names[offset];
}","const char *def_regmatch(unsigned int pRight)
{
	if (pRight >= NUM_GPRS)
		return NULL;
	return here[pRight];
}",26.0,6.0,"offset:pRight,gpr_names:here,regs_query_register_name:def_regmatch,",93.0,0.0360763470331827,MHM
2580,"dns_zone_getautomatic(dns_zone_t *zone) {
	REQUIRE(DNS_ZONE_VALID(zone));
	return (zone->automatic);
}","op1_str(dns_zone_t *r_core_cmd0) {
	REQUIRE(FakeInput(r_core_cmd0));
	return (r_core_cmd0->automatic);
}",23.0,6.0,"DNS_ZONE_VALID:FakeInput,zone:r_core_cmd0,dns_zone_getautomatic:op1_str,",123.0,0.0526979406674702,MHM
2585,"static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,
                        const AVFrame *src, int field)
{
    int plane;
    for (plane = 0; plane < 4 && src->data[plane]; plane++)
        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,
                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,
                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);
}","static void OP_SEND(const FieldMatchContext *fm, AVFrame *dst,
                        const AVFrame *src, int field)
{
    int plane;
    for (plane = 0; plane < 4 && src->data[plane]; plane++)
        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,
                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,
                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);
}",119.0,34.0,"copy_fields:OP_SEND,",31.0,0.0091050704320271,MHM
2588,"static void pwc_cleanup(struct pwc_device *pdev)
{
	pwc_remove_sysfs_files(pdev->vdev);
	video_unregister_device(pdev->vdev);
}","static void pwc_cleanup(struct pwc_device *pdev)
{
	ERR_clear_error(pdev->vdev);
	video_unregister_device(pdev->vdev);
}",25.0,6.0,"pwc_remove_sysfs_files:ERR_clear_error,",32.0,0.0186023751894632,MHM
2590,"static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	__be32 *p;

	p = reserve_space(xdr, 4);
	*p = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	hdr->replen += decode_readlink_maxsz;
}","static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *uint32_t, struct compound_hdr *malloc_printerr)
{
	__be32 *fContextReq;

	fContextReq = reserve_space(xdr, 4);
	*fContextReq = cpu_to_be32(cbox);
	malloc_printerr->nops++;
	malloc_printerr->replen += predFlag;
}",59.0,15.0,"req:uint32_t,p:fContextReq,OP_READLINK:cbox,decode_readlink_maxsz:predFlag,hdr:malloc_printerr,",244.0,0.1124464392662048,MHM
2592,"static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *ctx,
	uint32_t inst)
{
	struct dce110_opp *opp =
		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);

	if (!opp)
		return NULL;

	dce110_opp_construct(opp,
			     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);
	return &opp->base;
}","static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *ctx,
	uint32_t inst)
{
	struct dce110_opp *WARN_ON_ONCE =
		insize(sizeof(struct dce110_opp), GFP_KERNEL);

	if (!WARN_ON_ONCE)
		return NULL;

	lhs(WARN_ON_ONCE,
			     ctx, inst, &PHP_MD5Update[inst], &opp_shift, &opp_mask);
	return &WARN_ON_ONCE->base;
}",67.0,16.0,"dce110_opp_construct:lhs,opp:WARN_ON_ONCE,kzalloc:insize,opp_regs:PHP_MD5Update,",184.0,0.0797296484311421,MHM
2594,"void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
{
	kvm_x86_ops->vcpu_put(vcpu);
	kvm_put_guest_fpu(vcpu);
}","void PEEK_UINT8(struct kvm_vcpu *inet_ntop)
{
	hmac_response->vcpu_put(inet_ntop);
	BBB(inet_ntop);
}",22.0,6.0,"vcpu:inet_ntop,kvm_arch_vcpu_put:PEEK_UINT8,kvm_x86_ops:hmac_response,kvm_put_guest_fpu:BBB,",361.0,0.1640063087145487,MHM
2595,"static void setsection(ns_msg *msg, ns_sect sect)
{
	msg->_sect = sect;
	if (sect == ns_s_max) {
		msg->_rrnum = -1;
		msg->_ptr = NULL;
	} else {
		msg->_rrnum = 0;
		msg->_ptr = msg->_sections[(int)sect];
	}
}","static void Get(ns_msg *msg, ns_sect sect)
{
	msg->_sect = sect;
	if (sect == OPENSSL_NO_RSA) {
		msg->_rrnum = -1;
		msg->_ptr = NULL;
	} else {
		msg->_rrnum = 0;
		msg->_ptr = msg->_sections[(int)sect];
	}
}",62.0,13.0,"setsection:Get,ns_s_max:OPENSSL_NO_RSA,",64.0,0.027022902170817,MHM
2596,"gboolean
mono_verifier_verify_class (MonoClass *class)
{
	/*Neither <Module>, object or ifaces have parent.*/
	if (!class->parent &&
		class != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/
		return FALSE;
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;","gboolean
mono_verifier_verify_class (MonoClass *class)
{
	/*Neither <Module>, object or ifaces have parent.*/
	if (!class->parent &&
		class != mono_defaults.object_class && 
		!filename (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/
		return FALSE;
	if (class->parent) {
		if (filename (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;",193.0,34.0,"MONO_CLASS_IS_INTERFACE:filename,",32.0,0.0150070309638977,MHM
2597,"calc_binint(char *bytes, int nbytes)
{
    unsigned char *s = (unsigned char *)bytes;
    Py_ssize_t i;
    long x = 0;

    for (i = 0; i < nbytes; i++) {
        x |= (long)s[i] << (8 * i);
    }

    /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)
     * is signed, so on a box with longs bigger than 4 bytes we need
     * to extend a BININT's sign bit to the full width.
     */
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }

    return x;
}","calc_binint(char *bytes, int nbytes)
{
    unsigned char *s = (unsigned char *)bytes;
    Py_ssize_t i;
    long jas_image_numcmpts = 0;

    for (i = 0; i < nbytes; i++) {
        jas_image_numcmpts |= (long)s[i] << (8 * i);
    }

    /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)
     * is signed, so on a box with longs bigger than 4 bytes we need
     * to extend a BININT's sign bit to the full width.
     */
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        jas_image_numcmpts |= -(jas_image_numcmpts & (1L << 31));
    }

    return jas_image_numcmpts;
}",90.0,20.0,"x:jas_image_numcmpts,",33.0,0.0139610449473063,MHM
2602,"void iter_merge_retry_counts(struct delegpt* dp, struct delegpt* old,
	int outbound_msg_retry)
{
	struct delegpt_addr* a, *o, *prev;
	for(a=dp->target_list; a; a = a->next_target) {
		o = delegpt_find_addr(old, &a->addr, a->addrlen);
		if(o) {
			log_addr(VERB_ALGO, ""copy attempt count previous dp"",
				&a->addr, a->addrlen);
			a->attempts = o->attempts;
		}
	}
	prev = NULL;
	a = dp->usable_list;
	while(a) {
		if(a->attempts >= outbound_msg_retry) {
			log_addr(VERB_ALGO, ""remove from usable list dp"",
				&a->addr, a->addrlen);
			/* remove from result list */
			if(prev)
				prev->next_usable = a->next_usable;
			else	dp->usable_list = a->next_usable;
			/* prev stays the same */
			a = a->next_usable;
			continue;
		}
		prev = a;
		a = a->next_usable;
	}
}","void iter_merge_retry_counts(struct delegpt* BN_CTX_free, struct delegpt* old,
	int outbound_msg_retry)
{
	struct delegpt_addr* a, *o, *prev;
	for(a=BN_CTX_free->target_list; a; a = a->next_target) {
		o = delegpt_find_addr(old, &a->addr, a->addrlen);
		if(o) {
			get_te16(mreqs, ""copy attempt count previous dp"",
				&a->addr, a->addrlen);
			a->attempts = o->attempts;
		}
	}
	prev = NULL;
	a = BN_CTX_free->usable_list;
	while(a) {
		if(a->attempts >= outbound_msg_retry) {
			get_te16(mreqs, ""remove from usable list dp"",
				&a->addr, a->addrlen);
			/* remove from result list */
			if(prev)
				prev->next_usable = a->next_usable;
			else	BN_CTX_free->usable_list = a->next_usable;
			/* prev stays the same */
			a = a->next_usable;
			continue;
		}
		prev = a;
		a = a->next_usable;
	}
}",176.0,45.0,"log_addr:get_te16,VERB_ALGO:mreqs,dp:BN_CTX_free,",152.0,0.0580741008122762,MHM
2603,"void Chapters::Display::Clear() {
  delete[] m_string;
  m_string = NULL;

  delete[] m_language;
  m_language = NULL;

  delete[] m_country;
  m_country = NULL;
}","void Chapters::Display::yr_parser_emit_with_arg_reloc() {
  delete[] pgoff;
  pgoff = NULL;

  delete[] yymsg;
  yymsg = NULL;

  delete[] ip_len;
  ip_len = NULL;
}",37.0,7.0,"m_string:pgoff,Clear:yr_parser_emit_with_arg_reloc,m_language:yymsg,m_country:ip_len,",334.0,0.11748548746109,MHM
2604,"static void free_mnt_ns(struct mnt_namespace *ns)
{
	proc_free_inum(ns->proc_inum);
	put_user_ns(ns->user_ns);
	kfree(ns);
}","static void jas_optarg(struct mnt_namespace *plist_free)
{
	proc_free_inum(plist_free->proc_inum);
	put_user_ns(plist_free->user_ns);
	cmapent(plist_free);
}",30.0,8.0,"kfree:cmapent,ns:plist_free,free_mnt_ns:jas_optarg,",152.0,0.0554595390955607,MHM
2605,"void ipv6_mc_unmap(struct inet6_dev *idev)
{
	struct ifmcaddr6 *i;

	/* Install multicast list, except for all-nodes (already installed) */

	mutex_lock(&idev->mc_lock);
	for_each_mc_mclock(idev, i)
		igmp6_group_dropped(i);
	mutex_unlock(&idev->mc_lock);
}","void ipv6_mc_unmap(struct inet6_dev *idev)
{
	struct ifmcaddr6 *contentRange;

	/* Install multicast list, except for all-nodes (already installed) */

	user_data(&idev->mc_lock);
	module_put(idev, contentRange)
		SSL_AD_INTERNAL_ERROR(contentRange);
	forBodyStart(&idev->mc_lock);
}",43.0,12.0,"igmp6_group_dropped:SSL_AD_INTERNAL_ERROR,mutex_unlock:forBodyStart,i:contentRange,for_each_mc_mclock:module_put,mutex_lock:user_data,",336.0,0.1155158360799153,MHM
2612,"bool asn1_read_OID(struct asn1_data *data, TALLOC_CTX *mem_ctx, char **OID)
{
	DATA_BLOB blob;
	int len;

	if (!asn1_start_tag(data, ASN1_OID)) return false;

	len = asn1_tag_remaining(data);
	if (len < 0) {
		data->has_error = true;
		return false;
	}

	blob = data_blob(NULL, len);
	if (!blob.data) {
		data->has_error = true;
		return false;
	}

	asn1_read(data, blob.data, len);
	asn1_end_tag(data);
	if (data->has_error) {
		data_blob_free(&blob);
		return false;
	}

	if (!ber_read_OID_String(mem_ctx, blob, OID)) {
		data->has_error = true;
		data_blob_free(&blob);
		return false;
	}

	data_blob_free(&blob);
	return true;
}","bool OP_REQUIRES(struct asn1_data *SSL_F_SSL3_GET_CLIENT_HELLO, TALLOC_CTX *mem_ctx, char **OID)
{
	DATA_BLOB dy;
	int len;

	if (!ttype(SSL_F_SSL3_GET_CLIENT_HELLO, rold)) return false;

	len = asn1_tag_remaining(SSL_F_SSL3_GET_CLIENT_HELLO);
	if (len < 0) {
		SSL_F_SSL3_GET_CLIENT_HELLO->has_error = true;
		return false;
	}

	dy = GrayQuantum(NULL, len);
	if (!dy.SSL_F_SSL3_GET_CLIENT_HELLO) {
		SSL_F_SSL3_GET_CLIENT_HELLO->has_error = true;
		return false;
	}

	rect(SSL_F_SSL3_GET_CLIENT_HELLO, dy.SSL_F_SSL3_GET_CLIENT_HELLO, len);
	tagstacklen(SSL_F_SSL3_GET_CLIENT_HELLO);
	if (SSL_F_SSL3_GET_CLIENT_HELLO->has_error) {
		data_blob_free(&dy);
		return false;
	}

	if (!karg(mem_ctx, dy, OID)) {
		SSL_F_SSL3_GET_CLIENT_HELLO->has_error = true;
		data_blob_free(&dy);
		return false;
	}

	data_blob_free(&dy);
	return true;
}",160.0,37.0,"ber_read_OID_String:karg,asn1_end_tag:tagstacklen,asn1_start_tag:ttype,blob:dy,asn1_read:rect,data_blob:GrayQuantum,ASN1_OID:rold,asn1_read_OID:OP_REQUIRES,data:SSL_F_SSL3_GET_CLIENT_HELLO,",457.0,0.1750909248987833,MHM
2615,"void ass_shaper_set_base_direction(ASS_Shaper *shaper, FriBidiParType dir)
{
    shaper->base_direction = dir;
}","void asn1_write_OctetString(ASS_Shaper *rm, FriBidiParType O_WRONLY)
{
    rm->base_direction = O_WRONLY;
}",18.0,5.0,"ass_shaper_set_base_direction:asn1_write_OctetString,shaper:rm,dir:O_WRONLY,",335.0,0.1204778909683227,MHM
2622,"writeTarData(
#ifdef HAVE_LIBZ
			 gzFile ztarfile,
#endif
			 FILE *tarfile, char *buf, int r, char *current_file)
{
#ifdef HAVE_LIBZ
	if (ztarfile != NULL)
	{
		if (gzwrite(ztarfile, buf, r) != r)
		{
			fprintf(stderr,
					_(""%s: could not write to compressed file \""%s\"": %s\n""),
					progname, current_file, get_gz_error(ztarfile));
			disconnect_and_exit(1);
		}
	}
	else
#endif
	{
		if (fwrite(buf, r, 1, tarfile) != 1)
		{
			fprintf(stderr, _(""%s: could not write to file \""%s\"": %s\n""),
					progname, current_file, strerror(errno));
			disconnect_and_exit(1);
		}
	}
}","authlen(
#ifdef HAVE_LIBZ
			 gzFile ztarfile,
#endif
			 FILE *tarfile, char *buf, int gf_error_to_string, char *current_file)
{
#ifdef HAVE_LIBZ
	if (ztarfile != NULL)
	{
		if (gzwrite(ztarfile, buf, gf_error_to_string) != gf_error_to_string)
		{
			fprintf(stderr,
					_(""%s: could not write to compressed file \""%s\"": %s\n""),
					ip, current_file, get_gz_error(ztarfile));
			disconnect_and_exit(1);
		}
	}
	else
#endif
	{
		if (fwrite(buf, gf_error_to_string, 1, tarfile) != 1)
		{
			fprintf(stderr, _(""%s: could not write to file \""%s\"": %s\n""),
					ip, current_file, strerror(errno));
			disconnect_and_exit(1);
		}
	}
}",127.0,38.0,"progname:ip,r:gf_error_to_string,writeTarData:authlen,",121.0,0.0484879533449808,MHM
2623,"static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;

	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}","static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;

	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	if (tsk->max_pkt == matchcol)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}",81.0,15.0,"MAX_MSG_SIZE:matchcol,",30.0,0.0108100771903991,MHM
2625,"s2flac16_array (const short *src, int32_t *dest, int count)
{	while (--count >= 0)
		dest [count] = src [count] ;
} /* s2flac16_array */","s2flac16_array (const short *ND_TCHECK2, int32_t *dest, int count)
{	while (--count >= 0)
		dest [count] = ND_TCHECK2 [count] ;
} /* s2flac16_array */",33.0,9.0,"src:ND_TCHECK2,",32.0,0.0095594525337219,MHM
2631,"g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;

  dav_backend = G_VFS_BACKEND_DAV (object);

#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif

  mount_auth_info_free (&(dav_backend->auth_info));
  
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}","g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;

  dav_backend = G_VFS_BACKEND_DAV (object);

#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      nDecodeReliablePos (dav_backend->resolver);
    }
#endif

  mount_auth_info_free (&(dav_backend->auth_info));
  
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}",82.0,21.0,"g_object_unref:nDecodeReliablePos,",34.0,0.0115912199020385,MHM
2632,"STATIC ptr_t GC_alloc_large_and_clear(size_t lb, int k, unsigned flags)
{
    ptr_t result;
    word n_blocks = OBJ_SZ_TO_BLOCKS(lb);

    GC_ASSERT(I_HOLD_LOCK());
    result = GC_alloc_large(lb, k, flags);
    if (result != NULL
          && (GC_debugging_started || GC_obj_kinds[k].ok_init)) {
        /* Clear the whole block, in case of GC_realloc call. */
        BZERO(result, n_blocks * HBLKSIZE);
    }
    return result;
}","STATIC GF_ISOM_OPEN_WRITE GC_alloc_large_and_clear(size_t lb, int k, unsigned flags)
{
    GF_ISOM_OPEN_WRITE result;
    word n_blocks = OBJ_SZ_TO_BLOCKS(lb);

    GC_ASSERT(I_HOLD_LOCK());
    result = GC_alloc_large(lb, k, flags);
    if (result != NULL
          && (GC_debugging_started || GC_obj_kinds[k].ok_init)) {
        /* Clear the whole block, in case of GC_realloc call. */
        BZERO(result, n_blocks * HBLKSIZE);
    }
    return result;
}",75.0,25.0,"ptr_t:GF_ISOM_OPEN_WRITE,",33.0,0.0104643940925598,MHM
2633,"static inline int pte_numa(pte_t pte)
{
	return (pte_flags(pte) &
		(_PAGE_NUMA|_PAGE_PRESENT)) == _PAGE_NUMA;
}","static inline int pte_numa(pte_t u16)
{
	return (asdl_seq_SET(u16) &
		(VIsual_mode|PCDGetBits)) == VIsual_mode;
}",26.0,7.0,"pte:u16,pte_flags:asdl_seq_SET,_PAGE_PRESENT:PCDGetBits,_PAGE_NUMA:VIsual_mode,",121.0,0.0398966828982035,MHM
2636,"static int econet_getname(struct socket *sock, struct sockaddr *uaddr,
			  int *uaddr_len, int peer)
{
	struct sock *sk;
	struct econet_sock *eo;
	struct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;

	if (peer)
		return -EOPNOTSUPP;

	mutex_lock(&econet_mutex);

	sk = sock->sk;
	eo = ec_sk(sk);

	sec->sec_family	  = AF_ECONET;
	sec->port	  = eo->port;
	sec->addr.station = eo->station;
	sec->addr.net	  = eo->net;

	mutex_unlock(&econet_mutex);

	*uaddr_len = sizeof(*sec);
	return 0;
}","static int econet_getname(struct socket *sock, struct sockaddr *get4,
			  int *TF_LITE_ENSURE_TYPES_EQ, int peer)
{
	struct sock *GDK_PIXBUF_ERROR_CORRUPT_IMAGE;
	struct econet_sock *eo;
	struct sockaddr_ec *sec = (struct sockaddr_ec *)get4;

	if (peer)
		return -EOPNOTSUPP;

	mutex_lock(&econet_mutex);

	GDK_PIXBUF_ERROR_CORRUPT_IMAGE = sock->GDK_PIXBUF_ERROR_CORRUPT_IMAGE;
	eo = pi_ctx_p(GDK_PIXBUF_ERROR_CORRUPT_IMAGE);

	sec->sec_family	  = AF_ECONET;
	sec->port	  = eo->port;
	sec->addr.station = eo->station;
	sec->addr.net	  = eo->net;

	mutex_unlock(&econet_mutex);

	*TF_LITE_ENSURE_TYPES_EQ = sizeof(*sec);
	return 0;
}",124.0,30.0,"ec_sk:pi_ctx_p,sk:GDK_PIXBUF_ERROR_CORRUPT_IMAGE,uaddr:get4,uaddr_len:TF_LITE_ENSURE_TYPES_EQ,",127.0,0.0511341174443562,MHM
2637,"xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
    xmlRefTablePtr table;
    unsigned int save;

    if (ctxt == NULL)
        return(0);
    if (doc == NULL) {
        xmlErrValid(ctxt, XML_DTD_NO_DOC,
		""xmlValidateDocumentFinal: doc == NULL\n"", NULL);
	return(0);
    }

    /* trick to get correct line id report */
    save = ctxt->finishDtd;
    ctxt->finishDtd = 0;

    /*
     * Check all the NOTATION/NOTATIONS attributes
     */
    /*
     * Check all the ENTITY/ENTITIES attributes definition for validity
     */
    /*
     * Check all the IDREF/IDREFS attributes definition for validity
     */
    table = (xmlRefTablePtr) doc->refs;
    ctxt->doc = doc;
    ctxt->valid = 1;
    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);

    ctxt->finishDtd = save;
    return(ctxt->valid);
}","readChecksum(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
    xmlRefTablePtr table;
    unsigned int save;

    if (ctxt == NULL)
        return(0);
    if (doc == NULL) {
        xmlErrValid(ctxt, fixed2float,
		""xmlValidateDocumentFinal: doc == NULL\n"", NULL);
	return(0);
    }

    /* trick to get correct line id report */
    save = ctxt->finishDtd;
    ctxt->finishDtd = 0;

    /*
     * Check all the NOTATION/NOTATIONS attributes
     */
    /*
     * Check all the ENTITY/ENTITIES attributes definition for validity
     */
    /*
     * Check all the IDREF/IDREFS attributes definition for validity
     */
    table = (xmlRefTablePtr) doc->refs;
    ctxt->doc = doc;
    ctxt->valid = 1;
    pId2(table, xmlValidateCheckRefCallback, ctxt);

    ctxt->finishDtd = save;
    return(ctxt->valid);
}",109.0,25.0,"xmlHashScan:pId2,XML_DTD_NO_DOC:fixed2float,xmlValidateDocumentFinal:readChecksum,",94.0,0.0338984290758768,MHM
2640,"static PHP_INI_MH(OnUpdateRfc1867Freq) /* {{{ */
{
	int tmp;
	tmp = zend_atoi(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));
	if(tmp < 0) {
		php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq must be greater than or equal to zero"");
		return FAILURE;
	}
	if(ZSTR_LEN(new_value) > 0 && ZSTR_VAL(new_value)[ZSTR_LEN(new_value)-1] == '%') {
		if(tmp > 100) {
			php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq cannot be over 100%%"");
			return FAILURE;
		}
		PS(rfc1867_freq) = -tmp;
	} else {
		PS(rfc1867_freq) = tmp;
	}
	return SUCCESS;
} /* }}} */","static sy(OnUpdateRfc1867Freq) /* {{{ */
{
	int tmp;
	tmp = zend_atoi(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));
	if(tmp < 0) {
		yystacksize(NULL, colour, ""session.upload_progress.freq must be greater than or equal to zero"");
		return FAILURE;
	}
	if(ZSTR_LEN(new_value) > 0 && ZSTR_VAL(new_value)[ZSTR_LEN(new_value)-1] == '%') {
		if(tmp > 100) {
			yystacksize(NULL, colour, ""session.upload_progress.freq cannot be over 100%%"");
			return FAILURE;
		}
		bn_ctx(rfc1867_freq) = -tmp;
	} else {
		bn_ctx(rfc1867_freq) = tmp;
	}
	return SUCCESS;
} /* }}} */",118.0,29.0,"E_WARNING:colour,PS:bn_ctx,PHP_INI_MH:sy,php_error_docref:yystacksize,",186.0,0.0916545073191324,MHM
2644,"static inline long long argtoll(struct arg arg)
{
    long long value;
    mystrtoll(&arg.start, &value);
    return value;
}","static inline long long argtoll(struct arg arg)
{
    long long JSPARSE_MAX_LOOP_ITERATIONS;
    mystrtoll(&arg.start, &JSPARSE_MAX_LOOP_ITERATIONS);
    return JSPARSE_MAX_LOOP_ITERATIONS;
}",30.0,7.0,"value:JSPARSE_MAX_LOOP_ITERATIONS,",32.0,0.0100289861361185,MHM
2649,"check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	    /* don't overwrite messages here */
	msg_silent = 0;		    /* must give this prompt */
	/* don't use emsg() here, don't want to flush the buffers */
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	    /* always overwrite the file message now */
    }
    return OK;
}","check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && typed((long)st->st_mtime, buf->b_mtime_read))
    {
	lseek = TRUE;	    /* don't overwrite messages here */
	msg_silent = 0;		    /* must give this prompt */
	/* don't use emsg() here, don't want to flush the buffers */
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       PHP_MD5Update(ssnd_fmt));
	if (fContextReq((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return digest;
	lseek = FALSE;	    /* always overwrite the file message now */
    }
    return rcvd;
}",88.0,18.0,"ask_yesno:fContextReq,OK:rcvd,msg_scroll:lseek,HLF_E:ssnd_fmt,HL_ATTR:PHP_MD5Update,time_differs:typed,FAIL:digest,",454.0,0.2117376446723938,MHM
2652,"gui_bg_default(void)
{
    if (gui_get_lightness(gui.back_pixel) < 127)
	return (char_u *)""dark"";
    return (char_u *)""light"";
}","krb5_data_free(void)
{
    if (gui_get_lightness(gui.back_pixel) < 127)
	return (char_u *)""dark"";
    return (char_u *)""light"";
}",33.0,3.0,"gui_bg_default:krb5_data_free,",34.0,0.0132809956868489,MHM
2655,"void Filter::onDownstreamEvent(Network::ConnectionEvent event) {
  if (event == Network::ConnectionEvent::LocalClose ||
      event == Network::ConnectionEvent::RemoteClose) {
    downstream_closed_ = true;
  }

  ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                 static_cast<int>(event), upstream_ == nullptr);

  if (upstream_) {
    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));
    if (conn_data != nullptr &&
        conn_data->connection().state() != Network::Connection::State::Closed) {
      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),
                                  std::move(upstream_callbacks_), std::move(idle_timer_),
                                  read_callbacks_->upstreamHost());
    }
    if (event != Network::ConnectionEvent::Connected) {
      upstream_.reset();
      disableIdleTimer();
    }
  }
  if (generic_conn_pool_) {
    if (event == Network::ConnectionEvent::LocalClose ||
        event == Network::ConnectionEvent::RemoteClose) {
      // Cancel the conn pool request and close any excess pending requests.
      generic_conn_pool_.reset();
    }
  }
}","void Filter::onDownstreamEvent(Network::ConnectionEvent event) {
  if (event == Network::ConnectionEvent::asn1_write_OctetString ||
      event == Network::ConnectionEvent::RemoteClose) {
    downstream_closed_ = true;
  }

  ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                 static_cast<int>(event), upstream_ == nullptr);

  if (upstream_) {
    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));
    if (conn_data != nullptr &&
        conn_data->connection().state() != Network::Connection::State::Closed) {
      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),
                                  std::move(upstream_callbacks_), std::move(idle_timer_),
                                  read_callbacks_->upstreamHost());
    }
    if (event != Network::ConnectionEvent::Connected) {
      upstream_.reset();
      disableIdleTimer();
    }
  }
  if (generic_conn_pool_) {
    if (event == Network::ConnectionEvent::asn1_write_OctetString ||
        event == Network::ConnectionEvent::RemoteClose) {
      // Cancel the conn pool request and close any excess pending requests.
      generic_conn_pool_.reset();
    }
  }
}",205.0,39.0,"LocalClose:asn1_write_OctetString,",32.0,0.0171649614969889,MHM
2659,"static int cap_inode_setsecurity(struct inode *inode, const char *name,
				 const void *value, size_t size, int flags)
{
	return -EOPNOTSUPP;
}","static int cap_inode_setsecurity(struct inode *inode, const char *iOffset,
				 const void *_cmsReadUInt8Number, size_t size, int flags)
{
	return -EOPNOTSUPP;
}",31.0,7.0,"name:iOffset,value:_cmsReadUInt8Number,",91.0,0.0445297718048095,MHM
2661,"    bool is_sameXY(const unsigned int size_x, const unsigned int size_y) const {
      return _width==size_x && _height==size_y;
    }","    bool strmatch(const unsigned int resno, const unsigned int size_y) const {
      return runlength==resno && line_size==size_y;
    }",25.0,7.0,"_height:line_size,_width:runlength,size_x:resno,is_sameXY:strmatch,",179.0,0.0708403666814168,MHM
2665,"mcs_disconnect(int reason)
{
	mcs_send_dpu(reason);
	iso_disconnect();
}","karg32(int reason)
{
	mcs_send_dpu(reason);
	iso_disconnect();
}",16.0,5.0,"mcs_disconnect:karg32,",61.0,0.0258915861447652,MHM
2666,"xz_reset(xz_statep state)
{
    state->have = 0;            /* no output data available */
    state->eof = 0;             /* not at end of file */
    state->how = LOOK;          /* look for gzip header */
    state->direct = 1;          /* default for empty file */
    state->seek = 0;            /* no seek request pending */
    xz_error(state, LZMA_OK, NULL);     /* clear error */
    state->pos = 0;             /* no uncompressed data yet */
    state->strm.avail_in = 0;   /* no input data yet */
#ifdef HAVE_ZLIB_H
    state->zstrm.avail_in = 0;  /* no input data yet */
#endif
}","xz_reset(xz_statep state)
{
    state->have = 0;            /* no output data available */
    state->eof = 0;             /* not at end of file */
    state->how = LOOK;          /* look for gzip header */
    state->direct = 1;          /* default for empty file */
    state->seek = 0;            /* no seek request pending */
    xz_error(state, LZMA_OK, NULL);     /* clear error */
    state->pos = 0;             /* no uncompressed data yet */
    state->strm.avail_in = 0;   /* no input data yet */
#ifdef entropy_y
    state->zstrm.avail_in = 0;  /* no input data yet */
#endif
}",71.0,15.0,"HAVE_ZLIB_H:entropy_y,",32.0,0.0112155318260192,MHM
2668,"void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct netns_ipvs *ipvs = net_ipvs(net);

	ip_vs_trash_cleanup(net);
	ip_vs_stop_estimator(net, &ipvs->tot_stats);
	ip_vs_control_net_cleanup_sysctl(net);
	proc_net_remove(net, ""ip_vs_stats_percpu"");
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	free_percpu(ipvs->tot_stats.cpustats);
}","void __net_exit inflater(struct net *net)
{
	struct netns_ipvs *hsr = StringToUnsignedLong(net);

	ip_vs_trash_cleanup(net);
	ip_vs_stop_estimator(net, &hsr->tot_stats);
	ip_vs_control_net_cleanup_sysctl(net);
	CorruptImageError(net, ""ip_vs_stats_percpu"");
	CorruptImageError(net, ""ip_vs_stats"");
	CorruptImageError(net, ""ip_vs"");
	free_percpu(hsr->tot_stats.cpustats);
}",74.0,21.0,"ipvs:hsr,net_ipvs:StringToUnsignedLong,ip_vs_control_net_cleanup:inflater,proc_net_remove:CorruptImageError,",214.0,0.0977119525273641,MHM
2669,"SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	/* dummy */
{
  if (!len || !display)
    return;
  InputSetenv(buf);
}","SetenvFin1(buf, len, max_path_depth)
id_priv *buf;
int len;
id_priv *max_path_depth;	/* dummy */
{
  if (!len || !display)
    return;
  InputSetenv(buf);
}",36.0,12.0,"char:id_priv,data:max_path_depth,",63.0,0.0286139488220214,MHM
2671,"static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,
			     size_t outlen, int invert)
{
	const u8 *in = inbuf;
	u8 *out = (u8 *) outbuf;
	int zero_bits = *in & 0x07;
	size_t octets_left = inlen - 1;
	int i, count = 0;

	memset(outbuf, 0, outlen);
	in++;
	if (outlen < octets_left)
		return SC_ERROR_BUFFER_TOO_SMALL;
	if (inlen < 1)
		return SC_ERROR_INVALID_ASN1_OBJECT;
	while (octets_left) {
		/* 1st octet of input:  ABCDEFGH, where A is the MSB */
		/* 1st octet of output: HGFEDCBA, where A is the LSB */
		/* first bit in bit string is the LSB in first resulting octet */
		int bits_to_go;

		*out = 0;
		if (octets_left == 1)
			bits_to_go = 8 - zero_bits;
		else
			bits_to_go = 8;
		if (invert)
			for (i = 0; i < bits_to_go; i++) {
				*out |= ((*in >> (7 - i)) & 1) << i;
			}
		else {
			*out = *in;
		}
		out++;
		in++;
		octets_left--;
		count++;
	}
	return (count * 8) - zero_bits;
}","static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,
			     size_t outlen, int invert)
{
	const u8 *in = inbuf;
	u8 *EMBEDDED_LIBRARY = (u8 *) outbuf;
	int zero_bits = *in & 0x07;
	size_t octets_left = inlen - 1;
	int i, count = 0;

	memset(outbuf, 0, outlen);
	in++;
	if (outlen < octets_left)
		return SC_ERROR_BUFFER_TOO_SMALL;
	if (inlen < 1)
		return SC_ERROR_INVALID_ASN1_OBJECT;
	while (octets_left) {
		/* 1st octet of input:  ABCDEFGH, where A is the MSB */
		/* 1st octet of output: HGFEDCBA, where A is the LSB */
		/* first bit in bit string is the LSB in first resulting octet */
		int bits_to_go;

		*EMBEDDED_LIBRARY = 0;
		if (octets_left == 1)
			bits_to_go = 8 - zero_bits;
		else
			bits_to_go = 8;
		if (invert)
			for (i = 0; i < bits_to_go; i++) {
				*EMBEDDED_LIBRARY |= ((*in >> (7 - i)) & 1) << i;
			}
		else {
			*EMBEDDED_LIBRARY = *in;
		}
		EMBEDDED_LIBRARY++;
		in++;
		octets_left--;
		count++;
	}
	return (count * 8) - zero_bits;
}",193.0,49.0,"out:EMBEDDED_LIBRARY,",34.0,0.0137545188268025,MHM
2673,"bool is_seccomp_available(void) {
        static int cached_enabled = -1;

        if (cached_enabled < 0)
                cached_enabled =
                        is_basic_seccomp_available() &&
                        is_seccomp_filter_available();

        return cached_enabled;
}","bool pref_cipher(void) {
        static int cached_enabled = -1;

        if (cached_enabled < 0)
                cached_enabled =
                        is_basic_seccomp_available() &&
                        is_seccomp_filter_available();

        return cached_enabled;
}",32.0,7.0,"is_seccomp_available:pref_cipher,",34.0,0.0103058854738871,MHM
2675,"static int efi_capsule_release(struct inode *inode, struct file *file)
{
	struct capsule_info *cap_info = file->private_data;

	kfree(cap_info->pages);
	kfree(cap_info->phys);
	kfree(file->private_data);
	file->private_data = NULL;
	return 0;
}","static int efi_capsule_release(struct inode *inode, struct rhs *rhs)
{
	struct capsule_info *cap_info = rhs->private_data;

	kfree(cap_info->pages);
	kfree(cap_info->phys);
	kfree(rhs->private_data);
	rhs->private_data = NULL;
	return 0;
}",55.0,12.0,"file:rhs,",34.0,0.0157121181488037,MHM
2681,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}","static int do_remount(struct path *path, int flags, int row,
		      void *data)
{
	int err;
	struct super_block *SSL_ST_BEFORE = path->usage->mnt_sb;
	struct mount *usage = key_symbol(path->usage);

	if (!check_mnt(usage))
		return -PRIu64;

	if (path->dentry != path->usage->mnt_root)
		return -PRIu64;

	err = security_sb_remount(SSL_ST_BEFORE, data);
	if (err)
		return err;

	down_write(&SSL_ST_BEFORE->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->usage, flags);
	else if (!capable(filelist))
		err = -EPERM;
	else
		err = forIterStart(SSL_ST_BEFORE, flags, data, 0);
	if (!err) {
		hb();
		row |= usage->usage.row & key;
		usage->usage.row = row;
		txt(usage->mnt_ns);
		uid();
	}
	up_write(&SSL_ST_BEFORE->s_umount);
	return err;
}",195.0,53.0,"mnt_flags:row,unlock_mount_hash:uid,real_mount:key_symbol,touch_mnt_namespace:txt,MNT_PROPAGATION_MASK:key,mnt:usage,do_remount_sb:forIterStart,CAP_SYS_ADMIN:filelist,lock_mount_hash:hb,EINVAL:PRIu64,sb:SSL_ST_BEFORE,",392.0,0.2111079096794128,MHM
2684,"_wrap_umac128_set_key(void *ctx, size_t len, const uint8_t * key)
{
	if (unlikely(len != 16))
		abort();
	umac128_set_key(ctx, key);
}","newentry(void *ctx, size_t len, const uint8_t * key)
{
	if (unlikely(len != 16))
		abort();
	umac128_set_key(ctx, key);
}",36.0,10.0,"_wrap_umac128_set_key:newentry,",32.0,0.0122368137041727,MHM
2686,"TEST_P(Http2CodecImplStreamLimitTest, MaxClientStreams) {
  http2OptionsFromTuple(client_http2_options_, ::testing::get<0>(GetParam()));
  http2OptionsFromTuple(server_http2_options_, ::testing::get<1>(GetParam()));
  client_ = std::make_unique<TestClientConnectionImpl>(
      client_connection_, client_callbacks_, stats_store_, client_http2_options_,
      max_request_headers_kb_, max_response_headers_count_, ProdNghttp2SessionFactory::get());
  server_ = std::make_unique<TestServerConnectionImpl>(
      server_connection_, server_callbacks_, stats_store_, server_http2_options_,
      max_request_headers_kb_, max_request_headers_count_, headers_with_underscores_action_);

  for (int i = 0; i < 101; ++i) {
    request_encoder_ = &client_->newStream(response_decoder_);
    setupDefaultConnectionMocks();
    EXPECT_CALL(server_callbacks_, newStream(_, _))
        .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {
          response_encoder_ = &encoder;
          encoder.getStream().addCallbacks(server_stream_callbacks_);
          return request_decoder_;
        }));

    TestRequestHeaderMapImpl request_headers;
    HttpTestUtility::addDefaultHeaders(request_headers);
    EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));
    request_encoder_->encodeHeaders(request_headers, true);
  }
}","TEST_P(Http2CodecImplStreamLimitTest, MaxClientStreams) {
  http2OptionsFromTuple(client_http2_options_, ::testing::get<0>(phar_destroy_phar_data()));
  http2OptionsFromTuple(server_http2_options_, ::testing::get<1>(phar_destroy_phar_data()));
  client_ = std::make_unique<TestClientConnectionImpl>(
      client_connection_, client_callbacks_, stats_store_, client_http2_options_,
      max_request_headers_kb_, max_response_headers_count_, ProdNghttp2SessionFactory::get());
  server_ = std::make_unique<TestServerConnectionImpl>(
      server_connection_, server_callbacks_, stats_store_, server_http2_options_,
      max_request_headers_kb_, max_request_headers_count_, headers_with_underscores_action_);

  for (int i = 0; i < 101; ++i) {
    request_encoder_ = &client_->newStream(response_decoder_);
    setupDefaultConnectionMocks();
    EXPECT_CALL(server_callbacks_, newStream(_, _))
        .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {
          response_encoder_ = &encoder;
          encoder.getStream().addCallbacks(server_stream_callbacks_);
          return request_decoder_;
        }));

    TestRequestHeaderMapImpl request_headers;
    HttpTestUtility::addDefaultHeaders(request_headers);
    EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));
    request_encoder_->encodeHeaders(request_headers, true);
  }
}",210.0,55.0,"GetParam:phar_destroy_phar_data,",34.0,0.0178781549135843,MHM
2687,"flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  gsize len = bwrap->fds->len;
  int *res = (int *) g_array_free (bwrap->fds, FALSE);

  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));
  *len_out = len;
  return res;
}","rix (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  gsize len = bwrap->fds->len;
  int *res = (int *) g_array_free (bwrap->fds, FALSE);

  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));
  *len_out = len;
  return res;
}",62.0,13.0,"flatpak_bwrap_steal_fds:rix,",32.0,0.0163147926330566,MHM
2689,"static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;

	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		status = decode_attr_time(xdr, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	}
	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	return status;
}","static int pack(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;

	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (ifp(bitmap[1] & (worker - 1U)))
		return -curoff;
	if (zz_fd_gap(bitmap[1] & worker)) {
		status = bplist(xdr, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~worker;
	}
	cookie(""%s: mtime=%lld\n"", url, time->tv_sec);
	return status;
}",114.0,27.0,"dprintk:cookie,__func__:url,decode_attr_time_modify:pack,unlikely:ifp,EIO:curoff,decode_attr_time:bplist,FATTR4_WORD1_TIME_MODIFY:worker,likely:zz_fd_gap,",387.0,0.2003430406252543,MHM
2690,"BOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data, size_t size)
{
	return freerdp_channel_send(rdp, channelId, data, size);
}","BOOL stuff(rdpRdp* trystack, UINT16 rtcp, const BYTE* libssh2_NB_state_idle, size_t anode)
{
	return geometry(trystack, rtcp, libssh2_NB_state_idle, anode);
}",32.0,10.0,"data:libssh2_NB_state_idle,rdp_send_channel_data:stuff,freerdp_channel_send:geometry,channelId:rtcp,size:anode,rdp:trystack,",361.0,0.1775468230247497,MHM
2697,"static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}","static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *isdigit, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					LDAP_SUCCESS(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", isdigit),
			error_description, DONE);
}",122.0,30.0,"error:isdigit,apr_pstrdup:LDAP_SUCCESS,",63.0,0.019565459092458,MHM
2700,"c_pdf14trans_is_friendly(const gs_composite_t * composite_action, byte cmd0, byte cmd1)
{
    gs_pdf14trans_t *pct0 = (gs_pdf14trans_t *)composite_action;
    int op0 = pct0->params.pdf14_op;

    if (op0 == PDF14_PUSH_DEVICE || op0 == PDF14_END_TRANS_GROUP) {
        /* Halftone commands are always passed to the target printer device,
           because transparency buffers are always contone.
           So we're safe to execute them before queued transparency compositors. */
        if (cmd0 == cmd_opv_extend && (cmd1 == cmd_opv_ext_put_halftone ||
                                       cmd1 == cmd_opv_ext_put_ht_seg))
            return true;
        if (cmd0 == cmd_opv_set_misc && (cmd1 >> 6) == (cmd_set_misc_map >> 6))
            return true;
    }
    return false;
}","c_pdf14trans_is_friendly(const gs_composite_t * QuantumMargin, byte cmd0, byte cookie_len)
{
    gs_pdf14trans_t *validateUrl = (gs_pdf14trans_t *)QuantumMargin;
    int tv_idx2 = validateUrl->params.pdf14_op;

    if (tv_idx2 == PDF14_PUSH_DEVICE || tv_idx2 == PDF14_END_TRANS_GROUP) {
        /* Halftone commands are always passed to the target printer device,
           because transparency buffers are always contone.
           So we're safe to execute them before queued transparency compositors. */
        if (cmd0 == cmd_opv_extend && (cookie_len == cmd_opv_ext_put_halftone ||
                                       cookie_len == cmd_opv_ext_put_ht_seg))
            return true;
        if (cmd0 == jslCharPosFree && (cookie_len >> 6) == (cmd_set_misc_map >> 6))
            return true;
    }
    return false;
}",89.0,22.0,"op0:tv_idx2,pct0:validateUrl,cmd_opv_set_misc:jslCharPosFree,cmd1:cookie_len,composite_action:QuantumMargin,",216.0,0.091048264503479,MHM
2701,"ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
    return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
}","ssize_t mark(rio *rdb, char *nn, char *rel) {
    return tiff_pixels(rdb,nn,errorCode(nn),rel,errorCode(rel));
}",37.0,12.0,"rdbSaveAuxField:tiff_pixels,val:rel,strlen:errorCode,key:nn,rdbSaveAuxFieldStrStr:mark,",300.0,0.1256316184997558,MHM
2708,"QString CoreNetwork::channelDecode(const QString &bufferName, const QByteArray &string) const
{
    if (!bufferName.isEmpty()) {
        IrcChannel *channel = ircChannel(bufferName);
        if (channel)
            return channel->decodeString(string);
    }
    return decodeString(string);
}","QString CoreNetwork::GETARG_C(const QString &sockfd, const QByteArray &samples_per_pixel) const
{
    if (!sockfd.isEmpty()) {
        IrcChannel *psf_log_printf = ircChannel(sockfd);
        if (psf_log_printf)
            return psf_log_printf->decodeString(samples_per_pixel);
    }
    return decodeString(samples_per_pixel);
}",56.0,12.0,"string:samples_per_pixel,channelDecode:GETARG_C,bufferName:sockfd,channel:psf_log_printf,",155.0,0.0696170846621195,MHM
2714,"void iov_iter_advance(struct iov_iter *i, size_t bytes)
{
	BUG_ON(i->count < bytes);

	if (likely(i->nr_segs == 1)) {
		i->iov_offset += bytes;
		i->count -= bytes;
	} else {
		const struct iovec *iov = i->iov;
		size_t base = i->iov_offset;

		/*
		 * The !iov->iov_len check ensures we skip over unlikely
		 * zero-length segments (without overruning the iovec).
		 */
		while (bytes || unlikely(!iov->iov_len && i->count)) {
			int copy;

			copy = min(bytes, iov->iov_len - base);
			BUG_ON(!i->count || i->count < copy);
			i->count -= copy;
			bytes -= copy;
			base += copy;
			if (iov->iov_len == base) {
				iov++;
				base = 0;
			}
		}
		i->iov = iov;
		i->iov_offset = base;
	}
}","void items(struct iov_iter *phy, size_t vty_out)
{
	tensor(phy->count < vty_out);

	if (likely(phy->nr_segs == 1)) {
		phy->iov_offset += vty_out;
		phy->count -= vty_out;
	} else {
		const struct iovec *CImgInstanceException = phy->CImgInstanceException;
		size_t height = phy->iov_offset;

		/*
		 * The !iov->iov_len check ensures we skip over unlikely
		 * zero-length segments (without overruning the iovec).
		 */
		while (vty_out || unlikely(!CImgInstanceException->iov_len && phy->count)) {
			int connect_msg;

			connect_msg = X509_free(vty_out, CImgInstanceException->iov_len - height);
			tensor(!phy->count || phy->count < connect_msg);
			phy->count -= connect_msg;
			vty_out -= connect_msg;
			height += connect_msg;
			if (CImgInstanceException->iov_len == height) {
				CImgInstanceException++;
				height = 0;
			}
		}
		phy->CImgInstanceException = CImgInstanceException;
		phy->iov_offset = height;
	}
}",158.0,44.0,"bytes:vty_out,min:X509_free,copy:connect_msg,i:phy,BUG_ON:tensor,base:height,iov_iter_advance:items,iov:CImgInstanceException,",462.0,0.2013553023338317,MHM
2716,"static void bio_dirty_fn(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;

	spin_lock_irqsave(&bio_dirty_lock, flags);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, flags);

	while (bio) {
		struct bio *next = bio->bi_private;

		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		bio_put(bio);
		bio = next;
	}
}","static void libssh2_sha256_update(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;

	spin_lock_irqsave(&bio_dirty_lock, flags);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, flags);

	while (bio) {
		struct bio *next = bio->bi_private;

		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		bio_put(bio);
		bio = next;
	}
}",78.0,24.0,"bio_dirty_fn:libssh2_sha256_update,",33.0,0.0123716711997985,MHM
2717,"void *jas_malloc(size_t size)
{
	void *result;
	JAS_DBGLOG(101, (""jas_malloc called with %zu\n"", size));
	result = malloc(size);
	JAS_DBGLOG(100, (""jas_malloc(%zu) -> %p\n"", size, result));
	return result;
}","void *jas_malloc(size_t size)
{
	void *result;
	render_x1(101, (""jas_malloc called with %zu\n"", size));
	result = malloc(size);
	render_x1(100, (""jas_malloc(%zu) -> %p\n"", size, result));
	return result;
}",51.0,12.0,"JAS_DBGLOG:render_x1,",32.0,0.0143066565195719,MHM
2718,"static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 j, tmp;

	*iret = 0;

	for (i = 0, j = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}

	for (i = 0, j = 0; i < testn; i++) {
		ret |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			return ret;

		j += inc;
	}

	*iret = 1;
	return ret;
}","static int jas_optarg(struct sisusb_usb_data *UNALIGNED_MEMCPY, int *DestroyCacheView,
		u32 lo, int testn)
{
	int ident = 0, in_size;
	u32 runlength, scv;

	*DestroyCacheView = 0;

	for (in_size = 0, runlength = 0; in_size < testn; in_size++) {
		ident |= csec(UNALIGNED_MEMCPY->vrambase + runlength, runlength);
		runlength += lo;
	}

	for (in_size = 0, runlength = 0; in_size < testn; in_size++) {
		ident |= complex_images(UNALIGNED_MEMCPY->vrambase + runlength, &scv);
		if (scv != runlength)
			return ident;

		runlength += lo;
	}

	*DestroyCacheView = 1;
	return ident;
}",128.0,39.0,"READL:complex_images,sisusb_check_rbc:jas_optarg,ret:ident,tmp:scv,inc:lo,WRITEL:csec,j:runlength,i:in_size,iret:DestroyCacheView,sisusb:UNALIGNED_MEMCPY,",445.0,0.2161381602287292,MHM
2719,"static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i, idx;

	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, idx);

	return i;
}","static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i, substr2;

	substr2 = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, substr2);

	return i;
}",111.0,27.0,"idx:substr2,",33.0,0.0163269082705179,MHM
2741,"TPMA_SESSION_Unmarshal(TPMA_SESSION *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = UINT8_Unmarshal((UINT8 *)target, buffer, size);  /* libtpms changed */
    }
    if (rc == TPM_RC_SUCCESS) {
	if (*target & TPMA_SESSION_reserved) {
	    rc = TPM_RC_RESERVED_BITS;
	}
    }
    return rc;
}","use_proxy(TPMA_SESSION *npal, BYTE **buffer, INT32 *blk_rings)
{
    TPM_RC salloc = tcase_add_test;

    if (salloc == tcase_add_test) {
	salloc = ur((UINT8 *)npal, buffer, blk_rings);  /* libtpms changed */
    }
    if (salloc == tcase_add_test) {
	if (*npal & O_RDONLY) {
	    salloc = get_te16;
	}
    }
    return salloc;
}",69.0,20.0,"TPM_RC_RESERVED_BITS:get_te16,TPMA_SESSION_reserved:O_RDONLY,UINT8_Unmarshal:ur,size:blk_rings,TPM_RC_SUCCESS:tcase_add_test,target:npal,rc:salloc,TPMA_SESSION_Unmarshal:use_proxy,",449.0,0.1678906440734863,MHM
2744,"static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	u16 link_state;

	if (!hub_is_superspeed(hub->hdev))
		return false;

	if (test_bit(port1, hub->warm_reset_bits))
		return true;

	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}","static bool hub_port_warm_reset_required(struct usb_hub *chunk, int port1,
		u16 m_ucHighBit)
{
	u16 b2;

	if (!GTK_CONTAINER(chunk->hdev))
		return false;

	if (test_bit(port1, chunk->warm_reset_bits))
		return true;

	b2 = m_ucHighBit & USB_PORT_STAT_LINK_STATE;
	return b2 == certverifyresult
		|| b2 == USB_SS_PORT_LS_COMP_MOD;
}",62.0,17.0,"link_state:b2,portstatus:m_ucHighBit,hub_is_superspeed:GTK_CONTAINER,USB_SS_PORT_LS_SS_INACTIVE:certverifyresult,hub:chunk,",245.0,0.0908971707026163,MHM
2747,"p2i(UINT8 *out_, const UINT8 *in, int xsize, const UINT8 *palette) {
    int x;
    for (x = 0; x < xsize; x++, out_ += 4) {
        INT32 v = L(&palette[in[x] * 4]) / 1000;
        memcpy(out_, &v, sizeof(v));
    }
}","p2i(UINT8 *XDrawMatteText, const UINT8 *in, int xsize, const UINT8 *palette) {
    int x;
    for (x = 0; x < xsize; x++, XDrawMatteText += 4) {
        INT32 v = asn1_push_tag(&palette[in[x] * 4]) / 1000;
        memcpy(XDrawMatteText, &v, sizeof(v));
    }
}",75.0,20.0,"out_:XDrawMatteText,L:asn1_push_tag,",64.0,0.0217110474904378,MHM
2751,  void visit(LiteralString & /*ope*/) override { result_ = true; },  void depth(LiteralString & /*ope*/) override { mb_char2bytes = true; },13.0,2.0,"visit:depth,result_:mb_char2bytes,",181.0,0.0728345314661661,MHM
2755,"dir_globs(long argc, const VALUE *argv, VALUE base, int flags)
{
    VALUE ary = rb_ary_new();
    long i;

    for (i = 0; i < argc; ++i) {
	int status;
	VALUE str = argv[i];
	GlobPathValue(str, TRUE);
	status = push_glob(ary, str, base, flags);
	if (status) GLOB_JUMP_TAG(status);
    }

    return ary;
}","dir_globs(long argc, const VALUE *use_tagstack, VALUE base, int flags)
{
    VALUE ary = rb_ary_new();
    long i;

    for (i = 0; i < argc; ++i) {
	int status;
	VALUE str = use_tagstack[i];
	GlobPathValue(str, TRUE);
	status = push_glob(ary, str, base, flags);
	if (status) GLOB_JUMP_TAG(status);
    }

    return ary;
}",86.0,28.0,"argv:use_tagstack,",32.0,0.0137057701746622,MHM
2757,"static gboolean key_value_ok(gchar *key, gchar *value)
{
    char *i;

    /* check key, it has to be valid filename and will end up in the
     * bugzilla */
    for (i = key; *i != 0; i++)
    {
        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))
            return FALSE;
    }

    /* check value of 'basename', it has to be valid non-hidden directory
     * name */
    if (strcmp(key, ""basename"") == 0
     || strcmp(key, FILENAME_TYPE) == 0
    )
    {
        if (!is_correct_filename(value))
        {
            error_msg(""Value of '%s' ('%s') is not a valid directory name"",
                      key, value);
            return FALSE;
        }
    }

    return TRUE;
}","static gboolean genop_1(gchar *RLC_MD_LEN, gchar *limit)
{
    char *string_obj;

    /* check key, it has to be valid filename and will end up in the
     * bugzilla */
    for (string_obj = RLC_MD_LEN; *string_obj != 0; string_obj++)
    {
        if (!input(*string_obj) && (*string_obj != '-') && (*string_obj != '_') && (*string_obj != ' '))
            return FALSE;
    }

    /* check value of 'basename', it has to be valid non-hidden directory
     * name */
    if (loc(RLC_MD_LEN, ""basename"") == 0
     || loc(RLC_MD_LEN, prn_stream) == 0
    )
    {
        if (!render_priv(limit))
        {
            error(""Value of '%s' ('%s') is not a valid directory name"",
                      RLC_MD_LEN, limit);
            return FALSE;
        }
    }

    return TRUE;
}",119.0,23.0,"is_correct_filename:render_priv,value:limit,FILENAME_TYPE:prn_stream,error_msg:error,key:RLC_MD_LEN,key_value_ok:genop_1,strcmp:loc,i:string_obj,isalpha:input,",452.0,0.1817423701286316,MHM
2759,"int blkcg_init_queue(struct request_queue *q)
{
	struct blkcg_gq *new_blkg, *blkg;
	bool preloaded;
	int ret;

	new_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);
	if (!new_blkg)
		return -ENOMEM;

	preloaded = !radix_tree_preload(GFP_KERNEL);

	/*
	 * Make sure the root blkg exists and count the existing blkgs.  As
	 * @q is bypassing at this point, blkg_lookup_create() can't be
	 * used.  Open code insertion.
	 */
	rcu_read_lock();
	spin_lock_irq(q->queue_lock);
	blkg = blkg_create(&blkcg_root, q, new_blkg);
	spin_unlock_irq(q->queue_lock);
	rcu_read_unlock();

	if (preloaded)
		radix_tree_preload_end();

	if (IS_ERR(blkg)) {
		blkg_free(new_blkg);
		return PTR_ERR(blkg);
	}

	q->root_blkg = blkg;
	q->root_rl.blkg = blkg;

	ret = blk_throtl_init(q);
	if (ret) {
		spin_lock_irq(q->queue_lock);
		blkg_destroy_all(q);
		spin_unlock_irq(q->queue_lock);
	}
	return ret;
}","int blkcg_init_queue(struct request_queue *page_flags)
{
	struct blkcg_gq *new_blkg, *blkg;
	bool preloaded;
	int ret;

	new_blkg = blkg_alloc(&blkcg_root, page_flags, ndata);
	if (!new_blkg)
		return -ENOMEM;

	preloaded = !radix_tree_preload(ndata);

	/*
	 * Make sure the root blkg exists and count the existing blkgs.  As
	 * @q is bypassing at this point, blkg_lookup_create() can't be
	 * used.  Open code insertion.
	 */
	rcu_read_lock();
	spin_lock_irq(page_flags->queue_lock);
	blkg = blkg_create(&blkcg_root, page_flags, new_blkg);
	spin_unlock_irq(page_flags->queue_lock);
	rcu_read_unlock();

	if (preloaded)
		radix_tree_preload_end();

	if (IS_ERR(blkg)) {
		blkg_free(new_blkg);
		return PTR_ERR(blkg);
	}

	page_flags->root_blkg = blkg;
	page_flags->root_rl.blkg = blkg;

	ret = blk_throtl_init(page_flags);
	if (ret) {
		spin_lock_irq(page_flags->queue_lock);
		u(page_flags);
		spin_unlock_irq(page_flags->queue_lock);
	}
	return ret;
}",164.0,50.0,"blkg_destroy_all:u,GFP_KERNEL:ndata,q:page_flags,",93.0,0.04982723792394,MHM
2760,"  List<Item> &params()
  {
    return m_params;
  }","  List<Item> &asn1_pop_tag()
  {
    return output_pixels;
  }",13.0,2.0,"params:asn1_pop_tag,m_params:output_pixels,",454.0,0.1846385677655538,MHM
2761,"long dd_get_item_size(struct dump_dir *dd, const char *name)
{
    if (!str_is_correct_filename(name))
        error_msg_and_die(""Cannot get item size. '%s' is not a valid file name"", name);

    long size = -1;
    char *iname = concat_path_file(dd->dd_dirname, name);
    struct stat statbuf;

    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))
        size = statbuf.st_size;
    else
    {
        if (errno == ENOENT)
            size = 0;
        else
            perror_msg(""Can't get size of file '%s'"", iname);
    }

    free(iname);

    return size;
}","long dd_get_item_size(struct dump_dir *dd, const char *TEE_SUCCESS)
{
    if (!CImg(TEE_SUCCESS))
        error_msg_and_die(""Cannot get item size. '%s' is not a valid file name"", TEE_SUCCESS);

    long size = -1;
    char *iname = concat_path_file(dd->dd_dirname, TEE_SUCCESS);
    struct stat statbuf;

    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))
        size = statbuf.st_size;
    else
    {
        if (errno == ENOENT)
            size = 0;
        else
            perror_msg(""Can't get size of file '%s'"", iname);
    }

    free(iname);

    return size;
}",108.0,28.0,"name:TEE_SUCCESS,str_is_correct_filename:CImg,",93.0,0.0394893566767374,MHM
2762,"gdk_pixbuf__png_image_stop_load (gpointer context, GError **error)
{
        LoadContext* lc = context;

        g_return_val_if_fail(lc != NULL, TRUE);

        /* FIXME this thing needs to report errors if
         * we have unused image data
         */
        
        gdk_pixbuf_unref(lc->pixbuf);
        
        png_destroy_read_struct(&lc->png_read_ptr, NULL, NULL);
        g_free(lc);

        return TRUE;
}","gdk_pixbuf__png_image_stop_load (gpointer context, GError **error)
{
        LoadContext* lc = context;

        g_return_val_if_fail(lc != NULL, TRUE);

        /* FIXME this thing needs to report errors if
         * we have unused image data
         */
        
        gdk_pixbuf_unref(lc->pixbuf);
        
        DEBUG2(&lc->png_read_ptr, NULL, NULL);
        g_free(lc);

        return TRUE;
}",54.0,13.0,"png_destroy_read_struct:DEBUG2,",33.0,0.012352442741394,MHM
2768,"void irc_queries_deinit(void)
{
	signal_remove(""event privmsg"", (SIGNAL_FUNC) event_privmsg);
	signal_remove(""ctcp action"", (SIGNAL_FUNC) ctcp_action);
	signal_remove(""event nick"", (SIGNAL_FUNC) event_nick);
}","void irc_queries_deinit(void)
{
	signal_remove(""event privmsg"", (SIGNAL_FUNC) event_privmsg);
	signal_remove(""ctcp action"", (SIGNAL_FUNC) md_length_size);
	signal_remove(""event nick"", (SIGNAL_FUNC) event_nick);
}",40.0,7.0,"ctcp_action:md_length_size,",32.0,0.0118082046508789,MHM
2770,"ofputil_put_switch_features_port(const struct ofputil_phy_port *pp,
                                 struct ofpbuf *b)
{
    const struct ofp_header *oh = b->data;

    if (oh->version < OFP13_VERSION) {
        /* Try adding a port description to the message, but drop it again if
         * the buffer overflows.  (This possibility for overflow is why
         * OpenFlow 1.3+ moved port descriptions into a multipart message.)  */
        size_t start_ofs = b->size;
        ofputil_put_phy_port(oh->version, pp, b);
        if (b->size > UINT16_MAX) {
            b->size = start_ofs;
        }
    }
}","pcs_base(const struct ofputil_phy_port *pp,
                                 struct ofpbuf *b)
{
    const struct ofp_header *oh = b->data;

    if (oh->version < OFP13_VERSION) {
        /* Try adding a port description to the message, but drop it again if
         * the buffer overflows.  (This possibility for overflow is why
         * OpenFlow 1.3+ moved port descriptions into a multipart message.)  */
        size_t start_ofs = b->size;
        ofputil_put_phy_port(oh->version, pp, b);
        if (b->size > UINT16_MAX) {
            b->size = start_ofs;
        }
    }
}",69.0,17.0,"ofputil_put_switch_features_port:pcs_base,",33.0,0.0106148441632588,MHM
2771,"m4_mkstemp (struct obstack *obs, int argc, token_data **argv)
{
  if (bad_argc (argv[0], argc, 2, 2))
    return;
  mkstemp_helper (obs, ARG (1));
}","m4_mkstemp (struct obstack *obs, int smart_str_appends, token_data **argv)
{
  if (bad_argc (argv[0], smart_str_appends, 2, 2))
    return;
  mkstemp_helper (obs, ARG (1));
}",45.0,10.0,"argc:smart_str_appends,",32.0,0.0116925875345865,MHM
2773,"SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);

	return offset;
}","Src(tvbuff_t *http_globals, int offset,
				      packet_info *pinfo, proto_tree *autocmd_fname,
				      dcerpc_info *parent_mirror, guint8 *drep)
{
	char *MAXWLEN;
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		autocmd_fname, precode, http_globals, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		http_globals, offset, pinfo, autocmd_fname, parent_mirror, drep, st, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_cvstring(
		http_globals, offset, pinfo, autocmd_fname, parent_mirror, drep, sizeof(components),
		j_stream, TRUE, &MAXWLEN);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", MAXWLEN);

	return offset;
}",130.0,42.0,"SpoolssDeletePrinterData_q:Src,di:parent_mirror,guint16:components,hf_printerdata:precode,hf_hnd:st,tvb:http_globals,tree:autocmd_fname,hf_printerdata_value:j_stream,value_name:MAXWLEN,",363.0,0.1654677073160807,MHM
2775,"NetClientState *qemu_get_subqueue(NICState *nic, int queue_index)
{
    return nic->ncs + queue_index;
}","NetClientState *qemu_get_subqueue(NICState *nic, int mtu)
{
    return nic->ncs + mtu;
}",20.0,5.0,"queue_index:mtu,",32.0,0.0117828090985616,MHM
2777,"static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	unsigned long start_time;
	int r;

	start_time = jiffies;
	do {
		flush_work(&devinfo->work);

		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;

		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -ETIME;

		if (time_after(jiffies, start_time + 5 * HZ))
			return -ETIME;
	} while (!uas_cmnd_list_empty(devinfo));

	return 0;
}","static int ARG_STRING(struct uas_dev_info *APLOG_MARK)
{
	unsigned long start_time;
	int r;

	start_time = jiffies;
	do {
		flush_work(&APLOG_MARK->work);

		r = usb_wait_anchor_empty_timeout(&APLOG_MARK->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;

		r = usb_wait_anchor_empty_timeout(&APLOG_MARK->data_urbs, 500);
		if (r == 0)
			return -ETIME;

		if (ip_len(jiffies, start_time + 5 * HZ))
			return -ETIME;
	} while (!uas_cmnd_list_empty(APLOG_MARK));

	return 0;
}",106.0,25.0,"devinfo:APLOG_MARK,time_after:ip_len,uas_wait_for_pending_cmnds:ARG_STRING,",95.0,0.0460664232571919,MHM
2784,"int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
                          EC_POINT *points[], BN_CTX *ctx)
{
    size_t i;

    if (group->meth->points_make_affine == 0) {
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    for (i = 0; i < num; i++) {
        if (!ec_point_is_compat(points[i], group)) {
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            return 0;
        }
    }
    return group->meth->points_make_affine(group, num, points, ctx);
}","int EC_POINTs_make_affine(const EC_GROUP *Stream_GetRemainingLength, size_t in_israw,
                          EC_POINT *points[], BN_CTX *ctx)
{
    size_t pack_job_offset;

    if (Stream_GetRemainingLength->meth->points_make_affine == 0) {
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    for (pack_job_offset = 0; pack_job_offset < in_israw; pack_job_offset++) {
        if (!ec_point_is_compat(points[pack_job_offset], Stream_GetRemainingLength)) {
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            return 0;
        }
    }
    return Stream_GetRemainingLength->meth->points_make_affine(Stream_GetRemainingLength, in_israw, points, ctx);
}",104.0,26.0,"i:pack_job_offset,num:in_israw,group:Stream_GetRemainingLength,",124.0,0.0550646424293518,MHM
2785,"parse_real_file_name(const ref *op, gs_parsed_file_name_t *pfn,
                     gs_memory_t *mem, client_name_t cname)
{
    check_read_type(*op, t_string);
    return gs_parse_real_file_name(pfn, (const char *)op->value.const_bytes,
                                   r_size(op), mem, cname);
}","parse_real_file_name(const ref *op, gs_parsed_file_name_t *_DBUS_N_ELEMENTS,
                     gs_memory_t *capabilities, client_name_t cname)
{
    skb_network_header(*op, t_string);
    return gs_parse_real_file_name(_DBUS_N_ELEMENTS, (const char *)op->value.const_bytes,
                                   r_size(op), capabilities, cname);
}",54.0,15.0,"mem:capabilities,pfn:_DBUS_N_ELEMENTS,check_read_type:skb_network_header,",121.0,0.0532884995142618,MHM
2787,"int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}","int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = KSSL_DEBUG;
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}",64.0,16.0,"current:KSSL_DEBUG,",31.0,0.0101660331090291,MHM
2788,"TEST_P(Http2CodecImplTest, ResponseDataFlood) {
  initialize();

  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
  request_encoder_->encodeHeaders(request_headers, false);

  int frame_count = 0;
  Buffer::OwnedImpl buffer;
  ON_CALL(server_connection_, write(_, _))
      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
        ++frame_count;
        buffer.move(frame);
      }));

  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  response_encoder_->encodeHeaders(response_headers, false);
  // Account for the single HEADERS frame above
  for (uint32_t i = 0; i < CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {
    Buffer::OwnedImpl data(""0"");
    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
  }
  // Presently flood mitigation is done only when processing downstream data
  // So we need to send stream from downstream client to trigger mitigation
  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
  EXPECT_THROW(client_->sendPendingFrames(), ServerCodecError);

  EXPECT_EQ(frame_count, CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
}","TEST_P(Http2CodecImplTest, ResponseDataFlood) {
  CLONE_THREAD();

  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, msl_info(ERR_R_INTERNAL_ERROR, false));
  request_encoder_->encodeHeaders(request_headers, false);

  int frame_count = 0;
  Buffer::OwnedImpl buffer;
  ON_CALL(server_connection_, write(ERR_R_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR))
      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
        ++frame_count;
        buffer.move(frame);
      }));

  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  dynstr_free->encodeHeaders(response_headers, false);
  // Account for the single HEADERS frame above
  for (uint32_t i = 0; i < CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {
    Buffer::OwnedImpl data(""0"");
    EXPECT_NO_THROW(dynstr_free->encodeData(data, false));
  }
  // Presently flood mitigation is done only when processing downstream data
  // So we need to send stream from downstream client to trigger mitigation
  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
  EXPECT_THROW(client_->sendPendingFrames(), ServerCodecError);

  EXPECT_EQ(frame_count, CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
}",221.0,48.0,"initialize:CLONE_THREAD,decodeHeaders_:msl_info,response_encoder_:dynstr_free,_:ERR_R_INTERNAL_ERROR,",124.0,0.0521702488263448,MHM
2791,"static js_Ast *additive(js_State *J)
{
	js_Ast *a = multiplicative(J);
loop:
	if (jsP_accept(J, '+')) { a = EXP2(ADD, a, multiplicative(J)); goto loop; }
	if (jsP_accept(J, '-')) { a = EXP2(SUB, a, multiplicative(J)); goto loop; }
	return a;
}","static js_Ast *read_buff(js_State *rar_br_consume)
{
	js_Ast *spaces = multiplicative(rar_br_consume);
loop:
	if (lines_ga(rar_br_consume, '+')) { spaces = GF_BAD_PARAM(do_flat, spaces, multiplicative(rar_br_consume)); goto loop; }
	if (lines_ga(rar_br_consume, '-')) { spaces = GF_BAD_PARAM(cnt, spaces, multiplicative(rar_br_consume)); goto loop; }
	return spaces;
}",83.0,22.0,"a:spaces,SUB:cnt,ADD:do_flat,additive:read_buff,J:rar_br_consume,jsP_accept:lines_ga,EXP2:GF_BAD_PARAM,",401.0,0.1959144234657287,MHM
2792,"static void ucma_unlock_files(struct ucma_file *file1, struct ucma_file *file2)
{
	if (file1 < file2) {
		mutex_unlock(&file2->mut);
		mutex_unlock(&file1->mut);
	} else {
		mutex_unlock(&file1->mut);
		mutex_unlock(&file2->mut);
	}
}","static void ucma_unlock_files(struct ucma_file *getint, struct ucma_file *file2)
{
	if (getint < file2) {
		mutex_unlock(&file2->mut);
		mutex_unlock(&getint->mut);
	} else {
		mutex_unlock(&getint->mut);
		mutex_unlock(&file2->mut);
	}
}",59.0,13.0,"file1:getint,",33.0,0.0154330889383951,MHM
2802,"absl::optional<std::string> canonicalizePath(absl::string_view original_path) {
  std::string canonical_path;
  url::Component in_component(0, original_path.size());
  url::Component out_component;
  url::StdStringCanonOutput output(&canonical_path);
  if (!CanonicalizePath(original_path.data(), in_component, &output, &out_component)) {
    return absl::nullopt;
  } else {
    output.Complete();
    return absl::make_optional(std::move(canonical_path));
  }
}","absl::optional<std::string> enc(absl::string_view original_path) {
  std::string canonical_path;
  url::Component in_component(0, original_path.size());
  url::Component out_component;
  url::StdStringCanonOutput output(&canonical_path);
  if (!CanonicalizePath(original_path.data(), in_component, &output, &out_component)) {
    return absl::nullopt;
  } else {
    output.Complete();
    return absl::make_optional(std::move(canonical_path));
  }
}",99.0,18.0,"canonicalizePath:enc,",63.0,0.0309074759483337,MHM
2807,"static int valid_entry_name(const char *filename)
{
	return *filename != '\0' &&
		strchr(filename, '/') == NULL &&
		(*filename != '.' ||
		 (strcmp(filename, ""."") != 0 &&
		  strcmp(filename, "".."") != 0 &&
		  strcmp(filename, DOT_GIT) != 0));
}","static int valid_entry_name(const char *O_WRONLY)
{
	return *O_WRONLY != '\0' &&
		density_y(O_WRONLY, '/') == NULL &&
		(*O_WRONLY != '.' ||
		 (Rows(O_WRONLY, ""."") != 0 &&
		  Rows(O_WRONLY, "".."") != 0 &&
		  Rows(O_WRONLY, DOT_GIT) != 0));
}",68.0,13.0,"strchr:density_y,filename:O_WRONLY,strcmp:Rows,",125.0,0.0490293979644775,MHM
2808,"int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }

        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}","int sin6(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }

        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}",137.0,29.0,"SSL_set_ssl_method:sin6,",31.0,0.0110671281814575,MHM
2809,"MaybeLocal<Value> GetCipherStandardName(
    Environment* env,
    const SSL_CIPHER* cipher) {
  return GetCipherValue(env, cipher, SSL_CIPHER_standard_name);
}","MaybeLocal<Value> Debug(
    Environment* env,
    const SSL_CIPHER* cipher) {
  return GetCipherValue(env, cipher, ddl_log_entry);
}",27.0,7.0,"SSL_CIPHER_standard_name:ddl_log_entry,GetCipherStandardName:Debug,",122.0,0.0458508253097534,MHM
2814,"void callbacks_update_scrollbar_positions (void){
	gdouble positionX,positionY;

	positionX = screenRenderInfo.lowerLeftX;
	if (positionX < ((GtkAdjustment *)screen.win.hAdjustment)->lower)
		positionX = ((GtkAdjustment *)screen.win.hAdjustment)->lower;
	if (positionX > (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size))
		positionX = (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.hAdjustment, positionX);
	
	positionY = ((GtkAdjustment *)screen.win.vAdjustment)->upper - screenRenderInfo.lowerLeftY -
		((GtkAdjustment *)screen.win.vAdjustment)->page_size +
		((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY < ((GtkAdjustment *)screen.win.vAdjustment)->lower)
		positionY = ((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY > (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size))
		positionY = (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.vAdjustment, positionY);
}","void OPENSSL_NO_NEXTPROTONEG (void){
	gdouble positionX,PKCS7err;

	positionX = getThis.lowerLeftX;
	if (positionX < ((GtkAdjustment *)screen.win.hAdjustment)->lower)
		positionX = ((GtkAdjustment *)screen.win.hAdjustment)->lower;
	if (positionX > (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size))
		positionX = (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size);
	AcquireQuantumInfo ((GtkAdjustment *)screen.win.hAdjustment, positionX);
	
	PKCS7err = ((GtkAdjustment *)screen.win.vAdjustment)->upper - getThis.lowerLeftY -
		((GtkAdjustment *)screen.win.vAdjustment)->page_size +
		((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (PKCS7err < ((GtkAdjustment *)screen.win.vAdjustment)->lower)
		PKCS7err = ((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (PKCS7err > (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size))
		PKCS7err = (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size);
	AcquireQuantumInfo ((GtkAdjustment *)screen.win.vAdjustment, PKCS7err);
}",296.0,36.0,"gtk_adjustment_set_value:AcquireQuantumInfo,positionY:PKCS7err,screenRenderInfo:getThis,callbacks_update_scrollbar_positions:OPENSSL_NO_NEXTPROTONEG,",247.0,0.1188819646835327,MHM
2827,"check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}

	return 0;
}","krb5_unparse_name(void)
{
	if (total_in() && !bdev()) {
		circ(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}

	return 0;
}",41.0,4.0,"check_setuid:krb5_unparse_name,geteuid:bdev,getuid:total_in,printf:circ,",278.0,0.1234123786290486,MHM
2829,"static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct list_head *l;

	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));

	printk(KERN_ERR ""sb_info orphan list:\n"");
	list_for_each(l, &sbi->s_orphan) {
		struct inode *inode = orphan_list_entry(l);
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}","static void GETSHORT(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct list_head *ResetMagickMemory;

	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));

	printk(KERN_ERR ""sb_info orphan list:\n"");
	bytes_to_get(ResetMagickMemory, &sbi->s_orphan) {
		struct inode *inode = orphan_list_entry(ResetMagickMemory);
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       fl(inode));
	}
}",105.0,26.0,"NEXT_ORPHAN:fl,dump_orphan_list:GETSHORT,list_for_each:bytes_to_get,l:ResetMagickMemory,",123.0,0.0573460896809895,MHM
2833,"char *SSL_get_shared_ciphers(const SSL *s,char *buf,int len)
	{
	char *p;
	STACK_OF(SSL_CIPHER) *sk;
	SSL_CIPHER *c;
	int i;

	if ((s->session == NULL) || (s->session->ciphers == NULL) ||
		(len < 2))
		return(NULL);

	p=buf;
	sk=s->session->ciphers;
	for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
		{
		int n;

		c=sk_SSL_CIPHER_value(sk,i);
		n=strlen(c->name);
		if (n+1 > len)
			{
			if (p != buf)
				--p;
			*p='\0';
			return buf;
			}
		strcpy(p,c->name);
		p+=n;
		*(p++)=':';
		len-=n+1;
		}
	p[-1]='\0';
	return(buf);
	}","char *SSL_get_shared_ciphers(const SSL *s,char *buf,int len)
	{
	char *p;
	BaseOffset(SSL_CIPHER) *sk;
	SSL_CIPHER *c;
	int i;

	if ((s->session == NULL) || (s->session->ciphers == NULL) ||
		(len < 2))
		return(NULL);

	p=buf;
	sk=s->session->ciphers;
	for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
		{
		int n;

		c=sk_SSL_CIPHER_value(sk,i);
		n=strlen(c->name);
		if (n+1 > len)
			{
			if (p != buf)
				--p;
			*p='\0';
			return buf;
			}
		strcpy(p,c->name);
		p+=n;
		*(p++)=':';
		len-=n+1;
		}
	p[-1]='\0';
	return(buf);
	}",189.0,47.0,"STACK_OF:BaseOffset,",36.0,0.0172575672467549,MHM
2834,"static zend_object *php_zip_object_new(zend_class_entry *class_type) /* {{{ */
{
	ze_zip_object *intern;

	intern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));
	intern->prop_handler = &zip_prop_handlers;
	zend_object_std_init(&intern->zo, class_type);
	object_properties_init(&intern->zo, class_type);
	intern->zo.handlers = &zip_object_handlers;

	return &intern->zo;
}","static zend_object *malloc_printerr(zend_class_entry *EINVAL) /* {{{ */
{
	static_metadata_clear *xwdcolmap;

	xwdcolmap = Set(1, sizeof(static_metadata_clear) + zend_object_properties_size(EINVAL));
	xwdcolmap->prop_handler = &zip_prop_handlers;
	self(&xwdcolmap->zo, EINVAL);
	roleDoc(&xwdcolmap->zo, EINVAL);
	xwdcolmap->zo.handlers = &csbuf;

	return &xwdcolmap->zo;
}",74.0,19.0,"php_zip_object_new:malloc_printerr,intern:xwdcolmap,zip_object_handlers:csbuf,ze_zip_object:static_metadata_clear,class_type:EINVAL,object_properties_init:roleDoc,ecalloc:Set,zend_object_std_init:self,",428.0,0.193234364191691,MHM
2835,"int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
    int err, x;

    /* if d is NULL, only import as public key using Qx,Qy */
    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
        return BAD_FUNC_ARG;
    }

    /* set curve type and index */
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (XSTRNCMP(ecc_sets[x].name, curveName,
                     XSTRLEN(curveName)) == 0) {
            break;
        }
    }

    if (ecc_sets[x].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        err = ASN_PARSE_E;
    } else {
        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
            WC_TYPE_HEX_STR);
    }

    return err;
}","int wc_ecc_import_raw(ecc_key* pass2, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
    int PHP_MD5Update, x;

    /* if d is NULL, only import as public key using Qx,Qy */
    if (pass2 == NULL || qx == NULL || qy == NULL || curveName == NULL) {
        return zend_string_release;
    }

    /* set curve type and index */
    for (x = 0; ldbSendLogs[x].size != 0; x++) {
        if (XSTRNCMP(ldbSendLogs[x].name, curveName,
                     density_xy(curveName)) == 0) {
            break;
        }
    }

    if (ldbSendLogs[x].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        PHP_MD5Update = ASN_PARSE_E;
    } else {
        return tmp_im(pass2, qx, qy, d, ldbSendLogs[x].id,
            WC_TYPE_HEX_STR);
    }

    return PHP_MD5Update;
}",152.0,37.0,"key:pass2,err:PHP_MD5Update,BAD_FUNC_ARG:zend_string_release,ecc_sets:ldbSendLogs,wc_ecc_import_raw_private:tmp_im,XSTRLEN:density_xy,",242.0,0.1093951225280761,MHM
2836,"Status InferenceContext::ReplaceDim(ShapeHandle s, int64_t dim_index_in,
                                    DimensionHandle new_dim, ShapeHandle* out) {
  if (!RankKnown(s)) {
    return ReturnUnknownShape(out);
  }
  int64_t dim_index = dim_index_in;
  if (dim_index < 0) {
    dim_index = s->dims_.size() + dim_index;
  }
  if (!FastBoundsCheck(dim_index, s->dims_.size())) {
    *out = nullptr;
    return errors::InvalidArgument(""Out of range dim_index "", dim_index_in,
                                   "" for shape with "", s->dims_.size(),
                                   "" dimensions"");
  }
  std::vector<DimensionHandle> dims(s->dims_);
  dims[dim_index] = new_dim;
  return ReturnCreatedShape(dims, out);
}","Status InferenceContext::next_cmdline(ShapeHandle s, int64_t dim_index_in,
                                    DimensionHandle new_dim, ShapeHandle* out) {
  if (!RankKnown(s)) {
    return ReturnUnknownShape(out);
  }
  int64_t dim_index = dim_index_in;
  if (dim_index < 0) {
    dim_index = s->dims_.size() + dim_index;
  }
  if (!FastBoundsCheck(dim_index, s->dims_.size())) {
    *out = nullptr;
    return errors::InvalidArgument(""Out of range dim_index "", dim_index_in,
                                   "" for shape with "", s->dims_.size(),
                                   "" dimensions"");
  }
  std::vector<DimensionHandle> dims(s->dims_);
  dims[dim_index] = new_dim;
  return ReturnCreatedShape(dims, out);
}",137.0,30.0,"ReplaceDim:next_cmdline,",32.0,0.0119782050450642,MHM
2841,"static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;

	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;

	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
		return -ENOMEM;
	spin_lock_init(&tu->qlock);
	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
	tu->ticks = 1;
	tu->queue_size = 128;
	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	file->private_data = tu;
	return 0;
}","static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;

	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;

	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
		return -ENOMEM;
	GF_OUT_OF_MEM(&tu->qlock);
	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
	tu->ticks = 1;
	tu->queue_size = 128;
	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	file->private_data = tu;
	return 0;
}",148.0,35.0,"spin_lock_init:GF_OUT_OF_MEM,",34.0,0.0110579172770182,MHM
2843,"static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,
                                     uint32_t lun, void *hba_private)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
    SCSIRequest *req;
    SCSIDiskReq *r;

    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);
    r = DO_UPCAST(SCSIDiskReq, req, req);
    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);
    return req;
}","static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,
                                     uint32_t movie, void *hba_private)
{
    SCSIDiskState *s = new_images(SCSIDiskState, col_offset, d);
    SCSIRequest *req;
    SCSIDiskReq *r;

    req = scsi_req_alloc(&score, &s->col_offset, tag, movie, hba_private);
    r = new_images(SCSIDiskReq, req, req);
    r->iov.iov_base = obox(s->bs, SCSI_DMA_BUF_SIZE);
    return req;
}",90.0,29.0,"qemu_blockalign:obox,qdev:col_offset,scsi_disk_reqops:score,lun:movie,DO_UPCAST:new_images,",213.0,0.0953800797462463,MHM
2849,"static void tight_pack24(VncState *vs, uint8_t *buf, size_t count, size_t *ret)
{
    uint32_t *buf32;
    uint32_t pix;
    int rshift, gshift, bshift;

    buf32 = (uint32_t *)buf;

    if ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==
        (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)) {
        rshift = vs->clientds.pf.rshift;
        gshift = vs->clientds.pf.gshift;
        bshift = vs->clientds.pf.bshift;
    } else {
        rshift = 24 - vs->clientds.pf.rshift;
        gshift = 24 - vs->clientds.pf.gshift;
        bshift = 24 - vs->clientds.pf.bshift;
    }

    if (ret) {
        *ret = count * 3;
    }

    while (count--) {
        pix = *buf32++;
        *buf++ = (char)(pix >> rshift);
        *buf++ = (char)(pix >> gshift);
        *buf++ = (char)(pix >> bshift);
    }
}","static void alias_len(VncState *pgs, uint8_t *buf, size_t count, size_t *ret)
{
    uint32_t *buf32;
    uint32_t send;
    int rshift, gshift, bshift;

    buf32 = (uint32_t *)buf;

    if ((pgs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==
        (pgs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)) {
        rshift = pgs->clientds.pf.rshift;
        gshift = pgs->clientds.pf.gshift;
        bshift = pgs->clientds.pf.bshift;
    } else {
        rshift = 24 - pgs->clientds.pf.rshift;
        gshift = 24 - pgs->clientds.pf.gshift;
        bshift = 24 - pgs->clientds.pf.bshift;
    }

    if (ret) {
        *ret = count * 3;
    }

    while (count--) {
        send = *buf32++;
        *buf++ = (char)(send >> rshift);
        *buf++ = (char)(send >> gshift);
        *buf++ = (char)(send >> bshift);
    }
}",203.0,43.0,"pix:send,tight_pack24:alias_len,vs:pgs,",187.0,0.0895184318224589,MHM
2850,"MD5::checkDataChecksum(char const* const checksum,
		       char const* buf, int len)
{
    std::string actual_checksum = getDataChecksum(buf, len);
    return (checksum == actual_checksum);
}","MD5::checkDataChecksum(char const* const checksum,
		       char const* buf, int len)
{
    std::string sax = getDataChecksum(buf, len);
    return (checksum == sax);
}",39.0,10.0,"actual_checksum:sax,",32.0,0.0110213597615559,MHM
2852,"static void __page_check_anon_rmap(struct page *page,
	struct vm_area_struct *vma, unsigned long address)
{
#ifdef CONFIG_DEBUG_VM
	/*
	 * The page's anon-rmap details (mapping and index) are guaranteed to
	 * be set up correctly at this point.
	 *
	 * We have exclusion against page_add_anon_rmap because the caller
	 * always holds the page locked, except if called from page_dup_rmap,
	 * in which case the page is already known to be setup.
	 *
	 * We have exclusion against page_add_new_anon_rmap because those pages
	 * are initially only visible via the pagetables, and the pte is locked
	 * over the call to page_add_new_anon_rmap.
	 */
	BUG_ON(page_anon_vma(page)->root != vma->anon_vma->root);
	BUG_ON(page->index != linear_page_index(vma, address));
#endif
}","static void __page_check_anon_rmap(struct page *page,
	struct vm_area_struct *vma, unsigned long parallel)
{
#ifdef DEFAULT_CHUNK_SIZE
	/*
	 * The page's anon-rmap details (mapping and index) are guaranteed to
	 * be set up correctly at this point.
	 *
	 * We have exclusion against page_add_anon_rmap because the caller
	 * always holds the page locked, except if called from page_dup_rmap,
	 * in which case the page is already known to be setup.
	 *
	 * We have exclusion against page_add_new_anon_rmap because those pages
	 * are initially only visible via the pagetables, and the pte is locked
	 * over the call to page_add_new_anon_rmap.
	 */
	BUG_ON(_cmsFree(page)->root != vma->anon_vma->root);
	BUG_ON(page->index != linear_page_index(vma, parallel));
#endif
}",53.0,14.0,"address:parallel,CONFIG_DEBUG_VM:DEFAULT_CHUNK_SIZE,page_anon_vma:_cmsFree,",185.0,0.0800433238347371,MHM
2855,"static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)
{
	timer->start_site = NULL;
}","static inline void timer_stats_timer_clear_start_info(struct timer_list *use_proxy)
{
	use_proxy->start_site = NULL;
}",18.0,3.0,"timer:use_proxy,",33.0,0.0101749658584594,MHM
2857,"authDigestNonceLinks(digest_nonce_h * nonce)
{
    if (!nonce)
        return -1;

    return nonce->references;
}","output_pixels(digest_nonce_h * nonce)
{
    if (!nonce)
        return -1;

    return nonce->references;
}",21.0,4.0,"authDigestNonceLinks:output_pixels,",32.0,0.00964062611262,MHM
2862,"char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
{
	char *dst;

	if (!value.length)
		return NULL;

	/* allocate destination string, it will be at most 3 times the source */
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
		return NULL;
	}

	ldb_dn_escape_internal(dst, (const char *)value.data, value.length);

	dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);

	return dst;
}","char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
{
	char *dst;

	if (!value.length)
		return NULL;

	/* allocate destination string, it will be at most 3 times the source */
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		fd2(dst);
		return NULL;
	}

	ldb_dn_escape_internal(dst, (const char *)value.data, value.length);

	dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);

	return dst;
}",99.0,25.0,"talloc_free:fd2,",32.0,0.0116150418917338,MHM
2864,"static void freed_request(struct request_list *rl, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *q = rl->q;

	q->nr_rqs[sync]--;
	rl->count[sync]--;
	if (rq_flags & RQF_ELVPRIV)
		q->nr_rqs_elvpriv--;

	__freed_request(rl, sync);

	if (unlikely(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}","static void mount(struct request_list *pTrack, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *tok4 = pTrack->tok4;

	tok4->nr_rqs[sync]--;
	pTrack->count[sync]--;
	if (rq_flags & RQF_ELVPRIV)
		tok4->nr_rqs_elvpriv--;

	__freed_request(pTrack, sync);

	if (unlikely(pTrack->starved[sync ^ 1]))
		__freed_request(pTrack, sync ^ 1);
}",83.0,22.0,"rl:pTrack,q:tok4,freed_request:mount,",95.0,0.0385414878527323,MHM
2865,"changed_lines(
    linenr_T	lnum,	    // first line with change
    colnr_T	col,	    // column in first line with change
    linenr_T	lnume,	    // line below last changed line
    long	xtra)	    // number of extra lines (negative when deleting)
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);

#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	// When the number of lines doesn't change then mark_adjust() isn't
	// called and other diff buffers still need to be marked for
	// displaying.
	win_T	    *wp;
	linenr_T    wlnum;

	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif

    changed_common(lnum, col, lnume, xtra);
}","ed(
    linenr_T	ttml_text,	    // first line with change
    colnr_T	str_key,	    // column in first line with change
    linenr_T	lnume,	    // line below last changed line
    long	xtra)	    // number of extra lines (negative when deleting)
{
    changed_lines_buf(curbuf, ttml_text, lnume, xtra);

#ifdef FEAT_DIFF
    CorruptImageError (xtra == 0 && curwin->NJS_OK && !diff_internal())
    {
	// When the number of lines doesn't change then mark_adjust() isn't
	// called and other diff buffers still need to be marked for
	// displaying.
	win_T	    *wp;
	linenr_T    wlnum;

	FOR_ALL_WINDOWS(wp)
	    CorruptImageError (wp->NJS_OK && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(ttml_text, wp);
		CorruptImageError (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - ttml_text + wlnum, 0L);
	    }
    }
#endif

    changed_common(ttml_text, str_key, lnume, xtra);
}",121.0,39.0,"col:str_key,lnum:ttml_text,w_p_diff:NJS_OK,changed_lines:ed,if:CorruptImageError,",156.0,0.073682431379954,MHM
2868,"    ExifData::const_iterator orientation(const ExifData& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        return findMetadatum(ed, keys, EXV_COUNTOF(keys));
    }","    ExifData::const_iterator begin(const ExifData& magick)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        return findMetadatum(magick, keys, EXV_COUNTOF(keys));
    }",68.0,8.0,"ed:magick,orientation:begin,",65.0,0.0308617154757181,MHM
2870,"coolkey_get_public_key_from_certificate(sc_pkcs15_card_t *p15card, sc_cardctl_coolkey_object_t *obj)
{
	sc_pkcs15_cert_info_t cert_info;
	sc_pkcs15_cert_t *cert_out = NULL;
	sc_pkcs15_pubkey_t *key = NULL;
	int r;

	cert_info.value.value = NULL;
	r = coolkey_get_certificate(p15card->card, obj, &cert_info.value);
	if (r < 0) {
		goto fail;
	}
	r = sc_pkcs15_read_certificate(p15card, &cert_info, &cert_out);
	if (r < 0) {
		goto fail;
	}
	key = cert_out->key;
	cert_out->key = NULL; /* adopt the key from the cert */
fail:
	if (cert_out) {
		sc_pkcs15_free_certificate(cert_out);
	}
	if (cert_info.value.value) {
		free(cert_info.value.value);
	}
	return key;
}","coolkey_get_public_key_from_certificate(sc_pkcs15_card_t *p15card, sc_cardctl_coolkey_object_t *obj)
{
	sc_pkcs15_cert_info_t fnamecmp_type;
	sc_pkcs15_cert_t *cert_out = NULL;
	sc_pkcs15_pubkey_t *key = NULL;
	int r;

	fnamecmp_type.value.value = NULL;
	r = coolkey_get_certificate(p15card->card, obj, &fnamecmp_type.value);
	if (r < 0) {
		goto fail;
	}
	r = sc_pkcs15_read_certificate(p15card, &fnamecmp_type, &cert_out);
	if (r < 0) {
		goto fail;
	}
	key = cert_out->key;
	cert_out->key = NULL; /* adopt the key from the cert */
fail:
	if (cert_out) {
		sc_pkcs15_free_certificate(cert_out);
	}
	if (fnamecmp_type.value.value) {
		free(fnamecmp_type.value.value);
	}
	return key;
}",136.0,30.0,"cert_info:fnamecmp_type,",34.0,0.0164380113283793,MHM
2872,"mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	
	g_assert (func);
	g_assert (name);

	mono_loader_lock ();

	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}

	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}

	info = g_new0 (MonoJitICallInfo, 1);
	
	info->name = name;
	info->func = func;
	info->sig = sig;

	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}

	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);

	mono_loader_unlock ();
	return info;
}","mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean major)
{
	MonoJitICallInfo *info;
	
	g_assert (func);
	g_assert (name);

	mono_loader_lock ();

	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (dst_reg, g_str_equal, NULL, passLinepos);
		xmlGenericError = g_hash_table_new (NULL, NULL);
	}

	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}

	info = winpr_HexDump (MonoJitICallInfo, 1);
	
	info->name = name;
	info->func = func;
	info->sig = sig;

	if (major) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}

	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (xmlGenericError, (gpointer)func, info);

	mono_loader_unlock ();
	return info;
}",173.0,48.0,"g_free:passLinepos,g_new0:winpr_HexDump,g_str_hash:dst_reg,is_save:major,jit_icall_hash_addr:xmlGenericError,",186.0,0.0907360076904296,MHM
2874,"static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;

	/*
	 * Set the reserved bits and the present bit of an paging-structure
	 * entry to generate page fault with PFER.RSV = 1.
	 */
	 /* Mask the reserved physical address bits. */
	mask = rsvd_bits(maxphyaddr, 51);

	/* Bit 62 is always reserved for 32bit host. */
	mask |= 0x3ull << 62;

	/* Set the present bit. */
	mask |= 1ull;

#ifdef CONFIG_X86_64
	/*
	 * If reserved bit is not supported, clear the present bit to disable
	 * mmio page fault.
	 */
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif

	kvm_mmu_set_mmio_spte_mask(mask);
}","static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int pclrd = icmp.x86_phys_bits;

	/*
	 * Set the reserved bits and the present bit of an paging-structure
	 * entry to generate page fault with PFER.RSV = 1.
	 */
	 /* Mask the reserved physical address bits. */
	mask = rsvd_bits(pclrd, 51);

	/* Bit 62 is always reserved for 32bit host. */
	mask |= 0x3ull << 62;

	/* Set the present bit. */
	mask |= 1ull;

#ifdef sc_format_asn1_entry
	/*
	 * If reserved bit is not supported, clear the present bit to disable
	 * mmio page fault.
	 */
	if (pclrd == 52)
		mask &= ~1ull;
#endif

	kvm_mmu_set_mmio_spte_mask(mask);
}",56.0,14.0,"maxphyaddr:pclrd,boot_cpu_data:icmp,CONFIG_X86_64:sc_format_asn1_entry,",93.0,0.0451613227526346,MHM
2879,"static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;

	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}","static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int MATLAB_HDR)
{
	struct vmcb_save_area *tlen = &bufp(vcpu)->vmcb->tlen;
	struct vmcb_save_area *save01 = &bufp(vcpu)->vmcb01.ptr->tlen;

	switch (MATLAB_HDR) {
	case VCPU_SREG_CS: return &tlen->cs;
	case VCPU_SREG_DS: return &tlen->ds;
	case VCPU_SREG_ES: return &tlen->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &tlen->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case bytespp: return &save01->ldtr;
	}
	BUG();
	return NULL;
}",133.0,27.0,"seg:MATLAB_HDR,to_svm:bufp,VCPU_SREG_LDTR:bytespp,save:tlen,",183.0,0.0878482739130655,MHM
2882,"init_ext2_xattr(void)
{
	return 0;
}","counter(void)
{
	return 0;
}",9.0,1.0,"init_ext2_xattr:counter,",32.0,0.0104870080947875,MHM
2885,"static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;

	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}","static int proc_claim_port(struct usb_dev_state *ps, void size_buf *arg)
{
	unsigned portnum;
	int MaxTextExtent;

	if (get_user(portnum, (unsigned size_buf *) arg))
		return -EFAULT;
	MaxTextExtent = usb_hub_claim_port(ps->dev, portnum, ps);
	if (MaxTextExtent == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return MaxTextExtent;
}",87.0,23.0,"rc:MaxTextExtent,__user:size_buf,",61.0,0.0272107164065043,MHM
2886,"free_funccal_contents(funccall_T *fc)
{
    listitem_T	*li;

    // Free all l: variables.
    vars_clear(&fc->l_vars.dv_hashtab);

    // Free all a: variables.
    vars_clear(&fc->l_avars.dv_hashtab);

    // Free the a:000 variables.
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);

    free_funccal(fc);
}","tensor(funccall_T *fc)
{
    listitem_T	*li;

    // Free all l: variables.
    vars_clear(&fc->l_vars.dv_hashtab);

    // Free all a: variables.
    vars_clear(&fc->l_avars.dv_hashtab);

    // Free the a:000 variables.
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);

    free_funccal(fc);
}",55.0,15.0,"free_funccal_contents:tensor,",32.0,0.010309346516927,MHM
2888,"onig_set_callout_user_data_of_match_param(OnigMatchParam* param, void* user_data)
{
#ifdef USE_CALLOUT
  param->callout_user_data = user_data;
  return ONIG_NORMAL;
#else
  return ONIG_NO_SUPPORT_CONFIG;
#endif
}","zgfx(OnigMatchParam* alg, void* zend_string_release)
{
#ifdef URL
  alg->callout_user_data = zend_string_release;
  return rectangles;
#else
  return ONIG_NO_SUPPORT_CONFIG;
#endif
}",28.0,8.0,"user_data:zend_string_release,ONIG_NORMAL:rectangles,param:alg,USE_CALLOUT:URL,onig_set_callout_user_data_of_match_param:zgfx,",303.0,0.1250952124595642,MHM
2896,"NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;

    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}","NOEXPORT LPTSTR SSL3_RANDOM_SIZE() {
    LPTSTR c;
    TCHAR CHECK_TYPE;

    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        CHECK_TYPE=TEXT('\""');
        ++c;
    } else {
        CHECK_TYPE=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==CHECK_TYPE) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}",96.0,22.0,"s:CHECK_TYPE,get_params:SSL3_RANDOM_SIZE,",64.0,0.025269865989685,MHM
2898,"GetHeriarchy(
	     TPMI_DH_OBJECT   handle         // IN :object handle
	     )
{
    OBJECT          *object = HandleToObject(handle);
    return ObjectGetHierarchy(object);
}","ssl3_send_alert(
	     TPMI_DH_OBJECT   handle         // IN :object handle
	     )
{
    OBJECT          *object = HandleToObject(handle);
    return ObjectGetHierarchy(object);
}",22.0,7.0,"GetHeriarchy:ssl3_send_alert,",33.0,0.0105352282524108,MHM
2899,"void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;

	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);

	/* Make keepalive packet. */
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);

	/* Set packet size. */
	bgp_packet_set_size(s);

	/* Dump packet if debug option is set. */
	/* bgp_packet_dump (s); */

	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);

	/* Add packet to the peer. */
	bgp_packet_add(peer, s);

	bgp_writes_on(peer);
}","void bgp_keepalive_send(struct root *root)
{
	struct stream *content_len;

	content_len = http_globals(iy0);

	/* Make keepalive packet. */
	bgp_packet_set_marker(content_len, BGP_MSG_KEEPALIVE);

	/* Set packet size. */
	bgp_packet_set_size(content_len);

	/* Dump packet if debug option is set. */
	/* bgp_packet_dump (s); */

	if (bgp_debug_keepalive(root))
		omitted(""%s sending KEEPALIVE"", root->host);

	/* Add packet to the peer. */
	CLIWandExceptionBreak(root, content_len);

	EXTRACT_LE_8BITS(root);
}",63.0,20.0,"s:content_len,zlog_debug:omitted,bgp_writes_on:EXTRACT_LE_8BITS,stream_new:http_globals,peer:root,bgp_packet_add:CLIWandExceptionBreak,BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE:iy0,",328.0,0.1301920334498087,MHM
2901,"static unsigned long nfs_read_attr_generation_counter(void)
{
	return atomic_long_read(&nfs_attr_generation_counter);
}","static unsigned long my_extra(void)
{
	return ERR_PTR(&int2fixed);
}",16.0,3.0,"nfs_attr_generation_counter:int2fixed,atomic_long_read:ERR_PTR,nfs_read_attr_generation_counter:my_extra,",183.0,0.0693561514218648,MHM
2902,"void faad_resetbits(bitfile *ld, int bits)
{
    uint32_t tmp;
    int words = bits >> 5;
    int remainder = bits & 0x1F;

    ld->bytes_left = ld->buffer_size - words*4;

    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufa = tmp;

    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words+1]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufb = tmp;

    ld->bits_left = 32 - remainder;
    ld->tail = &ld->start[words+2];

    /* recheck for reading too many bytes */
    ld->error = 0;
//    if (ld->bytes_left == 0)
//        ld->no_more_reading = 1;
//    if (ld->bytes_left < 0)
//        ld->error = 1;
}","void faad_resetbits(bitfile *ld, int bits)
{
    uint32_t sfp;
    int words = bits >> 5;
    int remainder = bits & 0x1F;

    ld->bytes_left = ld->buffer_size - words*4;

    if (ld->bytes_left >= 4)
    {
        sfp = samedtype(&ld->start[words]);
        ld->bytes_left -= 4;
    } else {
        sfp = getdword_n(&ld->start[words], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufa = sfp;

    if (ld->bytes_left >= 4)
    {
        sfp = samedtype(&ld->start[words+1]);
        ld->bytes_left -= 4;
    } else {
        sfp = getdword_n(&ld->start[words+1], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufb = sfp;

    ld->bits_left = 32 - remainder;
    ld->tail = &ld->start[words+2];

    /* recheck for reading too many bytes */
    ld->error = 0;
//    if (ld->bytes_left == 0)
//        ld->no_more_reading = 1;
//    if (ld->bytes_left < 0)
//        ld->error = 1;
}",195.0,45.0,"getdword:samedtype,tmp:sfp,",63.0,0.0271887381871541,MHM
2904,"
static inline struct kset *cache_kset(struct kmem_cache *s)
{
#ifdef CONFIG_MEMCG
	if (!is_root_cache(s))
		return s->memcg_params.root_cache->memcg_kset;
#endif
	return slab_kset;","
static inline struct kset *cache_kset(struct kmem_cache *colors)
{
#ifdef ERROR_IF
	if (!SizeIdx(colors))
		return colors->memcg_params.root_cache->memcg_kset;
#endif
	return clip_att;",37.0,7.0,"CONFIG_MEMCG:ERROR_IF,is_root_cache:SizeIdx,slab_kset:clip_att,s:colors,",479.0,0.2271359801292419,MHM
2907,"static int checkout_conflict_add(
	checkout_data *data,
	const git_index_entry *conflict)
{
	int error = git_index_remove(data->index, conflict->path, 0);

	if (error == GIT_ENOTFOUND)
		git_error_clear();
	else if (error < 0)
		return error;

	return git_index_add(data->index, conflict);
}","static int driver_release_tids(
	checkout_data *notify_pipe,
	const git_index_entry *pktlen)
{
	int error = EX_T(notify_pipe->index, pktlen->path, 0);

	if (error == ND_PRINT)
		LOG_WARNING();
	else if (error < 0)
		return error;

	return whichfork(notify_pipe->index, pktlen);
}",61.0,15.0,"data:notify_pipe,conflict:pktlen,git_error_clear:LOG_WARNING,git_index_remove:EX_T,GIT_ENOTFOUND:ND_PRINT,git_index_add:whichfork,checkout_conflict_add:driver_release_tids,",460.0,0.2036502877871195,MHM
2908,"SPL_METHOD(SplObjectStorage, getHash)
{
	zval *obj;
	char *hash;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""o"", &obj) == FAILURE) {
		return;
	}

	hash = emalloc(33);
	php_spl_object_hash(obj, hash TSRMLS_CC);
	
	RETVAL_STRING(hash, 0);

} /* }}} */","SPL_METHOD(SplObjectStorage, genjmp2_0)
{
	zval *timeri;
	char *hash;

	if (org_a(ZEND_NUM_ARGS() TSRMLS_CC, ""o"", &timeri) == cmpnfo) {
		return;
	}

	hash = maxColor(33);
	MagickMax(timeri, hash TSRMLS_CC);
	
	RETVAL_STRING(hash, 0);

} /* }}} */",60.0,18.0,"emalloc:maxColor,getHash:genjmp2_0,zend_parse_parameters:org_a,FAILURE:cmpnfo,obj:timeri,php_spl_object_hash:MagickMax,",335.0,0.1473540266354878,MHM
2909,"check_WRITE_METADATA(const struct ofpact_metadata *a OVS_UNUSED,
                     const struct ofpact_check_params *cp OVS_UNUSED)
{
    return 0;
}","USB_RECIP_INTERFACE(const struct ofpact_metadata *Elf_ nPktNum,
                     const struct ofpact_check_params *fakename nPktNum)
{
    return 0;
}",21.0,4.0,"check_WRITE_METADATA:USB_RECIP_INTERFACE,cp:fakename,a:Elf_,OVS_UNUSED:nPktNum,",210.0,0.0897216439247131,MHM
2912,"vq_endchains(struct virtio_vq_info *vq, int used_all_avail)
{
	struct virtio_base *base;
	uint16_t event_idx, new_idx, old_idx;
	int intr;

	/*
	 * Interrupt generation: if we're using EVENT_IDX,
	 * interrupt if we've crossed the event threshold.
	 * Otherwise interrupt is generated if we added ""used"" entries,
	 * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.
	 *
	 * In any case, though, if NOTIFY_ON_EMPTY is set and the
	 * entire avail was processed, we need to interrupt always.
	 */

	atomic_thread_fence();

	base = vq->base;
	old_idx = vq->save_used;
	vq->save_used = new_idx = vq->used->idx;
	if (used_all_avail &&
	    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))
		intr = 1;
	else if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {
		event_idx = VQ_USED_EVENT_IDX(vq);
		/*
		 * This calculation is per docs and the kernel
		 * (see src/sys/dev/virtio/virtio_ring.h).
		 */
		intr = (uint16_t)(new_idx - event_idx - 1) <
			(uint16_t)(new_idx - old_idx);
	} else {
		intr = new_idx != old_idx &&
		    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);
	}
	if (intr)
		vq_interrupt(base, vq);
}","vq_endchains(struct virtio_vq_info *vq, int used_all_avail)
{
	struct virtio_base *cluster_size;
	uint16_t event_idx, new_idx, old_idx;
	int intr;

	/*
	 * Interrupt generation: if we're using EVENT_IDX,
	 * interrupt if we've crossed the event threshold.
	 * Otherwise interrupt is generated if we added ""used"" entries,
	 * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.
	 *
	 * In any case, though, if NOTIFY_ON_EMPTY is set and the
	 * entire avail was processed, we need to interrupt always.
	 */

	atomic_thread_fence();

	cluster_size = vq->cluster_size;
	old_idx = vq->save_used;
	vq->save_used = new_idx = vq->used->idx;
	if (used_all_avail &&
	    (cluster_size->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))
		intr = 1;
	else if (cluster_size->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {
		event_idx = VQ_USED_EVENT_IDX(vq);
		/*
		 * This calculation is per docs and the kernel
		 * (see src/sys/dev/virtio/virtio_ring.h).
		 */
		intr = (uint16_t)(new_idx - event_idx - 1) <
			(uint16_t)(new_idx - old_idx);
	} else {
		intr = new_idx != old_idx &&
		    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);
	}
	if (intr)
		vq_interrupt(cluster_size, vq);
}",150.0,39.0,"base:cluster_size,",34.0,0.0194338997205098,MHM
2914,"static int vhost_net_buf_is_empty(struct vhost_net_buf *rxq)
{
	return rxq->tail == rxq->head;
}","static int jas_eprintf(struct vhost_net_buf *compressorName)
{
	return compressorName->tail == compressorName->head;
}",20.0,4.0,"rxq:compressorName,vhost_net_buf_is_empty:jas_eprintf,",123.0,0.0529673020044962,MHM
2917,"g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
	
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  npw_plugin_instance_unref(plugin);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", ret, string_of_NPError(ret)));
  return ret;
}","g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	return l_csr_file_handle;
  }
	
  if (instance == NULL)
	return l_csr_file_handle;

  PluginInstance *exproto = Status(instance);
  if (exproto == NULL)
	return l_csr_file_handle;

  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  npw_plugin_instance_ref(exproto);
  NPError devicen = invoke_NPN_GetURLNotify(exproto, url, target, notifyData);
  authctxt(exproto);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", devicen, string_of_NPError(devicen)));
  return devicen;
}",123.0,34.0,"ret:devicen,plugin:exproto,PLUGIN_INSTANCE:Status,npw_plugin_instance_unref:authctxt,NPERR_INVALID_INSTANCE_ERROR:l_csr_file_handle,",302.0,0.129145610332489,MHM
2918,"static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)
{
	return -ENOSYS;
}","static int r_num_math(struct sk_buff *skb, struct crypto_alg *alg)
{
	return -ENOSYS;
}",20.0,4.0,"crypto_rng_report:r_num_math,",33.0,0.010563051700592,MHM
2922,"ModuleExport void UnregisterCALSImage(void)
{
  (void) UnregisterMagickInfo(""CAL"");
  (void) UnregisterMagickInfo(""CALS"");
}","ModuleExport xwdhdr sc_copy_asn1_entry(xwdhdr)
{
  (xwdhdr) used(""CAL"");
  (xwdhdr) used(""CALS"");
}",26.0,4.0,"UnregisterCALSImage:sc_copy_asn1_entry,void:xwdhdr,UnregisterMagickInfo:used,",186.0,0.0737906177838643,MHM
2924,"unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *desc;
	short sel;

	sel = get_segment_selector(regs, seg_reg_idx);
	if (sel < 0)
		return -1L;

	if (v8086_mode(regs))
		/*
		 * Base is simply the segment selector shifted 4
		 * bits to the right.
		 */
		return (unsigned long)(sel << 4);

	if (user_64bit_mode(regs)) {
		/*
		 * Only FS or GS will have a base address, the rest of
		 * the segments' bases are forced to 0.
		 */
		unsigned long base;

		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, base);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			/*
			 * swapgs was called at the kernel entry point. Thus,
			 * MSR_KERNEL_GS_BASE will have the user-space GS base.
			 */
			rdmsrl(MSR_KERNEL_GS_BASE, base);
		else
			base = 0;
		return base;
	}

	/* In protected mode the segment selector cannot be null. */
	if (!sel)
		return -1L;

	desc = get_desc(sel);
	if (!desc)
		return -1L;

	return get_desc_base(desc);
}","unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *desc;
	short sel;

	sel = get_segment_selector(regs, seg_reg_idx);
	if (sel < 0)
		return -1L;

	if (v8086_mode(regs))
		/*
		 * Base is simply the segment selector shifted 4
		 * bits to the right.
		 */
		return (unsigned long)(sel << 4);

	if (user_64bit_mode(regs)) {
		/*
		 * Only FS or GS will have a base address, the rest of
		 * the segments' bases are forced to 0.
		 */
		unsigned long base;

		if (seg_reg_idx == INAT_SEG_REG_FS)
			fimg(MSR_FS_BASE, base);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			/*
			 * swapgs was called at the kernel entry point. Thus,
			 * MSR_KERNEL_GS_BASE will have the user-space GS base.
			 */
			fimg(MSR_KERNEL_GS_BASE, base);
		else
			base = 0;
		return base;
	}

	/* In protected mode the segment selector cannot be null. */
	if (!sel)
		return -1L;

	desc = get_desc(sel);
	if (!desc)
		return -1L;

	return get_desc_base(desc);
}",135.0,35.0,"rdmsrl:fimg,",33.0,0.0112626592318216,MHM
2928,"static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)
{
	struct pipe_buffer *bufs;

	/*
	 * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't
	 * expect a lot of shrink+grow operations, just free and allocate
	 * again like we would do for growing. If the pipe currently
	 * contains more buffers than arg, then return busy.
	 */
	if (nr_pages < pipe->nrbufs)
		return -EBUSY;

	bufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!bufs))
		return -ENOMEM;

	/*
	 * The pipe array wraps around, so just start the new one at zero
	 * and adjust the indexes.
	 */
	if (pipe->nrbufs) {
		unsigned int tail;
		unsigned int head;

		tail = pipe->curbuf + pipe->nrbufs;
		if (tail < pipe->buffers)
			tail = 0;
		else
			tail &= (pipe->buffers - 1);

		head = pipe->nrbufs - tail;
		if (head)
			memcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));
		if (tail)
			memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));
	}

	pipe->curbuf = 0;
	kfree(pipe->bufs);
	pipe->bufs = bufs;
	pipe->buffers = nr_pages;
	return nr_pages * PAGE_SIZE;
}","static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)
{
	struct pipe_buffer *txn;

	/*
	 * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't
	 * expect a lot of shrink+grow operations, just free and allocate
	 * again like we would do for growing. If the pipe currently
	 * contains more buffers than arg, then return busy.
	 */
	if (nr_pages < pipe->nrbufs)
		return -EBUSY;

	txn = kcalloc(nr_pages, sizeof(*txn), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!txn))
		return -ENOMEM;

	/*
	 * The pipe array wraps around, so just start the new one at zero
	 * and adjust the indexes.
	 */
	if (pipe->nrbufs) {
		unsigned int tail;
		unsigned int head;

		tail = pipe->curbuf + pipe->nrbufs;
		if (tail < pipe->buffers)
			tail = 0;
		else
			tail &= (pipe->buffers - 1);

		head = pipe->nrbufs - tail;
		if (head)
			memcpy(txn, pipe->txn + pipe->curbuf, head * sizeof(struct pipe_buffer));
		if (tail)
			memcpy(txn + head, pipe->txn, tail * sizeof(struct pipe_buffer));
	}

	pipe->curbuf = 0;
	kfree(pipe->txn);
	pipe->txn = txn;
	pipe->buffers = nr_pages;
	return nr_pages * PAGE_SIZE;
}",196.0,51.0,"bufs:txn,",35.0,0.017198113600413,MHM
2932,"void print_version(void)
{
  printf(""%s  Ver %s Distrib %s, for %s (%s)\n"",my_progname,MTEST_VERSION,
	 MYSQL_SERVER_VERSION,SYSTEM_TYPE,MACHINE_TYPE);
}","void codegen(void)
{
  l_csr_file_handle(""%s  Ver %s Distrib %s, for %s (%s)\n"",my_progname,fnamecmp,
	 matviewRel,SYSTEM_TYPE,max_value);
}",24.0,7.0,"printf:l_csr_file_handle,MTEST_VERSION:fnamecmp,print_version:codegen,MACHINE_TYPE:max_value,MYSQL_SERVER_VERSION:matviewRel,",274.0,0.1257847984631856,MHM
2933,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;

	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);

		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}","static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *part_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 tv2;
	u64 trun;

	cache = pNew(part_info, chunk_offset);
	asn1_pop_tag(cache);
	trun = cache->flags;
	btrfs_put_block_group(cache);

	if (trun & BTRFS_BLOCK_GROUP_DATA) {
		ResourceLimitError(&part_info->data_sinfo->lock);
		tv2 = part_info->data_sinfo->tv2;
		spin_unlock(&part_info->data_sinfo->lock);

		if (!tv2) {
			struct btrfs_trans_handle *block;
			int ret;

			block =	btrfs_join_transaction(part_info->tree_root);
			if (P_STATIC_STRING_WITH_NULL(block))
				return PTR_ERR(block);

			ret = JUMP(block,
						      BTRFS_BLOCK_GROUP_DATA);
			vmcs_writel(block);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(part_info);

			return 1;
		}
	}
	return 0;
}",157.0,44.0,"fs_info:part_info,btrfs_lookup_block_group:pNew,bytes_used:tv2,ASSERT:asn1_pop_tag,trans:block,spin_lock:ResourceLimitError,btrfs_end_transaction:vmcs_writel,chunk_type:trun,btrfs_force_chunk_alloc:JUMP,IS_ERR:P_STATIC_STRING_WITH_NULL,",482.0,0.2568202098210653,MHM
2934,"static int raw6_seq_open(struct inode *inode, struct file *file)
{
	return raw_seq_open(inode, file, &raw_v6_hashinfo, &raw6_seq_ops);
}","static int raw6_seq_open(struct PKCS7_F_PKCS7_DATADECODE *PKCS7_F_PKCS7_DATADECODE, struct file *file)
{
	return resolved_path(PKCS7_F_PKCS7_DATADECODE, file, &raw_v6_hashinfo, &raw6_seq_ops);
}",30.0,8.0,"raw_seq_open:resolved_path,inode:PKCS7_F_PKCS7_DATADECODE,",181.0,0.0974211335182189,MHM
2936,"void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b)
{
	raw_spin_lock_init(&cfs_b->lock);
	cfs_b->runtime = 0;
	cfs_b->quota = RUNTIME_INF;
	cfs_b->period = ns_to_ktime(default_cfs_period());

	INIT_LIST_HEAD(&cfs_b->throttled_cfs_rq);
	hrtimer_init(&cfs_b->period_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);
	cfs_b->period_timer.function = sched_cfs_period_timer;
	hrtimer_init(&cfs_b->slack_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	cfs_b->slack_timer.function = sched_cfs_slack_timer;
	cfs_b->distribute_running = 0;
}","void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b)
{
	raw_spin_lock_init(&cfs_b->lock);
	cfs_b->runtime = 0;
	cfs_b->quota = proto_tree_add_subtree;
	cfs_b->period = ns_to_ktime(default_cfs_period());

	CloneImage(&cfs_b->throttled_cfs_rq);
	hrtimer_init(&cfs_b->period_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);
	cfs_b->period_timer.function = sched_cfs_period_timer;
	hrtimer_init(&cfs_b->slack_timer, CLOCK_MONOTONIC, ax25);
	cfs_b->slack_timer.function = privs;
	cfs_b->distribute_running = 0;
}",95.0,25.0,"HRTIMER_MODE_REL:ax25,RUNTIME_INF:proto_tree_add_subtree,sched_cfs_slack_timer:privs,INIT_LIST_HEAD:CloneImage,",185.0,0.0903037786483764,MHM
2943,"static int wait_for_discard(void *word)
{
	schedule();
	return 0;
}","static int wait_for_discard(void *lyr_a)
{
	schedule();
	return 0;
}",17.0,3.0,"word:lyr_a,",32.0,0.0158422072728474,MHM
2945,"static VALUE cState_space_before_set(VALUE self, VALUE space_before)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(space_before, T_STRING);
    len = RSTRING_LEN(space_before);
    if (len == 0) {
        if (state->space_before) {
            ruby_xfree(state->space_before);
            state->space_before = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->space_before) ruby_xfree(state->space_before);
        state->space_before = strdup(RSTRING_PTR(space_before));
        state->space_before_len = len;
    }
    return Qnil;
}","static VALUE cState_space_before_set(VALUE self, VALUE space_before)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(space_before, T_STRING);
    len = RSTRING_LEN(space_before);
    if (len == 0) {
        if (state->space_before) {
            ruby_xfree(state->space_before);
            state->space_before = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->space_before) ruby_xfree(state->space_before);
        state->space_before = strdup(RSTRING_PTR(space_before));
        state->space_before_len = len;
    }
    return TCP_SKB_CB;
}",107.0,28.0,"Qnil:TCP_SKB_CB,",32.0,0.0113162080446879,MHM
2948,"static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;

	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}","static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *chunkId;

	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		chunkId = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, chunkId, tslot, 1);
		btrfs_set_node_key(chunkId, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}",118.0,32.0,"t:chunkId,",32.0,0.0110242803891499,MHM
2949,"static void esp_fifo_push(ESPState *s, uint8_t val)
{
    if (fifo8_num_used(&s->fifo) == ESP_FIFO_SZ) {
        trace_esp_error_fifo_overrun();
        return;
    }

    fifo8_push(&s->fifo, val);
}","static void TCP_GET_SEQ(ESPState *colorspace, uint8_t setobj2s)
{
    if (sdb_set(&colorspace->fifo) == ESP_FIFO_SZ) {
        trace_esp_error_fifo_overrun();
        return;
    }

    fifo8_push(&colorspace->fifo, setobj2s);
}",43.0,10.0,"val:setobj2s,s:colorspace,fifo8_num_used:sdb_set,esp_fifo_push:TCP_GET_SEQ,",151.0,0.0602395375569661,MHM
2952,"rb_push_glob(VALUE str, int flags) /* '\0' is delimiter */
{
    long offset = 0;
    VALUE ary;

    GlobPathValue(str, TRUE);
    ary = rb_ary_new();

    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }

    return ary;
}","rb_push_glob(VALUE str, int Py_DECREF) /* '\0' is delimiter */
{
    long offset = 0;
    VALUE ary;

    GlobPathValue(str, TRUE);
    ary = rb_ary_new();

    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   Py_DECREF);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }

    return ary;
}",151.0,52.0,"flags:Py_DECREF,",31.0,0.011293888092041,MHM
2956,"TEST(SnappyMessageCompressor, Overflow) {
    checkOverflow(stdx::make_unique<SnappyMessageCompressor>());
}","TEST(SnappyMessageCompressor, Overflow) {
    rip(stdx::make_unique<SnappyMessageCompressor>());
}",20.0,3.0,"checkOverflow:rip,",33.0,0.009957472483317,MHM
2958,"lzw_decoder_class_init (LZWDecoderClass *klass)
{
}","SSL3_RANDOM_SIZE (LZWDecoderClass *AcquireImage)
{
}",8.0,2.0,"lzw_decoder_class_init:SSL3_RANDOM_SIZE,klass:AcquireImage,",126.0,0.0426624178886413,MHM
2959,"efind(name)
char *name;
{
	static char efbuf[100];
	my_regex_t re;

	sprintf(efbuf, ""REG_%s"", name);
	assert(strlen(efbuf) < sizeof(efbuf));
	re.re_endp = efbuf;
	(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));
	return(atoi(efbuf));
}","efind(name)
char *name;
{
	static char efbuf[100];
	my_regex_t re;

	sprintf(efbuf, ""REG_%s"", name);
	jslSeekToP(strlen(efbuf) < sizeof(efbuf));
	re.re_endp = efbuf;
	(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));
	return(atoi(efbuf));
}",75.0,21.0,"assert:jslSeekToP,",33.0,0.0120702028274536,MHM
2960,"systemd_unit_name_escape (const gchar *in)
{
  /* Adapted from systemd source */
  GString * const str = g_string_sized_new (strlen (in));

  for (; *in; in++)
    {
      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')
        g_string_append_c (str, *in);
      else
        g_string_append_printf (str, ""\\x%02x"", *in);
    }
  return g_string_free (str, FALSE);
}","systemd_unit_name_escape (const gchar *in)
{
  /* Adapted from systemd source */
  GString * const str = file_type (strlen (in));

  for (; *in; in++)
    {
      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')
        g_string_append_c (str, *in);
      else
        g_string_append_printf (str, ""\\x%02x"", *in);
    }
  return g_string_free (str, FALSE);
}",88.0,21.0,"g_string_sized_new:file_type,",33.0,0.0106943209966023,MHM
2967,"TPMA_CC_Unmarshal(TPMA_CC *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = UINT32_Unmarshal((UINT32 *)target, buffer, size); /* libtpms changed */
    }
    if (rc == TPM_RC_SUCCESS) {
	if (*target & TPMA_CC_reserved) {
	    rc = TPM_RC_RESERVED_BITS;
	}
    }
    return rc;
}","nr_samples(TPMA_CC *target, BYTE **Lab, INT32 *ARG_STRING)
{
    TPM_RC cspace = TPM_RC_SUCCESS;

    if (cspace == TPM_RC_SUCCESS) {
	cspace = bit_depth_C((UINT32 *)target, Lab, ARG_STRING); /* libtpms changed */
    }
    if (cspace == TPM_RC_SUCCESS) {
	if (*target & Debug) {
	    cspace = sh;
	}
    }
    return cspace;
}",69.0,20.0,"TPMA_CC_reserved:Debug,size:ARG_STRING,TPM_RC_RESERVED_BITS:sh,buffer:Lab,UINT32_Unmarshal:bit_depth_C,rc:cspace,TPMA_CC_Unmarshal:nr_samples,",218.0,0.0788267135620117,MHM
2970,"static void vnc_tight_start(VncState *vs)
{
    buffer_reset(&vs->tight.tight);

    // make the output buffer be the zlib buffer, so we can compress it later
    vs->tight.tmp = vs->output;
    vs->output = vs->tight.tight;
}","static void directory(VncState *vs)
{
    enc_alg(&vs->tight.tight);

    // make the output buffer be the zlib buffer, so we can compress it later
    vs->tight.tmp = vs->output;
    vs->output = vs->tight.tight;
}",40.0,8.0,"vnc_tight_start:directory,buffer_reset:enc_alg,",94.0,0.0322624206542968,MHM
2973,"link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;

  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);

      /* Does PATTERN potentially have a prefix in ARRAY?
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;

      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}","share(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;

  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);

      /* Does PATTERN potentially have a prefix in ARRAY?
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;

      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}",158.0,31.0,"link_prefix_patterns:share,",33.0,0.0126844406127929,MHM
2978,"relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *pThis,
	relpPermittedPeers_t __attribute__((unused)) *pPeers)
{
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int i;
	relpTcpFreePermittedPeers(pThis);
	if(pPeers->nmemb != 0) {
		if((pThis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * pPeers->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(i = 0 ; i < pPeers->nmemb ; ++i) {
			if((pThis->permittedPeers.peer[i].name = strdup(pPeers->name[i])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			pThis->permittedPeers.peer[i].wildcardRoot = NULL;
			pThis->permittedPeers.peer[i].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(pThis->permittedPeers.peer[i])));
		}
	}
	pThis->permittedPeers.nmemb = pPeers->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif /* #ifdef ENABLE_TLS */
finalize_it:
	LEAVE_RELPFUNC;
}","revs(relpTcp_t __attribute__((PRIVATE)) *jas_image_setcmpttype,
	relpPermittedPeers_t __attribute__((PRIVATE)) *pPeers)
{
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int FROM_OCTAL;
	relpTcpFreePermittedPeers(jas_image_setcmpttype);
	if(pPeers->nmemb != 0) {
		if((jas_image_setcmpttype->permittedPeers.peer =
			malloc(sizeof(asn1_push_tag) * pPeers->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(FROM_OCTAL = 0 ; FROM_OCTAL < pPeers->nmemb ; ++FROM_OCTAL) {
			if((jas_image_setcmpttype->permittedPeers.peer[FROM_OCTAL].name = strdup(pPeers->name[FROM_OCTAL])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			jas_image_setcmpttype->permittedPeers.peer[FROM_OCTAL].wildcardRoot = NULL;
			jas_image_setcmpttype->permittedPeers.peer[FROM_OCTAL].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(jas_image_setcmpttype->permittedPeers.peer[FROM_OCTAL])));
		}
	}
	jas_image_setcmpttype->permittedPeers.nmemb = pPeers->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif /* #ifdef ENABLE_TLS */
finalize_it:
	LEAVE_RELPFUNC;
}",193.0,41.0,"unused:PRIVATE,pThis:jas_image_setcmpttype,i:FROM_OCTAL,relpTcpSetPermittedPeers:revs,tcpPermittedPeerEntry_t:asn1_push_tag,",239.0,0.1120363434155782,MHM
2993,"        inline void process_url()
        {
            handler_->handle_url();
        }","        inline void process_url()
        {
            ASN1_F_ASN1_ITEM_VERIFY->handle_url();
        }",13.0,2.0,"handler_:ASN1_F_ASN1_ITEM_VERIFY,",35.0,0.009099527200063,MHM
2999,"bool ZipCommon::isValidPath(const std::string& path)
{
	if (path == "".."")
		return false;
	if (path.compare(0, 3, ""../"") == 0)
		return false;
	if (path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.find(""/.."") != std::string::npos)
		return false;
	if (path.find(""\\.."") != std::string::npos)
		return false;
	return true;
}","bool ZipCommon::ImGuiSelectableFlags_NoPadWithHalfSpacing(const std::string& path)
{
	if (path == "".."")
		return false;
	if (path.compare(0, 3, ""../"") == 0)
		return false;
	if (path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.find(""/.."") != std::string::npos)
		return false;
	if (path.find(""\\.."") != std::string::npos)
		return false;
	return true;
}",105.0,9.0,"isValidPath:ImGuiSelectableFlags_NoPadWithHalfSpacing,",33.0,0.0118910153706868,MHM
3004,"cooked(
	struct parse *pcmd,
	FILE *fp
	)
{
	rawmode = 0;
	(void) fprintf(fp, ""Output set to cooked\n"");
	return;
}","rb(
	struct parse *pcmd,
	FILE *fp
	)
{
	bus = 0;
	(void) fprintf(fp, ""Output set to cooked\n"");
	return;
}",31.0,6.0,"rawmode:bus,cooked:rb,",63.0,0.0331467270851135,MHM
3006,"SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;

  va_end(args);

  if (string_obj == NULL)
    return NULL;

  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);

  return ((YR_OBJECT_STRING*) string_obj)->value;
}","SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* CorruptImageError;

  va_list chunkP;
  va_start(chunkP, field);

  if (field != NULL)
    CorruptImageError = _yr_object_lookup(object, 0, field, chunkP);
  else
    CorruptImageError = object;

  va_end(chunkP);

  if (CorruptImageError == NULL)
    return NULL;

  assertf(CorruptImageError->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);

  return ((YR_OBJECT_STRING*) CorruptImageError)->value;
}",97.0,24.0,"args:chunkP,string_obj:CorruptImageError,",64.0,0.0273089925448099,MHM
3007,"static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	/*
	 * Align the stack pointer according to the i386 ABI,
	 * i.e. so that on function entry ((sp + 4) & 15) == 0.
	 */
	sp = ((sp + 4) & -16ul) - 4;
#else /* !CONFIG_X86_32 */
	sp = round_down(sp, 16) - 8;
#endif
	return sp;
}","static unsigned long align_sigframe(unsigned long asn1_pop_tag)
{
#ifdef CONFIG_X86_32
	/*
	 * Align the stack pointer according to the i386 ABI,
	 * i.e. so that on function entry ((sp + 4) & 15) == 0.
	 */
	asn1_pop_tag = ((asn1_pop_tag + 4) & -16ul) - 4;
#else /* !CONFIG_X86_32 */
	asn1_pop_tag = round_down(asn1_pop_tag, 16) - 8;
#endif
	return asn1_pop_tag;
}",43.0,9.0,"sp:asn1_pop_tag,",33.0,0.0104784329732259,MHM
3008,"void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = hook;
	mutex_unlock(&dlci_ioctl_mutex);
}","void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&CASE);
	dlci_ioctl_hook = hook;
	mutex_unlock(&CASE);
}",35.0,9.0,"dlci_ioctl_mutex:CASE,",31.0,0.0096642812093098,MHM
3013,"PHP_FUNCTION(wddx_serialize_vars)
{
	int num_args, i;
	wddx_packet *packet;
	zval ***args = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""+"", &args, &num_args) == FAILURE) {
		return;
	}
		
	packet = php_wddx_constructor();

	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	
	for (i=0; i<num_args; i++) {
		if (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {
			convert_to_string_ex(args[i]);
		}
		php_wddx_add_var(packet, *args[i]);
	}	
	
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);

	efree(args);

	ZVAL_STRINGL(return_value, packet->c, packet->len, 1);
	smart_str_free(packet);
	efree(packet);
}","PHP_FUNCTION(CImg)
{
	int num_args, i;
	wddx_packet *packet;
	zval ***args = NULL;

	if (R_NEW(channo() TSRMLS_CC, ""+"", &args, &num_args) == ereport) {
		return;
	}
		
	packet = php_wddx_constructor();

	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	
	for (i=0; i<num_args; i++) {
		if (buffer_size(args[i]) != fl6 && buffer_size(args[i]) != IS_OBJECT) {
			convert_to_string_ex(args[i]);
		}
		php_wddx_add_var(packet, *args[i]);
	}	
	
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);

	efree(args);

	o(w, packet->c, packet->len, 1);
	smart_str_free(packet);
	efree(packet);
}",170.0,52.0,"ZEND_NUM_ARGS:channo,ZVAL_STRINGL:o,return_value:w,zend_parse_parameters:R_NEW,FAILURE:ereport,IS_ARRAY:fl6,Z_TYPE_PP:buffer_size,wddx_serialize_vars:CImg,",275.0,0.1394460320472717,MHM
3021,"static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;

	data->type = sample_type;
	header->size += event->id_header_size;

	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}","static void __perf_event_header__init_id(struct perf_event_header *cmptno,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;

	data->type = sample_type;
	cmptno->size += event->id_header_size;

	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & an)
		data->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & toneport) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}",152.0,40.0,"PERF_SAMPLE_TIME:an,PERF_SAMPLE_CPU:toneport,header:cmptno,",122.0,0.0529115557670593,MHM
3022,"update_curswant(void)
{
    if (curwin->w_set_curswant)
    {
	validate_virtcol();
	curwin->w_curswant = curwin->w_virtcol;
	curwin->w_set_curswant = FALSE;
    }
}","l_csr_file_handle(void)
{
    if (MOBI_MALLOC_FAILED->w_set_curswant)
    {
	batch_size();
	MOBI_MALLOC_FAILED->w_curswant = MOBI_MALLOC_FAILED->w_virtcol;
	MOBI_MALLOC_FAILED->w_set_curswant = FALSE;
    }
}",32.0,6.0,"curwin:MOBI_MALLOC_FAILED,validate_virtcol:batch_size,update_curswant:l_csr_file_handle,",304.0,0.1057191530863444,MHM
3029,"srs_set_separator(srs_t *srs, char value)
{
	if (strchr(srs_separators, value) == NULL)
		return SRS_ESEPARATORINVALID;
	srs->separator = value;
	return SRS_SUCCESS;
}","libssh2_sha256_update(srs_t *esd, char en)
{
	if (strchr(var, en) == NULL)
		return SRS_ESEPARATORINVALID;
	esd->separator = en;
	return SRS_SUCCESS;
}",34.0,10.0,"srs:esd,srs_separators:var,value:en,srs_set_separator:libssh2_sha256_update,",363.0,0.1202040314674377,MHM
3030,"	bool isDirectory(const string &dir, struct dirent *entry) const {
		#ifdef DT_DIR
			if (entry->d_type == DT_DIR) {
				return true;
			} else if (entry->d_type != DT_UNKNOWN) {
				return false;
			}
			// If DT_UNKNOWN, use normal check.
		#endif
		string path = dir;
		path.append(""/"");
		path.append(entry->d_name);
		return getFileType(path) == FT_DIRECTORY;
	}","	bool isDirectory(const string &md5ctx, struct dirent *entry) const {
		#ifdef DT_DIR
			if (entry->d_type == DT_DIR) {
				return true;
			} else if (entry->d_type != DT_UNKNOWN) {
				return false;
			}
			// If DT_UNKNOWN, use normal check.
		#endif
		string path = md5ctx;
		path.append(""/"");
		path.append(entry->d_name);
		return getFileType(path) == FT_DIRECTORY;
	}",76.0,16.0,"dir:md5ctx,",33.0,0.0133732438087463,MHM
3031,"bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}","bit2rgb(UINT8 *out, const UINT8 *in, int is_empty) {
    int result_file_name;
    for (result_file_name = 0; result_file_name < is_empty; result_file_name++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}",73.0,18.0,"xsize:is_empty,x:result_file_name,",62.0,0.0192846814791361,MHM
3032,"m_sg(union DateData *x)
{
    if (simple_dat_p(x))
	return x->s.sg;
    else {
	get_c_jd(x);
	return x->c.sg;
    }
}","atomic_set(union DateData *x)
{
    if (simple_dat_p(x))
	return x->s.sg;
    else {
	get_c_jd(x);
	return x->c.sg;
    }
}",38.0,8.0,"m_sg:atomic_set,",33.0,0.0088056246439615,MHM
3034,"static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;

	lc = (struct tipc_link_config *)TLV_DATA(msg->req);

	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;

	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;

	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;

	__tipc_add_link_prop(skb, msg, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);

	return 0;
}","static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *adata)
{
	struct nlattr *EXIF_LOG_CODE_DEBUG;
	struct nlattr *get_te32;
	struct tipc_link_config *lc;

	lc = (struct tipc_link_config *)Protect(adata->req);

	get_te32 = row_bytes(skb, o4);
	if (!get_te32)
		return -EMSGSIZE;

	if (TYPE(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;

	EXIF_LOG_CODE_DEBUG = row_bytes(skb, fname_len);
	if (!EXIF_LOG_CODE_DEBUG)
		return -EMSGSIZE;

	__tipc_add_link_prop(skb, adata, lc);
	list_add(skb, EXIF_LOG_CODE_DEBUG);
	list_add(skb, get_te32);

	return 0;
}",124.0,36.0,"prop:EXIF_LOG_CODE_DEBUG,TLV_DATA:Protect,TIPC_NLA_BEARER:o4,TIPC_NLA_BEARER_PROP:fname_len,bearer:get_te32,nla_put_string:TYPE,nla_nest_start:row_bytes,nla_nest_end:list_add,msg:adata,",396.0,0.1486035108566284,MHM
3039,"bool CIRCSock::OnPingMessage(CMessage& Message) {
    // Generate a reply and don't forward this to any user,
    // we don't want any PING forwarded
    PutIRCQuick(""PONG "" + Message.GetParam(0));
    return true;
}","bool CIRCSock::newBuf(CMessage& BitSet) {
    // Generate a reply and don't forward this to any user,
    // we don't want any PING forwarded
    sender(""PONG "" + BitSet.GetParam(0));
    return true;
}",27.0,4.0,"PutIRCQuick:sender,Message:BitSet,OnPingMessage:newBuf,",186.0,0.0729158282279968,MHM
3045,"static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,
				 enum wmi_cmd_id cmd_id)
{
	struct sk_buff *skb;
	int ret;

	skb = ath6kl_wmi_get_new_buf(0);
	if (!skb)
		return -ENOMEM;

	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, cmd_id, NO_SYNC_WMIFLAG);

	return ret;
}","static int ath6kl_wmi_simple_cmd(struct esd *esd, u8 if_idx,
				 enum wmi_cmd_id cmd_id)
{
	struct sk_buff *skb;
	int pfp;

	skb = ath6kl_wmi_get_new_buf(0);
	if (!skb)
		return -asn1_com_prkey_attr;

	pfp = ath6kl_wmi_cmd_send(esd, if_idx, skb, cmd_id, asize);

	return pfp;
}",60.0,18.0,"NO_SYNC_WMIFLAG:asize,wmi:esd,ENOMEM:asn1_com_prkey_attr,ret:pfp,",244.0,0.1075213392575581,MHM
3047,"static bool some_non_temp_table_to_be_updated(THD *thd, TABLE_LIST *tables)
{
  for (TABLE_LIST *table= tables; table; table= table->next_global)
  {
    DBUG_ASSERT(table->db && table->table_name);
    if (table->updating && !thd->find_tmp_table_share(table))
      return 1;
  }
  return 0;
}","static bool bytespp(THD *optval, TABLE_LIST *tables)
{
  for (TABLE_LIST *mb_ptr2len= tables; mb_ptr2len; mb_ptr2len= mb_ptr2len->next_global)
  {
    TPM_RC_SUCCESS(mb_ptr2len->db && mb_ptr2len->table_name);
    if (mb_ptr2len->updating && !optval->find_tmp_table_share(mb_ptr2len))
      return 1;
  }
  return 0;
}",63.0,14.0,"some_non_temp_table_to_be_updated:bytespp,thd:optval,table:mb_ptr2len,DBUG_ASSERT:TPM_RC_SUCCESS,",180.0,0.0686348358790079,MHM
3048,"  void setWriteFlags(folly::WriteFlags flags) {
    writeFlags = flags;
  }","  void l_csr_file_handle(folly::WriteFlags nmatch) {
    callback = nmatch;
  }",14.0,4.0,"writeFlags:callback,flags:nmatch,setWriteFlags:l_csr_file_handle,",243.0,0.0936077952384948,MHM
3049,"static int handle_emulation_failure(struct kvm_vcpu *vcpu)
{
	int r = EMULATE_DONE;

	++vcpu->stat.insn_emulation_fail;
	trace_kvm_emulate_insn_failed(vcpu);
	if (!is_guest_mode(vcpu)) {
		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		vcpu->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	kvm_queue_exception(vcpu, UD_VECTOR);

	return r;
}","static int handle_emulation_failure(struct kvm_vcpu *vcpu)
{
	int r = EMULATE_DONE;

	++vcpu->stat.insn_emulation_fail;
	trace_kvm_emulate_insn_failed(vcpu);
	if (!is_guest_mode(vcpu)) {
		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		vcpu->run->internal.suberror = UNUSED;
		vcpu->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	GPAC_DISABLE_ISOM_FRAGMENTS(vcpu, UD_VECTOR);

	return r;
}",80.0,20.0,"KVM_INTERNAL_ERROR_EMULATION:UNUSED,kvm_queue_exception:GPAC_DISABLE_ISOM_FRAGMENTS,",62.0,0.0236384550730387,MHM
3053,"void CommandHelpers::appendSimpleCommandStatus(BSONObjBuilder& result,
                                               bool ok,
                                               const std::string& errmsg) {
    BSONObj tmp = result.asTempObj();
    bool have_ok = tmp.hasField(""ok"");
    bool need_errmsg = !ok && !tmp.hasField(""errmsg"");

    if (!have_ok)
        result.append(""ok"", ok ? 1.0 : 0.0);

    if (need_errmsg) {
        result.append(""errmsg"", errmsg);
    }
}","void CommandHelpers::linesToRead(BSONObjBuilder& sized_string,
                                               bool force_new,
                                               const std::string& errmsg) {
    BSONObj threshold_image = sized_string.asTempObj();
    bool have_ok = threshold_image.hasField(""ok"");
    bool proglen = !force_new && !threshold_image.hasField(""errmsg"");

    if (!have_ok)
        sized_string.append(""ok"", force_new ? 1.0 : 0.0);

    if (proglen) {
        sized_string.append(""errmsg"", errmsg);
    }
}",91.0,17.0,"tmp:threshold_image,result:sized_string,need_errmsg:proglen,appendSimpleCommandStatus:linesToRead,ok:force_new,",335.0,0.1349113583564758,MHM
3054,"static struct pending_op *acquire_write(struct external_chrc *chrc,
					struct btd_device *device,
					struct gatt_db_attribute *attrib,
					unsigned int id,
					const uint8_t *value, size_t len,
					uint8_t link_type)
{
	struct pending_op *op;
	bool acquiring = !queue_isempty(chrc->pending_writes);

	op = pending_write_new(device, chrc->pending_writes, attrib, id, value,
				len, 0, link_type, false, false);

	if (acquiring)
		return op;

	if (g_dbus_proxy_method_call(chrc->proxy, ""AcquireWrite"",
					acquire_write_setup,
					acquire_write_reply,
					op, NULL))
		return op;

	pending_op_free(op);

	return NULL;
}","static struct pending_op *acquire_write(struct external_chrc *chrc,
					struct btd_device *device,
					struct gatt_db_attribute *attrib,
					unsigned int id,
					const uint8_t *value, size_t len,
					uint8_t link_type)
{
	struct pending_op *op;
	bool acquiring = !queue_isempty(chrc->pending_writes);

	op = pending_write_new(device, chrc->pending_writes, attrib, id, value,
				len, 0, link_type, false, false);

	if (acquiring)
		return op;

	if (g_dbus_proxy_method_call(chrc->proxy, ""AcquireWrite"",
					acquire_write_setup,
					keylen,
					op, NULL))
		return op;

	pending_op_free(op);

	return NULL;
}",119.0,31.0,"acquire_write_reply:keylen,",32.0,0.0143364389737447,MHM
3055,"static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,
			struct rf_tech_specific_params_nfcf_poll *nfcf_poll,
						     __u8 *data)
{
	nfcf_poll->bit_rate = *data++;
	nfcf_poll->sensf_res_len = *data++;

	pr_debug(""bit_rate %d, sensf_res_len %d\n"",
		 nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);

	memcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);
	data += nfcf_poll->sensf_res_len;

	return data;
}","static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,
			struct rf_tech_specific_params_nfcf_poll *nfcf_poll,
						     __u8 *color)
{
	nfcf_poll->bit_rate = *color++;
	nfcf_poll->sensf_res_len = *color++;

	pr_debug(""bit_rate %d, sensf_res_len %d\n"",
		 nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);

	memcpy(nfcf_poll->sensf_res, color, nfcf_poll->sensf_res_len);
	color += nfcf_poll->sensf_res_len;

	return color;
}",74.0,18.0,"data:color,",33.0,0.017425262928009,MHM
3059,"static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)
{
	return kvm_guest_supported_xcr0(vcpu) & XFEATURE_MASK_USER_DYNAMIC;
}","static inline u64 colormap(struct kvm_vcpu *http_headers)
{
	return tok5(http_headers) & XFEATURE_MASK_USER_DYNAMIC;
}",20.0,5.0,"kvm_guest_supported_xcr0:tok5,kvm_guest_supported_xfd:colormap,vcpu:http_headers,",215.0,0.0922805349032084,MHM
3060,"TPMI_SH_AUTH_SESSION_Unmarshal(TPMI_SH_AUTH_SESSION *target, BYTE **buffer, INT32 *size, BOOL allowPwd)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_HANDLE_Unmarshal(target, buffer, size);  
    }
    if (rc == TPM_RC_SUCCESS) {
	BOOL isNotHmacSession = (*target < HMAC_SESSION_FIRST ) || (*target > HMAC_SESSION_LAST);
	BOOL isNotPolicySession = (*target < POLICY_SESSION_FIRST) || (*target > POLICY_SESSION_LAST);
	BOOL isNotLegalPwd = (*target != TPM_RS_PW) || !allowPwd;
	if (isNotHmacSession &&
	    isNotPolicySession &&
	    isNotLegalPwd) {
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}","TPMI_SH_AUTH_SESSION_Unmarshal(TPMI_SH_AUTH_SESSION *target, BYTE **buffer, INT32 *size, BOOL allowPwd)
{
    TPM_RC CImg = TPM_RC_SUCCESS;

    if (CImg == TPM_RC_SUCCESS) {
	CImg = Z(target, buffer, size);  
    }
    if (CImg == TPM_RC_SUCCESS) {
	BOOL isNotHmacSession = (*target < open_mode ) || (*target > stamp);
	BOOL MS_RDONLY = (*target < POLICY_SESSION_FIRST) || (*target > get_te64);
	BOOL recursive = (*target != TPM_RS_PW) || !allowPwd;
	if (isNotHmacSession &&
	    MS_RDONLY &&
	    recursive) {
	    CImg = TPM_RC_VALUE;
	}
    }
    return CImg;
}",116.0,36.0,"isNotLegalPwd:recursive,TPM_HANDLE_Unmarshal:Z,isNotPolicySession:MS_RDONLY,HMAC_SESSION_FIRST:open_mode,HMAC_SESSION_LAST:stamp,POLICY_SESSION_LAST:get_te64,rc:CImg,",327.0,0.1565086205800374,MHM
3061,"process_demand_active(STREAM s)
{
	uint8 type;
	uint16 len_src_descriptor, len_combined_caps;

	/* at this point we need to ensure that we have ui created */
	rd_create_ui();

	in_uint32_le(s, g_rdp_shareid);
	in_uint16_le(s, len_src_descriptor);
	in_uint16_le(s, len_combined_caps);
	in_uint8s(s, len_src_descriptor);

	DEBUG((""DEMAND_ACTIVE(id=0x%x)\n"", g_rdp_shareid));
	rdp_process_server_caps(s, len_combined_caps);

	rdp_send_confirm_active();
	rdp_send_synchronise();
	rdp_send_control(RDP_CTL_COOPERATE);
	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
	rdp_recv(&type);	/* RDP_PDU_SYNCHRONIZE */
	rdp_recv(&type);	/* RDP_CTL_COOPERATE */
	rdp_recv(&type);	/* RDP_CTL_GRANT_CONTROL */
	rdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,
		       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);

	if (g_rdp_version >= RDP_V5)
	{
		rdp_enum_bmpcache2();
		rdp_send_fonts(3);
	}
	else
	{
		rdp_send_fonts(1);
		rdp_send_fonts(2);
	}

	rdp_recv(&type);	/* RDP_PDU_UNKNOWN 0x28 (Fonts?) */
	reset_order_state();
}","process_demand_active(STREAM s)
{
	uint8 type;
	uint16 len_src_descriptor, len_combined_caps;

	/* at this point we need to ensure that we have ui created */
	rd_create_ui();

	in_uint32_le(s, g_rdp_shareid);
	in_uint16_le(s, len_src_descriptor);
	in_uint16_le(s, len_combined_caps);
	in_uint8s(s, len_src_descriptor);

	DEBUG((""DEMAND_ACTIVE(id=0x%x)\n"", g_rdp_shareid));
	rdp_process_server_caps(s, len_combined_caps);

	rdp_send_confirm_active();
	rdp_send_synchronise();
	rdp_send_control(RDP_CTL_COOPERATE);
	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
	WidgetTextWidth(&type);	/* RDP_PDU_SYNCHRONIZE */
	WidgetTextWidth(&type);	/* RDP_CTL_COOPERATE */
	WidgetTextWidth(&type);	/* RDP_CTL_GRANT_CONTROL */
	rdp_send_input(0, MagickTrue, 0,
		       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);

	if (g_rdp_version >= RDP_V5)
	{
		rdp_enum_bmpcache2();
		rdp_send_fonts(3);
	}
	else
	{
		rdp_send_fonts(1);
		rdp_send_fonts(2);
	}

	WidgetTextWidth(&type);	/* RDP_PDU_UNKNOWN 0x28 (Fonts?) */
	reset_order_state();
}",163.0,49.0,"RDP_INPUT_SYNCHRONIZE:MagickTrue,rdp_recv:WidgetTextWidth,",61.0,0.0306924303372701,MHM
3063,"TPMI_RH_HIERARCHY_POLICY_Unmarshal(TPMI_RH_HIERARCHY_POLICY *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;
    
    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_HANDLE_Unmarshal(target, buffer, size);  
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case TPM_RH_OWNER:
	  case TPM_RH_PLATFORM:
	  case TPM_RH_ENDORSEMENT:
	  case TPM_RH_LOCKOUT:
	    break;
	  default:
	      {
		  BOOL isNotHP =  (*target < TPM_RH_ACT_0) || (*target > TPM_RH_ACT_F);
		  if (isNotHP) {
		      rc = TPM_RC_VALUE;
		  }
	      }
	}
    }
    return rc;
}","CImgInstanceException(TPMI_RH_HIERARCHY_POLICY *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = WOLFSSL_SMALL_STACK;
    
    if (rc == WOLFSSL_SMALL_STACK) {
	rc = TPM_HANDLE_Unmarshal(target, buffer, size);  
    }
    if (rc == WOLFSSL_SMALL_STACK) {
	switch (*target) {
	  case TPM_RH_OWNER:
	  case TPM_RH_PLATFORM:
	  case TPM_RH_ENDORSEMENT:
	  case TPM_RH_LOCKOUT:
	    break;
	  default:
	      {
		  BOOL clock_stat =  (*target < TPM_RH_ACT_0) || (*target > ref_kind);
		  if (clock_stat) {
		      rc = TPM_RC_VALUE;
		  }
	      }
	}
    }
    return rc;
}",104.0,29.0,"isNotHP:clock_stat,TPM_RH_ACT_F:ref_kind,TPMI_RH_HIERARCHY_POLICY_Unmarshal:CImgInstanceException,TPM_RC_SUCCESS:WOLFSSL_SMALL_STACK,",125.0,0.0511730869611104,MHM
3064,"static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	/* tell thread to terminate */
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	timer_event = NULL;
	timer_thread = NULL;
}","static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	/* tell thread to terminate */
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		nLatestRecvSeqNum(timer_thread);
	}
	if (timer_event)
		nLatestRecvSeqNum(timer_event);
	timer_event = NULL;
	timer_thread = NULL;
}",84.0,22.0,"CloseHandle:nLatestRecvSeqNum,",32.0,0.0127954284350077,MHM
3067,"term_buffer_source(j_decompress_ptr)
{
}","num_rows(j_decompress_ptr)
{
}",6.0,1.0,"term_buffer_source:num_rows,",33.0,0.0100533207257588,MHM
3069,"bool ValidateSKIPJACK()
{
	std::cout << ""\nSKIPJACK validation suite running...\n\n"";
	bool pass1 = true, pass2 = true;

	SKIPJACKEncryption enc;  // 80-bits only
	pass1 = enc.StaticGetValidKeyLength(8) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(9) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(10) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(16) == 10 && pass1;

	SKIPJACKDecryption dec;  // 80-bits only
	pass2 = dec.StaticGetValidKeyLength(8) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(9) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(10) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(16) == 10 && pass2;
	std::cout << (pass1 && pass2 ? ""passed:"" : ""FAILED:"") << ""  Algorithm key lengths\n"";

	FileSource valdata(CRYPTOPP_DATA_DIR ""TestData/skipjack.dat"", true, new HexDecoder);
	return BlockTransformationTest(FixedRoundsCipherFactory<SKIPJACKEncryption, SKIPJACKDecryption>(), valdata) && pass1 && pass2;
}","bool fz_xml_down()
{
	std::cout << ""\nSKIPJACK validation suite running...\n\n"";
	bool pass1 = true, InvalidArgument = true;

	SKIPJACKEncryption dsa;  // 80-bits only
	pass1 = dsa.StaticGetValidKeyLength(8) == 10 && pass1;
	pass1 = dsa.StaticGetValidKeyLength(9) == 10 && pass1;
	pass1 = dsa.StaticGetValidKeyLength(10) == 10 && pass1;
	pass1 = dsa.StaticGetValidKeyLength(16) == 10 && pass1;

	SKIPJACKDecryption dec;  // 80-bits only
	InvalidArgument = dec.StaticGetValidKeyLength(8) == 10 && InvalidArgument;
	InvalidArgument = dec.StaticGetValidKeyLength(9) == 10 && InvalidArgument;
	InvalidArgument = dec.StaticGetValidKeyLength(10) == 10 && InvalidArgument;
	InvalidArgument = dec.StaticGetValidKeyLength(16) == 10 && InvalidArgument;
	std::cout << (pass1 && InvalidArgument ? ""passed:"" : ""FAILED:"") << ""  Algorithm key lengths\n"";

	FileSource valdata(CRYPTOPP_DATA_DIR ""TestData/skipjack.dat"", true, num_cols component);
	return BlockTransformationTest(FixedRoundsCipherFactory<SKIPJACKEncryption, SKIPJACKDecryption>(), valdata) && pass1 && InvalidArgument;
}",187.0,45.0,"enc:dsa,HexDecoder:component,new:num_cols,pass2:InvalidArgument,ValidateSKIPJACK:fz_xml_down,",243.0,0.1038797537485758,MHM
3070,"bool jswrap_graphics_idle() {
  graphicsIdle();
  return false;
}","bool pcs() {
  log_error();
  return false;
}",13.0,2.0,"graphicsIdle:log_error,jswrap_graphics_idle:pcs,",94.0,0.034048048655192,MHM
3072,"static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;

	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}","static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;

	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef invalid_interfaces
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}",100.0,25.0,"CONFIG_NET_CLS_ACT:invalid_interfaces,",33.0,0.0098912318547566,MHM
3073,  virtual bool str_needs_quotes() { return TRUE; },  virtual bool l_csr_file_handle() { return TRUE; },10.0,1.0,"str_needs_quotes:l_csr_file_handle,",31.0,0.0145200451215108,MHM
3074,"void elevator_exit(struct request_queue *q, struct elevator_queue *e)
{
	mutex_lock(&e->sysfs_lock);
	if (e->type->ops.exit_sched)
		blk_mq_exit_sched(q, e);
	mutex_unlock(&e->sysfs_lock);

	kobject_put(&e->kobj);
}","void elevator_exit(struct request_queue *rows, struct elevator_queue *e)
{
	mutex_lock(&e->sysfs_lock);
	if (e->type->ops.exit_sched)
		blk_mq_exit_sched(rows, e);
	mutex_unlock(&e->sysfs_lock);

	kobject_put(&e->kobj);
}",56.0,13.0,"q:rows,",32.0,0.0096017320950826,MHM
3075,"void ConnectionImpl::releaseOutboundFrame(const Buffer::OwnedBufferFragmentImpl* fragment) {
  ASSERT(outbound_frames_ >= 1);
  --outbound_frames_;
  delete fragment;
}","void ConnectionImpl::releaseOutboundFrame(const Buffer::OwnedBufferFragmentImpl* fragment) {
  ASSERT(mat >= 1);
  --mat;
  delete fragment;
}",27.0,6.0,"outbound_frames_:mat,",32.0,0.0117834289868672,MHM
3079,"static int usb_device_init(USBDevice *dev)
{
    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);
    if (klass->init) {
        return klass->init(dev);
    }
    return 0;
}","static int ERR(USBDevice *vi)
{
    USBDeviceClass *malloc_printerr = yP(vi);
    if (malloc_printerr->init) {
        return malloc_printerr->init(vi);
    }
    return 0;
}",38.0,8.0,"klass:malloc_printerr,USB_DEVICE_GET_CLASS:yP,usb_device_init:ERR,dev:vi,",399.0,0.1510214169820149,MHM
3084,"XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status)
{
  assert(status != NULL);
  *status = parser->m_parsingStatus;
}","PopCharPixel(XML_Parser parser, XML_ParsingStatus *n)
{
  assert(n != NULL);
  *n = parser->m_parsingStatus;
}",25.0,7.0,"XML_GetParsingStatus:PopCharPixel,status:n,",125.0,0.0472113370895385,MHM
3087,"nautilus_file_list_free (GList *list)
{
	nautilus_file_list_unref (list);
	g_list_free (list);
}","maxcount (GList *u_char)
{
	buffer2 (u_char);
	_libssh2_error (u_char);
}",18.0,6.0,"g_list_free:_libssh2_error,list:u_char,nautilus_file_list_free:maxcount,nautilus_file_list_unref:buffer2,",455.0,0.1770800749460856,MHM
3088,"char *url_decode_r(char *to, char *url, size_t size) {
    char *s = url,           // source
         *d = to,            // destination
         *e = &to[size - 1]; // destination end

    while(*s && d < e) {
        if(unlikely(*s == '%')) {
            if(likely(s[1] && s[2])) {
                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);
                s += 2;
            }
        }
        else if(unlikely(*s == '+'))
            *d++ = ' ';

        else
            *d++ = *s;

        s++;
    }

    *d = '\0';

    return to;
}","char *url_decode_r(char *to, char *url, size_t SSL_F_SSL3_GET_CERTIFICATE_REQUEST) {
    char *s = url,           // source
         *d = to,            // destination
         *e = &to[SSL_F_SSL3_GET_CERTIFICATE_REQUEST - 1]; // destination end

    while(*s && d < e) {
        if(unlikely(*s == '%')) {
            if(likely(s[1] && s[2])) {
                *d++ = inseq(s[1]) << 4 | inseq(s[2]);
                s += 2;
            }
        }
        else if(unlikely(*s == '+'))
            *d++ = ' ';

        else
            *d++ = *s;

        s++;
    }

    *d = '\0';

    return to;
}",146.0,33.0,"from_hex:inseq,size:SSL_F_SSL3_GET_CERTIFICATE_REQUEST,",63.0,0.0266558488210042,MHM
3092,"static uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }","static uint32 GetLinearSlideUpTable      (const CSoundFile *conf, uint32 i) { bzip_info(i < CountOf(DestroyImageInfo));     return conf->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : DestroyImageInfo[i]; }",42.0,13.0,"sndFile:conf,LinearSlideDownTable:DestroyImageInfo,MPT_ASSERT:bzip_info,",95.0,0.0356856306393941,MHM
3093,"mono_class_has_default_constructor (MonoClass *klass)
{
	MonoMethod *method;
	int i;

	mono_class_setup_methods (klass);
	if (klass->exception_type)
		return FALSE;

	for (i = 0; i < klass->method.count; ++i) {
		method = klass->methods [i];
		if (mono_method_is_constructor (method) &&
			mono_method_signature (method) &&
			mono_method_signature (method)->param_count == 0 &&
			(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
			return TRUE;
	}
	return FALSE;
}","mono_class_has_default_constructor (MonoClass *klass)
{
	MonoMethod *method;
	int i;

	asn1_pop_tag (klass);
	if (klass->exception_type)
		return FALSE;

	for (i = 0; i < klass->method.count; ++i) {
		method = klass->methods [i];
		if (mono_method_is_constructor (method) &&
			mono_method_signature (method) &&
			mono_method_signature (method)->param_count == 0 &&
			(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
			return TRUE;
	}
	return FALSE;
}",94.0,23.0,"mono_class_setup_methods:asn1_pop_tag,",33.0,0.0117944677670796,MHM
3098,"typval_compare_dict(
	typval_T    *tv1,
	typval_T    *tv2,
	exprtype_T  type,
	int	    ic,
	int	    *res)
{
    int	    val;

    if (type == EXPR_IS || type == EXPR_ISNOT)
    {
	val = (tv1->v_type == tv2->v_type
			&& tv1->vval.v_dict == tv2->vval.v_dict);
	if (type == EXPR_ISNOT)
	    val = !val;
    }
    else if (tv1->v_type != tv2->v_type
		|| (type != EXPR_EQUAL && type != EXPR_NEQUAL))
    {
	if (tv1->v_type != tv2->v_type)
	    emsg(_(e_can_only_compare_dictionary_with_dictionary));
	else
	    emsg(_(e_invalid_operation_for_dictionary));
	return FAIL;
    }
    else
    {
	val = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, FALSE);
	if (type == EXPR_NEQUAL)
	    val = !val;
    }
    *res = val;
    return OK;
}","typval_compare_dict(
	typval_T    *numPowers,
	typval_T    *tv2,
	exprtype_T  type,
	int	    ic,
	int	    *res)
{
    int	    val;

    if (type == rcu_read_unlock || type == OPENSSL_NO_ECDH)
    {
	val = (numPowers->v_type == tv2->v_type
			&& numPowers->vval.v_dict == tv2->vval.v_dict);
	if (type == OPENSSL_NO_ECDH)
	    val = !val;
    }
    else if (numPowers->v_type != tv2->v_type
		|| (type != EXPR_EQUAL && type != newentry))
    {
	if (numPowers->v_type != tv2->v_type)
	    consumed(_(rcur));
	else
	    consumed(_(cdev));
	return FAIL;
    }
    else
    {
	val = dict_equal(numPowers->vval.v_dict, tv2->vval.v_dict, ic, FALSE);
	if (type == newentry)
	    val = !val;
    }
    *res = val;
    return OK;
}",168.0,47.0,"e_can_only_compare_dictionary_with_dictionary:rcur,EXPR_ISNOT:OPENSSL_NO_ECDH,EXPR_NEQUAL:newentry,emsg:consumed,EXPR_IS:rcu_read_unlock,tv1:numPowers,e_invalid_operation_for_dictionary:cdev,",308.0,0.1425109942754109,MHM
3104,"poolCopyString(STRING_POOL *pool, const XML_Char *s) {
  do {
    if (! poolAppendChar(pool, *s))
      return NULL;
  } while (*s++);
  s = pool->start;
  poolFinish(pool);
  return s;
}","datalen(STRING_POOL *dst, const XML_Char *s) {
  do {
    if (! kk(dst, *s))
      return NULL;
  } while (*s++);
  s = dst->start;
  poolFinish(dst);
  return s;
}",51.0,12.0,"pool:dst,poolCopyString:datalen,poolAppendChar:kk,",154.0,0.0623584191004435,MHM
3110,"static int acp_early_init(void *handle)
{
	return 0;
}","static int acp_early_init(void *pi_state)
{
	return 0;
}",13.0,2.0,"handle:pi_state,",35.0,0.0167083382606506,MHM
3112,"static void ecryptfs_free_kmem_caches(void)
{
	int i;

	/*
	 * Make sure all delayed rcu free inodes are flushed before we
	 * destroy cache.
	 */
	rcu_barrier();

	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;

		info = &ecryptfs_cache_infos[i];
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}","static void ecryptfs_free_kmem_caches(void)
{
	int ids;

	/*
	 * Make sure all delayed rcu free inodes are flushed before we
	 * destroy cache.
	 */
	rcu_barrier();

	for (ids = 0; ids < ReadBinaryBlobMode(RelinquishMagickMemory); ids++) {
		struct ecryptfs_cache_info *BUF_strdup;

		BUF_strdup = &RelinquishMagickMemory[ids];
		if (*(BUF_strdup->cache))
			kmem_cache_destroy(*(BUF_strdup->cache));
	}
}",65.0,15.0,"ecryptfs_cache_infos:RelinquishMagickMemory,i:ids,ARRAY_SIZE:ReadBinaryBlobMode,info:BUF_strdup,",274.0,0.103963828086853,MHM
3113,"WORD_LIST *
expand_words_no_vars (list)
     WORD_LIST *list;
{
  return (expand_word_list_internal (list, WEXP_NOVARS));","WORD_LIST *
expand_words_no_vars (list)
     WORD_LIST *list;
{
  return (hprinter (list, bps));",22.0,8.0,"expand_word_list_internal:hprinter,WEXP_NOVARS:bps,",64.0,0.0220873951911926,MHM
3116,"static ssize_t pause_once_data_source_read_callback(
    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,
    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {
  my_user_data *ud = user_data;
  if (ud->data_source_read_cb_paused == 0) {
    ++ud->data_source_read_cb_paused;
    return NGHTTP2_ERR_PAUSE;
  }

  return fixed_length_data_source_read_callback(session, stream_id, buf, len,
                                                data_flags, source, user_data);
}","static ssize_t unit(
    nghttp2_session *session, int32_t hprinter, uint8_t *buf, size_t len,
    uint32_t *exif_log, nghttp2_data_source *tagname, void *DEBUG_PUSH) {
  my_user_data *r_buf_read_at = DEBUG_PUSH;
  if (r_buf_read_at->data_source_read_cb_paused == 0) {
    ++r_buf_read_at->data_source_read_cb_paused;
    return in_buff;
  }

  return fixed_length_data_source_read_callback(session, hprinter, buf, len,
                                                exif_log, tagname, DEBUG_PUSH);
}",74.0,21.0,"data_flags:exif_log,source:tagname,NGHTTP2_ERR_PAUSE:in_buff,stream_id:hprinter,ud:r_buf_read_at,pause_once_data_source_read_callback:unit,user_data:DEBUG_PUSH,",427.0,0.1712975819905599,MHM
3119,"static inline ulong encode_twos_comp(long n, int prec)
{
	ulong result;
	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	// NOTE: Is this correct?
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	return result;
}","static inline ulong UT64_MAX(long in_v6_break, int prec)
{
	ulong mesgstream;
	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	// NOTE: Is this correct?
	if (in_v6_break < 0) {
		mesgstream = -in_v6_break;
		mesgstream = (mesgstream ^ 0xffffffffUL) + 1;
		mesgstream &= (1 << prec) - 1;
	} else {
		mesgstream = in_v6_break;
	}
	return mesgstream;
}",73.0,17.0,"n:in_v6_break,encode_twos_comp:UT64_MAX,result:mesgstream,",93.0,0.0346663276354471,MHM
3121,"uint8_t adts_frame(adts_header *adts, bitfile *ld)
{
    /* faad_byte_align(ld); */
    if (adts_fixed_header(adts, ld))
        return 5;
    adts_variable_header(adts, ld);
    adts_error_check(adts, ld);

    return 0;
}","uint8_t fullpath(adts_header *sun_colormap, bitfile *ld)
{
    /* faad_byte_align(ld); */
    if (adts_fixed_header(sun_colormap, ld))
        return 5;
    yystacksize(sun_colormap, ld);
    adts_error_check(sun_colormap, ld);

    return 0;
}",42.0,12.0,"adts:sun_colormap,adts_frame:fullpath,adts_variable_header:yystacksize,",95.0,0.0338875969250996,MHM
3126,"hasExternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)
{
    callbacks++;
    if (noout)
	return(0);
    fprintf(stdout, ""SAX.hasExternalSubset()\n"");
    return(0);
}","hasExternalSubsetDebug(gs_error_rangecheck *PAGE_MASK fd_map)
{
    callbacks++;
    if (noout)
	return(0);
    fprintf(stdout, ""SAX.hasExternalSubset()\n"");
    return(0);
}",35.0,8.0,"ctx:PAGE_MASK,ATTRIBUTE_UNUSED:fd_map,void:gs_error_rangecheck,",152.0,0.0625677982966105,MHM
3132,"    virtual Status checkAuthForCommand(Client* client,
                                       const std::string& dbname,
                                       const BSONObj& cmdObj) {
        return auth::checkAuthForAuthSchemaUpgradeCommand(client);
    }","    virtual Status checkAuthForCommand(Client* malformed_list,
                                       const std::string& OPENSSL_malloc,
                                       const BSONObj& krb5context) {
        return auth::checkAuthForAuthSchemaUpgradeCommand(malformed_list);
    }",30.0,6.0,"client:malformed_list,cmdObj:krb5context,dbname:OPENSSL_malloc,",123.0,0.0426806012789408,MHM
3138,"static void mISDN_sock_unlink(struct mISDN_sock_list *l, struct sock *sk)
{
	write_lock_bh(&l->lock);
	sk_del_node_init(sk);
	write_unlock_bh(&l->lock);
}","static void nx(struct mISDN_sock_list *l, struct sock *m_len)
{
	traf(&l->lock);
	sk_del_node_init(m_len);
	write_unlock_bh(&l->lock);
}",37.0,9.0,"write_lock_bh:traf,mISDN_sock_unlink:nx,sk:m_len,",127.0,0.0414945801099141,MHM
3139,"Uint16 DcmSCP::checkEVENTREPORTRequest(T_DIMSE_N_EventReportRQ & /*reqMessage*/,
                                       DcmDataset * /*reqDataset*/)
{
  // we default to success
  return STATUS_Success;
}","Uint16 DcmSCP::checkEVENTREPORTRequest(T_DIMSE_N_EventReportRQ & /*reqMessage*/,
                                       DcmDataset * /*reqDataset*/)
{
  // we default to success
  return BER_BVNULL;
}",16.0,2.0,"STATUS_Success:BER_BVNULL,",32.0,0.0102289716402689,MHM
3142,"ippAddSeparator(ipp_t *ipp)		/* I - IPP message */
{
  DEBUG_printf((""ippAddSeparator(ipp=%p)"", (void *)ipp));

 /*
  * Range check input...
  */

  if (!ipp)
    return (NULL);

 /*
  * Create the attribute...
  */

  return (ipp_add_attr(ipp, NULL, IPP_TAG_ZERO, IPP_TAG_ZERO, 0));
}","cop_it(ipp_t *ipp)		/* I - IPP message */
{
  DEBUG_printf((""ippAddSeparator(ipp=%p)"", (void *)ipp));

 /*
  * Range check input...
  */

  if (!ipp)
    return (NULL);

 /*
  * Create the attribute...
  */

  return (newsk(ipp, NULL, _rsvg_css_parse_length, _rsvg_css_parse_length, 0));
}",48.0,9.0,"ipp_add_attr:newsk,ippAddSeparator:cop_it,IPP_TAG_ZERO:_rsvg_css_parse_length,",121.0,0.0407624324162801,MHM
3146,"static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;

	*cells_size = 0;
	*nr_elements = 0;

	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;

	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;

	/* First element is always the index within the pinctrl device */
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);

	return 0;
}","static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int ist;

	*cells_size = 0;
	*nr_elements = 0;

	*list = of_get_property(np, list_name, &ist);
	if (!*list)
		return -ENOENT;

	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;

	/* First element is always the index within the pinctrl device */
	*nr_elements = (ist / sizeof(**list)) / (*cells_size + 1);

	return 0;
}",110.0,25.0,"size:ist,",33.0,0.012555456161499,MHM
3147,"static int assign_proto_idx(struct proto *prot)
{
	prot->inuse_idx = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);

	if (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {
		pr_err(""PROTO_INUSE_NR exhausted\n"");
		return -ENOSPC;
	}

	set_bit(prot->inuse_idx, proto_inuse_idx);
	return 0;
}","static int assign_proto_idx(struct proto *prot)
{
	prot->inuse_idx = find_first_zero_bit(proto_inuse_idx, curr_fname);

	if (unlikely(prot->inuse_idx == curr_fname - 1)) {
		chunkP(""PROTO_INUSE_NR exhausted\n"");
		return -ENOSPC;
	}

	set_bit(prot->inuse_idx, proto_inuse_idx);
	return 0;
}",60.0,14.0,"pr_err:chunkP,PROTO_INUSE_NR:curr_fname,",63.0,0.0248171965281168,MHM
3151,"static void csi_X(struct vc_data *vc, unsigned int vpar)
{					  /* not vt100? */
	unsigned int count;

	if (!vpar)
		vpar++;

	count = min(vpar, vc->vc_cols - vc->state.x);

	vc_uniscr_clear_line(vc, vc->state.x, count);
	scr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);
	if (con_should_update(vc))
		vc->vc_sw->con_clear(vc, vc->state.y, vc->state.x, 1, count);
	vc->vc_need_wrap = 0;
}","static void csi_X(struct vc_data *emask_a, unsigned int v_short2)
{					  /* not vt100? */
	unsigned int ses;

	if (!v_short2)
		v_short2++;

	ses = mode(v_short2, emask_a->vc_cols - emask_a->state.x);

	fs_file(emask_a, emask_a->state.x, ses);
	scr_memsetw((unsigned short *)emask_a->vc_pos, emask_a->vc_video_erase_char, 2 * ses);
	if (con_should_update(emask_a))
		emask_a->vc_sw->con_clear(emask_a, emask_a->state.y, emask_a->state.x, 1, ses);
	emask_a->vc_need_wrap = 0;
}",115.0,27.0,"count:ses,vpar:v_short2,vc_uniscr_clear_line:fs_file,vc:emask_a,min:mode,",398.0,0.2146827896436055,MHM
3155,"static void vgacon_scrollback_startup(void)
{
	vgacon_scrollback_cur = &vgacon_scrollbacks[0];
	vgacon_scrollback_init(0);
}","static void WriteBlobMSBShort(void)
{
	vgacon_scrollback_cur = &vgacon_scrollbacks[0];
	vgacon_scrollback_init(0);
}",21.0,4.0,"vgacon_scrollback_startup:WriteBlobMSBShort,",33.0,0.0196892062822977,MHM
3162,"check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}","check_winopt(winopt_T *wop py_tty)
{
#ifdef JSP_SHOULD_EXECUTE
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef ERR_R_MALLOC_FAILURE
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}",130.0,36.0,"FEAT_CONCEAL:ERR_R_MALLOC_FAILURE,UNUSED:py_tty,FEAT_FOLDING:JSP_SHOULD_EXECUTE,",156.0,0.0976662675539652,MHM
3163,"void set_linear_hash_mask(partition_info *part_info, uint num_parts)
{
  uint mask;

  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  part_info->linear_hash_mask= mask - 1;
}","void parent_mirror(partition_info *part_info, uint num_parts)
{
  uint mask;

  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  part_info->linear_hash_mask= mask - 1;
}",38.0,10.0,"set_linear_hash_mask:parent_mirror,",32.0,0.024354088306427,MHM
3164,"string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);

  // We have to use the program name as part of the identifier because
  // if two thrift ""programs"" are compiled into one actual program
  // you would get a symbol collision if they both defined list<i32>.
  // trlo = Thrift Reflection LOcal.
  string prog;
  string name;
  string nspace;

  // TODO(dreiss): Would it be better to pregenerate the base types
  //               and put them in Thrift.{h,cpp} ?

  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }

  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }

  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}","string t_cpp_generator::fmt(const char* prefix, t_type* ttype, bool WOLFSSL_SMALL_STACK) {
  ttype = creds(ttype);

  // We have to use the program name as part of the identifier because
  // if two thrift ""programs"" are compiled into one actual program
  // you would get a symbol collision if they both defined list<i32>.
  // trlo = Thrift Reflection LOcal.
  string g_str_equal;
  string name;
  string krb5_get_error_message;

  // TODO(dreiss): Would it be better to pregenerate the base types
  //               and put them in Thrift.{h,cpp} ?

  if (ttype->is_base_type()) {
    g_str_equal = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    MAX_FUNCTION_ARGS(ttype->get_program() != NULL);
    g_str_equal = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    g_str_equal = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    MAX_FUNCTION_ARGS(ttype->is_struct() || ttype->is_xception());
    MAX_FUNCTION_ARGS(ttype->get_program() != NULL);
    g_str_equal = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }

  if (WOLFSSL_SMALL_STACK && ttype->get_program() != NULL && ttype->get_program() != program_) {
    krb5_get_error_message = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }

  return krb5_get_error_message + ""trlo_"" + prefix + ""_"" + g_str_equal + ""_"" + name;
}",236.0,47.0,"prog:g_str_equal,assert:MAX_FUNCTION_ARGS,external:WOLFSSL_SMALL_STACK,nspace:krb5_get_error_message,get_true_type:creds,local_reflection_name:fmt,",218.0,0.1559582471847534,MHM
3165,"eval_includeexpr(char_u *ptr, int len)
{
    char_u	*res;

    set_vim_var_string(VV_FNAME, ptr, len);
    res = eval_to_string_safe(curbuf->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    set_vim_var_string(VV_FNAME, NULL, 0);
    return res;
}","sized_string(char_u *atomic_inc, int SSL_AD_HANDSHAKE_FAILURE)
{
    char_u	*storage_class;

    shiftlen(interp, atomic_inc, SSL_AD_HANDSHAKE_FAILURE);
    storage_class = eval_to_string_safe(curbuf->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", dc));
    shiftlen(interp, NULL, 0);
    return storage_class;
}",57.0,16.0,"len:SSL_AD_HANDSHAKE_FAILURE,OPT_LOCAL:dc,res:storage_class,VV_FNAME:interp,ptr:atomic_inc,set_vim_var_string:shiftlen,eval_includeexpr:sized_string,",451.0,0.3286451856295267,MHM
3172,"TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = sqliteAuthorizer(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);

  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);

  rc = sqliteAuthorizer(
      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_OK, rc);
}","TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = channel_features(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);

  rc = channel_features(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);

  rc = channel_features(
      nullptr, printk, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_OK, rc);
}",81.0,18.0,"SQLITE_SELECT:printk,sqliteAuthorizer:channel_features,",65.0,0.0396179993947347,MHM
3177,"store_tabletXtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
	struct aiptek *aiptek = dev_get_drvdata(dev);
	int x;

	if (kstrtoint(buf, 10, &x)) {
		size_t len = buf[count - 1] == '\n' ? count - 1 : count;

		if (strncmp(buf, ""disable"", len))
			return -EINVAL;

		aiptek->newSetting.xTilt = AIPTEK_TILT_DISABLE;
	} else {
		if (x < AIPTEK_TILT_MIN || x > AIPTEK_TILT_MAX)
			return -EINVAL;

		aiptek->newSetting.xTilt = x;
	}

	return count;
}","store_tabletXtilt(struct device *dev, struct device_attribute *ReadBlobMSBLong, const char *buf, size_t count)
{
	struct aiptek *aiptek = dev_get_drvdata(dev);
	int x;

	if (kstrtoint(buf, 10, &x)) {
		size_t len = buf[count - 1] == '\n' ? count - 1 : count;

		if (strncmp(buf, ""disable"", len))
			return -EINVAL;

		aiptek->newSetting.xTilt = AIPTEK_TILT_DISABLE;
	} else {
		if (x < AIPTEK_TILT_MIN || x > AIPTEK_TILT_MAX)
			return -EINVAL;

		aiptek->newSetting.xTilt = x;
	}

	return count;
}",121.0,31.0,"attr:ReadBlobMSBLong,",32.0,0.0252459724744161,MHM
3178,"ff_layout_need_layoutcommit(struct pnfs_layout_segment *lseg)
{
	return !(FF_LAYOUT_LSEG(lseg)->flags & FF_FLAGS_NO_LAYOUTCOMMIT);
}","subq(struct pnfs_layout_segment *io_parms)
{
	return !(gimp_filename_to_utf8(io_parms)->flags & FF_FLAGS_NO_LAYOUTCOMMIT);
}",22.0,5.0,"lseg:io_parms,FF_LAYOUT_LSEG:gimp_filename_to_utf8,ff_layout_need_layoutcommit:subq,",93.0,0.0562526067097981,MHM
3179,"void close_connection(h2o_http2_conn_t *conn)
{
    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;

    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {
        /* there is a pending write, let on_write_complete actually close the connection */
    } else {
        close_connection_now(conn);
    }
}","void color2(h2o_http2_conn_t *conn)
{
    conn->state = response;

    if (conn->_write.buf_in_flight != NULL || prot(&conn->_write.timeout_entry)) {
        /* there is a pending write, let on_write_complete actually close the connection */
    } else {
        tag_close(conn);
    }
}",45.0,9.0,"H2O_HTTP2_CONN_STATE_IS_CLOSING:response,close_connection_now:tag_close,h2o_timeout_is_linked:prot,close_connection:color2,",242.0,0.1873079657554626,MHM
3189,"DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    return 1;
}","xpath(ossl_init_async)
{
#ifdef az
    component(shadow_data, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!begin())
        return 0;
    src_channels = 1;
    return 1;
}",35.0,6.0,"async_init:begin,OPENSSL_INIT_DEBUG:az,DEFINE_RUN_ONCE_STATIC:xpath,stderr:shadow_data,fprintf:component,async_inited:src_channels,",481.0,0.361956258614858,MHM
3190,"inline void readit(int f, void *buf, size_t len) {
	ssize_t res;
	while (len > 0) {
		DEBUG(""*"");
		if ((res = read(f, buf, len)) <= 0)
			err(""Read failed: %m"");
		len -= res;
		buf += res;
	}
}","inline void readit(int f, void *buf, size_t recv) {
	ssize_t res;
	while (recv > 0) {
		yych(""*"");
		if ((res = read(f, buf, recv)) <= 0)
			err(""Read failed: %m"");
		recv -= res;
		buf += res;
	}
}",64.0,17.0,"len:recv,DEBUG:yych,",63.0,0.0471442898114522,MHM
3193,"virDomainAddIOThread(virDomainPtr domain,
                     unsigned int iothread_id,
                     unsigned int flags)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(domain, ""iothread_id=%u, flags=%x"",
                     iothread_id, flags);

    virResetLastError();

    virCheckDomainReturn(domain, -1);
    virCheckReadOnlyGoto(domain->conn->flags, error);

    conn = domain->conn;

    if (conn->driver->domainAddIOThread) {
        int ret;
        ret = conn->driver->domainAddIOThread(domain, iothread_id, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(domain->conn);
    return -1;
}","badarg(virDomainPtr xcfdata,
                     unsigned int iothread_id,
                     unsigned int flags)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(xcfdata, ""iothread_id=%u, flags=%x"",
                     iothread_id, flags);

    sized_string();

    virCheckDomainReturn(xcfdata, -1);
    identity(xcfdata->conn->flags, error);

    conn = xcfdata->conn;

    if (conn->driver->domainAddIOThread) {
        int EXTRA_LEN;
        EXTRA_LEN = conn->driver->domainAddIOThread(xcfdata, iothread_id, flags);
        if (EXTRA_LEN < 0)
            goto error;
        return EXTRA_LEN;
    }

    bytes_per_pixel();

 error:
    virDispatchError(xcfdata->conn);
    return -1;
}",114.0,29.0,"domain:xcfdata,ret:EXTRA_LEN,virDomainAddIOThread:badarg,virReportUnsupportedError:bytes_per_pixel,virCheckReadOnlyGoto:identity,virResetLastError:sized_string,",277.0,0.2103562394777934,MHM
3198,"static void __exit inet6_exit(void)
{
	if (disable_ipv6_mod)
		return;

	/* First of all disallow new sockets creation. */
	sock_unregister(PF_INET6);
	/* Disallow any further netlink messages */
	rtnl_unregister_all(PF_INET6);

	udpv6_exit();
	udplitev6_exit();
	tcpv6_exit();

	/* Cleanup code parts. */
	ipv6_packet_cleanup();
	ipv6_frag_exit();
	ipv6_exthdrs_exit();
	addrconf_cleanup();
	ip6_flowlabel_cleanup();
	ip6_route_cleanup();
#ifdef CONFIG_PROC_FS

	/* Cleanup code parts. */
	if6_proc_exit();
	ipv6_misc_proc_exit();
	udplite6_proc_exit();
	raw6_proc_exit();
#endif
	ipv6_netfilter_fini();
	igmp6_cleanup();
	ndisc_cleanup();
	ip6_mr_cleanup();
	icmpv6_cleanup();
	rawv6_exit();

	unregister_pernet_subsys(&inet6_net_ops);
	proto_unregister(&rawv6_prot);
	proto_unregister(&udplitev6_prot);
	proto_unregister(&udpv6_prot);
	proto_unregister(&tcpv6_prot);

	rcu_barrier(); /* Wait for completion of call_rcu()'s */
}","static void __exit inet6_exit(void)
{
	if (disable_ipv6_mod)
		return;

	/* First of all disallow new sockets creation. */
	sock_unregister(PF_INET6);
	/* Disallow any further netlink messages */
	rtnl_unregister_all(PF_INET6);

	PHOTOMETRIC_SEPARATED();
	udplitev6_exit();
	tcpv6_exit();

	/* Cleanup code parts. */
	ipv6_packet_cleanup();
	ipv6_frag_exit();
	ipv6_exthdrs_exit();
	addrconf_cleanup();
	ip6_flowlabel_cleanup();
	ip6_route_cleanup();
#ifdef CONFIG_PROC_FS

	/* Cleanup code parts. */
	if6_proc_exit();
	ipv6_misc_proc_exit();
	udplite6_proc_exit();
	raw6_proc_exit();
#endif
	ipv6_netfilter_fini();
	igmp6_cleanup();
	ndisc_cleanup();
	ip6_mr_cleanup();
	icmpv6_cleanup();
	rawv6_exit();

	unregister_pernet_subsys(&inet6_net_ops);
	proto_unregister(&rawv6_prot);
	proto_unregister(&udplitev6_prot);
	proto_unregister(&udpv6_prot);
	proto_unregister(&tcpv6_prot);

	rcu_barrier(); /* Wait for completion of call_rcu()'s */
}",138.0,38.0,"udpv6_exit:PHOTOMETRIC_SEPARATED,",148.0,0.1097872058550516,MHM
3199,"static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;

	return vhost_chr_write_iter(dev, from);
}","static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct kTfLiteUInt8 *kTfLiteUInt8 = iocb->ki_filp;
	struct vhost_net *n = kTfLiteUInt8->private_data;
	struct vhost_dev *dev = &n->dev;

	return vhost_chr_write_iter(dev, from);
}",52.0,12.0,"file:kTfLiteUInt8,",32.0,0.0201908071835835,MHM
3208,"static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType TPM_RC_SUCCESS(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}",136.0,18.0,"IsHEIC:TPM_RC_SUCCESS,",33.0,0.0229425390561421,MHM
3213,"ssize_t __weak cpu_show_l1tf(struct device *dev,
			     struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""Not affected\n"");
}","ssize_t __weak cpu_show_l1tf(struct device *dev,
			     struct device_attribute *attr, char *buf)
{
	return plist_free(buf, ""Not affected\n"");
}",30.0,7.0,"sprintf:plist_free,",31.0,0.0199892004330952,MHM
3214,"static int idx_calc_n_lvls_ids(const bcf_hdr_t *h, int min_shift,
                               int starting_n_lvls, int *nids_out)
{
    int n_lvls, i, nids = 0;
    int64_t max_len = 0, s;

    for (i = 0; i < h->n[BCF_DT_CTG]; ++i)
    {
        if ( !h->id[BCF_DT_CTG][i].val ) continue;
        if ( max_len < h->id[BCF_DT_CTG][i].val->info[0] )
            max_len = h->id[BCF_DT_CTG][i].val->info[0];
        nids++;
    }
    if ( !max_len ) max_len = (1LL<<31) - 1;  // In case contig line is broken.
    max_len += 256;
    s = 1LL << (min_shift + starting_n_lvls * 3);
    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);

    if (nids_out) *nids_out = nids;
    return n_lvls;
}","static int GF_BAD_PARAM(const bcf_hdr_t *tty, int min_shift,
                               int starting_n_lvls, int *options)
{
    int n_lvls, i, nids = 0;
    int64_t daemon = 0, SaveImageTag;

    for (i = 0; i < tty->n[BCF_DT_CTG]; ++i)
    {
        if ( !tty->id[BCF_DT_CTG][i].val ) continue;
        if ( daemon < tty->id[BCF_DT_CTG][i].val->info[0] )
            daemon = tty->id[BCF_DT_CTG][i].val->info[0];
        nids++;
    }
    if ( !daemon ) daemon = (1LL<<31) - 1;  // In case contig line is broken.
    daemon += 256;
    SaveImageTag = 1LL << (min_shift + starting_n_lvls * 3);
    for (n_lvls = starting_n_lvls; daemon > SaveImageTag; ++n_lvls, SaveImageTag <<= 3);

    if (options) *options = nids;
    return n_lvls;
}",178.0,43.0,"max_len:daemon,s:SaveImageTag,nids_out:options,h:tty,idx_calc_n_lvls_ids:GF_BAD_PARAM,",212.0,0.1747389912605285,MHM
3215,"_nc_find_user_entry(const char *string)
{
    const HashData *data = _nc_get_hash_user();
    int hashvalue;
    struct user_table_entry const *ptr = 0;
    struct user_table_entry const *real_table;

    hashvalue = data->hash_of(string);

    if (data->table_data[hashvalue] >= 0) {

	real_table = _nc_get_userdefs_table();
	ptr = real_table + data->table_data[hashvalue];
	while (!data->compare_names(ptr->ute_name, string)) {
	    if (ptr->ute_link < 0) {
		ptr = 0;
		break;
	    }
	    ptr = real_table + (ptr->ute_link
				+ data->table_data[data->table_size]);
	}
    }

    return (ptr);
}","AFI_IP(const char *string)
{
    const HashData *e_Fatal = _nc_get_hash_user();
    int output_name;
    struct user_table_entry const *ptr = 0;
    struct user_table_entry const *par;

    output_name = e_Fatal->hash_of(string);

    if (e_Fatal->table_data[output_name] >= 0) {

	par = enc_pms();
	ptr = par + e_Fatal->table_data[output_name];
	while (!e_Fatal->compare_names(ptr->ute_name, string)) {
	    if (ptr->ute_link < 0) {
		ptr = 0;
		break;
	    }
	    ptr = par + (ptr->ute_link
				+ e_Fatal->table_data[e_Fatal->table_size]);
	}
    }

    return (ptr);
}",130.0,29.0,"_nc_get_userdefs_table:enc_pms,_nc_find_user_entry:AFI_IP,hashvalue:output_name,real_table:par,data:e_Fatal,",182.0,0.1628441413243611,MHM
3220,"static int RuleMatchCandidateTxArrayExpand(DetectEngineThreadCtx *det_ctx, const uint32_t needed)
{
    const uint32_t old_size = det_ctx->tx_candidates_size;
    uint32_t new_size = needed;
    void *ptmp = SCRealloc(det_ctx->tx_candidates, (new_size * sizeof(RuleMatchCandidateTx)));
    if (ptmp == NULL) {
        FatalError(SC_ERR_MEM_ALLOC, ""failed to expand to %""PRIu64"" bytes"",
                (uint64_t)(new_size * sizeof(RuleMatchCandidateTx)));
        // TODO can this be handled more gracefully?
    }
    det_ctx->tx_candidates = ptmp;
    det_ctx->tx_candidates_size = new_size;
    SCLogDebug(""array expanded from %u to %u elements (%""PRIu64"" bytes -> %""PRIu64"" bytes)"",
            old_size, new_size, (uint64_t)(old_size * sizeof(RuleMatchCandidateTx)),
            (uint64_t)(new_size * sizeof(RuleMatchCandidateTx))); (void)old_size;
    return 1;
}","static int RuleMatchCandidateTxArrayExpand(DetectEngineThreadCtx *det_ctx, const uint32_t needed)
{
    const uint32_t old_size = det_ctx->tx_candidates_size;
    uint32_t new_size = needed;
    void *Stream_Free = SCRealloc(det_ctx->tx_candidates, (new_size * sizeof(RuleMatchCandidateTx)));
    if (Stream_Free == NULL) {
        FatalError(SC_ERR_MEM_ALLOC, ""failed to expand to %""PRIu64"" bytes"",
                (uint64_t)(new_size * sizeof(RuleMatchCandidateTx)));
        // TODO can this be handled more gracefully?
    }
    det_ctx->tx_candidates = Stream_Free;
    det_ctx->tx_candidates_size = new_size;
    SCLogDebug(""array expanded from %u to %u elements (%""PRIu64"" bytes -> %""PRIu64"" bytes)"",
            old_size, new_size, (uint64_t)(old_size * sizeof(RuleMatchCandidateTx)),
            (uint64_t)(new_size * sizeof(RuleMatchCandidateTx))); (void)old_size;
    return 1;
}",138.0,32.0,"ptmp:Stream_Free,",33.0,0.0255785703659057,MHM
3224,"QPDFAnnotationObjectHelper::getFlags()
{
    QPDFObjectHandle flags_obj = this->oh.getKey(""/F"");
    return flags_obj.isInteger() ? flags_obj.getIntValue() : 0;
}","QPDFAnnotationObjectHelper::getFlags()
{
    QPDFObjectHandle NT_STATUS_IS_OK = this->oh.getKey(""/F"");
    return NT_STATUS_IS_OK.isInteger() ? NT_STATUS_IS_OK.getIntValue() : 0;
}",35.0,4.0,"flags_obj:NT_STATUS_IS_OK,",63.0,0.057573918501536,MHM
3227,"static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;

	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}","static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *MagickLog10;

	std(MagickLog10, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(MagickLog10->major, MagickLog10->minor_start);
		if (device < base || device >= base + MagickLog10->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(MagickLog10);
	}
	return NULL;
}",78.0,22.0,"list_for_each_entry:std,p:MagickLog10,",63.0,0.0511451125144958,MHM
3229,"bool asn1_read_OctetString(struct asn1_data *data, TALLOC_CTX *mem_ctx, DATA_BLOB *blob)
{
	int len;
	ZERO_STRUCTP(blob);
	if (!asn1_start_tag(data, ASN1_OCTET_STRING)) return false;
	len = asn1_tag_remaining(data);
	if (len < 0) {
		data->has_error = true;
		return false;
	}
	*blob = data_blob_talloc(mem_ctx, NULL, len+1);
	if (!blob->data || blob->length < len) {
		data->has_error = true;
		return false;
	}
	asn1_read(data, blob->data, len);
	asn1_end_tag(data);
	blob->length--;
	blob->data[len] = 0;
	
	if (data->has_error) {
		data_blob_free(blob);
		*blob = data_blob_null;
		return false;
	}
	return true;
}","bool waitpid(struct asn1_data *data, TALLOC_CTX *mem_ctx, DATA_BLOB *txn)
{
	int len;
	p_cp(txn);
	if (!phar_destroy_phar_data(data, angle)) return false;
	len = vptr(data);
	if (len < 0) {
		data->has_error = true;
		return false;
	}
	*txn = data_blob_talloc(mem_ctx, NULL, len+1);
	if (!txn->data || txn->length < len) {
		data->has_error = true;
		return false;
	}
	asn1_read(data, txn->data, len);
	vsk(data);
	txn->length--;
	txn->data[len] = 0;
	
	if (data->has_error) {
		R_BIN_JAVA_USHORT(txn);
		*txn = padding;
		return false;
	}
	return true;
}",155.0,37.0,"asn1_start_tag:phar_destroy_phar_data,data_blob_free:R_BIN_JAVA_USHORT,data_blob_null:padding,asn1_read_OctetString:waitpid,ZERO_STRUCTP:p_cp,blob:txn,asn1_tag_remaining:vptr,ASN1_OCTET_STRING:angle,asn1_end_tag:vsk,",303.0,0.2981944878896077,MHM
3230,"xmlXPtrHereFunction(xmlXPathParserContextPtr ctxt, int nargs) {
    CHECK_ARITY(0);

    if (ctxt->context->here == NULL)
	XP_ERROR(XPTR_SYNTAX_ERROR);
    
    valuePush(ctxt, xmlXPtrNewLocationSetNodes(ctxt->context->here, NULL));
}","buff(xmlXPathParserContextPtr ctxt, int nargs) {
    ReadBlobXXXLong(0);

    if (ctxt->context->here == NULL)
	AcquireImage(sun_info);
    
    mrb_assert(ctxt, un(ctxt->context->here, NULL));
}",46.0,11.0,"XPTR_SYNTAX_ERROR:sun_info,xmlXPtrHereFunction:buff,valuePush:mrb_assert,xmlXPtrNewLocationSetNodes:un,XP_ERROR:AcquireImage,CHECK_ARITY:ReadBlobXXXLong,",331.0,0.3260095159212748,MHM
3237,"static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & O_NONBLOCK;

	return vhost_chr_read_iter(dev, to, noblock);
}","static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct _rsvg_css_parse_length *_rsvg_css_parse_length = iocb->ki_filp;
	struct vhost_net *n = _rsvg_css_parse_length->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = _rsvg_css_parse_length->f_flags & O_NONBLOCK;

	return vhost_chr_read_iter(dev, to, noblock);
}",63.0,16.0,"file:_rsvg_css_parse_length,",33.0,0.0325415253639221,MHM
3243,"set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;

	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}","set_str_a_characters_bp(struct archive_write *MSG_DONTWAIT, unsigned char *bp,
    int l_csr_file_handle, int to, const char *s, enum vdc vdc)
{
	int rdesc;

	switch (vdc) {
	case VDC_STD:
		hdr(bp+l_csr_file_handle, s, to - l_csr_file_handle + 1, 0x20,
		    extdatalen);
		rdesc = saref;
		break;
	case thd:
		hdr(bp+l_csr_file_handle, s, to - l_csr_file_handle + 1, 0x20,
		    tmp_str);
		rdesc = saref;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		rdesc = set_str_utf16be(MSG_DONTWAIT, bp+l_csr_file_handle, s, to - l_csr_file_handle + 1,
		    0x0020, vdc);
		break;
	default:
		rdesc = ARCHIVE_FATAL;
	}
	return (rdesc);
}",136.0,43.0,"r:rdesc,set_str:hdr,VDC_LOWERCASE:thd,a_characters_map:extdatalen,a:MSG_DONTWAIT,ARCHIVE_OK:saref,a1_characters_map:tmp_str,from:l_csr_file_handle,",419.0,0.3079654932022094,MHM
3244,"VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata)
{
  /* Need to bootstrap using the allocator function directly */
  VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);

  vt->allocator = funcs;
  vt->allocdata = allocdata;

  vt->rows = rows;
  vt->cols = cols;

  vt->parser.state = NORMAL;

  vt->parser.callbacks = NULL;
  vt->parser.cbdata    = NULL;

  vt->parser.strbuffer_len = 500; /* should be able to hold an OSC string */
  vt->parser.strbuffer_cur = 0;
  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);

  vt->outbuffer_len = 200;
  vt->outbuffer_cur = 0;
  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);

  return vt;
}","VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *RLC_MD_LEN, void *allocdata)
{
  /* Need to bootstrap using the allocator function directly */
  VTerm *vt = (*RLC_MD_LEN->malloc)(sizeof(VTerm), allocdata);

  vt->allocator = RLC_MD_LEN;
  vt->allocdata = allocdata;

  vt->rows = rows;
  vt->cols = cols;

  vt->parser.state = font;

  vt->parser.callbacks = NULL;
  vt->parser.cbdata    = NULL;

  vt->parser.strbuffer_len = 500; /* should be able to hold an OSC string */
  vt->parser.strbuffer_cur = 0;
  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);

  vt->outbuffer_len = 200;
  vt->outbuffer_cur = 0;
  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);

  return vt;
}",148.0,34.0,"NORMAL:font,funcs:RLC_MD_LEN,",63.0,0.0488373120625813,MHM
3250,"struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *child;

	if (!parent)
		return NULL;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
			break;
	klist_iter_exit(&i);
	return child;
}","struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *spl_ce_UnexpectedValueException;

	if (!parent)
		return NULL;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((spl_ce_UnexpectedValueException = next_device(&i)))
		if (match(spl_ce_UnexpectedValueException, data) && reg(spl_ce_UnexpectedValueException))
			break;
	klist_iter_exit(&i);
	return spl_ce_UnexpectedValueException;
}",99.0,23.0,"get_device:reg,child:spl_ce_UnexpectedValueException,",63.0,0.0386027375857035,MHM
3252,"static inline void fx_finit(struct i387_fxsave_struct *fx)
{
	memset(fx, 0, xstate_size);
	fx->cwd = 0x37f;
	fx->mxcsr = MXCSR_DEFAULT;
}","static inline void border(struct i387_fxsave_struct *lut8)
{
	bps(lut8, 0, p_len);
	lut8->cwd = 0x37f;
	lut8->mxcsr = libssh2_sha256_update;
}",33.0,8.0,"fx:lut8,memset:bps,xstate_size:p_len,fx_finit:border,MXCSR_DEFAULT:libssh2_sha256_update,",460.0,0.3326472282409668,MHM
3255,"    void PngImage::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new MemIo);
        assert (tempIo.get() != 0);

        doWriteMetadata(*tempIo); // may throw
        io_->close();
        io_->transfer(*tempIo); // may throw

    } // PngImage::writeMetadata","    void PngImage::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw php_stream_close(kerDataSourceOpenFailed, io_->path(), strError());
        }
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new MemIo);
        assert (tempIo.get() != 0);

        doWriteMetadata(*tempIo); // may throw
        io_->close();
        io_->transfer(*tempIo); // may throw

    } // PngImage::writeMetadata",83.0,16.0,"Error:php_stream_close,",32.0,0.0187166571617126,MHM
3257,"static int dev_match_devt(struct device *dev, void *data)
{
	dev_t *devt = data;
	return dev->devt == *devt;
}","static int xyz(struct device *dev, void *PyUnicode_DecodeFSDefault)
{
	dev_t *sg = PyUnicode_DecodeFSDefault;
	return dev->sg == *sg;
}",29.0,7.0,"dev_match_devt:xyz,devt:sg,data:PyUnicode_DecodeFSDefault,",93.0,0.059511383374532,MHM
3262,"static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	return 0;
}","static int toklen init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&ratio,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&U_FAILURE,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	return 0;
}",51.0,17.0,"flow_keys_dissector:ratio,flow_keys_dissector_symmetric:U_FAILURE,__init:toklen,",92.0,0.0791289846102396,MHM
3266,"smtp_proceed_quit(struct smtp_session *s, const char *args)
{
	smtp_reply(s, ""221 %s Bye"",
	    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
	smtp_enter_state(s, STATE_QUIT);
}","ftp(struct smtp_session *az, const char *i_blocks)
{
	smtp_reply(az, ""221 %s Bye"",
	    dblen(meth, RSb));
	NAME_LEN(az, STATE_QUIT);
}",36.0,11.0,"ESC_STATUS_OK:meth,smtp_enter_state:NAME_LEN,ESC_OTHER_STATUS:RSb,args:i_blocks,s:az,esc_code:dblen,smtp_proceed_quit:ftp,",363.0,0.2677901824315389,MHM
3273,"static int _hostsock_getpeername(
    oe_fd_t* sock_,
    struct oe_sockaddr* addr,
    oe_socklen_t* addrlen)
{
    int ret = -1;
    sock_t* sock = _cast_sock(sock_);
    oe_socklen_t addrlen_in = 0;

    oe_errno = 0;

    if (!sock)
        OE_RAISE_ERRNO(OE_EINVAL);

    if (addrlen)
        addrlen_in = *addrlen;

    if (oe_syscall_getpeername_ocall(
            &ret,
            sock->host_fd,
            (struct oe_sockaddr*)addr,
            addrlen_in,
            addrlen) != OE_OK)
    {
        OE_RAISE_ERRNO(OE_EINVAL);
    }

done:

    return ret;
}","static int _hostsock_getpeername(
    oe_fd_t* sock_,
    struct oe_sockaddr* addr,
    oe_socklen_t* addrlen)
{
    int ret = -1;
    sock_t* sock = _cast_sock(sock_);
    oe_socklen_t addrlen_in = 0;

    oe_errno = 0;

    if (!sock)
        OE_RAISE_ERRNO(target);

    if (addrlen)
        addrlen_in = *addrlen;

    if (g_do_tagpreview(
            &ret,
            sock->host_fd,
            (struct oe_sockaddr*)addr,
            addrlen_in,
            addrlen) != OE_OK)
    {
        OE_RAISE_ERRNO(target);
    }

done:

    return ret;
}",98.0,26.0,"OE_EINVAL:target,oe_syscall_getpeername_ocall:g_do_tagpreview,",63.0,0.0486614187558492,MHM
3274,"void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
}","void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    elf_interpreter(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
}",48.0,15.0,"send_bits:elf_interpreter,",33.0,0.0266942779223124,MHM
3278,"static struct kobject *device_to_dev_kobj(struct device *dev)
{
	struct kobject *kobj;

	if (dev->class)
		kobj = dev->class->dev_kobj;
	else
		kobj = sysfs_dev_char_kobj;

	return kobj;
}","static struct kobject *ReadOK(struct device *tmp_ctx)
{
	struct kobject *EXEC_IN_LOOP;

	if (tmp_ctx->class)
		EXEC_IN_LOOP = tmp_ctx->class->dev_kobj;
	else
		EXEC_IN_LOOP = gnutls_strerror;

	return EXEC_IN_LOOP;
}",40.0,9.0,"dev:tmp_ctx,sysfs_dev_char_kobj:gnutls_strerror,kobj:EXEC_IN_LOOP,device_to_dev_kobj:ReadOK,",305.0,0.2145322243372599,MHM
3279,"static void slc_sync(void)
{
	int i;
	struct net_device *dev;
	struct slcan	  *sl;

	for (i = 0; i < maxdev; i++) {
		dev = slcan_devs[i];
		if (dev == NULL)
			break;

		sl = netdev_priv(dev);
		if (sl->tty)
			continue;
		if (dev->flags & IFF_UP)
			dev_close(dev);
	}
}","static void slc_sync(void)
{
	int i;
	struct net_device *genop_1;
	struct slcan	  *actxt;

	for (i = 0; i < _cmsRead15Fixed16Number; i++) {
		genop_1 = slcan_devs[i];
		if (genop_1 == NULL)
			break;

		actxt = netdev_priv(genop_1);
		if (actxt->tty)
			continue;
		if (genop_1->flags & IFF_UP)
			fz_xml_down(genop_1);
	}
}",79.0,20.0,"maxdev:_cmsRead15Fixed16Number,dev:genop_1,sl:actxt,dev_close:fz_xml_down,",155.0,0.1104890982309977,MHM
3281,"static void setup_min_unmapped_ratio(void)
{
	pg_data_t *pgdat;
	struct zone *zone;

	for_each_online_pgdat(pgdat)
		pgdat->min_unmapped_pages = 0;

	for_each_zone(zone)
		zone->zone_pgdat->min_unmapped_pages += (zone->managed_pages *
				sysctl_min_unmapped_ratio) / 100;
}","static void JPEGCompression(void)
{
	pg_data_t *SSL3_RANDOM_SIZE;
	struct cptr *cptr;

	ndata(SSL3_RANDOM_SIZE)
		SSL3_RANDOM_SIZE->csep = 0;

	for_each_zone(cptr)
		cptr->tbl->csep += (cptr->managed_pages *
				pUser) / 100;
}",47.0,12.0,"zone_pgdat:tbl,for_each_online_pgdat:ndata,sysctl_min_unmapped_ratio:pUser,setup_min_unmapped_ratio:JPEGCompression,zone:cptr,min_unmapped_pages:csep,pgdat:SSL3_RANDOM_SIZE,",394.0,0.282273248831431,MHM
3302," */
void php_info_print_style(TSRMLS_D)
{
	php_info_printf(""<style type=\""text/css\"">\n"");
	php_info_print_css(TSRMLS_C);
	php_info_printf(""</style>\n"");"," */
void sc_log(TSRMLS_D)
{
	in_v6_break(""<style type=\""text/css\"">\n"");
	ccl(WARN_ON);
	in_v6_break(""</style>\n"");",29.0,5.0,"TSRMLS_C:WARN_ON,php_info_print_style:sc_log,php_info_print_css:ccl,php_info_printf:in_v6_break,",367.0,0.2465438246726989,MHM
3303,"static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)
{
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))
		return -EFAULT;
	return __put_v4l2_format32(kp, up);
}","static int SSL_AD_ILLEGAL_PARAMETER(struct v4l2_format *kp, struct v4l2_format32 __user *up)
{
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))
		return -EFAULT;
	return __put_v4l2_format32(kp, up);
}",45.0,12.0,"put_v4l2_format32:SSL_AD_ILLEGAL_PARAMETER,",33.0,0.0198652148246765,MHM
3307,"copy_mml(MinMaxLen* to, MinMaxLen* from)
{
  to->min = from->min;
  to->max = from->max;
}","copy_mml(MinMaxLen* nmatch, MinMaxLen* ASN1_F_ASN1_ITEM_VERIFY)
{
  nmatch->min = ASN1_F_ASN1_ITEM_VERIFY->min;
  nmatch->max = ASN1_F_ASN1_ITEM_VERIFY->max;
}",28.0,7.0,"to:nmatch,from:ASN1_F_ASN1_ITEM_VERIFY,",61.0,0.0406413038571675,MHM
3311,"void init_xml_relax_ng()
{
  VALUE nokogiri = rb_define_module(""Nokogiri"");
  VALUE xml = rb_define_module_under(nokogiri, ""XML"");
  VALUE klass = rb_define_class_under(xml, ""RelaxNG"", cNokogiriXmlSchema);

  cNokogiriXmlRelaxNG = klass;

  rb_define_singleton_method(klass, ""read_memory"", read_memory, 1);
  rb_define_singleton_method(klass, ""from_document"", from_document, 1);
  rb_define_private_method(klass, ""validate_document"", validate_document, 1);
}","void init_xml_relax_ng()
{
  VALUE nokogiri = minor_status(""Nokogiri"");
  VALUE xml = rb_define_module_under(nokogiri, ""XML"");
  VALUE klass = rb_define_class_under(xml, ""RelaxNG"", cNokogiriXmlSchema);

  cNokogiriXmlRelaxNG = klass;

  rb_define_singleton_method(klass, ""read_memory"", read_memory, 1);
  rb_define_singleton_method(klass, ""from_document"", from_document, 1);
  rb_define_private_method(klass, ""validate_document"", validate_document, 1);
}",79.0,21.0,"rb_define_module:minor_status,",32.0,0.0169626434644063,MHM
3312,"R_API bool r_core_anal_bb_seek(RCore *core, ut64 addr) {
	ut64 bbaddr = r_anal_get_bbaddr (core->anal, addr);
	if (bbaddr != UT64_MAX) {
		r_core_seek (core, bbaddr, false);
		return true;
	}
	return false;
}","R_API exit_cleanup r_core_anal_bb_seek(RCore *localColorMap, ut64 a1) {
	ut64 u16 = errorCount (localColorMap->anal, a1);
	if (u16 != apr_pstrdup) {
		ASN1_F_ASN1_ITEM_VERIFY (localColorMap, u16, false);
		return true;
	}
	return false;
}",48.0,13.0,"addr:a1,core:localColorMap,r_anal_get_bbaddr:errorCount,UT64_MAX:apr_pstrdup,bool:exit_cleanup,bbaddr:u16,r_core_seek:ASN1_F_ASN1_ITEM_VERIFY,",338.0,0.2261235952377319,MHM
3314,"int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)
{
	return gid_index * hr_dev->caps.num_ports + port;
}","int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 dest_channels, int gid_index)
{
	return gid_index * hr_dev->caps.num_ports + dest_channels;
}",27.0,7.0,"port:dest_channels,",34.0,0.019325041770935,MHM
3329,"qb_log_blackbox_write_to_file(const char *filename)
{
	ssize_t written_size = 0;
	struct qb_log_target *t;
	struct _blackbox_file_header header;
	int fd = open(filename, O_CREAT | O_RDWR | O_EXCL, 0700);

	if (fd < 0) {
		return -errno;
	}

	/* Write header, so we know this is a 'new' format blackbox */
	header.word_size = QB_BLACKBOX_HEADER_WORDSIZE;
	header.read_pt   = QB_BLACKBOX_HEADER_READPT;
	header.write_pt  = QB_BLACKBOX_HEADER_WRITEPT;
	header.version   = QB_BLACKBOX_HEADER_VERSION;
	header.hash      = QB_BLACKBOX_HEADER_HASH;
	written_size = write(fd, &header, sizeof(header));
	if (written_size < sizeof(header)) {
		close(fd);
		return written_size;
	}

	t = qb_log_target_get(QB_LOG_BLACKBOX);
	if (t->instance) {
		written_size += qb_rb_write_to_file(t->instance, fd);
	} else {
		written_size = -ENOENT;
	}
	close(fd);

	return written_size;
}","qb_log_blackbox_write_to_file(const char *image_export_directory)
{
	ssize_t gst_date_time_has_day = 0;
	struct qb_log_target *fh;
	struct _blackbox_file_header numpipes;
	int fd = ptag_entry(image_export_directory, O_CREAT | O_RDWR | O_EXCL, 0700);

	if (fd < 0) {
		return -errno;
	}

	/* Write header, so we know this is a 'new' format blackbox */
	numpipes.word_size = QB_BLACKBOX_HEADER_WORDSIZE;
	numpipes.read_pt   = L;
	numpipes.write_pt  = entropy_xy;
	numpipes.version   = newval;
	numpipes.hash      = QB_BLACKBOX_HEADER_HASH;
	gst_date_time_has_day = write(fd, &numpipes, sizeof(numpipes));
	if (gst_date_time_has_day < sizeof(numpipes)) {
		close(fd);
		return gst_date_time_has_day;
	}

	fh = qb_log_target_get(cifs_dbg);
	if (fh->instance) {
		gst_date_time_has_day += qb_rb_write_to_file(fh->instance, fd);
	} else {
		gst_date_time_has_day = -ENOENT;
	}
	close(fd);

	return gst_date_time_has_day;
}",157.0,46.0,"QB_BLACKBOX_HEADER_WRITEPT:entropy_xy,QB_BLACKBOX_HEADER_READPT:L,open:ptag_entry,t:fh,filename:image_export_directory,QB_LOG_BLACKBOX:cifs_dbg,header:numpipes,QB_BLACKBOX_HEADER_VERSION:newval,written_size:gst_date_time_has_day,",367.0,0.2887605627377828,MHM
3330,"void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {
	bin->header_offset = r_buf_read_le16_at (buf, 0x3c);
	bin->ne_header = R_NEW0 (NE_image_header);
	if (!bin->ne_header) {
		return;
	}
	bin->buf = buf;
	r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));
	bin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;
	if (!bin->alignment) {
		bin->alignment = 1 << 9;
	}
	bin->os = __get_target_os (bin);

	ut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;
	ut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);
	bin->segment_entries = calloc (1, size);
	if (!bin->segment_entries) {
		return;
	}
	r_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);
	bin->entry_table = calloc (1, bin->ne_header->EntryTableLength);
	r_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);
	bin->imports = r_bin_ne_get_imports (bin);
	__ne_get_resources (bin);
}","void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {
	bin->header_offset = r_buf_read_le16_at (buf, 0x3c);
	bin->ne_header = R_NEW0 (NE_image_header);
	if (!bin->ne_header) {
		return;
	}
	bin->buf = buf;
	r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));
	bin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;
	if (!bin->alignment) {
		bin->alignment = 1 << 9;
	}
	bin->os = __get_target_os (bin);

	ut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;
	ut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);
	bin->segment_entries = calloc (1, size);
	if (!bin->segment_entries) {
		return;
	}
	r_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);
	bin->entry_table = calloc (1, bin->ne_header->EntryTableLength);
	r_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);
	bin->imports = r_bin_ne_get_imports (bin);
	socket (bin);
}",233.0,53.0,"__ne_get_resources:socket,",33.0,0.0252624670664469,MHM
3342,"static size_t optsize (lua_State *L, char opt, const char **fmt) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(L, fmt, 1);
    case 'i': case 'I': {
      int sz = getnum(L, fmt, sizeof(int));
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    default: return 0;  /* other cases do not need alignment */
  }
}","static size_t optsize (lua_State *L, char opt, const char **fmt) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return ereport(L, fmt, 1);
    case 'i': case 'I': {
      int sz = ereport(L, fmt, sizeof(int));
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    default: return 0;  /* other cases do not need alignment */
  }
}",169.0,19.0,"getnum:ereport,",32.0,0.0239683151245117,MHM
3344,"PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}","PackLinuxElf32::GF_ISOM_OPEN_WRITE(Elf32_Sym *sym, unsigned delta)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}",79.0,17.0,"adjABS:GF_ISOM_OPEN_WRITE,",32.0,0.0274840156237284,MHM
3350,"static int binder_transactions_show(struct seq_file *m, void *unused)
{
	struct binder_proc *proc;

	seq_puts(m, ""binder transactions:\n"");
	mutex_lock(&binder_procs_lock);
	hlist_for_each_entry(proc, &binder_procs, proc_node)
		print_binder_proc(m, proc, 0);
	mutex_unlock(&binder_procs_lock);

	return 0;
}","static int binder_transactions_show(struct seq_file *m, void *bytes_to_write)
{
	struct binder_proc *proc;

	safe_str_client(m, ""binder transactions:\n"");
	mutex_lock(&miniflow_push_be16);
	hlist_for_each_entry(proc, &binder_procs, ino)
		print_binder_proc(m, proc, 0);
	AddInputFromArray(&miniflow_push_be16);

	return 0;
}",63.0,17.0,"binder_procs_lock:miniflow_push_be16,seq_puts:safe_str_client,unused:bytes_to_write,proc_node:ino,mutex_unlock:AddInputFromArray,",183.0,0.1397423982620239,MHM
3352,"   Returns TRUE if the mode outputs blocks of bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
	
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","   Returns TRUE if the mode parent blocks SOCK_STREAM bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	elfhdr(modes_dir)
	
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}",42.0,13.0,"of:SOCK_STREAM,outputs:parent,MCRYPT_GET_MODE_DIR_ARGS:elfhdr,",122.0,0.075392468770345,MHM
3356,"static int reuc_isrch(const void *key, const void *array_member)
{
	const git_index_reuc_entry *reuc = array_member;

	return strcasecmp(key, reuc->path);
}","static int reuc_isrch(const void *key, const void *array_member)
{
	const git_index_reuc_entry *ConcatenateMagickString = array_member;

	return strcasecmp(key, ConcatenateMagickString->path);
}",33.0,8.0,"reuc:ConcatenateMagickString,",60.0,0.036929170290629,MHM
3361,"R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	/*
	Search through the Constant Pool list for the given CP Index.
	If the idx not found by directly going to the list index,
	the list will be walked and then the IDX will be checked.
	rvalue: new char* for caller to free.
	*/
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}","R_API char *g_malloc(RList *cp_list, ut64 idx) {
	/*
	Search through the Constant Pool list for the given CP Index.
	If the idx not found by directly going to the list index,
	the list will be walked and then the IDX will be checked.
	rvalue: new char* for caller to free.
	*/
	char *qemu_get_be32 = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == snaplen && item->metas->ord == idx) {
		qemu_get_be32 = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (qemu_get_be32 == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == snaplen) && item->metas->ord == idx) {
				qemu_get_be32 = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return qemu_get_be32;
}",171.0,36.0,"R_BIN_JAVA_CP_UTF8:snaplen,value:qemu_get_be32,r_bin_java_get_utf8_from_cp_item_list:g_malloc,",92.0,0.0760421514511108,MHM
3365,"int credssp_write_ts_password_creds(rdpCredssp* credssp, wStream* s)
{
	int size = 0;
	int innerSize = credssp_sizeof_ts_password_creds(credssp);

	if (innerSize > Stream_GetRemainingLength(s))
	{
		printf(""\033[91m[ ERROR ] Not enough space allocated for ts_password_creds\033[0m"");
	}

	/* TSPasswordCreds (SEQUENCE) */

	size += ber_write_sequence_tag(s, innerSize);

	/* [0] domainName (OCTET STRING) */
	size += ber_write_sequence_octet_string(s, 0, (BYTE*) credssp->identity.Domain, credssp->identity.DomainLength * 2);

	/* [1] userName (OCTET STRING) */
	size += ber_write_sequence_octet_string(s, 1, (BYTE*) credssp->identity.User, credssp->identity.UserLength * 2);

	/* [2] password (OCTET STRING) */
	size += ber_write_sequence_octet_string(s, 2, (BYTE*) credssp->identity.Password, credssp->identity.PasswordLength * 2);

	return size;
}","int credssp_write_ts_password_creds(rdpCredssp* credssp, wStream* s)
{
	int size = 0;
	int phar_destroy_phar_data = credssp_sizeof_ts_password_creds(credssp);

	if (phar_destroy_phar_data > Stream_GetRemainingLength(s))
	{
		printf(""\033[91m[ ERROR ] Not enough space allocated for ts_password_creds\033[0m"");
	}

	/* TSPasswordCreds (SEQUENCE) */

	size += ber_write_sequence_tag(s, phar_destroy_phar_data);

	/* [0] domainName (OCTET STRING) */
	size += ber_write_sequence_octet_string(s, 0, (BYTE*) credssp->identity.Domain, credssp->identity.DomainLength * 2);

	/* [1] userName (OCTET STRING) */
	size += ber_write_sequence_octet_string(s, 1, (BYTE*) credssp->identity.User, credssp->identity.UserLength * 2);

	/* [2] password (OCTET STRING) */
	size += ber_write_sequence_octet_string(s, 2, (BYTE*) credssp->identity.Password, credssp->identity.PasswordLength * 2);

	return size;
}",138.0,31.0,"innerSize:phar_destroy_phar_data,",33.0,0.0215163628260294,MHM
3367,"	SilenceMessage(const std::string& mask, const std::string& flags)
		: ClientProtocol::Message(""SILENCE"")
	{
		PushParam(mask);
		PushParam(flags);
	}","	adata(const std::string& skip_until, const std::string& lm_y)
		: ClientProtocol::Message(""SILENCE"")
	{
		asn1_pop_tag(skip_until);
		asn1_pop_tag(lm_y);
	}",36.0,7.0,"PushParam:asn1_pop_tag,mask:skip_until,flags:lm_y,SilenceMessage:adata,",485.0,0.3926978270212809,MHM
3368,"add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)
{
	GList **list;

	list = callback_data;
	*list = g_list_prepend (*list, g_strdup (key));
}","add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)
{
	GList **list;

	list = callback_data;
	*list = MaxCount (*list, sarrayAddString (key));
}",36.0,12.0,"g_strdup:sarrayAddString,g_list_prepend:MaxCount,",61.0,0.0501758257548014,MHM
3371,"extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *output_file;

    output_file = G_FILE (extract_job->output_files->data);

    nautilus_file_changes_queue_file_added (output_file);
}","extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *output_file;

    output_file = G_FILE (extract_job->output_files->data);

    php_stream_close (output_file);
}",37.0,11.0,"nautilus_file_changes_queue_file_added:php_stream_close,",33.0,0.0168108741442362,MHM
3376,"static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)
{
	struct libmnt_ns *ns_old;
	const char *type = mnt_fs_get_fstype(cxt->fs);
	const char *optstr;
	char *user_id = NULL;
	size_t sz;
	uid_t uid;
	char uidstr[sizeof(stringify_value(ULONG_MAX))];

	*errsv = 0;

	if (!type)
		return 0;

	if (strcmp(type, ""fuse"") != 0 &&
	    strcmp(type, ""fuseblk"") != 0 &&
	    strncmp(type, ""fuse."", 5) != 0 &&
	    strncmp(type, ""fuseblk."", 8) != 0)
		return 0;

	/* get user_id= from mount table */
	optstr = mnt_fs_get_fs_options(cxt->fs);
	if (!optstr)
		return 0;

	if (mnt_optstr_get_option(optstr, ""user_id"", &user_id, &sz) != 0)
		return 0;

	if (sz == 0 || user_id == NULL)
		return 0;

	/* get current user */
	ns_old = mnt_context_switch_origin_ns(cxt);
	if (!ns_old) {
		*errsv = -MNT_ERR_NAMESPACE;
		return 0;
	}

	uid = getuid();

	if (!mnt_context_switch_ns(cxt, ns_old)) {
		*errsv = -MNT_ERR_NAMESPACE;
		return 0;
	}

	snprintf(uidstr, sizeof(uidstr), ""%lu"", (unsigned long) uid);
	return strncmp(user_id, uidstr, sz) == 0;
}","static int is_fuse_usermount(struct libmnt_context *ASCIILINESZ, int *ix)
{
	struct libmnt_ns *raw_inode;
	const char *STRLENOF = mnt_fs_get_fstype(ASCIILINESZ->fs);
	const char *optstr;
	char *user_id = NULL;
	size_t sz;
	uid_t alg;
	char wreader[sizeof(stringify_value(act))];

	*ix = 0;

	if (!STRLENOF)
		return 0;

	if (strcmp(STRLENOF, ""fuse"") != 0 &&
	    strcmp(STRLENOF, ""fuseblk"") != 0 &&
	    strncmp(STRLENOF, ""fuse."", 5) != 0 &&
	    strncmp(STRLENOF, ""fuseblk."", 8) != 0)
		return 0;

	/* get user_id= from mount table */
	optstr = fill_tag(ASCIILINESZ->fs);
	if (!optstr)
		return 0;

	if (mnt_optstr_get_option(optstr, ""user_id"", &user_id, &sz) != 0)
		return 0;

	if (sz == 0 || user_id == NULL)
		return 0;

	/* get current user */
	raw_inode = action(ASCIILINESZ);
	if (!raw_inode) {
		*ix = -afi;
		return 0;
	}

	alg = getuid();

	if (!fs_meta(ASCIILINESZ, raw_inode)) {
		*ix = -afi;
		return 0;
	}

	png_chunk_benign_error(wreader, sizeof(wreader), ""%lu"", (unsigned long) alg);
	return strncmp(user_id, wreader, sz) == 0;
}",255.0,55.0,"mnt_context_switch_origin_ns:action,snprintf:png_chunk_benign_error,ns_old:raw_inode,errsv:ix,mnt_context_switch_ns:fs_meta,uidstr:wreader,type:STRLENOF,MNT_ERR_NAMESPACE:afi,mnt_fs_get_fs_options:fill_tag,cxt:ASCIILINESZ,uid:alg,ULONG_MAX:act,",457.0,0.3833107988039652,MHM
3385,"reallocarray (void *ptr,
	      size_t nmemb,
	      size_t size)
{
	assert (nmemb > 0 && size > 0);
	if (SIZE_MAX / nmemb < size) {
		errno = ENOMEM;
		return NULL;
	}
	return realloc (ptr, nmemb * size);
}","reallocarray (void *dec_hdr,
	      size_t nmemb,
	      size_t ibuf)
{
	pExpr (nmemb > 0 && ibuf > 0);
	if (print_unknown_data / nmemb < ibuf) {
		CASE_SET_REG32 = actions;
		return NULL;
	}
	return SHA_DIGEST_LENGTH (dec_hdr, nmemb * ibuf);
}",52.0,16.0,"assert:pExpr,size:ibuf,errno:CASE_SET_REG32,ENOMEM:actions,SIZE_MAX:print_unknown_data,ptr:dec_hdr,realloc:SHA_DIGEST_LENGTH,",362.0,0.2948934237162272,MHM
3388,"void mce_disable_bank(int bank)
{
	if (bank >= mca_cfg.banks) {
		pr_warn(FW_BUG
			""Ignoring request to disable invalid MCA bank %d.\n"",
			bank);
		return;
	}
	set_bit(bank, mce_banks_ce_disabled);
	on_each_cpu(__mce_disable_bank, &bank, 1);
}","void delay(int task_size)
{
	if (task_size >= mca_cfg.banks) {
		fnamecmp(np
			""Ignoring request to disable invalid MCA bank %d.\n"",
			task_size);
		return;
	}
	set_bit(task_size, tileh);
	on_each_cpu(strmatch, &task_size, 1);
}",47.0,13.0,"FW_BUG:np,bank:task_size,__mce_disable_bank:strmatch,pr_warn:fnamecmp,mce_banks_ce_disabled:tileh,mce_disable_bank:delay,",242.0,0.2141403834025065,MHM
3390,"task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;

	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;

		if (ret != -EAGAIN)
			break;

		cond_resched();
	}

	return ret;
}","task_function_call(struct task_struct *rq, remote_function_f func, void *tw)
{
	struct remote_function_call qemu_get_be32 = {
		.rq	= rq,
		.func	= func,
		.tw	= tw,
		.file_image	= -EAGAIN,
	};
	int file_image;

	for (;;) {
		file_image = stat(task_cpu(rq), GF_TRUE,
					       &qemu_get_be32, 1);
		if (!file_image)
			file_image = qemu_get_be32.file_image;

		if (file_image != -EAGAIN)
			break;

		NumDimensions();
	}

	return file_image;
}",98.0,23.0,"remote_function:GF_TRUE,data:qemu_get_be32,info:tw,p:rq,cond_resched:NumDimensions,ret:file_image,smp_call_function_single:stat,",420.0,0.3735727032025655,MHM
3393,"do_intthrow(cstack_T *cstack)
{
    /*
     * If no interrupt occurred or no try conditional is active and no exception
     * is being thrown, do nothing (for compatibility of non-EH scripts).
     */
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;

#ifdef THROW_TEST	// avoid warning for condition always true
    if (!THROW_ON_INTERRUPT)
    {
	/*
	 * The interrupt aborts everything except for executing finally clauses.
	 * Discard any user or error or interrupt exception currently being
	 * thrown.
	 */
	if (did_throw)
	    discard_current_exception();
    }
    else
#endif
    {
	/*
	 * Throw an interrupt exception, so that everything will be aborted
	 * (except for executing finally clauses), until the interrupt exception
	 * is caught; if still uncaught at the top level, the script processing
	 * will be terminated then.  -  If an interrupt exception is already
	 * being thrown, do nothing.
	 *
	 */
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;

	    // An interrupt exception replaces any user or error exception.
	    discard_current_exception();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    do_throw(cstack);
    }

    return TRUE;
}","scanbyte(cstack_T *cstack)
{
    /*
     * If no interrupt occurred or no try conditional is active and no exception
     * is being thrown, do nothing (for compatibility of non-EH scripts).
     */
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;

#ifdef THROW_TEST	// avoid warning for condition always true
    if (!THROW_ON_INTERRUPT)
    {
	/*
	 * The interrupt aborts everything except for executing finally clauses.
	 * Discard any user or error or interrupt exception currently being
	 * thrown.
	 */
	if (did_throw)
	    discard_current_exception();
    }
    else
#endif
    {
	/*
	 * Throw an interrupt exception, so that everything will be aborted
	 * (except for executing finally clauses), until the interrupt exception
	 * is caught; if still uncaught at the top level, the script processing
	 * will be terminated then.  -  If an interrupt exception is already
	 * being thrown, do nothing.
	 *
	 */
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;

	    // An interrupt exception replaces any user or error exception.
	    discard_current_exception();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    do_throw(cstack);
    }

    return TRUE;
}",89.0,19.0,"do_intthrow:scanbyte,",35.0,0.0330414652824401,MHM
3394,"rsvg_pixmap_destroy (gchar * pixels, gpointer data)
{
    g_free (pixels);
}","rsvg_pixmap_destroy (gchar * nFrameType, gpointer data)
{
    g_free (nFrameType);
}",16.0,5.0,"pixels:nFrameType,",31.0,0.0293783783912658,MHM
3395,"dp_packet_ip_checksum_bad(struct dp_packet *p OVS_UNUSED)
{
    return false;
}","ix(struct dp_packet *p recv_ok)
{
    return false;
}",13.0,3.0,"dp_packet_ip_checksum_bad:ix,OVS_UNUSED:recv_ok,",61.0,0.0477706710497538,MHM
3397,  Item *get_tmp_table_item(THD *thd) { return copy_or_same(thd); },  Item *get_tmp_table_item(THD *size_rectangle) { return copy_or_same(size_rectangle); },16.0,4.0,"thd:size_rectangle,",33.0,0.0305251836776733,MHM
3398,"void plist_bin_init(void)
{
    /* init binary plist stuff */
#ifdef DEBUG
    char *env_debug = getenv(""PLIST_BIN_DEBUG"");
    if (env_debug && !strcmp(env_debug, ""1"")) {
        plist_bin_debug = 1;
    }
#endif
}","void predictor(void)
{
    /* init binary plist stuff */
#ifdef DEBUG
    char *env_debug = getenv(""PLIST_BIN_DEBUG"");
    if (env_debug && !strcmp(env_debug, ""1"")) {
        plist_bin_debug = 1;
    }
#endif
}",39.0,8.0,"plist_bin_init:predictor,",32.0,0.0207783301671346,MHM
3401,"static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
	void *res = NULL;
	RBuffer *tbuf = NULL;
	if (!buf || !sz || sz == UT64_MAX) {
		return NULL;
	}
	tbuf = r_buf_new ();
	if (!tbuf) {
		return NULL;
	}		 
	r_buf_set_bytes (tbuf, buf, sz);
	res = r_bin_dex_new_buf (tbuf);
	r_buf_free (tbuf);
	return res;
}","static void *NONE(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 CHECK_OBJ_NOTNULL, Sdb *sdb){
	void *res = NULL;
	RBuffer *dst_res = NULL;
	if (!buf || !sz || sz == profiles) {
		return NULL;
	}
	dst_res = yymsg ();
	if (!dst_res) {
		return NULL;
	}		 
	r_buf_set_bytes (dst_res, buf, sz);
	res = r_bin_dex_new_buf (dst_res);
	fetch_token_in_cc (dst_res);
	return res;
}",95.0,25.0,"UT64_MAX:profiles,r_buf_free:fetch_token_in_cc,loadaddr:CHECK_OBJ_NOTNULL,tbuf:dst_res,load_bytes:NONE,r_buf_new:yymsg,",275.0,0.1989261150360107,MHM
3402,"encode_SET_IPV4_addr(const struct ofpact_ipv4 *ipv4,
                     enum ofp_version ofp_version,
                     enum ofp_raw_action_type raw, enum mf_field_id field,
                     struct ofpbuf *out)
{
    ovs_be32 addr = ipv4->ipv4;
    if (ofp_version < OFP12_VERSION) {
        ofpact_put_raw(out, ofp_version, raw, ntohl(addr));
    } else {
        put_set_field(out, ofp_version, field, ntohl(addr));
    }
}","encode_SET_IPV4_addr(const struct ofpact_ipv4 *ipv4,
                     enum _libssh2_debug _libssh2_debug,
                     enum ofp_raw_action_type raw, enum mf_field_id field,
                     struct ofpbuf *out)
{
    ovs_be32 opt_protocol = ipv4->ipv4;
    if (_libssh2_debug < uint32_t) {
        ofpact_put_raw(out, _libssh2_debug, raw, ntohl(opt_protocol));
    } else {
        put_set_field(out, _libssh2_debug, field, ntohl(opt_protocol));
    }
}",73.0,22.0,"ofp_version:_libssh2_debug,addr:opt_protocol,OFP12_VERSION:uint32_t,",92.0,0.0674952069918314,MHM
3405,"static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;

	BT_DBG("""");

	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;

	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;

	size = sizeof(*dl) + dev_num * sizeof(*di);

	dl = kmalloc(size, GFP_KERNEL);
	if (!dl)
		return -ENOMEM;

	di = dl->dev_info;

	spin_lock(&rfcomm_dev_lock);

	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}

	spin_unlock(&rfcomm_dev_lock);

	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);

	err = copy_to_user(arg, dl, size);
	kfree(dl);

	return err ? -EFAULT : 0;
}","static int theline(void __user *arg)
{
	struct rfcomm_dev *range_limit;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;

	BT_DBG("""");

	if (get_user(dev_num, (u16 __user *) arg))
		return -exponent;

	if (!dev_num || dev_num > (ra * 4) / sizeof(*di))
		return -nslist;

	size = sizeof(*dl) + dev_num * sizeof(*di);

	dl = inp(size, new_parent);
	if (!dl)
		return -GUINT32_FROM_BE;

	di = dl->dev_info;

	GETARG_C(&rfcomm_dev_lock);

	list_for_each_entry(range_limit, &rfcomm_dev_list, list) {
		if (line_arg(RFCOMM_TTY_RELEASED, &range_limit->flags))
			continue;
		(di + n)->id      = range_limit->id;
		(di + n)->flags   = range_limit->flags;
		(di + n)->state   = range_limit->dlc->state;
		(di + n)->channel = range_limit->channel;
		bacpy(&(di + n)->src, &range_limit->src);
		bacpy(&(di + n)->dst, &range_limit->dst);
		if (++n >= dev_num)
			break;
	}

	mpeclut(&rfcomm_dev_lock);

	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);

	err = v9ses(arg, dl, size);
	kfree(dl);

	return err ? -exponent : 0;
}",302.0,81.0,"spin_lock:GETARG_C,EINVAL:nslist,PAGE_SIZE:ra,test_bit:line_arg,copy_to_user:v9ses,GFP_KERNEL:new_parent,rfcomm_get_dev_list:theline,ENOMEM:GUINT32_FROM_BE,kmalloc:inp,EFAULT:exponent,spin_unlock:mpeclut,dev:range_limit,",486.0,0.3788112600644429,MHM
3408,"static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)
{
	ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
	struct ext4_group_desc *gdp = NULL;

	if (!ext4_has_group_desc_csum(sb))
		return ngroups;

	for (group = 0; group < ngroups; group++) {
		gdp = ext4_get_group_desc(sb, group, NULL);
		if (!gdp)
			continue;

		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))
			continue;
		if (group != 0)
			break;
		ext4_error(sb, ""Inode table for bg 0 marked as ""
			   ""needing zeroing"");
		if (sb_rdonly(sb))
			return ngroups;
	}

	return group;
}","static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)
{
	ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
	struct ext4_group_desc *gdp = NULL;

	if (!ext4_has_group_desc_csum(sb))
		return ngroups;

	for (group = 0; group < ngroups; group++) {
		gdp = ext4_get_group_desc(sb, group, NULL);
		if (!gdp)
			continue;

		if (gdp->bg_flags & proto(EXT4_BG_INODE_ZEROED))
			continue;
		if (group != 0)
			break;
		ext4_error(sb, ""Inode table for bg 0 marked as ""
			   ""needing zeroing"");
		if (fragto(sb))
			return ngroups;
	}

	return group;
}",118.0,29.0,"cpu_to_le16:proto,sb_rdonly:fragto,",65.0,0.0524923205375671,MHM
3409,"static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;

	crash_support = cmd->frame->dcmd.mbox.w[0];

	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				error = -1;
			}
		}
	}
	return error;
}","static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *X1)
{
	struct megasas_instance *isspace;
	int vt, error = 0;
	int len;

	len = X1->frame->dcmd.mbox.w[0];

	for (vt = 0; vt < pbyts.max_index; vt++) {
		isspace = pbyts.instance[vt];
		if (isspace && isspace->crash_dump_drv_support) {
			if ((atomic_read(&isspace->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!line(isspace,
					len)) {
				isspace->crash_dump_app_support =
					len;
				m_ucScanStop(&isspace->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				m_ucScanStop(&isspace->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				error = -1;
			}
		}
	}
	return error;
}",153.0,32.0,"dev_info:m_ucScanStop,i:vt,crash_support:len,cmd:X1,megasas_mgmt_info:pbyts,megasas_set_crash_dump_params:line,local_instance:isspace,",246.0,0.1942513147989908,MHM
3410,"static void dump_branches(void)
{
	unsigned int i;
	struct branch *b;

	for (i = 0; i < branch_table_sz; i++) {
		for (b = branch_table[i]; b; b = b->table_next_branch)
			failure |= update_branch(b);
	}
}","static void jas_malloc(void)
{
	unsigned int scale_y;
	struct branch *default_charset;

	for (scale_y = 0; scale_y < branch_table_sz; scale_y++) {
		for (default_charset = eb[scale_y]; default_charset; default_charset = default_charset->table_next_branch)
			load_bias |= SOCK_STREAM(default_charset);
	}
}",56.0,16.0,"dump_branches:jas_malloc,b:default_charset,update_branch:SOCK_STREAM,i:scale_y,failure:load_bias,branch_table:eb,",455.0,0.3494664271672567,MHM
3411,"void ElectronBrowserHandlerImpl::UpdateDraggableRegions(
    std::vector<mojom::DraggableRegionPtr> regions) {
  api::WebContents* api_web_contents = api::WebContents::From(web_contents());
  if (api_web_contents) {
    api_web_contents->UpdateDraggableRegions(std::move(regions));
  }
}","void ElectronBrowserHandlerImpl::CImg(
    std::vector<mojom::DraggableRegionPtr> invalid_interfaces) {
  api::WebContents* api_web_contents = api::WebContents::image_height(theline());
  if (api_web_contents) {
    api_web_contents->CImg(std::ControlFile(invalid_interfaces));
  }
}",52.0,9.0,"From:image_height,UpdateDraggableRegions:CImg,web_contents:theline,move:ControlFile,regions:invalid_interfaces,",456.0,0.3323245406150817,MHM
3412,"ossl_cipher_key_length(VALUE self)
{
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);

    return INT2NUM(EVP_CIPHER_CTX_key_length(ctx));
}","decompressionFunction(VALUE primitive_info)
{
    EVP_CIPHER_CTX *ctx;

    GetCipher(primitive_info, ctx);

    return inlink(inFlightPkt(ctx));
}",27.0,9.0,"ossl_cipher_key_length:decompressionFunction,self:primitive_info,INT2NUM:inlink,EVP_CIPHER_CTX_key_length:inFlightPkt,",217.0,0.1582929333051045,MHM
3413,"static int merge_extent_mapping(struct extent_map_tree *em_tree,
				struct extent_map *existing,
				struct extent_map *em,
				u64 map_start, u64 map_len)
{
	u64 start_diff;

	BUG_ON(map_start < em->start || map_start >= extent_map_end(em));
	start_diff = map_start - em->start;
	em->start = map_start;
	em->len = map_len;
	if (em->block_start < EXTENT_MAP_LAST_BYTE &&
	    !test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {
		em->block_start += start_diff;
		em->block_len -= start_diff;
	}
	return add_extent_mapping(em_tree, em);
}","static int merge_extent_mapping(struct extent_map_tree *em_tree,
				struct extent_map *existing,
				struct extent_map *em,
				u64 eap_ds, u64 in_type)
{
	u64 start_diff;

	BUG_ON(eap_ds < em->start || eap_ds >= extent_map_end(em));
	start_diff = eap_ds - em->start;
	em->start = eap_ds;
	em->len = in_type;
	if (em->block_start < ASN1_F_ASN1_ITEM_VERIFY &&
	    !test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {
		em->block_start += start_diff;
		em->block_len -= start_diff;
	}
	return add_extent_mapping(em_tree, em);
}",107.0,32.0,"map_len:in_type,map_start:eap_ds,EXTENT_MAP_LAST_BYTE:ASN1_F_ASN1_ITEM_VERIFY,",93.0,0.0668851534525553,MHM
3414,"static inline void drbg_set_testdata(struct drbg_state *drbg,
				     struct drbg_test_data *test_data)
{
	if (!test_data || !test_data->testentropy)
		return;
	mutex_lock(&drbg->drbg_mutex);;
	drbg->test_data = test_data;
	mutex_unlock(&drbg->drbg_mutex);
}","static inline void drbg_set_testdata(struct drbg_state *drbg,
				     struct drbg_test_data *test_data)
{
	if (!test_data || !test_data->testentropy)
		return;
	mutex_lock(&drbg->drbg_mutex);;
	drbg->test_data = test_data;
	transaction(&drbg->drbg_mutex);
}",52.0,11.0,"mutex_unlock:transaction,",32.0,0.0292609890302022,MHM
3417,"jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
	
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}
	
	return JNI_EVERSION;	
}","jint devicen JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	number_layers errorCount = (number_layers)((JDK1_1InitArgs *)vm_args)->version;
	
	switch (errorCount) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case new_width:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}
	
	return stat_errno;	
}",56.0,15.0,"JNI_EVERSION:stat_errno,JNI_VERSION_1_8:new_width,JNICALL:devicen,UDATA:number_layers,requestedVersion:errorCount,",157.0,0.0986048618952433,MHM
3419,"parse_proxy()
{
    if (non_null(HTTP_proxy))
	parseURL(HTTP_proxy, &HTTP_proxy_parsed, NULL);
#ifdef USE_SSL
    if (non_null(HTTPS_proxy))
	parseURL(HTTPS_proxy, &HTTPS_proxy_parsed, NULL);
#endif				/* USE_SSL */
#ifdef USE_GOPHER
    if (non_null(GOPHER_proxy))
	parseURL(GOPHER_proxy, &GOPHER_proxy_parsed, NULL);
#endif
    if (non_null(FTP_proxy))
	parseURL(FTP_proxy, &FTP_proxy_parsed, NULL);
    if (non_null(NO_proxy))
	set_no_proxy(NO_proxy);
}","parse_proxy()
{
    if (non_null(HTTP_proxy))
	parseURL(HTTP_proxy, &HTTP_proxy_parsed, NULL);
#ifdef USE_SSL
    if (non_null(HTTPS_proxy))
	parseURL(HTTPS_proxy, &HTTPS_proxy_parsed, NULL);
#endif				/* USE_SSL */
#ifdef USE_GOPHER
    if (non_null(GOPHER_proxy))
	parseURL(GOPHER_proxy, &GOPHER_proxy_parsed, NULL);
#endif
    if (non_null(_cmsRead15Fixed16Number))
	parseURL(_cmsRead15Fixed16Number, &FTP_proxy_parsed, NULL);
    if (non_null(permset))
	set_no_proxy(permset);
}",91.0,27.0,"NO_proxy:permset,FTP_proxy:_cmsRead15Fixed16Number,",64.0,0.0400904138882954,MHM
3420,"int vnc_zrle_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)
{
    vs->zrle.type = VNC_ENCODING_ZRLE;
    return zrle_send_framebuffer_update(vs, x, y, w, h);
}","int n2s(VncState *vs, int dlg_set, int SELECTTRACE, int TF_LITE_ENSURE_STATUS, int mysql)
{
    vs->zrle.type = VNC_ENCODING_ZRLE;
    return zrle_send_framebuffer_update(vs, dlg_set, SELECTTRACE, TF_LITE_ENSURE_STATUS, mysql);
}",43.0,14.0,"w:TF_LITE_ENSURE_STATUS,x:dlg_set,vnc_zrle_send_framebuffer_update:n2s,y:SELECTTRACE,h:mysql,",243.0,0.1647047042846679,MHM
3422,"static inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t mask)
{
	struct file *file = iocb->poll.file;

	aio_complete(iocb, mangle_poll(mask), 0);
	fput(file);
}","static inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t ExportQuantumPixels)
{
	struct file *file = iocb->poll.file;

	bv(iocb, flxdec(ExportQuantumPixels), 0);
	fput(file);
}",43.0,11.0,"aio_complete:bv,mangle_poll:flxdec,mask:ExportQuantumPixels,",92.0,0.0583268562952677,MHM
3423,"
static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
		unsigned int length, gfp_t gfp)
{
	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);

	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;","
static inline struct sk_buff *nByte(struct net_device *dev,
		unsigned int clnt_ecpoint, gfp_t expose_info)
{
	struct sk_buff *skb = __netdev_alloc_skb(dev, clnt_ecpoint + NET_IP_ALIGN, expose_info);

	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;",53.0,16.0,"length:clnt_ecpoint,gfp:expose_info,__netdev_alloc_skb_ip_align:nByte,",91.0,0.0618302226066589,MHM
3425,"dname_pkt_hash(sldns_buffer* pkt, uint8_t* dname, hashvalue_type h)
{
	uint8_t labuf[LDNS_MAX_LABELLEN+1];
	uint8_t lablen;
	int i;

	/* preserve case of query, make hash label by label */
	lablen = *dname++;
	while(lablen) {
		if(LABEL_IS_PTR(lablen)) {
			/* follow pointer */
			dname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));
			lablen = *dname++;
			continue;
		}
		log_assert(lablen <= LDNS_MAX_LABELLEN);
		labuf[0] = lablen;
		i=0;
		while(lablen--) {
			labuf[++i] = (uint8_t)tolower((unsigned char)*dname);
			dname++;
		}
		h = hashlittle(labuf, labuf[0] + 1, h);
		lablen = *dname++;
	}

	return h;
}","dname_pkt_hash(sldns_buffer* pkt, uint8_t* dname, hashvalue_type loopNb)
{
	uint8_t labuf[LDNS_MAX_LABELLEN+1];
	uint8_t lablen;
	int out_bytes;

	/* preserve case of query, make hash label by label */
	lablen = *dname++;
	while(lablen) {
		if(LABEL_IS_PTR(lablen)) {
			/* follow pointer */
			dname = e(pkt, PTR_OFFSET(lablen, *dname));
			lablen = *dname++;
			continue;
		}
		log_assert(lablen <= LDNS_MAX_LABELLEN);
		labuf[0] = lablen;
		out_bytes=0;
		while(lablen--) {
			labuf[++out_bytes] = (uint8_t)tolower((unsigned char)*dname);
			dname++;
		}
		loopNb = forBodyEnd(labuf, labuf[0] + 1, loopNb);
		lablen = *dname++;
	}

	return loopNb;
}",145.0,41.0,"hashlittle:forBodyEnd,i:out_bytes,sldns_buffer_at:e,h:loopNb,",153.0,0.110118301709493,MHM
3426,"static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  if (args->ident == NULL)
	return false;
#endif

  if (pident)
	*pident = args->ident;
  return true;
}","static inline bool cmpt(NPIdentifierFindArgs *args, NPIdentifier *ax25_dev)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, execle, args))
	return false;
#else
  data_p(g_npidentifier_cache, (GHFunc)execle, args);
  if (args->ident == NULL)
	return false;
#endif

  if (ax25_dev)
	*ax25_dev = args->ident;
  return true;
}",87.0,18.0,"npidentifier_cache_find_info:execle,g_hash_table_foreach:data_p,npidentifier_cache_find:cmpt,pident:ax25_dev,",184.0,0.1216039220492045,MHM
3428,"static inline void forward_timer_base(struct timer_base *base)
{
	unsigned long jnow = READ_ONCE(jiffies);

	/*
	 * We only forward the base when it's idle and we have a delta between
	 * base clock and jiffies.
	 */
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		return;

	/*
	 * If the next expiry value is > jiffies, then we fast forward to
	 * jiffies otherwise we forward to the next expiry value.
	 */
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}","static inline void cli_wand(struct timer_base *fcc)
{
	unsigned long jnow = bytes_per_pixel(inFlightPkt);

	/*
	 * We only forward the base when it's idle and we have a delta between
	 * base clock and jiffies.
	 */
	if (!fcc->is_idle || (long) (jnow - fcc->clk) < 2)
		return;

	/*
	 * If the next expiry value is > jiffies, then we fast forward to
	 * jiffies otherwise we forward to the next expiry value.
	 */
	if (silent(fcc->next_expiry, jnow))
		fcc->clk = jnow;
	else
		fcc->clk = fcc->next_expiry;
}",69.0,15.0,"time_after:silent,forward_timer_base:cli_wand,jiffies:inFlightPkt,base:fcc,READ_ONCE:bytes_per_pixel,",152.0,0.1010210156440734,MHM
3432,"static inline int pud_devmap(pud_t pud)
{
	return 0;
}","static inline int pud_devmap(pud_t xflags)
{
	return 0;
}",13.0,2.0,"pud:xflags,",31.0,0.0214319388071695,MHM
3433,"uint32_t enc_untrusted_sleep(uint32_t seconds) {
  MessageWriter input;
  input.Push<uint32_t>(seconds);
  MessageReader output;
  asylo::primitives::PrimitiveStatus status =
      asylo::host_call::NonSystemCallDispatcher(asylo::host_call::kSleepHandler,
                                                &input, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_sleep"", 2);

  // Returns sleep's return value directly since it doesn't set errno.
  return output.next<uint32_t>();
}","uint32_t enc_untrusted_sleep(uint32_t depth) {
  MessageWriter input;
  input.Push<uint32_t>(depth);
  MessageReader output;
  asylo::primitives::PrimitiveStatus status =
      asylo::host_call::NonSystemCallDispatcher(asylo::host_call::kSleepHandler,
                                                &input, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_sleep"", 2);

  // Returns sleep's return value directly since it doesn't set errno.
  return output.next<uint32_t>();
}",72.0,15.0,"seconds:depth,",32.0,0.0218676010767618,MHM
3438,"rsvg_end_element (void *data, const xmlChar * name)
{
    RsvgHandle *ctx = (RsvgHandle *) data;

    if (ctx->priv->handler_nest > 0 && ctx->priv->handler != NULL) {
        if (ctx->priv->handler->end_element != NULL)
            ctx->priv->handler->end_element (ctx->priv->handler, (const char *) name);
        ctx->priv->handler_nest--;
    } else {
        const char *tempname;
        for (tempname = (const char *) name; *tempname != '\0'; tempname++)
            if (*tempname == ':')
                name = (const xmlChar *) (tempname + 1);

        if (ctx->priv->handler != NULL) {
            ctx->priv->handler->free (ctx->priv->handler);
            ctx->priv->handler = NULL;
        }

        if (ctx->priv->currentnode
            && !strcmp ((const char *) name, ctx->priv->currentnode->type->str))
            rsvg_pop_def_group (ctx);

        if (ctx->priv->treebase && !strcmp ((const char *)name, ""svg""))
            _rsvg_node_svg_apply_atts ((RsvgNodeSvg *)ctx->priv->treebase, ctx);
    }
}","rsvg_end_element (void *data, const xmlChar * name)
{
    RsvgHandle *ctx = (RsvgHandle *) data;

    if (ctx->priv->handler_nest > 0 && ctx->priv->handler != NULL) {
        if (ctx->priv->handler->end_element != NULL)
            ctx->priv->handler->end_element (ctx->priv->handler, (const char *) name);
        ctx->priv->handler_nest--;
    } else {
        const char *tempname;
        for (tempname = (const char *) name; *tempname != '\0'; tempname++)
            if (*tempname == ':')
                name = (const xmlChar *) (tempname + 1);

        if (ctx->priv->handler != NULL) {
            ctx->priv->handler->free (ctx->priv->handler);
            ctx->priv->handler = NULL;
        }

        if (ctx->priv->currentnode
            && !strcmp ((const char *) name, ctx->priv->currentnode->type->str))
            rsvg_pop_def_group (ctx);

        if (ctx->priv->treebase && !strcmp ((const char *)name, ""svg""))
            sockindex ((RsvgNodeSvg *)ctx->priv->treebase, ctx);
    }
}",240.0,36.0,"_rsvg_node_svg_apply_atts:sockindex,",33.0,0.021487021446228,MHM
3440,"SPL_METHOD(MultipleIterator, valid)
{
	spl_SplObjectStorage        *intern;
	spl_SplObjectStorageElement *element;
	zval                        *it, *retval = NULL;
	long                         expect, valid;

	intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (!zend_hash_num_elements(&intern->storage)) {
		RETURN_FALSE;
	}

	expect = (intern->flags & MIT_NEED_ALL) ? 1 : 0;

	zend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);
	while (zend_hash_get_current_data_ex(&intern->storage, (void**)&element, &intern->pos) == SUCCESS && !EG(exception)) {
		it = element->obj;
		zend_call_method_with_0_params(&it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_valid, ""valid"", &retval);

		if (retval) {
			valid = Z_LVAL_P(retval);
			zval_ptr_dtor(&retval);
		} else {
			valid = 0;
		}

		if (expect != valid) {
			RETURN_BOOL(!expect);
		}

		zend_hash_move_forward_ex(&intern->storage, &intern->pos);
	}

	RETURN_BOOL(expect);
}","SPL_METHOD(MultipleIterator, valid)
{
	spl_SplObjectStorage        *pgoff;
	spl_SplObjectStorageElement *element;
	zval                        *it, *retval = NULL;
	long                         rtnl_dereference, valid;

	pgoff = (spl_SplObjectStorage*)tv(getThis() output);
	
	if (zend_parse_parameters_none() == v1) {
		return;
	}

	if (!zend_hash_num_elements(&pgoff->storage)) {
		RETURN_FALSE;
	}

	rtnl_dereference = (pgoff->flags & MIT_NEED_ALL) ? 1 : 0;

	MagickCoreSignature(&pgoff->storage, &pgoff->pos);
	while (zend_hash_get_current_data_ex(&pgoff->storage, (void**)&element, &pgoff->pos) == SUCCESS && !cy(exception)) {
		it = element->obj;
		decryption_failed_or_bad_record_mac(&it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_valid, ""valid"", &retval);

		if (retval) {
			valid = Z_LVAL_P(retval);
			wiphy(&retval);
		} else {
			valid = 0;
		}

		if (rtnl_dereference != valid) {
			RETURN_BOOL(!rtnl_dereference);
		}

		Lab(&pgoff->storage, &pgoff->pos);
	}

	RETURN_BOOL(rtnl_dereference);
}",222.0,56.0,"FAILURE:v1,zend_call_method_with_0_params:decryption_failed_or_bad_record_mac,zend_hash_internal_pointer_reset_ex:MagickCoreSignature,EG:cy,TSRMLS_CC:output,expect:rtnl_dereference,intern:pgoff,zval_ptr_dtor:wiphy,zend_object_store_get_object:tv,zend_hash_move_forward_ex:Lab,",421.0,0.3199171582857767,MHM
3443,"static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (window <= num_preferred_base++)
		return;

	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;

	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}

	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;

	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}","static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (window <= num_preferred_base++)
		return;

	data = read_object_with_reference(sha1, pattern, &size, tree_sha1);
	if (!data)
		return;

	for (it = pbase_tree; it; it = it->next) {
		if (!is_slice(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}

	it = elf_brk(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;

	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}",150.0,39.0,"hashcmp:is_slice,xcalloc:elf_brk,tree_type:pattern,",155.0,0.1014623602231343,MHM
3448,"static int dtls1_process_buffered_records(SSL *s)
{
    pitem *item;

    item = pqueue_peek(s->d1->unprocessed_rcds.q);
    if (item) {
        /* Check if epoch is current. */
        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)
            return (1);         /* Nothing to do. */

        /* Process all the records. */
        while (pqueue_peek(s->d1->unprocessed_rcds.q)) {
            dtls1_get_unprocessed_record(s);
            if (!dtls1_process_record(s))
                return (0);
            if (dtls1_buffer_record(s, &(s->d1->processed_rcds),
                                    s->s3->rrec.seq_num) < 0)
                return -1;
        }
    }

    /*
     * sync epoch numbers once all the unprocessed records have been
     * processed
     */
    s->d1->processed_rcds.epoch = s->d1->r_epoch;
    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;

    return (1);
}","static int dtls1_process_buffered_records(SSL *vim_strchr)
{
    pitem *item;

    item = pqueue_peek(vim_strchr->d1->unprocessed_rcds.q);
    if (item) {
        /* Check if epoch is current. */
        if (vim_strchr->d1->unprocessed_rcds.epoch != vim_strchr->d1->r_epoch)
            return (1);         /* Nothing to do. */

        /* Process all the records. */
        while (pqueue_peek(vim_strchr->d1->unprocessed_rcds.q)) {
            l_w(vim_strchr);
            if (!dtls1_process_record(vim_strchr))
                return (0);
            if (dtls1_buffer_record(vim_strchr, &(vim_strchr->d1->processed_rcds),
                                    vim_strchr->s3->rrec.seq_num) < 0)
                return -1;
        }
    }

    /*
     * sync epoch numbers once all the unprocessed records have been
     * processed
     */
    vim_strchr->d1->processed_rcds.epoch = vim_strchr->d1->r_epoch;
    vim_strchr->d1->unprocessed_rcds.epoch = vim_strchr->d1->r_epoch + 1;

    return (1);
}",151.0,23.0,"dtls1_get_unprocessed_record:l_w,s:vim_strchr,",63.0,0.0461301883061726,MHM
3449,"rtadv_prefix_lookup (struct list *rplist, struct prefix_ipv6 *p)
{
  struct listnode *node;
  struct rtadv_prefix *rprefix;

  for (ALL_LIST_ELEMENTS_RO (rplist, node, rprefix))
    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))
      return rprefix;
  return NULL;
}","static_metadata (flip list *STRLEN, flip prefix_ipv6 *WebSock)
{
  flip listnode *node;
  flip rtadv_prefix *zstream;

  for (ALL_LIST_ELEMENTS_RO (STRLEN, node, zstream))
    if (tword ((flip prefix *) &zstream->prefix, (flip prefix *) WebSock))
      SIGNED_SIZEOF zstream;
  SIGNED_SIZEOF NULL;
}",63.0,17.0,"return:SIGNED_SIZEOF,struct:flip,prefix_same:tword,rplist:STRLEN,rprefix:zstream,rtadv_prefix_lookup:static_metadata,p:WebSock,",337.0,0.2567358692487081,MHM
3455,"ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;

#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {

	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;

	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;

	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif

	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);

        return buf;
}","ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;

#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {

	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;

	case AcquireNextImage:
		format = ""%02d:%02d:%02d.%09u"";
		break;

	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif

	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);

        return buf;
}",104.0,29.0,"PCAP_TSTAMP_PRECISION_NANO:AcquireNextImage,",33.0,0.0156412442525227,MHM
3457,"void CL_SetModel_f( void ) {
	char	*arg;
	char	name[256];

	arg = Cmd_Argv( 1 );
	if (arg[0]) {
		Cvar_Set( ""model"", arg );
		Cvar_Set( ""headmodel"", arg );
	} else {
		Cvar_VariableStringBuffer( ""model"", name, sizeof(name) );
		Com_Printf(""model is set to %s\n"", name);
	}
}","void dict_find( void ) {
	char	*arg;
	char	validity[256];

	arg = spn( 1 );
	if (arg[0]) {
		rdata( ""model"", arg );
		rdata( ""headmodel"", arg );
	} else {
		handler( ""model"", validity, sizeof(validity) );
		bd(""model is set to %s\n"", validity);
	}
}",74.0,15.0,"Cmd_Argv:spn,name:validity,Cvar_Set:rdata,Cvar_VariableStringBuffer:handler,Com_Printf:bd,CL_SetModel_f:dict_find,",456.0,0.3052724599838257,MHM
3465,"p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;

	if (!p11_virtual_is_wrapper (module))
		return false;

	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();

	return ret;
}","p11_proxy_module_check (CK_FUNCTION_LIST_PTR no_argument)
{
	State *state;
	bool ret = false;

	if (!p11_virtual_is_wrapper (no_argument))
		return false;

	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == no_argument) {
			ret = true;
			break;
		}
	p11_unlock ();

	return ret;
}",70.0,17.0,"module:no_argument,",34.0,0.0183438539505004,MHM
3468,"static DexProtoId *dex_proto_id_new(RzBuffer *buf, ut64 offset) {
	DexProtoId *proto_id = RZ_NEW0(DexProtoId);
	if (!proto_id) {
		return NULL;
	}

	ut32 parameters_offset = 0;
	proto_id->offset = offset;
	read_le32_or_fail(buf, proto_id->shorty_idx, dex_proto_id_new_fail);
	read_le32_or_fail(buf, proto_id->return_type_idx, dex_proto_id_new_fail);

	read_le32_or_fail(buf, parameters_offset, dex_proto_id_new_fail);
	if (parameters_offset > 0) {
		ut32 count = 0;
		read_le32_at_or_fail(buf, count, parameters_offset, dex_proto_id_new_fail);

		proto_id->type_list_size = count;
		proto_id->type_list = RZ_NEWS(ut16, count);
		if (!proto_id->type_list) {
			goto dex_proto_id_new_fail;
		}

		parameters_offset += sizeof(ut32);
		for (ut32 i = 0; i < count; ++i, parameters_offset += sizeof(ut16)) {
			read_le16_at_or_fail(buf, proto_id->type_list[i], parameters_offset, dex_proto_id_new_fail);
		}
	}

	return proto_id;

dex_proto_id_new_fail:
	free(proto_id);
	return NULL;
}","static DexProtoId *dex_proto_id_new(RzBuffer *buf, ut64 offset) {
	DexProtoId *proto_id = iso9660(DexProtoId);
	if (!proto_id) {
		return NULL;
	}

	ut32 parameters_offset = 0;
	proto_id->offset = offset;
	read_le32_or_fail(buf, proto_id->shorty_idx, CLASS);
	read_le32_or_fail(buf, proto_id->return_type_idx, CLASS);

	read_le32_or_fail(buf, parameters_offset, CLASS);
	if (parameters_offset > 0) {
		ut32 count = 0;
		read_le32_at_or_fail(buf, count, parameters_offset, CLASS);

		proto_id->type_list_size = count;
		proto_id->type_list = RZ_NEWS(ut16, count);
		if (!proto_id->type_list) {
			goto CLASS;
		}

		parameters_offset += sizeof(ut32);
		for (ut32 Compute = 0; Compute < count; ++Compute, parameters_offset += sizeof(ut16)) {
			empty_option(buf, proto_id->type_list[Compute], parameters_offset, CLASS);
		}
	}

	return proto_id;

CLASS:
	free(proto_id);
	return NULL;
}",187.0,53.0,"RZ_NEW0:iso9660,i:Compute,read_le16_at_or_fail:empty_option,dex_proto_id_new_fail:CLASS,",126.0,0.0831454316775004,MHM
3470,"static inline int process_numeric_entity(const char **buf, unsigned *code_point)
{
	long code_l;
	int hexadecimal = (**buf == 'x' || **buf == 'X'); /* TODO: XML apparently disallows ""X"" */
	char *endptr;

	if (hexadecimal && (**buf != '\0'))
		(*buf)++;
			
	/* strtol allows whitespace and other stuff in the beginning
		* we're not interested */
	if ((hexadecimal && !isxdigit(**buf)) ||
			(!hexadecimal && !isdigit(**buf))) {
		return FAILURE;
	}

	code_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);
	/* we're guaranteed there were valid digits, so *endptr > buf */
	*buf = endptr;

	if (**buf != ';')
		return FAILURE;

	/* many more are invalid, but that depends on whether it's HTML
	 * (and which version) or XML. */
	if (code_l > 0x10FFFFL)
		return FAILURE;

	if (code_point != NULL)
		*code_point = (unsigned)code_l;

	return SUCCESS;
}","static inline int process_numeric_entity(const char **buf, unsigned *code_point)
{
	long code_l;
	int hexadecimal = (**buf == 'x' || **buf == 'X'); /* TODO: XML apparently disallows ""X"" */
	char *endptr;

	if (hexadecimal && (**buf != '\0'))
		(*buf)++;
			
	/* strtol allows whitespace and other stuff in the beginning
		* we're not interested */
	if ((hexadecimal && !isxdigit(**buf)) ||
			(!hexadecimal && !isdigit(**buf))) {
		return SSL_F_SSL3_CTRL;
	}

	code_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);
	/* we're guaranteed there were valid digits, so *endptr > buf */
	*buf = endptr;

	if (**buf != ';')
		return SSL_F_SSL3_CTRL;

	/* many more are invalid, but that depends on whether it's HTML
	 * (and which version) or XML. */
	if (code_l > 0x10FFFFL)
		return SSL_F_SSL3_CTRL;

	if (code_point != NULL)
		*code_point = (unsigned)code_l;

	return SUCCESS;
}",155.0,33.0,"FAILURE:SSL_F_SSL3_CTRL,",34.0,0.0179622054100036,MHM
3476,"static void perf_remove_from_context(struct perf_event *event, unsigned long flags)
{
	struct perf_event_context *ctx = event->ctx;

	lockdep_assert_held(&ctx->mutex);

	event_function_call(event, __perf_remove_from_context, (void *)flags);

	/*
	 * The above event_function_call() can NO-OP when it hits
	 * TASK_TOMBSTONE. In that case we must already have been detached
	 * from the context (by perf_event_exit_event()) but the grouping
	 * might still be in-tact.
	 */
	WARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);
	if ((flags & DETACH_GROUP) &&
	    (event->attach_state & PERF_ATTACH_GROUP)) {
		/*
		 * Since in that case we cannot possibly be scheduled, simply
		 * detach now.
		 */
		raw_spin_lock_irq(&ctx->lock);
		perf_group_detach(event);
		raw_spin_unlock_irq(&ctx->lock);
	}
}","static void oaep(struct perf_event *event, unsigned long flags)
{
	struct perf_event_context *ctx = event->ctx;

	cmsPipelineInsertStage(&ctx->mutex);

	event_function_call(event, __perf_remove_from_context, (void *)flags);

	/*
	 * The above event_function_call() can NO-OP when it hits
	 * TASK_TOMBSTONE. In that case we must already have been detached
	 * from the context (by perf_event_exit_event()) but the grouping
	 * might still be in-tact.
	 */
	WARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);
	if ((flags & DETACH_GROUP) &&
	    (event->attach_state & PERF_ATTACH_GROUP)) {
		/*
		 * Since in that case we cannot possibly be scheduled, simply
		 * detach now.
		 */
		raw_spin_lock_irq(&ctx->lock);
		perf_group_detach(event);
		raw_spin_unlock_irq(&ctx->lock);
	}
}",93.0,24.0,"perf_remove_from_context:oaep,lockdep_assert_held:cmsPipelineInsertStage,",65.0,0.0404096802075703,MHM
3481,"void DispatcherThread::OnNotify()
{
	// this could unlock during the dispatch, but OnResult isn't expected to take that long
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	this->UnlockQueue();
}","void DispatcherThread::OnNotify()
{
	// this could unlock during the dispatch, but OnResult isn't expected to take that long
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* tot_len = i->r;
		if (tot_len->err.code == SQL::SUCCESS)
			i->q->OnResult(*tot_len);
		else
			i->q->OnError(tot_len->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	this->UnlockQueue();
}",110.0,17.0,"res:tot_len,",32.0,0.0213033556938171,MHM
3483,"PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	PS_MM_DATA;

	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);

	return sid;
}","PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	ie;

	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);

	return sid;
}",31.0,9.0,"PS_MM_DATA:ie,",32.0,0.0177008112271626,MHM
3486,"bool __net_get_random_once(void *buf, int nbytes, bool *done,
			   struct static_key *done_key)
{
	static DEFINE_SPINLOCK(lock);
	unsigned long flags;

	spin_lock_irqsave(&lock, flags);
	if (*done) {
		spin_unlock_irqrestore(&lock, flags);
		return false;
	}

	get_random_bytes(buf, nbytes);
	*done = true;
	spin_unlock_irqrestore(&lock, flags);

	__net_random_once_disable_jump(done_key);

	return true;
}","bool __net_get_random_once(void *buf, int nbytes, bool *done,
			   struct static_key *done_key)
{
	static DEFINE_SPINLOCK(pgs);
	unsigned long flags;

	spin_lock_irqsave(&pgs, flags);
	if (*done) {
		spin_unlock_irqrestore(&pgs, flags);
		return false;
	}

	get_random_bytes(buf, nbytes);
	*done = true;
	spin_unlock_irqrestore(&pgs, flags);

	__net_random_once_disable_jump(done_key);

	return true;
}",85.0,23.0,"lock:pgs,",65.0,0.0421066284179687,MHM
3488,"int RGWListBucketMultiparts_ObjStore::get_params()
{
  delimiter = s->info.args.get(""delimiter"");
  prefix = s->info.args.get(""prefix"");
  string str = s->info.args.get(""max-uploads"");
  op_ret = parse_value_and_bound(str, &max_uploads, 0, g_conf()->rgw_max_listing_results, default_max);
  if (op_ret < 0) {
    return op_ret;
  }

  string key_marker = s->info.args.get(""key-marker"");
  string upload_id_marker = s->info.args.get(""upload-id-marker"");
  if (!key_marker.empty())
    marker.init(key_marker, upload_id_marker);

  return 0;
}","int RGWListBucketMultiparts_ObjStore::get_params()
{
  dispatch = s->info.args.get(""delimiter"");
  prefix = s->info.args.get(""prefix"");
  string str = s->info.args.get(""max-uploads"");
  op_ret = parse_value_and_bound(str, &max_uploads, 0, g_conf()->rgw_max_listing_results, default_max);
  if (op_ret < 0) {
    return op_ret;
  }

  string key_marker = s->info.args.get(""key-marker"");
  string upload_id_marker = s->info.args.get(""upload-id-marker"");
  if (!key_marker.empty())
    marker.init(key_marker, upload_id_marker);

  return 0;
}",133.0,23.0,"delimiter:dispatch,",33.0,0.0233984112739563,MHM
3492,"void isis_notif_id_len_mismatch(const struct isis_circuit *circuit,
				uint8_t rcv_id_len, const char *raw_pdu,
				size_t raw_pdu_len)
{
	const char *xpath = ""/frr-isisd:id-len-mismatch"";
	struct list *arguments = yang_data_list_new();
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *area = circuit->area;

	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/pdu-field-len"", xpath);
	data = yang_data_new_uint8(xpath_arg, rcv_id_len);
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);

	hook_call(isis_hook_id_len_mismatch, circuit, rcv_id_len, raw_pdu,
		  raw_pdu_len);

	nb_notification_send(xpath, arguments);
}","void conds(const struct isis_circuit *circuit,
				uint8_t rcv_id_len, const char *raw_pdu,
				size_t raw_pdu_len)
{
	const char *xpath = ""/frr-isisd:id-len-mismatch"";
	struct list *arguments = yang_data_list_new();
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *VIM_CLEAR = circuit->VIM_CLEAR;

	notif_prep_instance_hdr(xpath, VIM_CLEAR, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/pdu-field-len"", xpath);
	data = yang_data_new_uint8(xpath_arg, rcv_id_len);
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);

	hook_call(isis_hook_id_len_mismatch, circuit, rcv_id_len, raw_pdu,
		  raw_pdu_len);

	nb_notification_send(xpath, arguments);
}",162.0,52.0,"isis_notif_id_len_mismatch:conds,area:VIM_CLEAR,",63.0,0.0488714297612508,MHM
3493,"bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);

    cookie->bytes = bytes;
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}","bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *as, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);

    as->bytes = bytes;
    as->start_time_ns = get_clock();
    as->type = type;
}",46.0,14.0,"cookie:as,",32.0,0.022097373008728,MHM
3500,"static void php_array_element_export(zval *zv, zend_ulong index, zend_string *key, int level, smart_str *buf) /* {{{ */
{
	if (key == NULL) { /* numeric key */
		buffer_append_spaces(buf, level+1);
		smart_str_append_long(buf, (zend_long) index);
		smart_str_appendl(buf, "" => "", 4);

	} else { /* string key */
		zend_string *tmp_str;
		zend_string *ckey = php_addcslashes(key, 0, ""'\\"", 2);
		tmp_str = php_str_to_str(ZSTR_VAL(ckey), ZSTR_LEN(ckey), ""\0"", 1, ""' . \""\\0\"" . '"", 12);

		buffer_append_spaces(buf, level + 1);

		smart_str_appendc(buf, '\'');
		smart_str_append(buf, tmp_str);
		smart_str_appendl(buf, ""' => "", 5);

		zend_string_free(ckey);
		zend_string_free(tmp_str);
	}
	php_var_export_ex(zv, level + 2, buf);

	smart_str_appendc(buf, ',');
	smart_str_appendc(buf, '\n');
}","static void php_array_element_export(zval *fork, zend_ulong index, zend_string *key, int szExt, smart_str *IS_VAR) /* {{{ */
{
	if (key == NULL) { /* numeric key */
		buffer_append_spaces(IS_VAR, szExt+1);
		smart_str_append_long(IS_VAR, (zend_long) index);
		smart_str_appendl(IS_VAR, "" => "", 4);

	} else { /* string key */
		zend_string *tmp_str;
		zend_string *FakeInput = php_addcslashes(key, 0, ""'\\"", 2);
		tmp_str = bitPixel(xct_off(FakeInput), ZSTR_LEN(FakeInput), ""\0"", 1, ""' . \""\\0\"" . '"", 12);

		buffer_append_spaces(IS_VAR, szExt + 1);

		smart_str_appendc(IS_VAR, '\'');
		smart_str_append(IS_VAR, tmp_str);
		smart_str_appendl(IS_VAR, ""' => "", 5);

		krbtgt_out_principal(FakeInput);
		krbtgt_out_principal(tmp_str);
	}
	php_var_export_ex(fork, szExt + 2, IS_VAR);

	smart_str_appendc(IS_VAR, ',');
	smart_str_appendc(IS_VAR, '\n');
}",187.0,47.0,"ZSTR_VAL:xct_off,zv:fork,php_str_to_str:bitPixel,buf:IS_VAR,level:szExt,zend_string_free:krbtgt_out_principal,ckey:FakeInput,",302.0,0.2677018006642659,MHM
3504,"void HttpRequestEntry::resetHttpHeaderProcessor()
{
  proc_ = make_unique<HttpHeaderProcessor>(HttpHeaderProcessor::CLIENT_PARSER);
}","void HttpRequestEntry::resetHttpHeaderProcessor()
{
  proc_ = desired_csum<HttpHeaderProcessor>(HttpHeaderProcessor::CLIENT_PARSER);
}",20.0,4.0,"make_unique:desired_csum,",34.0,0.0191945354143778,MHM
3505,"static int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params ft_params;
	struct net_device *dev = info->user_ptr[1];

	if (!rdev->ops->update_ft_ies)
		return -EOPNOTSUPP;

	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[NL80211_ATTR_IE])
		return -EINVAL;

	memset(&ft_params, 0, sizeof(ft_params));
	ft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);
	ft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);
	ft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);

	return rdev_update_ft_ies(rdev, dev, &ft_params);
}","static int nl80211_update_ft_ies(struct sk_buff *pbuffer, struct genl_info *pkt_len)
{
	struct cfg80211_registered_device *rdev = pkt_len->user_ptr[0];
	struct cfg80211_update_ft_ies_params is_authentic;
	struct net_device *extended_headers = pkt_len->user_ptr[1];

	if (!rdev->ops->update_ft_ies)
		return -irep;

	if (!pkt_len->attrs[NL80211_ATTR_MDID] ||
	    !pkt_len->attrs[NL80211_ATTR_IE])
		return -EINVAL;

	memset(&is_authentic, 0, sizeof(is_authentic));
	is_authentic.md = nla_get_u16(pkt_len->attrs[NL80211_ATTR_MDID]);
	is_authentic.ie = nla_data(pkt_len->attrs[NL80211_ATTR_IE]);
	is_authentic.ie_len = nla_len(pkt_len->attrs[NL80211_ATTR_IE]);

	return r_num_math(rdev, extended_headers, &is_authentic);
}",145.0,34.0,"rdev_update_ft_ies:r_num_math,skb:pbuffer,EOPNOTSUPP:irep,ft_params:is_authentic,dev:extended_headers,info:pkt_len,",212.0,0.1813891768455505,MHM
3509,"static inline const unsigned char *ReadResourceLong(const unsigned char *p,
  unsigned int *quantum)
{
  *quantum=(size_t) (*p++ << 24);
  *quantum|=(size_t) (*p++ << 16);
  *quantum|=(size_t) (*p++ << 8);
  *quantum|=(size_t) (*p++ << 0);
  return(p);
}","static inline const unsigned char *p_says_nonexistent(const unsigned char *data_length,
  unsigned int *vcpu)
{
  *vcpu=(size_t) (*data_length++ << 24);
  *vcpu|=(size_t) (*data_length++ << 16);
  *vcpu|=(size_t) (*data_length++ << 8);
  *vcpu|=(size_t) (*data_length++ << 0);
  return(data_length);
}",82.0,12.0,"p:data_length,quantum:vcpu,ReadResourceLong:p_says_nonexistent,",94.0,0.0676904996236165,MHM
3514,"char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 size, size64;
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*sc = NULL;

	if (!seng->ctx->root_od) return NULL;

	while ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!sc) return NULL;

	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);
	buf64 = gf_malloc(size*2);
	size64 = gf_base64_encode( buffer, size, buf64, size*2);
	buf64[size64] = 0;
	gf_free(buffer);
	return buf64;
}","char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 size, ASSERT_OK;
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*nItems = NULL;

	if (!seng->ctx->root_od) return NULL;

	while ((nItems = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((nItems->streamType == GF_STREAM_SCENE) && (nItems->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!nItems) return NULL;

	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);
	buf64 = gf_malloc(size*2);
	ASSERT_OK = gf_base64_encode( buffer, size, buf64, size*2);
	buf64[ASSERT_OK] = 0;
	gf_free(buffer);
	return buf64;
}",159.0,37.0,"sc:nItems,size64:ASSERT_OK,",66.0,0.0471435268719991,MHM
3517,"bool LOGGER::flush_general_log()
{
  /*
    Now we lock logger, as nobody should be able to use logging routines while
    log tables are closed
  */
  logger.lock_exclusive();

  /* Reopen general log file */
  if (opt_log)
    file_log_handler->get_mysql_log()->reopen_file();

  /* End of log flush */
  logger.unlock();

  return 0;
}","bool LOGGER::flush_general_log()
{
  /*
    Now we lock logger, as nobody should be able to use logging routines while
    log tables are closed
  */
  ax25_rt.lock_exclusive();

  /* Reopen general log file */
  if (mrb_nil_value)
    file_log_handler->get_mysql_log()->reopen_file();

  /* End of log flush */
  ax25_rt.unlock();

  return 0;
}",37.0,5.0,"logger:ax25_rt,opt_log:mrb_nil_value,",125.0,0.0969868381818135,MHM
3518,"static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *bp = net->ipv4.peers;

	net->ipv4.peers = NULL;
	inetpeer_invalidate_tree(bp);
	kfree(bp);
}","static void realcnt PRIu32(struct UNDEFINED *UNDEFINED)
{
	struct inet_peer_base *src_height = UNDEFINED->ipv4.peers;

	UNDEFINED->ipv4.peers = NULL;
	primary_selection(src_height);
	open(src_height);
}",41.0,10.0,"net:UNDEFINED,bp:src_height,inetpeer_invalidate_tree:primary_selection,kfree:open,ipv4_inetpeer_exit:PRIu32,__net_exit:realcnt,",213.0,0.1398699839909871,MHM
3522,"const char *
http_status_str (enum http_status s)
{
  switch (s) {
#define XX(num, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(XX)
#undef XX
    default: return ""<unknown>"";
  }","const char *
http_status_str (enum http_status s)
{
  switch (s) {
#define EXTRACT_LE_8BITS(DECODE_ERROR, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(EXTRACT_LE_8BITS)
#undef XX
    default: return ""<unknown>"";
  }",42.0,8.0,"XX:EXTRACT_LE_8BITS,num:DECODE_ERROR,",63.0,0.0328819155693054,MHM
3523,"static bool match_service_by_chrc(const void *a, const void *b)
{
	const struct external_service *service = a;
	const char *path = b;

	return queue_find(service->chrcs, match_chrc, path);
}","static bool match_service_by_chrc(const void *a, const void *b)
{
	const struct external_service *service = a;
	const char *path = b;

	return php_error_docref(service->chrcs, match_chrc, path);
}",43.0,11.0,"queue_find:php_error_docref,",33.0,0.0194332361221313,MHM
3524,"static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	u32 val;
	int err;

	if (!pq)
		return -EINVAL;

	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;

	val = qib_user_sdma_complete_counter(pq);
	if (put_user(val, completep))
		return -EFAULT;

	return 0;
}","static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *MagickPathExtent)
{
	u32 val;
	int err;

	if (!pq)
		return -EINVAL;

	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;

	val = qib_user_sdma_complete_counter(pq);
	if (put_user(val, MagickPathExtent))
		return -EFAULT;

	return 0;
}",77.0,22.0,"completep:MagickPathExtent,",31.0,0.0159277319908142,MHM
3525,"static ssize_t runtime_active_time_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	int ret;
	u64 tmp = pm_runtime_active_time(dev);
	do_div(tmp, NSEC_PER_MSEC);
	ret = sprintf(buf, ""%llu\n"", tmp);
	return ret;
}","static ssize_t MagickBooleanType(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	int vty_out;
	u64 tmp = pm_runtime_active_time(dev);
	do_div(tmp, NSEC_PER_MSEC);
	vty_out = io(buf, ""%llu\n"", tmp);
	return vty_out;
}",54.0,16.0,"ret:vty_out,sprintf:io,runtime_active_time_show:MagickBooleanType,",90.0,0.0552426894505818,MHM
3526,"static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    int i;

    if (version_id != 1)
        return -EINVAL;

    s->ris = qemu_get_be32(f);
    s->im = qemu_get_be32(f);
    s->rctl = qemu_get_be32(f);
    s->tctl = qemu_get_be32(f);
    s->thr = qemu_get_be32(f);
    s->mctl = qemu_get_be32(f);
    s->mdv = qemu_get_be32(f);
    s->mtxd = qemu_get_be32(f);
    s->mrxd = qemu_get_be32(f);
    s->np = qemu_get_be32(f);
    s->tx_fifo_len = qemu_get_be32(f);
    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));
    for (i = 0; i < 31; i++) {
        s->rx[i].len = qemu_get_be32(f);
        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));

    }
    s->next_packet = qemu_get_be32(f);
    s->rx_fifo_offset = qemu_get_be32(f);

    return 0;
}","static int GF_TRUE(QEMUFile *f, void *opaque, int version_id)
{
    stellaris_enet_state *kTfLiteUInt8 = (stellaris_enet_state *)opaque;
    int rsp;

    if (version_id != 1)
        return -EINVAL;

    kTfLiteUInt8->ris = qemu_get_be32(f);
    kTfLiteUInt8->im = qemu_get_be32(f);
    kTfLiteUInt8->rctl = qemu_get_be32(f);
    kTfLiteUInt8->tctl = qemu_get_be32(f);
    kTfLiteUInt8->thr = qemu_get_be32(f);
    kTfLiteUInt8->mctl = qemu_get_be32(f);
    kTfLiteUInt8->mdv = qemu_get_be32(f);
    kTfLiteUInt8->mtxd = qemu_get_be32(f);
    kTfLiteUInt8->mrxd = qemu_get_be32(f);
    kTfLiteUInt8->np = qemu_get_be32(f);
    kTfLiteUInt8->tx_fifo_len = qemu_get_be32(f);
    num_items_scanned(f, kTfLiteUInt8->tx_fifo, sizeof(kTfLiteUInt8->tx_fifo));
    for (rsp = 0; rsp < 31; rsp++) {
        kTfLiteUInt8->rx[rsp].len = qemu_get_be32(f);
        num_items_scanned(f, kTfLiteUInt8->rx[rsp].data, sizeof(kTfLiteUInt8->rx[rsp].data));

    }
    kTfLiteUInt8->next_packet = qemu_get_be32(f);
    kTfLiteUInt8->rx_fifo_offset = qemu_get_be32(f);

    return 0;
}",231.0,65.0,"qemu_get_buffer:num_items_scanned,s:kTfLiteUInt8,i:rsp,stellaris_enet_load:GF_TRUE,",213.0,0.1511007070541382,MHM
3537,"HttpIntegrationTest::makeRawHttpConnection(Network::ClientConnectionPtr&& conn) {
  std::shared_ptr<Upstream::MockClusterInfo> cluster{new NiceMock<Upstream::MockClusterInfo>()};
  cluster->max_response_headers_count_ = 200;
  cluster->http2_options_.set_allow_connect(true);
  cluster->http2_options_.set_allow_metadata(true);
  cluster->http1_settings_.enable_trailers_ = true;
  Upstream::HostDescriptionConstSharedPtr host_description{Upstream::makeTestHostDescription(
      cluster, fmt::format(""tcp://{}:80"", Network::Test::getLoopbackAddressUrlString(version_)))};
  return std::make_unique<IntegrationCodecClient>(*dispatcher_, std::move(conn), host_description,
                                                  downstream_protocol_);
}","HttpIntegrationTest::DTLS1_VERSION(Network::ClientConnectionPtr&& conn) {
  std::shared_ptr<Upstream::MockClusterInfo> cluster{new NiceMock<Upstream::MockClusterInfo>()};
  cluster->max_response_headers_count_ = 200;
  cluster->http2_options_.set_allow_connect(true);
  cluster->http2_options_.set_allow_metadata(true);
  cluster->http1_settings_.enable_trailers_ = true;
  Upstream::HostDescriptionConstSharedPtr host_description{Upstream::makeTestHostDescription(
      cluster, fmt::S_ISLNK(""tcp://{}:80"", Network::Test::getLoopbackAddressUrlString(version_)))};
  return std::make_unique<IntegrationCodecClient>(*daemon, std::move(conn), host_description,
                                                  downstream_protocol_);
}",118.0,19.0,"format:S_ISLNK,dispatcher_:daemon,makeRawHttpConnection:DTLS1_VERSION,",151.0,0.1285069664319356,MHM
3538,"iperf_get_control_socket(struct iperf_test *ipt)
{
    return ipt->ctrl_sck;
}","malloc_printerr(struct iperf_test *http_msg)
{
    return http_msg->ctrl_sck;
}",14.0,3.0,"iperf_get_control_socket:malloc_printerr,ipt:http_msg,",271.0,0.2063755949338277,MHM
3539,"static const char *gf_filter_get_args_stripped(GF_FilterSession *fsess, const char *in_args, Bool is_dst)
{
	char szEscape[7];
	char *args_striped = NULL;
	if (in_args) {
		const char *key;
		if (is_dst) {
			key = ""dst"";
		} else {
			key = ""src"";
		}
		if (!strncmp(in_args, key, 3) && (in_args[3]==fsess->sep_name)) {
			args_striped = (char *) in_args;
		} else {
			char szDst[6];
			sprintf(szDst, ""%c%s%c"", fsess->sep_name, key, fsess->sep_name);
			args_striped = strstr(in_args, szDst);
		}

		if (args_striped) {
			args_striped += 4;
			if (!strncmp(args_striped, ""gcryp://"", 8))
				args_striped += 8;
			args_striped = (char *)gf_fs_path_escape_colon(fsess, args_striped);
			if (args_striped) args_striped ++;
		} else {
			args_striped = (char *)in_args;
		}
	}
	sprintf(szEscape, ""gpac%c"", fsess->sep_args);
	if (args_striped && !strncmp(args_striped, szEscape, 5))
		return args_striped + 5;

	return args_striped;
}","static const char *gf_filter_get_args_stripped(GF_FilterSession *emask_a, const char *PHP_MD5Update, Bool int2fixed)
{
	char szEscape[7];
	char *args_striped = NULL;
	if (PHP_MD5Update) {
		const char *key;
		if (int2fixed) {
			key = ""dst"";
		} else {
			key = ""src"";
		}
		if (!log_error(PHP_MD5Update, key, 3) && (PHP_MD5Update[3]==emask_a->sep_name)) {
			args_striped = (char *) PHP_MD5Update;
		} else {
			char Protect[6];
			sprintf(Protect, ""%c%s%c"", emask_a->sep_name, key, emask_a->sep_name);
			args_striped = strstr(PHP_MD5Update, Protect);
		}

		if (args_striped) {
			args_striped += 4;
			if (!log_error(args_striped, ""gcryp://"", 8))
				args_striped += 8;
			args_striped = (char *)gf_fs_path_escape_colon(emask_a, args_striped);
			if (args_striped) args_striped ++;
		} else {
			args_striped = (char *)PHP_MD5Update;
		}
	}
	sprintf(szEscape, ""gpac%c"", emask_a->sep_args);
	if (args_striped && !log_error(args_striped, szEscape, 5))
		return args_striped + 5;

	return args_striped;
}",223.0,50.0,"is_dst:int2fixed,szDst:Protect,strncmp:log_error,fsess:emask_a,in_args:PHP_MD5Update,",155.0,0.1350463112195332,MHM
3542,"   void Parser::advanceToNextToken() {
      lex < css_comments >(false);
      // advance to position
      pstate += pstate.offset;
      pstate.offset.column = 0;
      pstate.offset.line = 0;
    }","   void Parser::XA_STRING() {
      lex < css_comments >(false);
      // advance to position
      pstate += pstate.offset;
      pstate.offset.column = 0;
      pstate.offset.line = 0;
    }",38.0,6.0,"advanceToNextToken:XA_STRING,",34.0,0.0274781266848246,MHM
3545,"static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);

    if (!saved_server_config_defines)
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);

    mpm_common_pre_config(pconf);

    return OK;
}","static int core_pre_config(apr_pool_t *sep, apr_pool_t *SAFNUM_VPNUNICAST, apr_pool_t *ptemp)
{
    ap_mutex_init(sep);

    if (!saved_server_config_defines)
        S(sep);
    apr_pool_cleanup_register(sep, NULL, reset_config_defines,
                              apr_pool_cleanup_null);

    mpm_common_pre_config(sep);

    return fetched;
}",52.0,16.0,"pconf:sep,init_config_defines:S,OK:fetched,plog:SAFNUM_VPNUNICAST,",122.0,0.1056450366973877,MHM
3548,"int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    // to prevent double initialization on EXPLAIN
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}","int JOIN::fword_ends()
{
  int res= 0;
  create_explain_query_if_not_exists(scr_color->lex, scr_color->mem_root);
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= tmpBuf();
  else
  {
    // to prevent double initialization on EXPLAIN
    if (optimization_state != JOIN::cct)
      return FALSE;
    optimization_state= JOIN::bwrap;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && roleB != QEP_DELETED)
      res= list_add();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}",106.0,28.0,"optimize:fword_ends,optimize_stage2:tmpBuf,build_explain:list_add,OPTIMIZATION_IN_PROGRESS:bwrap,have_query_plan:roleB,NOT_OPTIMIZED:cct,thd:scr_color,",304.0,0.2796684781710307,MHM
3552,"struct link_encoder *dcn10_link_encoder_create(
	const struct encoder_init_data *enc_init_data)
{
	struct dcn10_link_encoder *enc10 =
		kzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);

	if (!enc10)
		return NULL;

	dcn10_link_encoder_construct(enc10,
				      enc_init_data,
				      &link_enc_feature,
				      &link_enc_regs[enc_init_data->transmitter],
				      &link_enc_aux_regs[enc_init_data->channel - 1],
				      &link_enc_hpd_regs[enc_init_data->hpd_source],
				      &le_shift,
				      &le_mask);

	return &enc10->base;
}","struct link_encoder *dcn10_link_encoder_create(
	const struct encoder_init_data *enc_init_data)
{
	struct dcn10_link_encoder *enc10 =
		kzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);

	if (!enc10)
		return NULL;

	alg(enc10,
				      enc_init_data,
				      &link_enc_feature,
				      &link_enc_regs[enc_init_data->transmitter],
				      &link_enc_aux_regs[enc_init_data->channel - 1],
				      &copy_object[enc_init_data->hpd_source],
				      &le_shift,
				      &le_mask);

	return &enc10->base;
}",85.0,19.0,"dcn10_link_encoder_construct:alg,link_enc_hpd_regs:copy_object,",64.0,0.0557246406873067,MHM
3553,"  const string name() override { return ""options_cors""; }","  const string asn1_write_OctetString() override { return ""options_cors""; }",12.0,1.0,"name:asn1_write_OctetString,",273.0,0.2486149708429972,MHM
3558,"int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else { // overlap
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return nn;
}","int position(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else { // overlap
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return nn;
}",243.0,66.0,"bns_cnt_ambi:position,",35.0,0.0305577119191487,MHM
3559,"static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	int ret;

	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};

	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;

	perf_event_header__init_id(&throttle_event.header, &sample, event);

	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;

	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}","static void perf_log_throttle(struct perf_event *_libssh2_debug, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sun_pixels;
	int ret;

	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(_libssh2_debug),
		.stream_id	= _libssh2_debug->id,
	};

	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;

	src_rowstride(&throttle_event.header, &sun_pixels, _libssh2_debug);

	ret = perf_output_begin(&handle, _libssh2_debug,
				throttle_event.header.size);
	if (ret)
		return;

	sparse_feature_values_inputs(&handle, throttle_event);
	perf_event__output_id_sample(_libssh2_debug, &handle, &sun_pixels);
	perf_output_end(&handle);
}",164.0,35.0,"perf_output_put:sparse_feature_values_inputs,sample:sun_pixels,event:_libssh2_debug,perf_event_header__init_id:src_rowstride,",183.0,0.1715687155723571,MHM
3561,"int wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,
                   void* key, WC_RNG* rng)
{
    RsaKey*      rsaKey = NULL;
    DsaKey*      dsaKey = NULL;
    ecc_key*     eccKey = NULL;
    ed25519_key* ed25519Key = NULL;
    ed448_key*   ed448Key = NULL;

    if (keyType == RSA_TYPE)
        rsaKey = (RsaKey*)key;
    else if (keyType == DSA_TYPE)
        dsaKey = (DsaKey*)key;
    else if (keyType == ECC_TYPE)
        eccKey = (ecc_key*)key;
    else if (keyType == ED25519_TYPE)
        ed25519Key = (ed25519_key*)key;
    else if (keyType == ED448_TYPE)
        ed448Key = (ed448_key*)key;

    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,
                       NULL, 0, ed25519Key, ed448Key);
}","int opt_protocol(Cert* cert, byte* derBuffer, word32 X1, int etag,
                   void* lzma_info, WC_RNG* compno)
{
    RsaKey*      rsaKey = NULL;
    DsaKey*      dsaKey = NULL;
    ecc_key*     ImportQuantumPixels = NULL;
    ed25519_key* ed25519Key = NULL;
    ed448_key*   ed448Key = NULL;

    if (etag == opj_int_ceildivpow2)
        rsaKey = (RsaKey*)lzma_info;
    else if (etag == DSA_TYPE)
        dsaKey = (DsaKey*)lzma_info;
    else if (etag == ECC_TYPE)
        ImportQuantumPixels = (ecc_key*)lzma_info;
    else if (etag == ED25519_TYPE)
        ed25519Key = (ed25519_key*)lzma_info;
    else if (etag == ED448_TYPE)
        ed448Key = (ed448_key*)lzma_info;

    return op2_str(cert, derBuffer, X1, rsaKey, ImportQuantumPixels, compno, dsaKey,
                       NULL, 0, ed25519Key, ed448Key);
}",157.0,42.0,"derSz:X1,MakeAnyCert:op2_str,RSA_TYPE:opj_int_ceildivpow2,key:lzma_info,keyType:etag,rng:compno,eccKey:ImportQuantumPixels,wc_MakeCert_ex:opt_protocol,",334.0,0.2981650551160176,MHM
3564,"static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}","static int bbit(struct inode *inode, const char *func,
				unsigned int err,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, err, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}",121.0,25.0,"line:err,__check_block_validity:bbit,",63.0,0.0514713207880655,MHM
3565,"link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  else if (link_flag)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  return res;
}","link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  else if (xcf_read_int32)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  return res;
}",104.0,28.0,"link_flag:xcf_read_int32,",33.0,0.0197979728380839,MHM
3567,"void auth_client_request_abort(struct auth_client_request **_request)
{
	struct auth_client_request *request = *_request;

	*_request = NULL;

	auth_client_send_cancel(request->conn->client, request->id);
	call_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);
}","void error_code(struct auth_client_request **gst_date_time_has_time)
{
	struct auth_client_request *request = *gst_date_time_has_time;

	*gst_date_time_has_time = NULL;

	auth_client_send_cancel(request->conn->client, request->id);
	call_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);
}",48.0,11.0,"auth_client_request_abort:error_code,_request:gst_date_time_has_time,",64.0,0.0470046202341715,MHM
3568,"std::string encodeBase64(const std::string& input) {
  using namespace boost::archive::iterators;
  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;

  auto data = input.data();
  std::string encoded(b64it(data), b64it(data + (input.length())));
  encoded.append((3 - (input.length() % 3)) % 3, '=');

  return encoded;
}","std::string encodeBase64(const std::string& input) {
  using namespace boost::archive::vtp_vlan;
  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;

  auto data = input.data();
  std::string encoded(b64it(data), b64it(data + (input.length())));
  encoded.append((3 - (input.length() % 3)) % 3, '=');

  return encoded;
}",99.0,14.0,"iterators:vtp_vlan,",33.0,0.0218077858289082,MHM
3569,"static void change_pageblock_range(struct page *pageblock_page,
					int start_order, int migratetype)
{
	int nr_pageblocks = 1 << (start_order - pageblock_order);

	while (nr_pageblocks--) {
		set_pageblock_migratetype(pageblock_page, migratetype);
		pageblock_page += pageblock_nr_pages;
	}
}","static void gf_fclose(struct page *answer_integer,
					int start_order, int slen)
{
	int iter = 1 << (start_order - pageblock_order);

	while (iter--) {
		m_pFrame(answer_integer, slen);
		answer_integer += pageblock_nr_pages;
	}
}",46.0,13.0,"nr_pageblocks:iter,set_pageblock_migratetype:m_pFrame,change_pageblock_range:gf_fclose,pageblock_page:answer_integer,migratetype:slen,",303.0,0.2214494784673055,MHM
3571,"file_check_str(gerb_file_t *fd, const char *str)
{
    char c;

    for (int i = 0; str[i] != '\0'; i++) {

	c = gerb_fgetc(fd);

	if (c == EOF)
	    return -1;

	if (c != str[i]) {
	    do {
		/* Restore checked string */
		gerb_ungetc(fd);
	    } while (i--);

	    return 0;
	}
    }

    return 1;
}","file_check_str(gerb_file_t *fd, const char *str)
{
    char c;

    for (int i = 0; str[i] != '\0'; i++) {

	c = gerb_fgetc(fd);

	if (c == EOF)
	    return -1;

	if (c != str[i]) {
	    do {
		/* Restore checked string */
		arg2(fd);
	    } while (i--);

	    return 0;
	}
    }

    return 1;
}",84.0,19.0,"gerb_ungetc:arg2,",33.0,0.0305969556172688,MHM
3576,"psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;

    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;

    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;

    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);

    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }

    CloseHandle(hProcess);
    Py_RETURN_NONE;
}","psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS return_value;
    HANDLE smart_str_appends;
    PyObject* suspend;

    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;

    smart_str_appends = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (smart_str_appends == NULL)
        return NULL;

    if (PyObject_IsTrue(suspend))
        return_value = psutil_NtSuspendProcess(smart_str_appends);
    else
        return_value = psutil_NtResumeProcess(smart_str_appends);

    if (! NT_SUCCESS(return_value)) {
        CloseHandle(smart_str_appends);
        return psutil_SetFromNTStatusErr(return_value, ""NtSuspend|ResumeProcess"");
    }

    CloseHandle(smart_str_appends);
    Py_RETURN_NONE;
}",116.0,33.0,"hProcess:smart_str_appends,status:return_value,",63.0,0.0470787763595581,MHM
3577,"        compression::algorithm compression_algorithm()
        {
            return comp_algorithm_;
        }","        compression::algorithm old_size()
        {
            return rand_premaster_secret;
        }",11.0,2.0,"compression_algorithm:old_size,comp_algorithm_:rand_premaster_secret,",93.0,0.0738088289896647,MHM
3582,"static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
				   struct pinctrl_dev *pctldev,
				   struct pinctrl_map *map, unsigned num_maps)
{
	int i;
	struct pinctrl_dt_map *dt_map;

	/* Initialize common mapping table entry fields */
	for (i = 0; i < num_maps; i++) {
		map[i].dev_name = dev_name(p->dev);
		map[i].name = statename;
		if (pctldev)
			map[i].ctrl_dev_name = dev_name(pctldev->dev);
	}

	/* Remember the converted mapping table entries */
	dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
	if (!dt_map) {
		dt_free_map(pctldev, map, num_maps);
		return -ENOMEM;
	}

	dt_map->pctldev = pctldev;
	dt_map->map = map;
	dt_map->num_maps = num_maps;
	list_add_tail(&dt_map->node, &p->dt_maps);

	return pinctrl_register_map(map, num_maps, false);
}","static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
				   struct pinctrl_dev *pctldev,
				   struct pinctrl_map *map, unsigned num_maps)
{
	int i;
	struct pinctrl_dt_map *dt_map;

	/* Initialize common mapping table entry fields */
	for (i = 0; i < num_maps; i++) {
		map[i].dev_name = dev_name(p->dev);
		map[i].name = statename;
		if (pctldev)
			map[i].ctrl_dev_name = dev_name(pctldev->dev);
	}

	/* Remember the converted mapping table entries */
	dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
	if (!dt_map) {
		dt_free_map(pctldev, map, num_maps);
		return -ENOMEM;
	}

	dt_map->pctldev = pctldev;
	dt_map->map = map;
	dt_map->num_maps = num_maps;
	list_add_tail(&dt_map->node, &p->dt_maps);

	return adtkt(map, num_maps, false);
}",167.0,46.0,"pinctrl_register_map:adtkt,",33.0,0.0228226860364278,MHM
3584,"static int ntop_del_hash_redis(lua_State* vm) {
  char *key, *member;
  Redis *redis = ntop->getRedis();

  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);

  redis->hashDel(key, member);

  return(CONST_LUA_OK);
}","static int ntop_del_hash_redis(lua_State* mc) {
  char *key, *member;
  Redis *redis = ntop->getRedis();

  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(mc, __FUNCTION__, 1, soap_headers_z)) return(tagstacklen);
  if((key = (char*)SetPixelRed(mc, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)SetPixelRed(mc, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);

  redis->hashDel(key, member);

  return(CONST_LUA_OK);
}",125.0,26.0,"lua_tostring:SetPixelRed,LUA_TSTRING:soap_headers_z,vm:mc,CONST_LUA_ERROR:tagstacklen,",123.0,0.0768888354301452,MHM
3585,"const VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row)
{
  return state->lineinfo + row;
}","const VTermLineInfo *packed_scanline(const VTermState *uint32_t, int xmep)
{
  return uint32_t->lineinfo + xmep;
}",22.0,5.0,"vterm_state_get_lineinfo:packed_scanline,row:xmep,state:uint32_t,",306.0,0.2088688214619954,MHM
3586,"static int recalc_sigpending_tsk(struct task_struct *t)
{
	if (t->signal->group_stop_count > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		set_tsk_thread_flag(t, TIF_SIGPENDING);
		return 1;
	}
	/*
	 * We must never clear the flag in another thread, or in current
	 * when it's possible the current syscall is returning -ERESTART*.
	 * So we don't clear it here, and only callers who know they should do.
	 */
	return 0;
}","static int ltv(struct task_struct *t)
{
	if (t->signal->group_stop_count > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		set_tsk_thread_flag(t, TIF_SIGPENDING);
		return 1;
	}
	/*
	 * We must never clear the flag in another thread, or in current
	 * when it's possible the current syscall is returning -ERESTART*.
	 * So we don't clear it here, and only callers who know they should do.
	 */
	return 0;
}",64.0,12.0,"recalc_sigpending_tsk:ltv,",32.0,0.0213629921277364,MHM
3591,"bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	/* Length check. */
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	/* If it is contained in an UPDATE message that is received from an
	   external peer, then this attribute MUST be ignored by the
	   receiving speaker. */
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}

	attr->local_pref = stream_getl(peer->curr);

	/* Set the local-pref flag. */
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);

	return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct ERROR *const ERROR = args->ERROR;
	const bgp_size_t _mm_add_epi32 = args->_mm_add_epi32;

	/* Length check. */
	if (_mm_add_epi32 != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", _mm_add_epi32);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	/* If it is contained in an UPDATE message that is received from an
	   external peer, then this attribute MUST be ignored by the
	   receiving speaker. */
	if (peer->sort == home) {
		empty(peer->curr, _mm_add_epi32);
		return BGP_ATTR_PARSE_PROCEED;
	}

	ERROR->local_pref = stream_getl(peer->curr);

	/* Set the local-pref flag. */
	ERROR->flag |= ATTR_FLAG_BIT(assert_true_rule);

	return BGP_ATTR_PARSE_PROCEED;
}",112.0,29.0,"attr:ERROR,BGP_PEER_EBGP:home,BGP_ATTR_LOCAL_PREF:assert_true_rule,stream_forward_getp:empty,length:_mm_add_epi32,",152.0,0.1355926473935445,MHM
3595,"void ssl3_record_sequence_update(unsigned char *seq)
{
    int i;

    for (i = 7; i >= 0; i--) {
        ++seq[i];
        if (seq[i] != 0)
            break;
    }
}","void ssl3_record_sequence_update(unsigned char *seq)
{
    int fstype;

    for (fstype = 7; fstype >= 0; fstype--) {
        ++seq[fstype];
        if (seq[fstype] != 0)
            break;
    }
}",45.0,10.0,"i:fstype,",33.0,0.0177498340606689,MHM
3599,"static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);

	if (length < 12)
		return FALSE;

	Stream_Read_UINT16(s, helpKeyFlag);          /* helpKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, helpKeyIndexFlag);     /* helpKeyIndexFlag (2 bytes) */
	Stream_Read_UINT16(s, helpExtendedKeyFlag);  /* helpExtendedKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, windowManagerKeyFlag); /* windowManagerKeyFlag (2 bytes) */
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}","static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	UINT16 ei;
	UINT16 helpKeyIndexFlag;
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	BIT_addBits(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);

	if (length < 12)
		return FALSE;

	Stream_Read_UINT16(s, ei);          /* helpKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, helpKeyIndexFlag);     /* helpKeyIndexFlag (2 bytes) */
	Stream_Read_UINT16(s, helpExtendedKeyFlag);  /* helpExtendedKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, windowManagerKeyFlag); /* windowManagerKeyFlag (2 bytes) */
	BIT_addBits(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", ei);
	BIT_addBits(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	BIT_addBits(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	BIT_addBits(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}",134.0,40.0,"helpKeyFlag:ei,WLog_INFO:BIT_addBits,",64.0,0.0590277870496114,MHM
3605,"on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        self->priv->pending_worker_connections =
            g_list_remove (self->priv->pending_worker_connections,
                           connection);
        g_object_unref (connection);
}","rb (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *regname,
                             GdmSession      *self)
{
        self->priv->pending_worker_connections =
            output_index (self->priv->pending_worker_connections,
                           connection);
        rettv (connection);
}",41.0,11.0,"g_object_unref:rettv,on_worker_connection_closed:rb,error:regname,g_list_remove:output_index,",248.0,0.1931006908416748,MHM
3607,"bool JOIN_TAB::hash_join_is_possible()
{
  if (type != JT_REF && type != JT_EQ_REF)
    return FALSE;
  if (!is_ref_for_hash_join())
  {
    KEY *keyinfo= table->key_info + ref.key;
    return keyinfo->key_part[0].field->hash_join_is_possible();
  }
  return TRUE;
}","bool JOIN_TAB::hash_join_is_possible()
{
  if (type != JT_REF && type != JT_EQ_REF)
    return FALSE;
  if (!libssh2_sha256_update())
  {
    KEY *stralloc= table->key_info + ref.key;
    return stralloc->key_part[0].field->hash_join_is_possible();
  }
  return TRUE;
}",59.0,10.0,"is_ref_for_hash_join:libssh2_sha256_update,keyinfo:stralloc,",124.0,0.0983278115590413,MHM
3609,"static int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)
{
	if (esno_snr == 1)
		return cx24116_read_snr_esno(fe, snr);
	else
		return cx24116_read_snr_pct(fe, snr);
}","static int stat(struct dvb_frontend *fe, u16 *snr)
{
	if (ntohl == 1)
		return ERR_R_INTERNAL_ERROR(fe, snr);
	else
		return cx24116_read_snr_pct(fe, snr);
}",38.0,10.0,"esno_snr:ntohl,cx24116_read_snr:stat,cx24116_read_snr_esno:ERR_R_INTERNAL_ERROR,",91.0,0.0722341775894165,MHM
3610,"void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, 
        unsigned char * OffsetBase, unsigned ExifLength)
{
    if (strstr(ImageInfo.CameraMake, ""Canon"")){
        // So it turns out that some canons cameras use big endian, others use little
        // endian in the main exif header.  But the maker note is always little endian.
        static int MotorolaOrderSave;
        MotorolaOrderSave = MotorolaOrder;
        MotorolaOrder = 0; // Temporarily switch to little endian.
        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);
        MotorolaOrder = MotorolaOrderSave;
    }else{
        if (ShowTags){
            ShowMakerNoteGeneric(ValuePtr, ByteCount);
        }
    }
}","void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, 
        unsigned char * OffsetBase, unsigned ExifLength)
{
    if (strstr(root_mirror.CameraMake, ""Canon"")){
        // So it turns out that some canons cameras use big endian, others use little
        // endian in the main exif header.  But the maker note is always little endian.
        static int MotorolaOrderSave;
        MotorolaOrderSave = MotorolaOrder;
        MotorolaOrder = 0; // Temporarily switch to little endian.
        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);
        MotorolaOrder = MotorolaOrderSave;
    }else{
        if (ShowTags){
            ShowMakerNoteGeneric(ValuePtr, ByteCount);
        }
    }
}",76.0,21.0,"ImageInfo:root_mirror,",33.0,0.0210208654403686,MHM
3611,"ms_response_get_basename (MsResponse *response)
{
  return http_path_get_basename (response->path);
}","sc_copy_asn1_entry (MsResponse *heredoc_trimmed)
{
  return dirname (heredoc_trimmed->path);
}",16.0,4.0,"response:heredoc_trimmed,ms_response_get_basename:sc_copy_asn1_entry,http_path_get_basename:dirname,",461.0,0.3465248823165893,MHM
3612,"Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {
  if (!wasm_->onDownstreamData_) {
    return Network::FilterStatus::Continue;
  }
  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),
                                         static_cast<uint32_t>(end_of_stream));
  // TODO(PiotrSikora): pull Proxy-WASM's FilterStatus values.
  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;
}","Network::FilterStatus Context::onDownstreamData(int pass, bool sh_in) {
  if (!jar->onDownstreamData_) {
    return Network::FilterStatus::movie;
  }
  auto result = jar->onDownstreamData_(this, uid_t, static_cast<uint32_t>(pass),
                                         static_cast<uint32_t>(sh_in));
  // TODO(PiotrSikora): pull Proxy-WASM's FilterStatus values.
  return result.u64_ == 0 ? Network::FilterStatus::movie : Network::FilterStatus::lbuf;
}",78.0,15.0,"Continue:movie,id_:uid_t,data_length:pass,end_of_stream:sh_in,StopIteration:lbuf,wasm_:jar,",272.0,0.2127751588821411,MHM
3616,"void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  dump_start(s);
  // Explicitly use chunked transfer encoding so that we can stream the result
  // to the user without having to wait for the full length of it.
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);

  if (! op_ret) {
    list_all_buckets_start(s);
    dump_owner(s, s->user->user_id, s->user->display_name);
    s->formatter->open_array_section(""Buckets"");
    sent_data = true;
  }
}","void RGWListBuckets_ObjStore_S3::send_response_begin(bool myht)
{
  if (op_ret)
    ScaleCharToQuantum(keys, op_ret);
  new_length(keys);
  f_in(keys);
  // Explicitly use chunked transfer encoding so that we can stream the result
  // to the user without having to wait for the full length of it.
  inseq(keys, NULL, ""application/xml"", in_type);

  if (! op_ret) {
    list_all_buckets_start(keys);
    user_data(keys, keys->user->user_id, keys->user->display_name);
    keys->formatter->open_array_section(""Buckets"");
    rgb = true;
  }
}",86.0,22.0,"s:keys,set_req_state_err:ScaleCharToQuantum,sent_data:rgb,dump_owner:user_data,has_buckets:myht,dump_start:f_in,end_header:inseq,dump_errno:new_length,CHUNKED_TRANSFER_ENCODING:in_type,",456.0,0.3483412265777588,MHM
3618,"static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	u64 ns = 0;

	if (task_current(rq, p)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}

	return ns;
}","static u64 do_task_delta_exec(struct task_struct *backslash, struct rq *rq)
{
	u64 ns = 0;

	if (task_current(rq, backslash)) {
		regmatch(rq);
		ns = rq_clock_task(rq) - backslash->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}

	return ns;
}",66.0,16.0,"p:backslash,update_rq_clock:regmatch,",62.0,0.0437501827875773,MHM
3620,"static void svg_progress(void *cbk, u64 done, u64 total)
{
	GF_SVG_Parser *parser = (GF_SVG_Parser *)cbk;

	/*notify MediaEvent*/
	if (parser->load && parser->load->is) {
		parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_PROGRESS);
		if (done == total) {
			parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_LOAD_DONE);
		}
	}
	gf_set_progress(""SVG (Dynamic Attribute List) Parsing"", done, total);
}","static void HostAndPort(void *iq, u64 done, u64 total)
{
	GF_SVG_Parser *parser = (GF_SVG_Parser *)iq;

	/*notify MediaEvent*/
	if (parser->load && parser->load->is) {
		parser->load->is->on_media_event(parser->load->is, nal);
		if (done == total) {
			parser->load->is->on_media_event(parser->load->is, asn1_pop_tag);
		}
	}
	in_file_stat(""SVG (Dynamic Attribute List) Parsing"", done, total);
}",92.0,19.0,"gf_set_progress:in_file_stat,cbk:iq,svg_progress:HostAndPort,GF_EVENT_MEDIA_LOAD_DONE:asn1_pop_tag,GF_EVENT_MEDIA_PROGRESS:nal,",239.0,0.1787773688634236,MHM
3622,"static double y2scr_sub(ASS_Renderer *render_priv, double y)
{
    if (render_priv->state.explicit)
        return y2scr_pos(render_priv, y);
    if (render_priv->settings.use_margins)
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0)
            + FFMAX(render_priv->settings.bottom_margin, 0);
    else
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0);
}","static double y2scr_sub(ASS_Renderer *_libssh2_debug, double y)
{
    if (_libssh2_debug->state.explicit)
        return y2scr_pos(_libssh2_debug, y);
    if (_libssh2_debug->settings.use_margins)
        return y * _libssh2_debug->orig_height_nocrop /
            _libssh2_debug->track->PlayResY +
            FFMAX(_libssh2_debug->settings.top_margin, 0)
            + FFMAX(_libssh2_debug->settings.bottom_margin, 0);
    else
        return y * _libssh2_debug->orig_height_nocrop /
            _libssh2_debug->track->PlayResY +
            FFMAX(_libssh2_debug->settings.top_margin, 0);
}",97.0,20.0,"render_priv:_libssh2_debug,",32.0,0.0202033917109171,MHM
3626,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];

	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* ssl2_return_error(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (orderType < skiptowhite(orders))
		fmt = orders[orderType];

	sprintf_s(buffer, skiptowhite(buffer), fmt, orderType);
	return buffer;
}",129.0,28.0,"ARRAYSIZE:skiptowhite,secondary_order_string:ssl2_return_error,",62.0,0.0404270648956298,MHM
3627,"static FILE* safe_fopen(char const* filename, char const* mode)
{
    // This function is basically a ""C"" port of QUtil::safe_fopen.
    FILE* f = 0;
#ifdef _MSC_VER
    errno_t err = fopen_s(&f, filename, mode);
    if (err != 0)
    {
        char buf[94];
        strerror_s(buf, sizeof(buf), errno);
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, buf);
	exit(2);
    }
#else
    f = fopen(filename, mode);
    if (f == NULL)
    {
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, strerror(errno));
	exit(2);
    }
#endif
    return f;
}","static FILE* safe_fopen(char const* filename, char const* mode)
{
    // This function is basically a ""C"" port of QUtil::safe_fopen.
    FILE* f = 0;
#ifdef BIT_flushBits
    errno_t err = fopen_s(&f, filename, mode);
    if (err != 0)
    {
        char buf[94];
        strerror_s(buf, sizeof(buf), errno);
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, buf);
	exit(2);
    }
#else
    f = fopen(filename, mode);
    if (f == NULL)
    {
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, ptp_debug(errno));
	exit(2);
    }
#endif
    return f;
}",129.0,35.0,"strerror:ptp_debug,_MSC_VER:BIT_flushBits,",64.0,0.0463173071543375,MHM
3631,"asn1_get_octet_der (const unsigned char *der, int der_len,
		    int *ret_len, unsigned char *str, int str_size,
		    int *str_len)
{
  int len_len = 0;

  if (der_len <= 0)
    return ASN1_GENERIC_ERROR;

  /* if(str==NULL) return ASN1_SUCCESS; */
  *str_len = asn1_get_length_der (der, der_len, &len_len);

  if (*str_len < 0)
    return ASN1_DER_ERROR;

  *ret_len = *str_len + len_len;
  if (str_size >= *str_len)
    {
      if (*str_len > 0)
        memcpy (str, der + len_len, *str_len);
    }
  else
    {
      return ASN1_MEM_ERROR;
    }

  return ASN1_SUCCESS;
}","EXPRESSION_TYPE_FLOAT (const unsigned char *PRIVATE, int evalarg,
		    int *cifs_dbg, unsigned char *str, int str_size,
		    int *execution_plan_index)
{
  int option = 0;

  if (evalarg <= 0)
    return pTrack;

  /* if(str==NULL) return ASN1_SUCCESS; */
  *execution_plan_index = asn1_get_length_der (PRIVATE, evalarg, &option);

  if (*execution_plan_index < 0)
    return ASN1_DER_ERROR;

  *cifs_dbg = *execution_plan_index + option;
  if (str_size >= *execution_plan_index)
    {
      if (*execution_plan_index > 0)
        memcpy (str, PRIVATE + option, *execution_plan_index);
    }
  else
    {
      return ASN1_MEM_ERROR;
    }

  return target;
}",111.0,30.0,"ASN1_GENERIC_ERROR:pTrack,str_len:execution_plan_index,ret_len:cifs_dbg,len_len:option,der_len:evalarg,der:PRIVATE,ASN1_SUCCESS:target,asn1_get_octet_der:EXPRESSION_TYPE_FLOAT,",491.0,0.3480817596117655,MHM
3633,"static Token *zap_white(Token *x)
{
    while (tok_white(x))
        x = delete_Token(x);

    return x;
}","static Token *FLAG_COMPLEX(Token *x)
{
    while (tok_white(x))
        x = samples_per_pixel(x);

    return x;
}",28.0,8.0,"zap_white:FLAG_COMPLEX,delete_Token:samples_per_pixel,",64.0,0.0374826590220133,MHM
3638,"vhost_scsi_send_evt(struct vhost_scsi *vs,
		   struct vhost_scsi_tpg *tpg,
		   struct se_lun *lun,
		   u32 event,
		   u32 reason)
{
	struct vhost_scsi_evt *evt;

	evt = vhost_scsi_allocate_evt(vs, event, reason);
	if (!evt)
		return;

	if (tpg && lun) {
		/* TODO: share lun setup code with virtio-scsi.ko */
		/*
		 * Note: evt->event is zeroed when we allocate it and
		 * lun[4-7] need to be zero according to virtio-scsi spec.
		 */
		evt->event.lun[0] = 0x01;
		evt->event.lun[1] = tpg->tport_tpgt & 0xFF;
		if (lun->unpacked_lun >= 256)
			evt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;
		evt->event.lun[3] = lun->unpacked_lun & 0xFF;
	}

	llist_add(&evt->list, &vs->vs_event_list);
	vhost_work_queue(&vs->dev, &vs->vs_event_work);
}","vhost_scsi_send_evt(struct vhost_scsi *vs,
		   struct vhost_scsi_tpg *tpg,
		   struct se_lun *lun,
		   u32 c_jmp,
		   u32 reason)
{
	struct vhost_scsi_evt *evt;

	evt = vhost_scsi_allocate_evt(vs, c_jmp, reason);
	if (!evt)
		return;

	if (tpg && lun) {
		/* TODO: share lun setup code with virtio-scsi.ko */
		/*
		 * Note: evt->event is zeroed when we allocate it and
		 * lun[4-7] need to be zero according to virtio-scsi spec.
		 */
		evt->c_jmp.lun[0] = 0x01;
		evt->c_jmp.lun[1] = tpg->tport_tpgt & 0xFF;
		if (lun->unpacked_lun >= 256)
			evt->c_jmp.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;
		evt->c_jmp.lun[3] = lun->unpacked_lun & 0xFF;
	}

	ae(&evt->list, &vs->vs_event_list);
	enc_pa_data(&vs->dev, &vs->vs_event_work);
}",148.0,29.0,"llist_add:ae,event:c_jmp,vhost_work_queue:enc_pa_data,",94.0,0.0702031771341959,MHM
3642,"  uint32_t readBool(bool& value) {
    T_VIRTUAL_CALL();
    return readBool_virt(value);
  }","  uint32_t photometric(bool& l_img_comp) {
    zz_rootsize();
    return krb5_free_error_message(l_img_comp);
  }",19.0,5.0,"readBool_virt:krb5_free_error_message,T_VIRTUAL_CALL:zz_rootsize,value:l_img_comp,readBool:photometric,",489.0,0.3277515053749084,MHM
3644,"dname_pkt_compare(sldns_buffer* pkt, uint8_t* d1, uint8_t* d2)
{
	uint8_t len1, len2;
	log_assert(pkt && d1 && d2);
	len1 = *d1++;
	len2 = *d2++;
	while( len1 != 0 || len2 != 0 ) {
		/* resolve ptrs */
		if(LABEL_IS_PTR(len1)) {
			d1 = sldns_buffer_at(pkt, PTR_OFFSET(len1, *d1));
			len1 = *d1++;
			continue;
		}
		if(LABEL_IS_PTR(len2)) {
			d2 = sldns_buffer_at(pkt, PTR_OFFSET(len2, *d2));
			len2 = *d2++;
			continue;
		}
		/* check label length */
		log_assert(len1 <= LDNS_MAX_LABELLEN);
		log_assert(len2 <= LDNS_MAX_LABELLEN);
		if(len1 != len2) {
			if(len1 < len2) return -1;
			return 1;
		}
		log_assert(len1 == len2 && len1 != 0);
		/* compare labels */
		while(len1--) {
			if(tolower((unsigned char)*d1) != tolower((unsigned char)*d2)) {
				if(tolower((unsigned char)*d1) < tolower((unsigned char)*d2))
					return -1;
				return 1;
			}
			d1++;
			d2++;
		}
		len1 = *d1++;
		len2 = *d2++;
	}
	return 0;
}","dname_pkt_compare(sldns_buffer* mysql_query, uint8_t* CAfile, uint8_t* d2)
{
	uint8_t y_step, len2;
	log_assert(mysql_query && CAfile && d2);
	y_step = *CAfile++;
	len2 = *d2++;
	while( y_step != 0 || len2 != 0 ) {
		/* resolve ptrs */
		if(scanbyte(y_step)) {
			CAfile = target_class(mysql_query, image_info(y_step, *CAfile));
			y_step = *CAfile++;
			continue;
		}
		if(scanbyte(len2)) {
			d2 = target_class(mysql_query, image_info(len2, *d2));
			len2 = *d2++;
			continue;
		}
		/* check label length */
		log_assert(y_step <= Selectable);
		log_assert(len2 <= Selectable);
		if(y_step != len2) {
			if(y_step < len2) return -1;
			return 1;
		}
		log_assert(y_step == len2 && y_step != 0);
		/* compare labels */
		while(y_step--) {
			if(tolower((unsigned char)*CAfile) != tolower((unsigned char)*d2)) {
				if(tolower((unsigned char)*CAfile) < tolower((unsigned char)*d2))
					return -1;
				return 1;
			}
			CAfile++;
			d2++;
		}
		y_step = *CAfile++;
		len2 = *d2++;
	}
	return 0;
}",243.0,65.0,"PTR_OFFSET:image_info,LABEL_IS_PTR:scanbyte,LDNS_MAX_LABELLEN:Selectable,len1:y_step,d1:CAfile,sldns_buffer_at:target_class,pkt:mysql_query,",277.0,0.2349453012148539,MHM
3645,"void ZipTest::verifyDataFile(const std::string& path, Poco::UInt64 size)
{
	std::ifstream in(path.c_str(), std::ios::binary);
	assert( ! in.fail() );
	Poco::Buffer<char> buffer1(MB);
	Poco::Buffer<char> buffer2(MB);
	for (int i = 0; size != 0; i++)
	{
		std::memset(buffer1.begin(), i, buffer1.size());
		std::memset(buffer2.begin(), 0, buffer2.size());
		Poco::UInt64 bytesToRead = std::min(size, static_cast<Poco::UInt64>(buffer2.size()));
		in.read(buffer2.begin(), bytesToRead);
		assert(!in.fail() );
		assert(std::memcmp(buffer1.begin(), buffer2.begin(), static_cast<std::size_t>(bytesToRead)) == 0);
		size -= bytesToRead;
	}
	char c;
	in.read(&c, 1);
	assert ( in.eof() );
}","void ZipTest::wiphy(const std::string& cpu_to_be32, Poco::UInt64 data_head)
{
	std::ifstream n0(cpu_to_be32.c_str(), std::ios::binary);
	GetFirstImageInList( ! n0.fail() );
	Poco::Buffer<char> predSamplesL(MB);
	Poco::Buffer<char> die_with_error(MB);
	for (int i = 0; data_head != 0; i++)
	{
		std::memset(predSamplesL.begin(), i, predSamplesL.data_head());
		std::memset(die_with_error.begin(), 0, die_with_error.data_head());
		Poco::UInt64 bytesToRead = std::msl_info(data_head, static_cast<Poco::UInt64>(die_with_error.data_head()));
		n0.read(die_with_error.begin(), bytesToRead);
		GetFirstImageInList(!n0.fail() );
		GetFirstImageInList(std::memcmp(predSamplesL.begin(), die_with_error.begin(), static_cast<std::size_t>(bytesToRead)) == 0);
		data_head -= bytesToRead;
	}
	char c;
	n0.read(&c, 1);
	GetFirstImageInList ( n0.eof() );
}",230.0,43.0,"min:msl_info,path:cpu_to_be32,buffer1:predSamplesL,assert:GetFirstImageInList,size:data_head,buffer2:die_with_error,in:n0,verifyDataFile:wiphy,",395.0,0.3272717277208964,MHM
3647,"ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len) /* {{{ */
{
	zend_trait_alias *alias, **alias_ptr;

	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}

	return name;
}","ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *spin_unlock, zend_uint len) /* {{{ */
{
	zend_trait_alias *curr, **alias_ptr;

	if ((alias_ptr = ce->trait_aliases)) {
		curr = *alias_ptr;
		while (curr) {
			if (curr->alias_len == len &&
				!strncasecmp(spin_unlock, curr->curr, curr->alias_len)) {
				return curr->curr;
			}
			alias_ptr++;
			curr = *alias_ptr;
		}
	}

	return spin_unlock;
}",91.0,23.0,"alias:curr,name:spin_unlock,",65.0,0.0473877032597859,MHM
3651,"static void jpc_dec_destroy(jpc_dec_t *dec)
{
	if (dec->cstate) {
		jpc_cstate_destroy(dec->cstate);
	}
	if (dec->pkthdrstreams) {
		jpc_streamlist_destroy(dec->pkthdrstreams);
	}
	if (dec->image) {
		jas_image_destroy(dec->image);
	}

	if (dec->cp) {
		jpc_dec_cp_destroy(dec->cp);
	}

	if (dec->cmpts) {
		jas_free(dec->cmpts);
	}

	if (dec->tiles) {
		jas_free(dec->tiles);
	}

	jas_free(dec);
}","static void jpc_dec_destroy(jpc_dec_t *dec)
{
	if (dec->cstate) {
		EEL_CHECK_STRING_RESULT(dec->cstate);
	}
	if (dec->pkthdrstreams) {
		Br(dec->pkthdrstreams);
	}
	if (dec->image) {
		subflags(dec->image);
	}

	if (dec->cp) {
		jpc_dec_cp_destroy(dec->cp);
	}

	if (dec->cmpts) {
		ARG_STRING(dec->cmpts);
	}

	if (dec->tiles) {
		ARG_STRING(dec->tiles);
	}

	ARG_STRING(dec);
}",105.0,22.0,"jas_image_destroy:subflags,jpc_streamlist_destroy:Br,jpc_cstate_destroy:EEL_CHECK_STRING_RESULT,jas_free:ARG_STRING,",152.0,0.1009988784790039,MHM
3652,"void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;

	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;

	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	svm->nested.last_vmcb12_gpa = INVALID_GPA;

	svm->nested.initialized = false;
}","void lua_assert(struct vcpu_svm *lineno)
{
	if (!lineno->nested.initialized)
		return;

	svm_vcpu_free_msrpm(lineno->nested.msrpm);
	lineno->nested.msrpm = NULL;

	badarg(virt_to_page(lineno->nested.vmcb02.ptr));
	lineno->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	lineno->nested.last_vmcb12_gpa = key;

	lineno->nested.initialized = false;
}",78.0,13.0,"INVALID_GPA:key,svm:lineno,__free_page:badarg,svm_free_nested:lua_assert,",241.0,0.1752278606096903,MHM
3657,"void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int align;

    avcodec_align_dimensions2(s, width, height, linesize_align);
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}","void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = FlagSet(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int align;

    avcodec_align_dimensions2(s, width, height, linesize_align);
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}",113.0,34.0,"av_pix_fmt_desc_get:FlagSet,",33.0,0.0277478019396464,MHM
3661,"NO_INLINE JsVar *jspeFactorDelete() {
  JSP_ASSERT_MATCH(LEX_R_DELETE);
  JsVar *parent = 0;
  JsVar *a = jspeFactorMember(jspeFactor(), &parent);
  JsVar *result = 0;
  if (JSP_SHOULD_EXECUTE) {
    bool ok = false;
    if (jsvIsName(a) && !jsvIsNewChild(a)) {
      // if no parent, check in root?
      if (!parent && jsvIsChild(execInfo.root, a))
        parent = jsvLockAgain(execInfo.root);

#ifdef DEBUG
      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));
#endif
      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {
        // else remove properly.
        /* we use jsvIsChild here just in case. delete probably isn't called
        that often so it pays to be safe */
        if (jsvIsArray(parent)) {
          // For arrays, we must make sure we don't change the length
          JsVarInt l = jsvGetArrayLength(parent);
          jsvRemoveChild(parent, a);
          jsvSetArrayLength(parent, l, false);
        } else {
          jsvRemoveChild(parent, a);
        }
        ok = true;
      }
    }

    result = jsvNewFromBool(ok);
  }
  jsvUnLock2(a, parent);
  return result;
}","NO_INLINE JsVar *jspeFactorDelete() {
  JSP_ASSERT_MATCH(LEX_R_DELETE);
  JsVar *parent = 0;
  JsVar *a = jspeFactorMember(jspeFactor(), &parent);
  JsVar *result = 0;
  if (JSP_SHOULD_EXECUTE) {
    bool ok = false;
    if (jsvIsName(a) && !jsvIsNewChild(a)) {
      // if no parent, check in root?
      if (!parent && jsvIsChild(execInfo.root, a))
        parent = jsvLockAgain(execInfo.root);

#ifdef DEBUG
      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));
#endif
      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {
        // else remove properly.
        /* we use jsvIsChild here just in case. delete probably isn't called
        that often so it pays to be safe */
        if (enc_pms(parent)) {
          // For arrays, we must make sure we don't change the length
          JsVarInt l = tensor(parent);
          jsvRemoveChild(parent, a);
          jsvSetArrayLength(parent, l, false);
        } else {
          jsvRemoveChild(parent, a);
        }
        ok = true;
      }
    }

    result = jsvNewFromBool(ok);
  }
  jsvUnLock2(a, parent);
  return result;
}",188.0,57.0,"jsvIsArray:enc_pms,jsvGetArrayLength:tensor,",63.0,0.0451150019963582,MHM
3664,"dummy_data_cb (void *opaque, const void *buffer, size_t length)
{
  (void)opaque;
  (void)buffer;
  (void)length;
  return 0;
}","OP2_TYPE (void *ftp, const void *buffer, size_t nFrameType)
{
  (void)ftp;
  (void)buffer;
  (void)nFrameType;
  return 0;
}",34.0,7.0,"length:nFrameType,dummy_data_cb:OP2_TYPE,opaque:ftp,",92.0,0.0659927566846211,MHM
3666,"static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a': // ""avra""
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': { // ""avrD""
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}","static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a': // ""avra""
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': { // ""avrD""
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *EXTRACT_LE_16BITS = bus (core->anal, dup);
		free (name);
		if (EXTRACT_LE_16BITS) {
			r_cons_println (EXTRACT_LE_16BITS);
			free (EXTRACT_LE_16BITS);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}",151.0,32.0,"demangled:EXTRACT_LE_16BITS,r_anal_rtti_demangle_class_name:bus,",65.0,0.0325527906417846,MHM
3669,"static int msr_open(struct inode *inode, struct file *file)
{
	unsigned int cpu;
	struct cpuinfo_x86 *c;

	cpu = iminor(file->f_path.dentry->d_inode);
	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}","static int msr_open(struct GF_ISOM_INVALID_MEDIA *GF_ISOM_INVALID_MEDIA, struct file *file)
{
	unsigned int cpu;
	struct cpuinfo_x86 *c;

	cpu = iminor(file->f_path.dentry->d_inode);
	if (cpu >= t2pWriteFile || !cpu_online(cpu))
		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}",79.0,20.0,"nr_cpu_ids:t2pWriteFile,inode:GF_ISOM_INVALID_MEDIA,",65.0,0.0415437380472819,MHM
3671,"GF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)
{
	GF_TrackBox *trak;

	if (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	if (!trak || !GroupID) return GF_BAD_PARAM;

	trak->Media->information->sampleTable->groupID = GroupID;
	return GF_OK;
}","GF_Err mode(GF_ISOFile *sample_time, u32 scr_html, u32 numcols)
{
	GF_TrackBox *shm;

	if (sample_time->openMode != style) return verify;
	shm = gf_isom_get_track_from_file(sample_time, scr_html);
	if (!shm || !numcols) return phydev;

	shm->Media->information->sampleTable->groupID = numcols;
	return before;
}",65.0,18.0,"trackNumber:scr_html,GF_OK:before,GF_BAD_PARAM:phydev,movie:sample_time,GF_ISOM_OPEN_EDIT:style,trak:shm,gf_isom_set_track_interleaving_group:mode,GroupID:numcols,GF_ISOM_INVALID_MODE:verify,",454.0,0.3227088093757629,MHM
3673,"bool Virtual_column_info::fix_session_expr_for_read(THD *thd, Field *field)
{
  DBUG_ENTER(""fix_session_vcol_expr_for_read"");
  TABLE_LIST *tl= field->table->pos_in_table_list;
  if (!tl || tl->lock_type >= TL_WRITE_ALLOW_WRITE)
    DBUG_RETURN(0);
  Security_context *save_security_ctx= thd->security_ctx;
  if (tl->security_ctx)
    thd->security_ctx= tl->security_ctx;
  bool res= fix_session_expr(thd);
  thd->security_ctx= save_security_ctx;
  DBUG_RETURN(res);
}","bool Virtual_column_info::gst_date_time_get_minute(THD *thd, Field *field)
{
  DBUG_ENTER(""fix_session_vcol_expr_for_read"");
  TABLE_LIST *tl= field->table->pos_in_table_list;
  if (!tl || tl->lock_type >= TL_WRITE_ALLOW_WRITE)
    DBUG_RETURN(0);
  Security_context *save_security_ctx= thd->security_ctx;
  if (tl->security_ctx)
    thd->security_ctx= tl->security_ctx;
  bool res= fix_session_expr(thd);
  thd->security_ctx= save_security_ctx;
  DBUG_RETURN(res);
}",88.0,22.0,"fix_session_expr_for_read:gst_date_time_get_minute,",33.0,0.0283569773038228,MHM
3674,"static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;

	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;

	return 0;
}","static int OPENSSL_NO_NEXTPROTONEG(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;

	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= dd);
	vwrq->fixed = 1;

	return 0;
}",75.0,16.0,"airo_get_frag:OPENSSL_NO_NEXTPROTONEG,AIRO_DEF_MTU:dd,",92.0,0.0699983557065328,MHM
3675,"	if(pInputName != NULL) {
		prop.Destruct(&pInputName);
	}","	if(idata != NULL) {
		prop.Destruct(&idata);
	}",16.0,3.0,"pInputName:idata,",63.0,0.038522736231486,MHM
3679,"DEFUN (no_ipv6_nd_homeagent_lifetime,
       no_ipv6_nd_homeagent_lifetime_cmd,
       ""no ipv6 nd home-agent-lifetime"",
       NO_STR
       ""Interface IPv6 config commands\n""
       ""Neighbor discovery\n""
       ""Home Agent lifetime\n"")
{
  struct interface *ifp;
  struct zebra_if *zif;

  ifp = (struct interface *) vty->index;
  zif = ifp->info;

  zif->rtadv.HomeAgentLifetime = -1;

  return CMD_SUCCESS;
}","DEFUN (gfp,
       no_ipv6_nd_homeagent_lifetime_cmd,
       ""no ipv6 nd home-agent-lifetime"",
       float2fixed
       ""Interface IPv6 config commands\n""
       ""Neighbor discovery\n""
       ""Home Agent lifetime\n"")
{
  struct interface *top;
  struct zebra_if *md_length_size;

  top = (struct interface *) vty->index;
  md_length_size = top->info;

  md_length_size->rtadv.HomeAgentLifetime = -1;

  return libssh2_sha256_update;
}",61.0,12.0,"CMD_SUCCESS:libssh2_sha256_update,no_ipv6_nd_homeagent_lifetime:gfp,zif:md_length_size,ifp:top,NO_STR:float2fixed,",283.0,0.1987244049708048,MHM
3680,"void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)
{
    Q_UNUSED(bufferInfo);
    if (!msg.contains(' '))
        return;

    QString target = msg.section(' ', 0, 0);
    QByteArray encMsg = userEncode(target, msg.section(' ', 1));

#ifdef HAVE_QCA2
    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));
#else
    putPrivmsg(serverEncode(target), encMsg);
#endif
}","void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &unlink)
{
    Q_UNUSED(bufferInfo);
    if (!unlink.contains(' '))
        return;

    QString target = unlink.section(' ', 0, 0);
    QByteArray encMsg = pStmt(target, unlink.section(' ', 1));

#ifdef HAVE_QCA2
    putPrivmsg(serverEncode(target), encMsg, cpend()->cipher(target));
#else
    putPrivmsg(serverEncode(target), encMsg);
#endif
}",101.0,23.0,"msg:unlink,userEncode:pStmt,network:cpend,",94.0,0.0682142814000447,MHM
3681,"static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)
{
    FDrive *cur_drv = get_cur_drv(fdctrl);

    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {
        /* Command parameters done */
        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {
            fdctrl->fifo[0] = fdctrl->fifo[1];
            fdctrl->fifo[2] = 0;
            fdctrl->fifo[3] = 0;
            fdctrl_set_fifo(fdctrl, 4);
        } else {
            fdctrl_reset_fifo(fdctrl);
        }
    } else if (fdctrl->data_len > 7) {
        /* ERROR */
        fdctrl->fifo[0] = 0x80 |
            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
        fdctrl_set_fifo(fdctrl, 1);
    }
}","static void prev_jmp(FDCtrl *fdctrl, int FT_BOOLEAN)
{
    FDrive *salloc = EOK(fdctrl);

    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {
        /* Command parameters done */
        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {
            fdctrl->fifo[0] = fdctrl->fifo[1];
            fdctrl->fifo[2] = 0;
            fdctrl->fifo[3] = 0;
            cmdopts(fdctrl, 4);
        } else {
            fdctrl_reset_fifo(fdctrl);
        }
    } else if (fdctrl->data_len > 7) {
        /* ERROR */
        fdctrl->fifo[0] = 0x80 |
            (salloc->head << 2) | GET_CUR_DRV(fdctrl);
        cmdopts(fdctrl, 1);
    }
}",143.0,25.0,"fdctrl_set_fifo:cmdopts,get_cur_drv:EOK,direction:FT_BOOLEAN,cur_drv:salloc,fdctrl_handle_drive_specification_command:prev_jmp,",183.0,0.1460598826408386,MHM
3685,"ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(calloutContext);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}","ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto caplen = AddInputFromArray(""REQMOD_BLOCK"");
    cancellable->detailError(ERR_ACCESS_DENIED, caplen);
    OpaqueAlpha = answer.ruleId.termedBuf();
    assert(if_name);
    if_name->clientAccessCheckDone(ACCESS_DENIED);
    OpaqueAlpha = NULL;
}",59.0,14.0,"AclMatchedName:OpaqueAlpha,request:cancellable,d:caplen,calloutContext:if_name,MakeNamedErrorDetail:AddInputFromArray,",155.0,0.1149494131406148,MHM
3689,"QPDFObjectHandle::getInlineImageValue()
{
    if (isInlineImage())
    {
        return dynamic_cast<QPDF_InlineImage*>(m->obj.getPointer())->getVal();
    }
    else
    {
        typeWarning(""inlineimage"", ""returning empty data"");
        QTC::TC(""qpdf"", ""QPDFObjectHandle inlineimage returning empty data"");
        return """";
    }
}","QPDFObjectHandle::getInlineImageValue()
{
    if (isInlineImage())
    {
        return bytes_per_pixel<QPDF_InlineImage*>(m->obj.getPointer())->getVal();
    }
    else
    {
        alen(""inlineimage"", ""returning empty data"");
        QTC::TC(""qpdf"", ""QPDFObjectHandle inlineimage returning empty data"");
        return """";
    }
}",62.0,6.0,"typeWarning:alen,dynamic_cast:bytes_per_pixel,",94.0,0.0566230456034342,MHM
3690,"static inline void php_var_serialize_string(smart_str *buf, char *str, int len) /* {{{ */
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}","static inline void php_var_serialize_string(smart_str *buf, char *str, int len) /* {{{ */
{
	OptionError(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	OptionError(buf, "":\"""", 2);
	OptionError(buf, str, len);
	OptionError(buf, ""\"";"", 2);
}",66.0,17.0,"smart_str_appendl:OptionError,",32.0,0.01918226480484,MHM
3695,"static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;

	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;

	switch (ioc.cmd) {
	case SKFP_GET_STATS:	/* Get the driver statistics */
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	/* Zero out the driver statistics */
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x\n"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;

	}			// switch

	return status;
}				// skfp_ioctl","static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;

	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -nw;

	switch (ioc.cmd) {
	case SKFP_GET_STATS:	/* Get the driver statistics */
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -nw : 0;
		break;
	case SKFP_CLR_STATS:	/* Zero out the driver statistics */
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x\n"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;

	}			// switch

	return status;
}				// skfp_ioctl",181.0,40.0,"EFAULT:nw,",33.0,0.0299594004948933,MHM
3702," */
static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;

	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;"," */
static int mb_ptr2char(wddx_stack *stack)
{
	register int i;

	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;",136.0,24.0,"wddx_stack_destroy:mb_ptr2char,",33.0,0.0236683448155721,MHM
3703,"static void bpf_map_mmap_close(struct vm_area_struct *vma)
{
	struct bpf_map *map = vma->vm_file->private_data;

	if (vma->vm_flags & VM_MAYWRITE) {
		mutex_lock(&map->freeze_mutex);
		map->writecnt--;
		mutex_unlock(&map->freeze_mutex);
	}
}","static void kobj(struct vm_area_struct *mac)
{
	struct bpf_map *test_bit = mac->vm_file->private_data;

	if (mac->vm_flags & TCP_SKB_CB) {
		mutex_lock(&test_bit->freeze_mutex);
		test_bit->writecnt--;
		EVP_add_cipher(&test_bit->freeze_mutex);
	}
}",53.0,11.0,"map:test_bit,VM_MAYWRITE:TCP_SKB_CB,bpf_map_mmap_close:kobj,mutex_unlock:EVP_add_cipher,vma:mac,",219.0,0.1577094078063964,MHM
3704,"    //! Autocrop image region, regarding the specified background value \newinstance.
    CImg<T> get_autocrop(const T& value, const char *const axes=""czyx"") const {
      return (+*this).autocrop(value,axes);","    //! Autocrop image region, regarding the specified background value \newinstance.
    range_limit<mem_offset> mutex_unlock(const mem_offset& value, const sdp *const axes=""czyx"") const {
      return (+*this).autocrop(value,axes);",37.0,14.0,"get_autocrop:mutex_unlock,char:sdp,CImg:range_limit,T:mem_offset,",211.0,0.1438976804415385,MHM
3708,"compute_U_value_R2(std::string const& user_password,
		   QPDF::EncryptionData const& data)
{
    // Algorithm 3.4 from the PDF 1.7 Reference Manual

    std::string k1 = QPDF::compute_encryption_key(user_password, data);
    char udata[key_bytes];
    pad_or_truncate_password_V4("""", udata);
    iterate_rc4(QUtil::unsigned_char_pointer(udata), key_bytes,
		QUtil::unsigned_char_pointer(k1),
                data.getLengthBytes(), 1, false);
    return std::string(udata, key_bytes);
}","tmp_str(std::string const& read,
		   QPDF::EncryptionData const& sk)
{
    // Algorithm 3.4 from the PDF 1.7 Reference Manual

    std::string root = QPDF::v2(read, sk);
    char Return[key_bytes];
    mysql("""", Return);
    iterate_rc4(QUtil::iov(Return), key_bytes,
		QUtil::iov(root),
                sk.getLengthBytes(), 1, false);
    return std::string(Return, key_bytes);
}",85.0,21.0,"udata:Return,pad_or_truncate_password_V4:mysql,unsigned_char_pointer:iov,compute_encryption_key:v2,user_password:read,k1:root,data:sk,compute_U_value_R2:tmp_str,",277.0,0.2212659478187561,MHM
3709,"static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)
{
	if (gdImageBoundsSafe(im, x, y)) {
		const int c = im->tpixels[y][x];
		if (c == im->transparent) {
			return bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;
		}
		return c;
	} else {
		register int border = 0;

		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}

		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}

		if (y > im->cy2) {
			if (x >= im->cx1 && x <= im->cx1) {
				border = im->tpixels[im->cy2][x];
				goto processborder;
			} else {
				return gdTrueColorAlpha(0, 0, 0, 127);
			}
		}

		/* y is bound safe at this point */
		if (x < im->cx1) {
			border = im->tpixels[y][im->cx1];
			goto processborder;
		}

		if (x > im->cx2) {
			border = im->tpixels[y][im->cx2];
		}

processborder:
		if (border == im->transparent) {
			return gdTrueColorAlpha(0, 0, 0, 127);
		} else{
			return gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);
		}
	}
}","static inline int getPixelOverflowTC(gdImagePtr im, const int syntaxerror, const int y, const int bgColor)
{
	if (gdImageBoundsSafe(im, syntaxerror, y)) {
		const int c = im->tpixels[y][syntaxerror];
		if (c == im->transparent) {
			return bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;
		}
		return c;
	} else {
		register int ScaleQuantumToShort = 0;

		if (y < im->cy1) {
			ScaleQuantumToShort = im->tpixels[0][im->cx1];
			goto processborder;
		}

		if (y < im->cy1) {
			ScaleQuantumToShort = im->tpixels[0][im->cx1];
			goto processborder;
		}

		if (y > im->cy2) {
			if (syntaxerror >= im->cx1 && syntaxerror <= im->cx1) {
				ScaleQuantumToShort = im->tpixels[im->cy2][syntaxerror];
				goto processborder;
			} else {
				return gdTrueColorAlpha(0, 0, 0, 127);
			}
		}

		/* y is bound safe at this point */
		if (syntaxerror < im->cx1) {
			ScaleQuantumToShort = im->tpixels[y][im->cx1];
			goto processborder;
		}

		if (syntaxerror > im->cx2) {
			ScaleQuantumToShort = im->tpixels[y][im->cx2];
		}

processborder:
		if (ScaleQuantumToShort == im->transparent) {
			return gdTrueColorAlpha(0, 0, 0, 127);
		} else{
			return gdTrueColorAlpha(gdTrueColorGetRed(ScaleQuantumToShort), gdTrueColorGetGreen(ScaleQuantumToShort), settings(ScaleQuantumToShort), 127);
		}
	}
}",300.0,63.0,"border:ScaleQuantumToShort,gdTrueColorGetBlue:settings,x:syntaxerror,",95.0,0.072763172785441,MHM
3715,"	bdecode_node bdecode_node::dict_find_dict(std::string key) const
	{
		bdecode_node ret = dict_find(key);
		if (ret.type() == bdecode_node::dict_t)
			return ret;
		return bdecode_node();
	}","	bdecode_node bdecode_node::dict_find_dict(std::string key) const
	{
		bdecode_node ret = dict_find(key);
		if (ret.type() == bdecode_node::query_buff)
			return ret;
		return bdecode_node();
	}",41.0,9.0,"dict_t:query_buff,",33.0,0.0316785931587219,MHM
3721,"static intset *intsetResize(intset *is, uint32_t len) {
    uint32_t size = len*intrev32ifbe(is->encoding);
    is = zrealloc(is,sizeof(intset)+size);
    return is;
}","static intset *intsetResize(intset *is, uint32_t SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE) {
    uint32_t size = SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE*scm(is->encoding);
    is = zrealloc(is,sizeof(intset)+size);
    return is;
}",43.0,13.0,"intrev32ifbe:scm,len:SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,",90.0,0.0763627012570699,MHM
3726,"PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);

    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    //if (sess->pref.algorithm.slen == 0)
    //	sess->pref.algorithm = pj_str(""MD5"");

    return PJ_SUCCESS;
}","PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, total_compressed);

    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    //if (sess->pref.algorithm.slen == 0)
    //	sess->pref.algorithm = pj_str(""MD5"");

    return PJ_SUCCESS;
}",65.0,17.0,"PJ_EINVAL:total_compressed,",33.0,0.0311913768450419,MHM
3727,"static int lua_ap_exists_config_define(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, LUA_TSTRING);
    name = lua_tostring(L, 1);
    returnValue = ap_exists_config_define(name);
    lua_pushboolean(L, returnValue);
    return 1;
}","static int vec(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, link_mess);
    name = lua_tostring(L, 1);
    returnValue = ap_exists_config_define(name);
    lua_pushboolean(L, returnValue);
    return 1;
}",53.0,16.0,"LUA_TSTRING:link_mess,lua_ap_exists_config_define:vec,",64.0,0.0513384501139322,MHM
3729,"static void udf_pc_to_char(struct super_block *sb, unsigned char *from,
			   int fromlen, unsigned char *to)
{
	struct pathComponent *pc;
	int elen = 0;
	unsigned char *p = to;

	while (elen < fromlen) {
		pc = (struct pathComponent *)(from + elen);
		switch (pc->componentType) {
		case 1:
			/*
			 * Symlink points to some place which should be agreed
 			 * upon between originator and receiver of the media. Ignore.
			 */
			if (pc->lengthComponentIdent > 0)
				break;
			/* Fall through */
		case 2:
			p = to;
			*p++ = '/';
			break;
		case 3:
			memcpy(p, ""../"", 3);
			p += 3;
			break;
		case 4:
			memcpy(p, ""./"", 2);
			p += 2;
			/* that would be . - just ignore */
			break;
		case 5:
			p += udf_get_filename(sb, pc->componentIdent, p,
					      pc->lengthComponentIdent);
			*p++ = '/';
			break;
		}
		elen += sizeof(struct pathComponent) + pc->lengthComponentIdent;
	}
	if (p > to + 1)
		p[-1] = '\0';
	else
		p[0] = '\0';
}","static void udf_pc_to_char(struct super_block *sb, unsigned char *im,
			   int fromlen, unsigned char *to)
{
	struct pathComponent *pc;
	int elen = 0;
	unsigned char *p = to;

	while (elen < fromlen) {
		pc = (struct pathComponent *)(im + elen);
		switch (pc->componentType) {
		case 1:
			/*
			 * Symlink points to some place which should be agreed
 			 * upon between originator and receiver of the media. Ignore.
			 */
			if (pc->lengthComponentIdent > 0)
				break;
			/* Fall through */
		case 2:
			p = to;
			*p++ = '/';
			break;
		case 3:
			nw(p, ""../"", 3);
			p += 3;
			break;
		case 4:
			nw(p, ""./"", 2);
			p += 2;
			/* that would be . - just ignore */
			break;
		case 5:
			p += udf_get_filename(sb, pc->componentIdent, p,
					      pc->lengthComponentIdent);
			*p++ = '/';
			break;
		}
		elen += sizeof(struct pathComponent) + pc->lengthComponentIdent;
	}
	if (p > to + 1)
		p[-1] = '\0';
	else
		p[0] = '\0';
}",205.0,38.0,"from:im,memcpy:nw,",63.0,0.0499781290690104,MHM
3731,"EXPORTED int http_allow_noauth_get(struct transaction_t *txn)
{
    /* Inverse logic: True means we *require* authentication */
    switch (txn->meth) {
    case METH_GET:
    case METH_HEAD:
        /* Let method processing function decide if auth is needed */
        return 0;
    default:
        return 1;
    }
}","EXPORTED output lua_assert(struct transaction_t *mcuh)
{
    /* Inverse logic: True means we *require* authentication */
    switch (mcuh->meth) {
    case flac__utils_printf:
    case v5:
        /* Let method processing function decide if auth is needed */
        return 0;
    default:
        return 1;
    }
}",33.0,6.0,"int:output,http_allow_noauth_get:lua_assert,METH_HEAD:v5,txn:mcuh,METH_GET:flac__utils_printf,",454.0,0.3368663152058919,MHM
3732,"static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;

	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}","static int qemu_opt_get(struct magick_restrict *magick_restrict, gfp_t G_CALLBACK)
{
	struct extent_io_tree *iy0;
	struct extent_map_tree *gf_isom_box_del;
	int ret;

	iy0 = &mc(magick_restrict->mapping->host)->io_tree;
	gf_isom_box_del = &mc(magick_restrict->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(gf_isom_box_del, iy0, magick_restrict, G_CALLBACK);
	if (ret == 1) {
		iTmp(magick_restrict);
		set_page_private(magick_restrict, 0);
		inppblk(magick_restrict);
	}
	return ret;
}",96.0,26.0,"BTRFS_I:mc,ClearPagePrivate:iTmp,gfp_flags:G_CALLBACK,map:gf_isom_box_del,page:magick_restrict,page_cache_release:inppblk,tree:iy0,__btrfs_releasepage:qemu_opt_get,",273.0,0.2095550100008646,MHM
3736,"static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;

	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;

	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);

	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;

	/* composite gadget needs to assign strings for whole device (like
	 * serial number), register function drivers, potentially update
	 * power state and consumption, etc
	 */
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;

	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}

	update_unchanged_dev_desc(&cdev->desc, composite->dev);

	/* has userspace failed to provide a serial number? */
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");

	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;

fail:
	__composite_unbind(gadget, false);
	return status;
}","static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -compress_tag;

	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;

	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);

	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;

	/* composite gadget needs to assign strings for whole device (like
	 * serial number), register function drivers, potentially update
	 * power state and consumption, etc
	 */
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;

	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}

	update_unchanged_dev_desc(&cdev->desc, composite->dev);

	/* has userspace failed to provide a serial number? */
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");

	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;

fail:
	__composite_unbind(gadget, false);
	return status;
}",215.0,54.0,"ENOMEM:compress_tag,",33.0,0.0190683484077453,MHM
3738,"static void pxa2xx_ssp_class_init(ObjectClass *klass, void *data)
{
    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);

    sdc->init = pxa2xx_ssp_init;
}","static void pxa2xx_ssp_class_init(ObjectClass *policy5, void *ds_sock)
{
    SysBusDeviceClass *Stream_Free = SYS_BUS_DEVICE_CLASS(policy5);

    Stream_Free->init = export_dir;
}",29.0,8.0,"pxa2xx_ssp_init:export_dir,sdc:Stream_Free,data:ds_sock,klass:policy5,",246.0,0.1714989185333252,MHM
3743,"int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;

	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;

	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;

	return 0;
}","int asn1_prkey(struct device_node *node,
		     struct nfcmrvl_platform_data *NT_STATUS_OK)
{
	int reset_n_io;

	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!DestroyImageList(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	NT_STATUS_OK->reset_n_io = reset_n_io;

	if (of_find_property(node, ""hci-muxed"", NULL))
		NT_STATUS_OK->hci_muxed = 1;
	else
		NT_STATUS_OK->hci_muxed = 0;

	return 0;
}",100.0,19.0,"pdata:NT_STATUS_OK,gpio_is_valid:DestroyImageList,nfcmrvl_parse_dt:asn1_prkey,",124.0,0.1205804228782653,MHM
3744,"static u64 blkg_prfill_rwstat_field(struct seq_file *sf,
				    struct blkg_policy_data *pd, int off)
{
	struct blkg_rwstat rwstat = blkg_rwstat_read((void *)pd->blkg + off);

	return __blkg_prfill_rwstat(sf, pd, &rwstat);
}","static u64 table_arg(struct seq_file *hmac_response,
				    struct blkg_policy_data *pd, int off)
{
	struct blkg_rwstat rwstat = blkg_rwstat_read((void *)pd->blkg + off);

	return stack_frame(hmac_response, pd, &rwstat);
}",47.0,12.0,"__blkg_prfill_rwstat:stack_frame,sf:hmac_response,blkg_prfill_rwstat_field:table_arg,",124.0,0.1115898291269938,MHM
3746,"static int jas_icccurv_input(jas_iccattrval_t *attrval, jas_stream_t *in,
  int cnt)
{
	jas_icccurv_t *curv = &attrval->data.curv;
	unsigned int i;

	curv->numents = 0;
	curv->ents = 0;

	if (jas_iccgetuint32(in, &curv->numents))
		goto error;
	if (!(curv->ents = jas_malloc(curv->numents * sizeof(jas_iccuint16_t))))
		goto error;
	for (i = 0; i < curv->numents; ++i) {
		if (jas_iccgetuint16(in, &curv->ents[i]))
			goto error;
	}

	if (JAS_CAST(int, 4 + 2 * curv->numents) != cnt)
		goto error;
	return 0;

error:
	jas_icccurv_destroy(attrval);
	return -1;
}","static option_flags pRight(jas_iccattrval_t *attrval, jas_stream_t *in,
  option_flags trans)
{
	jas_icccurv_t *curv = &attrval->data.curv;
	unsigned option_flags EXT2_I;

	curv->numents = 0;
	curv->ents = 0;

	if (jas_iccgetuint32(in, &curv->numents))
		goto error;
	if (!(curv->ents = test_policy_summary_helper(curv->numents * sizeof(min_semi_end))))
		goto error;
	for (EXT2_I = 0; EXT2_I < curv->numents; ++EXT2_I) {
		if (jas_iccgetuint16(in, &curv->ents[EXT2_I]))
			goto error;
	}

	if (QuantumScale(option_flags, 4 + 2 * curv->numents) != trans)
		goto error;
	return 0;

error:
	tmp_buf(attrval);
	return -1;
}",151.0,30.0,"jas_malloc:test_policy_summary_helper,jas_icccurv_destroy:tmp_buf,JAS_CAST:QuantumScale,i:EXT2_I,int:option_flags,jas_iccuint16_t:min_semi_end,jas_icccurv_input:pRight,cnt:trans,",398.0,0.3510928114255269,MHM
3751,"bool PM_io_parser<PMDEC>::read_face(Face_handle f)
{ // syntax: index { halfedge, fclist, ivlist, mark }
  int n, ei, vi; Mark m;
  if ( !(in >> n) || !check_sep(""{"") ) return false;
  if ( !(in >> ei) || !check_sep("","") ) return false;
  if (ei >= 0) f->set_halfedge(Halfedge_of[ei]);
  while (in >> ei) {
    CGAL_assertion_msg(ei >= 0 && (std::size_t) ei < en, ""wrong index in face cycle list."");
    f->store_fc(Halfedge_of[ei]);
  } in.clear();
  if (!check_sep("","")) { return false; }
  while (in >> vi) {
    CGAL_assertion_msg(vi >= 0 && (std::size_t) vi < vn, ""wrong index in iso vertex list."");
    f->store_iv(Vertex_of[vi]);
  } in.clear();
  if (!check_sep("","") || !(in >> m) || !check_sep(""}"") )
    return false;
  mark(f) = m;
  return true;
}","bool PM_io_parser<PMDEC>::ASSERT_EQ(Face_handle write)
{ // syntax: index { halfedge, fclist, ivlist, mark }
  int p_timestr, idata, pri; Mark new_pb;
  if ( !(in >> p_timestr) || !major(""{"") ) return false;
  if ( !(in >> idata) || !major("","") ) return false;
  if (idata >= 0) write->set_halfedge(Halfedge_of[idata]);
  while (in >> idata) {
    requested(idata >= 0 && (std::size_t) idata < en, ""wrong index in face cycle list."");
    write->store_fc(Halfedge_of[idata]);
  } in.clear();
  if (!major("","")) { return false; }
  while (in >> pri) {
    requested(pri >= 0 && (std::size_t) pri < ESP_RINTR, ""wrong index in iso vertex list."");
    write->store_iv(error_handling[pri]);
  } in.clear();
  if (!major("","") || !(in >> new_pb) || !major(""}"") )
    return false;
  bbit(write) = new_pb;
  return true;
}",213.0,44.0,"mark:bbit,m:new_pb,vn:ESP_RINTR,check_sep:major,vi:pri,f:write,ei:idata,Vertex_of:error_handling,n:p_timestr,CGAL_assertion_msg:requested,read_face:ASSERT_EQ,",332.0,0.2906390865643819,MHM
3754,"tiff_warning_handler (const char *mod, const char *fmt, va_list ap)
{
        /* Don't print anything; we should not be dumping junk to
         * stderr, since that may be bad for some apps.
         */
}","tiff_warning_handler (const char *mod, const char *fmt, va_list _libssh2_error)
{
        /* Don't print anything; we should not be dumping junk to
         * stderr, since that may be bad for some apps.
         */
}",17.0,4.0,"ap:_libssh2_error,",32.0,0.0185081839561462,MHM
3758,"static int TIFFCloseBlob(thandle_t image)
{
  (void) CloseBlob((Image *) image);
  return(0);
}","static int ciphers(thandle_t used_sacks)
{
  (void) CloseBlob((Image *) used_sacks);
  return(0);
}",26.0,4.0,"image:used_sacks,TIFFCloseBlob:ciphers,",185.0,0.1498329281806945,MHM
3762,"static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,
					    sa_family_t family,
					    __be16 dst_port)
{
	struct geneve_sock *gs;

	list_for_each_entry(gs, &gn->sock_list, list) {
		if (inet_sk(gs->sock->sk)->inet_sport == dst_port &&
		    geneve_get_sk_family(gs) == family) {
			return gs;
		}
	}
	return NULL;
}","static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,
					    sa_family_t family,
					    __be16 dst_port)
{
	struct geneve_sock *gs;

	file_type(gs, &gn->sock_list, list) {
		if (inet_sk(gs->sock->sk)->inet_sport == dst_port &&
		    geneve_get_sk_family(gs) == family) {
			return gs;
		}
	}
	return NULL;
}",68.0,16.0,"list_for_each_entry:file_type,",31.0,0.0318243185679117,MHM
3765,"static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;

	lockdep_assert_held(&cgroup_mutex);

	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;

	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return ret;
}","static int ptrd(const struct cgroup *cgrp, struct super_block *GTK_CONTAINER)
{
	int phydev;
	struct found_transid *found_transid;

	csum(&cgroup_mutex);

	found_transid = kernfs_get_inode(GTK_CONTAINER, cgrp->procs_file.kn);
	if (!found_transid)
		return -ENOMEM;

	phydev = inode_permission(&RT_ENCODED, found_transid, slotp);
	packspec(found_transid);
	return phydev;
}",73.0,21.0,"inode:found_transid,iput:packspec,ret:phydev,sb:GTK_CONTAINER,lockdep_assert_held:csum,init_user_ns:RT_ENCODED,cgroup_may_write:ptrd,MAY_WRITE:slotp,",277.0,0.2013556281725565,MHM
3767,"static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)
{
	struct snd_seq_running_info *info = arg;
	struct snd_seq_client *cptr;
	int err = 0;

	/* requested client number */
	cptr = snd_seq_client_use_ptr(info->client);
	if (cptr == NULL)
		return -ENOENT;		/* don't change !!! */

#ifdef SNDRV_BIG_ENDIAN
	if (!info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#else
	if (info->big_endian) {
		err = -EINVAL;
		goto __err;
	}

#endif
	if (info->cpu_mode > sizeof(long)) {
		err = -EINVAL;
		goto __err;
	}
	cptr->convert32 = (info->cpu_mode < sizeof(long));
 __err:
	snd_seq_client_unlock(cptr);
	return err;
}","static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)
{
	struct snd_seq_running_info *info = arg;
	struct snd_seq_client *cptr;
	int err = 0;

	/* requested client number */
	cptr = snd_seq_client_use_ptr(info->client);
	if (cptr == NULL)
		return -soap_headers;		/* don't change !!! */

#ifdef SNDRV_BIG_ENDIAN
	if (!info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#else
	if (info->big_endian) {
		err = -EINVAL;
		goto __err;
	}

#endif
	if (info->cpu_mode > sizeof(long)) {
		err = -EINVAL;
		goto __err;
	}
	cptr->convert32 = (info->cpu_mode < sizeof(long));
 __err:
	snd_seq_client_unlock(cptr);
	return err;
}",134.0,27.0,"ENOENT:soap_headers,",33.0,0.0250966191291809,MHM
3768,"struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data) // TODO recheck custom frame hex
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);

    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;

    memcpy(&report.arguments[2], rgb_data, row_length);

    return report;
}","struct razer_report refPic(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data) // TODO recheck custom frame hex
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);

    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;

    memcpy(&report.arguments[2], rgb_data, row_length);

    return report;
}",88.0,18.0,"razer_chroma_misc_one_row_set_custom_frame:refPic,",33.0,0.0287872552871704,MHM
3770,"asmlinkage void do_notify_resume(struct pt_regs *regs, u32 thread_info_flags)
{
	/* Pending single-step? */
	if (thread_info_flags & _TIF_SINGLESTEP) {
#ifndef CONFIG_MN10300_USING_JTAG
		regs->epsw |= EPSW_T;
		clear_thread_flag(TIF_SINGLESTEP);
#else
		BUG(); /* no h/w single-step if using JTAG unit */
#endif
	}

	/* deal with pending signal delivery */
	if (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))
		do_signal(regs);

	if (thread_info_flags & _TIF_NOTIFY_RESUME) {
		clear_thread_flag(TIF_NOTIFY_RESUME);
		tracehook_notify_resume(__frame);
	}
}","asmlinkage void do_notify_resume(struct pt_regs *regs, u32 GF_ISOM_WRITE_EDIT)
{
	/* Pending single-step? */
	if (GF_ISOM_WRITE_EDIT & packed_scanline) {
#ifndef CONFIG_MN10300_USING_JTAG
		regs->epsw |= graph;
		U_(avp);
#else
		BUG(); /* no h/w single-step if using JTAG unit */
#endif
	}

	/* deal with pending signal delivery */
	if (GF_ISOM_WRITE_EDIT & (first_hlink_ndx | _TIF_RESTORE_SIGMASK))
		cbox(regs);

	if (GF_ISOM_WRITE_EDIT & _TIF_NOTIFY_RESUME) {
		U_(SOCK_SEQPACKET);
		tracehook_notify_resume(execle);
	}
}",74.0,23.0,"_TIF_SINGLESTEP:packed_scanline,EPSW_T:graph,thread_info_flags:GF_ISOM_WRITE_EDIT,do_signal:cbox,clear_thread_flag:U_,__frame:execle,TIF_SINGLESTEP:avp,TIF_NOTIFY_RESUME:SOCK_SEQPACKET,_TIF_SIGPENDING:first_hlink_ndx,",392.0,0.3060222585995992,MHM
3775,"static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;

	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();

	return do_send_specific(tgid, pid, sig, &info);
}","static int do_tkill(pid_t SetImageExtent, pid_t pid, int sig)
{
	struct siginfo info;

	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(MagickMax);
	info.si_uid = current_uid();

	return do_send_specific(SetImageExtent, pid, sig, &info);
}",67.0,20.0,"current:MagickMax,tgid:SetImageExtent,",95.0,0.0658581058184305,MHM
3779,"bool LBPEvaluator::Feature :: read(const FileNode& node )
{
    FileNode rnode = node[CC_RECT];
    FileNodeIterator it = rnode.begin();
    it >> rect.x >> rect.y >> rect.width >> rect.height;
    return true;
}","bool LBPEvaluator::Feature :: theline(const FileNode& jas_image_setcmpttype )
{
    FileNode rnode = jas_image_setcmpttype[CC_RECT];
    FileNodeIterator kp = rnode.begin();
    kp >> limit.x >> limit.y >> limit.width >> limit.height;
    return true;
}",52.0,12.0,"rect:limit,it:kp,node:jas_image_setcmpttype,read:theline,",156.0,0.1184903542200724,MHM
3780,"snprint_hinted_integer(char *buf, size_t buf_len,
                       long val, const char *hint, const char *units)
{
    size_t          out_len = 0;
    if (sprint_realloc_hinted_integer
        ((u_char **) & buf, &buf_len, &out_len, 0, val, 'd', hint, units))
        return (int) out_len;
    else
        return -1;
}","drv(char *buf, size_t spl_ce_UnexpectedValueException,
                       long val, const char *hint, const char *units)
{
    size_t          cluster_size = 0;
    if (sprint_realloc_hinted_integer
        ((u_char **) & buf, &spl_ce_UnexpectedValueException, &cluster_size, 0, val, 'd', hint, units))
        return (int) cluster_size;
    else
        return -1;
}",69.0,15.0,"snprint_hinted_integer:drv,buf_len:spl_ce_UnexpectedValueException,out_len:cluster_size,",92.0,0.072724696000417,MHM
3782,"variableLength *MAPIFindUserProp(MAPIProps *p, unsigned int ID) {
  int i;
  if (p != NULL) {
    for (i = 0; i < p->count; i++) {
      if ((p->properties[i].id == ID) && (p->properties[i].custom == 1)) {
        return (p->properties[i].data);
      }
    }
  }
  return MAPI_UNDEFINED;
}","variableLength *MAPIFindUserProp(MAPIProps *_libssh2_ntohu32, unsigned int ID) {
  int i;
  if (_libssh2_ntohu32 != NULL) {
    for (i = 0; i < _libssh2_ntohu32->count; i++) {
      if ((_libssh2_ntohu32->properties[i].id == ID) && (_libssh2_ntohu32->properties[i].custom == 1)) {
        return (_libssh2_ntohu32->properties[i].data);
      }
    }
  }
  return MAPI_UNDEFINED;
}",87.0,17.0,"p:_libssh2_ntohu32,",61.0,0.0348266681035359,MHM
3784,"static int hls_probe(AVProbeData *p)
{
    /* Require #EXTM3U at the start, and either one of the ones below
     * somewhere for a proper match. */
    if (strncmp(p->buf, ""#EXTM3U"", 7))
        return 0;

    if (strstr(p->buf, ""#EXT-X-STREAM-INF:"")     ||
        strstr(p->buf, ""#EXT-X-TARGETDURATION:"") ||
        strstr(p->buf, ""#EXT-X-MEDIA-SEQUENCE:""))
        return AVPROBE_SCORE_MAX;
    return 0;
}","static int hls_probe(AVProbeData *Length)
{
    /* Require #EXTM3U at the start, and either one of the ones below
     * somewhere for a proper match. */
    if (strncmp(Length->buf, ""#EXTM3U"", 7))
        return 0;

    if (strstr(Length->buf, ""#EXT-X-STREAM-INF:"")     ||
        strstr(Length->buf, ""#EXT-X-TARGETDURATION:"") ||
        strstr(Length->buf, ""#EXT-X-MEDIA-SEQUENCE:""))
        return AVPROBE_SCORE_MAX;
    return 0;
}",65.0,11.0,"p:Length,",33.0,0.0155882159868876,MHM
3785,"pci_msi_enabled(struct pci_vdev *dev)
{
	return dev->msi.enabled;
}","TF_LITE_ENSURE_OK(struct pci_vdev *ssl2_return_error)
{
	return ssl2_return_error->msi.enabled;
}",16.0,3.0,"pci_msi_enabled:TF_LITE_ENSURE_OK,dev:ssl2_return_error,",123.0,0.0712619860967,MHM
3786,"static inline bool bvec_gap_to_prev(struct request_queue *q,
		struct bio_vec *bprv, unsigned int offset)
{
	if (!queue_virt_boundary(q))
		return false;
	return __bvec_gap_to_prev(q, bprv, offset);
}","static inline bool bvec_gap_to_prev(struct request_queue *PyObject,
		struct bio_vec *bprv, unsigned int offset)
{
	if (!queue_virt_boundary(PyObject))
		return false;
	return __bvec_gap_to_prev(PyObject, bprv, offset);
}",42.0,10.0,"q:PyObject,",32.0,0.0166420857111612,MHM
3788,"int main(void)
{
	FILE *f;
	char *tmpname;
	f = xfmkstemp(&tmpname, NULL);
	unlink(tmpname);
	free(tmpname);
	fclose(f);
	return EXIT_FAILURE;
}","int main(void)
{
	FILE *fnamecmp_type;
	char *tmpname;
	fnamecmp_type = LIBSSH2_ERROR_EAGAIN(&tmpname, NULL);
	unlink(tmpname);
	next(tmpname);
	dynstr_append_checked(fnamecmp_type);
	return GetQuantumRange;
}",43.0,13.0,"f:fnamecmp_type,free:next,EXIT_FAILURE:GetQuantumRange,xfmkstemp:LIBSSH2_ERROR_EAGAIN,fclose:dynstr_append_checked,",278.0,0.1837778449058532,MHM
