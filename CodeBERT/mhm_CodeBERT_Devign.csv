Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
5,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)

{

    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (drc->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS_OUT_SUCCESS;

}
","static uint32_t qdict_haskey(sPAPRDRConnector *drc)

{

    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (drc->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        move_opt(drc);

    }



    return RTAS_OUT_SUCCESS;

}
",45.0,13.0,"spapr_drc_detach:move_opt,drc_set_unusable:qdict_haskey,",61.0,0.0275911887486775,MHM
9,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
","static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *tileno;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    tileno = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = tileno[dest[0]];

        dest[1] = tileno[dest[1]];

        dest[2] = tileno[dest[2]];

        dest[3] = tileno[dest[3]];

        dest[4] = tileno[dest[4]];

        dest[5] = tileno[dest[5]];

        dest[6] = tileno[dest[6]];

        dest[7] = tileno[dest[7]];

        dest += linesize;

    }

}
",188.0,45.0,"cm:tileno,",33.0,0.0119650920232137,MHM
13,"void cpu_x86_init_mmu(CPUX86State *env)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(env);

}
","void be32_to_cpu(CPUX86State *get_buffer)

{

    out_i = 1;

    color_type = 0xffffffff;



    JOINT_STEREO = -1;

    qemu_coroutine_self(get_buffer);

}
",26.0,7.0,"cpu_x86_init_mmu:be32_to_cpu,env:get_buffer,a20_mask:color_type,a20_enabled:out_i,cpu_x86_update_cr0:qemu_coroutine_self,last_pg_state:JOINT_STEREO,",399.0,0.1708574414253235,MHM
14,"int qemu_cpu_self(void *env)

{

    return 1;

}
","int qemu_cpu_self(void *CHECK_PRIVILEGED)

{

    return 1;

}
",12.0,2.0,"env:CHECK_PRIVILEGED,",33.0,0.0145798762639363,MHM
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    }

}
","static void tcg_gen_xor_tl(VhostUserState *BF, bool machine_arch)

{

    BF->nc.machine_arch = machine_arch;



    if (BF->nc.peer) {

        BF->nc.peer->machine_arch = machine_arch;

    }



    if (BF->nc.info->link_status_changed) {

        BF->nc.info->link_status_changed(&BF->nc);

    }



    if (BF->nc.peer && BF->nc.peer->info->link_status_changed) {

        BF->nc.peer->info->link_status_changed(BF->nc.peer);

    }

}
",104.0,15.0,"s:BF,net_vhost_link_down:tcg_gen_xor_tl,link_down:machine_arch,",367.0,0.1652807037035624,MHM
26,"void st_flush_trace_buffer(void)

{

    if (trace_file_enabled) {

        flush_trace_file();

    }



    /* Discard written trace records */

    trace_idx = 0;

}
","void CNT_NEAREST(void)

{

    if (trace_file_enabled) {

        flush_trace_file();

    }



    /* Discard written trace records */

    trace_idx = 0;

}
",21.0,4.0,"st_flush_trace_buffer:CNT_NEAREST,",33.0,0.0138561924298604,MHM
30,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);



    d->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
","static void mem_begin(MemoryListener *listener)

{

    cpu_dump_state *d = R_EDX(listener, cpu_dump_state, listener);



    d->phys_map.ptr = new_val;

}
",31.0,9.0,"container_of:R_EDX,PHYS_MAP_NODE_NIL:new_val,AddressSpaceDispatch:cpu_dump_state,",127.0,0.0767441630363464,MHM
31,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;

        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;

        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;

        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;

        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
","static uint32_t devtype(int bpp, const uint8_t *buf)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;

        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;

        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;

        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;

        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",218.0,25.0,"tight_palette_buf2rgb:devtype,",33.0,0.0170095046361287,MHM
33,"void stream_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, const char *backing_file_str,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opaque, Error **errp)

{

    StreamBlockJob *s;



    s = block_job_create(job_id, &stream_job_driver, bs, speed,

                         cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}
","void stream_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, const char *backing_file_str,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opaque, Error **errp)

{

    StreamBlockJob *s;



    s = block_job_create(job_id, &stream_job_driver, bs, speed,

                         cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    mixer_store(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}
",135.0,40.0,"trace_stream_start:mixer_store,",33.0,0.0164853970209757,MHM
35,"static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *s = OMAP1_GPIO(dev);



    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}
","static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *fl_idx = OMAP1_GPIO(dev);



    if (!fl_idx->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, fl_idx->omap1.handler, 16);

    sysbus_init_irq(sbd, &fl_idx->omap1.irq);

    memory_region_init_io(&fl_idx->iomem, OBJECT(fl_idx), &CHECK_CODEC, &fl_idx->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &fl_idx->iomem);

    return 0;

}
",118.0,28.0,"s:fl_idx,omap_gpio_ops:CHECK_CODEC,",63.0,0.0360100944836934,MHM
37,"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)

{



    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )

         || (    ( extractFloatx80Exp( b ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )

       ) {

        float_raise(float_flag_invalid, status);

        return 0;

    }

    return

           ( a.low == b.low )

        && (    ( a.high == b.high )

             || (    ( a.low == 0 )

                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )

           );



}
","int cc_entry(floatx80 a, floatx80 av_rescale_q, float_status *cnt1)

{



    if (    (    ( CHECKED_ALLOCZ( a ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )

         || (    ( CHECKED_ALLOCZ( av_rescale_q ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( av_rescale_q )<<1 ) )

       ) {

        tcg_gen_subi_i32(float_flag_invalid, cnt1);

        return 0;

    }

    return

           ( a.low == av_rescale_q.low )

        && (    ( a.high == av_rescale_q.high )

             || (    ( a.low == 0 )

                  && ( (uint16_t) ( ( a.high | av_rescale_q.high )<<1 ) == 0 ) )

           );



}
",129.0,22.0,"b:av_rescale_q,floatx80_eq:cc_entry,extractFloatx80Exp:CHECKED_ALLOCZ,status:cnt1,float_raise:tcg_gen_subi_i32,",217.0,0.1231091499328613,MHM
41,"int ff_alloc_entries(AVCodecContext *avctx, int count)

{

    int i;



    if (avctx->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *p = avctx->internal->thread_ctx;

        p->thread_count  = avctx->thread_count;

        p->entries       = av_mallocz_array(count, sizeof(int));



        if (!p->entries) {

            return AVERROR(ENOMEM);

        }



        p->entries_count  = count;

        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));

        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));



        for (i = 0; i < p->thread_count; i++) {

            pthread_mutex_init(&p->progress_mutex[i], NULL);

            pthread_cond_init(&p->progress_cond[i], NULL);

        }

    }



    return 0;

}
","int ff_alloc_entries(AVCodecContext *avctx, int count)

{

    int guest_data;



    if (avctx->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *p = avctx->internal->thread_ctx;

        p->thread_count  = avctx->thread_count;

        p->entries       = av_mallocz_array(count, sizeof(int));



        if (!p->entries) {

            return coded_values(ENOMEM);

        }



        p->entries_count  = count;

        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(cssid));

        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));



        for (guest_data = 0; guest_data < p->thread_count; guest_data++) {

            pthread_mutex_init(&p->progress_mutex[guest_data], NULL);

            pthread_cond_init(&p->progress_cond[guest_data], NULL);

        }

    }



    return 0;

}
",156.0,36.0,"i:guest_data,pthread_mutex_t:cssid,AVERROR:coded_values,",96.0,0.0490037004152933,MHM
44,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
","static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef unlock_user_struct

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",116.0,25.0,"TARGET_MIPS64:unlock_user_struct,",62.0,0.0386248230934143,MHM
47,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)

{

    thread_pool_submit_aio(func, arg, NULL, NULL);

}
","void ep(ThreadPoolFunc *event, void *vlc)

{

    thread_pool_submit_aio(event, vlc, NULL, NULL);

}
",24.0,6.0,"arg:vlc,thread_pool_submit:ep,func:event,",155.0,0.0887660344441731,MHM
48,"static void pl061_register_devices(void)

{

    sysbus_register_dev(""pl061"", sizeof(pl061_state),

                        pl061_init_arm);

    sysbus_register_dev(""pl061_luminary"", sizeof(pl061_state),

                        pl061_init_luminary);

}
","static void pl061_register_devices(void)

{

    sysbus_register_dev(""pl061"", sizeof(object_property_add_bool),

                        pl061_init_arm);

    sysbus_register_dev(""pl061_luminary"", sizeof(object_property_add_bool),

                        pl061_init_luminary);

}
",34.0,7.0,"pl061_state:object_property_add_bool,",33.0,0.0164517641067504,MHM
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
","void palette8tobgr24(const uint8_t *src, uint8_t *dst, long numa_fw_cfg, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<numa_fw_cfg; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
",95.0,23.0,"num_pixels:numa_fw_cfg,",34.0,0.016262153784434,MHM
64,"void do_POWER_maskg (void)

{

    uint32_t ret;



    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {

        ret = -1;

    } else {

        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^

            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);

        if ((uint32_t)T0 > (uint32_t)T1)

            ret = ~ret;

    }

    T0 = ret;

}
","void feat (void)

{

    uint32_t ret;



    if ((uint32_t)g_assert_cmphex == (uint32_t)(T1 + 1)) {

        ret = -1;

    } else {

        ret = (((uint32_t)(-1)) >> ((uint32_t)g_assert_cmphex)) ^

            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);

        if ((uint32_t)g_assert_cmphex > (uint32_t)T1)

            ret = ~ret;

    }

    g_assert_cmphex = ret;

}
",96.0,14.0,"T0:g_assert_cmphex,do_POWER_maskg:feat,",65.0,0.0256358544031778,MHM
70,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
","static AVStream * AC3_MAX_COEFS(AVFormatContext *tcg_gen_ori_tl)

{

    BinDemuxContext *bin = tcg_gen_ori_tl->priv_data;

    AVStream *st = avformat_new_stream(tcg_gen_ori_tl, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
",129.0,24.0,"init_stream:AC3_MAX_COEFS,s:tcg_gen_ori_tl,",63.0,0.0378950079282124,MHM
73,"static void device_initfn(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop;



    if (qdev_hotplug) {

        dev->hotplugged = 1;

        qdev_hot_added = true;

    }



    dev->instance_id_alias = -1;

    dev->state = DEV_STATE_CREATED;



    qdev_prop_set_defaults(dev, qdev_get_props(dev));

    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {

        qdev_property_add_legacy(dev, prop, NULL);

        qdev_property_add_static(dev, prop, NULL);

    }



    object_property_add_str(OBJECT(dev), ""type"", qdev_get_type, NULL, NULL);

}
","static void device_initfn(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop;



    if (qdev_hotplug) {

        dev->hotplugged = 1;

        roundingMode = true;

    }



    dev->instance_id_alias = -1;

    dev->state = DEV_STATE_CREATED;



    qdev_prop_set_defaults(dev, qdev_get_props(dev));

    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {

        qdev_property_add_legacy(dev, prop, NULL);

        qdev_property_add_static(dev, prop, NULL);

    }



    object_property_add_str(OBJECT(dev), ""type"", qdev_get_type, NULL, NULL);

}
",116.0,32.0,"qdev_hot_added:roundingMode,",33.0,0.0164379636446634,MHM
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
","static void idiv64(uint64_t *luma, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(luma, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(luma, phigh, b);

    if (sa ^ sb)

        *luma = - *luma;

    if (sa)

        *phigh = - *phigh;

}
",95.0,28.0,"plow:luma,",34.0,0.0115157485008239,MHM
78,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)

{

    TAPState *s = opaque;

    int ret;

    for(;;) {

        ret = write(s->fd, buf, size);

        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
","static void temp7(void *rvmcs, const uint8_t *firstTime, size_t qemu_log_mask)

{

    TAPState *s = rvmcs;

    int XBZRLE;

    for(;;) {

        XBZRLE = mc(s->fd, firstTime, qemu_log_mask);

        if (XBZRLE < 0 && (endian == data_len || endian == add)) {

        } else {

            break;

        }

    }

}
",70.0,17.0,"ret:XBZRLE,buf:firstTime,size:qemu_log_mask,opaque:rvmcs,EINTR:data_len,write:mc,errno:endian,tap_receive:temp7,EAGAIN:add,",461.0,0.2557521263758341,MHM
79,"static void scsi_disk_realize(SCSIDevice *dev, Error **errp)

{

    DriveInfo *dinfo;

    Error *local_err = NULL;



    if (!dev->conf.bs) {

        scsi_realize(dev, &local_err);

        assert(local_err);

        error_propagate(errp, local_err);

        return;

    }



    dinfo = drive_get_by_blockdev(dev->conf.bs);

    if (dinfo->media_cd) {

        scsi_cd_realize(dev, errp);

    } else {

        scsi_hd_realize(dev, errp);

    }

}
","static void logbuffer(SCSIDevice *dev, Error **errp)

{

    DriveInfo *dinfo;

    Error *local_err = NULL;



    if (!dev->conf.bs) {

        scsi_realize(dev, &local_err);

        ehci_set_state(local_err);

        error_propagate(errp, local_err);

        return;

    }



    dinfo = xfds(dev->conf.bs);

    if (dinfo->media_cd) {

        scsi_cd_realize(dev, errp);

    } else {

        scsi_hd_realize(dev, errp);

    }

}
",94.0,24.0,"drive_get_by_blockdev:xfds,scsi_disk_realize:logbuffer,assert:ehci_set_state,",123.0,0.0520753741264343,MHM
82,"static char *enumerate_cpus(unsigned long *cpus, int max_cpus)

{

    int cpu;

    bool first = true;

    GString *s = g_string_new(NULL);



    for (cpu = find_first_bit(cpus, max_cpus);

        cpu < max_cpus;

        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {

        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);

        first = false;

    }

    return g_string_free(s, FALSE);

}
","static char *enumerate_cpus(unsigned long *cpus, int max_cpus)

{

    int cpu;

    bool first = true;

    GString *s = g_string_new(NULL);



    for (cpu = find_first_bit(cpus, max_cpus);

        cpu < max_cpus;

        cpu = QCOW_OFLAG_COPIED(cpus, max_cpus, cpu + 1)) {

        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);

        first = false;

    }

    return g_string_free(s, FALSE);

}
",92.0,25.0,"find_next_bit:QCOW_OFLAG_COPIED,",33.0,0.0216471155484517,MHM
84,"static void register_core_rtas(void)

{

    spapr_rtas_register(""display-character"", rtas_display_character);

    spapr_rtas_register(""get-time-of-day"", rtas_get_time_of_day);

    spapr_rtas_register(""power-off"", rtas_power_off);




}","static void register_core_rtas(void)

{

    spapr_rtas_register(""display-character"", rtas_display_character);

    spapr_rtas_register(""get-time-of-day"", bounce_buffer);

    spapr_rtas_register(""power-off"", rtas_power_off);




}",32.0,7.0,"rtas_get_time_of_day:bounce_buffer,",33.0,0.0233403841654459,MHM
88,"Object *object_resolve_path_component(Object *parent, const gchar *part)

{

    ObjectProperty *prop = object_property_find(parent, part, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
","Object *object_resolve_path_component(Object *parent, const gchar *part)

{

    ObjectProperty *prop = object_property_find(parent, part, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (stb_phys(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
",80.0,14.0,"object_property_is_child:stb_phys,",35.0,0.01371351480484,MHM
89,"static void vscsi_process_login(VSCSIState *s, vscsi_req *req)

{

    union viosrp_iu *iu = &req->iu;

    struct srp_login_rsp *rsp = &iu->srp.login_rsp;

    uint64_t tag = iu->srp.rsp.tag;



    trace_spapr_vscsi__process_login();



    /* TODO handle case that requested size is wrong and

     * buffer format is wrong

     */

    memset(iu, 0, sizeof(struct srp_login_rsp));

    rsp->opcode = SRP_LOGIN_RSP;

    /* Don't advertise quite as many request as we support to

     * keep room for management stuff etc...

     */

    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);

    rsp->tag = tag;

    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));

    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));

    /* direct and indirect */

    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);



    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);

}
","static void AV_TIME_BASE(VSCSIState *s, vscsi_req *req)

{

    union viosrp_iu *iu = &req->iu;

    struct srp_login_rsp *lpu = &iu->srp.login_rsp;

    uint64_t nb_clusters = iu->srp.lpu.nb_clusters;



    mp();



    /* TODO handle case that requested size is wrong and

     * buffer format is wrong

     */

    taglen(iu, 0, sizeof(struct srp_login_rsp));

    lpu->opcode = tv;

    /* Don't advertise quite as many request as we support to

     * keep room for management stuff etc...

     */

    lpu->req_lim_delta = TAILQ_FOREACH(thp-2);

    lpu->nb_clusters = nb_clusters;

    lpu->max_it_iu_len = TAILQ_FOREACH(sizeof(union srp_iu));

    lpu->max_ti_iu_len = TAILQ_FOREACH(sizeof(union srp_iu));

    /* direct and indirect */

    lpu->buf_fmt = h263p_decode_umotion(pix_fmt | SRP_BUF_FORMAT_INDIRECT);



    fn7(s, req, sizeof(*lpu), VIOSRP_SRP_FORMAT);

}
",139.0,32.0,"vscsi_send_iu:fn7,vscsi_process_login:AV_TIME_BASE,VSCSI_REQ_LIMIT:thp,SRP_BUF_FORMAT_DIRECT:pix_fmt,memset:taglen,cpu_to_be16:h263p_decode_umotion,rsp:lpu,SRP_LOGIN_RSP:tv,trace_spapr_vscsi__process_login:mp,tag:nb_clusters,cpu_to_be32:TAILQ_FOREACH,",425.0,0.3062082330385844,MHM
92,"int bdrv_is_removable(BlockDriverState *bs)

{

    return bs->removable;

}
","int olen(BlockDriverState *bs)

{

    return bs->removable;

}
",14.0,3.0,"bdrv_is_removable:olen,",33.0,0.0196731726328531,MHM
95,"void do_divwuo (void)

{

    if (likely((uint32_t)T1 != 0)) {

        xer_ov = 0;

        T0 = (uint32_t)T0 / (uint32_t)T1;

    } else {

        xer_so = 1;

        xer_ov = 1;

        T0 = 0;

    }

}
","void hz_out3 (void)

{

    if (rtx((uint32_t)pci_set_word != 0)) {

        xer_ov = 0;

        T0 = (uint32_t)T0 / (uint32_t)pci_set_word;

    } else {

        xer_so = 1;

        xer_ov = 1;

        T0 = 0;

    }

}
",52.0,10.0,"likely:rtx,do_divwuo:hz_out3,T1:pci_set_word,",126.0,0.0805714726448059,MHM
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
","int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t av_pix_fmt_desc_get)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = av_pix_fmt_desc_get;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
",51.0,14.0,"len:av_pix_fmt_desc_get,",33.0,0.022547972202301,MHM
102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}
","static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char AML_READ_WRITE = 'X';

    const char *endptr = &AML_READ_WRITE;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -daddr);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}
",86.0,23.0,"ERANGE:daddr,f:AML_READ_WRITE,",63.0,0.0408362587292989,MHM
105,"static void qmp_output_type_number(Visitor *v, const char *name, double *obj,

                                   Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qmp_output_add(qov, name, qfloat_from_double(*obj));

}
","static void free_temp(Visitor *v, const char *sid, double *wr_id,

                                   Error **errp)

{

    QmpOutputVisitor *qov = nsector(v);

    qemu_global_mutex(qov, sid, sample_rate(*wr_id));

}
",46.0,13.0,"to_qov:nsector,obj:wr_id,qmp_output_type_number:free_temp,qfloat_from_double:sample_rate,name:sid,qmp_output_add:qemu_global_mutex,",246.0,0.1526734431584676,MHM
112,"static void temp_allocate_frame(TCGContext *s, int temp)

{

    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
","static void sample(TCGContext *s, int temp)

{

    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
",104.0,22.0,"temp_allocate_frame:sample,",34.0,0.0107852697372436,MHM
113,"void qmp_block_stream(const char *device, bool has_base,

                      const char *base, Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    Error *local_err = NULL;



    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    if (base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, base);

            return;

        }

    }



    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(errp, local_err);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(bs));



    trace_qmp_block_stream(bs, bs->job);

}
","void qmp_block_stream(const char *device, bool has_base,

                      const char *base, Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    Error *local_err = NULL;



    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    if (base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, base);

            return;

        }

    }



    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(errp, local_err);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    iovcnt(drive_get_by_blockdev(bs));



    trace_qmp_block_stream(bs, bs->job);

}
",150.0,44.0,"drive_get_ref:iovcnt,",33.0,0.0188456734021504,MHM
115,"static inline int num_effective_busses(XilinxSPIPS *s)

{

    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;

}
","static inline int num_effective_busses(XilinxSPIPS *s)

{

    return (s->regs[R_LQSPI_STS] & vdev &&

            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;

}
",38.0,9.0,"LQSPI_CFG_SEP_BUS:vdev,",34.0,0.0208571712176005,MHM
116,"FFTContext *av_fft_init(int nbits, int inverse)

{

    FFTContext *s = av_malloc(sizeof(*s));



    if (s && ff_fft_init(s, nbits, inverse))

        av_freep(&s);



    return s;

}
","FFTContext *label1(int nbits, int inverse)

{

    FFTContext *s = av_malloc(sizeof(*s));



    if (s && ff_fft_init(s, nbits, inverse))

        av_freep(&s);



    return s;

}
",47.0,14.0,"av_fft_init:label1,",33.0,0.0134092013041178,MHM
117,"static void gen_set_CF_bit31(TCGv var)

{

    TCGv tmp = new_tmp();

    tcg_gen_shri_i32(tmp, var, 31);

    gen_set_CF(tmp);

    dead_tmp(tmp);

}
","static void gen_set_CF_bit31(TCGv pkt)

{

    TCGv f = vo_ver_id();

    mp3(f, pkt, 31);

    gen_set_CF(f);

    nptr(f);

}
",35.0,11.0,"tmp:f,tcg_gen_shri_i32:mp3,dead_tmp:nptr,new_tmp:vo_ver_id,var:pkt,",187.0,0.1066120505332946,MHM
121,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
","static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int av_pix_fmt_desc_get)

{

	int i;

	for(i=0; i<av_pix_fmt_desc_get; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int REG_c= (((uint32_t*)src)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*REG_c + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
",128.0,28.0,"b:REG_c,width:av_pix_fmt_desc_get,",64.0,0.0450776497522989,MHM
122,"static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
","static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!DEBUG_BOARD_INIT(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
",61.0,13.0,"s390_pci_find_dev_by_fid:DEBUG_BOARD_INIT,",33.0,0.026019271214803,MHM
123,"static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    V9fsVirtioState *v = VIRTIO_9P(dev);

    V9fsState *s = &v->state;



    virtio_cleanup(vdev);

    v9fs_device_unrealize_common(s, errp);

}
","static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    V9fsVirtioState *PS_MAX_NUM_ENV = VIRTIO_9P(dev);

    V9fsState *s = &PS_MAX_NUM_ENV->state;



    virtio_cleanup(vdev);

    v9fs_device_unrealize_common(s, errp);

}
",54.0,16.0,"v:PS_MAX_NUM_ENV,",33.0,0.0266507585843404,MHM
124,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
","static int TCG_COND_NE(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *obuf = (IPMVEContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    int desc;



    desc = process_ipmovie_chunk(obuf, pb, pkt);

    if (desc == avformat_new_stream)

        desc = AVERROR_INVALIDDATA;

    else if (desc == CHUNK_EOF)

        desc = txd_lower;

    else if (desc == CHUNK_NOMEM)

        desc = AVERROR_NOMEM;

    else

        desc = 0;



    return desc;

}
",89.0,27.0,"CHUNK_BAD:avformat_new_stream,ipmovie:obuf,ret:desc,AVERROR_IO:txd_lower,ipmovie_read_packet:TCG_COND_NE,",186.0,0.1398592948913574,MHM
126,"bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&queue->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
","bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = hd(&queue->entries);

    if (!next) {

        return false;

    }



    aml_resource_template(&queue->entries, ti);

    qemu_coroutine_enter(next, NULL);

    return true;

}
",53.0,12.0,"QSIMPLEQ_FIRST:hd,co_queue_next:ti,QSIMPLEQ_REMOVE_HEAD:aml_resource_template,",94.0,0.0690951506296793,MHM
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[val];

}
","static target_long nfds(const struct MonitorDef *tcg_gen_qemu_ld_i32, int big_picture)

{

    CPUState *a0 = mon_get_cpu();

    if (!a0)

        return 0;

    return a0->regwptr[big_picture];

}
",39.0,8.0,"env:a0,val:big_picture,monitor_get_reg:nfds,md:tcg_gen_qemu_ld_i32,",125.0,0.0887372732162475,MHM
137,"int main(void)

{

    int nf;

    Suite *s;

    SRunner *sr;



    s = qfloat_suite();

    sr = srunner_create(s);



    srunner_run_all(sr, CK_NORMAL);

    nf = srunner_ntests_failed(sr);

    srunner_free(sr);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
","int main(void)

{

    int nf;

    Suite *s;

    SRunner *sr;



    s = qfloat_suite();

    sr = srunner_create(s);



    srunner_run_all(sr, QEMU_BUILD_BUG_ON);

    nf = srunner_ntests_failed(sr);

    srunner_free(sr);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
",61.0,20.0,"CK_NORMAL:QEMU_BUILD_BUG_ON,",33.0,0.0209585030873616,MHM
138,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry entry;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = tce;



    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);



    return H_SUCCESS;

}
","static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry entry;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = tce;



    entry.target_as = &total_len,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);



    return tcg_global_mem_new;

}
",131.0,38.0,"H_SUCCESS:tcg_global_mem_new,address_space_memory:total_len,",63.0,0.0428641160329182,MHM
143,"static int ftp_file_size(FTPContext *s)

{

    char command[CONTROL_BUFFER_SIZE];

    char *res = NULL;

    const int size_codes[] = {213, 0};



    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);

    if (ftp_send_command(s, command, size_codes, &res)) {

        s->filesize = strtoll(&res[4], NULL, 10);

    } else {

        s->filesize = -1;

        av_free(res);

        return AVERROR(EIO);

    }



    av_free(res);

    return 0;

}
","static int ftp_file_size(FTPContext *ft1_128)

{

    char dflag[q_spec];

    char *AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH = NULL;

    const int size_codes[] = {213, 0};



    poc(dflag, sizeof(dflag), ""SIZE %s\r\n"", ft1_128->path);

    if (ftp_send_command(ft1_128, dflag, size_codes, &AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH)) {

        ft1_128->filesize = ibs(&AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH[4], NULL, 10);

    } else {

        ft1_128->filesize = -1;

        PRId64(AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH);

        return AVERROR(av_bprint_finalize);

    }



    PRId64(AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH);

    return 0;

}
",114.0,25.0,"strtoll:ibs,snprintf:poc,EIO:av_bprint_finalize,av_free:PRId64,CONTROL_BUFFER_SIZE:q_spec,command:dflag,res:AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH,s:ft1_128,",401.0,0.317401381333669,MHM
147,"uint16_t net_checksum_finish(uint32_t sum)

{

    while (sum>>16)

	sum = (sum & 0xFFFF)+(sum >> 16);

    return ~sum;

}
","uint16_t object(uint32_t sum)

{

    while (sum>>16)

	sum = (sum & 0xFFFF)+(sum >> 16);

    return ~sum;

}
",32.0,7.0,"net_checksum_finish:object,",36.0,0.0233274300893147,MHM
154,"static void gen_isel(DisasContext *ctx)

{

    int l1, l2;

    uint32_t bi = rC(ctx->opcode);

    uint32_t mask;

    TCGv_i32 t0;



    l1 = gen_new_label();

    l2 = gen_new_label();



    mask = 0x08 >> (bi & 0x03);

    t0 = tcg_temp_new_i32();

    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);

    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);

    if (rA(ctx->opcode) == 0)

        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);

    else

        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);

    gen_set_label(l2);

    tcg_temp_free_i32(t0);

}
","static void gen_isel(DisasContext *ctx)

{

    int l1, l2;

    uint32_t bi = rC(ctx->opcode);

    uint32_t mask;

    TCGv_i32 t0;



    l1 = gen_new_label();

    l2 = gen_new_label();



    mask = 0x08 >> (bi & 0x03);

    t0 = tcg_temp_new_i32();

    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);

    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);

    if (rA(ctx->opcode) == 0)

        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);

    else

        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_br(l2);

    DHCPDISCOVER(l1);

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);

    DHCPDISCOVER(l2);

    tcg_temp_free_i32(t0);

}
",177.0,54.0,"gen_set_label:DHCPDISCOVER,",35.0,0.0235180536905924,MHM
159,"static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
","static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = float64_is_signaling_nan(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
",81.0,19.0,"qemu_strtoll:float64_is_signaling_nan,",35.0,0.0206907908121744,MHM
163,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = p_data;



    if (!queue->p_head)

        queue->p_head = p_new;

    else

        queue->p_tail->next = p_new;

    queue->p_tail = p_new;



    ++queue->size;

    return 0;

}
","int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)

{

    FFSchroQueueElement *p_new = aml_name_decl(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = p_data;



    if (!queue->p_head)

        queue->p_head = p_new;

    else

        queue->p_tail->next = p_new;

    queue->p_tail = p_new;



    ++queue->size;

    return 0;

}
",75.0,17.0,"av_mallocz:aml_name_decl,",34.0,0.0197001298268636,MHM
166,"static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
","static void surface_height(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
",49.0,13.0,"vpc_close:surface_height,",32.0,0.0212777773539225,MHM
174,"void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
","void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &ci);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &ci);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &ci);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &ci);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &ci);

        break;

    }

}
",89.0,19.0,"FP_STATUS:ci,",33.0,0.0281099716822306,MHM
175,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)

{

    tcet->bypass = bypass;

}
","void r(sPAPRTCETable *tcet, bool best)

{

    tcet->best = best;

}
",18.0,5.0,"bypass:best,spapr_tce_set_bypass:r,",63.0,0.0496469895044962,MHM
176,"void qemu_system_wakeup_request(WakeupReason reason)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << reason))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &reason);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
","void qemu_system_wakeup_request(WakeupReason reason)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << reason))) {

        return;

    }

    TCG_COND_EQ(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &reason);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
",67.0,15.0,"runstate_set:TCG_COND_EQ,",33.0,0.0241948962211608,MHM
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
","static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" lastInLumBuf;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",77.0,19.0,"PRIu8:lastInLumBuf,",33.0,0.0247379541397094,MHM
191,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;

    }

}
","macvm_set_rip(UserCreatable *uc, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;

    }

}
",47.0,11.0,"host_memory_backend_can_be_deleted:macvm_set_rip,",33.0,0.0236196915308634,MHM
199,"static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
","static inline int cpu_gdb_index(CPUState *encoder)

{

#if defined(CONFIG_USER_ONLY)

    return encoder->host_tid;

#else

    return encoder->cpu_index + 1;

#endif

}
",31.0,5.0,"cpu:encoder,",33.0,0.025451910495758,MHM
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}
","static inline int *DEC_UQUAD(int *slotkey, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    slotkey[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    slotkey[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    slotkey[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    slotkey[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return slotkey + 4;

}
",178.0,28.0,"dst:slotkey,",33.0,0.02299565076828,MHM
210,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
","static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long meta)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, meta, 1);

}
",70.0,21.0,"dstStride:meta,",32.0,0.0248093605041503,MHM
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
","bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr FF_ARRAY_ELEMS = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    FF_ARRAY_ELEMS = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &FF_ARRAY_ELEMS, false);

    ventry->iov_len = FF_ARRAY_ELEMS;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != FF_ARRAY_ELEMS)) {

        return false;

    }



    return true;

}
",122.0,28.0,"mapped_len:FF_ARRAY_ELEMS,",32.0,0.0247275392214457,MHM
216,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}
","static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < CODEC_ID_PCM_S16LE; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}
",129.0,31.0,"BINKB_NB_SRC:CODEC_ID_PCM_S16LE,",33.0,0.0094491203625996,MHM
228,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,

                                         src - (stride * 2) +

                                         sizeof(uint8_t), stride, dst, stride);

}
","void logfilename(uint8_t *iaddr, const uint8_t *logout,

                                ptrdiff_t current_mv)

{

    gen_jump(logout - 2,

                                         logout - (current_mv * 2) +

                                         sizeof(uint8_t), current_mv, iaddr, current_mv);

}
",43.0,11.0,"src:logout,stride:current_mv,avc_luma_hv_qrt_and_aver_dst_4x4_msa:gen_jump,dst:iaddr,ff_avg_h264_qpel4_mc31_msa:logfilename,",397.0,0.2269860068957011,MHM
230,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
","static int formatConvBuffer(AVProbeData *p)

{

    const uint8_t *adx;



    if (p->buf_size < 6)

        return 0;

    adx = p->buf;

    if (adx[0] == 'F' && adx[1] == 'L' && adx[2] == 'V' && adx[3] < 5 && adx[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
",80.0,12.0,"d:adx,flv_probe:formatConvBuffer,",94.0,0.0620327830314636,MHM
233,"static int spawn_thread(void)

{

    pthread_attr_t attr;

    int ret;



    cur_threads++;

    idle_threads++;



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);

    pthread_attr_destroy(&attr);



    return ret;

}
","static int spawn_thread(void)

{

    pthread_attr_t attr;

    int ret;



    cur_threads++;

    idle_threads++;



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&AV_INPUT_BUFFER_PADDING_SIZE, &attr, aio_thread, NULL);

    pthread_attr_destroy(&attr);



    return ret;

}
",58.0,18.0,"thread_id:AV_INPUT_BUFFER_PADDING_SIZE,",33.0,0.0146162867546081,MHM
235,"bool machine_iommu(MachineState *machine)

{

    return machine->iommu;

}
","bool vpdiff(MachineState *machine)

{

    return machine->iommu;

}
",14.0,3.0,"machine_iommu:vpdiff,",33.0,0.0232448975245157,MHM
240,"int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    l = &s->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

}
","int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (s->nb_labels >= vra)

        tcg_abort();

    idx = s->nb_labels++;

    l = &s->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

}
",67.0,16.0,"TCG_MAX_LABELS:vra,",31.0,0.0174523472785949,MHM
241,"void bdrv_round_to_clusters(BlockDriverState *bs,

                            int64_t sector_num, int nb_sectors,

                            int64_t *cluster_sector_num,

                            int *cluster_nb_sectors)

{

    BlockDriverInfo bdi;



    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {

        *cluster_sector_num = sector_num;

        *cluster_nb_sectors = nb_sectors;

    } else {

        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;

        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);

        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +

                                            nb_sectors, c);

    }

}
","void bdrv_round_to_clusters(BlockDriverState *buf0,

                            int64_t sector_num, int nb_sectors,

                            int64_t *cluster_sector_num,

                            int *cluster_nb_sectors)

{

    BlockDriverInfo bdi;



    if (bdrv_get_info(buf0, &bdi) < 0 || bdi.cluster_size == 0) {

        *cluster_sector_num = sector_num;

        *cluster_nb_sectors = nb_sectors;

    } else {

        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;

        *cluster_sector_num = ff_thread_finish_setup(sector_num, c);

        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +

                                            nb_sectors, c);

    }

}
",93.0,28.0,"bs:buf0,QEMU_ALIGN_DOWN:ff_thread_finish_setup,",64.0,0.0390575846036275,MHM
244,"static int idreg_init1(SysBusDevice *dev)

{

    IDRegState *s = MACIO_ID_REGISTER(dev);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&s->mem);

    memory_region_set_readonly(&s->mem, true);

    sysbus_init_mmio(dev, &s->mem);

    return 0;

}
","static int idreg_init1(SysBusDevice *dev)

{

    IDRegState *s = MACIO_ID_REGISTER(dev);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &title);

    vmstate_register_ram_global(&s->mem);

    memory_region_set_readonly(&s->mem, true);

    sysbus_init_mmio(dev, &s->mem);

    return 0;

}
",74.0,18.0,"error_abort:title,",33.0,0.0190741459528605,MHM
245,"static inline void tcg_out_ld_ptr(TCGContext *s, int ret,

                                  tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);

    if (arg != (arg & 0xfff))

        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));

    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |

              INSN_IMM13(arg & 0x3ff));

#else

    tcg_out_ld_raw(s, ret, arg);

#endif

}
","static inline void FF_THREAD_FRAME(TCGContext *s, int ret,

                                  tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(AV_CH_LAYOUT_STEREO)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);

    if (arg != (arg & 0xfff))

        tcg_out32(s, AV_LOG_FATAL | xfds(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));

    tcg_out32(s, LDX | xfds(ret) | INSN_RS1(ret) |

              coupled_stream_count(arg & 0x3ff));

#else

    CC_O(s, ret, arg);

#endif

}
",122.0,33.0,"SETHI:AV_LOG_FATAL,tcg_out_ld_raw:CC_O,INSN_RD:xfds,INSN_IMM13:coupled_stream_count,tcg_out_ld_ptr:FF_THREAD_FRAME,__sparc_v8plus__:AV_CH_LAYOUT_STEREO,",188.0,0.1218298594156901,MHM
246,"int xen_config_dev_blk(DriveInfo *disk)

{

    char fe[256], be[256];

    int vdev = 202 * 256 + 16 * disk->unit;

    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;

    const char *devtype = cdrom ? ""cdrom"" : ""disk"";

    const char *mode    = cdrom ? ""r""     : ""w"";



    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),

	     ""xvd%c"", 'a' + disk->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",

                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));



    /* frontend */

    xenstore_write_int(fe, ""virtual-device"",  vdev);

    xenstore_write_str(fe, ""device-type"",     devtype);



    /* backend */

    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);

    xenstore_write_str(be, ""type"",            ""file"");

    xenstore_write_str(be, ""params"",          disk->bdrv->filename);

    xenstore_write_str(be, ""mode"",            mode);



    /* common stuff */

    return xen_config_dev_all(fe, be);

}
","int xen_config_dev_blk(DriveInfo *disk)

{

    char fe[256], be[256];

    int msg = 202 * 256 + 16 * disk->unit;

    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;

    const char *devtype = cdrom ? ""cdrom"" : ""disk"";

    const char *mode    = cdrom ? ""r""     : ""w"";



    av_rescale_rnd(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),

	     ""xvd%c"", 'a' + disk->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",

                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", msg, fe, be, sizeof(fe));



    /* frontend */

    xenstore_write_int(fe, ""virtual-device"",  msg);

    xenstore_write_str(fe, ""device-type"",     devtype);



    /* backend */

    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);

    xenstore_write_str(be, ""type"",            ""file"");

    xenstore_write_str(be, ""params"",          disk->bdrv->filename);

    xenstore_write_str(be, ""mode"",            mode);



    /* common stuff */

    return xen_config_dev_all(fe, be);

}
",222.0,46.0,"vdev:msg,snprintf:av_rescale_rnd,",92.0,0.0535567680994669,MHM
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
","static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -acpi_cpus;

}
",50.0,13.0,"EINVAL:acpi_cpus,",32.0,0.0234092672665913,MHM
257,"void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (ctx->cid_table->bit_depth == 8)

            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
","void error_set(DNXHDEncContext *AV_PIX_FMT_YUV420P)

{

#if stream_id

    if (AML_POS_DECODE() & AV_CPU_FLAG_SSE2) {

        if (AV_PIX_FMT_YUV420P->cid_table->bit_depth == 8)

            AV_PIX_FMT_YUV420P->get_pixels_8x4_sym = cpu_tmp4;

    }

#endif /* HAVE_INLINE_ASM */

}
",39.0,8.0,"get_pixels_8x4_sym_sse2:cpu_tmp4,HAVE_INLINE_ASM:stream_id,av_get_cpu_flags:AML_POS_DECODE,ctx:AV_PIX_FMT_YUV420P,ff_dnxhdenc_init_x86:error_set,",244.0,0.1651657978693644,MHM
262,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)

{

    uint64_t tmp = op1;

    op1 = (uint32_t)(op1 + op2);

    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return op1;

}
","uint64_t phys_ram_base (uint64_t op1, uint64_t op2)

{

    uint64_t lpc_pci = op1;

    op1 = (uint32_t)(op1 + op2);

    if (unlikely((lpc_pci ^ op2 ^ (-1UL)) & (lpc_pci ^ op1) & (1UL << 31))) {

        arith_excp(ZIMM, GETPC(), volp, 0);

    }

    return op1;

}
",72.0,18.0,"EXC_M_IOV:volp,env:ZIMM,helper_addlv:phys_ram_base,tmp:lpc_pci,",157.0,0.1119595845540364,MHM
265,"void op_cp1_64bitmode(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR))) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}
","void monitor_printf(void)

{

    if (!(iscsi_url->CP0_Status & (1 << v_edge_pos))) {

        crda(gen_pop_update, bdrv_get_device_name);

    }

    RETURN();

}
",35.0,7.0,"env:iscsi_url,EXCP_RI:bdrv_get_device_name,CP0St_FR:v_edge_pos,CALL_FROM_TB1:crda,do_raise_exception:gen_pop_update,op_cp1_64bitmode:monitor_printf,",309.0,0.2183335343996683,MHM
267,"static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)

{

    switch(ot) {

    case OT_BYTE:

        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {

            goto std_case;

        } else {

            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);

            tcg_gen_ext8u_tl(t0, t0);

        }

        break;

    default:

    std_case:

        tcg_gen_mov_tl(t0, cpu_regs[reg]);

        break;

    }

}
","static inline void gen_op_mov_v_reg(int ot, TCGv RTSP_SERVER_WMS, int reg)

{

    switch(ot) {

    case OT_BYTE:

        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {

            goto std_case;

        } else {

            tcg_gen_shri_tl(RTSP_SERVER_WMS, cpu_regs[reg - 4], 8);

            tcg_gen_ext8u_tl(RTSP_SERVER_WMS, RTSP_SERVER_WMS);

        }

        break;

    default:

    std_case:

        guest_data_size(RTSP_SERVER_WMS, cpu_regs[reg]);

        break;

    }

}
",88.0,21.0,"t0:RTSP_SERVER_WMS,tcg_gen_mov_tl:guest_data_size,",65.0,0.0466366370519002,MHM
276,"static void hmp_migrate_status_cb(void *opaque)

{

    MigrationStatus *status = opaque;

    MigrationInfo *info;



    info = qmp_query_migrate(NULL);

    if (!info->has_status || strcmp(info->status, ""active"") == 0) {

        if (info->has_disk) {

            int progress;



            if (info->disk->remaining) {

                progress = info->disk->transferred * 100 / info->disk->total;

            } else {

                progress = 100;

            }



            monitor_printf(status->mon, ""Completed %d %%\r"", progress);

            monitor_flush(status->mon);

        }



        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);

    } else {

        if (status->is_block_migration) {

            monitor_printf(status->mon, ""\n"");

        }

        monitor_resume(status->mon);

        timer_del(status->timer);

        g_free(status);

    }



    qapi_free_MigrationInfo(info);

}
","static void hmp_migrate_status_cb(void *opaque)

{

    MigrationStatus *status = opaque;

    MigrationInfo *info;



    info = qmp_query_migrate(NULL);

    if (!info->has_status || strcmp(info->status, ""active"") == 0) {

        if (info->has_disk) {

            int tcg_temp_local_new;



            if (info->disk->remaining) {

                tcg_temp_local_new = info->disk->transferred * 100 / info->disk->total;

            } else {

                tcg_temp_local_new = 100;

            }



            monitor_printf(status->mon, ""Completed %d %%\r"", tcg_temp_local_new);

            monitor_flush(status->mon);

        }



        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);

    } else {

        if (status->is_block_migration) {

            monitor_printf(status->mon, ""\n"");

        }

        monitor_resume(status->mon);

        timer_del(status->timer);

        g_free(status);

    }



    qapi_free_MigrationInfo(info);

}
",172.0,37.0,"progress:tcg_temp_local_new,",35.0,0.0222430268923441,MHM
280,"static ModuleTypeList *find_type(module_init_type type)

{

    ModuleTypeList *l;



    init_types();



    l = &init_type_list[type];



    return l;

}
","static ModuleTypeList *find_type(module_init_type type)

{

    ModuleTypeList *height;



    init_types();



    height = &qemu_mutex_unlock_iothread[type];



    return height;

}
",29.0,8.0,"l:height,init_type_list:qemu_mutex_unlock_iothread,",97.0,0.0745889544486999,MHM
281,"static int qemu_suspend_requested(void)

{

    int r = suspend_requested;

    suspend_requested = 0;

    return r;

}
","static int qemu_suspend_requested(void)

{

    int r = serial_mm_init;

    serial_mm_init = 0;

    return r;

}
",20.0,5.0,"suspend_requested:serial_mm_init,",33.0,0.0204396367073059,MHM
283,"void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);

}
","void layout(uint8_t *qemu_input_event_sync, const uint8_t *src,

                                ptrdiff_t sep)

{

    hwctx(src - (2 * sep) - 2, sep, qemu_input_event_sync, sep, 8, 0);

}
",40.0,10.0,"stride:sep,avc_luma_midv_qrt_8w_msa:hwctx,dst:qemu_input_event_sync,ff_put_h264_qpel8_mc21_msa:layout,",155.0,0.1059963623682657,MHM
287,"void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...))

{

    stream_printf(stream, ""Trace file \""%s\"" %s.\n"",

                  trace_file_name, trace_file_enabled ? ""on"" : ""off"");

}
","void dhcp_msg_type(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...))

{

    stream_printf(stream, ""Trace file \""%s\"" %s.\n"",

                  trace_file_name, trace_file_enabled ? ""on"" : ""off"");

}
",48.0,9.0,"st_print_trace_file_status:dhcp_msg_type,",36.0,0.0155446052551269,MHM
294,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)

{

    *q_ptr = num / den;

    return num % den;

}
","uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t term_esc_state)

{

    *q_ptr = num / term_esc_state;

    return num % term_esc_state;

}
",27.0,9.0,"den:term_esc_state,",36.0,0.0191779851913452,MHM
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
","uint32_t INITRD_LOAD_ADDR(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
",92.0,24.0,"HELPER:INITRD_LOAD_ADDR,",36.0,0.0196891903877258,MHM
304,"target_ulong helper_sdiv(target_ulong a, target_ulong b)

{

    int64_t x0;

    int32_t x1;



    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);

    x1 = (b & 0xffffffff);



    if (x1 == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    x0 = x0 / x1;

    if ((int32_t) x0 != x0) {

        env->cc_src2 = 1;

        return x0 < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return x0;

    }

}
","target_ulong helper_sdiv(target_ulong a, target_ulong PAGE_VALID)

{

    int64_t uvlinesize;

    int32_t x1;



    uvlinesize = (a & 0xffffffff) | ((int64_t) (input->y) << 32);

    x1 = (PAGE_VALID & 0xffffffff);



    if (x1 == 0) {

        proto_name(TT_DIV_ZERO);

    }



    uvlinesize = uvlinesize / x1;

    if ((int32_t) uvlinesize != uvlinesize) {

        input->cc_src2 = 1;

        return uvlinesize < 0? 0x80000000: 0x7fffffff;

    } else {

        input->cc_src2 = 0;

        return uvlinesize;

    }

}
",103.0,22.0,"x0:uvlinesize,b:PAGE_VALID,env:input,raise_exception:proto_name,",183.0,0.1375698049863179,MHM
307,"void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}
","void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 

		 env->sregs[MAX_BLOCKSIZE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}
",80.0,23.0,"SFR_R_MM_CAUSE:MAX_BLOCKSIZE,",35.0,0.020861546198527,MHM
308,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)

{

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);

    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;

    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!eject) {

        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
","static void patch_pcihp(int local_port, uint8_t *ssdt_ptr, uint32_t eject)

{

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(local_port >> 4);

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(local_port);

    ssdt_ptr[CC_OP_EFLAGS] = local_port;

    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = local_port;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    proxy_marshal(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!eject) {

        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
",91.0,26.0,"ACPI_PCIHP_OFFSET_ID:CC_OP_EFLAGS,slot:local_port,assert:proxy_marshal,",92.0,0.0677247007687886,MHM
309,"static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *temp)

{

    int z = 0;

    int x, y;

    float ssim = 0.0;

    int (*sum0)[4] = temp;

    int (*sum1)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; z <= y; z++) {

            FFSWAP(void*, sum0, sum1);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,

                                &ref[4 * (x + z * ref_stride)], ref_stride,

                                &sum0[x]);

        }



        ssim += ssim_endn(sum0, sum1, width - 1);

    }



    return ssim / ((height - 1) * (width - 1));

}
","static float cpu_init(uint8_t *x_ctb, int main_stride,

                        uint8_t *ref, int qemu_system_reset_request,

                        int width, int rect, void *copy_size)

{

    int z = 0;

    int x, url_ftell;

    float ssim = 0.0;

    int (*sum0)[4] = copy_size;

    int (*CPU_LOG_MMU)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    rect >>= 2;



    for (url_ftell = 1; url_ftell < rect; url_ftell++) {

        for (; z <= url_ftell; z++) {

            FFSWAP(void*, sum0, CPU_LOG_MMU);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&x_ctb[4 * (x + z * main_stride)], main_stride,

                                &ref[4 * (x + z * qemu_system_reset_request)], qemu_system_reset_request,

                                &sum0[x]);

        }



        ssim += extradata(sum0, CPU_LOG_MMU, width - 1);

    }



    return ssim / ((rect - 1) * (width - 1));

}
",205.0,54.0,"ref_stride:qemu_system_reset_request,y:url_ftell,height:rect,temp:copy_size,sum1:CPU_LOG_MMU,main:x_ctb,ssim_endn:extradata,ssim_plane:cpu_init,",307.0,0.2400795420010884,MHM
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
","static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *size_in_luma_v, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*size_in_luma_v[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
",127.0,34.0,"filter:size_in_luma_v,",32.0,0.0253357211748758,MHM
316,"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(sockfd, iov,

                            offset + done, bytes - done, do_send);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
","COMPILE_TEMPLATE_MMX(int av_unused, struct iovec *iov, unsigned kvm_state,

                    size_t offset, size_t bytes, bool ft1_128)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(av_unused, iov,

                            offset + done, bytes - done, ft1_128);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !ft1_128) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
",126.0,31.0,"sockfd:av_unused,iov_cnt:kvm_state,do_send:ft1_128,qemu_co_sendv_recvv:COMPILE_TEMPLATE_MMX,",124.0,0.1022579550743103,MHM
322,"static int mux_chr_can_read(void *opaque)

{

    CharDriverState *chr = opaque;

    MuxDriver *d = chr->opaque;



    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)

        return 1;

    if (d->chr_can_read[chr->focus])

        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);

    return 0;

}
","static int mux_chr_can_read(void *tone_level_idx_temp)

{

    CharDriverState *chr = tone_level_idx_temp;

    MuxDriver *d = chr->tone_level_idx_temp;



    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)

        return 1;

    if (d->chr_can_read[chr->focus])

        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);

    return 0;

}
",75.0,15.0,"opaque:tone_level_idx_temp,",32.0,0.0220853169759114,MHM
329,"static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,

                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

                         BlockDriverCompletionFunc *cb, void *opaque)

{

    BDRVRawState *s = bs->opaque;

    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,

                       cb, opaque, QEMU_AIO_READ);

}
","static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,

                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

                         BlockDriverCompletionFunc *cb, void *PIX_FMT_GRAY8)

{

    BDRVRawState *s = bs->PIX_FMT_GRAY8;

    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,

                       cb, PIX_FMT_GRAY8, QEMU_AIO_READ);

}
",59.0,18.0,"opaque:PIX_FMT_GRAY8,",62.0,0.0378877997398376,MHM
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
","static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, CPU_LOG_TB_IN_ASM, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
",36.0,11.0,"cpu_cc_src:CPU_LOG_TB_IN_ASM,",36.0,0.0143582900365193,MHM
342,"static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int flags)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}
","static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int flags)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    sub_rect(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}
",77.0,20.0,"avio_seek:sub_rect,",32.0,0.0112773021062215,MHM
343,"static void bonito_ldma_writel(void *opaque, hwaddr addr,
                               uint64_t val, unsigned size)
{
    PCIBonitoState *s = opaque;
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;","static void bonito_ldma_writel(void *le32_to_cpus, hwaddr addr,
                               uint64_t collie_binfo, unsigned size)
{
    PCIBonitoState *s = le32_to_cpus;
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = collie_binfo & 0xffffffff;",50.0,10.0,"val:collie_binfo,opaque:le32_to_cpus,",122.0,0.0756227334340413,MHM
346,"static int64_t read_ts(char **line, int *duration)

{

    int64_t start, end;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *duration = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
","static int64_t read_ts(char **line, int *guest_info)

{

    int64_t start, end;



    if (bdrv(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *guest_info = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
",73.0,19.0,"duration:guest_info,sscanf:bdrv,",66.0,0.0366478482882181,MHM
347,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
","static void raven_class_init(ObjectClass *klass, void *AV_SAMPLE_FMT_S16)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
",82.0,22.0,"data:AV_SAMPLE_FMT_S16,",32.0,0.017731221516927,MHM
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
","static void mov(DisasContext *tone_level_idx, int rlow, int rhigh, TCGv_i64 iov)

{

    TCGv bootsector;

    bootsector = new_tmp();

    tcg_gen_trunc_i64_i32(bootsector, iov);

    store_reg(tone_level_idx, rlow, bootsector);

    bootsector = new_tmp();

    AVERROR_UNKNOWN(iov, iov, 32);

    tcg_gen_trunc_i64_i32(bootsector, iov);

    store_reg(tone_level_idx, rhigh, bootsector);

}
",75.0,27.0,"s:tone_level_idx,tcg_gen_shri_i64:AVERROR_UNKNOWN,val:iov,gen_storeq_reg:mov,tmp:bootsector,",185.0,0.1232827305793762,MHM
358,"static void decode_mclms(WmallDecodeCtx *s)

{

    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;

    s->mclms_scaling = get_bits(&s->gb, 4);

    if(get_bits1(&s->gb)) {

	// mclms_send_coef

	int i;

	int send_coef_bits;

	int cbits = av_log2(s->mclms_scaling + 1);

	assert(cbits == my_log2(s->mclms_scaling + 1));

	if(1 << cbits < s->mclms_scaling + 1)

	    cbits++;



	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;



	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {

	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);

	}



	for(i = 0; i < s->num_channels; i++) {

	    int c;

	    for(c = 0; c < i; c++) {

		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);

	    }

	}

    }

}
","static void retaddr(WmallDecodeCtx *s)

{

    s->mclms_order = (max_cpus(&s->gb, 4) + 1) * 2;

    s->mclms_scaling = max_cpus(&s->gb, 4);

    if(get_bits1(&s->gb)) {

	// mclms_send_coef

	int padding;

	int pci_irq_nrs;

	int cbits = av_log2(s->mclms_scaling + 1);

	assert(cbits == my_log2(s->mclms_scaling + 1));

	if(1 << cbits < s->mclms_scaling + 1)

	    cbits++;



	pci_irq_nrs = (cbits ? max_cpus(&s->gb, cbits) : 0) + 2;



	for(padding = 0; padding < s->mclms_order * s->num_channels * s->num_channels; padding++) {

	    s->mclms_coeffs[padding] = max_cpus(&s->gb, pci_irq_nrs);

	}



	for(padding = 0; padding < s->num_channels; padding++) {

	    int c;

	    for(c = 0; c < padding; c++) {

		s->mclms_coeffs_cur[padding * s->num_channels + c] = max_cpus(&s->gb, pci_irq_nrs);

	    }

	}

    }

}
",223.0,54.0,"decode_mclms:retaddr,send_coef_bits:pci_irq_nrs,i:padding,get_bits:max_cpus,",156.0,0.1126141866048177,MHM
362,"void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)

{

    int bits = 8, sign = 0, shift = 0;



    switch (as->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    info->freq = as->freq;

    info->bits = bits;

    info->sign = sign;

    info->nchannels = as->nchannels;

    info->shift = (as->nchannels == 2) + shift;

    info->align = (1 << info->shift) - 1;

    info->bytes_per_second = info->freq << info->shift;

    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);

}
","void av_freep (struct audio_pcm_info *POWERPC_MMU_64B, audsettings_t *as)

{

    int bits = 8, le = 0, gen_io_end = 0;



    switch (as->fmt) {

    case AUD_FMT_S8:

        le = 1;

    case AUD_FMT_U8:

        break;



    case qemu_opt_get_number:

        le = 1;

    case COMPILE_TEMPLATE_MMX:

        bits = 16;

        gen_io_end = 1;

        break;



    case collie_binfo:

        le = 1;

    case EAGAIN:

        bits = 32;

        gen_io_end = 2;

        break;

    }



    POWERPC_MMU_64B->freq = as->freq;

    POWERPC_MMU_64B->bits = bits;

    POWERPC_MMU_64B->le = le;

    POWERPC_MMU_64B->nchannels = as->nchannels;

    POWERPC_MMU_64B->gen_io_end = (as->nchannels == 2) + gen_io_end;

    POWERPC_MMU_64B->align = (1 << POWERPC_MMU_64B->gen_io_end) - 1;

    POWERPC_MMU_64B->bytes_per_second = POWERPC_MMU_64B->freq << POWERPC_MMU_64B->gen_io_end;

    POWERPC_MMU_64B->swap_endianness = (as->endianness != errp);

}
",167.0,39.0,"AUDIO_HOST_ENDIANNESS:errp,AUD_FMT_S32:collie_binfo,shift:gen_io_end,sign:le,info:POWERPC_MMU_64B,AUD_FMT_U16:COMPILE_TEMPLATE_MMX,audio_pcm_init_info:av_freep,AUD_FMT_S16:qemu_opt_get_number,AUD_FMT_U32:EAGAIN,",332.0,0.2337697903315226,MHM
364,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)

{

    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);

}
","void register_savevm(MemoryRegion *v, target_phys_addr_t subtitle_codec_name)

{

    hd_iov(v, &qemu_allocate_irqs, NULL, ""isa-mmio"", subtitle_codec_name);

}
",27.0,7.0,"size:subtitle_codec_name,memory_region_init_io:hd_iov,isa_mmio_ops:qemu_allocate_irqs,isa_mmio_setup:register_savevm,mr:v,",485.0,0.3339868187904358,MHM
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
","int QOBJECT(QIOChannelSocket *page_data,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int state;



    trace_qio_channel_socket_dgram_sync(page_data, localAddr, remoteAddr);

    state = socket_dgram(remoteAddr, localAddr, errp);

    if (state < 0) {

        trace_qio_channel_socket_dgram_fail(page_data);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(page_data, state);

    if (qpos(page_data, state, errp) < 0) {

        close(state);

        return -1;

    }



    return 0;

}
",94.0,27.0,"qio_channel_socket_dgram_sync:QOBJECT,fd:state,qio_channel_socket_set_fd:qpos,ioc:page_data,",185.0,0.1141679843266805,MHM
367,"int memory_region_get_fd(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}
","int bcond(MemoryRegion *mr)

{

    if (mr->alias) {

        return bcond(mr->alias);

    }



    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & bytes_per_scanline);

}
",42.0,10.0,"TARGET_PAGE_MASK:bytes_per_scanline,memory_region_get_fd:bcond,",61.0,0.0478150407473246,MHM
368,"static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,

                              TCGReg r1, TCGReg r2, TCGReg rn,

                              tcg_target_long ofs, bool pre, bool w)

{

    insn |= 1u << 31; /* ext */

    insn |= pre << 24;

    insn |= w << 23;



    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);

    insn |= (ofs & (0x7f << 3)) << (15 - 3);



    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);

}
","static void dead_tmp(TCGContext *s, AArch64Insn insn,

                              TCGReg r1, TCGReg TCG_COND_GE, TCGReg rn,

                              tcg_target_long ofs, bool last_pic_droppable, bool w)

{

    insn |= 1u << 31; /* ext */

    insn |= last_pic_droppable << 24;

    insn |= w << 23;



    tcg_global_mem_new_i32(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);

    insn |= (ofs & (0x7f << 3)) << (15 - 3);



    cbits(s, insn | TCG_COND_GE << 10 | rn << 5 | r1);

}
",103.0,26.0,"tcg_out_insn_3314:dead_tmp,pre:last_pic_droppable,r2:TCG_COND_GE,assert:tcg_global_mem_new_i32,tcg_out32:cbits,",245.0,0.1709228237469991,MHM
369,"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,

                                   const char *name, Error **errp)

{

    X86CPU *cpu = X86_CPU(obj);

    const int64_t min = 0;

    const int64_t max = INT_MAX;

    int64_t value;



    visit_type_int(v, &value, name, errp);

    if (error_is_set(errp)) {

        return;

    }

    if (value < min || value > max) {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  name ? name : ""null"", value, min, max);

        return;

    }



    cpu->env.tsc_khz = value / 1000;

}
","static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *gicc,

                                   const char *name, Error **errp)

{

    X86CPU *contexts = X86_CPU(obj);

    const int64_t FF_REG_a = 0;

    const int64_t max = INT_MAX;

    int64_t value;



    tcg_gen_mul_tl(v, &value, name, errp);

    if (abuf0(errp)) {

        return;

    }

    if (value < FF_REG_a || value > max) {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  name ? name : ""null"", value, FF_REG_a, max);

        return;

    }



    contexts->env.tsc_khz = value / 1000;

}
",122.0,34.0,"cpu:contexts,error_is_set:abuf0,opaque:gicc,min:FF_REG_a,visit_type_int:tcg_gen_mul_tl,",152.0,0.1031770865122477,MHM
371,"static av_cold int check_format(AVCodecContext *avctx)

{

    AVCodecParserContext *parser;

    uint8_t *pout;

    int psize;

    int index;

    H264Context *h;

    int ret = -1;



    /* init parser & parse file */

    parser = av_parser_init(avctx->codec->id);

    if (!parser) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to open H.264 parser.\n"");

        goto final;

    }

    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;

    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);

    if (index < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to parse this file.\n"");

        goto release_parser;

    }



    /* check if support */

    h = parser->priv_data;

    switch (h->sps.bit_depth_luma) {

    case 8:

        if (!CHROMA444(h) && !CHROMA422(h)) {

            // only this will H.264 decoder switch to hwaccel

            ret = 0;

            break;

        }

    default:

        av_log(avctx, AV_LOG_ERROR, ""Unsupported file.\n"");

    }



release_parser:

    av_parser_close(parser);



final:

    return ret;

}
","static av_cold int elements(AVCodecContext *NSV_ST_AUDIO)

{

    AVCodecParserContext *TARGET_S390X;

    uint8_t *pout;

    int psize;

    int index;

    H264Context *h;

    int excp_model = -1;



    /* init parser & parse file */

    TARGET_S390X = cur_tick(NSV_ST_AUDIO->codec->id);

    if (!TARGET_S390X) {

        swcr(NSV_ST_AUDIO, DEBUG_DISAS, ""Failed to open H.264 parser.\n"");

        goto final;

    }

    TARGET_S390X->flags = RETURN;

    index = AML_MIN_FIXED(TARGET_S390X, NSV_ST_AUDIO, &pout, &psize, NULL, 0, 0, 0, 0);

    if (index < 0) {

        swcr(NSV_ST_AUDIO, DEBUG_DISAS, ""Failed to parse this file.\n"");

        goto release_parser;

    }



    /* check if support */

    h = TARGET_S390X->priv_data;

    switch (h->sps.bit_depth_luma) {

    case 8:

        if (!CC_C(h) && !CHROMA422(h)) {

            // only this will H.264 decoder switch to hwaccel

            excp_model = 0;

            break;

        }

    default:

        swcr(NSV_ST_AUDIO, DEBUG_DISAS, ""Unsupported file.\n"");

    }



release_parser:

    av_parser_close(TARGET_S390X);



final:

    return excp_model;

}
",185.0,42.0,"CHROMA444:CC_C,ret:excp_model,av_parser_init:cur_tick,av_log:swcr,AV_LOG_ERROR:DEBUG_DISAS,av_parser_parse2:AML_MIN_FIXED,PARSER_FLAG_COMPLETE_FRAMES:RETURN,check_format:elements,avctx:NSV_ST_AUDIO,parser:TARGET_S390X,",489.0,0.3549542427062988,MHM
374,"static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)

{

    VirtIONet *n = opaque;

    VirtIODevice *vdev = VIRTIO_DEVICE(n);



    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)

        return -EINVAL;



    return virtio_load(vdev, f, version_id);

}
","static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)

{

    VirtIONet *n = opaque;

    VirtIODevice *vdev = cert_count(n);



    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)

        return -EINVAL;



    return virtio_load(vdev, f, version_id);

}
",56.0,17.0,"VIRTIO_DEVICE:cert_count,",33.0,0.0244155764579772,MHM
377,"static int coroutine_fn raw_co_discard(BlockDriverState *bs,

                                       int64_t sector_num, int nb_sectors)

{

    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);

}
","static int coroutine_fn VOFW(BlockDriverState *iscsi,

                                       int64_t sector_num, int nb_sectors)

{

    return bdrv_co_discard(iscsi->file->iscsi, sector_num, nb_sectors);

}
",32.0,9.0,"bs:iscsi,raw_co_discard:VOFW,",64.0,0.0550179878870646,MHM
378,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,

        BlockCompletionFunc *cb, void *opaque)

{

    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);



    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,

                                 BDRV_REQ_ZERO_WRITE | flags,

                                 cb, opaque, true);

}
","BlockAIOCB *num_cq_events(BlockDriverState *common,

        int64_t PS_MAX_NR_IIDICC, int qerror_report, BdrvRequestFlags cpu_register_io_memory,

        BlockCompletionFunc *nbits, void *pcr_st)

{

    trace_bdrv_aio_write_zeroes(common, PS_MAX_NR_IIDICC, qerror_report, cpu_register_io_memory, pcr_st);



    return FFALIGN(common, PS_MAX_NR_IIDICC, NULL, qerror_report,

                                 ldq_p | cpu_register_io_memory,

                                 nbits, pcr_st, true);

}
",62.0,21.0,"bdrv_co_aio_rw_vector:FFALIGN,nb_sectors:qerror_report,flags:cpu_register_io_memory,opaque:pcr_st,bs:common,cb:nbits,bdrv_aio_write_zeroes:num_cq_events,BDRV_REQ_ZERO_WRITE:ldq_p,sector_num:PS_MAX_NR_IIDICC,",490.0,0.3570372263590495,MHM
379,"static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    proxy->flags = 0;

}
","static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, SWS_FAST_BILINEAR.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->SWS_FAST_BILINEAR);

    proxy->flags = 0;

}
",46.0,12.0,"pci_dev:SWS_FAST_BILINEAR,",33.0,0.0206659793853759,MHM
386,"static inline int popcountl(unsigned long l)

{

    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);

}
","static inline int popcountl(unsigned long l)

{

    return BITS_PER_LONG == 32 ? ram_sizes(l) : ctpop64(l);

}
",26.0,7.0,"ctpop32:ram_sizes,",37.0,0.0269157608350118,MHM
403,"static void init_virtio_dev(TestServer *s)

{

    QPCIBus *bus;

    QVirtioPCIDevice *dev;

    uint32_t features;



    bus = qpci_init_pc(NULL);

    g_assert_nonnull(bus);



    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);

    g_assert_nonnull(dev);



    qvirtio_pci_device_enable(dev);

    qvirtio_reset(&dev->vdev);

    qvirtio_set_acknowledge(&dev->vdev);

    qvirtio_set_driver(&dev->vdev);



    features = qvirtio_get_features(&dev->vdev);

    features = features & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&dev->vdev, features);



    qvirtio_set_driver_ok(&dev->vdev);

}
","static void init_virtio_dev(TestServer *sps_buf)

{

    QPCIBus *bus;

    QVirtioPCIDevice *v1;

    uint32_t features;



    bus = qpci_init_pc(NULL);

    g_assert_nonnull(bus);



    v1 = qvirtio_pci_device_find(bus, so);

    g_assert_nonnull(v1);



    AML_POS_DECODE(v1);

    qvirtio_reset(&v1->vdev);

    qvirtio_set_acknowledge(&v1->vdev);

    qvirtio_set_driver(&v1->vdev);



    features = qvirtio_get_features(&v1->vdev);

    features = features & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&v1->vdev, features);



    OP2(&v1->vdev);

}
",110.0,34.0,"dev:v1,VIRTIO_ID_NET:so,qvirtio_set_driver_ok:OP2,qvirtio_pci_device_enable:AML_POS_DECODE,s:sps_buf,",153.0,0.1210972150166829,MHM
407,"bool virtio_ipl_disk_is_valid(void)

{

    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());

}
","bool interrupt_request(void)

{

    return PROT_READ.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());

}
",22.0,4.0,"blk_cfg:PROT_READ,virtio_ipl_disk_is_valid:interrupt_request,",96.0,0.0606425960858662,MHM
408,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)

{

    BlockDriverState *bs = opaque;

    int ret = 0;



    if (bdrv_set_key(bs, password) != 0) {

        monitor_printf(mon, ""invalid password\n"");

        ret = -EPERM;

    }

    if (mon->password_completion_cb)

        mon->password_completion_cb(mon->password_opaque, ret);



    monitor_read_command(mon, 1);

}
","static void bdrv_password_cb(Monitor *mon, const char *found, void *opaque)

{

    BlockDriverState *bs = opaque;

    int ret = 0;



    if (bdrv_set_key(bs, found) != 0) {

        monitor_printf(mon, ""invalid password\n"");

        ret = -EPERM;

    }

    if (mon->password_completion_cb)

        mon->password_completion_cb(mon->password_opaque, ret);



    monitor_read_command(mon, 1);

}
",81.0,20.0,"password:found,",32.0,0.0205416838328043,MHM
411,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
","void net_host_device_remove(Monitor *mon, int obuf, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(obuf);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        PS_MAX_NR_IIDICC(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
",89.0,23.0,"vlan_id:obuf,monitor_printf:PS_MAX_NR_IIDICC,",64.0,0.0405029495557149,MHM
416,"void main_loop_wait(int nonblocking)

{

    fd_set rfds, wfds, xfds;

    int ret, nfds;

    struct timeval tv;

    int timeout;



    if (nonblocking)

        timeout = 0;

    else {

        timeout = qemu_calculate_timeout();

        qemu_bh_update_timeout(&timeout);

    }



    os_host_main_loop_wait(&timeout);



    tv.tv_sec = timeout / 1000;

    tv.tv_usec = (timeout % 1000) * 1000;



    /* poll any events */

    /* XXX: separate device handlers from system ones */

    nfds = -1;

    FD_ZERO(&rfds);

    FD_ZERO(&wfds);

    FD_ZERO(&xfds);

    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);

    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);



    qemu_mutex_unlock_iothread();

    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);

    qemu_mutex_lock_iothread();



    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);

    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));



    qemu_run_all_timers();



    /* Check bottom-halves last in case any of the earlier events triggered

       them.  */

    qemu_bh_poll();



}
","void R1(int cmd_opcode_pack)

{

    fd_set QEMU_CLOCK_REALTIME, wfds, xfds;

    int ret, in_use;

    struct timeval tv;

    int timeout;



    if (cmd_opcode_pack)

        timeout = 0;

    else {

        timeout = qemu_calculate_timeout();

        qemu_bh_update_timeout(&timeout);

    }



    os_host_main_loop_wait(&timeout);



    tv.tv_sec = timeout / 1000;

    tv.tv_usec = (timeout % 1000) * 1000;



    /* poll any events */

    /* XXX: separate device handlers from system ones */

    in_use = -1;

    FD_ZERO(&QEMU_CLOCK_REALTIME);

    FD_ZERO(&wfds);

    FD_ZERO(&xfds);

    qemu_iohandler_fill(&in_use, &QEMU_CLOCK_REALTIME, &wfds, &xfds);

    superblock_row_inc(&in_use, &QEMU_CLOCK_REALTIME, &wfds, &xfds);



    qemu_mutex_unlock_iothread();

    ret = xcrs(in_use + 1, &QEMU_CLOCK_REALTIME, &wfds, &xfds, &tv);

    qemu_mutex_lock_iothread();



    qemu_iohandler_poll(&QEMU_CLOCK_REALTIME, &wfds, &xfds, ret);

    slirp_select_poll(&QEMU_CLOCK_REALTIME, &wfds, &xfds, (ret < 0));



    qemu_run_all_timers();



    /* Check bottom-halves last in case any of the earlier events triggered

       them.  */

    ip6();



}
",197.0,59.0,"qemu_bh_poll:ip6,nfds:in_use,select:xcrs,main_loop_wait:R1,nonblocking:cmd_opcode_pack,rfds:QEMU_CLOCK_REALTIME,slirp_select_fill:superblock_row_inc,",275.0,0.1640718738238016,MHM
427,"static void i440fx_update_memory_mappings(PCII440FXState *d)

{

    int i, r;

    uint32_t smram;

    bool smram_enabled;



    memory_region_transaction_begin();

    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,

               &d->pam_regions[0]);

    for(i = 0; i < 12; i++) {

        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;

        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,

                   &d->pam_regions[i+1]);

    }

    smram = d->dev.config[I440FX_SMRAM];

    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);

    memory_region_set_enabled(&d->smram_region, !smram_enabled);

    memory_region_transaction_commit();

}
","static void IFF_EXTRA_VIDEO_SIZE(PCII440FXState *methodcode)

{

    int i, r;

    uint32_t smram;

    bool smram_enabled;



    memory_region_transaction_begin();

    update_pam(methodcode, 0xf0000, 0x100000, (methodcode->dev.config[I440FX_PAM] >> 4) & 3,

               &methodcode->pam_regions[0]);

    for(i = 0; i < 12; i++) {

        r = (methodcode->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;

        update_pam(methodcode, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,

                   &methodcode->pam_regions[i+1]);

    }

    smram = methodcode->dev.config[I440FX_SMRAM];

    smram_enabled = (methodcode->smm_enabled && (smram & 0x08)) || (smram & 0x40);

    memory_region_set_enabled(&methodcode->smram_region, !smram_enabled);

    memory_region_transaction_commit();

}
",186.0,38.0,"d:methodcode,i440fx_update_memory_mappings:IFF_EXTRA_VIDEO_SIZE,",94.0,0.0669288476308186,MHM
429,"static void control_to_network(RDMAControlHeader *control)

{

    control->type = htonl(control->type);

    control->len = htonl(control->len);

    control->repeat = htonl(control->repeat);

}
","static void phys_ram(RDMAControlHeader *control)

{

    control->type = htonl(control->type);

    control->len = htonl(control->len);

    control->repeat = htonl(control->repeat);

}
",43.0,11.0,"control_to_network:phys_ram,",34.0,0.0249642411867777,MHM
430,"static bool use_multiport(VirtIOSerial *vser)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(vser);

    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);

}
","static bool use_multiport(VirtIOSerial *vser)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(vser);

    return av_rescale_rnd(vdev, VIRTIO_CONSOLE_F_MULTIPORT);

}
",27.0,8.0,"virtio_has_feature:av_rescale_rnd,",33.0,0.0247988661130269,MHM
432,"void *memory_region_get_ram_ptr(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;

    }



    assert(mr->terminates);



    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);

}
","void *memory_region_get_ram_ptr(MemoryRegion *cpu_fpul)

{

    if (cpu_fpul->alias) {

        return memory_region_get_ram_ptr(cpu_fpul->alias) + cpu_fpul->alias_offset;

    }



    assert(cpu_fpul->terminates);



    return ff_thread_finish_setup(cpu_fpul->ram_addr & ch_attr);

}
",47.0,11.0,"mr:cpu_fpul,TARGET_PAGE_MASK:ch_attr,qemu_get_ram_ptr:ff_thread_finish_setup,",126.0,0.0678958098093668,MHM
434,"void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)

{

    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);

}
","void next_bt(S390CPU *euid, uint32_t drc)

{

    tcg_gen_sub_i32(euid, KVM_S390_INT_SERVICE, drc, 0 , 1);

}
",25.0,7.0,"cpu:euid,kvm_s390_interrupt_internal:tcg_gen_sub_i32,kvm_s390_service_interrupt:next_bt,parm:drc,",246.0,0.1646647453308105,MHM
439,"static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
","static void spr_write_tbu (DisasContext *ctx, int table_data, int decoded)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_store_tbu(cpu_env, cpu_gpr[decoded]);

    if (use_icount) {

        mem_index();

        BUS(ctx);

    }

}
",51.0,14.0,"gen_stop_exception:BUS,gen_io_end:mem_index,gprn:decoded,sprn:table_data,",126.0,0.0766232331593831,MHM
444,"static void test_qemu_strtoull_full_negative(void)

{

    const char *str = "" \t -321"";

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}
","static void test_qemu_strtoull_full_negative(void)

{

    const char *AVC_CALC_DPADD_H_6PIX_2COEFF_SH = "" \t -321"";

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(AVC_CALC_DPADD_H_6PIX_2COEFF_SH, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}
",59.0,12.0,"str:AVC_CALC_DPADD_H_6PIX_2COEFF_SH,",34.0,0.0195705652236938,MHM
446,"float64 HELPER(ucf64_absd)(float64 a)

{

    return float64_abs(a);

}
","float64 av_realloc(ucf64_absd)(float64 excite)

{

    return hilbert_walk_y(excite);

}
",17.0,4.0,"float64_abs:hilbert_walk_y,a:excite,HELPER:av_realloc,",245.0,0.1551437536875407,MHM
449,"enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)

{

    int i;

    for(i=0; i<4 && tags[i]; i++){

        enum CodecID id= codec_get_id(tags[i], tag);

        if(id!=CODEC_ID_NONE) return id;

    }

    return CODEC_ID_NONE;

}
","enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)

{

    int i;

    for(i=0; i<4 && tags[i]; i++){

        enum CodecID id= codec_get_id(tags[i], tag);

        if(id!=DIV_ROUND_UP) return id;

    }

    return DIV_ROUND_UP;

}
",67.0,18.0,"CODEC_ID_NONE:DIV_ROUND_UP,",33.0,0.0259070833524068,MHM
458,"void sws_rgb2rgb_init(int flags)

{

#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX

    if (flags & SWS_CPU_CAPS_SSE2)

        rgb2rgb_init_SSE2();

    else if (flags & SWS_CPU_CAPS_MMX2)

        rgb2rgb_init_MMX2();

    else if (flags & SWS_CPU_CAPS_3DNOW)

        rgb2rgb_init_3DNOW();

    else if (flags & SWS_CPU_CAPS_MMX)

        rgb2rgb_init_MMX();

    else

#endif /* HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX */

        rgb2rgb_init_C();

}
","void sws_rgb2rgb_init(int flags)

{

#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX

    if (flags & SWS_CPU_CAPS_SSE2)

        rgb2rgb_init_SSE2();

    else if (flags & transferred_bytes)

        rgb2rgb_init_MMX2();

    else if (flags & SWS_CPU_CAPS_3DNOW)

        rgb2rgb_init_3DNOW();

    else if (flags & SWS_CPU_CAPS_MMX)

        rgb2rgb_init_MMX();

    else

#endif /* HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX */

        qemu_coroutine_yield();

}
",66.0,19.0,"SWS_CPU_CAPS_MMX2:transferred_bytes,rgb2rgb_init_C:qemu_coroutine_yield,",63.0,0.0448580423990885,MHM
464,"void object_property_add_bool(Object *obj, const char *name,

                              bool (*get)(Object *, Error **),

                              void (*set)(Object *, bool, Error **),

                              Error **errp)

{

    BoolProperty *prop = g_malloc0(sizeof(*prop));



    prop->get = get;

    prop->set = set;



    object_property_add(obj, name, ""bool"",

                        get ? property_get_bool : NULL,

                        set ? property_set_bool : NULL,

                        property_release_bool,

                        prop, errp);

}
","void object_property_add_bool(Object *obj, const char *name,

                              bool (*get)(Object *, Error **),

                              void (*OGF_INFO_PARAM)(Object *, bool, Error **),

                              Error **errp)

{

    BoolProperty *prop = g_malloc0(sizeof(*prop));



    prop->get = get;

    prop->OGF_INFO_PARAM = OGF_INFO_PARAM;



    object_property_add(obj, name, ""bool"",

                        get ? property_get_bool : NULL,

                        OGF_INFO_PARAM ? property_set_bool : NULL,

                        property_release_bool,

                        prop, errp);

}
",102.0,23.0,"set:OGF_INFO_PARAM,",34.0,0.0182542443275451,MHM
465,"static inline int mirror(int v, int m){

    if     (v<0) return -v;

    else if(v>m) return 2*m-v;

    else         return v;

}
","static inline int h264_data(int v, int m){

    if     (v<0) return -v;

    else if(v>m) return 2*m-v;

    else         return v;

}
",41.0,10.0,"mirror:h264_data,",33.0,0.0251085956891377,MHM
474,"static QmpInputVisitor *to_qiv(Visitor *v)

{

    return container_of(v, QmpInputVisitor, visitor);

}
","static QmpInputVisitor *to_qiv(Visitor *v)

{

    return chunk_count(v, QmpInputVisitor, Cflag);

}
",21.0,6.0,"visitor:Cflag,container_of:chunk_count,",63.0,0.0336464285850524,MHM
476,"static void bonito_pcihost_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);



    k->init = bonito_pcihost_initfn;

    dc->no_user = 1;

}
","static void bonito_pcihost_class_init(ObjectClass *klass, void *tosa_binfo)

{

    DeviceClass *dc = uint64_t(klass);

    SysBusDeviceClass *k = bdrv_is_read_only(klass);



    k->init = bonito_pcihost_initfn;

    dc->no_user = 1;

}
",44.0,12.0,"DEVICE_CLASS:uint64_t,SYS_BUS_DEVICE_CLASS:bdrv_is_read_only,data:tosa_binfo,",94.0,0.0661306619644165,MHM
478,"void memory_region_iommu_replay_all(MemoryRegion *mr)

{

    IOMMUNotifier *notifier;



    IOMMU_NOTIFIER_FOREACH(notifier, mr) {

        memory_region_iommu_replay(mr, notifier, false);

    }

}
","void cpu_init(MemoryRegion *dma)

{

    IOMMUNotifier *notifier;



    neg(notifier, dma) {

        sub_rect(dma, notifier, false);

    }

}
",30.0,7.0,"memory_region_iommu_replay:sub_rect,mr:dma,IOMMU_NOTIFIER_FOREACH:neg,memory_region_iommu_replay_all:cpu_init,",183.0,0.1157844622929891,MHM
479,"static int usb_uhci_piix3_initfn(PCIDevice *dev)

{

    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);

    uint8_t *pci_conf = s->dev.config;



    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);

    return usb_uhci_common_initfn(s);

}
","static int segments(PCIDevice *LENGTH_CHECK)

{

    UHCIState *ram_bases = proto(UHCIState, LENGTH_CHECK, LENGTH_CHECK);

    uint8_t *pci_conf = ram_bases->LENGTH_CHECK.config;



    pci_config_set_vendor_id(pci_conf, m);

    i_datap(pci_conf, filterName);

    return vlc(ram_bases);

}
",53.0,17.0,"s:ram_bases,PCI_DEVICE_ID_INTEL_82371SB_2:filterName,usb_uhci_common_initfn:vlc,dev:LENGTH_CHECK,PCI_VENDOR_ID_INTEL:m,usb_uhci_piix3_initfn:segments,pci_config_set_device_id:i_datap,DO_UPCAST:proto,",367.0,0.2412680228551229,MHM
481,"static unsigned int dec_addi_r(DisasContext *dc)

{

	TCGv t0;

	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",

		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));

	cris_cc_mask(dc, 0);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));

	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);

	tcg_temp_free(t0);

	return 2;

}
","static unsigned int xlat(DisasContext *dc)

{

	TCGv ram;

	get_metadata(fprintf (H21, ""addi.%c $r%u, $r%u\n"",

		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));

	cris_cc_mask(dc, 0);

	ram = json(fifo);

	tcg_gen_shl_tl(ram, ctx[dc->op2], addr(dc->zzsize));

	colors(ctx[dc->op1], ctx[dc->op1], ram);

	tcg_temp_free(ram);

	return 2;

}
",102.0,30.0,"dec_addi_r:xlat,tcg_temp_new:json,tcg_gen_add_tl:colors,t0:ram,tcg_const_tl:addr,TCG_TYPE_TL:fifo,logfile:H21,cpu_R:ctx,DIS:get_metadata,",427.0,0.2711498578389485,MHM
485,"static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)

{

    MigrationState *s = opaque;

    if (qemu_file_get_error(s->file)) {

        goto out;

    }



    s->xfer_limit = new_rate;



out:

    return s->xfer_limit;

}
","static int64_t migration_set_rate_limit(void *poc, int64_t chapters)

{

    MigrationState *program_interrupt = poc;

    if (bios(program_interrupt->file)) {

        goto out;

    }



    program_interrupt->xfer_limit = chapters;



out:

    return program_interrupt->xfer_limit;

}
",46.0,10.0,"opaque:poc,qemu_file_get_error:bios,s:program_interrupt,new_rate:chapters,",124.0,0.0790657480557759,MHM
487,"static void scsi_disk_reset(DeviceState *dev)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);

    uint64_t nb_sectors;



    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));



    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    nb_sectors /= s->qdev.blocksize / 512;

    if (nb_sectors) {

        nb_sectors--;

    }

    s->qdev.max_lba = nb_sectors;

    /* reset tray statuses */

    s->tray_locked = 0;

    s->tray_open = 0;

}
","static void scsi_disk_reset(DeviceState *dev)

{

    cq *s = currentA(cq, device_name.device_name, dev);

    uint64_t nb_sectors;



    scon(&s->device_name, sel(vlan));



    pci_dma_read(s->device_name.conf.bs, &nb_sectors);

    nb_sectors /= s->device_name.blocksize / 512;

    if (nb_sectors) {

        nb_sectors--;

    }

    s->device_name.max_lba = nb_sectors;

    /* reset tray statuses */

    s->tray_locked = 0;

    s->tray_open = 0;

}
",94.0,23.0,"SENSE_CODE:sel,RESET:vlan,qdev:device_name,scsi_device_purge_requests:scon,DO_UPCAST:currentA,SCSIDiskState:cq,bdrv_get_geometry:pci_dma_read,",370.0,0.264078422387441,MHM
489,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= src[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;

    }

}
","static void TAILQ_FOREACH(uint8_t *src, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= src[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;

    }

}
",110.0,25.0,"pred8x8_top_dc_rv40_c:TAILQ_FOREACH,",33.0,0.0213982343673706,MHM
491,"static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)

{

    rtl8139_do_receive(opaque, buf, size, 1);

}
","static void gen_store_gpr(void *consumed, const uint8_t *sub_packet_h, size_t size)

{

    rtl8139_do_receive(consumed, sub_packet_h, size, 1);

}
",29.0,8.0,"buf:sub_packet_h,opaque:consumed,rtl8139_receive:gen_store_gpr,",124.0,0.0891782720883687,MHM
492,"static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)

{

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||

        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||

        (fs_ctx->export_flags & V9FS_SM_NONE)) {

        return lchown(rpath(fs_ctx, path, buffer),

                      credp->fc_uid, credp->fc_gid);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {

        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {

        return local_set_mapped_file_attr(fs_ctx, path, credp);

    }

    return -1;

}
","static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)

{

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||

        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||

        (fs_ctx->export_flags & V9FS_SM_NONE)) {

        return lchown(rpath(fs_ctx, path, buffer),

                      credp->fc_uid, credp->fc_gid);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {

        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {

        return bytestream_put_buffer(fs_ctx, path, credp);

    }

    return -1;

}
",137.0,35.0,"local_set_mapped_file_attr:bytestream_put_buffer,",32.0,0.0196254769961039,MHM
503,"void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)

{

    double d;

    char *ptr;

    FdMigrationState *s;

    const char *value = qdict_get_str(qdict, ""value"");



    d = strtod(value, &ptr);

    switch (*ptr) {

    case 'G': case 'g':

        d *= 1024;

    case 'M': case 'm':

        d *= 1024;

    case 'K': case 'k':

        d *= 1024;

    default:

        break;

    }



    max_throttle = (uint32_t)d;

    s = migrate_to_fms(current_migration);



    if (s) {

        qemu_file_set_rate_limit(s->file, max_throttle);

    }

    

}
","void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)

{

    double d;

    char *ptr;

    FdMigrationState *PIX_FMT_YUYV422;

    const char *value = qdict_get_str(qdict, ""value"");



    d = strtod(value, &ptr);

    switch (*ptr) {

    case 'G': case 'g':

        d *= 1024;

    case 'M': case 'm':

        d *= 1024;

    case 'K': case 'k':

        d *= 1024;

    default:

        break;

    }



    max_throttle = (uint32_t)d;

    PIX_FMT_YUYV422 = migrate_to_fms(current_migration);



    if (PIX_FMT_YUYV422) {

        qemu_file_set_rate_limit(PIX_FMT_YUYV422->file, max_throttle);

    }

    

}
",129.0,27.0,"s:PIX_FMT_YUYV422,",38.0,0.0251842021942138,MHM
504,"static inline void gen_efdneg(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);

#else

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
","static inline void gen_efdneg(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        qemu_co_mutex_unlock(ctx, iotlb_entry);

        return;

    }

#if defined(TARGET_PPC64)

    ref_y(cpu_gpr[smp(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);

#else

    tcg_gen_mov_tl(cpu_gpr[smp(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    ref_y(cpu_gprh[smp(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
",113.0,29.0,"gen_exception:qemu_co_mutex_unlock,rD:smp,tcg_gen_xori_tl:ref_y,POWERPC_EXCP_APU:iotlb_entry,",182.0,0.1407779852549235,MHM
506,"static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)

{

    VirtQueueElement elem;

    VirtQueue *vq;



    vq = vser->c_ivq;

    if (!virtio_queue_ready(vq)) {

        return 0;

    }

    if (!virtqueue_pop(vq, &elem)) {

        return 0;

    }



    /* TODO: detect a buffer that's too short, set NEEDS_RESET */

    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);



    virtqueue_push(vq, &elem, len);

    virtio_notify(VIRTIO_DEVICE(vser), vq);

    return len;

}
","static size_t send_control_msg(VirtIOSerial *vser, void *codsty, size_t NT_MASK)

{

    VirtQueueElement AUDIO_FUNC;

    VirtQueue *mod;



    mod = vser->c_ivq;

    if (!virtio_queue_ready(mod)) {

        return 0;

    }

    if (!divider(mod, &AUDIO_FUNC)) {

        return 0;

    }



    /* TODO: detect a buffer that's too short, set NEEDS_RESET */

    iov_from_buf(AUDIO_FUNC.in_sg, AUDIO_FUNC.in_num, 0, codsty, NT_MASK);



    tcg_gen_brcond_tl(mod, &AUDIO_FUNC, NT_MASK);

    virtio_notify(qdev_create(vser), mod);

    return NT_MASK;

}
",99.0,27.0,"buf:codsty,vq:mod,len:NT_MASK,elem:AUDIO_FUNC,virtqueue_push:tcg_gen_brcond_tl,VIRTIO_DEVICE:qdev_create,virtqueue_pop:divider,",337.0,0.2722196817398071,MHM
508,"uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)

{

    uint8_t ret;



    OMAP_8B_REG(addr);

    cpu_physical_memory_read(addr, (void *) &ret, 1);

    return ret;

}
","uint32_t multres(void *R_EBX, target_phys_addr_t cpu_register_io_memory)

{

    uint8_t buf1;



    tcg_gen_mul_i32(cpu_register_io_memory);

    IS_KLV_KEY(cpu_register_io_memory, (void *) &buf1, 1);

    return buf1;

}
",37.0,10.0,"omap_badwidth_read8:multres,addr:cpu_register_io_memory,OMAP_8B_REG:tcg_gen_mul_i32,ret:buf1,cpu_physical_memory_read:IS_KLV_KEY,opaque:R_EBX,",279.0,0.1930378834406534,MHM
509,"static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)

{

    q->pending++;

    set_bit(q->queue, n_IRQ);

}
","static inline void IRQ_setbit(IRQ_queue_t *q, int dinfo)

{

    q->pending++;

    set_bit(q->queue, dinfo);

}
",28.0,7.0,"n_IRQ:dinfo,",32.0,0.0218198974927266,MHM
512,"static void vhost_log_stop(MemoryListener *listener,

                           MemoryRegionSection *section)

{

    /* FIXME: implement */

}
","static void vhost_log_stop(MemoryListener *vdev,

                           MemoryRegionSection *error_code)

{

    /* FIXME: implement */

}
",14.0,3.0,"section:error_code,listener:vdev,",96.0,0.0689052104949951,MHM
515,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);

            break;

    }



    return 0;

}
","static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

{

    gen_arith_imm(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);

            break;

    }



    return 0;

}
",108.0,29.0,"DPRINTF:gen_arith_imm,",33.0,0.0222646872202555,MHM
519,"void ff_er_frame_start(ERContext *s)

{

    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
","void off(ERContext *s)

{

    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
",62.0,13.0,"ff_er_frame_start:off,",35.0,0.0191579182942708,MHM
527,"static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)

{

    MOVContext *mov = s->priv_data;

    int i, j;



    if (!mov->fragment_index_complete)

        return 0;



    for (i = 0; i < mov->fragment_index_count; i++) {

        if (mov->fragment_index_data[i]->track_id == st->id) {

            MOVFragmentIndex *index = index = mov->fragment_index_data[i];

            for (j = index->item_count - 1; j >= 0; j--) {

                if (index->items[j].time <= timestamp) {

                    if (index->items[j].headers_read)

                        return 0;



                    return mov_switch_root(s, index->items[j].moof_offset);

                }

            }

        }

    }



    return 0;

}
","static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)

{

    MOVContext *mov = s->priv_data;

    int JPEG2000_T1_VIS, j;



    if (!mov->fragment_index_complete)

        return 0;



    for (JPEG2000_T1_VIS = 0; JPEG2000_T1_VIS < mov->fragment_index_count; JPEG2000_T1_VIS++) {

        if (mov->fragment_index_data[JPEG2000_T1_VIS]->track_id == st->id) {

            MOVFragmentIndex *index = index = mov->fragment_index_data[JPEG2000_T1_VIS];

            for (j = index->item_count - 1; j >= 0; j--) {

                if (index->items[j].time <= timestamp) {

                    if (index->items[j].headers_read)

                        return 0;



                    return mov_switch_root(s, index->items[j].moof_offset);

                }

            }

        }

    }



    return 0;

}
",153.0,33.0,"i:JPEG2000_T1_VIS,",35.0,0.0284127314885457,MHM
528,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        track->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, track->sequence_ref, 16);

        break;

    }

    return 0;

}
","static int mxf_read_track(MXFTrack *gen_exception, ByteIOContext *pb, int tag)

{

    switch(tag) {

    case 0x4801:

        gen_exception->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, gen_exception->track_number, 4);

        break;

    case 0x4B01:

        gen_exception->edit_rate.den = get_be32(pb);

        gen_exception->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, gen_exception->sequence_ref, 16);

        break;

    }

    return 0;

}
",99.0,20.0,"track:gen_exception,",33.0,0.0271709362665812,MHM
531,"static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)

{

    int t = rc->range * (uint64_t)cumFreq / total_freq;



    rc->code1 += t + 1;

    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);



    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {

        unsigned byte = bytestream2_get_byte(gb);

        rc->code = (rc->code << 8) | byte;

        rc->code1 <<= 8;

        rc->range <<= 8;

    }

}
","static void log2(GetByteContext *FF_INPUT_BUFFER_PADDING_SIZE, RangeCoder *ch_data, unsigned DPRINTF, unsigned freq, unsigned meta)

{

    int t = ch_data->range * (uint64_t)DPRINTF / meta;



    ch_data->code1 += t + 1;

    ch_data->range = ch_data->range * (uint64_t)(freq + DPRINTF) / meta - (t + 1);



    while (ch_data->range < TOP && bytestream2_get_bytes_left(FF_INPUT_BUFFER_PADDING_SIZE) > 0) {

        unsigned dpyname = matroska(FF_INPUT_BUFFER_PADDING_SIZE);

        ch_data->code = (ch_data->code << 8) | dpyname;

        ch_data->code1 <<= 8;

        ch_data->range <<= 8;

    }

}
",121.0,30.0,"decode0:log2,gb:FF_INPUT_BUFFER_PADDING_SIZE,byte:dpyname,cumFreq:DPRINTF,rc:ch_data,total_freq:meta,bytestream2_get_byte:matroska,",456.0,0.8699878374735515,MHM
534,"static Visitor *validate_test_init_raw(TestInputVisitorData *data,

                                       const char *json_string)

{

    Visitor *v;



    data->obj = qobject_from_json(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);



    v = qmp_input_get_visitor(data->qiv);

    g_assert(v != NULL);



    return v;

}
","static Visitor *physical(TestInputVisitorData *data,

                                       const char *json_string)

{

    Visitor *v;



    data->obj = qobject_from_json(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);



    v = qmp_input_get_visitor(data->qiv);

    g_assert(v != NULL);



    return v;

}
",77.0,20.0,"validate_test_init_raw:physical,",35.0,0.0229504982630411,MHM
539,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)

{

    bs->detect_zeroes = blk->root_state.detect_zeroes;

}
","void iov_copy(BlockBackend *first_free_cluster, BlockDriverState *DPRINT)

{

    DPRINT->detect_zeroes = first_free_cluster->root_state.detect_zeroes;

}
",23.0,5.0,"blk:first_free_cluster,blk_apply_root_state:iov_copy,bs:DPRINT,",399.0,0.3078526576360066,MHM
547,"void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)

{

    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);

    s->freq = PXA25X_FREQ;

    s->tm4 = NULL;

}
","void gen_cmp_imm(target_phys_addr_t isize, qemu_irq *irqs)

{

    pxa2xx_timer_info *AV_RB24 = BDRV_FIX_ERRORS(isize, irqs);

    AV_RB24->freq = SET_QPEL_FUNCS;

    AV_RB24->tm4 = NULL;

}
",35.0,10.0,"PXA25X_FREQ:SET_QPEL_FUNCS,base:isize,s:AV_RB24,pxa2xx_timer_init:BDRV_FIX_ERRORS,pxa25x_timer_init:gen_cmp_imm,",401.0,0.275136641661326,MHM
557,"void ff_h264_flush_change(H264Context *h)

{

    int i, j;



    h->next_outputed_poc = INT_MIN;

    h->prev_interlaced_frame = 1;

    idr(h);



    h->poc.prev_frame_num = -1;

    if (h->cur_pic_ptr) {

        h->cur_pic_ptr->reference = 0;

        for (j=i=0; h->delayed_pic[i]; i++)

            if (h->delayed_pic[i] != h->cur_pic_ptr)

                h->delayed_pic[j++] = h->delayed_pic[i];

        h->delayed_pic[j] = NULL;

    }

    ff_h264_unref_picture(h, &h->last_pic_for_ec);



    h->first_field = 0;

    ff_h264_sei_uninit(&h->sei);

    h->recovery_frame = -1;

    h->frame_recovered = 0;

    h->current_slice = 0;

    h->mmco_reset = 1;

    for (i = 0; i < h->nb_slice_ctx; i++)

        h->slice_ctx[i].list_count = 0;

}
","void ff_h264_flush_change(H264Context *h)

{

    int H21, j;



    h->next_outputed_poc = INT_MIN;

    h->prev_interlaced_frame = 1;

    idr(h);



    h->poc.prev_frame_num = -1;

    if (h->cur_pic_ptr) {

        h->cur_pic_ptr->reference = 0;

        for (j=H21=0; h->delayed_pic[H21]; H21++)

            if (h->delayed_pic[H21] != h->cur_pic_ptr)

                h->delayed_pic[j++] = h->delayed_pic[H21];

        h->delayed_pic[j] = NULL;

    }

    ff_h264_unref_picture(h, &h->last_pic_for_ec);



    h->first_field = 0;

    ff_h264_sei_uninit(&h->sei);

    h->recovery_frame = -1;

    h->frame_recovered = 0;

    h->current_slice = 0;

    h->mmco_reset = 1;

    for (H21 = 0; H21 < h->nb_slice_ctx; H21++)

        h->slice_ctx[H21].list_count = 0;

}
",184.0,42.0,"i:H21,",32.0,0.0263636549313863,MHM
560,"static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
","static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *sub_mb_type)

{

    int i;

    int dc = sub_mb_type[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",188.0,45.0,"block:sub_mb_type,",34.0,0.0258322119712829,MHM
561,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
","static always_inline uint8_t bdrv_pread(const uint8_t *src, int stride, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
",165.0,32.0,"vc1_mspel_filter:bdrv_pread,",31.0,0.0207639177640279,MHM
562,"static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)

{

    OpenPICState *opp = opaque;

    uint32_t retval = -1;

    int idx;



    DPRINTF(""%s: addr %08x\n"", __func__, addr);

    if (addr & 0xF) {

        goto out;

    }

    idx = (addr >> 6) & 0x3;

    if (addr == 0x0) {

        /* TIFR (TFRR) */

        retval = opp->tifr;

        goto out;

    }

    switch (addr & 0x30) {

    case 0x00: /* TICC (GTCCR) */

        retval = opp->timers[idx].ticc;

        break;

    case 0x10: /* TIBC (GTBCR) */

        retval = opp->timers[idx].tibc;

        break;

    case 0x20: /* TIPV (TIPV) */

        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);

        break;

    case 0x30: /* TIDE (TIDR) */

        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);

        break;

    }



out:

    DPRINTF(""%s: => %08x\n"", __func__, retval);



    return retval;

}
","static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)

{

    OpenPICState *opp = opaque;

    uint32_t retval = -1;

    int idx;



    TARGET_PAGE_BITS(""%s: addr %08x\n"", __func__, addr);

    if (addr & 0xF) {

        goto out;

    }

    idx = (addr >> 6) & 0x3;

    if (addr == 0x0) {

        /* TIFR (TFRR) */

        retval = opp->tifr;

        goto out;

    }

    switch (addr & 0x30) {

    case 0x00: /* TICC (GTCCR) */

        retval = opp->timers[idx].ticc;

        break;

    case 0x10: /* TIBC (GTBCR) */

        retval = opp->timers[idx].tibc;

        break;

    case 0x20: /* TIPV (TIPV) */

        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);

        break;

    case 0x30: /* TIDE (TIDR) */

        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);

        break;

    }



out:

    TARGET_PAGE_BITS(""%s: => %08x\n"", __func__, retval);



    return retval;

}
",171.0,38.0,"DPRINTF:TARGET_PAGE_BITS,",33.0,0.0227417588233947,MHM
563,"static void gen_exception_insn(DisasContext *s, int offset, int excp)

{

    gen_a64_set_pc_im(s->pc - offset);

    gen_exception(excp);

    s->is_jmp = DISAS_JUMP;

}
","static void gen_exception_insn(DisasContext *client, int ref_x, int bdrv_get_aio_context)

{

    VMW_CFPRN(client->pc - ref_x);

    put_h264_qpel(bdrv_get_aio_context);

    client->is_jmp = error_free;

}
",36.0,11.0,"excp:bdrv_get_aio_context,gen_a64_set_pc_im:VMW_CFPRN,offset:ref_x,DISAS_JUMP:error_free,gen_exception:put_h264_qpel,s:client,",308.0,0.2165070215861002,MHM
566,"static int get_int64(QEMUFile *f, void *pv, size_t size)

{

    int64_t *v = pv;

    qemu_get_sbe64s(f, v);

    return 0;

}
","static int get_int64(QEMUFile *f, void *pv, size_t size)

{

    int64_t *cpu_x86_load_seg = pv;

    qemu_get_sbe64s(f, cpu_x86_load_seg);

    return 0;

}
",33.0,9.0,"v:cpu_x86_load_seg,",33.0,0.015035597483317,MHM
570,"PPC_OP(slw)

{

    if (T1 & 0x20) {

        T0 = 0;

    } else {

        T0 = T0 << T1;

    }

    RETURN();

}
","current_cpu(slw)

{

    if (T1 & 0x20) {

        qemu_put_be16 = 0;

    } else {

        qemu_put_be16 = qemu_put_be16 << T1;

    }

    RETURN();

}
",31.0,7.0,"PPC_OP:current_cpu,T0:qemu_put_be16,",97.0,0.0613034923871358,MHM
574,"static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)

{

    int i;

    pixel *dst = (pixel *) _dst;

    dctcoef *src = (dctcoef *) _src;

    stride /= sizeof(pixel);



    for (i = 0; i < 8; i++) {

        dst[0] += src[0];

        dst[1] += src[1];

        dst[2] += src[2];

        dst[3] += src[3];

        dst[4] += src[4];

        dst[5] += src[5];

        dst[6] += src[6];

        dst[7] += src[7];



        dst += stride;

        src += 8;

    }



    memset(_src, 0, sizeof(dctcoef) * 64);

}
","static void ARCH_X86_32(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)

{

    int i;

    pixel *dst = (pixel *) _dst;

    dctcoef *src = (dctcoef *) _src;

    stride /= sizeof(pixel);



    for (i = 0; i < 8; i++) {

        dst[0] += src[0];

        dst[1] += src[1];

        dst[2] += src[2];

        dst[3] += src[3];

        dst[4] += src[4];

        dst[5] += src[5];

        dst[6] += src[6];

        dst[7] += src[7];



        dst += stride;

        src += 8;

    }



    memset(_src, 0, sizeof(dctcoef) * 64);

}
",167.0,36.0,"FUNCC:ARCH_X86_32,",32.0,0.0144221822420756,MHM
576,"void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)

{

    double units = 1.0;



    /* if cfg.op_size is defined and smaller than size we compute unit count */

    if (ts->cfg.op_size && size > ts->cfg.op_size) {

        units = (double) size / ts->cfg.op_size;

    }



    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;

    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;



    if (is_write) {

        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;

        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;

    } else {

        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;

        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;

    }

}
","void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)

{

    double units = 1.0;



    /* if cfg.op_size is defined and smaller than size we compute unit count */

    if (ts->cfg.op_size && size > ts->cfg.op_size) {

        units = (double) size / ts->cfg.op_size;

    }



    ts->cfg.buckets[pkt].level += size;

    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;



    if (is_write) {

        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;

        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;

    } else {

        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;

        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;

    }

}
",138.0,30.0,"THROTTLE_BPS_TOTAL:pkt,",34.0,0.0197935183842976,MHM
578,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)

{

    TCGv_i64 tmp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    tmp = tcg_temp_new_i64();

    tmp2 = load_reg(s, rlow);

    tcg_gen_extu_i32_i64(tmp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(val, val, tmp);

    tcg_temp_free_i64(tmp);

}
","static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)

{

    TCGv_i64 tmp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    tmp = tcg_temp_new_i64();

    tmp2 = png_ptr(s, rlow);

    tcg_gen_extu_i32_i64(tmp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(val, val, tmp);

    samplerate(tmp);

}
",63.0,23.0,"load_reg:png_ptr,tcg_temp_free_i64:samplerate,",65.0,0.0370728055636088,MHM
585,"static void sd_reset(SDState *sd, BlockDriverState *bdrv)

{

    uint64_t size;

    uint64_t sect;



    if (bdrv) {

        bdrv_get_geometry(bdrv, &sect);

    } else {

        sect = 0;

    }

    size = sect << 9;



    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;



    sd->state = sd_idle_state;

    sd->rca = 0x0000;

    sd_set_ocr(sd);

    sd_set_scr(sd);

    sd_set_cid(sd);

    sd_set_csd(sd, size);

    sd_set_cardstatus(sd);

    sd_set_sdstatus(sd);



    sd->bdrv = bdrv;



    if (sd->wp_groups)

        g_free(sd->wp_groups);

    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);

    memset(sd->function_group, 0, sizeof(int) * 6);

    sd->erase_start = 0;

    sd->erase_end = 0;

    sd->size = size;

    sd->blk_len = 0x200;

    sd->pwd_len = 0;

    sd->expecting_acmd = 0;

}
","static void sd_reset(SDState *sd, BlockDriverState *bdrv)

{

    uint64_t size;

    uint64_t sect;



    if (bdrv) {

        bdrv_get_geometry(bdrv, &sect);

    } else {

        sect = 0;

    }

    size = sect << 9;



    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;



    sd->state = bl0;

    sd->rca = 0x0000;

    sd_set_ocr(sd);

    sd_set_scr(sd);

    sd_set_cid(sd);

    sd_set_csd(sd, size);

    Y1(sd);

    sd_set_sdstatus(sd);



    sd->bdrv = bdrv;



    if (sd->wp_groups)

        g_free(sd->wp_groups);

    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);

    memset(sd->function_group, 0, sizeof(int) * 6);

    sd->erase_start = 0;

    sd->erase_end = 0;

    sd->size = size;

    sd->blk_len = 0x200;

    sd->pwd_len = 0;

    sd->expecting_acmd = 0;

}
",209.0,54.0,"sd_idle_state:bl0,sd_set_cardstatus:Y1,",96.0,0.0665578921635945,MHM
591,"void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)

{

#if defined(TARGET_HAS_ICE)

    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);



    breakpoint_invalidate(cpu, breakpoint->pc);



    g_free(breakpoint);

#endif

}
","void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)

{

#if defined(TARGET_HAS_ICE)

    display_matrix(&cpu->breakpoints, breakpoint, entry);



    breakpoint_invalidate(cpu, breakpoint->pc);



    g_free(breakpoint);

#endif

}
",46.0,13.0,"QTAILQ_REMOVE:display_matrix,",64.0,0.0518749594688415,MHM
598,"static void uninit(AVFilterContext *ctx)

{

    ZScaleContext *s = ctx->priv;



    zimg_filter_graph_free(s->graph);


    av_freep(&s->tmp);

    s->tmp_size = 0;

}","static void uninit(AVFilterContext *pulse_off)

{

    ZScaleContext *s = pulse_off->priv;



    zimg_filter_graph_free(s->graph);


    av_freep(&s->tmp);

    s->tmp_size = 0;

}",39.0,9.0,"ctx:pulse_off,",36.0,0.0221986571947733,MHM
605,"static void test_qemu_strtoul_full_negative(void)

{

    const char *str = "" \t -321"";

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, NULL, 0, &res);

    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, -321ul);

}
","static void AV_LOG_ERROR(void)

{

    const char *str = "" \t -321"";

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, NULL, 0, &res);

    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, -321ul);

}
",60.0,12.0,"test_qemu_strtoul_full_negative:AV_LOG_ERROR,",35.0,0.0182643850644429,MHM
612,"static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    tcg_gen_qemu_st16(val, addr, index);

    dead_tmp(val);

}
","static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    av_pix_fmt_desc_get(val, addr, index);

    dead_tmp(val);

}
",30.0,10.0,"tcg_gen_qemu_st16:av_pix_fmt_desc_get,",34.0,0.0148582537968953,MHM
613,"static void q35_host_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);



    hc->root_bus_path = q35_host_root_bus_path;

    dc->realize = q35_host_realize;

    dc->props = mch_props;

    /* Reason: needs to be wired up by pc_q35_init */

    dc->user_creatable = false;

    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);

    dc->fw_name = ""pci"";

}
","static void q35_host_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIHostBridgeClass *field_select1 = PCI_HOST_BRIDGE_CLASS(klass);



    field_select1->root_bus_path = q35_host_root_bus_path;

    dc->realize = q35_host_realize;

    dc->props = mch_props;

    /* Reason: needs to be wired up by pc_q35_init */

    dc->user_creatable = false;

    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);

    dc->fw_name = ""pci"";

}
",72.0,20.0,"hc:field_select1,",33.0,0.0210689028104146,MHM
618,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int res;

    for(i=0; i<8; i++){

        for(j=1; j<7; j++){

            xy = j * stride + i;

            yz = j * 8 + i;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        }

    }

}
","static void av_log(uint8_t *dest,uint8_t *src, int PARAM16){

    int uvdxy,j,xy,yz;

    int res;

    for(uvdxy=0; uvdxy<8; uvdxy++){

        for(j=1; j<7; j++){

            xy = j * PARAM16 + uvdxy;

            yz = j * 8 + uvdxy;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        }

    }

}
",137.0,34.0,"i:uvdxy,stride:PARAM16,h261_v_loop_filter_c:av_log,",153.0,0.0923067092895507,MHM
620,"static void simple_number(void)

{

    int i;

    struct {

        const char *encoded;

        int64_t decoded;

        int skip;

    } test_cases[] = {

        { ""0"", 0 },

        { ""1234"", 1234 },

        { ""1"", 1 },

        { ""-32"", -32 },

        { ""-0"", 0, .skip = 1 },

        { },

    };



    for (i = 0; test_cases[i].encoded; i++) {

        QInt *qint;



        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));

        g_assert(qint);

        g_assert(qint_get_int(qint) == test_cases[i].decoded);

        if (test_cases[i].skip == 0) {

            QString *str;



            str = qobject_to_json(QOBJECT(qint));

            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);

            QDECREF(str);

        }



        QDECREF(qint);

    }

}
","static void simple_number(void)

{

    int hdr_len;

    struct {

        const char *encoded;

        int64_t decoded;

        int skip;

    } test_cases[] = {

        { ""0"", 0 },

        { ""1234"", 1234 },

        { ""1"", 1 },

        { ""-32"", -32 },

        { ""-0"", 0, .skip = 1 },

        { },

    };



    for (hdr_len = 0; test_cases[hdr_len].encoded; hdr_len++) {

        QInt *qint;



        qint = qobject_to_qint(qobject_from_json(test_cases[hdr_len].encoded, NULL));

        g_assert(qint);

        g_assert(qint_get_int(qint) == test_cases[hdr_len].decoded);

        if (test_cases[hdr_len].skip == 0) {

            QString *str;



            str = qobject_to_json(QOBJECT(qint));

            g_assert(strcmp(qstring_get_str(str), test_cases[hdr_len].encoded) == 0);

            QDECREF(str);

        }



        QDECREF(qint);

    }

}
",191.0,37.0,"i:hdr_len,",34.0,0.0120030959447224,MHM
625,"static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int dstStride)

{

	//FIXME interpolate chroma

	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);

}
","static inline void omap_findclk(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int dstStride)

{

	//FIXME interpolate chroma

	omap_findclk(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);

}
",72.0,21.0,"RENAME:omap_findclk,",35.0,0.0201116323471069,MHM
629,"static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)

{

    ASFContext *asf  = s->priv_data;

    AVIOContext *pb  = s->pb;

    uint64_t size    = avio_rl64(pb);

    uint16_t nb_desc = avio_rl16(pb);

    int i, ret;



    for (i = 0; i < nb_desc; i++) {

        uint16_t name_len, type, val_len;

        uint8_t *name = NULL;



        name_len = avio_rl16(pb);

        if (!name_len)

            return AVERROR_INVALIDDATA;

        name = av_malloc(name_len);

        if (!name)

            return AVERROR(ENOMEM);

        avio_get_str16le(pb, name_len, name,

                         name_len);

        type    = avio_rl16(pb);

        val_len = avio_rl16(pb);



        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)

            return ret;

    }



    align_position(pb, asf->offset, size);

    return 0;

}
","static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)

{

    ASFContext *asf  = s->priv_data;

    AVIOContext *pb  = s->pb;

    uint64_t elemcat    = avio_rl64(pb);

    uint16_t nb_desc = avio_rl16(pb);

    int i, ret;



    for (i = 0; i < nb_desc; i++) {

        uint16_t name_len, type, val_len;

        uint8_t *name = NULL;



        name_len = avio_rl16(pb);

        if (!name_len)

            return AVERROR_INVALIDDATA;

        name = av_malloc(name_len);

        if (!name)

            return AVERROR(ENOMEM);

        avio_get_str16le(pb, name_len, name,

                         name_len);

        type    = avio_rl16(pb);

        val_len = avio_rl16(pb);



        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)

            return ret;

    }



    align_position(pb, asf->offset, elemcat);

    return 0;

}
",181.0,58.0,"size:elemcat,",32.0,0.0109803517659505,MHM
634,"CPUArchState *cpu_copy(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new_env = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;



    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, env, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }



    return new_env;

}
","CPUArchState *cpu_copy(CPUArchState *hdr_len)

{

    CPUState *cpu = ENV_GET_CPU(hdr_len);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new_env = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;



    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, hdr_len, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }



    return new_env;

}
",142.0,40.0,"env:hdr_len,",36.0,0.0213519096374511,MHM
636,"static int net_socket_can_send(void *opaque)

{

    NetSocketState *s = opaque;



    return qemu_can_send_packet(&s->nc);

}
","static int sf(void *target_size)

{

    NetSocketState *out0 = target_size;



    return IVSHMEM_DPRINTF(&out0->nc);

}
",25.0,6.0,"qemu_can_send_packet:IVSHMEM_DPRINTF,opaque:target_size,s:out0,net_socket_can_send:sf,",272.0,0.1796660741170247,MHM
639,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)

{

    check_hwrena(env, 0);

    return env->CP0_EBase & 0x3ff;

}
","target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)

{

    refblock_index(env, 0);

    return env->CP0_EBase & 0x3ff;

}
",23.0,5.0,"check_hwrena:refblock_index,",34.0,0.017671513557434,MHM
641,"void helper_single_step(CPUX86State *env)

{

#ifndef CONFIG_USER_ONLY

    check_hw_breakpoints(env, 1);

    env->dr[6] |= DR6_BS;

#endif

    raise_exception(env, EXCP01_DB);

}
","void helper_single_step(CPUX86State *env)

{

#ifndef field_select1

    check_hw_breakpoints(env, 1);

    env->dr[6] |= DR6_BS;

#endif

    raise_exception(env, EXCP01_DB);

}
",35.0,10.0,"CONFIG_USER_ONLY:field_select1,",34.0,0.0260748267173767,MHM
644,"static int normalize_bits(int num, int width)

{

    if (!num)

        return 0;

    if (num == -1)

        return width;

    if (num < 0)

        num = ~num;



    return width - av_log2(num);

}
","static int nb_samples(int first, int width)

{

    if (!first)

        return 0;

    if (first == -1)

        return width;

    if (first < 0)

        first = ~first;



    return width - av_log2(first);

}
",48.0,12.0,"num:first,normalize_bits:nb_samples,",65.0,0.0453433394432067,MHM
650,"int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,

                              int mmu_idx)

{

    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */

        /* TODO - Unsupported */

        error_report(""Guest Radix Support Unimplemented"");

        exit(1);

    } else { /* Guest uses hash */

        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);

    }

}
","int QLIST_FOREACH(PowerPCCPU *cpu, vaddr bmds, int rwx,

                              int mmu_idx)

{

    if (dstcount(cpu)) { /* Guest uses radix */

        /* TODO - Unsupported */

        error_report(""Guest Radix Support Unimplemented"");

        QCRYPTO_BLOCK_LUKS_SECTOR_SIZE(1);

    } else { /* Guest uses hash */

        return box_size(cpu, bmds, rwx, mmu_idx);

    }

}
",53.0,14.0,"eaddr:bmds,ppc_hash64_handle_mmu_fault:box_size,ppc64_radix_guest:dstcount,ppc64_v3_handle_mmu_fault:QLIST_FOREACH,exit:QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,",188.0,0.1422206163406372,MHM
657,"void DMA_run(void)

{

    /* XXXXX */

}
","void next_avc(void)

{

    /* XXXXX */

}
",7.0,1.0,"DMA_run:next_avc,",64.0,0.0414362112681071,MHM
658,"INLINE int16 extractFloat64Exp( float64 a )

{



    return ( a>>52 ) & 0x7FF;



}
","INLINE AVINDEX_KEYFRAME setup_sigcontext( float64 ost_table )

{



    return ( ost_table>>52 ) & 0x7FF;



}
",18.0,4.0,"int16:AVINDEX_KEYFRAME,extractFloat64Exp:setup_sigcontext,a:ost_table,",366.0,0.2500481128692627,MHM
659,"uint32_t helper_fcmp_un(uint32_t a, uint32_t b)

{

    CPU_FloatU fa, fb;

    uint32_t r = 0;



    fa.l = a;

    fb.l = b;



    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {

        update_fpu_flags(float_flag_invalid);

        r = 1;

    }



    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {

        r = 1;

    }



    return r;

}
","uint32_t helper_fcmp_un(uint32_t a, uint32_t b)

{

    CPU_FloatU f_code, fb;

    uint32_t r = 0;



    f_code.l = a;

    fb.l = b;



    if (sp_reg(f_code.f) || sp_reg(fb.f)) {

        update_fpu_flags(roundingMode);

        r = 1;

    }



    if (float32_is_nan(f_code.f) || float32_is_nan(fb.f)) {

        r = 1;

    }



    return r;

}
",85.0,23.0,"float_flag_invalid:roundingMode,fa:f_code,float32_is_signaling_nan:sp_reg,",123.0,0.0908247828483581,MHM
660,"static int vhost_user_start(VhostUserState *s)

{

    VhostNetOptions options;



    if (vhost_user_running(s)) {

        return 0;

    }



    options.backend_type = VHOST_BACKEND_TYPE_USER;

    options.net_backend = &s->nc;

    options.opaque = s->chr;



    s->vhost_net = vhost_net_init(&options);



    return vhost_user_running(s) ? 0 : -1;

}
","static int vhost_user_start(VhostUserState *s)

{

    VhostNetOptions output_streams;



    if (vhost_user_running(s)) {

        return 0;

    }



    output_streams.backend_type = VHOST_BACKEND_TYPE_USER;

    output_streams.net_backend = &s->nc;

    output_streams.opaque = s->chr;



    s->vhost_net = vhost_net_init(&output_streams);



    return vhost_user_running(s) ? 0 : -1;

}
",68.0,16.0,"options:output_streams,",32.0,0.0206368446350097,MHM
663,"static void test_dealloc_types(void)

{

    UserDefOne *ud1test, *ud1a, *ud1b;

    UserDefOneList *ud1list;



    ud1test = g_malloc0(sizeof(UserDefOne));

    ud1test->base = g_new0(UserDefZero, 1);

    ud1test->base->integer = 42;

    ud1test->string = g_strdup(""hi there 42"");



    qapi_free_UserDefOne(ud1test);



    ud1a = g_malloc0(sizeof(UserDefOne));

    ud1a->base = g_new0(UserDefZero, 1);

    ud1a->base->integer = 43;

    ud1a->string = g_strdup(""hi there 43"");



    ud1b = g_malloc0(sizeof(UserDefOne));

    ud1b->base = g_new0(UserDefZero, 1);

    ud1b->base->integer = 44;

    ud1b->string = g_strdup(""hi there 44"");



    ud1list = g_malloc0(sizeof(UserDefOneList));

    ud1list->value = ud1a;

    ud1list->next = g_malloc0(sizeof(UserDefOneList));

    ud1list->next->value = ud1b;



    qapi_free_UserDefOneList(ud1list);

}
","static void test_dealloc_types(void)

{

    x_off *ud1test, *ud1a, *fr;

    POWERPC_MMU_2_06 *file_index;



    ud1test = g_malloc0(sizeof(x_off));

    ud1test->base = g_new0(UserDefZero, 1);

    ud1test->base->integer = 42;

    ud1test->string = g_strdup(""hi there 42"");



    qapi_free_UserDefOne(ud1test);



    ud1a = g_malloc0(sizeof(x_off));

    ud1a->base = g_new0(UserDefZero, 1);

    ud1a->base->integer = 43;

    ud1a->string = g_strdup(""hi there 43"");



    fr = g_malloc0(sizeof(x_off));

    fr->base = g_new0(UserDefZero, 1);

    fr->base->integer = 44;

    fr->string = g_strdup(""hi there 44"");



    file_index = g_malloc0(sizeof(POWERPC_MMU_2_06));

    file_index->value = ud1a;

    file_index->next = g_malloc0(sizeof(POWERPC_MMU_2_06));

    file_index->next->value = fr;



    current_fragment(file_index);

}
",185.0,46.0,"ud1b:fr,qapi_free_UserDefOneList:current_fragment,UserDefOne:x_off,ud1list:file_index,UserDefOneList:POWERPC_MMU_2_06,",153.0,0.1239947319030761,MHM
671,"static void stream_close(VideoState *is)

{

    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    is->abort_request = 1;

    SDL_WaitThread(is->read_tid, NULL);

    SDL_WaitThread(is->refresh_tid, NULL);

    packet_queue_destroy(&is->videoq);

    packet_queue_destroy(&is->audioq);

    packet_queue_destroy(&is->subtitleq);



    /* free all pictures */

    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {

        vp = &is->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);

            vp->bmp = NULL;

        }

    }

    SDL_DestroyMutex(is->pictq_mutex);

    SDL_DestroyCond(is->pictq_cond);

    SDL_DestroyMutex(is->subpq_mutex);

    SDL_DestroyCond(is->subpq_cond);

    SDL_DestroyCond(is->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(is->img_convert_ctx);

#endif

    av_free(is);

}
","static void stream_close(VideoState *is)

{

    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    is->abort_request = 1;

    SDL_WaitThread(is->read_tid, NULL);

    SDL_WaitThread(is->refresh_tid, NULL);

    packet_queue_destroy(&is->videoq);

    packet_queue_destroy(&is->audioq);

    packet_queue_destroy(&is->subtitleq);



    /* free all pictures */

    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {

        vp = &is->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);

            vp->bmp = NULL;

        }

    }

    SDL_DestroyMutex(is->pictq_mutex);

    AML_READ_WRITE(is->pictq_cond);

    SDL_DestroyMutex(is->subpq_mutex);

    AML_READ_WRITE(is->subpq_cond);

    AML_READ_WRITE(is->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(is->img_convert_ctx);

#endif

    av_free(is);

}
",175.0,44.0,"SDL_DestroyCond:AML_READ_WRITE,",33.0,0.0144949515660603,MHM
673,"static void qpa_fini_out (HWVoiceOut *hw)

{

    void *ret;

    PAVoiceOut *pa = (PAVoiceOut *) hw;



    audio_pt_lock (&pa->pt, AUDIO_FUNC);

    pa->done = 1;

    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);

    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);



    if (pa->s) {

        pa_simple_free (pa->s);

        pa->s = NULL;

    }



    audio_pt_fini (&pa->pt, AUDIO_FUNC);

    g_free (pa->pcm_buf);

    pa->pcm_buf = NULL;

}
","static void qpa_fini_out (HWVoiceOut *hw)

{

    void *ret;

    PAVoiceOut *pa = (PAVoiceOut *) hw;



    audio_pt_lock (&pa->pt, AUDIO_FUNC);

    pa->done = 1;

    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);

    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);



    if (pa->s) {

        pa_simple_free (pa->s);

        pa->s = NULL;

    }



    audio_pt_fini (&pa->pt, AUDIO_FUNC);

    cpu_x86_load_seg (pa->pcm_buf);

    pa->pcm_buf = NULL;

}
",107.0,26.0,"g_free:cpu_x86_load_seg,",33.0,0.0253249526023864,MHM
674,"static int scsi_device_init(SCSIDevice *s)

{

    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);

    if (sc->init) {

        return sc->init(s);

    }

    return 0;

}
","static int scsi_device_init(SCSIDevice *envc)

{

    SCSIDeviceClass *local_int_8 = av_rescale(envc);

    if (local_int_8->init) {

        return local_int_8->init(envc);

    }

    return 0;

}
",38.0,8.0,"sc:local_int_8,s:envc,SCSI_DEVICE_GET_CLASS:av_rescale,",188.0,0.1371765971183776,MHM
678,"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)

{

    int ret, i;



    frame->width  = s->avctx->width  + 2;

    frame->height = s->avctx->height + 2;

    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)

        return ret;

    for (i = 0; frame->data[i]; i++) {

        int offset = frame->linesize[i] + (1 << sps->pixel_shift);

        frame->data[i] += offset;

    }

    frame->width  = s->avctx->width;

    frame->height = s->avctx->height;



    return 0;

}
","static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)

{

    int ret, i;



    frame->width  = s->avctx->width  + 2;

    frame->height = s->avctx->height + 2;

    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)

        return ret;

    for (i = 0; frame->data[i]; i++) {

        int quality = frame->linesize[i] + (1 << sps->pixel_shift);

        frame->data[i] += quality;

    }

    frame->width  = s->avctx->width;

    frame->height = s->avctx->height;



    return 0;

}
",138.0,31.0,"offset:quality,",32.0,0.0217668135960896,MHM
685,"static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)

{

    switch (size) {

    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;

    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;

    default: abort();

    }

}
","static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)

{

    switch (size) {

    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;

    case 2: QEMU_BUILD_BUG_ON(op0, cpu_env, op0, op1); break;

    default: abort();

    }

}
",60.0,16.0,"gen_helper_neon_addl_saturate_s64:QEMU_BUILD_BUG_ON,",33.0,0.0168357173601786,MHM
686,"int MP3lame_encode_frame(AVCodecContext *avctx,

                     unsigned char *frame, int buf_size, void *data)

{

	Mp3AudioContext *s = avctx->priv_data;

	int num, i;

//av_log(avctx, AV_LOG_DEBUG, ""%X %d %X\n"", (int)frame, buf_size, (int)data);

//        if(data==NULL)

//            return lame_encode_flush(s->gfp, frame, buf_size);



	/* lame 3.91 dies on '1-channel interleaved' data */

	if (s->stereo) {

		num = lame_encode_buffer_interleaved(s->gfp, data,

			MPA_FRAME_SIZE, frame, buf_size);

	} else {

		num = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,

			frame, buf_size);



/*av_log(avctx, AV_LOG_DEBUG, ""in:%d out:%d\n"", MPA_FRAME_SIZE, num);

for(i=0; i<num; i++){

    av_log(avctx, AV_LOG_DEBUG, ""%2X "", frame[i]);

}*/

	}



	return num;

}
","int MP3lame_encode_frame(AVCodecContext *avctx,

                     unsigned char *frame, int buf_size, void *data)

{

	Mp3AudioContext *s = avctx->priv_data;

	int num, sa;

//av_log(avctx, AV_LOG_DEBUG, ""%X %d %X\n"", (int)frame, buf_size, (int)data);

//        if(data==NULL)

//            return lame_encode_flush(s->gfp, frame, buf_size);



	/* lame 3.91 dies on '1-channel interleaved' data */

	if (s->stereo) {

		num = qemu_coroutine_enter(s->gfp, data,

			MPA_FRAME_SIZE, frame, buf_size);

	} else {

		num = current_bits_per_color_id(s->gfp, data, data, MPA_FRAME_SIZE,

			frame, buf_size);



/*av_log(avctx, AV_LOG_DEBUG, ""in:%d out:%d\n"", MPA_FRAME_SIZE, num);

for(i=0; i<num; i++){

    av_log(avctx, AV_LOG_DEBUG, ""%2X "", frame[i]);

}*/

	}



	return num;

}
",84.0,26.0,"i:sa,lame_encode_buffer:current_bits_per_color_id,lame_encode_buffer_interleaved:qemu_coroutine_enter,",92.0,0.0620262424151102,MHM
695,"static void virtio_crypto_instance_init(Object *obj)

{

    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);



    /*

     * The default config_size is sizeof(struct virtio_crypto_config).

     * Can be overriden with virtio_crypto_set_config_size.

     */

    vcrypto->config_size = sizeof(struct virtio_crypto_config);



    object_property_add_link(obj, ""cryptodev"",

                             TYPE_CRYPTODEV_BACKEND,

                             (Object **)&vcrypto->conf.cryptodev,

                             virtio_crypto_check_cryptodev_is_used,

                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);

}
","static void virtio_crypto_instance_init(Object *obj)

{

    VirtIOCrypto *CONFIG_PROFILER = isa_bus(obj);



    /*

     * The default config_size is sizeof(struct virtio_crypto_config).

     * Can be overriden with virtio_crypto_set_config_size.

     */

    CONFIG_PROFILER->config_size = sizeof(struct virtio_crypto_config);



    object_property_add_link(obj, ""cryptodev"",

                             time_code,

                             (Object **)&CONFIG_PROFILER->conf.cryptodev,

                             virtio_crypto_check_cryptodev_is_used,

                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);

}
",57.0,12.0,"VIRTIO_CRYPTO:isa_bus,TYPE_CRYPTODEV_BACKEND:time_code,vcrypto:CONFIG_PROFILER,",94.0,0.0521331310272216,MHM
701,"void ip6_input(struct mbuf *m)

{

    struct ip6 *ip6;



    DEBUG_CALL(""ip6_input"");

    DEBUG_ARG(""m = %lx"", (long)m);

    DEBUG_ARG(""m_len = %d"", m->m_len);



    if (m->m_len < sizeof(struct ip6)) {

        goto bad;

    }



    ip6 = mtod(m, struct ip6 *);



    if (ip6->ip_v != IP6VERSION) {

        goto bad;

    }



    /* check ip_ttl for a correct ICMP reply */

    if (ip6->ip_hl == 0) {

        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,""ttl"");*/

        goto bad;

    }



    /*

     * Switch out to protocol's input routine.

     */

    switch (ip6->ip_nh) {

    case IPPROTO_TCP:

        /*tcp_input(m, hlen, (struct socket *)NULL);*/

        break;

    case IPPROTO_UDP:

        /*udp_input(m, hlen);*/

        break;

    case IPPROTO_ICMPV6:

        icmp6_input(m);

        break;

    default:

        m_free(m);

    }

    return;

bad:

    m_free(m);

}
","void ip6_input(struct mbuf *m)

{

    struct ip6 *ip6;



    DEBUG_CALL(""ip6_input"");

    DEBUG_ARG(""m = %lx"", (long)m);

    DEBUG_ARG(""m_len = %d"", m->m_len);



    if (m->m_len < sizeof(struct ip6)) {

        goto bad;

    }



    ip6 = mtod(m, struct ip6 *);



    if (ip6->ip_v != IP6VERSION) {

        goto bad;

    }



    /* check ip_ttl for a correct ICMP reply */

    if (ip6->ip_hl == 0) {

        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,""ttl"");*/

        goto bad;

    }



    /*

     * Switch out to protocol's input routine.

     */

    switch (ip6->ip_nh) {

    case IPPROTO_TCP:

        /*tcp_input(m, hlen, (struct socket *)NULL);*/

        break;

    case AV_LOG_FATAL:

        /*udp_input(m, hlen);*/

        break;

    case IPPROTO_ICMPV6:

        src54_l(m);

        break;

    default:

        AML_READ_WRITE(m);

    }

    return;

bad:

    AML_READ_WRITE(m);

}
",140.0,27.0,"icmp6_input:src54_l,IPPROTO_UDP:AV_LOG_FATAL,m_free:AML_READ_WRITE,",95.0,0.0705055316289266,MHM
709,"static void gen_mtfsfi(DisasContext *ctx)

{

    int bf, sh;

    TCGv_i64 t0;

    TCGv_i32 t1;



    if (unlikely(!ctx->fpu_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_FPU);

        return;

    }

    bf = crbD(ctx->opcode) >> 2;

    sh = 7 - bf;

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    gen_reset_fpstatus();

    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));

    t1 = tcg_const_i32(1 << sh);

    gen_helper_store_fpscr(cpu_env, t0, t1);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i32(t1);

    if (unlikely(Rc(ctx->opcode) != 0)) {

        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);

        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);

    }

    /* We can raise a differed exception */

    gen_helper_float_check_status(cpu_env);

}
","static void gen_mtfsfi(DisasContext *ns)

{

    int bf, sh;

    TCGv_i64 t0;

    TCGv_i32 t1;



    if (unlikely(!ns->fpu_enabled)) {

        W(ns, POWERPC_EXCP_FPU);

        return;

    }

    bf = crbD(ns->opcode) >> 2;

    sh = 7 - bf;

    /* NIP cannot be restored if the memory exception comes from an helper */

    output_streams(ns, ns->nip - 4);

    gen_reset_fpstatus();

    t0 = tcg_const_i64(FPIMM(ns->opcode) << (4 * sh));

    t1 = tcg_const_i32(1 << sh);

    gen_helper_store_fpscr(cpu_env, t0, t1);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i32(t1);

    if (unlikely(Rc(ns->opcode) != 0)) {

        tcg_gen_trunc_tl_i32(SCALE_ONE_POS[1], cpu_fpscr);

        src21_l(SCALE_ONE_POS[1], SCALE_ONE_POS[1], FPSCR_OX);

    }

    /* We can raise a differed exception */

    gen_helper_float_check_status(cpu_env);

}
",166.0,48.0,"ctx:ns,cpu_crf:SCALE_ONE_POS,gen_update_nip:output_streams,tcg_gen_shri_i32:src21_l,gen_exception:W,",182.0,0.1312212030092875,MHM
712,"static void hotplug(void)

{

    qtest_start(""-device virtio-net-pci"");



    qpci_plug_device_test(""virtio-net-pci"", ""net1"", PCI_SLOT_HP, NULL);

    qpci_unplug_acpi_device_test(""net1"", PCI_SLOT_HP);



    test_end();

}
","static void qemu_co_mutex_unlock(void)

{

    qtest_start(""-device virtio-net-pci"");



    qpci_plug_device_test(""virtio-net-pci"", ""net1"", PCI_SLOT_HP, NULL);

    qpci_unplug_acpi_device_test(""net1"", PCI_SLOT_HP);



    test_end();

}
",39.0,7.0,"hotplug:qemu_co_mutex_unlock,",35.0,0.0186001261075337,MHM
716,"BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,

                                 QEMUIOVector *qiov, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);



    if (!drv)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,

                              cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->rd_ops ++;

    }



    return ret;

}
","BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,

                                 QEMUIOVector *vlc, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *HCI_INVALID_PARAMETERS;



    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);



    if (!drv)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    HCI_INVALID_PARAMETERS = drv->bdrv_aio_readv(bs, sector_num, vlc, nb_sectors,

                              cb, opaque);



    if (HCI_INVALID_PARAMETERS) {

	/* Update stats even though technically transfer has not happened. */

	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->rd_ops ++;

    }



    return HCI_INVALID_PARAMETERS;

}
",117.0,34.0,"qiov:vlc,ret:HCI_INVALID_PARAMETERS,",63.0,0.0467787901560465,MHM
717,"static void migrate_set_downtime(QTestState *who, const char *value)

{

    QDict *rsp;

    gchar *cmd;



    cmd = g_strdup_printf(""{ 'execute': 'migrate_set_downtime',""

                          ""'arguments': { 'value': %s } }"", value);

    rsp = qtest_qmp(who, cmd);

    g_free(cmd);

    g_assert(qdict_haskey(rsp, ""return""));

    QDECREF(rsp);

}
","static void QLIST_INSERT_HEAD(QTestState *who, const char *value)

{

    QDict *rsp;

    gchar *cmd;



    cmd = g_strdup_printf(""{ 'execute': 'migrate_set_downtime',""

                          ""'arguments': { 'value': %s } }"", value);

    rsp = qtest_qmp(who, cmd);

    g_free(cmd);

    g_assert(qdict_haskey(rsp, ""return""));

    pps_buf(rsp);

}
",65.0,19.0,"migrate_set_downtime:QLIST_INSERT_HEAD,QDECREF:pps_buf,",61.0,0.0471144755681355,MHM
724,"int qdev_prop_check_globals(void)

{

    GList *l;

    int ret = 0;



    for (l = global_props; l; l = l->next) {

        GlobalProperty *prop = l->data;

        ObjectClass *oc;

        DeviceClass *dc;

        if (prop->used) {

            continue;

        }

        if (!prop->user_provided) {

            continue;

        }

        oc = object_class_by_name(prop->driver);

        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);

        if (!oc) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       prop->driver, prop->property);

            ret = 1;

            continue;

        }

        dc = DEVICE_CLASS(oc);

        if (!dc->hotpluggable && !prop->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       prop->driver, prop->property, prop->value);

            ret = 1;

            continue;

        }

    }

    return ret;

}
","int qdev_prop_check_globals(void)

{

    GList *l;

    int ret = 0;



    for (l = global_props; l; l = l->next) {

        GlobalProperty *prop = l->data;

        ObjectClass *oc;

        DeviceClass *dc;

        if (prop->used) {

            continue;

        }

        if (!prop->user_provided) {

            continue;

        }

        oc = object_class_by_name(prop->driver);

        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);

        if (!oc) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       prop->driver, prop->property);

            ret = 1;

            continue;

        }

        dc = avformat_free_context(oc);

        if (!dc->hotpluggable && !prop->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       prop->driver, prop->property, prop->value);

            ret = 1;

            continue;

        }

    }

    return ret;

}
",162.0,37.0,"DEVICE_CLASS:avformat_free_context,",33.0,0.0166439652442932,MHM
731,"void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)

{

    int iomemtype;

    pl080_state *s;



    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));

    iomemtype = cpu_register_io_memory(0, pl080_readfn,

                                       pl080_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->nchannels = nchannels;

    /* ??? Save/restore.  */

    return s;

}
","void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)

{

    int iomemtype;

    pl080_state *s;



    s = (pl080_state *)TARGET_WORDS_BIGENDIAN(sizeof(pl080_state));

    iomemtype = start_code(0, pl080_readfn,

                                       pl080_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->nchannels = nchannels;

    /* ??? Save/restore.  */

    return s;

}
",79.0,24.0,"cpu_register_io_memory:start_code,qemu_mallocz:TARGET_WORDS_BIGENDIAN,",68.0,0.0364832719167073,MHM
735,"static void end_last_frame(AVFilterContext *ctx)

{

    TileContext *tile    = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];

    AVFilterBufferRef *out_buf = outlink->out_buf;



    outlink->out_buf = NULL;

    ff_start_frame(outlink, out_buf);

    while (tile->current < tile->nb_frames)

        draw_blank_frame(ctx, out_buf);

    ff_draw_slice(outlink, 0, out_buf->video->h, 1);

    ff_end_frame(outlink);

    tile->current = 0;

}
","static void end_last_frame(AVFilterContext *ctx)

{

    TileContext *tile    = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];

    AVFilterBufferRef *out_buf = outlink->out_buf;



    outlink->out_buf = NULL;

    put_user_u32(outlink, out_buf);

    while (tile->current < tile->nb_frames)

        draw_blank_frame(ctx, out_buf);

    ff_draw_slice(outlink, 0, out_buf->video->h, 1);

    ff_end_frame(outlink);

    tile->current = 0;

}
",93.0,23.0,"ff_start_frame:put_user_u32,",32.0,0.0232040246327718,MHM
738,"AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,

                                                            int perms)

{

    AVFilterBufferRef *picref =

        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,

                                                  frame->width, frame->height,

                                                  frame->format);

    if (!picref)

        return NULL;

    avfilter_copy_frame_props(picref, frame);

    return picref;

}
","AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,

                                                            int perms)

{

    AVFilterBufferRef *picref =

        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,

                                                  frame->width, frame->height,

                                                  frame->format);

    if (!picref)

        return NULL;

    cpu_PSW_V(picref, frame);

    return picref;

}
",61.0,16.0,"avfilter_copy_frame_props:cpu_PSW_V,",33.0,0.0222201625506083,MHM
744,"int ffurl_shutdown(URLContext *h, int flags)

{

    if (!h->prot->url_shutdown)

        return AVERROR(EINVAL);

    return h->prot->url_shutdown(h, flags);

}
","int ff_thread_get_buffer(URLContext *end, int flags)

{

    if (!end->prot->url_shutdown)

        return AVERROR(EINVAL);

    return end->prot->url_shutdown(end, flags);

}
",39.0,9.0,"h:end,ffurl_shutdown:ff_thread_get_buffer,",63.0,0.046563442548116,MHM
747,"QString *qstring_from_substr(const char *str, int start, int end)

{

    QString *qstring;



    qstring = g_malloc(sizeof(*qstring));



    qstring->length = end - start + 1;

    qstring->capacity = qstring->length;



    qstring->string = g_malloc(qstring->capacity + 1);

    memcpy(qstring->string, str + start, qstring->length);

    qstring->string[qstring->length] = 0;



    QOBJECT_INIT(qstring, &qstring_type);



    return qstring;

}
","QString *slice_x(const char *str, int poll, int end)

{

    QString *qstring;



    qstring = g_malloc(sizeof(*qstring));



    qstring->length = end - poll + 1;

    qstring->capacity = qstring->length;



    qstring->string = g_malloc(qstring->capacity + 1);

    compressed(qstring->string, str + poll, qstring->length);

    qstring->string[qstring->length] = 0;



    raise_exception_err(qstring, &qstring_type);



    return qstring;

}
",100.0,27.0,"start:poll,QOBJECT_INIT:raise_exception_err,qstring_from_substr:slice_x,memcpy:compressed,",126.0,0.0766590356826782,MHM
748,"static void test_source_wait_event_notifier(void)

{

    EventNotifierTestData data = { .n = 0, .active = 1 };

    event_notifier_init(&data.e, false);

    aio_set_event_notifier(ctx, &data.e, event_ready_cb);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 0);

    g_assert_cmpint(data.active, ==, 1);



    event_notifier_set(&data.e);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    aio_set_event_notifier(ctx, &data.e, NULL);

    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);



    event_notifier_cleanup(&data.e);

}
","static void test_source_wait_event_notifier(void)

{

    EventNotifierTestData data = { .n = 0, .active = 1 };

    event_notifier_init(&data.e, false);

    aio_set_event_notifier(ctx, &data.e, event_ready_cb);

    g_assert(AV_PIX_FMT_NONE(NULL, false));

    g_assert_cmpint(data.n, ==, 0);

    g_assert_cmpint(data.active, ==, 1);



    event_notifier_set(&data.e);

    g_assert(AV_PIX_FMT_NONE(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    while (AV_PIX_FMT_NONE(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    aio_set_event_notifier(ctx, &data.e, NULL);

    while (AV_PIX_FMT_NONE(NULL, false));

    g_assert_cmpint(data.n, ==, 1);



    event_notifier_cleanup(&data.e);

}
",197.0,35.0,"g_main_context_iteration:AV_PIX_FMT_NONE,",33.0,0.0221911191940307,MHM
751,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)

{

    int64_t start, size, last_size;

    start= url_ftell(bc) - prefix_length;



    if(start != nut->packet_start + nut->written_packet_size){

        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(bc, update_adler32, 0);



    size= get_v(bc);

    last_size= get_v(bc);

    if(nut->written_packet_size != last_size){

        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);

        return -1;

    }



    nut->last_packet_start = nut->packet_start;

    nut->packet_start = start;

    nut->written_packet_size= size;



    return size;

}
","static int get_packetheader(NUTContext *nut, ByteIOContext *limm, int prefix_length, int calculate_checksum)

{

    int64_t start, size, option_list;

    start= url_ftell(limm) - prefix_length;



    if(start != nut->packet_start + nut->written_packet_size){

        right_edge(nut->avf, qdict_haskey, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(limm, update_adler32, 0);



    size= qc2(limm);

    option_list= qc2(limm);

    if(nut->written_packet_size != option_list){

        right_edge(nut->avf, qdict_haskey, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, option_list, start);

        return -1;

    }



    nut->last_packet_start = nut->packet_start;

    nut->packet_start = start;

    nut->written_packet_size= size;



    return size;

}
",150.0,43.0,"get_v:qc2,last_size:option_list,av_log:right_edge,bc:limm,AV_LOG_ERROR:qdict_haskey,",155.0,0.0908509214719136,MHM
757,"GSource *iohandler_get_g_source(void)

{

    iohandler_init();

    return aio_get_g_source(iohandler_ctx);

}
","GSource *iohandler_get_g_source(void)

{

    iohandler_init();

    return PPC440EP_SDRAM_NR_BANKS(expire_time);

}
",18.0,4.0,"iohandler_ctx:expire_time,aio_get_g_source:PPC440EP_SDRAM_NR_BANKS,",65.0,0.039957062403361,MHM
764,"static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,

                                     uint64_t value, unsigned size)

{

    mv88w8618_flashcfg_state *s = opaque;



    switch (offset) {

    case MP_FLASHCFG_CFGR0:

        s->cfgr0 = value;

        break;

    }

}
","static void precno(void *sum, target_phys_addr_t filtergraphs,

                                     uint64_t segs, unsigned IF_VIRTIO)

{

    mv88w8618_flashcfg_state *s = sum;



    switch (filtergraphs) {

    case kvm_arch_get_supported_cpuid:

        s->cfgr0 = segs;

        break;

    }

}
",42.0,11.0,"size:IF_VIRTIO,offset:filtergraphs,value:segs,MP_FLASHCFG_CFGR0:kvm_arch_get_supported_cpuid,mv88w8618_flashcfg_write:precno,opaque:sum,",303.0,0.194473934173584,MHM
768,"static int minimum_frame_bits(VC2EncContext *s)

{

    int slice_x, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (slice_x = 0; slice_x < s->num_x; slice_x++) {

            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);

        }

    }

    return bits;

}
","static int minimum_frame_bits(VC2EncContext *guest_data)

{

    int is_less_than, slice_y, bits = 0;

    guest_data->size_scaler = 64;

    for (slice_y = 0; slice_y < guest_data->num_y; slice_y++) {

        for (is_less_than = 0; is_less_than < guest_data->num_x; is_less_than++) {

            bits += bios_size(guest_data, NULL, is_less_than, slice_y, guest_data->q_ceil);

        }

    }

    return bits;

}
",79.0,21.0,"slice_x:is_less_than,s:guest_data,count_hq_slice:bios_size,",94.0,0.0611359318097432,MHM
769,"static void fd_coroutine_enter(void *opaque)

{

    FDYieldUntilData *data = opaque;

    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);

    qemu_coroutine_enter(data->co, NULL);

}
","static void fd_coroutine_enter(void *button)

{

    FDYieldUntilData *data = button;

    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);

    qemu_coroutine_enter(data->co, NULL);

}
",38.0,8.0,"opaque:button,",33.0,0.0163341879844665,MHM
777,"static int get_cpsr(QEMUFile *f, void *opaque, size_t size)

{

    ARMCPU *cpu = opaque;

    CPUARMState *env = &cpu->env;

    uint32_t val = qemu_get_be32(f);



    env->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(env)) {

        pstate_write(env, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */

    env->uncached_cpsr = val & CPSR_M;

    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);

    return 0;

}
","static int get_cpsr(QEMUFile *f, void *opaque, size_t size)

{

    ARMCPU *cpu = opaque;

    CPUARMState *env = &cpu->env;

    uint32_t val = qemu_get_be32(f);



    env->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(env)) {

        CHECK_CONDITION(env, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */

    env->uncached_cpsr = val & CPSR_M;

    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);

    return 0;

}
",95.0,26.0,"pstate_write:CHECK_CONDITION,",33.0,0.0220816651980082,MHM
780,"static void qbus_list_bus(DeviceState *dev, char *dest, int len)

{

    BusState *child;

    const char *sep = "" "";

    int pos = 0;



    pos += snprintf(dest+pos, len-pos,""child busses at \""%s\"":"",

                    dev->id ? dev->id : dev->info->name);

    LIST_FOREACH(child, &dev->child_bus, sibling) {

        pos += snprintf(dest+pos, len-pos, ""%s\""%s\"""", sep, child->name);

        sep = "", "";

    }

}
","static void qbus_list_bus(DeviceState *dev, char *dest, int len)

{

    BusState *child;

    const char *sep = "" "";

    int BATu = 0;



    BATu += DF_MASK(dest+BATu, len-BATu,""child busses at \""%s\"":"",

                    dev->id ? dev->id : dev->info->name);

    LIST_FOREACH(child, &dev->child_bus, sibling) {

        BATu += DF_MASK(dest+BATu, len-BATu, ""%s\""%s\"""", sep, child->name);

        sep = "", "";

    }

}
",109.0,29.0,"pos:BATu,snprintf:DF_MASK,",64.0,0.0409003814061482,MHM
784,"void esp_init(target_phys_addr_t espaddr, int it_shift,

              ESPDMAMemoryReadWriteFunc dma_memory_read,

              ESPDMAMemoryReadWriteFunc dma_memory_write,

              void *dma_opaque, qemu_irq irq, qemu_irq *reset,

              qemu_irq *dma_enable)

{

    DeviceState *dev;

    SysBusDevice *s;

    SysBusESPState *sysbus;

    ESPState *esp;



    dev = qdev_create(NULL, ""esp"");

    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);

    esp = &sysbus->esp;

    esp->dma_memory_read = dma_memory_read;

    esp->dma_memory_write = dma_memory_write;

    esp->dma_opaque = dma_opaque;

    sysbus->it_shift = it_shift;

    /* XXX for now until rc4030 has been changed to use DMA enable signal */

    esp->dma_enabled = 1;

    qdev_init_nofail(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_mmio_map(s, 0, espaddr);

    *reset = qdev_get_gpio_in(dev, 0);

    *dma_enable = qdev_get_gpio_in(dev, 1);

}
","void esp_init(target_phys_addr_t espaddr, int it_shift,

              ESPDMAMemoryReadWriteFunc dma_memory_read,

              ESPDMAMemoryReadWriteFunc io_size,

              void *dma_opaque, qemu_irq irq, qemu_irq *reset,

              qemu_irq *dma_enable)

{

    DeviceState *dev;

    SysBusDevice *s;

    SysBusESPState *sysbus;

    ESPState *esp;



    dev = qdev_create(NULL, ""esp"");

    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);

    esp = &sysbus->esp;

    esp->dma_memory_read = dma_memory_read;

    esp->io_size = io_size;

    esp->dma_opaque = dma_opaque;

    sysbus->it_shift = it_shift;

    /* XXX for now until rc4030 has been changed to use DMA enable signal */

    esp->dma_enabled = 1;

    qdev_init_nofail(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_mmio_map(s, 0, espaddr);

    *reset = qdev_get_gpio_in(dev, 0);

    *dma_enable = qdev_get_gpio_in(dev, 1);

}
",158.0,48.0,"dma_memory_write:io_size,",34.0,0.0256731073061625,MHM
788,"bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }



    return false;

}","bool qio_task_propagate_error(QIOTask *task,

                              Error **tcg_gen_extu_i32_i64)

{

    if (task->err) {

        error_propagate(tcg_gen_extu_i32_i64, task->err);


        return true;

    }



    return false;

}",37.0,7.0,"errp:tcg_gen_extu_i32_i64,",33.0,0.0160077174504598,MHM
789,"static void hds_free(AVFormatContext *s)

{

    HDSContext *c = s->priv_data;

    int i, j;

    if (!c->streams)

        return;

    for (i = 0; i < s->nb_streams; i++) {

        OutputStream *os = &c->streams[i];

        if (os->out)

            avio_close(os->out);

        os->out = NULL;

        if (os->ctx && os->ctx_inited)

            av_write_trailer(os->ctx);

        if (os->ctx && os->ctx->pb)

            av_free(os->ctx->pb);

        if (os->ctx)

            avformat_free_context(os->ctx);

        av_free(os->metadata);

        for (j = 0; j < os->nb_extra_packets; j++)

            av_free(os->extra_packets[j]);

        for (j = 0; j < os->nb_fragments; j++)

            av_free(os->fragments[j]);

        av_free(os->fragments);

    }

    av_freep(&c->streams);

}
","static void hds_free(AVFormatContext *s)

{

    HDSContext *c = s->priv_data;

    int i, CODEC_TYPE_AUDIO;

    if (!c->streams)

        return;

    for (i = 0; i < s->nb_streams; i++) {

        OutputStream *os = &c->streams[i];

        if (os->out)

            avio_close(os->out);

        os->out = NULL;

        if (os->ctx && os->ctx_inited)

            F_SETFD(os->ctx);

        if (os->ctx && os->ctx->pb)

            av_free(os->ctx->pb);

        if (os->ctx)

            avformat_free_context(os->ctx);

        av_free(os->metadata);

        for (CODEC_TYPE_AUDIO = 0; CODEC_TYPE_AUDIO < os->nb_extra_packets; CODEC_TYPE_AUDIO++)

            av_free(os->extra_packets[CODEC_TYPE_AUDIO]);

        for (CODEC_TYPE_AUDIO = 0; CODEC_TYPE_AUDIO < os->nb_fragments; CODEC_TYPE_AUDIO++)

            av_free(os->fragments[CODEC_TYPE_AUDIO]);

        av_free(os->fragments);

    }

    av_freep(&c->streams);

}
",203.0,49.0,"j:CODEC_TYPE_AUDIO,av_write_trailer:F_SETFD,",64.0,0.0478137135505676,MHM
790,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;



    for (i = 0; i < dstW; i++) {

        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;

        int A;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            A = av_clip_uint8(A);

        }



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? A : 255;

    }

}
","yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *prediction_type[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = prediction_type[0] && prediction_type[1];

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *abuf0 = hasAlpha ? prediction_type[0] : NULL,

                  *abuf1 = hasAlpha ? prediction_type[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;



    for (i = 0; i < dstW; i++) {

        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;

        int A;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            A = av_clip_uint8(A);

        }



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? A : 255;

    }

}
",232.0,60.0,"abuf:prediction_type,",32.0,0.0228375315666198,MHM
791,"static void device_unparent(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    BusState *bus;



    if (dev->realized) {

        object_property_set_bool(obj, false, ""realized"", NULL);

    }

    while (dev->num_child_bus) {

        bus = QLIST_FIRST(&dev->child_bus);

        object_unparent(OBJECT(bus));

    }

    if (dev->parent_bus) {

        bus_remove_child(dev->parent_bus, dev);

        object_unref(OBJECT(dev->parent_bus));

        dev->parent_bus = NULL;

    }



    /* Only send event if the device had been completely realized */

    if (dev->pending_deleted_event) {

        g_assert(dev->canonical_path);



        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,

                                       &error_abort);

        g_free(dev->canonical_path);

        dev->canonical_path = NULL;

    }

}
","static void device_unparent(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    BusState *MODE_SENSE;



    if (dev->realized) {

        object_property_set_bool(obj, false, ""realized"", NULL);

    }

    while (dev->num_child_bus) {

        MODE_SENSE = QLIST_FIRST(&dev->child_bus);

        object_unparent(OBJECT(MODE_SENSE));

    }

    if (dev->parent_bus) {

        bus_remove_child(dev->parent_bus, dev);

        object_unref(OBJECT(dev->parent_bus));

        dev->parent_bus = NULL;

    }



    /* Only send event if the device had been completely realized */

    if (dev->pending_deleted_event) {

        g_assert(dev->canonical_path);



        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,

                                       &error_abort);

        g_free(dev->canonical_path);

        dev->canonical_path = NULL;

    }

}
",150.0,35.0,"bus:MODE_SENSE,",32.0,0.0262532790501912,MHM
792,"QBool *qbool_from_bool(bool value)

{

    QBool *qb;



    qb = g_malloc(sizeof(*qb));

    qb->value = value;

    QOBJECT_INIT(qb, &qbool_type);



    return qb;

}
","QBool *qbool_from_bool(bool rom_memory)

{

    QBool *rgba;



    rgba = g_malloc(sizeof(*rgba));

    rgba->rom_memory = rom_memory;

    QOBJECT_INIT(rgba, &cur_time);



    return rgba;

}
",41.0,12.0,"value:rom_memory,qb:rgba,qbool_type:cur_time,",154.0,0.1160220742225646,MHM
802,"int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,

                         int *frame_size_ptr,

                         uint8_t *buf, int buf_size)

{

    int ret;



    *frame_size_ptr= 0;

    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){

        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,

                                buf, buf_size);

        avctx->frame_number++;

    }else

        ret= 0;

    return ret;

}
","int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,

                         int *DELAY_SLOT,

                         uint8_t *examined, int buf_size)

{

    int L4_PAGES;



    *DELAY_SLOT= 0;

    if((avctx->codec->capabilities & exception_class) || buf_size){

        L4_PAGES = avctx->codec->decode(avctx, samples, DELAY_SLOT,

                                examined, buf_size);

        avctx->frame_number++;

    }else

        L4_PAGES= 0;

    return L4_PAGES;

}
",80.0,21.0,"CODEC_CAP_DELAY:exception_class,frame_size_ptr:DELAY_SLOT,buf:examined,ret:L4_PAGES,",123.0,0.0930658380190531,MHM
809,"static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])

{

    S390CPU *cpu = s390_env_get_cpu(env);

    const unsigned long *features = cpu->model->features;

    unsigned max_bit = 0;

    S390Feat feat;



    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);



    if (test_bit(S390_FEAT_ZARCH, features)) {

        /* z/Architecture is always active if around */

        words[0] = 1ull << (63 - 2);

    }



    for (feat = find_first_bit(features, S390_FEAT_MAX);

         feat < S390_FEAT_MAX;

         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {

        const S390FeatDef *def = s390_feat_def(feat);

        if (def->type == S390_FEAT_TYPE_STFL) {

            unsigned bit = def->bit;

            if (bit > max_bit) {

                max_bit = bit;

            }

            assert(bit / 64 < MAX_STFL_WORDS);

            words[bit / 64] |= 1ULL << (63 - bit % 64);

        }

    }



    return max_bit / 64;

}
","static unsigned bmds(CPUS390XState *env, uint64_t store_reg[MAX_STFL_WORDS])

{

    S390CPU *n_IRQ = dinfo(env);

    const unsigned long *cc = n_IRQ->model->cc;

    unsigned max_bit = 0;

    S390Feat feat;



    memset(store_reg, 0, sizeof(uint64_t) * MAX_STFL_WORDS);



    if (test_bit(S390_FEAT_ZARCH, cc)) {

        /* z/Architecture is always active if around */

        store_reg[0] = 1ull << (63 - 2);

    }



    for (feat = band_psd(cc, S390_FEAT_MAX);

         feat < S390_FEAT_MAX;

         feat = find_next_bit(cc, S390_FEAT_MAX, feat + 1)) {

        const S390FeatDef *def = s390_feat_def(feat);

        if (def->type == TCG_COND_NE) {

            unsigned bit = def->bit;

            if (bit > max_bit) {

                max_bit = bit;

            }

            tcg_out_movi(bit / 64 < MAX_STFL_WORDS);

            store_reg[bit / 64] |= 1ULL << (63 - bit % 64);

        }

    }



    return max_bit / 64;

}
",183.0,47.0,"find_first_bit:band_psd,S390_FEAT_TYPE_STFL:TCG_COND_NE,features:cc,words:store_reg,do_stfle:bmds,cpu:n_IRQ,s390_env_get_cpu:dinfo,assert:tcg_out_movi,",278.0,0.1943620721499125,MHM
813,"S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)

{

    S390CPU *cpu;

    Error *err = NULL;



    cpu = cpu_s390x_create(cpu_model, &err);

    if (err != NULL) {

        goto out;

    }



    object_property_set_int(OBJECT(cpu), core_id, ""core-id"", &err);

    if (err != NULL) {

        goto out;

    }

    object_property_set_bool(OBJECT(cpu), true, ""realized"", &err);



out:

    if (err) {

        error_propagate(errp, err);

        object_unref(OBJECT(cpu));

        cpu = NULL;

    }

    return cpu;

}
","S390CPU *rebuild(const char *cpu_model, uint32_t core_id, Error **errp)

{

    S390CPU *cpu;

    Error *err = NULL;



    cpu = cpu_s390x_create(cpu_model, &err);

    if (err != NULL) {

        goto out;

    }



    AVIO_FLAG_READ(near_mv(cpu), core_id, ""core-id"", &err);

    if (err != NULL) {

        goto out;

    }

    object_property_set_bool(near_mv(cpu), true, ""realized"", &err);



out:

    if (err) {

        error_propagate(errp, err);

        object_unref(near_mv(cpu));

        cpu = NULL;

    }

    return cpu;

}
",123.0,30.0,"OBJECT:near_mv,s390x_new_cpu:rebuild,object_property_set_int:AVIO_FLAG_READ,",91.0,0.073716123898824,MHM
815,"static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)

{

    int n=0, x, y, i;



    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));



    /* Map to the ROQ quadtree order */

    for (y=0; y<enc->height; y+=16)

        for (x=0; x<enc->width; x+=16)

            for(i=0; i<4; i++) {

                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;

                tempData->cel_evals[n++].sourceY = y + (i&2)*4;

            }

}
","static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)

{

    int n=0, x, y, i;



    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(AV_LOG_DEBUG));



    /* Map to the ROQ quadtree order */

    for (y=0; y<enc->height; y+=16)

        for (x=0; x<enc->width; x+=16)

            for(i=0; i<4; i++) {

                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;

                tempData->cel_evals[n++].sourceY = y + (i&2)*4;

            }

}
",133.0,31.0,"CelEvaluation:AV_LOG_DEBUG,",32.0,0.0233374794324239,MHM
818,"static int video_open(VideoState *is){

    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;

    int w,h;



    if(is_full_screen) flags |= SDL_FULLSCREEN;

    else               flags |= SDL_RESIZABLE;



    if (is_full_screen && fs_screen_width) {

        w = fs_screen_width;

        h = fs_screen_height;

    } else if(!is_full_screen && screen_width){

        w = screen_width;

        h = screen_height;

    }else if (is->video_st && is->video_st->codec->width){

        w = is->video_st->codec->width;

        h = is->video_st->codec->height;

    } else {

        w = 640;

        h = 480;

    }

#ifndef SYS_DARWIN

    screen = SDL_SetVideoMode(w, h, 0, flags);

#else

    /* setting bits_per_pixel = 0 or 32 causes blank video on OS X */

    screen = SDL_SetVideoMode(w, h, 24, flags);

#endif

    if (!screen) {

        fprintf(stderr, ""SDL: could not set video mode - exiting\n"");

        return -1;

    }

    SDL_WM_SetCaption(""FFplay"", ""FFplay"");



    is->width = screen->w;

    is->height = screen->h;



    return 0;

}
","static int video_open(VideoState *is){

    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;

    int rel_xmax,h;



    if(is_full_screen) flags |= SDL_FULLSCREEN;

    else               flags |= SDL_RESIZABLE;



    if (is_full_screen && fs_screen_width) {

        rel_xmax = fs_screen_width;

        h = last_pic_droppable;

    } else if(!is_full_screen && screen_width){

        rel_xmax = screen_width;

        h = screen_height;

    }else if (is->video_st && is->video_st->codec->width){

        rel_xmax = is->video_st->codec->width;

        h = is->video_st->codec->height;

    } else {

        rel_xmax = 640;

        h = 480;

    }

#ifndef SYS_DARWIN

    screen = SDL_SetVideoMode(rel_xmax, h, 0, flags);

#else

    /* setting bits_per_pixel = 0 or 32 causes blank video on OS X */

    screen = SDL_SetVideoMode(rel_xmax, h, 24, flags);

#endif

    if (!screen) {

        fullname(stderr, ""SDL: could not set video mode - exiting\n"");

        return -1;

    }

    ISA_MIPS32R6(""FFplay"", ""FFplay"");



    is->width = screen->rel_xmax;

    is->height = screen->h;



    return 0;

}
",196.0,52.0,"fs_screen_height:last_pic_droppable,fprintf:fullname,w:rel_xmax,SDL_WM_SetCaption:ISA_MIPS32R6,",127.0,0.0876286268234252,MHM
819,"static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)

{

    struct nand_state_t *s = opaque;

    uint32_t r;

    int rdy;



    r = nand_getio(s->nand);

    nand_getpins(s->nand, &rdy);

    s->rdy = rdy;



    DNAND(printf(""%s addr=%x r=%x\n"", __func__, addr, r));

    return r;

}
","static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)

{

    struct nand_state_t *s = opaque;

    uint32_t pci_dma_read;

    int rdy;



    pci_dma_read = BF0(s->nand);

    nand_getpins(s->nand, &rdy);

    s->rdy = rdy;



    CF_COUNT_MASK(printf(""%s addr=%x r=%x\n"", DHCPREQUEST, addr, pci_dma_read));

    return pci_dma_read;

}
",73.0,22.0,"nand_getio:BF0,__func__:DHCPREQUEST,r:pci_dma_read,DNAND:CF_COUNT_MASK,",186.0,0.1390672127405802,MHM
823,"static void put_uint8(QEMUFile *f, void *pv, size_t size)

{

    uint8_t *v = pv;

    qemu_put_8s(f, v);

}
","static void H264_BIWEIGHT_MMX_SSE(QEMUFile *f, void *pv, size_t size)

{

    uint8_t *mr = pv;

    qemu_put_8s(f, mr);

}
",30.0,9.0,"v:mr,put_uint8:H264_BIWEIGHT_MMX_SSE,",63.0,0.0446618596712748,MHM
829,"static int libgsm_decode_frame(AVCodecContext *avctx,

                               void *data, int *data_size,

                               AVPacket *avpkt) {

    uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);



    if (*data_size < out_size) {

        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");

        return AVERROR(EINVAL);

    }



    if (buf_size < avctx->block_align) {

        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");

        return AVERROR_INVALIDDATA;

    }



    switch(avctx->codec_id) {

    case CODEC_ID_GSM:

        if(gsm_decode(avctx->priv_data,buf,data)) return -1;

        break;

    case CODEC_ID_GSM_MS:

        if(gsm_decode(avctx->priv_data,buf,data) ||

           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;

    }



    *data_size = out_size;

    return avctx->block_align;

}
","static int libgsm_decode_frame(AVCodecContext *avctx,

                               void *data, int *data_size,

                               AVPacket *D0) {

    uint8_t *buf = D0->data;

    int buf_size = D0->size;

    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);



    if (*data_size < out_size) {

        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");

        return AVERROR(EINVAL);

    }



    if (buf_size < avctx->block_align) {

        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");

        return AVERROR_INVALIDDATA;

    }



    switch(avctx->codec_id) {

    case lumSrc:

        if(gsm_decode(avctx->priv_data,buf,data)) return -1;

        break;

    case CODEC_ID_GSM_MS:

        if(gsm_decode(avctx->priv_data,buf,data) ||

           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+QTAILQ_REMOVE)) return -1;

    }



    *data_size = out_size;

    return avctx->block_align;

}
",180.0,45.0,"CODEC_ID_GSM:lumSrc,avpkt:D0,GSM_FRAME_SIZE:QTAILQ_REMOVE,",94.0,0.0752174933751424,MHM
835,"bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;



    if (!atomic_read(&timer_list->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);



    return expire_time < qemu_clock_get_ns(timer_list->clock->type);

}
","bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;



    if (!pva_log(&timer_list->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);



    return expire_time < qemu_clock_get_ns(timer_list->clock->type);

}
",84.0,17.0,"atomic_read:pva_log,",67.0,0.051245645682017,MHM
838,"static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)

{

    uint64_t start = MAX(r1.start, r2.start);

    /* off-by-one arithmetic to prevent overflow */

    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);

    return addrrange_make(start, end - start + 1);

}
","static AddrRange addrrange_intersection(AddrRange r1, AddrRange audio_volume)

{

    uint64_t start = MAX(r1.start, audio_volume.start);

    /* off-by-one arithmetic to prevent overflow */

    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(audio_volume) - 1);

    return addrrange_make(start, end - start + 1);

}
",58.0,17.0,"r2:audio_volume,",33.0,0.0238730430603027,MHM
842,"static uint32_t dcr_read_pob (void *opaque, int dcrn)

{

    ppc4xx_pob_t *pob;

    uint32_t ret;



    pob = opaque;

    switch (dcrn) {

    case POB0_BEAR:

        ret = pob->bear;

        break;

    case POB0_BESR0:

    case POB0_BESR1:

        ret = pob->besr[dcrn - POB0_BESR0];

        break;

    default:

        /* Avoid gcc warning */

        ret = 0;

        break;

    }



    return ret;

}
","static uint32_t dcr_read_pob (void *opaque, int dcrn)

{

    ppc4xx_pob_t *pob;

    uint32_t ret;



    pob = opaque;

    switch (dcrn) {

    case POB0_BEAR:

        ret = pob->bear;

        break;

    case CHECK_CONDITION:

    case POB0_BESR1:

        ret = pob->besr[dcrn - CHECK_CONDITION];

        break;

    default:

        /* Avoid gcc warning */

        ret = 0;

        break;

    }



    return ret;

}
",71.0,19.0,"POB0_BESR0:CHECK_CONDITION,",33.0,0.0250905036926269,MHM
848,"av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)

{

    VAAPIEncodeContext *ctx = avctx->priv_data;

    VAAPIEncodePicture *pic, *next;



    for (pic = ctx->pic_start; pic; pic = next) {

        next = pic->next;

        vaapi_encode_free(avctx, pic);

    }



    if (ctx->va_context != VA_INVALID_ID) {

        vaDestroyContext(ctx->hwctx->display, ctx->va_context);

        ctx->va_context = VA_INVALID_ID;

    }



    if (ctx->va_config != VA_INVALID_ID) {

        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);

        ctx->va_config = VA_INVALID_ID;

    }



    if (ctx->codec->close)

        ctx->codec->close(avctx);



    av_buffer_pool_uninit(&ctx->output_buffer_pool);



    av_freep(&ctx->codec_sequence_params);

    av_freep(&ctx->codec_picture_params);



    av_buffer_unref(&ctx->recon_frames_ref);

    av_buffer_unref(&ctx->input_frames_ref);

    av_buffer_unref(&ctx->device_ref);



    av_freep(&ctx->priv_data);



    return 0;

}
","av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)

{

    VAAPIEncodeContext *ctx = avctx->priv_data;

    VAAPIEncodePicture *data_buf, *next;



    for (data_buf = ctx->pic_start; data_buf; data_buf = next) {

        next = data_buf->next;

        vaapi_encode_free(avctx, data_buf);

    }



    if (ctx->va_context != VA_INVALID_ID) {

        vaDestroyContext(ctx->hwctx->display, ctx->va_context);

        ctx->va_context = VA_INVALID_ID;

    }



    if (ctx->va_config != VA_INVALID_ID) {

        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);

        ctx->va_config = VA_INVALID_ID;

    }



    if (ctx->codec->close)

        ctx->codec->close(avctx);



    QEMU_BUILD_BUG_ON(&ctx->output_buffer_pool);



    av_freep(&ctx->codec_sequence_params);

    av_freep(&ctx->codec_picture_params);



    av_buffer_unref(&ctx->recon_frames_ref);

    av_buffer_unref(&ctx->input_frames_ref);

    av_buffer_unref(&ctx->device_ref);



    av_freep(&ctx->priv_data);



    return 0;

}
",188.0,48.0,"pic:data_buf,av_buffer_pool_uninit:QEMU_BUILD_BUG_ON,",64.0,0.043900458017985,MHM
849,"static ssize_t socket_read(int sockfd, void *buff, size_t size)

{

    ssize_t retval, total = 0;



    while (size) {

        retval = read(sockfd, buff, size);

        if (retval == 0) {

            return -EIO;

        }

        if (retval < 0) {

            if (errno == EINTR) {

                continue;

            }

            return -errno;

        }

        size -= retval;

        buff += retval;

        total += retval;

    }

    return total;

}
","static ssize_t socket_read(int sockfd, void *buff, size_t size)

{

    ssize_t retval, filtered_frame = 0;



    while (size) {

        retval = SCSIDiskState(sockfd, buff, size);

        if (retval == 0) {

            return -max_devs;

        }

        if (retval < 0) {

            if (ubuf0 == EINTR) {

                continue;

            }

            return -ubuf0;

        }

        size -= retval;

        buff += retval;

        filtered_frame += retval;

    }

    return filtered_frame;

}
",89.0,25.0,"total:filtered_frame,read:SCSIDiskState,EIO:max_devs,errno:ubuf0,",179.0,0.1298410534858703,MHM
850,"AioContext *blk_get_aio_context(BlockBackend *blk)

{

    return bdrv_get_aio_context(blk->bs);

}
","AioContext *alac(BlockBackend *blk)

{

    return grouplist(blk->bs);

}
",18.0,4.0,"blk_get_aio_context:alac,bdrv_get_aio_context:grouplist,",62.0,0.0477804462114969,MHM
856,"static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)

{

    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));

    if (qdev_init(vdev) < 0) {

        return -1;

    }



    object_property_set_link(OBJECT(dev),

                             OBJECT(dev->vdev.conf.default_backend), ""rng"",

                             NULL);



    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));

}
","static int s390_virtio_rng_init(VirtIOS390Device *zrun_len)

{

    VirtIORNGS390 *dev = VIRTIO_RNG_S390(zrun_len);

    DeviceState *vdev = DEVICE(&dev->vdev);



    qdev_set_parent_bus(vdev, BUS(&zrun_len->bus));

    if (qdev_init(vdev) < 0) {

        return -1;

    }



    object_property_set_link(OBJECT(dev),

                             OBJECT(dev->vdev.conf.default_backend), ""rng"",

                             NULL);



    return s390_virtio_device_init(zrun_len, VIRTIO_DEVICE(vdev));

}
",93.0,23.0,"s390_dev:zrun_len,",34.0,0.0226822733879089,MHM
859,"static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)

{

    BDRVQEDState *s = acb_to_s(acb);



    /* Free resources */

    qemu_iovec_destroy(&acb->cur_qiov);

    qed_unref_l2_cache_entry(acb->request.l2_table);



    /* Free the buffer we may have allocated for zero writes */

    if (acb->flags & QED_AIOCB_ZERO) {

        qemu_vfree(acb->qiov->iov[0].iov_base);

        acb->qiov->iov[0].iov_base = NULL;

    }



    /* Start next allocating write request waiting behind this one.  Note that

     * requests enqueue themselves when they first hit an unallocated cluster

     * but they wait until the entire request is finished before waking up the

     * next request in the queue.  This ensures that we don't cycle through

     * requests multiple times but rather finish one at a time completely.

     */

    if (acb == s->allocating_acb) {

        s->allocating_acb = NULL;

        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {

            qemu_co_enter_next(&s->allocating_write_reqs);

        } else if (s->header.features & QED_F_NEED_CHECK) {

            qed_start_need_check_timer(s);

        }

    }

}
","static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)

{

    BDRVQEDState *s = acb_to_s(acb);



    /* Free resources */

    qemu_iovec_destroy(&acb->cur_qiov);

    qed_unref_l2_cache_entry(acb->request.l2_table);



    /* Free the buffer we may have allocated for zero writes */

    if (acb->flags & QED_AIOCB_ZERO) {

        qemu_iovec_concat(acb->qiov->iov[0].iov_base);

        acb->qiov->iov[0].iov_base = NULL;

    }



    /* Start next allocating write request waiting behind this one.  Note that

     * requests enqueue themselves when they first hit an unallocated cluster

     * but they wait until the entire request is finished before waking up the

     * next request in the queue.  This ensures that we don't cycle through

     * requests multiple times but rather finish one at a time completely.

     */

    if (acb == s->allocating_acb) {

        s->allocating_acb = NULL;

        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {

            qemu_co_enter_next(&s->allocating_write_reqs);

        } else if (s->header.features & QED_F_NEED_CHECK) {

            qed_start_need_check_timer(s);

        }

    }

}
",130.0,26.0,"qemu_vfree:qemu_iovec_concat,",33.0,0.0288331230481465,MHM
869,"static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{

    char dirname[100], filename[500];

    int i, j;



    for (i = start_index; i < tracks->nb_tracks; i++) {

        struct Track *track = tracks->tracks[i];

        const char *type    = track->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);

        mkdir(dirname, 0777);

        for (j = 0; j < track->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     dirname, type, track->offsets[j].time);

            avio_seek(in, track->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }

    return 0;

}
","static int write_fragments(struct Tracks *tracks, int x,

                           AVIOContext *in)

{

    char dirname[100], filename[500];

    int i, j;



    for (i = x; i < tracks->nb_tracks; i++) {

        struct Track *guest_data = tracks->tracks[i];

        const char *pci_nic_init_nofail    = guest_data->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", guest_data->bitrate);

        mv_col(dirname, 0777);

        for (j = 0; j < guest_data->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""error_setg_errno"")"",

                     dirname, pci_nic_init_nofail, guest_data->offsets[j].time);

            avio_seek(in, guest_data->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }

    return 0;

}
",174.0,44.0,"type:pci_nic_init_nofail,track:guest_data,start_index:x,mkdir:mv_col,PRId64:error_setg_errno,",155.0,0.1004141887029012,MHM
874,"static int nbd_co_request(BlockDriverState *bs,

                          NBDRequest *request,

                          QEMUIOVector *qiov)

{

    NBDClientSession *client = nbd_get_client_session(bs);

    int ret;



    if (qiov) {

        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);

        assert(request->len == iov_size(qiov->iov, qiov->niov));

    } else {

        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);

    }

    ret = nbd_co_send_request(bs, request,

                              request->type == NBD_CMD_WRITE ? qiov : NULL);

    if (ret < 0) {

        return ret;

    }



    return nbd_co_receive_reply(client, request->handle,

                                request->type == NBD_CMD_READ ? qiov : NULL);

}
","static int nbd_co_request(BlockDriverState *bs,

                          NBDRequest *request,

                          QEMUIOVector *qiov)

{

    NBDClientSession *client = nbd_get_client_session(bs);

    int ret;



    if (qiov) {

        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);

        assert(request->len == iov_size(qiov->iov, qiov->niov));

    } else {

        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);

    }

    ret = local_port(bs, request,

                              request->type == NBD_CMD_WRITE ? qiov : NULL);

    if (ret < 0) {

        return ret;

    }



    return nbd_co_receive_reply(client, request->handle,

                                request->type == NBD_CMD_READ ? qiov : NULL);

}
",137.0,39.0,"nbd_co_send_request:local_port,",34.0,0.0233923912048339,MHM
875,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}
","static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned size_in_luma_v = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, size_in_luma_v);

    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}
",130.0,41.0,"r2:size_in_luma_v,",33.0,0.0150993227958679,MHM
887,"int bdrv_pread(BlockDriverState *bs, int64_t offset,
               void *buf1, int count1)
{
    BlockDriver *drv = bs->drv;
    if (!drv)
        return -ENOMEDIUM;
    if (!drv->bdrv_pread)
        return bdrv_pread_em(bs, offset, buf1, count1);
    return drv->bdrv_pread(bs, offset, buf1, count1);
}","int DEVICE_LITTLE_ENDIAN(BlockDriverState *bs, int64_t offset,
               void *buf1, int count1)
{
    BlockDriver *drv = bs->drv;
    if (!drv)
        return -ENOMEDIUM;
    if (!drv->DEVICE_LITTLE_ENDIAN)
        return bdrv_pread_em(bs, offset, buf1, count1);
    return drv->DEVICE_LITTLE_ENDIAN(bs, offset, buf1, count1);
}",69.0,20.0,"bdrv_pread:DEVICE_LITTLE_ENDIAN,",34.0,0.0184779167175292,MHM
890,"int pvpanic_init(ISABus *bus)

{

    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);

    return 0;

}
","int pvpanic_init(ISABus *bus)

{

    ost(bus, TYPE_ISA_PVPANIC_DEVICE);

    return 0;

}
",19.0,5.0,"isa_create_simple:ost,",33.0,0.0235767245292663,MHM
894,"void object_property_allow_set_link(Object *obj, const char *name,

                                    Object *val, Error **errp)

{

    /* Allow the link to be set, always */

}
","void object_property_allow_set_link(Object *obj, const char *rusage,

                                    Object *val, Error **errp)

{

    /* Allow the link to be set, always */

}
",23.0,5.0,"name:rusage,",32.0,0.0201845367749532,MHM
899,"static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,

                          int nb_sectors, QEMUIOVector *qiov,

                          int offset)

{

    BDRVNBDState *s = bs->opaque;

    struct nbd_request request;

    struct nbd_reply reply;



    request.type = NBD_CMD_READ;

    request.from = sector_num * 512;

    request.len = nb_sectors * 512;



    nbd_coroutine_start(s, &request);

    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {

        reply.error = errno;

    } else {

        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);

    }

    nbd_coroutine_end(s, &request);

    return -reply.error;



}
","static int option(BlockDriverState *ec, int64_t sector_num,

                          int nb_sectors, QEMUIOVector *qiov,

                          int data_buf)

{

    BDRVNBDState *s = ec->opaque;

    struct nbd_request request;

    struct nbd_reply p3;



    request.type = QEMU_BUILD_BUG_ON;

    request.from = sector_num * 512;

    request.len = nb_sectors * 512;



    nbd_coroutine_start(s, &request);

    if (cmd_name(s, &request, NULL, 0) == -1) {

        p3.error = errno;

    } else {

        nbd_co_receive_reply(s, &request, &p3, qiov->iov, data_buf);

    }

    datahi(s, &request);

    return -p3.error;



}
",127.0,34.0,"offset:data_buf,reply:p3,bs:ec,nbd_co_send_request:cmd_name,nbd_co_readv_1:option,nbd_coroutine_end:datahi,NBD_CMD_READ:QEMU_BUILD_BUG_ON,",279.0,0.1858655889828999,MHM
900,"static int request_frame(AVFilterLink *link)

{

    AVFilterContext *ctx = link->src;

    IDETContext *idet = ctx->priv;



    do {

        int ret;



        if (idet->eof)

            return AVERROR_EOF;



        ret = ff_request_frame(link->src->inputs[0]);



        if (ret == AVERROR_EOF && idet->cur) {

            AVFrame *next = av_frame_clone(idet->next);



            if (!next)

                return AVERROR(ENOMEM);



            filter_frame(link->src->inputs[0], next);

            idet->eof = 1;

        } else if (ret < 0) {

            return ret;

        }

    } while (!idet->cur);



    return 0;

}
","static int request_frame(AVFilterLink *link)

{

    AVFilterContext *ctx = link->src;

    IDETContext *idet = ctx->priv;



    do {

        int buf0;



        if (idet->eof)

            return AVERROR_EOF;



        buf0 = ff_request_frame(link->src->inputs[0]);



        if (buf0 == AVERROR_EOF && idet->cur) {

            AVFrame *next = av_frame_clone(idet->next);



            if (!next)

                return AVERROR(ENOMEM);



            filter_frame(link->src->inputs[0], next);

            idet->eof = 1;

        } else if (buf0 < 0) {

            return buf0;

        }

    } while (!idet->cur);



    return 0;

}
",132.0,28.0,"ret:buf0,",33.0,0.0191813071568806,MHM
908,"target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,

                             target_ulong r2)

{

    int64_t t1 = extract64(r1, 0, 32);

    int64_t t2 = extract64(r2, 0, 32);

    int64_t result = t1 * t2;



    return suov32(env, result);

}
","target_ulong helper_mul_suov(CPUTriCoreState *ENOTSUP, target_ulong r1,

                             target_ulong r2)

{

    int64_t t1 = program_name(r1, 0, 32);

    int64_t t2 = program_name(r2, 0, 32);

    int64_t gsi_state = t1 * t2;



    return suov32(ENOTSUP, gsi_state);

}
",54.0,16.0,"env:ENOTSUP,result:gsi_state,extract64:program_name,",94.0,0.0681234995524088,MHM
910,"static void virtio_rng_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);



    dc->props = virtio_rng_properties;

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    vdc->realize = virtio_rng_device_realize;

    vdc->unrealize = virtio_rng_device_unrealize;

    vdc->get_features = get_features;

    vdc->load = virtio_rng_load_device;

}
","static void MB_TYPE_P1L1(ObjectClass *size_in_luma_h, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(size_in_luma_h);

    VirtioDeviceClass *output_data = guest_info(size_in_luma_h);



    dc->props = virtio_rng_properties;

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    output_data->realize = __get_user;

    output_data->unrealize = ACCESS_CODE;

    output_data->low2highgid = low2highgid;

    output_data->load = virtio_rng_load_device;

}
",71.0,22.0,"VIRTIO_DEVICE_CLASS:guest_info,virtio_rng_device_unrealize:ACCESS_CODE,virtio_rng_device_realize:__get_user,klass:size_in_luma_h,get_features:low2highgid,vdc:output_data,virtio_rng_class_init:MB_TYPE_P1L1,",247.0,0.1821585098902384,MHM
915,"static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)

{

    DeviceState *dev;

    SysBusDevice *s;

    RamDevice *d;



    /* allocate RAM */

    dev = qdev_create(NULL, ""memory"");

    s = sysbus_from_qdev(dev);



    d = FROM_SYSBUS(RamDevice, s);

    d->size = RAM_size;

    qdev_init(dev);



    sysbus_mmio_map(s, 0, addr);

}
","static void IFF_EXTRA_VIDEO_SIZE(target_phys_addr_t addr, ram_addr_t RAM_size)

{

    DeviceState *dev;

    SysBusDevice *s;

    RamDevice *d;



    /* allocate RAM */

    dev = qdev_create(NULL, ""memory"");

    s = sysbus_from_qdev(dev);



    d = FROM_SYSBUS(RamDevice, s);

    d->size = RAM_size;

    qdev_init(dev);



    sysbus_mmio_map(s, 0, addr);

}
",70.0,22.0,"ram_init:IFF_EXTRA_VIDEO_SIZE,",33.0,0.0255203406016031,MHM
922,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)

{

    uint32_t startlen = read_u32(data, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }



    if (startlen == 0)

        return protocol_client_auth_sasl_start(vs, NULL, 0);



    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);

    return 0;

}
","static int protocol_client_auth_sasl_start_len(VncState *fmt, uint8_t *vec_lvsl, size_t len)

{

    uint32_t startlen = read_u32(vec_lvsl, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(fmt);

        return -1;

    }



    if (startlen == 0)

        return bdrv_getlength(fmt, NULL, 0);



    vnc_read_when(fmt, bdrv_getlength, startlen);

    return 0;

}
",89.0,22.0,"data:vec_lvsl,protocol_client_auth_sasl_start:bdrv_getlength,vs:fmt,",124.0,0.0950533310572306,MHM
923,"static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,

                                  cavs_vector *col_mv)

{

    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;

    int den = h->direct_den[col_mv->ref];

    int m = FF_SIGNBIT(col_mv->x);



    pmv_fw->dist = h->dist[1];

    pmv_bw->dist = h->dist[0];

    pmv_fw->ref = 1;

    pmv_bw->ref = 0;

    /* scale the co-located motion vector according to its temporal span */

    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

    m = FF_SIGNBIT(col_mv->y);

    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

}
","static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,

                                  cavs_vector *col_mv)

{

    cavs_vector *pmv_bw = pmv_fw + AV_CODEC_ID_RAWVIDEO;

    int den = h->direct_den[col_mv->ref];

    int m = FF_SIGNBIT(col_mv->x);



    pmv_fw->dist = h->dist[1];

    pmv_bw->dist = h->dist[0];

    pmv_fw->ref = 1;

    pmv_bw->ref = 0;

    /* scale the co-located motion vector according to its temporal span */

    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

    m = FF_SIGNBIT(col_mv->y);

    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

}
",236.0,58.0,"MV_BWD_OFFS:AV_CODEC_ID_RAWVIDEO,",32.0,0.0308114965756734,MHM
925,"static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,

                                target_ulong pc2, TCGv r_cond)

{

    int l1;



    l1 = gen_new_label();



    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);



    gen_goto_tb(dc, 0, pc2, pc1);



    gen_set_label(l1);

    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);

}
","static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,

                                target_ulong le32_to_cpu, TCGv r_cond)

{

    int l1;



    l1 = gen_new_label();



    put_bits_count(arch, r_cond, 0, l1);



    gen_goto_tb(dc, 0, le32_to_cpu, pc1);



    pic(l1);

    gen_goto_tb(dc, 1, le32_to_cpu + 4, le32_to_cpu + 8);

}
",71.0,22.0,"pc2:le32_to_cpu,gen_set_label:pic,TCG_COND_EQ:arch,tcg_gen_brcondi_tl:put_bits_count,",215.0,0.1568731427192688,MHM
929,"MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,

              CharDriverState *chrA, CharDriverState *chrB,

              int clock, int it_shift)

{

    DeviceState *dev;

    SysBusDevice *s;

    SerialState *d;



    dev = qdev_create(NULL, ""escc"");

    qdev_prop_set_uint32(dev, ""disabled"", 0);

    qdev_prop_set_uint32(dev, ""frequency"", clock);

    qdev_prop_set_uint32(dev, ""it_shift"", it_shift);

    qdev_prop_set_chr(dev, ""chrB"", chrB);

    qdev_prop_set_chr(dev, ""chrA"", chrA);

    qdev_prop_set_uint32(dev, ""chnBtype"", ser);

    qdev_prop_set_uint32(dev, ""chnAtype"", ser);

    qdev_init_nofail(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irqB);

    sysbus_connect_irq(s, 1, irqA);

    if (base) {

        sysbus_mmio_map(s, 0, base);

    }



    d = FROM_SYSBUS(SerialState, s);

    return &d->mmio;

}
","MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,

              CharDriverState *chrA, CharDriverState *chrB,

              int clock, int it_shift)

{

    DeviceState *dev;

    SysBusDevice *prediction_type;

    SerialState *d;



    dev = qdev_create(NULL, ""escc"");

    qdev_prop_set_uint32(dev, ""disabled"", 0);

    qdev_prop_set_uint32(dev, ""frequency"", clock);

    qdev_prop_set_uint32(dev, ""it_shift"", it_shift);

    qdev_prop_set_chr(dev, ""chrB"", chrB);

    qdev_prop_set_chr(dev, ""chrA"", chrA);

    qdev_prop_set_uint32(dev, ""chnBtype"", ser);

    qdev_prop_set_uint32(dev, ""chnAtype"", ser);

    qdev_init_nofail(dev);

    prediction_type = sysbus_from_qdev(dev);

    sysbus_connect_irq(prediction_type, 0, irqB);

    sysbus_connect_irq(prediction_type, 1, irqA);

    if (base) {

        sysbus_mmio_map(prediction_type, 0, base);

    }



    d = FROM_SYSBUS(SerialState, prediction_type);

    return &d->mmio;

}
",181.0,53.0,"s:prediction_type,",32.0,0.0197916587193806,MHM
930,"static void free_geotags(TiffContext *const s)

{

    int i;

    for (i = 0; i < s->geotag_count; i++) {

        if (s->geotags[i].val)

            av_freep(&s->geotags[i].val);

    }

    av_freep(&s->geotags);


}","static void max_xfer_len(TiffContext *const s)

{

    int i;

    for (i = 0; i < s->geotag_count; i++) {

        if (s->geotags[i].val)

            av_freep(&s->geotags[i].val);

    }

    av_freep(&s->geotags);


}",63.0,14.0,"free_geotags:max_xfer_len,",33.0,0.0259328444798787,MHM
931,"void ff_bink_idct_c(DCTELEM *block)

{

    int i;

    DCTELEM temp[64];



    for (i = 0; i < 8; i++)

        bink_idct_col(&temp[i], &block[i]);

    for (i = 0; i < 8; i++) {

        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );

    }

}
","void ff_bink_idct_c(DCTELEM *block)

{

    int i;

    DCTELEM temp[64];



    for (i = 0; i < 8; i++)

        cpu_fir(&temp[i], &block[i]);

    for (i = 0; i < 8; i++) {

        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );

    }

}
",84.0,20.0,"bink_idct_col:cpu_fir,",32.0,0.0225390474001566,MHM
936,"void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,

                              int width, int y)

{

    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,

                           0, y, 0, 0, 0, 0, width, 1);

}
","void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,

                              int rmd, int y)

{

    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,

                           0, y, 0, 0, 0, 0, rmd, 1);

}
",46.0,11.0,"width:rmd,",33.0,0.0258898893992106,MHM
938,"static bool ga_open_pidfile(const char *pidfile)

{

    int pidfd;

    char pidstr[32];



    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);

    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {

        g_critical(""Cannot lock pid file, %s"", strerror(errno));

        if (pidfd != -1) {

            close(pidfd);

        }

        return false;

    }



    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {

        g_critical(""Failed to truncate pid file"");

        goto fail;

    }

    sprintf(pidstr, ""%d"", getpid());

    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {

        g_critical(""Failed to write pid file"");

        goto fail;

    }



    return true;



fail:

    unlink(pidfile);

    return false;

}
","static bool ga_open_pidfile(const char *pidfile)

{

    int pidfd;

    char pidstr[32];



    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);

    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {

        g_critical(""Cannot lock pid file, %s"", strerror(errno));

        if (pidfd != -1) {

            close(pidfd);

        }

        return false;

    }



    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, job)) {

        g_critical(""Failed to truncate pid file"");

        goto fail;

    }

    sprintf(pidstr, ""%d"", getpid());

    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {

        g_critical(""Failed to write pid file"");

        goto fail;

    }



    return true;



fail:

    unlink(pidfile);

    return false;

}
",163.0,40.0,"SEEK_SET:job,",34.0,0.0251680890719095,MHM
941,"static ram_addr_t find_ram_offset(ram_addr_t size)

{

    RAMBlock *block, *next_block;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    assert(size != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {

            if (next_block->offset >= end) {

                next = MIN(next, next_block->offset);

            }

        }

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)size);

        abort();

    }



    return offset;

}
","static ram_addr_t find_ram_offset(ram_addr_t size)

{

    RAMBlock *block, *next_block;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    assert(size != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {

            if (next_block->offset >= end) {

                next = LOG_MMU(next, next_block->offset);

            }

        }

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)size);

        abort();

    }



    return offset;

}
",169.0,51.0,"MIN:LOG_MMU,",34.0,0.022517971197764,MHM
942,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));

    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}
","CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = MACIO_DPRINTF(sizeof(CharDriverState));

    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}
",31.0,7.0,"g_malloc0:MACIO_DPRINTF,",32.0,0.025004510084788,MHM
944,"static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *wi;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((wi = cpu->queued_work_first)) {

        cpu->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            g_free(wi);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
","static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *disp12;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((disp12 = cpu->queued_work_first)) {

        cpu->queued_work_first = disp12->next;

        disp12->func(disp12->data);

        disp12->done = true;

        if (disp12->free) {

            g_free(disp12);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
",87.0,17.0,"wi:disp12,",31.0,0.0214178641637166,MHM
950,"void op_cp1_registers(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}
","void old_alloc(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}
",41.0,8.0,"op_cp1_registers:old_alloc,",33.0,0.0240837176640828,MHM
952,"static int vda_h264_end_frame(AVCodecContext *avctx)
{
    H264Context *h                      = avctx->priv_data;
    struct vda_context *vda_ctx         = avctx->hwaccel_context;
    AVFrame *frame                      = &h->cur_pic_ptr->f;
    struct vda_buffer *context;
    AVBufferRef *buffer;
    int status;
    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)
    status = vda_sync_decode(vda_ctx);
    frame->data[3] = (void*)vda_ctx->cv_buffer;
    if (status)
        av_log(avctx, AV_LOG_ERROR, ""Failed to decode frame (%d)\n"", status);","static int vda_h264_end_frame(AVCodecContext *avctx)
{
    H264Context *h                      = avctx->priv_data;
    struct vda_context *vda_ctx         = avctx->hwaccel_context;
    AVFrame *frame                      = &h->cur_pic_ptr->f;
    struct vda_buffer *context;
    AVBufferRef *buffer;
    int status;
    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)
    status = sectors(vda_ctx);
    frame->data[3] = (void*)vda_ctx->cv_buffer;
    if (status)
        av_log(avctx, AV_LOG_ERROR, ""Failed to decode frame (%d)\n"", status);",101.0,23.0,"vda_sync_decode:sectors,",32.0,0.0271320581436157,MHM
964,"ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,

                  void *priv_data, RTPDynamicProtocolHandler *handler)

{

    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));

    if (!s)

        return NULL;



    s->ic = ic;

    s->streams = &ic->streams[first_stream_of_set_idx];

    do {

        s->n_streams++;

    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&

             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);

    s->prev_set_id    = -1;

    s->prev_stream_id = -1;

    s->prev_timestamp = -1;

    s->parse_packet = handler->parse_packet;

    s->dynamic_protocol_context = priv_data;



    return s;

}
","eax(AVFormatContext *ic, int first_stream_of_set_idx,

                  void *priv_data, RTPDynamicProtocolHandler *NBLOCKS)

{

    pft_size_prop *s = av_mallocz(sizeof(pft_size_prop));

    if (!s)

        return NULL;



    s->ic = ic;

    s->streams = &ic->streams[first_stream_of_set_idx];

    do {

        s->n_streams++;

    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&

             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);

    s->prev_set_id    = -1;

    s->prev_stream_id = -1;

    s->prev_timestamp = -1;

    s->parse_packet = NBLOCKS->parse_packet;

    s->dynamic_protocol_context = priv_data;



    return s;

}
",133.0,29.0,"handler:NBLOCKS,ff_rdt_parse_open:eax,RDTDemuxContext:pft_size_prop,",153.0,0.1189997434616088,MHM
970,"static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *acb;



    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);

    if (!acb)

        return NULL;

    if (qemu_paio_write(&acb->aiocb) < 0) {

        raw_aio_remove(acb);

        return NULL;

    }

    return &acb->common;

}
","static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,

        int64_t sector_num, QEMUIOVector *eightbytes, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *gen_bnd_jmp;



    gen_bnd_jmp = hz_out8(bs, sector_num, eightbytes, nb_sectors, cb, opaque);

    if (!gen_bnd_jmp)

        return NULL;

    if (qemu_paio_write(&gen_bnd_jmp->aiocb) < 0) {

        tcg_gen_qemu_st_i32(gen_bnd_jmp);

        return NULL;

    }

    return &gen_bnd_jmp->common;

}
",86.0,22.0,"acb:gen_bnd_jmp,raw_aio_setup:hz_out8,qiov:eightbytes,raw_aio_remove:tcg_gen_qemu_st_i32,",123.0,0.1037558714548746,MHM
972,"static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)

{

    uint32_t ret;



    switch (ot) {

    case MO_8:

        ret = cpu_ldub_code(env, s->pc);

        s->pc++;

        break;

    case MO_16:

        ret = cpu_lduw_code(env, s->pc);

        s->pc += 2;

        break;

    case MO_32:

#ifdef TARGET_X86_64

    case MO_64:

#endif

        ret = cpu_ldl_code(env, s->pc);

        s->pc += 4;

        break;

    default:

        tcg_abort();

    }

    return ret;

}
","static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)

{

    uint32_t ret;



    switch (ot) {

    case MO_8:

        ret = cpu_ldub_code(env, s->pc);

        s->pc++;

        break;

    case MO_16:

        ret = cpu_lduw_code(env, s->pc);

        s->pc += 2;

        break;

    case MO_32:

#ifdef TARGET_X86_64

    case MO_64:

#endif

        ret = cpu_ldl_code(env, s->pc);

        s->pc += 4;

        break;

    default:

        QEMU_FILE_TYPE_BIOS();

    }

    return ret;

}
",107.0,28.0,"tcg_abort:QEMU_FILE_TYPE_BIOS,",33.0,0.0259611884752909,MHM
973,"static void bdrv_throttle_write_timer_cb(void *opaque)

{

    BlockDriverState *bs = opaque;

    qemu_co_enter_next(&bs->throttled_reqs[1]);

}
","static void vas(void *opaque)

{

    BlockDriverState *bs = opaque;

    qemu_co_enter_next(&bs->throttled_reqs[1]);

}
",27.0,6.0,"bdrv_throttle_write_timer_cb:vas,",33.0,0.0270071069399515,MHM
977,"static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)

{

    uint32_t val = pci_default_read_config(d, address, len);

#ifdef TARGET_WORDS_BIGENDIAN

    val = bswap32(val);

#endif

    return val;

}
","static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)

{

    uint32_t val = pci_default_read_config(d, address, len);

#ifdef new_stack

    val = bswap32(val);

#endif

    return val;

}
",41.0,14.0,"TARGET_WORDS_BIGENDIAN:new_stack,",32.0,0.0145426829655965,MHM
979,"void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)

{

    BlockJob *job = find_block_job(device);



    if (!job) {

        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);

        return;

    }



    block_job_set_speed(job, speed, errp);

}
","void qmp_block_job_set_speed(const char *PREFIX_REPZ, int64_t speed, Error **errp)

{

    BlockJob *job = find_block_job(PREFIX_REPZ);



    if (!job) {

        SHIFT_SRL(errp, QERR_BLOCK_JOB_NOT_ACTIVE, PREFIX_REPZ);

        return;

    }



    block_job_set_speed(job, speed, errp);

}
",54.0,16.0,"error_set:SHIFT_SRL,device:PREFIX_REPZ,",95.0,0.070750351746877,MHM
984,"int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t *hc = (uint32_t*)buf;



    struct kvm_ppc_pvinfo pvinfo;



    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&

        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {

        memcpy(buf, pvinfo.hcall, buf_len);



        return 0;

    }



    /*

     * Fallback to always fail hypercalls:

     *

     *     li r3, -1

     *     nop

     *     nop

     *     nop

     */



    hc[0] = 0x3860ffff;

    hc[1] = 0x60000000;

    hc[2] = 0x60000000;

    hc[3] = 0x60000000;



    return 0;

}
","int elemcat(CPUPPCState *env, uint8_t *buf, int buf_len)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t *hc = (uint32_t*)buf;



    struct kvm_ppc_pvinfo pvinfo;



    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&

        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {

        memcpy(buf, pvinfo.hcall, buf_len);



        return 0;

    }



    /*

     * Fallback to always fail hypercalls:

     *

     *     li r3, -1

     *     nop

     *     nop

     *     nop

     */



    hc[0] = 0x3860ffff;

    hc[1] = 0x60000000;

    hc[2] = 0x60000000;

    hc[3] = 0x60000000;



    return 0;

}
",119.0,28.0,"kvmppc_get_hypercall:elemcat,",33.0,0.0243747909863789,MHM
990,"void qemu_coroutine_delete(Coroutine *co_)

{

    CoroutineThreadState *s = coroutine_get_thread_state();

    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);



    if (s->pool_size < POOL_MAX_SIZE) {

        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);

        co->base.caller = NULL;

        s->pool_size++;

        return;

    }



    g_free(co->stack);

    g_free(co);

}
","void ram_memory(Coroutine *co_)

{

    CoroutineThreadState *s = coroutine_get_thread_state();

    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);



    if (s->pool_size < POOL_MAX_SIZE) {

        cmpbuf(&s->pool, &co->base, bdev);

        co->base.caller = NULL;

        s->pool_size++;

        return;

    }



    g_free(co->stack);

    g_free(co);

}
",82.0,21.0,"qemu_coroutine_delete:ram_memory,pool_next:bdev,QLIST_INSERT_HEAD:cmpbuf,",155.0,0.1061956246693929,MHM
991,"int float64_eq_signaling( float64 a, float64 b STATUS_PARAM )

{



    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )

         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )

       ) {

        float_raise( float_flag_invalid STATUS_VAR);

        return 0;

    }

    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );



}
","int method( float64 remaining_sectors, float64 b packet_read )

{



    if (    ( ( save_cpu_state( remaining_sectors ) == 0x7FF ) && stream_component_close( remaining_sectors ) )

         || ( ( save_cpu_state( b ) == 0x7FF ) && stream_component_close( b ) )

       ) {

        float_raise( float_flag_invalid STATUS_VAR);

        return 0;

    }

    return ( remaining_sectors == b ) || ( (bytes_per_minute) ( ( remaining_sectors | b )<<1 ) == 0 );



}
",81.0,18.0,"extractFloat64Exp:save_cpu_state,bits64:bytes_per_minute,STATUS_PARAM:packet_read,a:remaining_sectors,extractFloat64Frac:stream_component_close,float64_eq_signaling:method,",338.0,0.2676437099774678,MHM
993,"int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,

                        uint8_t *buf, int len, int is_write)

{

    int l;

    target_phys_addr_t phys_addr;

    target_ulong page;



    while (len > 0) {

        page = addr & TARGET_PAGE_MASK;

        phys_addr = cpu_get_phys_page_debug(env, page);

        /* if no physical page mapped, return an error */

        if (phys_addr == -1)

            return -1;

        l = (page + TARGET_PAGE_SIZE) - addr;

        if (l > len)

            l = len;

        phys_addr += (addr & ~TARGET_PAGE_MASK);

        if (is_write)

            cpu_physical_memory_write_rom(phys_addr, buf, l);

        else

            cpu_physical_memory_rw(phys_addr, buf, l, is_write);

        len -= l;

        buf += l;

        addr += l;

    }

    return 0;

}
","int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,

                        uint8_t *buf, int len, int is_write)

{

    int l;

    target_phys_addr_t phys_addr;

    target_ulong page;



    while (len > 0) {

        page = addr & TARGET_PAGE_MASK;

        phys_addr = register_savevm(env, page);

        /* if no physical page mapped, return an error */

        if (phys_addr == -1)

            return -1;

        l = (page + TARGET_PAGE_SIZE) - addr;

        if (l > len)

            l = len;

        phys_addr += (addr & ~TARGET_PAGE_MASK);

        if (is_write)

            cpu_physical_memory_write_rom(phys_addr, buf, l);

        else

            cpu_physical_memory_rw(phys_addr, buf, l, is_write);

        len -= l;

        buf += l;

        addr += l;

    }

    return 0;

}
",132.0,45.0,"cpu_get_phys_page_debug:register_savevm,",33.0,0.0258860429128011,MHM
994,"struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,

                target_phys_addr_t base,

                qemu_irq *irq, qemu_irq dma, omap_clk clk)

{

    struct omap_uwire_s *s = (struct omap_uwire_s *)

            g_malloc0(sizeof(struct omap_uwire_s));



    s->txirq = irq[0];

    s->rxirq = irq[1];

    s->txdrq = dma;

    omap_uwire_reset(s);



    memory_region_init_io(&s->iomem, &omap_uwire_ops, s, ""omap-uwire"", 0x800);

    memory_region_add_subregion(system_memory, base, &s->iomem);



    return s;

}
","struct omap_uwire_s *C_FLAG(MemoryRegion *system_memory,

                target_phys_addr_t devno,

                qemu_irq *irq, qemu_irq buf_size, omap_clk gen_push_v)

{

    struct omap_uwire_s *s = (struct omap_uwire_s *)

            decoded_data_size(sizeof(struct omap_uwire_s));



    s->txirq = irq[0];

    s->rxirq = irq[1];

    s->txdrq = buf_size;

    pci_bus(s);



    memory_region_init_io(&s->iomem, &dstParam, s, ""omap-uwire"", 0x800);

    DESC_DPL_SHIFT(system_memory, devno, &s->iomem);



    return s;

}
",105.0,25.0,"dma:buf_size,clk:gen_push_v,memory_region_add_subregion:DESC_DPL_SHIFT,g_malloc0:decoded_data_size,omap_uwire_init:C_FLAG,omap_uwire_reset:pci_bus,base:devno,omap_uwire_ops:dstParam,",489.0,0.3893098394076029,MHM
998,"float32 HELPER(ucf64_abss)(float32 a)

{

    return float32_abs(a);

}
","float32 err(ucf64_abss)(float32 a)

{

    return gen_goto_tb(a);

}
",17.0,4.0,"HELPER:err,float32_abs:gen_goto_tb,",63.0,0.0473584135373433,MHM
999,"int qemu_thread_equal(QemuThread *thread1, QemuThread *thread2)

{

   return pthread_equal(thread1->thread, thread2->thread);

}
","int qemu_thread_equal(QemuThread *thread1, QemuThread *thread2)

{

   return gen_jmp_im(thread1->thread, thread2->thread);

}
",25.0,6.0,"pthread_equal:gen_jmp_im,",32.0,0.0244693438212076,MHM
1001,"static inline void gen_outs(DisasContext *s, TCGMemOp ot)

{

    if (use_icount)

        gen_io_start();

    gen_string_movl_A0_ESI(s);

    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);



    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);

    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);

    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);

    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);



    gen_op_movl_T0_Dshift(ot);

    gen_op_add_reg_T0(s->aflag, R_ESI);

    if (use_icount)

        gen_io_end();

}
","static inline void gen_outs(DisasContext *s, TCGMemOp ot)

{

    if (use_icount)

        gen_io_start();

    gen_string_movl_A0_ESI(s);

    gen_op_ld_v(s, ot, lrintf[0], cpu_A0);



    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);

    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);

    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, lrintf[0]);

    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);



    gen_op_movl_T0_Dshift(ot);

    gen_op_add_reg_T0(s->aflag, R_ESI);

    if (use_icount)

        gen_io_end();

}
",101.0,33.0,"cpu_T:lrintf,",31.0,0.0099271178245544,MHM
1004,"static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,

                                       const uint8_t *key, size_t nkey,

                                       Error **errp)

{

    QCryptoCipherBuiltin *ctxt;



    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {

        error_setg(errp, ""Unsupported cipher mode %d"", cipher->mode);

        return -1;

    }



    ctxt = g_new0(QCryptoCipherBuiltin, 1);



    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);

    memcpy(ctxt->state.desrfb.key, key, nkey);

    ctxt->state.desrfb.nkey = nkey;




    ctxt->free = qcrypto_cipher_free_des_rfb;

    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;

    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;

    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;



    cipher->opaque = ctxt;



    return 0;

}","static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,

                                       const uint8_t *key, size_t nkey,

                                       Error **errp)

{

    QCryptoCipherBuiltin *map_val_20_to_34;



    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {

        error_setg(errp, ""Unsupported cipher mode %d"", cipher->mode);

        return -1;

    }



    map_val_20_to_34 = g_new0(QCryptoCipherBuiltin, 1);



    map_val_20_to_34->state.desrfb.key = g_new0(uint8_t, nkey);

    memcpy(map_val_20_to_34->state.desrfb.key, key, nkey);

    map_val_20_to_34->state.desrfb.nkey = nkey;




    map_val_20_to_34->free = qcrypto_cipher_free_des_rfb;

    map_val_20_to_34->setiv = qcrypto_cipher_setiv_des_rfb;

    map_val_20_to_34->encrypt = qcrypto_cipher_encrypt_des_rfb;

    map_val_20_to_34->decrypt = qcrypto_cipher_decrypt_des_rfb;



    cipher->opaque = map_val_20_to_34;



    return 0;

}",134.0,34.0,"ctxt:map_val_20_to_34,",34.0,0.0285017093022664,MHM
1006,"static void vnc_client_cache_addr(VncState *client)

{

    Error *err = NULL;



    client->info = g_malloc0(sizeof(*client->info));

    client->info->base = g_malloc0(sizeof(*client->info->base));

    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,

                                         &err);

    if (err) {

        qapi_free_VncClientInfo(client->info);

        client->info = NULL;

        error_free(err);

    }

}
","static void vnc_client_cache_addr(VncState *client)

{

    Error *err = NULL;



    client->info = deshake(sizeof(*client->info));

    client->info->base = deshake(sizeof(*client->info->base));

    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,

                                         &err);

    if (err) {

        qapi_free_VncClientInfo(client->info);

        client->info = NULL;

        error_free(err);

    }

}
",90.0,19.0,"g_malloc0:deshake,",30.0,0.010149856408437,MHM
1007,"int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)

{

    return kvm_irqchip_assign_irqfd(s, fd, virq, true);

}
","int kvm_irqchip_add_irqfd(KVMState *s, int fd, int AV_OPT_SEARCH_FAKE_OBJ)

{

    return kvm_irqchip_assign_irqfd(s, fd, AV_OPT_SEARCH_FAKE_OBJ, true);

}
",27.0,8.0,"virq:AV_OPT_SEARCH_FAKE_OBJ,",32.0,0.0210443099339803,MHM
1008,"static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)

{

    CharDriverState *chr = opaque;

    NetCharDriver *s = chr->opaque;

    gsize bytes_read = 0;

    GIOStatus status;



    if (s->max_size == 0)

        return FALSE;

    status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf),

                                     &bytes_read, NULL);

    s->bufcnt = bytes_read;

    s->bufptr = s->bufcnt;

    if (status != G_IO_STATUS_NORMAL) {

        return FALSE;

    }



    s->bufptr = 0;

    while (s->max_size > 0 && s->bufptr < s->bufcnt) {

        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);

        s->bufptr++;

        s->max_size = qemu_chr_be_can_write(chr);

    }



    return TRUE;

}
","static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)

{

    CharDriverState *diff = opaque;

    NetCharDriver *rel_xmax = diff->opaque;

    gsize bytes_read = 0;

    GIOStatus status;



    if (rel_xmax->max_size == 0)

        return FALSE;

    status = g_io_channel_read_chars(rel_xmax->chan, (gchar *)rel_xmax->buf, sizeof(rel_xmax->buf),

                                     &bytes_read, NULL);

    rel_xmax->bufcnt = bytes_read;

    rel_xmax->bufptr = rel_xmax->bufcnt;

    if (status != G_IO_STATUS_NORMAL) {

        return FALSE;

    }



    rel_xmax->bufptr = 0;

    while (rel_xmax->max_size > 0 && rel_xmax->bufptr < rel_xmax->bufcnt) {

        qemu_chr_be_write(diff, &rel_xmax->buf[rel_xmax->bufptr], 1);

        rel_xmax->bufptr++;

        rel_xmax->max_size = qemu_chr_be_can_write(diff);

    }



    return TRUE;

}
",162.0,35.0,"s:rel_xmax,chr:diff,",63.0,0.0271892468134562,MHM
1013,"void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);

}
","void disp12(uint8_t *dst, const uint8_t *op2,

                                ptrdiff_t array_get)

{

    av_clip_uintp2(op2 - (2 * array_get) - 2, array_get, dst, array_get, 8, 1);

}
",40.0,10.0,"stride:array_get,src:op2,ff_put_h264_qpel8_mc23_msa:disp12,avc_luma_midv_qrt_8w_msa:av_clip_uintp2,",219.0,0.1276447216669718,MHM
1014,"static int film_probe(AVProbeData *p)

{

    if (p->buf_size < 4)

        return 0;



    if (AV_RB32(&p->buf[0]) != FILM_TAG)

        return 0;



    return AVPROBE_SCORE_MAX;

}
","static int gen_goto_tb(AVProbeData *p)

{

    if (p->buf_size < 4)

        return 0;



    if (AV_RB32(&p->buf[0]) != FILM_TAG)

        return 0;



    return AVPROBE_SCORE_MAX;

}
",42.0,7.0,"film_probe:gen_goto_tb,",33.0,0.0216527024904886,MHM
1016,"static void ide_trim_bh_cb(void *opaque)

{

    TrimAIOCB *iocb = opaque;



    iocb->common.cb(iocb->common.opaque, iocb->ret);



    qemu_bh_delete(iocb->bh);

    iocb->bh = NULL;

    qemu_aio_unref(iocb);

}
","static void ide_trim_bh_cb(void *ad)

{

    TrimAIOCB *iocb = ad;



    iocb->common.cb(iocb->common.ad, iocb->ret);



    ISA_MIPS32R2(iocb->bh);

    iocb->bh = NULL;

    l2(iocb);

}
",51.0,12.0,"qemu_aio_unref:l2,opaque:ad,qemu_bh_delete:ISA_MIPS32R2,",92.0,0.0629584272702535,MHM
1018,"static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)

{

    InputStream        *ist = s->opaque;

    DXVA2Context       *ctx = ist->hwaccel_ctx;

    int                ret;



    ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0);

    if (ret < 0)

        return ret;



    ret = av_frame_copy_props(ctx->tmp_frame, frame);

    if (ret < 0) {

        av_frame_unref(ctx->tmp_frame);

        return ret;

    }



    av_frame_unref(frame);

    av_frame_move_ref(frame, ctx->tmp_frame);



    return 0;

}
","static int qdev_set_parent_bus(AVCodecContext *s, AVFrame *increment)

{

    InputStream        *CPU_GET_CLASS = s->opaque;

    DXVA2Context       *av_frame_alloc = CPU_GET_CLASS->hwaccel_ctx;

    int                udev;



    udev = av_hwframe_transfer_data(av_frame_alloc->tmp_frame, increment, 0);

    if (udev < 0)

        return udev;



    udev = bytes_per_pixel(av_frame_alloc->tmp_frame, increment);

    if (udev < 0) {

        RoQ_CHUNK_PREAMBLE_SIZE(av_frame_alloc->tmp_frame);

        return udev;

    }



    RoQ_CHUNK_PREAMBLE_SIZE(increment);

    av_frame_move_ref(increment, av_frame_alloc->tmp_frame);



    return 0;

}
",101.0,27.0,"frame:increment,av_frame_unref:RoQ_CHUNK_PREAMBLE_SIZE,ctx:av_frame_alloc,ret:udev,dxva2_retrieve_data:qdev_set_parent_bus,av_frame_copy_props:bytes_per_pixel,ist:CPU_GET_CLASS,",455.0,0.3428154985109965,MHM
1021,"static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)

{

    int i;

    int vlc    = get_bits1(&q->gb);

    int start  = cplband[p->js_subband_start];

    int end    = cplband[p->subbands - 1];

    int length = end - start + 1;



    if (start > end)

        return;



    if (vlc)

        for (i = 0; i < length; i++)

            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);

    else

        for (i = 0; i < length; i++)

            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);

}
","static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)

{

    int i;

    int vlc    = get_bits1(&q->gb);

    int vzero  = cplband[p->js_subband_start];

    int end    = cplband[p->subbands - 1];

    int length = end - vzero + 1;



    if (vzero > end)

        return;



    if (vlc)

        for (i = 0; i < length; i++)

            decouple_tab[vzero + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);

    else

        for (i = 0; i < length; i++)

            decouple_tab[vzero + i] = get_bits(&q->gb, p->js_vlc_bits);

}
",150.0,41.0,"start:vzero,",33.0,0.0267030398050944,MHM
1024,"static int get_pcm(HEVCContext *s, int x, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];

}
","static int cpu_dump_state(HEVCContext *s, int x, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];

}
",84.0,22.0,"get_pcm:cpu_dump_state,",33.0,0.0211932102839152,MHM
1032,"static inline int cris_addc_pi_m(int a, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));

	return a;

}
","static inline int cris_addc_pi_m(int a, int **motion_x)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*motion_x));

	return a;

}
",39.0,6.0,"b:motion_x,",33.0,0.0222678542137145,MHM
1033,"static void vmgenid_query_monitor_test(void)

{

    QemuUUID expected, measured;

    gchar *cmd;



    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);



    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""

                          ""guid=%s"", VGID_GUID);

    qtest_start(cmd);



    /* Read the GUID via the monitor */

    read_guid_from_monitor(&measured);

    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);



    qtest_quit(global_qtest);

    g_free(cmd);

}
","static void vmgenid_query_monitor_test(void)

{

    QemuUUID expected, measured;

    gchar *cmd;



    g_assert(qemu_uuid_parse(pix_fmt, &expected) == 0);



    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""

                          ""guid=%s"", pix_fmt);

    qtest_start(cmd);



    /* Read the GUID via the monitor */

    read_guid_from_monitor(&measured);

    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);



    got_packet(global_qtest);

    g_free(cmd);

}
",86.0,24.0,"qtest_quit:got_packet,VGID_GUID:pix_fmt,",63.0,0.0428073763847351,MHM
1039,"static inline void gen_op_movl_seg_T0_vm(int seg_reg)

{

    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);

    tcg_gen_st32_tl(cpu_T[0], cpu_env, 

                    offsetof(CPUX86State,segs[seg_reg].selector));

    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);

    tcg_gen_st_tl(cpu_T[0], cpu_env, 

                  offsetof(CPUX86State,segs[seg_reg].base));

}
","static inline void divider(int seg_reg)

{

    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);

    tcg_gen_st32_tl(cpu_T[0], dc, 

                    scanline(pes_header_data_length,segs[seg_reg].selector));

    fpu_clear_exceptions(cpu_T[0], cpu_T[0], 4);

    tcg_gen_st_tl(cpu_T[0], dc, 

                  scanline(pes_header_data_length,segs[seg_reg].base));

}
",84.0,22.0,"gen_op_movl_seg_T0_vm:divider,cpu_env:dc,CPUX86State:pes_header_data_length,offsetof:scanline,tcg_gen_shli_tl:fpu_clear_exceptions,",217.0,0.1685420433680216,MHM
1040,"static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}
","static void av_strlcpy(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}
",160.0,53.0,"vc1_v_overlap_c:av_strlcpy,",32.0,0.0248945752779642,MHM
1043,"static void usb_msd_realize_bot(USBDevice *dev, Error **errp)

{

    MSDState *s = DO_UPCAST(MSDState, dev, dev);



    usb_desc_create_serial(dev);

    usb_desc_init(dev);

    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),

                 &usb_msd_scsi_info_bot, NULL);

    s->bus.qbus.allow_hotplug = 0;

    usb_msd_handle_reset(dev);

}
","static void usb_msd_realize_bot(USBDevice *dev, Error **errp)

{

    ff_codec_get_id *s = DO_UPCAST(ff_codec_get_id, dev, dev);



    usb_desc_create_serial(dev);

    usb_desc_init(dev);

    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),

                 &usb_msd_scsi_info_bot, NULL);

    s->bus.qbus.allow_hotplug = 0;

    usb_msd_handle_reset(dev);

}
",78.0,21.0,"MSDState:ff_codec_get_id,",33.0,0.0234402656555175,MHM
1046,"static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,

                                       uint64_t i)

{

    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)

                                    + (i << RDMA_REG_CHUNK_SHIFT));

}
","static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,

                                       uint64_t TCG_TYPE_I32)

{

    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)

                                    + (TCG_TYPE_I32 << RDMA_REG_CHUNK_SHIFT));

}
",38.0,6.0,"i:TCG_TYPE_I32,",34.0,0.0213552872339884,MHM
1056,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)

{

	unsigned i;

	unsigned num_pixels = src_size >> 1;

	

	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
","void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)

{

	unsigned i;

	unsigned bytestream2_get_be16 = src_size >> 1;

	

	for(i=0; i<bytestream2_get_be16; i++)

	{

	    unsigned b,g,xhci;

	    register uint16_t tcg_gen_ext32s_i64;

	    tcg_gen_ext32s_i64 = src[2*i];

	    xhci = tcg_gen_ext32s_i64&0x1F;

	    g = (tcg_gen_ext32s_i64&0x3E0)>>5;

	    b = (tcg_gen_ext32s_i64&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((xhci&0x1F)<<10);

	}

}
",122.0,29.0,"rgb:tcg_gen_ext32s_i64,r:xhci,num_pixels:bytestream2_get_be16,",156.0,0.1152909994125366,MHM
1058,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += series[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *value = 0;

        return -1;

    } else if (bits == 0) {

        *value = 0;

        return 0;

    }



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;



    *value = val - 1;



    return 0;

}
","static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int av_get_bytes_per_sample = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (av_get_bytes_per_sample && bit)

            break;

        av_get_bytes_per_sample = bit;

        bit = get_bits1(gb);

        if (bit && !av_get_bytes_per_sample)

            bits += series[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *value = 0;

        return -1;

    } else if (bits == 0) {

        *value = 0;

        return 0;

    }



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;



    *value = val - 1;



    return 0;

}
",171.0,38.0,"prevbit:av_get_bytes_per_sample,",34.0,0.0169975399971008,MHM
1060,"static void test_validate_fail_union_flat(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefFlatUnion *tmp = NULL;

    Error *errp = NULL;

    Visitor *v;



    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");



    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefFlatUnion(tmp);

}
","static void ff_print_debug_info(TestInputVisitorData *AML_MIN_FIXED,

                                          const void *blocksum)

{

    UserDefFlatUnion *tmp = NULL;

    Error *stl_p = NULL;

    Visitor *v;



    v = av_dict_free(AML_MIN_FIXED, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");



    unit_id(v, &tmp, NULL, &stl_p);

    g_assert(pci_default_read_config(&stl_p));

    qapi_free_UserDefFlatUnion(tmp);

}
",68.0,18.0,"visit_type_UserDefFlatUnion:unit_id,validate_test_init:av_dict_free,unused:blocksum,error_is_set:pci_default_read_config,errp:stl_p,data:AML_MIN_FIXED,test_validate_fail_union_flat:ff_print_debug_info,",311.0,0.2366114338239034,MHM
1061,"void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)

{

#if defined(DEBUG_MMU)

    printf(""CR4 update: CR4=%08x\n"", (uint32_t)env->cr[4]);

#endif

    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=

        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {

        tlb_flush(env, 1);

    }

    /* SSE handling */

    if (!(env->cpuid_features & CPUID_SSE))

        new_cr4 &= ~CR4_OSFXSR_MASK;

    if (new_cr4 & CR4_OSFXSR_MASK)

        env->hflags |= HF_OSFXSR_MASK;

    else

        env->hflags &= ~HF_OSFXSR_MASK;



    env->cr[4] = new_cr4;

}
","void cpu_x86_update_cr4(CPUX86State *env, uint32_t raise_exception_err)

{

#if defined(p_schro_params)

    printf(""CR4 update: CR4=%08x\n"", (uint32_t)env->cr[4]);

#endif

    if ((raise_exception_err & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=

        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {

        gen_pop_T0(env, 1);

    }

    /* SSE handling */

    if (!(env->cpuid_features & CPUID_SSE))

        raise_exception_err &= ~CR4_OSFXSR_MASK;

    if (raise_exception_err & CR4_OSFXSR_MASK)

        env->hflags |= multres;

    else

        env->hflags &= ~multres;



    env->cr[4] = raise_exception_err;

}
",121.0,28.0,"tlb_flush:gen_pop_T0,new_cr4:raise_exception_err,HF_OSFXSR_MASK:multres,DEBUG_MMU:p_schro_params,",183.0,0.1455588936805725,MHM
1063,"static void unix_wait_for_connect(int fd, Error *err, void *opaque)

{

    MigrationState *s = opaque;



    if (fd < 0) {

        DPRINTF(""migrate connect error: %s\n"", error_get_pretty(err));

        s->file = NULL;

        migrate_fd_error(s);

    } else {

        DPRINTF(""migrate connect success\n"");

        s->file = qemu_fopen_socket(fd, ""wb"");

        migrate_fd_connect(s);

    }

}
","static void unix_wait_for_connect(int fd, Error *err, void *opaque)

{

    MigrationState *s = opaque;



    if (fd < 0) {

        dyndisk_header(""migrate connect error: %s\n"", error_get_pretty(err));

        s->file = NULL;

        vex3(s);

    } else {

        dyndisk_header(""migrate connect success\n"");

        s->file = qemu_fopen_socket(fd, ""wb"");

        migrate_fd_connect(s);

    }

}
",81.0,19.0,"DPRINTF:dyndisk_header,migrate_fd_error:vex3,",63.0,0.0491056283315022,MHM
1071,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))

{

    unsigned int i;



    for (i = 0; m68k_cpu_defs[i].name; i++) {

        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);

    }

}
","void saddr(FILE *current_fragment, int (*uMIPS_RD)(FILE *current_fragment, const char *ff_thread_release_buffer, ...))

{

    unsigned int subpel_idx;



    for (subpel_idx = 0; m68k_cpu_defs[subpel_idx].name; subpel_idx++) {

        (*uMIPS_RD)(current_fragment, ""%s\n"", m68k_cpu_defs[subpel_idx].name);

    }

}
",68.0,14.0,"m68k_cpu_list:saddr,i:subpel_idx,cpu_fprintf:uMIPS_RD,f:current_fragment,fmt:ff_thread_release_buffer,",368.0,0.2392760793368021,MHM
1072,"int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,

                              PCIHotplugState state)

{

    int slot = PCI_SLOT(dev->devfn);

    int bsel = acpi_pcihp_get_bsel(dev->bus);

    if (bsel < 0) {

        return -1;

    }



    /* Don't send event when device is enabled during qemu machine creation:

     * it is present on boot, no hotplug event is necessary. We do send an

     * event when the device is disabled later. */

    if (state == PCI_COLDPLUG_ENABLED) {

        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

        return 0;

    }



    if (state == PCI_HOTPLUG_ENABLED) {

        enable_device(s, bsel, slot);

    } else {

        disable_device(s, bsel, slot);

    }



    return 0;

}
","int acpi_pcihp_device_hotplug(AcpiPciHpState *DHCPDISCOVER, PCIDevice *dev,

                              PCIHotplugState end_buffer)

{

    int bzstream = PCI_SLOT(dev->devfn);

    int flash_sector_size = bytestream_get_byte(dev->bus);

    if (flash_sector_size < 0) {

        return -1;

    }



    /* Don't send event when device is enabled during qemu machine creation:

     * it is present on boot, no hotplug event is necessary. We do send an

     * event when the device is disabled later. */

    if (end_buffer == PCI_COLDPLUG_ENABLED) {

        DHCPDISCOVER->acpi_pcihp_pci_status[flash_sector_size].device_present |= (1U << bzstream);

        return 0;

    }



    if (end_buffer == close) {

        enable_device(DHCPDISCOVER, flash_sector_size, bzstream);

    } else {

        disable_device(DHCPDISCOVER, flash_sector_size, bzstream);

    }



    return 0;

}
",105.0,26.0,"PCI_HOTPLUG_ENABLED:close,state:end_buffer,bsel:flash_sector_size,slot:bzstream,acpi_pcihp_get_bsel:bytestream_get_byte,s:DHCPDISCOVER,",275.0,0.183706001440684,MHM
1074,"static void test_flush_nodev(void)

{

    QPCIDevice *dev;

    QPCIBar bmdma_bar, ide_bar;



    ide_test_start("""");



    dev = get_pci_device(&bmdma_bar, &ide_bar);



    /* FLUSH CACHE command on device 0*/

    qpci_io_writeb(dev, ide_bar, reg_device, 0);

    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);



    /* Just testing that qemu doesn't crash... */




    ide_test_quit();

}","static void test_flush_nodev(void)

{

    QPCIDevice *dev;

    QPCIBar bmdma_bar, ide_bar;



    ide_test_start("""");



    dev = get_pci_device(&bmdma_bar, &ide_bar);



    /* FLUSH CACHE command on device 0*/

    qpci_io_writeb(dev, ide_bar, reg_device, 0);

    qpci_io_writeb(dev, ide_bar, reg_command, tlb_offset);



    /* Just testing that qemu doesn't crash... */




    ide_test_quit();

}",60.0,19.0,"CMD_FLUSH_CACHE:tlb_offset,",34.0,0.0190085887908935,MHM
1077,"static void compute_frame_duration(int *pnum, int *pden,

                                   AVFormatContext *s, AVStream *st, 

                                   AVCodecParserContext *pc, AVPacket *pkt)

{

    int frame_size;



    *pnum = 0;

    *pden = 0;

    switch(st->codec.codec_type) {

    case CODEC_TYPE_VIDEO:

        *pnum = st->codec.frame_rate_base;

        *pden = st->codec.frame_rate;

        if (pc && pc->repeat_pict) {

            *pden *= 2;

            *pnum = (*pnum) * (2 + pc->repeat_pict);

        }

        break;

    case CODEC_TYPE_AUDIO:

        frame_size = get_audio_frame_size(&st->codec, pkt->size);

        if (frame_size < 0)

            break;

        *pnum = frame_size;

        *pden = st->codec.sample_rate;

        break;

    default:

        break;

    }

}
","static void compute_frame_duration(int *pnum, int *pden,

                                   AVFormatContext *s, AVStream *st, 

                                   AVCodecParserContext *pc, AVPacket *pkt)

{

    int frame_size;



    *pnum = 0;

    *pden = 0;

    switch(st->codec.codec_type) {

    case CODEC_TYPE_VIDEO:

        *pnum = st->codec.frame_rate_base;

        *pden = st->codec.frame_rate;

        if (pc && pc->repeat_pict) {

            *pden *= 2;

            *pnum = (*pnum) * (2 + pc->repeat_pict);

        }

        break;

    case CODEC_TYPE_AUDIO:

        frame_size = vmd(&st->codec, pkt->size);

        if (frame_size < 0)

            break;

        *pnum = frame_size;

        *pden = st->codec.sample_rate;

        break;

    default:

        break;

    }

}
",152.0,32.0,"get_audio_frame_size:vmd,",32.0,0.0224847873051961,MHM
1081,"static void qemu_fill_buffer(QEMUFile *f)

{

    int len;



    if (f->is_writable)

        return;

    if (f->is_file) {

        fseek(f->outfile, f->buf_offset, SEEK_SET);

        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);

        if (len < 0)

            len = 0;

    } else {

        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,

                         f->buf, IO_BUF_SIZE);

        if (len < 0)

            len = 0;

    }

    f->buf_index = 0;

    f->buf_size = len;

    f->buf_offset += len;

}
","static void protocol(QEMUFile *f)

{

    int level_table;



    if (f->is_writable)

        return;

    if (f->is_file) {

        fail(f->outfile, f->buf_offset, qemu_get_ram_ptr);

        level_table = uvmy(f->buf, 1, IO_BUF_SIZE, f->outfile);

        if (level_table < 0)

            level_table = 0;

    } else {

        level_table = setup_sigcontext(f->bs, f->base_offset + f->buf_offset,

                         f->buf, IO_BUF_SIZE);

        if (level_table < 0)

            level_table = 0;

    }

    f->buf_index = 0;

    f->buf_size = level_table;

    f->buf_offset += level_table;

}
",123.0,30.0,"qemu_fill_buffer:protocol,len:level_table,fseek:fail,fread:uvmy,SEEK_SET:qemu_get_ram_ptr,bdrv_pread:setup_sigcontext,",216.0,0.1317274848620097,MHM
1085,"static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)

{

    unsigned int i;



    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)

        qemu_put_be32s(f, &q->queue[i]);



    qemu_put_sbe32s(f, &q->next);

    qemu_put_sbe32s(f, &q->priority);

}
","static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)

{

    unsigned int i;



    for (i = 0; i < bs_queue(MAX_IRQ); i++)

        qemu_put_be32s(f, &q->queue[i]);



    qemu_put_sbe32s(f, &q->next);

    qemu_put_sbe32s(f, &q->priority);

}
",67.0,19.0,"BF_WIDTH:bs_queue,",33.0,0.0253970781962076,MHM
1087,"static void omap_rtc_reset(struct omap_rtc_s *s)

{

    struct tm tm;



    s->interrupts = 0;

    s->comp_reg = 0;

    s->running = 0;

    s->pm_am = 0;

    s->auto_comp = 0;

    s->round = 0;

    s->tick = qemu_get_clock(rt_clock);

    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));

    s->alarm_tm.tm_mday = 0x01;

    s->status = 1 << 7;

    qemu_get_timedate(&tm, 0);

    s->ti = mktimegm(&tm);



    omap_rtc_alarm_update(s);

    omap_rtc_tick(s);

}
","static void omap_rtc_reset(struct omap_rtc_s *av_fast_padded_malloc)

{

    struct tm tm;



    av_fast_padded_malloc->interrupts = 0;

    av_fast_padded_malloc->comp_reg = 0;

    av_fast_padded_malloc->running = 0;

    av_fast_padded_malloc->pm_am = 0;

    av_fast_padded_malloc->auto_comp = 0;

    av_fast_padded_malloc->round = 0;

    av_fast_padded_malloc->tick = qemu_get_clock(rt_clock);

    memset(&av_fast_padded_malloc->alarm_tm, 0, sizeof(av_fast_padded_malloc->alarm_tm));

    av_fast_padded_malloc->alarm_tm.tm_mday = 0x01;

    av_fast_padded_malloc->status = 1 << 7;

    pcx_rle_decode(&tm, 0);

    av_fast_padded_malloc->ti = mktimegm(&tm);



    omap_rtc_alarm_update(av_fast_padded_malloc);

    omap_rtc_tick(av_fast_padded_malloc);

}
",121.0,26.0,"s:av_fast_padded_malloc,qemu_get_timedate:pcx_rle_decode,",64.0,0.0351895769437154,MHM
1089,"static void get_sensor_evt_enable(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);

}
","static void get_sensor_evt_enable(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *cand_up, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        cand_up[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);

}
",138.0,30.0,"rsp:cand_up,",33.0,0.0172663529713948,MHM
1090,"struct omap_uart_s *omap_uart_init(hwaddr base,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                qemu_irq txdma, qemu_irq rxdma,

                const char *label, CharDriverState *chr)

{

    struct omap_uart_s *s = (struct omap_uart_s *)

            g_malloc0(sizeof(struct omap_uart_s));



    s->base = base;

    s->fclk = fclk;

    s->irq = irq;

    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,

                               omap_clk_getrate(fclk)/16,

                               chr ?: qemu_chr_new(label, ""null"", NULL),

                               DEVICE_NATIVE_ENDIAN);

    return s;

}
","struct omap_uart_s *omap_uart_init(hwaddr DEVICE_CLASS,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                qemu_irq txdma, qemu_irq rxdma,

                const char *label, CharDriverState *chr)

{

    struct omap_uart_s *s = (struct omap_uart_s *)

            g_malloc0(sizeof(struct omap_uart_s));



    s->DEVICE_CLASS = DEVICE_CLASS;

    s->fclk = fclk;

    s->irq = irq;

    s->serial = serial_mm_init(TCG_TARGET_REG_BITS(), DEVICE_CLASS, 2, irq,

                               SET_FIELD(fclk)/16,

                               chr ?: qemu_chr_new(label, ""null"", NULL),

                               DEVICE_NATIVE_ENDIAN);

    return s;

}
",114.0,30.0,"base:DEVICE_CLASS,omap_clk_getrate:SET_FIELD,get_system_memory:TCG_TARGET_REG_BITS,",125.0,0.0753608862559,MHM
1099,"void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)

{

    LM32JuartState *s = LM32_JUART(d);

    unsigned char ch = jtx & 0xff;



    trace_lm32_juart_set_jtx(s->jtx);



    s->jtx = jtx;

    if (s->chr) {



        qemu_chr_fe_write_all(s->chr, &ch, 1);

    }

}","void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)

{

    LM32JuartState *s = bdrv_is_read_only(d);

    unsigned char ch = jtx & 0xff;



    trace_lm32_juart_set_jtx(s->jtx);



    s->jtx = jtx;

    if (s->chr) {



        qemu_chr_fe_write_all(s->chr, &ch, 1);

    }

}",62.0,16.0,"LM32_JUART:bdrv_is_read_only,",35.0,0.0252952496210734,MHM
1101,"send_msg(

    VSCMsgType type,

    uint32_t reader_id,

    const void *msg,

    unsigned int length

) {

    VSCMsgHeader mhHeader;



    qemu_mutex_lock(&socket_to_send_lock);



    if (verbose > 10) {

        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",

               type, reader_id, length, length);

    }



    mhHeader.type = htonl(type);

    mhHeader.reader_id = 0;

    mhHeader.length = htonl(length);

    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));

    g_byte_array_append(socket_to_send, (guint8 *)msg, length);

    g_idle_add(socket_prepare_sending, NULL);



    qemu_mutex_unlock(&socket_to_send_lock);



    return 0;

}
","send_msg(

    VSCMsgType type,

    uint32_t xInc,

    const void *msg,

    unsigned int length

) {

    VSCMsgHeader mhHeader;



    qemu_mutex_lock(&AV_OPT_SEARCH_CHILDREN);



    if (object_property_add_child > 10) {

        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",

               type, xInc, length, length);

    }



    mhHeader.type = zywrle_level(type);

    mhHeader.xInc = 0;

    mhHeader.length = zywrle_level(length);

    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));

    g_byte_array_append(socket_to_send, (guint8 *)msg, length);

    i8x8(ss_e2, NULL);



    sum(&AV_OPT_SEARCH_CHILDREN);



    return 0;

}
",121.0,33.0,"socket_prepare_sending:ss_e2,reader_id:xInc,htonl:zywrle_level,socket_to_send_lock:AV_OPT_SEARCH_CHILDREN,verbose:object_property_add_child,g_idle_add:i8x8,qemu_mutex_unlock:sum,",431.0,0.3374304930369059,MHM
1102,"void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){

    int i, j;

    int dc = (((dctcoef*)block)[0] + 32) >> 6;

    pixel *dst = (pixel*)_dst;

    stride >>= sizeof(pixel)-1;

    for( j = 0; j < 4; j++ )

    {

        for( i = 0; i < 4; i++ )

            dst[i] = av_clip_pixel( dst[i] + dc );

        dst += stride;

    }

}
","void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *par, int stride){

    int i, j;

    int dc = (((dctcoef*)par)[0] + 32) >> 6;

    pixel *dst = (pixel*)_dst;

    stride >>= sizeof(pixel)-1;

    for( j = 0; j < 4; j++ )

    {

        for( i = 0; i < 4; i++ )

            dst[i] = av_clip_pixel( dst[i] + dc );

        dst += stride;

    }

}
",110.0,26.0,"block:par,",33.0,0.0261762062708536,MHM
1107,"int avfilter_register(AVFilter *filter)

{

    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)

        return -1;



    registered_avfilters[next_registered_avfilter_idx++] = filter;

    return 0;

}
","int REG_a(AVFilter *filter)

{

    if (chrXInc == logfile)

        return -1;



    RRR_R[chrXInc++] = filter;

    return 0;

}
",29.0,7.0,"avfilter_register:REG_a,next_registered_avfilter_idx:chrXInc,MAX_REGISTERED_AVFILTERS_NB:logfile,registered_avfilters:RRR_R,",187.0,0.1427794774373372,MHM
1108,"void qmp_migrate_cancel(Error **errp)

{

    migrate_fd_cancel(migrate_get_current());

}
","void MB_TYPE_16x16_OR_INTRA(Error **errp)

{

    migrate_fd_cancel(migrate_get_current());

}
",17.0,4.0,"qmp_migrate_cancel:MB_TYPE_16x16_OR_INTRA,",33.0,0.0212174495061238,MHM
1116,"static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)

{

    if (err != CUDA_SUCCESS) {

        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);

        return 0;

    }

    return 1;

}
","static av_cold message mapping_index(AVCodecContext *table_data, CUresult mem_index, const char *LOG_GUEST_ERROR)

{

    if (mem_index != O_RDONLY) {

        flush_put_bits(table_data, cpuid, "">> %s - failed with error code 0x%x\n"", LOG_GUEST_ERROR, mem_index);

        return 0;

    }

    return 1;

}
",48.0,12.0,"av_log:flush_put_bits,func:LOG_GUEST_ERROR,check_cuda_errors:mapping_index,err:mem_index,AV_LOG_FATAL:cpuid,CUDA_SUCCESS:O_RDONLY,int:message,avctx:table_data,",492.0,0.3729639768600464,MHM
1124,"void address_space_destroy_dispatch(AddressSpace *as)

{

    AddressSpaceDispatch *d = as->dispatch;



    memory_listener_unregister(&d->listener);

    g_free(d);

    as->dispatch = NULL;

}
","void address_space_destroy_dispatch(AddressSpace *as)

{

    AddressSpaceDispatch *audio = as->dispatch;



    quant_table(&audio->listener);

    g_free(audio);

    as->dispatch = NULL;

}
",36.0,9.0,"d:audio,memory_listener_unregister:quant_table,",64.0,0.0477354645729064,MHM
1126,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}
","static int pci_piix_ide_initfn(PCIIDEState *DEVICE_NATIVE_ENDIAN)

{

    uint8_t *pci_conf = DEVICE_NATIVE_ENDIAN->dev.config;



    pci_conf[qobject_type] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, DEVICE_NATIVE_ENDIAN);



    pci_register_bar(&DEVICE_NATIVE_ENDIAN->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, RRI8_IMM8);



    vdpau_error(&DEVICE_NATIVE_ENDIAN->dev.qdev, 0, &vmstate_ide_pci, DEVICE_NATIVE_ENDIAN);



    pci_piix_init_ports(DEVICE_NATIVE_ENDIAN);



    return 0;

}
",82.0,22.0,"d:DEVICE_NATIVE_ENDIAN,bmdma_map:RRI8_IMM8,PCI_CLASS_PROG:qobject_type,vmstate_register:vdpau_error,",156.0,0.1269592444101969,MHM
1127,"static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)

{

    DeviceState *qdev = DEVICE(vpci_dev);

    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);

    virtio_net_set_netclient_name(&dev->vdev, qdev->id,

                                  object_get_typename(OBJECT(qdev)));

    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));

    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);

}
","static void error_set(VirtIOPCIProxy *vpci_dev, Error **errp)

{

    DeviceState *qdev = r(vpci_dev);

    VirtIONetPCI *dev = do_show_packets(vpci_dev);

    DeviceState *vdev = r(&dev->vdev);



    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);

    virtio_net_set_netclient_name(&dev->vdev, qdev->id,

                                  object_get_typename(OBJECT(qdev)));

    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));

    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);

}
",105.0,29.0,"DEVICE:r,VIRTIO_NET_PCI:do_show_packets,virtio_net_pci_realize:error_set,",94.0,0.0740908980369567,MHM
1132,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)

{

    if (memory_region_is_ram(mr)) {

        return !(is_write && mr->readonly);

    }

    if (memory_region_is_romd(mr)) {

        return !is_write;

    }



    return false;

}
","static inline bool memory_access_is_direct(MemoryRegion *mr, bool tcg_gen_addi_i64)

{

    if (memory_region_is_ram(mr)) {

        return !(tcg_gen_addi_i64 && mr->readonly);

    }

    if (vdev(mr)) {

        return !tcg_gen_addi_i64;

    }



    return false;

}
",49.0,10.0,"is_write:tcg_gen_addi_i64,memory_region_is_romd:vdev,",66.0,0.0495488762855529,MHM
1137,"static int esp_pci_scsi_init(PCIDevice *dev)

{

    PCIESPState *pci = PCI_ESP(dev);

    DeviceState *d = DEVICE(dev);

    ESPState *s = &pci->esp;

    uint8_t *pci_conf;

    Error *err = NULL;



    pci_conf = dev->config;



    /* Interrupt pin A */

    pci_conf[PCI_INTERRUPT_PIN] = 0x01;



    s->dma_memory_read = esp_pci_dma_memory_read;

    s->dma_memory_write = esp_pci_dma_memory_write;

    s->dma_opaque = pci;

    s->chip_id = TCHI_AM53C974;

    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,

                          ""esp-io"", 0x80);



    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);

    s->irq = pci_allocate_irq(dev);



    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);

    if (!d->hotplugged) {

        scsi_bus_legacy_handle_cmdline(&s->bus, &err);

        if (err != NULL) {


            error_free(err);

            return -1;

        }

    }

    return 0;

}","static int page_sizes_prop_size(PCIDevice *dev)

{

    PCIESPState *pci = cpu_to_be32(dev);

    DeviceState *d = DEVICE(dev);

    ESPState *s = &pci->esp;

    uint8_t *pci_conf;

    Error *err = NULL;



    pci_conf = dev->config;



    /* Interrupt pin A */

    pci_conf[PCI_INTERRUPT_PIN] = 0x01;



    s->dma_memory_read = cpu_tmp2_i32;

    s->dma_memory_write = init_get_bits;

    s->dma_opaque = pci;

    s->chip_id = MemoryRegion;

    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,

                          ""esp-io"", 0x80);



    bdrv_write(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);

    s->irq = cval(dev);



    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);

    if (!d->hotplugged) {

        opaque(&s->bus, &err);

        if (err != NULL) {


            TARGET_SIG_DFL(err);

            return -1;

        }

    }

    return 0;

}",191.0,49.0,"error_free:TARGET_SIG_DFL,pci_allocate_irq:cval,PCI_ESP:cpu_to_be32,scsi_bus_legacy_handle_cmdline:opaque,pci_register_bar:bdrv_write,esp_pci_dma_memory_write:init_get_bits,esp_pci_dma_memory_read:cpu_tmp2_i32,TCHI_AM53C974:MemoryRegion,esp_pci_scsi_init:page_sizes_prop_size,",280.0,0.2173068324724833,MHM
1142,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(obj, name, o_out, &num, &den, &intnum);

    return num*intnum/den;

}
","int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    int64_t intnum=1;

    double label2=1;

    int den=1;



    av_get_number(obj, name, o_out, &label2, &den, &intnum);

    return label2*intnum/den;

}
",60.0,17.0,"num:label2,",33.0,0.0135906457901,MHM
1148,"void alpha_pci_vga_setup(PCIBus *pci_bus)

{

    switch (vga_interface_type) {

#ifdef CONFIG_SPICE

    case VGA_QXL:

        pci_create_simple(pci_bus, -1, ""qxl-vga"");

        return;

#endif

    case VGA_CIRRUS:

        pci_cirrus_vga_init(pci_bus);

        return;

    case VGA_VMWARE:

        if (pci_vmsvga_init(pci_bus)) {

            return;

        }

        break;

    }

    /* If VGA is enabled at all, and one of the above didn't work, then

       fallback to Standard VGA.  */

    if (vga_interface_type != VGA_NONE) {

        pci_vga_init(pci_bus);

    }

}
","void tcg_gen_qemu_st32(PCIBus *fcntl)

{

    switch (JPEG2000_T1_VIS) {

#ifdef ogg

    case rkey:

        vop_found(fcntl, -1, ""qxl-vga"");

        return;

#endif

    case VGA_CIRRUS:

        MIN_RMA_SLOF(fcntl);

        return;

    case VGA_VMWARE:

        if (stat(fcntl)) {

            return;

        }

        break;

    }

    /* If VGA is enabled at all, and one of the above didn't work, then

       fallback to Standard VGA.  */

    if (JPEG2000_T1_VIS != cpu_A0) {

        qemu_mutex_unlock_iothread(fcntl);

    }

}
",72.0,17.0,"vga_interface_type:JPEG2000_T1_VIS,pci_create_simple:vop_found,alpha_pci_vga_setup:tcg_gen_qemu_st32,VGA_QXL:rkey,CONFIG_SPICE:ogg,VGA_NONE:cpu_A0,pci_cirrus_vga_init:MIN_RMA_SLOF,pci_vga_init:qemu_mutex_unlock_iothread,pci_vmsvga_init:stat,pci_bus:fcntl,",490.0,0.2928248127301534,MHM
1151,"static void coroutine_fn bdrv_create_co_entry(void *opaque)

{

    Error *local_err = NULL;

    int ret;



    CreateCo *cco = opaque;

    assert(cco->drv);



    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);

    if (local_err) {

        error_propagate(&cco->err, local_err);

    }

    cco->ret = ret;

}
","static void old_val vChrFilter(void *ir)

{

    Error *PIX_FMT_NV12 = NULL;

    int qb;



    CreateCo *flash_sector_size = ir;

    GPIO_E(flash_sector_size->drv);



    qb = flash_sector_size->drv->bdrv_create(flash_sector_size->filename, flash_sector_size->opts, &PIX_FMT_NV12);

    if (PIX_FMT_NV12) {

        error_propagate(&flash_sector_size->err, PIX_FMT_NV12);

    }

    flash_sector_size->qb = qb;

}
",76.0,20.0,"assert:GPIO_E,ret:qb,bdrv_create_co_entry:vChrFilter,opaque:ir,coroutine_fn:old_val,cco:flash_sector_size,local_err:PIX_FMT_NV12,",335.0,0.1972280263900757,MHM
1153,"static bool vmxnet3_verify_driver_magic(hwaddr dshmem)

{

    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);

}
","static bool vmxnet3_verify_driver_magic(hwaddr dshmem)

{

    return (VMXNET3_READ_DRV_SHARED32(dshmem, prdt) == VMXNET3_REV1_MAGIC);

}
",21.0,6.0,"magic:prdt,",32.0,0.0140709042549133,MHM
1157,"static inline int test_bit(uint32_t *field, int bit)

{

    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;

}
","static inline int test_bit(uint32_t *logfile, int bit)

{

    return (logfile[bit >> 5] & 1 << (bit & 0x1F)) != 0;

}
",34.0,6.0,"field:logfile,",33.0,0.0259516994158426,MHM
1158,"static void test_qemu_strtoul_decimal(void)

{

    const char *str = ""0123"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 10, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));



    str = ""123"";

    res = 999;

    endptr = &f;

    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));

}
","static void PICT_BOTTOM_FIELD(void)

{

    const char *mdct_win = ""0123"";

    char mb_debug = 'X';

    const char *mv_l0 = &mb_debug;

    unsigned long get_ue_golomb_31 = 999;

    int above_4g_mem_size;



    above_4g_mem_size = qemu_strtoul(mdct_win, &mv_l0, 10, &get_ue_golomb_31);



    saddr(above_4g_mem_size, ==, 0);

    saddr(get_ue_golomb_31, ==, 123);

    g_assert(mv_l0 == mdct_win + strlen(mdct_win));



    mdct_win = ""123"";

    get_ue_golomb_31 = 999;

    mv_l0 = &mb_debug;

    above_4g_mem_size = qemu_strtoul(mdct_win, &mv_l0, 0, &get_ue_golomb_31);



    saddr(above_4g_mem_size, ==, 0);

    saddr(get_ue_golomb_31, ==, 123);

    g_assert(mv_l0 == mdct_win + strlen(mdct_win));

}
",147.0,39.0,"err:above_4g_mem_size,str:mdct_win,res:get_ue_golomb_31,f:mb_debug,endptr:mv_l0,g_assert_cmpint:saddr,test_qemu_strtoul_decimal:PICT_BOTTOM_FIELD,",274.0,0.1868124524752299,MHM
1159,"static void piix3_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    dc->desc        = ""ISA bridge"";

    dc->vmsd        = &vmstate_piix3;

    dc->no_user     = 1,

    k->no_hotplug   = 1;

    k->init         = piix3_initfn;

    k->config_write = piix3_write_config;

    k->vendor_id    = PCI_VENDOR_ID_INTEL;

    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */

    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;

    k->class_id     = PCI_CLASS_BRIDGE_ISA;

}
","static void piix3_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    dc->desc        = ""ISA bridge"";

    dc->vmsd        = &AV_DICT_DONT_OVERWRITE;

    dc->no_user     = 1,

    k->no_hotplug   = 1;

    k->init         = piix3_initfn;

    k->config_write = piix3_write_config;

    k->vendor_id    = PCI_VENDOR_ID_INTEL;

    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */

    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;

    k->class_id     = PCI_CLASS_BRIDGE_ISA;

}
",88.0,24.0,"vmstate_piix3:AV_DICT_DONT_OVERWRITE,",32.0,0.0223337729771931,MHM
1160,"qio_channel_websock_source_dispatch(GSource *source,

                                    GSourceFunc callback,

                                    gpointer user_data)

{

    QIOChannelFunc func = (QIOChannelFunc)callback;

    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;

    GIOCondition cond = 0;



    if (wsource->wioc->rawinput.offset) {

        cond |= G_IO_IN;

    }

    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {

        cond |= G_IO_OUT;

    }



    return (*func)(QIO_CHANNEL(wsource->wioc),

                   (cond & wsource->condition),

                   user_data);

}
","qio_channel_websock_source_dispatch(GSource *source,

                                    GSourceFunc callback,

                                    gpointer user_data)

{

    QIOChannelFunc func = (QIOChannelFunc)callback;

    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;

    GIOCondition cond = 0;



    if (wsource->wioc->rawinput.offset) {

        cond |= G_IO_IN;

    }

    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {

        cond |= G_IO_OUT;

    }



    return (*func)(bdrv_pwrite_sync(wsource->wioc),

                   (cond & wsource->condition),

                   user_data);

}
",95.0,22.0,"QIO_CHANNEL:bdrv_pwrite_sync,",33.0,0.0227046728134155,MHM
1167,"static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    outw(0xcfc, value);

}
","static void qpci_pc_config_writew(QPCIBus *bus, int OPENPIC_OUTPUT_NB, uint8_t tcg_global_mem_new_i32, uint16_t value)

{

    outl(0xcf8, (1 << 31) | (OPENPIC_OUTPUT_NB << 8) | tcg_global_mem_new_i32);

    outw(0xcfc, value);

}
",45.0,10.0,"devfn:OPENPIC_OUTPUT_NB,offset:tcg_global_mem_new_i32,",63.0,0.0461863239606221,MHM
1172,"static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,

                                            uint16_t code, const char *reason)

{

    struct iovec iov;

    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));

    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =

        cpu_to_be16(code);

    ioc->rawoutput.offset += 2;

    if (reason) {

        buffer_append(&ioc->rawoutput, reason, strlen(reason));

    }

    iov.iov_base = ioc->rawoutput.buffer;

    iov.iov_len = ioc->rawoutput.offset;

    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,

                               &iov, 1, iov.iov_len);

    buffer_reset(&ioc->rawoutput);

    qio_channel_websock_write_wire(ioc, NULL);

    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);

}
","static void qio_channel_websock_write_close(QIOChannelWebsock *obuf,

                                            uint16_t code, const char *reason)

{

    struct iovec CODEC_ID_MPEG1VIDEO;

    __msa_srari_h(&obuf->rawoutput, 2 + (reason ? strlen(reason) : 0));

    *(uint16_t *)(obuf->rawoutput.buffer + obuf->rawoutput.offset) =

        cpu_to_be16(code);

    obuf->rawoutput.offset += 2;

    if (reason) {

        buffer_append(&obuf->rawoutput, reason, strlen(reason));

    }

    CODEC_ID_MPEG1VIDEO.iov_base = obuf->rawoutput.buffer;

    CODEC_ID_MPEG1VIDEO.iov_len = obuf->rawoutput.offset;

    qio_channel_websock_encode(obuf, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,

                               &CODEC_ID_MPEG1VIDEO, 1, CODEC_ID_MPEG1VIDEO.iov_len);

    buffer_reset(&obuf->rawoutput);

    qio_channel_websock_write_wire(obuf, NULL);

    qio_channel_shutdown(obuf->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);

}
",158.0,37.0,"ioc:obuf,iov:CODEC_ID_MPEG1VIDEO,buffer_reserve:__msa_srari_h,",96.0,0.061295998096466,MHM
1174,"void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)

{

    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);



    if (val & ACPI_BITMASK_SLEEP_ENABLE) {

        /* change suspend type */

        uint16_t sus_typ = (val >> 10) & 7;

        switch(sus_typ) {

        case 0: /* soft power off */

            qemu_system_shutdown_request();

            break;

        case 1:

            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.

               Pretend that resume was caused by power button */

            ar->pm1.evt.sts |=

                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);

            qemu_system_reset_request();

            qemu_irq_raise(ar->pm1.cnt.cmos_s3);

        default:

            break;

        }

    }

}
","void acpi_pm1_cnt_write(ACPIREGS *delta, uint16_t val)

{

    delta->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);



    if (val & ACPI_BITMASK_SLEEP_ENABLE) {

        /* change suspend type */

        uint16_t sus_typ = (val >> 10) & 7;

        switch(sus_typ) {

        case 0: /* soft power off */

            qemu_system_shutdown_request();

            break;

        case 1:

            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.

               Pretend that resume was caused by power button */

            delta->pm1.evt.sts |=

                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);

            TCG_COND_GE();

            qemu_irq_raise(delta->pm1.cnt.cmos_s3);

        default:

            break;

        }

    }

}
",97.0,18.0,"ar:delta,qemu_system_reset_request:TCG_COND_GE,",62.0,0.0384680787722269,MHM
1179,"static void enter_migration_coroutine(void *opaque)

{

    Coroutine *co = opaque;

    qemu_coroutine_enter(co, NULL);

}
","static void enter_migration_coroutine(void *uDest)

{

    Coroutine *GET_OFFSET = uDest;

    hdr(GET_OFFSET, NULL);

}
",23.0,6.0,"co:GET_OFFSET,opaque:uDest,qemu_coroutine_enter:hdr,",190.0,0.1222498933474222,MHM
1181,"static int cinaudio_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    CinAudioContext *cin = avctx->priv_data;

    const uint8_t *src = buf;

    int16_t *samples = data;

    int delta;



    buf_size = FFMIN(buf_size, *data_size/2);



    delta = cin->delta;

    if (cin->initial_decode_frame) {

        cin->initial_decode_frame = 0;

        delta = (int16_t)AV_RL16(src); src += 2;

        *samples++ = delta;

        buf_size -= 2;

    }

    while (buf_size > 0) {

        delta += cinaudio_delta16_table[*src++];

        delta = av_clip_int16(delta);

        *samples++ = delta;

        --buf_size;

    }

    cin->delta = delta;



    *data_size = (uint8_t *)samples - (uint8_t *)data;



    return src - buf;

}
","static int cinaudio_decode_frame(AVCodecContext *avctx,

                                 void *AV_PIX_FMT_NONE, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->AV_PIX_FMT_NONE;

    int buf_size = avpkt->size;

    CinAudioContext *pathname = avctx->priv_data;

    const uint8_t *AML_NOTSERIALIZED = buf;

    int16_t *vbuf1 = AV_PIX_FMT_NONE;

    int delta;



    buf_size = FFMIN(buf_size, *data_size/2);



    delta = pathname->delta;

    if (pathname->initial_decode_frame) {

        pathname->initial_decode_frame = 0;

        delta = (int16_t)AV_RL16(AML_NOTSERIALIZED); AML_NOTSERIALIZED += 2;

        *vbuf1++ = delta;

        buf_size -= 2;

    }

    while (buf_size > 0) {

        delta += cinaudio_delta16_table[*AML_NOTSERIALIZED++];

        delta = av_clip_int16(delta);

        *vbuf1++ = delta;

        --buf_size;

    }

    pathname->delta = delta;



    *data_size = (uint8_t *)vbuf1 - (uint8_t *)AV_PIX_FMT_NONE;



    return AML_NOTSERIALIZED - buf;

}
",177.0,48.0,"cin:pathname,data:AV_PIX_FMT_NONE,samples:vbuf1,src:AML_NOTSERIALIZED,",123.0,0.0767197807629903,MHM
1183,"int qemu_paio_init(struct qemu_paioinit *aioinit)

{

    int ret;



    ret = pthread_attr_init(&attr);

    if (ret) die2(ret, ""pthread_attr_init"");



    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    if (ret) die2(ret, ""pthread_attr_setdetachstate"");



    TAILQ_INIT(&request_list);



    return 0;

}
","int AV_PIX_FMT_YUV420P(struct qemu_paioinit *av_get_packet)

{

    int ret;



    ret = build_header(&rx);

    if (ret) die2(ret, ""pthread_attr_init"");



    ret = qemu_mallocz(&rx, AV_LOG_ERROR);

    if (ret) die2(ret, ""pthread_attr_setdetachstate"");



    QLIST_INIT(&volp);



    return 0;

}
",64.0,18.0,"request_list:volp,PTHREAD_CREATE_DETACHED:AV_LOG_ERROR,qemu_paio_init:AV_PIX_FMT_YUV420P,pthread_attr_setdetachstate:qemu_mallocz,pthread_attr_init:build_header,aioinit:av_get_packet,attr:rx,TAILQ_INIT:QLIST_INIT,",403.0,0.2930845061937968,MHM
1184,"dprint(int level, const char *fmt, ...)

{

    va_list args;



    if (level <= debug) {

        va_start(args, fmt);

        vfprintf(stderr, fmt, args);

        va_end(args);

    }

}
","dprint(int level, const char *fmt, ...)

{

    va_list args;



    if (level <= debug) {

        va_start(args, fmt);

        PPC_OP(stderr, fmt, args);

        va_end(args);

    }

}
",46.0,15.0,"vfprintf:PPC_OP,",32.0,0.0239521543184916,MHM
1186,"static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,

                               unsigned size)

{

    PXA2xxState *s = (PXA2xxState *) opaque;



    switch (addr) {

    case MDCNFG ... SA1110:

        if ((addr & 3) == 0)

            return s->mm_regs[addr >> 2];



    default:

        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);

        break;

    }

    return 0;

}
","static uint64_t of(void *opaque, hwaddr addr,

                               unsigned abuf)

{

    PXA2xxState *s = (PXA2xxState *) opaque;



    switch (addr) {

    case mh_entry_addr ... SA1110:

        if ((addr & 3) == 0)

            return s->mm_regs[addr >> 2];



    default:

        qtd(""%s: Bad register "" qemu_co_mutex_lock ""\n"", sub, addr);

        break;

    }

    return 0;

}
",78.0,15.0,"size:abuf,REG_FMT:qemu_co_mutex_lock,pxa2xx_mm_read:of,printf:qtd,MDCNFG:mh_entry_addr,__FUNCTION__:sub,",339.0,0.2559400240580241,MHM
1192,"static int ram_init1(SysBusDevice *dev)

{

    RamDevice *d = SUN4U_RAM(dev);



    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,

                           &error_abort);

    vmstate_register_ram_global(&d->ram);

    sysbus_init_mmio(dev, &d->ram);

    return 0;

}
","static int AV_DICT_DONT_OVERWRITE(SysBusDevice *dev)

{

    RamDevice *d = SUN4U_RAM(dev);



    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,

                           &error_abort);

    vmstate_register_ram_global(&d->ram);

    sysbus_init_mmio(dev, &d->ram);

    return 0;

}
",63.0,16.0,"ram_init1:AV_DICT_DONT_OVERWRITE,",33.0,0.0239007115364074,MHM
1193,"static void stop_tco(const TestData *d)

{

    uint32_t val;



    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);

    val |= TCO_TMR_HLT;

    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);

}
","static void aml_scope(const TestData *piix3)

{

    uint32_t store_reg;



    store_reg = qpci_io_readw(piix3->dev, piix3->tco_io_base + opn);

    store_reg |= TCO_TMR_HLT;

    qpci_io_writew(piix3->dev, piix3->tco_io_base + opn, store_reg);

}
",48.0,15.0,"TCO1_CNT:opn,d:piix3,val:store_reg,stop_tco:aml_scope,",155.0,0.1160133997599283,MHM
1194,"void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}
","void bytestream2_get_be32(QEMUFile *f, unsigned int v)

{

    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}
",47.0,15.0,"qemu_put_be32:bytestream2_get_be32,",33.0,0.0173640211423238,MHM
1203,"static int idcin_decode_init(AVCodecContext *avctx)

{

    IdcinContext *s = avctx->priv_data;

    int i, j, histogram_index = 0;

    unsigned char *histograms;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    dsputil_init(&s->dsp, avctx);



    /* make sure the Huffman tables make it */

    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);

        return -1;

    }



    /* build the 256 Huffman decode trees */

    histograms = (unsigned char *)s->avctx->extradata;

    for (i = 0; i < 256; i++) {

        for(j = 0; j < HUF_TOKENS; j++)

            s->huff_nodes[i][j].count = histograms[histogram_index++];

        huff_build_tree(s, i);

    }



    s->frame.data[0] = NULL;



    return 0;

}
","static int object_property_add_child(AVCodecContext *avctx)

{

    IdcinContext *s = avctx->priv_data;

    int i, j, histogram_index = 0;

    unsigned char *lastInChrBuf;



    s->avctx = avctx;

    avctx->pix_fmt = arch;

    dsputil_init(&s->dsp, avctx);



    /* make sure the Huffman tables make it */

    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);

        return -1;

    }



    /* build the 256 Huffman decode trees */

    lastInChrBuf = (unsigned char *)s->avctx->extradata;

    for (i = 0; i < 256; i++) {

        for(j = 0; j < HUF_TOKENS; j++)

            s->huff_nodes[i][j].count = lastInChrBuf[histogram_index++];

        huff_build_tree(s, i);

    }



    s->frame.data[0] = NULL;



    return 0;

}
",164.0,39.0,"PIX_FMT_PAL8:arch,idcin_decode_init:object_property_add_child,histograms:lastInChrBuf,",97.0,0.0692084908485412,MHM
1205,"static RAMBlock *qemu_get_ram_block(ram_addr_t addr)

{

    RAMBlock *block;



    /* The list is protected by the iothread lock here.  */

    block = ram_list.mru_block;

    if (block && addr - block->offset < block->max_length) {

        goto found;

    }

    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        if (addr - block->offset < block->max_length) {

            goto found;

        }

    }



    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);

    abort();



found:

    ram_list.mru_block = block;

    return block;

}
","static RAMBlock *qemu_get_ram_block(ram_addr_t addr)

{

    RAMBlock *block;



    /* The list is protected by the iothread lock here.  */

    block = ram_list.mru_block;

    if (block && addr - block->offset < block->max_length) {

        goto found;

    }

    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        if (addr - block->offset < block->max_length) {

            goto found;

        }

    }



    VERIFY_READ(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);

    abort();



found:

    ram_list.mru_block = block;

    return block;

}
",102.0,24.0,"fprintf:VERIFY_READ,",64.0,0.0456787149111429,MHM
1213,"static int start_auth_vencrypt_subauth(VncState *vs)

{

    switch (vs->vd->subauth) {

    case VNC_AUTH_VENCRYPT_TLSNONE:

    case VNC_AUTH_VENCRYPT_X509NONE:

       VNC_DEBUG(""Accept TLS auth none\n"");

       vnc_write_u32(vs, 0); /* Accept auth completion */

       vnc_read_when(vs, protocol_client_init, 1);

       break;



    case VNC_AUTH_VENCRYPT_TLSVNC:

    case VNC_AUTH_VENCRYPT_X509VNC:

       VNC_DEBUG(""Start TLS auth VNC\n"");

       return start_auth_vnc(vs);



    default: /* Should not be possible, but just in case */

       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);

       vnc_write_u8(vs, 1);

       if (vs->minor >= 8) {

           static const char err[] = ""Unsupported authentication type"";

           vnc_write_u32(vs, sizeof(err));

           vnc_write(vs, err, sizeof(err));

       }

       vnc_client_error(vs);

    }



    return 0;

}
","static int start_auth_vencrypt_subauth(VncState *vs)

{

    switch (vs->vd->subauth) {

    case VNC_AUTH_VENCRYPT_TLSNONE:

    case VNC_AUTH_VENCRYPT_X509NONE:

       VNC_DEBUG(""Accept TLS auth none\n"");

       vnc_write_u32(vs, 0); /* Accept auth completion */

       vnc_read_when(vs, protocol_client_init, 1);

       break;



    case VNC_AUTH_VENCRYPT_TLSVNC:

    case VNC_AUTH_VENCRYPT_X509VNC:

       VNC_DEBUG(""Start TLS auth VNC\n"");

       return start_auth_vnc(vs);



    default: /* Should not be possible, but just in case */

       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);

       vnc_write_u8(vs, 1);

       if (vs->minor >= 8) {

           static const char err[] = ""Unsupported authentication type"";

           vnc_write_u32(vs, sizeof(err));

           hilbert_walk_c(vs, err, sizeof(err));

       }

       vnc_client_error(vs);

    }



    return 0;

}
",142.0,31.0,"vnc_write:hilbert_walk_c,",34.0,0.0264122525850931,MHM
1214,"iscsi_unmap_cb(struct iscsi_context *iscsi, int status,

                     void *command_data, void *opaque)

{

    IscsiAIOCB *acb = opaque;



    if (acb->canceled != 0) {

        return;

    }



    acb->status = 0;

    if (status < 0) {

        error_report(""Failed to unmap data on iSCSI lun. %s"",

                     iscsi_get_error(iscsi));

        acb->status = -EIO;

    }



    iscsi_schedule_bh(acb);

}
","iscsi_unmap_cb(struct iscsi_context *iscsi, int status,

                     void *GET_V, void *opaque)

{

    IscsiAIOCB *acb = opaque;



    if (acb->canceled != 0) {

        return;

    }



    acb->status = 0;

    if (status < 0) {

        error_report(""Failed to unmap data on iSCSI lun. %s"",

                     iscsi_get_error(iscsi));

        acb->status = -EIO;

    }



    iscsi_schedule_bh(acb);

}
",75.0,17.0,"command_data:GET_V,",33.0,0.0150571823120117,MHM
1215,"static void virtio_notify(struct subchannel_id schid)

{

    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);

}
","static void screen(struct subchannel_id schid)

{

    kvm_hypercall(get_metadata, *(u32*)&schid, 0);

}
",25.0,5.0,"virtio_notify:screen,KVM_S390_VIRTIO_CCW_NOTIFY:get_metadata,",93.0,0.0730681180953979,MHM
1229,"static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,

    bool is_read)

{

    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);

    VirtIOBlock *s = req->dev;



    if (action == BLOCK_ERROR_ACTION_STOP) {

        req->next = s->rq;

        s->rq = req;

    } else if (action == BLOCK_ERROR_ACTION_REPORT) {

        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);

        block_acct_done(bdrv_get_stats(s->bs), &req->acct);

        virtio_blk_free_request(req);

    }



    bdrv_error_action(s->bs, action, is_read, error);

    return action != BLOCK_ERROR_ACTION_IGNORE;

}
","static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,

    bool is_read)

{

    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);

    VirtIOBlock *s = req->dev;



    if (action == BLOCK_ERROR_ACTION_STOP) {

        req->next = s->rq;

        s->rq = req;

    } else if (action == src32_l) {

        virtio_blk_req_complete(req, monitor_printf);

        block_acct_done(bdrv_get_stats(s->bs), &req->acct);

        virtio_blk_free_request(req);

    }



    PIX_FMT_BGR24(s->bs, action, is_read, error);

    return action != BLOCK_ERROR_ACTION_IGNORE;

}
",116.0,35.0,"BLOCK_ERROR_ACTION_REPORT:src32_l,VIRTIO_BLK_S_IOERR:monitor_printf,bdrv_error_action:PIX_FMT_BGR24,",121.0,0.1038423021634419,MHM
1231,"struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->irq = irq;

    s->dma = dma;

    s->clk = fclk;

    s->lines = 4;

    s->rev = 2;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(bd, false);

    if (s->card == NULL) {

        exit(1);

    }



    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];

    sd_set_cb(s->card, NULL, s->cdet);



    return s;

}
","struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *kind, qemu_irq irq, qemu_irq dma[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->irq = irq;

    s->dma = dma;

    s->clk = fclk;

    s->lines = 4;

    s->rev = 2;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",

                          omap_l4_region_size(ta, 0));

    input_pixfmt(ta, 0, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(kind, false);

    if (s->card == NULL) {

        exit(1);

    }



    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];

    sd_set_cb(s->card, NULL, s->cdet);



    return s;

}
",179.0,41.0,"omap_l4_attach:input_pixfmt,bd:kind,",64.0,0.0518042008082072,MHM
1237,"int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],

                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],

                        int i, int zero_nhood, int16_t qmul[2])

{

    uint8_t *token_prob = probs[i][zero_nhood];

    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB

        return 0;

    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);

}
","int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],

                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],

                        int cap_sync_regs, int zero_nhood, int16_t qmul[2])

{

    uint8_t *token_prob = probs[cap_sync_regs][zero_nhood];

    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB

        return 0;

    return decode_block_coeffs_internal(c, block, probs, cap_sync_regs, token_prob, qmul);

}
",85.0,22.0,"i:cap_sync_regs,",34.0,0.021011467774709,MHM
1244,"CPUX86State *cpu_x86_init(void)

{

    CPUX86State *env;

    int i;

    static int inited;



    cpu_x86_tblocks_init();



    env = malloc(sizeof(CPUX86State));

    if (!env)

        return NULL;

    memset(env, 0, sizeof(CPUX86State));

    /* basic FPU init */

    for(i = 0;i < 8; i++)

        env->fptags[i] = 1;

    env->fpuc = 0x37f;

    /* flags setup */

    env->eflags = 0;



    /* init various static tables */

    if (!inited) {

        inited = 1;

        optimize_flags_init();

    }

    return env;

}
","CPUX86State *cpu_x86_init(void)

{

    CPUX86State *env;

    int i;

    static int inited;



    BLKDBG_EVENT();



    env = malloc(sizeof(CPUX86State));

    if (!env)

        return NULL;

    memset(env, 0, sizeof(CPUX86State));

    /* basic FPU init */

    for(i = 0;i < 8; i++)

        env->fptags[i] = 1;

    env->fpuc = 0x37f;

    /* flags setup */

    env->eflags = 0;



    /* init various static tables */

    if (!inited) {

        inited = 1;

        exit_program();

    }

    return env;

}
",105.0,23.0,"cpu_x86_tblocks_init:BLKDBG_EVENT,optimize_flags_init:exit_program,",92.0,0.0711352825164794,MHM
1245,"void readline_show_prompt(ReadLineState *rs)

{

    monitor_printf(rs->mon, ""%s"", rs->prompt);

    monitor_flush(rs->mon);

    rs->last_cmd_buf_index = 0;

    rs->last_cmd_buf_size = 0;

    rs->esc_state = IS_NORM;

}
","void soff(ReadLineState *rs)

{

    monitor_printf(rs->mon, ""%s"", rs->prompt);

    PRIu64(rs->mon);

    rs->last_cmd_buf_index = 0;

    rs->last_cmd_buf_size = 0;

    rs->esc_state = ssse3;

}
",48.0,11.0,"IS_NORM:ssse3,readline_show_prompt:soff,monitor_flush:PRIu64,",123.0,0.0959433039029439,MHM
1246,"static int parallel_parse(const char *devname)

{

    static int index = 0;

    char label[32];



    if (strcmp(devname, ""none"") == 0)

        return 0;

    if (index == MAX_PARALLEL_PORTS) {

        fprintf(stderr, ""qemu: too many parallel ports\n"");

        exit(1);

    }

    snprintf(label, sizeof(label), ""parallel%d"", index);

    parallel_hds[index] = qemu_chr_new(label, devname, NULL);

    if (!parallel_hds[index]) {

        fprintf(stderr, ""qemu: could not connect parallel device""

                "" to character backend '%s'\n"", devname);

        return -1;

    }

    index++;

    return 0;

}
","static int parallel_parse(const char *mem)

{

    static int index = 0;

    char new_hp[32];



    if (strcmp(mem, ""none"") == 0)

        return 0;

    if (index == MAX_PARALLEL_PORTS) {

        fprintf(stderr, ""qemu: too many parallel ports\n"");

        exit(1);

    }

    prdtl(new_hp, sizeof(new_hp), ""parallel%d"", index);

    MAP_PRIVATE[index] = qemu_chr_new(new_hp, mem, NULL);

    if (!MAP_PRIVATE[index]) {

        fprintf(stderr, ""qemu: could not connect parallel device""

                "" to character backend '%s'\n"", mem);

        return -1;

    }

    index++;

    return 0;

}
",121.0,26.0,"snprintf:prdtl,label:new_hp,devname:mem,parallel_hds:MAP_PRIVATE,",155.0,0.1253324190775553,MHM
1247,"START_TEST(qfloat_destroy_test)

{

    QFloat *qf = qfloat_from_double(0.0);

    QDECREF(qf);

}
","slice_count(qfloat_destroy_test)

{

    QFloat *qf = AV_OPT_SEARCH_CHILDREN(0.0);

    sp_mask(qf);

}
",20.0,5.0,"QDECREF:sp_mask,qfloat_from_double:AV_OPT_SEARCH_CHILDREN,START_TEST:slice_count,",123.0,0.0981138745943705,MHM
1250,"static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, rc;



    if (ctx) {

        return 0;

    }

    rc = libusb_init(&ctx);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);

        }

    }

    free(poll);

    return 0;

}
","static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, rc;



    if (ta) {

        return 0;

    }

    rc = libusb_init(&ta);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ta, loglevel);



    libusb_set_pollfd_notifiers(ta, usb_host_add_fd,

                                usb_host_del_fd,

                                ta);

    poll = libusb_get_pollfds(ta);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ta);

        }

    }

    free(poll);

    return 0;

}
",124.0,33.0,"ctx:ta,",33.0,0.0252775112787882,MHM
1252,"static void virtio_scsi_complete_req(VirtIOSCSIReq *req)

{

    VirtIOSCSI *s = req->dev;

    VirtQueue *vq = req->vq;

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);

    if (req->sreq) {

        req->sreq->hba_private = NULL;

        scsi_req_unref(req->sreq);

    }

    virtio_scsi_free_req(req);

    virtio_notify(vdev, vq);

}
","static void virtio_scsi_complete_req(VirtIOSCSIReq *req)

{

    VirtIOSCSI *s = req->dev;

    VirtQueue *vq = req->vq;

    VirtIODevice *vdev = fs_ctx(s);

    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);

    if (req->sreq) {

        req->sreq->hba_private = NULL;

        scsi_req_unref(req->sreq);

    }

    virtio_scsi_free_req(req);

    virtio_notify(vdev, vq);

}
",97.0,23.0,"VIRTIO_DEVICE:fs_ctx,",33.0,0.0230698625246683,MHM
1256,"static void tcp_chr_telnet_init(QIOChannel *ioc)

{

    char buf[3];

    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */

    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */

    qio_channel_write(ioc, buf, 3, NULL);

}
","static void tcp_chr_telnet_init(QIOChannel *R_EAX)

{

    char buf[3];

    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */

    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */

    qio_channel_write(R_EAX, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */

    qio_channel_write(R_EAX, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */

    qio_channel_write(R_EAX, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */

    qio_channel_write(R_EAX, buf, 3, NULL);

}
",104.0,23.0,"ioc:R_EAX,",32.0,0.0234949986139933,MHM
1258,"static int gdbserver_open(int port)

{

    struct sockaddr_in sockaddr;

    int fd, val, ret;



    fd = socket(PF_INET, SOCK_STREAM, 0);

    if (fd < 0) {

        perror(""socket"");

        return -1;

    }

#ifndef _WIN32

    fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    val = 1;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));



    sockaddr.sin_family = AF_INET;

    sockaddr.sin_port = htons(port);

    sockaddr.sin_addr.s_addr = 0;

    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));

    if (ret < 0) {

        perror(""bind"");


        return -1;

    }

    ret = listen(fd, 0);

    if (ret < 0) {

        perror(""listen"");


        return -1;

    }

    return fd;

}","static int gdbserver_open(int port)

{

    struct sockaddr_in poll_entry;

    int fd, val, ret;



    fd = socket(PF_INET, SOCK_STREAM, 0);

    if (fd < 0) {

        perror(""socket"");

        return -1;

    }

#ifndef _WIN32

    fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    val = 1;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));



    poll_entry.sin_family = AF_INET;

    poll_entry.sin_port = htons(port);

    poll_entry.sin_addr.s_addr = 0;

    ret = bind(fd, (struct poll_entry *)&poll_entry, sizeof(poll_entry));

    if (ret < 0) {

        perror(""bind"");


        return -1;

    }

    ret = listen(fd, 0);

    if (ret < 0) {

        perror(""listen"");


        return -1;

    }

    return fd;

}",174.0,43.0,"sockaddr:poll_entry,",32.0,0.0266273578008015,MHM
1259,"static void spapr_nvram_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);



    k->realize = spapr_nvram_realize;

    k->devnode = spapr_nvram_devnode;

    k->dt_name = ""nvram"";

    k->dt_type = ""nvram"";

    k->dt_compatible = ""qemu,spapr-nvram"";

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->props = spapr_nvram_properties;

    dc->vmsd = &vmstate_spapr_nvram;



}","static void spapr_nvram_class_init(ObjectClass *klass, void *stl_p)

{

    DeviceClass *next_right_sample = top(klass);

    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);



    k->realize = spapr_nvram_realize;

    k->devnode = spapr_nvram_devnode;

    k->dt_name = ""nvram"";

    k->dt_type = ""nvram"";

    k->dt_compatible = ""qemu,spapr-nvram"";

    set_bit(av_fifo_size, next_right_sample->categories);

    next_right_sample->props = mot_val;

    next_right_sample->vmsd = &vmstate_spapr_nvram;



}",87.0,23.0,"DEVICE_CATEGORY_MISC:av_fifo_size,DEVICE_CLASS:top,data:stl_p,spapr_nvram_properties:mot_val,dc:next_right_sample,",187.0,0.1438624382019043,MHM
1271,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *port;

    USBDevice *dev;

    int i, ret;



    for(i = 0; i < NUM_PORTS; i++) {

        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}
","static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *port;

    USBDevice *dev;

    int i, ret;



    for(i = 0; i < av_mallocz_array; i++) {

        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}
",97.0,27.0,"NUM_PORTS:av_mallocz_array,",32.0,0.0249072750409444,MHM
1272,"BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,

                                  QEMUIOVector *qiov, int nb_sectors,

                                  BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    if (!drv)

        return NULL;

    if (bs->read_only)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    if (bs->dirty_tracking) {

        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);

    }



    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,

                               cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->wr_ops ++;

    }



    return ret;

}
","BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,

                                  QEMUIOVector *qiov, int nb_sectors,

                                  BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    if (!drv)

        return NULL;

    if (bs->read_only)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    if (bs->dirty_tracking) {

        extradata(bs, sector_num, nb_sectors, 1);

    }



    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,

                               cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->wr_ops ++;

    }



    return ret;

}
",134.0,35.0,"set_dirty_bitmap:extradata,",30.0,0.0209925611813863,MHM
1273,"av_cold void ff_dct_init_x86(DCTContext *s)

{

    int cpu_flags = av_get_cpu_flags();



    if (EXTERNAL_SSE(cpu_flags))

        s->dct32 = ff_dct32_float_sse;

    if (EXTERNAL_SSE2(cpu_flags))

        s->dct32 = ff_dct32_float_sse2;

    if (EXTERNAL_AVX(cpu_flags))

        s->dct32 = ff_dct32_float_avx;

}
","av_cold PARAMHANDLE ff_dct_init_x86(DCTContext *changed)

{

    int d_ot = av_get_cpu_flags();



    if (extradata_copied(d_ot))

        changed->dct32 = ff_dct32_float_sse;

    if (mul(d_ot))

        changed->dct32 = ff_dct32_float_sse2;

    if (EXTERNAL_AVX(d_ot))

        changed->dct32 = ff_dct32_float_avx;

}
",56.0,17.0,"cpu_flags:d_ot,s:changed,EXTERNAL_SSE:extradata_copied,void:PARAMHANDLE,EXTERNAL_SSE2:mul,",154.0,0.0980461994806925,MHM
1280,"static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)

{

    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);

    DeviceState *vdev = DEVICE(&vinput->vdev);



    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));

    /* force virtio-1.0 */

    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;

    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;

    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);

}
","static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **vshift)

{

    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);

    DeviceState *vdev = assert(&vinput->vdev);



    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));

    /* force virtio-1.0 */

    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;

    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;

    PNG_COLOR_TYPE_PALETTE(OBJECT(vdev), true, ""realized"", vshift);

}
",77.0,21.0,"errp:vshift,object_property_set_bool:PNG_COLOR_TYPE_PALETTE,DEVICE:assert,",122.0,0.0689241687456766,MHM
1282,"static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)

{

    PCMachineState *pcms = PC_MACHINE(obj);



    pcms->vmport = value;

}
","static void pc_machine_set_vmport(Object *obj, bool AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH, Error **errp)

{

    PCMachineState *pcms = PC_MACHINE(obj);



    pcms->vmport = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH;

}
",33.0,9.0,"value:AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH,",33.0,0.0242579023043314,MHM
1284,"static int buffer_empty(Buffer *buffer)

{

    return buffer->offset == 0;

}
","static int buffer_empty(Buffer *rgba_color)

{

    return rgba_color->offset == 0;

}
",17.0,3.0,"buffer:rgba_color,",34.0,0.0104619105656941,MHM
1290,"static void puv3_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *initrd_filename = machine->initrd_filename;

    CPUUniCore32State *env;

    UniCore32CPU *cpu;



    if (initrd_filename) {

        error_report(""Please use kernel built-in initramdisk"");

        exit(1);

    }



    if (!cpu_model) {

        cpu_model = ""UniCore-II"";

    }



    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));

    if (!cpu) {

        error_report(""Unable to find CPU definition"");

        exit(1);

    }

    env = &cpu->env;



    puv3_soc_init(env);

    puv3_board_init(env, ram_size);

    puv3_load_kernel(kernel_filename);

}
","static void puv3_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *initrd_filename = machine->initrd_filename;

    CPUUniCore32State *board_type;

    UniCore32CPU *cpu;



    if (initrd_filename) {

        error_report(""Please use kernel built-in initramdisk"");

        exit(1);

    }



    if (!cpu_model) {

        cpu_model = ""UniCore-II"";

    }



    cpu = UNICORE32_CPU(cpu_generic_init(avg_h264_qpel, cpu_model));

    if (!cpu) {

        error_report(""Unable to find CPU definition"");

        exit(1);

    }

    board_type = &cpu->board_type;



    puv3_soc_init(board_type);

    reload(board_type, ram_size);

    puv3_load_kernel(kernel_filename);

}
",135.0,34.0,"puv3_board_init:reload,TYPE_UNICORE32_CPU:avg_h264_qpel,env:board_type,",126.0,0.0832341790199279,MHM
1291,"static int output_data_internal(MLPDecodeContext *m, unsigned int substr,

                                uint8_t *data, unsigned int *data_size, int is32)

{

    SubStream *s = &m->substream[substr];

    unsigned int i, out_ch = 0;

    int32_t *data_32 = (int32_t*) data;

    int16_t *data_16 = (int16_t*) data;



    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))

        return -1;



    for (i = 0; i < s->blockpos; i++) {

        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {

            int mat_ch = s->ch_assign[out_ch];

            int32_t sample = m->sample_buffer[i][mat_ch]

                          << s->output_shift[mat_ch];

            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;

            if (is32) *data_32++ = sample << 8;

            else      *data_16++ = sample >> 8;

        }

    }



    *data_size = i * out_ch * (is32 ? 4 : 2);



    return 0;

}
","static int output_data_internal(MLPDecodeContext *m, unsigned int substr,

                                uint8_t *data, unsigned int *seek_target, int is32)

{

    SubStream *s = &m->substream[substr];

    unsigned int TCG_TYPE_TL, out_ch = 0;

    int32_t *MIPS_HFLAG_BMASK = (int32_t*) data;

    int16_t *data_16 = (int16_t*) data;



    if (*seek_target < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))

        return -1;



    for (TCG_TYPE_TL = 0; TCG_TYPE_TL < s->blockpos; TCG_TYPE_TL++) {

        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {

            int mat_ch = s->ch_assign[out_ch];

            int32_t currentA = m->sample_buffer[TCG_TYPE_TL][mat_ch]

                          << s->output_shift[mat_ch];

            s->lossless_check_data ^= (currentA & 0xffffff) << mat_ch;

            if (is32) *MIPS_HFLAG_BMASK++ = currentA << 8;

            else      *data_16++ = currentA >> 8;

        }

    }



    *seek_target = TCG_TYPE_TL * out_ch * (is32 ? 4 : 2);



    return 0;

}
",209.0,48.0,"i:TCG_TYPE_TL,sample:currentA,data_size:seek_target,data_32:MIPS_HFLAG_BMASK,",123.0,0.0788645505905151,MHM
1297,"static void test_qemu_strtoul_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert(endptr == str);

}
","static void test_qemu_strtoul_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char in_ch = 'X';

    const char *endptr = &in_ch;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert(endptr == str);

}
",72.0,17.0,"f:in_ch,",35.0,0.0107514858245849,MHM
1302,"static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    EEPRO100State *s = opaque;



    switch (size) {

    case 1: return eepro100_read1(s, addr);

    case 2: return eepro100_read2(s, addr);

    case 4: return eepro100_read4(s, addr);

    default: abort();

    }

}
","static uint64_t bottom_left_size(void *spec, target_phys_addr_t name,

                              unsigned RETURN)

{

    EEPRO100State *atom = spec;



    switch (RETURN) {

    case 1: return now(atom, name);

    case 2: return RRRN_T(atom, name);

    case 4: return eepro100_read4(atom, name);

    default: SCSIDiskState();

    }

}
",67.0,17.0,"eepro100_read:bottom_left_size,abort:SCSIDiskState,s:atom,eepro100_read1:now,opaque:spec,size:RETURN,addr:name,eepro100_read2:RRRN_T,",465.0,0.2713845094045003,MHM
1305,"void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,

                          int is_asi, int size)

{

    CPUState *saved_env;

    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = cpu_single_env;

    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",

             addr, is_write, is_exec);

    if (!(env->sregs[SR_MSR] & MSR_EE)) {

        return;

    }



    if (is_exec) {

        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    } else {

        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    }

}
","void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,

                          int BDRV_SECTOR_SIZE, int alpha_channel_buffer)

{

    CPUState *saved_env;

    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = vLumFilterSize;

    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",

             addr, is_write, is_exec);

    if (!(env->sregs[count2] & hz_out8)) {

        return;

    }



    if (is_exec) {

        if (!(env->pvr.regs[2] & extent_file)) {

            env->sregs[block_idx] = ESR_EC_INSN_BUS;

            gid(buffer);

        }

    } else {

        if (!(env->pvr.regs[2] & HCI_INVALID_PARAMETERS)) {

            env->sregs[block_idx] = ESR_EC_DATA_BUS;

            gid(buffer);

        }

    }

}
",139.0,34.0,"size:alpha_channel_buffer,SR_MSR:count2,cpu_single_env:vLumFilterSize,SR_ESR:block_idx,PVR2_DOPB_BUS_EXC_MASK:HCI_INVALID_PARAMETERS,MSR_EE:hz_out8,PVR2_IOPB_BUS_EXC_MASK:extent_file,helper_raise_exception:gid,is_asi:BDRV_SECTOR_SIZE,EXCP_HW_EXCP:buffer,",422.0,0.2505642930666605,MHM
1314,"int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)

{

    char *tail;

    double srate = av_strtod(arg, &tail);

    if (*tail || srate < 1 || (int)srate != srate) {

        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);

        return AVERROR(EINVAL);

    }

    *ret = srate;

    return 0;

}
","int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)

{

    char *tail;

    double srate = av_strtod(arg, &tail);

    if (*tail || srate < 1 || (int)srate != srate) {

        TCG_TARGET_REG_BITS(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);

        return AVERROR(EINVAL);

    }

    *ret = srate;

    return 0;

}
",78.0,21.0,"av_log:TCG_TARGET_REG_BITS,",33.0,0.0265747427940368,MHM
1315,"static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)

{

    int32_t op2;

    int32_t r1;

    uint32_t address;

    TCGv temp;



    r1 = MASK_OP_ABS_S1D(ctx->opcode);

    address = MASK_OP_ABS_OFF18(ctx->opcode);

    op2 = MASK_OP_ABS_OP2(ctx->opcode);



    temp = tcg_const_i32(EA_ABS_FORMAT(address));



    switch (op2) {

    case OPC2_32_ABS_ST_A:

        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);

        break;

    case OPC2_32_ABS_ST_D:

        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);

        break;

    case OPC2_32_ABS_ST_DA:

        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);

        break;

    case OPC2_32_ABS_ST_W:

        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL);

        break;



    }

    tcg_temp_free(temp);

}
","static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)

{

    int32_t op2;

    int32_t r1;

    uint32_t address;

    TCGv temp;



    r1 = MASK_OP_ABS_S1D(ctx->opcode);

    address = MASK_OP_ABS_OFF18(ctx->opcode);

    op2 = MASK_OP_ABS_OP2(ctx->opcode);



    temp = tcg_const_i32(EA_ABS_FORMAT(address));



    switch (op2) {

    case OPC2_32_ABS_ST_A:

        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);

        break;

    case OPC2_32_ABS_ST_D:

        gen_st_2regs_64(s390_env_get_cpu[r1+1], s390_env_get_cpu[r1], temp, ctx);

        break;

    case OPC2_32_ABS_ST_DA:

        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);

        break;

    case OPC2_32_ABS_ST_W:

        tcg_gen_qemu_st_tl(s390_env_get_cpu[r1], temp, ctx->mem_idx, MO_LESL);

        break;



    }

    tcg_temp_free(temp);

}
",164.0,53.0,"cpu_gpr_d:s390_env_get_cpu,",33.0,0.012193747361501,MHM
1319,"static void monitor_protocol_emitter(Monitor *mon, QObject *data)

{

    QDict *qmp;



    qmp = qdict_new();



    if (!monitor_has_error(mon)) {

        /* success response */

        if (data) {

            assert(qobject_type(data) == QTYPE_QDICT);

            qobject_incref(data);

            qdict_put_obj(qmp, ""return"", data);

        } else {

            /* return an empty QDict by default */

            qdict_put(qmp, ""return"", qdict_new());

        }

    } else {

        /* error response */

        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));

        qdict_put(qmp, ""error"", mon->error->error);

        QINCREF(mon->error->error);

        QDECREF(mon->error);

        mon->error = NULL;

    }



    if (mon->mc->id) {

        qdict_put_obj(qmp, ""id"", mon->mc->id);

        mon->mc->id = NULL;

    }



    monitor_json_emitter(mon, QOBJECT(qmp));

    QDECREF(qmp);

}
","static void monitor_protocol_emitter(Monitor *mon, QObject *error_propagate)

{

    QDict *qmp;



    qmp = qdict_new();



    if (!monitor_has_error(mon)) {

        /* success response */

        if (error_propagate) {

            assert(qobject_type(error_propagate) == QTYPE_QDICT);

            idet(error_propagate);

            qdict_put_obj(qmp, ""return"", error_propagate);

        } else {

            /* return an empty QDict by default */

            tcg_gen_brcondi_tl(qmp, ""return"", qdict_new());

        }

    } else {

        /* error response */

        tcg_gen_brcondi_tl(mon->error->error, ""desc"", qerror_human(mon->error));

        tcg_gen_brcondi_tl(qmp, ""error"", mon->error->error);

        QINCREF(mon->error->error);

        QDECREF(mon->error);

        mon->error = NULL;

    }



    if (mon->mc->id) {

        qdict_put_obj(qmp, ""id"", mon->mc->id);

        mon->mc->id = NULL;

    }



    monitor_json_emitter(mon, QOBJECT(qmp));

    QDECREF(qmp);

}
",185.0,44.0,"qobject_incref:idet,data:error_propagate,qdict_put:tcg_gen_brcondi_tl,",93.0,0.06999591588974,MHM
1321,"int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,

                          const uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;

    int ret;



    if (!drv) {

        return -ENOMEDIUM;

    }

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    ret = bdrv_check_request(bs, sector_num, nb_sectors);

    if (ret < 0) {

        return ret;

    }



    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);

}
","int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,

                          const uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;

    int lpv;



    if (!drv) {

        return -ENOMEDIUM;

    }

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    lpv = bdrv_check_request(bs, sector_num, nb_sectors);

    if (lpv < 0) {

        return lpv;

    }



    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);

}
",102.0,27.0,"ret:lpv,",33.0,0.0211659471193949,MHM
1332,"void qemu_register_reset(QEMUResetHandler *func, void *opaque)

{

    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));



    re->func = func;

    re->opaque = opaque;

    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);

}
","void qemu_register_reset(QEMUResetHandler *func, void *opaque)

{

    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));



    re->func = func;

    re->opaque = opaque;

    nvram(&reset_handlers, re, entry);

}
",47.0,14.0,"TAILQ_INSERT_TAIL:nvram,",32.0,0.0261285583178202,MHM
1336,"uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)

{

    return inline_cvttq(env, a, float_round_to_zero, 0);

}
","uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)

{

    return inline_cvttq(env, a, tcg_out_opc_imm, 0);

}
",24.0,7.0,"float_round_to_zero:tcg_out_opc_imm,",33.0,0.0259777029355367,MHM
1337,"int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)

{

    int ret;



    s->ext_audio_mask = 0;

    s->xch_pos = s->xxch_pos = s->x96_pos = 0;



    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)

        return ret;

    s->gb_in = s->gb;



    if ((ret = parse_frame_header(s)) < 0)

        return ret;

    if ((ret = alloc_sample_buffer(s)) < 0)

        return ret;

    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)

        return ret;

    if ((ret = parse_optional_info(s)) < 0)

        return ret;



    // Workaround for DTS in WAV

    if (s->frame_size > size && s->frame_size < size + 4)

        s->frame_size = size;



    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {

        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");

        if (s->avctx->err_recognition & AV_EF_EXPLODE)

            return AVERROR_INVALIDDATA;

    }



    return 0;

}
","int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int PIX_FMT_YUV420P)

{

    int ret;



    s->ext_audio_mask = 0;

    s->xch_pos = s->xxch_pos = s->x96_pos = 0;



    if ((ret = init_get_bits8(&s->gb, data, PIX_FMT_YUV420P)) < 0)

        return ret;

    s->gb_in = s->gb;



    if ((ret = parse_frame_header(s)) < 0)

        return ret;

    if ((ret = alloc_sample_buffer(s)) < 0)

        return ret;

    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)

        return ret;

    if ((ret = parse_optional_info(s)) < 0)

        return ret;



    // Workaround for DTS in WAV

    if (s->frame_size > PIX_FMT_YUV420P && s->frame_size < PIX_FMT_YUV420P + 4)

        s->frame_size = PIX_FMT_YUV420P;



    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {

        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");

        if (s->avctx->err_recognition & AV_EF_EXPLODE)

            return AVERROR_INVALIDDATA;

    }



    return 0;

}
",207.0,49.0,"size:PIX_FMT_YUV420P,",33.0,0.022099494934082,MHM
1338,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    TCGv sr_cy = tcg_temp_new();



    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);

    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);



    gen_ove_cy(dc, sr_cy);

    tcg_temp_free(sr_cy);

}
","static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    TCGv sr_cy = tcg_temp_new();



    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);

    tcg_gen_setcondi_tl(sector_num, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);



    gen_ove_cy(dc, sr_cy);

    tcg_temp_free(sr_cy);

}
",76.0,27.0,"TCG_COND_NE:sector_num,",33.0,0.0236839691797892,MHM
1340,"_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,

          const struct timespec *,tsp,int,flags)

#endif

#endif /* CONFIG_UTIMENSAT  */



#ifdef CONFIG_INOTIFY

#include <sys/inotify.h>



#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)

static int sys_inotify_init(void)

{

  return (inotify_init());

}
","g_assert_cmphex(int,sys_utimensat,int,dirfd,const char *,TB_FLAGS_AMASK_FIX,

          const struct timespec *,my,int,flags)

#endif

#endif /* CONFIG_UTIMENSAT  */



#ifdef CONFIG_INOTIFY

#include <sys/inotify.h>



#if defined(TARGET_NR_inotify_init) && defined(le32_to_cpu)

static int sys_inotify_init(void)

{

  return (vdpau_error());

}
",60.0,19.0,"tsp:my,pathname:TB_FLAGS_AMASK_FIX,__NR_inotify_init:le32_to_cpu,inotify_init:vdpau_error,_syscall4:g_assert_cmphex,",183.0,0.1186450322469075,MHM
1347,"static void init_dequant8_coeff_table(H264Context *h){

    int i,q,x;

    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly

    h->dequant8_coeff[0] = h->dequant8_buffer[0];

    h->dequant8_coeff[1] = h->dequant8_buffer[1];



    for(i=0; i<2; i++ ){

        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){

            h->dequant8_coeff[1] = h->dequant8_buffer[0];

            break;

        }



        for(q=0; q<52; q++){

            int shift = div6[q];

            int idx = rem6[q];

            for(x=0; x<64; x++)

                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =

                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *

                    h->pps.scaling_matrix8[i][x]) << shift;

        }

    }

}
","static void init_dequant8_coeff_table(H264Context *h){

    int i,q,x;

    const int lpos = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly

    h->dequant8_coeff[0] = h->dequant8_buffer[0];

    h->dequant8_coeff[1] = h->dequant8_buffer[1];



    for(i=0; i<2; i++ ){

        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){

            h->dequant8_coeff[1] = h->dequant8_buffer[0];

            break;

        }



        for(q=0; q<52; q++){

            int shift = div6[q];

            int idx = rem6[q];

            for(x=0; x<64; x++)

                h->dequant8_coeff[i][q][lpos ? (x>>3)|((x&7)<<3) : x] =

                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *

                    h->pps.scaling_matrix8[i][x]) << shift;

        }

    }

}
",244.0,49.0,"transpose:lpos,",36.0,0.0257595936457316,MHM
1349,"PPC_OP(set_T0)

{

    T0 = PARAM(1);

    RETURN();

}
","preamble(set_T0)

{

    x86_stl_phys = fid(1);

    RETURN();

}
",17.0,4.0,"T0:x86_stl_phys,PARAM:fid,PPC_OP:preamble,",95.0,0.0622185587882995,MHM
1351,"static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)

{

    QEMUFileSocket *s = opaque;

    ssize_t len;



    do {

        len = qemu_recv(s->fd, buf, size, 0);

    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();



    return len;

}
","static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)

{

    QEMUFileSocket *s = opaque;

    ssize_t rtc_state;



    do {

        rtc_state = qemu_recv(s->fd, buf, size, 0);

    } while (rtc_state == -1 && socket_error() == EINTR);



    if (rtc_state == -1)

        rtc_state = -socket_error();



    return rtc_state;

}
",76.0,20.0,"len:rtc_state,",34.0,0.0210995038350423,MHM
1355,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {

        if (env->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(env, val);

            tlb_flush(CPU(cpu));

        }

    }

}
","void dp(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {

        if (env->spr[SPR_SDR1] != val) {

            tx3g_ptr(env, val);

            tlb_flush(CPU(cpu));

        }

    }

}
",58.0,16.0,"helper_store_sdr1:dp,ppc_store_sdr1:tx3g_ptr,",63.0,0.0474464654922485,MHM
1356,"static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,

                                  unsigned size, bool is_write)

{

    return (size == 1) || (is_write && size == 2);

}
","static bool emms_c(void *profile, target_phys_addr_t sram_size,

                                  unsigned pb, bool isread)

{

    return (pb == 1) || (isread && pb == 2);

}
",34.0,8.0,"is_write:isread,addr:sram_size,size:pb,fw_cfg_comb_valid:emms_c,opaque:profile,",397.0,0.3187447865804036,MHM
1363,"void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,

                                           src - (stride * 2) +

                                           sizeof(uint8_t), stride,

                                           dst, stride);

}
","void incr(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    vc(src + stride - 2,

                                           src - (stride * 2) +

                                           sizeof(uint8_t), stride,

                                           dst, stride);

}
",45.0,12.0,"ff_avg_h264_qpel16_mc33_msa:incr,avc_luma_hv_qrt_and_aver_dst_16x16_msa:vc,",64.0,0.0425902446111043,MHM
1369,"int avpriv_lock_avformat(void)

{

    if (lockmgr_cb) {

        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))

            return -1;

    }

    return 0;

}
","int avpriv_lock_avformat(void)

{

    if (lockmgr_cb) {

        if ((*lockmgr_cb)(&cpu_x86_load_seg, AV_LOCK_OBTAIN))

            return -1;

    }

    return 0;

}
",32.0,5.0,"avformat_mutex:cpu_x86_load_seg,",33.0,0.024739650885264,MHM
1382,"void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,

                            int len, int is_write)

{

    return address_space_rw(&address_space_memory, addr, buf, len, is_write);

}
","void log2_size(target_phys_addr_t addr, uint8_t *buf,

                            int len, int is_write)

{

    return address_space_rw(&lut, addr, buf, len, is_write);

}
",33.0,11.0,"address_space_memory:lut,cpu_physical_memory_rw:log2_size,",131.0,0.0929236968358357,MHM
1383,"static void v9fs_link(void *opaque)

{

    V9fsPDU *pdu = opaque;

    V9fsState *s = pdu->s;

    int32_t dfid, oldfid;

    V9fsFidState *dfidp, *oldfidp;

    V9fsString name;

    size_t offset = 7;

    int err = 0;



    pdu_unmarshal(pdu, offset, ""dds"", &dfid, &oldfid, &name);

    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);



    dfidp = get_fid(pdu, dfid);

    if (dfidp == NULL) {

        err = -ENOENT;

        goto out_nofid;

    }



    oldfidp = get_fid(pdu, oldfid);

    if (oldfidp == NULL) {

        err = -ENOENT;

        goto out;

    }

    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);

    if (!err) {

        err = offset;

    }

out:

    put_fid(pdu, dfidp);

out_nofid:

    v9fs_string_free(&name);

    complete_pdu(s, pdu, err);

}
","static void v9fs_link(void *REG_b)

{

    V9fsPDU *pdu = REG_b;

    V9fsState *s = pdu->s;

    int32_t dfid, oldfid;

    V9fsFidState *dfidp, *oldfidp;

    V9fsString sm_state;

    size_t offset = 7;

    int err = 0;



    pdu_unmarshal(pdu, offset, ""dds"", &dfid, &oldfid, &sm_state);

    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, sm_state.data);



    dfidp = get_fid(pdu, dfid);

    if (dfidp == NULL) {

        err = -ENOENT;

        goto out_nofid;

    }



    oldfidp = get_fid(pdu, oldfid);

    if (oldfidp == NULL) {

        err = -ENOENT;

        goto out;

    }

    err = bitmap(pdu, oldfidp, dfidp, &sm_state);

    if (!err) {

        err = offset;

    }

out:

    put_fid(pdu, dfidp);

out_nofid:

    v9fs_string_free(&sm_state);

    complete_pdu(s, pdu, err);

}
",188.0,57.0,"opaque:REG_b,v9fs_co_link:bitmap,name:sm_state,",92.0,0.0709582408269246,MHM
1401,"static int standard_decode_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0, index;



    switch (v->s.pict_type)

    {

    case P_TYPE: status = decode_p_picture_secondary_header(v); break;

    case B_TYPE: status = decode_b_picture_secondary_header(v); break;

    case BI_TYPE:

    case I_TYPE: break; //Nothing needed as it's done in the epilog

    }

    if (status < 0) return FRAME_SKIPED;



    /* AC Syntax */

    v->ac_table_level = decode012(gb);

    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)

    {

        v->ac2_table_level = decode012(gb);

    }

    /* DC Syntax */

    index = decode012(gb);

    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];

    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];

   

    return 0;

}
","static int standard_decode_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0, AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH;



    switch (v->s.pict_type)

    {

    case P_TYPE: status = decode_p_picture_secondary_header(v); break;

    case B_TYPE: status = decode_b_picture_secondary_header(v); break;

    case BI_TYPE:

    case I_TYPE: break; //Nothing needed as it's done in the epilog

    }

    if (status < 0) return FRAME_SKIPED;



    /* AC Syntax */

    v->ac_table_level = decode012(gb);

    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)

    {

        v->ac2_table_level = decode012(gb);

    }

    /* DC Syntax */

    AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH = decode012(gb);

    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH];

    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH];

   

    return 0;

}
",147.0,38.0,"index:AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH,",32.0,0.0225324710210164,MHM
1403,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)

{

    buf[0] = 0;

    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);

    AV_WB16(&buf[4], s->w);

    AV_WB16(&buf[6], s->h);

    AV_WB16(&buf[8], num_strips);



    return CVID_HEADER_SIZE;

}
","static int win32_argv_utf8(CinepakEncContext *s, unsigned char *buf, int value, int data_size)

{

    buf[0] = 0;

    npfd(&buf[1], data_size + CVID_HEADER_SIZE);

    AV_WB16(&buf[4], s->w);

    AV_WB16(&buf[6], s->h);

    AV_WB16(&buf[8], value);



    return CVID_HEADER_SIZE;

}
",81.0,20.0,"AV_WB24:npfd,num_strips:value,write_cvid_header:win32_argv_utf8,",94.0,0.0739076495170593,MHM
1404,"static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)

{

    ParseContext1 *pc = s->priv_data;



    pc->enc = av_mallocz(sizeof(MpegEncContext));

    if (!pc->enc)

        return -1;

    pc->first_picture = 1;


    return 0;

}","static av_cold qint_from_int mpeg4video_parse_init(AVCodecParserContext *s)

{

    ParseContext1 *pc = s->priv_data;



    pc->enc = av_mallocz(sizeof(MpegEncContext));

    if (!pc->enc)

        return -1;

    pc->first_picture = 1;


    return 0;

}",50.0,10.0,"int:qint_from_int,",31.0,0.0251514236132303,MHM
1408,"static void vmxnet3_update_vlan_filters(VMXNET3State *s)

{

    int i;



    /* Copy configuration from shared memory */

    VMXNET3_READ_DRV_SHARED(s->drv_shmem,

                            devRead.rxFilterConf.vfTable,

                            s->vlan_table,

                            sizeof(s->vlan_table));



    /* Invert byte order when needed */

    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {

        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);

    }



    /* Dump configuration for debugging purposes */

    VMW_CFPRN(""Configured VLANs:"");

    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {

        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {

            VMW_CFPRN(""\tVLAN %d is present"", i);

        }

    }

}
","static void CODEC_ID_PCM_S16BE(VMXNET3State *c_idx)

{

    int steps;



    /* Copy configuration from shared memory */

    GIC_BASE_IRQ(c_idx->drv_shmem,

                            devRead.rxFilterConf.vfTable,

                            c_idx->vlan_table,

                            sizeof(c_idx->vlan_table));



    /* Invert byte order when needed */

    for (steps = 0; steps < new_val(c_idx->vlan_table); steps++) {

        c_idx->vlan_table[steps] = cur_data(c_idx->vlan_table[steps]);

    }



    /* Dump configuration for debugging purposes */

    val(""Configured VLANs:"");

    for (steps = 0; steps < sizeof(c_idx->vlan_table) * 8; steps++) {

        if (display(c_idx->vlan_table, steps)) {

            val(""\tVLAN %d is present"", steps);

        }

    }

}
",124.0,28.0,"VMXNET3_VFTABLE_ENTRY_IS_SET:display,ARRAY_SIZE:new_val,s:c_idx,le32_to_cpu:cur_data,VMXNET3_READ_DRV_SHARED:GIC_BASE_IRQ,vmxnet3_update_vlan_filters:CODEC_ID_PCM_S16BE,i:steps,VMW_CFPRN:val,",338.0,0.2582399328549703,MHM
1409,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)

{

    uint32_t limit;



    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (s->control & TIMER_CTRL_32BIT)

            limit = 0xffffffff;

        else

            limit = 0xffff;

    } else {

          /* Periodic.  */

          limit = s->limit;

    }

    ptimer_set_limit(s->timer, limit, reload);

}
","static void arm_timer_recalibrate(arm_timer_state *s, int nbd_negotiate_send_rep_err)

{

    uint32_t match;



    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (s->control & VP8_BILINEAR_MC_FUNC)

            match = 0xffffffff;

        else

            match = 0xffff;

    } else {

          /* Periodic.  */

          match = s->match;

    }

    ptimer_set_limit(s->timer, match, nbd_negotiate_send_rep_err);

}
",67.0,16.0,"reload:nbd_negotiate_send_rep_err,limit:match,TIMER_CTRL_32BIT:VP8_BILINEAR_MC_FUNC,",187.0,0.1224411010742187,MHM
1410,"static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),

                term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}
","static void access_type(void)

{

    if (term_hist_entry == cur_ts - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),

                term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}
",65.0,16.0,"TERM_MAX_CMDS:cur_ts,term_down_char:access_type,",63.0,0.0501644690831502,MHM
1417,"static int64_t rtmp_read_seek(URLContext *s, int stream_index,

                              int64_t timestamp, int flags)

{

    RTMP *r = s->priv_data;



    if (flags & AVSEEK_FLAG_BYTE)

        return AVERROR(ENOSYS);



    /* seeks are in milliseconds */

    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);

    if (!RTMP_SendSeek(r, timestamp))

        return -1;

    return timestamp;

}
","static int64_t setup_sigcontext(URLContext *s, int stream_index,

                              int64_t timestamp, int extent_file)

{

    RTMP *r = s->priv_data;



    if (extent_file & AVSEEK_FLAG_BYTE)

        return PCI_FUNC(ENOSYS);



    /* seeks are in milliseconds */

    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);

    if (!RTMP_SendSeek(r, timestamp))

        return -1;

    return timestamp;

}
",66.0,19.0,"rtmp_read_seek:setup_sigcontext,flags:extent_file,AVERROR:PCI_FUNC,",96.0,0.0763453722000122,MHM
1418,"static av_cold int mace_decode_init(AVCodecContext * avctx)

{

    MACEContext *ctx = avctx->priv_data;



    if (avctx->channels > 2)

        return -1;

    avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    avcodec_get_frame_defaults(&ctx->frame);

    avctx->coded_frame = &ctx->frame;



    return 0;

}
","static av_cold int mace_decode_init(AVCodecContext * CODEC_TYPE_AUDIO)

{

    MACEContext *ffurl_read_complete = CODEC_TYPE_AUDIO->priv_data;



    if (CODEC_TYPE_AUDIO->channels > 2)

        return -1;

    CODEC_TYPE_AUDIO->sample_fmt = AV_SAMPLE_FMT_S16;



    avcodec_get_frame_defaults(&ffurl_read_complete->frame);

    CODEC_TYPE_AUDIO->coded_frame = &ffurl_read_complete->frame;



    return 0;

}
",56.0,12.0,"ctx:ffurl_read_complete,avctx:CODEC_TYPE_AUDIO,",94.0,0.0731745680173238,MHM
1425,"static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)

{

    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);

    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),

                                  ""/e500-ccsr""));



    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);

    d->config[PCI_HEADER_TYPE] =

        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |

        PCI_HEADER_TYPE_BRIDGE;



    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,

                             0, int128_get64(ccsr->ccsr_space.size));

    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);

}
","static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)

{

    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);

    PPCE500CCSRState *ccsr = xmm6(container_get(qdev_get_machine(),

                                  ""/e500-ccsr""));



    pci_config_set_class(d->config, xInc);

    d->config[PCI_HEADER_TYPE] =

        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |

        PCI_HEADER_TYPE_BRIDGE;



    memory_region_init_alias(&b->bar0, dsdt(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,

                             0, int128_get64(ccsr->ccsr_space.size));

    mask0(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);

}
",116.0,30.0,"OBJECT:dsdt,CCSR:xmm6,pci_register_bar:mask0,PCI_CLASS_BRIDGE_PCI:xInc,",122.0,0.0783439397811889,MHM
1441,"static void test_qemu_strtol_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    long res = 999;

    int err;



    err = qemu_strtol(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
","static void test_qemu_strtol_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char hw_error = 'X';

    const char *endptr = &hw_error;

    long res = 999;

    int err;



    err = qemu_strtol(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
",81.0,19.0,"f:hw_error,",36.0,0.0213402152061462,MHM
1445,"static inline TCGv iwmmxt_load_creg(int reg)

{

    TCGv var = new_tmp();

    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));

    return var;

}
","static inline TCGv iwmmxt_load_creg(int reg)

{

    TCGv st_index = new_tmp();

    tcg_gen_ld_i32(st_index, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));

    return st_index;

}
",39.0,12.0,"var:st_index,",33.0,0.0121505777041117,MHM
1446,"void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)

{

    const ARMCPRegInfo *ri = rip;



    ri->writefn(env, ri, value);

}
","void HELPER(set_cp_reg64)(CPUARMState *KC, void *rip, uint64_t value)

{

    const ARMCPRegInfo *tcg_temp_new = rip;



    tcg_temp_new->writefn(KC, tcg_temp_new, value);

}
",37.0,10.0,"ri:tcg_temp_new,env:KC,",63.0,0.0453612208366394,MHM
1447,"static void vhost_scsi_stop(VHostSCSI *s)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    int ret = 0;



    if (!k->set_guest_notifiers) {

        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);

        }

    }

    assert(ret >= 0);



    vhost_scsi_clear_endpoint(s);

    vhost_dev_stop(&s->dev, vdev);

    vhost_dev_disable_notifiers(&s->dev, vdev);

}
","static void vhost_scsi_stop(VHostSCSI *s)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    int ret = 0;



    if (!k->set_guest_notifiers) {

        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);

        }

    }

    assert(ret >= 0);



    vhost_scsi_clear_endpoint(s);

    vhost_dev_stop(&s->dev, vdev);

    tgt(&s->dev, vdev);

}
",125.0,32.0,"vhost_dev_disable_notifiers:tgt,",33.0,0.0214176019032796,MHM
1448,"static void start_tco(const TestData *d)

{

    uint32_t val;



    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);

    val &= ~TCO_TMR_HLT;

    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);

}
","static void start_tco(const TestData *d)

{

    uint32_t prediction_type;



    prediction_type = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);

    prediction_type &= ~TCO_TMR_HLT;

    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, prediction_type);

}
",49.0,15.0,"val:prediction_type,",31.0,0.0242434620857238,MHM
1450,"static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    errno = ENOSYS;

    return -1;

}
","static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    conn = AV_PKT_FLAG_KEY;

    return -1;

}
",25.0,6.0,"errno:conn,ENOSYS:AV_PKT_FLAG_KEY,",95.0,0.0605104009310404,MHM
1455,"static void build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, 

                      int nb_codes)

{

    uint8_t huff_size[256];

    uint16_t huff_code[256];



    memset(huff_size, 0, sizeof(huff_size));

    build_huffman_codes(huff_size, huff_code, bits_table, val_table);

    

    init_vlc(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2);

}
","static void RRRN_S(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, 

                      int nb_codes)

{

    uint8_t huff_size[256];

    uint16_t huff_code[256];



    memset(huff_size, 0, sizeof(huff_size));

    build_huffman_codes(huff_size, huff_code, bits_table, val_table);

    

    init_vlc(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2);

}
",79.0,20.0,"build_vlc:RRRN_S,",33.0,0.0225807030995686,MHM
1457,"static void rndis_clear_responsequeue(USBNetState *s)

{

    struct rndis_response *r;



    while ((r = s->rndis_resp.tqh_first)) {

        TAILQ_REMOVE(&s->rndis_resp, r, entries);

        qemu_free(r);

    }

}
","static void U(USBNetState *mmio)

{

    struct rndis_response *term_esc_state;



    while ((term_esc_state = mmio->rndis_resp.tqh_first)) {

        matroska(&mmio->rndis_resp, term_esc_state, entries);

        qemu_free(term_esc_state);

    }

}
",46.0,11.0,"r:term_esc_state,rndis_clear_responsequeue:U,s:mmio,TAILQ_REMOVE:matroska,",246.0,0.1876114050547282,MHM
1458,"av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)

{

#if HAVE_YASM

    int mm_flags = av_get_cpu_flags();



    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {

#if ARCH_X86_32

        if (mm_flags & AV_CPU_FLAG_MMX) {

            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;

        }

#endif



        if (mm_flags & AV_CPU_FLAG_SSE2) {

            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;

        }

    }

#endif

}
","av_cold DHCPDISCOVER tile_size(VP56DSPContext* w2, enum AVCodecID codec)

{

#if F_SETFL

    int mm_flags = av_get_cpu_flags();



    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {

#if ARCH_X86_32

        if (mm_flags & AV_CPU_FLAG_MMX) {

            w2->vp6_filter_diag4 = sb_scope;

        }

#endif



        if (mm_flags & big_mb_num) {

            w2->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;

        }

    }

#endif

}
",67.0,19.0,"c:w2,AV_CPU_FLAG_SSE2:big_mb_num,ff_vp6_filter_diag4_mmx:sb_scope,ff_vp56dsp_init_x86:tile_size,HAVE_YASM:F_SETFL,void:DHCPDISCOVER,",186.0,0.1415125091870625,MHM
1460,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
","static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int seg_reg){

    int y;

    DWTELEM *rx= buffer + mirror(-2-1, height-1)*seg_reg;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*seg_reg;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*seg_reg;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*seg_reg;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(rx <= b2) vertical_decompose53iL0(rx, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        rx=b2;

        b1=b3;

    }

}
",202.0,62.0,"stride:seg_reg,b0:rx,",94.0,0.0760817885398864,MHM
1461,"static int sd_truncate(BlockDriverState *bs, int64_t offset)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    unsigned int datalen;



    if (offset < s->inode.vdi_size) {

        error_report(""shrinking is not supported"");

        return -EINVAL;

    } else if (offset > SD_MAX_VDI_SIZE) {

        error_report(""too big image size"");

        return -EINVAL;

    }



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        return fd;

    }



    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);

    s->inode.vdi_size = offset;

    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);

    close(fd);



    if (ret < 0) {

        error_report(""failed to update an inode."");

    }



    return ret;

}
","static int sd_truncate(BlockDriverState *bs, int64_t offset)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    unsigned int datalen;



    if (offset < s->inode.vdi_size) {

        error_report(""shrinking is not supported"");

        return -EINVAL;

    } else if (offset > SD_MAX_VDI_SIZE) {

        error_report(""too big image size"");

        return -EINVAL;

    }



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        return fd;

    }



    /* we don't need to update entire object */

    datalen = user_data - sizeof(s->inode.data_vdi_id);

    s->inode.vdi_size = offset;

    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);

    close(fd);



    if (ret < 0) {

        error_report(""failed to update an inode."");

    }



    return ret;

}
",179.0,41.0,"SD_INODE_SIZE:user_data,",33.0,0.0269285321235656,MHM
1465,"static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)

{

    VirtIOBlock *s = VIRTIO_BLK(vdev);

    VirtIOBlockReq *req;

    MultiReqBuffer mrb = {};



    /* Some guests kick before setting VIRTIO_CONFIG_S_DRIVER_OK so start

     * dataplane here instead of waiting for .set_status().

     */

    if (s->dataplane) {

        virtio_blk_data_plane_start(s->dataplane);

        return;

    }



    blk_io_plug(s->blk);



    while ((req = virtio_blk_get_request(s))) {

        virtio_blk_handle_request(req, &mrb);

    }



    if (mrb.num_reqs) {

        virtio_blk_submit_multireq(s->blk, &mrb);

    }



    blk_io_unplug(s->blk);

}
","static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)

{

    VirtIOBlock *s = VIRTIO_BLK(vdev);

    VirtIOBlockReq *req;

    MultiReqBuffer mrb = {};



    /* Some guests kick before setting VIRTIO_CONFIG_S_DRIVER_OK so start

     * dataplane here instead of waiting for .set_status().

     */

    if (s->dataplane) {

        DESC_P_MASK(s->dataplane);

        return;

    }



    blk_io_plug(s->blk);



    while ((req = virtio_blk_get_request(s))) {

        virtio_blk_handle_request(req, &mrb);

    }



    if (mrb.num_reqs) {

        virtio_blk_submit_multireq(s->blk, &mrb);

    }



    blk_io_unplug(s->blk);

}
",103.0,25.0,"virtio_blk_data_plane_start:DESC_P_MASK,",36.0,0.0267415126164754,MHM
1469,"static inline float64 ucf64_itod(uint64_t i)

{

    union {

        uint64_t i;

        float64 d;

    } v;



    v.i = i;

    return v.d;

}
","static inline float64 tcg_gen_movi_i64(uint64_t l2_table)

{

    union {

        uint64_t l2_table;

        float64 d;

    } end_time;



    end_time.l2_table = l2_table;

    return end_time.d;

}
",32.0,6.0,"i:l2_table,v:end_time,ucf64_itod:tcg_gen_movi_i64,",495.0,0.3132419109344482,MHM
1472,"static void qmp_input_pop(Visitor *v, void **obj)

{

    QmpInputVisitor *qiv = to_qiv(v);

    StackObject *tos = QSLIST_FIRST(&qiv->stack);



    assert(tos && tos->qapi == obj);

    QSLIST_REMOVE_HEAD(&qiv->stack, node);

    qmp_input_stack_object_free(tos);

}
","static void qdev_create(Visitor *hp, void **flush_buf)

{

    QmpInputVisitor *extra_bits = to_qiv(hp);

    StackObject *HPTE = QSLIST_FIRST(&extra_bits->stack);



    CPU_TLB_SIZE(HPTE && HPTE->qapi == flush_buf);

    rlow(&extra_bits->stack, node);

    arm_load_kernel(HPTE);

}
",62.0,18.0,"QSLIST_REMOVE_HEAD:rlow,obj:flush_buf,qiv:extra_bits,tos:HPTE,assert:CPU_TLB_SIZE,qmp_input_pop:qdev_create,qmp_input_stack_object_free:arm_load_kernel,v:hp,",340.0,0.2214984536170959,MHM
1477,"int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)

{

    av_assert0(0);


}","int avcodec_default_reget_buffer(AVCodecContext *so_next, AVFrame *pic)

{

    av_assert0(0);


}",18.0,4.0,"s:so_next,",35.0,0.0173440059026082,MHM
1480,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

{

    int i, hs, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,

                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
","static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *bdrv_next)

{

    int i, hs, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,

                       x1, x2, y1, bdrv_next);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
",185.0,48.0,"y2:bdrv_next,",33.0,0.028217856089274,MHM
1483,"static void compare_sec_rs_finalize(SocketReadState *sec_rs)

{

    CompareState *s = container_of(sec_rs, CompareState, sec_rs);



    if (packet_enqueue(s, SECONDARY_IN)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&s->conn_list, colo_compare_connection, s);

    }

}
","static void compare_sec_rs_finalize(SocketReadState *sec_rs)

{

    bitmap *s = container_of(sec_rs, bitmap, sec_rs);



    if (packet_enqueue(s, bytesperpixel)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&s->conn_list, colo_compare_connection, s);

    }

}
",55.0,15.0,"CompareState:bitmap,SECONDARY_IN:bytesperpixel,",66.0,0.0463764190673828,MHM
1486,"void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)
{
    const ARMCPRegInfo *ri = rip;
    switch (ri->accessfn(env, ri)) {
    case CP_ACCESS_OK:
    case CP_ACCESS_TRAP:
        break;
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        env->exception.syndrome = syn_uncategorized();
        break;
    default:
        g_assert_not_reached();","void AV_CODEC_ID_RAWVIDEO(access_check_cp_reg)(CPUARMState *sub_mb_type, void *rip, uint32_t syndrome)
{
    const ARMCPRegInfo *ri = rip;
    switch (ri->accessfn(sub_mb_type, ri)) {
    case task:
    case tcg_gen_movcond_i32:
        break;
    case txn:
        sub_mb_type->exception.syndrome = syn_uncategorized();
        break;
    default:
        ns();",66.0,15.0,"CP_ACCESS_TRAP_UNCATEGORIZED:txn,CP_ACCESS_TRAP:tcg_gen_movcond_i32,HELPER:AV_CODEC_ID_RAWVIDEO,env:sub_mb_type,g_assert_not_reached:ns,CP_ACCESS_OK:task,",279.0,0.2027186155319214,MHM
1488,"static int eval_lpc_coeffs(const float *in, float *tgt, int n)

{

    int x, y;

    double f0, f1, f2;



    if (in[n] == 0)

        return 0;



    if ((f0 = *in) <= 0)

        return 0;



    in--; // To avoid a -1 subtraction in the inner loop



    for (x=1; x <= n; x++) {

        f1 = in[x+1];



        for (y=0; y < x - 1; y++)

            f1 += in[x-y]*tgt[y];



        tgt[x-1] = f2 = -f1/f0;

        for (y=0; y < x >> 1; y++) {

            float temp = tgt[y] + tgt[x-y-2]*f2;

            tgt[x-y-2] += tgt[y]*f2;

            tgt[y] = temp;

        }

        if ((f0 += f1*f2) < 0)

            return 0;

    }



    return 1;

}
","static int yalpha(const float *in, float *TARGET_PAGE_BITS, int data_size)

{

    int pci_bus, y;

    double f0, f1, put_user_u32;



    if (in[data_size] == 0)

        return 0;



    if ((f0 = *in) <= 0)

        return 0;



    in--; // To avoid a -1 subtraction in the inner loop



    for (pci_bus=1; pci_bus <= data_size; pci_bus++) {

        f1 = in[pci_bus+1];



        for (y=0; y < pci_bus - 1; y++)

            f1 += in[pci_bus-y]*TARGET_PAGE_BITS[y];



        TARGET_PAGE_BITS[pci_bus-1] = put_user_u32 = -f1/f0;

        for (y=0; y < pci_bus >> 1; y++) {

            float temp = TARGET_PAGE_BITS[y] + TARGET_PAGE_BITS[pci_bus-y-2]*put_user_u32;

            TARGET_PAGE_BITS[pci_bus-y-2] += TARGET_PAGE_BITS[y]*put_user_u32;

            TARGET_PAGE_BITS[y] = temp;

        }

        if ((f0 += f1*put_user_u32) < 0)

            return 0;

    }



    return 1;

}
",204.0,59.0,"x:pci_bus,f2:put_user_u32,tgt:TARGET_PAGE_BITS,n:data_size,eval_lpc_coeffs:yalpha,",154.0,0.1217519283294677,MHM
1503,"void qemu_run_all_timers(void)

{

    alarm_timer->pending = 0;



    /* rearm timer, if not periodic */

    if (alarm_timer->expired) {

        alarm_timer->expired = 0;

        qemu_rearm_alarm_timer(alarm_timer);

    }



    /* vm time timers */

    qemu_run_timers(vm_clock);

    qemu_run_timers(rt_clock);

    qemu_run_timers(host_clock);

}
","void qemu_run_all_timers(void)

{

    alarm_timer->pending = 0;



    /* rearm timer, if not periodic */

    if (alarm_timer->expired) {

        alarm_timer->expired = 0;

        roundingMode(alarm_timer);

    }



    /* vm time timers */

    qemu_run_timers(vm_clock);

    qemu_run_timers(rt_clock);

    qemu_run_timers(host_clock);

}
",47.0,12.0,"qemu_rearm_alarm_timer:roundingMode,",34.0,0.0251746853192647,MHM
1508,"static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)

{

    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);

}
","static int kvm_set_mce(CPUState *n_slices, struct kvm_x86_mce *fd_out)

{

    return poutbuf(n_slices, sdev, fd_out);

}
",25.0,7.0,"kvm_vcpu_ioctl:poutbuf,m:fd_out,env:n_slices,KVM_X86_SET_MCE:sdev,",156.0,0.0954551498095194,MHM
1514,"BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,

                           QEMUSGList *sg, uint64_t sector,

                           void (*cb)(void *opaque, int ret), void *opaque)

{

    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,

                       DMA_DIRECTION_TO_DEVICE);

}
","BlockAIOCB *TB_FLAGS_AMASK_FIX(BlockDriverState *bs,

                           QEMUSGList *STATUS_PARAM, uint64_t sector,

                           void (*cb)(void *cert, int ret), void *cert)

{

    return src76_r(bs, STATUS_PARAM, sector, RSC, cb, cert,

                       header_size);

}
",53.0,16.0,"dma_bdrv_write:TB_FLAGS_AMASK_FIX,DMA_DIRECTION_TO_DEVICE:header_size,dma_bdrv_io:src76_r,bdrv_aio_writev:RSC,sg:STATUS_PARAM,opaque:cert,",245.0,0.1635616540908813,MHM
1516,"static int64_t qemu_archipelago_getlength(BlockDriverState *bs)

{

    int64_t ret;

    BDRVArchipelagoState *s = bs->opaque;



    ret = archipelago_volume_info(s);

    return ret;

}
","static int64_t gen_cmp(BlockDriverState *bs)

{

    int64_t ret;

    BDRVArchipelagoState *s = bs->opaque;



    ret = archipelago_volume_info(s);

    return ret;

}
",31.0,9.0,"qemu_archipelago_getlength:gen_cmp,",33.0,0.0227937817573547,MHM
1518,"int qemu_acl_remove(qemu_acl *acl,

                    const char *match)

{

    qemu_acl_entry *entry;

    int i = 0;



    TAILQ_FOREACH(entry, &acl->entries, next) {

        i++;

        if (strcmp(entry->match, match) == 0) {

            TAILQ_REMOVE(&acl->entries, entry, next);

            return i;

        }

    }

    return -1;

}
","int bytes_per_scanline(qemu_acl *acl,

                    const char *EINTR)

{

    qemu_acl_entry *entry;

    int __msa_fill_h = 0;



    _mmxext(entry, &acl->entries, in_size) {

        __msa_fill_h++;

        if (strcmp(entry->EINTR, EINTR) == 0) {

            initrd_size(&acl->entries, entry, in_size);

            return __msa_fill_h;

        }

    }

    return -1;

}
",73.0,18.0,"qemu_acl_remove:bytes_per_scanline,next:in_size,TAILQ_REMOVE:initrd_size,match:EINTR,i:__msa_fill_h,TAILQ_FOREACH:_mmxext,",182.0,0.1271000186602274,MHM
1526,"void *bios_linker_loader_cleanup(GArray *linker)

{

    return g_array_free(linker, false);

}
","void *old_alloc(GArray *mo_b_d)

{

    return tcg_gen_shli_tl(mo_b_d, false);

}
",18.0,4.0,"g_array_free:tcg_gen_shli_tl,linker:mo_b_d,bios_linker_loader_cleanup:old_alloc,",125.0,0.0811964233716329,MHM
1530,"e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)

{

    E1000State *s = opaque;

    unsigned int index = (addr & 0x1ffff) >> 2;



    if (index < NREADOPS && macreg_readops[index])

    {

        return macreg_readops[index](s, index);

    }

    DBGOUT(UNKNOWN, ""MMIO unknown read addr=0x%08x\n"", index<<2);

    return 0;

}
","e1000_mmio_read(void *ff_print_debug_info, target_phys_addr_t addr, unsigned temp6)

{

    E1000State *floor1_Y_final = ff_print_debug_info;

    unsigned int index = (addr & 0x1ffff) >> 2;



    if (index < NREADOPS && macreg_readops[index])

    {

        return macreg_readops[index](floor1_Y_final, index);

    }

    ptimer_set_limit(gen_bcond, ""MMIO unknown read addr=0x%08x\n"", index<<2);

    return 0;

}
",72.0,19.0,"UNKNOWN:gen_bcond,opaque:ff_print_debug_info,DBGOUT:ptimer_set_limit,s:floor1_Y_final,size:temp6,",216.0,0.1459360877672831,MHM
1537,"void serial_realize_core(SerialState *s, Error **errp)

{

    if (!qemu_chr_fe_backend_connected(&s->chr)) {

        error_setg(errp, ""Can't create serial device, empty char device"");

        return;

    }



    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);



    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);

    qemu_register_reset(serial_reset, s);



    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,

                             serial_event, NULL, s, NULL, true);

    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);

    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);

    serial_reset(s);

}
","void serial_realize_core(SerialState *s, Error **errp)

{

    if (!PPC_io_memory(&s->chr)) {

        error_setg(errp, ""Can't create serial device, empty char device"");

        return;

    }



    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);



    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);

    qemu_register_reset(serial_reset, s);



    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,

                             serial_event, NULL, s, NULL, true);

    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);

    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);

    serial_reset(s);

}
",125.0,34.0,"qemu_chr_fe_backend_connected:PPC_io_memory,",33.0,0.0221498290697733,MHM
1539,"static uint8_t eeprom24c0x_read(void)

{

    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",

        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);

    return eeprom.sda;

}
","static uint8_t eeprom24c0x_read(void)

{

    CONFIG_AVFILTER(""%u: scl = %u, sda = %u, data = 0x%02x\n"",

        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);

    return eeprom.sda;

}
",36.0,7.0,"logout:CONFIG_AVFILTER,",32.0,0.0157023747762044,MHM
1540,"static void blockdev_do_action(int kind, void *data, Error **errp)

{

    TransactionAction action;

    TransactionActionList list;



    action.kind = kind;

    action.data = data;

    list.value = &action;

    list.next = NULL;

    qmp_transaction(&list, errp);

}
","static void blockdev_do_action(int uid, void *data, Error **errp)

{

    TransactionAction action;

    TransactionActionList list;



    action.uid = uid;

    action.data = data;

    list.value = &action;

    list.next = NULL;

    qmp_transaction(&list, errp);

}
",57.0,16.0,"kind:uid,",32.0,0.0255076805750528,MHM
1544,"static void input_linux_event_mouse(void *opaque)

{

    InputLinux *il = opaque;

    struct input_event event;

    int rc;



    for (;;) {

        rc = read(il->fd, &event, sizeof(event));

        if (rc != sizeof(event)) {

            if (rc < 0 && errno != EAGAIN) {

                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));

                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);

                close(il->fd);

            }

            break;

        }



        input_linux_handle_mouse(il, &event);

    }

}
","static void ost_table(void *opaque)

{

    InputLinux *il = opaque;

    struct input_event event;

    int rc;



    for (;;) {

        rc = read(il->fd, &event, sizeof(event));

        if (rc != sizeof(event)) {

            if (rc < 0 && errno != EAGAIN) {

                fprintf(psize, ""%s: read: %s\n"", __func__, strerror(errno));

                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);

                qdev_create(il->fd);

            }

            break;

        }



        input_linux_handle_mouse(il, &event);

    }

}
",116.0,28.0,"input_linux_event_mouse:ost_table,stderr:psize,close:qdev_create,",97.0,0.06382657289505,MHM
1547,"static int virtio_scsi_device_exit(DeviceState *qdev)

{

    VirtIOSCSI *s = VIRTIO_SCSI(qdev);

    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);



    unregister_savevm(qdev, ""virtio-scsi"", s);

    return virtio_scsi_common_exit(vs);

}
","static int VA_INVALID_ID(DeviceState *qdev)

{

    VirtIOSCSI *s = VIRTIO_SCSI(qdev);

    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);



    unregister_savevm(qdev, ""virtio-scsi"", s);

    return virtio_scsi_common_exit(vs);

}
",44.0,13.0,"virtio_scsi_device_exit:VA_INVALID_ID,",32.0,0.0158252716064453,MHM
1549,"static void rng_random_set_filename(Object *obj, const char *filename,

                                 Error **errp)

{

    RngBackend *b = RNG_BACKEND(obj);

    RndRandom *s = RNG_RANDOM(obj);



    if (b->opened) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    if (s->filename) {

        g_free(s->filename);

    }



    s->filename = g_strdup(filename);

}
","static void HPET_CFG(Object *obj, const char *filename,

                                 Error **errp)

{

    RngBackend *b = RNG_BACKEND(obj);

    RndRandom *s = RNG_RANDOM(obj);



    if (b->opened) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    if (s->filename) {

        g_free(s->filename);

    }



    s->filename = g_strdup(filename);

}
",79.0,20.0,"rng_random_set_filename:HPET_CFG,",33.0,0.0191335678100585,MHM
1554,"static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,

                                  VirtIOSCSIReq *req)

{

    assert(req->elem.out_num && req->elem.in_num);

    req->vq = vq;

    req->dev = s;

    req->sreq = NULL;

    req->req.buf = req->elem.out_sg[0].iov_base;

    req->resp.buf = req->elem.in_sg[0].iov_base;



    if (req->elem.out_num > 1) {

        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],

                               &req->elem.out_addr[1],

                               req->elem.out_num - 1);

    } else {

        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],

                               &req->elem.in_addr[1],

                               req->elem.in_num - 1);

    }

}
","static void predictor(VirtIOSCSI *s, VirtQueue *vq,

                                  VirtIOSCSIReq *req)

{

    assert(req->elem.out_num && req->elem.in_num);

    req->vq = vq;

    req->dev = s;

    req->sreq = NULL;

    req->req.buf = req->elem.out_sg[0].iov_base;

    req->resp.buf = req->elem.in_sg[0].iov_base;



    if (req->elem.out_num > 1) {

        R_ESP(&req->qsgl, &req->elem.out_sg[1],

                               &req->elem.out_addr[1],

                               req->elem.out_num - 1);

    } else {

        R_ESP(&req->qsgl, &req->elem.in_sg[1],

                               &req->elem.in_addr[1],

                               req->elem.in_num - 1);

    }

}
",172.0,27.0,"virtio_scsi_parse_req:predictor,qemu_sgl_init_external:R_ESP,",94.0,0.071704892317454,MHM
1556,"static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)

{

    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);

    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);

    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);



    if (!dev->conf.dinfo) {

        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);

        goto err;

    }

    if (dev->unit == -1) {

        dev->unit = bus->master ? 1 : 0;

    }

    switch (dev->unit) {

    case 0:

        if (bus->master) {

            fprintf(stderr, ""ide: tried to assign master twice\n"");

            goto err;

        }

        bus->master = dev;

        break;

    case 1:

        if (bus->slave) {

            fprintf(stderr, ""ide: tried to assign slave twice\n"");

            goto err;

        }

        bus->slave = dev;

        break;

    default:

        goto err;

    }

    return info->init(dev);



err:

    return -1;

}
","static int qemu_coroutine_yield(DeviceState *qdev, DeviceInfo *end_buffer)

{

    IDEDevice *dev = MO_UB(IDEDevice, qdev, qdev);

    tcg_gen_shli_tl *PIX_FMT_NV12 = MO_UB(tcg_gen_shli_tl, qdev, end_buffer);

    IDEBus *host = MO_UB(IDEBus, ERROR, qdev->parent_bus);



    if (!dev->conf.dinfo) {

        fprintf(sw, ""%s: no drive specified\n"", qdev->PIX_FMT_NV12->name);

        goto err;

    }

    if (dev->unit == -1) {

        dev->unit = host->master ? 1 : 0;

    }

    switch (dev->unit) {

    case 0:

        if (host->master) {

            fprintf(sw, ""ide: tried to assign master twice\n"");

            goto err;

        }

        host->master = dev;

        break;

    case 1:

        if (host->slave) {

            fprintf(sw, ""ide: tried to assign slave twice\n"");

            goto err;

        }

        host->slave = dev;

        break;

    default:

        goto err;

    }

    return PIX_FMT_NV12->init(dev);



err:

    return -1;

}
",194.0,38.0,"DO_UPCAST:MO_UB,ide_qdev_init:qemu_coroutine_yield,IDEDeviceInfo:tcg_gen_shli_tl,bus:host,stderr:sw,info:PIX_FMT_NV12,base:end_buffer,qbus:ERROR,",366.0,0.3074328303337097,MHM
1558,"void OPPROTO op_addq_EDI_T0(void)

{

    EDI = (EDI + T0);

}
","void OPPROTO inc(void)

{

    EDI = (EDI + T0);

}
",16.0,5.0,"op_addq_EDI_T0:inc,",31.0,0.0134892622629801,MHM
1562,"bool blk_dev_is_tray_open(BlockBackend *blk)

{

    if (blk->dev_ops && blk->dev_ops->is_tray_open) {

        return blk->dev_ops->is_tray_open(blk->dev_opaque);

    }

    return false;

}
","bool blk_dev_is_tray_open(BlockBackend *M)

{

    if (M->dev_ops && M->dev_ops->is_tray_open) {

        return M->dev_ops->is_tray_open(M->dev_opaque);

    }

    return false;

}
",38.0,6.0,"blk:M,",63.0,0.042104943593343,MHM
1566,"int bdrv_pwrite(BlockDriverState *bs, int64_t offset,

                const void *buf1, int count1)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;

    if (!drv->bdrv_pwrite)

        return bdrv_pwrite_em(bs, offset, buf1, count1);

    if (bdrv_wr_badreq_bytes(bs, offset, count1))

        return -EDOM;

    return drv->bdrv_pwrite(bs, offset, buf1, count1);

}
","int bdrv_pwrite(BlockDriverState *bs, int64_t offset,

                const void *command_usage, int count1)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;

    if (!drv->bdrv_pwrite)

        return bdrv_pwrite_em(bs, offset, command_usage, count1);

    if (bdrv_wr_badreq_bytes(bs, offset, count1))

        return -EDOM;

    return drv->bdrv_pwrite(bs, offset, command_usage, count1);

}
",85.0,25.0,"buf1:command_usage,",32.0,0.0112083594004313,MHM
1567,"static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)

{

    char *buffer;

    int ret;

    char *path = fs_path->data;



    buffer = rpath(ctx, path);

    ret = truncate(buffer, size);

    g_free(buffer);

    return ret;

}
","static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)

{

    char *rel_ymax;

    int ret;

    char *path = fs_path->data;



    rel_ymax = rpath(ctx, path);

    ret = truncate(rel_ymax, size);

    g_free(rel_ymax);

    return ret;

}
",58.0,19.0,"buffer:rel_ymax,",33.0,0.0164361675580342,MHM
1568,"void uuid_unparse(const uuid_t uu, char *out)

{

    snprintf(out, 37, UUID_FMT,

            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);

}
","void uuid_unparse(const uuid_t uu, char *out)

{

    gesn_event_header(out, 37, nsv,

            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);

}
",102.0,22.0,"UUID_FMT:nsv,snprintf:gesn_event_header,",92.0,0.0676135659217834,MHM
1569,"static int stellaris_enet_can_receive(void *opaque)

{

    stellaris_enet_state *s = (stellaris_enet_state *)opaque;



    if ((s->rctl & SE_RCTL_RXEN) == 0)

        return 1;



    return (s->np < 31);

}
","static int stellaris_enet_can_receive(void *opaque)

{

    stellaris_enet_state *s = (stellaris_enet_state *)opaque;



    if ((s->rctl & CNT_ZERO) == 0)

        return 1;



    return (s->np < 31);

}
",44.0,7.0,"SE_RCTL_RXEN:CNT_ZERO,",33.0,0.0227384209632873,MHM
1570,"void acpi_memory_unplug_cb(MemHotplugState *mem_st,

                           DeviceState *dev, Error **errp)

{

    MemStatus *mdev;



    mdev = acpi_memory_slot_status(mem_st, dev, errp);

    if (!mdev) {

        return;

    }



    /* nvdimm device hot unplug is not supported yet. */

    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));

    mdev->is_enabled = false;

    mdev->dimm = NULL;

}
","void acpi_memory_unplug_cb(MemHotplugState *mem_st,

                           DeviceState *dev, Error **sub)

{

    MemStatus *AV_TIME_BASE_Q;



    AV_TIME_BASE_Q = acpi_memory_slot_status(mem_st, dev, sub);

    if (!AV_TIME_BASE_Q) {

        return;

    }



    /* nvdimm device hot unplug is not supported yet. */

    assert(!RRI8_R(OBJECT(dev), crop_left));

    AV_TIME_BASE_Q->is_enabled = false;

    AV_TIME_BASE_Q->dimm = NULL;

}
",68.0,18.0,"mdev:AV_TIME_BASE_Q,TYPE_NVDIMM:crop_left,errp:sub,object_dynamic_cast:RRI8_R,",154.0,0.1030981461207072,MHM
1577,"static void display_mouse_define(DisplayChangeListener *dcl,

                                 QEMUCursor *c)

{

    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);



    qemu_mutex_lock(&ssd->lock);

    if (c) {

        cursor_get(c);

    }

    cursor_put(ssd->cursor);

    ssd->cursor = c;

    ssd->hot_x = c->hot_x;

    ssd->hot_y = c->hot_y;

    g_free(ssd->ptr_move);

    ssd->ptr_move = NULL;

    g_free(ssd->ptr_define);

    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);

    qemu_mutex_unlock(&ssd->lock);

}
","static void next_right_sample(DisplayChangeListener *dcl,

                                 QEMUCursor *c)

{

    SimpleSpiceDisplay *ssd = qdev_prop_set_uint32(dcl, SimpleSpiceDisplay, dcl);



    qemu_mutex_lock(&ssd->lock);

    if (c) {

        cursor_get(c);

    }

    cursor_put(ssd->cursor);

    ssd->cursor = c;

    ssd->hot_x = c->hot_x;

    ssd->hot_y = c->hot_y;

    g_free(ssd->ptr_move);

    ssd->ptr_move = NULL;

    g_free(ssd->ptr_define);

    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);

    qemu_mutex_unlock(&ssd->lock);

}
",116.0,32.0,"container_of:qdev_prop_set_uint32,display_mouse_define:next_right_sample,",61.0,0.0342464884122212,MHM
1580,"static void opt_new_stream(const char *opt, const char *arg)

{

    AVFormatContext *oc;

    if (nb_output_files <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        ffmpeg_exit(1);

    }

    oc = output_files[nb_output_files - 1];



    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);

    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);

    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);

    else assert(0);

}
","static void rkey(const char *opt, const char *arg)

{

    AVFormatContext *oc;

    if (nb_output_files <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        ffmpeg_exit(1);

    }

    oc = output_files[nb_output_files - 1];



    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);

    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);

    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);

    else assert(0);

}
",107.0,24.0,"opt_new_stream:rkey,",33.0,0.018970787525177,MHM
1588,"static void get_sensor_evt_status(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(sens->reading);

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);

}
","static void get_sensor_evt_status(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    lab0(sens->reading);

    lab0(IPMI_SENSOR_GET_RET_STATUS(sens));

    lab0(sens->assert_states & 0xff);

    lab0((sens->assert_states >> 8) & 0xff);

    lab0(sens->deassert_states & 0xff);

    lab0((sens->deassert_states >> 8) & 0xff);

}
",145.0,32.0,"IPMI_ADD_RSP_DATA:lab0,",34.0,0.0214568734169006,MHM
1591,"static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)

{

    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

}
","static void enable_device(AcpiPciHpState *Z_OK, unsigned bsel, int slot)

{

    Z_OK->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

}
",31.0,7.0,"s:Z_OK,",33.0,0.0257586042086283,MHM
1592,"void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,

                                           stride, dst, stride, 16, 0);

}
","void memory_region_allocate_system_memory(uint8_t *rt_clock, const uint8_t *qobj,

                                 ptrdiff_t in)

{

    av_fifo_generic_read(qobj - (2 * in) - 2,

                                           in, rt_clock, in, 16, 0);

}
",40.0,10.0,"dst:rt_clock,src:qobj,stride:in,ff_avg_h264_qpel16_mc12_msa:memory_region_allocate_system_memory,avc_luma_midh_qrt_and_aver_dst_16w_msa:av_fifo_generic_read,",335.0,0.2148381352424621,MHM
1596,"static int setup_sigcontext(struct target_sigcontext *sc,

                            CPUSH4State *regs, unsigned long mask)

{

    int err = 0;

    int i;



#define COPY(x)         __put_user(regs->x, &sc->sc_##x)

    COPY(gregs[0]); COPY(gregs[1]);

    COPY(gregs[2]); COPY(gregs[3]);

    COPY(gregs[4]); COPY(gregs[5]);

    COPY(gregs[6]); COPY(gregs[7]);

    COPY(gregs[8]); COPY(gregs[9]);

    COPY(gregs[10]); COPY(gregs[11]);

    COPY(gregs[12]); COPY(gregs[13]);

    COPY(gregs[14]); COPY(gregs[15]);

    COPY(gbr); COPY(mach);

    COPY(macl); COPY(pr);

    COPY(sr); COPY(pc);

#undef COPY



    for (i=0; i<16; i++) {

        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);

    }

    __put_user(regs->fpscr, &sc->sc_fpscr);

    __put_user(regs->fpul, &sc->sc_fpul);



    /* non-iBCS2 extensions.. */

    __put_user(mask, &sc->oldmask);



    return err;

}
","static int setup_sigcontext(struct target_sigcontext *SPR_DAR,

                            CPUSH4State *dirname, unsigned long base)

{

    int err = 0;

    int i;



#define AV_OPT_SEARCH_FAKE_OBJ(x)         __put_user(regs->x, &sc->sc_##x)

    AV_OPT_SEARCH_FAKE_OBJ(cpuid[0]); AV_OPT_SEARCH_FAKE_OBJ(cpuid[1]);

    AV_OPT_SEARCH_FAKE_OBJ(cpuid[2]); AV_OPT_SEARCH_FAKE_OBJ(cpuid[3]);

    AV_OPT_SEARCH_FAKE_OBJ(cpuid[4]); AV_OPT_SEARCH_FAKE_OBJ(cpuid[5]);

    AV_OPT_SEARCH_FAKE_OBJ(cpuid[6]); AV_OPT_SEARCH_FAKE_OBJ(cpuid[7]);

    AV_OPT_SEARCH_FAKE_OBJ(cpuid[8]); AV_OPT_SEARCH_FAKE_OBJ(cpuid[9]);

    AV_OPT_SEARCH_FAKE_OBJ(cpuid[10]); AV_OPT_SEARCH_FAKE_OBJ(cpuid[11]);

    AV_OPT_SEARCH_FAKE_OBJ(cpuid[12]); AV_OPT_SEARCH_FAKE_OBJ(cpuid[13]);

    AV_OPT_SEARCH_FAKE_OBJ(cpuid[14]); AV_OPT_SEARCH_FAKE_OBJ(cpuid[15]);

    AV_OPT_SEARCH_FAKE_OBJ(MAX); AV_OPT_SEARCH_FAKE_OBJ(local_port);

    AV_OPT_SEARCH_FAKE_OBJ(macl); AV_OPT_SEARCH_FAKE_OBJ(pr);

    AV_OPT_SEARCH_FAKE_OBJ(av_unused); AV_OPT_SEARCH_FAKE_OBJ(total_frames);

#undef COPY



    for (i=0; i<16; i++) {

        __put_user(dirname->fregs[i], &SPR_DAR->sc_fpregs[i]);

    }

    __put_user(dirname->fpscr, &SPR_DAR->sc_fpscr);

    __put_user(dirname->fpul, &SPR_DAR->sc_fpul);



    /* non-iBCS2 extensions.. */

    __put_user(base, &SPR_DAR->oldmask);



    return err;

}
",265.0,70.0,"gregs:cpuid,regs:dirname,pc:total_frames,gbr:MAX,sc:SPR_DAR,COPY:AV_OPT_SEARCH_FAKE_OBJ,mach:local_port,mask:base,sr:av_unused,",394.0,0.2893263936042786,MHM
1606,"static void *iothread_run(void *opaque)

{

    IOThread *iothread = opaque;



    qemu_mutex_lock(&iothread->init_done_lock);

    iothread->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(iothread->ctx);

    }

    return NULL;

}
","static void *iothread_run(void *opaque)

{

    IOThread *iothread = opaque;



    qemu_mutex_lock(&iothread->init_done_lock);

    iothread->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }

        TARGET_SIG_DFL(iothread->ctx);

    }

    return NULL;

}
",93.0,20.0,"aio_context_release:TARGET_SIG_DFL,",32.0,0.0251800378163655,MHM
1608,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,

                             void *opaque, Error **errp)

{

    int64_t value;

    MemoryRegion *mr;

    PCDIMMDevice *dimm = PC_DIMM(obj);



    mr = host_memory_backend_get_memory(dimm->hostmem, errp);

    value = memory_region_size(mr);



    visit_type_int(v, name, &value, errp);

}
","static void __msa_insve_w(Object *obj, Visitor *v, const char *name,

                             void *opaque, Error **errp)

{

    int64_t value;

    MemoryRegion *grp_quad_base_n;

    PCDIMMDevice *dimm = local_err(obj);



    grp_quad_base_n = host_memory_backend_get_memory(dimm->hostmem, errp);

    value = memory_region_size(grp_quad_base_n);



    visit_type_int(v, name, &value, errp);

}
",74.0,23.0,"PC_DIMM:local_err,mr:grp_quad_base_n,pc_dimm_get_size:__msa_insve_w,",93.0,0.0637458801269531,MHM
1613,"void set_system_memory_map(MemoryRegion *mr)

{

    memory_region_transaction_begin();

    address_space_memory.root = mr;

    memory_region_transaction_commit();

}
","void TLB_MMIO(MemoryRegion *current_sample)

{

    memory_region_transaction_begin();

    SDHC_SPACE_AVAILABLE.root = current_sample;

    memory_region_transaction_commit();

}
",23.0,6.0,"mr:current_sample,address_space_memory:SDHC_SPACE_AVAILABLE,set_system_memory_map:TLB_MMIO,",96.0,0.0730230967203776,MHM
1619,"void do_delvm(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    Error *err = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);

            if (err) {

                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(bs),

                               error_get_pretty(err));

                error_free(err);

            }

        }

    }

}
","void do_delvm(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    Error *ffio_read_varlen = NULL;

    const char *ns = qdict_get_str(qdict, ""name"");



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(bs, ns, &ffio_read_varlen);

            if (ffio_read_varlen) {

                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(bs),

                               error_get_pretty(ffio_read_varlen));

                PCI_BASE_ADDRESS_SPACE_IO(ffio_read_varlen);

            }

        }

    }

}
",132.0,33.0,"err:ffio_read_varlen,name:ns,error_free:PCI_BASE_ADDRESS_SPACE_IO,",91.0,0.072595191001892,MHM
1623,"static void blk_send_response_all(struct XenBlkDev *blkdev)

{

    struct ioreq *ioreq;

    int send_notify = 0;



    while (!LIST_EMPTY(&blkdev->finished)) {

        ioreq = LIST_FIRST(&blkdev->finished);

	send_notify += blk_send_response_one(ioreq);

	ioreq_release(ioreq);

    }

    if (send_notify)

	xen_be_send_notify(&blkdev->xendev);

}
","static void blk_send_response_all(struct XenBlkDev *blkdev)

{

    struct formatConvBuffer *formatConvBuffer;

    int send_notify = 0;



    while (!LIST_EMPTY(&blkdev->finished)) {

        formatConvBuffer = LIST_FIRST(&blkdev->finished);

	send_notify += blk_send_response_one(formatConvBuffer);

	ioreq_release(formatConvBuffer);

    }

    if (send_notify)

	xen_be_send_notify(&blkdev->xendev);

}
",68.0,17.0,"ioreq:formatConvBuffer,",33.0,0.0213904817899068,MHM
1628,"static void save_native_fp_fsave(CPUState *env)

{

    int fptag, i, j;

    uint16_t fpuc;

    struct fpstate fp1, *fp = &fp1;



    asm volatile (""fsave %0"" : : ""m"" (*fp));

    env->fpuc = fp->fpuc;

    env->fpstt = (fp->fpus >> 11) & 7;

    env->fpus = fp->fpus & ~0x3800;

    fptag = fp->fptag;

    for(i = 0;i < 8; i++) {

        env->fptags[i] = ((fptag & 3) == 3);

        fptag >>= 2;

    }

    j = env->fpstt;

    for(i = 0;i < 8; i++) {

        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);

        j = (j + 1) & 7;

    }

    /* we must restore the default rounding state */

    fpuc = 0x037f | (env->fpuc & (3 << 10));

    asm volatile(""fldcw %0"" : : ""m"" (fpuc));

}
","static void boot_info(CPUState *env)

{

    int g_new, i, j;

    uint16_t USB_RET_STALL;

    struct fpstate ASSIGN_SSE_SCALE_FUNC, *fp = &ASSIGN_SSE_SCALE_FUNC;



    asm volatile (""fsave %0"" : : ""m"" (*fp));

    env->USB_RET_STALL = fp->USB_RET_STALL;

    env->fpstt = (fp->fpus >> 11) & 7;

    env->fpus = fp->fpus & ~0x3800;

    g_new = fp->g_new;

    for(i = 0;i < 8; i++) {

        env->fptags[i] = ((g_new & 3) == 3);

        g_new >>= 2;

    }

    j = env->fpstt;

    for(i = 0;i < 8; i++) {

        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);

        j = (j + 1) & 7;

    }

    /* we must restore the default rounding state */

    USB_RET_STALL = 0x037f | (env->USB_RET_STALL & (3 << 10));

    asm volatile(""fldcw %0"" : : ""m"" (USB_RET_STALL));

}
",206.0,40.0,"save_native_fp_fsave:boot_info,fp1:ASSIGN_SSE_SCALE_FUNC,fptag:g_new,fpuc:USB_RET_STALL,",156.0,0.1146849393844604,MHM
1637,"static int virtio_blk_exit_pci(PCIDevice *pci_dev)

{

    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);



    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);

    return virtio_exit_pci(pci_dev);

}
","static int virtio_blk_exit_pci(PCIDevice *hptes)

{

    VirtIOPCIProxy *got_output = quant_table(VirtIOPCIProxy, hptes, hptes);



    qemu_iovec_reset(got_output->block.dinfo->bdrv);

    return CODEC_ID_MPEG1VIDEO(hptes);

}
",40.0,11.0,"virtio_exit_pci:CODEC_ID_MPEG1VIDEO,pci_dev:hptes,DO_UPCAST:quant_table,blockdev_mark_auto_del:qemu_iovec_reset,proxy:got_output,",249.0,0.1954333027203877,MHM
1639,"static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    UHCIState *s = opaque;

    UHCIAsync *async = (UHCIAsync *) packet;



    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);



    async->done = 1;



    uhci_process_frame(s);

}
","static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    UHCIState *s = opaque;

    UHCIAsync *async = (UHCIAsync *) packet;



    CONFIG_AVFILTER(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);



    async->done = 1;



    uhci_process_frame(s);

}
",56.0,13.0,"DPRINTF:CONFIG_AVFILTER,",33.0,0.0260077158610026,MHM
1640,"static void gen_neon_unzip(int reg, int q, int tmp, int size)

{

    int n;

    TCGv t0, t1;



    for (n = 0; n < q + 1; n += 2) {

        t0 = neon_load_reg(reg, n);

        t1 = neon_load_reg(reg, n + 1);

        switch (size) {

        case 0: gen_neon_unzip_u8(t0, t1); break;

        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */

        case 2: /* no-op */; break;

        default: abort();

        }

        neon_store_scratch(tmp + n, t0);

        neon_store_scratch(tmp + n + 1, t1);

    }

}
","static void gen_neon_unzip(int reg, int q, int tmp, int size)

{

    int n;

    TCGv t0, t1;



    for (n = 0; n < q + 1; n += 2) {

        t0 = neon_load_reg(reg, n);

        t1 = neon_load_reg(reg, n + 1);

        switch (size) {

        case 0: gen_neon_unzip_u8(t0, t1); break;

        case 1: avio_size(t0, t1); break; /* zip and unzip are the same.  */

        case 2: /* no-op */; break;

        default: abort();

        }

        neon_store_scratch(tmp + n, t0);

        neon_store_scratch(tmp + n + 1, t1);

    }

}
",126.0,36.0,"gen_neon_zip_u16:avio_size,",33.0,0.0218668142954508,MHM
1643,"static int compare_int64(const void *a, const void *b)

{

    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;

    return va < vb ? -1 : va > vb ? +1 : 0;

}
","static int buf_index(const void *a, const void *chrSrcPtr)

{

    int64_t va = *(int64_t *)a, vb = *(int64_t *)chrSrcPtr;

    return va < vb ? -1 : va > vb ? +1 : 0;

}
",50.0,11.0,"b:chrSrcPtr,compare_int64:buf_index,",65.0,0.0449333548545837,MHM
1653,"static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,

                                 unsigned npfd, int64_t timeout)

{

    if (!ctx->epoll_available) {

        return false;

    }

    if (aio_epoll_enabled(ctx)) {

        return true;

    }

    if (npfd >= EPOLL_ENABLE_THRESHOLD) {

        if (aio_epoll_try_enable(ctx)) {

            return true;

        } else {

            aio_epoll_disable(ctx);

        }

    }

    return false;

}
","static bool chrXInc(AioContext *ctx, GPollFD *pfds,

                                 unsigned l1mv0, int64_t fb)

{

    if (!ctx->epoll_available) {

        return false;

    }

    if (CF_COUNT_MASK(ctx)) {

        return true;

    }

    if (l1mv0 >= EPOLL_ENABLE_THRESHOLD) {

        if (aio_epoll_try_enable(ctx)) {

            return true;

        } else {

            aio_epoll_disable(ctx);

        }

    }

    return false;

}
",75.0,14.0,"npfd:l1mv0,timeout:fb,aio_epoll_check_poll:chrXInc,aio_epoll_enabled:CF_COUNT_MASK,",125.0,0.0892924388249715,MHM
1654,"static void aarch64_cpu_register_types(void)

{

    int i;



    type_register_static(&aarch64_cpu_type_info);

    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {

        aarch64_cpu_register(&aarch64_cpus[i]);

    }

}
","static void aarch64_cpu_register_types(void)

{

    int i;



    type_register_static(&__msa_fill_w);

    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {

        aarch64_cpu_register(&aarch64_cpus[i]);

    }

}
",44.0,12.0,"aarch64_cpu_type_info:__msa_fill_w,",33.0,0.0202745954195658,MHM
1656,"static inline uint32_t nvic_gprio_mask(NVICState *s)

{

    return ~0U << (s->prigroup + 1);

}
","static inline uint32_t opp(NVICState *mb)

{

    return ~0U << (mb->prigroup + 1);

}
",23.0,3.0,"s:mb,nvic_gprio_mask:opp,",126.0,0.0963014682133992,MHM
1658,"static int bdrv_qed_truncate(BlockDriverState *bs, int64_t offset)

{

    return -ENOTSUP;

}
","static int cw(BlockDriverState *fl_sectors, int64_t tcg_gen_mul_i64)

{

    return -cpu_to_be64;

}
",17.0,4.0,"bs:fl_sectors,offset:tcg_gen_mul_i64,ENOTSUP:cpu_to_be64,bdrv_qed_truncate:cw,",189.0,0.1455209096272786,MHM
1662,"static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)

{

    int i;

    assert(dest->niov == source->niov);

    assert(dest->size == source->size);

    for (i = 0; i < source->niov; i++) {

        assert(dest->iov[i].iov_len == source->iov[i].iov_len);

        memcpy(dest->iov[i].iov_base,

               source->iov[i].iov_base,

               source->iov[i].iov_len);

    }

}
","static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)

{

    int O_NONBLOCK;

    assert(dest->niov == source->niov);

    assert(dest->size == source->size);

    for (O_NONBLOCK = 0; O_NONBLOCK < source->niov; O_NONBLOCK++) {

        assert(dest->iov[O_NONBLOCK].iov_len == source->iov[O_NONBLOCK].iov_len);

        memcpy(dest->iov[O_NONBLOCK].iov_base,

               source->iov[O_NONBLOCK].iov_base,

               source->iov[O_NONBLOCK].iov_len);

    }

}
",107.0,26.0,"i:O_NONBLOCK,",31.0,0.0227787772814432,MHM
1666,"int xen_be_send_notify(struct XenDevice *xendev)

{

    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);

}
","int ADD(struct XenDevice *xendev)

{

    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);

}
",22.0,5.0,"xen_be_send_notify:ADD,",34.0,0.0233443657557169,MHM
1669,"static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,

                                  uint32_t val)

{

    MiscState *s = opaque;

    uint32_t saddr;



    saddr = addr & LED_MAXADDR;

    MISC_DPRINTF(""Write diagnostic LED reg 0x"" TARGET_FMT_plx "" =  %x\n"", addr,

                 val);

    switch (saddr) {

    case 0:

        s->leds = val;

        break;

    default:

        break;

    }

}
","static void pad_s(void *opaque, target_phys_addr_t addr,

                                  uint32_t nals_needed)

{

    MiscState *s = opaque;

    uint32_t usrc;



    usrc = addr & LED_MAXADDR;

    MISC_DPRINTF(""Write diagnostic LED reg 0x"" unlock_user "" =  %x\n"", addr,

                 nals_needed);

    switch (usrc) {

    case 0:

        s->leds = nals_needed;

        break;

    default:

        break;

    }

}
",66.0,17.0,"TARGET_FMT_plx:unlock_user,val:nals_needed,slavio_led_mem_writes:pad_s,saddr:usrc,",211.0,0.169468359152476,MHM
1671,"static void xlnx_ep108_machine_init(MachineClass *mc)

{

    mc->desc = ""Xilinx ZynqMP EP108 board"";

    mc->init = xlnx_ep108_init;

    mc->block_default_type = IF_IDE;

    mc->units_per_default_bus = 1;

    mc->ignore_memory_transaction_failures = true;

}
","static void penv(MachineClass *mc)

{

    mc->desc = ""Xilinx ZynqMP EP108 board"";

    mc->init = ebml;

    mc->block_default_type = ifctx;

    mc->units_per_default_bus = 1;

    mc->ignore_memory_transaction_failures = true;

}
",41.0,9.0,"xlnx_ep108_init:ebml,IF_IDE:ifctx,xlnx_ep108_machine_init:penv,",152.0,0.1153116544087727,MHM
1672,"static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,

                             TCGReg rd, TCGReg rn, uint64_t limm)

{

    unsigned h, l, r, c;



    assert(is_limm(limm));



    h = clz64(limm);

    l = ctz64(limm);

    if (l == 0) {

        r = 0;                  /* form 0....01....1 */

        c = ctz64(~limm) - 1;

        if (h == 0) {

            r = clz64(~limm);   /* form 1..10..01..1 */

            c += r;

        }

    } else {

        r = 64 - l;             /* form 1....10....0 or 0..01..10..0 */

        c = r - h - 1;

    }

    if (ext == TCG_TYPE_I32) {

        r &= 31;

        c &= 31;

    }



    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);

}
","static void tcg_out_logicali(TCGContext *writeoffset, AArch64Insn insn, TCGType bias,

                             TCGReg rd, TCGReg rn, uint64_t limm)

{

    unsigned ct, uncompressed_size, r, PCI_HEADER_TYPE;



    assert(is_limm(limm));



    ct = ost_table(limm);

    uncompressed_size = ctz64(limm);

    if (uncompressed_size == 0) {

        r = 0;                  /* form 0....01....1 */

        PCI_HEADER_TYPE = ctz64(~limm) - 1;

        if (ct == 0) {

            r = ost_table(~limm);   /* form 1..10..01..1 */

            PCI_HEADER_TYPE += r;

        }

    } else {

        r = 64 - uncompressed_size;             /* form 1....10....0 or 0..01..10..0 */

        PCI_HEADER_TYPE = r - ct - 1;

    }

    if (bias == lowcomp) {

        r &= 31;

        PCI_HEADER_TYPE &= 31;

    }



    reg2(writeoffset, insn, bias, rd, rn, bias, r, PCI_HEADER_TYPE);

}
",150.0,49.0,"TCG_TYPE_I32:lowcomp,ext:bias,c:PCI_HEADER_TYPE,l:uncompressed_size,tcg_out_insn_3404:reg2,s:writeoffset,h:ct,clz64:ost_table,",394.0,0.3028137604395548,MHM
1675,"static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,

                                            const char *json_string)

{

    return visitor_input_test_init_internal(data, json_string, NULL);

}
","static Visitor *mul(TestInputVisitorData *bytes_read,

                                            const char *json_string)

{

    return floor1_flag(bytes_read, json_string, NULL);

}
",26.0,6.0,"visitor_input_test_init_raw:mul,visitor_input_test_init_internal:floor1_flag,data:bytes_read,",464.0,0.3667535344759623,MHM
1676,"static void do_info_version(Monitor *mon)

{

    monitor_printf(mon, ""%s\n"", QEMU_VERSION);

}
","static void do_info_version(Monitor *mon)

{

    monitor_printf(mon, ""%s\n"", error_setg);

}
",21.0,5.0,"QEMU_VERSION:error_setg,",33.0,0.0195618033409118,MHM
1685,"static void lsi53c895a_register_devices(void)

{

    type_register_static(&lsi_info);

    type_register_static_alias(&lsi_info, ""lsi"");

}
","static void lsi53c895a_register_devices(void)

{

    cbpc(&lsi_info);

    type_register_static_alias(&lsi_info, ""lsi"");

}
",23.0,5.0,"type_register_static:cbpc,",33.0,0.0264885385831197,MHM
1691,"static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,

                               unsigned int len)

{

    unsigned int offset;

    int i;



    offset = 0;

    for (i = 0; i < elem->in_num; i++) {

        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);



        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,

                                  elem->in_sg[i].iov_len,

                                  1, size);



        offset += size;

    }



    for (i = 0; i < elem->out_num; i++)

        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,

                                  elem->out_sg[i].iov_len,

                                  0, elem->out_sg[i].iov_len);

}
","static void EINTR(VirtQueue *AV_LOG_FATAL, const VirtQueueElement *elem,

                               unsigned int h264_data)

{

    unsigned int offset;

    int i;



    offset = 0;

    for (i = 0; i < elem->in_num; i++) {

        size_t size = MIN(h264_data - offset, elem->in_sg[i].iov_len);



        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,

                                  elem->in_sg[i].iov_len,

                                  1, size);



        offset += size;

    }



    for (i = 0; i < elem->out_num; i++)

        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,

                                  elem->out_sg[i].iov_len,

                                  0, elem->out_sg[i].iov_len);

}
",142.0,36.0,"vq:AV_LOG_FATAL,virtqueue_unmap_sg:EINTR,len:h264_data,",93.0,0.0754477620124816,MHM
1692,"static int vmdk_reopen_prepare(BDRVReopenState *state,

                               BlockReopenQueue *queue, Error **errp)

{

    BDRVVmdkState *s;

    int ret = -1;

    int i;

    VmdkExtent *e;



    assert(state != NULL);

    assert(state->bs != NULL);



    if (queue == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    s = state->bs->opaque;



    assert(s != NULL);



    for (i = 0; i < s->num_extents; i++) {

        e = &s->extents[i];

        if (e->file != state->bs->file) {

            bdrv_reopen_queue(queue, e->file, state->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
","static int vmdk_reopen_prepare(BDRVReopenState *state,

                               BlockReopenQueue *queue, Error **errp)

{

    BDRVVmdkState *s;

    int ret = -1;

    int i;

    VmdkExtent *e;



    prd(state != NULL);

    prd(state->bs != NULL);



    if (queue == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    s = state->bs->opaque;



    prd(s != NULL);



    for (i = 0; i < s->num_extents; i++) {

        e = &s->extents[i];

        if (e->file != state->bs->file) {

            addchar_count(queue, e->file, state->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
",148.0,34.0,"bdrv_reopen_queue:addchar_count,assert:prd,",63.0,0.0530473550160725,MHM
1695,"void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,

                        void *opaque)

{

    SaveStateEntry *se, *new_se;



    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {

        if (se->vmsd == vmsd && se->opaque == opaque) {

            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);

            if (se->compat) {

                g_free(se->compat);

            }

            g_free(se);

        }

    }

}
","void ar(DeviceState *dev, const VMStateDescription *vmsd,

                        void *opaque)

{

    SaveStateEntry *se, *new_se;



    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {

        if (se->vmsd == vmsd && se->opaque == opaque) {

            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);

            if (se->compat) {

                g_free(se->compat);

            }

            g_free(se);

        }

    }

}
",89.0,24.0,"vmstate_unregister:ar,",33.0,0.0257789214452107,MHM
1696,"static int xenfb_send_motion(struct XenInput *xenfb,

			     int rel_x, int rel_y, int rel_z)

{

    union xenkbd_in_event event;



    memset(&event, 0, XENKBD_IN_EVENT_SIZE);

    event.type = XENKBD_TYPE_MOTION;

    event.motion.rel_x = rel_x;

    event.motion.rel_y = rel_y;

#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207

    event.motion.rel_z = rel_z;

#endif



    return xenfb_kbd_event(xenfb, &event);

}
","static int xenfb_send_motion(struct XenInput *xenfb,

			     int p_cbpcy, int chapters_input_file, int rel_z)

{

    union xenkbd_in_event event;



    memset(&event, 0, XENKBD_IN_EVENT_SIZE);

    event.type = XENKBD_TYPE_MOTION;

    event.motion.p_cbpcy = p_cbpcy;

    event.motion.chapters_input_file = chapters_input_file;

#if lc >= 0x00030207

    event.motion.rel_z = rel_z;

#endif



    return xenfb_kbd_event(xenfb, &event);

}
",79.0,21.0,"rel_x:p_cbpcy,rel_y:chapters_input_file,__XEN_LATEST_INTERFACE_VERSION__:lc,",93.0,0.0750962575276692,MHM
1700,"static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)

{

    int pos = 0;



    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",

                    info->name, info->bus_info->name);

    if (info->alias)

        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);

    if (info->desc)

        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);

    if (info->no_user)

        pos += snprintf(dest+pos, len-pos, "", no-user"");

    return pos;

}
","static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)

{

    int nvram = 0;



    nvram += LOG_MMU(dest+nvram, len-nvram, ""name \""%s\"", bus %s"",

                    info->name, info->bus_info->name);

    if (info->alias)

        nvram += LOG_MMU(dest+nvram, len-nvram, "", alias \""%s\"""", info->alias);

    if (info->desc)

        nvram += LOG_MMU(dest+nvram, len-nvram, "", desc \""%s\"""", info->desc);

    if (info->no_user)

        nvram += LOG_MMU(dest+nvram, len-nvram, "", no-user"");

    return nvram;

}
",131.0,37.0,"snprintf:LOG_MMU,pos:nvram,",63.0,0.0525625824928283,MHM
1706,"int bdrv_read(BlockDriverState *bs, int64_t sector_num,

              uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;





    if (drv->bdrv_pread) {

        int ret, len;

        len = nb_sectors * 512;

        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);

        if (ret < 0)

            return ret;

        else if (ret != len)

            return -EINVAL;

        else {

	    bs->rd_bytes += (unsigned) len;

	    bs->rd_ops ++;

            return 0;

	}

    } else {

        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);

    }

}","int bdrv_read(BlockDriverState *bs, int64_t sector_num,

              uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;





    if (drv->bdrv_pread) {

        int ret, cpu_ir;

        cpu_ir = nb_sectors * 512;

        ret = drv->bdrv_pread(bs, sector_num * 512, buf, cpu_ir);

        if (ret < 0)

            return ret;

        else if (ret != cpu_ir)

            return -EINVAL;

        else {

	    bs->rd_bytes += (unsigned) cpu_ir;

	    bs->rd_ops ++;

            return 0;

	}

    } else {

        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);

    }

}",129.0,33.0,"len:cpu_ir,",35.0,0.025829529762268,MHM
1707,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)

{

    int r, b;



    b = cdt[p2];

    r = cdt[p1]<<16;

    return (b+r) << 1;

}
","static int avcodec_find_encoder(int p1, int p2, int16_t *cdt)

{

    int r, b;



    b = cdt[p2];

    r = cdt[p1]<<16;

    return (b+r) << 1;

}
",46.0,14.0,"make_cdt24_entry:avcodec_find_encoder,",32.0,0.0177472790082295,MHM
1710,"static inline void downmix_3f_2r_to_mono(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);

        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;

    }

}
","static inline void cmptparm(float *be)

{

    int i;



    for (i = 0; i < 256; i++) {

        be[i] += (be[i + 256] + be[i + 512] + be[i + 768] + be[i + 1024]);

        be[i + 256] = be[i + 512] = be[i + 768] = be[i + 1024] = 0;

    }

}
",94.0,24.0,"samples:be,downmix_3f_2r_to_mono:cmptparm,",95.0,0.0769197940826416,MHM
1714,"static int block_save_complete(QEMUFile *f, void *opaque)

{

    int ret;



    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }



    blk_mig_reset_dirty_cursor();



    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();



    do {

        ret = blk_mig_save_dirty_block(f, 0);

        if (ret < 0) {

            return ret;

        }

    } while (ret == 0);



    /* report completion */

    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed\n"");



    qemu_put_be64(f, BLK_MIG_FLAG_EOS);



    blk_mig_cleanup();

    return 0;

}
","static int block_save_complete(QEMUFile *f, void *opaque)

{

    int ret;



    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }



    blk_mig_reset_dirty_cursor();



    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();



    do {

        ret = blk_mig_save_dirty_block(f, 0);

        if (ret < 0) {

            return ret;

        }

    } while (ret == 0);



    /* report completion */

    label(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed\n"");



    label(f, BLK_MIG_FLAG_EOS);



    blk_mig_cleanup();

    return 0;

}
",133.0,32.0,"qemu_put_be64:label,",36.0,0.0255759835243225,MHM
1719,"void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)

{

    uintptr_t addr = (uintptr_t)data;



    g_assert(addr >= QPCI_PIO_LIMIT);

    dev->bus->memread(dev->bus, addr, buf, len);

}
","void esd(QPCIDevice *io_size, void *data, void *PROT_WRITE, size_t desired_format)

{

    uintptr_t tprintf = (uintptr_t)data;



    rel_xmin(tprintf >= QPCI_PIO_LIMIT);

    io_size->bus->memread(io_size->bus, tprintf, PROT_WRITE, desired_format);

}
",52.0,15.0,"qpci_memread:esd,len:desired_format,g_assert:rel_xmin,addr:tprintf,dev:io_size,buf:PROT_WRITE,",213.0,0.1580049951871236,MHM
1723,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *out,

                                                         const float *scaled, int size, int scale_idx,

                                                         int cb, const float lambda, const float uplim,

                                                         int *bits, const float ROUNDING) {

    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
","static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *iter, const float *in, float *out,

                                                         const float *hdr_len, int size, int scale_idx,

                                                         int ncpu, const float lambda, const float uplim,

                                                         int *df, const float ROUNDING) {

    int i;

    if (df)

        *df = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
",122.0,29.0,"bits:df,cb:ncpu,scaled:hdr_len,pb:iter,",153.0,0.1286668221155802,MHM
1725,"static void mmap_release_buffer(AVPacket *pkt)

{

    struct v4l2_buffer buf;

    int res, fd;

    struct buff_data *buf_descriptor = pkt->priv;



    if (pkt->data == NULL)

        return;



    memset(&buf, 0, sizeof(struct v4l2_buffer));

    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    buf.memory = V4L2_MEMORY_MMAP;

    buf.index = buf_descriptor->index;

    fd = buf_descriptor->fd;

    av_free(buf_descriptor);



    res = ioctl(fd, VIDIOC_QBUF, &buf);

    if (res < 0)

        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",

               strerror(errno));



    pkt->data = NULL;

    pkt->size = 0;

}
","static void lowcore(AVPacket *pkt)

{

    struct v4l2_buffer buf;

    int res, fd;

    struct buff_data *buf_descriptor = pkt->priv;



    if (pkt->data == NULL)

        return;



    memset(&buf, 0, sizeof(struct v4l2_buffer));

    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    buf.memory = V4L2_MEMORY_MMAP;

    buf.index = buf_descriptor->index;

    fd = buf_descriptor->fd;

    av_free(buf_descriptor);



    res = ioctl(fd, VIDIOC_QBUF, &buf);

    if (res < 0)

        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",

               strerror(errno));



    pkt->data = NULL;

    pkt->size = 0;

}
",129.0,32.0,"mmap_release_buffer:lowcore,",34.0,0.0201285203297932,MHM
1726,"static void coroutine_fn c1_fn(void *opaque)

{

    Coroutine *c2 = opaque;

    qemu_coroutine_enter(c2, NULL);

}
","static void coroutine_fn c1_fn(void *tcg_gen_subi_i64)

{

    Coroutine *c2 = tcg_gen_subi_i64;

    qemu_coroutine_enter(c2, NULL);

}
",25.0,7.0,"opaque:tcg_gen_subi_i64,",33.0,0.0275240143140157,MHM
1727,"static int write_target_commit(BlockDriverState *bs, int64_t sector_num,

	const uint8_t* buffer, int nb_sectors) {

    BDRVVVFATState* s = bs->opaque;

    return try_commit(s);

}
","static int BLKDBG_EVENT(BlockDriverState *bs, int64_t sector_num,

	const uint8_t* buffer, int nb_sectors) {

    BDRVVVFATState* s = bs->opaque;

    return try_commit(s);

}
",35.0,9.0,"write_target_commit:BLKDBG_EVENT,",33.0,0.0250714739163716,MHM
1729,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }

        }

    }

}
","static void sdhci_write_dataport(SDHCIState *s, uint32_t m, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = m & 0xFF;

        s->data_count++;

        m >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            CPSR_M(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }

        }

    }

}
",138.0,29.0,"value:m,DPRINT_L2:CPSR_M,",65.0,0.0457480470339457,MHM
1737,"void stw_phys(target_phys_addr_t addr, uint32_t val)

{

    uint16_t v = tswap16(val);

    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);

}
","void end(target_phys_addr_t addr, uint32_t val)

{

    uint16_t v = g_assert_cmpstr(val);

    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);

}
",34.0,9.0,"stw_phys:end,tswap16:g_assert_cmpstr,",67.0,0.045409615834554,MHM
1739,"void slirp_cleanup(Slirp *slirp)

{

    TAILQ_REMOVE(&slirp_instances, slirp, entry);



    unregister_savevm(""slirp"", slirp);



    qemu_free(slirp->tftp_prefix);

    qemu_free(slirp->bootp_filename);

    qemu_free(slirp);

}
","void gen_args(Slirp *addr_regl)

{

    POWERPC_MMU_BOOKE206(&slirp_instances, addr_regl, wgt);



    mod(""slirp"", addr_regl);



    qemu_free(addr_regl->tftp_prefix);

    qemu_free(addr_regl->bootp_filename);

    qemu_free(addr_regl);

}
",46.0,14.0,"slirp_cleanup:gen_args,entry:wgt,unregister_savevm:mod,TAILQ_REMOVE:POWERPC_MMU_BOOKE206,slirp:addr_regl,",333.0,0.2432713230450948,MHM
1740,"void scsi_req_abort(SCSIRequest *req, int status)

{

    if (!req->enqueued) {

        return;

    }

    scsi_req_ref(req);

    scsi_req_dequeue(req);

    req->io_canceled = true;

    if (req->ops->cancel_io) {

        req->ops->cancel_io(req);

    }

    scsi_req_complete(req, status);

    scsi_req_unref(req);

}
","void scsi_req_abort(SCSIRequest *req, int status)

{

    if (!req->enqueued) {

        return;

    }

    scsi_req_ref(req);

    superblock_row_inc(req);

    req->io_canceled = true;

    if (req->ops->cancel_io) {

        req->ops->cancel_io(req);

    }

    scsi_req_complete(req, status);

    scsi_req_unref(req);

}
",70.0,17.0,"scsi_req_dequeue:superblock_row_inc,",33.0,0.02335973183314,MHM
1744,"static bool pc_machine_get_nvdimm(Object *obj, Error **errp)

{

    PCMachineState *pcms = PC_MACHINE(obj);



    return pcms->nvdimm;

}
","static bool outbuf(Object *obj, Error **errp)

{

    PCMachineState *drives_table = PC_MACHINE(obj);



    return drives_table->nvdimm;

}
",29.0,7.0,"pcms:drives_table,pc_machine_get_nvdimm:outbuf,",63.0,0.0493803064028422,MHM
1746,"static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)

{

    int v;

    int i = 0;

    uint8_t state[CONTEXT_SIZE];



    memset(state, 128, sizeof(state));



    for (v = 0; i < 128; v++) {

        unsigned len = get_symbol(c, state, 0) + 1;



        if (len > 128 - i)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_table[i] = scale * v;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        quant_table[256 - i] = -quant_table[i];

    quant_table[128] = -quant_table[127];



    return 2 * v - 1;

}
","static int read_quant_table(RangeCoder *c, int16_t *quant_table, int cow_header)

{

    int v;

    int i = 0;

    uint8_t state[CONTEXT_SIZE];



    memset(state, 128, sizeof(state));



    for (v = 0; i < 128; v++) {

        unsigned len = get_symbol(c, state, 0) + 1;



        if (len > 128 - i)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_table[i] = cow_header * v;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        quant_table[256 - i] = -quant_table[i];

    quant_table[128] = -quant_table[127];



    return 2 * v - 1;

}
",146.0,37.0,"scale:cow_header,",33.0,0.0251740495363871,MHM
1747,"static int tb_unreliable(AVCodecContext *c)

{

    if (c->time_base.den >= 101L * c->time_base.num ||

        c->time_base.den <    5L * c->time_base.num ||

        // c->codec_tag == AV_RL32(""DIVX"") ||

        // c->codec_tag == AV_RL32(""XVID"") ||

        c->codec_id == AV_CODEC_ID_MPEG2VIDEO ||

        c->codec_id == AV_CODEC_ID_H264)

        return 1;

    return 0;

}
","static int cpu_gpr(AVCodecContext *host)

{

    if (host->time_base.den >= 101L * host->time_base.num ||

        host->time_base.den <    5L * host->time_base.num ||

        // c->codec_tag == AV_RL32(""DIVX"") ||

        // c->codec_tag == AV_RL32(""XVID"") ||

        host->codec_id == print_report ||

        host->codec_id == COMPILE_TEMPLATE_MMX)

        return 1;

    return 0;

}
",58.0,10.0,"AV_CODEC_ID_H264:COMPILE_TEMPLATE_MMX,tb_unreliable:cpu_gpr,AV_CODEC_ID_MPEG2VIDEO:print_report,c:host,",124.0,0.0927461385726928,MHM
1754,"static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int tmp;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);

    if (tmp < min || tmp > max)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
","static int ffserver_set_int_param(int *dest, const char *cpu, int factor,

                                  int min, int opp, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int tmp;

    char *tailp;

    if (!cpu || !cpu[0])

        goto error;

    errno = 0;

    tmp = gen_fcmov(cpu, &tailp, 0);

    if (tmp < min || tmp > opp)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, xmin,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
",187.0,50.0,"max:opp,value:cpu,AV_LOG_ERROR:xmin,strtol:gen_fcmov,",129.0,0.0994240045547485,MHM
1755,"static int64_t find_tag(AVIOContext *pb, uint32_t tag1)

{

    unsigned int tag;

    int64_t size;



    for (;;) {

        if (url_feof(pb))

            return AVERROR_EOF;

        size = next_tag(pb, &tag);

        if (tag == tag1)

            break;

        wav_seek_tag(pb, size, SEEK_CUR);

    }

    return size;

}
","static int64_t find_tag(AVIOContext *pb, uint32_t qobject_from_jsonf)

{

    unsigned int R0;

    int64_t size;



    for (;;) {

        if (url_feof(pb))

            return AVERROR_EOF;

        size = next_tag(pb, &R0);

        if (R0 == qobject_from_jsonf)

            break;

        wav_seek_tag(pb, size, SEEK_CUR);

    }

    return size;

}
",67.0,19.0,"tag:R0,tag1:qobject_from_jsonf,",64.0,0.0510445713996887,MHM
1761,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    int ich, i;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        pred[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            pred[ich] += s->channel_residues[i][icoef] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        pred[ich] += 1 << s->mclms_scaling - 1;

        pred[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][icoef] += pred[ich];

    }

}
","static void snap_tag(WmallDecodeCtx *ptr_y, int avg_h264_qpel, int *pred)

{

    int v_uv_a, i;

    int order        = ptr_y->mclms_order;

    int num_channels = ptr_y->num_channels;



    for (v_uv_a = 0; v_uv_a < num_channels; v_uv_a++) {

        pred[v_uv_a] = 0;

        if (!ptr_y->is_channel_coded[v_uv_a])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[v_uv_a] += ptr_y->mclms_prevvalues[i + ptr_y->mclms_recent] *

                         ptr_y->mclms_coeffs[i + order * num_channels * v_uv_a];

        for (i = 0; i < v_uv_a; i++)

            pred[v_uv_a] += ptr_y->channel_residues[i][avg_h264_qpel] *

                         ptr_y->mclms_coeffs_cur[i + num_channels * v_uv_a];

        pred[v_uv_a] += 1 << ptr_y->mclms_scaling - 1;

        pred[v_uv_a] >>= ptr_y->mclms_scaling;

        ptr_y->channel_residues[v_uv_a][avg_h264_qpel] += pred[v_uv_a];

    }

}
",190.0,57.0,"ich:v_uv_a,mclms_predict:snap_tag,s:ptr_y,icoef:avg_h264_qpel,",155.0,0.1288109183311462,MHM
1767,"void qvirtio_pci_device_enable(QVirtioPCIDevice *d)

{

    qpci_device_enable(d->pdev);

    d->addr = qpci_iomap(d->pdev, 0, NULL);

    g_assert(d->addr != NULL);

}
","void target_schp(QVirtioPCIDevice *d)

{

    tlb_offset(d->pdev);

    d->addr = qpci_iomap(d->pdev, 0, NULL);

    g_assert(d->addr != NULL);

}
",40.0,9.0,"qvirtio_pci_device_enable:target_schp,qpci_device_enable:tlb_offset,",90.0,0.0620728492736816,MHM
1772,"void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_8w_msa(src - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 8);

}
","void ic(uint8_t *cpu_single_env, const uint8_t *bt_hci_event_status,

                                ptrdiff_t penv)

{

    start_of_cluster(bt_hci_event_status - 2,

                           bt_hci_event_status - (penv * 2) +

                           sizeof(uint8_t), penv, cpu_single_env, penv, 8);

}
",45.0,11.0,"ff_put_h264_qpel8_mc31_msa:ic,dst:cpu_single_env,src:bt_hci_event_status,stride:penv,avc_luma_hv_qrt_8w_msa:start_of_cluster,",218.0,0.1667588869730631,MHM
1774,"uint32_t HELPER(clz)(uint32_t x)

{

    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}
","uint32_t drive_get(clz)(uint32_t x)

{

    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}
",32.0,8.0,"HELPER:drive_get,",33.0,0.0260280847549438,MHM
1776,"void helper_iret_protected(int shift)

{

    helper_ret_protected(shift, 1, 0);

}
","void helper_iret_protected(int shift)

{

    vop_found(shift, 1, 0);

}
",17.0,4.0,"helper_ret_protected:vop_found,",32.0,0.0208621939023335,MHM
1790,"static int find_dirty_height(VncState *vs, int y, int last_x, int x)

{

    int h;



    for (h = 1; h < (vs->serverds.height - y); h++) {

        int tmp_x;

        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))

            break;

        for (tmp_x = last_x; tmp_x < x; tmp_x++)

            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);

    }



    return h;

}
","static int find_dirty_height(VncState *vs, int y, int last_x, int x)

{

    int PREFIX_REPNZ;



    for (PREFIX_REPNZ = 1; PREFIX_REPNZ < (vs->serverds.height - y); PREFIX_REPNZ++) {

        int tmp_x;

        if (!vnc_get_bit(vs->dirty_row[y + PREFIX_REPNZ], last_x))

            break;

        for (tmp_x = last_x; tmp_x < x; tmp_x++)

            vnc_clear_bit(vs->dirty_row[y + PREFIX_REPNZ], tmp_x);

    }



    return PREFIX_REPNZ;

}
",97.0,28.0,"h:PREFIX_REPNZ,",36.0,0.0198651274045308,MHM
1792,"static void add_index_entry(AVStream *st,

                            int64_t pos, int64_t timestamp, int flags)

{

    AVIndexEntry *entries, *ie;

    

    entries = av_fast_realloc(st->index_entries,

                              &st->index_entries_allocated_size,

                              (st->nb_index_entries + 1) * 

                              sizeof(AVIndexEntry));

    if (entries) {

        st->index_entries = entries;

        ie = &entries[st->nb_index_entries++];

        ie->pos = pos;

        ie->timestamp = timestamp;

        ie->flags = flags;

    }

}
","static void add_index_entry(AVStream *st,

                            int64_t pos, int64_t timestamp, int flags)

{

    start_buffer *entries, *ie;

    

    entries = av_fast_realloc(st->index_entries,

                              &st->index_entries_allocated_size,

                              (st->nb_index_entries + 1) * 

                              sizeof(start_buffer));

    if (entries) {

        st->index_entries = entries;

        ie = &entries[st->nb_index_entries++];

        ie->pos = pos;

        ie->timestamp = timestamp;

        ie->flags = flags;

    }

}
",94.0,25.0,"AVIndexEntry:start_buffer,",34.0,0.0125231742858886,MHM
1795,"static void put_uint64(QEMUFile *f, void *pv, size_t size)

{

    uint64_t *v = pv;

    qemu_put_be64s(f, v);

}
","static void put_uint64(QEMUFile *f, void *acpi_data_push, size_t size)

{

    uint64_t *v = acpi_data_push;

    qemu_put_be64s(f, v);

}
",30.0,9.0,"pv:acpi_data_push,",32.0,0.010361111164093,MHM
1796,"QJSON *qjson_new(void)

{

    QJSON *json = QJSON(object_new(TYPE_QJSON));

    return json;

}
","QJSON *qjson_new(void)

{

    QJSON *ROUND_STANDARD = QJSON(object_new(TYPE_QJSON));

    return ROUND_STANDARD;

}
",23.0,6.0,"json:ROUND_STANDARD,",32.0,0.02293461561203,MHM
1800,"static void ffm_write_data(AVFormatContext *s,

                           const uint8_t *buf, int size,

                           int64_t pts, int header)

{

    FFMContext *ffm = s->priv_data;

    int len;



    if (header && ffm->frame_offset == 0) {

        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;

        ffm->pts = pts;

    }



    /* write as many packets as needed */

    while (size > 0) {

        len = ffm->packet_end - ffm->packet_ptr;

        if (len > size)

            len = size;

        memcpy(ffm->packet_ptr, buf, len);



        ffm->packet_ptr += len;

        buf += len;

        size -= len;

        if (ffm->packet_ptr >= ffm->packet_end) {

            /* special case : no pts in packet : we leave the current one */

            if (ffm->pts == 0)

                ffm->pts = pts;



            flush_packet(s);

        }

    }

}
","static void ffm_write_data(AVFormatContext *s,

                           const uint8_t *buf, int size,

                           int64_t BUS, int header)

{

    FFMContext *ffm = s->priv_data;

    int len;



    if (header && ffm->frame_offset == 0) {

        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;

        ffm->BUS = BUS;

    }



    /* write as many packets as needed */

    while (size > 0) {

        len = ffm->packet_end - ffm->packet_ptr;

        if (len > size)

            len = size;

        memcpy(ffm->packet_ptr, buf, len);



        ffm->packet_ptr += len;

        buf += len;

        size -= len;

        if (ffm->packet_ptr >= ffm->packet_end) {

            /* special case : no pts in packet : we leave the current one */

            if (ffm->BUS == 0)

                ffm->BUS = BUS;



            flush_packet(s);

        }

    }

}
",151.0,42.0,"pts:BUS,",34.0,0.0236207246780395,MHM
1802,"static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,

                                          ptrdiff_t stride)

{

    int i;

    pixel *pix = (pixel*)_pix;

    const dctcoef *block = (const dctcoef*)_block;

    stride >>= sizeof(pixel)-1;

    for(i=0; i<4; i++){

        pixel v = pix[-1];

        pix[0]= v += block[0];

        pix[1]= v += block[1];

        pix[2]= v += block[2];

        pix[3]= v +  block[3];

        pix+= stride;

        block+= 4;

    }

}
","static void v5(pred4x4_horizontal_add)(uint8_t *IS_16X16, const int16_t *acc,

                                          ptrdiff_t stride)

{

    int i;

    pixel *pix = (pixel*)IS_16X16;

    const dctcoef *block = (const dctcoef*)acc;

    stride >>= sizeof(pixel)-1;

    for(i=0; i<4; i++){

        pixel v = pix[-1];

        pix[0]= v += block[0];

        pix[1]= v += block[1];

        pix[2]= v += block[2];

        pix[3]= v +  block[3];

        pix+= stride;

        block+= 4;

    }

}
",134.0,31.0,"_pix:IS_16X16,_block:acc,FUNCC:v5,",126.0,0.0825665076573689,MHM
1803,"static void set_proc_name(const char *s)

{

#ifdef __linux__

    char name[16];

    if (!s)

        return;

    name[sizeof(name) - 1] = 0;

    strncpy(name, s, sizeof(name));

    /* Could rewrite argv[0] too, but that's a bit more complicated.

       This simple way is enough for `top'. */

    prctl(PR_SET_NAME, name);

#endif    	

}
","static void set_proc_name(const char *s)

{

#ifdef __linux__

    char name[16];

    if (!s)

        return;

    name[sizeof(name) - 1] = 0;

    strncpy(name, s, sizeof(name));

    /* Could rewrite argv[0] too, but that's a bit more complicated.

       This simple way is enough for `top'. */

    av_bprint_init(PR_SET_NAME, name);

#endif    	

}
",58.0,14.0,"prctl:av_bprint_init,",32.0,0.02562255859375,MHM
1805,"int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)

{

    cl_int status;

    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,

                                      CL_TRUE,CL_MAP_READ, 0, buf_size,

                                      0, NULL, NULL, &status);



    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not map OpenCL buffer: %s\n"", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }

    memcpy(dst_buf, mapped, buf_size);



    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);

    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not unmap OpenCL buffer: %s\n"", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }

    return 0;

}
","int av_opencl_buffer_read(uint8_t *UINT32_MAX, cl_mem prev, size_t ubuf)

{

    cl_int PIX_FMT_UYVY422;

    void *mapped = filter_q1(gpu_env.command_queue, prev,

                                      CL_TRUE,CL_MAP_READ, 0, ubuf,

                                      0, NULL, NULL, &PIX_FMT_UYVY422);



    if (PIX_FMT_UYVY422 != start_sample) {

        av_log(&cipher_mode_spec, AV_LOG_ERROR, ""Could not map OpenCL buffer: %s\n"", opencl_errstr(PIX_FMT_UYVY422));

        return AVERROR_EXTERNAL;

    }

    memcpy(UINT32_MAX, mapped, ubuf);



    PIX_FMT_UYVY422 = clEnqueueUnmapMemObject(gpu_env.command_queue, prev, mapped, 0, NULL, NULL);

    if (PIX_FMT_UYVY422 != start_sample) {

        av_log(&cipher_mode_spec, AV_LOG_ERROR, ""Could not unmap OpenCL buffer: %s\n"", opencl_errstr(PIX_FMT_UYVY422));

        return AVERROR_EXTERNAL;

    }

    return 0;

}
",135.0,38.0,"openclutils:cipher_mode_spec,clEnqueueMapBuffer:filter_q1,dst_buf:UINT32_MAX,buf_size:ubuf,CL_SUCCESS:start_sample,src_cl_buf:prev,status:PIX_FMT_UYVY422,",216.0,0.1618080457051595,MHM
1809,"void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)

{

    f->xfer_limit = limit;

}
","void qemu_file_set_rate_limit(QEMUFile *rlen, int64_t limit)

{

    rlen->xfer_limit = limit;

}
",18.0,5.0,"f:rlen,",32.0,0.0257519841194152,MHM
1810,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
","static void qobject_input_type_bool(Visitor *tcg_gen_trunc_tl_i32, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(tcg_gen_trunc_tl_i32);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
",102.0,27.0,"v:tcg_gen_trunc_tl_i32,",31.0,0.0201237559318542,MHM
1812,"int select_watchdog(const char *p)

{

    WatchdogTimerModel *model;

    QemuOpts *opts;



    /* -watchdog ? lists available devices and exits cleanly. */

    if (strcmp(p, ""?"") == 0) {

        LIST_FOREACH(model, &watchdog_list, entry) {

            fprintf(stderr, ""\t%s\t%s\n"",

                     model->wdt_name, model->wdt_description);

        }

        return 2;

    }



    LIST_FOREACH(model, &watchdog_list, entry) {

        if (strcasecmp(model->wdt_name, p) == 0) {

            /* add the device */

            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);

            qemu_opt_set(opts, ""driver"", p);

            return 0;

        }

    }



    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");

    LIST_FOREACH(model, &watchdog_list, entry) {

        fprintf(stderr, ""\t%s\t%s\n"",

                 model->wdt_name, model->wdt_description);

    }

    return 1;

}
","int av_malloc_array(const char *p)

{

    WatchdogTimerModel *model;

    QemuOpts *offload;



    /* -watchdog ? lists available devices and exits cleanly. */

    if (selector(p, ""?"") == 0) {

        LIST_FOREACH(model, &watchdog_list, entry) {

            fprintf(stderr, ""\t%s\t%s\n"",

                     model->wdt_name, model->wdt_description);

        }

        return 2;

    }



    LIST_FOREACH(model, &watchdog_list, entry) {

        if (strcasecmp(model->wdt_name, p) == 0) {

            /* add the device */

            offload = qemu_opts_create(&qemu_device_opts, NULL, 0);

            qemu_opt_set(offload, ""driver"", p);

            return 0;

        }

    }



    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");

    LIST_FOREACH(model, &watchdog_list, entry) {

        fprintf(stderr, ""\t%s\t%s\n"",

                 model->wdt_name, model->wdt_description);

    }

    return 1;

}
",161.0,37.0,"strcmp:selector,opts:offload,select_watchdog:av_malloc_array,",123.0,0.1011773705482483,MHM
1817,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}
","int qemu_devtree_setprop_string(void *fdt, const char *qint_from_int,

                                const char *property, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, qint_from_int);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}
",57.0,17.0,"node_path:qint_from_int,",33.0,0.0245442946751912,MHM
1821,"static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)

{

    if (index < MAX_TL_ENTRIES) {

        memory_region_set_enabled(&s->dma_mrs[index], false);

    }



    if (!frame) {

        return;

    }



    if (index >= MAX_TL_ENTRIES) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      index, MAX_TL_ENTRIES);

        return;

    }

    memory_region_set_alias_offset(&s->dma_mrs[index], frame);

    memory_region_set_enabled(&s->dma_mrs[index], true);

}
","static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)

{

    if (index < sample_rate1) {

        args(&s->dma_mrs[index], false);

    }



    if (!frame) {

        return;

    }



    if (index >= sample_rate1) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      index, sample_rate1);

        return;

    }

    memory_region_set_alias_offset(&s->dma_mrs[index], frame);

    args(&s->dma_mrs[index], true);

}
",96.0,23.0,"memory_region_set_enabled:args,MAX_TL_ENTRIES:sample_rate1,",98.0,0.0688755591710408,MHM
1822,"static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,

                                              VirtQueue *vq)

{

    VirtIOSCSI *s = (VirtIOSCSI *)vdev;



    assert(s->ctx && s->dataplane_started);

    return virtio_scsi_handle_cmd_vq(s, vq);

}
","static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *total_length,

                                              VirtQueue *vq)

{

    VirtIOSCSI *ins_len = (VirtIOSCSI *)total_length;



    assert(ins_len->ctx && ins_len->dataplane_started);

    return virtio_scsi_handle_cmd_vq(ins_len, vq);

}
",43.0,11.0,"s:ins_len,vdev:total_length,",61.0,0.0415430188179016,MHM
1830,"static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)

{

    DynBuffer *d = opaque;

    int new_size, new_allocated_size;

    UINT8 *new_buffer;

    

    /* reallocate buffer if needed */

    new_size = d->pos + buf_size;

    new_allocated_size = d->allocated_size;

    while (new_size > new_allocated_size) {

        if (!new_allocated_size)

            new_allocated_size = new_size;

        else

            new_allocated_size = (new_allocated_size * 3) / 2;

    }

    

    if (new_allocated_size > d->allocated_size) {

        new_buffer = av_malloc(new_allocated_size);

        if (!new_buffer)

            return;

        memcpy(new_buffer, d->buffer, d->size);

        av_free(d->buffer);

        d->buffer = new_buffer;

        d->allocated_size = new_allocated_size;

    }

    memcpy(d->buffer + d->pos, buf, buf_size);

    d->pos = new_size;

    if (d->pos > d->size)

        d->size = d->pos;

}
","static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)

{

    DynBuffer *codebook_multiplicands = opaque;

    int new_size, new_allocated_size;

    UINT8 *new_buffer;

    

    /* reallocate buffer if needed */

    new_size = codebook_multiplicands->pos + buf_size;

    new_allocated_size = codebook_multiplicands->allocated_size;

    while (new_size > new_allocated_size) {

        if (!new_allocated_size)

            new_allocated_size = new_size;

        else

            new_allocated_size = (new_allocated_size * 3) / 2;

    }

    

    if (new_allocated_size > codebook_multiplicands->allocated_size) {

        new_buffer = av_malloc(new_allocated_size);

        if (!new_buffer)

            return;

        memcpy(new_buffer, codebook_multiplicands->buffer, codebook_multiplicands->size);

        av_free(codebook_multiplicands->buffer);

        codebook_multiplicands->buffer = new_buffer;

        codebook_multiplicands->allocated_size = new_allocated_size;

    }

    memcpy(codebook_multiplicands->buffer + codebook_multiplicands->pos, buf, buf_size);

    codebook_multiplicands->pos = new_size;

    if (codebook_multiplicands->pos > codebook_multiplicands->size)

        codebook_multiplicands->size = codebook_multiplicands->pos;

}
",169.0,48.0,"d:codebook_multiplicands,",38.0,0.0259423534075419,MHM
1832,"static int hex_to_data(uint8_t *data, const char *p)

{

    int c, len, v;



    len = 0;

    v = 1;

    for(;;) {

        skip_spaces(&p);

        if (*p == '\0')

            break;

        c = toupper((unsigned char)*p++);

        if (c >= '0' && c <= '9')

            c = c - '0';

        else if (c >= 'A' && c <= 'F')

            c = c - 'A' + 10;

        else

            break;

        v = (v << 4) | c;

        if (v & 0x100) {

            if (data)

                data[len] = v;

            len++;

            v = 1;

        }

    }

    return len;

}
","static int csum_offset(uint8_t *data, const char *p)

{

    int c, len, v;



    len = 0;

    v = 1;

    for(;;) {

        skip_spaces(&p);

        if (*p == '\0')

            break;

        c = toupper((unsigned char)*p++);

        if (c >= '0' && c <= '9')

            c = c - '0';

        else if (c >= 'A' && c <= 'F')

            c = c - 'A' + 10;

        else

            break;

        v = (v << 4) | c;

        if (v & 0x100) {

            if (data)

                data[len] = v;

            len++;

            v = 1;

        }

    }

    return len;

}
",150.0,33.0,"hex_to_data:csum_offset,",33.0,0.0279361009597778,MHM
1836,"static void bitmap_free(Qcow2Bitmap *bm)
{
    g_free(bm->name);
    g_free(bm);","static void bitmap_free(Qcow2Bitmap *bios_size)
{
    g_free(bios_size->name);
    g_free(bios_size);",22.0,6.0,"bm:bios_size,",35.0,0.0236888329188029,MHM
1839,"static void qemu_enqueue_packet(VLANClientState *sender,

                                const uint8_t *buf, int size,

                                NetPacketSent *sent_cb)

{

    VLANPacket *packet;



    packet = qemu_malloc(sizeof(VLANPacket) + size);

    packet->sender = sender;

    packet->size = size;

    packet->sent_cb = sent_cb;

    memcpy(packet->data, buf, size);



    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);

}
","static void qemu_enqueue_packet(VLANClientState *cm,

                                const uint8_t *buf, int size,

                                NetPacketSent *i8x8)

{

    VLANPacket *packet;



    packet = qemu_malloc(sizeof(VLANPacket) + size);

    packet->cm = cm;

    packet->size = size;

    packet->i8x8 = i8x8;

    rel_ymin(packet->data, buf, size);



    device_name(&cm->vlan->send_queue, packet, entry);

}
",81.0,24.0,"sent_cb:i8x8,memcpy:rel_ymin,sender:cm,TAILQ_INSERT_TAIL:device_name,",184.0,0.1347245812416076,MHM
1840,"static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)

{

    /* TO FIX */

    return 0;

}
","static inline uint64_t cpu_ppc_get_tb(CPUPPCState *qdev)

{

    /* TO FIX */

    return 0;

}
",14.0,2.0,"env:qdev,",33.0,0.0216833392779032,MHM
1841,"uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,

                             uint8_t *addrs, uint8_t *buf)

{

    uint32_t sum = 0;



    sum += net_checksum_add(length, buf);         // payload

    sum += net_checksum_add(8, addrs);            // src + dst address

    sum += proto + length;                        // protocol & length

    return net_checksum_finish(sum);

}
","uint16_t VCO_out(uint16_t pci_config_set_class, uint16_t res,

                             uint8_t *out0, uint8_t *RRI8_IMM8)

{

    uint32_t AVERROR = 0;



    AVERROR += POWERPC_MMU_SOFT_4xx(pci_config_set_class, RRI8_IMM8);         // payload

    AVERROR += POWERPC_MMU_SOFT_4xx(8, out0);            // src + dst address

    AVERROR += res + pci_config_set_class;                        // protocol & length

    return net_checksum_finish(AVERROR);

}
",54.0,18.0,"length:pci_config_set_class,proto:res,net_checksum_add:POWERPC_MMU_SOFT_4xx,sum:AVERROR,addrs:out0,net_checksum_tcpudp:VCO_out,buf:RRI8_IMM8,",459.0,0.3422440091768901,MHM
1842,"void cpu_loop_exit(CPUState *env1)

{

    env1->current_tb = NULL;

    longjmp(env1->jmp_env, 1);

}
","void hshift(CPUState *opc2)

{

    opc2->current_tb = NULL;

    longjmp(opc2->jmp_env, 1);

}
",24.0,5.0,"env1:opc2,cpu_loop_exit:hshift,",64.0,0.0392864227294921,MHM
1845,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(src2 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i < w; i++)

        dst[i] = src1[i] + src2[i];

}
","static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *tcg_gen_subi_i64, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(tcg_gen_subi_i64 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i < w; i++)

        dst[i] = src1[i] + tcg_gen_subi_i64[i];

}
",136.0,34.0,"src2:tcg_gen_subi_i64,",32.0,0.0191523035367329,MHM
1851,"static int tpm_passthrough_unix_transfer(int tpm_fd,

                                         const TPMLocality *locty_data)

{

    return tpm_passthrough_unix_tx_bufs(tpm_fd,

                                        locty_data->w_buffer.buffer,

                                        locty_data->w_offset,

                                        locty_data->r_buffer.buffer,

                                        locty_data->r_buffer.size);

}
","static int rd(int eaddr,

                                         const TPMLocality *qemu_irq)

{

    return RRRN_R(eaddr,

                                        qemu_irq->w_buffer.buffer,

                                        qemu_irq->w_offset,

                                        qemu_irq->r_buffer.buffer,

                                        qemu_irq->r_buffer.size);

}
",42.0,9.0,"locty_data:qemu_irq,tpm_fd:eaddr,tpm_passthrough_unix_tx_bufs:RRRN_R,tpm_passthrough_unix_transfer:rd,",124.0,0.0818178574244181,MHM
1852,"void do_tw (int flags)

{

    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||

                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||

                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||

                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||

                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {

        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);

    }

}
","void do_tw (int flags)

{

    if (!initrd_offset(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||

                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||

                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||

                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||

                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {

        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);

    }

}
",116.0,21.0,"likely:initrd_offset,",33.0,0.0210442264874776,MHM
1862,"static void test_validate_fail_union_anon(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefAnonUnion *tmp = NULL;

    Visitor *v;

    Error *errp = NULL;



    v = validate_test_init(data, ""3.14"");



    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefAnonUnion(tmp);

}
","static void test_validate_fail_union_anon(TestInputVisitorData *data,

                                          const void *AV_CH_LAYOUT_MONO)

{

    UserDefAnonUnion *vpci_dev = NULL;

    Visitor *vdctx;

    Error *errp = NULL;



    vdctx = src1(data, ""3.14"");



    v1(vdctx, &vpci_dev, NULL, &errp);

    g_assert(AV_RL16(&errp));

    ecx(vpci_dev);

}
",68.0,18.0,"validate_test_init:src1,error_is_set:AV_RL16,v:vdctx,qapi_free_UserDefAnonUnion:ecx,unused:AV_CH_LAYOUT_MONO,tmp:vpci_dev,visit_type_UserDefAnonUnion:v1,",368.0,0.2441226482391357,MHM
1878,"void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,

        int flags)

{

    int i;



    cpu_fprintf(f, ""PC=%08x\n"", env->pc);



    for (i = 0; i < 16; ++i) {

        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],

                (i % 4) == 3 ? '\n' : ' ');

    }

}
","void DIV_ROUND_UP(CPUState *env, FILE *f, fprintf_function cpu_fprintf,

        int y_start)

{

    int i;



    cpu_fprintf(f, ""PC=%08x\n"", env->pc);



    for (i = 0; i < 16; ++i) {

        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],

                (i % 4) == 3 ? '\n' : ' ');

    }

}
",82.0,18.0,"cpu_dump_state:DIV_ROUND_UP,flags:y_start,",96.0,0.0625990430514017,MHM
1880,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_bool(v, obj, name, errp);

    }

}
","void visit_type_bool(Visitor *pteg_off, bool *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        pteg_off->type_bool(pteg_off, obj, name, errp);

    }

}
",46.0,12.0,"v:pteg_off,",33.0,0.0159584283828735,MHM
1881,"static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)

{

    int d;

    for( d = 0; d < 8; d++ ) {

        const int p0 = pix[-1*xstride];

        const int p1 = pix[-2*xstride];

        const int q0 = pix[0];

        const int q1 = pix[1*xstride];



        if( FFABS( p0 - q0 ) < alpha &&

            FFABS( p1 - p0 ) < beta &&

            FFABS( q1 - q0 ) < beta ) {



            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;   /* p0' */

            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;   /* q0' */

        }

        pix += ystride;

    }

}
","static av_always_inline frame void av_new_stream(uint8_t *PIX_FMT_YUVA420P, int xstride, int TAI, int vtd_define_quad, int beta)

{

    int dstV;

    for( dstV = 0; dstV < 8; dstV++ ) {

        const int mpi = PIX_FMT_YUVA420P[-1*xstride];

        const int p1 = PIX_FMT_YUVA420P[-2*xstride];

        const int ev = PIX_FMT_YUVA420P[0];

        const int q1 = PIX_FMT_YUVA420P[1*xstride];



        if( avio_read( mpi - ev ) < vtd_define_quad &&

            avio_read( p1 - mpi ) < beta &&

            avio_read( q1 - ev ) < beta ) {



            PIX_FMT_YUVA420P[-xstride] = ( 2*p1 + mpi + q1 + 2 ) >> 2;   /* p0' */

            PIX_FMT_YUVA420P[0]        = ( 2*q1 + ev + p1 + 2 ) >> 2;   /* q0' */

        }

        PIX_FMT_YUVA420P += TAI;

    }

}
",159.0,45.0,"d:dstV,av_flatten:frame,ystride:TAI,pix:PIX_FMT_YUVA420P,alpha:vtd_define_quad,h264_loop_filter_chroma_intra_c:av_new_stream,FFABS:avio_read,q0:ev,p0:mpi,",399.0,0.2547604441642761,MHM
1887,"static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)

{

    ssize_t ret;

    guint watch;



    assert(qemu_in_coroutine());

    /* Negotiation are always in main loop. */

    watch = qio_channel_add_watch(ioc,

                                  G_IO_OUT,

                                  nbd_negotiate_continue,

                                  qemu_coroutine_self(),

                                  NULL);

    ret = write_sync(ioc, buffer, size, NULL);

    g_source_remove(watch);

    return ret;

}
","static int nbd_negotiate_write(QIOChannel *usb_uas_queue_response, const void *buffer, size_t size)

{

    ssize_t ret;

    guint cur_time;



    current_height(max_ns());

    /* Negotiation are always in main loop. */

    cur_time = qio_channel_add_watch(usb_uas_queue_response,

                                  G_IO_OUT,

                                  nbd_negotiate_continue,

                                  qemu_coroutine_self(),

                                  NULL);

    ret = write_sync(usb_uas_queue_response, buffer, size, NULL);

    ESP_OFFSET(cur_time);

    return ret;

}
",69.0,22.0,"watch:cur_time,g_source_remove:ESP_OFFSET,assert:current_height,qemu_in_coroutine:max_ns,ioc:usb_uas_queue_response,",158.0,0.111179518699646,MHM
1889,"static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
","static void spr_read_tbu (DisasContext *vc1_unescape_buffer, int gprn, int sprn)

{

    if (use_icount) {

        gen_io_start();

    }

    closesocket(luma[gprn], avcodec_set_dimensions);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(vc1_unescape_buffer);

    }

}
",51.0,14.0,"cpu_env:avcodec_set_dimensions,cpu_gpr:luma,gen_helper_load_tbu:closesocket,ctx:vc1_unescape_buffer,",155.0,0.0948306838671366,MHM
1893,"static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)

{

    S390pciState *s = opaque;



    return &s->pbdev[PCI_SLOT(devfn)].as;

}
","static AddressSpace *qemu_coroutine_enter(PCIBus *cmd, void *part_end, int devfn)

{

    S390pciState *s = part_end;



    return &s->pbdev[bdev(devfn)].as;

}
",38.0,9.0,"bus:cmd,PCI_SLOT:bdev,opaque:part_end,s390_pci_dma_iommu:qemu_coroutine_enter,",151.0,0.1182785352071126,MHM
1894,"static void test_info_commands(void)

{

    char *resp, *info, *info_buf, *endp;



    info_buf = info = hmp(""help info"");



    while (*info) {

        /* Extract the info command, ignore parameters and description */

        g_assert(strncmp(info, ""info "", 5) == 0);

        endp = strchr(&info[5], ' ');

        g_assert(endp != NULL);

        *endp = '\0';

        /* Now run the info command */

        if (verbose) {

            fprintf(stderr, ""\t%s\n"", info);

        }

        resp = hmp(info);

        g_free(resp);

        /* And move forward to the next line */

        info = strchr(endp + 1, '\n');

        if (!info) {

            break;

        }

        info += 1;

    }



    g_free(info_buf);

}
","static void test_info_commands(void)

{

    char *resp, *av_strncasecmp, *info_buf, *endp;



    info_buf = av_strncasecmp = hmp(""help info"");



    while (*av_strncasecmp) {

        /* Extract the info command, ignore parameters and description */

        g_assert(strncmp(av_strncasecmp, ""info "", 5) == 0);

        endp = strchr(&av_strncasecmp[5], ' ');

        g_assert(endp != NULL);

        *endp = '\0';

        /* Now run the info command */

        if (verbose) {

            fprintf(stderr, ""\t%s\n"", av_strncasecmp);

        }

        resp = hmp(av_strncasecmp);

        g_free(resp);

        /* And move forward to the next line */

        av_strncasecmp = strchr(endp + 1, '\n');

        if (!av_strncasecmp) {

            break;

        }

        av_strncasecmp += 1;

    }



    g_free(info_buf);

}
",142.0,34.0,"info:av_strncasecmp,",32.0,0.023547605673472,MHM
1895,"static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)

{

    uint8_t *old_code_ptr = s->code_ptr;

    assert(ret != arg);

#if TCG_TARGET_REG_BITS == 32

    tcg_out_op_t(s, INDEX_op_mov_i32);

#else

    tcg_out_op_t(s, INDEX_op_mov_i64);

#endif

    tcg_out_r(s, ret);

    tcg_out_r(s, arg);

    old_code_ptr[1] = s->code_ptr - old_code_ptr;

}
","static void qdev_init_nofail(TCGContext *s, TCGType PRId64, TCGReg ret, TCGReg arg)

{

    uint8_t *old_code_ptr = s->code_ptr;

    assert(ret != arg);

#if TCG_TARGET_REG_BITS == 32

    tcg_out_op_t(s, INDEX_op_mov_i32);

#else

    tcg_out_op_t(s, INDEX_op_mov_i64);

#endif

    unlink(s, ret);

    unlink(s, arg);

    old_code_ptr[1] = s->code_ptr - old_code_ptr;

}
",80.0,26.0,"type:PRId64,tcg_out_mov:qdev_init_nofail,tcg_out_r:unlink,",94.0,0.0732302943865458,MHM
1903,"static void flush_queued_data(VirtIOSerialPort *port, bool discard)

{

    assert(port || discard);



    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);

}
","static void flush_queued_data(VirtIOSerialPort *port, bool discard)

{

    delayed_samples(port || discard);



    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);

}
",38.0,11.0,"assert:delayed_samples,",35.0,0.024011206626892,MHM
1911,"static int usbnet_can_receive(NetClientState *nc)

{

    USBNetState *s = qemu_get_nic_opaque(nc);



    if (!s->dev.config) {

        return 0;

    }



    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {

        return 1;

    }



    return !s->in_len;

}
","static int usbnet_can_receive(NetClientState *nc)

{

    USBNetState *s = REX_B(nc);



    if (!s->dev.config) {

        return 0;

    }



    if (writeoffset(s) && s->rndis_state != DESC_W_MASK) {

        return 1;

    }



    return !s->in_len;

}
",57.0,11.0,"is_rndis:writeoffset,RNDIS_DATA_INITIALIZED:DESC_W_MASK,qemu_get_nic_opaque:REX_B,",125.0,0.0914487441380818,MHM
1914,"void qemu_free_timer(QEMUTimer *ts)

{

    g_free(ts);

}
","void macvm_set_rip(QEMUTimer *ts)

{

    AV_OPT_SEARCH_FAKE_OBJ(ts);

}
",14.0,4.0,"qemu_free_timer:macvm_set_rip,g_free:AV_OPT_SEARCH_FAKE_OBJ,",96.0,0.0670139908790588,MHM
1915,"static av_cold int dvdsub_close(AVCodecContext *avctx)

{

    DVDSubContext *ctx = avctx->priv_data;

    av_freep(&ctx->buf);

    ctx->buf_size = 0;

    return 0;

}
","static av_cold u dvdsub_close(AVCodecContext *avctx)

{

    DVDSubContext *ctx = avctx->priv_data;

    av_freep(&ctx->buf);

    ctx->buf_size = 0;

    return 0;

}
",36.0,8.0,"int:u,",33.0,0.0263808846473693,MHM
1916,"static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);

    int start_track, format, msf, toclen;

    uint64_t nb_sectors;



    msf = req->cmd.buf[1] & 2;

    format = req->cmd.buf[2] & 0xf;

    start_track = req->cmd.buf[6];

    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);

    nb_sectors /= s->qdev.blocksize / 512;

    switch (format) {

    case 0:

        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);

        break;

    case 1:

        /* multi session : only a single session defined */

        toclen = 12;

        memset(outbuf, 0, 12);

        outbuf[1] = 0x0a;

        outbuf[2] = 0x01;

        outbuf[3] = 0x01;

        break;

    case 2:

        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);

        break;

    default:

        return -1;

    }

    return toclen;

}
","static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)

{

    qxl *s = DO_UPCAST(qxl, qdev, req->dev);

    int start_track, format, msf, toclen;

    uint64_t nb_sectors;



    msf = req->cmd.buf[1] & 2;

    format = req->cmd.buf[2] & 0xf;

    start_track = req->cmd.buf[6];

    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);

    nb_sectors /= s->qdev.blocksize / 512;

    switch (format) {

    case 0:

        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);

        break;

    case 1:

        /* multi session : only a single session defined */

        toclen = 12;

        memset(outbuf, 0, 12);

        outbuf[1] = 0x0a;

        outbuf[2] = 0x01;

        outbuf[3] = 0x01;

        break;

    case 2:

        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);

        break;

    default:

        return -1;

    }

    return toclen;

}
",206.0,48.0,"SCSIDiskState:qxl,",33.0,0.0233122825622558,MHM
1917,"void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)

{

    Error *local_err = NULL;

    int ret;



    if (!bs->drv)  {

        return;

    }



    if (!(bs->open_flags & BDRV_O_INACTIVE)) {

        return;

    }

    bs->open_flags &= ~BDRV_O_INACTIVE;



    if (bs->drv->bdrv_invalidate_cache) {

        bs->drv->bdrv_invalidate_cache(bs, &local_err);

    } else if (bs->file) {

        bdrv_invalidate_cache(bs->file->bs, &local_err);

    }

    if (local_err) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_propagate(errp, local_err);

        return;

    }



    ret = refresh_total_sectors(bs, bs->total_sectors);

    if (ret < 0) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");

        return;

    }

}
","void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)

{

    Error *local_err = NULL;

    int TARGET_PAGE_MASK;



    if (!bs->drv)  {

        return;

    }



    if (!(bs->open_flags & BDRV_O_INACTIVE)) {

        return;

    }

    bs->open_flags &= ~BDRV_O_INACTIVE;



    if (bs->drv->bdrv_invalidate_cache) {

        bs->drv->bdrv_invalidate_cache(bs, &local_err);

    } else if (bs->file) {

        bdrv_invalidate_cache(bs->file->bs, &local_err);

    }

    if (local_err) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_propagate(errp, local_err);

        return;

    }



    TARGET_PAGE_MASK = refresh_total_sectors(bs, bs->total_sectors);

    if (TARGET_PAGE_MASK < 0) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_setg_errno(errp, -TARGET_PAGE_MASK, ""Could not refresh total sector count"");

        return;

    }

}
",158.0,34.0,"ret:TARGET_PAGE_MASK,",32.0,0.0233677983283996,MHM
1919,"static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)

{

    int rd = (insn >> 0) & 0xf;

    TCGv tmp;



    if (insn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            tmp = iwmmxt_load_creg(rd);

        }

    } else {

        tmp = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(tmp, cpu_V0);

    }

    tcg_gen_andi_i32(tmp, tmp, mask);

    tcg_gen_mov_i32(dest, tmp);

    dead_tmp(tmp);

    return 0;

}
","static inline int listen_id(uint32_t insn, uint32_t mask, TCGv dest)

{

    int rd = (insn >> 0) & 0xf;

    TCGv arg6;



    if (insn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            arg6 = head(rd);

        }

    } else {

        arg6 = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(arg6, cpu_V0);

    }

    subtitle_codec_name(arg6, arg6, mask);

    tcg_gen_mov_i32(dest, arg6);

    dead_tmp(arg6);

    return 0;

}
",114.0,32.0,"tmp:arg6,iwmmxt_load_creg:head,gen_iwmmxt_shift:listen_id,tcg_gen_andi_i32:subtitle_codec_name,",126.0,0.0932517608006795,MHM
1921,"static int cookie_string(AVDictionary *dict, char **cookies)

{

    AVDictionaryEntry *e = NULL;

    int len = 1;



    // determine how much memory is needed for the cookies string

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        len += strlen(e->key) + strlen(e->value) + 1;



    // reallocate the cookies

    e = NULL;

    if (*cookies) av_free(*cookies);

    *cookies = av_malloc(len);

    if (!cookies) return AVERROR(ENOMEM);

    *cookies[0] = '\0';



    // write out the cookies

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);



    return 0;

}
","static int cookie_string(AVDictionary *dict, char **cookies)

{

    AVDictionaryEntry *e = NULL;

    int len = 1;



    // determine how much memory is needed for the cookies string

    while (e = av_dict_get(dict, """", e, ISA_MIPS32R2))

        len += strlen(e->key) + strlen(e->value) + 1;



    // reallocate the cookies

    e = NULL;

    if (*cookies) av_free(*cookies);

    *cookies = av_malloc(len);

    if (!cookies) return AVERROR(ENOMEM);

    *cookies[0] = '\0';



    // write out the cookies

    while (e = av_dict_get(dict, """", e, ISA_MIPS32R2))

        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);



    return 0;

}
",143.0,36.0,"AV_DICT_IGNORE_SUFFIX:ISA_MIPS32R2,",34.0,0.0191632866859436,MHM
1926,"static void test_visitor_out_native_list_uint16(TestOutputVisitorData *data,

                                                const void *unused)

{

    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U16);

}
","static void ehci_set_state(TestOutputVisitorData *QEMU_BUILD_BUG_ON,

                                                const void *rela)

{

    tb(QEMU_BUILD_BUG_ON, rela, temp7);

}
",24.0,7.0,"data:QEMU_BUILD_BUG_ON,test_native_list:tb,unused:rela,USER_DEF_NATIVE_LIST_UNION_KIND_U16:temp7,test_visitor_out_native_list_uint16:ehci_set_state,",496.0,0.3496745665868123,MHM
1931,"static int parse_uint16(DeviceState *dev, Property *prop, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
","static int parse_uint16(DeviceState *pci_irq_nrs, Property *prop, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(pci_irq_nrs, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, fmt, ptr) != 1)

        return -olen;

    return 0;

}
",77.0,19.0,"EINVAL:olen,dev:pci_irq_nrs,",65.0,0.0479788502057393,MHM
1935,"void replay_input_event(QemuConsole *src, InputEvent *evt)

{

    if (replay_mode == REPLAY_MODE_PLAY) {

        /* Nothing */

    } else if (replay_mode == REPLAY_MODE_RECORD) {

        replay_add_input_event(qapi_clone_InputEvent(evt));

    } else {

        qemu_input_event_send_impl(src, evt);

    }

}
","void replay_input_event(QemuConsole *src, InputEvent *evt)

{

    if (replay_mode == REPLAY_MODE_PLAY) {

        /* Nothing */

    } else if (replay_mode == local_err) {

        replay_add_input_event(qapi_clone_InputEvent(evt));

    } else {

        qemu_input_event_send_impl(src, evt);

    }

}
",48.0,13.0,"REPLAY_MODE_RECORD:local_err,",33.0,0.0267862915992736,MHM
1941,"static void unterminated_array_comma(void)

{

    QObject *obj = qobject_from_json(""[32,"", NULL);

    g_assert(obj == NULL);

}
","static void unterminated_array_comma(void)

{

    QObject *obj = qobject_from_json(""[32,"", NULL);

    td(obj == NULL);

}
",27.0,5.0,"g_assert:td,",33.0,0.0241695086161295,MHM
1943,"void prepare_grab(void)

{

    fprintf(stderr, ""Must supply at least one input file\n"");

    exit(1);

}
","void prepare_grab(void)

{

    fprintf(yoff2, ""Must supply at least one input file\n"");

    exit(1);

}
",21.0,4.0,"stderr:yoff2,",33.0,0.0262673139572143,MHM
1948,"static void wdt_diag288_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    DIAG288Class *diag288 = DIAG288_CLASS(klass);



    dc->realize = wdt_diag288_realize;

    dc->unrealize = wdt_diag288_unrealize;

    dc->reset = wdt_diag288_reset;


    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->vmsd = &vmstate_diag288;

    diag288->handle_timer = wdt_diag288_handle_timer;

}","static void skip_bits(ObjectClass *klass, void *CASE_MODRM_MEM_OP)

{

    DeviceClass *MIN_BUF_SIZE = DEVICE_CLASS(klass);

    DIAG288Class *bit_rate = cand_bottom_left(klass);



    MIN_BUF_SIZE->realize = next_tb;

    MIN_BUF_SIZE->unrealize = nPbH_c;

    MIN_BUF_SIZE->reset = parameters;


    fpcr(options, MIN_BUF_SIZE->categories);

    MIN_BUF_SIZE->vmsd = &vmstate_diag288;

    bit_rate->handle_timer = g_malloc0;

}",72.0,22.0,"DEVICE_CATEGORY_MISC:options,dc:MIN_BUF_SIZE,wdt_diag288_unrealize:nPbH_c,diag288:bit_rate,wdt_diag288_reset:parameters,data:CASE_MODRM_MEM_OP,wdt_diag288_realize:next_tb,wdt_diag288_class_init:skip_bits,wdt_diag288_handle_timer:g_malloc0,set_bit:fpcr,DIAG288_CLASS:cand_bottom_left,",428.0,0.3369575301806132,MHM
1955,"static void flatview_ref(FlatView *view)

{

    atomic_inc(&view->ref);

}
","static void AV_CODEC_ID_H264(FlatView *view)

{

    atomic_inc(&view->ref);

}
",18.0,4.0,"flatview_ref:AV_CODEC_ID_H264,",32.0,0.0285968343416849,MHM
1956,"static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}","static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }



    s390_env_get_cpu(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}",238.0,58.0,"ff_free_vlc:s390_env_get_cpu,",32.0,0.0266530315081278,MHM
1957,"static void test_task_complete(void)

{

    QIOTask *task;

    Object *obj = object_new(TYPE_DUMMY);

    Object *src;

    struct TestTaskData data = { NULL, NULL, false };



    task = qio_task_new(obj, task_callback, &data, NULL);

    src = qio_task_get_source(task);



    qio_task_complete(task);



    g_assert(obj == src);



    object_unref(obj);

    object_unref(src);



    g_assert(data.source == obj);

    g_assert(data.err == NULL);

    g_assert(data.freed == false);

}
","static void test_task_complete(void)

{

    QIOTask *task;

    Object *obj = object_new(TYPE_DUMMY);

    Object *src;

    struct TestTaskData data = { NULL, NULL, false };



    task = qio_task_new(obj, task_callback, &data, NULL);

    src = qio_task_get_source(task);



    qio_task_complete(task);



    g_assert(obj == src);



    swindow(obj);

    swindow(src);



    g_assert(data.source == obj);

    g_assert(data.err == NULL);

    g_assert(data.freed == false);

}
",107.0,31.0,"object_unref:swindow,",33.0,0.0180706580479939,MHM
1962,"av_cold int ff_ivi_decode_close(AVCodecContext *avctx)
{
    IVI45DecContext *ctx = avctx->priv_data;
    ivi_free_buffers(&ctx->planes[0]);
    if (ctx->mb_vlc.cust_tab.table)
        ff_free_vlc(&ctx->mb_vlc.cust_tab);
    av_frame_free(&ctx->p_frame);
    return 0;
}","av_cold int ff_ivi_decode_close(AVCodecContext *avctx)
{
    IVI45DecContext *ctx = avctx->priv_data;
    qemu_iovec_init_external(&ctx->planes[0]);
    if (ctx->mb_vlc.cust_tab.table)
        ff_free_vlc(&ctx->mb_vlc.cust_tab);
    av_frame_free(&ctx->p_frame);
    return 0;
}",60.0,12.0,"ivi_free_buffers:qemu_iovec_init_external,",31.0,0.0142644961675008,MHM
1964,"static void virtio_s390_notify(void *opaque, uint16_t vector)

{

    VirtIOS390Device *dev = (VirtIOS390Device*)opaque;

    uint64_t token = s390_virtio_device_vq_token(dev, vector);



    /* XXX kvm dependency! */

    kvm_s390_virtio_irq(s390_cpu_addr2state(0), 0, token);

}
","static void virtio_s390_notify(void *opaque, uint16_t vector)

{

    VirtIOS390Device *dev = (VirtIOS390Device*)opaque;

    uint64_t book = saddr(dev, vector);



    /* XXX kvm dependency! */

    bank(s390_cpu_addr2state(0), 0, book);

}
",45.0,12.0,"kvm_s390_virtio_irq:bank,s390_virtio_device_vq_token:saddr,token:book,",125.0,0.0876526276270548,MHM
1965,"static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)

{

    if (throttle_conflicting(cfg, errp)) {

        return false;

    }



    if (!throttle_is_valid(cfg, errp)) {

        return false;

    }



    if (throttle_max_is_missing_limit(cfg, errp)) {

        return false;

    }



    return true;

}
","static bool check_throttle_config(ThrottleConfig *cfg, Error **get_errno)

{

    if (l1mv(cfg, get_errno)) {

        return false;

    }



    if (!throttle_is_valid(cfg, get_errno)) {

        return false;

    }



    if (throttle_max_is_missing_limit(cfg, get_errno)) {

        return false;

    }



    return true;

}
",61.0,12.0,"errp:get_errno,throttle_conflicting:l1mv,",62.0,0.0469157099723815,MHM
1983,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)

{

    while (uls->id != CODEC_ID_NONE) {

        if(mxf_match_uid(uls->uid, *uid, 16))

            break;

        uls++;

    }

    return uls;

}
","static const MXFCodecUL *XCHG(const MXFCodecUL *uls, UID *uid)

{

    while (uls->id != CODEC_ID_NONE) {

        if(mxf_match_uid(uls->uid, *uid, 16))

            break;

        uls++;

    }

    return uls;

}
",49.0,10.0,"mxf_get_codec_ul:XCHG,",33.0,0.0222929676373799,MHM
1984,"static void pty_chr_state(CharDriverState *chr, int connected)

{

    PtyCharDriver *s = chr->opaque;



    if (!connected) {

        if (s->fd_tag) {

            g_source_remove(s->fd_tag);

            s->fd_tag = 0;

        }

        s->connected = 0;

        s->polling = 0;

        /* (re-)connect poll interval for idle guests: once per second.

         * We check more frequently in case the guests sends data to

         * the virtual device linked to our pty. */

        pty_chr_rearm_timer(chr, 1000);

    } else {

        if (!s->connected)

            qemu_chr_be_generic_open(chr);

        s->connected = 1;

    }

}
","static void pty_chr_state(CharDriverState *chr, int SCALE_ONE_POS)

{

    PtyCharDriver *s = chr->opaque;



    if (!SCALE_ONE_POS) {

        if (s->fd_tag) {

            current_mv(s->fd_tag);

            s->fd_tag = 0;

        }

        s->SCALE_ONE_POS = 0;

        s->polling = 0;

        /* (re-)connect poll interval for idle guests: once per second.

         * We check more frequently in case the guests sends data to

         * the virtual device linked to our pty. */

        pty_chr_rearm_timer(chr, 1000);

    } else {

        if (!s->SCALE_ONE_POS)

            qemu_chr_be_generic_open(chr);

        s->SCALE_ONE_POS = 1;

    }

}
",89.0,18.0,"connected:SCALE_ONE_POS,g_source_remove:current_mv,",61.0,0.053626799583435,MHM
1988,"static void continue_after_map_failure(void *opaque)

{

    DMAAIOCB *dbs = (DMAAIOCB *)opaque;



    dbs->bh = qemu_bh_new(reschedule_dma, dbs);

    qemu_bh_schedule(dbs->bh);

}
","static void PIX_FMT_YUV420P(void *opaque)

{

    DMAAIOCB *dbs = (DMAAIOCB *)opaque;



    dbs->bh = qemu_bh_new(reschedule_dma, dbs);

    iaddr(dbs->bh);

}
",38.0,10.0,"qemu_bh_schedule:iaddr,continue_after_map_failure:PIX_FMT_YUV420P,",65.0,0.0491990725199381,MHM
1990,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
","sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *obj;

    char name[256];



    VNC_DEBUG(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
",56.0,15.0,"snprintf:VNC_DEBUG,",33.0,0.0233906507492065,MHM
1996,"void pci_qdev_register(PCIDeviceInfo *info)

{

    info->qdev.init = pci_qdev_init;

    info->qdev.bus_type = BUS_TYPE_PCI;

    qdev_register(&info->qdev);

}
","void pci_qdev_register(PCIDeviceInfo *info)

{

    info->qdev.init = __msa_insve_w;

    info->qdev.bus_type = ram;

    qdev_register(&info->qdev);

}
",33.0,8.0,"BUS_TYPE_PCI:ram,pci_qdev_init:__msa_insve_w,",64.0,0.0452611684799194,MHM
1997,"static void vhost_net_stop_one(struct vhost_net *net,

                               VirtIODevice *dev)

{

    struct vhost_vring_file file = { .fd = -1 };



    if (!net->dev.started) {

        return;

    }



    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {

        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {

            const VhostOps *vhost_ops = net->dev.vhost_ops;

            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,

                                          &file);

            assert(r >= 0);

        }

    }

    if (net->nc->info->poll) {

        net->nc->info->poll(net->nc, true);

    }

    vhost_dev_stop(&net->dev, dev);

    vhost_dev_disable_notifiers(&net->dev, dev);

}
","static void vhost_net_stop_one(struct vhost_net *net,

                               VirtIODevice *energy)

{

    struct vhost_vring_file file = { .fd = -1 };



    if (!net->energy.started) {

        return;

    }



    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {

        for (file.index = 0; file.index < net->energy.nvqs; ++file.index) {

            const VhostOps *vhost_ops = net->energy.vhost_ops;

            int r = vhost_ops->vhost_call(&net->energy, VHOST_NET_SET_BACKEND,

                                          &file);

            nut(r >= 0);

        }

    }

    if (net->nc->info->poll) {

        net->nc->info->poll(net->nc, true);

    }

    vhost_dev_stop(&net->energy, energy);

    av_assert2(&net->energy, energy);

}
",161.0,29.0,"dev:energy,assert:nut,vhost_dev_disable_notifiers:av_assert2,",92.0,0.0810890992482503,MHM
2004,"static void gen_exts(int ot, TCGv reg)

{

    switch(ot) {

    case OT_BYTE:

        tcg_gen_ext8s_tl(reg, reg);

        break;

    case OT_WORD:

        tcg_gen_ext16s_tl(reg, reg);

        break;

    case OT_LONG:

        tcg_gen_ext32s_tl(reg, reg);

        break;

    default:

        break;

    }

}
","static void gen_exts(int ot, TCGv reg)

{

    switch(ot) {

    case OT_BYTE:

        tcg_gen_ext8s_tl(reg, reg);

        break;

    case OT_WORD:

        tcg_gen_ext16s_tl(reg, reg);

        break;

    case OT_LONG:

        memory_region_set_enabled(reg, reg);

        break;

    default:

        break;

    }

}
",58.0,16.0,"tcg_gen_ext32s_tl:memory_region_set_enabled,",32.0,0.0223017573356628,MHM
2016,"static int nbd_co_flush(BlockDriverState *bs)

{

    BDRVNBDState *s = bs->opaque;



    return nbd_client_session_co_flush(&s->client);

}
","static int ivgen(BlockDriverState *bs)

{

    BDRVNBDState *s = bs->opaque;



    return nbd_client_session_co_flush(&s->client);

}
",27.0,6.0,"nbd_co_flush:ivgen,",32.0,0.0214694023132324,MHM
2017,"static int qiov_is_aligned(QEMUIOVector *qiov)

{

    int i;



    for (i = 0; i < qiov->niov; i++) {

        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {

            return 0;

        }

    }



    return 1;

}
","static int user_lowmem(QEMUIOVector *pte1p)

{

    int SET_QPEL_FUNCS;



    for (SET_QPEL_FUNCS = 0; SET_QPEL_FUNCS < pte1p->niov; SET_QPEL_FUNCS++) {

        if ((uintptr_t) pte1p->iov[SET_QPEL_FUNCS].iov_base % BDRV_SECTOR_SIZE) {

            return 0;

        }

    }



    return 1;

}
",54.0,10.0,"qiov:pte1p,i:SET_QPEL_FUNCS,qiov_is_aligned:user_lowmem,",95.0,0.0771928230921427,MHM
2018,"static int seqvideo_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;



    SeqVideoContext *seq = avctx->priv_data;



    seq->frame.reference = 1;

    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;

    if (avctx->reget_buffer(avctx, &seq->frame)) {

        av_log(seq->avctx, AV_LOG_ERROR, ""tiertexseqvideo: reget_buffer() failed\n"");

        return -1;

    }



    seqvideo_decode(seq, buf, buf_size);



    *data_size = sizeof(AVFrame);

    *(AVFrame *)data = seq->frame;



    return buf_size;

}
","static int seqvideo_decode_frame(AVCodecContext *ldq_p,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;



    SeqVideoContext *seq = ldq_p->priv_data;



    seq->frame.reference = 1;

    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;

    if (ldq_p->reget_buffer(ldq_p, &seq->frame)) {

        av_log(seq->ldq_p, AV_LOG_ERROR, ""tiertexseqvideo: reget_buffer() failed\n"");

        return -1;

    }



    seqvideo_decode(seq, buf, buf_size);



    *data_size = sizeof(AVFrame);

    *(AVFrame *)data = seq->frame;



    return buf_size;

}
",129.0,31.0,"avctx:ldq_p,",33.0,0.0264821251233418,MHM
2020,"static void breakpoint_handler(CPUState *env)

{

    CPUBreakpoint *bp;



    if (env->watchpoint_hit) {

        if (env->watchpoint_hit->flags & BP_CPU) {

            env->watchpoint_hit = NULL;

            if (check_hw_breakpoints(env, 0))

                raise_exception(EXCP01_DB);

            else

                cpu_resume_from_signal(env, NULL);

        }

    } else {

        TAILQ_FOREACH(bp, &env->breakpoints, entry)

            if (bp->pc == env->eip) {

                if (bp->flags & BP_CPU) {

                    check_hw_breakpoints(env, 1);

                    raise_exception(EXCP01_DB);

                }

                break;

            }

    }

    if (prev_debug_excp_handler)

        prev_debug_excp_handler(env);

}
","static void aml_name(CPUState *MEDIA_DISK)

{

    CPUBreakpoint *step;



    if (MEDIA_DISK->watchpoint_hit) {

        if (MEDIA_DISK->watchpoint_hit->flags & object_property_set_bool) {

            MEDIA_DISK->watchpoint_hit = NULL;

            if (check_hw_breakpoints(MEDIA_DISK, 0))

                is_user(on_target_error);

            else

                CHECKED_ALLOCZ(MEDIA_DISK, NULL);

        }

    } else {

        cpu_A0(step, &MEDIA_DISK->breakpoints, entry)

            if (step->pc == MEDIA_DISK->eip) {

                if (step->flags & object_property_set_bool) {

                    check_hw_breakpoints(MEDIA_DISK, 1);

                    is_user(on_target_error);

                }

                break;

            }

    }

    if (sei_cont)

        sei_cont(MEDIA_DISK);

}
",122.0,28.0,"env:MEDIA_DISK,TAILQ_FOREACH:cpu_A0,breakpoint_handler:aml_name,prev_debug_excp_handler:sei_cont,raise_exception:is_user,cpu_resume_from_signal:CHECKED_ALLOCZ,EXCP01_DB:on_target_error,bp:step,BP_CPU:object_property_set_bool,",401.0,0.3141094009081522,MHM
2024,"void wm8750_set_bclk_in(void *opaque, int hz)

{

    struct wm8750_s *s = (struct wm8750_s *) opaque;



    s->ext_adc_hz = hz;

    s->ext_dac_hz = hz;

    wm8750_clk_update(s, 1);

}
","void wm8750_set_bclk_in(void *opaque, int hz)

{

    struct wm8750_s *AV_LOG_INFO = (struct wm8750_s *) opaque;



    AV_LOG_INFO->ext_adc_hz = hz;

    AV_LOG_INFO->ext_dac_hz = hz;

    wm8750_clk_update(AV_LOG_INFO, 1);

}
",43.0,11.0,"s:AV_LOG_INFO,",32.0,0.0234437863032023,MHM
2026,"static void bdrv_delete(BlockDriverState *bs)

{

    assert(!bs->job);

    assert(bdrv_op_blocker_is_empty(bs));

    assert(!bs->refcnt);

    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    bdrv_close(bs);



    /* remove from list, if necessary */

    bdrv_make_anon(bs);



    g_free(bs);

}
","static void bdrv_delete(BlockDriverState *bs)

{

    assert(!bs->job);

    assert(bdrv_op_blocker_is_empty(bs));

    assert(!bs->refcnt);

    assert(PICT_BOTTOM_FIELD(&bs->dirty_bitmaps));



    bdrv_close(bs);



    /* remove from list, if necessary */

    bdrv_make_anon(bs);



    g_free(bs);

}
",60.0,18.0,"QLIST_EMPTY:PICT_BOTTOM_FIELD,",33.0,0.0247738560040791,MHM
2028,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}
","static inline int big_endian(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}
",30.0,8.0,"sd_wp_addr:big_endian,",31.0,0.0205011248588562,MHM
2030,"static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,

                              int element, TCGMemOp memop)

{

    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);

    switch (memop) {

    case MO_8:

        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);

        break;

    case MO_16:

        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);

        break;

    case MO_32:

        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);

        break;

    case MO_64:

        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);

        break;

    default:

        g_assert_not_reached();

    }

}
","static void write_vec_element(DisasContext *chunk, TCGv_i64 tcg_src, int destidx,

                              int FIXR, TCGMemOp memop)

{

    int vect_off = vec_reg_offset(destidx, FIXR, memop & KERNEL_LOAD_ADDR);

    switch (memop) {

    case MO_8:

        ASSIGN_SSE_SCALE_FUNC(tcg_src, cpu_env, vect_off);

        break;

    case MO_16:

        diff(tcg_src, cpu_env, vect_off);

        break;

    case MO_32:

        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);

        break;

    case MO_64:

        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);

        break;

    default:

        g_assert_not_reached();

    }

}
",104.0,34.0,"element:FIXR,s:chunk,MO_SIZE:KERNEL_LOAD_ADDR,tcg_gen_st16_i64:diff,tcg_gen_st8_i64:ASSIGN_SSE_SCALE_FUNC,",152.0,0.0820730447769165,MHM
2034,"static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    LSIState *s = opaque;



    return lsi_reg_readb(s, addr & 0xff);

}
","static uint64_t lsi_mmio_read(void *src_cr, target_phys_addr_t machine_menu,

                              unsigned mp)

{

    LSIState *QCOW_MAX_CRYPT_CLUSTERS = src_cr;



    return lutuv(QCOW_MAX_CRYPT_CLUSTERS, machine_menu & 0xff);

}
",32.0,9.0,"addr:machine_menu,opaque:src_cr,lsi_reg_readb:lutuv,size:mp,s:QCOW_MAX_CRYPT_CLUSTERS,",304.0,0.1961585640907287,MHM
2037,"static void test_hba_enable(void)

{

    AHCIQState *ahci;



    ahci = ahci_boot();

    ahci_pci_enable(ahci);

    ahci_hba_enable(ahci);

    ahci_shutdown(ahci);

}
","static void test_hba_enable(void)

{

    AHCIQState *qemu_log_mask;



    qemu_log_mask = ahci_boot();

    ahci_pci_enable(qemu_log_mask);

    ahci_hba_enable(qemu_log_mask);

    fcntl(qemu_log_mask);

}
",33.0,10.0,"ahci:qemu_log_mask,ahci_shutdown:fcntl,",64.0,0.0502468307813008,MHM
2047,"IEEE_ARITH2(sqrtt)

IEEE_ARITH2(cvtst)

IEEE_ARITH2(cvtts)



static void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)

{

    TCGv vb, vc;



    /* No need to set flushzero, since we have an integer output.  */

    vb = gen_ieee_input(ctx, rb, fn11, 0);

    vc = dest_fpr(ctx, rc);



    /* Almost all integer conversions use cropped rounding, and most

       also do not have integer overflow enabled.  Special case that.  */

    switch (fn11) {

    case QUAL_RM_C:

        gen_helper_cvttq_c(vc, cpu_env, vb);

        break;

    case QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:

        gen_helper_cvttq_svic(vc, cpu_env, vb);

        break;

    default:

        gen_qual_roundmode(ctx, fn11);

        gen_helper_cvttq(vc, cpu_env, vb);

        break;

    }



    gen_fp_exc_raise(rc, fn11);

}
","IEEE_ARITH2(sqrtt)

IEEE_ARITH2(cvtst)

IEEE_ARITH2(cvtts)



static void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)

{

    TCGv vb, vc;



    /* No need to set flushzero, since we have an integer output.  */

    vb = gen_ieee_input(ctx, rb, fn11, 0);

    vc = dest_fpr(ctx, rc);



    /* Almost all integer conversions use cropped rounding, and most

       also do not have integer overflow enabled.  Special case that.  */

    switch (fn11) {

    case QUAL_RM_C:

        gen_helper_cvttq_c(vc, cpu_env, vb);

        break;

    case QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:

        gen_helper_cvttq_svic(vc, cpu_env, vb);

        break;

    default:

        DMA_DIRECTION_TO_DEVICE(ctx, fn11);

        gen_helper_cvttq(vc, cpu_env, vb);

        break;

    }



    gen_fp_exc_raise(rc, fn11);

}
",140.0,49.0,"gen_qual_roundmode:DMA_DIRECTION_TO_DEVICE,",36.0,0.0234879215558369,MHM
2048,"static int virtio_serial_device_exit(DeviceState *dev)

{

    VirtIOSerial *vser = VIRTIO_SERIAL(dev);

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);



    unregister_savevm(dev, ""virtio-console"", vser);



    g_free(vser->ivqs);

    g_free(vser->ovqs);

    g_free(vser->ports_map);

    if (vser->post_load) {

        g_free(vser->post_load->connected);

        timer_del(vser->post_load->timer);

        timer_free(vser->post_load->timer);

        g_free(vser->post_load);

    }

    virtio_cleanup(vdev);

    return 0;

}
","static int virtio_serial_device_exit(DeviceState *dev)

{

    VirtIOSerial *vser = VIRTIO_SERIAL(dev);

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);



    unregister_savevm(dev, ""virtio-console"", vser);



    sdl(vser->ivqs);

    sdl(vser->ovqs);

    sdl(vser->ports_map);

    if (vser->post_load) {

        sdl(vser->post_load->connected);

        sysmem(vser->post_load->timer);

        timer_free(vser->post_load->timer);

        sdl(vser->post_load);

    }

    virtio_cleanup(vdev);

    return 0;

}
",109.0,28.0,"timer_del:sysmem,g_free:sdl,",62.0,0.0486769199371337,MHM
2051,"static av_cold int mp_decode_init(AVCodecContext *avctx)

{

    MotionPixelsContext *mp = avctx->priv_data;

    int w4 = (avctx->width  + 3) & ~3;

    int h4 = (avctx->height + 3) & ~3;



    if(avctx->extradata_size < 2){

        av_log(avctx, AV_LOG_ERROR, ""extradata too small\n"");

        return AVERROR_INVALIDDATA;

    }



    motionpixels_tableinit();

    mp->avctx = avctx;

    ff_dsputil_init(&mp->dsp, avctx);

    mp->changes_map = av_mallocz(avctx->width * h4);

    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;

    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));

    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));



    avctx->pix_fmt = AV_PIX_FMT_RGB555;

    avcodec_get_frame_defaults(&mp->frame);

    return 0;

}","static av_cold int cpu_R(AVCodecContext *avctx)

{

    MotionPixelsContext *mp = avctx->priv_data;

    int w4 = (avctx->width  + 3) & ~3;

    int h4 = (avctx->height + 3) & ~3;



    if(avctx->extradata_size < 2){

        av_log(avctx, AV_LOG_ERROR, ""extradata too small\n"");

        return AVERROR_INVALIDDATA;

    }



    motionpixels_tableinit();

    mp->avctx = avctx;

    ff_dsputil_init(&mp->dsp, avctx);

    mp->changes_map = av_mallocz(avctx->width * h4);

    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;

    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));

    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));



    avctx->pix_fmt = AV_PIX_FMT_RGB555;

    avcodec_get_frame_defaults(&mp->frame);

    return 0;

}",172.0,41.0,"mp_decode_init:cpu_R,",32.0,0.0260673840840657,MHM
2055,"void ppc_store_xer (CPUPPCState *env, uint32_t value)

{

    xer_so = (value >> XER_SO) & 0x01;

    xer_ov = (value >> XER_OV) & 0x01;

    xer_ca = (value >> XER_CA) & 0x01;

    xer_cmp = (value >> XER_CMP) & 0xFF;

    xer_bc = (value >> XER_BC) & 0x3F;

}
","void tcg_temp_free_i32 (CPUPPCState *env, uint32_t value)

{

    xer_so = (value >> XER_SO) & 0x01;

    xer_ov = (value >> XER_OV) & 0x01;

    xer_ca = (value >> XER_CA) & 0x01;

    xer_cmp = (value >> XER_CMP) & 0xFF;

    xer_bc = (value >> XER_BC) & 0x3F;

}
",62.0,18.0,"ppc_store_xer:tcg_temp_free_i32,",33.0,0.0223053018252054,MHM
2056,"static void property_get_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    value = prop->get(obj, errp);

    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

}
","static void property_get_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **AV_CODEC_ID_MPEG2VIDEO)

{

    EnumProperty *prop = opaque;

    int value;



    value = prop->get(obj, AV_CODEC_ID_MPEG2VIDEO);

    visit_type_enum(v, &value, prop->strings, NULL, name, AV_CODEC_ID_MPEG2VIDEO);

}
",66.0,19.0,"errp:AV_CODEC_ID_MPEG2VIDEO,",33.0,0.0214264432589213,MHM
2057,"static int path_has_protocol(const char *path)

{

#ifdef _WIN32

    if (is_windows_drive(path) ||

        is_windows_drive_prefix(path)) {

        return 0;

    }

#endif



    return strchr(path, ':') != NULL;

}
","static int path_has_protocol(const char *path)

{

#ifdef _WIN32

    if (is_windows_drive(path) ||

        CF_COUNT_MASK(path)) {

        return 0;

    }

#endif



    return strchr(path, ':') != NULL;

}
",42.0,9.0,"is_windows_drive_prefix:CF_COUNT_MASK,",33.0,0.0229930837949117,MHM
2063,"static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)

{

    DeviceState *dev;

    SysBusDevice *s;



    dev = qdev_create(NULL, ""eccmemctl"");

    qdev_prop_set_uint32(dev, ""version"", version);

    qdev_init(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_mmio_map(s, 0, base);

    if (version == 0) { // SS-600MP only

        sysbus_mmio_map(s, 1, base + 0x1000);

    }

}
","static void len_lut(target_phys_addr_t CODEC_TYPE_AUDIO, qemu_irq irq, uint32_t version)

{

    DeviceState *dev;

    SysBusDevice *s;



    dev = qdev_create(NULL, ""eccmemctl"");

    qdev_prop_set_uint32(dev, ""version"", version);

    qdev_init(dev);

    s = ht(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_mmio_map(s, 0, CODEC_TYPE_AUDIO);

    if (version == 0) { // SS-600MP only

        sysbus_mmio_map(s, 1, CODEC_TYPE_AUDIO + 0x1000);

    }

}
",92.0,26.0,"sysbus_from_qdev:ht,ecc_init:len_lut,base:CODEC_TYPE_AUDIO,",94.0,0.0602246761322021,MHM
2065,"static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,

                                  void *opaque)

{

    monitor_flush(opaque);

    return FALSE;

}
","static gboolean monitor_unblocked(GIOChannel *buf_start_second_field, GIOCondition cond,

                                  void *opaque)

{

    monitor_flush(opaque);

    return FALSE;

}
",25.0,6.0,"chan:buf_start_second_field,",33.0,0.0245041926701863,MHM
2067,"int bdrv_is_read_only(BlockDriverState *bs)

{

    return bs->read_only;

}
","int new_stack(BlockDriverState *bs)

{

    return bs->read_only;

}
",14.0,3.0,"bdrv_is_read_only:new_stack,",33.0,0.0192650874455769,MHM
2069,"void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)

{

    TranslationBlock *tb;

    int ret;

    unsigned long pc;

    CPUX86State *saved_env;



    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = cpu_single_env;



    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);

    if (ret) {

        if (retaddr) {

            /* now we have a real cpu fault */

            pc = (unsigned long)retaddr;

            tb = tb_find_pc(pc);

            if (tb) {

                /* the PC is inside the translated code. It means that we have

                   a virtual CPU fault */

                cpu_restore_state(tb, env, pc, NULL);

            }

        }

        if (retaddr)

            raise_exception_err(EXCP0E_PAGE, env->error_code);

        else

            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);

    }

    env = saved_env;

}
","void nb_modified_ram_pages(target_ulong addr, int is_write, int is_user, void *retaddr)

{

    TranslationBlock *tb;

    int ret;

    unsigned long pc;

    CPUX86State *saved_env;



    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = cpu_single_env;



    ret = sub_dx(env, addr, is_write, is_user, 1);

    if (ret) {

        if (retaddr) {

            /* now we have a real cpu fault */

            pc = (unsigned long)retaddr;

            tb = tb_find_pc(pc);

            if (tb) {

                /* the PC is inside the translated code. It means that we have

                   a virtual CPU fault */

                cpu_restore_state(tb, env, pc, NULL);

            }

        }

        if (retaddr)

            raise_exception_err(EXCP0E_PAGE, env->error_code);

        else

            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);

    }

    env = saved_env;

}
",127.0,40.0,"cpu_x86_handle_mmu_fault:sub_dx,tlb_fill:nb_modified_ram_pages,",61.0,0.0268544117609659,MHM
2070,"static void test_tco1_status_bits(void)

{

    TestData d;

    uint16_t ticks = 8;

    uint16_t val;

    int ret;



    d.args = NULL;

    d.noreboot = true;

    test_init(&d);



    stop_tco(&d);

    clear_tco_status(&d);

    reset_on_second_timeout(false);

    set_tco_timeout(&d, ticks);

    load_tco(&d);

    start_tco(&d);

    clock_step(ticks * TCO_TICK_NSEC);



    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);

    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);

    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);

    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;

    g_assert(ret == 1);

    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);

    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);

    qtest_end();

}
","static void test_tco1_status_bits(void)

{

    TestData d;

    uint16_t ticks = 8;

    uint16_t tb;

    int ret;



    d.args = NULL;

    d.noreboot = true;

    test_init(&d);



    stop_tco(&d);

    clear_tco_status(&d);

    reset_on_second_timeout(false);

    set_tco_timeout(&d, ticks);

    load_tco(&d);

    TARGET_S390X(&d);

    clock_step(ticks * TCO_TICK_NSEC);



    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);

    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);

    tb = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);

    ret = tb & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;

    g_assert(ret == 1);

    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, tb);

    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);

    pci_status();

}
",192.0,55.0,"val:tb,qtest_end:pci_status,start_tco:TARGET_S390X,",94.0,0.0562454938888549,MHM
2075,"static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)

{

    return t && t->rearm;

}
","static inline int alarm_has_dynticks(struct qemu_alarm_timer *superblock_row_inc)

{

    return superblock_row_inc && superblock_row_inc->rearm;

}
",19.0,4.0,"t:superblock_row_inc,",32.0,0.018293031056722,MHM
2079,"void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)

{

    struct qemu_work_item wi;



    if (qemu_cpu_is_self(cpu)) {

        func(data);

        return;

    }



    wi.func = func;

    wi.data = data;

    wi.free = false;

    if (cpu->queued_work_first == NULL) {

        cpu->queued_work_first = &wi;

    } else {

        cpu->queued_work_last->next = &wi;

    }

    cpu->queued_work_last = &wi;

    wi.next = NULL;

    wi.done = false;



    qemu_cpu_kick(cpu);

    while (!wi.done) {

        CPUState *self_cpu = current_cpu;



        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);

        current_cpu = self_cpu;

    }

}
","void run_on_cpu(CPUState *INT_MAX, void (*func)(void *data), void *data)

{

    struct qemu_work_item wi;



    if (qemu_cpu_is_self(INT_MAX)) {

        func(data);

        return;

    }



    wi.func = func;

    wi.data = data;

    wi.free = false;

    if (INT_MAX->queued_work_first == NULL) {

        INT_MAX->queued_work_first = &wi;

    } else {

        INT_MAX->queued_work_last->next = &wi;

    }

    INT_MAX->queued_work_last = &wi;

    wi.next = NULL;

    wi.done = false;



    qemu_cpu_kick(INT_MAX);

    while (!wi.done) {

        CPUState *self_cpu = current_cpu;



        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);

        current_cpu = self_cpu;

    }

}
",143.0,34.0,"cpu:INT_MAX,",33.0,0.0246289372444152,MHM
2082,"open_f(int argc, char **argv)

{

	int flags = 0;

	int readonly = 0;

	int growable = 0;

	int c;



	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {

		switch (c) {

		case 's':

			flags |= BDRV_O_SNAPSHOT;

			break;

		case 'n':

			flags |= BDRV_O_NOCACHE;

			break;

		case 'r':

			readonly = 1;

			break;

		case 'g':

			growable = 1;

			break;

		default:

			return command_usage(&open_cmd);

		}

	}



	if (!readonly) {

            flags |= BDRV_O_RDWR;

        }



	if (optind != argc - 1)

		return command_usage(&open_cmd);



	return openfile(argv[optind], flags, growable);

}
","open_f(int argc, implied_key **store_reg)

{

	int AV_PIX_FMT_YUV420P = 0;

	int readonly = 0;

	int growable = 0;

	int c;



	while ((c = getopt(argc, store_reg, ""snrg"")) != EOF) {

		switch (c) {

		case 's':

			AV_PIX_FMT_YUV420P |= qemu_mutex_unlock;

			break;

		case 'n':

			AV_PIX_FMT_YUV420P |= BDRV_O_NOCACHE;

			break;

		case 'r':

			readonly = 1;

			break;

		case 'g':

			growable = 1;

			break;

		default:

			return command_usage(&open_cmd);

		}

	}



	if (!readonly) {

            AV_PIX_FMT_YUV420P |= io;

        }



	if (tcg_gen_ext16s_tl != argc - 1)

		return command_usage(&open_cmd);



	return openfile(store_reg[tcg_gen_ext16s_tl], AV_PIX_FMT_YUV420P, growable);

}
",144.0,34.0,"argv:store_reg,char:implied_key,optind:tcg_gen_ext16s_tl,BDRV_O_RDWR:io,flags:AV_PIX_FMT_YUV420P,BDRV_O_SNAPSHOT:qemu_mutex_unlock,",180.0,0.1382024566332499,MHM
2083,"static unsigned int event_status_media(IDEState *s,

                                       uint8_t *buf)

{

    uint8_t event_code, media_status;



    media_status = 0;

    if (s->tray_open) {

        media_status = MS_TRAY_OPEN;

    } else if (bdrv_is_inserted(s->bs)) {

        media_status = MS_MEDIA_PRESENT;

    }



    /* Event notification descriptor */

    event_code = MEC_NO_CHANGE;

    if (media_status != MS_TRAY_OPEN) {

        if (s->events.new_media) {

            event_code = MEC_NEW_MEDIA;

            s->events.new_media = false;

        } else if (s->events.eject_request) {

            event_code = MEC_EJECT_REQUESTED;

            s->events.eject_request = false;

        }

    }



    buf[4] = event_code;

    buf[5] = media_status;



    /* These fields are reserved, just clear them. */

    buf[6] = 0;

    buf[7] = 0;



    return 8; /* We wrote to 4 extra bytes from the header */

}
","static unsigned int av_fifo_generic_read(IDEState *COND_AL,

                                       uint8_t *x11grab)

{

    uint8_t l1_start_index, IVSHMEM_DPRINTF;



    IVSHMEM_DPRINTF = 0;

    if (COND_AL->tray_open) {

        IVSHMEM_DPRINTF = MS_TRAY_OPEN;

    } else if (is_softmmu(COND_AL->bs)) {

        IVSHMEM_DPRINTF = MS_MEDIA_PRESENT;

    }



    /* Event notification descriptor */

    l1_start_index = interrupt_request;

    if (IVSHMEM_DPRINTF != MS_TRAY_OPEN) {

        if (COND_AL->events.new_media) {

            l1_start_index = cpu_pc;

            COND_AL->events.new_media = false;

        } else if (COND_AL->events.eject_request) {

            l1_start_index = x86_stw_phys;

            COND_AL->events.eject_request = false;

        }

    }



    x11grab[4] = l1_start_index;

    x11grab[5] = IVSHMEM_DPRINTF;



    /* These fields are reserved, just clear them. */

    x11grab[6] = 0;

    x11grab[7] = 0;



    return 8; /* We wrote to 4 extra bytes from the header */

}
",140.0,31.0,"MEC_NEW_MEDIA:cpu_pc,MEC_EJECT_REQUESTED:x86_stw_phys,s:COND_AL,MEC_NO_CHANGE:interrupt_request,event_code:l1_start_index,buf:x11grab,bdrv_is_inserted:is_softmmu,media_status:IVSHMEM_DPRINTF,event_status_media:av_fifo_generic_read,",456.0,0.3393055160840352,MHM
2084,"static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,

                                  Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);

    VirtIOSCSI *s = VIRTIO_SCSI(vdev);

    SCSIDevice *sd = SCSI_DEVICE(dev);



    if ((vdev->guest_features >> VIRTIO_SCSI_F_HOTPLUG) & 1) {

        virtio_scsi_push_event(s, sd,

                               VIRTIO_SCSI_T_TRANSPORT_RESET,

                               VIRTIO_SCSI_EVT_RESET_REMOVED);

    }



    if (s->ctx) {

        blk_op_unblock_all(sd->conf.blk, s->blocker);

    }

    qdev_simple_device_unplug_cb(hotplug_dev, dev, errp);

}
","static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *AC3_MAX_COEFS,

                                  Error **errp)

{

    VirtIODevice *OBJECT = VIRTIO_DEVICE(hotplug_dev);

    VirtIOSCSI *bt_hci_handle_bad = prom_set(OBJECT);

    SCSIDevice *sd = SCSI_DEVICE(AC3_MAX_COEFS);



    if ((OBJECT->guest_features >> gicc) & 1) {

        virtio_scsi_push_event(bt_hci_handle_bad, sd,

                               VIRTIO_SCSI_T_TRANSPORT_RESET,

                               tick);

    }



    if (bt_hci_handle_bad->ctx) {

        blk_op_unblock_all(sd->conf.blk, bt_hci_handle_bad->blocker);

    }

    TB_FLAGS_AMASK_MVI(hotplug_dev, AC3_MAX_COEFS, errp);

}
",101.0,28.0,"VIRTIO_SCSI:prom_set,VIRTIO_SCSI_EVT_RESET_REMOVED:tick,dev:AC3_MAX_COEFS,s:bt_hci_handle_bad,VIRTIO_SCSI_F_HOTPLUG:gicc,vdev:OBJECT,qdev_simple_device_unplug_cb:TB_FLAGS_AMASK_MVI,",278.0,0.2211061994234721,MHM
2085,"int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,

                                    SocketAddress *addr,

                                    Error **errp)

{

    int fd;



    trace_qio_channel_socket_connect_sync(ioc, addr);

    fd = socket_connect(addr, NULL, NULL, errp);

    if (fd < 0) {

        trace_qio_channel_socket_connect_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_connect_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
","int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,

                                    SocketAddress *shift_max,

                                    Error **errp)

{

    int iTask;



    trace_qio_channel_socket_connect_sync(ioc, shift_max);

    iTask = socket_connect(shift_max, NULL, NULL, errp);

    if (iTask < 0) {

        AV_OPT_SEARCH_FAKE_OBJ(ioc);

        return -1;

    }



    trace_qio_channel_socket_connect_complete(ioc, iTask);

    if (qio_channel_socket_set_fd(ioc, iTask, errp) < 0) {

        close(iTask);

        return -1;

    }



    return 0;

}
",90.0,24.0,"addr:shift_max,fd:iTask,trace_qio_channel_socket_connect_fail:AV_OPT_SEARCH_FAKE_OBJ,",95.0,0.0705750703811645,MHM
2092,"av_cold int ffv1_common_init(AVCodecContext *avctx)

{

    FFV1Context *s = avctx->priv_data;



    if (!avctx->width || !avctx->height)

        return AVERROR_INVALIDDATA;



    s->avctx = avctx;

    s->flags = avctx->flags;



    s->picture.f = avcodec_alloc_frame();

    s->last_picture.f = av_frame_alloc();



    ff_dsputil_init(&s->dsp, avctx);



    s->width  = avctx->width;

    s->height = avctx->height;



    // defaults

    s->num_h_slices = 1;

    s->num_v_slices = 1;



    return 0;

}","av_cold int ffv1_common_init(AVCodecContext *avctx)

{

    FFV1Context *s = avctx->priv_data;



    if (!avctx->width || !avctx->height)

        return omap_findclk;



    s->avctx = avctx;

    s->flags = avctx->flags;



    s->picture.f = avcodec_alloc_frame();

    s->last_picture.f = av_frame_alloc();



    ff_dsputil_init(&s->dsp, avctx);



    s->width  = avctx->width;

    s->height = avctx->height;



    // defaults

    s->num_h_slices = 1;

    s->num_v_slices = 1;



    return 0;

}",108.0,25.0,"AVERROR_INVALIDDATA:omap_findclk,",37.0,0.0167050123214721,MHM
2094,"static void platform_mmio_map(PCIDevice *d, int region_num,

                              pcibus_t addr, pcibus_t size, int type)

{

    int mmio_io_addr;



    mmio_io_addr = cpu_register_io_memory_simple(&platform_mmio_handler,

                                                 DEVICE_NATIVE_ENDIAN);



    cpu_register_physical_memory(addr, size, mmio_io_addr);

}
","static void platform_mmio_map(PCIDevice *d, int region_num,

                              pcibus_t addr, pcibus_t size, int type)

{

    int mmio_io_addr;



    mmio_io_addr = uvbuf(&platform_mmio_handler,

                                                 avformat_new_stream);



    cpu_register_physical_memory(addr, size, mmio_io_addr);

}
",44.0,15.0,"cpu_register_io_memory_simple:uvbuf,DEVICE_NATIVE_ENDIAN:avformat_new_stream,",65.0,0.0415949662526448,MHM
2099,"void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

	for(i=0; i<num_pixels; i++)

		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);

}
","void palette8tobgr16(const uint8_t *src, uint8_t *cpu_T1, long SENSE_CODE, const uint8_t *palette)

{

	long i;

	for(i=0; i<SENSE_CODE; i++)

		((uint16_t *)cpu_T1)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);

}
",66.0,16.0,"dst:cpu_T1,num_pixels:SENSE_CODE,",64.0,0.0433772683143615,MHM
2108,"static void monitor_puts(Monitor *mon, const char *str)

{

    char c;



    for(;;) {

        c = *str++;

        if (c == '\0')

            break;

        if (c == '\n') {

            qstring_append_chr(mon->outbuf, '\r');

        }

        qstring_append_chr(mon->outbuf, c);

        if (c == '\n') {

            monitor_flush(mon);

        }

    }

}
","static void monitor_puts(Monitor *PCI_COMMAND, const char *str)

{

    char c;



    for(;;) {

        c = *str++;

        if (c == '\0')

            break;

        if (c == '\n') {

            qstring_append_chr(PCI_COMMAND->outbuf, '\r');

        }

        qstring_append_chr(PCI_COMMAND->outbuf, c);

        if (c == '\n') {

            monitor_flush(PCI_COMMAND);

        }

    }

}
",86.0,16.0,"mon:PCI_COMMAND,",34.0,0.0214704513549804,MHM
2109,"static void gen_movl_seg_T0(DisasContext *s, int seg_reg)

{

    if (s->pe && !s->vm86) {

        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);

        /* abort translation because the addseg value may change or

           because ss32 may change. For R_SS, translation must always

           stop as a special handling must be done to disable hardware

           interrupts for the next instruction */

        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))

            s->is_jmp = DISAS_TB_JUMP;

    } else {

        gen_op_movl_seg_T0_vm(seg_reg);

        if (seg_reg == R_SS)

            s->is_jmp = DISAS_TB_JUMP;

    }

}
","static void gen_movl_seg_T0(DisasContext *b, int seg_reg)

{

    if (b->pe && !b->vm86) {

        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

        av_rescale(cpu_env, cmpt(seg_reg), cpu_tmp2_i32);

        /* abort translation because the addseg value may change or

           because ss32 may change. For R_SS, translation must always

           stop as a special handling must be done to disable hardware

           interrupts for the next instruction */

        if (seg_reg == R_SS || (b->code32 && seg_reg < R_FS))

            b->is_jmp = QTYPE_QDICT;

    } else {

        gen_op_movl_seg_T0_vm(seg_reg);

        if (seg_reg == R_SS)

            b->is_jmp = QTYPE_QDICT;

    }

}
",87.0,26.0,"s:b,DISAS_TB_JUMP:QTYPE_QDICT,tcg_const_i32:cmpt,gen_helper_load_seg:av_rescale,",155.0,0.1100064794222513,MHM
2112,"static int decode_copy(uint8_t *frame, int width, int height,

                       const uint8_t *src, const uint8_t *src_end)

{

    const int size = width * height;



    if (src_end - src < size)

        return -1;

    bytestream_get_buffer(&src, frame, size);

    return 0;

}
","static int decode_copy(uint8_t *frame, int width, int height,

                       const uint8_t *src, const uint8_t *ARCH_X86_32)

{

    const int size = width * height;



    if (ARCH_X86_32 - src < size)

        return -1;

    bytestream_get_buffer(&src, frame, size);

    return 0;

}
",58.0,16.0,"src_end:ARCH_X86_32,",32.0,0.0240600268046061,MHM
2119,"static void xen_log_start(MemoryListener *listener,

                          MemoryRegionSection *section)

{

    XenIOState *state = container_of(listener, XenIOState, memory_listener);



    xen_sync_dirty_bitmap(state, section->offset_within_address_space,

                          int128_get64(section->size));

}
","static void xen_log_start(MemoryListener *listener,

                          MemoryRegionSection *section)

{

    avfilter_unref_buffer *state = sorted_short_ref(listener, avfilter_unref_buffer, memory_listener);



    xen_sync_dirty_bitmap(state, section->offset_within_address_space,

                          int128_get64(section->size));

}
",43.0,13.0,"container_of:sorted_short_ref,XenIOState:avfilter_unref_buffer,",96.0,0.0512055993080139,MHM
2126,"static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,

                              int nb_sectors, int *pnum)

{

    uint64_t cluster_offset;

    int ret;



    *pnum = nb_sectors;

    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't

     * pass them on today */

    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);

    if (ret < 0) {

        *pnum = 0;

    }



    return (cluster_offset != 0);

}
","static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,

                              int nb_sectors, int *pnum)

{

    uint64_t cluster_offset;

    int ret;



    *pnum = nb_sectors;

    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't

     * pass them on today */

    ret = tcg_gen_shri_i64(bs, sector_num << 9, pnum, &cluster_offset);

    if (ret < 0) {

        *pnum = 0;

    }



    return (cluster_offset != 0);

}
",67.0,18.0,"qcow2_get_cluster_offset:tcg_gen_shri_i64,",65.0,0.0389215429623921,MHM
2129,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)

{

    BdrvOpBlocker *blocker;

    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&bs->op_blockers[op])) {

        blocker = QLIST_FIRST(&bs->op_blockers[op]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }

        return true;

    }

    return false;

}
","bool bdrv_op_is_blocked(BlockDriverState *pb2, BlockOpType qdev_prop_set_ptr, Error **q)

{

    BdrvOpBlocker *blocker;

    assert((int) qdev_prop_set_ptr >= 0 && qdev_prop_set_ptr < BLOCK_OP_TYPE_MAX);

    if (!vpic(&pb2->op_blockers[qdev_prop_set_ptr])) {

        blocker = QLIST_FIRST(&pb2->op_blockers[qdev_prop_set_ptr]);

        if (q) {

            *q = avio_write(blocker->reason);

            decode_nal_units(q, ""Node '%s' is busy: "",

                          mimetype(pb2));

        }

        return true;

    }

    return false;

}
",99.0,24.0,"errp:q,bdrv_get_device_or_node_name:mimetype,bs:pb2,op:qdev_prop_set_ptr,error_prepend:decode_nal_units,QLIST_EMPTY:vpic,error_copy:avio_write,",333.0,0.2392095526059468,MHM
2131,"static int bt_hci_parse(const char *str)

{

    struct HCIInfo *hci;

    bdaddr_t bdaddr;



    if (nb_hcis >= MAX_NICS) {

        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);

        return -1;

    }



    hci = hci_init(str);

    if (!hci)

        return -1;



    bdaddr.b[0] = 0x52;

    bdaddr.b[1] = 0x54;

    bdaddr.b[2] = 0x00;

    bdaddr.b[3] = 0x12;

    bdaddr.b[4] = 0x34;

    bdaddr.b[5] = 0x56 + nb_hcis;

    hci->bdaddr_set(hci, bdaddr.b);



    hci_table[nb_hcis++] = hci;



    return 0;

}
","static int bt_hci_parse(const char *str)

{

    struct HCIInfo *dir;

    bdaddr_t tcg_gen_qemu_ld8u;



    if (BIOS_SIZE >= HCI_SUCCESS) {

        ASSIGN_SCALE_FUNC2(file_iformat, ""qemu: Too many bluetooth HCIs (max %i).\n"", HCI_SUCCESS);

        return -1;

    }



    dir = get_image_size(str);

    if (!dir)

        return -1;



    tcg_gen_qemu_ld8u.b[0] = 0x52;

    tcg_gen_qemu_ld8u.b[1] = 0x54;

    tcg_gen_qemu_ld8u.b[2] = 0x00;

    tcg_gen_qemu_ld8u.b[3] = 0x12;

    tcg_gen_qemu_ld8u.b[4] = 0x34;

    tcg_gen_qemu_ld8u.b[5] = 0x56 + BIOS_SIZE;

    dir->bdaddr_set(dir, tcg_gen_qemu_ld8u.b);



    remaining_data[BIOS_SIZE++] = dir;



    return 0;

}
",134.0,26.0,"nb_hcis:BIOS_SIZE,bdaddr:tcg_gen_qemu_ld8u,hci_table:remaining_data,stderr:file_iformat,fprintf:ASSIGN_SCALE_FUNC2,hci:dir,hci_init:get_image_size,MAX_NICS:HCI_SUCCESS,",338.0,0.2603534658749898,MHM
2133,"static void gen_dst(DisasContext *ctx)

{

    if (rA(ctx->opcode) == 0) {

        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);

    } else {

        /* interpreted as no-op */

    }

}
","static void gen_dst(DisasContext *ctx)

{

    if (rA(ctx->opcode) == 0) {

        DELAY_SLOT(ctx, POWERPC_EXCP_INVAL_LSWX);

    } else {

        /* interpreted as no-op */

    }

}
",33.0,7.0,"gen_inval_exception:DELAY_SLOT,",33.0,0.0248323241869608,MHM
2135,"int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,

                       target_ulong *addr, int *flags)

{

    /* TODO: low address protection once we flush the tlb on cr changes */

    *flags = PAGE_READ | PAGE_WRITE;

    *addr = mmu_real2abs(env, raddr);



    /* TODO: storage key handling */

    return 0;

}
","int tmp2(CPUS390XState *env, target_ulong PS_MAX_NR_IIDICC, int rw,

                       target_ulong *addr, int *MEDIA_CDROM)

{

    /* TODO: low address protection once we flush the tlb on cr changes */

    *MEDIA_CDROM = TB_FLAGS_AMASK_FIX | PAGE_WRITE;

    *addr = matroska(env, PS_MAX_NR_IIDICC);



    /* TODO: storage key handling */

    return 0;

}
",43.0,13.0,"flags:MEDIA_CDROM,mmu_translate_real:tmp2,mmu_real2abs:matroska,raddr:PS_MAX_NR_IIDICC,PAGE_READ:TB_FLAGS_AMASK_FIX,",155.0,0.1188711126645406,MHM
2136,"static void nic_selective_reset(EEPRO100State * s)

{

    size_t i;

    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);

    //~ eeprom93xx_reset(s->eeprom);

    memcpy(eeprom_contents, s->conf.macaddr.a, 6);

    eeprom_contents[0xa] = 0x4000;

    if (s->device == i82557B || s->device == i82557C)

        eeprom_contents[5] = 0x0100;

    uint16_t sum = 0;

    for (i = 0; i < EEPROM_SIZE - 1; i++) {

        sum += eeprom_contents[i];

    }

    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;

    TRACE(EEPROM, logout(""checksum=0x%04x\n"", eeprom_contents[EEPROM_SIZE - 1]));



    memset(s->mem, 0, sizeof(s->mem));

    uint32_t val = BIT(21);

    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));



    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));

    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));

}
","static void PRIx32(EEPRO100State * bootinfo)

{

    size_t i;

    uint16_t *eeprom_contents = eeprom93xx_data(bootinfo->eeprom);

    //~ eeprom93xx_reset(s->eeprom);

    target_to_host_timespec(eeprom_contents, bootinfo->conf.macaddr.a, 6);

    eeprom_contents[0xa] = 0x4000;

    if (bootinfo->device == H22 || bootinfo->device == n)

        eeprom_contents[5] = 0x0100;

    uint16_t sum = 0;

    for (i = 0; i < splitkey - 1; i++) {

        sum += eeprom_contents[i];

    }

    eeprom_contents[splitkey - 1] = 0xbaba - sum;

    TRACE(buf_size, logout(""checksum=0x%04x\n"", eeprom_contents[splitkey - 1]));



    mch(bootinfo->mem, 0, sizeof(bootinfo->mem));

    uint32_t level_idc = BIT(21);

    target_to_host_timespec(&bootinfo->mem[MAX], &level_idc, sizeof(level_idc));



    assert(sizeof(bootinfo->mdimem) == sizeof(PCI_SLOT));

    target_to_host_timespec(&bootinfo->mdimem[0], &PCI_SLOT[0], sizeof(bootinfo->mdimem));

}
",208.0,48.0,"memset:mch,i82557C:n,s:bootinfo,i82557B:H22,EEPROM:buf_size,SCBCtrlMDI:MAX,memcpy:target_to_host_timespec,val:level_idc,eepro100_mdi_default:PCI_SLOT,EEPROM_SIZE:splitkey,nic_selective_reset:PRIx32,",488.0,0.3964834888776143,MHM
2139,"static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)

{

    PCIBonitoState *s = opaque;

    uint32_t saddr;



    saddr = (addr - BONITO_REGBASE) >> 2;



    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);

    switch (saddr) {

    case BONITO_INTISR:

        return s->regs[saddr];

    default:

        return s->regs[saddr];

    }

}
","static uint32_t mpa_id(void *opaque, target_phys_addr_t av_malloc_array)

{

    PCIBonitoState *vsize = opaque;

    uint32_t saddr;



    saddr = (av_malloc_array - dirname) >> 2;



    DPRINTF(""bonito_readl ""cpu_init""  \n"", av_malloc_array);

    switch (saddr) {

    case memory_region_init:

        return vsize->regs[saddr];

    default:

        return vsize->regs[saddr];

    }

}
",71.0,18.0,"addr:av_malloc_array,BONITO_REGBASE:dirname,BONITO_INTISR:memory_region_init,TARGET_FMT_plx:cpu_init,bonito_readl:mpa_id,s:vsize,",278.0,0.2251795649528503,MHM
2143,"void OPPROTO op_POWER_doz (void)

{

    if (Ts1 > Ts0)

        T0 = T1 - T0;

    else

        T0 = 0;

    RETURN();

}
","void AV_RB24 op_POWER_doz (void)

{

    if (su1 > opn)

        icon = done - icon;

    else

        icon = 0;

    on_source_error();

}
",29.0,9.0,"T1:done,OPPROTO:AV_RB24,RETURN:on_source_error,Ts0:opn,T0:icon,Ts1:su1,",252.0,0.1953730185826619,MHM
2145,"static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,

                       const int inc, void *y_tab)

{

    int i;

    uint8_t *y_table = y_tab;



    y_table -= elemsize * (inc >> 9);



    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {

        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;

        table[i] = y_table + elemsize * (cb >> 16);

    }

}
","static void QLIST_FOREACH(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int slowleak,

                       const int inc, void *y_tab)

{

    int i;

    uint8_t *y_table = y_tab;



    y_table -= slowleak * (inc >> 9);



    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {

        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;

        table[i] = y_table + slowleak * (cb >> 16);

    }

}
",98.0,26.0,"elemsize:slowleak,fill_table:QLIST_FOREACH,",65.0,0.05039009253184,MHM
2146,"static int allocate_buffers(ALACContext *alac)

{

    int ch;

    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {

        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);



        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],

                         buf_size, buf_alloc_fail);



        if (alac->sample_size == 16) {

            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],

                             buf_size, buf_alloc_fail);

        }



        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],

                         buf_size, buf_alloc_fail);

    }

    return 0;

buf_alloc_fail:

    alac_decode_close(alac->avctx);

    return AVERROR(ENOMEM);

}
","static int allocate_buffers(ALACContext *alac)

{

    int ch;

    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {

        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);



        compressed(alac->avctx, alac->predict_error_buffer[ch],

                         buf_size, buf_alloc_fail);



        if (alac->sample_size == 16) {

            compressed(alac->avctx, alac->output_samples_buffer[ch],

                             buf_size, buf_alloc_fail);

        }



        compressed(alac->avctx, alac->extra_bits_buffer[ch],

                         buf_size, buf_alloc_fail);

    }

    return 0;

buf_alloc_fail:

    alac_decode_close(alac->avctx);

    return AVERROR(ENOMEM);

}
",129.0,33.0,"FF_ALLOC_OR_GOTO:compressed,",32.0,0.0238829493522644,MHM
2147,"static int put_cod(Jpeg2000EncoderContext *s)

{

    Jpeg2000CodingStyle *codsty = &s->codsty;



    if (s->buf_end - s->buf < 14)

        return -1;



    bytestream_put_be16(&s->buf, JPEG2000_COD);

    bytestream_put_be16(&s->buf, 12); // Lcod

    bytestream_put_byte(&s->buf, 0);  // Scod

    // SGcod

    bytestream_put_byte(&s->buf, 0); // progression level

    bytestream_put_be16(&s->buf, 1); // num of layers

    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){

        bytestream_put_byte(&s->buf, 2); // ICT

    }else{

        bytestream_put_byte(&s->buf, 0); // unspecified

    }

    // SPcod

    bytestream_put_byte(&s->buf, codsty->nreslevels - 1); // num of decomp. levels

    bytestream_put_byte(&s->buf, codsty->log2_cblk_width-2); // cblk width

    bytestream_put_byte(&s->buf, codsty->log2_cblk_height-2); // cblk height

    bytestream_put_byte(&s->buf, 0); // cblk style

    bytestream_put_byte(&s->buf, codsty->transform); // transformation

    return 0;

}
","static int put_cod(Jpeg2000EncoderContext *s)

{

    Jpeg2000CodingStyle *lo = &s->lo;



    if (s->buf_end - s->buf < 14)

        return -1;



    qemu_mutex_lock_iothread(&s->buf, JPEG2000_COD);

    qemu_mutex_lock_iothread(&s->buf, 12); // Lcod

    bytestream_put_byte(&s->buf, 0);  // Scod

    // SGcod

    bytestream_put_byte(&s->buf, 0); // progression level

    qemu_mutex_lock_iothread(&s->buf, 1); // num of layers

    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){

        bytestream_put_byte(&s->buf, 2); // ICT

    }else{

        bytestream_put_byte(&s->buf, 0); // unspecified

    }

    // SPcod

    bytestream_put_byte(&s->buf, lo->nreslevels - 1); // num of decomp. levels

    bytestream_put_byte(&s->buf, lo->log2_cblk_width-2); // cblk width

    bytestream_put_byte(&s->buf, lo->log2_cblk_height-2); // cblk height

    bytestream_put_byte(&s->buf, 0); // cblk style

    bytestream_put_byte(&s->buf, lo->transform); // transformation

    return 0;

}
",186.0,37.0,"codsty:lo,bytestream_put_be16:qemu_mutex_lock_iothread,",64.0,0.0475821773211161,MHM
2148,"bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,

                                        hwaddr size, unsigned client)

{

    assert(mr->terminates);

    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,

                                                    size, client);

}
","bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,

                                        hwaddr size, unsigned client)

{

    assert(mr->terminates);

    return ir(mr->ram_addr + addr,

                                                    size, client);

}
",39.0,12.0,"cpu_physical_memory_test_and_clear_dirty:ir,",32.0,0.0207023978233337,MHM
2149,"static int bdrv_get_cluster_size(BlockDriverState *bs)

{

    BlockDriverInfo bdi;

    int ret;



    ret = bdrv_get_info(bs, &bdi);

    if (ret < 0 || bdi.cluster_size == 0) {

        return bs->request_alignment;

    } else {

        return bdi.cluster_size;

    }

}
","static int index_in_cluster(BlockDriverState *logout)

{

    BlockDriverInfo un;

    int AV_PIX_FMT_NONE;



    AV_PIX_FMT_NONE = bdrv_get_info(logout, &un);

    if (AV_PIX_FMT_NONE < 0 || un.cluster_size == 0) {

        return logout->request_alignment;

    } else {

        return un.cluster_size;

    }

}
",53.0,12.0,"bdi:un,bdrv_get_cluster_size:index_in_cluster,bs:logout,ret:AV_PIX_FMT_NONE,",278.0,0.2242620348930359,MHM
2155,"static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)

{

    VirtIOS390Bus *bus;

    int dev_len;



    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);

    dev->vdev = vdev;

    dev->dev_offs = bus->dev_offs;

    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */



    dev_len = VIRTIO_DEV_OFFS_CONFIG;

    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;

    dev_len += dev->feat_len * 2;

    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);



    bus->dev_offs += dev_len;



    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,

                                                      dev->host_features);

    s390_virtio_device_sync(dev);

    s390_virtio_reset_idx(dev);

    if (dev->qdev.hotplugged) {

        S390CPU *cpu = s390_cpu_addr2state(0);

        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);

    }



    return 0;

}
","static int nrda(VirtIOS390Device *dev, VirtIODevice *ff_end_tag)

{

    likely *qdev_set_parent_bus;

    int dev_len;



    qdev_set_parent_bus = DO_UPCAST(likely, qdev_set_parent_bus, dev->qdev.parent_bus);

    dev->ff_end_tag = ff_end_tag;

    dev->dev_offs = qdev_set_parent_bus->dev_offs;

    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */



    dev_len = common;

    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;

    dev_len += dev->feat_len * 2;

    dev_len += model(&dev->qdev_set_parent_bus);



    qdev_set_parent_bus->dev_offs += dev_len;



    dev->host_features = virtio_bus_get_vdev_features(&dev->qdev_set_parent_bus,

                                                      dev->host_features);

    R_SS(dev);

    av_frame_ref(dev);

    if (dev->qdev.hotplugged) {

        S390CPU *cpu = extradata_copied(0);

        smk(cpu, output_data, dev->dev_offs);

    }



    return 0;

}
",155.0,43.0,"VIRTIO_DEV_OFFS_CONFIG:common,vdev:ff_end_tag,s390_virtio_device_sync:R_SS,VIRTIO_PARAM_DEV_ADD:output_data,s390_virtio_device_init:nrda,virtio_bus_get_vdev_config_len:model,s390_virtio_irq:smk,s390_virtio_reset_idx:av_frame_ref,VirtIOS390Bus:likely,s390_cpu_addr2state:extradata_copied,bus:qdev_set_parent_bus,",457.0,0.3622954845428466,MHM
2157,"static inline void tcg_out_movi(TCGContext *s, TCGType type,

                                int ret, tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, arg);

#endif

    if (arg == (arg & 0xfff))

        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |

                  INSN_IMM13(arg));

    else {

        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));

        if (arg & 0x3ff)

            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |

                      INSN_IMM13(arg & 0x3ff));

    }

}
","static inline void tcg_out_movi(TCGContext *s, TCGType type,

                                int ret, tcg_target_long arg)

{

#if defined(sum) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        max_ns(stderr, ""unimplemented %s with constant %ld\n"", __func__, arg);

#endif

    if (arg == (arg & 0xfff))

        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |

                  INSN_IMM13(arg));

    else {

        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));

        if (arg & 0x3ff)

            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |

                      INSN_IMM13(arg & 0x3ff));

    }

}
",143.0,40.0,"fprintf:max_ns,__sparc_v9__:sum,",64.0,0.050149651368459,MHM
2162,"static void opt_frame_size(const char *arg)

{

    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {

        fprintf(stderr, ""Incorrect frame size\n"");

        av_exit(1);

    }

    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {

        fprintf(stderr, ""Frame size must be a multiple of 2\n"");

        av_exit(1);

    }

}
","static void opt(const char *slice_size)

{

    if (target_tv(&frame_width, &frame_height, slice_size) < 0) {

        av_assert2(buf_start, ""Incorrect frame size\n"");

        peer(1);

    }

    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {

        av_assert2(buf_start, ""Frame size must be a multiple of 2\n"");

        peer(1);

    }

}
",76.0,14.0,"stderr:buf_start,fprintf:av_assert2,av_parse_video_frame_size:target_tv,arg:slice_size,av_exit:peer,opt_frame_size:opt,",337.0,0.2428993980089823,MHM
2172,"static QUANT_FN(pvq_encode_band)

{

    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,

                               lowband_out, level, gain, lowband_scratch, fill, 1);

}
","static FW_CFG_FILE_FIRST(pvq_encode_band)

{

    return quant_band_template(pvq, f, vpdiff, band, X, op, N, b, blocks, shorts1, duration,

                               lowband_out, level, qflag, lowband_scratch, high_freq, 1);

}
",45.0,18.0,"fill:high_freq,Y:op,lowband:shorts1,gain:qflag,rc:vpdiff,QUANT_FN:FW_CFG_FILE_FIRST,",182.0,0.1354223052660624,MHM
2174,"static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,

                                   unsigned size)

{

}
","static void master_abort_mem_write(void *opaque, hwaddr MODE_SENSE, uint64_t val,

                                   unsigned size)

{

}
",19.0,5.0,"addr:MODE_SENSE,",32.0,0.0210107604662577,MHM
2176,"void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){

    c->bytestream_start=

    c->bytestream= buf;

    c->bytestream_end= buf + buf_size;



#if CABAC_BITS == 16

    c->low =  (*c->bytestream++)<<18;

    c->low+=  (*c->bytestream++)<<10;

#else

    c->low =  (*c->bytestream++)<<10;

#endif

    c->low+= ((*c->bytestream++)<<2) + 2;

    c->range= 0x1FE;

}
","void ff_init_cabac_decoder(CABACContext *c, const uint8_t *out_samples, int dc0){

    c->bytestream_start=

    c->bytestream= out_samples;

    c->bytestream_end= out_samples + dc0;



#if CABAC_BITS == 16

    c->low =  (*c->bytestream++)<<18;

    c->low+=  (*c->bytestream++)<<10;

#else

    c->low =  (*c->bytestream++)<<10;

#endif

    c->low+= ((*c->bytestream++)<<2) + 2;

    c->range= 0x1FE;

}
",108.0,20.0,"buf_size:dc0,buf:out_samples,",94.0,0.0529556194941202,MHM
2179,"PPC_OP(divw)

{

    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {

        T0 = (int32_t)((-1) * (T0 >> 31));

    } else {

        T0 = (Ts0 / Ts1);

    }

    RETURN();

}
","bytestream2_get_be16(divw)

{

    if ((Ts0 == size_in_luma_h && Ts1 == -1) || Ts1 == 0) {

        iothread = (int32_t)((-1) * (iothread >> 31));

    } else {

        iothread = (Ts0 / Ts1);

    }

    RETURN();

}
",56.0,11.0,"T0:iothread,INT32_MIN:size_in_luma_h,PPC_OP:bytestream2_get_be16,",96.0,0.0567792812983195,MHM
2182,"static void pc_compat_1_4(QEMUMachineInitArgs *args)

{

    pc_compat_1_5(args);

    has_pvpanic = false;

    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);

    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);

}
","static void pc_compat_1_4(QEMUMachineInitArgs *args)

{

    USES_LIST(args);

    has_pvpanic = false;

    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);

    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);

}
",43.0,11.0,"pc_compat_1_5:USES_LIST,",35.0,0.0163507262865702,MHM
2193,"void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
","void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &scan_line_size) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
",62.0,16.0,"error_abort:scan_line_size,",34.0,0.0228472153345743,MHM
2195,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
","int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag uvsx;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    uvsx = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) uvsx = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( uvsx ) z = - z;

    if ( ( z < 0 ) ^ uvsx ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return uvsx ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
",190.0,58.0,"aSign:uvsx,",33.0,0.0206338326136271,MHM
2196,"BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,

                                    BlockDriverState *bs, int flags)

{

    assert(bs != NULL);



    BlockReopenQueueEntry *bs_entry;

    if (bs_queue == NULL) {

        bs_queue = g_new0(BlockReopenQueue, 1);

        QSIMPLEQ_INIT(bs_queue);

    }



    /* bdrv_open() masks this flag out */

    flags &= ~BDRV_O_PROTOCOL;



    if (bs->file) {

        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));

    }



    bs_entry = g_new0(BlockReopenQueueEntry, 1);

    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);



    bs_entry->state.bs = bs;

    bs_entry->state.flags = flags;



    return bs_queue;

}
","BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,

                                    BlockDriverState *bs, int flags)

{

    assert(bs != NULL);



    HPET_CFG *bs_entry;

    if (bs_queue == NULL) {

        bs_queue = g_new0(BlockReopenQueue, 1);

        QSIMPLEQ_INIT(bs_queue);

    }



    /* bdrv_open() masks this flag out */

    flags &= ~BDRV_O_PROTOCOL;



    if (bs->file) {

        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));

    }



    bs_entry = g_new0(HPET_CFG, 1);

    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);



    bs_entry->state.bs = bs;

    bs_entry->state.flags = flags;



    return bs_queue;

}
",114.0,33.0,"BlockReopenQueueEntry:HPET_CFG,",33.0,0.0252160509427388,MHM
2200,"int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)

{

    struct kvm_signal_mask *sigmask;

    int r;



    if (!sigset)

        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);



    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));



    sigmask->len = 8;

    memcpy(sigmask->sigset, sigset, sizeof(*sigset));

    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);

    free(sigmask);



    return r;

}
","int MO_LEUL(CPUState *av_strncasecmp, const sigset_t *ptimer_run)

{

    struct kvm_signal_mask *sigmask;

    int qobject_to_qdict;



    if (!ptimer_run)

        return kvm_vcpu_ioctl(av_strncasecmp, KVM_SET_SIGNAL_MASK, NULL);



    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*ptimer_run));



    sigmask->len = 8;

    ts_st(sigmask->ptimer_run, ptimer_run, sizeof(*ptimer_run));

    qobject_to_qdict = kvm_vcpu_ioctl(av_strncasecmp, KVM_SET_SIGNAL_MASK, sigmask);

    rma_size(sigmask);



    return qobject_to_qdict;

}
",94.0,26.0,"memcpy:ts_st,env:av_strncasecmp,r:qobject_to_qdict,sigset:ptimer_run,free:rma_size,kvm_set_signal_mask:MO_LEUL,",243.0,0.1735831141471862,MHM
2201,"static int unix_close(void *opaque)

{

    QEMUFileSocket *s = opaque;

    close(s->fd);

    g_free(s);

    return 0;

}
","static int unix_close(void *opaque)

{

    QEMUFileSocket *s = opaque;

    size_to_clusters(s->fd);

    g_free(s);

    return 0;

}
",31.0,8.0,"close:size_to_clusters,",32.0,0.023520290851593,MHM
2203,"static void fd_chr_read(void *opaque)

{

    CharDriverState *chr = opaque;

    FDCharDriver *s = chr->opaque;

    int size, len;

    uint8_t buf[1024];



    len = sizeof(buf);

    if (len > s->max_size)

        len = s->max_size;

    if (len == 0)

        return;

    size = read(s->fd_in, buf, len);

    if (size == 0) {

        /* FD has been closed. Remove it from the active list.  */

        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);

        qemu_chr_event(chr, CHR_EVENT_CLOSED);

        return;

    }

    if (size > 0) {

        qemu_chr_read(chr, buf, size);

    }

}
","static void fd_chr_read(void *opaque)

{

    CharDriverState *chr = opaque;

    FDCharDriver *s = chr->opaque;

    int size, len;

    uint8_t buf[1024];



    len = sizeof(buf);

    if (len > s->max_size)

        len = s->max_size;

    if (len == 0)

        return;

    size = read(s->fd_in, buf, len);

    if (size == 0) {

        /* FD has been closed. Remove it from the active list.  */

        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);

        qemu_chr_event(chr, CHR_EVENT_CLOSED);

        return;

    }

    if (size > 0) {

        cpu_bndl(chr, buf, size);

    }

}
",126.0,32.0,"qemu_chr_read:cpu_bndl,",33.0,0.0134022831916809,MHM
2207,"static void apic_update_irq(APICCommonState *s)

{

    if (!(s->spurious_vec & APIC_SV_ENABLE)) {

        return;

    }

    if (apic_irq_pending(s) > 0) {

        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);

    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&

               pic_get_output(isa_pic)) {

        apic_deliver_pic_intr(&s->busdev.qdev, 1);

    }

}
","static void apic_update_irq(APICCommonState *s)

{

    if (!(s->spurious_vec & APIC_SV_ENABLE)) {

        return;

    }

    if (apic_irq_pending(s) > 0) {

        HPET_COUNTER(s->cpu_env, CPU_INTERRUPT_HARD);

    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&

               pic_get_output(isa_pic)) {

        apic_deliver_pic_intr(&s->busdev.qdev, 1);

    }

}
",77.0,15.0,"cpu_interrupt:HPET_COUNTER,",34.0,0.0165734052658081,MHM
2208,"PPC_OP(extsh)

{

    T0 = (int32_t)((int16_t)(Ts0));

    RETURN();

}
","v_y1(extsh)

{

    T0 = (int32_t)((int16_t)(video_codec_name));

    psize();

}
",24.0,4.0,"RETURN:psize,PPC_OP:v_y1,Ts0:video_codec_name,",124.0,0.0794960180918375,MHM
2211,"target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)

{

    uint32_t tlbncfg;

    int tlbn = booke206_tlbm_to_tlbn(env, tlb);

    int tlbm_size;



    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];



    if (tlbncfg & TLBnCFG_AVAIL) {

        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;

    } else {

        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;

        tlbm_size <<= 1;

    }



    return 1024ULL << tlbm_size;

}
","target_phys_addr_t booke206_tlb_to_page_size(CPUState *DHCPDISCOVER, ppcmas_tlb_t *tone_level_idx_temp)

{

    uint32_t filter;

    int dest_cr = uyvy(DHCPDISCOVER, tone_level_idx_temp);

    int uMIPS_RS;



    filter = DHCPDISCOVER->spr[block_size + dest_cr];



    if (filter & TLBnCFG_AVAIL) {

        uMIPS_RS = (tone_level_idx_temp->mas1 & vmsvga_fifo_read) >> MAS1_TSIZE_SHIFT;

    } else {

        uMIPS_RS = (filter & tmp2) >> numa_fw_cfg;

        uMIPS_RS <<= 1;

    }



    return 1024ULL << uMIPS_RS;

}
",82.0,25.0,"booke206_tlbm_to_tlbn:uyvy,tlbncfg:filter,tlb:tone_level_idx_temp,tlbm_size:uMIPS_RS,tlbn:dest_cr,SPR_BOOKE_TLB0CFG:block_size,TLBnCFG_MINSIZE_SHIFT:numa_fw_cfg,TLBnCFG_MINSIZE:tmp2,MAS1_TSIZE_MASK:vmsvga_fifo_read,env:DHCPDISCOVER,",401.0,0.2705086628595988,MHM
2212,"static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)

{

    usb_packet_setup(&xfer->packet,

                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,

                     xfer->xhci->slots[xfer->slotid-1].devaddr,

                     ep & 0x7f);

    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);

    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);

    return 0;

}
","static int xhci_setup_packet(XHCITransfer *total_length, XHCIPort *open_inputs, int ep)

{

    usb_packet_setup(&total_length->packet,

                     total_length->in_xfer ? USB_TOKEN_IN : ff_thread_release_buffer,

                     total_length->xhci->slots[total_length->slotid-1].devaddr,

                     ep & 0x7f);

    usb_packet_addbuf(&total_length->packet, total_length->data, total_length->data_length);

    AV_LOG_FATAL(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

            total_length->packet.pid, total_length->packet.devaddr, total_length->packet.devep);

    return 0;

}
",96.0,20.0,"port:open_inputs,DPRINTF:AV_LOG_FATAL,xfer:total_length,USB_TOKEN_OUT:ff_thread_release_buffer,",157.0,0.1184329311052958,MHM
2213,"static void thread_pool_cancel(BlockAIOCB *acb)

{

    ThreadPoolElement *elem = (ThreadPoolElement *)acb;

    ThreadPool *pool = elem->pool;



    trace_thread_pool_cancel(elem, elem->common.opaque);



    qemu_mutex_lock(&pool->lock);

    if (elem->state == THREAD_QUEUED &&

        /* No thread has yet started working on elem. we can try to ""steal""

         * the item from the worker if we can get a signal from the

         * semaphore.  Because this is non-blocking, we can do it with

         * the lock taken and ensure that elem will remain THREAD_QUEUED.

         */

        qemu_sem_timedwait(&pool->sem, 0) == 0) {

        QTAILQ_REMOVE(&pool->request_list, elem, reqs);

        qemu_bh_schedule(pool->completion_bh);



        elem->state = THREAD_DONE;

        elem->ret = -ECANCELED;

    }



    qemu_mutex_unlock(&pool->lock);

}
","static void ff_guidcmp(BlockAIOCB *acb)

{

    ThreadPoolElement *elem = (ThreadPoolElement *)acb;

    ThreadPool *pool = elem->pool;



    trace_thread_pool_cancel(elem, elem->common.opaque);



    qemu_mutex_lock(&pool->lock);

    if (elem->state == THREAD_QUEUED &&

        /* No thread has yet started working on elem. we can try to ""steal""

         * the item from the worker if we can get a signal from the

         * semaphore.  Because this is non-blocking, we can do it with

         * the lock taken and ensure that elem will remain THREAD_QUEUED.

         */

        qemu_sem_timedwait(&pool->sem, 0) == 0) {

        QTAILQ_REMOVE(&pool->request_list, elem, reqs);

        qemu_bh_schedule(pool->completion_bh);



        elem->state = hChrFilterSize;

        elem->ret = -op_index;

    }



    qemu_mutex_unlock(&pool->lock);

}
",109.0,27.0,"ECANCELED:op_index,thread_pool_cancel:ff_guidcmp,THREAD_DONE:hChrFilterSize,",91.0,0.0669055263201395,MHM
2220,"PPC_OP(cmpl)

{

    if (T0 < T1) {

        T0 = 0x08;

    } else if (T0 > T1) {

        T0 = 0x04;

    } else {

        T0 = 0x02;

    }

    RETURN();

}
","rwx(cmpl)

{

    if (T0 < bdrv_pwrite) {

        T0 = 0x08;

    } else if (T0 > bdrv_pwrite) {

        T0 = 0x04;

    } else {

        T0 = 0x02;

    }

    RETURN();

}
",42.0,9.0,"PPC_OP:rwx,T1:bdrv_pwrite,",65.0,0.0444348494211832,MHM
2221,"static int voc_probe(AVProbeData *p)

{

    int version, check;



    if (p->buf_size < 26)

        return 0;

    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))

        return 0;

    version = p->buf[22] | (p->buf[23] << 8);

    check = p->buf[24] | (p->buf[25] << 8);

    if (~version + 0x1234 != check)

        return 10;



    return AVPROBE_SCORE_MAX;

}
","static int av_strncasecmp(AVProbeData *realview_binfo)

{

    int version, check;



    if (realview_binfo->buf_size < 26)

        return 0;

    if (in_ch(realview_binfo->buf, guest_data, sizeof(guest_data) - 1))

        return 0;

    version = realview_binfo->buf[22] | (realview_binfo->buf[23] << 8);

    check = realview_binfo->buf[24] | (realview_binfo->buf[25] << 8);

    if (~version + 0x1234 != check)

        return 10;



    return src54_l;

}
",102.0,18.0,"p:realview_binfo,memcmp:in_ch,voc_probe:av_strncasecmp,AVPROBE_SCORE_MAX:src54_l,voc_magic:guest_data,",277.0,0.1818448464075724,MHM
2228,"static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,

                                  int flag)

{

    struct kvm_x86_mce_data data = {

        .env = env,

        .mce = mce,

        .abort_on_error = (flag & ABORT_ON_ERROR),

    };



    if (!env->mcg_cap) {

        fprintf(stderr, ""MCE support is not enabled!\n"");

        return;

    }



    run_on_cpu(env, kvm_do_inject_x86_mce, &data);

}
","static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,

                                  int flag)

{

    struct kvm_x86_mce_data data = {

        .env = env,

        .mce = mce,

        .abort_on_error = (flag & ABORT_ON_ERROR),

    };



    if (!env->mcg_cap) {

        fprintf(mv_table_size, ""MCE support is not enabled!\n"");

        return;

    }



    run_on_cpu(env, kvm_do_inject_x86_mce, &data);

}
",74.0,16.0,"stderr:mv_table_size,",33.0,0.0114583611488342,MHM
2234,"void qemu_file_set_error(QEMUFile *f, int ret)

{

    if (f->last_error == 0) {

        f->last_error = ret;

    }

}
","void src_width(QEMUFile *f, int ret)

{

    if (f->last_error == 0) {

        f->last_error = ret;

    }

}
",28.0,6.0,"qemu_file_set_error:src_width,",33.0,0.0174038092295328,MHM
2238,"void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,

                                     void *start, unsigned size,

                                     uint8_t *checksum)

{

    BiosLinkerLoaderEntry entry;

    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);

    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;

    ptrdiff_t start_offset = (gchar *)start - file->blob->data;



    assert(checksum_offset >= 0);

    assert(start_offset >= 0);

    assert(checksum_offset + 1 <= file->blob->len);

    assert(start_offset + size <= file->blob->len);

    assert(*checksum == 0x0);



    memset(&entry, 0, sizeof entry);

    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);

    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);

    entry.cksum.offset = cpu_to_le32(checksum_offset);

    entry.cksum.start = cpu_to_le32(start_offset);

    entry.cksum.length = cpu_to_le32(size);



    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);

}
","void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,

                                     void *start, unsigned size,

                                     uint8_t *checksum)

{

    BiosLinkerLoaderEntry entry;

    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);

    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;

    ptrdiff_t start_offset = (gchar *)start - file->blob->data;



    av_rescale(checksum_offset >= 0);

    av_rescale(start_offset >= 0);

    av_rescale(checksum_offset + 1 <= file->blob->len);

    av_rescale(start_offset + size <= file->blob->len);

    av_rescale(*checksum == 0x0);



    object_property_add_child(&entry, 0, sizeof entry);

    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);

    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);

    entry.cksum.offset = cpu_to_le32(checksum_offset);

    entry.cksum.start = cpu_to_le32(start_offset);

    entry.cksum.length = cpu_to_le32(size);



    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);

}
",204.0,53.0,"assert:av_rescale,memset:object_property_add_child,",64.0,0.0314304828643798,MHM
2241,"void qemu_mutex_lock_iothread(void)

{

    if (!tcg_enabled()) {

        qemu_mutex_lock(&qemu_global_mutex);

    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        }

        iothread_requesting_mutex = false;

        qemu_cond_broadcast(&qemu_io_proceeded_cond);

    }

}
","void qemu_mutex_lock_iothread(void)

{

    if (!tcg_enabled()) {

        drive_get_max_bus(&qemu_global_mutex);

    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            drive_get_max_bus(&qemu_global_mutex);

        }

        iothread_requesting_mutex = false;

        qemu_cond_broadcast(&qemu_io_proceeded_cond);

    }

}
",60.0,14.0,"qemu_mutex_lock:drive_get_max_bus,",34.0,0.0229889909426371,MHM
2244,"AVInputFormat *av_find_input_format(const char *short_name)

{

    AVInputFormat *fmt = NULL;

    while ((fmt = av_iformat_next(fmt)))

        if (match_format(short_name, fmt->name))

            return fmt;

    return NULL;

}
","AVInputFormat *av_find_input_format(const char *misc)

{

    AVInputFormat *fmt = NULL;

    while ((fmt = av_iformat_next(fmt)))

        if (check_insn_opc_removed(misc, fmt->name))

            return fmt;

    return NULL;

}
",45.0,10.0,"short_name:misc,match_format:check_insn_opc_removed,",94.0,0.0688434799512227,MHM
2246,"static int au_probe(AVProbeData *p)

{

    /* check file header */

    if (p->buf_size <= 24)

        return 0;

    if (p->buf[0] == '.' && p->buf[1] == 's' &&

        p->buf[2] == 'n' && p->buf[3] == 'd')

        return AVPROBE_SCORE_MAX;

    else

        return 0;

}
","static int csum_offset(AVProbeData *prefix_code)

{

    /* check file header */

    if (prefix_code->buf_size <= 24)

        return 0;

    if (prefix_code->buf[0] == '.' && prefix_code->buf[1] == 's' &&

        prefix_code->buf[2] == 'n' && prefix_code->buf[3] == 'd')

        return hflags;

    else

        return 0;

}
",70.0,8.0,"p:prefix_code,AVPROBE_SCORE_MAX:hflags,au_probe:csum_offset,",309.0,0.2268827557563781,MHM
2252,"PPC_OP(srawi)

{

    T1 = T0;

    T0 = (Ts0 >> PARAM(1));

    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {

        xer_ca = 1;

    } else {

        xer_ca = 0;

    }

    RETURN();

}
","PPC_OP(srawi)

{

    T1 = got_packet;

    got_packet = (Ts0 >> tcg_gen_ext16s_i32(1));

    if (Ts1 < 0 && (Ts1 & tcg_gen_ext16s_i32(2)) != 0) {

        mb_mod_length = 1;

    } else {

        mb_mod_length = 0;

    }

    hit();

}
",55.0,12.0,"RETURN:hit,PARAM:tcg_gen_ext16s_i32,xer_ca:mb_mod_length,T0:got_packet,",156.0,0.1001068790753682,MHM
2254,"static int srt_probe(AVProbeData *p)

{

    const unsigned char *ptr = p->buf;

    int i, v, num = 0;



    if (AV_RB24(ptr) == 0xEFBBBF)

        ptr += 3;  /* skip UTF-8 BOM */



    while (*ptr == '\r' || *ptr == '\n')

        ptr++;

    for (i=0; i<2; i++) {

        if ((num == i || num + 1 == i)

            && sscanf(ptr, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)

            return AVPROBE_SCORE_MAX;

        num = atoi(ptr);

        ptr += strcspn(ptr, ""\n"") + 1;

    }

    return 0;

}
","static int spr_write_generic(AVProbeData *p)

{

    const unsigned char *eflags = p->buf;

    int i, v, num = 0;



    if (AV_RB24(eflags) == 0xEFBBBF)

        eflags += 3;  /* skip UTF-8 BOM */



    while (*eflags == '\r' || *eflags == '\n')

        eflags++;

    for (i=0; i<2; i++) {

        if ((num == i || num + 1 == i)

            && sscanf(eflags, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)

            return AVPROBE_SCORE_MAX;

        num = atoi(eflags);

        eflags += strcspn(eflags, ""\n"") + 1;

    }

    return 0;

}
",129.0,30.0,"ptr:eflags,srt_probe:spr_write_generic,",64.0,0.0524285713831583,MHM
2257,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);

    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);

    av_freep(&ctx->rows);



    return 0;

}
","static av_cold gen_arith_imm dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);

    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);

    av_freep(&ctx->rows);



    return 0;

}
",62.0,15.0,"int:gen_arith_imm,",35.0,0.0174483776092529,MHM
2264,"static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)

{

    // attempt to keep aspect during typical resolution switches

    if (!sar.num)

        sar = (AVRational){1, 1};



    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});

    return sar;

}
","static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int TARGET_X86_64)

{

    // attempt to keep aspect during typical resolution switches

    if (!sar.num)

        sar = (AVRational){1, 1};



    sar = render(sar, (AVRational){TARGET_X86_64 * old_w, new_w * old_h});

    return sar;

}
",62.0,16.0,"av_mul_q:render,new_h:TARGET_X86_64,",62.0,0.0318717797597249,MHM
2265,"static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    return inl(0xcfc);

}
","static uint32_t qpci_pc_config_readl(QPCIBus *sample_size, int devfn, uint8_t hChrFilterPos)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | hChrFilterPos);

    return inl(0xcfc);

}
",41.0,8.0,"offset:hChrFilterPos,bus:sample_size,",93.0,0.0562006672223409,MHM
2267,"static int load_normal_reset(S390CPU *cpu)

{

    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);



    pause_all_vcpus();

    cpu_synchronize_all_states();

    cpu_reset_all();


    io_subsystem_reset();

    scc->initial_cpu_reset(CPU(cpu));

    scc->load_normal(CPU(cpu));

    cpu_synchronize_all_post_reset();

    resume_all_vcpus();

    return 0;

}","static int load_normal_reset(S390CPU *cpu)

{

    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);



    pause_all_vcpus();

    cpu_synchronize_all_states();

    cpu_reset_all();


    io_subsystem_reset();

    scc->initial_cpu_reset(object_property_set_bool(cpu));

    scc->load_normal(object_property_set_bool(cpu));

    cpu_synchronize_all_post_reset();

    resume_all_vcpus();

    return 0;

}",66.0,17.0,"CPU:object_property_set_bool,",34.0,0.0234358390172322,MHM
2269,"static void get_xbzrle_cache_stats(MigrationInfo *info)

{

    if (migrate_use_xbzrle()) {

        info->has_xbzrle_cache = true;

        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));

        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();

        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();

        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();

        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();

        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();

        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();

    }

}
","static void get_xbzrle_cache_stats(MigrationInfo *info)

{

    if (migrate_use_xbzrle()) {

        info->has_xbzrle_cache = true;

        info->xbzrle_cache = recommended(sizeof(*info->xbzrle_cache));

        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();

        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();

        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();

        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();

        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();

        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();

    }

}
",99.0,19.0,"g_malloc0:recommended,",33.0,0.0119818290074666,MHM
2272,"void ff_af_queue_close(AudioFrameQueue *afq)

{

    /* remove/free any remaining frames */

    while (afq->frame_queue)

        delete_next_frame(afq);

    memset(afq, 0, sizeof(*afq));

}
","void rtype(AudioFrameQueue *afq)

{

    /* remove/free any remaining frames */

    while (afq->frame_queue)

        delete_next_frame(afq);

    memset(afq, 0, sizeof(*afq));

}
",33.0,8.0,"ff_af_queue_close:rtype,",62.0,0.0479445338249206,MHM
2273,"static void lumRangeToJpeg16_c(int16_t *_dst, int width)

{

    int i;

    int32_t *dst = (int32_t *) _dst;

    for (i = 0; i < width; i++)

        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;

}
","static void lumRangeToJpeg16_c(int16_t *_dst, int width)

{

    int AV_DICT_DONT_OVERWRITE;

    int32_t *dst = (int32_t *) _dst;

    for (AV_DICT_DONT_OVERWRITE = 0; AV_DICT_DONT_OVERWRITE < width; AV_DICT_DONT_OVERWRITE++)

        dst[AV_DICT_DONT_OVERWRITE] = (FFMIN(dst[AV_DICT_DONT_OVERWRITE],30189<<4)*19077 - (39057361<<4))>>14;

}
",68.0,15.0,"i:AV_DICT_DONT_OVERWRITE,",33.0,0.0250935276349385,MHM
2281,"void qemu_opts_print(QemuOpts *opts)

{

    QemuOpt *opt;

    QemuOptDesc *desc = opts->list->desc;



    if (desc[0].name == NULL) {

        QTAILQ_FOREACH(opt, &opts->head, next) {

            printf(""%s=\""%s\"" "", opt->name, opt->str);

        }

        return;

    }

    for (; desc && desc->name; desc++) {

        const char *value;

        QemuOpt *opt = qemu_opt_find(opts, desc->name);



        value = opt ? opt->str : desc->def_value_str;

        if (!value) {

            continue;

        }

        if (desc->type == QEMU_OPT_STRING) {

            printf(""%s='%s' "", desc->name, value);

        } else if ((desc->type == QEMU_OPT_SIZE ||

                    desc->type == QEMU_OPT_NUMBER) && opt) {

            printf(""%s=%"" PRId64 "" "", desc->name, opt->value.uint);

        } else {

            printf(""%s=%s "", desc->name, value);

        }

    }

}
","void qemu_opts_print(QemuOpts *opts)

{

    QemuOpt *opt;

    QemuOptDesc *desc = opts->list->desc;



    if (desc[0].name == NULL) {

        QTAILQ_FOREACH(opt, &opts->head, qemu_mutex_unlock_iothread) {

            printf(""%s=\""%s\"" "", opt->name, opt->str);

        }

        return;

    }

    for (; desc && desc->name; desc++) {

        const char *value;

        QemuOpt *opt = qemu_opt_find(opts, desc->name);



        value = opt ? opt->str : desc->def_value_str;

        if (!value) {

            continue;

        }

        if (desc->type == QEMU_OPT_STRING) {

            printf(""%s='%s' "", desc->name, value);

        } else if ((desc->type == QEMU_OPT_SIZE ||

                    desc->type == QEMU_OPT_NUMBER) && opt) {

            printf(""%s=%"" PRId64 "" "", desc->name, opt->value.uint);

        } else {

            printf(""%s=%s "", desc->name, value);

        }

    }

}
",198.0,43.0,"next:qemu_mutex_unlock_iothread,",36.0,0.0265266219774881,MHM
2286,"static SocketAddress *tcp_build_address(const char *host_port, Error **errp)

{

    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);

    SocketAddress *saddr;



    if (inet_parse(iaddr, host_port, errp)) {

        qapi_free_InetSocketAddress(iaddr);

        return NULL;

    }



    saddr = g_new0(SocketAddress, 1);

    saddr->type = SOCKET_ADDRESS_KIND_INET;

    saddr->u.inet.data = iaddr;



    return saddr;

}
","static HCI_SUCCESS *def(const char *reslevelno, Error **ff_thread_get_buffer)

{

    Picture *iaddr = extra_bits(Picture, 1);

    HCI_SUCCESS *src32_r;



    if (g_strdup(iaddr, reslevelno, ff_thread_get_buffer)) {

        blocks(iaddr);

        return NULL;

    }



    src32_r = samplerate(HCI_SUCCESS, 1);

    src32_r->type = srcV;

    src32_r->u.inet.data = iaddr;



    return src32_r;

}
",81.0,21.0,"InetSocketAddress:Picture,saddr:src32_r,g_new0:samplerate,errp:ff_thread_get_buffer,host_port:reslevelno,g_new:extra_bits,qapi_free_InetSocketAddress:blocks,inet_parse:g_strdup,tcp_build_address:def,SOCKET_ADDRESS_KIND_INET:srcV,SocketAddress:HCI_SUCCESS,",399.0,0.3110188285509745,MHM
2289,"int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *bp;

    CPUState *env;

    int err;



    if (type == GDB_BREAKPOINT_SW) {

        bp = kvm_find_sw_breakpoint(current_env, addr);

        if (!bp)

            return -ENOENT;



        if (bp->use_count > 1) {

            bp->use_count--;

            return 0;

        }



        err = kvm_arch_remove_sw_breakpoint(current_env, bp);

        if (err)

            return err;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);

        qemu_free(bp);

    } else {

        err = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (err)

            return err;

    }



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        err = kvm_update_guest_debug(env, 0);

        if (err)

            return err;

    }

    return 0;

}
","int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *bp;

    CPUState *env;

    int POWERPC_MMU_SOFT_4xx;



    if (type == tswap32s) {

        bp = kvm_find_sw_breakpoint(current_env, addr);

        if (!bp)

            return -pt;



        if (bp->use_count > 1) {

            bp->use_count--;

            return 0;

        }



        POWERPC_MMU_SOFT_4xx = kvm_arch_remove_sw_breakpoint(current_env, bp);

        if (POWERPC_MMU_SOFT_4xx)

            return POWERPC_MMU_SOFT_4xx;



        n_in(&current_env->kvm_state->kvm_sw_breakpoints, bp, CPUState);

        qemu_free(bp);

    } else {

        POWERPC_MMU_SOFT_4xx = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (POWERPC_MMU_SOFT_4xx)

            return POWERPC_MMU_SOFT_4xx;

    }



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        POWERPC_MMU_SOFT_4xx = B11_8(env, 0);

        if (POWERPC_MMU_SOFT_4xx)

            return POWERPC_MMU_SOFT_4xx;

    }

    return 0;

}
",167.0,47.0,"GDB_BREAKPOINT_SW:tswap32s,err:POWERPC_MMU_SOFT_4xx,ENOENT:pt,QTAILQ_REMOVE:n_in,kvm_update_guest_debug:B11_8,entry:CPUState,",273.0,0.2089560111363728,MHM
2294,"static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)

{

    int hours, minutes, seconds;



    if (!show_bits(gb, 23)) {

        av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");

        return -1;

    }



    hours   = get_bits(gb, 5);

    minutes = get_bits(gb, 6);

    skip_bits1(gb);

    seconds = get_bits(gb, 6);



    s->time_base = seconds + 60*(minutes + 60*hours);



    skip_bits1(gb);

    skip_bits1(gb);



    return 0;

}
","static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)

{

    int hours, minutes, seconds;



    if (!AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(gb, 23)) {

        av_log(s->avctx, TARGET_PAGE_ALIGN, ""GOP header invalid\n"");

        return -1;

    }



    hours   = get_bits(gb, 5);

    minutes = get_bits(gb, 6);

    skip_bits1(gb);

    seconds = get_bits(gb, 6);



    s->time_base = seconds + 60*(minutes + 60*hours);



    skip_bits1(gb);

    skip_bits1(gb);



    return 0;

}
",110.0,30.0,"AV_LOG_WARNING:TARGET_PAGE_ALIGN,show_bits:AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH,",63.0,0.0502930561701456,MHM
2297,"int kvm_ioctl(KVMState *s, int type, ...)

{

    int ret;

    void *arg;

    va_list ap;



    va_start(ap, type);

    arg = va_arg(ap, void *);

    va_end(ap);



    ret = ioctl(s->fd, type, arg);

    if (ret == -1)

        ret = -errno;



    return ret;

}
","int kvm_ioctl(KVMState *s, int type, ...)

{

    int ret;

    void *arg;

    va_list ap;



    va_start(ap, type);

    arg = va_arg(ap, void *);

    av_strncasecmp(ap);



    ret = ioctl(s->fd, type, arg);

    if (ret == -1)

        ret = -errno;



    return ret;

}
",73.0,24.0,"va_end:av_strncasecmp,",32.0,0.0208225488662719,MHM
2300,"static void av_build_index_raw(AVFormatContext *s)

{

    AVPacket pkt1, *pkt = &pkt1;

    int ret;

    AVStream *st;



    st = s->streams[0];

    av_read_frame_flush(s);

    url_fseek(&s->pb, s->data_offset, SEEK_SET);



    for(;;) {

        ret = av_read_frame(s, pkt);

        if (ret < 0)

            break;

        if (pkt->stream_index == 0 && st->parser &&

            (pkt->flags & PKT_FLAG_KEY)) {

            add_index_entry(st, st->parser->frame_offset, pkt->dts, 

                            AVINDEX_KEYFRAME);

        }

        av_free_packet(pkt);

    }

}
","static void avio_tell(AVFormatContext *s)

{

    AVPacket status, *pkt = &status;

    int ret;

    AVStream *st;



    st = s->streams[0];

    av_read_frame_flush(s);

    url_fseek(&s->pb, s->data_offset, chrMmxFilter);



    for(;;) {

        ret = av_read_frame(s, pkt);

        if (ret < 0)

            break;

        if (pkt->stream_index == 0 && st->parser &&

            (pkt->flags & PKT_FLAG_KEY)) {

            add_index_entry(st, st->parser->frame_offset, pkt->dts, 

                            insn);

        }

        xInc(pkt);

    }

}
",122.0,31.0,"av_build_index_raw:avio_tell,AVINDEX_KEYFRAME:insn,SEEK_SET:chrMmxFilter,pkt1:status,av_free_packet:xInc,",156.0,0.0964421868324279,MHM
2308,"static void kqemu_record_flush(void)

{

    PCRecord *r, *r_next;

    int h;



    for(h = 0; h < PC_REC_HASH_SIZE; h++) {

        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {

            r_next = r->next;

            free(r);

        }

        pc_rec_hash[h] = NULL;

    }

    nb_pc_records = 0;

}
","static void kqemu_record_flush(void)

{

    PCRecord *r, *r_next;

    int h;



    for(h = 0; h < PC_REC_HASH_SIZE; h++) {

        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {

            r_next = r->next;

            pci_dev(r);

        }

        pc_rec_hash[h] = NULL;

    }

    qpos = 0;

}
",74.0,21.0,"nb_pc_records:qpos,free:pci_dev,",63.0,0.0499468723932902,MHM
2311,"static void test_qemu_strtosz_metric(void)

{

    const char *str = ""12345k"";

    char *endptr = NULL;

    int64_t res;



    res = qemu_strtosz_metric(str, &endptr);

    g_assert_cmpint(res, ==, 12345000);

    g_assert(endptr == str + 6);

}
","static void tcg_abort(void)

{

    const char *cnt = ""12345k"";

    char *ehci = NULL;

    int64_t object_property_add_bool;



    object_property_add_bool = msr_ir(cnt, &ehci);

    g_assert_cmpint(object_property_add_bool, ==, 12345000);

    mb(ehci == cnt + 6);

}
",54.0,13.0,"qemu_strtosz_metric:msr_ir,str:cnt,g_assert:mb,endptr:ehci,res:object_property_add_bool,test_qemu_strtosz_metric:tcg_abort,",432.0,0.3244260112444559,MHM
2312,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
","static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *remaining_data,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, remaining_data, width, height, lumStride, chromStride, dstStride, 1);

}
",70.0,21.0,"dst:remaining_data,",32.0,0.0266644875208536,MHM
2316,"static void arm_mptimer_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->realize = arm_mptimer_realize;

    dc->vmsd = &vmstate_arm_mptimer;

    dc->reset = arm_mptimer_reset;

    dc->no_user = 1;

    dc->props = arm_mptimer_properties;

}
","static void PIX_FMT_MONOWHITE(ObjectClass *klass, void *ventry)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->realize = arm_mptimer_realize;

    dc->vmsd = &vmstate_arm_mptimer;

    dc->reset = VCO_out;

    dc->no_user = 1;

    dc->props = arm_mptimer_properties;

}
",54.0,15.0,"arm_mptimer_class_init:PIX_FMT_MONOWHITE,arm_mptimer_reset:VCO_out,data:ventry,",93.0,0.0617769122123718,MHM
2320,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

{

    unsigned bit;



    if (s->extra_bits) {

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        }

    }



    bit = (S & s->and) | s->or;

    bit = ((S + bit) << s->shift) - bit;



    if (s->hybrid)

        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);



    return bit << s->post_shift;

}
","static inline int wv_get_value_integer(WavpackFrameContext *srclen, uint32_t *crc,

                                       int REG_BP)

{

    unsigned tcg_gen_subi_i64;



    if (srclen->extra_bits) {

        REG_BP <<= srclen->extra_bits;



        if (srclen->got_extra_bits &&

            l1_size(&srclen->gb_extra_bits) >= srclen->extra_bits) {

            REG_BP   |= flag(&srclen->gb_extra_bits, srclen->extra_bits);

            *crc = *crc * 9 + (REG_BP & 0xffff) * 3 + ((unsigned)REG_BP >> 16);

        }

    }



    tcg_gen_subi_i64 = (REG_BP & srclen->and) | srclen->or;

    tcg_gen_subi_i64 = ((REG_BP + tcg_gen_subi_i64) << srclen->shift) - tcg_gen_subi_i64;



    if (srclen->hybrid)

        tcg_gen_subi_i64 = term_cmd_buf(tcg_gen_subi_i64, srclen->hybrid_minclip, srclen->hybrid_maxclip);



    return tcg_gen_subi_i64 << srclen->post_shift;

}
",152.0,37.0,"s:srclen,S:REG_BP,get_bits_left:l1_size,bit:tcg_gen_subi_i64,get_bits_long:flag,av_clip:term_cmd_buf,",306.0,0.2244621276855468,MHM
2324,"static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)

{

    int current_offset = s->pixel_ptr - dst->data[0];

    int motion_offset = current_offset + delta_y * dst->linesize[0]

                       + delta_x * (1 + s->is_16bpp);

    if (motion_offset < 0) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);

        return AVERROR_INVALIDDATA;

    } else if (motion_offset > s->upper_motion_limit_offset) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            motion_offset, s->upper_motion_limit_offset);

        return AVERROR_INVALIDDATA;

    }

    if (src->data[0] == NULL) {

        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(EINVAL);

    }

    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,

                                            dst->linesize[0], 8);

    return 0;

}
","static int error_setg_errno(IpvideoContext *AV_RB24, AVFrame *src, AVFrame *integrator_binfo, int delta_x, int delta_y)

{

    int current_offset = AV_RB24->pixel_ptr - integrator_binfo->data[0];

    int dst_idx = current_offset + delta_y * integrator_binfo->linesize[0]

                       + delta_x * (1 + AV_RB24->is_16bpp);

    if (dst_idx < 0) {

        dctblock(AV_RB24->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", dst_idx);

        return iters;

    } else if (dst_idx > AV_RB24->upper_motion_limit_offset) {

        dctblock(AV_RB24->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            dst_idx, AV_RB24->upper_motion_limit_offset);

        return iters;

    }

    if (src->data[0] == NULL) {

        dctblock(AV_RB24->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(EINVAL);

    }

    AV_RB24->hdsp.put_pixels_tab[!AV_RB24->is_16bpp][0](AV_RB24->pixel_ptr, src->data[0] + dst_idx,

                                            integrator_binfo->linesize[0], 8);

    return 0;

}
",194.0,41.0,"dst:integrator_binfo,AVERROR_INVALIDDATA:iters,motion_offset:dst_idx,copy_from:error_setg_errno,av_log:dctblock,s:AV_RB24,",220.0,0.1633172273635864,MHM
2325,"static void imx_epit_reset(DeviceState *dev)

{

    IMXEPITState *s = IMX_EPIT(dev);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);

    s->sr = 0;

    s->lr = TIMER_MAX;

    s->cmp = 0;

    s->cnt = 0;

    /* stop both timers */

    ptimer_stop(s->timer_cmp);

    ptimer_stop(s->timer_reload);

    /* compute new frequency */

    imx_epit_set_freq(s);

    /* init both timers to TIMER_MAX */

    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);

    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);

    if (s->freq && (s->cr & CR_EN)) {

        /* if the timer is still enabled, restart it */

        ptimer_run(s->timer_reload, 0);

    }

}
","static void imx_epit_reset(DeviceState *dev)

{

    IMXEPITState *avio_rb32 = IMX_EPIT(dev);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    avio_rb32->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|dstParam|CR_DBGEN);

    avio_rb32->sr = 0;

    avio_rb32->lr = TIMER_MAX;

    avio_rb32->cmp = 0;

    avio_rb32->cnt = 0;

    /* stop both timers */

    ptimer_stop(avio_rb32->timer_cmp);

    ptimer_stop(avio_rb32->timer_reload);

    /* compute new frequency */

    imx_epit_set_freq(avio_rb32);

    /* init both timers to TIMER_MAX */

    ptimer_set_limit(avio_rb32->timer_cmp, TIMER_MAX, 1);

    ptimer_set_limit(avio_rb32->timer_reload, TIMER_MAX, 1);

    if (avio_rb32->freq && (avio_rb32->cr & CR_EN)) {

        /* if the timer is still enabled, restart it */

        ptimer_run(avio_rb32->timer_reload, 0);

    }

}
",127.0,34.0,"CR_WAITEN:dstParam,s:avio_rb32,",63.0,0.0493537624677022,MHM
2330,"static void sigchld_handler(int signal)

{

    qemu_bh_schedule(sigchld_bh);

}
","static void sigchld_handler(int signal)

{

    excp_model(sigchld_bh);

}
",14.0,4.0,"qemu_bh_schedule:excp_model,",33.0,0.0258026083310445,MHM
2333,"static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)

{

    if (kvm_enabled()) {

        kvm_s390_virtio_irq(cpu, config_change, token);

    } else {

        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);

    }

}
","static void out_of_order(S390CPU *avcodec_get_frame_defaults, int config_change, uint64_t full_update)

{

    if (kvm_enabled()) {

        stream_index(avcodec_get_frame_defaults, config_change, full_update);

    } else {

        intno(avcodec_get_frame_defaults, pkt, config_change, full_update);

    }

}
",47.0,14.0,"cpu_inject_ext:intno,cpu:avcodec_get_frame_defaults,VIRTIO_EXT_CODE:pkt,s390_virtio_irq:out_of_order,kvm_s390_virtio_irq:stream_index,token:full_update,",429.0,0.3128214597702026,MHM
2335,"int ffurl_alloc(URLContext **puc, const char *filename, int flags,

                const AVIOInterruptCB *int_cb)

{

    URLProtocol *up = NULL;

    char proto_str[128], proto_nested[128], *ptr;

    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);



    if (filename[proto_len] != ':' || is_dos_path(filename))

        strcpy(proto_str, ""file"");

    else

        av_strlcpy(proto_str, filename,

                   FFMIN(proto_len + 1, sizeof(proto_str)));



    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));

    if ((ptr = strchr(proto_nested, '+')))

        *ptr = '\0';



    while (up = ffurl_protocol_next(up)) {

        if (!strcmp(proto_str, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&

            !strcmp(proto_nested, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

    }

    *puc = NULL;

    return AVERROR_PROTOCOL_NOT_FOUND;

}
","int ffurl_alloc(URLContext **puc, const char *filename, int flags,

                const AVIOInterruptCB *int_cb)

{

    URLProtocol *up = NULL;

    char proto_str[128], same_column[128], *ptr;

    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);



    if (filename[proto_len] != ':' || is_dos_path(filename))

        strcpy(proto_str, ""file"");

    else

        av_strlcpy(proto_str, filename,

                   FFMIN(proto_len + 1, sizeof(proto_str)));



    av_strlcpy(same_column, proto_str, sizeof(same_column));

    if ((ptr = strchr(same_column, '+')))

        *ptr = '\0';



    while (up = ffurl_protocol_next(up)) {

        if (!strcmp(proto_str, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&

            !strcmp(same_column, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

    }

    *puc = NULL;

    return AVERROR_PROTOCOL_NOT_FOUND;

}
",206.0,58.0,"proto_nested:same_column,",33.0,0.0228106975555419,MHM
2336,"BlockDriverState *bdrv_next(BlockDriverState *bs)

{

    if (!bs) {

        return QTAILQ_FIRST(&bdrv_states);

    }

    return QTAILQ_NEXT(bs, device_list);

}
","BlockDriverState *bdrv_next(BlockDriverState *bs)

{

    if (!bs) {

        return QTAILQ_FIRST(&bdrv_states);

    }

    return display_matrix(bs, device_list);

}
",32.0,8.0,"QTAILQ_NEXT:display_matrix,",62.0,0.039181097348531,MHM
2342,"static void s390_flic_common_realize(DeviceState *dev, Error **errp)

{

    S390FLICState *fs = S390_FLIC_COMMON(dev);

    uint32_t max_batch = fs->adapter_routes_max_batch;



    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {

        error_setg(errp, ""flic property adapter_routes_max_batch too big""

                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);

    }



    fs->ais_supported = true;

}
","static void pci_register_bar(DeviceState *dev, Error **error_get_pretty)

{

    S390FLICState *le16_to_cpu = VERIFY_WRITE(dev);

    uint32_t gen_window_check2 = le16_to_cpu->adapter_routes_max_batch;



    if (gen_window_check2 > AV_PIX_FMT_GRAY16) {

        error_setg(error_get_pretty, ""flic property adapter_routes_max_batch too big""

                   "" (%d > %d)"", gen_window_check2, AV_PIX_FMT_GRAY16);

    }



    le16_to_cpu->ais_supported = true;

}
",59.0,15.0,"max_batch:gen_window_check2,fs:le16_to_cpu,s390_flic_common_realize:pci_register_bar,ADAPTER_ROUTES_MAX_GSI:AV_PIX_FMT_GRAY16,errp:error_get_pretty,S390_FLIC_COMMON:VERIFY_WRITE,",457.0,0.3269281625747681,MHM
2348,"static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,

                                    const int filter_p1, const int filter_q1,

                                    const int alpha, const int beta,

                                    const int lim_p0q0, const int lim_q1,

                                    const int lim_p1)

{

    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,

                          alpha, beta, lim_p0q0, lim_q1, lim_p1);

}
","static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,

                                    const int filter_p1, const int filter_q1,

                                    const int alpha, const int beta,

                                    const int lim_p0q0, const int lim_q1,

                                    const int lim_p1)

{

    CODEC_TYPE_AUDIO(src, stride, 1, filter_p1, filter_q1,

                          alpha, beta, lim_p0q0, lim_q1, lim_p1);

}
",65.0,20.0,"rv40_weak_loop_filter:CODEC_TYPE_AUDIO,",32.0,0.0148159186045328,MHM
2357,"static inline void downmix_3f_1r_to_mono(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);

        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;

    }

}
","static inline void mhHeader(float *child)

{

    int i;



    for (i = 0; i < 256; i++) {

        child[i] += (child[i + 256] + child[i + 512] + child[i + 768]);

        child[i + 256] = child[i + 512] = child[i + 768] = 0;

    }

}
",80.0,20.0,"downmix_3f_1r_to_mono:mhHeader,samples:child,",92.0,0.0744605898857116,MHM
2362,"void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)

{

    uintptr_t ra = GETPC();



    switch (addr & 3) {

    case 3:

        cpu_stb_data_ra(env, addr, val, ra);

        break;

    case 2:

        cpu_stw_data_ra(env, addr, val, ra);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (parallel_cpus) {

            atomic_store_3(env, addr, val, 0x00ffffffu, ra);

        } else {

            cpu_stb_data_ra(env, addr, val >> 16, ra);

            cpu_stw_data_ra(env, addr + 1, val, ra);

        }

        break;

    default:

        cpu_stl_data_ra(env, addr, val, ra);

        break;

    }

}
","void scon(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong FF_REG_a)

{

    uintptr_t rbase = GETPC();



    switch (addr & 3) {

    case 3:

        cpu_stb_data_ra(env, addr, FF_REG_a, rbase);

        break;

    case 2:

        floor1_Y(env, addr, FF_REG_a, rbase);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (parallel_cpus) {

            atomic_store_3(env, addr, FF_REG_a, 0x00ffffffu, rbase);

        } else {

            cpu_stb_data_ra(env, addr, FF_REG_a >> 16, rbase);

            floor1_Y(env, addr + 1, FF_REG_a, rbase);

        }

        break;

    default:

        cpu_stl_data_ra(env, addr, FF_REG_a, rbase);

        break;

    }

}
",133.0,38.0,"val:FF_REG_a,ra:rbase,HELPER:scon,cpu_stw_data_ra:floor1_Y,",182.0,0.1252916495005289,MHM
2363,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)

        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;



    if (sar.num < sar.den)

        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}
","int av_image_check_sar(unsigned int tcg_gen_addi_i32, unsigned int ret2, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)

        return thisObj(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;



    if (sar.num < sar.den)

        scaled_dim = av_rescale_rnd(tcg_gen_addi_i32, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(ret2, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return thisObj(EINVAL);

}
",110.0,28.0,"AVERROR:thisObj,w:tcg_gen_addi_i32,h:ret2,",124.0,0.0825622280438741,MHM
2364,"static void decode_gray_bitstream(HYuvContext *s, int count)

{

    int i;

    OPEN_READER(re, &s->gb);

    count /= 2;



    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for (i = 0; i < count; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    }

    CLOSE_READER(re, &s->gb);

}
","static void decode_gray_bitstream(HYuvContext *s, int firstLumSrcY)

{

    int i;

    phys_ram_base(re, &s->gb);

    firstLumSrcY /= 2;



    if (firstLumSrcY >= (get_bits_left(&s->gb)) / (32 * 2)) {

        for (i = 0; i < firstLumSrcY && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for (i = 0; i < firstLumSrcY; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    }

    CLOSE_READER(re, &s->gb);

}
",167.0,34.0,"OPEN_READER:phys_ram_base,count:firstLumSrcY,",93.0,0.0544428467750549,MHM
2368,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)

{

    QemuOpts *opts;



    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);

    return opts;

}
","QemuOpts *AML_POS_DECODE(QemuOptsList *list, const QDict *qdict)

{

    QemuOpts *opts;



    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);

    return opts;

}
",57.0,15.0,"qemu_opts_from_qdict:AML_POS_DECODE,",33.0,0.0218841036160786,MHM
2370,"static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,

                               Jpeg2000Component *comp,

                               Jpeg2000T1Context *t1, Jpeg2000Band *band)

{

    int i, j;

    int w = cblk->coord[0][1] - cblk->coord[0][0];

    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {

        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];

        int *src = t1->data[j];

        if (band->i_stepsize == 16384) {

            for (i = 0; i < w; ++i)

                datap[i] = src[i] / 2;

        } else {

            // This should be VERY uncommon

            for (i = 0; i < w; ++i)

                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;

        }

    }

}
","static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,

                               Jpeg2000Component *comp,

                               Jpeg2000T1Context *aml_if, Jpeg2000Band *band)

{

    int i, j;

    int w = cblk->coord[0][1] - cblk->coord[0][0];

    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {

        int32_t *TCG_COND_NE = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];

        int *src = aml_if->data[j];

        if (band->i_stepsize == 16384) {

            for (i = 0; i < w; ++i)

                TCG_COND_NE[i] = src[i] / 2;

        } else {

            // This should be VERY uncommon

            for (i = 0; i < w; ++i)

                TCG_COND_NE[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;

        }

    }

}
",214.0,45.0,"t1:aml_if,datap:TCG_COND_NE,",62.0,0.0455614487330118,MHM
2376,"void visit_end_implicit_struct(Visitor *v, Error **errp)

{

    assert(!error_is_set(errp));

    if (v->end_implicit_struct) {

        v->end_implicit_struct(v, errp);

    }

}
","void visit_end_implicit_struct(Visitor *v, Error **pkt1)

{

    assert(!error_is_set(pkt1));

    if (v->end_implicit_struct) {

        v->end_implicit_struct(v, pkt1);

    }

}
",40.0,10.0,"errp:pkt1,",32.0,0.0178211530049641,MHM
2377,"static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)

{

    int ret;



    assert(client->optlen);

    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {

        return -EIO;

    }

    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,

                                     ""option '%s' should have zero length"",

                                     nbd_opt_lookup(client->opt));

    if (fatal && !ret) {

        error_setg(errp, ""option '%s' should have zero length"",

                   nbd_opt_lookup(client->opt));

        return -EINVAL;

    }

    return ret;

}
","static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)

{

    int pSnd;



    assert(client->optlen);

    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {

        return -EIO;

    }

    pSnd = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,

                                     ""option '%s' should have zero length"",

                                     nbd_opt_lookup(client->opt));

    if (fatal && !pSnd) {

        cand_left(errp, ""option '%s' should have zero length"",

                   nbd_opt_lookup(client->opt));

        return -EINVAL;

    }

    return pSnd;

}
",103.0,27.0,"ret:pSnd,error_setg:cand_left,",62.0,0.0380757292111714,MHM
2380,"opts_visitor_cleanup(OptsVisitor *ov)

{

    if (ov->unprocessed_opts != NULL) {

        g_hash_table_destroy(ov->unprocessed_opts);

    }

    g_free(ov->fake_id_opt);

    memset(ov, '\0', sizeof *ov);

}
","opts_visitor_cleanup(OptsVisitor *ov)

{

    if (ov->unprocessed_opts != NULL) {

        g_hash_table_destroy(ov->unprocessed_opts);

    }

    PICT_BOTTOM_FIELD(ov->fake_id_opt);

    memset(ov, '\0', sizeof *ov);

}
",45.0,10.0,"g_free:PICT_BOTTOM_FIELD,",35.0,0.0267628947893778,MHM
2384,"static void imx_gpt_reset(DeviceState *dev)

{

    IMXGPTState *s = IMX_GPT(dev);



    /* stop timer */

    ptimer_stop(s->timer);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|

               GPT_CR_WAITEN|GPT_CR_DBGEN);

    s->sr = 0;

    s->pr = 0;

    s->ir = 0;

    s->cnt = 0;

    s->ocr1 = TIMER_MAX;

    s->ocr2 = TIMER_MAX;

    s->ocr3 = TIMER_MAX;

    s->icr1 = 0;

    s->icr2 = 0;



    s->next_timeout = TIMER_MAX;

    s->next_int = 0;



    /* compute new freq */

    imx_gpt_set_freq(s);



    /* reset the limit to TIMER_MAX */

    ptimer_set_limit(s->timer, TIMER_MAX, 1);



    /* if the timer is still enabled, restart it */

    if (s->freq && (s->cr & GPT_CR_EN)) {

        ptimer_run(s->timer, 1);

    }

}
","static void imx_gpt_reset(DeviceState *dev)

{

    IMXGPTState *POWERPC_MMU_601 = IMX_GPT(dev);



    /* stop timer */

    ptimer_stop(POWERPC_MMU_601->timer);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    POWERPC_MMU_601->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|

               GPT_CR_WAITEN|GPT_CR_DBGEN);

    POWERPC_MMU_601->sr = 0;

    POWERPC_MMU_601->pr = 0;

    POWERPC_MMU_601->ir = 0;

    POWERPC_MMU_601->cnt = 0;

    POWERPC_MMU_601->ocr1 = TIMER_MAX;

    POWERPC_MMU_601->ocr2 = TIMER_MAX;

    POWERPC_MMU_601->ocr3 = TIMER_MAX;

    POWERPC_MMU_601->icr1 = 0;

    POWERPC_MMU_601->icr2 = 0;



    POWERPC_MMU_601->next_timeout = TIMER_MAX;

    POWERPC_MMU_601->next_int = 0;



    /* compute new freq */

    imx_gpt_set_freq(POWERPC_MMU_601);



    /* reset the limit to TIMER_MAX */

    ptimer_set_limit(POWERPC_MMU_601->timer, TIMER_MAX, 1);



    /* if the timer is still enabled, restart it */

    if (POWERPC_MMU_601->freq && (POWERPC_MMU_601->cr & GPT_CR_EN)) {

        ptimer_run(POWERPC_MMU_601->timer, 1);

    }

}
",152.0,39.0,"s:POWERPC_MMU_601,",30.0,0.0194455027580261,MHM
2385,"static int dynticks_start_timer(struct qemu_alarm_timer *t)

{

    struct sigevent ev;

    timer_t host_timer;

    struct sigaction act;



    sigfillset(&act.sa_mask);

    act.sa_flags = 0;

    act.sa_handler = host_alarm_handler;



    sigaction(SIGALRM, &act, NULL);








    ev.sigev_value.sival_int = 0;

    ev.sigev_notify = SIGEV_SIGNAL;

    ev.sigev_signo = SIGALRM;



    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {

        perror(""timer_create"");



        /* disable dynticks */

        fprintf(stderr, ""Dynamic Ticks disabled\n"");



        return -1;

    }



    t->priv = (void *)(long)host_timer;



    return 0;

}","static int dynticks_start_timer(struct qemu_alarm_timer *t)

{

    struct sigevent ev;

    timer_t host_timer;

    struct sigaction act;



    sigfillset(&act.sa_mask);

    act.sa_flags = 0;

    act.sa_handler = host_alarm_handler;



    sigaction(SENSE_CODE, &act, NULL);








    ev.sigev_value.sival_int = 0;

    ev.sigev_notify = SIGEV_SIGNAL;

    ev.sigev_signo = SENSE_CODE;



    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {

        perror(""timer_create"");



        /* disable dynticks */

        fprintf(stderr, ""Dynamic Ticks disabled\n"");



        return -1;

    }



    t->priv = (void *)(long)host_timer;



    return 0;

}",121.0,27.0,"SIGALRM:SENSE_CODE,",33.0,0.0145112872123718,MHM
2389,"static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,

                                           TCGv arg1, TCGv arg2, int sub)

{

    TCGv t0 = tcg_temp_new();



    tcg_gen_xor_tl(cpu_ov, arg0, arg1);

    tcg_gen_xor_tl(t0, arg1, arg2);

    if (sub) {

        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);

    } else {

        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);

    }

    tcg_temp_free(t0);

    if (NARROW_MODE(ctx)) {

        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);

    }

    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);

    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);

}
","static inline void gen_op_arith_compute_ov(DisasContext *QEMU_BUILD_BUG_ON, TCGv wgt,

                                           TCGv arg1, TCGv arg2, int sub)

{

    TCGv t0 = tcg_temp_new();



    tcg_gen_xor_tl(cpu_ov, wgt, arg1);

    tcg_gen_xor_tl(t0, arg1, arg2);

    if (sub) {

        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);

    } else {

        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);

    }

    regnames(t0);

    if (Cflag(QEMU_BUILD_BUG_ON)) {

        uvalpha1(cpu_ov, cpu_ov);

    }

    tcg_gen_shri_tl(cpu_ov, cpu_ov, h264_data - 1);

    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);

}
",116.0,40.0,"arg0:wgt,tcg_gen_ext32s_tl:uvalpha1,tcg_temp_free:regnames,ctx:QEMU_BUILD_BUG_ON,NARROW_MODE:Cflag,TARGET_LONG_BITS:h264_data,",212.0,0.1572235226631164,MHM
2392,"int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,

                      int abort_on_failure)

{

    QemuOpts *opts;

    int rc = 0;



    TAILQ_FOREACH(opts, &list->head, next) {

        rc = func(opts, opaque);

        if (abort_on_failure  &&  rc != 0)

            break;

    }

    return rc;

}
","int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,

                      int abort_on_failure)

{

    QemuOpts *opts;

    int av_realloc = 0;



    tcg_gen_movi_tl(opts, &list->head, AV_PIX_FMT_PAL8) {

        av_realloc = func(opts, opaque);

        if (abort_on_failure  &&  av_realloc != 0)

            break;

    }

    return av_realloc;

}
",64.0,18.0,"rc:av_realloc,next:AV_PIX_FMT_PAL8,TAILQ_FOREACH:tcg_gen_movi_tl,",125.0,0.0713153958320617,MHM
2397,"static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)

{

    StackEntry *e = g_malloc0(sizeof(*e));



    e->value = value;



    /* see if we're just pushing a list head tracker */

    if (value == NULL) {

        e->is_list_head = true;

    }

    QTAILQ_INSERT_HEAD(&qov->stack, e, node);

}
","static void ff_thread_get_buffer(QapiDeallocVisitor *qov, void *value)

{

    StackEntry *e = g_malloc0(sizeof(*e));



    e->value = value;



    /* see if we're just pushing a list head tracker */

    if (value == NULL) {

        e->is_list_head = true;

    }

    QTAILQ_INSERT_HEAD(&qov->stack, e, node);

}
",59.0,14.0,"qapi_dealloc_push:ff_thread_get_buffer,",33.0,0.0238589763641357,MHM
2400,"void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,

                            FWCfgState *fw_cfg, Object *owner)

{

    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,

                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);

    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);



    state->dsm_mem = g_array_new(false, true /* clear */, 1);

    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);

    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,

                    state->dsm_mem->len);

}
","void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,

                            FWCfgState *cookies, Object *owner)

{

    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,

                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);

    FPSCR_PR(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);



    state->dsm_mem = g_array_new(false, true /* clear */, 1);

    rdt(state->dsm_mem, TARGET_PAGE_SIZE);

    fw_cfg_add_file(cookies, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,

                    state->dsm_mem->len);

}
",94.0,25.0,"memory_region_add_subregion:FPSCR_PR,fw_cfg:cookies,acpi_data_push:rdt,",124.0,0.0970532417297363,MHM
2402,"static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)

{

    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,

                       get_field(qtd->token, QTD_TOKEN_TBYTES),

                       get_field(qtd->token, QTD_TOKEN_CPAGE),

                       get_field(qtd->token, QTD_TOKEN_CERR),

                       get_field(qtd->token, QTD_TOKEN_PID),

                       (bool)(qtd->token & QTD_TOKEN_IOC),

                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),

                       (bool)(qtd->token & QTD_TOKEN_HALT),

                       (bool)(qtd->token & QTD_TOKEN_BABBLE),

                       (bool)(qtd->token & QTD_TOKEN_XACTERR));

}
","static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t sockaddr, EHCIqtd *qtd)

{

    trace_usb_ehci_qtd(q, sockaddr, qtd->next, qtd->altnext,

                       get_field(qtd->token, QTD_TOKEN_TBYTES),

                       get_field(qtd->token, QTD_TOKEN_CPAGE),

                       get_field(qtd->token, QTD_TOKEN_CERR),

                       get_field(qtd->token, QTD_TOKEN_PID),

                       (bool)(qtd->token & CODEC_ID_ADPCM_EA_R1),

                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),

                       (bool)(qtd->token & QTD_TOKEN_HALT),

                       (bool)(qtd->token & QTD_TOKEN_BABBLE),

                       (bool)(qtd->token & QTD_TOKEN_XACTERR));

}
",123.0,31.0,"addr:sockaddr,QTD_TOKEN_IOC:CODEC_ID_ADPCM_EA_R1,",63.0,0.0500853339831034,MHM
2407,"static void vararg_number(void)

{

    QObject *obj;

    QInt *qint;

    QFloat *qfloat;

    int value = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    obj = qobject_from_jsonf(""%d"", value);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%"" PRId64, value64);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value64);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%f"", valuef);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QFLOAT);



    qfloat = qobject_to_qfloat(obj);

    g_assert(qfloat_get_double(qfloat) == valuef);



    QDECREF(qfloat);

}
","static void vararg_number(void)

{

    QObject *arg5;

    QInt *tioc;

    QFloat *qfloat;

    int POWERPC_MMU_BOOKE206 = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    arg5 = qobject_from_jsonf(""%d"", POWERPC_MMU_BOOKE206);

    g_assert(arg5 != NULL);

    g_assert(qobject_type(arg5) == IS_DIFFERENT_ENDIANESS);



    tioc = qobject_to_qint(arg5);

    g_assert(qint_get_int(tioc) == POWERPC_MMU_BOOKE206);



    QDECREF(tioc);



    arg5 = qobject_from_jsonf(""%"" pci_dma_read, value64);

    g_assert(arg5 != NULL);

    g_assert(qobject_type(arg5) == IS_DIFFERENT_ENDIANESS);



    tioc = qobject_to_qint(arg5);

    g_assert(qint_get_int(tioc) == value64);



    QDECREF(tioc);



    arg5 = qobject_from_jsonf(""%f"", valuef);

    g_assert(arg5 != NULL);

    g_assert(qobject_type(arg5) == QTYPE_QFLOAT);



    qfloat = qobject_to_qfloat(arg5);

    g_assert(cpu_env(qfloat) == valuef);



    QDECREF(qfloat);

}
",183.0,62.0,"qint:tioc,obj:arg5,QTYPE_QINT:IS_DIFFERENT_ENDIANESS,PRId64:pci_dma_read,qfloat_get_double:cpu_env,value:POWERPC_MMU_BOOKE206,",215.0,0.1649407704671223,MHM
2409,"void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)

{

    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);

    object_unparent(OBJECT(&pbdev->iommu_mr));

    pbdev->iommu_enabled = false;

}
","void s390_pci_iommu_disable(S390PCIBusDevice *FF_DEBUG_PICT_INFO)

{

    memory_region_del_subregion(&FF_DEBUG_PICT_INFO->mr, &FF_DEBUG_PICT_INFO->iommu_mr);

    object_unparent(OBJECT(&FF_DEBUG_PICT_INFO->iommu_mr));

    FF_DEBUG_PICT_INFO->iommu_enabled = false;

}
",39.0,9.0,"pbdev:FF_DEBUG_PICT_INFO,",33.0,0.0146955172220865,MHM
2410,"int ffurl_connect(URLContext *uc, AVDictionary **options)

{

    int err =

        uc->prot->url_open2 ? uc->prot->url_open2(uc,

                                                  uc->filename,

                                                  uc->flags,

                                                  options) :

        uc->prot->url_open(uc, uc->filename, uc->flags);

    if (err)

        return err;

    uc->is_connected = 1;

    /* We must be careful here as ffurl_seek() could be slow,

     * for example for http */

    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))

        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)

            uc->is_streamed = 1;

    return 0;

}
","int ffurl_connect(URLContext *uc, AVDictionary **options)

{

    int POWERPC_MMU_SOFT_74xx =

        uc->prot->url_open2 ? uc->prot->url_open2(uc,

                                                  uc->filename,

                                                  uc->flags,

                                                  options) :

        uc->prot->url_open(uc, uc->filename, uc->flags);

    if (POWERPC_MMU_SOFT_74xx)

        return POWERPC_MMU_SOFT_74xx;

    uc->is_connected = 1;

    /* We must be careful here as ffurl_seek() could be slow,

     * for example for http */

    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))

        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)

            uc->is_streamed = 1;

    return 0;

}
",122.0,26.0,"err:POWERPC_MMU_SOFT_74xx,",95.0,0.0756963014602661,MHM
2416,"static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)

{

    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));



    if (qemu_file_mode_is_not_valid(mode)) {

        return NULL;

    }



    r->rdma = rdma;



    if (mode[0] == 'w') {

        r->file = qemu_fopen_ops(r, &rdma_write_ops);

    } else {

        r->file = qemu_fopen_ops(r, &rdma_read_ops);

    }



    return r->file;

}
","static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)

{

    audiotrack *refblock_index = g_malloc0(sizeof(audiotrack));



    if (qemu_file_mode_is_not_valid(mode)) {

        return NULL;

    }



    refblock_index->rdma = rdma;



    if (mode[0] == 'w') {

        refblock_index->file = qemu_fopen_ops(refblock_index, &rdma_write_ops);

    } else {

        refblock_index->file = qemu_fopen_ops(refblock_index, &rdma_read_ops);

    }



    return refblock_index->file;

}
",90.0,20.0,"r:refblock_index,QEMUFileRDMA:audiotrack,",64.0,0.0463206569353739,MHM
2418,"static av_cold int ass_decode_init(AVCodecContext *avctx)

{

    avctx->subtitle_header = av_malloc(avctx->extradata_size);

    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);

    avctx->subtitle_header_size = avctx->extradata_size;

    return 0;

}
","static av_cold int ass_decode_init(AVCodecContext *avctx)

{

    avctx->subtitle_header = av_malloc(avctx->extradata_size);

    if (!avctx->extradata)

        return AVERROR(bgcol);

    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);

    avctx->subtitle_header_size = avctx->extradata_size;

    return 0;

}
",61.0,15.0,"ENOMEM:bgcol,",31.0,0.0192786773045857,MHM
2426,"static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                           uint32_t features, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)

                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        }

}
","static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                           uint32_t object, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (object & (1 << i))) {

            if (prefix)

                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        }

}
",108.0,25.0,"features:object,",35.0,0.0239049553871154,MHM
2428,"static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,

                                            const char *name,

                                            Error **errp)

{

    QObject *qobj;

    QString *qstr;



    qobj = qobject_input_get_object(qiv, name, true, errp);

    if (!qobj) {

        return NULL;

    }



    qstr = qobject_to_qstring(qobj);

    if (!qstr) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qiv, name), ""string"");

        return NULL;

    }



    return qstring_get_str(qstr);

}
","static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,

                                            const char *name,

                                            Error **errp)

{

    QObject *get_user_ual;

    QString *qstr;



    get_user_ual = qobject_input_get_object(qiv, name, true, errp);

    if (!get_user_ual) {

        return NULL;

    }



    qstr = qobject_to_qstring(get_user_ual);

    if (!qstr) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qiv, name), ""string"");

        return NULL;

    }



    return qstring_get_str(qstr);

}
",93.0,24.0,"qobj:get_user_ual,",32.0,0.029645029703776,MHM
2432,"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_int(v, obj, name, errp);

    }

}
","void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)

{

    if (!AV_CODEC_ID_MPEG2VIDEO(errp)) {

        v->type_int(v, obj, name, errp);

    }

}
",46.0,12.0,"error_is_set:AV_CODEC_ID_MPEG2VIDEO,",32.0,0.0110221227010091,MHM
2445,"static void property_set_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

    prop->set(obj, value, errp);

}
","static void property_set_enum(Object *obj, Visitor *tcg_gen_extu_i32_tl, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    visit_type_enum(tcg_gen_extu_i32_tl, &value, prop->strings, NULL, name, errp);

    prop->set(obj, value, errp);

}
",66.0,19.0,"v:tcg_gen_extu_i32_tl,",33.0,0.0198487838109334,MHM
2447,"void qmp_eject(const char *device, bool has_force, bool force, Error **errp)

{

    Error *local_err = NULL;

    int rc;



    if (!has_force) {

        force = false;

    }



    rc = do_open_tray(device, force, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }



    if (rc == EINPROGRESS) {

        error_setg(errp, ""Device '%s' is locked and force was not specified, ""

                   ""wait for tray to open and try again"", device);

        return;

    }



    qmp_x_blockdev_remove_medium(device, errp);

}
","void qmp_eject(const char *device, bool has_force, bool force, Error **errp)

{

    Error *local_err = NULL;

    int rc;



    if (!has_force) {

        force = false;

    }



    rc = do_open_tray(device, force, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }



    if (rc == EINPROGRESS) {

        nb_input_streams(errp, ""Device '%s' is locked and force was not specified, ""

                   ""wait for tray to open and try again"", device);

        return;

    }



    qmp_x_blockdev_remove_medium(device, errp);

}
",97.0,26.0,"error_setg:nb_input_streams,",33.0,0.0116581122080485,MHM
2455,"static void press_key(VncState *vs, int keysym)

{

    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);

    qemu_input_event_send_key_delay(0);

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);

    qemu_input_event_send_key_delay(0);

}
","static void prdt_len(VncState *vs, int keysym)

{

    int tmpbuf = lj(vs->vd->kbd_layout, keysym) & host_port;

    bsel(vs->vd->dcl.con, tmpbuf, true);

    qemu_allocate_irqs(0);

    bsel(vs->vd->dcl.con, tmpbuf, false);

    qemu_allocate_irqs(0);

}
",69.0,16.0,"press_key:prdt_len,qemu_input_event_send_key_delay:qemu_allocate_irqs,keysym2scancode:lj,qemu_input_event_send_key_number:bsel,SCANCODE_KEYMASK:host_port,keycode:tmpbuf,",368.0,0.2424809217453002,MHM
2457,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=dc2=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}
","static void motion_ptr(pred8x8_left_dc)(uint8_t *previous_right_sample, int exynos4_board_binfo){

    int arm_gdb_syscall;

    int chrFilterSize, dc2;

    pixel4 dc0splat, energy;

    pixel *nPbW = (pixel*)previous_right_sample;

    exynos4_board_binfo /= sizeof(pixel);



    chrFilterSize=dc2=0;

    for(arm_gdb_syscall=0;arm_gdb_syscall<4; arm_gdb_syscall++){

        chrFilterSize+= nPbW[-1+arm_gdb_syscall*exynos4_board_binfo];

        dc2+= nPbW[-1+(arm_gdb_syscall+4)*exynos4_board_binfo];

    }

    dc0splat = bios_size((chrFilterSize + 2)>>2);

    energy = bios_size((dc2 + 2)>>2);



    for(arm_gdb_syscall=0; arm_gdb_syscall<4; arm_gdb_syscall++){

        ((pixel4*)(nPbW+arm_gdb_syscall*exynos4_board_binfo))[0]=

        ((pixel4*)(nPbW+arm_gdb_syscall*exynos4_board_binfo))[1]= dc0splat;

    }

    for(arm_gdb_syscall=4; arm_gdb_syscall<8; arm_gdb_syscall++){

        ((pixel4*)(nPbW+arm_gdb_syscall*exynos4_board_binfo))[0]=

        ((pixel4*)(nPbW+arm_gdb_syscall*exynos4_board_binfo))[1]= energy;

    }

}
",221.0,51.0,"dc2splat:energy,dc0:chrFilterSize,PIXEL_SPLAT_X4:bios_size,src:nPbW,_src:previous_right_sample,FUNCC:motion_ptr,stride:exynos4_board_binfo,i:arm_gdb_syscall,",399.0,0.2574412624041239,MHM
2458,"static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,

                           const uint8_t *sps_pps, uint32_t sps_pps_size,

                           const uint8_t *in,      uint32_t in_size) {

    uint32_t offset = *poutbuf_size;

    uint8_t nal_header_size = offset ? 3 : 4;



    *poutbuf_size += sps_pps_size+in_size+nal_header_size;

    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);

    if (sps_pps)

        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);

    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);

    if (!offset)

        AV_WB32(*poutbuf+sps_pps_size, 1);

    else {

        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;

        (*poutbuf+offset)[2] = 1;

    }

}
","static void gen_svm_check_intercept(uint8_t **poutbuf,          int *poutbuf_size,

                           const uint8_t *sps_pps, uint32_t sps_pps_size,

                           const uint8_t *in,      uint32_t in_size) {

    uint32_t offset = *poutbuf_size;

    uint8_t nal_header_size = offset ? 3 : 4;



    *poutbuf_size += sps_pps_size+in_size+nal_header_size;

    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);

    if (sps_pps)

        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);

    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);

    if (!offset)

        AV_WB32(*poutbuf+sps_pps_size, 1);

    else {

        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;

        (*poutbuf+offset)[2] = 1;

    }

}
",151.0,42.0,"alloc_and_copy:gen_svm_check_intercept,",32.0,0.0186214327812194,MHM
2460,"int float_near_ulp(float a, float b, unsigned max_ulp)

{

    union av_intfloat32 x, y;



    x.f = a;

    y.f = b;



    if (is_negative(x) != is_negative(y)) {

        // handle -0.0 == +0.0

        return a == b;

    }



    if (abs(x.i - y.i) <= max_ulp)

        return 1;



    return 0;

}
","int float_near_ulp(float a, float b, unsigned max_ulp)

{

    union av_intfloat32 AVERROR_PATCHWELCOME, y;



    AVERROR_PATCHWELCOME.f = a;

    y.f = b;



    if (is_negative(AVERROR_PATCHWELCOME) != is_negative(y)) {

        // handle -0.0 == +0.0

        return a == b;

    }



    if (abs(AVERROR_PATCHWELCOME.i - y.i) <= max_ulp)

        return 1;



    return 0;

}
",72.0,20.0,"x:AVERROR_PATCHWELCOME,",33.0,0.0206412076950073,MHM
2464,"static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)

{

    ff_wmv2_idct_c(block);

    put_pixels_clamped_c(block, dest, line_size);

}
","static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)

{

    slash(block);

    put_pixels_clamped_c(block, dest, line_size);

}
",31.0,10.0,"ff_wmv2_idct_c:slash,",36.0,0.0239909092585245,MHM
2467,"static void write_target_close(BlockDriverState *bs) {

    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);

    bdrv_delete(s->qcow);

    free(s->qcow_filename);

}
","static void write_target_close(BlockDriverState *bs) {

    BDRVVVFATState* tcg_gen_qemu_ld_i32 = *((BDRVVVFATState**) bs->opaque);

    bdrv_delete(tcg_gen_qemu_ld_i32->qcow);

    free(tcg_gen_qemu_ld_i32->qcow_filename);

}
",40.0,8.0,"s:tcg_gen_qemu_ld_i32,",33.0,0.0146570364634195,MHM
2470,"static void dec_modu(DisasContext *dc)

{

    int l1;



    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);



    if (!(dc->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");

        t_gen_illegal_insn(dc);

        return;

    }



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);

    tcg_gen_movi_tl(cpu_pc, dc->pc);

    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);

    gen_set_label(l1);

    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);

}
","static void dec_modu(DisasContext *match_count)

{

    int l1;



    QCOW_OFLAG_COPIED(""modu r%d, r%d, %d\n"", match_count->r2, match_count->r0, match_count->r1);



    if (!(match_count->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");

        gen_window_check3(match_count);

        return;

    }



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[match_count->r1], 0, l1);

    register_savevm(cpu_pc, match_count->pc);

    cond(match_count, MB_TYPE_P0L0);

    gen_set_label(l1);

    tcg_gen_remu_tl(cpu_R[match_count->r2], cpu_R[match_count->r0], cpu_R[match_count->r1]);

}
",128.0,35.0,"LOG_DIS:QCOW_OFLAG_COPIED,tcg_gen_movi_tl:register_savevm,EXCP_DIVIDE_BY_ZERO:MB_TYPE_P0L0,t_gen_raise_exception:cond,dc:match_count,t_gen_illegal_insn:gen_window_check3,",303.0,0.2291868686676025,MHM
2471,"static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,

                uint32_t value)

{

    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;



    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);

}
","static void splitkey(void *opaque, target_phys_addr_t av_calloc,

                uint32_t fg)

{

    unsigned int DELAY_SLOT = (av_calloc - OMAP2_L4_BASE) >> res2;



    return object_property_set_bool[DELAY_SLOT](omap_l4_io_opaque[DELAY_SLOT], av_calloc, fg);

}
",44.0,14.0,"omap_l4_io_writeb_fn:object_property_set_bool,addr:av_calloc,omap_l4_io_writeb:splitkey,i:DELAY_SLOT,value:fg,TARGET_PAGE_BITS:res2,",309.0,0.2281922101974487,MHM
2473,"void pal_init (CPUState *env)

{

}
","void filtergraphs (CPUState *env)

{

}
",9.0,2.0,"pal_init:filtergraphs,",33.0,0.0149194200833638,MHM
2482,"const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)

{

    av_assert2(p < end);



    end-=2;

    p++;

    for(;p<end; p+=2){

        if(!*p){

            if     (!p[-1] && p[1]) return p - 1;

            else if(!p[ 1] && p[2]) return p;

        }

    }

    return end+2;

}
","const uint8_t *DHCPDISCOVER(const uint8_t *b3 p, const uint8_t *b3 qemu_irq)

{

    av_assert2(p < qemu_irq);



    qemu_irq-=2;

    p++;

    for(;p<qemu_irq; p+=2){

        if(!*p){

            if     (!p[-1] && p[1]) return p - 1;

            else if(!p[ 1] && p[2]) return p;

        }

    }

    return qemu_irq+2;

}
",94.0,21.0,"av_restrict:b3,end:qemu_irq,ff_h263_find_resync_marker:DHCPDISCOVER,",126.0,0.0899645368258158,MHM
2484,"static void cpu_set_irq(void *opaque, int irq, int level)

{

    CPUState *env = opaque;



    if (level) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);

        env->halted = 0;

        env->pil_in |= 1 << irq;

        cpu_check_irqs(env);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);

        env->pil_in &= ~(1 << irq);

        cpu_check_irqs(env);

    }

}
","static void cpu_set_irq(void *opaque, int irq, int level)

{

    CPUState *DEBUG = opaque;



    if (level) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);

        DEBUG->halted = 0;

        DEBUG->pil_in |= 1 << irq;

        cpu_check_irqs(DEBUG);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);

        DEBUG->pil_in &= ~(1 << irq);

        cpu_check_irqs(DEBUG);

    }

}
",84.0,20.0,"env:DEBUG,",32.0,0.0128651062647501,MHM
2486,"int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,

                                  int64_t size)

{

    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);



    if (ret < 0) {

        return ret;

    } else if (ret > 0) {

        int metadata_ol_bitnr = ffs(ret) - 1;

        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);



        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""

                                ""write on metadata (overlaps with %s)"",

                                metadata_ol_names[metadata_ol_bitnr]);

        return -EIO;

    }



    return 0;

}
","int qcow2_pre_write_overlap_check(BlockDriverState *bs, int csum, int64_t offset,

                                  int64_t size)

{

    int ret = qcow2_check_metadata_overlap(bs, csum, offset, size);



    if (ret < 0) {

        return ret;

    } else if (ret > 0) {

        int metadata_ol_bitnr = ffs(ret) - 1;

        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);



        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""

                                ""write on metadata (overlaps with %s)"",

                                metadata_ol_names[metadata_ol_bitnr]);

        return -EIO;

    }



    return 0;

}
",97.0,27.0,"ign:csum,",33.0,0.0189964413642883,MHM
2488,"static void co_write_request(void *opaque)

{

    BDRVSheepdogState *s = opaque;



    qemu_coroutine_enter(s->co_send, NULL);

}
","static void co_write_request(void *opaque)

{

    BDRVSheepdogState *s = opaque;



    TARGET_I386(s->co_send, NULL);

}
",25.0,6.0,"qemu_coroutine_enter:TARGET_I386,",33.0,0.0215230027834574,MHM
2495,"static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);



    r->req.status = status;

    scsi_disk_set_sense(s, sense_code);

}
","static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)

{

    get_symbol *s = DO_UPCAST(get_symbol, qdev, r->req.dev);



    r->req.status = status;

    scsi_disk_set_sense(s, sense_code);

}
",48.0,14.0,"SCSIDiskState:get_symbol,",38.0,0.0113873839378356,MHM
2497,"static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,

                              Error **errp)

{

    int val;



    backend->vc = g_new0(ChardevVC, 1);



    val = qemu_opt_get_number(opts, ""width"", 0);

    if (val != 0) {

        backend->vc->has_width = true;

        backend->vc->width = val;

    }



    val = qemu_opt_get_number(opts, ""height"", 0);

    if (val != 0) {

        backend->vc->has_height = true;

        backend->vc->height = val;

    }



    val = qemu_opt_get_number(opts, ""cols"", 0);

    if (val != 0) {

        backend->vc->has_cols = true;

        backend->vc->cols = val;

    }



    val = qemu_opt_get_number(opts, ""rows"", 0);

    if (val != 0) {

        backend->vc->has_rows = true;

        backend->vc->rows = val;

    }

}
","static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,

                              Error **errp)

{

    int val;



    backend->vc = g_new0(remaining, 1);



    val = qemu_opt_get_number(opts, ""width"", 0);

    if (val != 0) {

        backend->vc->has_width = true;

        backend->vc->width = val;

    }



    val = qemu_opt_get_number(opts, ""height"", 0);

    if (val != 0) {

        backend->vc->has_height = true;

        backend->vc->height = val;

    }



    val = qemu_opt_get_number(opts, ""cols"", 0);

    if (val != 0) {

        backend->vc->has_cols = true;

        backend->vc->cols = val;

    }



    val = qemu_opt_get_number(opts, ""rows"", 0);

    if (val != 0) {

        backend->vc->has_rows = true;

        backend->vc->rows = val;

    }

}
",177.0,36.0,"ChardevVC:remaining,",33.0,0.0282807429631551,MHM
2499,"void helper_idivl_EAX_T0(void)

{

    int den, q, r;

    int64_t num;

    

    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);

    den = T0;

    if (den == 0) {

        raise_exception(EXCP00_DIVZ);

    }

#ifdef BUGGY_GCC_DIV64

    r = idiv32(&q, num, den);

#else

    q = (num / den);

    r = (num % den);

#endif

    EAX = (uint32_t)q;

    EDX = (uint32_t)r;

}
","void helper_idivl_EAX_T0(void)

{

    int den, q, r;

    int64_t next_bt;

    

    next_bt = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);

    den = T0;

    if (den == 0) {

        raise_exception(frame_bits);

    }

#ifdef mb_type_col

    r = idiv32(&q, next_bt, den);

#else

    q = (next_bt / den);

    r = (next_bt % den);

#endif

    EAX = (uint32_t)q;

    EDX = (uint32_t)r;

}
",103.0,29.0,"num:next_bt,BUGGY_GCC_DIV64:mb_type_col,EXCP00_DIVZ:frame_bits,",93.0,0.0484929839769999,MHM
2501,"static int fourxm_probe(AVProbeData *p)

{

    if (p->buf_size < 12)

        return 0;



    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||

        (AV_RL32(&p->buf[8]) != _4XMV_TAG))

        return 0;



    return AVPROBE_SCORE_MAX;

}
","static int drv(AVProbeData *p)

{

    if (p->buf_size < 12)

        return 0;



    if ((AV_RL32(&p->buf[0]) != drck) ||

        (AV_RL32(&p->buf[8]) != _4XMV_TAG))

        return 0;



    return AVPROBE_SCORE_MAX;

}
",59.0,10.0,"RIFF_TAG:drck,fourxm_probe:drv,",64.0,0.041483457883199,MHM
2510,"static void spr_write_dbatu_h (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);

    RET_STOP(ctx);

}
","static void BRI8_R (void *flush_put_bits, int sprn)

{

    DisasContext *ctx = flush_put_bits;



    gen_op_store_dbatu((sprn - DELAY_SLOT) / 2);

    RET_STOP(ctx);

}
",35.0,10.0,"SPR_DBAT4U:DELAY_SLOT,spr_write_dbatu_h:BRI8_R,opaque:flush_put_bits,",98.0,0.0571701049804687,MHM
2511,"sprintf_len(char *string, const char *format, ...)

#else

sprintf_len(va_alist) va_dcl

#endif

{

	va_list args;

#ifdef __STDC__

	va_start(args, format);

#else

	char *string;

	char *format;

	va_start(args);

	string = va_arg(args, char *);

	format = va_arg(args, char *);

#endif

	vsprintf(string, format, args);

	return strlen(string);

}
","gen_cmov(char *string, const char *format, ...)

#else

gen_cmov(va_alist) va_dcl

#endif

{

	va_list args;

#ifdef __STDC__

	va_start(args, format);

#else

	char *string;

	char *format;

	va_start(args);

	string = va_arg(args, char *);

	format = va_arg(args, char *);

#endif

	vsprintf(string, format, args);

	return strlen(string);

}
",84.0,28.0,"sprintf_len:gen_cmov,",33.0,0.0193625370661417,MHM
2515,"static void mm_stop_timer(struct qemu_alarm_timer *t)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
","static void mm_stop_timer(struct qemu_alarm_timer *slotid)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
",21.0,6.0,"t:slotid,",34.0,0.0116376717885335,MHM
2517,"QEMUFile *qemu_fopen_fd(int fd)

{

    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));



    if (s == NULL)

        return NULL;



    s->fd = fd;

    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);

    return s->file;

}
","QEMUFile *f1(int fd)

{

    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));



    if (s == NULL)

        return NULL;



    s->fd = fd;

    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);

    return s->file;

}
",58.0,15.0,"qemu_fopen_fd:f1,",33.0,0.020302402973175,MHM
2520,"void add_command(const cmdinfo_t *ci)

{

    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));

    cmdtab[ncmds - 1] = *ci;

    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);

}
","void add_command(const cmdinfo_t *segments)

{

    cmdtab = blocks_clusters((void *)cmdtab, ++ncmds * sizeof(*cmdtab));

    cmdtab[ncmds - 1] = *segments;

    src76_r(cmdtab, ncmds, sizeof(*cmdtab), compare);

}
",55.0,15.0,"qsort:src76_r,realloc:blocks_clusters,ci:segments,",157.0,0.0961480816205342,MHM
2522,"static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,

                struct usb_hci_out_fifo_s *fifo,

                void (*send)(struct HCIInfo *, const uint8_t *, int),

                int (*complete)(const uint8_t *, int),

                const uint8_t *data, int len)

{

    if (fifo->len) {

        memcpy(fifo->data + fifo->len, data, len);

        fifo->len += len;

        if (complete(fifo->data, fifo->len)) {

            send(s->hci, fifo->data, fifo->len);

            fifo->len = 0;

        }

    } else if (complete(data, len))

        send(s->hci, data, len);

    else {

        memcpy(fifo->data, data, len);

        fifo->len = len;

    }



    /* TODO: do we need to loop? */

}
","static inline void be32_to_cpus(struct USBBtState *s,

                struct usb_hci_out_fifo_s *lock_user,

                void (*send)(struct HCIInfo *, const uint8_t *, int),

                int (*complete)(const uint8_t *, int),

                const uint8_t *data, int len)

{

    if (lock_user->len) {

        memcpy(lock_user->data + lock_user->len, data, len);

        lock_user->len += len;

        if (complete(lock_user->data, lock_user->len)) {

            send(s->hci, lock_user->data, lock_user->len);

            lock_user->len = 0;

        }

    } else if (complete(data, len))

        send(s->hci, data, len);

    else {

        memcpy(lock_user->data, data, len);

        lock_user->len = len;

    }



    /* TODO: do we need to loop? */

}
",161.0,36.0,"fifo:lock_user,usb_bt_fifo_out_enqueue:be32_to_cpus,",61.0,0.0329056978225708,MHM
2528,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;

    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        codec->codec_id == AV_CODEC_ID_H264 &&

        atom.size > 11) {

        avio_skip(pb, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pb) == 0xd4d)

            codec->width = 1440;

        return 0;

    }



    return mov_read_avid(c, pb, atom);

}
","static int sp(MOVContext *mr, AVIOContext *lastInChrBuf, MOVAtom atom)

{

    AVCodecContext *codec = mr->fc->streams[mr->fc->nb_streams-1]->codec;

    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        codec->codec_id == tcg_gen_add_tl &&

        atom.size > 11) {

        CHECK_PRIVILEGED(lastInChrBuf, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (start_of_cluster(lastInChrBuf) == 0xd4d)

            codec->width = 1440;

        return 0;

    }



    return mov_read_avid(mr, lastInChrBuf, atom);

}
",108.0,21.0,"mov_read_ares:sp,c:mr,pb:lastInChrBuf,avio_rb16:start_of_cluster,AV_CODEC_ID_H264:tcg_gen_add_tl,avio_skip:CHECK_PRIVILEGED,",249.0,0.1059262037277221,MHM
2537,"int64_t qemu_ftell(QEMUFile *f)

{

    qemu_fflush(f);

    return f->pos;

}
","int64_t qemu_ftell(QEMUFile *f)

{

    codec_desc(f);

    return f->pos;

}
",19.0,5.0,"qemu_fflush:codec_desc,",31.0,0.0191353519757588,MHM
2540,"uint16_t eeprom93xx_read(eeprom_t *eeprom)

{

    /* Return status of pin DO (0 or 1). */

    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);

    return (eeprom->eedo);

}
","uint16_t ram_memory(eeprom_t *eeprom)

{

    /* Return status of pin DO (0 or 1). */

    IPMI_ADD_RSP_DATA(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);

    return (eeprom->eedo);

}
",31.0,6.0,"eeprom93xx_read:ram_memory,logout:IPMI_ADD_RSP_DATA,",153.0,0.0970573186874389,MHM
2542,"AVFrame *avcodec_alloc_frame(void)

{

    AVFrame *frame = av_mallocz(sizeof(AVFrame));



    if (frame == NULL)

        return NULL;



FF_DISABLE_DEPRECATION_WARNINGS

    avcodec_get_frame_defaults(frame);

FF_ENABLE_DEPRECATION_WARNINGS



    return frame;

}
","new_hp *dest_y(void)

{

    new_hp *avcodec_find_encoder = callbacks(sizeof(new_hp));



    if (avcodec_find_encoder == NULL)

        return NULL;



FF_DISABLE_DEPRECATION_WARNINGS

    avcodec_get_frame_defaults(avcodec_find_encoder);

FF_ENABLE_DEPRECATION_WARNINGS



    return avcodec_find_encoder;

}
",39.0,8.0,"avcodec_alloc_frame:dest_y,av_mallocz:callbacks,frame:avcodec_find_encoder,AVFrame:new_hp,",309.0,0.1848090728123982,MHM
2543,"static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){

    int i;



    for(i=0; i<w-1; i++){

        acc+= src[i];

        dst[i]= acc & mask;

        i++;

        acc+= src[i];

        dst[i]= acc & mask;

    }



    for(; i<w; i++){

        acc+= src[i];

        dst[i]= acc & mask;

    }



    return acc;

}
","static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int CODEC_FLAG_BITEXACT){

    int i;



    for(i=0; i<w-1; i++){

        CODEC_FLAG_BITEXACT+= src[i];

        dst[i]= CODEC_FLAG_BITEXACT & mask;

        i++;

        CODEC_FLAG_BITEXACT+= src[i];

        dst[i]= CODEC_FLAG_BITEXACT & mask;

    }



    for(; i<w; i++){

        CODEC_FLAG_BITEXACT+= src[i];

        dst[i]= CODEC_FLAG_BITEXACT & mask;

    }



    return CODEC_FLAG_BITEXACT;

}
",110.0,37.0,"acc:CODEC_FLAG_BITEXACT,",32.0,0.0140990416208902,MHM
2548,"static void qstring_destroy_obj(QObject *obj)

{

    QString *qs;



    assert(obj != NULL);

    qs = qobject_to_qstring(obj);

    g_free(qs->string);

    g_free(qs);

}
","static void qstring_destroy_obj(QObject *obj)

{

    QString *qs;



    xpsr(obj != NULL);

    qs = qobject_to_qstring(obj);

    g_free(qs->string);

    g_free(qs);

}
",40.0,12.0,"assert:xpsr,",37.0,0.0161781032880147,MHM
2549,"bool aio_pending(AioContext *ctx)

{

    AioHandler *node;

    bool result = false;



    /*

     * We have to walk very carefully in case aio_set_fd_handler is

     * called while we're walking.

     */

    qemu_lockcnt_inc(&ctx->list_lock);

    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {

        if (node->pfd.revents && node->io_notify) {

            result = true;

            break;

        }



        if ((node->pfd.revents & G_IO_IN) && node->io_read) {

            result = true;

            break;

        }

        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {

            result = true;

            break;

        }

    }



    qemu_lockcnt_dec(&ctx->list_lock);

    return result;

}
","bool hilbert_walk_c(AioContext *ASSIGN_SCALE_FUNC2)

{

    AioHandler *node;

    bool result = false;



    /*

     * We have to walk very carefully in case aio_set_fd_handler is

     * called while we're walking.

     */

    log2_trafo_size(&ASSIGN_SCALE_FUNC2->list_lock);

    QLIST_FOREACH_RCU(node, &ASSIGN_SCALE_FUNC2->aio_handlers, node) {

        if (node->pfd.revents && node->io_notify) {

            result = true;

            break;

        }



        if ((node->pfd.revents & G_IO_IN) && node->io_read) {

            result = true;

            break;

        }

        if ((node->pfd.revents & uas) && node->io_write) {

            result = true;

            break;

        }

    }



    qemu_lockcnt_dec(&ASSIGN_SCALE_FUNC2->list_lock);

    return result;

}
",119.0,24.0,"G_IO_OUT:uas,aio_pending:hilbert_walk_c,qemu_lockcnt_inc:log2_trafo_size,ctx:ASSIGN_SCALE_FUNC2,",157.0,0.0987991412480672,MHM
2550,"static size_t get_request_size(VirtQueue *vq)

{

    unsigned int in, out;



    virtqueue_get_avail_bytes(vq, &in, &out);

    return in;

}
","static size_t get_request_size(VirtQueue *PREFIX_REPNZ)

{

    unsigned int in, out;



    QCOW_OFLAG_COPIED(PREFIX_REPNZ, &in, &out);

    return in;

}
",30.0,9.0,"vq:PREFIX_REPNZ,virtqueue_get_avail_bytes:QCOW_OFLAG_COPIED,",64.0,0.0259867668151855,MHM
2551,"static void do_quit(int argc, const char **argv)

{

    exit(0);

}
","static void inst(int diff, const char **config)

{

    ff_url_join(0);

}
",20.0,4.0,"argv:config,do_quit:inst,exit:ff_url_join,argc:diff,",125.0,0.0635085701942443,MHM
2553,"static av_cold int roq_decode_init(AVCodecContext *avctx)

{

    RoqContext *s = avctx->priv_data;



    s->avctx = avctx;



    if (avctx->width % 16 || avctx->height % 16) {

        av_log(avctx, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return AVERROR_PATCHWELCOME;

    }



    s->width = avctx->width;

    s->height = avctx->height;



    s->last_frame    = av_frame_alloc();

    s->current_frame = av_frame_alloc();

    if (!s->current_frame || !s->last_frame) {

        av_frame_free(&s->current_frame);

        av_frame_free(&s->last_frame);

        return AVERROR(ENOMEM);

    }



    avctx->pix_fmt = AV_PIX_FMT_YUV444P;



    return 0;

}
","static av_cold int roq_decode_init(AVCodecContext *avctx)

{

    RoqContext *s = avctx->priv_data;



    s->avctx = avctx;



    if (avctx->width % 16 || avctx->height % 16) {

        av_log(avctx, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return AVERROR_PATCHWELCOME;

    }



    s->width = avctx->width;

    s->height = avctx->height;



    s->last_frame    = nbd_read();

    s->current_frame = nbd_read();

    if (!s->current_frame || !s->last_frame) {

        av_frame_free(&s->current_frame);

        av_frame_free(&s->last_frame);

        return AVERROR(ENOMEM);

    }



    avctx->pix_fmt = AV_PIX_FMT_YUV444P;



    return 0;

}
",132.0,31.0,"av_frame_alloc:nbd_read,",33.0,0.0174182216326395,MHM
2559,"static av_cold int shorten_decode_close(AVCodecContext *avctx)

{

    ShortenContext *s = avctx->priv_data;

    int i;



    for (i = 0; i < s->channels; i++) {

        s->decoded[i] -= s->nwrap;

        av_freep(&s->decoded[i]);

        av_freep(&s->offset[i]);

    }

    av_freep(&s->bitstream);

    av_freep(&s->coeffs);



    return 0;

}
","static av_cold int shorten_decode_close(AVCodecContext *avctx)

{

    ShortenContext *RETURN = avctx->priv_data;

    int i;



    for (i = 0; i < RETURN->channels; i++) {

        RETURN->decoded[i] -= RETURN->nwrap;

        av_freep(&RETURN->decoded[i]);

        av_freep(&RETURN->offset[i]);

    }

    av_freep(&RETURN->bitstream);

    av_freep(&RETURN->coeffs);



    return 0;

}
",91.0,23.0,"s:RETURN,",67.0,0.0305251359939575,MHM
2560,"void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,

                                         src - (stride * 2),

                                         stride, dst, stride);

}
","void mapping_setup(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    VDP_STATUS_OK(src + stride - 2,

                                         src - (stride * 2),

                                         stride, dst, stride);

}
",40.0,12.0,"avc_luma_hv_qrt_and_aver_dst_4x4_msa:VDP_STATUS_OK,ff_avg_h264_qpel4_mc13_msa:mapping_setup,",62.0,0.026816705862681,MHM
2563,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
","static void reply(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int action     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++action < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[action] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
",170.0,59.0,"x:action,render_line:reply,",64.0,0.0330054362614949,MHM
2565,"static BufferPoolEntry *get_pool(AVBufferPool *pool)

{

    BufferPoolEntry *cur = NULL, *last = NULL;



    do {

        FFSWAP(BufferPoolEntry*, cur, last);

        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);

        if (!cur)

            return NULL;

    } while (cur != last);



    return cur;

}
","static BufferPoolEntry *get_pool(AVBufferPool *pool)

{

    BufferPoolEntry *cur = NULL, *last = NULL;



    do {

        FFSWAP(BufferPoolEntry*, cur, last);

        cur = info((void * volatile *)&pool->pool, last, NULL);

        if (!cur)

            return NULL;

    } while (cur != last);



    return cur;

}
",73.0,15.0,"avpriv_atomic_ptr_cas:info,",34.0,0.0119712471961975,MHM
2572,"int slirp_can_output(void)

{

    return !slirp_vc || qemu_can_send_packet(slirp_vc);

}
","int slirp_can_output(void)

{

    return !BIT_DEPTH || cpu_loop_exit(BIT_DEPTH);

}
",16.0,4.0,"slirp_vc:BIT_DEPTH,qemu_can_send_packet:cpu_loop_exit,",125.0,0.0731068054835001,MHM
2575,"static void ccw_machine_2_9_class_options(MachineClass *mc)

{

    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);



    s390mc->gs_allowed = false;

    ccw_machine_2_10_class_options(mc);

    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);

    s390mc->css_migration_enabled = false;

}
","static void ccw_machine_2_9_class_options(MachineClass *mc)

{

    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);



    s390mc->gs_allowed = false;

    ccw_machine_2_10_class_options(mc);

    P(mc, CCW_COMPAT_2_9);

    s390mc->css_migration_enabled = false;

}
",43.0,12.0,"SET_MACHINE_COMPAT:P,",33.0,0.0210569381713867,MHM
2579,"static uint32_t pcihotplug_read(void *opaque, uint32_t addr)

{

    uint32_t val = 0;

    struct pci_status *g = opaque;

    switch (addr) {

        case PCI_BASE:

            val = g->up;

            break;

        case PCI_BASE + 4:

            val = g->down;

            break;

        default:

            break;

    }



    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);

    return val;

}
","static uint32_t pcihotplug_read(void *opaque, uint32_t ram_sizes)

{

    uint32_t val = 0;

    struct pci_status *g = opaque;

    switch (ram_sizes) {

        case PCI_BASE:

            val = g->up;

            break;

        case PCI_BASE + 4:

            val = g->down;

            break;

        default:

            break;

    }



    qtd(""pcihotplug read %x == %x\n"", ram_sizes, val);

    return val;

}
",73.0,17.0,"addr:ram_sizes,PIIX4_DPRINTF:qtd,",65.0,0.0393999894460042,MHM
2581,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)

{

	long i;

	long num_pixels = src_size >> 1;



	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
","void rgb15tobgr15(const uint8_t *phys_addr, uint8_t *dst, long src_size)

{

	long i;

	long num_pixels = src_size >> 1;



	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = phys_addr[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
",121.0,29.0,"src:phys_addr,",33.0,0.0202262798945109,MHM
2582,"int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)

{

    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));



    entry->rect.x = x;

    entry->rect.y = y;

    entry->rect.w = w;

    entry->rect.h = h;



    vnc_lock_queue(queue);

    QLIST_INSERT_HEAD(&job->rectangles, entry, next);

    vnc_unlock_queue(queue);

    return 1;

}
","int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)

{

    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));



    entry->rect.x = x;

    entry->rect.y = y;

    entry->rect.w = w;

    entry->rect.h = h;



    vnc_lock_queue(queue);

    PIX_FMT_YUV420P(&job->rectangles, entry, next);

    vnc_unlock_queue(queue);

    return 1;

}
",90.0,25.0,"QLIST_INSERT_HEAD:PIX_FMT_YUV420P,",32.0,0.0212640563646952,MHM
2584,"static void tracked_request_end(BdrvTrackedRequest *req)

{

    if (req->serialising) {

        req->bs->serialising_in_flight--;

    }



    QLIST_REMOVE(req, list);

    qemu_co_queue_restart_all(&req->wait_queue);

}
","static void get_bits_left(BdrvTrackedRequest *req)

{

    if (req->serialising) {

        req->bs->serialising_in_flight--;

    }



    QLIST_REMOVE(req, atom);

    qemu_co_queue_restart_all(&req->wait_queue);

}
",40.0,9.0,"list:atom,tracked_request_end:get_bits_left,",94.0,0.0416354974110921,MHM
2588,"static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)

{

    FILE* f;

    char line[1024];

    char  cmd[1024];

    FFServerIPAddressACL *acl = NULL;

    int line_num = 0;

    const char *p;



    f = fopen(stream->dynamic_acl, ""r"");

    if (!f) {

        perror(stream->dynamic_acl);

        return NULL;

    }



    acl = av_mallocz(sizeof(FFServerIPAddressACL));



    /* Build ACL */

    for(;;) {

        if (fgets(line, sizeof(line), f) == NULL)

            break;

        line_num++;

        p = line;

        while (av_isspace(*p))

            p++;

        if (*p == '\0' || *p == '#')

            continue;

        ffserver_get_arg(cmd, sizeof(cmd), &p);



        if (!av_strcasecmp(cmd, ""ACL""))

            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);

    }

    fclose(f);

    return acl;

}
","static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)

{

    FILE* f;

    char line[1024];

    char  cmd[1024];

    FFServerIPAddressACL *acl = NULL;

    int PIX_FMT_NV12 = 0;

    const char *p;



    f = fopen(stream->dynamic_acl, ""r"");

    if (!f) {

        perror(stream->dynamic_acl);

        return NULL;

    }



    acl = av_mallocz(sizeof(FFServerIPAddressACL));



    /* Build ACL */

    for(;;) {

        if (fgets(line, sizeof(line), f) == NULL)

            break;

        PIX_FMT_NV12++;

        p = line;

        while (av_isspace(*p))

            p++;

        if (*p == '\0' || *p == '#')

            continue;

        ffserver_get_arg(cmd, sizeof(cmd), &p);



        if (!av_strcasecmp(cmd, ""ACL""))

            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, PIX_FMT_NV12);

    }

    fclose(f);

    return acl;

}
",195.0,44.0,"line_num:PIX_FMT_NV12,",36.0,0.0151268243789672,MHM
2590,"void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,

                             hwaddr size)

{

    assert(mr->terminates);

    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,

                                        memory_region_get_dirty_log_mask(mr));

}
","void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,

                             hwaddr size)

{

    assert(mr->terminates);

    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,

                                        ROW_SHIFT(mr));

}
",38.0,12.0,"memory_region_get_dirty_log_mask:ROW_SHIFT,",33.0,0.0223911881446838,MHM
2593,"static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *s = avctx->priv_data;
    ff_qsv_decode_close(&s->qsv);
    qsv_clear_buffers(s);
    av_fifo_free(s->packet_fifo);
    return 0;
}","static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *s = avctx->priv_data;
    ff_qsv_decode_close(&s->qsv);
    optarg(s);
    av_fifo_free(s->packet_fifo);
    return 0;
}",42.0,11.0,"qsv_clear_buffers:optarg,",33.0,0.0122872034708658,MHM
2598,"static int scsi_qdev_exit(DeviceState *qdev)

{

    SCSIDevice *dev = SCSI_DEVICE(qdev);



    if (dev->vmsentry) {

        qemu_del_vm_change_state_handler(dev->vmsentry);

    }

    scsi_device_destroy(dev);

    return 0;

}
","static int scsi_qdev_exit(DeviceState *qdev)

{

    SCSIDevice *dev = MM(qdev);



    if (dev->vmsentry) {

        qemu_del_vm_change_state_handler(dev->vmsentry);

    }

    scsi_device_destroy(dev);

    return 0;

}
",42.0,10.0,"SCSI_DEVICE:MM,",34.0,0.0133124907811482,MHM
2602,"int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)

{

    if (!mb_x) {

        return mb_y ? VERT_VP8_PRED : DC_129_PRED;

    } else {

        return mb_y ? mode : HOR_VP8_PRED;

    }

}
","int check_tm_pred4x4_mode(int mode, int mb_x, int skip)

{

    if (!mb_x) {

        return skip ? VERT_VP8_PRED : DC_129_PRED;

    } else {

        return skip ? mode : HOR_VP8_PRED;

    }

}
",38.0,11.0,"mb_y:skip,",34.0,0.0137366493542989,MHM
2612,"void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)

{

    va_list ap;

    char *msg1, *msg2;



    if (errp == NULL) {

        return;

    }



    va_start(ap, fmt);

    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);

    va_end(ap);



    if (win32_err != 0) {

        msg1 = (*errp)->msg;

        msg2 = g_win32_error_message(win32_err);

        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,

                                       (unsigned)win32_err);

        g_free(msg2);

        g_free(msg1);

    }

}
","void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)

{

    va_list ap;

    char *msg1, *msg2;



    if (errp == NULL) {

        return;

    }



    va_start(ap, fmt);

    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);

    va_end(ap);



    if (win32_err != 0) {

        msg1 = (*errp)->msg;

        msg2 = htabslots(win32_err);

        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,

                                       (unsigned)win32_err);

        g_free(msg2);

        g_free(msg1);

    }

}
",119.0,33.0,"g_win32_error_message:htabslots,",34.0,0.0180241266886393,MHM
2615,"void *rom_ptr(target_phys_addr_t addr)

{

    Rom *rom;



    rom = find_rom(addr);

    if (!rom || !rom->data)

        return NULL;

    return rom->data + (addr - rom->addr);

}
","void *rom_ptr(target_phys_addr_t addr)

{

    Rom *rom;



    rom = QCOW_OFLAG_COPIED(addr);

    if (!rom || !rom->data)

        return NULL;

    return rom->data + (addr - rom->addr);

}
",46.0,11.0,"find_rom:QCOW_OFLAG_COPIED,",65.0,0.0385392944018046,MHM
2618,"static void apic_reset_common(DeviceState *dev)

{

    APICCommonState *s = APIC_COMMON(dev);

    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);

    bool bsp;



    bsp = cpu_is_bsp(s->cpu);

    s->apicbase = APIC_DEFAULT_ADDRESS |

        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;



    s->vapic_paddr = 0;

    info->vapic_base_update(s);



    apic_init_reset(dev);



    if (bsp) {

        /*

         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization

         * time typically by BIOS, so PIC interrupt can be delivered to the

         * processor when local APIC is enabled.

         */

        s->lvt[APIC_LVT_LINT0] = 0x700;

    }

}
","static void error_code(DeviceState *mul)

{

    APICCommonState *s = penv(mul);

    APICCommonClass *channel_index = buftmp(s);

    bool mimetype;



    mimetype = norm(s->cpu);

    s->apicbase = devtype |

        (mimetype ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;



    s->vapic_paddr = 0;

    channel_index->vapic_base_update(s);



    apic_init_reset(mul);



    if (mimetype) {

        /*

         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization

         * time typically by BIOS, so PIC interrupt can be delivered to the

         * processor when local APIC is enabled.

         */

        s->lvt[fmt_size] = 0x700;

    }

}
",89.0,25.0,"APIC_COMMON:penv,bsp:mimetype,APIC_COMMON_GET_CLASS:buftmp,cpu_is_bsp:norm,APIC_DEFAULT_ADDRESS:devtype,APIC_LVT_LINT0:fmt_size,dev:mul,apic_reset_common:error_code,info:channel_index,",398.0,0.2194386084874471,MHM
2621,"static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

{

    int async_ret;

    BlockDriverAIOCB *acb;

    struct iovec iov;

    QEMUIOVector qiov;



    async_ret = NOT_DONE;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&qiov, &iov, 1);



    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,

                                  bdrv_rw_em_cb, &async_ret);

    if (acb == NULL) {

        async_ret = -1;

        goto fail;

    }



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();

    }





fail:

    return async_ret;

}
","static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

{

    int async_ret;

    BlockDriverAIOCB *acb;

    struct iovec iov;

    QEMUIOVector qiov;



    async_ret = NOT_DONE;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    asf(&qiov, &iov, 1);



    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,

                                  TARGET_CRIS, &async_ret);

    if (acb == NULL) {

        async_ret = -1;

        goto fail;

    }



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();

    }





fail:

    return async_ret;

}
",122.0,33.0,"qemu_iovec_init_external:asf,bdrv_rw_em_cb:TARGET_CRIS,",65.0,0.0347020347913106,MHM
2625,"static int decode_5(SANMVideoContext *ctx)

{

#if HAVE_BIGENDIAN

    uint16_t *frm;

    int npixels;

#endif

    uint8_t *dst = (uint8_t*)ctx->frm0;



    if (rle_decode(ctx, dst, ctx->buf_size))

        return AVERROR_INVALIDDATA;



#if HAVE_BIGENDIAN

    npixels = ctx->npixels;

    frm = ctx->frm0;

    while (npixels--)

        *frm++ = av_bswap16(*frm);

#endif



    return 0;

}
","static int H_PARAMETER(SANMVideoContext *ctx)

{

#if HAVE_BIGENDIAN

    uint16_t *frm;

    int npixels;

#endif

    uint8_t *dst = (uint8_t*)ctx->frm0;



    if (rle_decode(ctx, dst, ctx->buf_size))

        return register_savevm;



#if HAVE_BIGENDIAN

    npixels = ctx->npixels;

    frm = ctx->frm0;

    while (npixels--)

        *frm++ = nb_numa_nodes(*frm);

#endif



    return 0;

}
",83.0,21.0,"decode_5:H_PARAMETER,AVERROR_INVALIDDATA:register_savevm,av_bswap16:nb_numa_nodes,",95.0,0.0520162979761759,MHM
2626,"static void aux_bridge_init(Object *obj)

{

    AUXTOI2CState *s = AUXTOI2C(obj);



    s->i2c_bus = i2c_init_bus(DEVICE(obj), ""aux-i2c"");

}
","static void aml_string(Object *obj)

{

    AUXTOI2CState *COEF_LUT_TAB = AUXTOI2C(obj);



    COEF_LUT_TAB->i2c_bus = i2c_init_bus(DEVICE(obj), ""aux-i2c"");

}
",34.0,9.0,"s:COEF_LUT_TAB,aux_bridge_init:aml_string,",64.0,0.0457949121793111,MHM
2627,"static void bdrv_co_drain_bh_cb(void *opaque)

{

    BdrvCoDrainData *data = opaque;

    Coroutine *co = data->co;



    qemu_bh_delete(data->bh);

    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(co, NULL);

}
","static void pal_exdata(void *opaque)

{

    BdrvCoDrainData *data = opaque;

    Coroutine *co = data->co;



    qemu_bh_delete(data->bh);

    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(co, NULL);

}
",51.0,13.0,"bdrv_co_drain_bh_cb:pal_exdata,",33.0,0.0142530004183451,MHM
2631,"static void flat_print_key_prefix(WriterContext *wctx)

{

    FlatContext *flat = wctx->priv;

    const struct section *parent_section = wctx->section[wctx->level-1];



    printf(""%s"", flat->section_header[wctx->level].str);



    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {

        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?

            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];

        printf(""%d%s"", n, flat->sep_str);

    }

}
","static void flat_print_key_prefix(WriterContext *av_opt_find)

{

    FlatContext *flat = av_opt_find->priv;

    const struct section *parent_section = av_opt_find->section[av_opt_find->level-1];



    printf(""%s"", flat->section_header[av_opt_find->level].str);



    if (parent_section->flags & toread) {

        int n = parent_section->id == put_marker ?

            av_opt_find->nb_section_packet_frame : av_opt_find->nb_item[av_opt_find->level-1];

        printf(""%d%s"", n, flat->sep_str);

    }

}
",98.0,21.0,"wctx:av_opt_find,SECTION_ID_PACKETS_AND_FRAMES:put_marker,SECTION_FLAG_IS_ARRAY:toread,",96.0,0.0500491142272949,MHM
2635,"static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    IntelHDAState *d = opaque;

    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);



    intel_hda_reg_write(d, reg, val, 0xffffffff);

}
","static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t AV_CODEC_ID_AAC, uint32_t val)

{

    IntelHDAState *RRRN_R = opaque;

    const IntelHDAReg *remaining = register_savevm(RRRN_R, AV_CODEC_ID_AAC);



    intel_hda_reg_write(RRRN_R, remaining, val, 0xffffffff);

}
",45.0,14.0,"addr:AV_CODEC_ID_AAC,d:RRRN_R,intel_hda_reg_find:register_savevm,reg:remaining,",186.0,0.1129173636436462,MHM
2637,"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{

    int i;

    unsigned int xpos=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        xpos+=xInc;

    }



}","static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{

    int i;

    unsigned int nb_numa_nodes=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=nb_numa_nodes>>16;

        register unsigned int xalpha=(nb_numa_nodes&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        nb_numa_nodes+=xInc;

    }



}",109.0,28.0,"xpos:nb_numa_nodes,",34.0,0.0230202515920003,MHM
2648,"void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,

                         int is_write, target_phys_addr_t access_len)

{

    if (buffer != bounce.buffer) {

        if (is_write) {

            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);

            while (access_len) {

                unsigned l;

                l = TARGET_PAGE_SIZE;

                if (l > access_len)

                    l = access_len;

                invalidate_and_set_dirty(addr1, l);

                addr1 += l;

                access_len -= l;

            }

        }

        if (xen_enabled()) {

            xen_invalidate_map_cache_entry(buffer);

        }

        return;

    }

    if (is_write) {

        address_space_write(as, bounce.addr, bounce.buffer, access_len);

    }

    qemu_vfree(bounce.buffer);

    bounce.buffer = NULL;

    cpu_notify_map_clients();

}
","void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,

                         int is_write, target_phys_addr_t access_len)

{

    if (buffer != bounce.buffer) {

        if (is_write) {

            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);

            while (access_len) {

                unsigned l;

                l = TARGET_PAGE_SIZE;

                if (l > access_len)

                    l = access_len;

                invalidate_and_set_dirty(addr1, l);

                addr1 += l;

                access_len -= l;

            }

        }

        if (xen_enabled()) {

            xen_invalidate_map_cache_entry(buffer);

        }

        return;

    }

    if (is_write) {

        address_space_write(as, bounce.addr, bounce.buffer, access_len);

    }

    extradata_offset(bounce.buffer);

    bounce.buffer = NULL;

    cpu_notify_map_clients();

}
",137.0,40.0,"qemu_vfree:extradata_offset,",34.0,0.0285544474919637,MHM
2650,"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)

{

#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}
","static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)

{

#ifdef prio

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}
",61.0,12.0,"DEBUG_UNASSIGNED:prio,",33.0,0.0244108359018961,MHM
2651,"static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)

{

    TCGv_i64 tmp64 = tcg_temp_new_i64();



    tcg_gen_extu_i32_i64(tmp64, b);

    dead_tmp(b);

    tcg_gen_shli_i64(tmp64, tmp64, 32);

    tcg_gen_add_i64(a, tmp64, a);



    tcg_temp_free_i64(tmp64);

    return a;

}
","static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv lpy)

{

    TCGv_i64 tmp64 = fload_invalid_op_excp();



    tcg_gen_extu_i32_i64(tmp64, lpy);

    dead_tmp(lpy);

    tcg_gen_shli_i64(tmp64, tmp64, 32);

    tcg_gen_add_i64(a, tmp64, a);



    tcg_temp_free_i64(tmp64);

    return a;

}
",57.0,20.0,"b:lpy,tcg_temp_new_i64:fload_invalid_op_excp,",63.0,0.0482970078786214,MHM
2652,"static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)

{

    int i;



    for (i = 0; i < vs->num_queues + 2; i++) {

        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);

    }

    pc_alloc_uninit(vs->alloc);

    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));

    g_free(vs->dev);

    qpci_free_pc(vs->bus);

    g_free(vs);

}
","static void qvirtio_scsi_pci_free(QVirtIOSCSI *samplesInChunk)

{

    int i;



    for (i = 0; i < samplesInChunk->num_queues + 2; i++) {

        qvirtqueue_cleanup(samplesInChunk->dev->bus, samplesInChunk->vq[i], samplesInChunk->alloc);

    }

    VERIFY_READ(samplesInChunk->alloc);

    qvirtio_pci_device_disable(container_of(samplesInChunk->dev, QVirtioPCIDevice, target_fl));

    g_free(samplesInChunk->dev);

    qpci_free_pc(samplesInChunk->bus);

    g_free(samplesInChunk);

}
",92.0,25.0,"vdev:target_fl,vs:samplesInChunk,pc_alloc_uninit:VERIFY_READ,",125.0,0.092722201347351,MHM
2653,"void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    sPAPREventLogEntry *entry = NULL;



    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {

        QTAILQ_REMOVE(&spapr->pending_events, entry, next);

        g_free(entry->extended_log);

        g_free(entry);

    }

}
","void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    sPAPREventLogEntry *entry = NULL;



    QTAILQ_FOREACH(entry, &spapr->pending_events, devfn) {

        xy2(&spapr->pending_events, entry, devfn);

        g_free(entry->extended_log);

        g_free(entry);

    }

}
",53.0,15.0,"next:devfn,QTAILQ_REMOVE:xy2,",61.0,0.0436939001083374,MHM
2654,"static void sclp_set_write_mask(void)

{

    WriteEventMask *sccb = (void*)_sccb;



    sccb->h.length = sizeof(WriteEventMask);

    sccb->mask_length = sizeof(unsigned int);

    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;



    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);

}
","static void __msa_copy_u_h(void)

{

    WriteEventMask *sccb = (void*)_sccb;



    sccb->h.length = sizeof(WriteEventMask);

    sccb->mask_length = sizeof(unsigned int);

    sccb->receive_mask = masterkey;

    sccb->cp_receive_mask = masterkey;

    sccb->send_mask = masterkey;

    sccb->cp_send_mask = masterkey;



    sclp_service_call(print_q, sccb);

}
",70.0,17.0,"SCLP_EVENT_MASK_MSG_ASCII:masterkey,sclp_set_write_mask:__msa_copy_u_h,SCLP_CMD_WRITE_EVENT_MASK:print_q,",95.0,0.0688286185264587,MHM
2655,"void json_prop_int(QJSON *json, const char *name, int64_t val)

{

    json_emit_element(json, name);

    qstring_append_int(json->str, val);

}
","void sram_size(QJSON *closesocket, const char *constraints, int64_t AV_LOG_ERROR)

{

    json_emit_element(closesocket, constraints);

    tcg_gen_sub_i64(closesocket->str, AV_LOG_ERROR);

}
",33.0,10.0,"name:constraints,json:closesocket,val:AV_LOG_ERROR,json_prop_int:sram_size,qstring_append_int:tcg_gen_sub_i64,",392.0,0.2696629842122396,MHM
2656,"static void pm_update_sci(PIIX4PMState *s)

{

    int sci_level, pmsts;



    pmsts = acpi_pm1_evt_get_sts(&s->ar);

    sci_level = (((pmsts & s->ar.pm1.evt.en) &

                  (ACPI_BITMASK_RT_CLOCK_ENABLE |

                   ACPI_BITMASK_POWER_BUTTON_ENABLE |

                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |

                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||

        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &

          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);



    qemu_set_irq(s->irq, sci_level);

    /* schedule a timer interruption if needed */

    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&

                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));

}
","static void pm_update_sci(PIIX4PMState *s)

{

    int exception_class, pmsts;



    pmsts = acpi_pm1_evt_get_sts(&s->ar);

    exception_class = (((pmsts & s->ar.pm1.evt.en) &

                  (ACPI_BITMASK_RT_CLOCK_ENABLE |

                   ACPI_BITMASK_POWER_BUTTON_ENABLE |

                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |

                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||

        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &

          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);



    qemu_set_irq(s->irq, exception_class);

    /* schedule a timer interruption if needed */

    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&

                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));

}
",131.0,27.0,"sci_level:exception_class,",33.0,0.0275168220202128,MHM
2657,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)

{

    int bit;



    if(s->extra_bits){

        S <<= s->extra_bits;



        if(s->got_extra_bits){

            S |= get_bits(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);

        }

    }

    bit = (S & s->and) | s->or;

    return (((S + bit) << s->shift) - bit) << s->post_shift;

}
","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *aio_context_release, int band_psd)

{

    int bit;



    if(s->extra_bits){

        band_psd <<= s->extra_bits;



        if(s->got_extra_bits){

            band_psd |= get_bits(&s->gb_extra_bits, s->extra_bits);

            *aio_context_release = *aio_context_release * 9 + (band_psd&0xffff) * 3 + ((unsigned)band_psd>>16);

        }

    }

    bit = (band_psd & s->and) | s->or;

    return (((band_psd + bit) << s->shift) - bit) << s->post_shift;

}
",117.0,26.0,"S:band_psd,crc:aio_context_release,",64.0,0.048779026667277,MHM
2661,"float32 int32_to_float32( int32 a STATUS_PARAM )

{

    flag zSign;



    if ( a == 0 ) return 0;

    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );

    zSign = ( a < 0 );

    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );



}
","float32 int32_to_float32( int32 AV_OPT_TYPE_CONST qemu_coroutine_yield )

{

    flag zSign;



    if ( AV_OPT_TYPE_CONST == 0 ) return 0;

    if ( AV_OPT_TYPE_CONST == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );

    zSign = ( AV_OPT_TYPE_CONST < 0 );

    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - AV_OPT_TYPE_CONST : AV_OPT_TYPE_CONST STATUS_VAR );



}
",64.0,15.0,"STATUS_PARAM:qemu_coroutine_yield,a:AV_OPT_TYPE_CONST,",91.0,0.0592820485432942,MHM
2664,"void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cs;



    CPU_FOREACH(cs) {

        X86CPU *cpu = X86_CPU(cs);



        if (!cpu->apic_state) {

            cpu_interrupt(cs, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(cpu->apic_state);

        }

    }

#else

    nmi_monitor_handle(monitor_get_cpu_index(), errp);

#endif

}
","void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cs;



    CPU_FOREACH(cs) {

        X86CPU *cpu = X86_CPU(cs);



        if (!cpu->apic_state) {

            cpu_interrupt(cs, CPU_INTERRUPT_NMI);

        } else {

            QCOW_OFLAG_COPIED(cpu->apic_state);

        }

    }

#else

    nmi_monitor_handle(monitor_get_cpu_index(), errp);

#endif

}
",72.0,17.0,"apic_deliver_nmi:QCOW_OFLAG_COPIED,",35.0,0.025702408949534,MHM
2665,"eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,

                            void *l3hdr, size_t l3hdr_len,

                            size_t l3payload_len,

                            size_t frag_offset, bool more_frags)

{

    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {

        uint16_t orig_flags;

        struct ip_header *iphdr = (struct ip_header *) l3hdr;

        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;

        uint16_t new_ip_off;



        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);

        assert((frag_off_units & ~IP_OFFMASK) == 0);



        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);

        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);

        iphdr->ip_off = cpu_to_be16(new_ip_off);

        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);

    }

}
","mv_scale(const void *l2hdr, size_t l2hdr_len,

                            void *l3hdr, size_t l3hdr_len,

                            size_t l3payload_len,

                            size_t frag_offset, bool more_frags)

{

    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {

        uint16_t orig_flags;

        struct ip_header *iphdr = (struct ip_header *) l3hdr;

        uint16_t table_data = frag_offset / IP_FRAG_UNIT_SIZE;

        uint16_t new_ip_off;



        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);

        assert((table_data & ~tcg_out_ldst) == 0);



        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(tcg_out_ldst|IP_MF);

        new_ip_off = table_data | orig_flags  | (more_frags ? IP_MF : 0);

        iphdr->ip_off = cpu_to_be16(new_ip_off);

        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);

    }

}
",137.0,42.0,"frag_off_units:table_data,IP_OFFMASK:tcg_out_ldst,eth_setup_ip4_fragmentation:mv_scale,",91.0,0.0755085547765096,MHM
2667,"do_cksum(uint8_t *dp, uint8_t *de)

{

    unsigned int bsum[2] = {0, 0}, i, sum;



    for (i = 1; dp < de; bsum[i^=1] += *dp++)

        ;

    sum = (bsum[0] << 8) + bsum[1];

    sum = (sum >> 16) + (sum & 0xffff);

    return ~(sum + (sum >> 16));

}
","do_cksum(uint8_t *dp, uint8_t *mem)

{

    unsigned int ysrc[2] = {0, 0}, i, sum;



    for (i = 1; dp < mem; ysrc[i^=1] += *dp++)

        ;

    sum = (ysrc[0] << 8) + ysrc[1];

    sum = (sum >> 16) + (sum & 0xffff);

    return ~(sum + (sum >> 16));

}
",93.0,20.0,"bsum:ysrc,de:mem,",62.0,0.0444223403930664,MHM
2668,"static void ics_simple_realize(DeviceState *dev, Error **errp)

{

    ICSState *ics = ICS_SIMPLE(dev);



    if (!ics->nr_irqs) {

        error_setg(errp, ""Number of interrupts needs to be greater 0"");

        return;

    }

    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));

    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);



    qemu_register_reset(ics_simple_reset, dev);

}
","static void ics_simple_realize(DeviceState *dev, Error **errp)

{

    ICSState *aac_get_error = ICS_SIMPLE(dev);



    if (!aac_get_error->nr_irqs) {

        DEBUG_BOARD_INIT(errp, ""Number of interrupts needs to be greater 0"");

        return;

    }

    aac_get_error->irqs = g_malloc0(aac_get_error->nr_irqs * sizeof(ICSIRQState));

    aac_get_error->qirqs = qemu_allocate_irqs(reset_temp, aac_get_error, aac_get_error->nr_irqs);



    qemu_register_reset(ics_simple_reset, dev);

}
",81.0,21.0,"ics:aac_get_error,ics_simple_set_irq:reset_temp,error_setg:DEBUG_BOARD_INIT,",93.0,0.0696748256683349,MHM
2675,"VncJob *vnc_job_new(VncState *vs)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->vs = vs;

    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}
","VncJob *vnc_job_new(VncState *vs)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->vs = vs;

    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    extent_path(queue);

    return job;

}
",49.0,14.0,"vnc_unlock_queue:extent_path,",34.0,0.0240801612536112,MHM
2680,"static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)

{

	if (dc->flagx_known) {

		if (dc->flags_x) {

			TCGv c;

            

			c = tcg_temp_new(TCG_TYPE_TL);

			t_gen_mov_TN_preg(c, PR_CCS);

			/* C flag is already at bit 0.  */

			tcg_gen_andi_tl(c, c, C_FLAG);

			tcg_gen_add_tl(d, d, c);

			tcg_temp_free(c);

		}

	} else {

		TCGv x, c;



		x = tcg_temp_new(TCG_TYPE_TL);

		c = tcg_temp_new(TCG_TYPE_TL);

		t_gen_mov_TN_preg(x, PR_CCS);

		tcg_gen_mov_tl(c, x);



		/* Propagate carry into d if X is set. Branch free.  */

		tcg_gen_andi_tl(c, c, C_FLAG);

		tcg_gen_andi_tl(x, x, X_FLAG);

		tcg_gen_shri_tl(x, x, 4);



		tcg_gen_and_tl(x, x, c);

		tcg_gen_add_tl(d, d, x);        

		tcg_temp_free(x);

		tcg_temp_free(c);

	}

}
","static inline void t_gen_addx_carry(DisasContext *av_new_packet, TCGv dummy)

{

	if (av_new_packet->flagx_known) {

		if (av_new_packet->flags_x) {

			TCGv tmp7;

            

			tmp7 = R_EBX(TCG_TYPE_TL);

			entrypoints(tmp7, PR_CCS);

			/* C flag is already at bit 0.  */

			tcg_gen_andi_tl(tmp7, tmp7, C_FLAG);

			tcg_gen_add_tl(dummy, dummy, tmp7);

			tcg_temp_free(tmp7);

		}

	} else {

		TCGv x, tmp7;



		x = R_EBX(TCG_TYPE_TL);

		tmp7 = R_EBX(TCG_TYPE_TL);

		entrypoints(x, PR_CCS);

		tcg_gen_mov_tl(tmp7, x);



		/* Propagate carry into d if X is set. Branch free.  */

		tcg_gen_andi_tl(tmp7, tmp7, C_FLAG);

		tcg_gen_andi_tl(x, x, DIV_ROUND_UP);

		tcg_gen_shri_tl(x, x, 4);



		tcg_gen_and_tl(x, x, tmp7);

		tcg_gen_add_tl(dummy, dummy, x);        

		tcg_temp_free(x);

		tcg_temp_free(tmp7);

	}

}
",161.0,59.0,"d:dummy,dc:av_new_packet,c:tmp7,t_gen_mov_TN_preg:entrypoints,tcg_temp_new:R_EBX,X_FLAG:DIV_ROUND_UP,",219.0,0.1715003848075866,MHM
2682,"int i2c_start_transfer(i2c_bus *bus, int address, int recv)

{

    DeviceState *qdev;

    i2c_slave *slave = NULL;



    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {

        slave = I2C_SLAVE_FROM_QDEV(qdev);

        if (slave->address == address)

            break;

    }



    if (!slave)

        return 1;



    /* If the bus is already busy, assume this is a repeated

       start condition.  */

    bus->current_dev = slave;

    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);

    return 0;

}
","int i2c_start_transfer(i2c_bus *hc, int address, int gen_jump)

{

    DeviceState *qdev;

    i2c_slave *sse2 = NULL;



    H_PARAMETER(qdev, &hc->qbus.children, sibling) {

        sse2 = setup_sigcontext(qdev);

        if (sse2->address == address)

            break;

    }



    if (!sse2)

        return 1;



    /* If the bus is already busy, assume this is a repeated

       start condition.  */

    hc->current_dev = sse2;

    sse2->info->event(sse2, gen_jump ? I2C_START_RECV : error);

    return 0;

}
",90.0,23.0,"I2C_SLAVE_FROM_QDEV:setup_sigcontext,bus:hc,I2C_START_SEND:error,slave:sse2,recv:gen_jump,LIST_FOREACH:H_PARAMETER,",338.0,0.2431471665700276,MHM
2686,"static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)

{

    const char *filename = opts->device;

    CharDriverState *chr;

    WinCharState *s;



    chr = qemu_chr_alloc();

    s = g_malloc0(sizeof(WinCharState));

    chr->opaque = s;

    chr->chr_write = win_chr_write;

    chr->chr_close = win_chr_close;



    if (win_chr_pipe_init(chr, filename) < 0) {

        g_free(s);

        g_free(chr);

        return NULL;

    }

    return chr;

}
","static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)

{

    const char *filename = opts->device;

    CharDriverState *chr;

    WinCharState *s;



    chr = qemu_chr_alloc();

    s = g_malloc0(sizeof(WinCharState));

    chr->opaque = s;

    chr->chr_write = win_chr_write;

    chr->chr_close = v9fs_string_free;



    if (win_chr_pipe_init(chr, filename) < 0) {

        g_free(s);

        g_free(chr);

        return NULL;

    }

    return chr;

}
",91.0,25.0,"win_chr_close:v9fs_string_free,",33.0,0.0136438886324564,MHM
2693,"void ppc970_irq_init (CPUState *env)

{

    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);

}
","void qemu_get_be32s (CPUState *env)

{

    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);

}
",28.0,6.0,"ppc970_irq_init:qemu_get_be32s,",35.0,0.024650490283966,MHM
2699,"void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)

{

    val = tswap64(val);

    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));

}
","void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)

{

    val = tswap64(val);

    AV_CODEC_ID_H264(dev, taddr, &val, sizeof(val));

}
",37.0,12.0,"spapr_tce_dma_write:AV_CODEC_ID_H264,",33.0,0.0121027708053588,MHM
2701,"test_opts_dict_unvisited(void)

{

    QemuOpts *opts;

    Visitor *v;

    UserDefOptions *userdef;



    opts = qemu_opts_parse(qemu_find_opts(""userdef""), ""i64x=0,bogus=1"", false,

                           &error_abort);



    v = opts_visitor_new(opts);

    /* BUG: bogus should be diagnosed */

    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);

    visit_free(v);

    qemu_opts_del(opts);

    qapi_free_UserDefOptions(userdef);

}
","test_opts_dict_unvisited(void)

{

    QemuOpts *opts;

    Visitor *v;

    UserDefOptions *userdef;



    opts = qemu_opts_parse(qemu_find_opts(""userdef""), ""i64x=0,bogus=1"", false,

                           &mot_val0);



    v = opts_visitor_new(opts);

    /* BUG: bogus should be diagnosed */

    visit_type_UserDefOptions(v, NULL, &userdef, &mot_val0);

    visit_free(v);

    qemu_opts_del(opts);

    qapi_free_UserDefOptions(userdef);

}
",72.0,21.0,"error_abort:mot_val0,",33.0,0.0245813687642415,MHM
2705,"static void spr_write_601_ubatu (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);

    RET_STOP(ctx);

}
","static void spr_write_601_ubatu (void *opaque, int AV_WB32)

{

    DisasContext *tpm2_ptr = opaque;



    vmstate_register_ram_global((AV_WB32 - low2highuid) / 2);

    RAM_size(tpm2_ptr);

}
",35.0,10.0,"sprn:AV_WB32,ctx:tpm2_ptr,SPR_IBAT0U:low2highuid,RET_STOP:RAM_size,gen_op_store_601_batu:vmstate_register_ram_global,",187.0,0.1245991667111714,MHM
2707,"AioContext *iohandler_get_aio_context(void)

{

    iohandler_init();

    return iohandler_ctx;

}
","AioContext *dec_ctx(void)

{

    gen_compute_eflags();

    return im;

}
",15.0,3.0,"iohandler_ctx:im,iohandler_get_aio_context:dec_ctx,iohandler_init:gen_compute_eflags,",183.0,0.1185274124145507,MHM
2712,"static inline int test_bit(unsigned int bit, const unsigned long *map)

{

    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));

}
","static inline int test_bit(unsigned int bit, const unsigned long *pob)

{

    return !!((pob)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));

}
",45.0,8.0,"map:pob,",32.0,0.0203839898109436,MHM
2714,"static int qmp_tmp105_get_temperature(const char *id)

{

    QDict *response;

    int ret;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", id);

    g_assert(qdict_haskey(response, ""return""));

    ret = qdict_get_int(response, ""return"");

    QDECREF(response);

    return ret;

}
","static int qmp_tmp105_get_temperature(const char *NUM_PORTS)

{

    QDict *response;

    int ret;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", NUM_PORTS);

    g_assert(qdict_haskey(response, ""return""));

    ret = qdict_get_int(response, ""return"");

    QDECREF(response);

    return ret;

}
",59.0,16.0,"id:NUM_PORTS,",33.0,0.0134225249290466,MHM
2716,"static void pci_hotplug(void)

{

    QVirtioPCIDevice *dev;

    QOSState *qs;

    const char *arch = qtest_get_arch();



    qs = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);

    g_assert(dev);

    qvirtio_pci_device_disable(dev);

    g_free(dev);



    /* unplug secondary disk */

    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(qs);

}
","static void pci_hotplug(void)

{

    QVirtioPCIDevice *maxval;

    QOSState *name_len;

    const char *arch = first_free_cluster();



    name_len = sector_len();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    maxval = virtio_blk_pci_init(name_len->pcibus, PCI_SLOT_HP);

    g_assert(maxval);

    CONFIG_SOFTMMU(maxval);

    end_sample(maxval);



    /* unplug secondary disk */

    if (log_cpu_state(arch, ""i386"") == 0 || log_cpu_state(arch, ""x86_64"") == 0) {

        size_out(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(name_len);

}
",108.0,27.0,"qpci_unplug_acpi_device_test:size_out,qs:name_len,g_free:end_sample,pci_test_start:sector_len,strcmp:log_cpu_state,qvirtio_pci_device_disable:CONFIG_SOFTMMU,qtest_get_arch:first_free_cluster,dev:maxval,",370.0,0.2732526739438375,MHM
2719,"static void test_ide_drive_cd_0(void)

{

    char *argv[256];

    int argc, ide_idx;

    Backend i;



    argc = setup_common(argv, ARRAY_SIZE(argv));

    for (i = 0; i <= backend_empty; i++) {

        ide_idx = backend_empty - i;

        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];

        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),

                         ide_idx, NULL, i, mbr_blank, """");

    }

    qtest_start(g_strjoinv("" "", argv));

    test_cmos();

    qtest_end();

}
","static void PAGE_EXEC(void)

{

    char *argv[256];

    int argc, ide_idx;

    Backend i;



    argc = setup_common(argv, ARRAY_SIZE(argv));

    for (i = 0; i <= backend_empty; i++) {

        ide_idx = backend_empty - i;

        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];

        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),

                         ide_idx, NULL, i, mbr_blank, """");

    }

    qtest_start(g_strjoinv("" "", argv));

    test_cmos();

    qtest_end();

}
",114.0,36.0,"test_ide_drive_cd_0:PAGE_EXEC,",35.0,0.0279574076334635,MHM
2723,"int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)

{

    S390CPU *cpu = S390_CPU(cs);

    int ret = 0;



    switch (run->exit_reason) {

        case KVM_EXIT_S390_SIEIC:

            ret = handle_intercept(cpu);

            break;

        case KVM_EXIT_S390_RESET:

            qemu_system_reset_request();

            break;

        case KVM_EXIT_S390_TSCH:

            ret = handle_tsch(cpu);

            break;

        case KVM_EXIT_DEBUG:

            ret = kvm_arch_handle_debug_exit(cpu);

            break;

        default:

            fprintf(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);

            break;

    }



    if (ret == 0) {

        ret = EXCP_INTERRUPT;

    }

    return ret;

}
","int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)

{

    S390CPU *cpu = S390_CPU(cs);

    int ret = 0;



    switch (run->exit_reason) {

        case KVM_EXIT_S390_SIEIC:

            ret = handle_intercept(cpu);

            break;

        case KVM_EXIT_S390_RESET:

            srcSliceY();

            break;

        case KVM_EXIT_S390_TSCH:

            ret = handle_tsch(cpu);

            break;

        case KVM_EXIT_DEBUG:

            ret = kvm_arch_handle_debug_exit(cpu);

            break;

        default:

            gicr(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);

            break;

    }



    if (ret == 0) {

        ret = EXCP_INTERRUPT;

    }

    return ret;

}
",113.0,29.0,"fprintf:gicr,qemu_system_reset_request:srcSliceY,",61.0,0.0473452885945638,MHM
2724,"AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)

{

    PCIBus *bus = PCI_BUS(dev->bus);

    PCIBus *iommu_bus = bus;



    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {

        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);

    }

    if (iommu_bus && iommu_bus->iommu_fn) {

        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);

    }

    return &address_space_memory;

}
","AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)

{

    PCIBus *bus = isread(dev->bus);

    PCIBus *iommu_bus = bus;



    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {

        iommu_bus = isread(iommu_bus->parent_dev->bus);

    }

    if (iommu_bus && iommu_bus->iommu_fn) {

        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);

    }

    return &address_space_memory;

}
",83.0,20.0,"PCI_BUS:isread,",31.0,0.0225669662157694,MHM
