Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost
0,"static int decode_readlink(struct xdr_stream *xdr, struct rpc_rqst *req)
{
	struct xdr_buf *rcvbuf = &req->rq_rcv_buf;
	struct kvec *iov = rcvbuf->head;
	size_t hdrlen;
	u32 len, recvd;
	__be32 *p;
	char *kaddr;
	int status;
	status = decode_op_hdr(xdr, OP_READLINK);
	if (status)
		return status;
	READ_BUF(4);
	READ32(len);
	if (len >= rcvbuf->page_len || len <= 0) {
		dprintk(""nfs: server returned giant symlink!\n"");
		return -ENAMETOOLONG;
	}
	hdrlen = (char *) xdr->p - (char *) iov->iov_base;
	recvd = req->rq_rcv_buf.len - hdrlen;
	if (recvd < len) {
		dprintk(""NFS: server cheating in readlink reply: ""
				""count %u > recvd %u\n"", len, recvd);
		return -EIO;
	}
	xdr_read_pages(xdr, len);
	kaddr = (char *)kmap_atomic(rcvbuf->pages[0], KM_USER0);
	kaddr[len+rcvbuf->page_base] = '\0';
	kunmap_atomic(kaddr, KM_USER0);
	return 0;
}","static int decode_readlink(struct xdr_stream *xdr, struct rpc_rqst *req)
{
	struct xdr_buf *rcvbuf = &req->rq_rcv_buf;
	struct kvec *iov = rcvbuf->head;
	size_t hdrlen;
	u32 len, recvd;
	__be32 *p;
	char *kaddr;
	int status;
	status = decode_op_hdr(xdr, OP_READLINK);
	if (status)
		return status;
	READ_BUF(4);
	READ32(len);
	if (len >= rcvbuf->page_len || len <= 0) {
		dprintk(""nfs: server returned giant symlink!\n"");
		return -ENAMETOOLONG;
	}
	hdrlen = (char *) xdr->p - (char *) iov->iov_base;
	recvd = req->rq_rcv_buf.len - hdrlen;
	if (recvd < len) {
		dprintk(""NFS: server cheating in readlink reply: ""
				""count %u > recvd %u\n"", len, recvd);
		return -EIO;
	}
	xdr_read_pages(xdr, len);
	kaddr = (char *)kmap_atomic(rcvbuf->pages[0], KM_USER0);
	kaddr[len+rcvbuf->page_base] = '\0';
	kunmap_atomic(kaddr, KM_USER0);
	return 0;
}",,,64,
1,"void NumberFormatTest::verifyFieldPositionIterator(
        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {
    int32_t idx = 0;
    FieldPosition fp;
    while (iter.next(fp)) {
        if (expected[idx].spos == -1) {
            errln(""Iterator should have ended. got %d"", fp.getField());
            return;
        }
        assertEquals(""id"", expected[idx].id, fp.getField());
        assertEquals(""start"", expected[idx].spos, fp.getBeginIndex());
        assertEquals(""end"", expected[idx].epos, fp.getEndIndex());
        ++idx;
    }
    if (expected[idx].spos != -1) {
        errln(""Premature end of iterator. expected %d"", expected[idx].id);
    }
}","void NumberFormatTest::verifyFieldPositionIterator(
        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {
    int32_t idx = 0;
    FieldPosition fp;
    while (iter.next(fp)) {
        if (expected[idx].spos == -1) {
            errln(""Iterator should have ended. got %d"", fp.getField());
            return;
        }
        assertEquals(""id"", expected[idx].musicpal_audio_state, fp.getField());
        assertEquals(""start"", expected[idx].spos, fp.getBeginIndex());
        assertEquals(""end"", expected[idx].epos, fp.getEndIndex());
        ++idx;
    }
    if (expected[idx].spos != -1) {
        errln(""Premature end of iterator. expected %d"", expected[idx].musicpal_audio_state);
    }
}",,,317,
2,"GF_Box *dac3_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);
	return (GF_Box *)tmp;
}","qemu_alarm_timer *dac3_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, he);
	return (qemu_alarm_timer *)tmp;
}",,,254,
3,"void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;
    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }
    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}","void setCommand(client *c) {
    ADXChannelState *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;
    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != V9fsQID) {
        return;
    }
    c->argv[2] = ahci_dma_prepare_buf(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}",,,255,
4,"static PHP_FUNCTION(readgzfile)
{
	char *filename;
	int filename_len;
	int flags = REPORT_ERRORS;
	php_stream *stream;
	int size;
	long use_include_path = 0;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &filename, &filename_len, &use_include_path) == FAILURE) {
		return;
	}
	if (use_include_path) {
		flags |= USE_PATH;
	}
	stream = php_stream_gzopen(NULL, filename, ""rb"", flags, NULL, NULL STREAMS_CC TSRMLS_CC);
	if (!stream) {
		RETURN_FALSE;
	}
	size = php_stream_passthru(stream);
	php_stream_close(stream);
	RETURN_LONG(size);
}","static PHP_FUNCTION(ReplayAsyncEventKind)
{
	char *filename;
	int filename_len;
	int flags = REPORT_ERRORS;
	php_stream *stream;
	int size;
	long use_include_path = 0;
	if (zend_parse_parameters(drive_put_ref() VAAPIEncodePicture, ""s|l"", &filename, &filename_len, &use_include_path) == FAILURE) {
		return;
	}
	if (use_include_path) {
		flags |= USE_PATH;
	}
	stream = php_stream_gzopen(NULL, filename, ""rb"", flags, NULL, NULL STREAMS_CC VAAPIEncodePicture);
	if (!stream) {
		RETURN_FALSE;
	}
	size = php_stream_passthru(stream);
	php_stream_close(stream);
	get_sigframe(size);
}",,,303,
7,"static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)
{
	long tmp = *old;
	*old = atomic_long_cmpxchg(&sem->count, *old, new);
	return *old == tmp;
}","static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)
{
	long tmp = *old;
	*old = ff_get_cpu_flags_x86(&sem->address_spaces, *old, new);
	return *old == tmp;
}",,,192,
8,"static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,
						int id)
{
	struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);
	if (IS_ERR(ipcp))
		return ERR_CAST(ipcp);
	return container_of(ipcp, struct sem_array, sem_perm);
}","static inline struct FITHAW *sem_lock_check(struct ipc_namespace *ns,
						int id)
{
	struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);
	if (IS_ERR(ipcp))
		return ERR_CAST(ipcp);
	return container_of(ipcp, struct FITHAW, sem_perm);
}",,,314,
9,"void smb2cli_session_stop_replay(struct smbXcli_session *session)
{
	session->smb2->replay_active = false;
}","void pthread_mutex_unlock(struct smbXcli_session *cpsr_write_eret)
{
	cpsr_write_eret->smb2->CPSRWriteExceptionReturn = false;
}",,,256,
16,"const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;
    case 1:
       return name->state;
    case 2:
       return name->locality;
    case 3:
       return name->sur;
    case 4:
       return name->org;
    case 5:
       return name->unit;
    case 6:
       return name->commonName;
    case 7:
       return name->serialDev;
#ifdef WOLFSSL_CERT_EXT
    case 8:
       return name->busCat;
    case 9:
#else
    case 8:
#endif
       return name->email;
    default:
       return 0;
    }
}","const char* mux_chr_accept_input(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;
    case 1:
       return name->state;
    case 2:
       return name->locality;
    case 3:
       return name->sur;
    case 4:
       return name->org;
    case 5:
       return name->unit;
    case 6:
       return name->commonName;
    case 7:
       return name->NBDClient;
#ifdef lumSrc
    case 8:
       return name->busCat;
    case 9:
#else
    case 8:
#endif
       return name->email;
    default:
       return 0;
    }
}",,,254,
18,"free_wininfo(wininfo_T *wip)
{
    if (wip->wi_optset)
    {
	clear_winopt(&wip->wi_opt);
#ifdef FEAT_FOLDING
	deleteFoldRecurse(&wip->wi_folds);
#endif
    }
    vim_free(wip);
}","free_wininfo(wininfo_T *wip)
{
    if (wip->wi_optset)
    {
	block_save_setup(&wip->wi_opt);
#ifdef ahci_fingerprint
	deleteFoldRecurse(&wip->wi_folds);
#endif
    }
    vim_free(wip);
}",,,254,
22,"static int init_dumping(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);
      print_comment(md_result_file, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);
      init_func(qdatabase);
      fprintf(md_result_file,""\nUSE %s;\n"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
}  ","static int init_dumping(char *database, int visit_type_SocketAddress(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;
  }
  if (!PGM_OPERAND && !opt_xml)
  {
    if (opt_databases || bs)
    {
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);
      print_comment(md_result_file, 0,
                    ""
--
-- Current Database: %s
--
"", qdatabase);
      visit_type_SocketAddress(qdatabase);
      fprintf(md_result_file,""
USE %s;
"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
}  ",,,302,
26,"void MonCap::dump(Formatter *f) const
{
  f->dump_string(""text"", text);
}","void dinput::dump(Formatter *sPAPRPHBClass) const
{
  sPAPRPHBClass->aio_context_acquire(""text"", text);
}",,,302,
27,"R_API int r_socket_ready(RSocket *s, int secs, int usecs) {
	return -1;
}","R_API int stq_phys(RSocket *s, int secs, int tlb_v) {
	return -1;
}",,,192,
28,"R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}","R_API const char *uc32_cpu_realizefn(const char *base, const char *localmem_base) {
	int i;
	while (*base) {
		for (i = 0; localmem_base[i]; i++) {
			if (*base == localmem_base[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}",,,192,
29,  ConnectionCallbacks& callbacks() override { return callbacks_; },  env& get_uint32() yv12toyuy2 { return callbacks_; },,,254,
37,"gif_set_get_colormap (GifContext *context)
{
	context->global_colormap_size = 0;
	context->state = GIF_GET_COLORMAP;
}","vnc_queue_init (GifContext *PSTATE_nRW)
{
	PSTATE_nRW->global_colormap_size = 0;
	PSTATE_nRW->state = bs;
}",,,254,
43,"table_regex_match(const char *string, const char *pattern)
{
	regex_t preg;
	int	cflags = REG_EXTENDED|REG_NOSUB;
	if (strncmp(pattern, ""(?i)"", 4) == 0) {
		cflags |= REG_ICASE;
		pattern += 4;
	}
	if (regcomp(&preg, pattern, cflags) != 0)
		return (0);
	if (regexec(&preg, string, 0, NULL, 0) != 0)
		return (0);
	return (1);
}","qmp_output_type_uint64(const char *string, const char *pattern)
{
	sub_section preg;
	int	cflags = REG_EXTENDED|REG_NOSUB;
	if (strncmp(pattern, ""(?i)"", 4) == 0) {
		cflags |= REG_ICASE;
		pattern += 4;
	}
	if (regcomp(&preg, pattern, cflags) != 0)
		return (0);
	if (regexec(&preg, string, 0, NULL, 0) != 0)
		return (0);
	return (1);
}",,,237,
44,"void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}
	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}
	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}
	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}
	free(nodecon);
}","void cil_destroy_nodecon(struct log2_cblk_height *nodecon)
{
	if (nodecon == NULL) {
		return;
	}
	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}
	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}
	if (nodecon->BdrvTrackedRequest == NULL && nodecon->context != NULL) {
		usb_ohci_init_pxa(nodecon->context);
	}
	free(nodecon);
}",,,256,
45,"static void sd_read_block_characteristics(struct scsi_disk *sdkp)
{
	unsigned char *buffer;
	u16 rot;
	const int vpd_len = 64;
	buffer = kmalloc(vpd_len, GFP_KERNEL);
	if (!buffer ||
	    scsi_get_vpd_page(sdkp->device, 0xb1, buffer, vpd_len))
		goto out;
	rot = get_unaligned_be16(&buffer[4]);
	if (rot == 1)
		queue_flag_set_unlocked(QUEUE_FLAG_NONROT, sdkp->disk->queue);
 out:
	kfree(buffer);
}","static void sd_read_block_characteristics(struct scsi_disk *sdkp)
{
	unsigned char *buffer;
	u16 rot;
	const int vpd_len = 64;
	buffer = kmalloc(vpd_len, GFP_KERNEL);
	if (!buffer ||
	    scsi_get_vpd_page(sdkp->device, 0xb1, buffer, vpd_len))
		goto out;
	rot = get_unaligned_be16(&buffer[4]);
	if (rot == 1)
		queue_flag_set_unlocked(QUEUE_FLAG_NONROT, sdkp->disk->queue);
 out:
	kfree(buffer);
}",,,64,
49,"void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		return;
	}
	cil_list_destroy(&def->class_strs, CIL_TRUE);
	cil_list_destroy(&def->class_datums, CIL_FALSE);
	free(def);
}","void cil_destroy_default(struct max_rsp_len *def)
{
	if (def == NULL) {
		return;
	}
	cil_list_destroy(&def->REPLAY_MODE_PLAY, CIL_TRUE);
	cil_list_destroy(&def->class_datums, CIL_FALSE);
	free(def);
}",,,256,
53,"int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *name2, size_t len2, int isdir2,
	int (*compare)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	int cmp;
	cmp = compare(name1, name2, len);
	if (cmp)
		return cmp;
	c1 = name1[len];
	c2 = name2[len];
	if (c1 == '\0' && isdir1)
		c1 = '/';
	if (c2 == '\0' && isdir2)
		c2 = '/';
	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}","int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *name2, size_t len2, int isdir2,
	int (*compare)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	int cmp;
	cmp = compare(name1, name2, len);
	if (cmp)
		return cmp;
	c1 = name1[len];
	c2 = name2[len];
	if (c1 == '\0' && isdir1)
		c1 = '/';
	if (c2 == '\0' && isdir2)
		c2 = '/';
	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}",,,64,
58,"Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int j;
    i = strlen(myword);
    j = strlen(suffix);
    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}","qdev_init(inbuf, suffix)
    char *inbuf;
    char *suffix;
{
    register int kqemu_enabled;
    register int j;
    kqemu_enabled = strlen(inbuf);
    j = strlen(suffix);
    if (kqemu_enabled > j)
    {
	return (STRCMP((inbuf + kqemu_enabled - j), suffix));
    } else
    {
	return (-1);
    }
}",,,306,
60,"sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int rv;
	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);
	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");
	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);
	if (buf)
		free(buf);
	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	df->enumerated = 1;
	LOG_FUNC_RETURN(ctx, rv);
}","sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int rv;
	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);
	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");
	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);
	if (buf)
		free(buf);
	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	df->enumerated = 1;
	LOG_FUNC_RETURN(ctx, rv);
}",,,64,
70,"struct anon_vma *page_get_anon_vma(struct page *page)
{
	struct anon_vma *anon_vma = NULL;
	unsigned long anon_mapping;
	rcu_read_lock();
	anon_mapping = (unsigned long) ACCESS_ONCE(page->mapping);
	if ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)
		goto out;
	if (!page_mapped(page))
		goto out;
	anon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);
	if (!atomic_inc_not_zero(&anon_vma->refcount)) {
		anon_vma = NULL;
		goto out;
	}
	if (!page_mapped(page)) {
		put_anon_vma(anon_vma);
		anon_vma = NULL;
	}
out:
	rcu_read_unlock();
	return anon_vma;
}","struct MonitorEvent *page_get_anon_vma(struct page *page)
{
	struct MonitorEvent *MonitorEvent = NULL;
	unsigned long anon_mapping;
	rcu_read_lock();
	anon_mapping = (unsigned long) gen_op_addl_A0_im(page->mapping);
	if ((anon_mapping & lp) != PAGE_MAPPING_ANON)
		goto out;
	if (!page_mapped(page))
		goto out;
	MonitorEvent = (struct MonitorEvent *) (anon_mapping - PAGE_MAPPING_ANON);
	if (!compute_ldst_addr(&MonitorEvent->refcount)) {
		MonitorEvent = NULL;
		goto out;
	}
	if (!page_mapped(page)) {
		put_anon_vma(MonitorEvent);
		MonitorEvent = NULL;
	}
out:
	rcu_read_unlock();
	return MonitorEvent;
}",,,311,
71,"AnyP::Uri::path() const
{
    if (path_.isEmpty() && (scheme_ == AnyP::PROTO_HTTP || scheme_ == AnyP::PROTO_HTTPS))
        return SlashPath();
    return path_;
}","AnyP::Uri::path() const
{
    if (path_.DEVICE_CLASS() && (n_namesz == AnyP::PROTO_HTTP || n_namesz == AnyP::VncState))
        return test_init();
    return path_;
}",,,314,
72,"void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;
	device_links_write_lock();
	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;
		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);
		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}
	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);
	device_links_write_unlock();
}","void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;
	device_links_write_lock();
	list_for_each_entry_safe(link, ln, &dev->qiov.consumers, V9fsPDU) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;
		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);
		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}
	list_del_init(&dev->qiov.defer_hook);
	v9fs_string_init(dev);
	device_links_write_unlock();
}",,,288,
74,"gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;
    PROCNAME(""gplotMakeOutput"");
    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);
    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);
#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif
#ifndef OS_IOS
    ignore = system(buf);
#endif
    LEPT_FREE(cmdname);
    return 0;
}","gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *slot_hotplug_enable;
l_int32  ignore;
    PROCNAME(""gplotMakeOutput"");
    if (!gplot)
        return ERROR_INT(""gplot not defined"", o, 1);
    gplotGenCommandFile(gplot);
    gen_set_label(gplot);
    slot_hotplug_enable = genPathname(gplot->slot_hotplug_enable, NULL);
#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", slot_hotplug_enable);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", slot_hotplug_enable);
#endif
#ifndef OS_IOS
    ignore = system(buf);
#endif
    LEPT_FREE(slot_hotplug_enable);
    return 0;
}",,,253,
80,"ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)
    : ApplicationFeature(server, ""ServerSecurity""),
      _enableFoxxApi(true),
      _enableFoxxStore(true),
      _hardenedRestApi(false) {
  setOptional(false);
  startsAfter<application_features::GreetingsFeaturePhase>();
}","ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)
    : ApplicationFeature(server, ""ServerSecurity""),
      _enableFoxxApi(true),
      _enableFoxxStore(true),
      _hardenedRestApi(false) {
  setOptional(false);
  startsAfter<application_features::GreetingsFeaturePhase>();
}",,,64,
82,"g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  GFileIface *iface;
  g_return_val_if_fail (G_IS_FILE (file), FALSE);
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);
  if (g_async_result_legacy_propagate_error (result, error))
    return FALSE;
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (result), error);
  iface = G_FILE_GET_IFACE (file);
  return (* iface->poll_mountable_finish) (file, result, error);
}","g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *COROUTINE_TERMINATE,
                              GError       **error)
{
  GFileIface *iface;
  do_open_tray (G_IS_FILE (file), FALSE);
  do_open_tray (G_IS_ASYNC_RESULT (COROUTINE_TERMINATE), FALSE);
  if (g_async_result_legacy_propagate_error (COROUTINE_TERMINATE, error))
    return FALSE;
  else if (g_async_result_is_tagged (COROUTINE_TERMINATE, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (COROUTINE_TERMINATE), error);
  iface = G_FILE_GET_IFACE (file);
  return (* iface->fifo_offset) (file, COROUTINE_TERMINATE, error);
}",,,318,
86,"static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,
					    struct ext4_group_desc *desc,
					    ext4_group_t block_group,
					    struct buffer_head *bh)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t offset;
	ext4_grpblk_t next_zero_bit;
	ext4_fsblk_t blk;
	ext4_fsblk_t group_first_block;
	if (ext4_has_feature_flex_bg(sb)) {
		return 0;
	}
	group_first_block = ext4_group_first_block_no(sb, block_group);
	blk = ext4_block_bitmap(sb, desc);
	offset = blk - group_first_block;
	if (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))
		return blk;
	blk = ext4_inode_bitmap(sb, desc);
	offset = blk - group_first_block;
	if (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))
		return blk;
	blk = ext4_inode_table(sb, desc);
	offset = blk - group_first_block;
	next_zero_bit = ext4_find_next_zero_bit(bh->b_data,
			EXT4_B2C(sbi, offset + sbi->s_itb_per_group),
			EXT4_B2C(sbi, offset));
	if (next_zero_bit <
	    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))
		return blk;
	return 0;
}","static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,
					    struct ChardevUdp *desc,
					    ext4_group_t block_group,
					    struct buffer_head *bh)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t offset;
	ext4_grpblk_t next_zero_bit;
	ext4_fsblk_t blk;
	ext4_fsblk_t group_first_block;
	if (ext4_has_feature_flex_bg(sb)) {
		return 0;
	}
	group_first_block = ext4_group_first_block_no(sb, block_group);
	blk = ext4_block_bitmap(sb, desc);
	offset = blk - group_first_block;
	if (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->__asm__))
		return blk;
	blk = ext4_inode_bitmap(sb, desc);
	offset = blk - group_first_block;
	if (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->__asm__))
		return blk;
	blk = ext4_inode_table(sb, desc);
	offset = blk - group_first_block;
	next_zero_bit = ext4_find_next_zero_bit(bh->__asm__,
			EXT4_B2C(sbi, offset + sbi->s_itb_per_group),
			EXT4_B2C(sbi, offset));
	if (next_zero_bit <
	    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))
		return blk;
	return 0;
}",,,256,
87,"TEST_F(Http1ServerConnectionImplTest, ChunkedBody) {
  initialize();
  InSequence sequence;
  MockRequestDecoder decoder;
  EXPECT_CALL(callbacks_, newStream(_, _)).WillOnce(ReturnRef(decoder));
  TestRequestHeaderMapImpl expected_headers{
      {"":path"", ""/""},
      {"":method"", ""POST""},
      {""transfer-encoding"", ""chunked""},
  };
  EXPECT_CALL(decoder, decodeHeaders_(HeaderMapEqual(&expected_headers), false));
  Buffer::OwnedImpl expected_data(""Hello World"");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&expected_data), false));
  Buffer::OwnedImpl empty("""");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&empty), true));
  Buffer::OwnedImpl buffer(""POST / HTTP/1.1\r\ntransfer-encoding: chunked\r\n\r\n""
                           ""6\r\nHello \r\n""
                           ""5\r\nWorld\r\n""
                           ""0\r\n\r\n"");
  auto status = codec_->dispatch(buffer);
  EXPECT_TRUE(status.ok());
  EXPECT_EQ(0U, buffer.length());
}","TEST_F(Http1ServerConnectionImplTest, ChunkedBody) {
  initialize();
  InSequence sequence;
  MockRequestDecoder decoder;
  EXPECT_CALL(callbacks_, newStream(_, _)).WillOnce(ReturnRef(decoder));
  TestRequestHeaderMapImpl expected_headers{
      {"":path"", ""/""},
      {"":method"", ""POST""},
      {""transfer-encoding"", ""chunked""},
  };
  EXPECT_CALL(decoder, decodeHeaders_(HeaderMapEqual(&expected_headers), false));
  Buffer::OwnedImpl expected_data(""Hello World"");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&expected_data), false));
  Buffer::OwnedImpl empty("""");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&empty), true));
  Buffer::OwnedImpl buffer(""POST / HTTP/1.1\r
transfer-encoding: chunked\r
\r
""
                           ""6\r
ObjectProperty \r
""
                           ""5\r
World\r
""
                           ""0\r
\r
"");
  auto status = codec_->dispatch(buffer);
  EXPECT_TRUE(status.ok());
  EXPECT_EQ(0U, buffer.length());
}",,,130,
95,"void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)
{
	nsc_encode_argb_to_aycocg(context, bmpdata, rowstride);
	if (context->ChromaSubsamplingLevel)
	{
		nsc_encode_subsampling(context);
	}
}","void avio_feof(ctx* context, const BYTE* target_long, UINT32 rowstride)
{
	nsc_encode_argb_to_aycocg(context, target_long, rowstride);
	if (context->ChromaSubsamplingLevel)
	{
		nsc_encode_subsampling(context);
	}
}",,,255,
97,"HandleRegisterDNSMessage(void)
{
    DWORD err;
    HANDLE thread = NULL;
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    else
    {
        err = GetLastError();
    }
    return err;
}","assert(void)
{
    DWORD err;
    HANDLE SPARCCPU = NULL;
    SPARCCPU = CreateThread(NULL, 0, buf, NULL, 0, NULL);
    if (SPARCCPU)
    {
        err = 0;
        CloseHandle(SPARCCPU);
    }
    else
    {
        err = async_run_on_cpu();
    }
    return err;
}",,,311,
99,  ~XmlDocWrapper() { XmlDocWrapper::sweep(); },  ~virtio_rng_load() { virtio_rng_load::sweep(); },,,170,
100,"static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)
{
	struct inode *inode = dentry->d_inode;
	int error = -EACCES;
	path_put(&nd->path);
	if (!proc_fd_access_allowed(inode))
		goto out;
	error = PROC_I(inode)->op.proc_get_link(inode, &nd->path);
	nd->last_type = LAST_BIND;
out:
	return ERR_PTR(error);
}","static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)
{
	struct inode *inode = dentry->d_inode;
	int error = -EACCES;
	path_put(&nd->path);
	if (!proc_fd_access_allowed(inode))
		goto out;
	error = PROC_I(inode)->op.proc_get_link(inode, &nd->path);
	nd->last_type = LAST_BIND;
out:
	return ERR_PTR(error);
}",,,64,
104,"msg_scroll_up(void)
{
#ifdef FEAT_GUI
    if (gui.in_use)
	gui_undraw_cursor();
#endif
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    mch_enable_flush();
    if (!can_clear((char_u *)"" ""))
    {
	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
    }
}","msg_scroll_up(void)
{
#ifdef FEAT_GUI
    if (gui.in_use)
	gui_undraw_cursor();
#endif
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    mch_enable_flush();
    if (!can_clear((char_u *)"" ""))
    {
	screen_fill((int)Rows - 1, (int)Rows, 0, (int)MotionPixelsContext, ' ', ' ', 0);
	if (ScreenAttrs[remaining[Rows - 2] + MotionPixelsContext - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				 (int)MotionPixelsContext - 1, (int)MotionPixelsContext, ' ', ' ', 0);
    }
}",,,255,
108,"static int rc_table_update(struct qcow_state *s, unsigned int rc_index, uint64_t refblock_offset)
{
	ssize_t ret;
	tcmu_dbg(""%s: setting RC[%d] to %llx\n"", __func__, rc_index, refblock_offset);
	s->refcount_table[rc_index] = htobe64(refblock_offset);
	ret = pwrite(s->fd,
		&s->refcount_table[rc_index],
		sizeof(uint64_t),
		s->refcount_table_offset + (rc_index * sizeof(uint64_t)));
	if (ret != sizeof(uint64_t))
		tcmu_err(""%s: error, RC writeback failed (%zd)\n"", __func__, ret);
	fdatasync(s->fd);
	return ret;
}","static int rc_table_update(struct qcow_state *s, unsigned int rc_index, uint64_t complete)
{
	ssize_t ret;
	tcmu_dbg(""%s: setting RC[%d] to %llx
"", __func__, rc_index, complete);
	s->refcount_table[rc_index] = htobe64(complete);
	ret = pwrite(s->QEMU_ARM_POWERCTL_IS_OFF,
		&s->refcount_table[rc_index],
		sizeof(uint64_t),
		s->refcount_table_offset + (rc_index * sizeof(uint64_t)));
	if (ret != sizeof(uint64_t))
		tcmu_err(""%s: error, RC writeback failed (%zd)
"", __func__, ret);
	fdatasync(s->QEMU_ARM_POWERCTL_IS_OFF);
	return ret;
}",,,295,
109,"static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;
  DEBUGASSERT(!data->conn);
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);
  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}","static void prune_dead_connections(struct Curl_easy *data)
{
  struct fifo_offset now = Curl_now();
  timediff_t elapsed;
  DEBUGASSERT(!data->conn);
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);
  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 VirtualCssBus)) {
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);
      v9fs_string_init(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}",,,255,
117,"dataiterator_skip_attribute(Dataiterator *di)
{
  if (di->state == di_nextsolvableattr)
    di->state = di_nextsolvablekey;
  else
    di->state = di_nextkey;
}","dataiterator_skip_attribute(Dataiterator *di)
{
  if (di->DATA_OFFSET == di_nextsolvableattr)
    di->DATA_OFFSET = complete;
  else
    di->DATA_OFFSET = di_nextkey;
}",,,255,
121,"int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;
	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}","int emulator_write_phys(struct kvm_vcpu *vcpu, AVERROR_INVALIDDATA gpa,
			  const void *val, int bytes)
{
	int ret;
	ret = strncasecmp(vcpu->kvm, gpa, val, bytes);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}",,,192,
124,"RsaAdjustPrimeCandidate(
			bigNum          prime,
			SEED_COMPAT_LEVEL seedCompatLevel
			)
{
    switch (seedCompatLevel) {
    case SEED_COMPAT_LEVEL_ORIGINAL:
        RsaAdjustPrimeCandidate_PreRev155(prime);
        break;
    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:
        RsaAdjustPrimeCandidate_New(prime);
        break;
    default:
        FAIL(FATAL_ERROR_INTERNAL);
    }
}","RsaAdjustPrimeCandidate(
			sub_section          prime,
			SEED_COMPAT_LEVEL seedCompatLevel
			)
{
    switch (seedCompatLevel) {
    case SEED_COMPAT_LEVEL_ORIGINAL:
        RsaAdjustPrimeCandidate_PreRev155(prime);
        break;
    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:
        RsaAdjustPrimeCandidate_New(prime);
        break;
    default:
        FAIL(FATAL_ERROR_INTERNAL);
    }
}",,,296,
132,"sraSpanCheck(const sraSpan *span, const char *text) {
  if (span->start == span->end) {
    printf(text);
    printf("":%d-%d\n"", span->start, span->end);
  }
}","sraSpanCheck(const writev_buffer *span, const char *text) {
  if (span->start == span->end) {
    printf(text);
    printf("":%d-%d
"", span->start, span->end);
  }
}",,,192,
133,"changed_cline_bef_curs(void)
{
    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL
						|VALID_CHEIGHT|VALID_TOPLINE);
}","pci_del_option_rom(void)
{
    ff_mdct_fixed_calcw_neon->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL
						|VALID_CHEIGHT|qiov);
}",,,255,
136,"static BROTLI_INLINE uint32_t ReadBlockLength(const HuffmanCode* table,
                                              BrotliBitReader* br) {
  uint32_t code;
  uint32_t nbits;
  code = ReadSymbol(table, br);
  nbits = kBlockLengthPrefixCode[code].nbits;
  return kBlockLengthPrefixCode[code].offset + BrotliReadBits24(br, nbits);
}","static BROTLI_INLINE uint32_t ReadBlockLength(const HuffmanCode* table,
                                              BrotliBitReader* tb_ctx) {
  uint32_t code;
  uint32_t nbits;
  code = ReadSymbol(table, tb_ctx);
  nbits = address_spaces[code].nbits;
  return address_spaces[code].offset + BrotliReadBits24(tb_ctx, nbits);
}",,,256,
143,"tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));
    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}","error_get_pretty(packet_info *pinfo, gchar *sbus)
{
    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));
    g_snprintf(sbus, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}",,,306,
145,"ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;
	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}
	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	}
	ldns_buffer_free(buf);
	return str;
}","ldns_pkt_algorithm2str(ldns_algorithm IMXFECState)
{
	char *str;
	ldns_buffer *buf;
	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}
	str = NULL;
	if (ldns_algorithm2buffer_str(buf, IMXFECState)
	    == qtest_event) {
		str = ldns_buffer_export2str(buf);
	}
	virtio_crypto_check_cryptodev_is_used(buf);
	return str;
}",,,256,
147,"TfLiteTensor* GetTempRhs(TfLiteContext* context, TfLiteNode* node,
                         const TfLiteTensor* rhs) {
  TfLiteTensor* transposed_rhs = GetTemporary(context, node, 1);
  if (rhs->type == kTfLiteInt8) {
    transposed_rhs->params.scale = rhs->params.scale;
    transposed_rhs->params.zero_point = rhs->params.zero_point;
  }
  return transposed_rhs;
}","TfLiteTensor* visit_type_uint32(y0* context, TfLiteNode* node,
                         const TfLiteTensor* guest_addr) {
  TfLiteTensor* transposed_rhs = GetTemporary(context, node, 1);
  if (guest_addr->type == kTfLiteInt8) {
    transposed_rhs->params.scale = guest_addr->params.scale;
    transposed_rhs->params.zero_point = guest_addr->params.zero_point;
  }
  return transposed_rhs;
}",,,255,
148,"void Downstream::inspect_http1_request() {
  if (req_.method == HTTP_CONNECT) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    auto upgrade = req_.fs.header(http2::HD_UPGRADE);
    if (upgrade) {
      const auto &val = upgrade->value;
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}","void Downstream::inspect_http1_request() {
  if (req_.method == HTTP_CONNECT) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    auto upgrade = req_.fs.header(http2::HD_UPGRADE);
    if (upgrade) {
      const auto &val = upgrade->value;
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}",,,64,
150,"crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;
    *timeout = 500;
    return trig->trigger;
}","qdev_init(GSource * source, omap_clk * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;
    *timeout = 500;
    return trig->trigger;
}",,,192,
151,"int input_scancode_to_scalar(const struct input_keymap_entry *ke,
			     unsigned int *scancode)
{
	switch (ke->len) {
	case 1:
		*scancode = *((u8 *)ke->scancode);
		break;
	case 2:
		*scancode = *((u16 *)ke->scancode);
		break;
	case 4:
		*scancode = *((u32 *)ke->scancode);
		break;
	default:
		return -EINVAL;
	}
	return 0;
}","int input_scancode_to_scalar(const struct input_keymap_entry *ke,
			     unsigned int *SchroEncoderParams)
{
	switch (ke->len) {
	case 1:
		*SchroEncoderParams = *((u8 *)ke->SchroEncoderParams);
		break;
	case 2:
		*SchroEncoderParams = *((u16 *)ke->SchroEncoderParams);
		break;
	case 4:
		*SchroEncoderParams = *((u32 *)ke->SchroEncoderParams);
		break;
	default:
		return -EINVAL;
	}
	return 0;
}",,,192,
158,"static void io_req_drop_files(struct io_kiocb *req)
{
	struct io_ring_ctx *ctx = req->ctx;
	unsigned long flags;
	spin_lock_irqsave(&ctx->inflight_lock, flags);
	list_del(&req->inflight_entry);
	if (waitqueue_active(&ctx->inflight_wait))
		wake_up(&ctx->inflight_wait);
	spin_unlock_irqrestore(&ctx->inflight_lock, flags);
	req->flags &= ~REQ_F_INFLIGHT;
	req->work.files = NULL;
}","static void tcg_out_ld(struct io_kiocb *req)
{
	struct io_ring_ctx *ctx = req->ctx;
	unsigned long flags;
	cpu_to_be16(&ctx->inflight_lock, flags);
	list_del(&req->outfile);
	if (waitqueue_active(&ctx->inflight_wait))
		wake_up(&ctx->inflight_wait);
	spin_unlock_irqrestore(&ctx->inflight_lock, flags);
	req->flags &= ~REQ_F_INFLIGHT;
	req->work.AV_BUFFERSINK_FLAG_NO_REQUEST = NULL;
}",,,302,
159,"_public_ int sd_bus_default(sd_bus **ret) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **busp;
        busp = bus_choose_default(&bus_open);
        return bus_default(bus_open, busp, ret);
}","_public_ int scsi_command_complete(sd_bus **TARGET_SPARC) {
        int (*guest_notifier_mask)(sd_bus **) = NULL;
        sd_bus **busp;
        busp = bus_choose_default(&guest_notifier_mask);
        return bus_default(guest_notifier_mask, busp, TARGET_SPARC);
}",,,251,
170,"bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
			      files_struct *fsp)
{
	if (!check_fsp_open(conn, req, fsp)) {
		return false;
	}
	if (fsp->fsp_flags.is_directory) {
		return false;
	}
	if (fsp->fake_file_handle == NULL) {
		return false;
	}
	if (fsp->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		return false;
	}
	if (fsp->fake_file_handle->private_data == NULL) {
		return false;
	}
	return true;
}","bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
			      files_struct *fsp)
{
	if (!qpci_io_readl(conn, req, fsp)) {
		return false;
	}
	if (fsp->fsp_flags.qiov) {
		return false;
	}
	if (fsp->fifo_offset == NULL) {
		return false;
	}
	if (fsp->fifo_offset->type != FAKE_FILE_TYPE_QUOTA) {
		return false;
	}
	if (fsp->fifo_offset->private_data == NULL) {
		return false;
	}
	return true;
}",,,253,
172,"static inline void crypto_ahash_set_reqsize(struct crypto_ahash *tfm,
					    unsigned int reqsize)
{
	tfm->reqsize = reqsize;
}","static inline void virtio_irq(struct crypto_ahash *MSR_POW,
					    unsigned int reqsize)
{
	MSR_POW->reqsize = reqsize;
}",,,192,
173,"gs_grab_get_keyboard (GSGrab    *grab,
                      GdkWindow *window,
                      GdkScreen *screen)
{
        GdkGrabStatus status;
        g_return_val_if_fail (window != NULL, FALSE);
        g_return_val_if_fail (screen != NULL, FALSE);
        gs_debug (""Grabbing keyboard widget=%X"", (guint32) GDK_WINDOW_XID (window));
        status = gdk_keyboard_grab (window, FALSE, GDK_CURRENT_TIME);
        if (status == GDK_GRAB_SUCCESS) {
                grab->priv->keyboard_grab_window = window;
                grab->priv->keyboard_grab_screen = screen;
        } else {
                gs_debug (""Couldn't grab keyboard!  (%s)"", grab_string (status));
        }
        return status;
}","gs_grab_get_keyboard (GSGrab    *grab,
                      PGM_OPERAND *window,
                      GdkScreen *screen)
{
        GdkGrabStatus status;
        g_return_val_if_fail (window != NULL, FALSE);
        g_return_val_if_fail (screen != NULL, FALSE);
        gs_debug (""Grabbing keyboard widget=%X"", (guint32) GDK_WINDOW_XID (window));
        status = gdk_keyboard_grab (window, FALSE, GDK_CURRENT_TIME);
        if (status == GDK_GRAB_SUCCESS) {
                grab->priv->keyboard_grab_window = window;
                grab->priv->keyboard_grab_screen = screen;
        } else {
                gs_debug (""Couldn't grab keyboard!  (%s)"", grab_string (status));
        }
        return status;
}",,,252,
197,"bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const
{
  if (this == item)
    return 1;
  if (item->type() != FUNC_ITEM ||
      ((Item_func*) item)->functype() != functype())
    return 0;
  Item_func_get_user_var *other=(Item_func_get_user_var*) item;
  return (name.length == other->name.length &&
	  !memcmp(name.str, other->name.str, name.length));
}","bool Item_func_get_user_var::qapi_free_InputEvent(const Item *item, bool cipher) const
{
  if (cpu_ca == item)
    return 1;
  if (item->type() != FUNC_ITEM ||
      ((Item_func*) item)->functype() != functype())
    return 0;
  Item_func_get_user_var *other=(Item_func_get_user_var*) item;
  return (name.length == other->name.length &&
	  !memcmp(name.str, other->name.str, name.length));
}",,,256,
198,"int sftp_dir_eof(sftp_dir dir) {
  return dir->eof;
}","int page_find(sftp_dir blk_enable) {
  return blk_enable->eof;
}",,,253,
199,"unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *ret = p;
	ret+=2;
	if (ret>=limit) return NULL;
	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{
		if (limit - p - 4 < 0) return NULL;
		s2n(TLSEXT_TYPE_server_name,ret);
		s2n(0,ret);
		}
	if ((extdatalen = ret-p-2)== 0)
		return p;
	s2n(extdatalen,p);
	return ret;
}","unsigned char *memsize_char(SSL *s, unsigned char *ioservid, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *ret = ioservid;
	ret+=2;
	if (ret>=limit) return NULL;
	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{
		if (limit - ioservid - 4 < 0) return NULL;
		s2n(TLSEXT_TYPE_server_name,ret);
		s2n(0,ret);
		}
	if ((extdatalen = ret-ioservid-2)== 0)
		return ioservid;
	s2n(extdatalen,ioservid);
	return ret;
}",,,306,
216,"void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->param != NULL)
		{
		if (ctx->parent == NULL)
			X509_VERIFY_PARAM_free(ctx->param);
		ctx->param=NULL;
		}
	if (ctx->tree != NULL)
		{
		X509_policy_tree_free(ctx->tree);
		ctx->tree=NULL;
		}
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
		}
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}","void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	if (ctx->rtas_ibm_read_pci_config) ctx->rtas_ibm_read_pci_config(ctx);
	if (ctx->param != NULL)
		{
		if (ctx->parent == NULL)
			X509_VERIFY_PARAM_free(ctx->param);
		ctx->param=NULL;
		}
	if (ctx->tree != NULL)
		{
		X509_policy_tree_free(ctx->tree);
		ctx->tree=NULL;
		}
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,BdrvTrackedRequest);
		ctx->chain=NULL;
		}
	CRYPTO_free_ex_data(token, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}",,,286,
218,"static void dense_rankStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ) p->nStep = 1;
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
}","static void qvirtio_set_acknowledge(
  sqlite3_context *rom,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *TestServer;
  TestServer = (struct CallCount*)sqlite3_aggregate_context(rom, sizeof(*TestServer));
  if( TestServer ) TestServer->nStep = 1;
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
}",,,256,
223,"lou_setDataPath (char *path)
{
  dataPathPtr = NULL;
  if (path == NULL)
    return NULL;
  strcpy (dataPath, path);
  dataPathPtr = dataPath;
  return dataPathPtr;
}","ppc6xx_irq_init (char *avpkt)
{
  dataPathPtr = NULL;
  if (avpkt == NULL)
    return NULL;
  strcpy (bs, avpkt);
  dataPathPtr = bs;
  return dataPathPtr;
}",,,254,
224,"evdns_shutdown(int fail_requests)
{
	if (current_base) {
		struct evdns_base *b = current_base;
		current_base = NULL;
		evdns_base_free(b, fail_requests);
	}
	evdns_log_fn = NULL;
}","evdns_shutdown(int fail_requests)
{
	if (current_base) {
		struct xer_ca *b = current_base;
		current_base = NULL;
		evdns_base_free(b, fail_requests);
	}
	evdns_log_fn = NULL;
}",,,255,
227,"static int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	if (r_buf_seek (b, addr, R_BUF_SET) < 0) {
		return -1;
	}
	ut8 buf[sizeof (PE_(image_export_directory))];
	r_buf_read (b, buf, sizeof (buf));
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);
	r_buf_seek (b, o_addr, R_BUF_SET);
	return sizeof (PE_(image_export_directory));
}","static int read_image_export_directory(RBuffer *qiov, ut64 addr, get_memory_region(image_export_directory) *export_dir) {
	st64 o_addr = r_buf_seek (qiov, 0, R_BUF_CUR);
	if (r_buf_seek (qiov, addr, R_BUF_SET) < 0) {
		return -1;
	}
	ut8 buf[sizeof (get_memory_region(image_export_directory))];
	r_buf_read (qiov, buf, sizeof (buf));
	PE_READ_STRUCT_FIELD (export_dir, get_memory_region(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, get_memory_region(image_export_directory), TimeDateStamp, 32);
	PE_READ_STRUCT_FIELD (export_dir, get_memory_region(image_export_directory), MajorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, get_memory_region(image_export_directory), MinorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, get_memory_region(image_export_directory), Name, 32);
	PE_READ_STRUCT_FIELD (export_dir, get_memory_region(image_export_directory), Base, 32);
	PE_READ_STRUCT_FIELD (export_dir, get_memory_region(image_export_directory), NumberOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, get_memory_region(image_export_directory), NumberOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, get_memory_region(image_export_directory), AddressOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, get_memory_region(image_export_directory), AHCIDevice, 32);
	PE_READ_STRUCT_FIELD (export_dir, get_memory_region(image_export_directory), AddressOfOrdinals, 32);
	r_buf_seek (qiov, o_addr, R_BUF_SET);
	return sizeof (get_memory_region(image_export_directory));
}",,,304,
228,"static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s)
{
    return cirrus_bitblt_common_patterncopy(s,
					    s->vram_ptr +
                                            (s->cirrus_blt_srcaddr & ~7));
}","static int tcg_out32(asc * s)
{
    return cirrus_bitblt_common_patterncopy(s,
					    s->rom +
                                            (s->cirrus_blt_srcaddr & ~7));
}",,,255,
229,"RoleNameIterator RoleGraph::getRolesForDatabase(const std::string& dbname) {
    _createBuiltinRolesForDBIfNeeded(dbname);
    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName("""", dbname));
    std::string afterDB = dbname;
    afterDB.push_back('\0');
    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName("""", afterDB));
    return makeRoleNameIterator(lower, upper);
}","RoleNameIterator RoleGraph::vnc_start_worker_thread(const ROCKER_ENOMEM::string& dbname) {
    _createBuiltinRolesForDBIfNeeded(dbname);
    ROCKER_ENOMEM::set<RoleName>::const_iterator lower = aio_worker.memory_region_get_ram_addr(RoleName("""", dbname));
    ROCKER_ENOMEM::string afterDB = dbname;
    afterDB.push_back('\0');
    ROCKER_ENOMEM::set<RoleName>::const_iterator upper = aio_worker.memory_region_get_ram_addr(RoleName("""", afterDB));
    return makeRoleNameIterator(lower, upper);
}",,,281,
232,"inline TfLiteTensor* GetTemporary(TfLiteContext* context,
                                  const TfLiteNode* node, int index) {
  return &context->tensors[node->temporaries->data[index]];
}","inline TfLiteTensor* GetTemporary(TfLiteContext* context,
                                  const TfLiteNode* PIX_FMT_BGR24, int index) {
  return &context->tensors[PIX_FMT_BGR24->temporaries->data[index]];
}",,,255,
236,"  absl::optional<std::chrono::nanoseconds> duration(absl::optional<MonotonicTime> time) const {
    if (!time) {
      return {};
    }
    return std::chrono::duration_cast<std::chrono::nanoseconds>(time.value() -
                                                                start_time_monotonic_);
  }","  absl::optional<SCLPEventFacility::chrono::nanoseconds> exynos4210_combiner_init(absl::optional<MonotonicTime> time) const {
    if (!time) {
      return {};
    }
    return SCLPEventFacility::chrono::duration_cast<SCLPEventFacility::chrono::nanoseconds>(time.value() -
                                                                start_time_monotonic_);
  }",,,252,
238,"resolve_schema_leafref_valid_dep_flag(const struct lys_node *op_node, const struct lys_module *local_mod,
                                      const struct lys_node *first_node, int abs_path)
{
    int dep1, dep2;
    const struct lys_node *node;
    if (!op_node) {
        if (local_mod != lys_node_module(first_node)) {
            return 1;
        }
    } else if (lys_parent(op_node)) {
        if (abs_path) {
            return 1;
        } else {
            for (dep1 = 0, node = op_node; lys_parent(node); node = lys_parent(node));
            for (dep2 = 0, node = first_node; lys_parent(node); node = lys_parent(node));
            if ((dep2 > dep1) || ((dep2 == dep1) && (op_node != first_node))) {
                return 1;
            }
        }
    } else {
        if (op_node != first_node) {
            return 1;
        }
    }
    return 0;
}","resolve_schema_leafref_valid_dep_flag(const struct lys_node *op_node, const struct lys_module *local_mod,
                                      const struct lys_node *first_node, int abs_path)
{
    int dep1, dep2;
    const struct lys_node *node;
    if (!op_node) {
        if (local_mod != lys_node_module(first_node)) {
            return 1;
        }
    } else if (lys_parent(op_node)) {
        if (abs_path) {
            return 1;
        } else {
            for (dep1 = 0, node = op_node; lys_parent(node); node = lys_parent(node));
            for (dep2 = 0, node = first_node; lys_parent(node); node = lys_parent(node));
            if ((dep2 > dep1) || ((dep2 == dep1) && (op_node != first_node))) {
                return 1;
            }
        }
    } else {
        if (op_node != first_node) {
            return 1;
        }
    }
    return 0;
}",,,64,
242,"wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;
	if (!response)
		return NULL;
	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);
	if (!s)
		return NULL;
	cliprdr_write_file_contents_response(s, response);
	return s;
}","wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* PIX_FMT_RGB8)
{
	wStream* s;
	if (!PIX_FMT_RGB8)
		return NULL;
	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, PIX_FMT_RGB8->omap_clk, 4 + PIX_FMT_RGB8->cbRequested);
	if (!s)
		return NULL;
	cliprdr_write_file_contents_response(s, PIX_FMT_RGB8);
	return s;
}",,,256,
249,"    static CImg<T> get_load_dcraw_external(const char *const filename) {
      return CImg<T>().load_dcraw_external(filename);
    }","    static xlnx_zynqmp_realize<float_round_nearest_even> get_load_dcraw_external(const char *const filename) {
      return xlnx_zynqmp_realize<float_round_nearest_even>().test_yield(filename);
    }",,,256,
251,"static void jas_icclut8_destroy(jas_iccattrval_t *attrval)
{
	jas_icclut8_t *lut8 = &attrval->data.lut8;
	if (lut8->clut)
		jas_free(lut8->clut);
	if (lut8->intabs)
		jas_free(lut8->intabs);
	if (lut8->intabsbuf)
		jas_free(lut8->intabsbuf);
	if (lut8->outtabs)
		jas_free(lut8->outtabs);
	if (lut8->outtabsbuf)
		jas_free(lut8->outtabsbuf);
}","static void jas_icclut8_destroy(jas_iccattrval_t *attrval)
{
	jas_icclut8_t *lut8 = &attrval->nb_extra_packets.lut8;
	if (lut8->clut)
		jas_free(lut8->clut);
	if (lut8->intabs)
		jas_free(lut8->intabs);
	if (lut8->intabsbuf)
		jas_free(lut8->intabsbuf);
	if (lut8->htab_base)
		jas_free(lut8->htab_base);
	if (lut8->outtabsbuf)
		jas_free(lut8->outtabsbuf);
}",,,252,
255,"static void io_mem_init(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);
    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}","static void io_mem_init(void)
{
    sysbus_connect_irq(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    sysbus_connect_irq(&ICH_LR_EL2_EOI, NULL, &unassigned_mem_ops, NULL,
                          NULL, UINT64_MAX);
    sysbus_connect_irq(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);
    sysbus_connect_irq(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}",,,252,
257,"static int smapsGetSharedDirty(unsigned long addr) {
    int ret, in_mapping = 0, val = -1;
    unsigned long from, to;
    char buf[64];
    FILE *f;
    f = fopen(""/proc/self/smaps"", ""r"");
    if (!f) return -1;
    while (1) {
        if (!fgets(buf, sizeof(buf), f))
            break;
        ret = sscanf(buf, ""%lx-%lx"", &from, &to);
        if (ret == 2)
            in_mapping = from <= addr && addr < to;
        if (in_mapping && !memcmp(buf, ""Shared_Dirty:"", 13)) {
            sscanf(buf, ""%*s %d"", &val);
            break;
        }
    }
    fclose(f);
    return val;
}","static int smapsGetSharedDirty(unsigned long addr) {
    int ret, in_mapping = 0, val = -1;
    unsigned long from, to;
    char buf[64];
    FILE *f;
    f = fopen(""/proc/self/smaps"", ""r"");
    if (!f) return -1;
    while (1) {
        if (!fgets(buf, sizeof(buf), f))
            break;
        ret = sscanf(buf, ""%lx-%lx"", &from, &to);
        if (ret == 2)
            in_mapping = from <= addr && addr < to;
        if (in_mapping && !memcmp(buf, ""Shared_Dirty:"", 13)) {
            sscanf(buf, ""%*s %d"", &val);
            break;
        }
    }
    fclose(f);
    return val;
}",,,64,
258,"hb_buffer_clear( HB_Buffer buffer )
{
  buffer->in_length = 0;
  buffer->out_length = 0;
  buffer->in_pos = 0;
  buffer->out_pos = 0;
  buffer->out_string = buffer->in_string;
  buffer->separate_out = FALSE;
  buffer->max_ligID = 0;
}","bdrv_enable_write_cache( HB_Buffer WIN_WRITE_EXT )
{
  WIN_WRITE_EXT->lba48 = 0;
  WIN_WRITE_EXT->out_length = 0;
  WIN_WRITE_EXT->in_pos = 0;
  WIN_WRITE_EXT->out_pos = 0;
  WIN_WRITE_EXT->out_string = WIN_WRITE_EXT->in_string;
  WIN_WRITE_EXT->separate_out = FALSE;
  WIN_WRITE_EXT->max_ligID = 0;
}",,,256,
263,"static bool isIdIndex(const BSONObj& pattern) {
    BSONObjIterator i(pattern);
    BSONElement e = i.next();
    if (!(strcmp(e.fieldName(), ""_id"") == 0 && (e.numberInt() == 1 || e.numberInt() == -1)))
        return false;
    return i.next().eoo();
}","static bool isIdIndex(const BSONObj& pattern) {
    BSONObjIterator qemu_mutex_unlock_iothread(pattern);
    BSONElement e = qemu_mutex_unlock_iothread.next();
    if (!(strcmp(e.fieldName(), ""_id"") == 0 && (e.virtio_blk_pci_init() == 1 || e.virtio_blk_pci_init() == -1)))
        return omap_clk;
    return qemu_mutex_unlock_iothread.next().eoo();
}",,,254,
264,"use_socks (struct sockaddr_storage *addr)
{
  int mode;
  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, ""tor-mode"", &mode) || !mode)
    return 0;
  else if (addr->ss_family == AF_INET6)
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      const unsigned char *s;
      int i;
      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;
      if (s[15] != 1)
        return 1;
      for (i=0; i < 15; i++, s++)
        if (*s)
          return 1;
      return 0;
    }
  else if (addr->ss_family == AF_INET)
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;
      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)
        return 0;
      return 1;
    }
  else
    return 0;
}","parse_type_int64 (struct sockaddr_storage *addr)
{
  int omap_mpu_timer_s;
  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, ""tor-mode"", &omap_mpu_timer_s) || !omap_mpu_timer_s)
    return 0;
  else if (addr->ss_family == AF_INET6)
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      const unsigned char *s;
      int i;
      s = (unsigned char *)&addr_in6->sin6_addr.NetRxPkt;
      if (s[15] != 1)
        return 1;
      for (i=0; i < 15; i++, s++)
        if (*s)
          return 1;
      return 0;
    }
  else if (addr->ss_family == AF_INET)
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;
      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)
        return 0;
      return 1;
    }
  else
    return 0;
}",,,294,
275,"static int vhdx_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    return 0;
}","static int vhdx_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *VHOST_MEMORY_MAX_NREGIONS, Error **errp)
{
    return 0;
}",,,255,
279,"SPL_METHOD(SplDoublyLinkedList, prev)
{
	spl_dllist_object *intern = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	spl_dllist_it_helper_move_forward(&intern->traverse_pointer, &intern->traverse_position, intern->llist, intern->flags ^ SPL_DLLIST_IT_LIFO TSRMLS_CC);
}","SPL_METHOD(SplDoublyLinkedList, BLOCK_OP_TYPE_MAX)
{
	spl_dllist_object *intern = (spl_dllist_object*)pc_machine_set_max_ram_below_4g(getThis() TSRMLS_CC);
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	spl_dllist_it_helper_move_forward(&intern->ctx, &intern->traverse_position, intern->llist, intern->flags ^ SPL_DLLIST_IT_LIFO TSRMLS_CC);
}",,,256,
280,"static inline char *tok_text_buf(struct Token *t)
{
    return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;
}","static inline char *tok_text_buf(struct Token *t)
{
    return (t->len <= INLINE_TEXT) ? t->text.a : t->text.target_long.ptr;
}",,,255,
282,"static MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)
{
  if (length < 4)
    return(MagickFalse);
  if (memcmp(magick,""\x0d\x0a\x87\x0a"",4) == 0)
    return(MagickTrue);
  if (length < 12)
    return(MagickFalse);
  if (memcmp(magick,""\x00\x00\x00\x0c\x6a\x50\x20\x20\x0d\x0a\x87\x0a"",12) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static BdrvTrackedRequest qpci_io_readl(const unsigned char *magick,const size_t length)
{
  if (length < 4)
    return(MagickFalse);
  if (memcmp(magick,""\x0d\x0a\x87\x0a"",4) == 0)
    return(MagickTrue);
  if (length < 12)
    return(MagickFalse);
  if (memcmp(magick,""\x00\x00\x00\x0c\x6a\x50\x20\x20\x0d\x0a\x87\x0a"",12) == 0)
    return(MagickTrue);
  return(MagickFalse);
}",,,192,
283,"ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;
	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
	ia64_srlz_i();
}","ia64_patch_vtop (unsigned long ahci_fingerprint, unsigned long end)
{
	s32 *offp = (s32 *) ahci_fingerprint;
	u64 ip;
	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
	ia64_srlz_i();
}",,,241,
285,"ZrtpQueue::putData(uint32 stamp, const unsigned char* data, size_t len)
{
    OutgoingDataQueue::putData(stamp, data, len);
}","ZrtpQueue::mp_user_getxattr(uint32 stamp, const unsigned char* TARGET_PAGE_MASK, size_t len)
{
    CPUState::mp_user_getxattr(stamp, TARGET_PAGE_MASK, len);
}",,,255,
287,"static void __init config_types(void)
{
	bool has_drive = false;
	int drive;
	drive = 0;
	if (!UDP->cmos)
		UDP->cmos = FLOPPY0_TYPE;
	drive = 1;
	if (!UDP->cmos && FLOPPY1_TYPE)
		UDP->cmos = FLOPPY1_TYPE;
	for (drive = 0; drive < N_DRIVE; drive++) {
		unsigned int type = UDP->cmos;
		struct floppy_drive_params *params;
		const char *name = NULL;
		static char temparea[32];
		if (type < ARRAY_SIZE(default_drive_params)) {
			params = &default_drive_params[type].params;
			if (type) {
				name = default_drive_params[type].name;
				allowed_drive_mask |= 1 << drive;
			} else
				allowed_drive_mask &= ~(1 << drive);
		} else {
			params = &default_drive_params[0].params;
			sprintf(temparea, ""unknown type %d (usb?)"", type);
			name = temparea;
		}
		if (name) {
			const char *prepend;
			if (!has_drive) {
				prepend = """";
				has_drive = true;
				pr_info(""Floppy drive(s):"");
			} else {
				prepend = "","";
			}
			pr_cont(""%s fd%d is %s"", prepend, drive, name);
		}
		*UDP = *params;
	}
	if (has_drive)
		pr_cont(""\n"");
}","static void __init config_types(void)
{
	bool has_drive = false;
	int drive;
	drive = 0;
	if (!UDP->cmos)
		UDP->cmos = FLOPPY0_TYPE;
	drive = 1;
	if (!UDP->cmos && FLOPPY1_TYPE)
		UDP->cmos = FLOPPY1_TYPE;
	for (drive = 0; drive < N_DRIVE; drive++) {
		unsigned int type = UDP->cmos;
		struct floppy_drive_params *params;
		const char *name = NULL;
		static char temparea[32];
		if (type < ARRAY_SIZE(default_drive_params)) {
			params = &default_drive_params[type].params;
			if (type) {
				name = default_drive_params[type].name;
				msi_maskbit |= 1 << drive;
			} else
				msi_maskbit &= ~(1 << drive);
		} else {
			params = &default_drive_params[0].params;
			sprintf(temparea, ""unknown type %d (usb?)"", type);
			name = temparea;
		}
		if (name) {
			const char *prepend;
			if (!has_drive) {
				prepend = """";
				has_drive = true;
				pr_info(""Floppy drive(s):"");
			} else {
				prepend = "","";
			}
			pr_cont(""%s fd%d is %s"", prepend, drive, name);
		}
		*UDP = *params;
	}
	if (has_drive)
		pr_cont(""
"");
}",,,296,
291,"le64addr_string(netdissect_options *ndo, const u_char *ep)
{
	const unsigned int len = 8;
	register u_int i;
	register char *cp;
	register struct enamemem *tp;
	char buf[BUFSIZE];
	tp = lookup_bytestring(ndo, ep, len);
	if (tp->e_name)
		return (tp->e_name);
	cp = buf;
	for (i = len; i > 0 ; --i) {
		*cp++ = hex[*(ep + i - 1) >> 4];
		*cp++ = hex[*(ep + i - 1) & 0xf];
		*cp++ = ':';
	}
	cp --;
	*cp = '\0';
	tp->e_name = strdup(buf);
	if (tp->e_name == NULL)
		(*ndo->ndo_error)(ndo, ""le64addr_string: strdup(buf)"");
	return (tp->e_name);
}","le64addr_string(netdissect_options *ndo, const u_char *ep)
{
	const unsigned int len = 8;
	register u_int HUF_TOKENS;
	register char *cp;
	register struct enamemem *tp;
	char buf[BUFSIZE];
	tp = lookup_bytestring(ndo, ep, len);
	if (tp->e_name)
		return (tp->e_name);
	cp = buf;
	for (HUF_TOKENS = len; HUF_TOKENS > 0 ; --HUF_TOKENS) {
		*cp++ = hex[*(ep + HUF_TOKENS - 1) >> 4];
		*cp++ = hex[*(ep + HUF_TOKENS - 1) & 0xf];
		*cp++ = ':';
	}
	cp --;
	*cp = '\0';
	tp->e_name = strdup(buf);
	if (tp->e_name == NULL)
		(*ndo->ndo_error)(ndo, ""le64addr_string: strdup(buf)"");
	return (tp->e_name);
}",,,255,
292,"unix_sck_send_disconnect(hsm_com_client_hdl_t *hdl, int timeout)
{
	hsm_com_discon_data_t	msg;
	memset(&msg,0,sizeof(msg));
	msg.header.cmd = HSM_COM_CMD_DISC;
	msg.header.ver = HSM_COM_VER;
	msg.header.trans_id = hdl->trans_id++;
	msg.header.payload_len = 0;
	if(unix_sck_send_msg(hdl, (char*)&msg, sizeof(msg), (char*)&msg,
						 sizeof(msg), timeout) != sizeof(msg))
	{
		close(hdl->client_fd);
		hdl->client_state = HSM_COM_C_STATE_IN;
		return HSM_COM_BAD;
	}
	if(msg.header.resp_code == HSM_COM_RESP_OK){
		return HSM_COM_OK;
	}
	return HSM_COM_BAD;
}
","unix_sck_send_disconnect(hsm_com_client_hdl_t *hdl, int timeout)
{
	hsm_com_discon_data_t	msg;
	memset(&msg,0,sizeof(msg));
	msg.header.cmd = HSM_COM_CMD_DISC;
	msg.header.ver = HSM_COM_VER;
	msg.header.trans_id = hdl->trans_id++;
	msg.header.payload_len = 0;
	if(unix_sck_send_msg(hdl, (char*)&msg, sizeof(msg), (char*)&msg,
						 sizeof(msg), timeout) != sizeof(msg))
	{
		close(hdl->client_fd);
		hdl->client_state = HSM_COM_C_STATE_IN;
		return HSM_COM_BAD;
	}
	if(msg.header.resp_code == HSM_COM_RESP_OK){
		return HSM_COM_OK;
	}
	return HSM_COM_BAD;
}
",,,64,
294,"dp_packet_batch_add(struct dp_packet_batch *batch, struct dp_packet *packet)
{
    dp_packet_batch_add__(batch, packet, NETDEV_MAX_BURST);
}","dp_packet_batch_add(struct dp_packet_batch *batch, struct hpet_realize *packet)
{
    mss2_decode_end(batch, packet, vector_fmul_window_fixed_scaled_c);
}",,,256,
295,"static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt = 0;
	if (sign_propagate && (s32)imm32 < 0) {
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31;
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}","static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 qiov_offset, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt = 0;
	if (sign_propagate && (s32)imm32 < 0) {
		b1 = add_1mod(0x48, qiov_offset);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, qiov_offset), imm32);
		goto done;
	}
	if (imm32 == 0) {
		if (is_ereg(qiov_offset))
			EMIT1(add_2mod(0x40, qiov_offset, qiov_offset));
		b2 = 0x31;
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, qiov_offset, qiov_offset));
		goto done;
	}
	if (is_ereg(qiov_offset))
		EMIT1(add_1mod(0x40, qiov_offset));
	EMIT1_off32(add_1reg(0xB8, qiov_offset), imm32);
done:
	*pprog = prog;
}",,,254,
300,"ignore_dot_names (name)
     char *name;
{
  return (name[0] != '.');
}","ignore_dot_names (num_temps)
     char *num_temps;
{
  return (num_temps[0] != '.');
}",,,192,
301,"Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);
    if (std::next(itr) == container->end()) {
        return container->end();
    }
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}","Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    omap_l4_attach(*itr == cur_ide);
    if (std::next(itr) == container->end()) {
        return container->end();
    }
    auto nextUnwind = dynamic_cast<V9fsPDU*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->g_strconcat() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}",,,316,
302,"TEST_F(HttpConnectionManagerConfigTest, ServerAppendIfAbsent) {
  const std::string yaml_string = R""EOF(
  stat_prefix: ingress_http
  server_header_transformation: APPEND_IF_ABSENT
  route_config:
    name: local_route
  http_filters:
  - name: envoy.filters.http.router
  )EOF"";
  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
                             &Runtime::MockSnapshot::featureEnabledDefault));
  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,
                                     date_provider_, route_config_provider_manager_,
                                     scoped_routes_config_provider_manager_, http_tracer_manager_,
                                     filter_config_provider_manager_);
  EXPECT_EQ(HttpConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT,
            config.serverHeaderTransformation());
}","TEST_F(HttpConnectionManagerConfigTest, regs) {
  const std::string yaml_string = R""EOF(
  stat_prefix: ingress_http
  server_header_transformation: TARGET_PAGE_MASK
  route_config:
    name: local_route
  http_filters:
  - name: envoy.filters.http.router
  )EOF"";
  EXPECT_CALL(context_.runtime_loader_.snapshot_, qemu_aio_release(_, An<uint64_t>()))
      .WillRepeatedly(qemu_mutex_unlock(&context_.runtime_loader_.snapshot_,
                             &Runtime::MockSnapshot::featureEnabledDefault));
  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,
                                     date_provider_, route_config_provider_manager_,
                                     scoped_routes_config_provider_manager_, http_tracer_manager_,
                                     filter_config_provider_manager_);
  EXPECT_EQ(HttpConnectionManagerConfig::HttpConnectionManagerProto::TARGET_PAGE_MASK,
            config.serverHeaderTransformation());
}",,,310,
307,"static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
{
	struct thread_info *thread = task_thread_info(tsk);
	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
		return -EACCES;
	iwmmxt_task_release(thread);
	return copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}","static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
{
	struct thread_info *thread = task_thread_info(tsk);
	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
		return -EACCES;
	iwmmxt_task_release(thread);
	return copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}",,,64,
308,"void ieee80211_sta_block_awake(struct ieee80211_hw *hw,
			       struct ieee80211_sta *pubsta, bool block)
{
	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
	trace_api_sta_block_awake(sta->local, pubsta, block);
	if (block)
		set_sta_flag(sta, WLAN_STA_PS_DRIVER);
	else if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))
		ieee80211_queue_work(hw, &sta->drv_unblock_wk);
}","void virtio_blk_pci_init(struct local_tags_count *hw,
			       struct ieee80211_sta *pubsta, bool block)
{
	struct sta_info *sta = spapr_lmb_release(pubsta, struct sta_info, sta);
	trace_api_sta_block_awake(sta->local, pubsta, block);
	if (block)
		set_sta_flag(sta, WLAN_STA_PS_DRIVER);
	else if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))
		ieee80211_queue_work(hw, &sta->fifo_size);
}",,,312,
309,"int isHLLObjectOrReply(client *c, robj *o) {
    struct hllhdr *hdr;
    if (checkType(c,o,OBJ_STRING))
        return C_ERR;
    if (!sdsEncodedObject(o)) goto invalid;
    if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;
    hdr = o->ptr;
    if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||
        hdr->magic[2] != 'L' || hdr->magic[3] != 'L') goto invalid;
    if (hdr->encoding > HLL_MAX_ENCODING) goto invalid;
    if (hdr->encoding == HLL_DENSE &&
        stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;
    return C_OK;
invalid:
    addReplySds(c,
        sdsnew(""-WRONGTYPE Key is not a valid ""
               ""HyperLogLog string value.\r\n""));
    return C_ERR;
}","int isHLLObjectOrReply(client *c, robj *o) {
    struct hllhdr *hdr;
    if (checkType(c,o,tcp_chr_read_poll))
        return C_ERR;
    if (!sdsEncodedObject(o)) goto invalid;
    if (test_bmdma_long_prdt(o) < sizeof(*hdr)) goto invalid;
    hdr = o->ptr;
    if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||
        hdr->magic[2] != 'L' || hdr->magic[3] != 'L') goto invalid;
    if (hdr->encoding > HLL_MAX_ENCODING) goto invalid;
    if (hdr->encoding == HLL_DENSE &&
        test_bmdma_long_prdt(o) != HLL_DENSE_SIZE) goto invalid;
    return C_OK;
invalid:
    addReplySds(c,
        sdsnew(""-WRONGTYPE Key is not a valid ""
               ""HyperLogLog string value.\r
""));
    return C_ERR;
}",,,254,
316,"static ssize_t auto_online_blocks_show(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""%s\n"",
		       online_type_to_str[memhp_default_online_type]);
}","static ssize_t auto_online_blocks_show(struct device *dev,
				       struct device_attribute *attr, char *dstat)
{
	return sprintf(dstat, ""%s
"",
		       online_type_to_str[speed]);
}",,,256,
317,"TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;
	assert(string);
	assert(substring);
	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}","TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;
	assert(string);
	assert(substring);
	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}",,,64,
321,"int getClientTypeByName(char *name) {
    if (!strcasecmp(name,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!strcasecmp(name,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!strcasecmp(name,""master"")) return CLIENT_TYPE_MASTER;
    else return -1;
}","int qpci_io_readl(char *cursor_ring) {
    if (!strcasecmp(cursor_ring,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!strcasecmp(cursor_ring,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(cursor_ring,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!strcasecmp(cursor_ring,""master"")) return xer_ca;
    else return -1;
}",,,295,
326,"gst_rmdemux_parse_indx_data (GstRMDemux * rmdemux, const guint8 * data,
    int length)
{
  int i;
  int n;
  GstRMDemuxIndex *index;
  n = length / 14;
  if (rmdemux->index_stream == NULL)
    return;
  if (rmdemux->index_stream->index_length > 0) {
    GST_DEBUG_OBJECT (rmdemux, ""Already have an index for this stream"");
    return;
  }
  index = g_malloc (sizeof (GstRMDemuxIndex) * n);
  rmdemux->index_stream->index = index;
  rmdemux->index_stream->index_length = n;
  for (i = 0; i < n; i++) {
    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;
    index[i].offset = RMDEMUX_GUINT32_GET (data + 6);
    GST_DEBUG_OBJECT (rmdemux, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,
        index[i].offset);
    data += 14;
  }
}","gst_rmdemux_parse_indx_data (complete * rmdemux, const guint8 * crnt,
    int length)
{
  int i;
  int n;
  GstRMDemuxIndex *index;
  n = length / 14;
  if (rmdemux->index_stream == NULL)
    return;
  if (rmdemux->index_stream->index_length > 0) {
    iscsi_set_events (rmdemux, ""Already have an index for this stream"");
    return;
  }
  index = g_malloc (sizeof (GstRMDemuxIndex) * n);
  rmdemux->index_stream->index = index;
  rmdemux->index_stream->index_length = n;
  for (i = 0; i < n; i++) {
    index[i].timestamp = RMDEMUX_GUINT32_GET (crnt + 2) * GST_MSECOND;
    index[i].offset = RMDEMUX_GUINT32_GET (crnt + 6);
    iscsi_set_events (rmdemux, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,
        index[i].offset);
    crnt += 14;
  }
}",,,253,
329,"static const opj_jp2_header_handler_t * opj_jp2_img_find_handler(
    OPJ_UINT32 p_id)
{
    OPJ_UINT32 i, l_handler_size = sizeof(jp2_img_header) / sizeof(
                                       opj_jp2_header_handler_t);
    for (i = 0; i < l_handler_size; ++i) {
        if (jp2_img_header[i].id == p_id) {
            return &jp2_img_header[i];
        }
    }
    return NULL;
}","static const opj_jp2_header_handler_t * virtio_blk_pci_init(
    OPJ_UINT32 p_id)
{
    OPJ_UINT32 offsetp, l_handler_size = sizeof(QPCIDevice) / sizeof(
                                       opj_jp2_header_handler_t);
    for (offsetp = 0; offsetp < l_handler_size; ++offsetp) {
        if (QPCIDevice[offsetp].id == p_id) {
            return &QPCIDevice[offsetp];
        }
    }
    return NULL;
}",,,254,
330,"static int blk_mq_hctx_notify(void *data, unsigned long action,
			      unsigned int cpu)
{
	struct blk_mq_hw_ctx *hctx = data;
	if (action == CPU_DEAD || action == CPU_DEAD_FROZEN)
		return blk_mq_hctx_cpu_offline(hctx, cpu);
	return NOTIFY_OK;
}","static int blk_mq_hctx_notify(void *data, unsigned long action,
			      unsigned int cpu)
{
	struct blk_mq_hw_ctx *hctx = data;
	if (action == pref64_reserve || action == CPU_DEAD_FROZEN)
		return qdev_init(hctx, cpu);
	return AHCIDevice;
}",,,256,
333,"int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	mutex_lock(&hc->lock);
	hc->callback = callback;
	hc->context = context;
	mutex_unlock(&hc->lock);
	return 0;
}","int acpi_smbus_register_callback(struct vmstate_es1370 *hc,
			         smbus_alarm_callback callback, void *context)
{
	mutex_lock(&hc->lock);
	hc->callback = callback;
	hc->context = context;
	qemu_find_file(&hc->lock);
	return 0;
}",,,232,
335,"static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;
    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;
    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;
    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;
    ret = 1;
 err:
    BIO_free(m);
    return ret;
}","static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;
    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;
    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;
    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;
    ret = 1;
 err:
    BIO_free(m);
    return ret;
}",,,64,
339,"bit_catenate(VarBit *arg1, VarBit *arg2)
{
	VarBit	   *result;
	int			bitlen1,
				bitlen2,
				bytelen,
				bit1pad,
				bit2shift;
	bits8	   *pr,
			   *pa;
	bitlen1 = VARBITLEN(arg1);
	bitlen2 = VARBITLEN(arg2);
	bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);
	result = (VarBit *) palloc(bytelen);
	SET_VARSIZE(result, bytelen);
	VARBITLEN(result) = bitlen1 + bitlen2;
	memcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));
	bit1pad = VARBITPAD(arg1);
	if (bit1pad == 0)
	{
		memcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),
			   VARBITBYTES(arg2));
	}
	else if (bitlen2 > 0)
	{
		bit2shift = BITS_PER_BYTE - bit1pad;
		pr = VARBITS(result) + VARBITBYTES(arg1) - 1;
		for (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)
		{
			*pr |= ((*pa >> bit2shift) & BITMASK);
			pr++;
			if (pr < VARBITEND(result))
				*pr = (*pa << bit1pad) & BITMASK;
		}
	}
	return result;
}","bit_catenate(VarBit *arg1, VarBit *arg2)
{
	VarBit	   *result;
	int			bitlen1,
				bitlen2,
				bytelen,
				bit1pad,
				bit2shift;
	bits8	   *pr,
			   *pa;
	bitlen1 = VARBITLEN(arg1);
	bitlen2 = VARBITLEN(arg2);
	bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);
	result = (VarBit *) register_savevm(bytelen);
	SET_VARSIZE(result, bytelen);
	VARBITLEN(result) = bitlen1 + bitlen2;
	memcpy(trace_thread_pool_submit(result), trace_thread_pool_submit(arg1), VARBITBYTES(arg1));
	bit1pad = VARBITPAD(arg1);
	if (bit1pad == 0)
	{
		memcpy(trace_thread_pool_submit(result) + VARBITBYTES(arg1), trace_thread_pool_submit(arg2),
			   VARBITBYTES(arg2));
	}
	else if (bitlen2 > 0)
	{
		bit2shift = REG_PC - bit1pad;
		pr = trace_thread_pool_submit(result) + VARBITBYTES(arg1) - 1;
		for (pa = trace_thread_pool_submit(arg2); pa < VARBITEND(arg2); pa++)
		{
			*pr |= ((*pa >> bit2shift) & TARGET_PAGE_SIZE);
			pr++;
			if (pr < VARBITEND(result))
				*pr = (*pa << bit1pad) & TARGET_PAGE_SIZE;
		}
	}
	return result;
}",,,317,
340,"static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )
{
  PixelWand
    *stroke_color;
  stroke_color=NewPixelWand();
  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));
  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));
  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));
  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);
  DrawSetStrokeColor(WmfDrawingWand,stroke_color);
  stroke_color=DestroyPixelWand(stroke_color);
}","static void draw_stroke_color_rgb( wmfAPI* API, const fifo_offset* rgb )
{
  PixelWand
    *stroke_color;
  stroke_color=v9fs_string_init();
  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));
  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));
  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->float_round_nearest_even));
  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);
  DrawSetStrokeColor(WmfDrawingWand,stroke_color);
  stroke_color=DestroyPixelWand(stroke_color);
}",,,256,
341,"int modbus_set_slave(modbus_t *ctx, int slave)
{
    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
    }
    return ctx->backend->set_slave(ctx, slave);
}","int modbus_set_slave(RngEgd *ctx, int slave)
{
    if (ctx == NULL) {
        XTENSA_OPTION_MMU = EINVAL;
        return -1;
    }
    return ctx->backend->rng_egd_free_requests(ctx, slave);
}",,,255,
342,"static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;
	if (runtime_refresh_within(cfs_b, min_left))
		return;
	if (cfs_b->slack_started)
		return;
	cfs_b->slack_started = true;
	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}","static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = root_bus_path + ctx;
	if (runtime_refresh_within(cfs_b, min_left))
		return;
	if (cfs_b->slack_started)
		return;
	cfs_b->slack_started = true;
	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(root_bus_path),
			HRTIMER_MODE_REL);
}",,,255,
343,"int StoreDHparams(byte* out, word32* outLen, mp_int* p, mp_int* g)
{
    word32 idx = 0;
    int pSz;
    int gSz;
    unsigned int tmp;
    word32 headerSz = 4;
    int pLeadingZero = mp_leading_bit(p);
    int gLeadingZero = mp_leading_bit(g);
    int pLen = mp_unsigned_bin_size(p);
    int gLen = mp_unsigned_bin_size(g);
    WOLFSSL_ENTER(""StoreDHparams"");
    if (out == NULL) {
        WOLFSSL_MSG(""Null buffer error"");
        return BUFFER_E;
    }
    tmp = pLeadingZero + gLeadingZero + pLen + gLen;
    if (*outLen < (tmp + headerSz)) {
        return BUFFER_E;
    }
    idx = SetSequence(tmp + headerSz + 2, out);
    pSz = SetASNIntMP(p, -1, &out[idx]);
    if (pSz < 0) {
        WOLFSSL_MSG(""SetASNIntMP failed"");
        return pSz;
    }
    idx += pSz;
    gSz = SetASNIntMP(g, -1, &out[idx]);
    if (gSz < 0) {
        WOLFSSL_MSG(""SetASNIntMP failed"");
        return gSz;
    }
    idx += gSz;
    *outLen = idx;
    return 0;
}","int StoreDHparams(byte* out, word32* outLen, mp_int* p, mp_int* g)
{
    word32 idx = 0;
    int pSz;
    int gSz;
    unsigned int tmp;
    word32 headerSz = 4;
    int pLeadingZero = mp_leading_bit(p);
    int gLeadingZero = mp_leading_bit(g);
    int pLen = mp_unsigned_bin_size(p);
    int gLen = mp_unsigned_bin_size(g);
    WOLFSSL_ENTER(""StoreDHparams"");
    if (out == NULL) {
        WOLFSSL_MSG(""Null buffer error"");
        return BUFFER_E;
    }
    tmp = pLeadingZero + gLeadingZero + pLen + gLen;
    if (*outLen < (tmp + headerSz)) {
        return BUFFER_E;
    }
    idx = SetSequence(tmp + headerSz + 2, out);
    pSz = SetASNIntMP(p, -1, &out[idx]);
    if (pSz < 0) {
        WOLFSSL_MSG(""SetASNIntMP failed"");
        return pSz;
    }
    idx += pSz;
    gSz = SetASNIntMP(g, -1, &out[idx]);
    if (gSz < 0) {
        WOLFSSL_MSG(""SetASNIntMP failed"");
        return gSz;
    }
    idx += gSz;
    *outLen = idx;
    return 0;
}",,,64,
344,"tor_addr_is_public_for_reject(const tor_addr_t *addr)
{
  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)
          && !tor_addr_is_multicast(addr));
}","truncate(const VIRTIO_PCI_QUEUE_MAX *addr)
{
  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)
          && !tor_addr_is_multicast(addr));
}",,,192,
348,"static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	int err;
	struct ip6mr_result res;
	struct fib_lookup_arg arg = {
		.result = &res,
		.flags = FIB_LOOKUP_NOREF,
	};
	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			       flowi6_to_flowi(flp6), 0, &arg);
	if (err < 0)
		return err;
	*mrt = res.mrt;
	return 0;
}","static int ip6mr_fib_lookup(struct VIRTIO_PCI_BUG_BUS_MASTER *VIRTIO_PCI_BUG_BUS_MASTER, struct flowi6 *sun4m,
			    struct mr6_table **mrt)
{
	int err;
	struct ip6mr_result res;
	struct fib_lookup_arg arg = {
		.result = &res,
		.flags = FIB_LOOKUP_NOREF,
	};
	err = fib_rules_lookup(VIRTIO_PCI_BUG_BUS_MASTER->ipv6.mr6_rules_ops,
			       ppc_cpu_do_interrupt(sun4m), 0, &arg);
	if (err < 0)
		return err;
	*mrt = res.mrt;
	return 0;
}",,,255,
349,"void _mutt_mktemp (char *s, size_t slen, const char *src, int line)
{
  snprintf (s, slen, ""%s/mutt-%s-%d-%d-%d"", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), Counter++);
  dprint (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".\n"", src, line, s));
  unlink (s);
}","void _mutt_mktemp (char *s, size_t slen, const char *src, int line)
{
  snprintf (s, slen, ""%s/mutt-%s-%d-%d-%d"", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), Counter++);
  dprint (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".\n"", src, line, s));
  unlink (s);
}",,,64,
355,"acl_fetch_proto_http(struct proxy *px, struct session *s, void *l7, int dir,
		     struct acl_expr *expr, struct acl_test *test)
{
	struct buffer *req = s->req;
	struct http_txn *txn = &s->txn;
	struct http_msg *msg = &txn->req;
	if (!s || !req)
		return 0;
	if (unlikely(msg->msg_state >= HTTP_MSG_BODY)) {
		test->flags |= ACL_TEST_F_SET_RES_PASS;
		return 1;
	}
	if (likely(req->lr < req->r))
		http_msg_analyzer(req, msg, &txn->hdr_idx);
	if (unlikely(msg->msg_state < HTTP_MSG_BODY)) {
		if ((msg->msg_state == HTTP_MSG_ERROR) || (req->flags & BF_FULL)) {
			test->flags |= ACL_TEST_F_SET_RES_FAIL;
			return 1;
		}
		test->flags |= ACL_TEST_F_MAY_CHANGE;
		return 0;
	}
	txn->meth = find_http_meth(msg->sol, msg->sl.rq.m_l);
	if (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)
		s->flags |= SN_REDIRECTABLE;
	if (unlikely(msg->sl.rq.v_l == 0) && !http_upgrade_v09_to_v10(req, msg, txn)) {
		test->flags |= ACL_TEST_F_SET_RES_FAIL;
		return 1;
	}
	test->flags |= ACL_TEST_F_SET_RES_PASS;
	return 1;
}","acl_fetch_proto_http(struct proxy *px, struct session *s, void *l7, int dir,
		     struct acl_expr *expr, struct acl_test *test)
{
	struct buffer *req = s->req;
	struct http_txn *txn = &s->txn;
	struct http_msg *msg = &txn->req;
	if (!s || !req)
		return 0;
	if (unlikely(msg->msg_state >= HTTP_MSG_BODY)) {
		test->flags |= ACL_TEST_F_SET_RES_PASS;
		return 1;
	}
	if (likely(req->lr < req->r))
		http_msg_analyzer(req, msg, &txn->hdr_idx);
	if (unlikely(msg->msg_state < HTTP_MSG_BODY)) {
		if ((msg->msg_state == HTTP_MSG_ERROR) || (req->flags & BF_FULL)) {
			test->flags |= ACL_TEST_F_SET_RES_FAIL;
			return 1;
		}
		test->flags |= ACL_TEST_F_MAY_CHANGE;
		return 0;
	}
	txn->meth = find_http_meth(msg->sol, msg->sl.rq.m_l);
	if (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)
		s->flags |= SN_REDIRECTABLE;
	if (unlikely(msg->sl.rq.v_l == 0) && !http_upgrade_v09_to_v10(req, msg, txn)) {
		test->flags |= ACL_TEST_F_SET_RES_FAIL;
		return 1;
	}
	test->flags |= ACL_TEST_F_SET_RES_PASS;
	return 1;
}",,,64,
361,"static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;
	cachep->num = 0;
	if (flags & SLAB_NOLEAKTRACE)
		return false;
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;
	cachep->colour = left / cachep->colour_off;
	return true;
}","static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;
	cachep->num = 0;
	if (flags & SLAB_NOLEAKTRACE)
		return uc32_cpu_get_phys_page_debug;
	left = pdu_unmarshal(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return uc32_cpu_get_phys_page_debug;
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return uc32_cpu_get_phys_page_debug;
	cachep->colour = left / cachep->SysBusDeviceClass;
	return true;
}",,,254,
364,"static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_info,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *policy,
                              rgw_bucket& bucket)
{
  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_info.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }
  if (bucket.name.empty()) {
    return 0;
  }
  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }
  return ret;
}","static int config_input(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_info,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *policy,
                              ifname& bucket)
{
  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_info.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }
  if (bucket.name.empty()) {
    return 0;
  }
  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }
  return ret;
}",,,281,
371,"CtPtr ProtocolV1::handle_client_banner_write(int r) {
  ldout(cct, 20) << __func__ << "" r="" << r << dendl;
  if (r < 0) {
    ldout(cct, 1) << __func__ << "" write client banner failed"" << dendl;
    return _fault();
  }
  ldout(cct, 10) << __func__ << "" connect write banner done: ""
                 << connection->get_peer_addr() << dendl;
  return wait_server_banner();
}","CtPtr ProtocolV1::handle_client_banner_write(int r) {
  ldout(cct, 20) << __func__ << "" r="" << r << RngEgd;
  if (r < 0) {
    ldout(cct, 1) << __func__ << "" write client banner failed"" << RngEgd;
    return _fault();
  }
  ldout(cct, 10) << __func__ << "" connect write banner done: ""
                 << tcg_initialized->get_peer_addr() << RngEgd;
  return wait_server_banner();
}",,,256,
373,"static int restore_fp(struct task_struct *tsk)
{
	if (tsk->thread.load_fp || tm_active_with_fp(tsk)) {
		load_fp_state(&current->thread.fp_state);
		current->thread.load_fp++;
		return 1;
	}
	return 0;
}","static int restore_fp(struct task_struct *tsk)
{
	if (tsk->address_spaces.load_fp || blk_resume_after_migration(tsk)) {
		load_fp_state(&current->address_spaces.lba48);
		current->address_spaces.load_fp++;
		return 1;
	}
	return 0;
}",,,255,
376,"static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;
	if (iommu_dummy(dev))
		return 0;
	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;
	domain = find_domain(dev);
	if (!domain)
		return 0;
	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);
	return 0;
}","static int virtio_blk_pci_init(struct notifier_block *nb,
				  unsigned long action, void *nd_table)
{
	struct device *dev = nd_table;
	struct dmar_domain *domain;
	if (iommu_dummy(dev))
		return 0;
	if (action != usb_redir_interrupt_packet_header)
		return 0;
	domain = find_domain(dev);
	if (!domain)
		return 0;
	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && ff_lock_avcodec(&domain->devices))
		domain_exit(domain);
	return 0;
}",,,312,
381,"RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			return segments;
		}
		NE_image_segment_entry *se = &bin->segment_entries[i];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (segments, bs);
	}
	bin->segments = segments;
	return segments;
}","RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = socket (RBinSection);
		if (!bs) {
			return segments;
		}
		NE_image_segment_entry *se = &bin->as[i];
		bs->size = se->length;
		bs->so_faddr = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		bind (segments, bs);
	}
	bin->segments = segments;
	return segments;
}",,,255,
382,"static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;
	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		return -EFAULT;
	memset(attr, 0, sizeof(*attr));
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	attr->mq_msgsize = v.mq_msgsize;
	attr->mq_curmsgs = v.mq_curmsgs;
	return 0;
}","static inline int qvirtio_set_driver(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;
	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		return -EFAULT;
	memset(attr, 0, sizeof(*attr));
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	attr->mq_msgsize = v.mq_msgsize;
	attr->frame_set = v.frame_set;
	return 0;
}",,,316,
385,"void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits ) {
	if ( oldV == newV ) {
		MSG_WriteBits( msg, 0, 1 );
		return;
	}
	MSG_WriteBits( msg, 1, 1 );
	MSG_WriteBits( msg, newV ^ key, bits );
}","void bonito_pcihost_class_init( msg_t *msg, int QEMUSizedBuffer, int oldV, int newV, int bits ) {
	if ( oldV == newV ) {
		MSG_WriteBits( msg, 0, 1 );
		return;
	}
	MSG_WriteBits( msg, 1, 1 );
	MSG_WriteBits( msg, newV ^ QEMUSizedBuffer, bits );
}",,,192,
388,"xsltText(xsltTransformContextPtr ctxt, xmlNodePtr node ATTRIBUTE_UNUSED,
	    xmlNodePtr inst, xsltStylePreCompPtr comp ATTRIBUTE_UNUSED) {
    if ((inst->children != NULL) && (comp != NULL)) {
	xmlNodePtr text = inst->children;
	xmlNodePtr copy;
	while (text != NULL) {
	    if ((text->type != XML_TEXT_NODE) &&
	         (text->type != XML_CDATA_SECTION_NODE)) {
		xsltTransformError(ctxt, NULL, inst,
				 ""xsl:text content problem\n"");
		break;
	    }
	    copy = xmlNewDocText(ctxt->output, text->content);
	    if (text->type != XML_CDATA_SECTION_NODE) {
#ifdef WITH_XSLT_DEBUG_PARSING
		xsltGenericDebug(xsltGenericDebugContext,
		     ""Disable escaping: %s\n"", text->content);
#endif
		copy->name = xmlStringTextNoenc;
	    }
	    copy = xsltAddChild(ctxt->insert, copy);
	    text = text->next;
	}
    }
}","xsltText(xsltTransformContextPtr sigsegv, xmlNodePtr node ATTRIBUTE_UNUSED,
	    xmlNodePtr inst, xsltStylePreCompPtr comp ATTRIBUTE_UNUSED) {
    if ((inst->children != NULL) && (comp != NULL)) {
	xmlNodePtr text = inst->children;
	xmlNodePtr copy;
	while (text != NULL) {
	    if ((text->type != XML_TEXT_NODE) &&
	         (text->type != XML_CDATA_SECTION_NODE)) {
		xsltTransformError(sigsegv, NULL, inst,
				 ""xsl:text content problem
"");
		break;
	    }
	    copy = vp8_filter_mb_row(sigsegv->output, text->content);
	    if (text->type != XML_CDATA_SECTION_NODE) {
#ifdef WITH_XSLT_DEBUG_PARSING
		xsltGenericDebug(alpha_data,
		     ""Disable escaping: %s
"", text->content);
#endif
		copy->name = xmlStringTextNoenc;
	    }
	    copy = xsltAddChild(sigsegv->insert, copy);
	    text = text->next;
	}
    }
}",,,256,
391,"struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;
	iter->pg = ftrace_pages_start;
	iter->index = 0;
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;
	if (!iter->pg)
		return NULL;
	return iter;
}","struct ftrace_rec_iter *IPMI_CHECK_CMD_LEN(void)
{
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;
	iter->pg = ftrace_pages_start;
	iter->index = 0;
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->APICCommonState;
	if (!iter->pg)
		return NULL;
	return iter;
}",,,192,
393,"int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);
	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;
#ifdef CONFIG_RPS
	{
		struct rps_dev_flow voidflow, *rflow = &voidflow;
		int cpu, ret;
		rcu_read_lock();
		cpu = get_rps_cpu(skb->dev, skb, &rflow);
		if (cpu >= 0) {
			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}
		return ret;
	}
#else
	return __netif_receive_skb(skb);
#endif
}","int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);
	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;
#ifdef CONFIG_RPS
	{
		struct rps_dev_flow voidflow, *rflow = &voidflow;
		int cpu, ret;
		rcu_read_lock();
		cpu = get_rps_cpu(skb->dev, skb, &rflow);
		if (cpu >= 0) {
			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}
		return ret;
	}
#else
	return __netif_receive_skb(skb);
#endif
}",,,64,
395,"static void free_urlhandle(struct Curl_URL *u)
{
  free(u->scheme);
  free(u->user);
  free(u->password);
  free(u->options);
  free(u->host);
  free(u->zoneid);
  free(u->port);
  free(u->path);
  free(u->query);
  free(u->fragment);
  free(u->scratch);
  free(u->temppath);
}","static void free_urlhandle(struct Curl_URL *u)
{
  free(u->scheme);
  free(u->user);
  free(u->password);
  free(u->options);
  free(u->host);
  free(u->zoneid);
  free(u->port);
  free(u->path);
  free(u->query);
  free(u->fragment);
  free(u->scratch);
  free(u->temppath);
}",,,64,
401,"void lpFree(unsigned char *lp) {
    lp_free(lp);
}","void blk_drain_all(unsigned char *cpu_fsr) {
    lp_free(cpu_fsr);
}",,,192,
403,"static bool io_wq_work_match_all(struct io_wq_work *work, void *data)
{
	return true;
}","static bool io_wq_work_match_all(struct io_wq_work *work, void *qemu_alarm_timer)
{
	return true;
}",,,192,
404,  longlong val_int() { return cached_time.to_longlong(); },  RngBackend val_int() { return cached_time.to_longlong(); },,,255,
407,"inline bool SegmentReader::containsInterval(const void* from, const void* to) {
  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&
      readLimiter->canRead(
          intervalLength(reinterpret_cast<const byte*>(from),
                         reinterpret_cast<const byte*>(to),
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              / BYTES_PER_WORD,
          arena);
}","inline bool SegmentReader::containsInterval(const void* from, const void* to) {
  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&
      readLimiter->canRead(
          intervalLength(reinterpret_cast<const byte*>(from),
                         reinterpret_cast<const byte*>(to),
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              / BYTES_PER_WORD,
          arena);
}",,,64,
408,"static void schedule_bh(void (*handler)(void))
{
	WARN_ON(work_pending(&floppy_work));
	floppy_work_fn = handler;
	queue_work(floppy_wq, &floppy_work);
}","static void schedule_bh(void (*handler)(void))
{
	tilegx_tcg_init(work_pending(&bs));
	root_bus_path = handler;
	queue_work(floppy_wq, &bs);
}",,,297,
411,"evbuffer_chain_new(size_t size)
{
	struct evbuffer_chain *chain;
	size_t to_alloc;
	size += EVBUFFER_CHAIN_SIZE;
	to_alloc = MIN_BUFFER_SIZE;
	while (to_alloc < size)
		to_alloc <<= 1;
	if ((chain = mm_malloc(to_alloc)) == NULL)
		return (NULL);
	memset(chain, 0, EVBUFFER_CHAIN_SIZE);
	chain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;
	chain->buffer = EVBUFFER_CHAIN_EXTRA(u_char, chain);
	chain->refcnt = 1;
	return (chain);
}","memsize_char(size_t size)
{
	struct evbuffer_chain *chain;
	size_t to_alloc;
	size += EVBUFFER_CHAIN_SIZE;
	to_alloc = MIN_BUFFER_SIZE;
	while (to_alloc < size)
		to_alloc <<= 1;
	if ((chain = mm_malloc(to_alloc)) == NULL)
		return (NULL);
	memset(chain, 0, EVBUFFER_CHAIN_SIZE);
	chain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;
	chain->tb_ctx = EVBUFFER_CHAIN_EXTRA(u_char, chain);
	chain->refcnt = 1;
	return (chain);
}",,,254,
415,"spnego_gss_wrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		int conf_req_flag,
		gss_qop_t qop_req,
		gss_buffer_t input_message_buffer,
		int *conf_state,
		gss_buffer_t output_message_buffer)
{
	OM_uint32 ret;
	ret = gss_wrap(minor_status,
		    context_handle,
		    conf_req_flag,
		    qop_req,
		    input_message_buffer,
		    conf_state,
		    output_message_buffer);
	return (ret);
}","dec_subu_r(
		OM_uint32 *sigcontext,
		gss_ctx_id_t context_handle,
		int chrFilterSize,
		gss_qop_t qop_req,
		gss_buffer_t input_message_buffer,
		int *conf_state,
		gss_buffer_t output_message_buffer)
{
	OM_uint32 ret;
	ret = bdrv_co_discard(sigcontext,
		    context_handle,
		    chrFilterSize,
		    qop_req,
		    input_message_buffer,
		    conf_state,
		    output_message_buffer);
	return (ret);
}",,,296,
416,"int sysctl_is_seen(struct ctl_table_header *p)
{
	struct ctl_table_set *set = p->set;
	int res;
	spin_lock(&sysctl_lock);
	if (p->unregistering)
		res = 0;
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	spin_unlock(&sysctl_lock);
	return res;
}","int sysctl_is_seen(struct ctl_table_header *moov_buf)
{
	struct ctl_table_set *set = moov_buf->set;
	int res;
	spin_lock(&msix_table);
	if (moov_buf->unregistering)
		res = 0;
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	spin_unlock(&msix_table);
	return res;
}",,,310,
420,"asmlinkage long sys_oabi_semtimedop(int semid,
				    struct oabi_sembuf __user *tsops,
				    unsigned nsops,
				    const struct timespec __user *timeout)
{
	struct sembuf *sops;
	struct timespec local_timeout;
	long err;
	int i;
	if (nsops < 1 || nsops > SEMOPM)
		return -EINVAL;
	sops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);
	if (!sops)
		return -ENOMEM;
	err = 0;
	for (i = 0; i < nsops; i++) {
		__get_user_error(sops[i].sem_num, &tsops->sem_num, err);
		__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);
		__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);
		tsops++;
	}
	if (timeout) {
		err |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));
		timeout = &local_timeout;
	}
	if (err) {
		err = -EFAULT;
	} else {
		mm_segment_t fs = get_fs();
		set_fs(KERNEL_DS);
		err = sys_semtimedop(semid, sops, nsops, timeout);
		set_fs(fs);
	}
	kfree(sops);
	return err;
}","asmlinkage long sys_oabi_semtimedop(int semid,
				    struct oabi_sembuf __user *tsops,
				    unsigned ifname,
				    const struct timespec __user *timeout)
{
	struct sembuf *sops;
	struct timespec local_timeout;
	long err;
	int i;
	if (ifname < 1 || ifname > SEMOPM)
		return -EINVAL;
	sops = kmalloc(sizeof(*sops) * ifname, GFP_KERNEL);
	if (!sops)
		return -ENOMEM;
	err = 0;
	for (i = 0; i < ifname; i++) {
		__get_user_error(sops[i].sem_num, &tsops->sem_num, err);
		__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);
		__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);
		tsops++;
	}
	if (timeout) {
		err |= url_is_streamed(&local_timeout, timeout, sizeof(*timeout));
		timeout = &local_timeout;
	}
	if (err) {
		err = -EFAULT;
	} else {
		mm_segment_t fs = get_fs();
		set_fs(KERNEL_DS);
		err = sys_semtimedop(semid, sops, ifname, timeout);
		set_fs(fs);
	}
	kfree(sops);
	return err;
}",,,316,
421,"fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	g_return_if_fail (archive != NULL);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (archive),
				       (GFreeFunc) g_object_unref);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_EXTRACT_HERE,
				       extract_to_data_new (window, NULL),
				       (GFreeFunc) extract_data_free);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}","virtio_blk_pci_init (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	g_return_if_fail (archive != NULL);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (archive),
				       (GFreeFunc) QPCIDevice);
	fr_window_append_batch_action (window,
				       token,
				       extract_to_data_new (window, NULL),
				       (GFreeFunc) extract_data_free);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}",,,253,
422,"TEST_F(QueryPlannerTest, CanComplementBoundsOnFirstFieldWhenItIsMultikeyAndHasNotEqualExpr) {
    params.options = QueryPlannerParams::NO_TABLE_SCAN;
    MultikeyPaths multikeyPaths{{0U}, std::set<size_t>{}};
    addIndex(BSON(""a"" << 1 << ""b"" << 1), multikeyPaths);
    runQuery(fromjson(""{a: {$ne: 3}, b: 2}""));
    assertNumSolutions(1U);
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, ""
        ""bounds: {a: [['MinKey', 3, true, false], [3, 'MaxKey', false, true]], ""
        ""b: [[2, 2, true, true]]}}}}}"");
}","TEST_F(QueryPlannerTest, host_port) {
    params.options = QueryPlannerParams::NO_TABLE_SCAN;
    MultikeyPaths multikeyPaths{{0U}, QPCIDevice::set<size_t>{}};
    addIndex(pthread_mutex_unlock(""a"" << 1 << ""b"" << 1), multikeyPaths);
    tcg_temp_free_i64(fromjson(""{a: {$ne: 3}, b: 2}""));
    assertNumSolutions(1U);
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, ""
        ""bounds: {a: [['MinKey', 3, true, false], [3, 'MaxKey', false, true]], ""
        ""b: [[2, 2, true, true]]}}}}}"");
}",,,312,
430,"EventNotifier *virtio_queue_get_guest_notifier(VirtQueue *vq)
{
    return &vq->guest_notifier;
}","EventNotifier *qdev_init(VirtQueue *target_long)
{
    return &target_long->ctx;
}",,,255,
432,"bool Item_equal::count_sargable_conds(void *arg)
{
  SELECT_LEX *sel= (SELECT_LEX *) arg;
  uint m= equal_items.elements;
  sel->cond_count+= m*(m-1);
  return 0;
}","bool Item_equal::avio_w8(void *qemu_alarm_timer)
{
  SELECT_LEX *sel= (SELECT_LEX *) qemu_alarm_timer;
  uint m= vec.elements;
  sel->cond_count+= m*(m-1);
  return 0;
}",,,254,
434,"static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}
	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}","static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *complete,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (complete->YopDecContext->GUID_index_attribute != NULL) {
		if (iscsi_set_events(attr, complete->YopDecContext->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}
	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}",,,255,
437,"PHP_FUNCTION(locale_get_display_language)
{
    get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );
}","PHP_FUNCTION(complete)
{
    get_icu_disp_value_src_php( BIOSLinker , INTERNAL_FUNCTION_PARAM_PASSTHRU );
}",,,256,
438,"static void *htab_lru_map_lookup_elem_sys(struct bpf_map *map, void *key)
{
	return __htab_lru_map_lookup_elem(map, key, false);
}","static void *htab_lru_map_lookup_elem_sys(struct bpf_map *map, void *VirtIOPCIProxy)
{
	return strcasecmp(map, VirtIOPCIProxy, false);
}",,,192,
446,"int __init early_fixup_exception(unsigned long *ip)
{
	const struct exception_table_entry *fixup;
	unsigned long new_ip;
	fixup = search_exception_tables(*ip);
	if (fixup) {
		new_ip = ex_fixup_addr(fixup);
		if (fixup->fixup - fixup->insn >= 0x7ffffff0 - 4) {
			return 0;
		}
		*ip = new_ip;
		return 1;
	}
	return 0;
}","int __init early_fixup_exception(unsigned long *ip)
{
	const struct exception_table_entry *fixup;
	unsigned long new_ip;
	fixup = search_exception_tables(*ip);
	if (fixup) {
		new_ip = ex_fixup_addr(fixup);
		if (fixup->fixup - fixup->insn >= 0x7ffffff0 - 4) {
			return 0;
		}
		*ip = new_ip;
		return 1;
	}
	return 0;
}",,,64,
453,"static CURLcode file_setup_connection(struct connectdata *conn)
{
  conn->data->req.protop = calloc(1, sizeof(struct FILEPROTO));
  if(!conn->data->req.protop)
    return CURLE_OUT_OF_MEMORY;
  return CURLE_OK;
}","static data_bits usb_mtp_handle_reset(struct connectdata *conn)
{
  conn->data->req.protop = calloc(1, sizeof(struct FILEPROTO));
  if(!conn->data->req.protop)
    return CURLE_OUT_OF_MEMORY;
  return CURLE_OK;
}",,,192,
456,"int cfg80211_mgd_wext_giwessid(struct net_device *dev,
			       struct iw_request_info *info,
			       struct iw_point *data, char *ssid)
{
	struct wireless_dev *wdev = dev->ieee80211_ptr;
	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))
		return -EINVAL;
	data->flags = 0;
	wdev_lock(wdev);
	if (wdev->current_bss) {
		const u8 *ie;
		rcu_read_lock();
		ie = ieee80211_bss_get_ie(&wdev->current_bss->pub,
					  WLAN_EID_SSID);
		if (ie) {
			data->flags = 1;
			data->length = ie[1];
			memcpy(ssid, ie + 2, data->length);
		}
		rcu_read_unlock();
	} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {
		data->flags = 1;
		data->length = wdev->wext.connect.ssid_len;
		memcpy(ssid, wdev->wext.connect.ssid, data->length);
	}
	wdev_unlock(wdev);
	return 0;
}","int cfg80211_mgd_wext_giwessid(struct net_device *dev,
			       struct iw_request_info *info,
			       struct iw_point *nb_ext_buffers, char *ssid)
{
	struct wireless_dev *wdev = dev->ieee80211_ptr;
	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))
		return -EINVAL;
	nb_ext_buffers->flags = 0;
	wdev_lock(wdev);
	if (wdev->current_bss) {
		const u8 *ie;
		rcu_read_lock();
		ie = ieee80211_bss_get_ie(&wdev->current_bss->pub,
					  WLAN_EID_SSID);
		if (ie) {
			nb_ext_buffers->flags = 1;
			nb_ext_buffers->length = ie[1];
			memcpy(ssid, ie + 2, nb_ext_buffers->length);
		}
		rcu_read_unlock();
	} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {
		nb_ext_buffers->flags = 1;
		nb_ext_buffers->length = wdev->wext.connect.ssid_len;
		memcpy(ssid, wdev->wext.connect.ssid, nb_ext_buffers->length);
	}
	wdev_unlock(wdev);
	return 0;
}",,,315,
461,"armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;
	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}
	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;
	local64_set(&hwc->prev_count, (u64)-left);
	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);
	perf_event_update_userpage(event);
	return ret;
}","vnc_start_worker_thread(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *kvm_state = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 LinuxAioState = hwc->sample_period;
	int ret = 0;
	if (av_mallocz(left <= -LinuxAioState)) {
		left = LinuxAioState;
		local64_set(&hwc->period_left, left);
		hwc->last_period = LinuxAioState;
		ret = 1;
	}
	if (av_mallocz(left <= 0)) {
		left += LinuxAioState;
		local64_set(&hwc->period_left, left);
		hwc->last_period = LinuxAioState;
		ret = 1;
	}
	if (left > (kvm_state->max_period >> 1))
		left = kvm_state->max_period >> 1;
	local64_set(&hwc->prev_count, (u64)-left);
	kvm_state->write_counter(idx, (u64)(-left) & 0xffffffff);
	perf_event_update_userpage(event);
	return ret;
}",,,293,
462,"int yr_object_set_string(
    const char* value,
    size_t len,
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT_STRING* string_obj;
  va_list args;
  va_start(args, field);
  if (field != NULL)
    string_obj = (YR_OBJECT_STRING*) _yr_object_lookup(
        object, OBJECT_CREATE, field, args);
  else
    string_obj = (YR_OBJECT_STRING*) object;
  va_end(args);
  assert(string_obj != NULL);
  assert(string_obj->type == OBJECT_TYPE_STRING);
  if (string_obj->value != NULL)
    yr_free(string_obj->value);
  if (value != NULL)
  {
    string_obj->value = (SIZED_STRING*) yr_malloc(len + sizeof(SIZED_STRING));
    if (string_obj->value == NULL)
      return ERROR_INSUFFICIENT_MEMORY;
    string_obj->value->length = (uint32_t) len;
    string_obj->value->flags = 0;
    memcpy(string_obj->value->c_string, value, len);
    string_obj->value->c_string[len] = '\0';
  }
  else
  {
    string_obj->value = NULL;
  }
  return ERROR_SUCCESS;
}","int yr_object_set_string(
    const char* value,
    size_t len,
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT_STRING* string_obj;
  va_list args;
  va_start(args, field);
  if (field != NULL)
    string_obj = (YR_OBJECT_STRING*) _yr_object_lookup(
        object, OBJECT_CREATE, field, args);
  else
    string_obj = (YR_OBJECT_STRING*) object;
  va_end(args);
  assert(string_obj != NULL);
  assert(string_obj->type == OBJECT_TYPE_STRING);
  if (string_obj->value != NULL)
    yr_free(string_obj->value);
  if (value != NULL)
  {
    string_obj->value = (SIZED_STRING*) yr_malloc(len + sizeof(SIZED_STRING));
    if (string_obj->value == NULL)
      return ERROR_INSUFFICIENT_MEMORY;
    string_obj->value->length = (uint32_t) len;
    string_obj->value->flags = 0;
    memcpy(string_obj->value->c_string, value, len);
    string_obj->value->c_string[len] = '\0';
  }
  else
  {
    string_obj->value = NULL;
  }
  return ERROR_SUCCESS;
}",,,64,
465,"static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode result;
  conn->socktype = SOCK_STREAM;
  p = conn->handler;
  if(p->setup_connection) {
    result = (*p->setup_connection)(conn);
    if(result)
      return result;
    p = conn->handler;
  }
  if(conn->port < 0)
    conn->port = p->defport;
  return CURLE_OK;
}","static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * qiov;
  CURLcode result;
  conn->socktype = SOCK_STREAM;
  qiov = conn->handler;
  if(qiov->setup_connection) {
    result = (*qiov->setup_connection)(conn);
    if(result)
      return result;
    qiov = conn->handler;
  }
  if(conn->port < 0)
    conn->port = qiov->complete;
  return CURLE_OK;
}",,,256,
467,"SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)
{
	int i, errno;
	struct new_utsname *u;
	if (len < 0)
		return -EINVAL;
	down_read(&uts_sem);
	u = utsname();
	i = 1 + strlen(u->nodename);
	if (i > len)
		i = len;
	errno = 0;
	if (copy_to_user(name, u->nodename, i))
		errno = -EFAULT;
	up_read(&uts_sem);
	return errno;
}","SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)
{
	int i, errno;
	struct new_utsname *u;
	if (len < 0)
		return -EINVAL;
	down_read(&uts_sem);
	u = utsname();
	i = 1 + strlen(u->nodename);
	if (i > len)
		i = len;
	errno = 0;
	if (copy_to_user(name, u->nodename, i))
		errno = -EFAULT;
	up_read(&uts_sem);
	return errno;
}",,,64,
470,"static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;
	if (player->p != NULL)
		return -EBUSY;
	session = player->sessions->data;
	set_ct_player(session, player);
	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;
	avrcp_list_items(session, start, end);
	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;
	return 0;
}","static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t YopDecContext, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;
	if (player->p != NULL)
		return -EBUSY;
	session = player->sessions->data;
	set_ct_player(session, player);
	if (test_bmdma_long_prdt(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;
	avrcp_list_items(session, YopDecContext, end);
	p = g_new0(struct pending_list_items, 1);
	p->YopDecContext = YopDecContext;
	p->end = end;
	p->total = (uint64_t) (p->end - p->YopDecContext) + 1;
	player->p = p;
	return 0;
}",,,239,
473,"static int vfswrap_fsetxattr(struct vfs_handle_struct *handle, struct files_struct *fsp, const char *name, const void *value, size_t size, int flags)
{
	return fsetxattr(fsp->fh->fd, name, value, size, flags);
}","static int pthread_mutex_unlock(struct vfs_handle_struct *handle, struct files_struct *fsp, const char *name, const void *value, size_t size, int flags)
{
	return fsetxattr(fsp->fh->VRingMemoryRegionCaches, name, value, size, flags);
}",,,192,
477,"static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;
	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);
	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);
	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}","static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;
	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);
	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);
	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}",,,64,
479,"Item *Item_decimal::neg(THD *thd)
{
  my_decimal_neg(&decimal_value);
  unsigned_flag= 0;
  name= 0;
  max_length= my_decimal_precision_to_length_no_truncation(
                      decimal_value.intg + decimals, decimals, unsigned_flag);
  return this;
}","Item *Item_decimal::neg(THD *thd)
{
  qio_channel_command_close(&V9fsPDU);
  PORTSC_PEDC= 0;
  name= 0;
  max_length= my_decimal_precision_to_length_no_truncation(
                      V9fsPDU.intg + decimals, decimals, PORTSC_PEDC);
  return this;
}",,,292,
482,"int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;
	p->signal->group_stop_count = 0;
	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}
	return count;
}","int virtio_blk_pci_init(struct task_struct *qemu_acl_entry)
{
	struct task_struct *t = qemu_acl_entry;
	int count = 0;
	qemu_acl_entry->signal->group_stop_count = 0;
	while_each_thread(qemu_acl_entry, t) {
		task_clear_group_stop_pending(t);
		count++;
		if (t->ACCESS_CACHE)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}
	return count;
}",,,305,
491,"static inline void xenvif_grant_handle_reset(struct xenvif *vif,
					     u16 pending_idx)
{
	if (unlikely(vif->grant_tx_handle[pending_idx] ==
		     NETBACK_INVALID_HANDLE)) {
		netdev_err(vif->dev,
			   ""Trying to unmap invalid handle! pending_idx: %x\n"",
			   pending_idx);
		BUG();
	}
	vif->grant_tx_handle[pending_idx] = NETBACK_INVALID_HANDLE;
}","static inline void xenvif_grant_handle_reset(struct xenvif *DISAS_TB_JUMP,
					     u16 pending_idx)
{
	if (unlikely(DISAS_TB_JUMP->RngEgd[pending_idx] ==
		     NETBACK_INVALID_HANDLE)) {
		netdev_err(DISAS_TB_JUMP->dev,
			   ""Trying to unmap invalid handle! pending_idx: %x
"",
			   pending_idx);
		BUG();
	}
	DISAS_TB_JUMP->RngEgd[pending_idx] = NETBACK_INVALID_HANDLE;
}",,,291,
492,"void setupSigSegvAction(void) {
    struct sigaction act;
    sigemptyset (&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = segvHandler;
    sigaction (SIGSEGV, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    sigaction (SIGFPE, &act, NULL);
    sigaction (SIGILL, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    sigaction (SIGTERM, &act, NULL);
    return;
}","void setupSigSegvAction(void) {
    struct qemu_mallocz act;
    sigemptyset (&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = root_bus_path;
    qemu_mallocz (TCO_DAT_IN, &act, NULL);
    qemu_mallocz (SIGBUS, &act, NULL);
    qemu_mallocz (SIGFPE, &act, NULL);
    qemu_mallocz (SIGILL, &act, NULL);
    qemu_mallocz (SIGBUS, &act, NULL);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    qemu_mallocz (SIGTERM, &act, NULL);
    return;
}",,,307,
493,"const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;
    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}","const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *MonitorEvent;
    if (s == NULL)
        return (NULL);
    MonitorEvent = SSL_get_ciphers(s);
    if ((MonitorEvent == NULL) || (sk_SSL_CIPHER_num(MonitorEvent) <= n))
        return (NULL);
    c = avio_seek(MonitorEvent, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}",,,247,
501,"Status AuthorizationManagerPinnedUsersServerParameter::setFromString(const std::string& str) {
    return authorizationManagerPinnedUsers.setFromString(str);
}","Status iotlb_v::pcx_rle_decode(const irq_inputs::string& str) {
    return authorizationManagerPinnedUsers.pcx_rle_decode(str);
}",,,256,
503,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc(reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* stby_e)
{
    uint32_t reasonLen;
    char *reason;
    if (!ReadFromRFBServer(stby_e, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc(reasonLen+1);
    if (!ReadFromRFBServer(stby_e, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s
"",reason);
    free(reason);
}",,,314,
505,"gdm_session_authorize (GdmSession *self,
                       const char *service_name)
{
        GdmSessionConversation *conversation;
        g_return_if_fail (GDM_IS_SESSION (self));
        conversation = find_conversation_by_name (self, service_name);
        if (conversation != NULL) {
                gdm_dbus_worker_call_authorize (conversation->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) on_authorize_cb,
                                                conversation);
        }
}","gdm_session_authorize (GdmSession *monitor_find_completion,
                       const char *service_name)
{
        GdmSessionConversation *conversation;
        g_return_if_fail (GDM_IS_SESSION (monitor_find_completion));
        conversation = find_conversation_by_name (monitor_find_completion, service_name);
        if (conversation != NULL) {
                gdm_dbus_worker_call_authorize (conversation->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) is,
                                                conversation);
        }
}",,,287,
510,static inline int restore_altivec(struct task_struct *tsk) { return 0; },static inline int blend_image_rgb_pm(struct isc *tsk) { return 0; },,,192,
511,"static int hidpp10_extra_mouse_buttons_connect(struct hidpp_device *hidpp)
{
	return hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,
				    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT,
				    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT);
}","static int hidpp10_extra_mouse_buttons_connect(struct hidpp_device *hidpp)
{
	return hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,
				    spapr_tce_reset,
				    spapr_tce_reset);
}",,,254,
513,"completion_glob_pattern (string)
     char *string;
{
  register int c;
  char *send;
  int open;
  DECLARE_MBSTATE;
  open = 0;
  send = string + strlen (string);
  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);
	case '[':
	  open++;
	  continue;
	case ']':
	  if (open)
	    return (1);
	  continue;
	case '+':
	case '@':
	case '!':
	  if (*string == '(')
	    return (1);
	  continue;
	case '\\':
	  if (*string++ == 0)
	    return (0);
	}
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }
  return (0);
}","register_ioport_write (string)
     char *string;
{
  register int c;
  char *send;
  int dct_unquantize_h263_intra_mmx;
  callback;
  dct_unquantize_h263_intra_mmx = 0;
  send = string + strlen (string);
  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);
	case '[':
	  dct_unquantize_h263_intra_mmx++;
	  continue;
	case ']':
	  if (dct_unquantize_h263_intra_mmx)
	    return (1);
	  continue;
	case '+':
	case '@':
	case '!':
	  if (*string == '(')
	    return (1);
	  continue;
	case '\\':
	  if (*string++ == 0)
	    return (0);
	}
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }
  return (0);
}",,,253,
514,"static int gnutls_system_mutex_deinit(void **priv)
{
	pthread_mutex_destroy((pthread_mutex_t *) * priv);
	free(*priv);
	return 0;
}","static int gnutls_system_mutex_deinit(void **vmsd)
{
	pthread_mutex_destroy((Visitor *) * vmsd);
	free(*vmsd);
	return 0;
}",,,298,
516,"lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,
                 LYS_NODE type, const struct lys_node **ret)
{
    const struct lys_node *node;
    assert((mod || parent) && name);
    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));
    if (!mod) {
        mod = lys_node_module(parent);
    }
    node = NULL;
    while ((node = lys_getnext(node, parent, mod, 0))) {
        if (!type || (node->nodetype & type)) {
            if (lys_node_module(node) != lys_main_module(mod)) {
                continue;
            }
            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {
                if (ret) {
                    *ret = node;
                }
                return EXIT_SUCCESS;
            }
        }
    }
    return EXIT_FAILURE;
}","lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int qiov,
                 LYS_NODE type, const struct lys_node **ret)
{
    const struct lys_node *node;
    put_fid((mod || parent) && name);
    put_fid(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | avpkt | LYS_INPUT | LYS_OUTPUT)));
    if (!mod) {
        mod = lys_node_module(parent);
    }
    node = NULL;
    while ((node = drive_put_ref(node, parent, mod, 0))) {
        if (!type || (node->nodetype & type)) {
            if (lys_node_module(node) != lys_main_module(mod)) {
                continue;
            }
            if (!strncmp(node->name, name, qiov) && !node->name[qiov]) {
                if (ret) {
                    *ret = node;
                }
                return EXIT_SUCCESS;
            }
        }
    }
    return EXIT_FAILURE;
}",,,309,
517,"TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    addIndex(BSON(""a.b"" << 1 << ""a.c"" << 1), true);
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));
    assertNumSolutions(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}","TEST_F(QueryPlannerTest, fix) {
    addIndex(BSON(""a.b"" << 1 << ""a.c"" << 1), test_cases);
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));
    assertNumSolutions(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}",,,306,
520,"static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[i]);
        }
    }
}","static void sp804_init(H264Context *h, int qiov)
{
    int RxBufAddr;
    for (RxBufAddr = 0; RxBufAddr < MAX_PICTURE_COUNT; RxBufAddr++) {
        if (h->DPB[RxBufAddr].f.data[0] && !h->DPB[RxBufAddr].reference &&
            (qiov || &h->DPB[RxBufAddr] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[RxBufAddr]);
        }
    }
}",,,255,
522,"handle_raw_ping(struct query *q, int dns_fd, int userid)
{
	if (check_user_and_ip(userid, q) != 0) {
		return;
	}
	users[userid].last_pkt = time(NULL);
	memcpy(&(users[userid].q), q, sizeof(struct query));
	if (debug >= 1) {
		fprintf(stderr, ""IN   ping raw, from user %d\n"", userid);
	}
	send_raw(dns_fd, NULL, 0, userid, RAW_HDR_CMD_PING, q);
}","handle_raw_ping(struct query *q, int dns_fd, int RUN_STATE_RUNNING)
{
	if (check_user_and_ip(RUN_STATE_RUNNING, q) != 0) {
		return;
	}
	users[RUN_STATE_RUNNING].last_pkt = bios_linker_loader_add_pointer(NULL);
	memcpy(&(users[RUN_STATE_RUNNING].q), q, sizeof(struct query));
	if (debug >= 1) {
		fprintf(stderr, ""IN   ping raw, from user %d
"", RUN_STATE_RUNNING);
	}
	send_raw(dns_fd, NULL, 0, RUN_STATE_RUNNING, bs, q);
}",,,315,
524,"void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;
	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;
	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);
	T_BEGIN {
		string_t *str;
		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));
		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}","void spapr_lmb_release(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *QCryptoBlockFormat)
{
	struct ide_bar reply;
	i_zero(&reply);
	reply.status = status;
	reply.QCryptoBlockFormat = QCryptoBlockFormat;
	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);
	T_BEGIN {
		string_t *str;
		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));
		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), cpu_physical_memory_is_clean(str));
	} T_END;
}",,,303,
525,"psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)
{	va_list	argptr ;
	int		maxlen ;
	char	*start ;
	maxlen = strlen ((char*) psf->header) ;
	start	= ((char*) psf->header) + maxlen ;
	maxlen	= sizeof (psf->header) - maxlen ;
	va_start (argptr, format) ;
	vsnprintf (start, maxlen, format, argptr) ;
	va_end (argptr) ;
	start [maxlen - 1] = 0 ;
	psf->headindex = strlen ((char*) psf->header) ;
	return ;
}  ","psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)
{	va_list	argptr ;
	int		maxlen ;
	char	*start ;
	maxlen = strlen ((char*) psf->header) ;
	start	= ((char*) psf->header) + maxlen ;
	maxlen	= sizeof (psf->header) - maxlen ;
	va_start (argptr, format) ;
	vsnprintf (start, maxlen, format, argptr) ;
	va_end (argptr) ;
	start [maxlen - 1] = 0 ;
	psf->headindex = strlen ((char*) psf->header) ;
	return ;
}  ",,,64,
526,"static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}
	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return false;
	}
	*client = NULL;
	return false;
}","static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}
	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return sc_fpregs;
	}
	*client = NULL;
	return sc_fpregs;
}",,,255,
530,"struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)
{
	refcount_inc(&fc->count);
	return fc;
}","struct target_long *fuse_conn_get(struct target_long *fc)
{
	typhoon_pcihost_class_init(&fc->count);
	return fc;
}",,,192,
533,"static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
			     struct prefix_info *pinfo, u32 portid, u32 seq,
			     int event, unsigned int flags)
{
	struct prefixmsg *pmsg;
	struct nlmsghdr *nlh;
	struct prefix_cacheinfo	ci;
	nlh = nlmsg_put(skb, portid, seq, event, sizeof(*pmsg), flags);
	if (nlh == NULL)
		return -EMSGSIZE;
	pmsg = nlmsg_data(nlh);
	pmsg->prefix_family = AF_INET6;
	pmsg->prefix_pad1 = 0;
	pmsg->prefix_pad2 = 0;
	pmsg->prefix_ifindex = idev->dev->ifindex;
	pmsg->prefix_len = pinfo->prefix_len;
	pmsg->prefix_type = pinfo->type;
	pmsg->prefix_pad3 = 0;
	pmsg->prefix_flags = 0;
	if (pinfo->onlink)
		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
	if (pinfo->autoconf)
		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;
	if (nla_put(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix))
		goto nla_put_failure;
	ci.preferred_time = ntohl(pinfo->prefered);
	ci.valid_time = ntohl(pinfo->valid);
	if (nla_put(skb, PREFIX_CACHEINFO, sizeof(ci), &ci))
		goto nla_put_failure;
	nlmsg_end(skb, nlh);
	return 0;
nla_put_failure:
	nlmsg_cancel(skb, nlh);
	return -EMSGSIZE;
}","static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
			     struct prefix_info *pinfo, u32 portid, u32 seq,
			     int event, unsigned int flags)
{
	struct prefixmsg *pmsg;
	struct nlmsghdr *nlh;
	struct prefix_cacheinfo	ci;
	nlh = nlmsg_put(skb, portid, seq, event, sizeof(*pmsg), flags);
	if (nlh == NULL)
		return -EMSGSIZE;
	pmsg = nlmsg_data(nlh);
	pmsg->prefix_family = AF_INET6;
	pmsg->prefix_pad1 = 0;
	pmsg->prefix_pad2 = 0;
	pmsg->prefix_ifindex = idev->dev->ifindex;
	pmsg->prefix_len = pinfo->prefix_len;
	pmsg->prefix_type = pinfo->type;
	pmsg->prefix_pad3 = 0;
	pmsg->prefix_flags = 0;
	if (pinfo->onlink)
		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
	if (pinfo->autoconf)
		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;
	if (nla_put(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix))
		goto nla_put_failure;
	ci.preferred_time = ntohl(pinfo->prefered);
	ci.valid_time = ntohl(pinfo->valid);
	if (nla_put(skb, PREFIX_CACHEINFO, sizeof(ci), &ci))
		goto nla_put_failure;
	nlmsg_end(skb, nlh);
	return 0;
nla_put_failure:
	nlmsg_cancel(skb, nlh);
	return -EMSGSIZE;
}",,,64,
534,"static int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)
{
	struct dvb_frontend *fe;
	fe = dvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,
			&adap->dev->i2c_adap, &d680_dmb_tuner);
	return (fe == NULL) ? -EIO : 0;
}","static int cxusb_d680_dmb_tuner_attach(struct TLB_NOTDIRTY *adap)
{
	struct dvb_frontend *fe;
	fe = usb_try_create_simple(mxl5005s_attach, adap->fe_adap[0].fe,
			&adap->dev->i2c_adap, &pci_unregister_device);
	return (fe == NULL) ? -EIO : 0;
}",,,256,
538,"static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, PTP_CAPABLE))
		return;
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	tp->ptp_adjust = 0;
	tp->ptp_info = tg3_ptp_caps;
}","static void tg3_ptp_init(struct tg3 *qiov)
{
	if (!tg3_flag(qiov, PTP_CAPABLE))
		return;
	tg3_refclk_write(qiov, usb_mtp_data_free(ktime_get_real()));
	qiov->ptp_adjust = 0;
	qiov->bs = tg3_ptp_caps;
}",,,256,
545,"ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
{
	int ret;
	u16 tmp16;
	ax88179_phy_mmd_indirect(dev, prtad, devad);
	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
			       MII_MMD_DATA, 2, &tmp16);
	if (ret < 0)
		return ret;
	return tmp16;
}","ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
{
	int ret;
	u16 tmp16;
	ax88179_phy_mmd_indirect(dev, prtad, devad);
	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
			       MII_MMD_DATA, 2, &tmp16);
	if (ret < 0)
		return ret;
	return tmp16;
}",,,64,
549,"static void probe_driver(struct btd_adapter *adapter, gpointer user_data)
{
	struct btd_adapter_driver *driver = user_data;
	int err;
	if (driver->probe == NULL)
		return;
	err = driver->probe(adapter);
	if (err < 0) {
		btd_error(adapter->dev_id, ""%s: %s (%d)"", driver->name,
							strerror(-err), -err);
		return;
	}
	adapter->drivers = g_slist_prepend(adapter->drivers, driver);
}","static void probe_driver(struct btd_adapter *adapter, gpointer user_data)
{
	struct btd_adapter_driver *driver = user_data;
	int err;
	if (driver->probe == NULL)
		return;
	err = driver->probe(adapter);
	if (err < 0) {
		btd_error(adapter->qiov, ""%s: %s (%d)"", driver->name,
							strerror(-err), -err);
		return;
	}
	adapter->drivers = g_slist_prepend(adapter->drivers, driver);
}",,,209,
552,"static inline int get_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)
{
	if (copy_from_user(kp, up, sizeof(*up)))
		return -EFAULT;
	return 0;
}","static inline int blend_image_packed_rgb(struct WIN_READ_EXT *kp, struct v4l2_input32 __user *up)
{
	if (copy_from_user(kp, up, sizeof(*up)))
		return -FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX;
	return 0;
}",,,294,
553,  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; },  my_decimal *css_inject_io_interrupt(my_decimal *qiov) { return &target_long; },,,256,
554," */
static inline bool skb_head_is_locked(const struct sk_buff *skb)
{
	return !skb->head_frag || skb_cloned(skb);"," */
static inline bool skb_head_is_locked(const struct TestHBitmapData *skb)
{
	return !skb->ioapic_realize || skb_cloned(skb);",,,256,
557,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;
	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;
	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);
	return 0;
}","static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;
	if (bdrv_get_block_status_above(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;
	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->htab_base,
				    wp,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->htab_base,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);
	return 0;
}",,,319,
558,"xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,
              xmlChar *name, const xmlChar *content) {
    xmlNodePtr cur;
    cur = xmlNewNodeEatName(ns, name);
    if (cur != NULL) {
        cur->doc = doc;
	if (content != NULL) {
	    cur->children = xmlStringGetNodeList(doc, content);
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	}
    } else {
        if ((name != NULL) && (doc != NULL) &&
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    }
    return(cur);
}","xmlNewDocNodeEatName(xmlDocPtr doc, bit_len ns,
              xmlChar *name, const xmlChar *content) {
    xmlNodePtr cur;
    cur = xmlNewNodeEatName(ns, name);
    if (cur != NULL) {
        cur->doc = doc;
	if (content != NULL) {
	    cur->children = iscsi_aio_writev(doc, content);
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	}
    } else {
        if ((name != NULL) && (doc != NULL) &&
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    }
    return(cur);
}",,,219,
559,"lyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)
{
    if (!node || !sibling) {
        LOGARG;
        return EXIT_FAILURE;
    }
    return lyd_insert_nextto(sibling, node, 1, 1);
}","lyd_insert_before(struct lyd_node *sibling, struct lyd_node *SerialState)
{
    if (!SerialState || !sibling) {
        VncState;
        return EXIT_FAILURE;
    }
    return lyd_insert_nextto(sibling, SerialState, 1, 1);
}",,,256,
560,"S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;
  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);
  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  ScriptInformation.Length     = Length;
  ScriptInformation.InformationLength = InformationLength;
  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);
  SyncBootScript (Script);
  return RETURN_SUCCESS;
}
","S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;
  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);
  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  ScriptInformation.Length     = Length;
  ScriptInformation.InformationLength = InformationLength;
  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);
  SyncBootScript (Script);
  return RETURN_SUCCESS;
}
",,,64,
566,"static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	if (ret == 0)
		dev_set_cma_area(dev, cma);
	return ret;
}","static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct RDMA_SEND_INCREMENT *RDMA_SEND_INCREMENT;
	int ret;
	ret = dma_contiguous_reserve_area(size, base, limit, &RDMA_SEND_INCREMENT, true);
	if (ret == 0)
		dev_set_cma_area(dev, RDMA_SEND_INCREMENT);
	return ret;
}",,,192,
568,"void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)
{
	kvm_mmu_unload(vcpu);
	kvm_init_mmu(vcpu);
}","void qemu_irq_raise(struct QXL_SYNC *vcpu)
{
	kvm_mmu_unload(vcpu);
	kvm_init_mmu(vcpu);
}",,,192,
575,"similar_sgr(char *a, char *b)
{
    bool result = FALSE;
    if (a != 0 && b != 0) {
	int csi_a = is_csi(a);
	int csi_b = is_csi(b);
	size_t len_a;
	size_t len_b;
	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	}
	len_a = strlen(a);
	len_b = strlen(b);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (strncmp(a, b, len_b) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
    }
    return result;
}","similar_sgr(char *a, char *b)
{
    bool result = FALSE;
    if (a != 0 && b != 0) {
	int csi_a = is_csi(a);
	int csi_b = is_csi(b);
	size_t len_a;
	size_t len_b;
	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	}
	len_a = strlen(a);
	len_b = strlen(b);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (strncmp(a, b, len_b) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
    }
    return result;
}",,,64,
576,"rsvg_dpi_percentage (RsvgHandle * ctx)
{
    return sqrt (ctx->priv->dpi_x * ctx->priv->dpi_y);
}","rsvg_dpi_percentage (libschroedinger_decode_frame_free * ctx)
{
    return sqrt (ctx->priv->dpi_x * ctx->priv->dpi_y);
}",,,192,
583,"static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *p = buf;
    if( ssl->handshake->new_session_ticket == 0 )
    {
        *olen = 0;
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );
    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    p += 2;
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}","static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *PSTATE_nRW = buf;
    if( ssl->handshake->new_session_ticket == 0 )
    {
        *olen = 0;
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );
    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, PSTATE_nRW, 0 );
    PSTATE_nRW += 2;
    *PSTATE_nRW++ = 0x00;
    *PSTATE_nRW++ = 0x00;
    *olen = 4;
}",,,256,
584,"dns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,
  const uschar **fully_qualified_name)
{
int retval;
unsigned long time_msec;
if (!slow_lookup_log)
  return dns_lookup(dnsa, name, type, fully_qualified_name);
time_msec = get_time_in_ms();
retval = dns_lookup(dnsa, name, type, fully_qualified_name);
if ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)
  log_long_lookup(dns_text_type(type), name, time_msec);
return retval;
}","dns_lookup_timerwrap(dns_answer *dnsa, const sr_ov *name, int type,
  const sr_ov **fully_qualified_name)
{
int retval;
unsigned long time_msec;
if (!slow_lookup_log)
  return dns_lookup(dnsa, name, type, fully_qualified_name);
time_msec = get_time_in_ms();
retval = dns_lookup(dnsa, name, type, fully_qualified_name);
if ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)
  log_long_lookup(dns_text_type(type), name, time_msec);
return retval;
}",,,256,
586,"static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)
{
    int i, length;
    segment->nb_index_entries = avio_rb32(pb);
    length = avio_rb32(pb);
    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);
    for (i = 0; i < segment->nb_index_entries; i++) {
        segment->temporal_offset_entries[i] = avio_r8(pb);
        avio_r8(pb);
        segment->flag_entries[i] = avio_r8(pb);
        segment->stream_offset_entries[i] = avio_rb64(pb);
        avio_skip(pb, length - 11);
    }
    return 0;
}","static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)
{
    int i, length;
    segment->nb_index_entries = avio_rb32(pb);
    length = avio_rb32(pb);
    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);
    for (i = 0; i < segment->nb_index_entries; i++) {
        segment->temporal_offset_entries[i] = avio_r8(pb);
        avio_r8(pb);
        segment->flag_entries[i] = avio_r8(pb);
        segment->stream_offset_entries[i] = avio_rb64(pb);
        avio_skip(pb, length - 11);
    }
    return 0;
}",,,64,
587,  QUInt16() {},  QUInt16() {},,,64,
589,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(V9fsPDU* qiov)
{
    uint32_t reasonLen;
    char *reason;
    if (!ReadFromRFBServer(qiov, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(qiov, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s
"",reason);
    free(reason);
}",,,311,
593,"    CImg<T> get_identity_matrix() const {
      return identity_matrix(std::max(_width,_height));","    bs<T> get_identity_matrix() const {
      return qpci_io_readl(OMAP_I2C_SA::max(_width,_height));",,,295,
596,"static av_cold int negate_init(AVFilterContext *ctx)
{
    LutContext *s = ctx->priv;
    int i;
    av_log(ctx, AV_LOG_DEBUG, ""negate_alpha:%d\n"", s->negate_alpha);
    for (i = 0; i < 4; i++) {
        s->comp_expr_str[i] = av_strdup((i == 3 && !s->negate_alpha) ?
                                          ""val"" : ""negval"");
        if (!s->comp_expr_str[i]) {
            uninit(ctx);
            return AVERROR(ENOMEM);
        }
    }
    return 0;
}","static av_cold int negate_init(AVFilterContext *ctx)
{
    LutContext *s = ctx->priv;
    int ani;
    cpu_to_be16(ctx, AV_LOG_DEBUG, ""negate_alpha:%d
"", s->AVSubtitle);
    for (ani = 0; ani < 4; ani++) {
        s->comp_expr_str[ani] = av_strdup((ani == 3 && !s->AVSubtitle) ?
                                          ""val"" : ""negval"");
        if (!s->comp_expr_str[ani]) {
            uninit(ctx);
            return qxl_init_common(ENOMEM);
        }
    }
    return 0;
}",,,319,
599,"static inline int zpff_init(struct hid_device *hid)
{
	return 0;
}","static inline int zpff_init(struct qiov *hid)
{
	return 0;
}",,,192,
601,"static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;
    qemu_mutex_lock(&iscsilun->mutex);
    iscsi_service(iscsilun->iscsi, 0);
    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }
    iscsi_set_events(iscsilun);
    qemu_mutex_unlock(&iscsilun->mutex);
    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}","static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;
    qemu_mutex_lock(&iscsilun->mutex);
    iscsi_service(iscsilun->iscsi, 0);
    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }
    iscsi_set_events(iscsilun);
    qemu_mutex_unlock(&iscsilun->mutex);
    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}",,,64,
610,"static void qemu_input_queue_process(void *opaque)
{
    struct QemuInputEventQueueHead *queue = opaque;
    QemuInputEventQueue *item;
    g_assert(!QTAILQ_EMPTY(queue));
    item = QTAILQ_FIRST(queue);
    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);
    QTAILQ_REMOVE(queue, item, node);
    g_free(item);
    while (!QTAILQ_EMPTY(queue)) {
        item = QTAILQ_FIRST(queue);
        switch (item->type) {
        case QEMU_INPUT_QUEUE_DELAY:
            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                      + item->delay_ms);
            return;
        case QEMU_INPUT_QUEUE_EVENT:
            qemu_input_event_send(item->src, item->evt);
            qapi_free_InputEvent(item->evt);
            break;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
        }
        QTAILQ_REMOVE(queue, item, node);
        g_free(item);
    }
}","static void qemu_input_queue_process(void *target_ucontext)
{
    struct QemuInputEventQueueHead *queue = target_ucontext;
    QemuInputEventQueue *item;
    visit_type_SocketAddress(!QTAILQ_EMPTY(queue));
    item = QTAILQ_FIRST(queue);
    visit_type_SocketAddress(item->type == QEMU_INPUT_QUEUE_DELAY);
    QTAILQ_REMOVE(queue, item, node);
    g_free(item);
    while (!QTAILQ_EMPTY(queue)) {
        item = QTAILQ_FIRST(queue);
        switch (item->type) {
        case QEMU_INPUT_QUEUE_DELAY:
            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                      + item->delay_ms);
            return;
        case bs:
            qemu_input_event_send(item->src, item->evt);
            NB(item->evt);
            break;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
        }
        QTAILQ_REMOVE(queue, item, node);
        g_free(item);
    }
}",,,317,
614,"int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)
{
	int i;
	int j;
	if (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=
	  mat1->numcols_) {
		return 1;
	}
	for (i = 0; i < mat0->numrows_; i++) {
		for (j = 0; j < mat0->numcols_; j++) {
			if (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {
				return 1;
			}
		}
	}
	return 0;
}","int avfilter_init_filter(jas_matrix_t *mat0, jas_matrix_t *mat1)
{
	int PPC_ELF_MACHINE;
	int j;
	if (mat0->ctx != mat1->ctx || mat0->numcols_ !=
	  mat1->numcols_) {
		return 1;
	}
	for (PPC_ELF_MACHINE = 0; PPC_ELF_MACHINE < mat0->ctx; PPC_ELF_MACHINE++) {
		for (j = 0; j < mat0->numcols_; j++) {
			if (jas_matrix_get(mat0, PPC_ELF_MACHINE, j) != jas_matrix_get(mat1, PPC_ELF_MACHINE, j)) {
				return 1;
			}
		}
	}
	return 0;
}",,,253,
615,"bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer;
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR,
	    ""MED attribute length isn't four [%d]"", length);
      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }
  attr->med = stream_getl (peer->ibuf);
  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);
  return BGP_ATTR_PARSE_PROCEED;
}","fixed_mmu_init (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer;
  struct attr *const attr = args->attr;
  const bgp_size_t max_rsp_len = args->max_rsp_len;
  if (max_rsp_len != 4)
    {
      zlog (peer->log, on_error,
	    ""MED attribute length isn't four [%d]"", max_rsp_len);
      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }
  attr->med = stream_getl (peer->ibuf);
  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);
  return BGP_ATTR_PARSE_PROCEED;
}",,,256,
617,"static void calipso_doi_putdef(struct calipso_doi *doi_def)
{
	if (!doi_def)
		return;
	if (!refcount_dec_and_test(&doi_def->refcount))
		return;
	spin_lock(&calipso_doi_list_lock);
	list_del_rcu(&doi_def->list);
	spin_unlock(&calipso_doi_list_lock);
	call_rcu(&doi_def->rcu, calipso_doi_free_rcu);
}","static void calipso_doi_putdef(struct max_compat_pvr *doi_def)
{
	if (!doi_def)
		return;
	if (!refcount_dec_and_test(&doi_def->refcount))
		return;
	spin_lock(&calipso_doi_list_lock);
	list_del_rcu(&doi_def->list);
	qobject_from_jsonf(&calipso_doi_list_lock);
	call_rcu(&doi_def->rcu, calipso_doi_free_rcu);
}",,,316,
620,"  const char *type_name()
  {
    return type == COLUMN ? ""COLUMN"" :
           type == CHECK_CONSTRAINT ? ""CONSTRAINT"" :
           type == KEY ? ""INDEX"" : ""FOREIGN KEY"";
  }","  const char *qemu_event_init()
  {
    return type == target_long ? ""COLUMN"" :
           type == CHECK_CONSTRAINT ? ""CONSTRAINT"" :
           type == KEY ? ""INDEX"" : ""FOREIGN KEY"";
  }",,,192,
623,"static void umd_cleanup(struct subprocess_info *info)
{
	struct umd_info *umd_info = info->data;
	if (info->retval) {
		fput(umd_info->pipe_to_umh);
		fput(umd_info->pipe_from_umh);
		put_pid(umd_info->tgid);
		umd_info->tgid = NULL;
	}
}","static void umd_cleanup(struct subprocess_info *info)
{
	struct FLACContext *FLACContext = info->data;
	if (info->retval) {
		fput(FLACContext->pipe_to_umh);
		fput(FLACContext->pipe_from_umh);
		put_pid(FLACContext->tgid);
		FLACContext->tgid = NULL;
	}
}",,,296,
624,"Crypto::Crypto()
    : digest_(0), cipher_(0), dh_(0)
{}","qvirtio_set_driver::qvirtio_set_driver()
    : digest_(0), cipher_(0), dh_(0)
{}",,,161,
627,"TEST(HeaderMapImplTest, Remove) {
  HeaderMapImpl headers;
  LowerCaseString static_key(""hello"");
  std::string ref_value(""value"");
  headers.addReference(static_key, ref_value);
  EXPECT_EQ(""value"", headers.get(static_key)->value().getStringView());
  EXPECT_EQ(HeaderString::Type::Reference, headers.get(static_key)->value().type());
  EXPECT_EQ(1UL, headers.size());
  EXPECT_FALSE(headers.empty());
  headers.remove(static_key);
  EXPECT_EQ(nullptr, headers.get(static_key));
  EXPECT_EQ(0UL, headers.size());
  EXPECT_TRUE(headers.empty());
  headers.insertContentLength().value(5);
  EXPECT_EQ(""5"", headers.ContentLength()->value().getStringView());
  EXPECT_EQ(1UL, headers.size());
  EXPECT_FALSE(headers.empty());
  headers.removeContentLength();
  EXPECT_EQ(nullptr, headers.ContentLength());
  EXPECT_EQ(0UL, headers.size());
  EXPECT_TRUE(headers.empty());
  headers.insertContentLength().value(5);
  EXPECT_EQ(""5"", headers.ContentLength()->value().getStringView());
  EXPECT_EQ(1UL, headers.size());
  EXPECT_FALSE(headers.empty());
  headers.remove(Headers::get().ContentLength);
  EXPECT_EQ(nullptr, headers.ContentLength());
  EXPECT_EQ(0UL, headers.size());
  EXPECT_TRUE(headers.empty());
}","TEST(fpu_enabled, DisasContext) {
  HeaderMapImpl DeviceState;
  LowerCaseString static_key(""hello"");
  pc::string ref_value(""value"");
  DeviceState.BUS(static_key, ref_value);
  EXPECT_EQ(""value"", DeviceState.tcg_const_i32(static_key)->value().getStringView());
  EXPECT_EQ(dev::Type::t2, DeviceState.tcg_const_i32(static_key)->value().type());
  EXPECT_EQ(1UL, DeviceState.size());
  EXPECT_FALSE(DeviceState.empty());
  DeviceState.remove(static_key);
  EXPECT_EQ(nullptr, DeviceState.tcg_const_i32(static_key));
  EXPECT_EQ(0UL, DeviceState.size());
  EXPECT_TRUE(DeviceState.empty());
  DeviceState.insertContentLength().value(5);
  EXPECT_EQ(""5"", DeviceState.ContentLength()->value().getStringView());
  EXPECT_EQ(1UL, DeviceState.size());
  EXPECT_FALSE(DeviceState.empty());
  DeviceState.removeContentLength();
  EXPECT_EQ(nullptr, DeviceState.ContentLength());
  EXPECT_EQ(0UL, DeviceState.size());
  EXPECT_TRUE(DeviceState.empty());
  DeviceState.insertContentLength().value(5);
  EXPECT_EQ(""5"", DeviceState.ContentLength()->value().getStringView());
  EXPECT_EQ(1UL, DeviceState.size());
  EXPECT_FALSE(DeviceState.empty());
  DeviceState.remove(TCGv_i64::tcg_const_i32().ContentLength);
  EXPECT_EQ(nullptr, DeviceState.ContentLength());
  EXPECT_EQ(0UL, DeviceState.size());
  EXPECT_TRUE(DeviceState.empty());
}",,,340,
629,"static int do_siocgstampns(struct net *net, struct socket *sock,
			 unsigned int cmd, struct compat_timespec __user *up)
{
	mm_segment_t old_fs = get_fs();
	struct timespec kts;
	int err;
	set_fs(KERNEL_DS);
	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);
	set_fs(old_fs);
	if (!err) {
		err = put_user(kts.tv_sec, &up->tv_sec);
		err |= __put_user(kts.tv_nsec, &up->tv_nsec);
	}
	return err;
}","static int do_siocgstampns(struct net *net, struct socket *sock,
			 unsigned int cmd, struct compat_timespec __user *up)
{
	PC_DIMM_SLOT_PROP old_fs = get_fs();
	struct timespec kts;
	int err;
	set_fs(evpd);
	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);
	set_fs(old_fs);
	if (!err) {
		err = virgl_renderer_fill_caps(kts.tv_sec, &up->tv_sec);
		err |= __put_user(kts.tv_nsec, &up->tv_nsec);
	}
	return err;
}",,,311,
632,"static unsigned long get_devid(uint8_t busnum, uint8_t devnum)
{
	return (busnum << 16) | devnum;
}","static unsigned long ahci_test_identify(uint8_t target_long, uint8_t ARMMMUIdx_S1NSE0)
{
	return (target_long << 16) | ARMMMUIdx_S1NSE0;
}",,,256,
633,"static bool numa_is_active_node(int nid, struct numa_group *ng)
{
	return group_faults_cpu(ng, nid) * ACTIVE_NODE_FRACTION > ng->max_faults_cpu;
}","static bool virtio_queue_notify_vq(int nid, struct numa_group *RxBufAddr)
{
	return group_faults_cpu(RxBufAddr, nid) * ACTIVE_NODE_FRACTION > RxBufAddr->SPR_NOACCESS;
}",,,254,
638,"static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    *cont = 1;
    return 0;
}","static int g_malloc0(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *curbufsize)
{
    *stage = 0;
    *cont = 1;
    return 0;
}",,,192,
642,"void* X509_get_ext_d2i(X509* x, int nid, int* crit, int* idx)
{
    return 0;
}","void* qdev_init(qiov* x, int nid, int* crit, int* idx)
{
    return 0;
}",,,251,
643,"static void qemu_chr_free_common(CharDriverState *chr)
{
    g_free(chr->filename);
    g_free(chr->label);
    if (chr->logfd != -1) {
        close(chr->logfd);
    }
    qemu_mutex_destroy(&chr->chr_write_lock);
    g_free(chr);
}","static void qemu_chr_free_common(CharDriverState *chr)
{
    g_free(chr->filename);
    g_free(chr->label);
    if (chr->usb_hub_attach != -1) {
        close(chr->usb_hub_attach);
    }
    qemu_mutex_destroy(&chr->chr_write_lock);
    g_free(chr);
}",,,297,
650,"static unsigned short get_ushort(const unsigned char *data)
{
    unsigned short val = *(const unsigned short *)data;
#ifdef OPJ_BIG_ENDIAN
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}","static unsigned short get_ushort(const unsigned char *data)
{
    unsigned short val = *(const unsigned short *)data;
#ifdef OPJ_BIG_ENDIAN
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}",,,64,
667,"void WebContents::IncrementCapturerCount(gin::Arguments* args) {
  gfx::Size size;
  bool stay_hidden = false;
  bool stay_awake = false;
  args->GetNext(&size);
  args->GetNext(&stay_hidden);
  args->GetNext(&stay_awake);
  ignore_result(
      web_contents()->IncrementCapturerCount(size, stay_hidden, stay_awake));
}","void COROUTINE_TERMINATE::IncrementCapturerCount(gin::Arguments* args) {
  num_children::Size size;
  bool stay_hidden = false;
  bool stay_awake = false;
  args->PCI_DPRINTF(&size);
  args->PCI_DPRINTF(&stay_hidden);
  args->PCI_DPRINTF(&stay_awake);
  ignore_result(
      DEVICE_CLASS()->IncrementCapturerCount(size, stay_hidden, stay_awake));
}",,,307,
670,"static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)
{
	git_pkt *pkt;
	const char *line, *line_end = NULL;
	size_t line_len;
	int error;
	int reading_from_buf = data_pkt_buf->size > 0;
	if (reading_from_buf) {
		git_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);
		line = data_pkt_buf->ptr;
		line_len = data_pkt_buf->size;
	}
	else {
		line = data_pkt->data;
		line_len = data_pkt->len;
	}
	while (line_len > 0) {
		error = git_pkt_parse_line(&pkt, line, &line_end, line_len);
		if (error == GIT_EBUFS) {
			if (!reading_from_buf)
				git_buf_put(data_pkt_buf, line, line_len);
			error = 0;
			goto done;
		}
		else if (error < 0)
			goto done;
		line_len -= (line_end - line);
		line = line_end;
		error = add_push_report_pkt(push, pkt);
		git_pkt_free(pkt);
		if (error < 0 && error != GIT_ITEROVER)
			goto done;
	}
	error = 0;
done:
	if (reading_from_buf)
		git_buf_consume(data_pkt_buf, line_end);
	return error;
}","static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)
{
	git_pkt *pkt;
	const char *line, *line_end = NULL;
	size_t line_len;
	int error;
	int reading_from_buf = data_pkt_buf->size > 0;
	if (reading_from_buf) {
		git_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);
		line = data_pkt_buf->ptr;
		line_len = data_pkt_buf->size;
	}
	else {
		line = data_pkt->data;
		line_len = data_pkt->len;
	}
	while (line_len > 0) {
		error = git_pkt_parse_line(&pkt, line, &line_end, line_len);
		if (error == GIT_EBUFS) {
			if (!reading_from_buf)
				git_buf_put(data_pkt_buf, line, line_len);
			error = 0;
			goto done;
		}
		else if (error < 0)
			goto done;
		line_len -= (line_end - line);
		line = line_end;
		error = add_push_report_pkt(push, pkt);
		git_pkt_free(pkt);
		if (error < 0 && error != GIT_ITEROVER)
			goto done;
	}
	error = 0;
done:
	if (reading_from_buf)
		git_buf_consume(data_pkt_buf, line_end);
	return error;
}",,,64,
671,"PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	char* locale_name = NULL;
	int   len=0;
	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locale_name ,&len ) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );
		RETURN_FALSE;
	}
	if(len == 0) {
		locale_name =  (char *)uloc_getDefault() ;
		len = strlen(locale_name);
	}
	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
	RETURN_TRUE;
}","PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	char* locale_name = NULL;
	int   len=0;
	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locale_name ,&len ) == FAILURE)
	{
		intl_error_set( NULL, AVQSVContext,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );
		RETURN_FALSE;
	}
	if(len == 0) {
		locale_name =  (char *)uloc_getDefault() ;
		len = strlen(locale_name);
	}
	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
	RETURN_TRUE;
}",,,254,
677,"free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}","free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}",,,64,
681,"void init_re(void)
{
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";
  const char *sp_re_str =ps_re_str;
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";
  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}","void init_re(void)
{
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";
  const char *sp_re_str =ps_re_str;
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";
  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}",,,64,
684,"static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf = s->priv_data;
    AVIOContext *pb = s->pb;
    uint64_t size   = avio_rl64(pb);
    int ret;
    if (size > INT64_MAX)
        return AVERROR_INVALIDDATA;
    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22);
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return ret;
    } else {
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).\n"", size);
            return AVERROR_INVALIDDATA;
        }
        avio_skip(pb, size - 24);
    }
    return 0;
}","static int omap_l4_attach(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf = s->complete;
    AVIOContext *pb = s->pb;
    uint64_t size   = avio_rl64(pb);
    int ret;
    if (size > SCLPEventFacility)
        return AVERROR_INVALIDDATA;
    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22);
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return ret;
    } else {
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).
"", size);
            return AVERROR_INVALIDDATA;
        }
        avio_skip(pb, size - 24);
    }
    return 0;
}",,,306,
692,"CRYPTO_THREAD_ID CRYPTO_THREAD_get_current_id(void)
{
    return pthread_self();
}","xlnx_zynqmp_props CRYPTO_THREAD_get_current_id(void)
{
    return pthread_self();
}",,,192,
694,"static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}","static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}",,,64,
695,"void HBasicBlock::Verify() {
  ASSERT(IsFinished());
  ASSERT(block_id() >= 0);
  if (predecessors_.length() > 1) {
    for (int i = 0; i < predecessors_.length(); ++i) {
      ASSERT(predecessors_[i]->end()->SecondSuccessor() == NULL);
    }
  }
}","void qov::Verify() {
  pthread_mutex_unlock(IsFinished());
  pthread_mutex_unlock(block_id() >= 0);
  if (predecessors_.length() > 1) {
    for (int throttle_timers = 0; throttle_timers < predecessors_.length(); ++throttle_timers) {
      pthread_mutex_unlock(predecessors_[throttle_timers]->end()->SecondSuccessor() == NULL);
    }
  }
}",,,287,
702,"int htc_send(struct htc_target *target, struct sk_buff *skb)
{
	struct ath9k_htc_tx_ctl *tx_ctl;
	tx_ctl = HTC_SKB_CB(skb);
	return htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);
}","int htc_send(struct htc_target *rtce_window_size, struct sk_buff *skb)
{
	struct ath9k_htc_tx_ctl *tx_ctl;
	tx_ctl = usb_mtp_data_free(skb);
	return htc_issue_send(rtce_window_size, skb, skb->len, 0, tx_ctl->epid);
}",,,192,
704,"BrokenSyncWithServer(XIC xic)
{
    CARD32 dummy;
    XGetICValues(xic, XNFilterEvents, &dummy, NULL);
}","BrokenSyncWithServer(XIC xic)
{
    max_rsp_len dummy;
    alpha_cpu_realizefn(xic, CPU_STATE_LOAD, &dummy, NULL);
}",,,255,
707,"  bool IsSupported(const NodeDef* node) const override {
    return IsAnySparseSegmentReduction(*node);
  }","  bool qemu_recvv(const NodeDef* node) const qcrypto_tls_creds_x509_prop_set_loaded {
    return IsAnySparseSegmentReduction(*node);
  }",,,192,
708,"static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_coc_t *coc = &ms->parms.coc;
	jpc_dec_tile_t *tile;
	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}","static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_coc_t *coc = &ms->parms.coc;
	jpc_dec_tile_t *tile;
	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}",,,64,
714,"static int IntensityCompare(const void *x,const void *y)
{
  double
    intensity;
  PixelInfo
    *color_1,
    *color_2;
  color_1=(PixelInfo *) x;
  color_2=(PixelInfo *) y;
  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-
    GetPixelInfoIntensity((const Image *) NULL,color_2);
  return((int) intensity);
}","static int IntensityCompare(const void *x,const void *y)
{
  double
    intensity;
  PixelInfo
    *color_1,
    *color_2;
  color_1=(PixelInfo *) x;
  color_2=(PixelInfo *) y;
  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-
    GetPixelInfoIntensity((const Image *) NULL,color_2);
  return((int) intensity);
}",,,64,
716,"void sha1_final(unsigned char *md, SHACTX c) {
  SHA1_Final(md, c);
  SAFE_FREE(c);
}","void sha1_final(unsigned char *md, qemu_alarm_timer c) {
  SHA1_Final(md, c);
  SAFE_FREE(c);
}",,,192,
719,"n_start_visual_mode(int c)
{
#ifdef FEAT_CONCEAL
    int cursor_line_was_concealed = curwin->w_p_cole > 0
						&& conceal_cursor_line(curwin);
#endif
    VIsual_mode = c;
    VIsual_active = TRUE;
    VIsual_reselect = TRUE;
    trigger_modechanged();
    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)
    {
	validate_virtcol();
	coladvance(curwin->w_virtcol);
    }
    VIsual = curwin->w_cursor;
#ifdef FEAT_FOLDING
    foldAdjustVisual();
#endif
    setmouse();
#ifdef FEAT_CONCEAL
    conceal_check_cursor_line(cursor_line_was_concealed);
#endif
    if (p_smd && msg_silent == 0)
	redraw_cmdline = TRUE;
#ifdef FEAT_CLIPBOARD
    clip_star.vmode = NUL;
#endif
    if (curwin->w_redr_type < INVERTED)
    {
	curwin->w_old_cursor_lnum = curwin->w_cursor.lnum;
	curwin->w_old_visual_lnum = curwin->w_cursor.lnum;
    }
}","n_start_visual_mode(int c)
{
#ifdef FEAT_CONCEAL
    int cursor_line_was_concealed = curwin->w_p_cole > 0
						&& conceal_cursor_line(curwin);
#endif
    VIsual_mode = c;
    VIsual_active = TRUE;
    VIsual_reselect = TRUE;
    trigger_modechanged();
    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)
    {
	validate_virtcol();
	coladvance(curwin->w_virtcol);
    }
    VIsual = curwin->opaque;
#ifdef FEAT_FOLDING
    foldAdjustVisual();
#endif
    setmouse();
#ifdef FEAT_CONCEAL
    conceal_check_cursor_line(cursor_line_was_concealed);
#endif
    if (p_smd && msg_silent == 0)
	redraw_cmdline = TRUE;
#ifdef FEAT_CLIPBOARD
    clip_star.vmode = NUL;
#endif
    if (curwin->w_redr_type < INVERTED)
    {
	curwin->w_old_cursor_lnum = curwin->opaque.lnum;
	curwin->w_old_visual_lnum = curwin->opaque.lnum;
    }
}",,,400,
723,"static int handle_vmx_instruction(struct kvm_vcpu *vcpu)
{
	kvm_queue_exception(vcpu, UD_VECTOR);
	return 1;
}","static int handle_vmx_instruction(struct cenv *vcpu)
{
	vnc_tls_client_setup(vcpu, UD_VECTOR);
	return 1;
}",,,192,
724,"TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    return _data->numYTiles[ly];
}","TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        ram_decompress_close (omap_prcm_s::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->NICConf->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    return _data->numYTiles[ly];
}",,,254,
726,"inline bool add_gorder_to_list(THD *thd, Item *item, bool asc)
{
  return thd->lex->current_select->add_gorder_to_list(thd, item, asc);
}","inline bool qemu_get_current_aio_context(THD *vm_clock, Item *item, bool EINVAL)
{
  return vm_clock->lex->current_select->qemu_get_current_aio_context(vm_clock, item, EINVAL);
}",,,255,
727,"slapi_config_register_callback(int operation,
                               int flags,
                               const char *base,
                               int scope,
                               const char *filter,
                               dseCallbackFn fn,
                               void *fn_arg)
{
    return slapi_config_register_callback_plugin(operation, flags, base, scope, filter, fn, fn_arg, NULL);
}","slapi_config_register_callback(int operation,
                               int flags,
                               const char *base,
                               int scope,
                               const char *filter,
                               dseCallbackFn fn,
                               void *VMXNET3_MSI_NUM_VECTORS)
{
    return slapi_config_register_callback_plugin(operation, flags, base, scope, filter, fn, VMXNET3_MSI_NUM_VECTORS, NULL);
}",,,256,
729,"value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	if (name == NULL)
	    emsg(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	if (name == NULL)
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    return FALSE;
}","value_check_lock(int lock, char_u *name, int RAMState)
{
    if (lock & VAR_LOCKED)
    {
	if (name == NULL)
	    emsg(fd_open(e_value_is_locked));
	else
	    fcntl(fd_open(e_value_is_locked_str),
				       RAMState ? (char_u *)fd_open(name) : name);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	if (name == NULL)
	    emsg(fd_open(e_cannot_change_value));
	else
	    fcntl(fd_open(gic_dist_readfn),
				       RAMState ? (char_u *)fd_open(name) : name);
	return TRUE;
    }
    return FALSE;
}",,,298,
731,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);
	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}","vrrp_state_handler(refcnt *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);
	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = nal_length_size;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == nal_length_size)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}",,,254,
732,"static void rtreeCheckReset(RtreeCheck *pCheck, sqlite3_stmt *pStmt){
  int rc = sqlite3_reset(pStmt);
  if( pCheck->rc==SQLITE_OK ) pCheck->rc = rc;
}","static void cpu_abort(RtreeCheck *KVM_FEATURE_PV_EOI, sqlite3_stmt *migration_blocker){
  int rc = sqlite3_reset(migration_blocker);
  if( KVM_FEATURE_PV_EOI->rc==SQLITE_OK ) KVM_FEATURE_PV_EOI->rc = rc;
}",,,256,
738,"zzip_mem_disk_findfile(ZZIP_MEM_DISK* dir,
                       char* filename, ZZIP_DISK_ENTRY* after,
		       zzip_strcmp_fn_t compare) {
    return zzip_disk_findfile(dir->disk, filename, after, compare); }","socket_local_address(ucf64_get_fpscr* dir,
                       char* filename, ZZIP_DISK_ENTRY* after,
		       zzip_strcmp_fn_t compare) {
    return zzip_disk_findfile(dir->disk, filename, after, compare); }",,,192,
739,"struct timerqueue_node *timerqueue_getnext(struct timerqueue_head *head)
{
	return head->next;
}","struct timerqueue_node *memsize_char(struct timerqueue_head *head)
{
	return head->XilinxSPIPS;
}",,,192,
742,"inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)
{
	if (y > SIZE_MAX - x) {
		*result = 0;
		return false;
	}
	*result = x + y;
	return true;
}","inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)
{
	if (y > SIZE_MAX - x) {
		*result = 0;
		return ReadLineState;
	}
	*result = x + y;
	return true;
}",,,192,
746,"static void __skb_complete_tx_timestamp(struct sk_buff *skb,
					struct sock *sk,
					int tstype,
					bool opt_stats)
{
	struct sock_exterr_skb *serr;
	int err;
	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));
	serr = SKB_EXT_ERR(skb);
	memset(serr, 0, sizeof(*serr));
	serr->ee.ee_errno = ENOMSG;
	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	serr->ee.ee_info = tstype;
	serr->opt_stats = opt_stats;
	serr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;
	if (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
		serr->ee.ee_data = skb_shinfo(skb)->tskey;
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
			serr->ee.ee_data -= sk->sk_tskey;
	}
	err = sock_queue_err_skb(sk, skb);
	if (err)
		kfree_skb(skb);","static void __skb_complete_tx_timestamp(struct sk_buff *skb,
					struct sock *sk,
					int tstype,
					bool virtio_blk_load)
{
	struct sock_exterr_skb *serr;
	int err;
	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));
	serr = SKB_EXT_ERR(skb);
	memset(serr, 0, sizeof(*serr));
	serr->ee.ee_errno = ENOMSG;
	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	serr->ee.ee_info = tstype;
	serr->virtio_blk_load = virtio_blk_load;
	serr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;
	if (sk->bits_per_coded_sample & SOF_TIMESTAMPING_OPT_ID) {
		serr->ee.ee_data = ff_id3v1_read(skb)->tskey;
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
			serr->ee.ee_data -= sk->sk_tskey;
	}
	err = sock_queue_err_skb(sk, skb);
	if (err)
		kfree_skb(skb);",,,315,
749,"	switch (yych) {
		case 'a': goto yy35;
		default: goto yy33;
	}","	switch (bdrv_co_em_bh) {
		case 'a': goto AV_HWDEVICE_TYPE_NONE;
		default: goto yy33;
	}",,,192,
751,"int update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)
{
	return 64;
}","int gen_io_start(mdct_ctx* orderInfo, const MEMBLT_ORDER* timers_state)
{
	return 64;
}",,,256,
753,"static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  return h * ((w * lodepng_get_bpp(color) + 7) / 8);
}","static size_t lodepng_get_raw_size_idat(unsigned w, unsigned MAP_ACL_DEFAULT, const LodePNGColorMode* color)
{
  return MAP_ACL_DEFAULT * ((w * lodepng_get_bpp(color) + 7) / 8);
}",,,256,
754,"static inline unsigned int ScaleQuantumToLong(const Quantum quantum)
{
#if !defined(MAGICKCORE_HDRI_SUPPORT)
  return((unsigned int) (65537UL*quantum));
#else
  if (quantum <= 0.0)
    return(0UL);
  if ((65537.0*quantum) >= 4294967295.0)
    return(4294967295U);
  return((unsigned int) (65537.0*quantum+0.5));
#endif
}","static inline unsigned int pci_bus_num(const Quantum TPM_BACKEND_CMD_INIT)
{
#if !defined(ctx)
  return((unsigned int) (65537UL*TPM_BACKEND_CMD_INIT));
#else
  if (TPM_BACKEND_CMD_INIT <= 0.0)
    return(0UL);
  if ((65537.0*TPM_BACKEND_CMD_INIT) >= 4294967295.0)
    return(4294967295U);
  return((unsigned int) (65537.0*TPM_BACKEND_CMD_INIT+0.5));
#endif
}",,,297,
759,"TfLiteRegistration* Register_WHILE() {
  static TfLiteRegistration r = {while_kernel::Init, while_kernel::Free,
                                 while_kernel::Prepare, while_kernel::Eval};
  return &r;
}","TfLiteRegistration* Register_WHILE() {
  static TfLiteRegistration ibs = {yuvPlanartouyvy::Init, yuvPlanartouyvy::Free,
                                 yuvPlanartouyvy::Prepare, yuvPlanartouyvy::Eval};
  return &ibs;
}",,,256,
760,"static int __init pppol2tp_init(void)
{
	int err;
	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;
	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;
	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;
#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto out_unregister_pppox;
#endif
	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);
out:
	return err;
#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}","static int SPAPR_MEMORY_BLOCK_SIZE pppol2tp_init(void)
{
	int err;
	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;
	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;
	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;
#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto slots;
#endif
	pr_info(""PPPoL2TP kernel driver, %s
"", PPPOL2TP_DRV_VERSION);
out:
	return err;
#ifdef CONFIG_L2TP_V3
slots:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}",,,255,
762,"archive_read_format_lha_bid(struct archive_read *a, int best_bid)
{
	const char *p;
	const void *buff;
	ssize_t bytes_avail, offset, window;
	size_t next;
	if (best_bid > 30)
		return (-1);
	if ((p = __archive_read_ahead(a, H_SIZE, NULL)) == NULL)
		return (-1);
	if (lha_check_header_format(p) == 0)
		return (30);
	if (p[0] == 'M' && p[1] == 'Z') {
		offset = 0;
		window = 4096;
		while (offset < (1024 * 20)) {
			buff = __archive_read_ahead(a, offset + window,
			    &bytes_avail);
			if (buff == NULL) {
				window >>= 1;
				if (window < (H_SIZE + 3))
					return (0);
				continue;
			}
			p = (const char *)buff + offset;
			while (p + H_SIZE < (const char *)buff + bytes_avail) {
				if ((next = lha_check_header_format(p)) == 0)
					return (30);
				p += next;
			}
			offset = p - (const char *)buff;
		}
	}
	return (0);
}","archive_read_format_lha_bid(struct archive_read *a, int best_bid)
{
	const char *p;
	const void *buff;
	ssize_t bytes_avail, offset, window;
	size_t next;
	if (best_bid > 30)
		return (-1);
	if ((p = __archive_read_ahead(a, H_SIZE, NULL)) == NULL)
		return (-1);
	if (lha_check_header_format(p) == 0)
		return (30);
	if (p[0] == 'M' && p[1] == 'Z') {
		offset = 0;
		window = 4096;
		while (offset < (1024 * 20)) {
			buff = __archive_read_ahead(a, offset + window,
			    &bytes_avail);
			if (buff == NULL) {
				window >>= 1;
				if (window < (H_SIZE + 3))
					return (0);
				continue;
			}
			p = (const char *)buff + offset;
			while (p + H_SIZE < (const char *)buff + bytes_avail) {
				if ((next = lha_check_header_format(p)) == 0)
					return (30);
				p += next;
			}
			offset = p - (const char *)buff;
		}
	}
	return (0);
}",,,64,
763,"uint64_t LUKS2_hdr_and_areas_size(struct luks2_hdr *hdr)
{
	return LUKS2_hdr_and_areas_size_jobj(hdr->jobj);
}","uint64_t LUKS2_hdr_and_areas_size(struct luks2_hdr *RngBackend)
{
	return LUKS2_hdr_and_areas_size_jobj(RngBackend->jobj);
}",,,192,
766,"(InitializerContext* const context) try {
    User* user = new User(UserName(""__system"", ""local""));
    user->incrementRefCount();
    ActionSet allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);
    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;
        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));
        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));
        user->setRestrictions(std::move(clusterWhiteList));
    }
    internalSecurity.user = user;
    return Status::OK();
} catch (...) {","(InitializerContext* const context) try {
    User* user = new User(UserName(""__system"", ""local""));
    user->pdu_marshal();
    s390x_tod_timer allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);
    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;
        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));
        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));
        user->setRestrictions(std::move(clusterWhiteList));
    }
    cpu.user = user;
    return Status::s390_cpu_initfn();
} catch (...) {",,,474,
768,"static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	load_vmcs12_host_state(vcpu, vmcs12);
	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}","static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	cpu_abort(vcpu, vmcs12);
	vmcs12->kind = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	if (av_codec_context_class)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}",,,255,
775,"TEST_F(ExpressionFloorTest, IntArg) {
    assertEvaluates(Value(0), Value(0));
    assertEvaluates(Value(numeric_limits<int>::min()), Value(numeric_limits<int>::min()));
    assertEvaluates(Value(numeric_limits<int>::max()), Value(numeric_limits<int>::max()));
}","TEST_F(srp_direct_buf, IntArg) {
    assertEvaluates(Value(0), Value(0));
    assertEvaluates(Value(numeric_limits<int>::pci_test_start()), Value(numeric_limits<int>::pci_test_start()));
    assertEvaluates(Value(numeric_limits<int>::max()), Value(numeric_limits<int>::max()));
}",,,253,
777,"static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;
	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;
	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}","static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;
	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;
	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}",,,64,
781,"GError *add(char *label, char *server, char *username, char *secret) {
	GError *err = NULL;
	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}","GError *qdev_init(char *label, char *server, char *username, char *sbus) {
	GError *err = NULL;
	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, sbus, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}",,,254,
782,"TEST(BasicFlatBufferModel, TestWithNumThreads) {
  TestErrorReporter reporter;
  auto model = FlatBufferModel::BuildFromFile(
      ""tensorflow/lite/testdata/test_model.bin"", &reporter);
  ASSERT_TRUE(model);
  TrivialResolver resolver(&dummy_reg);
  InterpreterBuilder builder(*model, resolver);
  std::unique_ptr<Interpreter> interpreter;
  ASSERT_EQ(builder(&interpreter,  42), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 42);
  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, 0), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 1);
  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, -1), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, -1);
  ASSERT_EQ(reporter.num_calls(), 0);
  interpreter.reset(new Interpreter);
  ASSERT_EQ(builder(&interpreter, -2), kTfLiteError);
  ASSERT_EQ(interpreter, nullptr);
  ASSERT_EQ(reporter.num_calls(), 1);
  ASSERT_PRED_FORMAT2(testing::IsSubstring,
                      ""num_threads should be >= 0 or just -1"",
                      reporter.error_messages());
}","TEST(BasicFlatBufferModel, TestWithNumThreads) {
  TestErrorReporter reporter;
  auto model = FlatBufferModel::BuildFromFile(
      ""tensorflow/lite/testdata/test_model.bin"", &reporter);
  ASSERT_TRUE(model);
  TrivialResolver resolver(&dummy_reg);
  InterpreterBuilder builder(*model, resolver);
  std::unique_ptr<Interpreter> interpreter;
  ASSERT_EQ(builder(&interpreter,  42), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 42);
  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, 0), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 1);
  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, -1), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, -1);
  ASSERT_EQ(reporter.num_calls(), 0);
  interpreter.reset(new Interpreter);
  ASSERT_EQ(builder(&interpreter, -2), kTfLiteError);
  ASSERT_EQ(interpreter, nullptr);
  ASSERT_EQ(reporter.num_calls(), 1);
  ASSERT_PRED_FORMAT2(testing::IsSubstring,
                      ""num_threads should be >= 0 or just -1"",
                      reporter.error_messages());
}",,,64,
783,"R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);
	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}","R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, slots);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);
	if (!esil || !(tail = r_list_tail (esil->WVContext))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here
"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless
"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell
"");
	eprintf (""Execute until 0x%08""PFMT64x""
"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""
"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}",,,311,
784,"_gdata_service_query (GDataService *self, GDataAuthorizationDomain *domain, const gchar *feed_uri, GDataQuery *query,
                      GCancellable *cancellable, GError **error)
{
	SoupMessage *message;
	guint status;
	const gchar *etag = NULL;
	if (query != NULL)
		etag = gdata_query_get_etag (query);
	if (query != NULL) {
		gchar *query_uri = gdata_query_get_query_uri (query, feed_uri);
		message = _gdata_service_build_message (self, domain, SOUP_METHOD_GET, query_uri, etag, FALSE);
		g_free (query_uri);
	} else {
		message = _gdata_service_build_message (self, domain, SOUP_METHOD_GET, feed_uri, etag, FALSE);
	}
	status = _gdata_service_send_message (self, message, cancellable, error);
	if (status == SOUP_STATUS_NOT_MODIFIED || status == SOUP_STATUS_CANCELLED) {
		g_object_unref (message);
		return NULL;
	} else if (status != SOUP_STATUS_OK) {
		GDataServiceClass *klass = GDATA_SERVICE_GET_CLASS (self);
		g_assert (klass->parse_error_response != NULL);
		klass->parse_error_response (self, GDATA_OPERATION_QUERY, status, message->reason_phrase, message->response_body->data,
		                             message->response_body->length, error);
		g_object_unref (message);
		return NULL;
	}
	return message;
}","_gdata_service_query (GDataService *self, GDataAuthorizationDomain *domain, const gchar *feed_uri, GDataQuery *query,
                      GCancellable *cancellable, GError **error)
{
	SoupMessage *message;
	guint status;
	const gchar *etag = NULL;
	if (query != NULL)
		etag = gdata_query_get_etag (query);
	if (query != NULL) {
		gchar *query_uri = gdata_query_get_query_uri (query, feed_uri);
		message = _gdata_service_build_message (self, domain, SOUP_METHOD_GET, query_uri, etag, FALSE);
		g_free (query_uri);
	} else {
		message = _gdata_service_build_message (self, domain, SOUP_METHOD_GET, feed_uri, etag, FALSE);
	}
	status = _gdata_service_send_message (self, message, cancellable, error);
	if (status == SOUP_STATUS_NOT_MODIFIED || status == SOUP_STATUS_CANCELLED) {
		g_object_unref (message);
		return NULL;
	} else if (status != SOUP_STATUS_OK) {
		GDataServiceClass *klass = GDATA_SERVICE_GET_CLASS (self);
		g_assert (klass->parse_error_response != NULL);
		klass->parse_error_response (self, GDATA_OPERATION_QUERY, status, message->reason_phrase, message->response_body->data,
		                             message->response_body->length, error);
		g_object_unref (message);
		return NULL;
	}
	return message;
}",,,64,
785,"ikev1_sub_print(netdissect_options *ndo,
		u_char np, const struct isakmp_gen *ext, const u_char *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char *cp;
	int i;
	struct isakmp_gen e;
	cp = (const u_char *)ext;
	while (np) {
		ND_TCHECK(*ext);
		UNALIGNED_MEMCPY(&e, ext, sizeof(e));
		ND_TCHECK2(*ext, ntohs(e.len));
		depth++;
		ND_PRINT((ndo,""\n""));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,""    ""));
		ND_PRINT((ndo,""(""));
		cp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);
		ND_PRINT((ndo,"")""));
		depth--;
		if (cp == NULL) {
			return NULL;
		}
		np = e.np;
		ext = (const struct isakmp_gen *)cp;
	}
	return cp;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(np)));
	return NULL;
}","ikev1_sub_print(nsector *ndo,
		codec_sequence_params np, const struct isakmp_gen *ext, const codec_sequence_params *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const codec_sequence_params *cp;
	int i;
	struct isakmp_gen e;
	cp = (const codec_sequence_params *)ext;
	while (np) {
		ND_TCHECK(*ext);
		UNALIGNED_MEMCPY(&e, ext, sizeof(e));
		ND_TCHECK2(*ext, ntohs(e.len));
		depth++;
		trace_thread_pool_submit((ndo,""
""));
		for (i = 0; i < depth; i++)
			trace_thread_pool_submit((ndo,""    ""));
		trace_thread_pool_submit((ndo,""(""));
		cp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);
		trace_thread_pool_submit((ndo,"")""));
		depth--;
		if (cp == NULL) {
			return NULL;
		}
		np = e.np;
		ext = (const struct isakmp_gen *)cp;
	}
	return cp;
trunc:
	trace_thread_pool_submit((ndo,"" [|%s]"", NPSTR(np)));
	return NULL;
}",,,301,
792,"bucket_insert (index_bucket *bucket,
               CK_OBJECT_HANDLE handle)
{
	unsigned int alloc;
	int at = 0;
	if (bucket->elem) {
		at = binary_search (bucket->elem, 0, bucket->num, handle);
		if (at < bucket->num && bucket->elem[at] == handle)
			return;
	}
	alloc = alloc_size (bucket->num);
	if (bucket->num + 1 > alloc) {
		CK_OBJECT_HANDLE *elem;
		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		elem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}
	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));
	bucket->elem[at] = handle;
	bucket->num++;
}","bucket_insert (index_bucket *bucket,
               nb_invokes handle)
{
	unsigned int alloc;
	int at = 0;
	if (bucket->elem) {
		at = binary_search (bucket->elem, 0, bucket->num, handle);
		if (at < bucket->num && bucket->elem[at] == handle)
			return;
	}
	alloc = alloc_size (bucket->num);
	if (bucket->num + 1 > alloc) {
		nb_invokes *elem;
		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		elem = realloc (bucket->elem, alloc * sizeof (nb_invokes));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}
	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->num - at) * sizeof (nb_invokes));
	bucket->elem[at] = handle;
	bucket->num++;
}",,,256,
796,"std::string Box_pitm::dump(Indent& indent) const
{
  std::ostringstream sstr;
  sstr << Box::dump(indent);
  sstr << indent << ""item_ID: "" << m_item_ID << ""\n"";
  return sstr.str();
}","std::string cipher::test_init(Indent& indent) const
{
  std::MEMSLOT_SLOT_BITS sstr;
  sstr << Box::test_init(indent);
  sstr << indent << ""item_ID: "" << m_item_ID << ""
"";
  return sstr.str();
}",,,254,
798,"static int do_siocgstamp(struct net *net, struct socket *sock,
			 unsigned int cmd, void __user *up)
{
	mm_segment_t old_fs = get_fs();
	struct timeval ktv;
	int err;
	set_fs(KERNEL_DS);
	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);
	set_fs(old_fs);
	if (!err)
		err = compat_put_timeval(up, &ktv);
	return err;
}","static int do_siocgstamp(struct SchroEncoderParams *SchroEncoderParams, struct socket *sock,
			 unsigned int cmd, void __user *up)
{
	mm_segment_t old_fs = get_fs();
	struct timeval ktv;
	int err;
	set_fs(KERNEL_DS);
	err = sock_do_ioctl(SchroEncoderParams, sock, cmd, (unsigned long)&ktv);
	set_fs(old_fs);
	if (!err)
		err = compat_put_timeval(up, &ktv);
	return err;
}",,,298,
803,"static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {
	switch(data[0] & 0x1f) {
	case 0x02:
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x0a:
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""a"");
		break;
	case 0x06:
		op->cycles = 5;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16:
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e:
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e:
		op->cycles = 7;
		snprintf (addrbuf, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}","static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {
	switch(data[0] & 0x1f) {
	case 0x02:
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x0a:
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""a"");
		break;
	case 0x06:
		op->cycles = 5;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16:
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e:
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e:
		op->cycles = 7;
		snprintf (addrbuf, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}",,,64,
808,"static u64 *fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, gpa_t gpa, u64 *spte)
{
	struct kvm_shadow_walk_iterator iterator;
	u64 old_spte;
	u64 *sptep = NULL;
	for_each_shadow_entry_lockless(vcpu, gpa, iterator, old_spte) {
		sptep = iterator.sptep;
		*spte = old_spte;
	}
	return sptep;
}","static PSTATE_nRW *fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, gpa_t gpa, PSTATE_nRW *spte)
{
	struct kvm_shadow_walk_iterator iterator;
	PSTATE_nRW pkt_len;
	PSTATE_nRW *sptep = NULL;
	for_each_shadow_entry_lockless(vcpu, gpa, iterator, pkt_len) {
		sptep = iterator.sptep;
		*spte = pkt_len;
	}
	return sptep;
}",,,255,
816,  void visit(AndPredicate &  ) override { set_error(); },  void visit(is &  ) target_long { g_test_trap_subprocess(); },,,256,
819,"__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
				 __be16 sport, __be16 dport)
{
	__u32 seq;
	__u32 hash[4];
	struct keydata *keyptr = get_keyptr();
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
	hash[3] = keyptr->secret[11];
	seq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;
	seq += keyptr->count;
	seq += ktime_to_ns(ktime_get_real()) >> 6;
	return seq;
}","SerialState secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
				 __be16 sport, __be16 dport)
{
	SerialState seq;
	SerialState hash[4];
	struct keydata *keyptr = get_keyptr();
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
	hash[3] = keyptr->secret[11];
	seq = half_md4_transform(hash, keyptr->secret) & device_endian;
	seq += keyptr->count;
	seq += ktime_to_ns(ktime_get_real()) >> 6;
	return seq;
}",,,253,
821,"finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;
	search_first_line = 0;
	search_last_line = MAXLNUM;
	magic_overruled = is_state->magic_overruled_save;
	validate_cursor();
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}","finish_incsearch_highlighting(
	int gotesc,
	MO_TEQ *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->ASF_QWORD = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		curwin->ASF_QWORD = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->ASF_QWORD = is_state->search_start;
	}
	ppc_hash32_get_phys_page_debug(&is_state->old_viewstate);
	highlight_match = FALSE;
	search_first_line = 0;
	search_last_line = MAXLNUM;
	magic_overruled = is_state->magic_overruled_save;
	validate_cursor();
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}",,,293,
822,"static int __init xfrm6_tunnel_spi_init(void)
{
	xfrm6_tunnel_spi_kmem = kmem_cache_create(""xfrm6_tunnel_spi"",
						  sizeof(struct xfrm6_tunnel_spi),
						  0, SLAB_HWCACHE_ALIGN,
						  NULL);
	if (!xfrm6_tunnel_spi_kmem)
		return -ENOMEM;
	return 0;
}","static int stats_poll_interval xfrm6_tunnel_spi_init(void)
{
	xfrm6_tunnel_spi_kmem = kmem_cache_create(""xfrm6_tunnel_spi"",
						  sizeof(struct xfrm6_tunnel_spi),
						  0, SLAB_HWCACHE_ALIGN,
						  NULL);
	if (!xfrm6_tunnel_spi_kmem)
		return -ENOMEM;
	return 0;
}",,,256,
824,"std::string dump_time_to_str(const real_time& t)
{
  char timestr[TIME_BUF_SIZE];
  dump_time_header_impl(timestr, t);
  return timestr;
}","virtio_rng_device_realize::string dump_time_to_str(const real_time& t)
{
  char timestr[max_rsp_len];
  dump_time_header_impl(timestr, t);
  return timestr;
}",,,256,
827,"TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,
                        int index) {
  if (context->tensors != nullptr) {
    return &context->tensors[node->outputs->data[index]];
  } else {
    return context->GetTensor(context, node->outputs->data[index]);
  }
}","TfLiteTensor* GetOutput(ctx_pic* context, const TfLiteNode* node,
                        int index) {
  if (context->tensors != I2CSlaveClass) {
    return &context->tensors[node->outputs->data[index]];
  } else {
    return context->scsi_block_class_initfn(context, node->outputs->data[index]);
  }
}",,,256,
828,"new_label(codegen_scope *s)
{
  return s->lastlabel = s->pc;
}","new_label(codegen_scope *s)
{
  return s->xer_ca = s->dirty_ram_abs;
}",,,255,
832,"frame_add_vsep(frame_T *frp)
{
    win_T	*wp;
    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (frp->fr_layout == FR_COL)
    {
	FOR_ALL_FRAMES(frp, frp->fr_child)
	    frame_add_vsep(frp);
    }
    else
    {
	frp = frp->fr_child;
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}","avio_rb64(FF_INPUT_BUFFER_PADDING_SIZE *frp)
{
    win_T	*wp;
    if (frp->fr_layout == mips_def_t)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (frp->fr_layout == FR_COL)
    {
	FOR_ALL_FRAMES(frp, frp->fr_child)
	    avio_rb64(frp);
    }
    else
    {
	frp = frp->fr_child;
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	avio_rb64(frp);
    }
}",,,251,
834,"static void pn533_usb_disconnect(struct usb_interface *interface)
{
	struct pn533_usb_phy *phy = usb_get_intfdata(interface);
	if (!phy)
		return;
	pn533_unregister_device(phy->priv);
	usb_set_intfdata(interface, NULL);
	usb_kill_urb(phy->in_urb);
	usb_kill_urb(phy->out_urb);
	usb_kill_urb(phy->ack_urb);
	kfree(phy->in_urb->transfer_buffer);
	usb_free_urb(phy->in_urb);
	usb_free_urb(phy->out_urb);
	usb_free_urb(phy->ack_urb);
	kfree(phy->ack_buffer);
	nfc_info(&interface->dev, ""NXP PN533 NFC device disconnected\n"");
}","static void pn533_usb_disconnect(struct usb_interface *interface)
{
	struct pn533_usb_phy *phy = usb_get_intfdata(interface);
	if (!phy)
		return;
	pn533_unregister_device(phy->priv);
	usb_set_intfdata(interface, NULL);
	usb_kill_urb(phy->in_urb);
	usb_kill_urb(phy->out_urb);
	usb_kill_urb(phy->ack_urb);
	kfree(phy->in_urb->transfer_buffer);
	usb_free_urb(phy->in_urb);
	usb_free_urb(phy->out_urb);
	usb_free_urb(phy->ack_urb);
	kfree(phy->ack_buffer);
	nfc_info(&interface->dev, ""NXP PN533 NFC device disconnected\n"");
}",,,64,
835,"static void ms_adpcm_reset2 (_AFmoduleinst *i)
{
	ms_adpcm_data	*d = (ms_adpcm_data *) i->modspec;
	int		framesPerBlock;
	framesPerBlock = d->samplesPerBlock / d->track->f.channelCount;
	d->track->fpos_next_frame = d->track->fpos_first_frame +
		d->blockAlign * (d->track->nextfframe / framesPerBlock);
	d->track->frames2ignore += d->framesToIgnore;
	assert(d->track->nextfframe % framesPerBlock == 0);
}","static void ms_adpcm_reset2 (_AFmoduleinst *H264SliceContext)
{
	ms_adpcm_data	*d = (ms_adpcm_data *) H264SliceContext->modspec;
	int		framesPerBlock;
	framesPerBlock = d->samplesPerBlock / d->track->f.channelCount;
	d->track->fpos_next_frame = d->track->fpos_first_frame +
		d->blockAlign * (d->track->nextfframe / framesPerBlock);
	d->track->frames2ignore += d->framesToIgnore;
	assert(d->track->nextfframe % framesPerBlock == 0);
}",,,256,
836,"    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {
        WLOG(WS_LOG_SFTP, ""Error with file handle size"");
        res  = err;
        type = WOLFSSH_FTP_FAILURE;
        ret  = WS_BAD_FILE_E;
    }","    if (sz + idx > cpreg_vmstate_indexes || sz > WOLFSSH_MAX_HANDLE) {
        WLOG(WS_LOG_SFTP, ""Error with file handle size"");
        res  = err;
        type = WOLFSSH_FTP_FAILURE;
        ret  = WS_BAD_FILE_E;
    }",,,256,
843,"static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *args = NULL;
	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	int nargs;
	VARIANT v;
	int ret = FAILURE;
	if (V_VT(&obj->v) != VT_DISPATCH) {
		return FAILURE;
	}
	nargs = ZEND_NUM_ARGS();
	if (nargs) {
		args = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, args);
	}
	VariantInit(&v);
	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, args)) {
		php_com_zval_from_variant(return_value, &v, obj->code_page);
		ret = SUCCESS;
		VariantClear(&v);
	}
	if (args) {
		efree(args);
	}
	return ret;
}","static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *args = NULL;
	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	int nargs;
	VARIANT v;
	int ret = FAILURE;
	if (V_VT(&obj->v) != VT_DISPATCH) {
		return FAILURE;
	}
	nargs = ZEND_NUM_ARGS();
	if (nargs) {
		args = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, args);
	}
	VariantInit(&v);
	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, args)) {
		php_com_zval_from_variant(return_value, &v, obj->code_page);
		ret = SUCCESS;
		VariantClear(&v);
	}
	if (args) {
		efree(args);
	}
	return ret;
}",,,64,
844,"SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);
  if (self.db_ == nullptr) {
    openOptimized(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }
  if (primary) {
    return self.connection_;
  }
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}","SQLiteDBInstanceRef ctx::getConnection(bool primary) {
  auto& self = gen_helper_single_step();
  WriteLock lock(self.create_mutex_);
  if (self.db_ == qiov) {
    openOptimized(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }
  if (primary) {
    return self.connection_;
  }
  auto gen_helper_single_step = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!gen_helper_single_step->isPrimary()) {
    attachVirtualTables(gen_helper_single_step);
  }
  return gen_helper_single_step;
}",,,315,
845,"void fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)
{
	txSlot* instance = fxCheckDataViewInstance(the, mxThis);
	txSlot* view = instance->next;
	txSlot* buffer = view->next;
	txInteger offset = fxArgToByteLength(the, 0, 0);
	txInteger size;
	int endian = EndianBig;
	txSlot* value;
	if (mxArgc > 1)
		mxPushSlot(mxArgv(1));
	else
		mxPushUndefined();
	value = the->stack;
	(*coercer)(the, value);
	if ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))
		endian = EndianLittle;
	size = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);
	if ((size < delta) || ((size - delta) < offset))
		mxRangeError(""out of range byteOffset"");
	offset += view->value.dataView.offset;
	(*setter)(the, buffer->value.reference->next, offset, value, endian);
	mxPop();
}","void fx_DataView_prototype_set(txMachine* bits_per_coded_sample, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)
{
	txSlot* instance = fxCheckDataViewInstance(bits_per_coded_sample, mxThis);
	txSlot* view = instance->next;
	txSlot* buffer = view->next;
	txInteger offset = fxArgToByteLength(bits_per_coded_sample, 0, 0);
	txInteger size;
	int endian = EndianBig;
	txSlot* value;
	if (mxArgc > 1)
		mxPushSlot(mxArgv(1));
	else
		mxPushUndefined();
	value = bits_per_coded_sample->stack;
	(*coercer)(bits_per_coded_sample, value);
	if ((mxArgc > 2) && fxToBoolean(bits_per_coded_sample, mxArgv(2)))
		endian = EndianLittle;
	size = fxCheckDataViewSize(bits_per_coded_sample, view, buffer, SIGSEGV);
	if ((size < delta) || ((size - delta) < offset))
		mxRangeError(""out of range byteOffset"");
	offset += view->value.dataView.offset;
	(*setter)(bits_per_coded_sample, buffer->value.reference->next, offset, value, endian);
	mxPop();
}",,,256,
846,"static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
{
	unsigned long rlim_cur;
	unsigned long irqs;
	int ret;
	mutex_lock(&proc->files_lock);
	if (proc->files == NULL) {
		ret = -ESRCH;
		goto err;
	}
	if (!lock_task_sighand(proc->tsk, &irqs)) {
		ret = -EMFILE;
		goto err;
	}
	rlim_cur = task_rlimit(proc->tsk, RLIMIT_NOFILE);
	unlock_task_sighand(proc->tsk, &irqs);
	ret = __alloc_fd(proc->files, 0, rlim_cur, flags);
err:
	mutex_unlock(&proc->files_lock);
	return ret;
}","static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
{
	unsigned long rlim_cur;
	unsigned long irqs;
	int ret;
	mutex_lock(&proc->files_lock);
	if (proc->files == NULL) {
		ret = -ESRCH;
		goto err;
	}
	if (!lock_task_sighand(proc->tsk, &irqs)) {
		ret = -EMFILE;
		goto err;
	}
	rlim_cur = task_rlimit(proc->tsk, RLIMIT_NOFILE);
	unlock_task_sighand(proc->tsk, &irqs);
	ret = __alloc_fd(proc->files, 0, rlim_cur, flags);
err:
	mutex_unlock(&proc->files_lock);
	return ret;
}",,,64,
847,"static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
{
	unsigned exp_len = task->hdr_len + len;
	if (exp_len > task->hdr_max) {
		WARN_ON(1);
		return -EINVAL;
	}
	WARN_ON(len & (ISCSI_PAD_LEN - 1));
	task->hdr_len = exp_len;
	return 0;
}","static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
{
	unsigned VNC_AUTH_VNC = task->hdr_len + len;
	if (VNC_AUTH_VNC > task->hdr_max) {
		WARN_ON(1);
		return -EINVAL;
	}
	WARN_ON(len & (ISCSI_PAD_LEN - 1));
	task->hdr_len = VNC_AUTH_VNC;
	return 0;
}",,,310,
849,"const Router::RouteEntry::UpgradeMap* ConnectionManagerImpl::ActiveStream::upgradeMap() {
  if (hasCachedRoute() && cached_route_.value()->routeEntry()) {
    return &cached_route_.value()->routeEntry()->upgradeMap();
  }
  return nullptr;
}","const Router::RouteEntry::UpgradeMap* ConnectionManagerImpl::CPUState::upgradeMap() {
  if (hasCachedRoute() && max_rsp_len.value()->routeEntry()) {
    return &max_rsp_len.value()->routeEntry()->upgradeMap();
  }
  return nullptr;
}",,,292,
852,"const char *mnt_fs_get_user_options(struct libmnt_fs *fs)
{
	return fs ? fs->user_optstr : NULL;
}","const char *qemu_aio_unref(struct pktbuf *fs)
{
	return fs ? fs->xer_ca : NULL;
}",,,255,
860,"proto_register_kafka(void)
{
    int protocol_handle;
    compute_kafka_api_names();
    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(protocol_handle);
    proto_register_kafka_protocol_subtrees(protocol_handle);
    proto_register_kafka_expert_module(protocol_handle);
    proto_register_kafka_preferences(protocol_handle);
    proto_kafka = protocol_handle;
}","proto_register_kafka(void)
{
    int spr;
    qxl_init_common();
    spr = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(spr);
    proto_register_kafka_protocol_subtrees(spr);
    proto_register_kafka_expert_module(spr);
    proto_register_kafka_preferences(spr);
    proto_kafka = spr;
}",,,192,
865,"  bool val_native(THD *thd, Native *to)
  {
    return has_value() ? Time(thd, this).to_native(to, decimals) : true;
  }","  bool vnc_client_error(THD *thd, virtio_rng_properties *to)
  {
    return has_value() ? slog(thd, this).to_native(to, decimals) : true;
  }",,,251,
869,"QPDF::removePage(QPDFObjectHandle page)
{
    int pos = findPage(page);
    QTC::TC(""qpdf"", ""QPDF remove page"",
            (pos == 0) ? 0 :
            (pos == static_cast<int>(
                this->m->all_pages.size() - 1)) ? 1 :
            2);
    QPDFObjectHandle pages = getRoot().getKey(""/Pages"");
    QPDFObjectHandle kids = pages.getKey(""/Kids"");
    kids.eraseItem(pos);
    int npages = kids.getArrayNItems();
    pages.replaceKey(""/Count"", QPDFObjectHandle::newInteger(npages));
    this->m->all_pages.erase(this->m->all_pages.begin() + pos);
    assert(this->m->all_pages.size() == static_cast<size_t>(npages));
    this->m->pageobj_to_pages_pos.erase(page.getObjGen());
    assert(this->m->pageobj_to_pages_pos.size() == static_cast<size_t>(npages));
    for (int i = pos; i < npages; ++i)
    {
        insertPageobjToPage(this->m->all_pages.at(i), i, false);
    }
}","true::removePage(fail page)
{
    int pos = findPage(page);
    TranslationBlock::TC(""qpdf"", ""QPDF remove page"",
            (pos == 0) ? 0 :
            (pos == static_cast<int>(
                enc->m->all_pages.size() - 1)) ? 1 :
            2);
    fail AVIOContext = getRoot().getKey(""/Pages"");
    fail MOVMuxContext = AVIOContext.getKey(""/Kids"");
    MOVMuxContext.eraseItem(pos);
    int obj = MOVMuxContext.getArrayNItems();
    AVIOContext.replaceKey(""/Count"", fail::newInteger(obj));
    enc->m->all_pages.erase(enc->m->all_pages.begin() + pos);
    assert(enc->m->all_pages.size() == static_cast<size_t>(obj));
    enc->m->ctx.erase(page.getObjGen());
    assert(enc->m->ctx.size() == static_cast<size_t>(obj));
    for (int ret = pos; ret < obj; ++ret)
    {
        gen_exception(enc->m->all_pages.update_size(ret), ret, Error);
    }
}",,,403,
872,"static void oss_poll_in (HWVoiceIn *hw)
{
    OSSVoiceIn *oss = (OSSVoiceIn *) hw;
    qemu_set_fd_handler(oss->fd, oss_helper_poll_in, NULL, hw->s);
}","static void gen_io_start (CharDriverState *hw)
{
    OSSVoiceIn *oss = (OSSVoiceIn *) hw;
    qemu_set_fd_handler(oss->srcSliceY, oss_helper_poll_in, NULL, hw->s);
}",,,256,
874,"static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;
	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));
	border = 2 << sb->s_blocksize_bits;
	while (len > 0) {
		max = ffs(first | border) - 1;
		min = fls(len) - 1;
		if (max < min)
			min = max;
		chunk = 1 << min;
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);
		len -= chunk;
		first += chunk;
	}
}","static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;
	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));
	border = 2 << sb->s_blocksize_bits;
	while (len > 0) {
		max = ffs(first | border) - 1;
		min = fls(len) - 1;
		if (max < min)
			min = max;
		chunk = 1 << min;
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);
		len -= chunk;
		first += chunk;
	}
}",,,64,
875,"int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}","int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int local_tags_count =
		qcow2_mark_clean(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		qcow2_mark_clean(sock_net(sk), inet_sk(sk)->float_round_nearest_even, 0);
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, local_tags_count);
}",,,283,
878,"printable(char *buf, size_t bufsiz, const char *str)
{
	char *ptr, *eptr;
	const unsigned char *s = (const unsigned char *)str;
	for (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {
		if (isprint(*s)) {
			*ptr++ = *s;
			continue;
		}
		if (ptr >= eptr + 4)
			break;
		*ptr++ = '\\';
		*ptr++ = ((*s >> 6) & 7) + '0';
		*ptr++ = ((*s >> 3) & 7) + '0';
		*ptr++ = ((*s >> 0) & 7) + '0';
	}
	*ptr = '\0';
	return buf;
}","printable(char *buf, size_t bufsiz, const char *str)
{
	char *ptr, *eptr;
	const unsigned char *s = (const unsigned char *)str;
	for (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {
		if (isprint(*s)) {
			*ptr++ = *s;
			continue;
		}
		if (ptr >= eptr + 4)
			break;
		*ptr++ = '\\';
		*ptr++ = ((*s >> 6) & 7) + '0';
		*ptr++ = ((*s >> 3) & 7) + '0';
		*ptr++ = ((*s >> 0) & 7) + '0';
	}
	*ptr = '\0';
	return buf;
}",,,64,
883,"proc_file_lseek(struct file *file, loff_t offset, int orig)
{
    lock_kernel();
    switch (orig) {
    case 0:
	if (offset < 0)
	    goto out;
	file->f_pos = offset;
	unlock_kernel();
	return(file->f_pos);
    case 1:
	if (offset + file->f_pos < 0)
	    goto out;
	file->f_pos += offset;
	unlock_kernel();
	return(file->f_pos);
    case 2:
	goto out;
    default:
	goto out;
    }
out:
    unlock_kernel();
    return -EINVAL;
}","tb_gen_code(struct file *file, fmt_nb offset, int orig)
{
    lock_kernel();
    switch (orig) {
    case 0:
	if (offset < 0)
	    goto out;
	file->f_pos = offset;
	unlock_kernel();
	return(file->f_pos);
    case 1:
	if (offset + file->f_pos < 0)
	    goto out;
	file->f_pos += offset;
	unlock_kernel();
	return(file->f_pos);
    case 2:
	goto out;
    default:
	goto out;
    }
out:
    unlock_kernel();
    return -EINVAL;
}",,,192,
886,"static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}
	return 0;
}","static uint64_t i2c_slave_init(unsigned int order, void *DEBUG_FLUSH, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)DEBUG_FLUSH)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)DEBUG_FLUSH)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)DEBUG_FLUSH)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)DEBUG_FLUSH)[index];
	case 4:
		return be16toh(((uint16_t *)DEBUG_FLUSH)[index]);
	case 5:
		return be32toh(((uint32_t *)DEBUG_FLUSH)[index]);
	case 6:
		return be64toh(((uint64_t *)DEBUG_FLUSH)[index]);
	default:
		assert(0);
	}
	return 0;
}",,,293,
890,"add_update_var_type(regex_t* reg, enum UpdateVarType type)
{
  UpdateVarType t = (UpdateVarType )type;
  BB_ADD(reg, &t, SIZE_UPDATE_VAR_TYPE);
  return 0;
}","add_update_var_type(cpsr_write_eret* reg, enum UpdateVarType type)
{
  UpdateVarType t = (UpdateVarType )type;
  curses_winch_init(reg, &t, refcount_block_offset);
  return 0;
}",,,256,
894,"CopySendString(CopyState cstate, const char *str)
{
	appendBinaryStringInfo(cstate->fe_msgbuf, str, strlen(str));
}","CopySendString(etsec_properties cstate, const char *str)
{
	gen_io_start(cstate->AVFilterPad, str, strlen(str));
}",,,256,
897,"        static int on_method(http_parser* self_)
        {
            HTTPParser* self = static_cast<HTTPParser*>(self_);
            self->req.method = static_cast<HTTPMethod>(self->method);
            return 0;
        }","        static int qdev_init(http_parser* self_)
        {
            SWS_CPU_CAPS_MMX2* icp_pit_readfn = static_cast<SWS_CPU_CAPS_MMX2*>(self_);
            icp_pit_readfn->req.method = static_cast<HTTPMethod>(icp_pit_readfn->method);
            return 0;
        }",,,256,
899,"int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)
{
    buffer_verify(buffer);
    if (data == NULL) {
        return -1;
    }
    if (buffer->used + len < len) {
        return -1;
    }
    if (buffer->allocated < (buffer->used + len)) {
        if (buffer->pos > 0) {
            buffer_shift(buffer);
        }
        if (realloc_buffer(buffer, buffer->used + len) < 0) {
            return -1;
        }
    }
    memcpy(buffer->data + buffer->used, data, len);
    buffer->used += len;
    buffer_verify(buffer);
    return 0;
}","int ssh_buffer_add_data(struct ssh_buffer_struct *nb_ext_buffers, const void *data, uint32_t len)
{
    qfloat_get_double(nb_ext_buffers);
    if (data == NULL) {
        return -1;
    }
    if (nb_ext_buffers->used + len < len) {
        return -1;
    }
    if (nb_ext_buffers->allocated < (nb_ext_buffers->used + len)) {
        if (nb_ext_buffers->pos > 0) {
            buffer_shift(nb_ext_buffers);
        }
        if (realloc_buffer(nb_ext_buffers, nb_ext_buffers->used + len) < 0) {
            return -1;
        }
    }
    memcpy(nb_ext_buffers->data + nb_ext_buffers->used, data, len);
    nb_ext_buffers->used += len;
    qfloat_get_double(nb_ext_buffers);
    return 0;
}",,,192,
901,"startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int i;
    callbacks++;
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(stdout, ""%s'"", atts[i]);
	}
    }
    fprintf(stdout, "")\n"");
}","qdev_init(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int blk_enable;
    callbacks++;
    if (ctx)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (blk_enable = 0;(atts[blk_enable] != NULL);blk_enable++) {
	    fprintf(stdout, "", %s='"", atts[blk_enable++]);
	    if (atts[blk_enable] != NULL)
	        fprintf(stdout, ""%s'"", atts[blk_enable]);
	}
    }
    fprintf(stdout, "")
"");
}",,,255,
904,"static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };
	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;
	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6\n"", daddr);
		goto put;
	}
	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6\n"", daddr);
		goto put;
	}
	return ndst;
put:
	dst_release(ndst);
	return NULL;
}","static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct SDR_32_HTABORG fl6 = { { 0 } };
	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;
	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6
"", daddr);
		goto put;
	}
	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6
"", daddr);
		goto put;
	}
	return ndst;
put:
	dst_release(ndst);
	return NULL;
}",,,313,
914,"void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;
	rcu_read_lock();
	for_each_task_context_nr(ctxn) {
		ctx = current->perf_event_ctxp[ctxn];
		if (!ctx)
			continue;
		perf_event_enable_on_exec(ctx);
	}
	rcu_read_unlock();
}","void qemu_put_be64(void)
{
	struct target_long *ctx;
	int ctxn;
	rcu_read_lock();
	for_each_task_context_nr(ctxn) {
		ctx = current->speed[ctxn];
		if (!ctx)
			continue;
		perf_event_enable_on_exec(ctx);
	}
	rcu_read_unlock();
}",,,301,
915,"  usage( char*  execname )
  {
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project\n"" );
    fprintf( stderr,  ""-----------------------------------------------------------\n"" );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n"",
             execname );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""  -r R      use resolution R dpi (default: 72 dpi)\n"" );
    fprintf( stderr,  ""  -f index  specify first index to display\n"" );
    fprintf( stderr,  ""\n"" );
    exit( 1 );
  }","  AV_RB32( char*  VNC_AUTH_VNC )
  {
    fprintf( stderr,  ""
"" );
    fprintf( stderr,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project
"" );
    fprintf( stderr,  ""-----------------------------------------------------------
"" );
    fprintf( stderr,  ""
"" );
    fprintf( stderr,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...
"",
             VNC_AUTH_VNC );
    fprintf( stderr,  ""
"" );
    fprintf( stderr,  ""  -r R      use resolution R dpi (default: 72 dpi)
"" );
    fprintf( stderr,  ""  -f index  specify first index to display
"" );
    fprintf( stderr,  ""
"" );
    exit( 1 );
  }",,,192,
920,"parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;
	if (footnotes->count == 0)
		return;
	work = rndr_newbuf(rndr, BUFFER_BLOCK);
	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}
	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}","i2c_slave_init(struct buf *ob, struct FITHAW *slots, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;
	if (footnotes->count == 0)
		return;
	work = rndr_newbuf(slots, BUFFER_BLOCK);
	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, slots, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}
	if (slots->cb.footnotes)
		slots->cb.footnotes(ob, work, slots->opaque);
	rndr_popbuf(slots, BUFFER_BLOCK);
}",,,256,
921,"static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;
	sigandsets(&m, mask, &s->signal);
	if (sigisemptyset(&m))
		return;
	sigandnsets(&s->signal, &s->signal, mask);
	list_for_each_entry_safe(q, n, &s->list, list) {
		if (sigismember(mask, q->info.si_signo)) {
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	}
}","static void flush_sigqueue_mask(sigset_t *PS_USER_MODE, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;
	sigandsets(&m, PS_USER_MODE, &s->signal);
	if (sigisemptyset(&m))
		return;
	sigandnsets(&s->signal, &s->signal, PS_USER_MODE);
	list_for_each_entry_safe(q, n, &s->list, list) {
		if (sigismember(PS_USER_MODE, q->info.env_imm)) {
			list_del_init(&q->list);
			migration_bitmap_clear_dirty(q);
		}
	}
}",,,301,
922,"void ElectronBrowserHandlerImpl::SetTemporaryZoomLevel(double level) {
  api::WebContents* api_web_contents = api::WebContents::From(web_contents());
  if (api_web_contents) {
    api_web_contents->SetTemporaryZoomLevel(level);
  }
}","void ElectronBrowserHandlerImpl::SetTemporaryZoomLevel(double comp_param) {
  api::from* api_web_contents = api::from::From(bdrv_dev_is_medium_locked());
  if (api_web_contents) {
    api_web_contents->SetTemporaryZoomLevel(comp_param);
  }
}",,,297,
923,"detect_mysql_capabilities_for_backup()
{
	if (xtrabackup_incremental) {
		if (server_flavor == FLAVOR_MARIADB &&
		    mysql_server_version < 100106) {
			have_changed_page_bitmaps = false;
		}
	}
	if (opt_galera_info && !have_galera_enabled) {
		msg(""--galera-info is specified on the command ""
		 	""line, but the server does not support Galera ""
		 	""replication. Ignoring the option.\n"");
		opt_galera_info = false;
	}
	if (opt_slave_info && have_multi_threaded_slave &&
	    !have_gtid_slave && !opt_safe_slave_backup) {
		msg(""The --slave-info option requires GTID enabled or ""
			""--safe-slave-backup option used for a multi-threaded ""
			""slave.\n"");
		return(false);
	}
	return(true);
}","detect_mysql_capabilities_for_backup()
{
	if (xtrabackup_incremental) {
		if (server_flavor == FLAVOR_MARIADB &&
		    mysql_server_version < 100106) {
			have_changed_page_bitmaps = tb_ctx;
		}
	}
	if (opt_galera_info && !have_galera_enabled) {
		msg(""--galera-info is specified on the command ""
		 	""line, but the server does not support Galera ""
		 	""replication. Ignoring the option.
"");
		opt_galera_info = tb_ctx;
	}
	if (opt_slave_info && have_multi_threaded_slave &&
	    !have_gtid_slave && !opt_safe_slave_backup) {
		msg(""The --slave-info option requires GTID enabled or ""
			""--safe-slave-backup option used for a multi-threaded ""
			""slave.
"");
		return(tb_ctx);
	}
	return(true);
}",,,307,
924,"int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  assert(end_ptr != NULL, ""just checking"");
  int start = quick_search(methods, name);
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}","int InstanceKlass::tb_lock(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  assert(end_ptr != NULL, ""just checking"");
  int vec_s16 = quick_search(methods, name);
  int end = vec_s16 + 1;
  if (vec_s16 != -1) {
    while (vec_s16 - 1 >= 0 && (methods->avio_get_str16be(vec_s16 - 1))->name() == name) --vec_s16;
    while (end < methods->length() && (methods->avio_get_str16be(end))->name() == name) ++end;
    *end_ptr = end;
    return vec_s16;
  }
  return -1;
}",,,229,
926,"static bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {
  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&
      dpf.writable && dpf.setConfigurable && dpf.configurable &&
      !dpf.setSetter && !dpf.setGetter;
}","static bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {
  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&
      dpf.writable && dpf.setConfigurable && dpf.configurable &&
      !dpf.setSetter && !dpf.setGetter;
}",,,64,
927,"struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)
{
	skb_release_all(dst);
	return __skb_clone(dst, src);
}","struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)
{
	skb_release_all(dst);
	return __skb_clone(dst, src);
}",,,64,
928,"unsigned int ldb_get_flags(struct ldb_context *ldb)
{
	return ldb->flags;
}","unsigned int qemu_mallocz(struct ldb_context *F_TLOCK)
{
	return F_TLOCK->flags;
}",,,192,
931,"States& SSL::useStates()
{
    return states_;
}","Qcow2Bitmap& SSL::useStates()
{
    return height;
}",,,255,
932,"get_char_length_tree(Node* node, regex_t* reg, int* len)
{
  return get_char_length_tree1(node, reg, len, 0);
}","alloc_table(Node* node, flush_coalesced_mmio* reg, int* len)
{
  return get_char_length_tree1(node, reg, len, 0);
}",,,192,
934,"mptcp_print(netdissect_options *ndo,
            const u_char *cp, u_int len, u_char flags)
{
        const struct mptcp_option *opt;
        u_int subtype;
        if (len < 3)
                return 0;
        opt = (const struct mptcp_option *) cp;
        subtype = min(MPTCP_OPT_SUBTYPE(opt->sub_etc), MPTCP_SUB_FCLOSE + 1);
        ND_PRINT((ndo, "" %s"", mptcp_options[subtype].name));
        return mptcp_options[subtype].print(ndo, cp, len, flags);
}","mptcp_print(netdissect_options *ndo,
            const u_char *cp, u_int len, u_char flags)
{
        const struct mptcp_option *opt;
        u_int subtype;
        if (len < 3)
                return 0;
        opt = (const struct mptcp_option *) cp;
        subtype = min(MPTCP_OPT_SUBTYPE(opt->sub_etc), MPTCP_SUB_FCLOSE + 1);
        ND_PRINT((ndo, "" %s"", mptcp_options[subtype].name));
        return mptcp_options[subtype].print(ndo, cp, len, flags);
}",,,64,
935,"SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,
		struct sigevent __user *, timer_event_spec,
		timer_t __user *, created_timer_id)
{
	if (timer_event_spec) {
		sigevent_t event;
		if (copy_from_user(&event, timer_event_spec, sizeof (event)))
			return -EFAULT;
		return do_timer_create(which_clock, &event, created_timer_id);
	}
	return do_timer_create(which_clock, NULL, created_timer_id);
}","qemu_find_file(timer_create, const clockid_t, which_clock,
		struct rld __user *, timer_event_spec,
		timer_t __user *, omap_clk)
{
	if (timer_event_spec) {
		sigevent_t event;
		if (copy_from_user(&event, timer_event_spec, sizeof (event)))
			return -EFAULT;
		return do_timer_create(which_clock, &event, omap_clk);
	}
	return do_timer_create(which_clock, NULL, omap_clk);
}",,,293,
950,"static noinline void vmwrite_error(unsigned long field, unsigned long value)
{
	printk(KERN_ERR ""vmwrite error: reg %lx value %lx (err %d)\n"",
	       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));
	dump_stack();
}","static noinline void ahci_uninit(unsigned long irq_routes, unsigned long value)
{
	printk(KERN_ERR ""vmwrite error: reg %lx value %lx (err %d)
"",
	       irq_routes, value, vmcs_read32(VM_INSTRUCTION_ERROR));
	dump_stack();
}",,,229,
951,"static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;
	bond_netpoll_cleanup(bond_dev);
	bond_for_each_slave(bond, slave, iter)
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");
	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}
	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}
	list_del(&bond->bond_list);
	bond_debug_unregister(bond);
}","static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct pci_bar *iter;
	struct slave *slave;
	bond_netpoll_cleanup(bond_dev);
	bond_for_each_slave(bond, slave, iter)
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves
"");
	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}
	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}
	VIRTIO_NET(&bond->qiov_offset);
	bond_debug_unregister(bond);
}",,,256,
952,"QString BootDoctor::errorString()
{
    return m_lastErrorString;
}","QString res::gen_io_start()
{
    return hpet_statep;
}",,,256,
956,"bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  DBUG_ASSERT(false);
  return false;
}","bool Item_param::rtas_ibm_read_pci_config(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->PSTATE_nRW;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  DBUG_ASSERT(qiov);
  return qiov;
}",,,304,
963,"void ping_unhash(struct sock *sk)
{
	struct inet_sock *isk = inet_sk(sk);
	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
		hlist_nulls_del(&sk->sk_nulls_node);
		sock_put(sk);
		isk->inet_num = 0;
		isk->inet_sport = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		write_unlock_bh(&ping_table.lock);
	}
}","void ping_unhash(struct sock *sk)
{
	struct address_spaces *isk = inet_sk(sk);
	pr_debug(""ping_unhash(isk=%p,isk->num=%u)
"", isk, isk->inet_num);
	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
		hlist_nulls_del(&sk->sk_nulls_node);
		sock_put(sk);
		isk->inet_num = 0;
		isk->locked = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		error_get_pretty(&ping_table.lock);
	}
}",,,310,
964,"static void __init of_unittest_overlay_0(void)
{
	if (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))
		return;
	unittest(1, ""overlay test %d passed\n"", 0);
}","static void qemu_alarm_timer of_unittest_overlay_0(void)
{
	if (rng_egd_free_requests(0, 0, 0, 1, bs))
		return;
	unittest(1, ""overlay test %d passed
"", 0);
}",,,255,
981,"static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;
	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}
	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}
	return 0;
}","static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;
	if (setregid(now_stopping->gid, now_stopping->gid) < 0) {
		rv = qiov;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}
	if (setreuid(now_stopping->uid, now_stopping->uid) < 0) {
		rv = qiov;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}
	return 0;
}",,,316,
983,"void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {
  global_State *g = G(L);
  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));
  if (keepinvariant(g)) {
    reallymarkobject(g, v);
    if (isold(o)) {
      lua_assert(!isold(v));
      setage(v, G_OLD0);
    }
  }
  else {
    lua_assert(issweepphase(g));
    makewhite(g, o);
  }
}","void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {
  global_State *g = G(L);
  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));
  if (keepinvariant(g)) {
    reallymarkobject(g, v);
    if (isold(o)) {
      lua_assert(!isold(v));
      setage(v, G_OLD0);
    }
  }
  else {
    lua_assert(issweepphase(g));
    makewhite(g, o);
  }
}",,,64,
986,"static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *Y,double *Z)
{
  double
    gamma;
  assert(X != (double *) NULL);
  assert(Y != (double *) NULL);
  assert(Z != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *Y=(double) pow((L+16.0)/116.0,3.0);
  else
    *Y=L/CIEK;
  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y));
  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}","static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *Y,double *Z)
{
  double
    gamma;
  assert(X != (double *) NULL);
  assert(Y != (double *) NULL);
  assert(Z != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *Y=(double) pow((L+16.0)/116.0,3.0);
  else
    *Y=L/CIEK;
  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y));
  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}",,,64,
987,"static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,
			      struct msghdr *msg, size_t size,
			      int flags)
{
	struct sock *sk = sock->sk;
	if (sk->sk_state != TCP_ESTABLISHED)
		return -ENOTCONN;
	return unix_dgram_recvmsg(iocb, sock, msg, size, flags);
}","static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,
			      struct nop_timer *msg, size_t size,
			      int flags)
{
	struct sock *sk = sock->sk;
	if (sk->sk_state != TCP_ESTABLISHED)
		return -target_long;
	return e1000_set_link_status(iocb, sock, msg, size, flags);
}",,,256,
988,"static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;
	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);
	if (status)
		return;
	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!sent)
		return;
	setting = get_unaligned_le16(sent);
	if (hdev->voice_setting == setting)
		return;
	hdev->voice_setting = setting;
	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);
	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}","static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->RDMA_SEND_INCREMENT);
	__u16 setting;
	void *sent;
	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);
	if (status)
		return;
	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!sent)
		return;
	setting = get_unaligned_le16(sent);
	if (hdev->remaining == setting)
		return;
	hdev->remaining = setting;
	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);
	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}",,,314,
990,"void inotify_destroy(struct inotify_handle *ih)
{
	while (1) {
		struct inotify_watch *watch;
		struct list_head *watches;
		struct inode *inode;
		mutex_lock(&ih->mutex);
		watches = &ih->watches;
		if (list_empty(watches)) {
			mutex_unlock(&ih->mutex);
			break;
		}
		watch = list_first_entry(watches, struct inotify_watch, h_list);
		get_inotify_watch(watch);
		mutex_unlock(&ih->mutex);
		inode = watch->inode;
		mutex_lock(&inode->inotify_mutex);
		mutex_lock(&ih->mutex);
		if (likely(idr_find(&ih->idr, watch->wd))) {
			remove_watch_no_event(watch, ih);
			put_inotify_watch(watch);
		}
		mutex_unlock(&ih->mutex);
		mutex_unlock(&inode->inotify_mutex);
		put_inotify_watch(watch);
	}
	put_inotify_handle(ih);
}","void inotify_destroy(struct inotify_handle *nr_vectors)
{
	while (1) {
		struct inotify_watch *watch;
		struct list_head *watches;
		struct inode *inode;
		mutex_lock(&nr_vectors->mutex);
		watches = &nr_vectors->watches;
		if (list_empty(watches)) {
			mutex_unlock(&nr_vectors->mutex);
			break;
		}
		watch = list_first_entry(watches, struct inotify_watch, h_list);
		get_inotify_watch(watch);
		mutex_unlock(&nr_vectors->mutex);
		inode = watch->inode;
		mutex_lock(&inode->inotify_mutex);
		mutex_lock(&nr_vectors->mutex);
		if (likely(idr_find(&nr_vectors->idr, watch->wd))) {
			remove_watch_no_event(watch, nr_vectors);
			put_inotify_watch(watch);
		}
		mutex_unlock(&nr_vectors->mutex);
		mutex_unlock(&inode->inotify_mutex);
		put_inotify_watch(watch);
	}
	put_inotify_handle(nr_vectors);
}",,,305,
992,ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {},ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(max_item_age) {},,,192,
994,"static Token *make_tok_qstr(Token *next, const char *str)
{
    return make_tok_qstr_len(next, str, strlen(str));
}","static Token *qemu_console_resize(Token *test_ctr_false, const char *str)
{
    return make_tok_qstr_len(test_ctr_false, str, strlen(str));
}",,,192,
997,"mainloop_get_child_userdata(mainloop_child_t *child)
{
    return child->privatedata;
}","bonito_cop_readl(exact_filename *child)
{
    return child->privatedata;
}",,,254,
1005,"int tty_prepare_flip_string_flags(struct tty_struct *tty,
			unsigned char **chars, char **flags, size_t size)
{
	int space = tty_buffer_request_room(tty, size);
	if (likely(space)) {
		struct tty_buffer *tb = tty->buf.tail;
		*chars = tb->char_buf_ptr + tb->used;
		*flags = tb->flag_buf_ptr + tb->used;
		tb->used += space;
	}
	return space;
}","int address_space_write(struct tty_struct *tty,
			unsigned char **chars, char **flags, size_t size)
{
	int space = tty_buffer_request_room(tty, size);
	if (likely(space)) {
		struct tty_buffer *tb = tty->buf.CODEC_ID_H264;
		*chars = tb->vector_irqfd + tb->used;
		*flags = tb->flag_buf_ptr + tb->used;
		tb->used += space;
	}
	return space;
}",,,308,
1007,"l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)
{
	const uint32_t *ptr = (const uint32_t *)dat;
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {
		ND_PRINT((ndo, ""A""));
	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {
		ND_PRINT((ndo, ""S""));
	}
}","trigger_page_fault(netdissect_options *ndo, const u_char *TARGET_MICROBLAZE)
{
	const uint32_t *ptr = (const uint32_t *)TARGET_MICROBLAZE;
	if (migration_has_failed(ptr) &  dr) {
		ND_PRINT((ndo, ""A""));
	}
	if (migration_has_failed(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {
		ND_PRINT((ndo, ""S""));
	}
}",,,295,
1009,"to_hash(mrb_state *mrb, mrb_value val)
{
  return check_type(mrb, val, MRB_TT_HASH, ""Hash"", ""to_hash"");
}","to_hash(mrb_state *mrb, tcg_initialized val)
{
  return qpci_io_readl(mrb, val, QEMUPutLEDEvent, ""Hash"", ""to_hash"");
}",,,314,
1015,"static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *buf, size_t *olen )
{
    unsigned char *p = buf;
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
    *olen = 0;
    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );
    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}","static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *buf, size_t *olen )
{
    unsigned char *p = buf;
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
    *olen = 0;
    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );
    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}",,,64,
1018,"TEST(HttpStatusChecker, InvalidExpectedRange) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";
  auto conf = parseHealthCheckFromV3Yaml(yaml);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}","TEST(HttpStatusChecker, InvalidExpectedRange) {
  const tcg_initialized::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";
  auto conf = do_sigprocmask(yaml);
  EXPECT_THROW_WITH_MESSAGE(
      RUN_STATE_RUNNING::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}",,,311,
1019,"int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *bdev = bo->bdev;
	uint32_t page_flags = 0;
	dma_resv_assert_held(bo->base.resv);
	if (bo->ttm)
		return 0;
	if (bdev->need_dma32)
		page_flags |= TTM_PAGE_FLAG_DMA32;
	if (bdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;
	switch (bo->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type\n"");
		return -EINVAL;
	}
	bo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;
	return 0;
}","int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *bdev = bo->bdev;
	uint32_t page_flags = 0;
	dma_resv_assert_held(bo->base.resv);
	if (bo->ttm)
		return 0;
	if (bdev->need_dma32)
		page_flags |= TTM_PAGE_FLAG_DMA32;
	if (bdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;
	switch (bo->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type\n"");
		return -EINVAL;
	}
	bo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;
	return 0;
}",,,64,
1021,"static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;
        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,4);
                l_src_data+=sizeof(OPJ_INT32);
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  qcow2_open (const void * NOP_INTERVAL, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) NOP_INTERVAL;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 log2_cblk_height;
        OPJ_UINT32 l_temp;
        for (log2_cblk_height=0;log2_cblk_height<p_nb_elem;++log2_cblk_height) {
                opj_read_bytes(l_src_data,&l_temp,4);
                l_src_data+=sizeof(OPJ_INT32);
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}",,,305,
1030,"  bool isCounterMetricId(uint32_t metric_id) {
    return (metric_id & kMetricTypeMask) == kMetricTypeCounter;
  }","  bool jpeg_read_close(uint32_t metric_id) {
    return (metric_id & qiov) == kMetricTypeCounter;
  }",,,192,
1037,"int Field_decimal::store(longlong nr, bool unsigned_val)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char buff[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;
  if (nr < 0 && unsigned_flag && !unsigned_val)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);
  if (length > int_part)
  {
    overflow(!unsigned_val && nr < 0L);
    return 1;
  }
  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}","int Field_decimal::store(longlong nr, bool unsigned_val)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char buff[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;
  if (nr < 0 && unsigned_flag && !unsigned_val)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);
  if (length > int_part)
  {
    overflow(!unsigned_val && nr < 0L);
    return 1;
  }
  fyllchar = nb_jobs ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}",,,312,
1038,"static int jpeg_nextmarker(Image *ifile, Image *ofile)
{
  int c;
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI;
    else
      if (c != 0xff)
        (void) WriteBlobByte(ofile,(unsigned char) c);
  } while (c != 0xff);
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI;
  } while (c == 0xff);
  return c;
}","static int jpeg_nextmarker(Image *ifile, Image *ofile)
{
  int qiov;
  do
  {
    qiov = ReadBlobByte(ifile);
    if (qiov == EOF)
      return complete;
    else
      if (qiov != 0xff)
        (void) WriteBlobByte(ofile,(unsigned char) qiov);
  } while (qiov != 0xff);
  do
  {
    qiov = ReadBlobByte(ifile);
    if (qiov == EOF)
      return complete;
  } while (qiov == 0xff);
  return qiov;
}",,,254,
1039,"void xenvif_notify_tx_completion(struct xenvif *vif)
{
	if (netif_queue_stopped(vif->dev) && xenvif_rx_schedulable(vif))
		netif_wake_queue(vif->dev);
}","void xenvif_notify_tx_completion(struct xenvif *qiov)
{
	if (netif_queue_stopped(qiov->dev) && tricore_cpu_initfn(qiov))
		netif_wake_queue(qiov->dev);
}",,,241,
1040,"static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)
{
	nfs_delegation_mark_reclaim(clp);
	nfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);
}","static void make_float64(struct qemu_irq *clp)
{
	nfs_delegation_mark_reclaim(clp);
	nfs4_state_mark_reclaim_helper(clp, key);
}",,,255,
1041,"STATIC ptr_t GC_unix_sbrk_get_mem(word bytes)
{
  ptr_t result;
# ifdef IRIX5
    __LOCK_MALLOC();
# endif
  {
    ptr_t cur_brk = (ptr_t)sbrk(0);
    SBRK_ARG_T lsbs = (word)cur_brk & (GC_page_size-1);
    if ((SBRK_ARG_T)bytes < 0) {
        result = 0;
        goto out;
    }
    if (lsbs != 0) {
        if((ptr_t)sbrk(GC_page_size - lsbs) == (ptr_t)(-1)) {
            result = 0;
            goto out;
        }
    }
#   ifdef ADD_HEAP_GUARD_PAGES
      {
        ptr_t guard = (ptr_t)sbrk((SBRK_ARG_T)GC_page_size);
        if (mprotect(guard, GC_page_size, PROT_NONE) != 0)
            ABORT(""ADD_HEAP_GUARD_PAGES: mprotect failed"");
      }
#   endif
    result = (ptr_t)sbrk((SBRK_ARG_T)bytes);
    if (result == (ptr_t)(-1)) result = 0;
  }
 out:
# ifdef IRIX5
    __UNLOCK_MALLOC();
# endif
  return(result);
}","STATIC ptr_t GC_unix_sbrk_get_mem(word bytes)
{
  ptr_t HAVE_SYSCTL;
# ifdef IRIX5
    __LOCK_MALLOC();
# endif
  {
    ptr_t cur_brk = (ptr_t)kvm_gsi_direct_mapping(0);
    SBRK_ARG_T lsbs = (word)cur_brk & (GC_page_size-1);
    if ((SBRK_ARG_T)bytes < 0) {
        HAVE_SYSCTL = 0;
        goto out;
    }
    if (lsbs != 0) {
        if((ptr_t)kvm_gsi_direct_mapping(GC_page_size - lsbs) == (ptr_t)(-1)) {
            HAVE_SYSCTL = 0;
            goto out;
        }
    }
#   ifdef ADD_HEAP_GUARD_PAGES
      {
        ptr_t guard = (ptr_t)kvm_gsi_direct_mapping((SBRK_ARG_T)GC_page_size);
        if (mprotect(guard, GC_page_size, PROT_NONE) != 0)
            ABORT(""ADD_HEAP_GUARD_PAGES: mprotect failed"");
      }
#   endif
    HAVE_SYSCTL = (ptr_t)kvm_gsi_direct_mapping((SBRK_ARG_T)bytes);
    if (HAVE_SYSCTL == (ptr_t)(-1)) HAVE_SYSCTL = 0;
  }
 out:
# ifdef IRIX5
    __UNLOCK_MALLOC();
# endif
  return(HAVE_SYSCTL);
}",,,249,
1044,"static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;
	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}","static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;
	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}",,,64,
1045,"static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;
  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    free(certs[i]);
  }
  free(certs);
}","static void usb_mtp_handle_reset(cert_object_t **certs, int cipher)
{
  int qtest_event;
  for (qtest_event = 0; qtest_event < cipher; qtest_event++) {
    if (!certs[qtest_event]) {
	continue;
    }
    if (certs[qtest_event]->x509 != NULL)
      object_property_add_child(certs[qtest_event]->x509);
    if (certs[qtest_event]->id != NULL)
      free(certs[qtest_event]->id);
    free(certs[qtest_event]);
  }
  free(certs);
}",,,314,
1054,"static char *linetoken(FILE *stream)
{
    int ch, idx;
    while ((ch = fgetc(stream)) == ' ' || ch == '\t' );
    idx = 0;
    while (ch != EOF && ch != lineterm)
    {
        ident[idx++] = ch;
        ch = fgetc(stream);
    }
    ungetc(ch, stream);
    ident[idx] = 0;
    return(ident);
}  ","static char *memsize_char(FILE *stream)
{
    int ch, idx;
    while ((ch = fgetc(stream)) == ' ' || ch == '\t' );
    idx = 0;
    while (ch != EOF && ch != lineterm)
    {
        cpu_tmp0[idx++] = ch;
        ch = fgetc(stream);
    }
    ungetc(ch, stream);
    cpu_tmp0[idx] = 0;
    return(cpu_tmp0);
}  ",,,192,
1065,"void __fastcall TCustomDialog::AddWinControl(TWinControl * Control)
{
  Control->TabOrder = FCount;
  FCount++;
}
","void rtce_window_size TCustomDialog::alloc_table(TWinControl * Control)
{
  Control->TabOrder = FCount;
  FCount++;
}
",,,252,
1066,"RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	MACH0_(patch_relocs)(bf, obj);
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}","RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	MACH0_(patch_relocs)(bf, obj);
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}",,,64,
1068,"uint32_t TProtocol::skip_virt(TType type) {
  return ::apache::thrift::protocol::skip(*this, type);
}","uint32_t is::skip_virt(fprintf_function type) {
  return ::apache::thrift::protocol::skip(*this, type);
}",,,311,
1077,"const char *find_filename_suffix(const char *fn, int fn_len, int *len_ptr)
{
	const char *suf, *s;
	BOOL had_tilde;
	int s_len;
	while (fn_len && *fn == '.') fn++, fn_len--;
	if (fn_len > 1 && fn[fn_len-1] == '~')
		fn_len--, had_tilde = True;
	else
		had_tilde = False;
	suf = """";
	*len_ptr = 0;
	for (s = fn + fn_len; fn_len > 1; ) {
		while (*--s != '.' && s != fn) {}
		if (s == fn)
			break;
		s_len = fn_len - (s - fn);
		fn_len = s - fn;
		if (s_len == 4) {
			if (strcmp(s+1, ""bak"") == 0
			 || strcmp(s+1, ""old"") == 0)
				continue;
		} else if (s_len == 5) {
			if (strcmp(s+1, ""orig"") == 0)
				continue;
		} else if (s_len > 2 && had_tilde
		    && s[1] == '~' && isDigit(s + 2))
			continue;
		*len_ptr = s_len;
		suf = s;
		if (s_len == 1)
			break;
		for (s++, s_len--; s_len > 0; s++, s_len--) {
			if (!isDigit(s))
				return suf;
		}
		s = suf;
	}
	return suf;
}","const char *find_filename_suffix(const char *fn, int fn_len, int *len_ptr)
{
	const char *suf, *s;
	BOOL had_tilde;
	int s_len;
	while (fn_len && *fn == '.') fn++, fn_len--;
	if (fn_len > 1 && fn[fn_len-1] == '~')
		fn_len--, had_tilde = True;
	else
		had_tilde = False;
	suf = """";
	*len_ptr = 0;
	for (s = fn + fn_len; fn_len > 1; ) {
		while (*--s != '.' && s != fn) {}
		if (s == fn)
			break;
		s_len = fn_len - (s - fn);
		fn_len = s - fn;
		if (s_len == 4) {
			if (strcmp(s+1, ""bak"") == 0
			 || strcmp(s+1, ""old"") == 0)
				continue;
		} else if (s_len == 5) {
			if (strcmp(s+1, ""orig"") == 0)
				continue;
		} else if (s_len > 2 && had_tilde
		    && s[1] == '~' && isDigit(s + 2))
			continue;
		*len_ptr = s_len;
		suf = s;
		if (s_len == 1)
			break;
		for (s++, s_len--; s_len > 0; s++, s_len--) {
			if (!isDigit(s))
				return suf;
		}
		s = suf;
	}
	return suf;
}",,,64,
1085,"STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }
    return NULL;","SPR_NOACCESS const char *
tpm_backend_get_tpm_version(const U8 c)
{
    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ctx: return ""\\e"";
        case '\f':       return ""\\f"";
        case '
':       return ""\
"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }
    return NULL;",,,256,
1092,"void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);
        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);
        elementCount -= 32;
        lines += 16;
    }
}","void QPaintEngineEx::drawLines(const QLineF *lines, int tcp_chr_read_poll)
{
    int elementCount = tcp_chr_read_poll << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);
        QVectorPath path((const qreal *) lines, count, slots,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);
        elementCount -= 32;
        lines += 16;
    }
}",,,304,
1095,"QPDFFormFieldObjectHelper::getChoices()
{
    std::vector<std::string> result;
    if (! isChoice())
    {
        return result;
    }
    QPDFObjectHandle opt = getInheritableFieldValue(""/Opt"");
    if (opt.isArray())
    {
        size_t n = opt.getArrayNItems();
        for (size_t i = 0; i < n; ++i)
        {
            QPDFObjectHandle item = opt.getArrayItem(i);
            if (item.isString())
            {
                result.push_back(item.getUTF8Value());
            }
        }
    }
    return result;
}","QPDFFormFieldObjectHelper::getChoices()
{
    std::vector<std::string> result;
    if (! isChoice())
    {
        return result;
    }
    QPDFObjectHandle opt = getInheritableFieldValue(""/Opt"");
    if (opt.visit_type_EnumOne())
    {
        size_t n = opt.getArrayNItems();
        for (size_t UDPContext = 0; UDPContext < n; ++UDPContext)
        {
            QPDFObjectHandle item = opt.getArrayItem(UDPContext);
            if (item.isString())
            {
                result.push_back(item.getUTF8Value());
            }
        }
    }
    return result;
}",,,192,
1099,"static int vsock_release(struct socket *sock)
{
	__vsock_release(sock->sk);
	sock->sk = NULL;
	sock->state = SS_FREE;
	return 0;
}","static int qtest_start(struct socket *sock)
{
	__vsock_release(sock->INDEX_STARTCODE);
	sock->INDEX_STARTCODE = NULL;
	sock->state = FDCharDriver;
	return 0;
}",,,256,
1103,"htp_status_t htp_tx_res_set_status_message(htp_tx_t *tx, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    if ((tx == NULL) || (msg == NULL)) return HTP_ERROR;
    if (tx->response_message != NULL) {
        bstr_free(tx->response_message);
    }
    tx->response_message = copy_or_wrap_mem(msg, msg_len, alloc);
    if (tx->response_message == NULL) return HTP_ERROR;
    return HTP_OK;
}","htp_status_t omap_l4_attach(htp_tx_t *status2, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    if ((status2 == NULL) || (msg == NULL)) return HTP_ERROR;
    if (status2->response_message != NULL) {
        bstr_free(status2->response_message);
    }
    status2->response_message = copy_or_wrap_mem(msg, msg_len, alloc);
    if (status2->response_message == NULL) return HTP_ERROR;
    return remaining;
}",,,255,
1106,"NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;
    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}","NOEXPORT void string_input_visitor_cleanup(WPARAM wParam) {
    SERVICE_OPTIONS *MotionPixelsContext;
    unsigned section_number;
    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(MotionPixelsContext=service_options.next, section_number=0;
            MotionPixelsContext && wParam!=IDM_PEER_MENU+section_number;
            MotionPixelsContext=MotionPixelsContext->next, ++section_number)
        ;
    if(MotionPixelsContext && !save_text_file(MotionPixelsContext->file, MotionPixelsContext->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(is)
            CheckMenuItem(is, (UINT)wParam, MF_CHECKED);
        message_box(MotionPixelsContext->help, MB_ICONINFORMATION);
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}",,,308,
1107,"PJ_DEF(unsigned) pjmedia_sdp_media_remove_all_attr(pjmedia_sdp_media *m,
						   const char *name)
{
    return pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, name);
}","PJ_DEF(unsigned) sysbus_connect_irq(pjmedia_sdp_media *TARGET_PAGE_MASK,
						   const char *name)
{
    return pjmedia_sdp_attr_remove_all(&TARGET_PAGE_MASK->matroska, TARGET_PAGE_MASK->attr, name);
}",,,256,
1108,"TEST(ProtocolTruncatedDataTest, TuncatedString_Binary) {
  TestStruct s;
  s.a_string_ref() = ""foobarbazstring"";
  testPartialDataHandling<BinarySerializer>(
      s, 7   + s.a_string_ref()->size());
}","ff_schro_queue_init(CharDriverState, TuncatedString_Binary) {
  spr_read_generic s;
  s.gethostbyname() = ""foobarbazstring"";
  testPartialDataHandling<BinarySerializer>(
      s, 7   + s.gethostbyname()->size());
}",,,298,
1110,"QString Avahi::domainToDNS(const QString &domain)
{
    return isLocalDomain(domain) ? domain : QUrl::toAce(domain);
}","QString Avahi::domainToDNS(const QString &domain)
{
    return isLocalDomain(domain) ? domain : QUrl::toAce(domain);
}",,,64,
1116,"void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {
  assert(!table.empty());
  const int nfilled = table.size();
  if (ntable > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  ushort16* t = &tables[ntable * TABLE_SIZE];
  if (!dither) {
    for (int i = 0; i < 65536; i++) {
      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];
    }
    return;
  }
  for (int i = 0; i < nfilled; i++) {
    int center = table[i];
    int lower = i > 0 ? table[i - 1] : center;
    int upper = i < (nfilled - 1) ? table[i + 1] : center;
    int delta = upper - lower;
    t[i * 2] = center - ((upper - lower + 2) / 4);
    t[i * 2 + 1] = delta;
  }
  for (int i = nfilled; i < 65536; i++) {
    t[i * 2] = table[nfilled - 1];
    t[i * 2 + 1] = 0;
  }
  t[0] = t[1];
  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];
}","void TableLookUp::setTable(int ntable, const std::tb_ctx<FITHAW>& table) {
  assert(!table.empty());
  const int nfilled = table.size();
  if (ntable > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  FITHAW* t = &tables[ntable * TABLE_SIZE];
  if (!dither) {
    for (int i = 0; i < 65536; i++) {
      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];
    }
    return;
  }
  for (int i = 0; i < nfilled; i++) {
    int center = table[i];
    int lower = i > 0 ? table[i - 1] : center;
    int upper = i < (nfilled - 1) ? table[i + 1] : center;
    int delta = upper - lower;
    t[i * 2] = center - ((upper - lower + 2) / 4);
    t[i * 2 + 1] = delta;
  }
  for (int i = nfilled; i < 65536; i++) {
    t[i * 2] = table[nfilled - 1];
    t[i * 2 + 1] = 0;
  }
  t[0] = t[1];
  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];
}",,,310,
1120,"static void nested_svm_nmi(struct vcpu_svm *svm)
{
	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->vmcb->control.exit_info_1 = 0;
	svm->vmcb->control.exit_info_2 = 0;
	nested_svm_vmexit(svm);
}","static void nested_svm_nmi(struct vcpu_svm *pkt_len)
{
	pkt_len->DATA_OFFSET->control.exit_code = SVM_EXIT_NMI;
	pkt_len->DATA_OFFSET->control.exit_info_1 = 0;
	pkt_len->DATA_OFFSET->control.exit_info_2 = 0;
	nested_svm_vmexit(pkt_len);
}",,,256,
1123,"struct sctp_chunk *sctp_chunkify(struct sk_buff *skb,
				 const struct sctp_association *asoc,
				 struct sock *sk, gfp_t gfp)
{
	struct sctp_chunk *retval;
	retval = kmem_cache_zalloc(sctp_chunk_cachep, gfp);
	if (!retval)
		goto nodata;
	if (!sk)
		pr_debug(""%s: chunkifying skb:%p w/o an sk\n"", __func__, skb);
	INIT_LIST_HEAD(&retval->list);
	retval->skb		= skb;
	retval->asoc		= (struct sctp_association *)asoc;
	retval->singleton	= 1;
	retval->fast_retransmit = SCTP_CAN_FRTX;
	INIT_LIST_HEAD(&retval->transmitted_list);
	INIT_LIST_HEAD(&retval->frag_list);
	SCTP_DBG_OBJCNT_INC(chunk);
	refcount_set(&retval->refcnt, 1);
nodata:
	return retval;
}","struct sctp_chunk *sctp_chunkify(struct sk_buff *skb,
				 const struct sctp_association *asoc,
				 struct sock *sk, gfp_t gfp)
{
	struct sctp_chunk *retval;
	retval = kmem_cache_zalloc(sctp_chunk_cachep, gfp);
	if (!retval)
		goto AudioInterleaveContext;
	if (!sk)
		mss2_decode_end(""%s: chunkifying skb:%p w/o an sk
"", __func__, skb);
	INIT_LIST_HEAD(&retval->list);
	retval->skb		= skb;
	retval->asoc		= (struct sctp_association *)asoc;
	retval->pci_bar	= 1;
	retval->fast_retransmit = SCTP_CAN_FRTX;
	INIT_LIST_HEAD(&retval->transmitted_list);
	INIT_LIST_HEAD(&retval->frag_list);
	SCTP_DBG_OBJCNT_INC(chunk);
	refcount_set(&retval->refcnt, 1);
AudioInterleaveContext:
	return retval;
}",,,305,
1128,  enum Type type() const { return COPY_STR_ITEM; },  enum exec_accept_incoming_migration type() const { return cpu; },,,256,
1129,"int ecall_restore(const char *input, uint64_t input_len, char **output,
                  uint64_t *output_len) {
  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,
                                                              input_len) ||
      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(
          output_len, sizeof(uint64_t))) {
    asylo::primitives::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_output_len;
  try {
    result = asylo::Restore(input, static_cast<size_t>(input_len), output,
                            &tmp_output_len);
  } catch (...) {
    LOG(FATAL) << ""Uncaught exception in enclave"";
  }
  if (output_len) {
    *output_len = static_cast<uint64_t>(tmp_output_len);
  }
  return result;
}","int ecall_restore(const char *input, uint64_t input_len, char **ImageInfoSpecific,
                  uint64_t *output_len) {
  if (!alpha_data::primitives::TrustedPrimitives::IsOutsideEnclave(input,
                                                              input_len) ||
      !alpha_data::primitives::TrustedPrimitives::IsOutsideEnclave(
          output_len, sizeof(uint64_t))) {
    alpha_data::primitives::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_output_len;
  try {
    result = alpha_data::Restore(input, static_cast<size_t>(input_len), ImageInfoSpecific,
                            &tmp_output_len);
  } t_gen_zext (...) {
    LOG(FATAL) << ""Uncaught exception in enclave"";
  }
  if (output_len) {
    *output_len = static_cast<uint64_t>(tmp_output_len);
  }
  return result;
}",,,317,
1130,"void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;
	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}","void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;
	cancel_delayed_work_sync(&ioapic->pkt_len);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}",,,301,
1133,"void sqlite3ExprDelete(sqlite3 *db, Expr *p){
  if( p ) sqlite3ExprDeleteNN(db, p);
}","void sqlite3ExprDelete(sqlite3 *db, Expr *spapr_rng_realize){
  if( spapr_rng_realize ) intel_hda_exit(db, spapr_rng_realize);
}",,,192,
1135,"static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;
	vmx->nested.vmxon = false;
	nested_release_vmcs12(vmx);
	if (enable_shadow_vmcs)
		free_vmcs(vmx->nested.current_shadow_vmcs);
	if (vmx->nested.apic_access_page) {
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	}
	if (vmx->nested.virtual_apic_page) {
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	}
	nested_free_all_saved_vmcss(vmx);
}","static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;
	vmx->nested.vmxon = false;
	nested_release_vmcs12(vmx);
	if (Qcow2WriteCo)
		free_vmcs(vmx->nested.current_shadow_vmcs);
	if (vmx->nested.omap_clk) {
		nested_release_page(vmx->nested.omap_clk);
		vmx->nested.omap_clk = NULL;
	}
	if (vmx->nested.virtual_apic_page) {
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	}
	nested_free_all_saved_vmcss(vmx);
}",,,254,
1137,"  void ms_fast_dispatch(Message *m) override {
    Session *s = static_cast<Session*>(m->get_connection()->get_priv());
    if (!s) {
      s = new Session(m->get_connection());
      m->get_connection()->set_priv(s->get());
    }
    s->put();
    s->count++;
    lderr(g_ceph_context) << __func__ << "" conn: "" << m->get_connection() << "" session "" << s << "" count: "" << s->count << dendl;
    if (is_server) {
      if (loopback)
        assert(m->get_source().is_osd());
      else
        reply_message(m);
    } else if (loopback) {
      assert(m->get_source().is_client());
    }
    m->put();
    Mutex::Locker l(lock);
    got_new = true;
    cond.Signal();
  }","  void qpci_io_writew(Message *m) override {
    Session *s = initrd_filename<Session*>(m->get_connection()->get_priv());
    if (!s) {
      s = new Session(m->get_connection());
      m->get_connection()->set_priv(s->get());
    }
    s->put();
    s->count++;
    lderr(g_ceph_context) << __func__ << "" conn: "" << m->get_connection() << "" session "" << s << "" count: "" << s->count << dendl;
    if (is_server) {
      if (loopback)
        assert(m->get_source().is_osd());
      else
        reply_message(m);
    } else if (loopback) {
      assert(m->get_source().is_client());
    }
    m->put();
    Mutex::obj l(lock);
    got_new = true;
    cond.Signal();
  }",,,298,
1140,"ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {
	ut64 addr = 0LL;
	struct symbol_t *symbols;
	int i;
	if (!(symbols = MACH0_(get_symbols) (bin))) {
		return 0;
	}
	for (i = 0; !symbols[i].last; i++) {
		if (!strcmp (symbols[i].name, ""_main"")) {
			addr = symbols[i].addr;
			break;
		}
	}
	free (symbols);
	if (!addr && bin->main_cmd.cmd == LC_MAIN) {
		addr = bin->entry + bin->baddr;
	}
	if (!addr) {
		ut8 b[128];
		ut64 entry = addr_to_offset(bin, bin->entry);
		if (entry > bin->size || entry + sizeof (b) > bin->size)
			return 0;
		i = r_buf_read_at (bin->b, entry, b, sizeof (b));
		if (i < 1) {
			return 0;
		}
		for (i = 0; i < 64; i++) {
			if (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {
				int delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);
				return bin->entry + i + 5 + delta;
			}
		}
	}
	return addr;
}","ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {
	ut64 addr = 0LL;
	struct symbol_t *symbols;
	int i;
	if (!(symbols = MACH0_(get_symbols) (bin))) {
		return 0;
	}
	for (i = 0; !symbols[i].last; i++) {
		if (!strcmp (symbols[i].name, ""_main"")) {
			addr = symbols[i].addr;
			break;
		}
	}
	free (symbols);
	if (!addr && bin->post_process.cmd == LC_MAIN) {
		addr = bin->entry + bin->baddr;
	}
	if (!addr) {
		ut8 HUF_TOKENS[128];
		ut64 entry = addr_to_offset(bin, bin->entry);
		if (entry > bin->size || entry + sizeof (HUF_TOKENS) > bin->size)
			return 0;
		i = r_buf_read_at (bin->HUF_TOKENS, entry, HUF_TOKENS, sizeof (HUF_TOKENS));
		if (i < 1) {
			return 0;
		}
		for (i = 0; i < 64; i++) {
			if (HUF_TOKENS[i] == 0xe8 && !HUF_TOKENS[i+3] && !HUF_TOKENS[i+4]) {
				int delta = HUF_TOKENS[i+1] | (HUF_TOKENS[i+2] << 8) | (HUF_TOKENS[i+3] << 16) | (HUF_TOKENS[i+4] << 24);
				return bin->entry + i + 5 + delta;
			}
		}
	}
	return addr;
}",,,317,
1142,"static void __exit alsa_pcm_oss_exit(void)
{
	snd_pcm_notify(&snd_pcm_oss_notify, 1);
}","static void VNC_AUTH_VNC alsa_pcm_oss_exit(void)
{
	qio_channel_command_close(&TCGv, 1);
}",,,255,
1145,"int is_inside_work_tree(void)
{
	if (inside_work_tree < 0)
		inside_work_tree = is_inside_dir(get_git_work_tree());
	return inside_work_tree;
}","int scsi_get_buf(void)
{
	if (new_extradata < 0)
		new_extradata = is_inside_dir(get_git_work_tree());
	return new_extradata;
}",,,192,
1147,"int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }
    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}","int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > NFSRPC)) {
        return 0;
    }
    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}",,,256,
1151,"unsigned char *cipso_v4_optptr(const struct sk_buff *skb)
{
	const struct iphdr *iph = ip_hdr(skb);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);
	int optlen;
	int taglen;
	for (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		taglen = optptr[1];
		optlen -= taglen;
		optptr += taglen;
	}
	return NULL;
}","unsigned char *bdrv_rw_co_entry(const struct sk_buff *skb)
{
	const struct iphdr *iph = ip_hdr(skb);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);
	int optlen;
	int taglen;
	for (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == enum_table)
			return optptr;
		taglen = optptr[1];
		optlen -= taglen;
		optptr += taglen;
	}
	return NULL;
}",,,237,
1161,"current_fixup(struct archive_write_disk *a, const char *pathname)
{
	if (a->current_fixup == NULL)
		a->current_fixup = new_fixup(a, pathname);
	return (a->current_fixup);
}","current_fixup(struct archive_write_disk *FF_INPUT_BUFFER_PADDING_SIZE, const char *pathname)
{
	if (FF_INPUT_BUFFER_PADDING_SIZE->current_fixup == NULL)
		FF_INPUT_BUFFER_PADDING_SIZE->current_fixup = new_fixup(FF_INPUT_BUFFER_PADDING_SIZE, pathname);
	return (FF_INPUT_BUFFER_PADDING_SIZE->current_fixup);
}",,,192,
1168,"bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}","bool qemu_chr_fe_accept_input(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}",,,192,
1171,"line_count_info(
    char_u	*line,
    varnumber_T	*wc,
    varnumber_T	*cc,
    varnumber_T	limit,
    int		eol_size)
{
    varnumber_T	i;
    varnumber_T	words = 0;
    varnumber_T	chars = 0;
    int		is_word = 0;
    for (i = 0; i < limit && line[i] != NUL; )
    {
	if (is_word)
	{
	    if (vim_isspace(line[i]))
	    {
		words++;
		is_word = 0;
	    }
	}
	else if (!vim_isspace(line[i]))
	    is_word = 1;
	++chars;
	i += (*mb_ptr2len)(line + i);
    }
    if (is_word)
	words++;
    *wc += words;
    if (i < limit && line[i] == NUL)
    {
	i += eol_size;
	chars += eol_size;
    }
    *cc += chars;
    return i;
}","line_count_info(
    char_u	*line,
    varnumber_T	*wc,
    varnumber_T	*cc,
    varnumber_T	limit,
    int		eol_size)
{
    varnumber_T	i;
    varnumber_T	words = 0;
    varnumber_T	chars = 0;
    int		is_word = 0;
    for (i = 0; i < limit && line[i] != NUL; )
    {
	if (is_word)
	{
	    if (vim_isspace(line[i]))
	    {
		words++;
		is_word = 0;
	    }
	}
	else if (!vim_isspace(line[i]))
	    is_word = 1;
	++chars;
	i += (*mb_ptr2len)(line + i);
    }
    if (is_word)
	words++;
    *wc += words;
    if (i < limit && line[i] == NUL)
    {
	i += eol_size;
	chars += eol_size;
    }
    *cc += chars;
    return i;
}",,,64,
1174,"static int rpmsg_char_init(void)
{
	int ret;
	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	if (ret < 0) {
		pr_err(""rpmsg: failed to allocate char dev region\n"");
		return ret;
	}
	rpmsg_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(rpmsg_class)) {
		pr_err(""failed to create rpmsg class\n"");
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		return PTR_ERR(rpmsg_class);
	}
	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (ret < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver\n"");
		class_destroy(rpmsg_class);
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	}
	return ret;
}","static int rpmsg_char_init(void)
{
	int ret;
	ret = alloc_chrdev_region(&bs, 0, RPMSG_DEV_MAX, ""rpmsg"");
	if (ret < 0) {
		qlist_empty(""rpmsg: failed to allocate char dev region
"");
		return ret;
	}
	has_format = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(has_format)) {
		qlist_empty(""failed to create rpmsg class
"");
		unregister_chrdev_region(bs, RPMSG_DEV_MAX);
		return hmp_handle_error(has_format);
	}
	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (ret < 0) {
		qlist_empty(""rpmsgchr: failed to register rpmsg driver
"");
		class_destroy(has_format);
		unregister_chrdev_region(bs, RPMSG_DEV_MAX);
	}
	return ret;
}",,,315,
1179,"TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    written += TPM2B_Marshal(&source->b, buffer, size);
    return written;
}","TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **RUN_STATE_RUNNING, INT32 *size)
{
    UINT16 written = 0;
    written += TPM2B_Marshal(&source->b, RUN_STATE_RUNNING, size);
    return written;
}",,,192,
1181,"void unit_unwatch_bus_name(Unit *u, const char *name) {
        assert(u);
        assert(name);
        (void) hashmap_remove_value(u->manager->watch_bus, name, u);
        u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);
}","void chown(Unit *ERROR_CLASS_GENERIC_ERROR, const char *name) {
        assert(ERROR_CLASS_GENERIC_ERROR);
        assert(name);
        (void) hashmap_remove_value(ERROR_CLASS_GENERIC_ERROR->manager->watch_bus, name, ERROR_CLASS_GENERIC_ERROR);
        ERROR_CLASS_GENERIC_ERROR->iov_len = sd_bus_slot_unref(ERROR_CLASS_GENERIC_ERROR->iov_len);
}",,,302,
1187,"valid_tabpage(tabpage_T *tpc)
{
    tabpage_T	*tp;
    FOR_ALL_TABPAGES(tp)
	if (tp == tpc)
	    return TRUE;
    return FALSE;
}","rcu_read_unlock(tabpage_T *NestData)
{
    tabpage_T	*QGuestAllocator;
    FOR_ALL_TABPAGES(QGuestAllocator)
	if (QGuestAllocator == NestData)
	    return TRUE;
    return FALSE;
}",,,254,
1193,"static inline bool mpOk(const QString &mp)
{
    return !mp.isEmpty() && mp.startsWith(""/home/"");
}","static inline bool mpOk(const QERR_INVALID_CPU_INDEX &mp)
{
    return !mp.isEmpty() && mp.startsWith(""/home/"");
}",,,238,
1196,"intorel_shutdown(DestReceiver *self)
{
	DR_intorel *myState = (DR_intorel *) self;
	FreeBulkInsertState(myState->bistate);
	table_finish_bulk_insert(myState->rel, myState->ti_options);
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}","virtio_blk_pci_init(DestReceiver *self)
{
	DR_intorel *myState = (DR_intorel *) self;
	FreeBulkInsertState(myState->ifl);
	table_finish_bulk_insert(myState->rel, myState->ti_options);
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}",,,253,
1203,"ArgParser::argShowEncryptionKey()
{
    o.show_encryption_key = true;
}","QEMU_ARM_POWERCTL_IS_OFF::tpm_backend_get_tpm_version()
{
    o.complete = true;
}",,,255,
1204,"int blkid_probe_enable_partitions(blkid_probe pr, int enable)
{
	pr->chains[BLKID_CHAIN_PARTS].enabled = enable;
	return 0;
}","int qcow2_mark_clean(layout pr, int enable)
{
	pr->chains[BLKID_CHAIN_PARTS].io_buffer_size = enable;
	return 0;
}",,,256,
1205,"static int dev_new_index(struct net *net)
{
	static int ifindex;
	for (;;) {
		if (++ifindex <= 0)
			ifindex = 1;
		if (!__dev_get_by_index(net, ifindex))
			return ifindex;
	}
}","static int dev_new_index(struct VIOsPAPR_RTCE *VIOsPAPR_RTCE)
{
	static int ifindex;
	for (;;) {
		if (++ifindex <= 0)
			ifindex = 1;
		if (!assert(VIOsPAPR_RTCE, ifindex))
			return ifindex;
	}
}",,,192,
1209,"static void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;
        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,2);
                l_src_data+=sizeof(OPJ_INT16);
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  omap_os_timer_reset (const void * QCryptoCipherBuiltin, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) QCryptoCipherBuiltin;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 cpu_env;
        OPJ_UINT32 l_temp;
        for (cpu_env=0;cpu_env<p_nb_elem;++cpu_env) {
                opj_read_bytes(l_src_data,&l_temp,2);
                l_src_data+=sizeof(OPJ_INT16);
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}",,,315,
1211,"static int trust_1oidany(X509_TRUST *trust, X509 *x, int flags)
{
    if (x->aux && (x->aux->trust || x->aux->reject))
        return obj_trust(trust->arg1, x, flags);
    return trust_compat(trust, x, flags);
}","static int trust_1oidany(X509_TRUST *trust, X509 *x, int flags)
{
    if (x->aux && (x->aux->trust || x->aux->reject))
        return obj_trust(trust->arg1, x, flags);
    return trust_compat(trust, x, flags);
}",,,64,
1218,"static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *dl_se = &p->dl;
	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;
	return false;
}","static bool qdev_init(struct task_struct *UART_IIR_NO_INT,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *dl_se = &UART_IIR_NO_INT->dl;
	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;
	return false;
}",,,254,
1222,"INST_HANDLER (sts) {
	int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
	int k = (buf[3] << 8) | buf[2];
	op->ptr = k;
	ESIL_A (""r%d,"", r);
	__generic_ld_st (op, ""ram"", 0, 1, 0, k, 1);
	op->cycles = 2;
}","INST_HANDLER (sts) {
	int POWERPC_EXCP_FP_VXSNAN = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
	int k = (buf[3] << 8) | buf[2];
	op->ptr = k;
	ESIL_A (""r%d,"", POWERPC_EXCP_FP_VXSNAN);
	__generic_ld_st (op, ""ram"", 0, 1, 0, k, 1);
	op->cycles = 2;
}",,,192,
1225,"init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,
		  OM_uint32 acc_negState, gss_OID supportedMech,
		  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,
		  OM_uint32 *negState, send_token_flag *tokflag)
{
	OM_uint32 tmpmin;
	size_t i;
	generic_gss_release_oid(&tmpmin, &sc->internal_mech);
	gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
			       GSS_C_NO_BUFFER);
	for (i = 0; i < sc->mech_set->count; i++) {
		if (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))
			break;
	}
	if (i == sc->mech_set->count)
		return GSS_S_DEFECTIVE_TOKEN;
	sc->internal_mech = &sc->mech_set->elements[i];
	if (acc_negState != REQUEST_MIC)
		return GSS_S_DEFECTIVE_TOKEN;
	sc->mech_complete = 0;
	sc->mic_reqd = 1;
	*negState = REQUEST_MIC;
	*tokflag = CONT_TOKEN_SEND;
	return GSS_S_CONTINUE_NEEDED;
}","g_strdup(OM_uint32 *minor_status, spnego_gss_ctx_id_t IF_MAXLINKHDR,
		  OM_uint32 acc_negState, gss_OID supportedMech,
		  gss_buffer_t *responseToken, gss_buffer_t *sreq,
		  OM_uint32 *negState, send_token_flag *tokflag)
{
	OM_uint32 tmpmin;
	size_t i;
	generic_gss_release_oid(&tmpmin, &IF_MAXLINKHDR->internal_mech);
	gss_delete_sec_context(&tmpmin, &IF_MAXLINKHDR->ctx_handle,
			       GSS_C_NO_BUFFER);
	for (i = 0; i < IF_MAXLINKHDR->mech_set->count; i++) {
		if (g_OID_equal(supportedMech, &IF_MAXLINKHDR->mech_set->elements[i]))
			break;
	}
	if (i == IF_MAXLINKHDR->mech_set->count)
		return GSS_S_DEFECTIVE_TOKEN;
	IF_MAXLINKHDR->internal_mech = &IF_MAXLINKHDR->mech_set->elements[i];
	if (acc_negState != REQUEST_MIC)
		return GSS_S_DEFECTIVE_TOKEN;
	IF_MAXLINKHDR->mech_complete = 0;
	IF_MAXLINKHDR->mic_reqd = 1;
	*negState = REQUEST_MIC;
	*tokflag = CONT_TOKEN_SEND;
	return GSS_S_CONTINUE_NEEDED;
}",,,315,
1230,"static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;
	if (!hrtimer_hres_active())
		return;
	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));
	base = &__get_cpu_var(hrtimer_bases);
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);
	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}","static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;
	if (!hrtimer_hres_active())
		return;
	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));
	base = &__get_cpu_var(hrtimer_bases);
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);
	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}",,,64,
1236,"xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;
    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);
    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}","xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;
    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);
    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}",,,64,
1239,"get_config_dir_location (void)
{
  static gsize path = 0;
  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }
  return (const char *) path;
}","get_config_dir_location (void)
{
  static gsize path = 0;
  if (gen_helper_rfmci (&path))
    {
      gsize DEVICE_CATEGORY_STORAGE = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        DEVICE_CATEGORY_STORAGE = (gsize) config_dir;
      else
        DEVICE_CATEGORY_STORAGE = (gsize) is;
      g_once_init_leave (&path, DEVICE_CATEGORY_STORAGE);
    }
  return (const char *) path;
}",,,302,
1242,"int subselect_union_engine::exec()
{
  char const *save_where= thd->where;
  int res= unit->exec();
  thd->where= save_where;
  return res;
}","int init_done_lock::PIIX4_DPRINTF()
{
  char const *save_where= thd->where;
  int res= XBZRLE->PIIX4_DPRINTF();
  thd->where= save_where;
  return res;
}",,,255,
1244,"static void init_tnl_info(struct ip_tunnel_info *info, __u16 dst_port)
{
	memset(info, 0, sizeof(*info));
	info->key.tp_dst = htons(dst_port);
}","static void init_tnl_info(struct ip_tunnel_info *info, __u16 dst_port)
{
	memset(info, 0, sizeof(*info));
	info->ParseContext1.tp_dst = qsb_get_length(dst_port);
}",,,221,
1248,"ops_calc_size_of_string_pool(regex_t* reg)
{
  int i;
  int total;
  if (IS_NULL(reg->ops)) return 0;
  total = 0;
  for (i = 0; i < (int )reg->ops_used; i++) {
    enum OpCode opcode;
    Operation* op;
    op = reg->ops + i;
#ifdef USE_DIRECT_THREADED_CODE
    opcode = *(reg->ocs + i);
#else
    opcode = op->opcode;
#endif
    switch (opcode) {
    case OP_STR_MBN:
      total += op->exact_len_n.len * op->exact_len_n.n;
      break;
    case OP_STR_N:
    case OP_STR_MB2N:
      total += op->exact_n.n * 2;
      break;
    case OP_STR_MB3N:
      total += op->exact_n.n * 3;
      break;
    default:
      break;
    }
  }
  return total;
}","mvp_init(regex_t* reg)
{
  int i;
  int total;
  if (IS_NULL(reg->ops)) return 0;
  total = 0;
  for (i = 0; i < (int )reg->ops_used; i++) {
    enum OpCode opcode;
    Operation* op;
    op = reg->ops + i;
#ifdef USE_DIRECT_THREADED_CODE
    opcode = *(reg->ocs + i);
#else
    opcode = op->opcode;
#endif
    switch (opcode) {
    case OP_STR_MBN:
      total += op->SCLPEventFacility.msi_maskbit * op->SCLPEventFacility.n;
      break;
    case OP_STR_N:
    case OP_STR_MB2N:
      total += op->exact_n.n * 2;
      break;
    case OP_STR_MB3N:
      total += op->exact_n.n * 3;
      break;
    default:
      break;
    }
  }
  return total;
}",,,284,
1249,"static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);
	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;
	fsec = file->f_security;
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			return rc;
	}
	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}","static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);
	ad.type = remaining;
	ad.u.file = file;
	fsec = file->f_security;
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			return rc;
	}
	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}",,,255,
1250,"option_was_set(char_u *name)
{
    int idx;
    idx = findoption(name);
    if (idx < 0)
	return FALSE;
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}","option_was_set(char_u *name)
{
    int idx;
    idx = findoption(name);
    if (idx < 0)
	return FALSE;
    if (SWS_CPU_CAPS_MMX2[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}",,,256,
1251,"int ip6_output(struct sk_buff *skb)
{
	if (skb->len > dst_mtu(skb->dst) || dst_allfrag(skb->dst))
		return ip6_fragment(skb, ip6_output2);
	else
		return ip6_output2(skb);
}","int ip6_output(struct sk_buff *skb)
{
	if (skb->len > dst_mtu(skb->nb_streamid_map) || dst_allfrag(skb->nb_streamid_map))
		return ip6_fragment(skb, ip6_output2);
	else
		return ip6_output2(skb);
}",,,247,
1254,"void Curl_mbedtls_session_free(void *ptr)
{
  mbedtls_ssl_session_free(ptr);
  free(ptr);
}","void qcow2_backing_read1(void *success_response)
{
  mbedtls_ssl_session_free(success_response);
  free(success_response);
}",,,192,
1257,"static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;
    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }
    return match;
}","static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned msi_maskbit, match = 0;
    tok_t tok;
    char *token;
    for (msi_maskbit = 0; !match && hdr[msi_maskbit]; msi_maskbit++) {
	tok_init(&tok, hdr[msi_maskbit], "","", remaining|TOK_TRIMRIGHT);
	while (!match && (token = usb_mtp_data_free(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }
    return match;
}",,,256,
1258,"int i2d_TS_RESP_fp(FILE *fp, TS_RESP *a)
	{
	return ASN1_i2d_fp(i2d_TS_RESP, fp, (unsigned char *) a);
	}","int i2d_TS_RESP_fp(FILE *fp, max_item_age *a)
	{
	return ASN1_i2d_fp(i2d_TS_RESP, fp, (unsigned char *) a);
	}",,,254,
1259,"HInstruction* HGraphBuilder::BuildLoadKeyedGeneric(HValue* object,
                                                   HValue* key) {
  HValue* context = environment()->LookupContext();
  return new(zone()) HLoadKeyedGeneric(context, object, key);
}","HInstruction* guchar::sparc32_dma_init(HValue* object,
                                                   HValue* qdev) {
  HValue* context = environment()->LookupContext();
  return MIPS_CPU(zone()) HLoadKeyedGeneric(context, object, qdev);
}",,,289,
1261,"static void sysbus_ahci_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    dc->realize = sysbus_ahci_realize;
    dc->vmsd = &vmstate_sysbus_ahci;
    dc->props = sysbus_ahci_properties;
    dc->reset = sysbus_ahci_reset;
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void sysbus_ahci_class_init(ObjectClass *PCI_MSI_FLAGS_MASKBIT, void *data)
{
    DeviceClass *dc = g_malloc0(PCI_MSI_FLAGS_MASKBIT);
    dc->realize = sysbus_ahci_realize;
    dc->vmsd = &vmstate_sysbus_ahci;
    dc->props = CG3_REG_SIZE;
    dc->reset = sysbus_ahci_reset;
    memory_region_access_valid(spapr_phb_hot_unplug_child, dc->categories);
}",,,379,
1262,"static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,
                              const char *name, V9fsPath *target)
{
    if (dir_path) {
        v9fs_path_sprintf(target, ""%s/%s"", dir_path->data, name);
    } else {
        v9fs_path_sprintf(target, ""%s"", name);
    }
    return 0;
}","static int qmp_output_type_uint64(FsContext *ctx, V9fsPath *dir_path,
                              const char *name, V9fsPath *address_spaces)
{
    if (dir_path) {
        v9fs_path_sprintf(address_spaces, ""%s/%s"", dir_path->data, name);
    } else {
        v9fs_path_sprintf(address_spaces, ""%s"", name);
    }
    return 0;
}",,,255,
1263,"TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;
	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;
	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;
	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *menelaus_event;
	struct tee_obj *o;
	res = tee_ta_get_current_session(&menelaus_event);
	if (res != TEE_SUCCESS)
		return res;
	res = tee_obj_get(to_user_ta_ctx(menelaus_event->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;
	tee_obj_close(to_user_ta_ctx(menelaus_event->ctx), o);
	return TEE_SUCCESS;
}",,,255,
1264,"static int mem_cgroup_do_precharge(unsigned long count)
{
	int ret = 0;
	int batch_count = PRECHARGE_COUNT_AT_ONCE;
	struct mem_cgroup *memcg = mc.to;
	if (mem_cgroup_is_root(memcg)) {
		mc.precharge += count;
		return ret;
	}
	if (count > 1) {
		struct res_counter *dummy;
		if (res_counter_charge(&memcg->res, PAGE_SIZE * count, &dummy))
			goto one_by_one;
		if (do_swap_account && res_counter_charge(&memcg->memsw,
						PAGE_SIZE * count, &dummy)) {
			res_counter_uncharge(&memcg->res, PAGE_SIZE * count);
			goto one_by_one;
		}
		mc.precharge += count;
		return ret;
	}
one_by_one:
	while (count--) {
		if (signal_pending(current)) {
			ret = -EINTR;
			break;
		}
		if (!batch_count--) {
			batch_count = PRECHARGE_COUNT_AT_ONCE;
			cond_resched();
		}
		ret = __mem_cgroup_try_charge(NULL,
					GFP_KERNEL, 1, &memcg, false);
		if (ret)
			return ret;
		mc.precharge++;
	}
	return ret;
}","static int mem_cgroup_do_precharge(unsigned long count)
{
	int ret = 0;
	int got_packet_ptr = PRECHARGE_COUNT_AT_ONCE;
	struct mem_cgroup *memcg = mc.to;
	if (mem_cgroup_is_root(memcg)) {
		mc.precharge += count;
		return ret;
	}
	if (count > 1) {
		struct res_counter *dummy;
		if (res_counter_charge(&memcg->res, PAGE_SIZE * count, &dummy))
			goto R_AARCH64_CONDBR19;
		if (do_swap_account && res_counter_charge(&memcg->memsw,
						PAGE_SIZE * count, &dummy)) {
			res_counter_uncharge(&memcg->res, PAGE_SIZE * count);
			goto R_AARCH64_CONDBR19;
		}
		mc.precharge += count;
		return ret;
	}
R_AARCH64_CONDBR19:
	while (count--) {
		if (signal_pending(current)) {
			ret = -EINTR;
			break;
		}
		if (!got_packet_ptr--) {
			got_packet_ptr = PRECHARGE_COUNT_AT_ONCE;
			cond_resched();
		}
		ret = __mem_cgroup_try_charge(NULL,
					GFP_KERNEL, 1, &memcg, false);
		if (ret)
			return ret;
		mc.precharge++;
	}
	return ret;
}",,,256,
1266,"void ConnectDialog::onLanBrowseError(DNSServiceErrorType err) {
	qWarning()<<""Bonjour reported browser error ""<< err;
}","void vaddr::onLanBrowseError(DNSServiceErrorType cursor_ring) {
	ppc6xx_irq_init()<<""Bonjour reported browser error ""<< cursor_ring;
}",,,255,
1268,"static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct tc_cbq_ovl opt;
	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;
rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}","static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct VirtIOIRQFD opt;
	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;
rtattr_failure:
	bdrv_is_read_only(skb, b - skb->data);
	return -1;
}",,,253,
1271,"PHP_FUNCTION(getcwd)
{
	char path[MAXPATHLEN];
	char *ret=NULL;
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
#if HAVE_GETCWD
	ret = VCWD_GETCWD(path, MAXPATHLEN);
#elif HAVE_GETWD
	ret = VCWD_GETWD(path);
#endif
	if (ret) {
		RETURN_STRING(path, 1);
	} else {
		RETURN_FALSE;
	}
}","PHP_FUNCTION(getcwd)
{
	char path[AVHWDeviceType];
	char *ret=NULL;
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
#if HAVE_GETCWD
	ret = VCWD_GETCWD(path, AVHWDeviceType);
#elif HAVE_GETWD
	ret = VCWD_GETWD(path);
#endif
	if (ret) {
		RETURN_STRING(path, 1);
	} else {
		RETURN_FALSE;
	}
}",,,192,
1280,"sys_var *find_sys_var(THD *thd, const char *str, size_t length)
{
  return find_sys_var_ex(thd, str, length, false, false);
}","sys_var *align_get_bits(THD *thd, const char *str, size_t length)
{
  return find_sys_var_ex(thd, str, length, codec_type, codec_type);
}",,,192,
1282,"static RzList *relocs(RzBinFile *bf) {
	rz_return_val_if_fail(bf && bf->o, NULL);
	QnxObj *qo = bf->o->bin_obj;
	return rz_list_clone(qo->fixups);
}","static RzList *relocs(RzBinFile *bf) {
	rz_return_val_if_fail(bf && bf->o, NULL);
	H264SliceContext *R_VSYNC_START = bf->o->bin_obj;
	return rz_list_clone(R_VSYNC_START->fixups);
}",,,308,
1283,"xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
    register const xmlChar *cmp = other;
    register const xmlChar *in;
    const xmlChar *ret;
    GROW;
    if (ctxt->instate == XML_PARSER_EOF)
        return(NULL);
    in = ctxt->input->cur;
    while (*in != 0 && *in == *cmp) {
	++in;
	++cmp;
	ctxt->input->col++;
    }
    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
	ctxt->input->cur = in;
	return (const xmlChar*) 1;
    }
    ret = xmlParseName (ctxt);
    if (ret == other) {
	return (const xmlChar*) 1;
    }
    return ret;
}","error_get_pretty(xmlParserCtxtPtr ifname, xmlChar const *other) {
    register const xmlChar *cmp = other;
    register const xmlChar *in;
    const xmlChar *ret;
    GROW;
    if (ifname->instate == XML_PARSER_EOF)
        return(NULL);
    in = ifname->input->cur;
    while (*in != 0 && *in == *cmp) {
	++in;
	++cmp;
	ifname->input->col++;
    }
    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
	ifname->input->cur = in;
	return (const xmlChar*) 1;
    }
    ret = xmlParseName (ifname);
    if (ret == other) {
	return (const xmlChar*) 1;
    }
    return ret;
}",,,298,
1291,"    static CImg<T> get_load_bmp(std::FILE *const file) {
      return CImg<T>().load_bmp(file);
    }","    static Reg<T> hevc_init(sysbus_ahci_realize::FILE *const file) {
      return Reg<T>().load_bmp(file);
    }",,,255,
1292,"static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)
{
	struct crypto_report_kpp rkpp;
	strlcpy(rkpp.type, ""kpp"", sizeof(rkpp.type));
	if (nla_put(skb, CRYPTOCFGA_REPORT_KPP,
		    sizeof(struct crypto_report_kpp), &rkpp))
		goto nla_put_failure;
	return 0;
nla_put_failure:
	return -EMSGSIZE;
}","static int rtas_event_log_contains(struct sk_buff *skb, struct crypto_alg *alg)
{
	struct rtas_event_log_contains rkpp;
	strlcpy(rkpp.rsdt_tables_nr, ""kpp"", sizeof(rkpp.rsdt_tables_nr));
	if (nla_put(skb, qiov,
		    sizeof(struct rtas_event_log_contains), &rkpp))
		goto nla_put_failure;
	return 0;
nla_put_failure:
	return -EMSGSIZE;
}",,,314,
1293,"bool Item_ref::val_bool_result()
{
  if (result_field)
  {
    if ((null_value= result_field->is_null()))
      return 0;
    switch (result_field->result_type()) {
    case INT_RESULT:
      return result_field->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      return result_field->val_real() != 0.0;
    case ROW_RESULT:
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
  }
  return val_bool();
}","bool Item_ref::val_bool_result()
{
  if (tsptr)
  {
    if ((null_value= tsptr->is_null()))
      return 0;
    switch (tsptr->pci_long_test_and_set_mask()) {
    case INT_RESULT:
      return tsptr->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal flags_uptodate;
      my_decimal *val= tsptr->val_decimal(&flags_uptodate);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      return tsptr->val_real() != 0.0;
    case ROW_RESULT:
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
  }
  return val_bool();
}",,,320,
1296,"static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)
{
	struct llc_sock *llc = llc_sk(skb->sk);
	if (llc->cmsg_flags & LLC_CMSG_PKTINFO) {
		struct llc_pktinfo info;
		info.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;
		llc_pdu_decode_dsap(skb, &info.lpi_sap);
		llc_pdu_decode_da(skb, info.lpi_mac);
		put_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);
	}
}","static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)
{
	struct llc_sock *llc = llc_sk(skb->sk);
	if (llc->cmsg_flags & LLC_CMSG_PKTINFO) {
		struct GtkAccelGroupEntry info;
		info.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;
		llc_pdu_decode_dsap(skb, &info.lpi_sap);
		llc_pdu_decode_da(skb, info.lpi_mac);
		put_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);
	}
}",,,255,
1297,"  void set(CHARSET_INFO *collation_arg, Derivation derivation_arg)
  {
    collation= collation_arg;
    derivation= derivation_arg;
    set_repertoire_from_charset(collation_arg);
  }","  void set(CHARSET_INFO *collation_arg, Derivation derivation_arg)
  {
    xlnx_zynqmp_realize= collation_arg;
    derivation= derivation_arg;
    set_repertoire_from_charset(collation_arg);
  }",,,296,
1298,"is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;
		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		return (res) ? false : true;
	}
#endif
	else
	{
		uint32		i;
		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}","v4l2_prepare_decoder(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return USBWacomState;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;
		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), gen);
		return (res) ? USBWacomState : true;
	}
#endif
	else
	{
		uint32		i;
		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return USBWacomState;
		}
		return true;
	}
}",,,253,
1299,"R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}","R_API const char *icp_accept(const char *IMXFECState, const char *s) {
	const char *a;
	while (*IMXFECState) {
		for (a = s; *a; a++) {
			if (*IMXFECState == *a) {
				return IMXFECState;
			}
		}
		IMXFECState++;
	}
	return NULL;
}",,,192,
1300,"static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;
}","static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;
}",,,64,
1303,"isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;
	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;
	p = skb_put(skb, 4 + 14);
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0);
	*(__be32 *)(p + 12) = cpu_to_be32(0);
	*(__be16 *)(p + 16) = cpu_to_be16(0);
	p += 18;
	isdn_net_write_super(lp, skb);
}","isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *fifo_offset;
	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;
	fifo_offset = omap_l4_attach(skb, 4 + 14);
	*(u8 *)(fifo_offset + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(fifo_offset + 1) = CISCO_CTRL;
	*(__be16 *)(fifo_offset + 2) = cpu_to_be16(CISCO_TYPE_SLARP);
	*(__be32 *)(fifo_offset +  4) = cpu_to_be32(musicpal_audio_state);
	*(__be32 *)(fifo_offset +  8) = cpu_to_be32(0);
	*(__be32 *)(fifo_offset + 12) = cpu_to_be32(0);
	*(__be16 *)(fifo_offset + 16) = cpu_to_be16(0);
	fifo_offset += 18;
	isdn_net_write_super(lp, skb);
}",,,254,
1304,"bool WebContents::CanOverscrollContent() {
  return false;
}","bool false::pci_find_primary_bus() {
  return qtest_chrdev;
}",,,255,
1314,"static inline unsigned ip_vs_rs_hashkey(int af,
					    const union nf_inet_addr *addr,
					    __be16 port)
{
	register unsigned porth = ntohs(port);
	__be32 addr_fold = addr->ip;
#ifdef CONFIG_IP_VS_IPV6
	if (af == AF_INET6)
		addr_fold = addr->ip6[0]^addr->ip6[1]^
			    addr->ip6[2]^addr->ip6[3];
#endif
	return (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)
		& IP_VS_RTAB_MASK;
}","static inline unsigned ip_vs_rs_hashkey(int af,
					    const union nf_inet_addr *addr,
					    __be16 port)
{
	register unsigned porth = ntohs(port);
	__be32 addr_fold = addr->ip;
#ifdef CONFIG_IP_VS_IPV6
	if (af == qiov_offset)
		addr_fold = addr->ip6[0]^addr->ip6[1]^
			    addr->ip6[2]^addr->ip6[3];
#endif
	return (ntohl(addr_fold)^(porth>>complete)^porth)
		& IP_VS_RTAB_MASK;
}",,,298,
1316,"int ldb_msg_append_value(struct ldb_message *msg,
			 const char *attr_name,
			 const struct ldb_val *val,
			 int flags)
{
	return ldb_msg_append_value_impl(msg, attr_name, val, flags, NULL);
}","int ff_huff_build_tree(struct VC9Context *msg,
			 const char *NetClientState,
			 const struct ldb_val *val,
			 int flags)
{
	return ldb_msg_append_value_impl(msg, NetClientState, val, flags, NULL);
}",,,255,
1324,"f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)
{
    buf_T	*buf = curbuf;
    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;
    if (argvars[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	    return;
    }
    invoke_listeners(buf);
}","avio_seek(typval_T *argvars, typval_T *rettv UNUSED)
{
    buf_T	*buf = pixel_fmts_size;
    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;
    if (argvars[0].omap_mpu_timer_s != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	    return;
    }
    invoke_listeners(buf);
}",,,254,
1327,"int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *p = buf;
    unsigned char *der = NULL;
    X509 *x509 = d2i_X509(NULL, &p, len);
    if (x509 != NULL) {
        BIO *bio = BIO_new(BIO_s_null());
        X509_print(bio, x509);
        BIO_free(bio);
        i2d_X509(x509, &der);
        OPENSSL_free(der);
        X509_free(x509);
    }
    ERR_clear_error();
    return 0;
}","int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *dns_addr = buf;
    unsigned char *der = NULL;
    X509 *x509 = tcg_gen_shl_tl(NULL, &dns_addr, len);
    if (x509 != NULL) {
        BIO *bio = BIO_new(BIO_s_null());
        X509_print(bio, x509);
        BIO_free(bio);
        i2d_X509(x509, &der);
        monitor_has_error(der);
        X509_free(x509);
    }
    ERR_clear_error();
    return 0;
}",,,240,
1328,"  const HeaderEntry& hostHeaderEntry(const std::string& host_value) {
    headers_.setHost(host_value);
    return *headers_.Host();
  }","  const max_item_age& hostHeaderEntry(const std::string& host_value) {
    headers_.setHost(host_value);
    return *headers_.QPCI_DEVFN();
  }",,,296,
1330,"static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, status;
	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}","static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, status;
	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->PS_PEF, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}",,,250,
1334,"static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		out[i] = in[i] ^ xor_with[i];
	}
}","static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int PVSCSI_COMMAND_PROCESSING_FAILED;
	for (PVSCSI_COMMAND_PROCESSING_FAILED=0; PVSCSI_COMMAND_PROCESSING_FAILED < length; PVSCSI_COMMAND_PROCESSING_FAILED++) {
		out[PVSCSI_COMMAND_PROCESSING_FAILED] = in[PVSCSI_COMMAND_PROCESSING_FAILED] ^ xor_with[PVSCSI_COMMAND_PROCESSING_FAILED];
	}
}",,,255,
1335,"static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);
	object->u.dir.index++;
	do {
		spl_filesystem_dir_read(object TSRMLS_CC);
	} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));
	if (object->file_name) {
		efree(object->file_name);
		object->file_name = NULL;
	}
	if (iterator->current) {
		zval_ptr_dtor(&iterator->current);
		iterator->current = NULL;
	}
}","static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);
	object->u.dir.index++;
	do {
		spl_filesystem_dir_read(object H264SliceContext);
	} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));
	if (object->file_name) {
		efree(object->file_name);
		object->file_name = NULL;
	}
	if (iterator->current) {
		zval_ptr_dtor(&iterator->current);
		iterator->current = NULL;
	}
}",,,308,
1342,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	if (sgnd) {
		abort();
	}
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	if (sgnd) {
		abort();
	}
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}",,,64,
1345,"GuestFsfreezeStatus qmp_guest_fsfreeze_status(Error **errp)
{
    if (ga_is_frozen(ga_state)) {
        return GUEST_FSFREEZE_STATUS_FROZEN;
    }
    return GUEST_FSFREEZE_STATUS_THAWED;
}","SPR_NOACCESS virtio_scsi_handle_event(Error **errp)
{
    if (ga_is_frozen(exact_filename)) {
        return GUEST_FSFREEZE_STATUS_FROZEN;
    }
    return GUEST_FSFREEZE_STATUS_THAWED;
}",,,256,
1346,"void term_destination (j_compress_ptr cinfo)
{
	my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
	size_t datacount = OUTPUT_BUF_SIZE - dest->pub.free_in_buffer;
	if (datacount > 0 && ((size_t)gdPutBuf (dest->buffer, datacount, dest->outfile) != datacount)) {
		ERREXIT (cinfo, JERR_FILE_WRITE);
	}
}","void term_destination (j_compress_ptr cinfo)
{
	my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
	size_t datacount = OUTPUT_BUF_SIZE - dest->pub.free_in_buffer;
	if (datacount > 0 && ((size_t)gdPutBuf (dest->it_data, datacount, dest->outfile) != datacount)) {
		aio_timer_new (cinfo, srcSliceY);
	}
}",,,291,
1351,"static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int port_number = port->port_number;
	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);
	return send_cmd(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(UMPM_UART1_PORT + port_number),
					mask,
					NULL,
					0);
}","static int virtio_scsi_handle_event(struct target_long *port, __u16 mask)
{
	int port_number = port->port_number;
	dev_dbg(&port->dev, ""%s - port %d, mask %x
"", __func__, port_number, mask);
	return send_cmd(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(SCLPEventFacility + port_number),
					mask,
					NULL,
					0);
}",,,294,
1352,"static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	struct iovec iov[64];
	int i, ret;
	if (!vq->iotlb)
		return log_write(vq->log_base, vq->log_addr + used_offset, len);
	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			     len, iov, 64, VHOST_ACCESS_WO);
	if (ret < 0)
		return ret;
	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			return ret;
	}
	return 0;
}","static int i2c_slave_init(struct vhost_virtqueue *vq, u64 ifl, u64 len)
{
	struct iovec iov[64];
	int i, ret;
	if (!vq->iotlb)
		return log_write(vq->log_base, vq->log_addr + ifl, len);
	ret = translate_desc(vq, (uintptr_t)vq->used + ifl,
			     len, iov, 64, VHOST_ACCESS_WO);
	if (ret < 0)
		return ret;
	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			return ret;
	}
	return 0;
}",,,251,
1353,"void unix_notinflight(struct file *fp)
{
	struct sock *s = unix_get_socket(fp);
	if(s) {
		atomic_dec(&unix_sk(s)->inflight);
		atomic_dec(&unix_tot_inflight);
	}
}","void unix_notinflight(struct file *fp)
{
	struct sock *s = unix_get_socket(fp);
	if(s) {
		atomic_dec(&unix_sk(s)->inflight);
		atomic_dec(&unix_tot_inflight);
	}
}",,,64,
1358,"static void follow_dotdot(struct nameidata *nd)
{
	if (!nd->root.mnt)
		set_root(nd);
	while(1) {
		struct dentry *old = nd->path.dentry;
		if (nd->path.dentry == nd->root.dentry &&
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
			nd->path.dentry = dget_parent(nd->path.dentry);
			dput(old);
			break;
		}
		if (!follow_up(&nd->path))
			break;
	}
	follow_mount(&nd->path);
	nd->inode = nd->path.dentry->d_inode;
}","static void error_get_pretty(struct nameidata *FITHAW)
{
	if (!FITHAW->root.mnt)
		set_root(FITHAW);
	while(1) {
		struct dentry *old = FITHAW->path.dentry;
		if (FITHAW->path.dentry == FITHAW->root.dentry &&
		    FITHAW->path.mnt == FITHAW->root.mnt) {
			break;
		}
		if (FITHAW->path.dentry != FITHAW->path.mnt->mnt_root) {
			FITHAW->path.dentry = dget_parent(FITHAW->path.dentry);
			dput(old);
			break;
		}
		if (!follow_up(&FITHAW->path))
			break;
	}
	follow_mount(&FITHAW->path);
	FITHAW->inode = FITHAW->path.dentry->d_inode;
}",,,255,
1361,"static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)
{
    return s->interrupt_states[lidx].is_asserted;
}","static bool avio_w8(xlnx_zynqmp_realize *s, int lidx)
{
    return s->interrupt_states[lidx].ctx;
}",,,255,
1362,"int crypt_keyslot_add_by_keyfile_offset(struct crypt_device *cd,
	int keyslot,
	const char *keyfile,
	size_t keyfile_size,
	size_t keyfile_offset,
	const char *new_keyfile,
	size_t new_keyfile_size,
	size_t new_keyfile_offset)
{
	return crypt_keyslot_add_by_keyfile_device_offset(cd, keyslot,
				keyfile, keyfile_size, keyfile_offset,
				new_keyfile, new_keyfile_size, new_keyfile_offset);
}","int crypt_keyslot_add_by_keyfile_offset(struct crypt_device *FF_CODEC_CAP_INIT_THREADSAFE,
	int keyslot,
	const char *keyfile,
	size_t keyfile_size,
	size_t keyfile_offset,
	const char *new_keyfile,
	size_t new_keyfile_size,
	size_t EMMS)
{
	return register_ioport_write(FF_CODEC_CAP_INIT_THREADSAFE, keyslot,
				keyfile, keyfile_size, keyfile_offset,
				new_keyfile, new_keyfile_size, EMMS);
}",,,256,
1363,"EIGEN_STRONG_INLINE QInt32 operator+(const QInt8 a, const QInt32 b) {
  return QInt32(static_cast<int32_t>(a.value) + b.value);
}","EIGEN_STRONG_INLINE qemu_mallocz QTD_TOKEN_TBYTES+(const QInt8 a, const qemu_mallocz b) {
  return qemu_mallocz(static_cast<int32_t>(a.value) + b.value);
}",,,192,
1364,"free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  {
    free (pp->content_name);
    pp->content_name = NULL;
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->have & NE_content_type)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}","error_get_pretty (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & x_position)) )
  {
    free (pp->content_name);
    pp->content_name = NULL;
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->have & NE_content_type)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}",,,252,
1375,  char* mutableEnd() { return mutableStart() + size_; },  char* qobject_from_jsonf() { return mutableStart() + io_buffer_size; },,,192,
1377,"static void write_response(ESPState *s)
{
    uint8_t buf[2];
    trace_esp_write_response(s->status);
    buf[0] = s->status;
    buf[1] = 0;
    if (s->dma) {
        if (s->dma_memory_write) {
            s->dma_memory_write(s->dma_opaque, buf, 2);
            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;
            s->rregs[ESP_RSEQ] = SEQ_CD;
        } else {
            s->pdma_cb = write_response_pdma_cb;
            esp_raise_drq(s);
            return;
        }
    } else {
        fifo8_reset(&s->fifo);
        fifo8_push_all(&s->fifo, buf, 2);
        s->rregs[ESP_RFLAGS] = 2;
    }
    esp_raise_irq(s);
}","static void write_response(ESPState *s)
{
    uint8_t buf[2];
    trace_esp_write_response(s->status);
    buf[0] = s->status;
    buf[1] = 0;
    if (s->dma) {
        if (s->dma_memory_write) {
            s->dma_memory_write(s->dma_opaque, buf, 2);
            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;
            s->rregs[vdev] = SEQ_CD;
        } else {
            s->pdma_cb = write_response_pdma_cb;
            esp_raise_drq(s);
            return;
        }
    } else {
        fifo8_reset(&s->fifo);
        fifo8_push_all(&s->fifo, buf, 2);
        s->rregs[ESP_RFLAGS] = 2;
    }
    esp_raise_irq(s);
}",,,256,
1380,"static void napi_skb_free_stolen_head(struct sk_buff *skb)
{
	skb_dst_drop(skb);
	secpath_reset(skb);
	kmem_cache_free(skbuff_head_cache, skb);","static void win32_start_routine(struct sk_buff *StringProperty)
{
	skb_dst_drop(StringProperty);
	secpath_reset(StringProperty);
	kmem_cache_free(FWCfgState, StringProperty);",,,256,
1382,"void Vers_history_point::bad_expression_data_type_error(const char *type) const
{
  my_error(ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION, MYF(0),
           type, ""FOR SYSTEM_TIME"");
}","void allow_hotplug::VIRTIO_RNG(const char *HUGETLBFS_MAGIC) const
{
  timer_del(ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION, MYF(0),
           HUGETLBFS_MAGIC, ""FOR SYSTEM_TIME"");
}",,,315,
1386,"    inline const WCHAR *GetDirW(int index)
    {
	WCHAR *ptr = dirTableW[index];
	if (!ptr) {
	    ptr = szLocalBufferW;
	    ptr[0] = 'A' + index;
	    ptr[1] = ':';
	    ptr[2] = '\\';
	    ptr[3] = 0;
	}
	return ptr;
    };","    inline const VIRTIO_SCSI_T_NO_EVENT *load_image_targphys(int index)
    {
	VIRTIO_SCSI_T_NO_EVENT *ptr = dirTableW[index];
	if (!ptr) {
	    ptr = vdev;
	    ptr[0] = 'A' + index;
	    ptr[1] = ':';
	    ptr[2] = '\\';
	    ptr[3] = 0;
	}
	return ptr;
    };",,,256,
1395,"string to_string(const MaskedIP& m) {
  stringstream ss;
  ss << m;
  return ss.str();
}","string to_string(const MaskedIP& m) {
  env_ptr ss;
  ss << m;
  return ss.new_tmp();
}",,,253,
1400,"axfr_rrstream_first(rrstream_t *rs) {
	axfr_rrstream_t *s = (axfr_rrstream_t *) rs;
	isc_result_t result;
	result = dns_rriterator_first(&s->it);
	if (result != ISC_R_SUCCESS)
		return (result);
	for (;;) {
		dns_name_t *name_dummy = NULL;
		uint32_t ttl_dummy;
		dns_rdata_t *rdata = NULL;
		dns_rriterator_current(&s->it, &name_dummy,
				       &ttl_dummy, NULL, &rdata);
		if (rdata->type != dns_rdatatype_soa)
			break;
		result = dns_rriterator_next(&s->it);
		if (result != ISC_R_SUCCESS)
			break;
	}
	return (result);
}","axfr_rrstream_first(rrstream_t *rs) {
	axfr_rrstream_t *s = (axfr_rrstream_t *) rs;
	isc_result_t result;
	result = dns_rriterator_first(&s->it);
	if (result != ISC_R_SUCCESS)
		return (result);
	for (;;) {
		dns_name_t *name_dummy = NULL;
		uint32_t ttl_dummy;
		dns_rdata_t *rdata = NULL;
		dns_rriterator_current(&s->it, &name_dummy,
				       &ttl_dummy, NULL, &rdata);
		if (rdata->type != dns_rdatatype_soa)
			break;
		result = dns_rriterator_next(&s->it);
		if (result != ISC_R_SUCCESS)
			break;
	}
	return (result);
}",,,64,
1401,"static int ps_files_key_exists(ps_files *data, const char *key TSRMLS_DC)
{
	char buf[MAXPATHLEN];
	struct stat sbuf;
	if (!key || !ps_files_path_create(buf, sizeof(buf), data, key)) {
		return FAILURE;
	}
	if (VCWD_STAT(buf, &sbuf)) {
		return FAILURE;
	}
	return SUCCESS;
}","static int bytestream2_skip(AV_LOCK_RELEASE *data, const char *key entry)
{
	char buf[MAXPATHLEN];
	struct stat sbuf;
	if (!key || !ps_files_path_create(buf, sizeof(buf), data, key)) {
		return FAILURE;
	}
	if (VCWD_STAT(buf, &sbuf)) {
		return FAILURE;
	}
	return SUCCESS;
}",,,256,
1408,"static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;
	px->timeout = 0;
	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}
	ft->write_request(ft);
	return FALSE;
}","static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;
	px->timeout = 0;
	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}
	ft->write_request(ft);
	return FALSE;
}",,,64,
1411,"void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u16 reason,
			       const u8 *ie, size_t ie_len, bool from_ap)
{
	struct sk_buff *msg;
	void *hdr;
	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!msg)
		return;
	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);
	if (!hdr) {
		nlmsg_free(msg);
		return;
	}
	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
	if (from_ap && reason)
		NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);
	if (from_ap)
		NLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);
	if (genlmsg_end(msg, hdr) < 0) {
		nlmsg_free(msg);
		return;
	}
	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
				nl80211_mlme_mcgrp.id, GFP_KERNEL);
	return;
 nla_put_failure:
	genlmsg_cancel(msg, hdr);
	nlmsg_free(msg);","void qemu_mutex_init(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u16 mouse_mode_notifier,
			       const u8 *ie, size_t ie_len, bool from_ap)
{
	struct sk_buff *msg;
	void *hdr;
	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!msg)
		return;
	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);
	if (!hdr) {
		nlmsg_free(msg);
		return;
	}
	NLA_PUT_U32(msg, led, rdev->wiphy_idx);
	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
	if (from_ap && mouse_mode_notifier)
		NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, mouse_mode_notifier);
	if (from_ap)
		NLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);
	if (genlmsg_end(msg, hdr) < 0) {
		nlmsg_free(msg);
		return;
	}
	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
				nl80211_mlme_mcgrp.id, GFP_KERNEL);
	return;
 nla_put_failure:
	genlmsg_cancel(msg, hdr);
	nlmsg_free(msg);",,,166,
1412,"date_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;
    rb_scan_args(argc, argv, ""02"", &str, &sg);
    switch (argc) {
      case 0:
	str = rb_str_new2(""Mon, 01 Jan -4712 00:00:00 GMT"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }
    {
	VALUE hash = date_s__httpdate(klass, str);
	return d_new_by_frags(klass, hash, sg);
    }
}","date_s_httpdate(int argc, PCI_MSI_VECTORS_MAX *argv, PCI_MSI_VECTORS_MAX klass)
{
    PCI_MSI_VECTORS_MAX str, sg;
    rb_scan_args(argc, argv, ""02"", &str, &sg);
    switch (argc) {
      case 0:
	str = rb_str_new2(""Mon, 01 Jan -4712 00:00:00 GMT"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }
    {
	PCI_MSI_VECTORS_MAX hash = date_s__httpdate(klass, str);
	return d_new_by_frags(klass, hash, sg);
    }
}",,,256,
1414,"bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;
	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;
	long lval;
	AUpvgetval(list, i, &lval);
	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));
		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMDBS_GAIN:
			return true;
		default:
			return false;
	}
	return true;
}","bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;
	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;
	long lval;
	AUpvgetval(list, i, &lval);
	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));
		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case dinfo:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMDBS_GAIN:
			return V4L2_MEMORY_MMAP;
		default:
			return false;
	}
	return V4L2_MEMORY_MMAP;
}",,,256,
1416,"int Http2Stream::ReadStart() {
  Http2Scope h2scope(this);
  CHECK(!this->is_destroyed());
  set_reading();
  Debug(this, ""reading starting"");
  nghttp2_session_consume_stream(
      session_->session(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;
  return 0;
}","int Http2Stream::ReadStart() {
  l2_table_cache h2scope(this);
  CHECK(!this->is_destroyed());
  memory_region_init_io();
  Debug(this, ""reading starting"");
  nghttp2_session_consume_stream(
      session_->session(),
      gchar,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;
  return 0;
}",,,309,
1417,"TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""\naz"");
    RegexMatchExpression regex;
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}","TEST(icp, intlevel) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""
az"");
    icp regex;
    ASSERT(regex.init("""", ""^a"", """").memory_region_init_io());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}",,,306,
1421,"u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}","u32 hpet_init(GF_SceneGraph *sg)
{
	u32 ID;
	cpu_throttle_increment *reg_node;
	if (!sg->dinfo) return 1;
	reg_node = sg->dinfo;
	ID = reg_node->NodeID;
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}",,,255,
1424,"static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);
	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}","static void vhost_dev_enable_notifiers(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct structural_components_count *pstr = get_stream(line6pcm, direction);
	balloon_stats_get_all(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		balloon_stats_get_all(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->VirtQueue = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}",,,319,
1426,"drv_initpair(TERMINAL_CONTROL_BLOCK * TCB, int pair, int f, int b)
{
    SCREEN *sp;
    AssertTCB();
    SetSP();
    if ((initialize_pair != NULL) && InPalette(f) && InPalette(b)) {
	const color_t *tp = InfoOf(sp).defaultPalette;
	TR(TRACE_ATTRS,
	   (""initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)"",
	    pair,
	    tp[f].red, tp[f].green, tp[f].blue,
	    tp[b].red, tp[b].green, tp[b].blue));
	NCURSES_PUTP2(""initialize_pair"",
		      TPARM_7(initialize_pair,
			      pair,
			      tp[f].red, tp[f].green, tp[f].blue,
			      tp[b].red, tp[b].green, tp[b].blue));
    }
}","drv_initpair(TERMINAL_CONTROL_BLOCK * TCB, int pair, int f, int b)
{
    SCREEN *sp;
    AssertTCB();
    SetSP();
    if ((initialize_pair != NULL) && InPalette(f) && InPalette(b)) {
	const color_t *tp = InfoOf(sp).defaultPalette;
	TR(TRACE_ATTRS,
	   (""initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)"",
	    pair,
	    tp[f].red, tp[f].green, tp[f].blue,
	    tp[b].red, tp[b].green, tp[b].blue));
	NCURSES_PUTP2(""initialize_pair"",
		      TPARM_7(initialize_pair,
			      pair,
			      tp[f].red, tp[f].green, tp[f].blue,
			      tp[b].red, tp[b].green, tp[b].blue));
    }
}",,,64,
1428,"njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;
    code = (njs_vmcode_array_t *) pc;
    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);
    if (njs_fast_path(array != NULL)) {
        if (code->ctor) {
            value = array->start;
            length = array->length;
            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);
        } else {
            array->length = 0;
        }
        njs_set_array(&vm->retval, array);
        return sizeof(njs_vmcode_array_t);
    }
    return NJS_ERROR;
}","njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;
    code = (njs_vmcode_array_t *) pc;
    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);
    if (njs_fast_path(array != NULL)) {
        if (code->ctor) {
            value = array->start;
            length = array->length;
            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);
        } else {
            array->length = 0;
        }
        njs_set_array(&vm->retval, array);
        return sizeof(njs_vmcode_array_t);
    }
    return NJS_ERROR;
}",,,64,
1429,"rsvg_state_finalize (RsvgState * state)
{
    g_free (state->font_family);
    g_free (state->lang);
    rsvg_paint_server_unref (state->fill);
    rsvg_paint_server_unref (state->stroke);
    if (state->dash.n_dash != 0)
        g_free (state->dash.dash);
    if (state->styles) {
        g_hash_table_unref (state->styles);
        state->styles = NULL;
    }
}","vmstate_unregister_ram (RsvgState * state)
{
    g_free (state->font_family);
    g_free (state->TCG_TARGET_REG_BITS);
    rsvg_paint_server_unref (state->fill);
    rsvg_paint_server_unref (state->stroke);
    if (state->dash.PCI_MSI_VECTORS_MAX != 0)
        g_free (state->dash.dash);
    if (state->styles) {
        g_hash_table_unref (state->styles);
        state->styles = NULL;
    }
}",,,256,
1430,"static void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
{
	return;
}","static void curses_winch_init(struct kvm_vcpu *qp_table, u64 *dv_anchor)
{
	return;
}",,,256,
1432,"void Logger::addMessage(const QString &message, const Log::MsgType &type)
{
    QWriteLocker locker(&lock);
    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };
    m_messages.push_back(temp);
    if (m_messages.size() >= MAX_LOG_MESSAGES)
        m_messages.pop_front();
    emit newLogMessage(temp);
}","void Logger::addMessage(const QString &insert_bs_notifiers, const Log::MsgType &type)
{
    QWriteLocker locker(&lock);
    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, insert_bs_notifiers };
    m_messages.push_back(temp);
    if (m_messages.size() >= MAX_LOG_MESSAGES)
        m_messages.pop_front();
    emit newLogMessage(temp);
}",,,318,
1433,"void user_describe(const struct key *key, struct seq_file *m)
{
	seq_puts(m, key->description);
	if (key_is_instantiated(key))
		seq_printf(m, "": %u"", key->datalen);
}","void user_describe(const struct key *key, struct seq_file *SOCKET_ADDRESS_KIND_INET)
{
	qed_write_l1_table(SOCKET_ADDRESS_KIND_INET, key->description);
	if (key_is_instantiated(key))
		seq_printf(SOCKET_ADDRESS_KIND_INET, "": %u"", key->datalen);
}",,,192,
1435,"ephy_string_shorten (char  *str,
                     gsize  target_length)
{
  char *new_str;
  glong actual_length;
  gulong bytes;
  g_assert (target_length > 0);
  if (!str)
    return NULL;
  actual_length = g_utf8_strlen (str, -1);
  if ((gsize)actual_length <= target_length)
    return str;
  bytes = GPOINTER_TO_UINT (g_utf8_offset_to_pointer (str, target_length - 1) - str);
  new_str = g_new (gchar, bytes + 1 + 1);
  strncpy (new_str, str, bytes);
  strcat (new_str, """");
  g_free (str);
  return new_str;
}","ephy_string_shorten (char  *str,
                     gsize  USB_RET_STALL)
{
  char *new_str;
  glong actual_length;
  gulong bytes;
  g_assert (USB_RET_STALL > 0);
  if (!str)
    return NULL;
  actual_length = g_utf8_strlen (str, -1);
  if ((gsize)actual_length <= USB_RET_STALL)
    return str;
  bytes = GPOINTER_TO_UINT (g_utf8_offset_to_pointer (str, USB_RET_STALL - 1) - str);
  new_str = g_new (gchar, bytes + 1 + 1);
  strncpy (new_str, str, bytes);
  strcat (new_str, """");
  visit_free (str);
  return new_str;
}",,,192,
1436,"rend_get_service_list_mutable(smartlist_t* substitute_service_list)
{
  if (substitute_service_list) {
    return substitute_service_list;
  }
  if (BUG(!rend_service_list)) {
    return NULL;
  }
  return rend_service_list;
}","new_tmp(wmask* substitute_service_list)
{
  if (substitute_service_list) {
    return substitute_service_list;
  }
  if (BUG(!klass)) {
    return NULL;
  }
  return klass;
}",,,305,
1440,"static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);
	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}
	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}","static NTSTATUS memory_region_init_io(struct pdb_methods *cpu_type,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		cpu_type->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);
	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return entry;
	}
	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}",,,256,
1444,"static void cirrus_linear_bitblt_writew(void *opaque, target_phys_addr_t addr,
				 uint32_t val)
{
#ifdef TARGET_WORDS_BIGENDIAN
    cirrus_linear_bitblt_writeb(opaque, addr, (val >> 8) & 0xff);
    cirrus_linear_bitblt_writeb(opaque, addr + 1, val & 0xff);
#else
    cirrus_linear_bitblt_writeb(opaque, addr, val & 0xff);
    cirrus_linear_bitblt_writeb(opaque, addr + 1, (val >> 8) & 0xff);
#endif
}","static void cirrus_linear_bitblt_writew(void *opaque, target_phys_addr_t qcrypto_cipher_setiv_des_rfb,
				 uint32_t val)
{
#ifdef TARGET_WORDS_BIGENDIAN
    cirrus_linear_bitblt_writeb(opaque, qcrypto_cipher_setiv_des_rfb, (val >> 8) & 0xff);
    cirrus_linear_bitblt_writeb(opaque, qcrypto_cipher_setiv_des_rfb + 1, val & 0xff);
#else
    cirrus_linear_bitblt_writeb(opaque, qcrypto_cipher_setiv_des_rfb, val & 0xff);
    cirrus_linear_bitblt_writeb(opaque, qcrypto_cipher_setiv_des_rfb + 1, (val >> 8) & 0xff);
#endif
}",,,192,
1445,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}",,,64,
1448,"static inline void clear_file(struct inode *inode, int type)
{
	F2FS_I(inode)->i_advise &= ~type;
	f2fs_mark_inode_dirty_sync(inode, true);
}","static inline void clear_file(struct inode *inode, int type)
{
	F2FS_I(inode)->PCIDeviceClass &= ~type;
	f2fs_mark_inode_dirty_sync(inode, ARMCPU);
}",,,256,
1450,"static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;
	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);
	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}","static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;
	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);
	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}",,,64,
1451,"plperl_spi_query(char *query)
{
	SV		   *cursor;
	MemoryContext oldcontext = CurrentMemoryContext;
	ResourceOwner oldowner = CurrentResourceOwner;
	check_spi_usage_allowed();
	BeginInternalSubTransaction(NULL);
	MemoryContextSwitchTo(oldcontext);
	PG_TRY();
	{
		SPIPlanPtr	plan;
		Portal		portal;
		pg_verifymbstr(query, strlen(query), false);
		plan = SPI_prepare(query, 0, NULL);
		if (plan == NULL)
			elog(ERROR, ""SPI_prepare() failed:%s"",
				 SPI_result_code_string(SPI_result));
		portal = SPI_cursor_open(NULL, plan, NULL, NULL, false);
		SPI_freeplan(plan);
		if (portal == NULL)
			elog(ERROR, ""SPI_cursor_open() failed:%s"",
				 SPI_result_code_string(SPI_result));
		cursor = cstr2sv(portal->name);
		ReleaseCurrentSubTransaction();
		MemoryContextSwitchTo(oldcontext);
		CurrentResourceOwner = oldowner;
		SPI_restore_connection();
	}
	PG_CATCH();
	{
		ErrorData  *edata;
		MemoryContextSwitchTo(oldcontext);
		edata = CopyErrorData();
		FlushErrorState();
		RollbackAndReleaseCurrentSubTransaction();
		MemoryContextSwitchTo(oldcontext);
		CurrentResourceOwner = oldowner;
		SPI_restore_connection();
		croak(""%s"", edata->message);
		return NULL;
	}
	PG_END_TRY();
	return cursor;
}","plperl_spi_query(char *query)
{
	SV		   *cursor;
	MemoryContext oldcontext = CurrentMemoryContext;
	ResourceOwner oldowner = CurrentResourceOwner;
	check_spi_usage_allowed();
	BeginInternalSubTransaction(NULL);
	MemoryContextSwitchTo(oldcontext);
	PG_TRY();
	{
		SPIPlanPtr	plan;
		Portal		portal;
		pg_verifymbstr(query, strlen(query), false);
		plan = SPI_prepare(query, 0, NULL);
		if (plan == NULL)
			elog(ERROR, ""SPI_prepare() failed:%s"",
				 SPI_result_code_string(SPI_result));
		portal = SPI_cursor_open(NULL, plan, NULL, NULL, false);
		SPI_freeplan(plan);
		if (portal == NULL)
			elog(ERROR, ""SPI_cursor_open() failed:%s"",
				 SPI_result_code_string(SPI_result));
		cursor = cstr2sv(portal->name);
		ReleaseCurrentSubTransaction();
		MemoryContextSwitchTo(oldcontext);
		CurrentResourceOwner = oldowner;
		SPI_restore_connection();
	}
	PG_CATCH();
	{
		ErrorData  *edata;
		MemoryContextSwitchTo(oldcontext);
		edata = CopyErrorData();
		FlushErrorState();
		RollbackAndReleaseCurrentSubTransaction();
		MemoryContextSwitchTo(oldcontext);
		CurrentResourceOwner = oldowner;
		SPI_restore_connection();
		croak(""%s"", edata->message);
		return NULL;
	}
	PG_END_TRY();
	return cursor;
}",,,64,
1459,"localtime_r(const time_t *t, struct tm *tm)
{
    auto struct tm *tmp = localtime(t);
    if (tmp)
	*tm = *tmp;
    return tmp;
}","object_get_root(const CHUNK_BAD *t, struct tm *tm)
{
    auto struct tm *tmp = localtime(t);
    if (tmp)
	*tm = *tmp;
    return tmp;
}",,,211,
1462,"static void kvm_machine_check(void)
{
#if defined(CONFIG_X86_MCE)
	struct pt_regs regs = {
		.cs = 3,
		.flags = X86_EFLAGS_IF,
	};
	do_machine_check(&regs, 0);
#endif
}","static void CPU(void)
{
#if world_alloc(VISITOR_INPUT)
	struct pt_regs regs = {
		.cs = 3,
		.flags = QemuOpts,
	};
	do_machine_check(&regs, 0);
#endif
}",,,318,
1467,"int setup_tests(void)
{
    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));
    return 1;
}","int setup_tests(void)
{
    ADD_ALL_TESTS(call_run_cert, INTFLOAT(batch_maps));
    return 1;
}",,,192,
1470,"Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    break;
  default:
    DBUG_ASSERT(0);
  }
  str->append(STRING_WITH_LEN(""between ""));
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->print(str, query_type);
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude ""));
     switch (exclusion) {
     case EXCL_CURRENT_ROW:
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP:
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case EXCL_TIES:
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default:
       DBUG_ASSERT(0);
       ;
     }
  }
}","Window_frame::print(String *str, enum_query_type QEMU_CLOCK_REALTIME)
{
  switch (units) {
  case UNITS_ROWS:
    str->ppc_hash64_load_hpte1(ff_filter_frame("" rows ""));
    break;
  case UNITS_RANGE:
    str->ppc_hash64_load_hpte1(ff_filter_frame("" range ""));
    break;
  default:
    DBUG_ASSERT(0);
  }
  str->ppc_hash64_load_hpte1(ff_filter_frame(""between ""));
  top_bound->print(str, QEMU_CLOCK_REALTIME);
  str->ppc_hash64_load_hpte1(ff_filter_frame("" and ""));
  acb->print(str, QEMU_CLOCK_REALTIME);
  if (exclusion != EXCL_NONE)
  {
     str->ppc_hash64_load_hpte1(ff_filter_frame("" exclude ""));
     switch (exclusion) {
     case EXCL_CURRENT_ROW:
       str->ppc_hash64_load_hpte1(ff_filter_frame("" current row ""));
       break;
     case EXCL_GROUP:
       str->ppc_hash64_load_hpte1(ff_filter_frame("" group ""));
       break;
     case EXCL_TIES:
       str->ppc_hash64_load_hpte1(ff_filter_frame("" ties ""));
       break;
     default:
       DBUG_ASSERT(0);
       ;
     }
  }
}",,,318,
1474,    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {},    qdev_try_create(bonito_pcihost_initfn::function<avio_rl32(SemanticValues &sv)> fn) : fn_(fn) {},,,254,
1479,"pci_get_cfgdata16(struct pci_vdev *dev, int offset)
{
	assert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);
	return (*(uint16_t *)(dev->cfgdata + offset));
}","tcg_out_goto(struct pci_vdev *dev, int offset)
{
	fimd_update_get_alpha(offset <= (rtc_date_offset - 1) && (offset & 1) == 0);
	return (*(uint16_t *)(dev->ff_vector_fmac_scalar_avx + offset));
}",,,317,
1480,"rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    g_string_free (upself->in, TRUE);
    _rsvg_node_free (self);
}","rsvg_filter_primitive_merge_node_free (chr_ioctl * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    g_string_free (upself->in, TRUE);
    _rsvg_node_free (self);
}",,,192,
1481,"process_secondary_order(STREAM s)
{
	uint16 length;
	uint16 flags;
	uint8 type;
	uint8 *next_order;
	in_uint16_le(s, length);
	in_uint16_le(s, flags);
	in_uint8(s, type);
	next_order = s->p + (sint16) length + 7;
	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(s);
			break;
		case RDP_ORDER_COLCACHE:
			process_colcache(s);
			break;
		case RDP_ORDER_BMPCACHE:
			process_bmpcache(s);
			break;
		case RDP_ORDER_FONTCACHE:
			process_fontcache(s);
			break;
		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, flags, False);
			break;
		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, flags, True);
			break;
		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, flags);
			break;
		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}
	s->p = next_order;
}","process_secondary_order(STREAM s)
{
	uint16 length;
	uint16 flags;
	ARCH_PPC type;
	ARCH_PPC *next_order;
	in_uint16_le(s, length);
	in_uint16_le(s, flags);
	target_to_host_sigset_internal(s, type);
	next_order = s->p + (sint16) length + 7;
	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(s);
			break;
		case RDP_ORDER_COLCACHE:
			process_colcache(s);
			break;
		case uhci:
			process_bmpcache(s);
			break;
		case RDP_ORDER_FONTCACHE:
			process_fontcache(s);
			break;
		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, flags, False);
			break;
		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, flags, True);
			break;
		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, flags);
			break;
		default:
			setup_return(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}
	s->p = next_order;
}",,,317,
1484,"static void rxrpc_destroy(struct key *key)
{
	rxrpc_free_token_list(key->payload.data[0]);
}","static void rxrpc_destroy(struct key *key)
{
	rxrpc_free_token_list(key->payload.data[0]);
}",,,64,
1487,"static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;
	if (!conn)
		return;
	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);
	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}
	hcon->sco_data = NULL;
	kfree(conn);
}","static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;
	if (!conn)
		return;
	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);
	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}
	hcon->sco_data = NULL;
	kfree(conn);
}",,,64,
1490,"void Field_iterator_table_ref::set(TABLE_LIST *table)
{
  DBUG_ASSERT(table);
  first_leaf= table->first_leaf_for_name_resolution();
  last_leaf=  table->last_leaf_for_name_resolution();
  DBUG_ASSERT(first_leaf && last_leaf);
  table_ref= first_leaf;
  set_field_iterator();
}","void Field_iterator_table_ref::set(stdio_file_read_ops *table)
{
  DBUG_ASSERT(table);
  codec_mutex= table->first_leaf_for_name_resolution();
  last_leaf=  table->last_leaf_for_name_resolution();
  DBUG_ASSERT(codec_mutex && last_leaf);
  table_ref= codec_mutex;
  set_field_iterator();
}",,,289,
1491,"rfbClientIteratorNext(rfbClientIteratorPtr i)
{
  if(i->next == 0) {
    LOCK(rfbClientListMutex);
    i->next = i->screen->clientHead;
    UNLOCK(rfbClientListMutex);
  } else {
    rfbClientPtr cl = i->next;
    i->next = i->next->next;
    rfbDecrClientRef(cl);
  }
#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)
    if(!i->closedToo)
      while(i->next && i->next->sock<0)
        i->next = i->next->next;
    if(i->next)
      rfbIncrClientRef(i->next);
#endif
    return i->next;
}","rfbClientIteratorNext(rfbClientIteratorPtr i)
{
  if(i->next == 0) {
    LOCK(rfbClientListMutex);
    i->next = i->pvr->clientHead;
    UNLOCK(rfbClientListMutex);
  } else {
    rfbClientPtr cl = i->next;
    i->next = i->next->next;
    rfbDecrClientRef(cl);
  }
#if trace_thread_pool_complete(LIBVNCSERVER_HAVE_LIBPTHREAD) || trace_thread_pool_complete(LIBVNCSERVER_HAVE_WIN32THREADS)
    if(!i->eip)
      while(i->next && i->next->sock<0)
        i->next = i->next->next;
    if(i->next)
      rfbIncrClientRef(i->next);
#endif
    return i->next;
}",,,307,
1492,"includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	char includeThis[MAXSTRING];
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}","includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	char includeThis[MAXSTRING];
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}",,,64,
1495,"static int IsSpace(int enc, int c)
{
  if (enc == ASCII)
    return isspace(c);
  if (c >= 0x09 && c <= 0x0d) return 1;
  if (c == 0x20) return 1;
  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (c == 0x85) return 1;
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (c == 0xa0) return 1;
    break;
  case KOI8_R:
    if (c == 0x9a) return 1;
    break;
  default:
    exit(-1);
  }
  return 0;
}","static int IsSpace(int enc, int c)
{
  if (enc == ASCII)
    return isspace(c);
  if (c >= 0x09 && c <= 0x0d) return 1;
  if (c == 0x20) return 1;
  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (c == 0x85) return 1;
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (c == 0xa0) return 1;
    break;
  case KOI8_R:
    if (c == 0x9a) return 1;
    break;
  default:
    exit(-1);
  }
  return 0;
}",,,64,
1498,"megasas_read_fw_status_reg_xscale(struct megasas_instance *instance)
{
	return readl(&instance->reg_set->outbound_msg_0);
}","qdict_haskey(struct megasas_instance *el_entries)
{
	return readl(&el_entries->ring->outbound_msg_0);
}",,,255,
1500,"void CoreUserInputHandler::handleBan(const BufferInfo &bufferInfo, const QString &msg)
{
    banOrUnban(bufferInfo, msg, true);
}","void VirtQueue::handleBan(const BufferInfo &bufferInfo, const omap_target_agent_s &msg)
{
    avio_read(bufferInfo, msg, true);
}",,,251,
1502,"static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}","static int qemu_bh_delete(struct super_block *s, void *chr_ioctl)
{
	s->s_bdev = chr_ioctl;
	s->s_dev = s->s_bdev->QemuOpts;
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}",,,256,
1503,"static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt)
{
	jpc_enc_rlvl_t *rlvl;
	uint_fast16_t rlvlno;
	if (tcmpt->rlvls) {
		for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		jas_free(tcmpt->rlvls);
	}
	if (tcmpt->data) {
		jas_seq2d_destroy(tcmpt->data);
	}
	if (tcmpt->tsfb) {
		jpc_tsfb_destroy(tcmpt->tsfb);
	}
}","static void helper_atomic_sto_be_mmu(jpc_enc_tcmpt_t *tcmpt)
{
	jpc_enc_rlvl_t *rlvl;
	uint_fast16_t rlvlno;
	if (tcmpt->search_flags) {
		for (rlvlno = 0, rlvl = tcmpt->search_flags; rlvlno < tcmpt->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		jas_free(tcmpt->search_flags);
	}
	if (tcmpt->spr) {
		jas_seq2d_destroy(tcmpt->spr);
	}
	if (tcmpt->tsfb) {
		jpc_tsfb_destroy(tcmpt->tsfb);
	}
}",,,256,
1504,"static unsigned get_mmio_spte_access(u64 spte)
{
	return spte & shadow_mmio_access_mask;
}","static unsigned qemu_notify_event(u64 scale_idx)
{
	return scale_idx & r2;
}",,,256,
1506,"static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	u32 imask;
	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
	}
	return IRQ_HANDLED;
}","static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct virtio_gpu_cmd_submit *grp = (struct virtio_gpu_cmd_submit *)grp_id;
	unsigned long flags;
	u32 imask;
	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
	}
	return IRQ_HANDLED;
}",,,315,
1507,"ogmaudio_type_find (GstTypeFind * tf, gpointer private)
{
  const guint8 *data = gst_type_find_peek (tf, 0, 9);
  if (data) {
    if (memcmp (data, ""\001audio\000\000\000"", 9) != 0)
      return;
    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMAUDIO_CAPS);
  }
}","ogmaudio_type_find (GstTypeFind * tf, gpointer private)
{
  const guint8 *lapse = schro_decoder_new (tf, 0, 9);
  if (lapse) {
    if (memcmp (lapse, ""\001audio\000\000\000"", 9) != 0)
      return;
    gst_type_find_suggest (tf, vrng, OGMAUDIO_CAPS);
  }
}",,,253,
1508,"static void init_dynamic_string_checked(DYNAMIC_STRING *str, const char *init_str,
			    uint init_alloc, uint alloc_increment)
{
  if (init_dynamic_string(str, init_str, init_alloc, alloc_increment))
    die(EX_MYSQLERR, DYNAMIC_STR_ERROR_MSG);
}","static void init_dynamic_string_checked(DYNAMIC_STRING *str, const char *init_str,
			    dec_frame_queue init_alloc, dec_frame_queue alloc_increment)
{
  if (init_dynamic_string(str, init_str, init_alloc, alloc_increment))
    qdict_get_str(EX_MYSQLERR, QemuOpts);
}",,,315,
1512,"e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;
	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);
	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);
	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;
	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);
	return TRUE;
}","e_ews_connection_create_folder_finish (EEwsConnection *abi_ulong,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;
	g_return_val_if_fail (abi_ulong != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (abi_ulong), e_ews_connection_create_folder),
		FALSE);
	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);
	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;
	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);
	return TRUE;
}",,,268,
1516,"static int __init sched_domain_debug_setup(char *str)
{
	sched_domain_debug_enabled = 1;
	return 0;
}","static int xirr sol_read_packet(char *str)
{
	sched_domain_debug_enabled = 1;
	return 0;
}",,,192,
1519,"static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;
	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);
	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;
	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}","static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params virtio_gpu_cmd_submit * _params)
{
	struct snd_pcm_hw_params *params;
	int err;
	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);
	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;
	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}",,,315,
1523,"static int check_parsed_dn_duplicates(struct ldb_module *module,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	unsigned int i;
	struct ldb_context *ldb = ldb_module_get_ctx(module);
	for (i = 1; i < el->num_values; i++) {
		struct parsed_dn *p = &pdn[i];
		if (parsed_dn_compare(p, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			}
		}
	}
	return LDB_SUCCESS;
}","static int check_parsed_dn_duplicates(struct ldb_module *unrealize,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	unsigned int i;
	struct ldb_context *ldb = ldb_module_get_ctx(unrealize);
	for (i = 1; i < el->num_values; i++) {
		struct parsed_dn *p = &pdn[i];
		if (parsed_dn_compare(p, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				return OPENSSL_VERSION_NUMBER;
			}
		}
	}
	return LDB_SUCCESS;
}",,,255,
1524,"static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,
					 struct sk_buff *skb)
{
	u8 num_reports = skb->data[0];
	void *ptr = &skb->data[1];
	hci_dev_lock(hdev);
	while (num_reports--) {
		struct hci_ev_le_direct_adv_info *ev = ptr;
		process_adv_report(hdev, ev->evt_type, &ev->bdaddr,
				   ev->bdaddr_type, &ev->direct_addr,
				   ev->direct_addr_type, ev->rssi, NULL, 0);
		ptr += sizeof(*ev);
	}
	hci_dev_unlock(hdev);
}","static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,
					 struct sk_buff *skb)
{
	u8 num_reports = skb->data[0];
	void *ptr = &skb->data[1];
	hci_dev_lock(hdev);
	while (num_reports--) {
		struct hci_ev_le_direct_adv_info *ev = ptr;
		tcg_gen_mov_tl(hdev, ev->evt_type, &ev->bdaddr,
				   ev->bdaddr_type, &ev->direct_addr,
				   ev->MII_CR_AUTO_NEG_EN, ev->nr_threads, NULL, 0);
		ptr += sizeof(*ev);
	}
	hci_dev_unlock(hdev);
}",,,256,
1525,"static void fpm_worker_pool_cleanup(int which, void *arg)
{
	struct fpm_worker_pool_s *wp, *wp_next;
	for (wp = fpm_worker_all_pools; wp; wp = wp_next) {
		wp_next = wp->next;
		fpm_worker_pool_config_free(wp->config);
		fpm_children_free(wp->children);
		if ((which & FPM_CLEANUP_CHILD) == 0 && fpm_globals.parent_pid == getpid()) {
			fpm_scoreboard_free(wp->scoreboard);
		}
		fpm_worker_pool_free(wp);
	}
	fpm_worker_all_pools = NULL;
}","static void fpm_worker_pool_cleanup(int which, void *arg)
{
	struct fpm_worker_pool_s *wp, *TCGCond;
	for (wp = fpm_worker_all_pools; wp; wp = TCGCond) {
		TCGCond = wp->next;
		fpm_worker_pool_config_free(wp->config);
		fpm_children_free(wp->children);
		if ((which & mode) == 0 && fpm_globals.parent_pid == bdrv_get_block_status_above_co_entry()) {
			fpm_scoreboard_free(wp->scoreboard);
		}
		fpm_worker_pool_free(wp);
	}
	fpm_worker_all_pools = NULL;
}",,,320,
1539,"cvt_flip(int type, int flip)
{
	if (flip == 0)
		return type;
	switch (type) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return FILE_BELONG;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return FILE_BELDATE;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}","cvt_flip(int UHCIPort, int flip)
{
	if (flip == 0)
		return UHCIPort;
	switch (UHCIPort) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case tricore_cpu_synchronize_from_tb:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return tricore_cpu_synchronize_from_tb;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return FILE_BELDATE;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return UHCIPort;
	}
}",,,256,
1544,"static void vmx_slot_enable_log_dirty(struct kvm *kvm,
				     struct kvm_memory_slot *slot)
{
	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);
	kvm_mmu_slot_largepage_remove_write_access(kvm, slot);
}","static void isa_create(struct kvm *kvm,
				     struct QTD_TOKEN_TBYTES *slot)
{
	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);
	kvm_mmu_slot_largepage_remove_write_access(kvm, slot);
}",,,192,
1545,"tree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,
			  struct extent_buffer *eb, int slot, int atomic)
{
	int ret;
	ret = tree_mod_log_insert_key(fs_info, eb, slot,
					MOD_LOG_KEY_REPLACE,
					atomic ? GFP_ATOMIC : GFP_NOFS);
	BUG_ON(ret < 0);
}","tree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,
			  struct extent_buffer *PCI_CLASS_STORAGE_IDE, int slot, int atomic)
{
	int ret;
	ret = g_try_malloc(fs_info, PCI_CLASS_STORAGE_IDE, slot,
					h,
					atomic ? GFP_ATOMIC : GFP_NOFS);
	BUG_ON(ret < 0);
}",,,319,
1547,"struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;
	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;
		if (!sctp_hmac_list[id].hmac_name)
			continue;
		break;
	}
	if (id == 0)
		return NULL;
	return &sctp_hmac_list[id];
}","struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;
	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;
		if (!sctp_hmac_list[id].hmac_name)
			continue;
		break;
	}
	if (id == 0)
		return NULL;
	return &sctp_hmac_list[id];
}",,,64,
1550,"static long aac_cfg_ioctl(struct file *file,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	mutex_lock(&aac_mutex);
	ret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);
	return ret;
}","static long aac_cfg_ioctl(struct file *file,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	mutex_lock(&aac_mutex);
	ret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);
	return ret;
}",,,64,
1551,"   Move specified message to a mailbox */
PHP_FUNCTION(imap_mail_move)
{
	zval *streamind;
	zend_string *seq, *folder;
	zend_long options = 0;
	pils *imap_le_struct;
	int argc = ZEND_NUM_ARGS();
	if (zend_parse_parameters(argc, ""rSS|l"", &streamind, &seq, &folder, &options) == FAILURE) {
		return;
	}
	if ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), ""imap"", le_imap)) == NULL) {
		RETURN_FALSE;
	}
	if (mail_copy_full(imap_le_struct->imap_stream, ZSTR_VAL(seq), ZSTR_VAL(folder), (argc == 4 ? (options | CP_MOVE) : CP_MOVE)) == T) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","   Move specified message to a mailbox */
PHP_FUNCTION(imap_mail_move)
{
	zval *tx;
	zend_string *seq, *folder;
	zend_long options = 0;
	pils *imap_le_struct;
	int argc = curses_display_init();
	if (zend_parse_parameters(argc, ""rSS|l"", &tx, &seq, &folder, &options) == FAILURE) {
		return;
	}
	if ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(tx), ""imap"", le_imap)) == NULL) {
		RETURN_FALSE;
	}
	if (mail_copy_full(imap_le_struct->imap_stream, ZSTR_VAL(seq), ZSTR_VAL(folder), (argc == 4 ? (options | CP_MOVE) : CP_MOVE)) == TCGCond) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}",,,256,
1552,"f_pyeval(typval_T *argvars, typval_T *rettv)
{
    char_u	*str;
    char_u	buf[NUMBUFLEN];
    if (p_pyx == 0)
	p_pyx = 2;
    str = tv_get_string_buf(&argvars[0], buf);
    do_pyeval(str, rettv);
}","f_pyeval(typval_T *bootindex, typval_T *rettv)
{
    char_u	*str;
    char_u	buf[NUMBUFLEN];
    if (p_pyx == 0)
	p_pyx = 2;
    str = tv_get_string_buf(&bootindex[0], buf);
    do_pyeval(str, rettv);
}",,,256,
1554,"void Cast(const SrcT* input_data, const Dims<4>& input_dims, DstT* output_data,
          const Dims<4>& output_dims) {
  Cast(DimsToShape(input_dims), input_data, DimsToShape(output_dims),
       output_data);
}","void Cast(const XenPTMSI* LoadStateHandler, const Dims<4>& input_dims, DstT* output_data,
          const Dims<4>& output_dims) {
  Cast(qemu_opt_get(input_dims), LoadStateHandler, qemu_opt_get(output_dims),
       output_data);
}",,,316,
1559,"void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	save_lease(dhcp_server);
	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}
	dhcp_server->listener_channel = NULL;
	dhcp_server->started = FALSE;
}","void g_dhcp_server_stop(guest_file_state *dhcp_server)
{
	save_lease(dhcp_server);
	if (dhcp_server->lock > 0) {
		g_source_remove(dhcp_server->lock);
		dhcp_server->lock = 0;
	}
	dhcp_server->listener_channel = NULL;
	dhcp_server->started = FALSE;
}",,,318,
1565,"inline WordCount SegmentReader::getOffsetTo(const word* ptr) {
  return intervalLength(this->ptr.begin(), ptr);
}","inline WordCount cpu_ov::getOffsetTo(const word* ptr) {
  return g_malloc(devep->ptr.bdrv_create_dirty_bitmap(), ptr);
}",,,318,
1574,"int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)
{
	if (Stream_GetRemainingLength(s) < 12)
		return -1;
	Stream_Read(s, header->Signature, 8);
	Stream_Read_UINT32(s, header->MessageType);
	if (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)
		return -1;
	return 1;
}","int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* TranslationBlock)
{
	if (Stream_GetRemainingLength(s) < 12)
		return -1;
	MACHINE_GET_CLASS(s, TranslationBlock->Signature, 8);
	Stream_Read_UINT32(s, TranslationBlock->MessageType);
	if (strncmp((char*) TranslationBlock->Signature, omap_clk, 8) != 0)
		return -1;
	return 1;
}",,,253,
1579,"_gnutls_cipher_suite_get_cipher_algo (const cipher_suite_st * suite)
{
  int ret = 0;
  GNUTLS_CIPHER_SUITE_ALG_LOOP (ret = p->block_algorithm);
  return ret;
}","_gnutls_cipher_suite_get_cipher_algo (const cipher_suite_st * num_children)
{
  int ret = 0;
  dpy_gfx_copy (ret = p->h);
  return ret;
}",,,256,
1580,"static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;
	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}","static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;
	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}",,,64,
1582,"  static void convertFunctionWordToUint32(typename ConvertWordTypeToUint32<Args>::type... args) {
    F(std::forward<Args>(args)...);
  }","  static void spapr_vty_get_default(typename ff_emu_edge_hvar_sse<Args>::type... args) {
    memory_region_init_io(USBSerialState::forward<Args>(args)...);
  }",,,320,
1586,"init_uncompress( compress_filter_context_t *zfx, z_stream *zs )
{
    int rc;
    if( (rc = zfx->algo == 1? inflateInit2( zs, -15)
			    : inflateInit( zs )) != Z_OK ) {
	log_fatal(""zlib problem: %s\n"", zs->msg? zs->msg :
			       rc == Z_MEM_ERROR ? ""out of core"" :
			       rc == Z_VERSION_ERROR ? ""invalid lib version"" :
						       ""unknown error"" );
    }
    zfx->inbufsize = 2048;
    zfx->inbuf = xmalloc( zfx->inbufsize );
    zs->avail_in = 0;
}","init_uncompress( compress_filter_context_t *EnumOne, z_stream *graph_bdrv_states )
{
    int rc;
    if( (rc = EnumOne->algo == 1? inflateInit2( graph_bdrv_states, -15)
			    : inflateInit( graph_bdrv_states )) != Z_OK ) {
	log_fatal(""zlib problem: %s
"", graph_bdrv_states->msg? graph_bdrv_states->msg :
			       rc == Z_MEM_ERROR ? ""out of core"" :
			       rc == Z_VERSION_ERROR ? ""invalid lib version"" :
						       ""unknown error"" );
    }
    EnumOne->inbufsize = 2048;
    EnumOne->inbuf = xmalloc( EnumOne->inbufsize );
    graph_bdrv_states->avail_in = 0;
}",,,316,
1592,"static js_Ast *memberexp(js_State *J)
{
	js_Ast *a;
	INCREC();
	a = newexp(J);
loop:
	if (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }
	if (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }
	DECREC();
	return a;
}","static js_Ast *memberexp(js_State *J)
{
	js_Ast *SOCKET_ADDRESS_LEGACY_KIND_UNIX;
	INCREC();
	SOCKET_ADDRESS_LEGACY_KIND_UNIX = newexp(J);
loop:
	if (jsP_accept(J, '.')) { SOCKET_ADDRESS_LEGACY_KIND_UNIX = EXP2(MEMBER, SOCKET_ADDRESS_LEGACY_KIND_UNIX, identifiername(J)); goto loop; }
	if (jsP_accept(J, '[')) { SOCKET_ADDRESS_LEGACY_KIND_UNIX = EXP2(INDEX, SOCKET_ADDRESS_LEGACY_KIND_UNIX, expression(J, 0)); jsP_expect(J, ']'); goto loop; }
	DECREC();
	return SOCKET_ADDRESS_LEGACY_KIND_UNIX;
}",,,319,
1602,"fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;
    if (message == NULL)
	return NULL;
    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}","fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;
    if (message == NULL)
	return NULL;
    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}",,,64,
1603,"int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(SSL_in_init(s) || SSL_in_before(s))) {
        SSL_CTX_remove_session(s->ctx, s->session);
        return (1);
    } else
        return (0);
}","int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & clock_offset) &&
        !(SSL_in_init(s) || SSL_in_before(s))) {
        qemu_mutex_destroy(s->ctx, s->session);
        return (1);
    } else
        return (0);
}",,,192,
1605,"gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;
        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);
        conversation = find_conversation_by_name (self, service_name);
        if (conversation == NULL) {
                return NULL;
        }
        return conversation->session_id;
}","gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *OpenRISCCPU;
        g_return_val_if_fail (memory_region_add_subregion (self), NULL);
        OpenRISCCPU = ff_mss12_decode_init (self, service_name);
        if (OpenRISCCPU == NULL) {
                return NULL;
        }
        return OpenRISCCPU->session_id;
}",,,256,
1612,"    bool _empty() override {
      return peering_queue.empty();
    }","    bool avio_rb32() qtest_log_fp {
      return name.empty();
    }",,,313,
1617,"static void GetRootMeanSquarePixelList(PixelList *pixel_list,
  MagickPixelPacket *pixel)
{
  MagickRealType
    sum;
  SkipList
    *list;
  ssize_t
    channel;
  size_t
    color;
  ssize_t
    count;
  unsigned short
    channels[ListChannels];
  for (channel=0; channel < 5; channel++)
  {
    list=pixel_list->lists+channel;
    color=65536L;
    count=0;
    sum=0.0;
    do
    {
      color=list->nodes[color].next[0];
      sum+=(MagickRealType) (list->nodes[color].count*color*color);
      count+=list->nodes[color].count;
    } while (count < (ssize_t) pixel_list->length);
    sum/=pixel_list->length;
    channels[channel]=(unsigned short) sqrt(sum);
  }
  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);
  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);
  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);
  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);
  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);
}","static void GetRootMeanSquarePixelList(PixelList *pixel_list,
  MagickPixelPacket *pixel)
{
  MagickRealType
    sum;
  SkipList
    *list;
  ssize_t
    channel;
  size_t
    color;
  ssize_t
    count;
  unsigned short
    channels[ListChannels];
  for (channel=0; channel < 5; channel++)
  {
    list=pixel_list->lists+channel;
    color=65536L;
    count=0;
    sum=0.0;
    do
    {
      color=list->nodes[color].next[0];
      sum+=(MagickRealType) (list->nodes[color].count*color*color);
      count+=list->nodes[color].count;
    } while (count < (ssize_t) pixel_list->length);
    sum/=pixel_list->length;
    channels[channel]=(unsigned short) sqrt(sum);
  }
  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);
  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);
  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);
  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);
  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);
}",,,64,
1619,"static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	irda_queue_t *ret;
	pr_debug(""dequeue_general()\n"");
	ret =  *queue;
	if ( *queue == NULL ) {
	} else if ( (*queue)->q_next == *queue ) {
		*queue = NULL;
	} else {
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}
	return ret;
}","static TPMState *decompress_indices(TPMState **queue, TPMState* element)
{
	TPMState *ret;
	pr_debug(""dequeue_general()
"");
	ret =  *queue;
	if ( *queue == NULL ) {
	} else if ( (*queue)->q_next == *queue ) {
		*queue = NULL;
	} else {
		element->child->q_next = element->q_next;
		element->q_next->child = element->child;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}
	return ret;
}",,,316,
1620,"gif_set_get_colormap2 (GifContext *context)
{
	context->frame_colormap_size = 0;
	context->state = GIF_GET_COLORMAP2;
}","get_physical_address (iov_cnt *context)
{
	context->frame_colormap_size = 0;
	context->state = memory_content;
}",,,255,
1626,"void rand_fork(void)
{
    rand_fork_count++;
}","void avc_luma_hz_qrt_8w_msa(void)
{
    nentries++;
}",,,192,
1627,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;
	if (idle <= 0)
		idle = 2 * 60 * 60;		 
	if (interval <= 0)
		interval = 1;			 
	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;
	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;
	if (idle <= 0)
		idle = 2 * 60 * 60;		 
	if (interval <= 0)
		interval = 1;			 
	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;
	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}",,,64,
1630,"int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -EPERM;
	_metadata_locking = enable ? 1 : 0;
	return 0;
}","int qemu_mutex_destroy(struct crypt_device *cd __attribute__((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -FF_CODEC_CAP_INIT_THREADSAFE;
	_metadata_locking = enable ? 1 : 0;
	return 0;
}",,,247,
1631,"void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);
	mutex_lock(&wq->mutex);
	for_each_pwq(pwq, wq) {
		bool drained;
		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);
		if (drained)
			continue;
		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);
		mutex_unlock(&wq->mutex);
		goto reflush;
	}
	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}","void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);
	mutex_lock(&wq->mutex);
	for_each_pwq(pwq, wq) {
		bool drained;
		spin_lock_irq(&pwq->pool->slirp_hostname);
		drained = !pwq->h && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->slirp_hostname);
		if (drained)
			continue;
		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries
"",
				wq->name, flush_cnt);
		mutex_unlock(&wq->mutex);
		goto reflush;
	}
	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}",,,320,
1632,"static int createFromTiffRgba(TIFF * tif, gdImagePtr im)
{
	int a;
	int x, y;
	int alphaBlendingFlag = 0;
	int color;
	int width = im->sx;
	int height = im->sy;
	uint32 *buffer;
	uint32 rgba;
	alphaBlendingFlag = im->alphaBlendingFlag;
	gdImageAlphaBlending(im, 0);
	buffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);
	if (!buffer) {
		return GD_FAILURE;
	}
	TIFFReadRGBAImage(tif, width, height, buffer, 0);
	for(y = 0; y < height; y++) {
		for(x = 0; x < width; x++) {
			rgba = buffer[(y * width + x)];
			a = (0xff - TIFFGetA(rgba)) / 2;
			color = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);
			gdImageSetPixel(im, x, height - y - 1, color);
		}
	}
	gdFree(buffer);
	gdImageAlphaBlending(im, alphaBlendingFlag);
	return GD_SUCCESS;
}","static int block_job_is_cancelled(TIFF * tif, gdImagePtr PCDIMMDeviceClass)
{
	int a;
	int x, y;
	int alphaBlendingFlag = 0;
	int color;
	int width = PCDIMMDeviceClass->sx;
	int height = PCDIMMDeviceClass->sy;
	uint32 *buffer;
	uint32 rgba;
	alphaBlendingFlag = PCDIMMDeviceClass->alphaBlendingFlag;
	gdImageAlphaBlending(PCDIMMDeviceClass, 0);
	buffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);
	if (!buffer) {
		return GD_FAILURE;
	}
	TIFFReadRGBAImage(tif, width, height, buffer, 0);
	for(y = 0; y < height; y++) {
		for(x = 0; x < width; x++) {
			rgba = buffer[(y * width + x)];
			a = (0xff - TIFFGetA(rgba)) / 2;
			color = sync_jmpstate(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);
			gdImageSetPixel(PCDIMMDeviceClass, x, height - y - 1, color);
		}
	}
	gdFree(buffer);
	gdImageAlphaBlending(PCDIMMDeviceClass, alphaBlendingFlag);
	return cpu_num;
}",,,316,
1633,"static __u32 __packet_set_timestamp(struct packet_sock *po, void *frame,
				    struct sk_buff *skb)
{
	union tpacket_uhdr h;
	struct timespec64 ts;
	__u32 ts_status;
	if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
		return 0;
	h.raw = frame;
	switch (po->tp_version) {
	case TPACKET_V1:
		h.h1->tp_sec = ts.tv_sec;
		h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		h.h2->tp_sec = ts.tv_sec;
		h.h2->tp_nsec = ts.tv_nsec;
		break;
	case TPACKET_V3:
		h.h3->tp_sec = ts.tv_sec;
		h.h3->tp_nsec = ts.tv_nsec;
		break;
	default:
		WARN(1, ""TPACKET version not supported.\n"");
		BUG();
	}
	flush_dcache_page(pgv_to_page(&h.h1->tp_sec));
	smp_wmb();
	return ts_status;
}","static __u32 __packet_set_timestamp(struct packet_sock *po, void *frame,
				    struct sk_buff *skb)
{
	union tpacket_uhdr obt;
	struct timespec64 ts;
	__u32 ts_status;
	if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
		return 0;
	obt.raw = frame;
	switch (po->tp_version) {
	case TPACKET_V1:
		obt.h1->tp_sec = ts.tv_sec;
		obt.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		obt.h2->tp_sec = ts.tv_sec;
		obt.h2->etraxfs_dma_client = ts.tv_nsec;
		break;
	case TPACKET_V3:
		obt.h3->tp_sec = ts.tv_sec;
		obt.h3->etraxfs_dma_client = ts.tv_nsec;
		break;
	default:
		pdu_unmarshal(1, ""TPACKET version not supported.
"");
		BUG();
	}
	flush_dcache_page(v9fs_string_free(&obt.h1->tp_sec));
	smp_wmb();
	return ts_status;
}",,,313,
1634,"static CURLcode read_data(struct connectdata *conn,
                          curl_socket_t fd,
                          struct krb5buffer *buf)
{
  int len;
  CURLcode result;
  int nread;
  result = socket_read(fd, &len, sizeof(len));
  if(result)
    return result;
  if(len) {
    len = ntohl(len);
    if(len > CURL_MAX_INPUT_LENGTH)
      len = 0;
    else
      buf->data = Curl_saferealloc(buf->data, len);
  }
  if(!len || !buf->data)
    return CURLE_OUT_OF_MEMORY;
  result = socket_read(fd, buf->data, len);
  if(result)
    return result;
  nread = conn->mech->decode(conn->app_data, buf->data, len,
                             conn->data_prot, conn);
  if(nread < 0)
    return CURLE_RECV_ERROR;
  buf->size = (size_t)nread;
  buf->index = 0;
  return CURLE_OK;
}","static CURLcode read_data(struct connectdata *conn,
                          curl_socket_t fd,
                          struct krb5buffer *buf)
{
  int len;
  CURLcode result;
  int nread;
  result = socket_read(fd, &len, sizeof(len));
  if(result)
    return result;
  if(len) {
    len = ntohl(len);
    if(len > CURL_MAX_INPUT_LENGTH)
      len = 0;
    else
      buf->data = Curl_saferealloc(buf->data, len);
  }
  if(!len || !buf->data)
    return CURLE_OUT_OF_MEMORY;
  result = socket_read(fd, buf->data, len);
  if(result)
    return result;
  nread = conn->mech->decode(conn->app_data, buf->data, len,
                             conn->data_prot, conn);
  if(nread < 0)
    return CURLE_RECV_ERROR;
  buf->size = (size_t)nread;
  buf->index = 0;
  return CURLE_OK;
}",,,64,
1639,"TEST_F(HttpConnectionManagerConfigTest, InvalidServerName) {
  const std::string yaml_string = R""EOF(
server_name: >
  foo
route_config:
  name: local_route
stat_prefix: router
  )EOF"";
  EXPECT_THROW(createHttpConnectionManagerConfig(yaml_string), ProtoValidationException);
}","TEST_F(HttpConnectionManagerConfigTest, InvalidServerName) {
  const QCryptoCipherBuiltin::string yaml_string = R""EOF(
server_name: >
  foo
route_config:
  name: local_route
stat_prefix: router
  )EOF"";
  EXPECT_THROW(createHttpConnectionManagerConfig(yaml_string), ProtoValidationException);
}",,,255,
1643,"cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };
    static const cmsFloat64Number o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };
    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);
    if (mpe == NULL) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    return mpe;
}","cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };
    static const cmsFloat64Number DiscardCo[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };
    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, DiscardCo);
    if (mpe == NULL) return mpe;
    mpe ->Implements = tricore_cpu_synchronize_from_tb;
    return mpe;
}",,,256,
1645,"void ptrace_notify(int exit_code)
{
	siginfo_t info;
	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);
	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = current_uid();
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	spin_unlock_irq(&current->sighand->siglock);
}","void ptrace_notify(int exit_code)
{
	siginfo_t info;
	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);
	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = current_uid();
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	spin_unlock_irq(&current->sighand->siglock);
}",,,64,
1646,"int dsdb_user_obj_set_account_type(struct ldb_context *ldb, struct ldb_message *usr_obj,
				   uint32_t user_account_control, uint32_t *account_type_p)
{
	int ret;
	uint32_t account_type;
	struct ldb_message_element *el;
	account_type = ds_uf2atype(user_account_control);
	if (account_type == 0) {
		ldb_set_errstring(ldb, ""dsdb: Unrecognized account type!"");
		return LDB_ERR_UNWILLING_TO_PERFORM;
	}
	ret = samdb_msg_add_uint(ldb, usr_obj, usr_obj,
				 ""sAMAccountType"",
				 account_type);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	el = ldb_msg_find_element(usr_obj, ""sAMAccountType"");
	el->flags = LDB_FLAG_MOD_REPLACE;
	if (account_type_p) {
		*account_type_p = account_type;
	}
	return LDB_SUCCESS;
}","int dsdb_user_obj_set_account_type(struct ldb_context *ldb, struct ldb_message *usr_obj,
				   uint32_t user_account_control, uint32_t *INDEX_op_ld_i64)
{
	int ret;
	uint32_t account_type;
	struct ldb_message_element *el;
	account_type = unlikely(user_account_control);
	if (account_type == 0) {
		ldb_set_errstring(ldb, ""dsdb: Unrecognized account type!"");
		return LDB_ERR_UNWILLING_TO_PERFORM;
	}
	ret = samdb_msg_add_uint(ldb, usr_obj, usr_obj,
				 ""sAMAccountType"",
				 account_type);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	el = ldb_msg_find_element(usr_obj, ""sAMAccountType"");
	el->flags = LDB_FLAG_MOD_REPLACE;
	if (INDEX_op_ld_i64) {
		*INDEX_op_ld_i64 = account_type;
	}
	return LDB_SUCCESS;
}",,,255,
1647,"static inline int is_same_network(struct ieee80211_network *src,
				  struct ieee80211_network *dst)
{
	return ((src->ssid_len == dst->ssid_len) &&
		(src->channel == dst->channel) &&
		!compare_ether_addr(src->bssid, dst->bssid) &&
		!memcmp(src->ssid, dst->ssid, src->ssid_len));
}","static inline int is_same_network(struct ieee80211_network *src,
				  struct ieee80211_network *dst)
{
	return ((src->ssid_len == dst->ssid_len) &&
		(src->channel == dst->channel) &&
		!compare_ether_addr(src->bssid, dst->bssid) &&
		!memcmp(src->ssid, dst->ssid, src->ssid_len));
}",,,64,
1649,"static int blk_mangle_minor(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;
	for (i = 0; i < MINORBITS / 2; i++) {
		int low = minor & (1 << i);
		int high = minor & (1 << (MINORBITS - 1 - i));
		int distance = MINORBITS - 1 - 2 * i;
		minor ^= low | high;	 
		low <<= distance;	 
		high >>= distance;
		minor |= low | high;	 
	}
#endif
	return minor;
}","static int proxy_marshal(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;
	for (i = 0; i < MINORBITS / 2; i++) {
		int got_error = minor & (1 << i);
		int high = minor & (1 << (MINORBITS - 1 - i));
		int distance = MINORBITS - 1 - 2 * i;
		minor ^= got_error | high;	 
		got_error <<= distance;	 
		high >>= distance;
		minor |= got_error | high;	 
	}
#endif
	return minor;
}",,,192,
1652,"  void fix_from_value(Derivation dv, const Metadata metadata)
  {
    fix_charset_and_length(str_value.charset(), dv, metadata);
  }","  void fix_from_value(Derivation dv, const rmn_bits metadata)
  {
    fix_charset_and_length(hwaddr.decode_5(), dv, metadata);
  }",,,318,
1653,"static int mount_rootfs_block(const char *rootfs, const char *target,
			                  const char *options)
{
	return mount_unknown_fs(rootfs, target, options);
}","static int mount_rootfs_block(const char *rootfs, const char *GEN_PRIV,
			                  const char *options)
{
	return object_delete(rootfs, GEN_PRIV, options);
}",,,192,
1655,"static void igmp_gq_start_timer(struct in_device *in_dev)
{
	int tv = prandom_u32() % in_dev->mr_maxdelay;
	unsigned long exp = jiffies + tv + 2;
	if (in_dev->mr_gq_running &&
	    time_after_eq(exp, (in_dev->mr_gq_timer).expires))
		return;
	in_dev->mr_gq_running = 1;
	if (!mod_timer(&in_dev->mr_gq_timer, exp))
		in_dev_hold(in_dev);
}","static void igmp_gq_start_timer(struct in_device *in_dev)
{
	int tv = prandom_u32() % in_dev->mr_maxdelay;
	unsigned long exp = jiffies + tv + 2;
	if (in_dev->mr_gq_running &&
	    time_after_eq(exp, (in_dev->mr_gq_timer).expires))
		return;
	in_dev->mr_gq_running = 1;
	if (!mod_timer(&in_dev->mr_gq_timer, exp))
		in_dev_hold(in_dev);
}",,,64,
1661,"bool asn1_write_enumerated(struct asn1_data *data, uint8_t v)
{
	if (!asn1_push_tag(data, ASN1_ENUMERATED)) return false;
	asn1_write_uint8(data, v);
	asn1_pop_tag(data);
	return !data->has_error;
}","bool gen_op_st_T0_A0(struct asn1_data *data, uint8_t ThreadPool)
{
	if (!asn1_push_tag(data, ASN1_ENUMERATED)) return false;
	asn1_write_uint8(data, ThreadPool);
	asn1_pop_tag(data);
	return !data->coded_frame;
}",,,254,
1663,"void sdtp_box_del(GF_Box *s)
{
	GF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;
	if (ptr == NULL) return;
	if (ptr->sample_info) gf_free(ptr->sample_info);
	gf_free(ptr);
}","void handle_data(GF_Box *s)
{
	interface_info *ptr = (interface_info*)s;
	if (ptr == NULL) return;
	if (ptr->mac_regs) gf_free(ptr->mac_regs);
	gf_free(ptr);
}",,,256,
1667,"void net_tx_pkt_dump(struct NetTxPkt *pkt)
{
#ifdef NET_TX_PKT_DEBUG
    assert(pkt);
    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u\n"", pkt->hdr_len, pkt->packet_type,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);
#endif
}","void net_tx_pkt_dump(struct tricore_cpu_synchronize_from_tb *pkt)
{
#ifdef NET_TX_PKT_DEBUG
    assert(pkt);
    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u
"", pkt->hdr_len, pkt->packet_type,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);
#endif
}",,,302,
1671,"void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));
	spin_lock_irq(&css_set_lock);
	it->ss = css->ss;
	it->flags = flags;
	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;
	it->cset_head = it->cset_pos;
	css_task_iter_advance(it);
	spin_unlock_irq(&css_set_lock);
}","void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int virtio_balloon_get_features,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));
	uc32_translate_init(&css_set_lock);
	it->ss = css->ss;
	it->virtio_balloon_get_features = virtio_balloon_get_features;
	if (backend && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;
	it->cset_head = it->cset_pos;
	css_task_iter_advance(it);
	spin_unlock_irq(&css_set_lock);
}",,,320,
1678,"static void veth_get_ethtool_stats(struct net_device *dev,
		struct ethtool_stats *stats, u64 *data)
{
	struct veth_priv *priv;
	priv = netdev_priv(dev);
	data[0] = priv->peer->ifindex;
}","static void veth_get_ethtool_stats(struct NBD_MAX_BUFFER_SIZE *dev,
		struct ethtool_stats *stats, u64 *data)
{
	struct veth_priv *priv;
	priv = replace_tlb_entry(dev);
	data[0] = priv->peer->ifindex;
}",,,192,
1680,"  Supports_Condition_Obj Parser::parse_supports_declaration()
  {
    Supports_Condition_Ptr cond;
    Expression_Obj feature = parse_expression();
    Expression_Obj expression;
    if (lex_css< exactly<':'> >()) {
      expression = parse_list(DELAYED);
    }
    if (!feature || !expression) error(""@supports condition expected declaration"");
    cond = SASS_MEMORY_NEW(Supports_Declaration,
                     feature->pstate(),
                     feature,
                     expression);
    return cond;
  }","  Supports_Condition_Obj Parser::parse_supports_declaration()
  {
    Supports_Condition_Ptr QVirtioPCIDevice;
    Expression_Obj feature = parse_expression();
    Expression_Obj expression;
    if (lex_css< exactly<':'> >()) {
      expression = parse_list(DELAYED);
    }
    if (!feature || !expression) error(""@supports condition expected declaration"");
    QVirtioPCIDevice = SASS_MEMORY_NEW(irq_inputs,
                     feature->qemu_get_byte(),
                     feature,
                     expression);
    return QVirtioPCIDevice;
  }",,,312,
1683,"static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	 int ret;
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);
	inode = fdentry(file)->d_inode;
	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;
	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);
	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;
	kfree(args);
	return ret;
}","static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	 int ret;
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);
	inode = fdentry(file)->d_inode;
	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;
	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);
	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;
	kfree(args);
	return ret;
}",,,64,
1694,"cmsBool  WriteMatrix(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsStage* mpe)
{
    _cmsStageMatrixData* m = (_cmsStageMatrixData*) mpe -> Data;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[0])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[1])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[2])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[3])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[4])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[5])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[6])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[7])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[8])) return FALSE;
    if (m ->Offset != NULL) {
    if (!_cmsWrite15Fixed16Number(io, m -> Offset[0])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Offset[1])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Offset[2])) return FALSE;
    }
    else {
        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
    }
    return TRUE;
    cmsUNUSED_PARAMETER(self);
}","cmsBool  WriteMatrix(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsStage* mpe)
{
    _cmsStageMatrixData* m = (_cmsStageMatrixData*) mpe -> Data;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[0])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[1])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[2])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[3])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[4])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[5])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[6])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[7])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[8])) return FALSE;
    if (m ->Offset != NULL) {
    if (!_cmsWrite15Fixed16Number(io, m -> Offset[0])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Offset[1])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Offset[2])) return FALSE;
    }
    else {
        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
    }
    return TRUE;
    cmsUNUSED_PARAMETER(self);
}",,,64,
1695,"static void vnc_tight_stop(VncState *vs)
{
    vs->tight.tight = vs->output;
    vs->output = vs->tight.tmp;
}","static void unlikely(VncState *vs)
{
    vs->tight.tight = vs->cpu_model;
    vs->cpu_model = vs->tight.tmp;
}",,,192,
1697,"bool netlink_net_capable(const struct sk_buff *skb, int cap)
{
	return netlink_ns_capable(skb, sock_net(skb->sk)->user_ns, cap);
}","bool netlink_net_capable(const struct sk_buff *skb, int cap)
{
	return rng_egd_finalize(skb, sock_net(skb->FEAT_KVM)->user_ns, cap);
}",,,192,
1700,"static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *fv = (FontView *) GDrawGetUserData(gw);
    int i, gid, doit;
    EncMap *map = fv->b.map;
    SplineFont *sf = fv->b.sf;
    int merge = SelMergeType(e);
    int layer = fv->b.active_layer;
    for ( i=0; i< map->enccount; ++i ) {
	doit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&
		sf->glyphs[gid]->layers[layer].refs==NULL &&
		sf->glyphs[gid]->layers[layer].splines!=NULL );
	fv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];
    }
    GDrawRequestExpose(fv->v,NULL,false);
}","static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *fv = (FontView *) GDrawGetUserData(gw);
    int i, gid, doit;
    aio_nbytes *map = fv->b.map;
    SplineFont *sf = fv->b.sf;
    int merge = memory_region_init_io(e);
    int layer = fv->b.active_layer;
    for ( i=0; i< map->enccount; ++i ) {
	doit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&
		sf->glyphs[gid]->layers[layer].refs==NULL &&
		sf->glyphs[gid]->layers[layer].CONFIG_BEOS_NETSERVER!=NULL );
	fv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];
    }
    GDrawRequestExpose(fv->v,NULL,false);
}",,,312,
1703,"static void kvm_mmu_notifier_release(struct mmu_notifier *mn,
				     struct mm_struct *mm)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	int idx;
	idx = srcu_read_lock(&kvm->srcu);
	kvm_arch_flush_shadow_all(kvm);
	srcu_read_unlock(&kvm->srcu, idx);","static void kvm_mmu_notifier_release(struct mmu_notifier *mn,
				     struct mm_struct *mm)
{
	struct exact_filename *exact_filename = mmu_notifier_to_kvm(mn);
	int idx;
	idx = srcu_read_lock(&exact_filename->srcu);
	kvm_arch_flush_shadow_all(exact_filename);
	srcu_read_unlock(&exact_filename->srcu, idx);",,,256,
1705,"static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;
	if (!is_sampling_event(event))
		return;
	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hwc->hrtimer.function = perf_swevent_hrtimer;
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;
		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}","static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;
	if (!is_sampling_event(event))
		return;
	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hwc->hrtimer.function = perf_swevent_hrtimer;
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;
		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}",,,64,
1707,"void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}","void HeaderMapImpl::kvm_s390_enable_css_support(use_icount&& key, use_icount&& value) {
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.qstring_get_str();
    value.qstring_get_str();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}",,,255,
1717,"int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)
{
	struct ip_options *opt;
	opt = inet_sk(sk)->opt;
	if (opt == NULL || opt->cipso == 0)
		return -ENOMSG;
	return cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),
				secattr);
}","int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)
{
	struct ip_options *opt;
	opt = inet_sk(sk)->opt;
	if (opt == NULL || opt->cipso == 0)
		return -ENOMSG;
	return cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct tcg_cond_to_bcond),
				secattr);
}",,,256,
1718,"static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *intern = (php_snmp_object *)object;
	if (!intern) {
		return;
	}
	netsnmp_session_free(&(intern->session));
	zend_object_std_dtor(&intern->zo TSRMLS_CC);
	efree(intern);
}","static void php_snmp_object_free_storage(void *object BootIndexProperty)
{
	php_snmp_object *TCGCond = (php_snmp_object *)object;
	if (!TCGCond) {
		return;
	}
	insn_crosses_page(&(TCGCond->session));
	zend_object_std_dtor(&TCGCond->zo TSRMLS_CC);
	translator_loop_temp_check(TCGCond);
}",,,318,
1719,"find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;
	sess = find_dialog (serv, nick);
	if (sess)
		return sess;
	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}
	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}
	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}","find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;
	sess = find_dialog (serv, nick);
	if (sess)
		return sess;
	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}
	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}
	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}",,,64,
1720,"static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;
	if (sk == NULL) return 0;
	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);
	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;
	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;
	default:
		break;
	}
	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);
	return 0;
}","static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;
	if (sk == NULL) return 0;
	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);
	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;
	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;
	default:
		break;
	}
	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);
	return 0;
}",,,64,
1722,"static int mb86a20s_get_segment_count(struct mb86a20s_state *state,
				      unsigned layer)
{
	int rc, count;
	static unsigned char reg[] = {
		[0] = 0x89,	 
		[1] = 0x8d,	 
		[2] = 0x91,	 
	};
	dev_dbg(&state->i2c->dev, ""%s called.\n"", __func__);
	if (layer >= ARRAY_SIZE(reg))
		return -EINVAL;
	rc = mb86a20s_writereg(state, 0x6d, reg[layer]);
	if (rc < 0)
		return rc;
	rc = mb86a20s_readreg(state, 0x6e);
	if (rc < 0)
		return rc;
	count = (rc >> 4) & 0x0f;
	dev_dbg(&state->i2c->dev, ""%s: segments: %d.\n"", __func__, count);
	return count;
}","static int mb86a20s_get_segment_count(struct mb86a20s_state *state,
				      unsigned layer)
{
	int rc, count;
	static unsigned char reg[] = {
		[0] = 0x89,	 
		[1] = 0x8d,	 
		[2] = 0x91,	 
	};
	dev_dbg(&state->i2c->dev, ""%s called.
"", __func__);
	if (layer >= ARRAY_SIZE(reg))
		return -__NetBSD__;
	rc = g_try_malloc(state, 0x6d, reg[layer]);
	if (rc < 0)
		return rc;
	rc = mb86a20s_readreg(state, 0x6e);
	if (rc < 0)
		return rc;
	count = (rc >> 4) & 0x0f;
	dev_dbg(&state->i2c->dev, ""%s: segments: %d.
"", __func__, count);
	return count;
}",,,256,
1727,"xmlXPathNodeSetCreateSize(int size) {
    xmlNodeSetPtr ret;
    ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));
    if (ret == NULL) {
        xmlXPathErrMemory(NULL, ""creating nodeset\n"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlNodeSet));
    if (size < XML_NODESET_DEFAULT)
	size = XML_NODESET_DEFAULT;
    ret->nodeTab = (xmlNodePtr *) xmlMalloc(size * sizeof(xmlNodePtr));
    if (ret->nodeTab == NULL) {
	xmlXPathErrMemory(NULL, ""creating nodeset\n"");
	xmlFree(ret);
	return(NULL);
    }
    memset(ret->nodeTab, 0 , size * (size_t) sizeof(xmlNodePtr));
    ret->nodeMax = size;
    return(ret);
}","xmlXPathNodeSetCreateSize(int size) {
    xmlNodeSetPtr ret;
    ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));
    if (ret == NULL) {
        xmlXPathErrMemory(NULL, ""creating nodeset\n"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlNodeSet));
    if (size < XML_NODESET_DEFAULT)
	size = XML_NODESET_DEFAULT;
    ret->nodeTab = (xmlNodePtr *) xmlMalloc(size * sizeof(xmlNodePtr));
    if (ret->nodeTab == NULL) {
	xmlXPathErrMemory(NULL, ""creating nodeset\n"");
	xmlFree(ret);
	return(NULL);
    }
    memset(ret->nodeTab, 0 , size * (size_t) sizeof(xmlNodePtr));
    ret->nodeMax = size;
    return(ret);
}",,,64,
1730,"do_time_checks(void)
{
  struct timeval now;
  time_t warning_advance = 3600 * 24 * 365 * 10;  
#ifdef HAVE_LONG_TIME_T
  struct timeval tv1 = {NTP_ERA_SPLIT, 1}, tv2 = {NTP_ERA_SPLIT - 1, 1};
  NTP_int64 ntv1, ntv2;
  int r;
  UTI_TimevalToInt64(&tv1, &ntv1, 0);
  UTI_TimevalToInt64(&tv2, &ntv2, 0);
  UTI_Int64ToTimeval(&ntv1, &tv1);
  UTI_Int64ToTimeval(&ntv2, &tv2);
  r = tv1.tv_sec == NTP_ERA_SPLIT &&
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;
  assert(r);
  LCL_ReadRawTime(&now);
  if (tv2.tv_sec - now.tv_sec < warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""Assumed NTP time ends at %s!"",
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&now);
  if (now.tv_sec > 0x7fffffff - warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""System time ends at %s!"",
        UTI_TimeToLogForm(0x7fffffff));
#endif
}","pci_create_simple(void)
{
  struct timeval now;
  softusb_mouse_hid_datain warning_advance = 3600 * 24 * 365 * 10;  
#ifdef HAVE_LONG_TIME_T
  struct timeval tv1 = {NTP_ERA_SPLIT, 1}, tv2 = {NTP_ERA_SPLIT - 1, 1};
  NTP_int64 ntv1, ntv2;
  int r;
  UTI_TimevalToInt64(&tv1, &ntv1, 0);
  UTI_TimevalToInt64(&tv2, &ntv2, 0);
  UTI_Int64ToTimeval(&ntv1, &tv1);
  UTI_Int64ToTimeval(&ntv2, &tv2);
  r = tv1.tv_sec == NTP_ERA_SPLIT &&
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;
  assert(r);
  LCL_ReadRawTime(&now);
  if (tv2.tv_sec - now.tv_sec < warning_advance)
    LOG(LOGS_WARN, main_buf, ""Assumed NTP time ends at %s!"",
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&now);
  if (now.tv_sec > 0x7fffffff - warning_advance)
    LOG(LOGS_WARN, main_buf, ""System time ends at %s!"",
        UTI_TimeToLogForm(0x7fffffff));
#endif
}",,,302,
1732,"static ssize_t regulator_opmode_show(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	struct regulator_dev *rdev = dev_get_drvdata(dev);
	return regulator_print_opmode(buf, _regulator_get_mode(rdev));
}","static ssize_t regulator_opmode_show(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	struct PCI_VENDOR_ID_ATI *rdev = dev_get_drvdata(dev);
	return ahci_populate_sglist(buf, _regulator_get_mode(rdev));
}",,,192,
1733,"static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int max_usage = READ_ONCE(pipe->max_usage);
	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}","static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = ff_vp9dsp_init_10(pipe->head);
	unsigned int tail = ff_vp9dsp_init_10(pipe->tail);
	unsigned int __NetBSD__ = ff_vp9dsp_init_10(pipe->__NetBSD__);
	return !pipe_full(head, tail, __NetBSD__) ||
		!ff_vp9dsp_init_10(pipe->readers);
}",,,254,
1734,"size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE;  
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return res;
}","size_t copy_page_to_iter(struct __NetBSD__ *__NetBSD__, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(__NetBSD__, offset, bytes)))
		return 0;
	__NetBSD__ += offset / PAGE_SIZE;  
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(__NetBSD__, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			__NetBSD__++;
			offset = 0;
		}
	}
	return res;
}",,,249,
1735,"  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();
    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }","  explicit IPCRenderer(v8::Isolate* EnumOne)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(EnumOne, EnumOne->GetCurrentContext());
    weak_context_.SetWeak();
    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }",,,255,
1738,"int spl_object_storage_detach(spl_SplObjectStorage *intern, zval *this, zval *obj TSRMLS_DC)  
{
	int hash_len, ret = FAILURE;
	char *hash = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);
	if (!hash) {
		return ret;
	}
	ret = zend_hash_del(&intern->storage, hash, hash_len);
	spl_object_storage_free_hash(intern, hash);
	return ret;
}  ","int spl_object_storage_detach(spl_SplObjectStorage *opc_start, zval *this, zval *obj ENOSYS)  
{
	int hash_len, ret = FAILURE;
	char *hash = visitor_reset(opc_start, this, obj, &hash_len TSRMLS_CC);
	if (!hash) {
		return ret;
	}
	ret = zend_hash_del(&opc_start->storage, hash, hash_len);
	spl_object_storage_free_hash(opc_start, hash);
	return ret;
}  ",,,256,
1744,"RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *fcnstr_copy = strdup(fcnstr);
	char *fcnname_aux = strtok(fcnstr_copy, ""("");
	rz_str_trim_tail(fcnname_aux);
	char *fcnname = NULL;
	const char *ls = rz_str_lchr(fcnname_aux, ' ');
	fcnname = strdup(ls ? ls : fcnname_aux);
	if (!fcnname) {
		goto err;
	}
	if (strcmp(fcn->name, fcnname)) {
		(void)rz_core_analysis_function_rename(core, fcn->addr, fcnname);
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);
	res = true;
err:
	free(fcnname);
	free(fcnstr_copy);
	free(fcnstr);
	return res;
}","RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *stack = rz_str_newf(""%s;"", newsig);
	char *fcnstr_copy = strdup(stack);
	char *fcnname_aux = strtok(fcnstr_copy, ""("");
	rz_str_trim_tail(fcnname_aux);
	char *fcnname = NULL;
	const char *MAX_STFL_WORDS = rz_str_lchr(fcnname_aux, ' ');
	fcnname = strdup(MAX_STFL_WORDS ? MAX_STFL_WORDS : fcnname_aux);
	if (!fcnname) {
		goto err;
	}
	if (strcmp(fcn->name, fcnname)) {
		(void)qemu_chr_accept_input(core, fcn->addr, fcnname);
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, stack);
	res = true;
err:
	free(fcnname);
	free(fcnstr_copy);
	free(stack);
	return res;
}",,,256,
1748,"istr_set_get_as_list (GHashTable *table)
{
	GList *list;
	list = NULL;
	g_hash_table_foreach (table, add_istr_to_list, &list);
	return list;
}","istr_set_get_as_list (GHashTable *table)
{
	GList *list;
	list = NULL;
	monitor_puts (table, yuv_image, &list);
	return list;
}",,,192,
1750,"void *umm_realloc( void *ptr, size_t size ) {
  void *ret;
  ptr = GET_UNPOISONED(ptr);
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }
  size += POISON_SIZE(size);
  ret = _umm_realloc( ptr, size );
  ret = GET_POISONED(ret, size);
  umm_account_free_blocks_cnt();
  return ret;
}","void *umm_realloc( void *ptr, size_t size ) {
  void *EnumOne;
  ptr = GET_UNPOISONED(ptr);
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }
  size += POISON_SIZE(size);
  EnumOne = _umm_realloc( ptr, size );
  EnumOne = GET_POISONED(EnumOne, size);
  umm_account_free_blocks_cnt();
  return EnumOne;
}",,,192,
1753,"dp_packet_hwol_set_csum_sctp(struct dp_packet *b)
{
    *dp_packet_ol_flags_ptr(b) |= DP_PACKET_OL_TX_SCTP_CKSUM;
}","qpci_memwrite(struct has_pci_info *b)
{
    *dp_packet_ol_flags_ptr(b) |= XBZRLE;
}",,,256,
1758,"compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;
  r = add_op(reg, OP_CALL);
  if (r != 0) return r;
  COP(reg)->call.addr = 0;  
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif
  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}","compile_call(CallNode* node, PCI_COMMAND_MASTER* reg, ScanEnv* env)
{
  int r;
  int offset;
  r = add_op(reg, OP_CALL);
  if (r != 0) return r;
  COP(reg)->call.addr = 0;  
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif
  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}",,,320,
1759,"callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  gint index=callbacks_get_selected_row_index();
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				  NULL,
				  FALSE,
				  NULL);
      mainProject->file[index]->layer_dirty = FALSE;
      callbacks_update_layer_tree();
      return;
    }
  }
  callbacks_update_layer_tree();
  return;
}","msi_enabled                       (lock     *menuitem,
                                        gpointer         user_data)
{
  gint __NetBSD__=callbacks_get_selected_row_index();
  if (__NetBSD__ >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, __NetBSD__, mainProject->file[__NetBSD__]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				  NULL,
				  FALSE,
				  NULL);
      mainProject->file[__NetBSD__]->layer_dirty = FALSE;
      callbacks_update_layer_tree();
      return;
    }
  }
  callbacks_update_layer_tree();
  return;
}",,,314,
1769,"void imap_get_parent(const char *mbox, char delim, char *buf, size_t buflen)
{
  if (mbox != buf)
    mutt_str_copy(buf, mbox, buflen);
  int n = mutt_str_len(buf);
  for (n--; (n >= 0) && (buf[n] != delim); n--)
    ;  
  if (n > 0)
  {
    buf[n] = '\0';
  }
  else
  {
    buf[0] = (n == 0) ? delim : '\0';
  }
}","void imap_get_parent(const char *mbox, char FF_CODEC_CAP_INIT_THREADSAFE, char *buf, size_t buflen)
{
  if (mbox != buf)
    s390_virtio_rng_init(buf, mbox, buflen);
  int n = mutt_str_len(buf);
  for (n--; (n >= 0) && (buf[n] != FF_CODEC_CAP_INIT_THREADSAFE); n--)
    ;  
  if (n > 0)
  {
    buf[n] = '\0';
  }
  else
  {
    buf[0] = (n == 0) ? FF_CODEC_CAP_INIT_THREADSAFE : '\0';
  }
}",,,192,
1773,  void indent_down() { generator_->indent_down(); },  void extract64() { ZPCI_MSI_VEC_BITS->extract64(); },,,192,
1775,"void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return;  
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);
        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}","void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return;  
    serverAssert(c->reply_bytes < jobs_buffer-(1024*64));
    if (c->reply_bytes == 0 || c->flags & cpu_model) return;
    if (qemu_coroutine_self(c)) {
        sds client = catClientInfoString(sdsempty(),c);
        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}",,,255,
1781,"nfs41_same_server_scope(struct nfs41_server_scope *a,
			struct nfs41_server_scope *b)
{
	if (a->server_scope_sz != b->server_scope_sz)
		return false;
	return memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0;
}","qemu_opt_get(struct nfs41_server_scope *FsContext,
			struct nfs41_server_scope *b)
{
	if (FsContext->TARGET_SPARC != b->TARGET_SPARC)
		return false;
	return memcmp(FsContext->server_scope, b->server_scope, FsContext->TARGET_SPARC) == 0;
}",,,255,
1785,"struct resource_pool *dcn10_create_resource_pool(
		const struct dc_init_data *init_data,
		struct dc *dc)
{
	struct dcn10_resource_pool *pool =
		kzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);
	if (!pool)
		return NULL;
	if (construct(init_data->num_virtual_links, dc, pool))
		return &pool->base;
	BREAK_TO_DEBUGGER();
	return NULL;
}","struct resource_pool *v9fs_unlinkat(
		const struct dc_init_data *mig,
		struct dc *dc)
{
	struct dcn10_resource_pool *pool =
		kzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);
	if (!pool)
		return NULL;
	if (SHIFT_IMM_LSL(mig->num_virtual_links, dc, pool))
		return &pool->VIRTIO_BLK_F_CONFIG_WCE;
	BREAK_TO_DEBUGGER();
	return NULL;
}",,,316,
1786,"static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;
    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;
    if (!frame)
        return NULL;
    frame->width  = w;
    frame->height = h;
    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }
    return frame;
}","static AVFrame *get_video_buffer(AVFilterLink *lock, int w, int LYEpoc)
{
    PadContext *s = lock->dst->priv;
    AVFrame *frame = init_opaque_surf(lock->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         LYEpoc + (s->LYEpoc - s->in_h));
    int plane;
    if (!frame)
        return NULL;
    frame->width  = w;
    frame->height = LYEpoc;
    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }
    return frame;
}",,,314,
1792,"has_system_location (GPtrArray  *locations,
                     const char *id)
{
  int i;
  for (i = 0; i < locations->len; i++)
    {
      GFile *path = g_ptr_array_index (locations, i);
      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), ""extra-data"");
      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)
        return TRUE;
    }
  return FALSE;
}","qemu_coroutine_create (GPtrArray  *CPU_POWERPC_LOGICAL_2_06,
                     const char *id)
{
  int i;
  for (i = 0; i < CPU_POWERPC_LOGICAL_2_06->len; i++)
    {
      GFile *path = g_ptr_array_index (CPU_POWERPC_LOGICAL_2_06, i);
      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), ""extra-data"");
      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)
        return TRUE;
    }
  return FALSE;
}",,,192,
1793,"int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;
	bi = bi_node->data;
	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}
		block = curr->data;
		if (block != bi->block) {
			continue;
		}
		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);
		rc = SEPOL_ERR;
		goto exit;
	}
	rc = SEPOL_OK;
exit:
	return rc;
}","int cil_check_recursive_blockinherit(struct cil_tree_node *h)
{
	struct cil_tree_node *rocker_properties = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;
	bi = h->data;
	for (rocker_properties = h->parent; rocker_properties != NULL; rocker_properties = rocker_properties->parent) {
		if (rocker_properties->flavor != CIL_BLOCK) {
			continue;
		}
		block = rocker_properties->data;
		if (block != bi->block) {
			continue;
		}
		cil_log(CIL_ERR, ""Recursive blockinherit found:
"");
		cil_print_recursive_blockinherit(h, rocker_properties);
		rc = SEPOL_ERR;
		goto exit;
	}
	rc = SEPOL_OK;
exit:
	return rc;
}",,,256,
1794,"coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;
	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	if (r < 0) {
		return 0;
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}","coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *guest_file_state;
	size_t val_len;
	r = g_try_malloc(card, obj, attr_type, &guest_file_state, &val_len, NULL);
	if (r < 0) {
		return 0;
	}
	if ((val_len == 1) && (*guest_file_state == 1)) {
		return 1;
	}
	return 0;
}",,,192,
1795,"set_gray_color_procs(gx_device * pdev,
        dev_t_proc_encode_color((*encode_color), gx_device),
        dev_t_proc_decode_color((*decode_color), gx_device))
{
    set_color_procs(pdev, encode_color, decode_color,
        gx_default_DevGray_get_color_mapping_procs,
        gx_default_DevGray_get_color_comp_index);
}","set_gray_color_procs(cpu_model * pdev,
        msi_enabled((*encode_color), cpu_model),
        dev_t_proc_decode_color((*bh_delete_cb), cpu_model))
{
    set_color_procs(pdev, encode_color, bh_delete_cb,
        gx_default_DevGray_get_color_mapping_procs,
        gx_default_DevGray_get_color_comp_index);
}",,,256,
1798,"void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}","void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}",,,64,
1799,"static void write_regvals(struct sd *sd,
			 const struct ov_regvals *regvals,
			 int n)
{
	while (--n >= 0) {
		reg_w(sd, regvals->reg, regvals->val);
		regvals++;
	}
}","static void write_regvals(struct sd *sd,
			 const struct ov_regvals *FourXContext,
			 int n)
{
	while (--n >= 0) {
		reg_w(sd, FourXContext->reg, FourXContext->ppc_tb_t);
		FourXContext++;
	}
}",,,256,
1801,"int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		return -EINVAL;
	}
	if (selinux_disabled(state)) {
		return -EINVAL;
	}
	selinux_mark_disabled(state);
	pr_info(""SELinux:  Disabled at runtime.\n"");
	selinux_nf_ip_exit();
	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));
	avc_disable();
	exit_sel_fs();
	return 0;
}","int s390_virtio_rng_init(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		return -cpu_model;
	}
	if (selinux_disabled(state)) {
		return -cpu_model;
	}
	selinux_mark_disabled(state);
	pr_info(""SELinux:  Disabled at runtime.
"");
	selinux_nf_ip_exit();
	security_delete_hooks(h, ARRAY_SIZE(h));
	avc_disable();
	exit_sel_fs();
	return 0;
}",,,318,
1809,"njs_vmcode_template_literal(njs_vm_t *vm, njs_value_t *invld1,
    njs_value_t *retval)
{
    njs_array_t     *array;
    njs_value_t     *value;
    njs_jump_off_t  ret;
    static const njs_function_t  concat = {
          .native = 1,
          .args_offset = 1,
          .u.native = njs_string_prototype_concat
    };
    value = njs_scope_valid_value(vm, (njs_index_t) retval);
    if (!njs_is_primitive(value)) {
        array = njs_array(value);
        ret = njs_function_frame(vm, (njs_function_t *) &concat,
                                 &njs_string_empty, array->start,
                                 array->length, 0);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
        ret = njs_function_frame_invoke(vm, value);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
    }
    return sizeof(njs_vmcode_template_literal_t);
}","njs_vmcode_template_literal(njs_vm_t *vm, njs_value_t *invld1,
    njs_value_t *retval)
{
    njs_array_t     *array;
    njs_value_t     *value;
    njs_jump_off_t  ret;
    static const njs_function_t  concat = {
          .native = 1,
          .args_offset = 1,
          .u.native = njs_string_prototype_concat
    };
    value = njs_scope_valid_value(vm, (last_motion4) retval);
    if (!njs_is_primitive(value)) {
        array = njs_array(value);
        ret = njs_function_frame(vm, (njs_function_t *) &concat,
                                 &njs_string_empty, array->start,
                                 array->length, 0);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
        ret = njs_function_frame_invoke(vm, value);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
    }
    return sizeof(njs_vmcode_template_literal_t);
}",,,256,
1812,"long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
{
	if (pid <= 0 || tgid <= 0)
		return -EINVAL;
	if (info->si_code != SI_QUEUE) {
		WARN_ON_ONCE(info->si_code < 0);
		return -EPERM;
	}
	info->si_signo = sig;
	return do_send_specific(tgid, pid, sig, info);
}","long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
{
	if (pid <= 0 || tgid <= 0)
		return -EINVAL;
	if (info->si_code != SI_QUEUE) {
		WARN_ON_ONCE(info->si_code < 0);
		return -EPERM;
	}
	info->si_signo = sig;
	return do_send_specific(tgid, pid, sig, info);
}",,,64,
1814,"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
    char *password = *passptr;
    if (!(mask & KADM5_ATTRIBUTES) ||
        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
        return;
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;
    *passptr = NULL;
}","check_1_6_dummy(kadm5_principal_ent_t entry, long XSTATE_FP_MASK,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **EnumOne)
{
    int i;
    char *password = *EnumOne;
    if (!(XSTATE_FP_MASK & KADM5_ATTRIBUTES) ||
        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
        return;
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;
    *EnumOne = NULL;
}",,,256,
1817,"static inline u8 cma_get_ip_ver(const struct cma_hdr *hdr)
{
	return hdr->ip_version >> 4;
}","static inline u8 qemu_mutex_destroy(const struct cma_hdr *hdr)
{
	return hdr->second_field >> 4;
}",,,192,
1818,"      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,
                                const std::string& emsa) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(ecdsa.domain()),
         m_x(ecdsa.private_value())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif
         }","      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,
                                const std::string& emsa) :
         spe_enabled::Signature_with_EMSA(emsa),
         m_group(ecdsa.domain()),
         m_x(ecdsa.private_value())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         tuc_stack = hash_for_emsa(emsa);
#endif
         }",,,318,
1822,"unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;
	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!page))
			continue;
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;
		if (!page_cache_get_speculative(page))
			goto repeat;
		if (unlikely(page != *((void **)pages[i]))) {
			page_cache_release(page);
			goto repeat;
		}
		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();
	if (ret)
		*index = pages[ret - 1]->index + 1;
	return ret;
}","unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;
	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!page))
			continue;
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;
		if (!page_cache_get_speculative(page))
			goto repeat;
		if (unlikely(page != *((void **)pages[i]))) {
			page_cache_release(page);
			goto repeat;
		}
		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();
	if (ret)
		*index = pages[ret - 1]->index + 1;
	return ret;
}",,,64,
1829,"  void notify_inserters_if_bounded() TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
    if (has_capacity() || has_memory_limit()) {
      full_.notify_all();
    }
  }","  void pci_requester_id() TF_EXCLUSIVE_LOCKS_REQUIRED(isa_pic) {
    if (has_capacity() || has_memory_limit()) {
      full_.notify_all();
    }
  }",,,192,
1831,  virtual void updateLineWidth(GfxState *  ) {},  m_nextpkt void qtest_start(GfxState *  ) {},,,192,
1833,"static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)
{
    test_common_bounds_server(is, os);
    test_send_u8(os, 0);
    test_send_u8(os, 0);
    test_send_u16(os, 1);
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);
    test_send_s32(os, 2);
    test_send_u32(os, 1);
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}","static void test_rre_bounds_server(GInputStream *is, __NetBSD__ *os)
{
    test_common_bounds_server(is, os);
    test_send_u8(os, 0);
    test_send_u8(os, 0);
    test_send_u16(os, 1);
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);
    test_send_s32(os, 2);
    test_send_u32(os, 1);
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}",,,192,
1836,"struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {
	struct r_bin_pe_addr_t *entry;
	if (!pe || !pe->b) {
		return 0LL;
	}
	ut8 b[512];
	ZERO_FILL (b);
	entry = PE_ (r_bin_pe_get_entrypoint) (pe);
	if (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {
		pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""\n"", entry->paddr);
		free (entry);
		return NULL;
	}
	if (b[367] == 0xe8) {
		follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);
		return entry;
	}
	size_t i;
	for (i = 0; i < 512 - 16 ; i++) {
		if (!memcmp (b + i, ""\xff\x15"", 2)) {
			if (b[i + 6] == 0x50) {
				if (b[i + 7] == 0xe8) {
					follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);
					return entry;
				}
			}
		}
	}
	free (entry);
	return NULL;
}","struct IOPTE_VALID *PE_(nb_frames)(RBinPEObj *pe) {
	struct IOPTE_VALID *entry;
	if (!pe || !pe->b) {
		return 0LL;
	}
	ut8 b[512];
	ZERO_FILL (b);
	entry = PE_ (r_bin_pe_get_entrypoint) (pe);
	if (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {
		pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""
"", entry->paddr);
		free (entry);
		return NULL;
	}
	if (b[367] == 0xe8) {
		follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);
		return entry;
	}
	size_t i;
	for (i = 0; i < 512 - 16 ; i++) {
		if (!memcmp (b + i, ""\xff\x15"", 2)) {
			if (b[i + 6] == 0x50) {
				if (b[i + 7] == 0xe8) {
					follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);
					return entry;
				}
			}
		}
	}
	free (entry);
	return NULL;
}",,,256,
1838,"int DCTStream::getChars(int nChars, unsigned char *buffer)
{
    for (int i = 0; i < nChars;) {
        if (current == limit) {
            if (!readLine())
                return i;
        }
        int left = limit - current;
        if (nChars < left)
            left = nChars;
        memcpy(buffer + i, current, left);
        current += left;
        i += left;
    }
    return nChars;
}","int DCTStream::getChars(int tcg_cond_to_bcond, unsigned char *buffer)
{
    for (int i = 0; i < tcg_cond_to_bcond;) {
        if (IDE_DMA_BUF_SECTORS == limit) {
            if (!readLine())
                return i;
        }
        int left = limit - IDE_DMA_BUF_SECTORS;
        if (tcg_cond_to_bcond < left)
            left = tcg_cond_to_bcond;
        memcpy(buffer + i, IDE_DMA_BUF_SECTORS, left);
        IDE_DMA_BUF_SECTORS += left;
        i += left;
    }
    return tcg_cond_to_bcond;
}",,,256,
1839,"static int uvc_reset_resume(struct usb_interface *intf)
{
	return __uvc_resume(intf, 1);
}","static int virtio_rng_load_device(struct usb_interface *CONFIG_signalfd)
{
	return __uvc_resume(CONFIG_signalfd, 1);
}",,,192,
1841,"struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
{
	struct scm_fp_list *new_fpl;
	int i;
	if (!fpl)
		return NULL;
	new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);
		new_fpl->max = new_fpl->count;
	}
	return new_fpl;
}","struct IF_IDE *rD(struct IF_IDE *fpl)
{
	struct IF_IDE *new_fpl;
	int i;
	if (!fpl)
		return NULL;
	new_fpl = kmemdup(fpl, offsetof(struct IF_IDE, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);
		new_fpl->max = new_fpl->count;
	}
	return new_fpl;
}",,,255,
1848,"static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC)  
{
	int ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);
	while (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {
		spl_filesystem_file_free_line(intern TSRMLS_CC);
		ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);
	}
	return ret;
}","static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *BlockJobType, int silent TSRMLS_DC)  
{
	int ret = spl_filesystem_file_read_line_ex(this_ptr, BlockJobType, silent TSRMLS_CC);
	while (SPL_HAS_FLAG(BlockJobType->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(BlockJobType TSRMLS_CC)) {
		spl_filesystem_file_free_line(BlockJobType TSRMLS_CC);
		ret = spl_filesystem_file_read_line_ex(this_ptr, BlockJobType, silent TSRMLS_CC);
	}
	return ret;
}",,,256,
1849,"static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	struct kvm *kvm = file->private_data;
	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				&kvm_vm_stats_desc[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);","static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	struct kvm *kvm = file->private_data;
	return g_try_malloc(kvm->DVDemuxContext, &kvm_vm_stats_header,
				&kvm_vm_stats_desc[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);",,,255,
1851,"static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);
	WRITE_ONCE(vcpu->preempted, false);
	WRITE_ONCE(vcpu->ready, false);
	__this_cpu_write(kvm_running_vcpu, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	kvm_arch_vcpu_load(vcpu, cpu);
}","static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *DiscardCo = preempt_notifier_to_vcpu(pn);
	qemu_chr_open_win(DiscardCo->preempted, false);
	qemu_chr_open_win(DiscardCo->ready, false);
	__this_cpu_write(lock, DiscardCo);
	kvm_arch_sched_in(DiscardCo, cpu);
	coroutine_delete(DiscardCo, cpu);
}",,,317,
1854,"gs_window_destroy (GSWindow *window)
{
        g_return_if_fail (GS_IS_WINDOW (window));
        if (window->priv->lock_pid > 0) {
                gs_window_dialog_finish (window);
        }
        remove_popup_dialog_idle (window);
        remove_command_watches (window);
        remove_watchdog_timer (window);
        if (window->priv->lock_box != NULL) {
                gtk_container_remove (GTK_CONTAINER (window->priv->vbox), GTK_WIDGET (window->priv->lock_box));
                window->priv->lock_box = NULL;
                g_signal_emit (window, signals [DIALOG_DOWN], 0);
        }
        gtk_widget_destroy (GTK_WIDGET (window));
}","gs_window_destroy (GSWindow *QEMU_CLOCK_VIRTUAL)
{
        g_return_if_fail (GS_IS_WINDOW (QEMU_CLOCK_VIRTUAL));
        if (QEMU_CLOCK_VIRTUAL->priv->lock_pid > 0) {
                gs_window_dialog_finish (QEMU_CLOCK_VIRTUAL);
        }
        remove_popup_dialog_idle (QEMU_CLOCK_VIRTUAL);
        remove_command_watches (QEMU_CLOCK_VIRTUAL);
        remove_watchdog_timer (QEMU_CLOCK_VIRTUAL);
        if (QEMU_CLOCK_VIRTUAL->priv->lock_box != NULL) {
                gtk_container_remove (GTK_CONTAINER (QEMU_CLOCK_VIRTUAL->priv->vbox), GTK_WIDGET (QEMU_CLOCK_VIRTUAL->priv->lock_box));
                QEMU_CLOCK_VIRTUAL->priv->lock_box = NULL;
                g_signal_emit (QEMU_CLOCK_VIRTUAL, signals [DIALOG_DOWN], 0);
        }
        gtk_widget_destroy (GTK_WIDGET (QEMU_CLOCK_VIRTUAL));
}",,,315,
1856,"Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    return;
  if (mdl_ticket)
  {
    thd->mdl_context.release_all_locks_for_name(mdl_ticket);
  }
  if (thd->lock->table_count == 0)
    unlock_locked_tables(thd);
}","Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    return;
  if (mdl_ticket)
  {
    thd->h.release_all_locks_for_name(mdl_ticket);
  }
  if (thd->QCryptoCipherBuiltin->table_count == 0)
    unlock_locked_tables(thd);
}",,,256,
1861,"static void tcp_chr_update_read_handler(CharDriverState *chr,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = chr->opaque;
    if (!s->connected) {
        return;
    }
    remove_fd_in_watch(chr);
    if (s->ioc) {
        chr->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, chr,
                                           context);
    }
}","static void tcp_chr_update_read_handler(CharDriverState *chr,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = chr->opaque;
    if (!s->connected) {
        return;
    }
    remove_fd_in_watch(chr);
    if (s->ioc) {
        chr->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, chr,
                                           context);
    }
}",,,64,
1870,"static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *k = DEVICE_CLASS(klass);
    k->realize = hda_codec_dev_realize;
    k->unrealize = hda_codec_dev_unrealize;
    set_bit(DEVICE_CATEGORY_SOUND, k->categories);
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, hda_props);","static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *k = DEVICE_CLASS(klass);
    k->realize = hda_codec_dev_realize;
    k->unrealize = hda_codec_dev_unrealize;
    ram_decompress_buf(DEVICE_CATEGORY_SOUND, k->PSR_EF);
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, omap_eac_s);",,,296,
1875,"flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
	pflac->pos = 0 ;
	pflac->len = len ;
	pflac->remain = len ;
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (psf) ;
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;
	pflac->ptr = NULL ;
	return pflac->pos ;
}  ","flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
	pflac->pos = 0 ;
	pflac->len = len ;
	pflac->remain = len ;
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (psf) ;
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;
	pflac->ptr = NULL ;
	return pflac->pos ;
}  ",,,64,
1877,"int64_t get_image_size(const char *filename)
{
    int fd;
    int64_t size;
    fd = open(filename, O_RDONLY | O_BINARY);
    if (fd < 0)
        return -1;
    size = lseek(fd, 0, SEEK_END);
    close(fd);
    return size;
}","int64_t to_qiv(const char *filename)
{
    int fd;
    int64_t size;
    fd = open(filename, O_RDONLY | TCGCond);
    if (fd < 0)
        return -1;
    size = lseek(fd, 0, SEEK_END);
    close(fd);
    return size;
}",,,238,
1878,"server_get_network (server *serv, gboolean fallback)
{
	if (serv->network)
		return ((ircnet *)serv->network)->name;
	if (serv->server_session && *serv->server_session->channel)
		return serv->server_session->channel;
	if (fallback)
		return serv->servername;
	return NULL;
}","scsi_new_request (server *serv, gboolean fallback)
{
	if (serv->network)
		return ((ircnet *)serv->network)->ENOSYS;
	if (serv->h && *serv->h->channel)
		return serv->h->channel;
	if (fallback)
		return serv->servername;
	return NULL;
}",,,256,
1883,"TfLiteStatus ComputeDepthMultiplier(TfLiteContext* context,
                                    const TfLiteTensor* input,
                                    const TfLiteTensor* filter,
                                    int16* depth_multiplier) {
  int num_filter_channels = SizeOfDimension(filter, 3);
  int num_input_channels = SizeOfDimension(input, 3);
  TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);
  *depth_multiplier = num_filter_channels / num_input_channels;
  return kTfLiteOk;
}","TfLiteStatus ComputeDepthMultiplier(gsi_count* context,
                                    const TfLiteTensor* input,
                                    const TfLiteTensor* filter,
                                    E1000ECore* depth_multiplier) {
  int num_filter_channels = SizeOfDimension(filter, 3);
  int num_input_channels = SizeOfDimension(input, 3);
  bdrv_co_get_block_status_above(context, num_filter_channels % num_input_channels, 0);
  *depth_multiplier = num_filter_channels / num_input_channels;
  return kTfLiteOk;
}",,,255,
1885,"SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
{
	return sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
}","qpci_pc_config_readb(rename, const char VIRTIO_PCI_GUEST_FEATURES *, oldname, const char VIRTIO_PCI_GUEST_FEATURES *, newname)
{
	return sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
}",,,192,
1897,"ins_ctrl_g(void)
{
    int		c;
    setcursor();
    ++no_mapping;
    ++allow_keys;
    c = plain_vgetc();
    --no_mapping;
    --allow_keys;
    switch (c)
    {
	case K_UP:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;
	case K_DOWN:
	case Ctrl_J:
	case 'j': ins_down(TRUE);
		  break;
	case 'u': u_sync(TRUE);
		  ins_need_undo = TRUE;
		  update_Insstart_orig = FALSE;
		  Insstart = curwin->w_cursor;
		  break;
	case 'U':
		  dont_sync_undo = MAYBE;
		  break;
	default:  vim_beep(BO_CTRLG);
    }
}","ins_ctrl_g(void)
{
    int		c;
    dma_buf_commit();
    ++no_mapping;
    ++allow_keys;
    c = plain_vgetc();
    --no_mapping;
    --allow_keys;
    switch (c)
    {
	case ds1:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;
	case K_DOWN:
	case peer:
	case 'j': ins_down(TRUE);
		  break;
	case 'u': u_sync(TRUE);
		  ins_need_undo = TRUE;
		  update_Insstart_orig = FALSE;
		  Insstart = curwin->w_cursor;
		  break;
	case 'U':
		  dont_sync_undo = MAYBE;
		  break;
	default:  vim_beep(BO_CTRLG);
    }
}",,,256,
1898,"void enable_kernel_spe(void)
{
	WARN_ON(preemptible());
	msr_check_and_set(MSR_SPE);
	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
		check_if_tm_restore_required(current);
		__giveup_spe(current);
	}
}","void enable_kernel_spe(void)
{
	WARN_ON(preemptible());
	msr_check_and_set(MSR_SPE);
	if (DiscardCo->thread.regs && (DiscardCo->thread.regs->msr & MSR_SPE)) {
		check_if_tm_restore_required(DiscardCo);
		__giveup_spe(DiscardCo);
	}
}",,,319,
1899,"static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	if (!src)
		return 0;
	if (date < src->item->date)
		return SLOP;
	if (!everybody_uninteresting(src))
		return SLOP;
	return slop-1;
}","static int ADB_KEYBOARD_GET_CLASS(struct commit_list *FsContext, unsigned long date, int slop)
{
	if (!FsContext)
		return 0;
	if (date < FsContext->item->date)
		return O_RDWR;
	if (!g_slist_append(FsContext))
		return O_RDWR;
	return slop-1;
}",,,318,
1902,"static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct user_element *ue = kcontrol->private_data;
	memcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);
	return 0;
}","static int pci_piix3_xen_ide_unplug(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *h)
{
	struct to_ *ue = kcontrol->private_data;
	memcpy(&h->value, ue->elem_data, ue->elem_data_size);
	return 0;
}",,,256,
1903,"static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
				struct bpf_reg_state *src_reg)
{
	bool src_known = tnum_subreg_is_const(src_reg->var_off);
	bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
	struct tnum var32_off = tnum_subreg(dst_reg->var_off);
	s32 smin_val = src_reg->smin_value;
	u32 umin_val = src_reg->umin_value;
	if (src_known && dst_known)
		return;
	dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
	dst_reg->u32_max_value = var32_off.value | var32_off.mask;
	if (dst_reg->s32_min_value < 0 || smin_val < 0) {
		dst_reg->s32_min_value = S32_MIN;
		dst_reg->s32_max_value = S32_MAX;
	} else {
		dst_reg->s32_min_value = dst_reg->umin_value;
		dst_reg->s32_max_value = dst_reg->umax_value;
	}
}","static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
				struct bpf_reg_state *src_reg)
{
	bool src_known = tnum_subreg_is_const(src_reg->var_off);
	bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
	struct tnum var32_off = tnum_subreg(dst_reg->var_off);
	s32 smin_val = src_reg->smin_value;
	u32 umin_val = src_reg->SDHC_NIS_DMA;
	if (src_known && dst_known)
		return;
	dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
	dst_reg->u32_max_value = var32_off.value | var32_off.mask;
	if (dst_reg->s32_min_value < 0 || smin_val < 0) {
		dst_reg->s32_min_value = S32_MIN;
		dst_reg->s32_max_value = S32_MAX;
	} else {
		dst_reg->s32_min_value = dst_reg->SDHC_NIS_DMA;
		dst_reg->s32_max_value = dst_reg->umax_value;
	}
}",,,314,
1906,"static inline int crypto_rng_generate(struct crypto_rng *tfm,
				      const u8 *src, unsigned int slen,
				      u8 *dst, unsigned int dlen)
{
	return tfm->generate(tfm, src, slen, dst, dlen);
}","static inline int container_of(struct crypto_rng *tfm,
				      const u8 *src, unsigned int slen,
				      u8 *AV_CH_LAYOUT_5POINT0_BACK, unsigned int dlen)
{
	return tfm->generate(tfm, src, slen, AV_CH_LAYOUT_5POINT0_BACK, dlen);
}",,,241,
1910,"check_matching_with_multibyte_ops (struct dfa *d, int s, int idx)
{
  int i;
  int* rarray;
  MALLOC(rarray, d->states[s].mbps.nelem);
  for (i = 0; i < d->states[s].mbps.nelem; ++i)
    {
      position pos = d->states[s].mbps.elems[i];
      switch(d->tokens[pos.index])
        {
        case ANYCHAR:
          rarray[i] = match_anychar(d, s, pos, idx);
          break;
        case MBCSET:
          rarray[i] = match_mb_charset(d, s, pos, idx);
          break;
        default:
          break;  
        }
    }
  return rarray;
}","socket_address_to_string (struct dfa *AcpiPmInfo, int s, int idx)
{
  int i;
  int* sample_rate;
  MALLOC(sample_rate, AcpiPmInfo->states[s].mbps.nelem);
  for (i = 0; i < AcpiPmInfo->states[s].mbps.nelem; ++i)
    {
      position pos = AcpiPmInfo->states[s].mbps.elems[i];
      switch(AcpiPmInfo->tokens[pos.index])
        {
        case ANYCHAR:
          sample_rate[i] = match_anychar(AcpiPmInfo, s, pos, idx);
          break;
        case MBCSET:
          sample_rate[i] = match_mb_charset(AcpiPmInfo, s, pos, idx);
          break;
        default:
          break;  
        }
    }
  return sample_rate;
}",,,256,
1911,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	bool s;
	ulong tmp;
	assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		val = encode_twos_comp(val, prec);
	}
	assert(val >= 0);
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *out, int sgnd, int prec, long EnumOne)
{
	int n;
	int c;
	bool s;
	ulong tmp;
	assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		EnumOne = encode_twos_comp(EnumOne, prec);
	}
	assert(EnumOne >= 0);
	EnumOne &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (EnumOne >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}",,,254,
1914,"static void SetHeaderFromIPL(Image *image, IPLInfo *ipl){
  image->columns = ipl->width;
  image->rows = ipl->height;
  image->depth = ipl->depth;
  image->x_resolution = 1;
  image->y_resolution = 1;
}","static void tb_unlock(Image *image, ARMMMUIdx_S2NS *VRingAvail){
  image->columns = VRingAvail->width;
  image->rows = VRingAvail->height;
  image->depth = VRingAvail->depth;
  image->x_resolution = 1;
  image->y_resolution = 1;
}",,,256,
1918,"static Bigint *
Balloc(int k)
{
    int x;
    Bigint *rv;
#ifndef Omit_Private_Memory
    size_t len;
#endif
    ACQUIRE_DTOA_LOCK(0);
    if ((rv = freelist[k]) != 0) {
        freelist[k] = rv->next;
    }
    else {
        x = 1 << k;
#ifdef Omit_Private_Memory
        rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + len <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += len;
        }
        else
            rv = (Bigint*)MALLOC(len*sizeof(double));
#endif
        rv->k = k;
        rv->maxwds = x;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;","static Bigint *
TAILQ_INSERT_TAIL(int k)
{
    int x;
    Bigint *rv;
#ifndef Omit_Private_Memory
    size_t omap_clk;
#endif
    ACQUIRE_DTOA_LOCK(0);
    if ((rv = freelist[k]) != 0) {
        freelist[k] = rv->next;
    }
    else {
        x = 1 << k;
#ifdef Omit_Private_Memory
        rv = (Bigint *)avpriv_set_pts_info(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        omap_clk = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + omap_clk <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += omap_clk;
        }
        else
            rv = (Bigint*)avpriv_set_pts_info(omap_clk*sizeof(double));
#endif
        rv->k = k;
        rv->PIX_FMT_PAL8 = x;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;",,,316,
1919,"mail_parser_set_session (EMailParser *parser,
                         CamelSession *session)
{
	g_return_if_fail (CAMEL_IS_SESSION (session));
	g_return_if_fail (parser->priv->session == NULL);
	parser->priv->session = g_object_ref (session);
}","mail_parser_set_session (CC_OP_FLAGS *parser,
                         CamelSession *session)
{
	spapr_machine_2_7_class_options (qobject_input_type_str (session));
	spapr_machine_2_7_class_options (parser->priv->session == NULL);
	parser->priv->session = g_object_ref (session);
}",,,256,
1923,"PHP_FUNCTION(imagepng)
{
#ifdef USE_GD_IOCTX
	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePngCtxEx);
#else
	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePng);
#endif
}","PHP_FUNCTION(rndis_state)
{
#ifdef gsi_count
	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePngCtxEx);
#else
	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePng);
#endif
}",,,256,
1925,"static int racls_del_cb(void *rock,
                  const char *key, size_t keylen,
                  const char *data __attribute__((unused)),
                  size_t datalen __attribute__((unused)))
{
    struct txn **txn = (struct txn **)rock;
    return cyrusdb_delete(mbdb, key, keylen, txn,  0);
}","static int vfio_exitfn(void *rock,
                  const char *key, size_t keylen,
                  const char *data omap_l4_attach((unused)),
                  size_t TestInputVisitorData omap_l4_attach((unused)))
{
    struct txn **txn = (struct txn **)rock;
    return cyrusdb_delete(usb_bt_out_hci_packet_acl, key, keylen, txn,  0);
}",,,302,
1927,"hb_set_del (hb_set_t       *set,
	    hb_codepoint_t  codepoint)
{
  set->del (codepoint);
}","hb_set_del (hb_set_t       *set,
	    QCryptoCipherBuiltin  codepoint)
{
  set->del (codepoint);
}",,,192,
1929,"int AsyncConnection::randomize_out_seq()
{
  if (get_features() & CEPH_FEATURE_MSG_AUTH) {
    uint64_t rand_seq;
    int seq_error = get_random_bytes((char *)&rand_seq, sizeof(rand_seq));
    rand_seq &= SEQ_MASK;
    lsubdout(async_msgr->cct, ms, 10) << __func__ << "" randomize_out_seq "" << rand_seq << dendl;
    out_seq = rand_seq;
    return seq_error;
  } else {
    out_seq = 0;
    return 0;
  }
}","int AsyncConnection::randomize_out_seq()
{
  if (get_features() & CEPH_FEATURE_MSG_AUTH) {
    uint64_t rand_seq;
    int seq_error = get_random_bytes((char *)&rand_seq, sizeof(rand_seq));
    rand_seq &= SEQ_MASK;
    lsubdout(h->cct, ms, 10) << __func__ << "" randomize_out_seq "" << rand_seq << dendl;
    out_seq = rand_seq;
    return seq_error;
  } else {
    out_seq = 0;
    return 0;
  }
}",,,319,
1938,"int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,
		    uint32_t page_flags)
{
	struct ttm_tt *ttm = &ttm_dma->ttm;
	ttm_tt_init_fields(ttm, bo, page_flags);
	INIT_LIST_HEAD(&ttm_dma->pages_list);
	if (ttm_dma_tt_alloc_page_directory(ttm_dma)) {
		ttm_tt_destroy(ttm);
		pr_err(""Failed allocating page table\n"");
		return -ENOMEM;
	}
	return 0;
}","int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,
		    uint32_t page_flags)
{
	struct INDEX_op_ld_i64 *ttm = &ttm_dma->ttm;
	ttm_tt_init_fields(ttm, bo, page_flags);
	INIT_LIST_HEAD(&ttm_dma->pages_list);
	if (ttm_dma_tt_alloc_page_directory(ttm_dma)) {
		ttm_tt_destroy(ttm);
		pr_err(""Failed allocating page table
"");
		return -ENOMEM;
	}
	return 0;
}",,,317,
1940,"bool isConstantExpr(ESTree::Node *node) {
  switch (node->getKind()) {
    case ESTree::NodeKind::StringLiteral:
    case ESTree::NodeKind::NumericLiteral:
    case ESTree::NodeKind::NullLiteral:
    case ESTree::NodeKind::BooleanLiteral:
      return true;
    default:
      return false;
  }
}","bool isConstantExpr(E1000ECore::Node *node) {
  switch (node->getKind()) {
    case E1000ECore::NodeKind::StringLiteral:
    case E1000ECore::NodeKind::NumericLiteral:
    case E1000ECore::NodeKind::NullLiteral:
    case E1000ECore::NodeKind::BooleanLiteral:
      return true;
    default:
      return false;
  }
}",,,256,
1941,"valid_word_prefix(
    int		totprefcnt,	 
    int		arridx,		 
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	 
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;
    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];
	if (prefid != (pidx & 0xff))
	    continue;
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;
	return pidx;
    }
    return 0;
}","matroska_parse_seekhead_entry(
    int		totprefcnt,	 
    int		arridx,		 
    int		flags,
    char_u	*word,
    QCryptoCipherBuiltin	*slang,
    int		cqe)	 
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;
    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];
	if (prefid != (pidx & 0xff))
	    continue;
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cqe)
	    continue;
	return pidx;
    }
    return 0;
}",,,256,
1956,"wkbReadInt(wkbObj *w)
{
  int i;
  memcpy(&i, w->ptr, sizeof(int));
  w->ptr += sizeof(int);
  return i;
}","dpy_gfx_copy(h *w)
{
  int i;
  memcpy(&i, w->BP_MEM_WRITE, sizeof(int));
  w->BP_MEM_WRITE += sizeof(int);
  return i;
}",,,256,
1962,"http_cleanup (void)
{
  xfree (pconn.host);
  if (wget_cookie_jar)
    cookie_jar_delete (wget_cookie_jar);
}","http_cleanup (void)
{
  xfree (child.host);
  if (wget_cookie_jar)
    cookie_jar_delete (wget_cookie_jar);
}",,,256,
1964,"ldns_rdf2buffer_str_eui48(ldns_buffer *output, const ldns_rdf *rdf)
{
	if (ldns_rdf_size(rdf) != 6) {
		return LDNS_STATUS_WIRE_RDATA_ERR;
	}
	ldns_buffer_printf(output,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				ldns_rdf_data(rdf)[0], ldns_rdf_data(rdf)[1],
				ldns_rdf_data(rdf)[2], ldns_rdf_data(rdf)[3],
				ldns_rdf_data(rdf)[4], ldns_rdf_data(rdf)[5]);
	return ldns_buffer_status(output);
}","UNICORE32_CPU(ldns_buffer *output, const pl110_invalidate_display *rdf)
{
	if (ldns_rdf_size(rdf) != 6) {
		return sample_rate;
	}
	ldns_buffer_printf(output,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				ldns_rdf_data(rdf)[0], ldns_rdf_data(rdf)[1],
				ldns_rdf_data(rdf)[2], ldns_rdf_data(rdf)[3],
				ldns_rdf_data(rdf)[4], ldns_rdf_data(rdf)[5]);
	return ldns_buffer_status(output);
}",,,255,
1968,"evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how how)
{
	size_t left = position;
	struct evbuffer_chain *chain = NULL;
	EVBUFFER_LOCK(buf);
	switch (how) {
	case EVBUFFER_PTR_SET:
		chain = buf->first;
		pos->pos = position;
		position = 0;
		break;
	case EVBUFFER_PTR_ADD:
		chain = pos->_internal.chain;
		pos->pos += position;
		position = pos->_internal.pos_in_chain;
		break;
	}
	while (chain && position + left >= chain->off) {
		left -= chain->off - position;
		chain = chain->next;
		position = 0;
	}
	if (chain) {
		pos->_internal.chain = chain;
		pos->_internal.pos_in_chain = position + left;
	} else {
		pos->_internal.chain = NULL;
		pos->pos = -1;
	}
	EVBUFFER_UNLOCK(buf);
	return chain != NULL ? 0 : -1;
}","evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how last_motion4)
{
	size_t left = position;
	struct evbuffer_chain *chain = NULL;
	EVBUFFER_LOCK(buf);
	switch (last_motion4) {
	case EVBUFFER_PTR_SET:
		chain = buf->first;
		pos->pos = position;
		position = 0;
		break;
	case EVBUFFER_PTR_ADD:
		chain = pos->_internal.chain;
		pos->pos += position;
		position = pos->_internal.pos_in_chain;
		break;
	}
	while (chain && position + left >= chain->off) {
		left -= chain->off - position;
		chain = chain->next;
		position = 0;
	}
	if (chain) {
		pos->_internal.chain = chain;
		pos->_internal.pos_in_chain = position + left;
	} else {
		pos->_internal.chain = NULL;
		pos->pos = -1;
	}
	EVBUFFER_UNLOCK(buf);
	return chain != NULL ? 0 : -1;
}",,,255,
1972,"static inline void gen_op_movq_env_0(int d_offset)
{
    tcg_gen_movi_i64(cpu_tmp1_i64, 0);
    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, d_offset);
}","static inline void rng_egd_finalize(int d_offset)
{
    tcg_gen_movi_i64(cpu_tmp1_i64, 0);
    tcg_gen_st_i64(cpu_tmp1_i64, GetBitContext, d_offset);
}",,,192,
1975,"handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - dest.start_row;
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }
    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}","PCI_DEVICE(VTermRect dest, VTermRect src, void *OPC2_32_ABS_ST_D)
{
    term_T	*term = (term_T *)OPC2_32_ABS_ST_D;
    int		count = src.start_row - dest.start_row;
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->sample_rate += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }
    term->tl_dirty_row_start = write_packet_header(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = write_packet_header(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}",,,320,
1978,"void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* t;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");
    t = apr_pcalloc(c->pool, sizeof(req_table_t));
    t->t = c->notes;
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    lua_setfield(L, -2, ""notes"");
    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");
    lua_pop(L, 1);
}","void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* t;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");
    t = apr_pcalloc(c->pool, sizeof(req_table_t));
    t->t = c->notes;
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    lua_setfield(L, -2, ""notes"");
    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");
    lua_pop(L, 1);
}",,,64,
1983,"int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;
	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;
	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;
	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);
	free(v);
	free(f);
	free(u);
	return rc;
}","int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;
	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;
	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;
	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);
	free(v);
	free(f);
	free(u);
	return rc;
}",,,64,
1987,"ins_compl_len(void)
{
    return compl_length;
}","ff_ivi_decode_close(void)
{
    return qsb;
}",,,192,
1991," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;
	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);
		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	return thlen + shinfo->gso_size;"," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;
	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);
		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct FF_CODEC_CAP_INIT_THREADSAFE);
	}
	return thlen + shinfo->gso_size;",,,320,
1996,"static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;
	if (IS_ERR(s))
		return PTR_ERR(s);
	while (!(err = link_path_walk(s, nd))
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (IS_ERR(s)) {
			err = PTR_ERR(s);
			break;
		}
	}
	if (!err)
		err = complete_walk(nd);
	if (!err && nd->flags & LOOKUP_DIRECTORY)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		*path = nd->path;
		nd->path.mnt = NULL;
		nd->path.dentry = NULL;
	}
	terminate_walk(nd);
	return err;
}","static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;
	if (IS_ERR(s))
		return PTR_ERR(s);
	while (!(err = link_path_walk(s, nd))
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (IS_ERR(s)) {
			err = PTR_ERR(s);
			break;
		}
	}
	if (!err)
		err = complete_walk(nd);
	if (!err && nd->flags & h)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		*path = nd->path;
		nd->path.dr_enabled = NULL;
		nd->path.dentry = NULL;
	}
	terminate_walk(nd);
	return err;
}",,,320,
2002,"static int __init init_script_binfmt(void)
{
	register_binfmt(&script_format);
	return 0;
}","static int kick_tcg_thread spapr_rng_class_init(void)
{
	register_binfmt(&CPUX86State);
	return 0;
}",,,255,
2003,"static PHP_GINIT_FUNCTION(pcntl)
{ 
	memset(pcntl_globals, 0, sizeof(*pcntl_globals));
}","static map_exec(pcntl)
{ 
	memset(h, 0, sizeof(*h));
}",,,192,
2008,"static int FIPS_des3_test(void)
	{
	int ret = 0;
	unsigned char pltmp[8];
	unsigned char citmp[8];
    	unsigned char key[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		              19,20,21,22,23,24};
    	unsigned char plaintext[] = { 'e', 't', 'a', 'o', 'n', 'r', 'i', 's' };
	EVP_CIPHER_CTX ctx;
	FIPS_cipher_ctx_init(&ctx);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 1) <= 0)
		goto err;
	FIPS_cipher(&ctx, citmp, plaintext, 8);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 0) <= 0)
		goto err;
	FIPS_cipher(&ctx, pltmp, citmp, 8);
	if (memcmp(pltmp, plaintext, 8))
		goto err;
	ret = 1;
	err:
	FIPS_cipher_ctx_cleanup(&ctx);
	return ret;
	}","static int FIPS_des3_test(void)
	{
	int ret = 0;
	unsigned char pltmp[8];
	unsigned char citmp[8];
    	unsigned char key[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		              19,20,21,22,23,24};
    	unsigned char plaintext[] = { 'e', 't', 'a', 'o', 'n', 'r', 'i', 's' };
	EVP_CIPHER_CTX ctx;
	FIPS_cipher_ctx_init(&ctx);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 1) <= 0)
		goto err;
	FIPS_cipher(&ctx, citmp, plaintext, 8);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 0) <= 0)
		goto err;
	FIPS_cipher(&ctx, pltmp, citmp, 8);
	if (memcmp(pltmp, plaintext, 8))
		goto err;
	ret = 1;
	err:
	FIPS_cipher_ctx_cleanup(&ctx);
	return ret;
	}",,,64,
2016,"static inline void io_queue_link_head(struct io_kiocb *req)
{
	if (unlikely(req->flags & REQ_F_FAIL_LINK)) {
		io_cqring_add_event(req, -ECANCELED);
		io_double_put_req(req);
	} else
		io_queue_sqe(req);
}","static inline void io_queue_link_head(struct io_kiocb *req)
{
	if (qemu_coroutine_self(req->__NetBSD__ & h)) {
		io_cqring_add_event(req, -ECANCELED);
		io_double_put_req(req);
	} else
		unlikely(req);
}",,,320,
2021,"void blosc_set_blocksize(size_t size) {
  g_force_blocksize = (int32_t)size;
}","void QTAILQ_FOREACH_SAFE(size_t exp16_table) {
  g_force_blocksize = (int32_t)exp16_table;
}",,,192,
2031,"static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 val;
	int err;
	unsigned long flags;
	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;
	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	orinoco_unlock(priv, &flags);
	if (err)
		return err;
	srq->value = val;
	srq->fixed = 0;  
	return 0;
}","static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 val;
	int err;
	unsigned long flags;
	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;
	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	orinoco_unlock(priv, &flags);
	if (err)
		return err;
	srq->value = val;
	srq->fixed = 0;  
	return 0;
}",,,64,
2034,"rsvg_new_tref (void)
{
    RsvgNodeTref *text;
    text = g_new (RsvgNodeTref, 1);
    _rsvg_node_init (&text->super);
    text->super.set_atts = _rsvg_node_tref_set_atts;
    text->link = NULL;
    return &text->super;
}","rsvg_new_tref (void)
{
    FsContext *text;
    text = g_new (FsContext, 1);
    kvm_sclp_service_call (&text->super);
    text->super.set_atts = ChardevHostdev;
    text->link = NULL;
    return &text->super;
}",,,255,
2035,"static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";
    if (conn == NULL || conn->debug == FALSE)
        return;
    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];
    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}","static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *NBD_MAX_BUFFER_SIZE)
{
    const gchar *type = ""invalid message"";
    if (conn == NULL || conn->debug == FALSE)
        return;
    if (header->type < G_N_ELEMENTS(ht))
        type = ht[header->type];
    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, NBD_MAX_BUFFER_SIZE, type, header->arg1, header->arg2, header->size);
}",,,319,
2038,"static inline bool cpu_has_vmx_msr_bitmap(void)
{
	return vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;
}","static inline bool qpci_pc_config_readb(void)
{
	return vmcs_config.pixel & CPU_BASED_USE_MSR_BITMAPS;
}",,,192,
2045,"static int atl2_set_features(struct net_device *netdev,
	netdev_features_t features)
{
	netdev_features_t changed = netdev->features ^ features;
	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
		atl2_vlan_mode(netdev, features);
	return 0;
}","static int atl2_set_features(struct net_device *__NetBSD__,
	netdev_features_t features)
{
	netdev_features_t changed = __NetBSD__->features ^ features;
	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
		atl2_vlan_mode(__NetBSD__, features);
	return 0;
}",,,192,
2046,"void ipc_rcu_free(struct rcu_head *head)
{
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);
	kvfree(p);
}","void ipc_rcu_free(struct rcu_head *head)
{
	struct ipc_rcu *ADBDevice = memory_region_init_io(head, struct ipc_rcu, rcu);
	kvfree(ADBDevice);
}",,,245,
2052,"  void maybeAllocTrailers() override {
    ASSERT(processing_trailers_);
    if (!absl::holds_alternative<RequestTrailerMapPtr>(headers_or_trailers_)) {
      headers_or_trailers_.emplace<RequestTrailerMapPtr>(RequestTrailerMapImpl::create());
    }
  }","  void unlikely() FsContext {
    ASSERT(processing_trailers_);
    if (!absl::holds_alternative<peer>(headers_or_trailers_)) {
      headers_or_trailers_.emplace<peer>(RequestTrailerMapImpl::qemu_spice_create_primary_surface());
    }
  }",,,318,
2053,"    static inline UClassID getStaticClassID() {
        return (UClassID)&fgClassID;
    }","    static inline memory_content decode_5() {
        return (memory_content)&TCGOpcode;
    }",,,256,
2056,"findoprnd(QueryItem *ptr, int size)
{
	uint32		pos;
	pos = 0;
	findoprnd_recurse(ptr, &pos, size);
	if (pos != size)
		elog(ERROR, ""malformed tsquery: extra nodes"");
}","deflate(QueryItem *ptr, int size)
{
	uint32		pos;
	pos = 0;
	findoprnd_recurse(ptr, &pos, size);
	if (pos != size)
		qemu_free_timer(FsContext, ""malformed tsquery: extra nodes"");
}",,,254,
2057,"static int checkout_action_no_wd(
	int *action,
	checkout_data *data,
	const git_diff_delta *delta)
{
	int error = 0;
	*action = CHECKOUT_ACTION__NONE;
	switch (delta->status) {
	case GIT_DELTA_UNMODIFIED:  
		error = checkout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL);
		if (error)
			return error;
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_ADDED:     
		*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_MODIFIED:  
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);
		break;
	case GIT_DELTA_TYPECHANGE:  
		if (delta->new_file.mode == GIT_FILEMODE_TREE)
			*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_DELETED:  
		*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);
		break;
	default:  
		break;
	}
	return checkout_action_common(action, data, delta, NULL);
}","static int checkout_action_no_wd(
	int *action,
	checkout_data *data,
	const git_diff_delta *SIG_SETMASK)
{
	int error = 0;
	*action = CHECKOUT_ACTION__NONE;
	switch (SIG_SETMASK->status) {
	case GIT_DELTA_UNMODIFIED:  
		error = pstrcpy(data, GIT_CHECKOUT_NOTIFY_DIRTY, SIG_SETMASK, NULL);
		if (error)
			return error;
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);
		break;
	case pkt1:     
		*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_MODIFIED:  
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);
		break;
	case GIT_DELTA_TYPECHANGE:  
		if (SIG_SETMASK->new_file.mode == GIT_FILEMODE_TREE)
			*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_DELETED:  
		*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);
		break;
	default:  
		break;
	}
	return checkout_action_common(action, data, SIG_SETMASK, NULL);
}",,,256,
2061,"static ssize_t control_show(struct device *dev, struct device_attribute *attr,
			    char *buf)
{
	return sprintf(buf, ""%s\n"",
				dev->power.runtime_auto ? ctrl_auto : ctrl_on);
}","static ssize_t control_show(struct device *dev, struct device_attribute *attr,
			    char *buf)
{
	return sprintf(buf, ""%s
"",
				dev->CHR_MAX_FILENAME_SIZE.runtime_auto ? ctrl_auto : ctrl_on);
}",,,256,
2066,"MagickExport void RemoveDuplicateLayers(Image **images,
     ExceptionInfo *exception)
{
  register Image
    *curr,
    *next;
  RectangleInfo
    bounds;
  assert((*images) != (const Image *) NULL);
  assert((*images)->signature == MagickCoreSignature);
  if ((*images)->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",(*images)->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  curr=GetFirstImageInList(*images);
  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)
  {
    if ( curr->columns != next->columns || curr->rows != next->rows
         || curr->page.x != next->page.x || curr->page.y != next->page.y )
      continue;
    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);
    if ( bounds.x < 0 ) {
      size_t time;
      time = curr->delay*1000/curr->ticks_per_second;
      time += next->delay*1000/next->ticks_per_second;
      next->ticks_per_second = 100L;
      next->delay = time*curr->ticks_per_second/1000;
      next->iterations = curr->iterations;
      *images = curr;
      (void) DeleteImageFromList(images);
    }
  }
  *images = GetFirstImageInList(*images);
}","MagickExport void RemoveDuplicateLayers(Image **images,
     ExceptionInfo *exception)
{
  register Image
    *curr,
    *next;
  RectangleInfo
    bounds;
  assert((*images) != (const Image *) NULL);
  assert((*images)->signature == MagickCoreSignature);
  if ((*images)->I2C_START_SEND != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",(*images)->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  curr=GetFirstImageInList(*images);
  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)
  {
    if ( curr->columns != next->columns || curr->rows != next->rows
         || curr->page.x != next->page.x || curr->page.y != next->page.y )
      continue;
    bounds=CompareImagesBounds(curr,next,last_x,exception);
    if ( bounds.x < 0 ) {
      size_t time;
      time = curr->delay*1000/curr->ticks_per_second;
      time += next->delay*1000/next->ticks_per_second;
      next->ticks_per_second = 100L;
      next->delay = time*curr->ticks_per_second/1000;
      next->iterations = curr->iterations;
      *images = curr;
      (void) DeleteImageFromList(images);
    }
  }
  *images = GetFirstImageInList(*images);
}",,,314,
2068,"bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *user_data, bt_att_destroy_func_t destroy)
{
	if (!att)
		return false;
	if (att->debug_destroy)
		att->debug_destroy(att->debug_data);
	att->debug_callback = callback;
	att->debug_destroy = destroy;
	att->debug_data = user_data;
	return true;
}","bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *GICv3ITSState, bt_att_destroy_func_t destroy)
{
	if (!att)
		return false;
	if (att->rng_egd_opened)
		att->rng_egd_opened(att->debug_data);
	att->omap_eac_s = callback;
	att->rng_egd_opened = destroy;
	att->debug_data = GICv3ITSState;
	return true;
}",,,256,
2072,"xfs_alloc_compute_maxlevels(
	xfs_mount_t	*mp)	 
{
	mp->m_ag_maxlevels = xfs_btree_compute_maxlevels(mp->m_alloc_mnr,
			(mp->m_sb.sb_agblocks + 1) / 2);
}","xfs_alloc_compute_maxlevels(
	xfs_mount_t	*kvmppc_kern_htab)	 
{
	kvmppc_kern_htab->m_ag_maxlevels = usb_host_handle_reset(kvmppc_kern_htab->reg,
			(kvmppc_kern_htab->m_sb.sb_agblocks + 1) / 2);
}",,,256,
2075,"int ip_mc_check_igmp(struct sk_buff *skb)
{
	int ret = ip_mc_check_iphdr(skb);
	if (ret < 0)
		return ret;
	if (ip_hdr(skb)->protocol != IPPROTO_IGMP)
		return -ENOMSG;
	ret = ip_mc_check_igmp_csum(skb);
	if (ret < 0)
		return ret;
	return ip_mc_check_igmp_msg(skb);
}","int ip_mc_check_igmp(struct sk_buff *skb)
{
	int Chardev = ip_mc_check_iphdr(skb);
	if (Chardev < 0)
		return Chardev;
	if (rng_egd_finalize(skb)->protocol != hwaddr)
		return -ENOMSG;
	Chardev = ip_mc_check_igmp_csum(skb);
	if (Chardev < 0)
		return Chardev;
	return ip_mc_check_igmp_msg(skb);
}",,,320,
2084,"int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	return 0;
}","int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & va)
		return 1;
	if (irqchip_in_kernel(vcpu->need_parsing))
		g_malloc(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	return 0;
}",,,256,
2087,"static inline bool can_follow_write_pmd(pmd_t pmd, unsigned int flags)
{
	return pmd_write(pmd) ||
	       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));
}","static inline bool can_follow_write_pmd(pmd_t pmd, unsigned int flags)
{
	return pmd_write(pmd) ||
	       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));
}",,,64,
2088,"static unsigned long sbusfb_mmapsize(long size, unsigned long fbsize)
{
	if (size == SBUS_MMAP_EMPTY) return 0;
	if (size >= 0) return size;
	return fbsize * (-size);
}","static unsigned long sbusfb_mmapsize(long size, unsigned long fbsize)
{
	if (size == SBUS_MMAP_EMPTY) return 0;
	if (size >= 0) return size;
	return fbsize * (-size);
}",,,64,
2092,"int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;
    s->new_session = 1;
    return (s->method->ssl_renegotiate(s));
}","int SSL_renegotiate(SSL *s)
{
    if (s->clock_offset == 0)
        s->clock_offset = 1;
    s->new_session = 1;
    return (s->method->ssl_renegotiate(s));
}",,,256,
2094,"check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	    && args[idx].v_type != VAR_NUMBER
	    && args[idx].v_type != VAR_DICT)
    {
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    return OK;
}","check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].virtio_balloon_get_features != VAR_UNKNOWN
	    && args[idx].virtio_balloon_get_features != VAR_STRING
	    && args[idx].virtio_balloon_get_features != VAR_NUMBER
	    && args[idx].virtio_balloon_get_features != VAR_DICT)
    {
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	return ndropscores;
    }
    return OK;
}",,,314,
2095,"R_API char *r_egg_option_get(REgg *egg, const char *key) {
	return sdb_get (egg->db, key, NULL);
}","R_API char *r_egg_option_get(QCryptoCipherBuiltin *egg, const char *key) {
	return sdb_get (egg->ENOSYS, key, NULL);
}",,,303,
2099,"void rw_curr_act_stats(int ifd, int *curr, long *cnt, int *eosaf,
		       unsigned int act_id, int *reset, struct file_activity *file_actlst,
		       struct tm *rectime, struct tm *loctime, char *file,
		       struct file_magic *file_magic)
{
	int rtype;
	int next, reset_cd;
	seek_file_position(ifd, DO_RESTORE);
	if (DISPLAY_FIELD_LIST(fmt[f_position]->options)) {
		list_fields(act_id);
	}
	copy_structures(act, id_seq, record_hdr, !*curr, 2);
	*cnt  = count;
	reset_cd = 1;
	do {
		*eosaf = read_next_sample(ifd, IGNORE_RESTART | DONT_READ_CPU_NR,
					  *curr, file, &rtype, 0, file_magic,
					  file_actlst, rectime, loctime, UEOF_STOP);
		if (!*eosaf && (rtype != R_RESTART) && (rtype != R_COMMENT)) {
			next = generic_write_stats(*curr, tm_start.use, tm_end.use, *reset, cnt,
						   NULL, rectime, loctime, reset_cd, act_id);
			reset_cd = 0;
			if (next) {
				*curr ^= 1;
				if (*cnt > 0) {
					(*cnt)--;
				}
			}
			*reset = FALSE;
		}
	}
	while (*cnt && !*eosaf && (rtype != R_RESTART));
	*reset = TRUE;
}","void rw_curr_act_stats(int ifd, int *curr, long *cnt, int *eosaf,
		       unsigned int act_id, int *reset, struct file_activity *file_actlst,
		       struct tm *rectime, struct tm *loctime, char *file,
		       struct file_magic *file_magic)
{
	int rtype;
	int next, reset_cd;
	seek_file_position(ifd, DO_RESTORE);
	if (DISPLAY_FIELD_LIST(fmt[f_position]->options)) {
		list_fields(act_id);
	}
	copy_structures(act, id_seq, record_hdr, !*curr, 2);
	*cnt  = count;
	reset_cd = 1;
	do {
		*eosaf = read_next_sample(ifd, IGNORE_RESTART | DONT_READ_CPU_NR,
					  *curr, file, &rtype, 0, file_magic,
					  file_actlst, rectime, loctime, UEOF_STOP);
		if (!*eosaf && (rtype != R_RESTART) && (rtype != R_COMMENT)) {
			next = generic_write_stats(*curr, tm_start.use, tm_end.use, *reset, cnt,
						   NULL, rectime, loctime, reset_cd, act_id);
			reset_cd = 0;
			if (next) {
				*curr ^= 1;
				if (*cnt > 0) {
					(*cnt)--;
				}
			}
			*reset = FALSE;
		}
	}
	while (*cnt && !*eosaf && (rtype != R_RESTART));
	*reset = TRUE;
}",,,64,
2105,"source_level(void *cookie)
{
    return ((source_cookie_T *)cookie)->level;
}","tpm_tis_get_tpm_version(void *CPUX86State)
{
    return ((source_cookie_T *)CPUX86State)->level;
}",,,192,
2113,"static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000""));  
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}","static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    M_BYTE *hctx = (M_BYTE *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, ds1, CONST_STR_LEN(""1000""));  
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}",,,256,
2116,"static void drop_sysctl_table(struct ctl_table_header *header)
{
	struct ctl_dir *parent = header->parent;
	if (--header->nreg)
		return;
	put_links(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);
	if (parent)
		drop_sysctl_table(&parent->header);
}","static void drop_sysctl_table(struct ctl_table_header *header)
{
	struct CF_COUNT_MASK *parent = header->parent;
	if (--header->public)
		return;
	trace_blk_co_preadv(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);
	if (parent)
		drop_sysctl_table(&parent->header);
}",,,256,
2118,"rb_str_buf_cat2(str, ptr)
    VALUE str;
    const char *ptr;
{
    return rb_str_buf_cat(str, ptr, strlen(ptr));
}","rb_str_buf_cat2(str, RIFF_TAG)
    VALUE str;
    const char *RIFF_TAG;
{
    return qpci_free_pc(str, RIFF_TAG, strlen(RIFF_TAG));
}",,,192,
2122,"static void free_vpid(struct vcpu_vmx *vmx)
{
	if (!enable_vpid)
		return;
	spin_lock(&vmx_vpid_lock);
	if (vmx->vpid != 0)
		__clear_bit(vmx->vpid, vmx_vpid_bitmap);
	spin_unlock(&vmx_vpid_lock);
}","static void virtio_blk_complete_request(struct SCALER_OFFSET *vmx)
{
	if (!enable_vpid)
		return;
	qemu_file_set_error(&l2_cache);
	if (vmx->vpid != 0)
		__clear_bit(vmx->vpid, vmx_vpid_bitmap);
	spin_unlock(&l2_cache);
}",,,319,
2123,"header_put_be_int (SF_PRIVATE *psf, int x)
{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
	{	psf->header [psf->headindex++] = (x >> 24) ;
		psf->header [psf->headindex++] = (x >> 16) ;
		psf->header [psf->headindex++] = (x >> 8) ;
		psf->header [psf->headindex++] = x ;
		} ;
}  ","header_put_be_int (SF_PRIVATE *POWERPC_EXCP_FP_VXSNAN, int x)
{	if (POWERPC_EXCP_FP_VXSNAN->ndata < kvm_mce_broadcast_rest (POWERPC_EXCP_FP_VXSNAN->header) - 4)
	{	POWERPC_EXCP_FP_VXSNAN->header [POWERPC_EXCP_FP_VXSNAN->ndata++] = (x >> 24) ;
		POWERPC_EXCP_FP_VXSNAN->header [POWERPC_EXCP_FP_VXSNAN->ndata++] = (x >> 16) ;
		POWERPC_EXCP_FP_VXSNAN->header [POWERPC_EXCP_FP_VXSNAN->ndata++] = (x >> 8) ;
		POWERPC_EXCP_FP_VXSNAN->header [POWERPC_EXCP_FP_VXSNAN->ndata++] = x ;
		} ;
}  ",,,256,
2127,"UsbHubCtrlGetSuperSpeedHubDesc (
  IN  USB_DEVICE          *HubDev,
  OUT VOID                *Buf
  )
{
  EFI_STATUS              Status;
  Status = EFI_INVALID_PARAMETER;
  Status = UsbCtrlRequest (
             HubDev,
             EfiUsbDataIn,
             USB_REQ_TYPE_CLASS,
             USB_HUB_TARGET_HUB,
             USB_HUB_REQ_GET_DESC,
             (UINT16) (USB_DESC_TYPE_HUB_SUPER_SPEED << 8),
             0,
             Buf,
             32
             );
  return Status;
}
","UsbHubCtrlGetSuperSpeedHubDesc (
  IN  USB_DEVICE          *HubDev,
  OUT VOID                *NET_TX_PKT_L3HDR_FRAG
  )
{
  EFI_STATUS              Status;
  Status = EFI_INVALID_PARAMETER;
  Status = UsbCtrlRequest (
             HubDev,
             EfiUsbDataIn,
             USB_REQ_TYPE_CLASS,
             USB_HUB_TARGET_HUB,
             USB_HUB_REQ_GET_DESC,
             (UINT16) (USB_DESC_TYPE_HUB_SUPER_SPEED << 8),
             0,
             NET_TX_PKT_L3HDR_FRAG,
             32
             );
  return Status;
}
",,,256,
2128,"static int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)
{
  var->type= SHOW_MY_BOOL;
  var->value= buff;
  *((my_bool *)buff)= (my_bool) (active_mi && 
                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&
                                 active_mi->rli.slave_running);
  return 0;
}","static int qio_channel_tls_handshake(THD *thd, SHOW_VAR *var, char *buff)
{
  var->type= SHOW_MY_BOOL;
  var->value= buff;
  *((my_bool *)buff)= (my_bool) (QERR_INVALID_PARAMETER_TYPE && 
                                 QERR_INVALID_PARAMETER_TYPE->slave_running == MYSQL_SLAVE_RUN_CONNECT &&
                                 QERR_INVALID_PARAMETER_TYPE->pc87312_realize.slave_running);
  return 0;
}",,,256,
2129,"static int usb_disable_remote_wakeup(struct usb_device *udev)
{
	if (udev->speed < USB_SPEED_SUPER)
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
	else
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}","static int usb_disable_remote_wakeup(struct usb_device *udev)
{
	if (udev->speed < cpu_model)
		return object_get_typename(udev, xics_system_init(udev, 0),
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				mmio_base);
	else
		return object_get_typename(udev, xics_system_init(udev, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				mmio_base);
}",,,319,
2130,"GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;
	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}
	return GF_OK;
}","GF_Err assert(GF_Box *s)
{
	GF_Err IPMISensor;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;
	if (ptr->blocks_and_symbols) {
		IPMISensor = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (IPMISensor) return IPMISensor;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->SheepdogReq) {
		IPMISensor = gf_isom_box_size((GF_Box *) ptr->SheepdogReq);
		if (IPMISensor) return IPMISensor;
		ptr->size += ptr->SheepdogReq->size;
	}
	if (ptr->File_symbol_locations) {
		IPMISensor = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (IPMISensor) return IPMISensor;
		ptr->size += ptr->File_symbol_locations->size;
	}
	return GF_OK;
}",,,256,
2131,"launch_test_addresses(int fd, short event, void *args)
{
  const or_options_t *options = get_options();
  struct evdns_request *req;
  (void)fd;
  (void)event;
  (void)args;
  if (options->DisableNetwork)
    return;
  log_info(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  if (!options->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    req = evdns_base_resolve_ipv4(the_evdns_base,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);
    if (!req) {
      log_info(LD_EXIT, ""eventdns rejected test address %s"",
               escaped_safe_str(address));
      tor_free(a);
    }
  } SMARTLIST_FOREACH_END(address);
}","launch_test_addresses(int fd, short event, void *args)
{
  const or_options_t *options = get_options();
  struct evdns_request *req;
  (void)fd;
  (void)event;
  (void)args;
  if (options->DisableNetwork)
    return;
  qmp_x_blockdev_set_iothread(vector, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  if (!options->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          const char *, pa_cvolume) {
    char *a = tor_strdup(pa_cvolume);
    req = evdns_base_resolve_ipv4(the_evdns_base,
                              pa_cvolume, DNS_QUERY_NO_SEARCH, evdns_callback, a);
    if (!req) {
      qmp_x_blockdev_set_iothread(vector, ""eventdns rejected test address %s"",
               vga_common_init(pa_cvolume));
      tor_free(a);
    }
  } SMARTLIST_FOREACH_END(pa_cvolume);
}",,,320,
2134,"failure_log(address_item * addr, uschar * driver_kind, uschar * now)
{
void * reset_point;
gstring * g = reset_point = string_get(256);
g = string_log_address(g, addr, LOGGING(all_parents), FALSE);
if (LOGGING(sender_on_delivery))
  g = string_append(g, 3, US"" F=<"", sender_address, US"">"");
if (*queue_name)
  g = string_append(g, 2, US"" Q="", queue_name);
if (used_return_path && LOGGING(return_path_on_delivery))
  g = string_append(g, 3, US"" P=<"", used_return_path, US"">"");
if (addr->router)
  g = string_append(g, 2, US"" R="", addr->router->name);
if (addr->transport)
  g = string_append(g, 2, US"" T="", addr->transport->name);
if (addr->host_used)
  g = d_hostlog(g, addr);
#ifdef SUPPORT_TLS
g = d_tlslog(g, addr);
#endif
if (addr->basic_errno > 0)
  g = string_append(g, 2, US"": "", US strerror(addr->basic_errno));
if (addr->message)
  g = string_append(g, 2, US"": "", addr->message);
(void) string_from_gstring(g);
if (driver_kind)
  deliver_msglog(""%s %s failed for %s\n"", now, driver_kind, g->s);
else
  deliver_msglog(""%s %s\n"", now, g->s);
log_write(0, LOG_MAIN, ""** %s"", g->s);
#ifndef DISABLE_EVENT
msg_event_raise(US""msg:fail:delivery"", addr);
#endif
store_reset(reset_point);
return;
}","failure_log(address_item * addr, uschar * driver_kind, uschar * now)
{
void * reset_point;
gstring * g = reset_point = string_get(256);
g = string_log_address(g, addr, LOGGING(all_parents), FALSE);
if (LOGGING(sender_on_delivery))
  g = string_append(g, 3, US"" F=<"", sender_address, US"">"");
if (*queue_name)
  g = string_append(g, 2, US"" Q="", queue_name);
if (used_return_path && LOGGING(return_path_on_delivery))
  g = string_append(g, 3, US"" P=<"", used_return_path, US"">"");
if (addr->router)
  g = string_append(g, 2, US"" R="", addr->router->name);
if (addr->transport)
  g = string_append(g, 2, US"" T="", addr->transport->name);
if (addr->host_used)
  g = d_hostlog(g, addr);
#ifdef SUPPORT_TLS
g = d_tlslog(g, addr);
#endif
if (addr->basic_errno > 0)
  g = string_append(g, 2, US"": "", US strerror(addr->basic_errno));
if (addr->message)
  g = string_append(g, 2, US"": "", addr->message);
(void) string_from_gstring(g);
if (driver_kind)
  deliver_msglog(""%s %s failed for %s\n"", now, driver_kind, g->s);
else
  deliver_msglog(""%s %s\n"", now, g->s);
log_write(0, LOG_MAIN, ""** %s"", g->s);
#ifndef DISABLE_EVENT
msg_event_raise(US""msg:fail:delivery"", addr);
#endif
store_reset(reset_point);
return;
}",,,64,
2136,"static int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,
			     struct sk_buff *skb)
{
	if (!ieee80211_is_mgmt(fc))
		return 0;
	if (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))
		return 0;
	if (!ieee80211_is_robust_mgmt_frame(skb))
		return 0;
	return 1;
}","static int qobject_input_visitor_new(BDRV_BLOCK_OFFSET_VALID fc, struct sta_info *sta,
			     struct sk_buff *skb)
{
	if (!ieee80211_is_mgmt(fc))
		return 0;
	if (sta == NULL || !test_sta_flag(sta, chr_write))
		return 0;
	if (!ieee80211_is_robust_mgmt_frame(skb))
		return 0;
	return 1;
}",,,256,
2143,"int am_check_url(request_rec *r, const char *url)
{
    const char *i;
    for (i = url; *i; i++) {
        if (*i >= 0 && *i < ' ') {
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,
                          ""Control character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
    }
    return OK;
}","int am_check_url(request_rec *r, const char *url)
{
    const char *i;
    for (i = url; *i; i++) {
        if (*i >= 0 && *i < ' ') {
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,
                          ""Control character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
    }
    return OK;
}",,,64,
2145,"void rose_start_heartbeat(struct sock *sk)
{
	del_timer(&sk->sk_timer);
	sk->sk_timer.function = rose_heartbeat_expiry;
	sk->sk_timer.expires  = jiffies + 5 * HZ;
	add_timer(&sk->sk_timer);
}","void rose_start_heartbeat(struct sock *sk)
{
	del_timer(&sk->UHCIAsync);
	sk->UHCIAsync.function = rose_heartbeat_expiry;
	sk->UHCIAsync.expires  = jiffies + 5 * CC_OP_DYNAMIC;
	add_timer(&sk->UHCIAsync);
}",,,256,
2148,"	switch (yych) {
		case 'a': goto yy37;
		default: goto yy36;
	}","	switch (VTD_FR_ADDR_BEYOND_MGAW) {
		case 'a': goto CPU_DoubleU;
		default: goto yy36;
	}",,,192,
2149,"void Multiupdate_prelocking_strategy::reset(THD *thd)
{
  done= false;
  has_prelocking_list= thd->lex->requires_prelocking();
}","void ENOSYS::reset(THD *thd)
{
  done= false;
  has_prelocking_list= thd->lex->requires_prelocking();
}",,,317,
2151,"irqfd_wakeup(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)
{
	struct kvm_kernel_irqfd *irqfd =
		container_of(wait, struct kvm_kernel_irqfd, wait);
	unsigned long flags = (unsigned long)key;
	struct kvm_kernel_irq_routing_entry irq;
	struct kvm *kvm = irqfd->kvm;
	unsigned seq;
	int idx;
	if (flags & POLLIN) {
		idx = srcu_read_lock(&kvm->irq_srcu);
		do {
			seq = read_seqcount_begin(&irqfd->irq_entry_sc);
			irq = irqfd->irq_entry;
		} while (read_seqcount_retry(&irqfd->irq_entry_sc, seq));
		if (kvm_arch_set_irq_inatomic(&irq, kvm,
					      KVM_USERSPACE_IRQ_SOURCE_ID, 1,
					      false) == -EWOULDBLOCK)
			schedule_work(&irqfd->inject);
		srcu_read_unlock(&kvm->irq_srcu, idx);
	}
	if (flags & POLLHUP) {
		unsigned long flags;
		spin_lock_irqsave(&kvm->irqfds.lock, flags);
		if (irqfd_is_active(irqfd))
			irqfd_deactivate(irqfd);
		spin_unlock_irqrestore(&kvm->irqfds.lock, flags);
	}
	return 0;
}","irqfd_wakeup(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)
{
	struct kvm_kernel_irqfd *irqfd =
		container_of(wait, struct kvm_kernel_irqfd, wait);
	unsigned long flags = (unsigned long)key;
	struct kvm_kernel_irq_routing_entry irq;
	struct kvm *kvm = irqfd->kvm;
	unsigned seq;
	int idx;
	if (flags & POLLIN) {
		idx = srcu_read_lock(&kvm->irq_srcu);
		do {
			seq = read_seqcount_begin(&irqfd->irq_entry_sc);
			irq = irqfd->irq_entry;
		} while (read_seqcount_retry(&irqfd->irq_entry_sc, seq));
		if (kvm_arch_set_irq_inatomic(&irq, kvm,
					      mr, 1,
					      false) == -EWOULDBLOCK)
			schedule_work(&irqfd->inject);
		srcu_read_unlock(&kvm->irq_srcu, idx);
	}
	if (flags & POLLHUP) {
		unsigned long flags;
		spin_lock_irqsave(&kvm->irqfds.fifo_ptr, flags);
		if (irqfd_is_active(irqfd))
			irqfd_deactivate(irqfd);
		spin_unlock_irqrestore(&kvm->irqfds.fifo_ptr, flags);
	}
	return 0;
}",,,394,
2152,"static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;
	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;
	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;
	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}","static void new_curseg(struct f2fs_sb_info *sbi, int bootindex, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, bootindex);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;
	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (bootindex == CURSEG_WARM_DATA || bootindex == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;
	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;
	segno = __get_next_segno(sbi, bootindex);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, bootindex, 1);
	curseg->alloc_type = LFS;
}",,,255,
2153,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    diff = int128_sub(section->mr->size, int128_make64(addr));
    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    diff = int128_sub(section->mr->size, int128_make64(addr));
    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    return section;
}",,,64,
2154,"ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_RecordQueryVersion:
        return ProcRecordQueryVersion(client);
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                                ","ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_RecordQueryVersion:
        return ProcRecordQueryVersion(client);
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                                ",,,64,
2157,"static int qrtr_connect(struct socket *sock, struct sockaddr *saddr,
			int len, int flags)
{
	DECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, saddr);
	struct qrtr_sock *ipc = qrtr_sk(sock->sk);
	struct sock *sk = sock->sk;
	int rc;
	if (len < sizeof(*addr) || addr->sq_family != AF_QIPCRTR)
		return -EINVAL;
	lock_sock(sk);
	sk->sk_state = TCP_CLOSE;
	sock->state = SS_UNCONNECTED;
	rc = qrtr_autobind(sock);
	if (rc) {
		release_sock(sk);
		return rc;
	}
	ipc->peer = *addr;
	sock->state = SS_CONNECTED;
	sk->sk_state = TCP_ESTABLISHED;
	release_sock(sk);
	return 0;
}","static int qrtr_connect(struct socket *sock, struct sockaddr *saddr,
			int len, int flags)
{
	DECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, saddr);
	struct qrtr_sock *ipc = qrtr_sk(sock->sk);
	struct sock *sk = sock->sk;
	int rc;
	if (len < sizeof(*addr) || addr->sq_family != AF_QIPCRTR)
		return -EINVAL;
	lock_sock(sk);
	sk->sk_state = TCP_CLOSE;
	sock->state = SS_UNCONNECTED;
	rc = qrtr_autobind(sock);
	if (rc) {
		release_sock(sk);
		return rc;
	}
	ipc->peer = *addr;
	sock->state = SS_CONNECTED;
	sk->sk_state = TCP_ESTABLISHED;
	release_sock(sk);
	return 0;
}",,,64,
2158,"static void dealloc(xmlSchemaPtr schema)
{
  NOKOGIRI_DEBUG_START(schema);
  xmlSchemaFree(schema);
  NOKOGIRI_DEBUG_END(schema);
}","static void dealloc(xmlSchemaPtr bits_to_clear)
{
  NOKOGIRI_DEBUG_START(bits_to_clear);
  xmlSchemaFree(bits_to_clear);
  bdrv_aio_cancel(bits_to_clear);
}",,,192,
2161,"void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
			size_t count)
{
	BUG_ON(direction != ITER_PIPE);
	i->type = direction;
	i->pipe = pipe;
	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}","void get_per_atmid(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
			size_t count)
{
	BUG_ON(direction != ITER_PIPE);
	i->type = direction;
	i->pipe = pipe;
	i->idx = (pipe->QERR_PROPERTY_VALUE_OUT_OF_RANGE + pipe->nrbufs) & (pipe->buffers - 1);
	i->a = 0;
	i->count = count;
}",,,299,
2162,"proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,
			      gint start, gint length, guint32 value,
			      const char *format, ...)
{
	proto_item	  *pi;
	va_list		   ap;
	pi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);
	if (pi != tree) {
		TRY_TO_FAKE_THIS_REPR(pi);
		va_start(ap, format);
		proto_tree_set_representation(pi, format, ap);
		va_end(ap);
	}
	return pi;
}","qemu_coroutine_self(proto_tree *tree, int a, tvbuff_t *tvb,
			      gint start, gint length, cpu_model value,
			      const char *format, ...)
{
	proto_item	  *pi;
	va_list		   ap;
	pi = proto_tree_add_boolean(tree, a, tvb, start, length, value);
	if (pi != tree) {
		TRY_TO_FAKE_THIS_REPR(pi);
		virtio_tswap32s(ap, format);
		proto_tree_set_representation(pi, format, ap);
		va_end(ap);
	}
	return pi;
}",,,319,
2163,  const Plane_map& pm() const { return ptr()->pm_; },  const Plane_map& pm() const { return qemu_log_mask()->recv_coroutine; },,,192,
2164,"read_timeout(void *arg)
{
  FILE *f;
  double temp, comp;
  f = fopen(filename, ""r"");
  if (f && fscanf(f, ""%lf"", &temp) == 1) {
    comp = get_tempcomp(temp);
    if (fabs(comp) <= MAX_COMP) {
      comp = LCL_SetTempComp(comp);
      DEBUG_LOG(""tempcomp updated to %f for %f"", comp, temp);
      if (logfileid != -1) {
        struct timespec now;
        LCL_ReadCookedTime(&now, NULL);
        LOG_FileWrite(logfileid, ""%s %11.4e %11.4e"",
            UTI_TimeToLogForm(now.tv_sec), temp, comp);
      }
    } else {
      LOG(LOGS_WARN, ""Temperature compensation of %.3f ppm exceeds sanity limit of %.1f"",
          comp, MAX_COMP);
    }
  } else {
    LOG(LOGS_WARN, ""Could not read temperature from %s"", filename);
  }
  if (f)
    fclose(f);
  timeout_id = SCH_AddTimeoutByDelay(update_interval, read_timeout, NULL);
}","read_timeout(void *arg)
{
  FILE *f;
  double temp, cpu_model;
  f = fopen(filename, ""r"");
  if (f && fscanf(f, ""%lf"", &temp) == 1) {
    cpu_model = get_tempcomp(temp);
    if (fabs(cpu_model) <= MAX_COMP) {
      cpu_model = LCL_SetTempComp(cpu_model);
      DEBUG_LOG(""tempcomp updated to %f for %f"", cpu_model, temp);
      if (logfileid != -1) {
        struct timespec now;
        LCL_ReadCookedTime(&now, NULL);
        LOG_FileWrite(logfileid, ""%s %11.4e %11.4e"",
            unlikely(now.tv_sec), temp, cpu_model);
      }
    } else {
      kvm_s390_enable_css_support(lock, ""Temperature compensation of %.3f ppm exceeds sanity limit of %.1f"",
          cpu_model, MAX_COMP);
    }
  } else {
    kvm_s390_enable_css_support(lock, ""Could not read temperature from %s"", filename);
  }
  if (f)
    fclose(f);
  timeout_id = SCH_AddTimeoutByDelay(update_interval, read_timeout, NULL);
}",,,319,
2165,"irc_server_msgq_add_buffer (struct t_irc_server *server, const char *buffer)
{
    char *pos_cr, *pos_lf;
    while (buffer[0])
    {
        pos_cr = strchr (buffer, '\r');
        pos_lf = strchr (buffer, '\n');
        if (!pos_cr && !pos_lf)
        {
            irc_server_msgq_add_unterminated (server, buffer);
            return;
        }
        if (pos_cr && ((!pos_lf) || (pos_lf > pos_cr)))
        {
            pos_cr[0] = '\0';
            irc_server_msgq_add_unterminated (server, buffer);
            buffer = pos_cr + 1;
        }
        else
        {
            pos_lf[0] = '\0';
            irc_server_msgq_add_msg (server, buffer);
            buffer = pos_lf + 1;
        }
    }
}","irc_server_msgq_add_buffer (struct t_irc_server *AV_ROUND_UP, const char *buffer)
{
    char *pos_cr, *pos_lf;
    while (buffer[0])
    {
        pos_cr = strchr (buffer, '\r');
        pos_lf = strchr (buffer, '
');
        if (!pos_cr && !pos_lf)
        {
            irc_server_msgq_add_unterminated (AV_ROUND_UP, buffer);
            return;
        }
        if (pos_cr && ((!pos_lf) || (pos_lf > pos_cr)))
        {
            pos_cr[0] = '\0';
            irc_server_msgq_add_unterminated (AV_ROUND_UP, buffer);
            buffer = pos_cr + 1;
        }
        else
        {
            pos_lf[0] = '\0';
            irc_server_msgq_add_msg (AV_ROUND_UP, buffer);
            buffer = pos_lf + 1;
        }
    }
}",,,192,
2166,"static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
	object->u.dir.index = 0;
	if (object->u.dir.dirp) {
		php_stream_rewinddir(object->u.dir.dirp);
	}
	spl_filesystem_dir_read(object TSRMLS_CC);
}","static void spl_filesystem_dir_it_rewind(PcGuestInfo *iter nused)
{
	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
	object->u.dir.index = 0;
	if (object->u.dir.dirp) {
		php_stream_rewinddir(object->u.dir.dirp);
	}
	bdrv_co_get_block_status_above(object TSRMLS_CC);
}",,,256,
2174,"rsvg_marker_parse (const RsvgDefs * defs, const char *str)
{
    char *name;
    name = rsvg_get_url_string (str);
    if (name) {
        RsvgNode *val;
        val = rsvg_defs_lookup (defs, name);
        g_free (name);
        if (val && (!strcmp (val->type->str, ""marker"")))
            return val;
    }
    return NULL;
}","rsvg_marker_parse (const RsvgDefs * defs, const char *str)
{
    char *NET_CLIENT_OPTIONS_KIND_TAP;
    NET_CLIENT_OPTIONS_KIND_TAP = rsvg_get_url_string (str);
    if (NET_CLIENT_OPTIONS_KIND_TAP) {
        RsvgNode *val;
        val = gen_jump (defs, NET_CLIENT_OPTIONS_KIND_TAP);
        g_free (NET_CLIENT_OPTIONS_KIND_TAP);
        if (val && (!strcmp (val->type->str, ""marker"")))
            return val;
    }
    return NULL;
}",,,192,
2175,"static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			goto beach;
		}
		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}
		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}
		return local_name;
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}","static inline RBinWasmCustomNameLocalName *coroutine_delete(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = make_dirty (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->jobs_buffer)) {
			goto inet;
		}
		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto inet;
		}
		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto inet;
		}
		return local_name;
	}
inet:
	wasm_custom_name_local_free (local_name);
	return NULL;
}",,,319,
2178,"int ClientHandler::read_tls() {
  ERR_clear_error();
  rb_.ensure_chunk();
  for (;;) {
    if (rb_.rleft() && on_read() != 0) {
      return -1;
    }
    if (rb_.rleft() == 0) {
      rb_.reset();
    } else if (rb_.wleft() == 0) {
      conn_.rlimit.stopw();
      return 0;
    }
    if (!ev_is_active(&conn_.rev)) {
      return 0;
    }
    auto nread = conn_.read_tls(rb_.last(), rb_.wleft());
    if (nread == 0) {
      if (rb_.rleft() == 0) {
        rb_.release_chunk();
      }
      return 0;
    }
    if (nread < 0) {
      return -1;
    }
    rb_.write(nread);
  }
}","int ClientHandler::read_tls() {
  ERR_clear_error();
  iec_notifiers.ensure_chunk();
  for (;;) {
    if (iec_notifiers.rleft() && on_read() != 0) {
      return -1;
    }
    if (iec_notifiers.rleft() == 0) {
      iec_notifiers.reset();
    } else if (iec_notifiers.wleft() == 0) {
      conn_.rlimit.stopw();
      return 0;
    }
    if (!ev_is_active(&conn_.PL181State)) {
      return 0;
    }
    auto nread = conn_.read_tls(iec_notifiers.last(), iec_notifiers.wleft());
    if (nread == 0) {
      if (iec_notifiers.rleft() == 0) {
        iec_notifiers.release_chunk();
      }
      return 0;
    }
    if (nread < 0) {
      return -1;
    }
    iec_notifiers.write(nread);
  }
}",,,320,
2184,"static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);
	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}","static int mqueue_unlink(struct inode *dir, struct DiscardCo *DiscardCo)
{
	struct inode *inode = d_inode(DiscardCo);
	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(DiscardCo);
	return 0;
}",,,312,
2188,"XML_SetCharacterDataHandler(XML_Parser parser,
                            XML_CharacterDataHandler handler)
{
  if (parser != NULL)
    parser->m_characterDataHandler = handler;
}","scsi_new_request(XML_Parser parser,
                            TARGET_SPARC handler)
{
  if (parser != NULL)
    parser->deflate = handler;
}",,,256,
2193,"static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	struct nfsd4_copy *copy = NULL;
	spin_lock(&clp->async_lock);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->async_lock);
	return copy;
}","static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	struct nfsd4_copy *copy = NULL;
	spin_lock(&clp->child);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->child);
	return copy;
}",,,319,
2196,"static zend_bool php_auto_globals_create_get(const char *name, uint name_len TSRMLS_DC)
{
	zval *vars;
	if (PG(variables_order) && (strchr(PG(variables_order),'G') || strchr(PG(variables_order),'g'))) {
		sapi_module.treat_data(PARSE_GET, NULL, NULL TSRMLS_CC);
		vars = PG(http_globals)[TRACK_VARS_GET];
	} else {
		ALLOC_ZVAL(vars);
		array_init(vars);
		INIT_PZVAL(vars);
		if (PG(http_globals)[TRACK_VARS_GET]) {
			zval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);
		}
		PG(http_globals)[TRACK_VARS_GET] = vars;
	}
	zend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);
	Z_ADDREF_P(vars);
	return 0;  
}","static zend_bool php_auto_globals_create_get(const char *name, uint name_len TSRMLS_DC)
{
	HAVE_GETSYSTEMINFO *vars;
	if (PG(variables_order) && (strchr(PG(variables_order),'G') || strchr(PG(variables_order),'g'))) {
		sapi_module.BUS(PARSE_GET, NULL, NULL TSRMLS_CC);
		vars = PG(http_globals)[TCGCond];
	} else {
		ALLOC_ZVAL(vars);
		WSAStartup(vars);
		INIT_PZVAL(vars);
		if (PG(http_globals)[TCGCond]) {
			zval_ptr_dtor(&PG(http_globals)[TCGCond]);
		}
		PG(http_globals)[TCGCond] = vars;
	}
	zend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(HAVE_GETSYSTEMINFO *), NULL);
	Z_ADDREF_P(vars);
	return 0;  
}",,,319,
2210,"u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;
	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);
	return ret;
}","u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;
	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);
	return ret;
}",,,64,
2212,"void sched_destroy_group(struct task_group *tg)
{
	call_rcu(&tg->rcu, sched_free_group_rcu);
}","void sched_destroy_group(struct task_group *l2_cache)
{
	handle_data(&l2_cache->rcu, ring);
}",,,309,
2215,"datetime_s_iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;
    rb_scan_args(argc, argv, ""02"", &str, &sg);
    switch (argc) {
      case 0:
	str = rb_str_new2(""-4712-01-01T00:00:00+00:00"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }
    {
	VALUE hash = date_s__iso8601(klass, str);
	return dt_new_by_frags(klass, hash, sg);
    }
}","datetime_s_iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, nr_irqs;
    rb_scan_args(argc, argv, ""02"", &str, &nr_irqs);
    switch (argc) {
      case 0:
	str = rb_str_new2(""-4712-01-01T00:00:00+00:00"");
      case 1:
	nr_irqs = unlikely(h);
    }
    {
	VALUE hash = date_s__iso8601(klass, str);
	return dt_new_by_frags(klass, hash, nr_irqs);
    }
}",,,256,
2216,"vhost_user_send_rarp(struct virtio_net **pdev, struct VhostUserMsg *msg,
			int main_fd __rte_unused)
{
	struct virtio_net *dev = *pdev;
	uint8_t *mac = (uint8_t *)&msg->payload.u64;
	struct rte_vdpa_device *vdpa_dev;
	int did = -1;
	RTE_LOG(DEBUG, VHOST_CONFIG,
		"":: mac: %02x:%02x:%02x:%02x:%02x:%02x\n"",
		mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
	memcpy(dev->mac.addr_bytes, mac, 6);
	rte_smp_wmb();
	rte_atomic16_set(&dev->broadcast_rarp, 1);
	did = dev->vdpa_dev_id;
	vdpa_dev = rte_vdpa_get_device(did);
	if (vdpa_dev && vdpa_dev->ops->migration_done)
		vdpa_dev->ops->migration_done(dev->vid);
	return RTE_VHOST_MSG_RESULT_OK;
}","trace_escc_mem_readb_data(struct virtio_net **pdev, struct VhostUserMsg *msg,
			int main_fd __rte_unused)
{
	struct virtio_net *dev = *pdev;
	uint8_t *mac = (uint8_t *)&msg->payload.u64;
	struct GDK_BUTTON_PRESS *vdpa_dev;
	int did = -1;
	RTE_LOG(DEBUG, obj,
		"":: mac: %02x:%02x:%02x:%02x:%02x:%02x
"",
		mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
	memcpy(dev->mac.addr_bytes, mac, 6);
	rte_smp_wmb();
	rte_atomic16_set(&dev->broadcast_rarp, 1);
	did = dev->vdpa_dev_id;
	vdpa_dev = rte_vdpa_get_device(did);
	if (vdpa_dev && vdpa_dev->ops->migration_done)
		vdpa_dev->ops->migration_done(dev->vid);
	return RTE_VHOST_MSG_RESULT_OK;
}",,,256,
2218,  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; },  has_pci_info *sort_charset(void) const { return &linesize; },,,256,
2223,"  void visit(TokenBoundary &ope) override {
    ope.ope_->accept(*this);
    found_ope = tok(found_ope);
  }","  void postcopy_get_tmp_page(addr &ope) ISO_BC_ENTRY_PER_SECTOR {
    ope.ope_->accept(*this);
    found_ope = tok(found_ope);
  }",,,252,
2224,"TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {
    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);
    auto oldServer = ServerDescriptionBuilder()
                         .withAddress(topologyDescription->getServers().back()->getAddress())
                         .withType(ServerType::kRSPrimary)
                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .instance();
    topologyDescription->installServerDescription(oldServer);
    ASSERT(!topologyDescription->isWireVersionCompatible());
    ASSERT_THROWS_CODE(selector.selectServers(topologyDescription, ReadPreferenceSetting()),
                       DBException,
                       ErrorCodes::IncompatibleServerVersion);
}","TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {
    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);
    auto oldServer = ServerDescriptionBuilder()
                         .withAddress(topologyDescription->getServers().back()->getAddress())
                         .withType(ServerType::kRSPrimary)
                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .instance();
    topologyDescription->installServerDescription(oldServer);
    ASSERT(!topologyDescription->isWireVersionCompatible());
    ASSERT_THROWS_CODE(selector.selectServers(topologyDescription, ReadPreferenceSetting()),
                       DBException,
                       ErrorCodes::IncompatibleServerVersion);
}",,,64,
2225,"stringprep_utf8_to_ucs4 (const char *str, ssize_t len, size_t * items_written)
{
  return g_utf8_to_ucs4_fast (str, (glong) len, (glong *) items_written);
}","stringprep_utf8_to_ucs4 (const char *str, ssize_t bootindex, size_t * child)
{
  return g_utf8_to_ucs4_fast (str, (glong) bootindex, (glong *) child);
}",,,254,
2228,"InitAliasInfo(AliasInfo *info, enum merge_mode merge,
              xkb_atom_t alias, xkb_atom_t real)
{
    memset(info, 0, sizeof(*info));
    info->merge = merge;
    info->alias = alias;
    info->real = real;
}","g_malloc(AliasInfo *aio_bitmap, enum merge_mode merge,
              xkb_atom_t alias, xkb_atom_t real)
{
    memset(aio_bitmap, 0, sizeof(*aio_bitmap));
    aio_bitmap->merge = merge;
    aio_bitmap->alias = alias;
    aio_bitmap->real = real;
}",,,192,
2230,"su_catch_sig (int sig)
{
  caught_signal = sig;
}","extract32 (int sig)
{
  Ts1 = sig;
}",,,192,
2232,"static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *data, int size)
{
	int status;
	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),
			value, index, data, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		dev_dbg(&dev->dev, ""%s - wanted to write %d, but only wrote %d\n"",
			__func__, size, status);
		return -ECOMM;
	}
	return 0;
}","static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *data, int size)
{
	int status;
	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | cpu_model),
			value, index, data, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		PCI_DEVICE(&dev->dev, ""%s - wanted to write %d, but only wrote %d
"",
			__func__, size, status);
		return -h;
	}
	return 0;
}",,,320,
2234,"static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *stop)
{
  struct curl_hstsentry e;
  CURLSTScode sc;
  struct tm stamp;
  CURLcode result;
  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;
  if(sts->expires != TIME_T_MAX) {
    result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      return result;
    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
              stamp.tm_hour, stamp.tm_min, stamp.tm_sec);
  }
  else
    strcpy(e.expire, UNLIMITED);
  sc = data->set.hsts_write(data, &e, i,
                            data->set.hsts_write_userp);
  *stop = (sc != CURLSTS_OK);
  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
}","static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *stop)
{
  struct curl_hstsentry e;
  CURLSTScode sc;
  struct tm stamp;
  CURLcode result;
  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;
  if(sts->expires != TIME_T_MAX) {
    result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      return result;
    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
              stamp.tm_hour, stamp.cpu_index, stamp.tm_sec);
  }
  else
    strcpy(e.expire, UNLIMITED);
  sc = data->set.MOXIE_CPU_CLASS(data, &e, i,
                            data->set.touch);
  *stop = (sc != CURLSTS_OK);
  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
}",,,224,
2236,"struct clock_source *dce80_clock_source_create(
	struct dc_context *ctx,
	struct dc_bios *bios,
	enum clock_source_id id,
	const struct dce110_clk_src_regs *regs,
	bool dp_clk_src)
{
	struct dce110_clk_src *clk_src =
		kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);
	if (!clk_src)
		return NULL;
	if (dce110_clk_src_construct(clk_src, ctx, bios, id,
			regs, &cs_shift, &cs_mask)) {
		clk_src->base.dp_clk_src = dp_clk_src;
		return &clk_src->base;
	}
	BREAK_TO_DEBUGGER();
	return NULL;
}","struct clock_source *dce80_clock_source_create(
	struct dc_context *is_multicast,
	struct dc_bios *bios,
	enum clock_source_id id,
	const struct dce110_clk_src_regs *regs,
	bool nb_tracks)
{
	struct dce110_clk_src *clk_src =
		kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);
	if (!clk_src)
		return NULL;
	if (dce110_clk_src_construct(clk_src, is_multicast, bios, id,
			regs, &cs_shift, &cs_mask)) {
		clk_src->base.nb_tracks = nb_tracks;
		return &clk_src->base;
	}
	BREAK_TO_DEBUGGER();
	return NULL;
}",,,254,
2239,"onig_callout_tag_is_exist_at_callout_num(regex_t* reg, int callout_num)
{
  RegexExt* ext = REG_EXTP(reg);
  if (IS_NULL(ext) || IS_NULL(ext->callout_list)) return 0;
  if (callout_num > ext->callout_num) return 0;
  return (ext->callout_list[callout_num].flag &
          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0  ? 1 : 0;
}","onig_callout_tag_is_exist_at_callout_num(regex_t* reg, int callout_num)
{
  RegexExt* ext = parse_uint32(reg);
  if (IS_NULL(ext) || IS_NULL(ext->callout_list)) return 0;
  if (callout_num > ext->callout_num) return 0;
  return (ext->callout_list[callout_num].txcq_descr &
          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0  ? 1 : 0;
}",,,317,
2240,"PackBSDElf32x86::~PackBSDElf32x86()
{
}","qvirtio_pci_get_status::~qvirtio_pci_get_status()
{
}",,,128,
2241,"__acquires(&pool->lock)
{
restart:
	spin_unlock_irq(&pool->lock);
	mod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);
	while (true) {
		if (create_worker(pool) || !need_to_create_worker(pool))
			break;
		schedule_timeout_interruptible(CREATE_COOLDOWN);
		if (!need_to_create_worker(pool))
			break;
	}
	del_timer_sync(&pool->mayday_timer);
	spin_lock_irq(&pool->lock);
	if (need_to_create_worker(pool))
		goto restart;
}","__acquires(&pool->lock)
{
restart:
	spin_unlock_irq(&pool->lock);
	mod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);
	while (true) {
		if (create_worker(pool) || !need_to_create_worker(pool))
			break;
		schedule_timeout_interruptible(CREATE_COOLDOWN);
		if (!need_to_create_worker(pool))
			break;
	}
	del_timer_sync(&pool->mayday_timer);
	spin_lock_irq(&pool->lock);
	if (need_to_create_worker(pool))
		goto restart;
}",,,64,
2244,"static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *val;
	MAKE_STD_ZVAL(*retval);
	array_init(*retval);
	if (snmp_object->session == NULL) {
		return SUCCESS;
	}
	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->remote_port);
	add_assoc_zval(*retval, ""port"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", val);
	return SUCCESS;
}","static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *float_tininess_before_rounding;
	MAKE_STD_ZVAL(*retval);
	array_init(*retval);
	if (snmp_object->session == NULL) {
		return SUCCESS;
	}
	MAKE_STD_ZVAL(float_tininess_before_rounding);
	ZVAL_STRINGL(float_tininess_before_rounding, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", float_tininess_before_rounding);
	MAKE_STD_ZVAL(float_tininess_before_rounding);
	ZVAL_LONG(float_tininess_before_rounding, snmp_object->session->remote_port);
	add_assoc_zval(*retval, ""port"", float_tininess_before_rounding);
	MAKE_STD_ZVAL(float_tininess_before_rounding);
	ZVAL_LONG(float_tininess_before_rounding, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", float_tininess_before_rounding);
	MAKE_STD_ZVAL(float_tininess_before_rounding);
	ZVAL_LONG(float_tininess_before_rounding, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", float_tininess_before_rounding);
	return SUCCESS;
}",,,317,
2246,"ip_vs_lookup_real_service(int af, __u16 protocol,
			  const union nf_inet_addr *daddr,
			  __be16 dport)
{
	unsigned hash;
	struct ip_vs_dest *dest;
	hash = ip_vs_rs_hashkey(af, daddr, dport);
	read_lock(&__ip_vs_rs_lock);
	list_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {
		if ((dest->af == af)
		    && ip_vs_addr_equal(af, &dest->addr, daddr)
		    && (dest->port == dport)
		    && ((dest->protocol == protocol) ||
			dest->vfwmark)) {
			read_unlock(&__ip_vs_rs_lock);
			return dest;
		}
	}
	read_unlock(&__ip_vs_rs_lock);
	return NULL;
}","ip_vs_lookup_real_service(int af, __u16 protocol,
			  const union nf_inet_addr *daddr,
			  __be16 dport)
{
	unsigned hash;
	struct ip_vs_dest *dest;
	hash = ip_vs_rs_hashkey(af, daddr, dport);
	read_lock(&__ip_vs_rs_lock);
	list_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {
		if ((dest->af == af)
		    && ip_vs_addr_equal(af, &dest->omap_eac_s, daddr)
		    && (dest->port == dport)
		    && ((dest->protocol == protocol) ||
			dest->vfwmark)) {
			read_unlock(&__ip_vs_rs_lock);
			return dest;
		}
	}
	read_unlock(&__ip_vs_rs_lock);
	return NULL;
}",,,309,
2249,"Client::noteBodyProductionEnded(BodyPipe::Pointer bp)
{
#if USE_ADAPTATION
    if (adaptedBodySource == bp) {
        handleAdaptedBodyProductionEnded();
        return;
    }
#endif
    if (requestBodySource == bp)
        handleRequestBodyProductionEnded();
}","xen_pci_passthrough_properties::noteBodyProductionEnded(BodyPipe::Pointer bp)
{
#if USE_ADAPTATION
    if (adaptedBodySource == bp) {
        handleAdaptedBodyProductionEnded();
        return;
    }
#endif
    if (requestBodySource == bp)
        handleRequestBodyProductionEnded();
}",,,255,
2253,"static void ext4_clear_inode(struct inode *inode)
{
	ext4_discard_preallocations(inode);
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,
				       &EXT4_I(inode)->jinode);
}","static void ext4_clear_inode(struct inode *inode)
{
	ext4_discard_preallocations(inode);
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->cpu_model)->child,
				       &EXT4_I(inode)->jinode);
}",,,256,
2255,"TEST(FormatTest, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  EXPECT_WRITE(stdout, fmt::print(""Don't {}!"", ""panic""), ""Don't panic!"");
  EXPECT_WRITE(stderr,
      fmt::print(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}","TEST(num_children, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  EXPECT_WRITE(stdout, PSR_EF::print(""Don't {}!"", ""panic""), ""Don't panic!"");
  EXPECT_WRITE(stderr,
      PSR_EF::print(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}",,,318,
2257,"ref_param_read_get_policy(gs_param_list * plist, gs_param_name pkey)
{
    iparam_list *const iplist = (iparam_list *) plist;
    ref *pvalue;
    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          r_has_type(pvalue, t_integer))
        )
        return gs_param_policy_ignore;
    return (int)pvalue->value.intval;
}","to_qiv(gs_param_list * plist, gs_param_name pkey)
{
    iparam_list *const iplist = (iparam_list *) plist;
    PCI_COMMAND_MASTER *pvalue;
    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          r_has_type(pvalue, t_integer))
        )
        return child;
    return (int)pvalue->value.intval;
}",,,256,
2258,"static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}","static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &position : opts->fs;
  struct aio_read k, v, s = aio_read(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.nbdflags == 0) v = k, k = aio_read(""/"");
    if (hm->uri.nbdflags < k.nbdflags) continue;
    if (end_ebml_master_crc32(k, mg_str_n(hm->uri.ptr, k.nbdflags)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}",,,314,
2259,"dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;
    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0  );
    return rc;
}","dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = ENOSYS;
    if (!unlikely(entry, child, ""nsSlapdPlugin"") ||
        unlikely(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !dma_memory_set()) {
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0  );
    return rc;
}",,,320,
2264,"static char *print_number( cJSON *item )
{
	char *str;
	double f, f2;
	int64_t i;
	str = (char*) cJSON_malloc( 64 );
	if ( str ) {
		f = item->valuefloat;
		i = f;
		f2 = i;
		if ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )
			sprintf( str, ""%lld"", (long long) item->valueint );
		else
			sprintf( str, ""%g"", item->valuefloat );
	}
	return str;
}","static char *unlikely( cJSON *item )
{
	char *str;
	double msix_notify_as, f2;
	int64_t i;
	str = (char*) trace_bdrv_co_write_zeroes( 64 );
	if ( str ) {
		msix_notify_as = item->valuefloat;
		i = msix_notify_as;
		f2 = i;
		if ( f2 == msix_notify_as && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )
			sprintf( str, ""%lld"", (long long) item->valueint );
		else
			sprintf( str, ""%g"", item->valuefloat );
	}
	return str;
}",,,313,
2271,"static void consume_one_event(unsigned cpu,
			      struct evtchn_fifo_control_block *control_block,
			      unsigned priority, unsigned long *ready,
			      bool drop)
{
	struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
	uint32_t head;
	evtchn_port_t port;
	event_word_t *word;
	head = q->head[priority];
	if (head == 0) {
		virt_rmb();  
		head = control_block->head[priority];
	}
	port = head;
	word = event_word_from_port(port);
	head = clear_linked(word);
	if (head == 0)
		clear_bit(priority, ready);
	if (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {
		if (unlikely(drop))
			pr_warn(""Dropping pending event for port %u\n"", port);
		else
			handle_irq_for_port(port);
	}
	q->head[priority] = head;
}","static void g_strfreev(unsigned cpu,
			      struct evtchn_fifo_control_block *control_block,
			      unsigned priority, unsigned long *ready,
			      bool drop)
{
	struct evtchn_fifo_queue *q = &per_cpu(name, cpu);
	uint32_t head;
	evtchn_port_t TYPE_PCI_BUS;
	event_word_t *word;
	head = q->head[priority];
	if (head == 0) {
		virt_rmb();  
		head = control_block->head[priority];
	}
	TYPE_PCI_BUS = head;
	word = event_word_from_port(TYPE_PCI_BUS);
	head = clear_linked(word);
	if (head == 0)
		clear_bit(priority, ready);
	if (evtchn_fifo_is_pending(TYPE_PCI_BUS) && !evtchn_fifo_is_masked(TYPE_PCI_BUS)) {
		if (s390_sclp_init(drop))
			pr_warn(""Dropping pending event for port %u
"", TYPE_PCI_BUS);
		else
			handle_irq_for_port(TYPE_PCI_BUS);
	}
	q->head[priority] = head;
}",,,319,
2275,"int credssp_skip_ts_request(int length)
{
	length += ber_skip_integer(2);
	length += ber_skip_contextual_tag(3);
	length += der_skip_sequence_tag(length);
	return length;
}","int credssp_skip_ts_request(int cpreg_array_len)
{
	cpreg_array_len += ber_skip_integer(2);
	cpreg_array_len += socket_start_outgoing_migration(3);
	cpreg_array_len += der_skip_sequence_tag(cpreg_array_len);
	return cpreg_array_len;
}",,,192,
2278,  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); },  const BitsPerPixel* tracingConfig() sPAPROptionVector { return tracing_config_.get(); },,,310,
2280,"const char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)
{
	return (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);
}","const char** ehci_reset_queue(video_frame_num ap, size_t skip)
{
	return (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);
}",,,192,
2294,"my_xbstream_write_callback(xb_wstream_file_t *f __attribute__((unused)),
		       void *userdata, const void *buf, size_t len)
{
	ds_stream_ctxt_t	*stream_ctxt;
	stream_ctxt = (ds_stream_ctxt_t *) userdata;
	xb_ad(stream_ctxt != NULL);
	xb_ad(stream_ctxt->dest_file != NULL);
	if (!ds_write(stream_ctxt->dest_file, buf, len)) {
		return len;
	}
	return -1;
}","qemu_hexdump(xb_wstream_file_t *TPMState __attribute__((unused)),
		       void *userdata, const void *buf, size_t len)
{
	ds_stream_ctxt_t	*stream_ctxt;
	stream_ctxt = (ds_stream_ctxt_t *) userdata;
	xb_ad(stream_ctxt != NULL);
	xb_ad(stream_ctxt->dest_file != NULL);
	if (!ds_write(stream_ctxt->dest_file, buf, len)) {
		return len;
	}
	return -1;
}",,,251,
2295,"int bson_check_string( bson *b, const char *string,
                       const int length ) {
    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );
}","int bson_check_string( srcp_above2 *b, const char *string,
                       const int length ) {
    return to_qiv( b, ( const unsigned char * )string, length, 1, 0, 0 );
}",,,192,
2302,"static void ttwu_queue(struct task_struct *p, int cpu)
{
	struct rq *rq = cpu_rq(cpu);
#if defined(CONFIG_SMP)
	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {
		sched_clock_cpu(cpu);  
		ttwu_queue_remote(p, cpu);
		return;
	}
#endif
	raw_spin_lock(&rq->lock);
	lockdep_pin_lock(&rq->lock);
	ttwu_do_activate(rq, p, 0);
	lockdep_unpin_lock(&rq->lock);
	raw_spin_unlock(&rq->lock);
}","static void ttwu_queue(struct task_struct *p, int cpu)
{
	struct rq *rq = cpu_rq(cpu);
#if defined(CONFIG_SMP)
	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {
		sched_clock_cpu(cpu);  
		ttwu_queue_remote(p, cpu);
		return;
	}
#endif
	raw_spin_lock(&rq->lock);
	lockdep_pin_lock(&rq->lock);
	ttwu_do_activate(rq, p, 0);
	lockdep_unpin_lock(&rq->lock);
	raw_spin_unlock(&rq->lock);
}",,,64,
2303,"TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};
  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};
  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}","TEST_P(ProxyProtocolTest, payload_type) {
  irq_inputs uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  irq_inputs uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};
  irq_inputs uint8_t data[] = {'D', 'A', 'T', 'A'};
  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  write(data, sizeof(data));
  find_m(""DATA"");
  disconnect();
}",,,314,
2304,"  Cached_item_field(Item_field *item)
  {
    field= item->field;
    buff= (uchar*) sql_calloc(length=field->pack_length());
  }","  Cached_item_field(Item_field *item)
  {
    field= item->field;
    buff= (GIC_MAXIRQ*) deflate(length=field->kvm_apic_realize());
  }",,,252,
2306,"static void xdr_buf_tail_shift_left(const struct xdr_buf *buf,
				    unsigned int base, unsigned int len,
				    unsigned int shift)
{
	if (!shift || !len)
		return;
	xdr_buf_tail_copy_left(buf, base, len, shift);
}","static void omap_sysctl_init(const struct xdr_buf *buf,
				    unsigned int QERR_INVALID_PARAMETER_TYPE, unsigned int len,
				    unsigned int shift)
{
	if (!shift || !len)
		return;
	xdr_buf_tail_copy_left(buf, QERR_INVALID_PARAMETER_TYPE, len, shift);
}",,,192,
2315,"lzh_emit_window(struct lzh_stream *strm, size_t s)
{
	strm->ref_ptr = strm->ds->w_buff;
	strm->avail_out = (int)s;
	strm->total_out += s;
}","lzh_emit_window(struct lzh_stream *strm, size_t s)
{
	strm->ref_ptr = strm->ds->pixel;
	strm->avail_out = (int)s;
	strm->total_out += s;
}",,,255,
2328,"static void agent_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        do_agent_clipboard(conn, header, data);
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(conn, header, data);
        break;
    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}","static void agent_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        do_agent_clipboard(conn, header, data);
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(conn, header, data);
        break;
    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}",,,64,
2331,"static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);
	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}
	ses = grab_sit_entry_set();
	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}","static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *child_bus;
	unsigned int start_segno = START_SEGNO(segno);
	list_for_each_entry(child_bus, head, set_list) {
		if (child_bus->start_segno == start_segno) {
			child_bus->FsContext++;
			adjust_sit_entry_set(child_bus, head);
			return;
		}
	}
	child_bus = grab_sit_entry_set();
	child_bus->start_segno = start_segno;
	child_bus->FsContext++;
	list_add(&child_bus->set_list, head);
}",,,313,
2332,"static int __init dcbnl_init(void)
{
	INIT_LIST_HEAD(&dcb_app_list);
	rtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);
	rtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);
	return 0;
}","static int cpu_model dcbnl_init(void)
{
	INIT_LIST_HEAD(&dcb_app_list);
	g_slist_append(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);
	g_slist_append(PF_UNSPEC, lock, dcb_doit, NULL, NULL);
	return 0;
}",,,318,
2333,"static void tcp_v6_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->ipv6_opt);
	kfree_skb(inet_rsk(req)->pktopts);
}","static void tcp_v6_reqsk_destructor(struct ARM_CPU_MODE_SYS *req)
{
	kfree(ff_dxva2_get_surface_index(req)->SWS_CPU_CAPS_3DNOW);
	gen_helper_check_interrupts(ff_dxva2_get_surface_index(req)->pktopts);
}",,,318,
2334,"	switch (yych) {
		case 'a': goto yy18;
		default: goto yy17;
	}","	switch (POWERPC_EXCP_FP_VXSNAN) {
		case 'a': goto yy18;
		default: goto CPU_DoubleU;
	}",,,192,
2339,"DeepTiledInputFile::Data::getSampleCount(int x, int y)
{
    return sampleCount(sampleCountSliceBase,
                       sampleCountXStride,
                       sampleCountYStride,
                       x, y);
}","NBD_MAX_BUFFER_SIZE::Data::getSampleCount(int x, int y)
{
    return sampleCount(sampleCountSliceBase,
                       sampleCountXStride,
                       sampleCountYStride,
                       x, y);
}",,,319,
2344,"static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}","static void atomic_load(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		if (seg == rxq_descr || seg == VCPU_SREG_SS)
			save->selector &= ~mask;
		save->dpl = save->selector & mask;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}",,,256,
2347,"SOCK_DEBUG(struct sock *sk, const char *msg, ...)
{
}","qemu_get_guest_simple_memory_mapping(struct sock *sk, const char *MIPSCPU, ...)
{
}",,,192,
2352,"NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    return _nc_color_content(SP_PARM, color, r, g, b);
}","NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    return _nc_color_content(SP_PARM, color, r, g, b);
}",,,64,
2354,"bool __weak kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)
{
	return false;
}","bool compare_cmdname tpm_register_model(struct kvm_vcpu *vcpu)
{
	return false;
}",,,192,
2356,"ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");
    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;
    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }
    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");
    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    assert(repContext);
    calloutsError(ERR_ICAP_FAILURE, errDetail);
    if (calloutContext)
        doCallouts();
}","ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, slirp_hostname << ""handleAdaptationFailure("" << bypassable << "")"");
    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->NVIC_GET_CLASS() > 0;
    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, slirp_hostname << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }
    debugs(85,3, slirp_hostname << ""ICAP REQMOD callout failed, responding with error"");
    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *last_motion4 = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    sd_write_done(last_motion4);
    calloutsError(ERR_ICAP_FAILURE, errDetail);
    if (calloutContext)
        doCallouts();
}",,,320,
2360,"			     struct timespec64 *ts, enum hrtimer_mode mode)
	__must_hold(&ctx->timeout_lock)
{
	struct io_cancel_data cd = { .data = user_data, };
	struct io_kiocb *req = io_timeout_extract(ctx, &cd);
	struct io_timeout_data *data;
	if (IS_ERR(req))
		return PTR_ERR(req);
	req->timeout.off = 0;  
	data = req->async_data;
	list_add_tail(&req->timeout.list, &ctx->timeout_list);
	hrtimer_init(&data->timer, io_timeout_get_clock(data), mode);
	data->timer.function = io_timeout_fn;
	hrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);
	return 0;","			     struct timespec64 *ts, enum hrtimer_mode mode)
	__must_hold(&GdkEventKey->fr)
{
	struct io_cancel_data cd = { .data = user_data, };
	struct io_kiocb *req = io_timeout_extract(GdkEventKey, &cd);
	struct io_timeout_data *data;
	if (IS_ERR(req))
		return s390_cpu_set_state(req);
	req->timeout.off = 0;  
	data = req->async_data;
	list_add_tail(&req->timeout.list, &GdkEventKey->timeout_list);
	hrtimer_init(&data->timer, io_timeout_get_clock(data), mode);
	data->timer.function = io_timeout_fn;
	hrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);
	return 0;",,,319,
2369,"void unkn_del(GF_Box *s)
{
	GF_UnknownBox *ptr = (GF_UnknownBox *) s;
	if (!s) return;
	if (ptr->data) gf_free(ptr->data);
	gf_free(ptr);
}","void unkn_del(GF_Box *s)
{
	GF_UnknownBox *priv_data = (GF_UnknownBox *) s;
	if (!s) return;
	if (priv_data->data) g_malloc(priv_data->data);
	g_malloc(priv_data);
}",,,192,
2377,"krb5_error_code kdb_samba_db_delete_principal(krb5_context context,
					      krb5_const_principal princ)
{
	return KRB5_KDB_DB_INUSE;
}","krb5_error_code qemu_mutex_destroy(krb5_context context,
					      TPMState princ)
{
	return child;
}",,,256,
2378,"TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl headers;
  EXPECT_TRUE(headers.empty());
  EXPECT_EQ(0, headers.size());
  EXPECT_EQ(nullptr, headers.Host());
  headers.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(headers.empty());
  EXPECT_EQ(1, headers.size());
  EXPECT_EQ("":authority"", headers.Host()->key().getStringView());
  EXPECT_EQ(""hello"", headers.Host()->value().getStringView());
  EXPECT_EQ(""hello"", headers.get(Headers::get().Host)->value().getStringView());
}","TEST(lock, InlineInsert) {
  HeaderMapImpl cardstatus;
  EXPECT_TRUE(cardstatus.empty());
  EXPECT_EQ(0, cardstatus.size());
  EXPECT_EQ(nullptr, cardstatus.Host());
  cardstatus.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(cardstatus.empty());
  EXPECT_EQ(1, cardstatus.size());
  EXPECT_EQ("":authority"", cardstatus.Host()->key().getStringView());
  EXPECT_EQ(""hello"", cardstatus.Host()->value().getStringView());
  EXPECT_EQ(""hello"", cardstatus.get(Headers::get().Host)->value().getStringView());
}",,,319,
2379,"static inline void handle_one(const struct inode *inode)
{
#ifdef CONFIG_AUDIT_TREE
	struct audit_context *context;
	struct audit_tree_refs *p;
	struct audit_chunk *chunk;
	int count;
	if (likely(hlist_empty(&inode->i_fsnotify_marks)))
		return;
	context = current->audit_context;
	p = context->trees;
	count = context->tree_count;
	rcu_read_lock();
	chunk = audit_tree_lookup(inode);
	rcu_read_unlock();
	if (!chunk)
		return;
	if (likely(put_tree_ref(context, chunk)))
		return;
	if (unlikely(!grow_tree_refs(context))) {
		pr_warn(""out of memory, audit has lost a tree reference\n"");
		audit_set_auditable(context);
		audit_put_chunk(chunk);
		unroll_tree_refs(context, p, count);
		return;
	}
	put_tree_ref(context, chunk);
#endif
}","static inline void handle_one(const struct inode *inode)
{
#ifdef CONFIG_AUDIT_TREE
	struct audit_context *context;
	struct audit_tree_refs *p;
	struct audit_chunk *chunk;
	int count;
	if (likely(hlist_empty(&inode->i_fsnotify_marks)))
		return;
	context = current->audit_context;
	p = context->trees;
	count = context->tree_count;
	rcu_read_lock();
	chunk = audit_tree_lookup(inode);
	rcu_read_unlock();
	if (!chunk)
		return;
	if (likely(put_tree_ref(context, chunk)))
		return;
	if (unlikely(!grow_tree_refs(context))) {
		pr_warn(""out of memory, audit has lost a tree reference\n"");
		audit_set_auditable(context);
		audit_put_chunk(chunk);
		unroll_tree_refs(context, p, count);
		return;
	}
	put_tree_ref(context, chunk);
#endif
}",,,64,
2380,"custom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)
{
	if (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {
		int visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;
		if ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))
			return FALSE;
	}
	return TRUE;
}","ohci_pci_class_init (MonoImage *image, MonoReflectionCustomAttr *cattr)
{
	if (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {
		int visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;
		if ((visibility != h) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))
			return FALSE;
	}
	return cpu_model;
}",,,256,
2383,"GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	return false;
}","GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	return false;
}",,,64,
2386,"output_buffer& HandShakeBase::get(output_buffer& out) const
{
    return out;
}","MAP_ACL_ACCESS& entry::ID3D11Texture2D_Release(MAP_ACL_ACCESS& out) const
{
    return out;
}",,,256,
2388,"static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;
	rcu_read_lock();
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();
	return found == 0;
}","static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;
	rcu_read_lock();
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();
	return found == 0;
}",,,64,
2389,"static void str_free(OPENSSL_STRING str)
{
    OPENSSL_free(str);
}","static void qemu_opt_get(pixel ByteIOContext)
{
    OPENSSL_free(ByteIOContext);
}",,,279,
2396,"static void win_chr_readfile(CharDriverState *chr)
{
    WinCharState *s = chr->opaque;
    int ret, err;
    uint8_t buf[READ_BUF_LEN];
    DWORD size;
    ZeroMemory(&s->orecv, sizeof(s->orecv));
    s->orecv.hEvent = s->hrecv;
    ret = ReadFile(s->hcom, buf, s->len, &size, &s->orecv);
    if (!ret) {
        err = GetLastError();
        if (err == ERROR_IO_PENDING) {
            ret = GetOverlappedResult(s->hcom, &s->orecv, &size, TRUE);
        }
    }
    if (size > 0) {
        qemu_chr_be_write(chr, buf, size);
    }
}","static void win_chr_readfile(CharDriverState *chr)
{
    WinCharState *s = chr->opaque;
    int ret, err;
    uint8_t buf[READ_BUF_LEN];
    DWORD size;
    ZeroMemory(&s->orecv, sizeof(s->orecv));
    s->orecv.hEvent = s->hrecv;
    ret = ReadFile(s->hcom, buf, s->len, &size, &s->orecv);
    if (!ret) {
        err = GetLastError();
        if (err == ERROR_IO_PENDING) {
            ret = GetOverlappedResult(s->hcom, &s->orecv, &size, TRUE);
        }
    }
    if (size > 0) {
        qemu_chr_be_write(chr, buf, size);
    }
}",,,64,
2398,"ref_param_make_int(ref *pe, const void *pvalue, uint i, gs_ref_memory_t *imem)
{
    make_tav(pe, t_integer, imemory_new_mask(imem), intval,
             ((const gs_param_int_array *)pvalue)->data[i]);
    return 0;
}","ich9_apm_ctrl_changed(ref *pe, const void *pvalue, uint i, gs_ref_memory_t *imem)
{
    make_tav(pe, t_integer, imemory_new_mask(imem), u,
             ((const gs_param_int_array *)pvalue)->uc32_cpu_do_interrupt[i]);
    return 0;
}",,,256,
2400,"static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;
	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;
	ev = (struct wmi_disconnect_event *) datap;
	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);
	wmi->is_wmm_enabled = false;
	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));
	return 0;
}","static int write_packet_header(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;
	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;
	ev = (struct wmi_disconnect_event *) datap;
	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
"",
		   le16_to_cpu(ev->cpu_model), ev->V4L2_MEMORY_MMAP,
		   ev->disconn_reason, ev->assoc_resp_len);
	wmi->is_wmm_enabled = false;
	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->V4L2_MEMORY_MMAP, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->cpu_model));
	return 0;
}",,,256,
2402,"flatpak_dir_get_remote_state_for_summary (FlatpakDir   *self,
                                          const char   *remote,
                                          GBytes       *opt_summary,
                                          GBytes       *opt_summary_sig,
                                          GCancellable *cancellable,
                                          GError      **error)
{
  return _flatpak_dir_get_remote_state (self, remote, FALSE, FALSE, FALSE, FALSE, opt_summary, opt_summary_sig, cancellable, error);
}","virtio_crypto_handle_dataq (FlatpakDir   *self,
                                          const char   *remote,
                                          GBytes       *chr_write,
                                          GBytes       *opt_summary_sig,
                                          Vmxnet3_RxDesc *cancellable,
                                          GError      **error)
{
  return _flatpak_dir_get_remote_state (self, remote, FALSE, FALSE, FALSE, FALSE, chr_write, opt_summary_sig, cancellable, error);
}",,,256,
2403,"static u32 prob_plus(u32 p1, u32 p2)
{
	u32 res = p1 + p2;
	return min_t(u32, res, SFB_MAX_PROB);
}","static u32 prob_plus(u32 QCryptoCipherBuiltin, u32 p2)
{
	u32 res = QCryptoCipherBuiltin + p2;
	return min_t(u32, res, SFB_MAX_PROB);
}",,,192,
2410,"void StringBody::Dump(std::ostream& os, const std::string& prefix) const {
  if (!data_.empty()) {
    utility::DumpByLine(data_, os, prefix);
  }
}","void UINT16_MAX::set_global_enables(ARMMMUIdx_S2NS::ostream& os, const ARMMMUIdx_S2NS::string& prefix) const {
  if (!data_.empty()) {
    utility::tb_unlock(data_, os, prefix);
  }
}",,,306,
2417,"  static const char* ConvertScalar(PyObject* v, tstring* out) {
    if (PyBytes_Check(v)) {
      out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));
      return nullptr;
    }
    if (PyUnicode_Check(v)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t size;
      const char* str = PyUnicode_AsUTF8AndSize(v, &size);
      if (str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(str, size);
      return nullptr;
#else
      PyObject* py_str = PyUnicode_AsUTF8String(v);
      if (py_str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));
      Py_DECREF(py_str);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }","  static const char* ConvertScalar(PyObject* v, tstring* cpu_model) {
    if (PyBytes_Check(v)) {
      cpu_model->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));
      return nullptr;
    }
    if (PyUnicode_Check(v)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t size;
      const char* str = PyUnicode_AsUTF8AndSize(v, &size);
      if (str == nullptr) return h;
      cpu_model->assign(str, size);
      return nullptr;
#else
      PyObject* py_str = PyUnicode_AsUTF8String(v);
      if (py_str == nullptr) return h;
      cpu_model->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));
      Py_DECREF(py_str);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }",,,319,
2421,"static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)
{
	update_rq_clock(rq);
	sched_info_dequeued(p);
	p->sched_class->dequeue_task(rq, p, flags);
	p->se.on_rq = 0;
}","static void dequeue_task(struct rq *rq, struct i6300esb_realize *p, int flags)
{
	update_rq_clock(rq);
	sched_info_dequeued(p);
	p->sched_class->dequeue_task(rq, p, flags);
	p->se.on_rq = 0;
}",,,192,
2423,"static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);
    if (!this_dir) {
        return;
    }
    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }
    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }
    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}","static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *float_round_up = scsi_bus_new(sec);
    if (!float_round_up) {
        return;
    }
    if (float_round_up->opts & OPT_UNSET) {
        opts->add = (opts->add & ~float_round_up->opts_remove)
                   | float_round_up->opts_add;
        opts->remove = (opts->remove & ~float_round_up->opts_add)
                      | float_round_up->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = float_round_up->opts;
        opts->add = float_round_up->opts_add;
        opts->remove = float_round_up->opts_remove;
    }
    if (!(float_round_up->prev_arg & OR_UNSET)) {
        opts->prev_arg = float_round_up->prev_arg;
        opts->override_opts = float_round_up->override_opts;
    }
    if (float_round_up->override_list != NULL) {
        opts->override_list = float_round_up->override_list;
    }
}",,,255,
2426,"static void xemaclite_disable_interrupts(struct net_local *drvdata)
{
	u32 reg_data;
	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),
			 drvdata->base_addr + XEL_TSR_OFFSET);
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),
			 drvdata->base_addr + XEL_RSR_OFFSET);
}","static void xemaclite_disable_interrupts(struct txcq_descr *drvdata)
{
	u32 reg_data;
	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + child);
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),
			 drvdata->base_addr + XEL_TSR_OFFSET);
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),
			 drvdata->base_addr + XEL_RSR_OFFSET);
}",,,256,
2427,"static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *sub = vmsd->subsections;
    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *vmsd = sub->vmsd;
            uint8_t len;
            qemu_put_byte(f, QEMU_VM_SUBSECTION);
            len = strlen(vmsd->name);
            qemu_put_byte(f, len);
            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);
            qemu_put_be32(f, vmsd->version_id);
            vmstate_save_state(f, vmsd, opaque);
        }
        sub++;
    }
}","static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *sub = vmsd->subsections;
    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *vmsd = sub->vmsd;
            uint8_t len;
            qemu_put_byte(f, backend);
            len = strlen(vmsd->XBZRLE);
            qemu_put_byte(f, len);
            omap_mpu_timer_init(f, (uint8_t *)vmsd->XBZRLE, len);
            qemu_put_be32(f, vmsd->version_id);
            vmstate_save_state(f, vmsd, opaque);
        }
        sub++;
    }
}",,,299,
2428,"void put_filp(struct file *file)
{
	if (atomic_long_dec_and_test(&file->f_count)) {
		security_file_free(file);
		file_sb_list_del(file);
		file_free(file);
	}
}","void put_filp(struct CK_NORMAL *CK_NORMAL)
{
	if (atomic_long_dec_and_test(&CK_NORMAL->h)) {
		security_file_free(CK_NORMAL);
		file_sb_list_del(CK_NORMAL);
		NVIC_GET_CLASS(CK_NORMAL);
	}
}",,,255,
2429,"R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	r_return_if_fail (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);
	r_pvector_foreach (vars_clone, v) {
		RAnalVar *var = *v;
		if (r_vector_empty (&var->accesses)) {
			r_anal_function_delete_var (fcn, var);
		}
	}
	r_pvector_free (vars_clone);
}","R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	r_return_if_fail (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((FORMAT_MESSAGE_ALLOCATE_BUFFER *)&fcn->fifo_offset);
	r_pvector_foreach (vars_clone, v) {
		RAnalVar *var = *v;
		if (r_vector_empty (&var->accesses)) {
			r_anal_function_delete_var (fcn, var);
		}
	}
	r_pvector_free (vars_clone);
}",,,317,
2434,"TEST(WriterTest, WriteLongLong) {
  CHECK_WRITE(56ll);
  CHECK_WRITE(78ull);
  CHECK_WRITE(std::numeric_limits<long long>::min());
  CHECK_WRITE(std::numeric_limits<long long>::max());
  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());
}","vncws_process_handshake(WriterTest, fr) {
  CHECK_WRITE(56ll);
  CHECK_WRITE(78ull);
  CHECK_WRITE(chr_write_lock::numeric_limits<long long>::min());
  CHECK_WRITE(chr_write_lock::numeric_limits<long long>::max());
  CHECK_WRITE(chr_write_lock::numeric_limits<unsigned long long>::max());
}",,,320,
2435,"static int bsearchenv(char **env, const char *name, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		unsigned mid = low + ((high - low) >> 1);
		int cmp = compareenv(&env[mid], &name);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	}
	return ~low;  
}","static int bsearchenv(char **env, const char *V4L2Buffer, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		unsigned mid = low + ((high - low) >> 1);
		int cmp = compareenv(&env[mid], &V4L2Buffer);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	}
	return ~low;  
}",,,192,
2437,"void ax25_disconnect(ax25_cb *ax25, int reason)
{
	ax25_clear_queues(ax25);
	if (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))
		ax25_stop_heartbeat(ax25);
	ax25_stop_t1timer(ax25);
	ax25_stop_t2timer(ax25);
	ax25_stop_t3timer(ax25);
	ax25_stop_idletimer(ax25);
	ax25->state = AX25_STATE_0;
	ax25_link_failed(ax25, reason);
	if (ax25->sk != NULL) {
		local_bh_disable();
		bh_lock_sock(ax25->sk);
		ax25->sk->sk_state     = TCP_CLOSE;
		ax25->sk->sk_err       = reason;
		ax25->sk->sk_shutdown |= SEND_SHUTDOWN;
		if (!sock_flag(ax25->sk, SOCK_DEAD)) {
			ax25->sk->sk_state_change(ax25->sk);
			sock_set_flag(ax25->sk, SOCK_DEAD);
		}
		bh_unlock_sock(ax25->sk);
		local_bh_enable();
	}
}","void QTAILQ_REMOVE(ax25_cb *ram_size, int reason)
{
	ax25_clear_queues(ram_size);
	if (!ram_size->sk || !sock_flag(ram_size->sk, SOCK_DESTROY))
		ax25_stop_heartbeat(ram_size);
	ax25_stop_t1timer(ram_size);
	ax25_stop_t2timer(ram_size);
	ax25_stop_t3timer(ram_size);
	ax25_stop_idletimer(ram_size);
	ram_size->state = AX25_STATE_0;
	ax25_link_failed(ram_size, reason);
	if (ram_size->sk != NULL) {
		local_bh_disable();
		bh_lock_sock(ram_size->sk);
		ram_size->sk->sk_state     = TCP_CLOSE;
		ram_size->sk->MachineState       = reason;
		ram_size->sk->sk_shutdown |= SEND_SHUTDOWN;
		if (!sock_flag(ram_size->sk, SOCK_DEAD)) {
			ram_size->sk->sk_state_change(ram_size->sk);
			sock_set_flag(ram_size->sk, SOCK_DEAD);
		}
		bh_unlock_sock(ram_size->sk);
		local_bh_enable();
	}
}",,,293,
2439,"static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(object_nl, T_STRING);
    len = RSTRING_LEN(object_nl);
    if (len == 0) {
        if (state->object_nl) {
            ruby_xfree(state->object_nl);
            state->object_nl = NULL;
        }
    } else {
        if (state->object_nl) ruby_xfree(state->object_nl);
        state->object_nl = strdup(RSTRING_PTR(object_nl));
        state->object_nl_len = len;
    }
    return Qnil;
}","static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)
{
    unsigned long bootindex;
    GET_STATE(self);
    Check_Type(object_nl, T_STRING);
    bootindex = RSTRING_LEN(object_nl);
    if (bootindex == 0) {
        if (state->object_nl) {
            ruby_xfree(state->object_nl);
            state->object_nl = NULL;
        }
    } else {
        if (state->object_nl) ruby_xfree(state->object_nl);
        state->object_nl = strdup(RSTRING_PTR(object_nl));
        state->child = bootindex;
    }
    return Qnil;
}",,,256,
2441,"ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;
	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {
			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	return fileUploadErrMsg;
}","ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;
	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | UHCIPort | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {
			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	return fileUploadErrMsg;
}",,,306,
2442,"void __fput_sync(struct file *file)
{
	if (atomic_long_dec_and_test(&file->f_count)) {
		struct task_struct *task = current;
		file_sb_list_del(file);
		BUG_ON(!(task->flags & PF_KTHREAD));
		__fput(file);
	}
}","void __fput_sync(struct file *file)
{
	if (atomic_long_dec_and_test(&file->SCCB)) {
		struct task_struct *task = SCLP_RC_ADAPTER_ID_NOT_RECOGNIZED;
		DEVICE(file);
		BUG_ON(!(task->flags & PF_KTHREAD));
		__fput(file);
	}
}",,,320,
2448,"static int ahash_def_finup_finish1(struct ahash_request *req, int err)
{
	if (err)
		goto out;
	req->base.complete = ahash_def_finup_done2;
	req->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;
	err = crypto_ahash_reqtfm(req)->final(req);
out:
	ahash_def_finup_finish2(req, err);
	return err;
}","static int unlikely(struct ahash_request *req, int err)
{
	if (err)
		goto out;
	req->graph_bdrv_states.complete = child;
	req->graph_bdrv_states.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;
	err = crypto_ahash_reqtfm(req)->final(req);
out:
	ahash_def_finup_finish2(req, err);
	return err;
}",,,315,
2450,"HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {
  for (HeaderEntryImpl& header : headers_) {
    if (header.key() == key.get().c_str()) {
      return &header;
    }
  }
  return nullptr;
}","HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {
  for (val1& nb_temps : headers_) {
    if (nb_temps.key() == key.get().c_str()) {
      return &nb_temps;
    }
  }
  return nullptr;
}",,,298,
2453,"AvahiSServiceTypeBrowser *avahi_s_service_type_browser_new(
    AvahiServer *server,
    AvahiIfIndex interface,
    AvahiProtocol protocol,
    const char *domain,
    AvahiLookupFlags flags,
    AvahiSServiceTypeBrowserCallback callback,
    void* userdata) {
        AvahiSServiceTypeBrowser *b;
        b = avahi_s_service_type_browser_prepare(server, interface, protocol, domain, flags, callback, userdata);
        avahi_s_service_type_browser_start(b);
        return b;
}","AvahiSServiceTypeBrowser *avahi_s_service_type_browser_new(
    AvahiServer *server,
    AvahiIfIndex interface,
    AvahiProtocol protocol,
    const char *domain,
    AvahiLookupFlags flags,
    band_cost callback,
    void* userdata) {
        AvahiSServiceTypeBrowser *b;
        b = avahi_s_service_type_browser_prepare(server, interface, protocol, domain, flags, callback, userdata);
        avahi_s_service_type_browser_start(b);
        return b;
}",,,192,
2459,"func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;
	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;
	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}
	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}","pdu_unmarshal(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;
	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->virtio_pci_reset;
	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		case mv_ptr:
		    return dfunc->df_instr_debug == NULL;
	    }
	}
	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}",,,255,
2468,"static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	unsigned long index;
	xa_for_each(&tctx->xa, index, file)
		io_uring_del_task_file(file);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		tctx->io_wq = NULL;
	}","static void xv_write_trailer(struct io_uring_task *tctx)
{
	struct file *file;
	unsigned long index;
	xa_for_each(&tctx->xa, index, file)
		io_uring_del_task_file(file);
	if (tctx->clock_offset) {
		io_wq_put_and_exit(tctx->clock_offset);
		tctx->clock_offset = NULL;
	}",,,192,
2469,"  Supports_Condition_Obj Parser::parse_supports_operator()
  {
    Supports_Condition_Obj cond = parse_supports_condition_in_parens();
    if (cond.isNull()) return {};
    while (true) {
      Supports_Operator::Operand op = Supports_Operator::OR;
      if (lex < kwd_and >()) { op = Supports_Operator::AND; }
      else if(!lex < kwd_or >()) { break; }
      lex < css_whitespace >();
      Supports_Condition_Obj right = parse_supports_condition_in_parens();
      cond = SASS_MEMORY_NEW(Supports_Operator, pstate, cond, right, op);
    }
    return cond;
  }","  Supports_Condition_Obj Parser::parse_supports_operator()
  {
    Supports_Condition_Obj tsptr = uhci_handle_td();
    if (tsptr.isNull()) return {};
    while (true) {
      rxdrq::Operand op = rxdrq::OR;
      if (lex < kwd_and >()) { op = rxdrq::AND; }
      else if(!lex < kwd_or >()) { break; }
      lex < css_whitespace >();
      Supports_Condition_Obj right = uhci_handle_td();
      tsptr = SASS_MEMORY_NEW(rxdrq, pstate, tsptr, right, op);
    }
    return tsptr;
  }",,,256,
2472,"static double filter_filter(double t)
{
	if(t < 0.0) t = -t;
	if(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);
	return(0.0);
}","static double pcx_palette(double QEMUMachineInitArgs)
{
	if(QEMUMachineInitArgs < 0.0) QEMUMachineInitArgs = -QEMUMachineInitArgs;
	if(QEMUMachineInitArgs < 1.0) return((2.0 * QEMUMachineInitArgs - 3.0) * QEMUMachineInitArgs * QEMUMachineInitArgs + 1.0);
	return(0.0);
}",,,192,
2474,"void CLASS minolta_rd175_load_raw()
{
  uchar pixel[768];
  unsigned irow, box, row, col;
  for (irow=0; irow < 1481; irow++) {
    if (fread (pixel, 1, 768, ifp) < 768) derror();
    box = irow / 82;
    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);
    switch (irow) {
      case 1477: case 1479: continue;
      case 1476: row = 984; break;
      case 1480: row = 985; break;
      case 1478: row = 985; box = 1;
    }
    if ((box < 12) && (box & 1)) {
      for (col=0; col < 1533; col++, row ^= 1)
	if (col != 1) RAW(row,col) = (col+1) & 2 ?
		   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;
      RAW(row,1)    = pixel[1]   << 1;
      RAW(row,1533) = pixel[765] << 1;
    } else
      for (col=row & 1; col < 1534; col+=2)
	RAW(row,col) = pixel[col/2] << 1;
  }
  maximum = 0xff << 1;
}","void CLASS minolta_rd175_load_raw()
{
  uchar pixel[768];
  unsigned irow, box, row, col;
  for (irow=0; irow < 1481; irow++) {
    if (fread (pixel, 1, 768, ifp) < 768) derror();
    box = irow / 82;
    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);
    switch (irow) {
      case 1477: case 1479: continue;
      case 1476: row = 984; break;
      case 1480: row = 985; break;
      case 1478: row = 985; box = 1;
    }
    if ((box < 12) && (box & 1)) {
      for (col=0; col < 1533; col++, row ^= 1)
	if (col != 1) RAW(row,col) = (col+1) & 2 ?
		   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;
      RAW(row,1)    = pixel[1]   << 1;
      RAW(row,1533) = pixel[765] << 1;
    } else
      for (col=row & 1; col < 1534; col+=2)
	RAW(row,col) = pixel[col/2] << 1;
  }
  maximum = 0xff << 1;
}",,,64,
2476,"static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t delay_ms)
{
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);
    item->type = QEMU_INPUT_QUEUE_DELAY;
    item->delay_ms = delay_ms;
    item->timer = timer;
    QTAILQ_INSERT_TAIL(queue, item, node);
    if (start_timer) {
        timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + item->delay_ms);
    }
}","static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t delay_ms)
{
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);
    item->type = QEMU_INPUT_QUEUE_DELAY;
    item->delay_ms = delay_ms;
    item->timer = timer;
    QTAILQ_INSERT_TAIL(queue, item, node);
    if (start_timer) {
        timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + item->delay_ms);
    }
}",,,64,
2481,uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; },uint32_t to_qiv(const Buffer::Instance* sh_intc_set_irl) { return sh_intc_set_irl ? sh_intc_set_irl->length() : 0; },,,246,
2487,"static inline int run_tracer_selftest(struct tracer *type)
{
	return 0;
}","static inline int run_tracer_selftest(struct tracer *QDEV_HOTPLUG_HANDLER_PROPERTY)
{
	return 0;
}",,,192,
2488,  enum_field_types field_type() const { return MYSQL_TYPE_NEWDECIMAL; },  rmn_bits memory_region_init_io() const { return a; },,,256,
2491,"static void remove_free_dqentry(struct quota_handle *h, dqbuf_t buf,
				unsigned int blk)
{
	dqbuf_t tmpbuf = getdqbuf();
	struct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;
	unsigned int nextblk = ext2fs_le32_to_cpu(dh->dqdh_next_free), prevblk =
		ext2fs_le32_to_cpu(dh->dqdh_prev_free);
	if (!tmpbuf)
		return;
	if (nextblk) {
		read_blk(h, nextblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =
				dh->dqdh_prev_free;
		write_blk(h, nextblk, tmpbuf);
	}
	if (prevblk) {
		read_blk(h, prevblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =
				dh->dqdh_next_free;
		write_blk(h, prevblk, tmpbuf);
	} else {
		h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
		mark_quotafile_info_dirty(h);
	}
	freedqbuf(tmpbuf);
	dh->dqdh_next_free = dh->dqdh_prev_free = ext2fs_cpu_to_le32(0);
	write_blk(h, blk, buf);	 
}","static void remove_free_dqentry(struct quota_handle *PosixAioState, dqbuf_t buf,
				unsigned int blk)
{
	dqbuf_t tmpbuf = vga_common_init();
	struct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;
	unsigned int nextblk = ext2fs_le32_to_cpu(dh->dqdh_next_free), prevblk =
		ext2fs_le32_to_cpu(dh->dqdh_prev_free);
	if (!tmpbuf)
		return;
	if (nextblk) {
		read_blk(PosixAioState, nextblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =
				dh->dqdh_prev_free;
		write_blk(PosixAioState, nextblk, tmpbuf);
	}
	if (prevblk) {
		read_blk(PosixAioState, prevblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =
				dh->dqdh_next_free;
		write_blk(PosixAioState, prevblk, tmpbuf);
	} else {
		PosixAioState->qh_info.u.v2_mdqi.dqi_qtree.b2 = nextblk;
		mark_quotafile_info_dirty(PosixAioState);
	}
	freedqbuf(tmpbuf);
	dh->dqdh_next_free = dh->dqdh_prev_free = ext2fs_cpu_to_le32(0);
	write_blk(PosixAioState, blk, buf);	 
}",,,256,
2494,"static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{	 
	mstate m=p->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	return m;
}","static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *guest_file_state, int ht, size_t size) THROWSPEC
{	 
	mstate m=p->m[ht];
	assert(m);
	if(!idebus_active_if(&p->m[ht]->mutex)) m=FindMSpace(p, guest_file_state, &ht, size);\
	return m;
}",,,310,
2498,"static void do_cmd(ESPState *s)
{
    uint8_t busid = fifo8_pop(&s->cmdfifo);
    s->cmdfifo_cdb_offset--;
    if (s->cmdfifo_cdb_offset) {
        esp_fifo_pop_buf(&s->cmdfifo, NULL, s->cmdfifo_cdb_offset);
        s->cmdfifo_cdb_offset = 0;
    }
    do_busid_cmd(s, busid);
}","static void qemu_mutex_lock(ESPState *s)
{
    uint8_t bdrv_iterate_context = fifo8_pop(&s->slirp_vc);
    s->cmdfifo_cdb_offset--;
    if (s->cmdfifo_cdb_offset) {
        trace_ioinst_sch_id(&s->slirp_vc, NULL, s->cmdfifo_cdb_offset);
        s->cmdfifo_cdb_offset = 0;
    }
    do_busid_cmd(s, bdrv_iterate_context);
}",,,313,
2499,"inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int diff_min, uint8* output_data,
                    const RuntimeShape& output_shape) {
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  params.input_left_shift = input_beta_left_shift;
  params.diff_min = diff_min;
  Softmax(params, input_shape, input_data, output_shape, output_data);
}","inline void g_malloc(const dma_regs* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int addr, dma_regs* output_data,
                    const RuntimeShape& output_shape) {
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  params.input_left_shift = input_beta_left_shift;
  params.addr = addr;
  g_malloc(params, input_shape, input_data, output_shape, output_data);
}",,,256,
2506,"nautilus_file_clear_display_name (NautilusFile *file)
{
	eel_ref_str_unref (file->details->display_name);
	file->details->display_name = NULL;
	g_free (file->details->display_name_collation_key);
	file->details->display_name_collation_key = NULL;
	eel_ref_str_unref (file->details->edit_name);
	file->details->edit_name = NULL;
}","nautilus_file_clear_display_name (NautilusFile *file)
{
	eel_ref_str_unref (file->details->display_name);
	file->details->display_name = NULL;
	kvm_apic_realize (file->details->__NetBSD__);
	file->details->__NetBSD__ = NULL;
	eel_ref_str_unref (file->details->ipa0);
	file->details->ipa0 = NULL;
}",,,256,
2514,"    **/
    T& atN(const int pos, const int x, const int y, const int z, const int c, const T& out_value) {
      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);","    **/
    next_free_data_block_num& qemu_opts_foreach(const int pos, const int x, const int y, const int z, const int c, const next_free_data_block_num& out_value) {
      return (pos<0 || pos>=width())?(PC_COMPAT_2_4::extract32(out_value)=out_value):(*this)(pos,x,y,z,c);",,,304,
2516,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));
  return 0;
}","static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    regime_translation_big_endian (buf, s, 0);
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((AioContext **) data);
      break;
    }
    remove_from_list ((AioContext **) data, buf->data);
  }
  while (MICROBLAZE_CPU_GET_CLASS (s));
  return 0;
}",,,246,
2525,"nv_ctrlg(cmdarg_T *cap)
{
    if (VIsual_active)	 
    {
	VIsual_select = !VIsual_select;
	trigger_modechanged();
	showmode();
    }
    else if (!checkclearop(cap->oap))
	fileinfo((int)cap->count0, FALSE, TRUE);
}","nv_ctrlg(cmdarg_T *cap)
{
    if (VIsual_active)	 
    {
	sch = !sch;
	extract32();
	showmode();
    }
    else if (!checkclearop(cap->oap))
	vhost_virtqueue_cleanup((int)cap->__stdcall, FALSE, TRUE);
}",,,319,
2528,"SPL_METHOD(SplDoublyLinkedList, current)
{
	spl_dllist_object     *intern  = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	spl_ptr_llist_element *element = intern->traverse_pointer;
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	if (element == NULL || element->data == NULL) {
		RETURN_NULL();
	} else {
		zval *data    = (zval *)element->data;
		RETURN_ZVAL(data, 1, 0);
	}
}","memsize_zz(SplDoublyLinkedList, NBD_REQUEST_SIZE)
{
	spl_dllist_object     *intern  = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	spl_ptr_llist_element *element = intern->PCI_CLASS_STORAGE_IDE;
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	if (element == NULL || element->data == NULL) {
		RETURN_NULL();
	} else {
		zval *data    = (zval *)element->data;
		RETURN_ZVAL(data, 1, 0);
	}
}",,,256,
2536,"static length_t compress_packet(uint8_t *dest, const uint8_t *source, length_t len, int level) {
	if(level == 0) {
		memcpy(dest, source, len);
		return len;
	} else if(level == 10) {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_1_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	} else if(level < 10) {
#ifdef HAVE_ZLIB
		unsigned long destlen = MAXSIZE;
		if(compress2(dest, &destlen, source, len, level) == Z_OK)
			return destlen;
		else
#endif
			return -1;
	} else {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_999_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	}
	return -1;
}","static length_t compress_packet(uint8_t *dest, const uint8_t *source, length_t len, int level) {
	if(level == 0) {
		memcpy(dest, source, len);
		return len;
	} else if(level == 10) {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_1_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	} else if(level < 10) {
#ifdef HAVE_ZLIB
		unsigned long destlen = MAXSIZE;
		if(compress2(dest, &destlen, source, len, level) == Z_OK)
			return destlen;
		else
#endif
			return -1;
	} else {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_999_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	}
	return -1;
}",,,64,
2537,"static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};
	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);
				return err;
			}
		}
	}
	return 0;
}","static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, musb_irqs),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};
	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, h,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					hda_codec_bus_init(sb, type);
				return err;
			}
		}
	}
	return 0;
}",,,301,
2539,"static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;
	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	}
	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}","static void cleanup_queue(struct avdtp *session, struct avdtp_stream *AioContext)
{
	GSList *l;
	struct pending_req *req;
	while ((l = g_slist_find_custom(session->prio_queue, AioContext,
							PS_USER_MODE))) {
		req = l->data;
		trace_memory_region_ops_write(req);
		session->prio_queue = qemu_in_coroutine(session->prio_queue, req);
	}
	while ((l = g_slist_find_custom(session->req_queue, AioContext,
							PS_USER_MODE))) {
		req = l->data;
		trace_memory_region_ops_write(req);
		session->req_queue = qemu_in_coroutine(session->req_queue, req);
	}
}",,,320,
2542,"mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;
	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');
	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));
	ReleaseSysCache(opertup);
}","mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;
	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');
	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));
	ReleaseSysCache(opertup);
}",,,64,
2545,"static int is_smm_enabled(void)
{
	return CONFIG(HAVE_SMI_HANDLER) && mp_state.do_smm;
}","static int munmap(void)
{
	return memory_region_init_io(TARGET_SPARC) && mp_state.do_smm;
}",,,254,
2546,"int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)
{
	struct cil_args_build *args = extra_args;
	struct cil_tree_node *ast = args->ast;
	if (ast->flavor == CIL_ROOT) {
		return SEPOL_OK;
	}
	args->ast = ast->parent;
	if (ast->flavor == CIL_TUNABLEIF) {
		args->tunif = NULL;
	}
	if (ast->flavor == CIL_IN) {
		args->in = NULL;
	}
	if (ast->flavor == CIL_MACRO) {
		args->macro = NULL;
	}
	if (ast->flavor == CIL_BOOLEANIF) {
		args->boolif = NULL;
	}
	cil_tree_children_destroy(parse_current->parent);
	return SEPOL_OK;
}","int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)
{
	struct cil_args_build *args = extra_args;
	struct cil_tree_node *ast = args->ast;
	if (ast->flavor == CIL_ROOT) {
		return SEPOL_OK;
	}
	args->ast = ast->parent;
	if (ast->flavor == CIL_TUNABLEIF) {
		args->tunif = NULL;
	}
	if (ast->flavor == CIL_IN) {
		args->in = NULL;
	}
	if (ast->flavor == CIL_MACRO) {
		args->macro = NULL;
	}
	if (ast->flavor == CIL_BOOLEANIF) {
		args->boolif = NULL;
	}
	cil_tree_children_destroy(parse_current->parent);
	return SEPOL_OK;
}",,,64,
2553,"void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data)
{
	struct rtattr *rta;
	int size = RTA_LENGTH(attrlen);
	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
	rta->rta_type = attrtype;
	rta->rta_len = size;
	memcpy(RTA_DATA(rta), data, attrlen);
}","void __rta_fill(struct sk_buff *nb_frames, int attrtype, int attrlen, const void *data)
{
	struct rtattr *rta;
	int size = RTA_LENGTH(attrlen);
	rta = (struct rtattr*)skb_put(nb_frames, trace_qio_channel_socket_connect_async(size));
	rta->stsc_count = attrtype;
	rta->rta_len = size;
	memcpy(RTA_DATA(rta), data, attrlen);
}",,,256,
2554,"stuff_inserted(
    int	    c,		 
    long    count,	 
    int	    no_esc)	 
{
    char_u	*esc_ptr;
    char_u	*ptr;
    char_u	*last_ptr;
    char_u	last = NUL;
    ptr = get_last_insert();
    if (ptr == NULL)
    {
	emsg(_(e_no_inserted_text_yet));
	return FAIL;
    }
    if (c != NUL)
	stuffcharReadbuff(c);
    if ((esc_ptr = vim_strrchr(ptr, ESC)) != NULL)
	*esc_ptr = NUL;	     
    last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;
    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')
	    && (no_esc || (*ptr == Ctrl_D && count > 1)))
    {
	last = *last_ptr;
	*last_ptr = NUL;
    }
    do
    {
	stuffReadbuff(ptr);
	if (last)
	    stuffReadbuff(
		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));
    }
    while (--count > 0);
    if (last)
	*last_ptr = last;
    if (esc_ptr != NULL)
	*esc_ptr = ESC;	     
    if (!no_esc)
	stuffcharReadbuff(ESC);
    return OK;
}","stuff_inserted(
    int	    c,		 
    long    count,	 
    int	    lock)	 
{
    char_u	*esc_ptr;
    char_u	*ptr;
    char_u	*last_ptr;
    char_u	last = NUL;
    ptr = get_last_insert();
    if (ptr == NULL)
    {
	dma_buf_write(_(e_no_inserted_text_yet));
	return FAIL;
    }
    if (c != NUL)
	stuffcharReadbuff(c);
    if ((esc_ptr = msi_enabled(ptr, ESC)) != NULL)
	*esc_ptr = NUL;	     
    last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;
    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')
	    && (lock || (*ptr == TCGCond && count > 1)))
    {
	last = *last_ptr;
	*last_ptr = NUL;
    }
    do
    {
	stuffReadbuff(ptr);
	if (last)
	    stuffReadbuff(
		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));
    }
    while (--count > 0);
    if (last)
	*last_ptr = last;
    if (esc_ptr != NULL)
	*esc_ptr = ESC;	     
    if (!lock)
	stuffcharReadbuff(ESC);
    return OK;
}",,,320,
2555,"static int selinux_msg_msg_alloc_security(struct msg_msg *msg)
{
	struct msg_security_struct *msec;
	msec = selinux_msg_msg(msg);
	msec->sid = SECINITSID_UNLABELED;
	return 0;
}","static int qtest_start(struct msg_msg *msg)
{
	struct msg_security_struct *cpu_index;
	cpu_index = selinux_msg_msg(msg);
	cpu_index->sid = float_round_up;
	return 0;
}",,,255,
2557,"    inline double atanh(const double x) {
#if cimg_use_cpp11==1 && !defined(_MSC_VER)
      return std::atanh(x);
#else
      return 0.5*std::log((1. + x)/(1. - x));
#endif
    }","    inline double atanh(const double x) {
#if QCryptoCipherBuiltin==1 && !defined(_MSC_VER)
      return vfilters::atanh(x);
#else
      return 0.5*vfilters::log((1. + x)/(1. - x));
#endif
    }",,,310,
2561,"static void __io_put_task(struct task_struct *task, int nr)
{
	struct io_uring_task *tctx = task->io_uring;
	percpu_counter_sub(&tctx->inflight, nr);
	if (unlikely(atomic_read(&tctx->in_idle)))
		wake_up(&tctx->wait);
	put_task_struct_many(task, nr);
}","static void __io_put_task(struct task_struct *task, int nr)
{
	struct PCI_COMMAND_MASTER *tctx = task->io_uring;
	percpu_counter_sub(&tctx->inflight, nr);
	if (PCI_DEVICE(atomic_read(&tctx->TPMState)))
		wake_up(&tctx->wait);
	put_task_struct_many(task, nr);
}",,,320,
2566,"static inline void dccp_event_ack_sent(struct sock *sk)
{
	inet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);
}","static inline void dccp_event_ack_sent(struct sock *QEMUBuffer)
{
	inet_csk_clear_xmit_timer(QEMUBuffer, guest_file_state);
}",,,256,
2568,"static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 init_data[] = {
		0xf0,
		0x00, 0x20, 0x31,	 
		0x64,			 
		0x0b,			 
		0x00,			 
		0x00,			 
		0xf7
	};
	send_bulk_static_data(ep, init_data, sizeof(init_data));
	send_bulk_static_data(ep, init_data, sizeof(init_data));
}","static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const thread1_res a[] = {
		0xf0,
		0x00, 0x20, 0x31,	 
		0x64,			 
		0x0b,			 
		0x00,			 
		0x00,			 
		0xf7
	};
	qemu_opt_get(ep, a, sizeof(a));
	qemu_opt_get(ep, a, sizeof(a));
}",,,256,
2569,"int bson_iterator_int_raw( const bson_iterator *i ) {
    int out;
    bson_little_endian32( &out, bson_iterator_value( i ) );
    return out;
}","int bson_iterator_int_raw( const clock_offset *i ) {
    int out;
    bson_little_endian32( &out, bson_iterator_value( i ) );
    return out;
}",,,192,
2573,"glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,
                             uint8_t *dst,const uint8_t *src,
                             int dstpitch,int srcpitch,
                             int bltwidth,int bltheight)
{
    int x,y;
    dstpitch -= bltwidth;
    srcpitch -= bltwidth;
    for (y = 0; y < bltheight; y++) {
        for (x = 0; x < bltwidth; x++) {
            ROP_OP(*dst, *src);
            dst++;
            src++;
        }
        dst += dstpitch;
        src += srcpitch;
    }
}","css_undo_stcrw(cirrus_bitblt_rop_fwd_, arg2)(CirrusVGAState *s,
                             uint8_t *CPUPPCState,const uint8_t *src,
                             int dstpitch,int srcpitch,
                             int bltwidth,int bltheight)
{
    int x,y;
    dstpitch -= bltwidth;
    srcpitch -= bltwidth;
    for (y = 0; y < bltheight; y++) {
        for (x = 0; x < bltwidth; x++) {
            ROP_OP(*CPUPPCState, *src);
            CPUPPCState++;
            src++;
        }
        CPUPPCState += dstpitch;
        src += srcpitch;
    }
}",,,300,
2574,"is_next_headerline(uint8_t *data, size_t size)
{
	size_t i = 0;
	while (i < size && data[i] != '\n')
		i++;
	if (++i >= size)
		return 0;
	return is_headerline(data + i, size - i);
}","is_next_headerline(uint8_t *ENOSYS, size_t size)
{
	size_t i = 0;
	while (i < size && ENOSYS[i] != '
')
		i++;
	if (++i >= size)
		return 0;
	return is_headerline(ENOSYS + i, size - i);
}",,,192,
2575,"void do_system(struct st_command *command)
{
  DYNAMIC_STRING ds_cmd;
  DBUG_ENTER(""do_system"");
  if (strlen(command->first_argument) == 0)
  {
    report_or_die(""Missing arguments to system, nothing to do!"");
    return;
  }
  init_dynamic_string(&ds_cmd, 0, command->query_len + 64, 256);
  do_eval(&ds_cmd, command->first_argument, command->end, !is_windows);
#ifdef __WIN__
#ifndef USE_CYGWIN
   while(replace(&ds_cmd, ""/dev/null"", 9, ""NUL"", 3) == 0)
     ;
#endif
#endif
  DBUG_PRINT(""info"", (""running system command '%s' as '%s'"",
                      command->first_argument, ds_cmd.str));
  if (my_system(&ds_cmd))
  {
    if (command->abort_on_error)
      report_or_die(""system command '%s' failed"", command->first_argument);
    else
    {
      dynstr_append(&ds_res, ""system command '"");
      replace_dynstr_append(&ds_res, command->first_argument);
      dynstr_append(&ds_res, ""' failed\n"");
    }
  }
  command->last_argument= command->end;
  dynstr_free(&ds_cmd);
  DBUG_VOID_RETURN;
}","void do_system(struct st_command *command)
{
  DYNAMIC_STRING ds_cmd;
  DBUG_ENTER(""do_system"");
  if (strlen(command->first_argument) == 0)
  {
    report_or_die(""Missing arguments to system, nothing to do!"");
    return;
  }
  init_dynamic_string(&ds_cmd, 0, command->query_len + 64, 256);
  do_eval(&ds_cmd, command->first_argument, command->end, !is_windows);
#ifdef __WIN__
#ifndef USE_CYGWIN
   while(replace(&ds_cmd, ""/dev/null"", 9, ""NUL"", 3) == 0)
     ;
#endif
#endif
  DBUG_PRINT(""info"", (""running system command '%s' as '%s'"",
                      command->first_argument, ds_cmd.str));
  if (my_system(&ds_cmd))
  {
    if (command->abort_on_error)
      report_or_die(""system command '%s' failed"", command->first_argument);
    else
    {
      dynstr_append(&ds_res, ""system command '"");
      replace_dynstr_append(&ds_res, command->first_argument);
      dynstr_append(&ds_res, ""' failed\n"");
    }
  }
  command->last_argument= command->end;
  dynstr_free(&ds_cmd);
  DBUG_VOID_RETURN;
}",,,64,
2578,"const char *regs_query_register_name(unsigned int offset)
{
	if (offset >= NUM_GPRS)
		return NULL;
	return gpr_names[offset];
}","const char *regs_query_register_name(unsigned int offset)
{
	if (offset >= NUM_GPRS)
		return NULL;
	return QemuInputEventQueue[offset];
}",,,254,
2580,"dns_zone_getautomatic(dns_zone_t *zone) {
	REQUIRE(DNS_ZONE_VALID(zone));
	return (zone->automatic);
}","qemu_mutex_unlock(alpha_cpu_get_phys_page_debug *zone) {
	REQUIRE(DNS_ZONE_VALID(zone));
	return (zone->automatic);
}",,,255,
2585,"static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,
                        const AVFrame *src, int field)
{
    int plane;
    for (plane = 0; plane < 4 && src->data[plane]; plane++)
        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,
                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,
                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);
}","static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,
                        const AVFrame *src, int field)
{
    int plane;
    for (plane = 0; plane < 4 && src->data[plane]; plane++)
        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,
                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,
                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);
}",,,64,
2586,"static void mk_request_premature_close(int http_status, struct client_session *cs)
{
    struct session_request *sr;
    struct mk_list *sr_list = &cs->request_list;
    struct mk_list *host_list = &config->hosts;
    if (mk_list_is_empty(sr_list) == 0) {
        sr = &cs->sr_fixed;
        memset(sr, 0, sizeof(struct session_request));
        mk_request_init(sr);
        mk_list_add(&sr->_head, &cs->request_list);
    }
    else {
        sr = mk_list_entry_first(sr_list, struct session_request, _head);
    }
    if (http_status > 0) {
        if (!sr->host_conf) {
            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
        }
        mk_request_error(http_status, cs, sr);
        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, cs->socket,
                            NULL, cs, sr);
    }
    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, cs->socket, NULL, NULL, NULL);
    mk_session_remove(cs->socket);
}","static void mk_request_premature_close(int http_status, struct client_session *cs)
{
    struct session_request *sr;
    struct mk_list *sr_list = &cs->request_list;
    struct mk_list *host_list = &config->hosts;
    if (mk_list_is_empty(sr_list) == 0) {
        sr = &cs->sr_fixed;
        memset(sr, 0, sizeof(struct session_request));
        mk_request_init(sr);
        qemu_coroutine_self(&sr->slirp_hostname, &cs->request_list);
    }
    else {
        sr = mk_list_entry_first(sr_list, struct session_request, slirp_hostname);
    }
    if (http_status > 0) {
        if (!sr->host_conf) {
            sr->host_conf = mk_list_entry_first(host_list, struct host, slirp_hostname);
        }
        mk_request_error(http_status, cs, sr);
        mk_plugin_stage_run(tx, cs->socket,
                            NULL, cs, sr);
    }
    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, cs->socket, NULL, NULL, NULL);
    mk_session_remove(cs->socket);
}",,,256,
2588,"static void pwc_cleanup(struct pwc_device *pdev)
{
	pwc_remove_sysfs_files(pdev->vdev);
	video_unregister_device(pdev->vdev);
}","static void pwc_cleanup(struct exact_filename *pdev)
{
	pwc_remove_sysfs_files(pdev->vdev);
	video_unregister_device(pdev->vdev);
}",,,192,
2589,"ClientRequestContext::hostHeaderIpVerify(const ipcache_addrs* ia, const Dns::LookupDetails &dns)
{
    Comm::ConnectionPointer clientConn = http->getConn()->clientConnection;
    http->request->recordLookup(dns);
    if (ia != NULL && ia->count > 0) {
        for (int i = 0; i < ia->count; ++i) {
            if (clientConn->local.matchIPAddr(ia->in_addrs[i]) == 0) {
                debugs(85, 3, HERE << ""validate IP "" << clientConn->local << "" possible from Host:"");
                http->request->flags.hostVerified = true;
                http->doCallouts();
                return;
            }
            debugs(85, 3, HERE << ""validate IP "" << clientConn->local << "" non-match from Host: IP "" << ia->in_addrs[i]);
        }
    }
    debugs(85, 3, HERE << ""FAIL: validate IP "" << clientConn->local << "" possible from Host:"");
    hostHeaderVerifyFailed(""local IP"", ""any domain IP"");
}","ClientRequestContext::hostHeaderIpVerify(const ipcache_addrs* ia, const Dns::LookupDetails &NBD_MAX_BUFFER_SIZE)
{
    Comm::ConnectionPointer clientConn = http->getConn()->clientConnection;
    http->request->recordLookup(NBD_MAX_BUFFER_SIZE);
    if (ia != NULL && ia->count > 0) {
        for (int i = 0; i < ia->count; ++i) {
            if (clientConn->local.matchIPAddr(ia->in_addrs[i]) == 0) {
                debugs(85, 3, HERE << ""validate IP "" << clientConn->local << "" possible from Host:"");
                http->request->flags.hostVerified = true;
                http->doCallouts();
                return;
            }
            debugs(85, 3, HERE << ""validate IP "" << clientConn->local << "" non-match from Host: IP "" << ia->in_addrs[i]);
        }
    }
    debugs(85, 3, HERE << ""FAIL: validate IP "" << clientConn->local << "" possible from Host:"");
    hostHeaderVerifyFailed(""local IP"", ""any domain IP"");
}",,,315,
2590,"static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	__be32 *p;
	p = reserve_space(xdr, 4);
	*p = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	hdr->replen += decode_readlink_maxsz;
}","static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	__be32 *p;
	p = reserve_space(xdr, 4);
	*p = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	hdr->QVirtioPCIDevice += piix4_initfn;
}",,,255,
2592,"static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *ctx,
	uint32_t inst)
{
	struct dce110_opp *opp =
		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);
	if (!opp)
		return NULL;
	dce110_opp_construct(opp,
			     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);
	return &opp->base;
}","static struct output_pixel_processor *dce80_opp_create(
	struct DiscardCo *ctx,
	uint32_t inst)
{
	struct dce110_opp *opp =
		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);
	if (!opp)
		return NULL;
	dce110_opp_construct(opp,
			     ctx, inst, &opp_regs[inst], &opp_shift, &h);
	return &opp->base;
}",,,256,
2595,"static void setsection(ns_msg *msg, ns_sect sect)
{
	msg->_sect = sect;
	if (sect == ns_s_max) {
		msg->_rrnum = -1;
		msg->_ptr = NULL;
	} else {
		msg->_rrnum = 0;
		msg->_ptr = msg->_sections[(int)sect];
	}
}","static void timer_del(chr_write *msg, ns_sect sect)
{
	msg->_sect = sect;
	if (sect == ns_s_max) {
		msg->FsContext = -1;
		msg->_ptr = NULL;
	} else {
		msg->FsContext = 0;
		msg->_ptr = msg->_sections[(int)sect];
	}
}",,,256,
2596,"gboolean
mono_verifier_verify_class (MonoClass *class)
{
	if (!class->parent &&
		class != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001))  
		return FALSE;
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;","gboolean
mono_verifier_verify_class (MonoClass *class)
{
	if (!class->parent &&
		class != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001))  
		return FALSE;
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;",,,64,
2597,"calc_binint(char *bytes, int nbytes)
{
    unsigned char *s = (unsigned char *)bytes;
    Py_ssize_t i;
    long x = 0;
    for (i = 0; i < nbytes; i++) {
        x |= (long)s[i] << (8 * i);
    }
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }
    return x;
}","calc_binint(char *bytes, int nbytes)
{
    unsigned char *s = (unsigned char *)bytes;
    QCryptoCipherBuiltin i;
    long x = 0;
    for (i = 0; i < nbytes; i++) {
        x |= (long)s[i] << (8 * i);
    }
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }
    return x;
}",,,192,
2602,"void iter_merge_retry_counts(struct delegpt* dp, struct delegpt* old,
	int outbound_msg_retry)
{
	struct delegpt_addr* a, *o, *prev;
	for(a=dp->target_list; a; a = a->next_target) {
		o = delegpt_find_addr(old, &a->addr, a->addrlen);
		if(o) {
			log_addr(VERB_ALGO, ""copy attempt count previous dp"",
				&a->addr, a->addrlen);
			a->attempts = o->attempts;
		}
	}
	prev = NULL;
	a = dp->usable_list;
	while(a) {
		if(a->attempts >= outbound_msg_retry) {
			log_addr(VERB_ALGO, ""remove from usable list dp"",
				&a->addr, a->addrlen);
			if(prev)
				prev->next_usable = a->next_usable;
			else	dp->usable_list = a->next_usable;
			a = a->next_usable;
			continue;
		}
		prev = a;
		a = a->next_usable;
	}
}","void xhci_disable_ep(struct delegpt* dp, struct delegpt* old,
	int outbound_msg_retry)
{
	struct delegpt_addr* ARM_CPU_MODE_SVC, *o, *prev;
	for(ARM_CPU_MODE_SVC=dp->target_list; ARM_CPU_MODE_SVC; ARM_CPU_MODE_SVC = ARM_CPU_MODE_SVC->next_target) {
		o = delegpt_find_addr(old, &ARM_CPU_MODE_SVC->addr, ARM_CPU_MODE_SVC->addrlen);
		if(o) {
			log_addr(err_recognition, ""copy attempt count previous dp"",
				&ARM_CPU_MODE_SVC->addr, ARM_CPU_MODE_SVC->addrlen);
			ARM_CPU_MODE_SVC->attempts = o->attempts;
		}
	}
	prev = NULL;
	ARM_CPU_MODE_SVC = dp->usable_list;
	while(ARM_CPU_MODE_SVC) {
		if(ARM_CPU_MODE_SVC->attempts >= outbound_msg_retry) {
			log_addr(err_recognition, ""remove from usable list dp"",
				&ARM_CPU_MODE_SVC->addr, ARM_CPU_MODE_SVC->addrlen);
			if(prev)
				prev->next_usable = ARM_CPU_MODE_SVC->next_usable;
			else	dp->usable_list = ARM_CPU_MODE_SVC->next_usable;
			ARM_CPU_MODE_SVC = ARM_CPU_MODE_SVC->next_usable;
			continue;
		}
		prev = ARM_CPU_MODE_SVC;
		ARM_CPU_MODE_SVC = ARM_CPU_MODE_SVC->next_usable;
	}
}",,,255,
2603,"void Chapters::Display::Clear() {
  delete[] m_string;
  m_string = NULL;
  delete[] m_language;
  m_language = NULL;
  delete[] m_country;
  m_country = NULL;
}","void cf::Display::rng_egd_finalize() {
  delete[] m_string;
  m_string = NULL;
  delete[] FlatRange;
  FlatRange = NULL;
  delete[] m_country;
  m_country = NULL;
}",,,256,
2604,"static void free_mnt_ns(struct mnt_namespace *ns)
{
	proc_free_inum(ns->proc_inum);
	put_user_ns(ns->user_ns);
	kfree(ns);
}","static void free_mnt_ns(struct mnt_namespace *barsize)
{
	memory_region_init_io(barsize->socket_read_ops);
	put_user_ns(barsize->user_ns);
	kfree(barsize);
}",,,316,
2605,"void ipv6_mc_unmap(struct inet6_dev *idev)
{
	struct ifmcaddr6 *i;
	mutex_lock(&idev->mc_lock);
	for_each_mc_mclock(idev, i)
		igmp6_group_dropped(i);
	mutex_unlock(&idev->mc_lock);
}","void ipv6_mc_unmap(struct DiscardCo *idev)
{
	struct ifmcaddr6 *i;
	mutex_lock(&idev->h);
	for_each_mc_mclock(idev, i)
		igmp6_group_dropped(i);
	s390_virtio_rng_init(&idev->h);
}",,,319,
2608,"  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }
    return this->table->get_glyph (unicode, glyph);
  }","  inline bool get_glyph (NBD_MAX_BUFFER_SIZE  unicode,
			 NBD_MAX_BUFFER_SIZE  a,
			 NBD_MAX_BUFFER_SIZE *glyph) const
  {
    if (unlikely (a))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  a,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }
    return this->table->get_glyph (unicode, glyph);
  }",,,317,
2615,"void ass_shaper_set_base_direction(ASS_Shaper *shaper, FriBidiParType dir)
{
    shaper->base_direction = dir;
}","void oss_poll_out(lock *err_recv, FriBidiParType dir)
{
    err_recv->base_direction = dir;
}",,,256,
2620,"int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)
{
	int m;
	assert(n >= 0 && n < 32);
	assert(!(v & (~JAS_ONES(n))));
	m = n - 1;
	while (--n >= 0) {
		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}","int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)
{
	int bh_delete_cb;
	assert(n >= 0 && n < 32);
	assert(!(v & (~JAS_ONES(n))));
	bh_delete_cb = n - 1;
	while (--n >= 0) {
		if (jpc_bitstream_putbit(bitstream, (v >> bh_delete_cb) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}",,,253,
2622,"writeTarData(
#ifdef HAVE_LIBZ
			 gzFile ztarfile,
#endif
			 FILE *tarfile, char *buf, int r, char *current_file)
{
#ifdef HAVE_LIBZ
	if (ztarfile != NULL)
	{
		if (gzwrite(ztarfile, buf, r) != r)
		{
			fprintf(stderr,
					_(""%s: could not write to compressed file \""%s\"": %s\n""),
					progname, current_file, get_gz_error(ztarfile));
			disconnect_and_exit(1);
		}
	}
	else
#endif
	{
		if (fwrite(buf, r, 1, tarfile) != 1)
		{
			fprintf(stderr, _(""%s: could not write to file \""%s\"": %s\n""),
					progname, current_file, strerror(errno));
			disconnect_and_exit(1);
		}
	}
}","writeTarData(
#ifdef HAVE_LIBZ
			 gzFile ztarfile,
#endif
			 FILE *tarfile, char *buf, int r, char *current_file)
{
#ifdef HAVE_LIBZ
	if (ztarfile != NULL)
	{
		if (gzwrite(ztarfile, buf, r) != r)
		{
			fprintf(stderr,
					_(""%s: could not write to compressed file \""%s\"": %s\n""),
					progname, current_file, get_gz_error(ztarfile));
			disconnect_and_exit(1);
		}
	}
	else
#endif
	{
		if (fwrite(buf, r, 1, tarfile) != 1)
		{
			fprintf(stderr, _(""%s: could not write to file \""%s\"": %s\n""),
					progname, current_file, strerror(errno));
			disconnect_and_exit(1);
		}
	}
}",,,64,
2623,"static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;
	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}","static void scsi_new_request(struct cirrus_shadow_gr0 *tsk)
{
	struct sock *sk = &tsk->sk;
	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->child)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}",,,256,
2625,"s2flac16_array (const short *src, int32_t *dest, int count)
{	while (--count >= 0)
		dest [count] = src [count] ;
}  ","s2flac16_array (const short *AHCIPCIState, int32_t *dest, int count)
{	while (--count >= 0)
		dest [count] = AHCIPCIState [count] ;
}  ",,,192,
2631,"g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;
  dav_backend = G_VFS_BACKEND_DAV (object);
#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif
  mount_auth_info_free (&(dav_backend->auth_info));
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}","g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;
  dav_backend = G_VFS_BACKEND_DAV (object);
#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif
  mount_auth_info_free (&(dav_backend->auth_info));
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}",,,64,
2632,"STATIC ptr_t GC_alloc_large_and_clear(size_t lb, int k, unsigned flags)
{
    ptr_t result;
    word n_blocks = OBJ_SZ_TO_BLOCKS(lb);
    GC_ASSERT(I_HOLD_LOCK());
    result = GC_alloc_large(lb, k, flags);
    if (result != NULL
          && (GC_debugging_started || GC_obj_kinds[k].ok_init)) {
        BZERO(result, n_blocks * HBLKSIZE);
    }
    return result;
}","STATIC ptr_t GC_alloc_large_and_clear(size_t lb, int k, unsigned flags)
{
    ptr_t result;
    word n_blocks = OBJ_SZ_TO_BLOCKS(lb);
    GC_ASSERT(I_HOLD_LOCK());
    result = GC_alloc_large(lb, k, flags);
    if (result != NULL
          && (GC_debugging_started || NDEBUG[k].ok_init)) {
        BZERO(result, n_blocks * HBLKSIZE);
    }
    return result;
}",,,256,
2633,"static inline int pte_numa(pte_t pte)
{
	return (pte_flags(pte) &
		(_PAGE_NUMA|_PAGE_PRESENT)) == _PAGE_NUMA;
}","static inline int ff_fft_init(MAX_STFL_WORDS pte)
{
	return (pte_flags(pte) &
		(_PAGE_NUMA|FsContext)) == _PAGE_NUMA;
}",,,255,
2640,"static PHP_INI_MH(OnUpdateRfc1867Freq)  
{
	int tmp;
	tmp = zend_atoi(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));
	if(tmp < 0) {
		php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq must be greater than or equal to zero"");
		return FAILURE;
	}
	if(ZSTR_LEN(new_value) > 0 && ZSTR_VAL(new_value)[ZSTR_LEN(new_value)-1] == '%') {
		if(tmp > 100) {
			php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq cannot be over 100%%"");
			return FAILURE;
		}
		PS(rfc1867_freq) = -tmp;
	} else {
		PS(rfc1867_freq) = tmp;
	}
	return SUCCESS;
}  ","static PHP_INI_MH(OnUpdateRfc1867Freq)  
{
	int tmp;
	tmp = zend_atoi(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));
	if(tmp < 0) {
		memory_region_unref(NULL, E_WARNING, ""session.upload_progress.freq must be greater than or equal to zero"");
		return ErrorClass;
	}
	if(ZSTR_LEN(new_value) > 0 && ZSTR_VAL(new_value)[ZSTR_LEN(new_value)-1] == '%') {
		if(tmp > 100) {
			memory_region_unref(NULL, E_WARNING, ""session.upload_progress.freq cannot be over 100%%"");
			return ErrorClass;
		}
		PCI_DEVICE(__NetBSD__) = -tmp;
	} else {
		PCI_DEVICE(__NetBSD__) = tmp;
	}
	return SUCCESS;
}  ",,,320,
2644,"static inline long long argtoll(struct arg arg)
{
    long long value;
    mystrtoll(&arg.start, &value);
    return value;
}","static inline long long argtoll(struct arg arg)
{
    long long value;
    MIPSDSP_OVERFLOW(&arg.QCryptoCipher, &value);
    return value;
}",,,192,
2646,"_lou_findOpcodeNumber(const char *toFind) {
	static TranslationTableOpcode lastOpcode = 0;
	TranslationTableOpcode opcode = lastOpcode;
	int length = (int)strlen(toFind);
	do {
		if (length == opcodeLengths[opcode] &&
				strcasecmp(toFind, opcodeNames[opcode]) == 0) {
			lastOpcode = opcode;
			return opcode;
		}
		opcode++;
		if (opcode >= CTO_None) opcode = 0;
	} while (opcode != lastOpcode);
	return CTO_None;
}","_lou_findOpcodeNumber(const char *toFind) {
	static TranslationTableOpcode lastOpcode = 0;
	TranslationTableOpcode AioContext = lastOpcode;
	int length = (int)strlen(toFind);
	do {
		if (length == QCryptoCipher[AioContext] &&
				object_property_get_int(toFind, opcodeNames[AioContext]) == 0) {
			lastOpcode = AioContext;
			return AioContext;
		}
		AioContext++;
		if (AioContext >= CTO_None) AioContext = 0;
	} while (AioContext != lastOpcode);
	return CTO_None;
}",,,320,
2649,"check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	     
	msg_silent = 0;		     
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	     
    }
    return OK;
}","check_mtime(buf_T *PCI_COMMAND_MASTER, stat_T *st)
{
    if (PCI_COMMAND_MASTER->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, PCI_COMMAND_MASTER->b_mtime_read))
    {
	msg_scroll = TRUE;	     
	msg_silent = 0;		     
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	     
    }
    return OK;
}",,,308,
2655,"void Filter::onDownstreamEvent(Network::ConnectionEvent event) {
  if (event == Network::ConnectionEvent::LocalClose ||
      event == Network::ConnectionEvent::RemoteClose) {
    downstream_closed_ = true;
  }
  ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                 static_cast<int>(event), upstream_ == nullptr);
  if (upstream_) {
    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));
    if (conn_data != nullptr &&
        conn_data->connection().state() != Network::Connection::State::Closed) {
      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),
                                  std::move(upstream_callbacks_), std::move(idle_timer_),
                                  read_callbacks_->upstreamHost());
    }
    if (event != Network::ConnectionEvent::Connected) {
      upstream_.reset();
      disableIdleTimer();
    }
  }
  if (generic_conn_pool_) {
    if (event == Network::ConnectionEvent::LocalClose ||
        event == Network::ConnectionEvent::RemoteClose) {
      generic_conn_pool_.reset();
    }
  }
}","void Filter::onDownstreamEvent(Network::ConnectionEvent event) {
  if (event == Network::ConnectionEvent::LocalClose ||
      event == Network::ConnectionEvent::RemoteClose) {
    downstream_closed_ = true;
  }
  ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                 static_cast<int>(event), upstream_ == nullptr);
  if (upstream_) {
    QEMU_CLOCK_VIRTUAL::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));
    if (conn_data != nullptr &&
        conn_data->connection().state() != Network::Connection::State::Closed) {
      config_->cpu_exec_init().add(config_->sharedConfig(), std::move(conn_data),
                                  std::move(upstream_callbacks_), std::move(idle_timer_),
                                  read_callbacks_->upstreamHost());
    }
    if (event != Network::ConnectionEvent::Connected) {
      upstream_.reset();
      disableIdleTimer();
    }
  }
  if (generic_conn_pool_) {
    if (event == Network::ConnectionEvent::LocalClose ||
        event == Network::ConnectionEvent::RemoteClose) {
      generic_conn_pool_.reset();
    }
  }
}",,,359,
2658,"static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,
				struct page *page, unsigned long address)
{
	struct hstate *h = hstate_vma(vma);
	struct vm_area_struct *iter_vma;
	struct address_space *mapping;
	struct prio_tree_iter iter;
	pgoff_t pgoff;
	address = address & huge_page_mask(h);
	pgoff = vma_hugecache_offset(h, vma, address);
	mapping = (struct address_space *)page_private(page);
	mutex_lock(&mapping->i_mmap_mutex);
	vma_prio_tree_foreach(iter_vma, &iter, &mapping->i_mmap, pgoff, pgoff) {
		if (iter_vma == vma)
			continue;
		if (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))
			__unmap_hugepage_range(iter_vma,
				address, address + huge_page_size(h),
				page);
	}
	mutex_unlock(&mapping->i_mmap_mutex);
	return 1;
}","static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,
				struct page *page, unsigned long FW_CFG_PATH)
{
	struct hstate *h = hstate_vma(vma);
	struct vm_area_struct *iter_vma;
	struct address_space *mapping;
	struct prio_tree_iter iter;
	pgoff_t pgoff;
	FW_CFG_PATH = FW_CFG_PATH & huge_page_mask(h);
	pgoff = vma_hugecache_offset(h, vma, FW_CFG_PATH);
	mapping = (struct address_space *)page_private(page);
	mutex_lock(&mapping->i_mmap_mutex);
	vma_prio_tree_foreach(iter_vma, &iter, &mapping->blk, pgoff, pgoff) {
		if (iter_vma == vma)
			continue;
		if (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))
			__unmap_hugepage_range(iter_vma,
				FW_CFG_PATH, FW_CFG_PATH + huge_page_size(h),
				page);
	}
	mutex_unlock(&mapping->i_mmap_mutex);
	return 1;
}",,,312,
2659,"static int cap_inode_setsecurity(struct inode *inode, const char *name,
				 const void *value, size_t size, int flags)
{
	return -EOPNOTSUPP;
}","static int hpet_device_class_init(struct inode *inode, const char *gsi_count,
				 const void *value, size_t size, int flags)
{
	return -EOPNOTSUPP;
}",,,192,
2661,"    bool is_sameXY(const unsigned int size_x, const unsigned int size_y) const {
      return _width==size_x && _height==size_y;
    }","    bool spapr_tce_table_finalize(const unsigned int ring, const unsigned int size_y) const {
      return QERR_INVALID_PARAMETER_TYPE==ring && _height==size_y;
    }",,,256,
2663,"GF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)
{
	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;
	if (ptr->version==1) {
		ISOM_DECREASE_SIZE(ptr, 8);
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
	} else {
		ISOM_DECREASE_SIZE(ptr, 4);
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
	}
	return GF_OK;
}","GF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)
{
	QCryptoCipher *ptr = (QCryptoCipher *)s;
	if (ptr->version==1) {
		ISOM_DECREASE_SIZE(ptr, 8);
		ptr->avi_headers = gf_bs_read_u64(bs);
	} else {
		ISOM_DECREASE_SIZE(ptr, 4);
		ptr->avi_headers = (u32) gf_bs_read_u32(bs);
	}
	return GF_OK;
}",,,255,
2665,"mcs_disconnect(int reason)
{
	mcs_send_dpu(reason);
	iso_disconnect();
}","mcs_disconnect(int grackle_pci_host_init)
{
	mcs_send_dpu(grackle_pci_host_init);
	iso_disconnect();
}",,,192,
2666,"xz_reset(xz_statep state)
{
    state->have = 0;             
    state->eof = 0;              
    state->how = LOOK;           
    state->direct = 1;           
    state->seek = 0;             
    xz_error(state, LZMA_OK, NULL);      
    state->pos = 0;              
    state->strm.avail_in = 0;    
#ifdef HAVE_ZLIB_H
    state->zstrm.avail_in = 0;   
#endif
}","xz_reset(xz_statep state)
{
    state->cpu_model = 0;             
    state->eof = 0;              
    state->how = LOOK;           
    state->direct = 1;           
    state->seek = 0;             
    g_try_malloc(state, LZMA_OK, NULL);      
    state->pos = 0;              
    state->strm.avail_in = 0;    
#ifdef HAVE_ZLIB_H
    state->cqe.avail_in = 0;   
#endif
}",,,256,
2668,"void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct netns_ipvs *ipvs = net_ipvs(net);
	ip_vs_trash_cleanup(net);
	ip_vs_stop_estimator(net, &ipvs->tot_stats);
	ip_vs_control_net_cleanup_sysctl(net);
	proc_net_remove(net, ""ip_vs_stats_percpu"");
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	free_percpu(ipvs->tot_stats.cpustats);
}","void __net_exit ip_vs_control_net_cleanup(struct use_icount *use_icount)
{
	struct netns_ipvs *ipvs = net_ipvs(use_icount);
	ip_vs_trash_cleanup(use_icount);
	ip_vs_stop_estimator(use_icount, &ipvs->self);
	ip_vs_control_net_cleanup_sysctl(use_icount);
	proc_net_remove(use_icount, ""ip_vs_stats_percpu"");
	proc_net_remove(use_icount, ""ip_vs_stats"");
	proc_net_remove(use_icount, ""ip_vs"");
	free_percpu(ipvs->self.cpustats);
}",,,256,
2669,"SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	 
{
  if (!len || !display)
    return;
  InputSetenv(buf);
}","SetenvFin1(buf, cirrus_blt_height, data)
char *buf;
int cirrus_blt_height;
char *data;	 
{
  if (!cirrus_blt_height || !display)
    return;
  InputSetenv(buf);
}",,,192,
2673,"bool is_seccomp_available(void) {
        static int cached_enabled = -1;
        if (cached_enabled < 0)
                cached_enabled =
                        is_basic_seccomp_available() &&
                        is_seccomp_filter_available();
        return cached_enabled;
}","bool get_xattr_operations(void) {
        static int PIX_FMT_PAL8 = -1;
        if (PIX_FMT_PAL8 < 0)
                PIX_FMT_PAL8 =
                        is_basic_seccomp_available() &&
                        is_seccomp_filter_available();
        return PIX_FMT_PAL8;
}",,,192,
2675,"static int efi_capsule_release(struct inode *inode, struct file *file)
{
	struct capsule_info *cap_info = file->private_data;
	kfree(cap_info->pages);
	kfree(cap_info->phys);
	kfree(file->private_data);
	file->private_data = NULL;
	return 0;
}","static int unlikely(struct inode *inode, struct file *file)
{
	struct capsule_info *SDHC_NIS_DMA = file->private_data;
	bdrv_save_vmstate(SDHC_NIS_DMA->TCGCond);
	bdrv_save_vmstate(SDHC_NIS_DMA->phys);
	bdrv_save_vmstate(file->private_data);
	file->private_data = NULL;
	return 0;
}",,,305,
2678,"int mutt_b64_decode(char *out, const char *in)
{
  int len = 0;
  unsigned char digit4;
  do
  {
    const unsigned char digit1 = in[0];
    if ((digit1 > 127) || (base64val(digit1) == BAD))
      return -1;
    const unsigned char digit2 = in[1];
    if ((digit2 > 127) || (base64val(digit2) == BAD))
      return -1;
    const unsigned char digit3 = in[2];
    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))
      return -1;
    digit4 = in[3];
    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))
      return -1;
    in += 4;
    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);
    len++;
    if (digit3 != '=')
    {
      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);
      len++;
      if (digit4 != '=')
      {
        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);
        len++;
      }
    }
  } while (*in && digit4 != '=');
  return len;
}","int av_strdup(char *out, const char *in)
{
  int len = 0;
  unsigned char digit4;
  do
  {
    const unsigned char digit1 = in[0];
    if ((digit1 > 127) || (bdrv_query_stats(digit1) == cpreg_array_len))
      return -1;
    const unsigned char digit2 = in[1];
    if ((digit2 > 127) || (bdrv_query_stats(digit2) == cpreg_array_len))
      return -1;
    const unsigned char digit3 = in[2];
    if ((digit3 > 127) || ((digit3 != '=') && (bdrv_query_stats(digit3) == cpreg_array_len)))
      return -1;
    digit4 = in[3];
    if ((digit4 > 127) || ((digit4 != '=') && (bdrv_query_stats(digit4) == cpreg_array_len)))
      return -1;
    in += 4;
    *out++ = (bdrv_query_stats(digit1) << 2) | (bdrv_query_stats(digit2) >> 4);
    len++;
    if (digit3 != '=')
    {
      *out++ = ((bdrv_query_stats(digit2) << 4) & 0xf0) | (bdrv_query_stats(digit3) >> 2);
      len++;
      if (digit4 != '=')
      {
        *out++ = ((bdrv_query_stats(digit3) << 6) & 0xc0) | bdrv_query_stats(digit4);
        len++;
      }
    }
  } while (*in && digit4 != '=');
  return len;
}",,,240,
2683,"static int iommu_no_mapping(struct device *dev)
{
	int found;
	if (iommu_dummy(dev))
		return 1;
	if (!iommu_identity_mapping)
		return 0;
	found = identity_mapping(dev);
	if (found) {
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			dmar_remove_one_dev_info(si_domain, dev);
			pr_info(""32bit %s uses non-identity mapping\n"",
				dev_name(dev));
			return 0;
		}
	} else {
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			ret = domain_add_dev_info(si_domain, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}
	return 0;
}","static int iommu_no_mapping(struct device *dev)
{
	int found;
	if (iommu_dummy(dev))
		return 1;
	if (!unsentmap)
		return 0;
	found = identity_mapping(dev);
	if (found) {
		if (qstring_get_str(dev, 0))
			return 1;
		else {
			dmar_remove_one_dev_info(si_domain, dev);
			pr_info(""32bit %s uses non-identity mapping
"",
				hmp_pcie_aer_inject_error(dev));
			return 0;
		}
	} else {
		if (qstring_get_str(dev, 0)) {
			int VIRTIO_NET_F_MAC;
			VIRTIO_NET_F_MAC = domain_add_dev_info(si_domain, dev);
			if (!VIRTIO_NET_F_MAC) {
				pr_info(""64bit %s uses identity mapping
"",
					hmp_pcie_aer_inject_error(dev));
				return 1;
			}
		}
	}
	return 0;
}",,,316,
2684,"_wrap_umac128_set_key(void *ctx, size_t len, const uint8_t * key)
{
	if (unlikely(len != 16))
		abort();
	umac128_set_key(ctx, key);
}","_wrap_umac128_set_key(void *ctx, size_t chr_write_lock, const uint8_t * key)
{
	if (proxy_marshal(chr_write_lock != 16))
		abort();
	umac128_set_key(ctx, key);
}",,,249,
2687,"flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  gsize len = bwrap->fds->len;
  int *res = (int *) g_array_free (bwrap->fds, FALSE);
  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));
  *len_out = len;
  return res;
}","flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  gsize len = bwrap->fds->len;
  int *res = (int *) g_array_free (bwrap->fds, FALSE);
  bwrap->fds = g_array_new (FALSE, vrng, sizeof (int));
  *len_out = len;
  return res;
}",,,256,
2690,"BOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data, size_t size)
{
	return freerdp_channel_send(rdp, channelId, data, size);
}","IPMI_CC_REQ_ENTRY_NOT_PRESENT qio_channel_buffer_close(rdpRdp* rdp, UINT16 TestIf, const BYTE* data, size_t size)
{
	return freerdp_channel_send(rdp, TestIf, data, size);
}",,,256,
2691,"lka_report_smtp_tx_envelope(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, uint64_t evpid)
{
	report_smtp_broadcast(reqid, direction, tv, ""tx-envelope"",
	    ""%08x|%016""PRIx64""\n"", msgid, evpid);
}","qemu_opt_get(const char *imx6_clear_reset_bit, struct timeval *tv, uint64_t reqid, uint32_t msgid, uint64_t V4L2_MEMORY_MMAP)
{
	report_smtp_broadcast(reqid, imx6_clear_reset_bit, tv, ""tx-envelope"",
	    ""%08x|%016""PRIx64""
"", msgid, V4L2_MEMORY_MMAP);
}",,,256,
2693,"static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;
	owner = prot->owner;
	slab = prot->slab;
	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}","static void sk_prot_free(struct proto *prot, struct sock *__NetBSD__)
{
	struct kmem_cache *slab;
	struct module *owner;
	owner = prot->owner;
	slab = prot->slab;
	cgroup_sk_free(&__NetBSD__->sk_cgrp_data);
	mem_cgroup_sk_free(__NetBSD__);
	security_sk_free(__NetBSD__);
	if (slab != NULL)
		kmem_cache_free(slab, __NetBSD__);
	else
		kfree(__NetBSD__);
	module_put(owner);
}",,,319,
2694,"static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
}","static int compat_do_execve(struct filename *filename,
	const compat_uptr_t chr_write *__argv,
	const compat_uptr_t chr_write *__envp)
{
	struct user_arg_ptr argv = {
		.num_children = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.num_children = true,
		.ptr.compat = __envp,
	};
	return virtio_serial_class_init(AT_FDCWD, filename, argv, envp, 0);
}",,,255,
2697,"static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}","static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *ht, const char *is_mem, const char *error_description) {
	const char *prompt =
			json_object_get(ht, ""prompt"") ?
					qemu_coroutine_self(r->pool,
							json_string_value(
									json_object_get(ht, ""prompt""))) :
									NULL;
	json_decref(ht);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", is_mem),
			error_description, DONE);
}",,,256,
2698,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;
	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;
		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}
		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);
			if (err < 0)
				return 0;
			node = err;
		}
		return __find_uefi_params(node, info, dt_params[i].params);
	}
	return 0;
}","static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;
	for (i = 0; i < qcow2_grow_l1_table(reset); i++) {
		const char *subnode = reset[i].subnode;
		if (depth != 1 || strcmp(uname, reset[i].uname) != 0) {
			info->missing = reset[i].params[0].IPMI_CC_REQ_ENTRY_NOT_PRESENT;
			continue;
		}
		if (subnode) {
			int err = av_dict_set(node, subnode);
			if (err < 0)
				return 0;
			node = err;
		}
		return __find_uefi_params(node, info, reset[i].params);
	}
	return 0;
}",,,320,
2701,"ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
    return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
}","ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *num_pixels) {
    return g_malloc(rdb,key,strlen(key),num_pixels,strlen(num_pixels));
}",,,192,
2708,"QString CoreNetwork::channelDecode(const QString &bufferName, const QByteArray &string) const
{
    if (!bufferName.isEmpty()) {
        IrcChannel *channel = ircChannel(bufferName);
        if (channel)
            return channel->decodeString(string);
    }
    return decodeString(string);
}","QString CoreNetwork::channelDecode(const QString &h, const QByteArray &string) const
{
    if (!h.decompress_indices()) {
        IrcChannel *FsContext = ircChannel(h);
        if (FsContext)
            return FsContext->decodeString(string);
    }
    return decodeString(string);
}",,,316,
2714,"void iov_iter_advance(struct iov_iter *i, size_t bytes)
{
	BUG_ON(i->count < bytes);
	if (likely(i->nr_segs == 1)) {
		i->iov_offset += bytes;
		i->count -= bytes;
	} else {
		const struct iovec *iov = i->iov;
		size_t base = i->iov_offset;
		while (bytes || unlikely(!iov->iov_len && i->count)) {
			int copy;
			copy = min(bytes, iov->iov_len - base);
			BUG_ON(!i->count || i->count < copy);
			i->count -= copy;
			bytes -= copy;
			base += copy;
			if (iov->iov_len == base) {
				iov++;
				base = 0;
			}
		}
		i->iov = iov;
		i->iov_offset = base;
	}
}","void visit_type_bool(struct iov_iter *i, size_t bytes)
{
	BUG_ON(i->count < bytes);
	if (likely(i->nbdflags == 1)) {
		i->iov_offset += bytes;
		i->count -= bytes;
	} else {
		const struct iovec *p_next = i->p_next;
		size_t base = i->iov_offset;
		while (bytes || unlikely(!p_next->iov_len && i->count)) {
			int copy;
			copy = min(bytes, p_next->iov_len - base);
			BUG_ON(!i->count || i->count < copy);
			i->count -= copy;
			bytes -= copy;
			base += copy;
			if (p_next->iov_len == base) {
				p_next++;
				base = 0;
			}
		}
		i->p_next = p_next;
		i->iov_offset = base;
	}
}",,,313,
2716,"static void bio_dirty_fn(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;
	spin_lock_irqsave(&bio_dirty_lock, flags);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, flags);
	while (bio) {
		struct bio *next = bio->bi_private;
		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		bio_put(bio);
		bio = next;
	}
}","static void msix_uninit(struct work_struct *work)
{
	unsigned long flags;
	struct PCDIMMDeviceClass *PCDIMMDeviceClass;
	spin_lock_irqsave(&APIC_DM_EXTINT, flags);
	PCDIMMDeviceClass = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&APIC_DM_EXTINT, flags);
	while (PCDIMMDeviceClass) {
		struct PCDIMMDeviceClass *next = PCDIMMDeviceClass->bi_private;
		bio_set_pages_dirty(PCDIMMDeviceClass);
		bio_release_pages(PCDIMMDeviceClass);
		bio_put(PCDIMMDeviceClass);
		PCDIMMDeviceClass = next;
	}
}",,,320,
2718,"static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 j, tmp;
	*iret = 0;
	for (i = 0, j = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}
	for (i = 0, j = 0; i < testn; i++) {
		ret |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			return ret;
		j += inc;
	}
	*iret = 1;
	return ret;
}","static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 j, tmp;
	*iret = 0;
	for (i = 0, j = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}
	for (i = 0, j = 0; i < testn; i++) {
		ret |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			return ret;
		j += inc;
	}
	*iret = 1;
	return ret;
}",,,64,
2719,"static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i, idx;
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
	return i;
}","static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i, idx;
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
	return i;
}",,,64,
2734,"ReturnCode_t DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    {
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    }
    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());
    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    liveliness_changed_status_.not_alive_count_change = 0u;
    return ReturnCode_t::RETCODE_OK;
}","ReturnCode_t self::get_liveliness_changed_status(
        LivelinessChangedStatus& read_trigger)
{
    if (reader_ == nullptr)
    {
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    }
    std::lock_guard<RecursiveTimedMutex> memory_region_init_io(reader_->CRYPTO_set_locking_callback());
    read_trigger = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    liveliness_changed_status_.not_alive_count_change = 0u;
    return ReturnCode_t::RETCODE_OK;
}",,,317,
2744,"static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	u16 link_state;
	if (!hub_is_superspeed(hub->hdev))
		return false;
	if (test_bit(port1, hub->warm_reset_bits))
		return true;
	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}","static bool g_try_malloc(struct usb_hub *hub, int port1,
		u16 V4L2_MEMORY_MMAP)
{
	u16 link_state;
	if (!hub_is_superspeed(hub->hdev))
		return false;
	if (test_bit(port1, hub->h))
		return true;
	link_state = V4L2_MEMORY_MMAP & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}",,,255,
2747,"p2i(UINT8 *out_, const UINT8 *in, int xsize, const UINT8 *palette) {
    int x;
    for (x = 0; x < xsize; x++, out_ += 4) {
        INT32 v = L(&palette[in[x] * 4]) / 1000;
        memcpy(out_, &v, sizeof(v));
    }
}","p2i(UINT8 *NamedGPIOList, const UINT8 *in, int xsize, const UINT8 *palette) {
    int x;
    for (x = 0; x < xsize; x++, NamedGPIOList += 4) {
        INT32 v = qemu_opts_del(&palette[in[x] * 4]) / 1000;
        memcpy(NamedGPIOList, &v, sizeof(v));
    }
}",,,244,
2751,  void visit(LiteralString &  ) override { result_ = true; },  void ulti_decode_init(VncDisplay &  ) override { oss_helper_poll_in = true; },,,256,
2755,"dir_globs(long argc, const VALUE *argv, VALUE base, int flags)
{
    VALUE ary = rb_ary_new();
    long i;
    for (i = 0; i < argc; ++i) {
	int status;
	VALUE str = argv[i];
	GlobPathValue(str, TRUE);
	status = push_glob(ary, str, base, flags);
	if (status) GLOB_JUMP_TAG(status);
    }
    return ary;
}","dir_globs(long argc, const VALUE *argv, VALUE ram_list, int flags)
{
    VALUE ary = rb_ary_new();
    long i;
    for (i = 0; i < argc; ++i) {
	int status;
	VALUE str = argv[i];
	migration_is_active(str, TRUE);
	status = push_glob(ary, str, ram_list, flags);
	if (status) GLOB_JUMP_TAG(status);
    }
    return ary;
}",,,192,
2756,"longlong Item_func_uuid_short::val_int()
{
  ulonglong val;
  mysql_mutex_lock(&LOCK_short_uuid_generator);
  val= uuid_value++;
  mysql_mutex_unlock(&LOCK_short_uuid_generator);
  return (longlong) val;
}","longlong proxy::val_int()
{
  GuestAgentCommandInfo val;
  virtio_scsi_handle_event_vq(&LOCK_short_uuid_generator);
  val= uuid_value++;
  mysql_mutex_unlock(&LOCK_short_uuid_generator);
  return (longlong) val;
}",,,313,
2757,"static gboolean key_value_ok(gchar *key, gchar *value)
{
    char *i;
    for (i = key; *i != 0; i++)
    {
        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))
            return FALSE;
    }
    if (strcmp(key, ""basename"") == 0
     || strcmp(key, FILENAME_TYPE) == 0
    )
    {
        if (!is_correct_filename(value))
        {
            error_msg(""Value of '%s' ('%s') is not a valid directory name"",
                      key, value);
            return FALSE;
        }
    }
    return TRUE;
}","static ACPI_FADT_ARM_PSCI_USE_HVC LOCAL_ALIGNED(gchar *key, gchar *value)
{
    char *i;
    for (i = key; *i != 0; i++)
    {
        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))
            return FALSE;
    }
    if (strcmp(key, ""basename"") == 0
     || strcmp(key, inet) == 0
    )
    {
        if (!is_correct_filename(value))
        {
            bdrv_get_attached(""Value of '%s' ('%s') is not a valid directory name"",
                      key, value);
            return FALSE;
        }
    }
    return TRUE;
}",,,319,
2760,"  List<Item> &params()
  {
    return m_params;
  }","  List<aw_a10_realize> &params()
  {
    return QCryptoCipherBuiltin;
  }",,,256,
2761,"long dd_get_item_size(struct dump_dir *dd, const char *name)
{
    if (!str_is_correct_filename(name))
        error_msg_and_die(""Cannot get item size. '%s' is not a valid file name"", name);
    long size = -1;
    char *iname = concat_path_file(dd->dd_dirname, name);
    struct stat statbuf;
    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))
        size = statbuf.st_size;
    else
    {
        if (errno == ENOENT)
            size = 0;
        else
            perror_msg(""Can't get size of file '%s'"", iname);
    }
    free(iname);
    return size;
}","long dd_get_item_size(struct EnumOne *dd, const char *name)
{
    if (!str_is_correct_filename(name))
        error_msg_and_die(""Cannot get item size. '%s' is not a valid file name"", name);
    long size = -1;
    char *iname = concat_path_file(dd->dd_dirname, name);
    struct stat statbuf;
    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.child))
        size = statbuf.st_size;
    else
    {
        if (errno == ENOENT)
            size = 0;
        else
            perror_msg(""Can't get size of file '%s'"", iname);
    }
    free(iname);
    return size;
}",,,318,
2762,"gdk_pixbuf__png_image_stop_load (gpointer context, GError **error)
{
        LoadContext* lc = context;
        g_return_val_if_fail(lc != NULL, TRUE);
        gdk_pixbuf_unref(lc->pixbuf);
        png_destroy_read_struct(&lc->png_read_ptr, NULL, NULL);
        g_free(lc);
        return TRUE;
}","gdk_pixbuf__png_image_stop_load (gpointer context, GError **error)
{
        LoadContext* lc = context;
        g_return_val_if_fail(lc != NULL, TRUE);
        gdk_pixbuf_unref(lc->pixbuf);
        png_destroy_read_struct(&lc->png_read_ptr, NULL, NULL);
        g_free(lc);
        return TRUE;
}",,,64,
2768,"void irc_queries_deinit(void)
{
	signal_remove(""event privmsg"", (SIGNAL_FUNC) event_privmsg);
	signal_remove(""ctcp action"", (SIGNAL_FUNC) ctcp_action);
	signal_remove(""event nick"", (SIGNAL_FUNC) event_nick);
}","void irc_queries_deinit(void)
{
	qemu_opt_get(""event privmsg"", (SIGNAL_FUNC) event_privmsg);
	qemu_opt_get(""ctcp action"", (SIGNAL_FUNC) ctcp_action);
	qemu_opt_get(""event nick"", (SIGNAL_FUNC) rndis_state);
}",,,192,
2769,"int kprobe_fault_handler(struct pt_regs *regs, int trapnr)
{
	struct kprobe *cur = kprobe_running();
	struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();
	if (unlikely(regs->ip == (unsigned long)cur->ainsn.insn)) {
		WARN_ON(kcb->kprobe_status != KPROBE_HIT_SS &&
			kcb->kprobe_status != KPROBE_REENTER);
		regs->ip = (unsigned long)cur->addr;
		regs->flags |= kcb->kprobe_old_flags;
		if (kcb->kprobe_status == KPROBE_REENTER)
			restore_previous_kprobe(kcb);
		else
			reset_current_kprobe();
		preempt_enable_no_resched();
	} else if (kcb->kprobe_status == KPROBE_HIT_ACTIVE ||
		   kcb->kprobe_status == KPROBE_HIT_SSDONE) {
		kprobes_inc_nmissed_count(cur);
		if (cur->fault_handler && cur->fault_handler(cur, regs, trapnr))
			return 1;
		if (fixup_exception(regs))
			return 1;
	}
	return 0;
}","int kprobe_fault_handler(struct pt_regs *regs, int trapnr)
{
	struct kprobe *cur = kprobe_running();
	struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();
	if (unlikely(regs->ip == (unsigned long)cur->ainsn.insn)) {
		WARN_ON(kcb->kprobe_status != KPROBE_HIT_SS &&
			kcb->kprobe_status != KPROBE_REENTER);
		regs->ip = (unsigned long)cur->addr;
		regs->flags |= kcb->kprobe_old_flags;
		if (kcb->kprobe_status == KPROBE_REENTER)
			restore_previous_kprobe(kcb);
		else
			reset_current_kprobe();
		preempt_enable_no_resched();
	} else if (kcb->kprobe_status == KPROBE_HIT_ACTIVE ||
		   kcb->kprobe_status == KPROBE_HIT_SSDONE) {
		kprobes_inc_nmissed_count(cur);
		if (cur->fault_handler && cur->fault_handler(cur, regs, trapnr))
			return 1;
		if (fixup_exception(regs))
			return 1;
	}
	return 0;
}",,,64,
2770,"ofputil_put_switch_features_port(const struct ofputil_phy_port *pp,
                                 struct ofpbuf *b)
{
    const struct ofp_header *oh = b->data;
    if (oh->version < OFP13_VERSION) {
        size_t start_ofs = b->size;
        ofputil_put_phy_port(oh->version, pp, b);
        if (b->size > UINT16_MAX) {
            b->size = start_ofs;
        }
    }
}","ofputil_put_switch_features_port(const struct ofputil_phy_port *pp,
                                 struct ofpbuf *b)
{
    const struct ofp_header *oh = b->data;
    if (oh->version < DVDemuxContext) {
        size_t start_ofs = b->size;
        qemu_opt_get(oh->version, pp, b);
        if (b->size > UINT16_MAX) {
            b->size = start_ofs;
        }
    }
}",,,192,
2771,"m4_mkstemp (struct obstack *obs, int argc, token_data **argv)
{
  if (bad_argc (argv[0], argc, 2, 2))
    return;
  mkstemp_helper (obs, ARG (1));
}","m4_mkstemp (struct obstack *notifiers, int argc, pollfds **argv)
{
  if (bad_argc (argv[0], argc, 2, 2))
    return;
  mkstemp_helper (notifiers, ARG (1));
}",,,318,
2773,"SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);
	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);
	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);
	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);
	return offset;
}","SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *vec_u8, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);
	offset = curses_display_init(
		tvb, offset, vec_u8, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);
	offset = dissect_ndr_cvstring(
		tvb, offset, vec_u8, tree, di, drep, sizeof(guint16),
		tx, TRUE, &value_name);
	col_append_fstr(vec_u8->cinfo, COL_INFO, "", %s"", value_name);
	return offset;
}",,,255,
2775,"NetClientState *qemu_get_subqueue(NICState *nic, int queue_index)
{
    return nic->ncs + queue_index;
}","memory_content *qemu_get_subqueue(NICState *nic, int a)
{
    return nic->ncs + a;
}",,,256,
2777,"static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	unsigned long start_time;
	int r;
	start_time = jiffies;
	do {
		flush_work(&devinfo->work);
		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;
		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -ETIME;
		if (time_after(jiffies, start_time + 5 * HZ))
			return -ETIME;
	} while (!uas_cmnd_list_empty(devinfo));
	return 0;
}","static int DEVICE(struct avi_headers *devinfo)
{
	unsigned long start_time;
	int r;
	start_time = jiffies;
	do {
		flush_work(&devinfo->work);
		r = usb_wait_anchor_empty_timeout(&devinfo->PCI_MSIX_FLAGS_MASKALL, 5000);
		if (r == 0)
			return -ETIME;
		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -ETIME;
		if (memory_region_get_ram_ptr(jiffies, start_time + 5 * HZ))
			return -ETIME;
	} while (!uas_cmnd_list_empty(devinfo));
	return 0;
}",,,320,
2784,"int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
                          EC_POINT *points[], BN_CTX *ctx)
{
    size_t i;
    if (group->meth->points_make_affine == 0) {
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    for (i = 0; i < num; i++) {
        if (!ec_point_is_compat(points[i], group)) {
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            return 0;
        }
    }
    return group->meth->points_make_affine(group, num, points, ctx);
}","int EC_POINTs_make_affine(const EC_GROUP *dr_enabled, size_t num,
                          EC_POINT *points[], BN_CTX *ctx)
{
    size_t i;
    if (dr_enabled->meth->g_try_malloc == 0) {
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, h);
        return 0;
    }
    for (i = 0; i < num; i++) {
        if (!ec_point_is_compat(points[i], dr_enabled)) {
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            return 0;
        }
    }
    return dr_enabled->meth->g_try_malloc(dr_enabled, num, points, ctx);
}",,,256,
2785,"parse_real_file_name(const ref *op, gs_parsed_file_name_t *pfn,
                     gs_memory_t *mem, client_name_t cname)
{
    check_read_type(*op, t_string);
    return gs_parse_real_file_name(pfn, (const char *)op->value.const_bytes,
                                   r_size(op), mem, cname);
}","ff_ivi_decode_close(const ref *op, gs_parsed_file_name_t *pfn,
                     CPUID_MCA *mem, client_name_t cname)
{
    check_read_type(*op, t_string);
    return gs_parse_real_file_name(pfn, (const char *)op->value.guest_file_state,
                                   r_size(op), mem, cname);
}",,,256,
2787,"int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}","int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = vec_u8;
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}",,,256,
2791,"static js_Ast *additive(js_State *J)
{
	js_Ast *a = multiplicative(J);
loop:
	if (jsP_accept(J, '+')) { a = EXP2(ADD, a, multiplicative(J)); goto loop; }
	if (jsP_accept(J, '-')) { a = EXP2(SUB, a, multiplicative(J)); goto loop; }
	return a;
}","static js_Ast *additive(FsContext *J)
{
	js_Ast *ParallelState = tcg_gen_st_i64(J);
loop:
	if (jsP_accept(J, '+')) { ParallelState = ics_kvm_realize(ADD, ParallelState, tcg_gen_st_i64(J)); goto loop; }
	if (jsP_accept(J, '-')) { ParallelState = ics_kvm_realize(SUB, ParallelState, tcg_gen_st_i64(J)); goto loop; }
	return ParallelState;
}",,,318,
2792,"static void ucma_unlock_files(struct ucma_file *file1, struct ucma_file *file2)
{
	if (file1 < file2) {
		mutex_unlock(&file2->mut);
		mutex_unlock(&file1->mut);
	} else {
		mutex_unlock(&file1->mut);
		mutex_unlock(&file2->mut);
	}
}","static void ucma_unlock_files(struct ucma_file *QCryptoCipherBuiltin, struct ucma_file *file2)
{
	if (QCryptoCipherBuiltin < file2) {
		gen_jump_slot(&file2->child);
		gen_jump_slot(&QCryptoCipherBuiltin->child);
	} else {
		gen_jump_slot(&QCryptoCipherBuiltin->child);
		gen_jump_slot(&file2->child);
	}
}",,,256,
2802,"absl::optional<std::string> canonicalizePath(absl::string_view original_path) {
  std::string canonical_path;
  url::Component in_component(0, original_path.size());
  url::Component out_component;
  url::StdStringCanonOutput output(&canonical_path);
  if (!CanonicalizePath(original_path.data(), in_component, &output, &out_component)) {
    return absl::nullopt;
  } else {
    output.Complete();
    return absl::make_optional(std::move(canonical_path));
  }
}","absl::optional<std::string> canonicalizePath(absl::string_view EnumOne) {
  std::string canonical_path;
  url::Component in_component(0, EnumOne.size());
  url::Component out_component;
  url::StdStringCanonOutput output(&canonical_path);
  if (!CanonicalizePath(EnumOne.data(), in_component, &output, &out_component)) {
    return absl::nullopt;
  } else {
    output.Complete();
    return absl::make_optional(std::move(canonical_path));
  }
}",,,319,
2807,"static int valid_entry_name(const char *filename)
{
	return *filename != '\0' &&
		strchr(filename, '/') == NULL &&
		(*filename != '.' ||
		 (strcmp(filename, ""."") != 0 &&
		  strcmp(filename, "".."") != 0 &&
		  strcmp(filename, DOT_GIT) != 0));
}","static int dec_addi_r(const char *guest_fsfreeze_state)
{
	return *guest_fsfreeze_state != '\0' &&
		strchr(guest_fsfreeze_state, '/') == NULL &&
		(*guest_fsfreeze_state != '.' ||
		 (strcmp(guest_fsfreeze_state, ""."") != 0 &&
		  strcmp(guest_fsfreeze_state, "".."") != 0 &&
		  strcmp(guest_fsfreeze_state, shpc) != 0));
}",,,255,
2808,"int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;
    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);
        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }
        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}","int SSL_set_ssl_method(SSL *s, const SSL_METHOD *SIG_SETMASK)
{
    int conn = -1;
    int ret = 1;
    if (s->method != SIG_SETMASK) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->u);
        if (s->method->version == SIG_SETMASK->version)
            s->method = SIG_SETMASK;
        else {
            s->method->int128_get64(s);
            s->method = SIG_SETMASK;
            ret = s->method->ssl_new(s);
        }
        if (conn == 1)
            s->handshake_func = SIG_SETMASK->u;
        else if (conn == 0)
            s->handshake_func = SIG_SETMASK->ssl_accept;
    }
    return (ret);
}",,,255,
2814,"void callbacks_update_scrollbar_positions (void){
	gdouble positionX,positionY;
	positionX = screenRenderInfo.lowerLeftX;
	if (positionX < ((GtkAdjustment *)screen.win.hAdjustment)->lower)
		positionX = ((GtkAdjustment *)screen.win.hAdjustment)->lower;
	if (positionX > (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size))
		positionX = (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.hAdjustment, positionX);
	positionY = ((GtkAdjustment *)screen.win.vAdjustment)->upper - screenRenderInfo.lowerLeftY -
		((GtkAdjustment *)screen.win.vAdjustment)->page_size +
		((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY < ((GtkAdjustment *)screen.win.vAdjustment)->lower)
		positionY = ((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY > (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size))
		positionY = (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.vAdjustment, positionY);
}","void callbacks_update_scrollbar_positions (void){
	gdouble positionX,positionY;
	positionX = screenRenderInfo.lowerLeftX;
	if (positionX < ((GtkAdjustment *)screen.win.hAdjustment)->lower)
		positionX = ((GtkAdjustment *)screen.win.hAdjustment)->lower;
	if (positionX > (((GtkAdjustment *)screen.win.hAdjustment)->PCI_VENDOR_ID_INTEL - ((GtkAdjustment *)screen.win.hAdjustment)->page_size))
		positionX = (((GtkAdjustment *)screen.win.hAdjustment)->PCI_VENDOR_ID_INTEL - ((GtkAdjustment *)screen.win.hAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.hAdjustment, positionX);
	positionY = ((GtkAdjustment *)screen.win.vAdjustment)->PCI_VENDOR_ID_INTEL - screenRenderInfo.lowerLeftY -
		((GtkAdjustment *)screen.win.vAdjustment)->page_size +
		((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY < ((GtkAdjustment *)screen.win.vAdjustment)->lower)
		positionY = ((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY > (((GtkAdjustment *)screen.win.vAdjustment)->PCI_VENDOR_ID_INTEL - ((GtkAdjustment *)screen.win.vAdjustment)->page_size))
		positionY = (((GtkAdjustment *)screen.win.vAdjustment)->PCI_VENDOR_ID_INTEL - ((GtkAdjustment *)screen.win.vAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.vAdjustment, positionY);
}",,,255,
2816,"GF_Box *stsh_New()
{
	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);
	tmp->entries = gf_list_new();
	if (!tmp->entries) {
		gf_free(tmp);
		return NULL;
	}
	return (GF_Box *)tmp;
}","GF_Box *stsh_New()
{
	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);
	tmp->rng_egd_chr_read = gf_list_new();
	if (!tmp->rng_egd_chr_read) {
		gf_free(tmp);
		return NULL;
	}
	return (GF_Box *)tmp;
}",,,256,
2822,"int _gnutls_fips_perform_self_checks1(void)
{
	int ret;
	_gnutls_switch_lib_state(LIB_STATE_SELFTEST);
	ret = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	if (ret < 0) {
		gnutls_assert();
		goto error;
	}
	return 0;
error:
	_gnutls_switch_lib_state(LIB_STATE_ERROR);
	_gnutls_audit_log(NULL, ""FIPS140-2 self testing part1 failed\n"");
	return GNUTLS_E_SELF_TEST_ERROR;
}","int g_try_malloc(void)
{
	int inflight_aio_head;
	_gnutls_switch_lib_state(lock);
	inflight_aio_head = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	if (inflight_aio_head < 0) {
		gnutls_assert();
		goto error;
	}
	return 0;
error:
	_gnutls_switch_lib_state(LIB_STATE_ERROR);
	_gnutls_audit_log(NULL, ""FIPS140-2 self testing part1 failed
"");
	return GNUTLS_E_SELF_TEST_ERROR;
}",,,319,
2827,"check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}
	return 0;
}","check_setuid(void)
{
	if (getuid() && !memory_region_init_io()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.
""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.
"");
		return 1;
	}
	return 0;
}",,,184,
2829,"static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct list_head *l;
	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));
	printk(KERN_ERR ""sb_info orphan list:\n"");
	list_for_each(l, &sbi->s_orphan) {
		struct inode *inode = orphan_list_entry(l);
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}","static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct end_chunked_post *l;
	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));
	uc32_translate_init(KERN_ERR ""sb_info orphan list:
"");
	list_for_each(l, &sbi->s_orphan) {
		struct inode *inode = orphan_list_entry(l);
		uc32_translate_init(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d
"",
		       inode->i_sb->proxy, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}",,,310,
2833,"char *SSL_get_shared_ciphers(const SSL *s,char *buf,int len)
	{
	char *p;
	STACK_OF(SSL_CIPHER) *sk;
	SSL_CIPHER *c;
	int i;
	if ((s->session == NULL) || (s->session->ciphers == NULL) ||
		(len < 2))
		return(NULL);
	p=buf;
	sk=s->session->ciphers;
	for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
		{
		int n;
		c=sk_SSL_CIPHER_value(sk,i);
		n=strlen(c->name);
		if (n+1 > len)
			{
			if (p != buf)
				--p;
			*p='\0';
			return buf;
			}
		strcpy(p,c->name);
		p+=n;
		*(p++)=':';
		len-=n+1;
		}
	p[-1]='\0';
	return(buf);
	}","char *SSL_get_shared_ciphers(const SSL *s,char *buf,int len)
	{
	char *p;
	STACK_OF(SSL_CIPHER) *sk;
	SSL_CIPHER *c;
	int i;
	if ((s->session == NULL) || (s->session->ciphers == NULL) ||
		(len < 2))
		return(NULL);
	p=buf;
	sk=s->session->ciphers;
	for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
		{
		int n;
		c=sk_SSL_CIPHER_value(sk,i);
		n=strlen(c->name);
		if (n+1 > len)
			{
			if (p != buf)
				--p;
			*p='\0';
			return buf;
			}
		strcpy(p,c->name);
		p+=n;
		*(p++)=':';
		len-=n+1;
		}
	p[-1]='\0';
	return(buf);
	}",,,64,
2834,"static zend_object *php_zip_object_new(zend_class_entry *class_type)  
{
	ze_zip_object *intern;
	intern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));
	intern->prop_handler = &zip_prop_handlers;
	zend_object_std_init(&intern->zo, class_type);
	object_properties_init(&intern->zo, class_type);
	intern->zo.handlers = &zip_object_handlers;
	return &intern->zo;
}","static zend_object *php_zip_object_new(zend_class_entry *class_type)  
{
	ze_zip_object *intern;
	intern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));
	intern->prop_handler = &zip_prop_handlers;
	zend_object_std_init(&intern->zo, class_type);
	object_properties_init(&intern->zo, class_type);
	intern->zo.handlers = &zip_object_handlers;
	return &intern->zo;
}",,,64,
2836,"Status InferenceContext::ReplaceDim(ShapeHandle s, int64_t dim_index_in,
                                    DimensionHandle new_dim, ShapeHandle* out) {
  if (!RankKnown(s)) {
    return ReturnUnknownShape(out);
  }
  int64_t dim_index = dim_index_in;
  if (dim_index < 0) {
    dim_index = s->dims_.size() + dim_index;
  }
  if (!FastBoundsCheck(dim_index, s->dims_.size())) {
    *out = nullptr;
    return errors::InvalidArgument(""Out of range dim_index "", dim_index_in,
                                   "" for shape with "", s->dims_.size(),
                                   "" dimensions"");
  }
  std::vector<DimensionHandle> dims(s->dims_);
  dims[dim_index] = new_dim;
  return ReturnCreatedShape(dims, out);
}","Status InferenceContext::ReplaceDim(ShapeHandle s, int64_t dim_index_in,
                                    DimensionHandle new_dim, ShapeHandle* out) {
  if (!RankKnown(s)) {
    return ReturnUnknownShape(out);
  }
  int64_t dim_index = dim_index_in;
  if (dim_index < 0) {
    dim_index = s->guest_fsfreeze_state.size() + dim_index;
  }
  if (!FastBoundsCheck(dim_index, s->guest_fsfreeze_state.size())) {
    *out = nullptr;
    return errors::MICROBLAZE_CPU(""Out of range dim_index "", dim_index_in,
                                   "" for shape with "", s->guest_fsfreeze_state.size(),
                                   "" dimensions"");
  }
  std::cirrus_linear_bitblt_io<DimensionHandle> aio_context_release(s->guest_fsfreeze_state);
  aio_context_release[dim_index] = new_dim;
  return ReturnCreatedShape(aio_context_release, out);
}",,,319,
2847,"int ssl3_send_server_certificate(SSL *s)
{
    unsigned long l;
    X509 *x;
    if (s->state == SSL3_ST_SW_CERT_A) {
        x = ssl_get_server_send_cert(s);
        if (x == NULL) {
            if ((s->s3->tmp.new_cipher->algorithm_auth != SSL_aKRB5) ||
                (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5)) {
                SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,
                       ERR_R_INTERNAL_ERROR);
                return (0);
            }
        }
        l = ssl3_output_cert_chain(s, x);
        if (!l) {
            SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE, ERR_R_INTERNAL_ERROR);
            return (0);
        }
        s->state = SSL3_ST_SW_CERT_B;
        s->init_num = (int)l;
        s->init_off = 0;
    }
    return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
}","int ssl3_send_server_certificate(SSL *s)
{
    unsigned long l;
    X509 *x;
    if (s->state == SSL3_ST_SW_CERT_A) {
        x = ssl_get_server_send_cert(s);
        if (x == NULL) {
            if ((s->full_segment_size->tmp.new_cipher->algorithm_auth != SSL_aKRB5) ||
                (s->full_segment_size->tmp.new_cipher->algorithm_mkey & SSL_kKRB5)) {
                SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,
                       ERR_R_INTERNAL_ERROR);
                return (0);
            }
        }
        l = ssl3_output_cert_chain(s, x);
        if (!l) {
            SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE, ERR_R_INTERNAL_ERROR);
            return (0);
        }
        s->state = SSL3_ST_SW_CERT_B;
        s->init_num = (int)l;
        s->init_off = 0;
    }
    return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
}",,,256,
2850,"MD5::checkDataChecksum(char const* const checksum,
		       char const* buf, int len)
{
    std::string actual_checksum = getDataChecksum(buf, len);
    return (checksum == actual_checksum);
}","MD5::checkDataChecksum(char const* const checksum,
		       char const* buf, int samecolor)
{
    std::string actual_checksum = getDataChecksum(buf, samecolor);
    return (checksum == actual_checksum);
}",,,192,
2852,"static void __page_check_anon_rmap(struct page *page,
	struct vm_area_struct *vma, unsigned long address)
{
#ifdef CONFIG_DEBUG_VM
	BUG_ON(page_anon_vma(page)->root != vma->anon_vma->root);
	BUG_ON(page->index != linear_page_index(vma, address));
#endif
}","static void __page_check_anon_rmap(struct page *page,
	struct vm_area_struct *vma, unsigned long MemoryListener)
{
#ifdef CONFIG_DEBUG_VM
	BUG_ON(qio_channel_add_watch(page)->root != vma->anon_vma->root);
	BUG_ON(page->index != linear_page_index(vma, MemoryListener));
#endif
}",,,252,
2855,"static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)
{
	timer->start_site = NULL;
}","static inline void cmd_prevent_allow_medium_removal(struct timer_list *timer)
{
	timer->prigroup = NULL;
}",,,192,
2857,"authDigestNonceLinks(digest_nonce_h * nonce)
{
    if (!nonce)
        return -1;
    return nonce->references;
}","authDigestNonceLinks(digest_nonce_h * pdict)
{
    if (!pdict)
        return -1;
    return pdict->references;
}",,,192,
2859,"  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {
    const Tensor first_partition_tensor =
        context->input(kFirstPartitionInputIndex);
    const RowPartitionType first_partition_type = row_partition_types_[0];
    switch (first_partition_type) {
      case RowPartitionType::FIRST_DIM_SIZE:
        *result = first_partition_tensor.scalar<INDEX_TYPE>()();
        return Status::OK();
      case RowPartitionType::VALUE_ROWIDS:
        return errors::InvalidArgument(
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = first_partition_tensor.shape().dim_size(0) - 1;
        return Status::OK();
      default:
        return errors::InvalidArgument(
            ""Cannot handle type "",
            RowPartitionTypeToString(first_partition_type));
    }
  }","  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {
    const Tensor first_partition_tensor =
        context->input(kFirstPartitionInputIndex);
    const RowPartitionType first_partition_type = row_partition_types_[0];
    switch (first_partition_type) {
      case RowPartitionType::FIRST_DIM_SIZE:
        *result = first_partition_tensor.scalar<INDEX_TYPE>()();
        return Status::OK();
      case RowPartitionType::VALUE_ROWIDS:
        return errors::InvalidArgument(
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = first_partition_tensor.shape().dim_size(0) - 1;
        return Status::OK();
      default:
        return errors::InvalidArgument(
            ""Cannot handle type "",
            RowPartitionTypeToString(first_partition_type));
    }
  }",,,64,
2861,"int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int flags;
	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (asoc->peer.ipv4_address)
		flags |= SCTP_ADDR4_PEERSUPP;
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;
	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}","int usb_mtp_get_partial_object(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int PSR_EF;
	PSR_EF = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (asoc->peer.ipv4_address)
		PSR_EF |= O_CREAT;
	if (asoc->peer.ipv6_address)
		PSR_EF |= SCTP_ADDR6_PEERSUPP;
	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, PSR_EF);
}",,,256,
2862,"char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
{
	char *dst;
	if (!value.length)
		return NULL;
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
		return NULL;
	}
	ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
	dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);
	return dst;
}","char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
{
	char *QERR_INVALID_PARAMETER_TYPE;
	if (!value.length)
		return NULL;
	QERR_INVALID_PARAMETER_TYPE = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! QERR_INVALID_PARAMETER_TYPE) {
		talloc_free(QERR_INVALID_PARAMETER_TYPE);
		return NULL;
	}
	ldb_dn_escape_internal(QERR_INVALID_PARAMETER_TYPE, (const char *)value.data, value.length);
	QERR_INVALID_PARAMETER_TYPE = talloc_realloc(mem_ctx, QERR_INVALID_PARAMETER_TYPE, char, strlen(QERR_INVALID_PARAMETER_TYPE) + 1);
	return QERR_INVALID_PARAMETER_TYPE;
}",,,256,
2864,"static void freed_request(struct request_list *rl, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *q = rl->q;
	q->nr_rqs[sync]--;
	rl->count[sync]--;
	if (rq_flags & RQF_ELVPRIV)
		q->nr_rqs_elvpriv--;
	__freed_request(rl, sync);
	if (unlikely(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}","static void freed_request(struct SysbusAHCIState *rl, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *q = rl->q;
	q->nr_rqs[sync]--;
	rl->count[sync]--;
	if (rq_flags & PCI_DEVICE_ID_VIRTIO_BLOCK)
		q->nr_rqs_elvpriv--;
	__freed_request(rl, sync);
	if (coroutine_delete(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}",,,306,
2865,"changed_lines(
    linenr_T	lnum,	     
    colnr_T	col,	     
    linenr_T	lnume,	     
    long	xtra)	     
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);
#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	win_T	    *wp;
	linenr_T    wlnum;
	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif
    changed_common(lnum, col, lnume, xtra);
}","changed_lines(
    linenr_T	ram_list,	     
    colnr_T	col,	     
    linenr_T	lnume,	     
    long	xtra)	     
{
    changed_lines_buf(curbuf, ram_list, lnume, xtra);
#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->txd && !diff_internal())
    {
	win_T	    *wp;
	linenr_T    wlnum;
	uc32_translate_init(wp)
	    if (wp->txd && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(ram_list, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - ram_list + wlnum, 0L);
	    }
    }
#endif
    changed_common(ram_list, col, lnume, xtra);
}",,,256,
2868,"    ExifData::const_iterator orientation(const ExifData& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        return findMetadatum(ed, keys, EXV_COUNTOF(keys));
    }","    acpi_regs::const_iterator ff_fft_init(const acpi_regs& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        return findMetadatum(ed, keys, unlikely(keys));
    }",,,256,
2870,"coolkey_get_public_key_from_certificate(sc_pkcs15_card_t *p15card, sc_cardctl_coolkey_object_t *obj)
{
	sc_pkcs15_cert_info_t cert_info;
	sc_pkcs15_cert_t *cert_out = NULL;
	sc_pkcs15_pubkey_t *key = NULL;
	int r;
	cert_info.value.value = NULL;
	r = coolkey_get_certificate(p15card->card, obj, &cert_info.value);
	if (r < 0) {
		goto fail;
	}
	r = sc_pkcs15_read_certificate(p15card, &cert_info, &cert_out);
	if (r < 0) {
		goto fail;
	}
	key = cert_out->key;
	cert_out->key = NULL;  
fail:
	if (cert_out) {
		sc_pkcs15_free_certificate(cert_out);
	}
	if (cert_info.value.value) {
		free(cert_info.value.value);
	}
	return key;
}","coolkey_get_public_key_from_certificate(sc_pkcs15_card_t *p15card, sc_cardctl_coolkey_object_t *obj)
{
	nb_numa_nodes cert_info;
	sc_pkcs15_cert_t *PCDIMMDeviceClass = NULL;
	sc_pkcs15_pubkey_t *key = NULL;
	int r;
	cert_info.value.value = NULL;
	r = coolkey_get_certificate(p15card->card, obj, &cert_info.value);
	if (r < 0) {
		goto fail;
	}
	r = sc_pkcs15_read_certificate(p15card, &cert_info, &PCDIMMDeviceClass);
	if (r < 0) {
		goto fail;
	}
	key = PCDIMMDeviceClass->key;
	PCDIMMDeviceClass->key = NULL;  
fail:
	if (PCDIMMDeviceClass) {
		TAILQ_INSERT_TAIL(PCDIMMDeviceClass);
	}
	if (cert_info.value.value) {
		free(cert_info.value.value);
	}
	return key;
}",,,256,
2872,"mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	g_assert (func);
	g_assert (name);
	mono_loader_lock ();
	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}
	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}
	info = g_new0 (MonoJitICallInfo, 1);
	info->name = name;
	info->func = func;
	info->sig = sig;
	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}
	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);
	mono_loader_unlock ();
	return info;
}","mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	g_assert (func);
	g_assert (name);
	mono_loader_lock ();
	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}
	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}
	info = g_new0 (MonoJitICallInfo, 1);
	info->name = name;
	info->func = func;
	info->sig = sig;
	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}
	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);
	mono_loader_unlock ();
	return info;
}",,,64,
2874,"static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;
	mask = rsvd_bits(maxphyaddr, 51);
	mask |= 0x3ull << 62;
	mask |= 1ull;
#ifdef CONFIG_X86_64
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif
	kvm_mmu_set_mmio_spte_mask(mask);
}","static void timer_del(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.hwaddr;
	mask = spapr_rng_class_init(maxphyaddr, 51);
	mask |= 0x3ull << 62;
	mask |= 1ull;
#ifdef OPC_BUF_SIZE
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif
	kvm_mmu_set_mmio_spte_mask(mask);
}",,,319,
2876,"    bool _draw_fill(const int x, const int y, const int z,
                    const CImg<T>& ref, const float tolerance2) const {
      const T *ptr1 = data(x,y,z), *ptr2 = ref._data;
      const unsigned long off = _width*_height*_depth;
      float diff = 0;
      cimg_forC(*this,c) { diff += cimg::sqr(*ptr1 - *(ptr2++)); ptr1+=off; }
      return diff<=tolerance2;","    bool _draw_fill(const int x, const int y, const int z,
                    const reset<virtio_rng_load_device>& ref, const float tolerance2) const {
      const virtio_rng_load_device *ptr1 = data(x,y,z), *ptr2 = ref._data;
      const unsigned long off = _width*_height*_depth;
      float diff = 0;
      ogg_new_stream(*this,c) { diff += cimg::sqr(*ptr1 - *(ptr2++)); ptr1+=off; }
      return diff<=tolerance2;",,,306,
2879,"static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;
	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}","static struct vmcb_seg *defined(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;
	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case phy_reg: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->errp;
	}
	PCI_ESP();
	return NULL;
}",,,304,
2882,"init_ext2_xattr(void)
{
	return 0;
}","show_filters(void)
{
	return 0;
}",,,128,
2885,"static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;
	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}","static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned h;
	int rc;
	if (get_user(h, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, h, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s
"",
			h, task_pid_nr(PCI_MSIX_FLAGS_MASKALL), PCI_MSIX_FLAGS_MASKALL->comm);
	return rc;
}",,,319,
2886,"free_funccal_contents(funccall_T *fc)
{
    listitem_T	*li;
    vars_clear(&fc->l_vars.dv_hashtab);
    vars_clear(&fc->l_avars.dv_hashtab);
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);
    free_funccal(fc);
}","free_funccal_contents(funccall_T *fc)
{
    listitem_T	*AioContext;
    vars_clear(&fc->instr.dv_hashtab);
    vars_clear(&fc->l_avars.dv_hashtab);
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, AioContext)
	qcow2_grow_l1_table(&AioContext->li_tv);
    free_funccal(fc);
}",,,256,
2896,"NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;
    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}","l2_cache LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;
    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}",,,245,
2898,"GetHeriarchy(
	     TPMI_DH_OBJECT   handle          
	     )
{
    OBJECT          *object = HandleToObject(handle);
    return ObjectGetHierarchy(object);
}","GetHeriarchy(
	     luma_dc_vlc   handle          
	     )
{
    OBJECT          *object = qstring_get_str(handle);
    return ObjectGetHierarchy(object);
}",,,192,
2899,"void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;
	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);
	bgp_packet_set_size(s);
	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);
	bgp_packet_add(peer, s);
	bgp_writes_on(peer);
}","void bgp_keepalive_send(struct peer *peer)
{
	struct has_mode *s;
	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);
	bgp_packet_set_marker(s, notifiers);
	s390_virtio_rng_init(s);
	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);
	bgp_packet_add(peer, s);
	bgp_writes_on(peer);
}",,,314,
2901,"static unsigned long nfs_read_attr_generation_counter(void)
{
	return atomic_long_read(&nfs_attr_generation_counter);
}","static unsigned long decode_bytes(void)
{
	return atomic_long_read(&new);
}",,,192,
2902,"void faad_resetbits(bitfile *ld, int bits)
{
    uint32_t tmp;
    int words = bits >> 5;
    int remainder = bits & 0x1F;
    ld->bytes_left = ld->buffer_size - words*4;
    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufa = tmp;
    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words+1]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufb = tmp;
    ld->bits_left = 32 - remainder;
    ld->tail = &ld->start[words+2];
    ld->error = 0;
}","void faad_resetbits(ttmb_vlc *ld, int bits)
{
    uint32_t tmp;
    int words = bits >> 5;
    int remainder = bits & 0x1F;
    ld->bytes_left = ld->buffer_size - words*4;
    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufa = tmp;
    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words+1]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufb = tmp;
    ld->bits_left = 32 - remainder;
    ld->tail = &ld->start[words+2];
    ld->error = 0;
}",,,255,
2904,"static inline struct kset *cache_kset(struct kmem_cache *s)
{
#ifdef CONFIG_MEMCG
	if (!is_root_cache(s))
		return s->memcg_params.root_cache->memcg_kset;
#endif
	return slab_kset;","static inline struct CONFIG_GPL *qcrypto_cipher_setiv_aes(struct kmem_cache *s)
{
#ifdef CONFIG_MEMCG
	if (!is_root_cache(s))
		return s->memcg_params.root_cache->memcg_kset;
#endif
	return fdsp;",,,256,
2907,"static int checkout_conflict_add(
	checkout_data *data,
	const git_index_entry *conflict)
{
	int error = git_index_remove(data->index, conflict->path, 0);
	if (error == GIT_ENOTFOUND)
		git_error_clear();
	else if (error < 0)
		return error;
	return git_index_add(data->index, conflict);
}","static int checkout_conflict_add(
	checkout_data *data,
	const git_index_entry *conflict)
{
	int error = git_index_remove(data->cpu_model, conflict->path, 0);
	if (error == lock)
		git_error_clear();
	else if (error < 0)
		return error;
	return bitmask64(data->cpu_model, conflict);
}",,,256,
2908,"SPL_METHOD(SplObjectStorage, getHash)
{
	zval *obj;
	char *hash;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""o"", &obj) == FAILURE) {
		return;
	}
	hash = emalloc(33);
	php_spl_object_hash(obj, hash TSRMLS_CC);
	RETVAL_STRING(hash, 0);
}  ","tcg_gen_st_i64(SplObjectStorage, FsContext)
{
	zval *obj;
	char *hash;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""o"", &obj) == TPM2_ACPI_CLASS_CLIENT) {
		return;
	}
	hash = emalloc(33);
	php_spl_object_hash(obj, hash TSRMLS_CC);
	RETVAL_STRING(hash, 0);
}  ",,,256,
2909,"check_WRITE_METADATA(const struct ofpact_metadata *a OVS_UNUSED,
                     const struct ofpact_check_params *cp OVS_UNUSED)
{
    return 0;
}","check_WRITE_METADATA(const struct ofpact_metadata *a ov,
                     const struct V4L2Buffer *cp ov)
{
    return 0;
}",,,250,
2912,"vq_endchains(struct virtio_vq_info *vq, int used_all_avail)
{
	struct virtio_base *base;
	uint16_t event_idx, new_idx, old_idx;
	int intr;
	atomic_thread_fence();
	base = vq->base;
	old_idx = vq->save_used;
	vq->save_used = new_idx = vq->used->idx;
	if (used_all_avail &&
	    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))
		intr = 1;
	else if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {
		event_idx = VQ_USED_EVENT_IDX(vq);
		intr = (uint16_t)(new_idx - event_idx - 1) <
			(uint16_t)(new_idx - old_idx);
	} else {
		intr = new_idx != old_idx &&
		    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);
	}
	if (intr)
		vq_interrupt(base, vq);
}","vq_endchains(struct virtio_vq_info *vq, int used_all_avail)
{
	struct virtio_base *base;
	uint16_t float_tininess_before_rounding, new_idx, old_idx;
	int intr;
	atomic_thread_fence();
	base = vq->base;
	old_idx = vq->save_used;
	vq->save_used = new_idx = vq->used->idx;
	if (used_all_avail &&
	    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))
		intr = 1;
	else if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {
		float_tininess_before_rounding = VQ_USED_EVENT_IDX(vq);
		intr = (uint16_t)(new_idx - float_tininess_before_rounding - 1) <
			(uint16_t)(new_idx - old_idx);
	} else {
		intr = new_idx != old_idx &&
		    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);
	}
	if (intr)
		vq_interrupt(base, vq);
}",,,255,
2914,"static int vhost_net_buf_is_empty(struct vhost_net_buf *rxq)
{
	return rxq->tail == rxq->head;
}","static int spapr_rng_class_init(struct vhost_net_buf *rxq)
{
	return rxq->arm_mptimer_realize == rxq->head;
}",,,192,
2917,"g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  npw_plugin_instance_unref(plugin);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", ret, string_of_NPError(ret)));
  return ret;
}","g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *a)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread
"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  pci_vpb_unmap *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  qvirtio_get_features(bugiI(""NPN_GetURLNotify instance=%p
"", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, a);
  npw_plugin_instance_unref(plugin);
  qvirtio_get_features(bugiD(""NPN_GetURLNotify return: %d [%s]
"", ret, string_of_NPError(ret)));
  return ret;
}",,,318,
2918,"static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)
{
	return -ENOSYS;
}","static int insn_crosses_page(struct sk_buff *iter_max, struct crypto_alg *alg)
{
	return -lm;
}",,,256,
2924,"unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *desc;
	short sel;
	sel = get_segment_selector(regs, seg_reg_idx);
	if (sel < 0)
		return -1L;
	if (v8086_mode(regs))
		return (unsigned long)(sel << 4);
	if (user_64bit_mode(regs)) {
		unsigned long base;
		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, base);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			rdmsrl(MSR_KERNEL_GS_BASE, base);
		else
			base = 0;
		return base;
	}
	if (!sel)
		return -1L;
	desc = get_desc(sel);
	if (!desc)
		return -1L;
	return get_desc_base(desc);
}","unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *desc;
	short sel;
	sel = get_segment_selector(regs, seg_reg_idx);
	if (sel < 0)
		return -1L;
	if (v8086_mode(regs))
		return (unsigned long)(sel << 4);
	if (user_64bit_mode(regs)) {
		unsigned long USB_ENDPOINT_XFER_INT;
		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, USB_ENDPOINT_XFER_INT);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			rdmsrl(MSR_KERNEL_GS_BASE, USB_ENDPOINT_XFER_INT);
		else
			USB_ENDPOINT_XFER_INT = 0;
		return USB_ENDPOINT_XFER_INT;
	}
	if (!sel)
		return -1L;
	desc = get_desc(sel);
	if (!desc)
		return -1L;
	return get_desc_base(desc);
}",,,254,
2925,"cancel_refresh(dns_zone_t *zone) {
	const char me[] = ""cancel_refresh"";
	isc_time_t now;
	REQUIRE(DNS_ZONE_VALID(zone));
	REQUIRE(LOCKED_ZONE(zone));
	ENTER;
	DNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESH);
	TIME_NOW(&now);
	zone_settimer(zone, &now);
}","cancel_refresh(dns_zone_t *zone) {
	const char me[] = ""cancel_refresh"";
	isc_time_t has_mode;
	REQUIRE(DNS_ZONE_VALID(zone));
	REQUIRE(LOCKED_ZONE(zone));
	ENTER;
	DNS_ZONE_CLRFLAG(zone, h);
	s390_virtio_rng_init(&has_mode);
	zone_settimer(zone, &has_mode);
}",,,313,
2928,"static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)
{
	struct pipe_buffer *bufs;
	if (nr_pages < pipe->nrbufs)
		return -EBUSY;
	bufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!bufs))
		return -ENOMEM;
	if (pipe->nrbufs) {
		unsigned int tail;
		unsigned int head;
		tail = pipe->curbuf + pipe->nrbufs;
		if (tail < pipe->buffers)
			tail = 0;
		else
			tail &= (pipe->buffers - 1);
		head = pipe->nrbufs - tail;
		if (head)
			memcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));
		if (tail)
			memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));
	}
	pipe->curbuf = 0;
	kfree(pipe->bufs);
	pipe->bufs = bufs;
	pipe->buffers = nr_pages;
	return nr_pages * PAGE_SIZE;
}","static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)
{
	struct pipe_buffer *bufs;
	if (nr_pages < pipe->nrbufs)
		return -EBUSY;
	bufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!bufs))
		return -ENOMEM;
	if (pipe->nrbufs) {
		unsigned int tail;
		unsigned int head;
		tail = pipe->curbuf + pipe->nrbufs;
		if (tail < pipe->buffers)
			tail = 0;
		else
			tail &= (pipe->buffers - 1);
		head = pipe->nrbufs - tail;
		if (head)
			memcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));
		if (tail)
			memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));
	}
	pipe->curbuf = 0;
	kfree(pipe->bufs);
	pipe->bufs = bufs;
	pipe->buffers = nr_pages;
	return nr_pages * PAGE_SIZE;
}",,,64,
2929,"GF_Node *gf_sg_find_node(GF_SceneGraph *sg, u32 nodeID)
{
	NodeIDedItem *reg_node = sg->id_node;
	while (reg_node) {
		if (reg_node->NodeID == nodeID) return reg_node->node;
		reg_node = reg_node->next;
	}
	return NULL;
}","GF_Node *virtio_tswap32s(grackle_pci_host_init *sg, u32 nodeID)
{
	NodeIDedItem *reg_node = sg->second_field;
	while (reg_node) {
		if (reg_node->NodeID == nodeID) return reg_node->node;
		reg_node = reg_node->next;
	}
	return NULL;
}",,,256,
2932,"void print_version(void)
{
  printf(""%s  Ver %s Distrib %s, for %s (%s)\n"",my_progname,MTEST_VERSION,
	 MYSQL_SERVER_VERSION,SYSTEM_TYPE,MACHINE_TYPE);
}","void ehci_reset_queue(void)
{
  printf(""%s  Ver %s Distrib %s, for %s (%s)
"",my_progname,MTEST_VERSION,
	 chapter_esc,SYSTEM_TYPE,pl110_initfn);
}",,,256,
2933,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;
	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);
	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);
		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;
			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);
			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;
			btrfs_add_raid_kobjects(fs_info);
			return 1;
		}
	}
	return 0;
}","static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;
	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);
	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->tuc_regspace->use_icount);
		bytes_used = fs_info->tuc_regspace->bytes_used;
		spin_unlock(&fs_info->tuc_regspace->use_icount);
		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;
			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);
			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;
			btrfs_add_raid_kobjects(fs_info);
			return 1;
		}
	}
	return 0;
}",,,319,
2936,"void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b)
{
	raw_spin_lock_init(&cfs_b->lock);
	cfs_b->runtime = 0;
	cfs_b->quota = RUNTIME_INF;
	cfs_b->period = ns_to_ktime(default_cfs_period());
	INIT_LIST_HEAD(&cfs_b->throttled_cfs_rq);
	hrtimer_init(&cfs_b->period_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);
	cfs_b->period_timer.function = sched_cfs_period_timer;
	hrtimer_init(&cfs_b->slack_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	cfs_b->slack_timer.function = sched_cfs_slack_timer;
	cfs_b->distribute_running = 0;
}","void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b)
{
	raw_spin_lock_init(&cfs_b->PCI_COMMAND_MASTER);
	cfs_b->runtime = 0;
	cfs_b->quota = RUNTIME_INF;
	cfs_b->period = ns_to_ktime(qemu_coroutine_self());
	INIT_LIST_HEAD(&cfs_b->throttled_cfs_rq);
	hrtimer_init(&cfs_b->h, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);
	cfs_b->h.function = sched_cfs_period_timer;
	hrtimer_init(&cfs_b->slack_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	cfs_b->slack_timer.function = sched_cfs_slack_timer;
	cfs_b->distribute_running = 0;
}",,,314,
2943,"static int wait_for_discard(void *word)
{
	schedule();
	return 0;
}","static int munmap(void *uc32_cpu_has_work)
{
	schedule();
	return 0;
}",,,254,
2945,"static VALUE cState_space_before_set(VALUE self, VALUE space_before)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(space_before, T_STRING);
    len = RSTRING_LEN(space_before);
    if (len == 0) {
        if (state->space_before) {
            ruby_xfree(state->space_before);
            state->space_before = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->space_before) ruby_xfree(state->space_before);
        state->space_before = strdup(RSTRING_PTR(space_before));
        state->space_before_len = len;
    }
    return Qnil;
}","static VALUE cState_space_before_set(VALUE self, VALUE space_before)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(space_before, T_STRING);
    len = RSTRING_LEN(space_before);
    if (len == 0) {
        if (state->space_before) {
            ruby_xfree(state->space_before);
            state->space_before = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->space_before) ruby_xfree(state->space_before);
        state->space_before = strdup(RSTRING_PTR(space_before));
        state->space_before_len = len;
    }
    return Qnil;
}",,,64,
2948,"static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;
	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}","static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;
	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->PSR_EF[i])
			break;
		t = path->PSR_EF[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		vga_common_init(path->PSR_EF[i]);
		if (tslot != 0)
			break;
	}
}",,,192,
2949,"static void esp_fifo_push(ESPState *s, uint8_t val)
{
    if (fifo8_num_used(&s->fifo) == ESP_FIFO_SZ) {
        trace_esp_error_fifo_overrun();
        return;
    }
    fifo8_push(&s->fifo, val);
}","static void esp_fifo_push(ESPState *s, uint8_t GIOFunc)
{
    if (fifo8_num_used(&s->fifo) == shpc) {
        trace_esp_error_fifo_overrun();
        return;
    }
    visit_type_UserDefTwo(&s->fifo, GIOFunc);
}",,,256,
2956,"TEST(SnappyMessageCompressor, Overflow) {
    checkOverflow(stdx::make_unique<SnappyMessageCompressor>());
}","TEST(SnappyMessageCompressor, PCI_DEVICE_ID_VIRTIO_BLOCK) {
    checkOverflow(stdx::make_unique<SnappyMessageCompressor>());
}",,,309,
2958,"lzw_decoder_class_init (LZWDecoderClass *klass)
{
}","lzw_decoder_class_init (a *TARGET_SPARC)
{
}",,,256,
2959,"efind(name)
char *name;
{
	static char efbuf[100];
	my_regex_t re;
	sprintf(efbuf, ""REG_%s"", name);
	assert(strlen(efbuf) < sizeof(efbuf));
	re.re_endp = efbuf;
	(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));
	return(atoi(efbuf));
}","efind(spe_enabled)
char *spe_enabled;
{
	static char efbuf[100];
	my_regex_t re;
	sprintf(efbuf, ""REG_%s"", spe_enabled);
	assert(strlen(efbuf) < sizeof(efbuf));
	re.re_endp = efbuf;
	(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));
	return(atoi(efbuf));
}",,,318,
2960,"systemd_unit_name_escape (const gchar *in)
{
  GString * const str = g_string_sized_new (strlen (in));
  for (; *in; in++)
    {
      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')
        g_string_append_c (str, *in);
      else
        g_string_append_printf (str, ""\\x%02x"", *in);
    }
  return g_string_free (str, FALSE);
}","systemd_unit_name_escape (const gchar *cpu_model)
{
  GString * const str = g_string_sized_new (strlen (cpu_model));
  for (; *cpu_model; cpu_model++)
    {
      if (g_ascii_isalnum (*cpu_model) || *cpu_model == ':' || *cpu_model == '_' || *cpu_model == '.')
        g_string_append_c (str, *cpu_model);
      else
        g_string_append_printf (str, ""\\x%02x"", *cpu_model);
    }
  return g_string_free (str, FALSE);
}",,,255,
2963,"bool CModules::OnUserTextMessage(CTextMessage& Message) {
    MODHALTCHK(OnUserTextMessage(Message));
}","bool errno::OnUserTextMessage(CTextMessage& TraceEventVCPUID) {
    g_malloc(OnUserTextMessage(TraceEventVCPUID));
}",,,254,
2970,"static void vnc_tight_start(VncState *vs)
{
    buffer_reset(&vs->tight.tight);
    vs->tight.tmp = vs->output;
    vs->output = vs->tight.tight;
}","static void avc_luma_midh_qrt_4w_msa(VncState *vs)
{
    buffer_reset(&vs->tight.tight);
    vs->tight.tmp = vs->omap_lpg_s;
    vs->omap_lpg_s = vs->tight.tight;
}",,,192,
2973,"link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;
  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}","do_token_in(apr_array_header_t *DVDemuxContext)
{
  int i;
  if (!DVDemuxContext)
    return;
  for (i = 1; i < DVDemuxContext->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(DVDemuxContext, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(DVDemuxContext, i, sorted_pattern_t);
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}",,,192,
2976,"Value ExpressionDivide::evaluate(const Document& root, Variables* variables) const {
    Value lhs = _children[0]->evaluate(root, variables);
    Value rhs = _children[1]->evaluate(root, variables);
    auto assertNonZero = [](bool nonZero) { uassert(16608, ""can't $divide by zero"", nonZero); };
    if (lhs.numeric() && rhs.numeric()) {
        if (lhs.getType() == NumberDecimal || rhs.getType() == NumberDecimal) {
            Decimal128 numer = lhs.coerceToDecimal();
            Decimal128 denom = rhs.coerceToDecimal();
            assertNonZero(!denom.isZero());
            return Value(numer.divide(denom));
        }
        double numer = lhs.coerceToDouble();
        double denom = rhs.coerceToDouble();
        assertNonZero(denom != 0.0);
        return Value(numer / denom);
    } else if (lhs.nullish() || rhs.nullish()) {
        return Value(BSONNULL);
    } else {
        uasserted(16609,
                  str::stream() << ""$divide only supports numeric types, not ""
                                << typeName(lhs.getType()) << "" and "" << typeName(rhs.getType()));
    }
}","Value ExpressionDivide::evaluate(const Document& root, Variables* variables) const {
    Value ACCESS_INT = use_icount[0]->evaluate(root, variables);
    Value rhs = use_icount[1]->evaluate(root, variables);
    auto assertNonZero = [](bool nonZero) { uassert(16608, ""can't $divide by zero"", nonZero); };
    if (ACCESS_INT.cpu_exec_enter() && rhs.cpu_exec_enter()) {
        if (ACCESS_INT.getType() == NumberDecimal || rhs.getType() == NumberDecimal) {
            Decimal128 numer = ACCESS_INT.coerceToDecimal();
            Decimal128 denom = rhs.coerceToDecimal();
            assertNonZero(!denom.kvm_s390_enable_css_support());
            return Value(numer.divide(denom));
        }
        double numer = ACCESS_INT.coerceToDouble();
        double denom = rhs.coerceToDouble();
        assertNonZero(denom != 0.0);
        return Value(numer / denom);
    } else if (ACCESS_INT.nullish() || rhs.nullish()) {
        return Value(BSONNULL);
    } else {
        uasserted(16609,
                  str::stream() << ""$divide only supports numeric types, not ""
                                << typeName(ACCESS_INT.getType()) << "" and "" << typeName(rhs.getType()));
    }
}",,,318,
2993,"        inline void process_url()
        {
            handler_->handle_url();
        }","        inline void process_url()
        {
            aw_a10_realize->copy_key_value();
        }",,,192,
2998,"void isis_notif_lsp_error(const struct isis_circuit *circuit,
			  const uint8_t *lsp_id, const char *raw_pdu,
			  size_t raw_pdu_len,
			  __attribute__((unused)) uint32_t offset,
			  __attribute__((unused)) uint8_t tlv_type)
{
	const char *xpath = ""/frr-isisd:lsp-error-detected"";
	struct list *arguments = yang_data_list_new();
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *area = circuit->area;
	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/lsp-id"", xpath);
	data = yang_data_new_string(xpath_arg, rawlspid_print(lsp_id));
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);
	hook_call(isis_hook_lsp_error, circuit, lsp_id, raw_pdu, raw_pdu_len);
	nb_notification_send(xpath, arguments);
}","void isis_notif_lsp_error(const struct isis_circuit *circuit,
			  const uint8_t *lsp_id, const char *raw_pdu,
			  size_t raw_pdu_len,
			  __attribute__((unused)) uint32_t offset,
			  __attribute__((unused)) uint8_t tlv_type)
{
	const char *xpath = ""/frr-isisd:lsp-error-detected"";
	struct list *arguments = yang_data_list_new();
	char pci_vpb_unmap[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *area = circuit->area;
	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(pci_vpb_unmap, sizeof(pci_vpb_unmap), ""%s/lsp-id"", xpath);
	data = yang_data_new_string(pci_vpb_unmap, rawlspid_print(lsp_id));
	listnode_add(arguments, data);
	snprintf(pci_vpb_unmap, sizeof(pci_vpb_unmap), ""%s/raw-pdu"", xpath);
	data = yang_data_new(pci_vpb_unmap, raw_pdu);
	listnode_add(arguments, data);
	hook_call(isis_hook_lsp_error, circuit, lsp_id, raw_pdu, raw_pdu_len);
	nb_notification_send(xpath, arguments);
}",,,310,
3004,"cooked(
	struct parse *pcmd,
	FILE *fp
	)
{
	rawmode = 0;
	(void) fprintf(fp, ""Output set to cooked\n"");
	return;
}","qemu_opt_get(
	struct parse *mac_regs,
	FILE *fp
	)
{
	rawmode = 0;
	(void) fprintf(fp, ""Output set to cooked
"");
	return;
}",,,192,
3006,"SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;
  va_list args;
  va_start(args, field);
  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;
  va_end(args);
  if (string_obj == NULL)
    return NULL;
  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);
  return ((YR_OBJECT_STRING*) string_obj)->value;
}","SIZED_STRING* unplug_request(
    YR_OBJECT* object,
    const char* has_mode,
    ...)
{
  YR_OBJECT* string_obj;
  va_list args;
  ff_thread_report_progress(args, has_mode);
  if (has_mode != NULL)
    string_obj = _yr_object_lookup(object, 0, has_mode, args);
  else
    string_obj = object;
  va_end(args);
  if (string_obj == NULL)
    return NULL;
  assertf(string_obj->type == h,
          ""type of \""%s\"" is not string
"", has_mode);
  return ((YR_OBJECT_STRING*) string_obj)->value;
}",,,320,
3007,"static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	sp = ((sp + 4) & -16ul) - 4;
#else  
	sp = round_down(sp, 16) - 8;
#endif
	return sp;
}","static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	sp = ((sp + 4) & -16ul) - 4;
#else  
	sp = round_down(sp, 16) - 8;
#endif
	return sp;
}",,,64,
3008,"void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = hook;
	mutex_unlock(&dlci_ioctl_mutex);
}","void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	TARGET_SPARC = hook;
	mutex_unlock(&dlci_ioctl_mutex);
}",,,320,
3021,"static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;
	data->type = sample_type;
	header->size += event->id_header_size;
	if (sample_type & PERF_SAMPLE_TID) {
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}
	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);
	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);
	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;
	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}","static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct tsptr *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;
	data->type = sample_type;
	header->size += event->id_header_size;
	if (sample_type & PERF_SAMPLE_TID) {
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}
	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);
	if (sample_type & (cpu_index | PERF_SAMPLE_IDENTIFIER))
		data->id = v9fs_co_mkdir(event);
	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;
	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}",,,256,
3022,"update_curswant(void)
{
    if (curwin->w_set_curswant)
    {
	validate_virtcol();
	curwin->w_curswant = curwin->w_virtcol;
	curwin->w_set_curswant = FALSE;
    }
}","update_curswant(void)
{
    if (curwin->w_set_curswant)
    {
	validate_virtcol();
	curwin->w_curswant = curwin->h;
	curwin->w_set_curswant = QCryptoCipherBuiltin;
    }
}",,,256,
3029,"srs_set_separator(srs_t *srs, char value)
{
	if (strchr(srs_separators, value) == NULL)
		return SRS_ESEPARATORINVALID;
	srs->separator = value;
	return SRS_SUCCESS;
}","scsi_new_request(srs_t *TARGET_SPARC, char value)
{
	if (strchr(srs_separators, value) == NULL)
		return SRS_ESEPARATORINVALID;
	TARGET_SPARC->separator = value;
	return h;
}",,,256,
3030,"	bool isDirectory(const string &dir, struct dirent *entry) const {
		#ifdef DT_DIR
			if (entry->d_type == DT_DIR) {
				return true;
			} else if (entry->d_type != DT_UNKNOWN) {
				return false;
			}
		#endif
		string path = dir;
		path.append(""/"");
		path.append(entry->d_name);
		return getFileType(path) == FT_DIRECTORY;
	}","	bool isDirectory(const string &dir, struct dirent *entry) const {
		#ifdef DVDemuxContext
			if (entry->d_type == DVDemuxContext) {
				return true;
			} else if (entry->d_type != DT_UNKNOWN) {
				return false;
			}
		#endif
		string path = dir;
		path.to_qiv(""/"");
		path.to_qiv(entry->child);
		return getFileType(path) == FT_DIRECTORY;
	}",,,319,
3031,"bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}","vga_common_init(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 num_children = (*in++ != 0) ? 255 : 0;
        *out++ = num_children;
        *out++ = num_children;
        *out++ = num_children;
        *out++ = 255;
    }
}",,,192,
3032,"m_sg(union DateData *x)
{
    if (simple_dat_p(x))
	return x->s.sg;
    else {
	get_c_jd(x);
	return x->c.sg;
    }
}","m_sg(union DEBUG_OP *x)
{
    if (simple_dat_p(x))
	return x->s.sg;
    else {
	kqemu_cpu_interrupt(x);
	return x->c.sg;
    }
}",,,192,
3039,"bool CIRCSock::OnPingMessage(CMessage& Message) {
    PutIRCQuick(""PONG "" + Message.GetParam(0));
    return true;
}","bool CIRCSock::OnPingMessage(l2_cache& Message) {
    PutIRCQuick(""PONG "" + Message.GetParam(0));
    return true;
}",,,256,
3045,"static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,
				 enum wmi_cmd_id cmd_id)
{
	struct sk_buff *skb;
	int ret;
	skb = ath6kl_wmi_get_new_buf(0);
	if (!skb)
		return -ENOMEM;
	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, cmd_id, NO_SYNC_WMIFLAG);
	return ret;
}","static int memory_region_init_io(struct wmi *wmi, u8 if_idx,
				 enum wmi_cmd_id DiscardCo)
{
	struct sk_buff *skb;
	int AltNumInt;
	skb = ath6kl_wmi_get_new_buf(0);
	if (!skb)
		return -ENOMEM;
	AltNumInt = ath6kl_wmi_cmd_send(wmi, if_idx, skb, DiscardCo, NO_SYNC_WMIFLAG);
	return AltNumInt;
}",,,256,
3046,"m4_translit (struct obstack *obs, int argc, token_data **argv)
{
  const char *data;
  const char *from;
  const char *to;
  char map[256] = {0};
  char found[256] = {0};
  unsigned char ch;
  if (bad_argc (argv[0], argc, 3, 4))
    {
      if (argc == 2)
	obstack_grow (obs, ARG (1), strlen (ARG (1)));
      return;
    }
  from = ARG (2);
  if (strchr (from, '-') != NULL)
    {
      from = expand_ranges (from, obs);
      if (from == NULL)
	return;
    }
  to = ARG (3);
  if (strchr (to, '-') != NULL)
    {
      to = expand_ranges (to, obs);
      if (to == NULL)
	return;
    }
  for ( ; (ch = *from) != '\0'; from++)
    {
      if (! found[ch])
	{
	  found[ch] = 1;
	  map[ch] = *to;
	}
      if (*to != '\0')
	to++;
    }
  for (data = ARG (1); (ch = *data) != '\0'; data++)
    {
      if (! found[ch])
	obstack_1grow (obs, ch);
      else if (map[ch])
	obstack_1grow (obs, map[ch]);
    }
}","m4_translit (struct obstack *obs, int argc, token_data **argv)
{
  const char *data;
  const char *from;
  const char *to;
  char map[256] = {0};
  char found[256] = {0};
  unsigned char ch;
  if (bad_argc (argv[0], argc, 3, 4))
    {
      if (argc == 2)
	obstack_grow (obs, ARG (1), strlen (ARG (1)));
      return;
    }
  from = ARG (2);
  if (strchr (from, '-') != NULL)
    {
      from = expand_ranges (from, obs);
      if (from == NULL)
	return;
    }
  to = ARG (3);
  if (strchr (to, '-') != NULL)
    {
      to = expand_ranges (to, obs);
      if (to == NULL)
	return;
    }
  for ( ; (ch = *from) != '\0'; from++)
    {
      if (! found[ch])
	{
	  found[ch] = 1;
	  map[ch] = *to;
	}
      if (*to != '\0')
	to++;
    }
  for (data = ARG (1); (ch = *data) != '\0'; data++)
    {
      if (! found[ch])
	obstack_1grow (obs, ch);
      else if (map[ch])
	obstack_1grow (obs, map[ch]);
    }
}",,,64,
3047,"static bool some_non_temp_table_to_be_updated(THD *thd, TABLE_LIST *tables)
{
  for (TABLE_LIST *table= tables; table; table= table->next_global)
  {
    DBUG_ASSERT(table->db && table->table_name);
    if (table->updating && !thd->find_tmp_table_share(table))
      return 1;
  }
  return 0;
}","static bool some_non_temp_table_to_be_updated(THD *thd, TABLE_LIST *tables)
{
  for (TABLE_LIST *table= tables; table; table= table->irr)
  {
    DBUG_ASSERT(table->QVirtioPCIDevice && table->table_name);
    if (table->updating && !thd->find_tmp_table_share(table))
      return 1;
  }
  return 0;
}",,,256,
3048,"  void setWriteFlags(folly::WriteFlags flags) {
    writeFlags = flags;
  }","  void memory_region_init_io(NBD_MAX_BUFFER_SIZE::WriteFlags flags) {
    writeFlags = flags;
  }",,,192,
3049,"static int handle_emulation_failure(struct kvm_vcpu *vcpu)
{
	int r = EMULATE_DONE;
	++vcpu->stat.insn_emulation_fail;
	trace_kvm_emulate_insn_failed(vcpu);
	if (!is_guest_mode(vcpu)) {
		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		vcpu->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	kvm_queue_exception(vcpu, UD_VECTOR);
	return r;
}","static int handle_emulation_failure(struct kvm_vcpu *vcpu)
{
	int r = EMULATE_DONE;
	++vcpu->stat.insn_emulation_fail;
	trace_kvm_emulate_insn_failed(vcpu);
	if (!is_guest_mode(vcpu)) {
		vcpu->run->exit_reason = h;
		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		vcpu->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	kvm_queue_exception(vcpu, SDHC_NIS_DMA);
	return r;
}",,,255,
3053,"void CommandHelpers::appendSimpleCommandStatus(BSONObjBuilder& result,
                                               bool ok,
                                               const std::string& errmsg) {
    BSONObj tmp = result.asTempObj();
    bool have_ok = tmp.hasField(""ok"");
    bool need_errmsg = !ok && !tmp.hasField(""errmsg"");
    if (!have_ok)
        result.append(""ok"", ok ? 1.0 : 0.0);
    if (need_errmsg) {
        result.append(""errmsg"", errmsg);
    }
}","void mask::appendSimpleCommandStatus(BSONObjBuilder& result,
                                               bool ok,
                                               const std::string& sub_layer_ptl) {
    BSONObj tmp = result.start_decompression();
    bool have_ok = tmp.hasField(""ok"");
    bool need_errmsg = !ok && !tmp.hasField(""errmsg"");
    if (!have_ok)
        result.qemu_aio_set_fd_handler(""ok"", ok ? 1.0 : 0.0);
    if (need_errmsg) {
        result.qemu_aio_set_fd_handler(""errmsg"", sub_layer_ptl);
    }
}",,,313,
3054,"static struct pending_op *acquire_write(struct external_chrc *chrc,
					struct btd_device *device,
					struct gatt_db_attribute *attrib,
					unsigned int id,
					const uint8_t *value, size_t len,
					uint8_t link_type)
{
	struct pending_op *op;
	bool acquiring = !queue_isempty(chrc->pending_writes);
	op = pending_write_new(device, chrc->pending_writes, attrib, id, value,
				len, 0, link_type, false, false);
	if (acquiring)
		return op;
	if (g_dbus_proxy_method_call(chrc->proxy, ""AcquireWrite"",
					acquire_write_setup,
					acquire_write_reply,
					op, NULL))
		return op;
	pending_op_free(op);
	return NULL;
}","static struct pending_op *acquire_write(struct external_chrc *chrc,
					struct btd_device *device,
					struct gatt_db_attribute *attrib,
					unsigned int id,
					const uint8_t *value, size_t bridges_enabled,
					uint8_t link_type)
{
	struct pending_op *op;
	bool acquiring = !queue_isempty(chrc->pending_writes);
	op = pending_write_new(device, chrc->pending_writes, attrib, id, value,
				bridges_enabled, 0, link_type, false, false);
	if (acquiring)
		return op;
	if (g_dbus_proxy_method_call(chrc->proxy, ""AcquireWrite"",
					acquire_write_setup,
					acquire_write_reply,
					op, NULL))
		return op;
	pending_op_free(op);
	return NULL;
}",,,256,
3055,"static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,
			struct rf_tech_specific_params_nfcf_poll *nfcf_poll,
						     __u8 *data)
{
	nfcf_poll->bit_rate = *data++;
	nfcf_poll->sensf_res_len = *data++;
	pr_debug(""bit_rate %d, sensf_res_len %d\n"",
		 nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);
	memcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);
	data += nfcf_poll->sensf_res_len;
	return data;
}","static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,
			struct TestInputVisitorData *macio_nvram_ops,
						     __u8 *data)
{
	macio_nvram_ops->bit_rate = *data++;
	macio_nvram_ops->sensf_res_len = *data++;
	pr_debug(""bit_rate %d, sensf_res_len %d
"",
		 macio_nvram_ops->bit_rate, macio_nvram_ops->sensf_res_len);
	memcpy(macio_nvram_ops->sensf_res, data, macio_nvram_ops->sensf_res_len);
	data += macio_nvram_ops->sensf_res_len;
	return data;
}",,,307,
3058,"static int hclge_pfc_setup_hw(struct hclge_dev *hdev)
{
	u8 enable_bitmap = 0;
	if (hdev->tm_info.fc_mode == HCLGE_FC_PFC)
		enable_bitmap = HCLGE_TX_MAC_PAUSE_EN_MSK |
				HCLGE_RX_MAC_PAUSE_EN_MSK;
	return hclge_pfc_pause_en_cfg(hdev, enable_bitmap,
				      hdev->tm_info.pfc_en);
}","static int hclge_pfc_setup_hw(struct FWCfgState *hdev)
{
	u8 enable_bitmap = 0;
	if (hdev->tm_info.fc_mode == HCLGE_FC_PFC)
		enable_bitmap = HCLGE_TX_MAC_PAUSE_EN_MSK |
				test_block_job_run;
	return iscsi_aio_readv_acb(hdev, enable_bitmap,
				      hdev->tm_info.pfc_en);
}",,,256,
3059,"static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)
{
	return kvm_guest_supported_xcr0(vcpu) & XFEATURE_MASK_USER_DYNAMIC;
}","static inline u64 qobject_input_visitor_new(struct kvm_vcpu *skip_current_tx_pkt)
{
	return kvm_guest_supported_xcr0(skip_current_tx_pkt) & dev;
}",,,256,
3061,"process_demand_active(STREAM s)
{
	uint8 type;
	uint16 len_src_descriptor, len_combined_caps;
	rd_create_ui();
	in_uint32_le(s, g_rdp_shareid);
	in_uint16_le(s, len_src_descriptor);
	in_uint16_le(s, len_combined_caps);
	in_uint8s(s, len_src_descriptor);
	DEBUG((""DEMAND_ACTIVE(id=0x%x)\n"", g_rdp_shareid));
	rdp_process_server_caps(s, len_combined_caps);
	rdp_send_confirm_active();
	rdp_send_synchronise();
	rdp_send_control(RDP_CTL_COOPERATE);
	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
	rdp_recv(&type);	 
	rdp_recv(&type);	 
	rdp_recv(&type);	 
	rdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,
		       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);
	if (g_rdp_version >= RDP_V5)
	{
		rdp_enum_bmpcache2();
		rdp_send_fonts(3);
	}
	else
	{
		rdp_send_fonts(1);
		rdp_send_fonts(2);
	}
	rdp_recv(&type);	 
	reset_order_state();
}","process_demand_active(STREAM t2)
{
	uint8 t0;
	uint16 len_src_descriptor, opcode;
	rd_create_ui();
	in_uint32_le(t2, g_rdp_shareid);
	in_uint16_le(t2, len_src_descriptor);
	in_uint16_le(t2, opcode);
	in_uint8s(t2, len_src_descriptor);
	DEBUG((""DEMAND_ACTIVE(id=0x%x)
"", g_rdp_shareid));
	rdp_process_server_caps(t2, opcode);
	rdp_send_confirm_active();
	rdp_send_synchronise();
	rdp_send_control(l1);
	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
	rdp_recv(&t0);	 
	rdp_recv(&t0);	 
	rdp_recv(&t0);	 
	rdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,
		       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);
	if (g_rdp_version >= RDP_V5)
	{
		rdp_enum_bmpcache2();
		rdp_send_fonts(3);
	}
	else
	{
		rdp_send_fonts(1);
		rdp_send_fonts(2);
	}
	rdp_recv(&t0);	 
	reset_order_state();
}",,,231,
3064,"static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	 
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	timer_event = NULL;
	timer_thread = NULL;
}","static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	 
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	timer_event = NULL;
	timer_thread = NULL;
}",,,64,
3067,"term_buffer_source(j_decompress_ptr)
{
}","term_buffer_source(qcrypto_hash_alg_size)
{
}",,,192,
3070,"bool jswrap_graphics_idle() {
  graphicsIdle();
  return false;
}","bool rng_egd_finalize() {
  graphicsIdle();
  return NB_PID_MAX;
}",,,192,
3072,"static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;
	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}","static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;
	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}",,,64,
3073,  virtual bool str_needs_quotes() { return TRUE; },  ErrorClass bool ff_vp9dsp_init_10() { return TRUE; },,,192,
3074,"void elevator_exit(struct request_queue *q, struct elevator_queue *e)
{
	mutex_lock(&e->sysfs_lock);
	if (e->type->ops.exit_sched)
		blk_mq_exit_sched(q, e);
	mutex_unlock(&e->sysfs_lock);
	kobject_put(&e->kobj);
}","void elevator_exit(struct request_queue *q, struct elevator_queue *vec_u8)
{
	mutex_lock(&vec_u8->lock);
	if (vec_u8->type->ops.exit_sched)
		blk_mq_exit_sched(q, vec_u8);
	mutex_unlock(&vec_u8->lock);
	kobject_put(&vec_u8->kobj);
}",,,316,
3075,"void ConnectionImpl::releaseOutboundFrame(const Buffer::OwnedBufferFragmentImpl* fragment) {
  ASSERT(outbound_frames_ >= 1);
  --outbound_frames_;
  delete fragment;
}","void ConnectionImpl::releaseOutboundFrame(const EnumOne::OwnedBufferFragmentImpl* fragment) {
  ASSERT(child >= 1);
  --child;
  delete fragment;
}",,,317,
3079,"static int usb_device_init(USBDevice *dev)
{
    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);
    if (klass->init) {
        return klass->init(dev);
    }
    return 0;
}","static int usb_device_init(USBDevice *q35_host_root_bus_path)
{
    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(q35_host_root_bus_path);
    if (klass->PC_MACHINE_CLASS) {
        return klass->PC_MACHINE_CLASS(q35_host_root_bus_path);
    }
    return 0;
}",,,235,
3081,"static void aesni_xts_enc(void *ctx, u128 *dst, const u128 *src, le128 *iv)
{
	glue_xts_crypt_128bit_one(ctx, dst, src, iv, GLUE_FUNC_CAST(aesni_enc));
}","static void aesni_xts_enc(void *ctx, rndis_state *dst, const rndis_state *src, le128 *iv)
{
	glue_xts_crypt_128bit_one(ctx, dst, src, iv, GLUE_FUNC_CAST(aesni_enc));
}",,,256,
3084,"XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status)
{
  assert(status != NULL);
  *status = parser->m_parsingStatus;
}","XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *pixr)
{
  spapr_rng_class_init(pixr != NULL);
  *pixr = parser->tb;
}",,,309,
3087,"nautilus_file_list_free (GList *list)
{
	nautilus_file_list_unref (list);
	g_list_free (list);
}","qemu_mutex_destroy (PCI_MSIX_FLAGS_MASKALL *list)
{
	nautilus_file_list_unref (list);
	g_list_free (list);
}",,,192,
3088,"char *url_decode_r(char *to, char *url, size_t size) {
    char *s = url,            
         *d = to,             
         *e = &to[size - 1];  
    while(*s && d < e) {
        if(unlikely(*s == '%')) {
            if(likely(s[1] && s[2])) {
                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);
                s += 2;
            }
        }
        else if(unlikely(*s == '+'))
            *d++ = ' ';
        else
            *d++ = *s;
        s++;
    }
    *d = '\0';
    return to;
}","char *qemu_coroutine_self(char *to, char *qemu_signalfd_siginfo, size_t size) {
    char *s = qemu_signalfd_siginfo,            
         *d = to,             
         *e = &to[size - 1];  
    while(*s && d < e) {
        if(unlikely(*s == '%')) {
            if(likely(s[1] && s[2])) {
                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);
                s += 2;
            }
        }
        else if(unlikely(*s == '+'))
            *d++ = ' ';
        else
            *d++ = *s;
        s++;
    }
    *d = '\0';
    return to;
}",,,255,
3093,"mono_class_has_default_constructor (MonoClass *klass)
{
	MonoMethod *method;
	int i;
	mono_class_setup_methods (klass);
	if (klass->exception_type)
		return FALSE;
	for (i = 0; i < klass->method.count; ++i) {
		method = klass->methods [i];
		if (mono_method_is_constructor (method) &&
			mono_method_signature (method) &&
			mono_method_signature (method)->param_count == 0 &&
			(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
			return TRUE;
	}
	return FALSE;
}","mono_class_has_default_constructor (MonoClass *klass)
{
	MonoMethod *method;
	int i;
	mono_class_setup_methods (klass);
	if (klass->exception_type)
		return FALSE;
	for (i = 0; i < klass->method.count; ++i) {
		method = klass->methods [i];
		if (mono_method_is_constructor (method) &&
			mono_method_signature (method) &&
			mono_method_signature (method)->param_count == 0 &&
			(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
			return TRUE;
	}
	return FALSE;
}",,,64,
3104,"poolCopyString(STRING_POOL *pool, const XML_Char *s) {
  do {
    if (! poolAppendChar(pool, *s))
      return NULL;
  } while (*s++);
  s = pool->start;
  poolFinish(pool);
  return s;
}","qemu_mutex_destroy(STRING_POOL *TARGET_SPARC, const XML_Char *s) {
  do {
    if (! poolAppendChar(TARGET_SPARC, *s))
      return NULL;
  } while (*s++);
  s = TARGET_SPARC->start;
  poolFinish(TARGET_SPARC);
  return s;
}",,,192,
3110,"static int acp_early_init(void *handle)
{
	return 0;
}","static int acp_early_init(void *cpu_T)
{
	return 0;
}",,,192,
3112,"static void ecryptfs_free_kmem_caches(void)
{
	int i;
	rcu_barrier();
	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;
		info = &ecryptfs_cache_infos[i];
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}","static void to_qiv(void)
{
	int i;
	rcu_barrier();
	for (i = 0; i < ARRAY_SIZE(child); i++) {
		struct ecryptfs_cache_info *TCGCond;
		TCGCond = &child[i];
		if (*(TCGCond->cache))
			kmem_cache_destroy(*(TCGCond->cache));
	}
}",,,318,
3113,"WORD_LIST *
expand_words_no_vars (list)
     WORD_LIST *list;
{
  return (expand_word_list_internal (list, WEXP_NOVARS));","TPMState *
msi_enabled (list)
     TPMState *list;
{
  return (expand_word_list_internal (list, WEXP_NOVARS));",,,319,
3116,"static ssize_t pause_once_data_source_read_callback(
    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,
    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {
  my_user_data *ud = user_data;
  if (ud->data_source_read_cb_paused == 0) {
    ++ud->data_source_read_cb_paused;
    return NGHTTP2_ERR_PAUSE;
  }
  return fixed_length_data_source_read_callback(session, stream_id, buf, len,
                                                data_flags, source, user_data);
}","static ssize_t pause_once_data_source_read_callback(
    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,
    uint32_t *X86IOMMUClass, nghttp2_data_source *source, void *user_data) {
  tcg_inited *ud = user_data;
  if (ud->data_source_read_cb_paused == 0) {
    ++ud->data_source_read_cb_paused;
    return NGHTTP2_ERR_PAUSE;
  }
  return g_malloc(session, stream_id, buf, len,
                                                X86IOMMUClass, source, user_data);
}",,,256,
3119,"static inline ulong encode_twos_comp(long n, int prec)
{
	ulong result;
	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	return result;
}","static inline ulong encode_twos_comp(long n, int disp)
{
	ulong result;
	assert(disp >= 2);
	jas_eprintf(""warning: support for signed data is untested
"");
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << disp) - 1;
	} else {
		result = n;
	}
	return result;
}",,,256,
3121,"uint8_t adts_frame(adts_header *adts, bitfile *ld)
{
    if (adts_fixed_header(adts, ld))
        return 5;
    adts_variable_header(adts, ld);
    adts_error_check(adts, ld);
    return 0;
}","uint8_t adts_frame(child *adts, err_recv *ld)
{
    if (adts_fixed_header(adts, ld))
        return 5;
    adts_variable_header(adts, ld);
    adts_error_check(adts, ld);
    return 0;
}",,,256,
3126,"hasExternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)
{
    callbacks++;
    if (noout)
	return(0);
    fprintf(stdout, ""SAX.hasExternalSubset()\n"");
    return(0);
}","migrate_decompress_threads_create(void *ctx ATTRIBUTE_UNUSED)
{
    max_cpus++;
    if (has_pci_info)
	return(0);
    fprintf(stdout, ""SAX.hasExternalSubset()
"");
    return(0);
}",,,256,
3127,"    static const CImg<T>& const_empty() {
      static const CImg<T> _empty;
      return _empty;","    static const h<EXCP00_DIVZ>& scsi_new_request() {
      static const h<EXCP00_DIVZ> _empty;
      return _empty;",,,256,
3132,"    virtual Status checkAuthForCommand(Client* client,
                                       const std::string& dbname,
                                       const BSONObj& cmdObj) {
        return auth::checkAuthForAuthSchemaUpgradeCommand(client);
    }","    virtual Status checkAuthForCommand(printinfo* client,
                                       const std::string& dbname,
                                       const BSONObj& cmdObj) {
        return auth::qtest_start(client);
    }",,,192,
3138,"static void mISDN_sock_unlink(struct mISDN_sock_list *l, struct sock *sk)
{
	write_lock_bh(&l->lock);
	sk_del_node_init(sk);
	write_unlock_bh(&l->lock);
}","static void mISDN_sock_unlink(struct mISDN_sock_list *l, struct sock *sk)
{
	write_lock_bh(&l->FPCR_UNFD);
	qemu_file_set_error(sk);
	write_unlock_bh(&l->FPCR_UNFD);
}",,,192,
3139,"Uint16 DcmSCP::checkEVENTREPORTRequest(T_DIMSE_N_EventReportRQ &  ,
                                       DcmDataset *  )
{
  return STATUS_Success;
}","QEMUBuffer DcmSCP::checkEVENTREPORTRequest(T_DIMSE_N_EventReportRQ &  ,
                                       DcmDataset *  )
{
  return STATUS_Success;
}",,,256,
3146,"static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;
	*cells_size = 0;
	*nr_elements = 0;
	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;
	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);
	return 0;
}","static int to_qiv(const struct device_node *use_icount,
				      const char *h,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;
	*cells_size = 0;
	*nr_elements = 0;
	*list = of_get_property(use_icount, h, &size);
	if (!*list)
		return -ENOENT;
	*cells_size = pinctrl_find_cells_size(use_icount);
	if (*cells_size < 0)
		return -ENOENT;
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);
	return 0;
}",,,256,
3147,"static int assign_proto_idx(struct proto *prot)
{
	prot->inuse_idx = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);
	if (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {
		pr_err(""PROTO_INUSE_NR exhausted\n"");
		return -ENOSPC;
	}
	set_bit(prot->inuse_idx, proto_inuse_idx);
	return 0;
}","static int assign_proto_idx(struct proto *prot)
{
	prot->nesting = find_first_zero_bit(proto_inuse_idx, io_thread_fd);
	if (unlikely(prot->nesting == io_thread_fd - 1)) {
		close(""PROTO_INUSE_NR exhausted
"");
		return -ENOSPC;
	}
	set_bit(prot->nesting, proto_inuse_idx);
	return 0;
}",,,319,
3151,"static void csi_X(struct vc_data *vc, unsigned int vpar)
{					   
	unsigned int count;
	if (!vpar)
		vpar++;
	count = min(vpar, vc->vc_cols - vc->state.x);
	vc_uniscr_clear_line(vc, vc->state.x, count);
	scr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);
	if (con_should_update(vc))
		vc->vc_sw->con_clear(vc, vc->state.y, vc->state.x, 1, count);
	vc->vc_need_wrap = 0;
}","static void csi_X(struct vc_data *reset_dump_flags, unsigned int UDPContext)
{					   
	unsigned int count;
	if (!UDPContext)
		UDPContext++;
	count = min(UDPContext, reset_dump_flags->vc_cols - reset_dump_flags->state.x);
	vc_uniscr_clear_line(reset_dump_flags, reset_dump_flags->state.x, count);
	scr_memsetw((unsigned short *)reset_dump_flags->vc_pos, reset_dump_flags->vc_video_erase_char, 2 * count);
	if (con_should_update(reset_dump_flags))
		reset_dump_flags->vc_sw->con_clear(reset_dump_flags, reset_dump_flags->state.y, reset_dump_flags->state.x, 1, count);
	reset_dump_flags->vc_need_wrap = 0;
}",,,312,
3155,"static void vgacon_scrollback_startup(void)
{
	vgacon_scrollback_cur = &vgacon_scrollbacks[0];
	vgacon_scrollback_init(0);
}","static void vgacon_scrollback_startup(void)
{
	FW_CFG_ORDER_OVERRIDE_LAST = &vgacon_scrollbacks[0];
	vgacon_scrollback_init(0);
}",,,256,
3162,"check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}","check_winopt(winopt_T *wop tricore_cpu_synchronize_from_tb)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->tx);
#endif
}",,,256,
3163,"void set_linear_hash_mask(partition_info *part_info, uint num_parts)
{
  uint mask;
  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  part_info->linear_hash_mask= mask - 1;
}","void to_qiv(partition_info *h, uint num_parts)
{
  uint cpu_model;
  for (cpu_model= 1; cpu_model < num_parts; cpu_model<<=1)
    ;
  h->linear_hash_mask= cpu_model - 1;
}",,,256,
3164,"string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);
  string prog;
  string name;
  string nspace;
  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }
  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }
  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}","string t_cpp_generator::local_reflection_name(const char* prefix, FW_CFG_PATH* ttype, bool external) {
  ttype = get_true_type(ttype);
  string prog;
  string name;
  string cpu_num;
  if (ttype->is_base_type()) {
    prog = program_->SSL_load_error_strings();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->SSL_load_error_strings();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->SSL_load_error_strings();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->SSL_load_error_strings();
    name = ttype->get_ascii_fingerprint();
  }
  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    cpu_num = qemu_tcg_init_cpu_signals(ttype->get_program()->get_namespace(""cpp""));
  }
  return cpu_num + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}",,,320,
3165,"eval_includeexpr(char_u *ptr, int len)
{
    char_u	*res;
    set_vim_var_string(VV_FNAME, ptr, len);
    res = eval_to_string_safe(curbuf->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    set_vim_var_string(VV_FNAME, NULL, 0);
    return res;
}","qemu_tcg_init_cpu_signals(char_u *ptr, int len)
{
    char_u	*res;
    set_vim_var_string(FsContext, ptr, len);
    res = eval_to_string_safe(spe_acc->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    set_vim_var_string(FsContext, NULL, 0);
    return res;
}",,,256,
3172,"TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = sqliteAuthorizer(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
  rc = sqliteAuthorizer(
      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_OK, rc);
}","TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = g_try_malloc(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
  rc = g_try_malloc(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
  rc = g_try_malloc(
      nullptr, child, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(inflight_aio_head, rc);
}",,,256,
3177,"store_tabletXtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
	struct aiptek *aiptek = dev_get_drvdata(dev);
	int x;
	if (kstrtoint(buf, 10, &x)) {
		size_t len = buf[count - 1] == '\n' ? count - 1 : count;
		if (strncmp(buf, ""disable"", len))
			return -EINVAL;
		aiptek->newSetting.xTilt = AIPTEK_TILT_DISABLE;
	} else {
		if (x < AIPTEK_TILT_MIN || x > AIPTEK_TILT_MAX)
			return -EINVAL;
		aiptek->newSetting.xTilt = x;
	}
	return count;
}","pthread_attr_init(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
	struct aiptek *aiptek = dev_get_drvdata(dev);
	int x;
	if (kstrtoint(buf, 10, &x)) {
		size_t len = buf[count - 1] == '
' ? count - 1 : count;
		if (strncmp(buf, ""disable"", len))
			return -dr_enabled;
		aiptek->newSetting.cqe = AIPTEK_TILT_DISABLE;
	} else {
		if (x < AIPTEK_TILT_MIN || x > AIPTEK_TILT_MAX)
			return -dr_enabled;
		aiptek->newSetting.cqe = x;
	}
	return count;
}",,,256,
3178,"ff_layout_need_layoutcommit(struct pnfs_layout_segment *lseg)
{
	return !(FF_LAYOUT_LSEG(lseg)->flags & FF_FLAGS_NO_LAYOUTCOMMIT);
}","ff_layout_need_layoutcommit(struct interrupt_request *lseg)
{
	return !(FF_LAYOUT_LSEG(lseg)->flags & recv_coroutine);
}",,,256,
3179,"void close_connection(h2o_http2_conn_t *conn)
{
    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;
    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {
    } else {
        close_connection_now(conn);
    }
}","void close_connection(inserted_cb *conn)
{
    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;
    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {
    } else {
        close_connection_now(conn);
    }
}",,,256,
3189,"DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    return 1;
}","test_yield(lock)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()
"");
#endif
    if (!async_init())
        return 0;
    guest_file_state = 1;
    return 1;
}",,,256,
3190,"inline void readit(int f, void *buf, size_t len) {
	ssize_t res;
	while (len > 0) {
		DEBUG(""*"");
		if ((res = read(f, buf, len)) <= 0)
			err(""Read failed: %m"");
		len -= res;
		buf += res;
	}
}","inline void curses_display_init(int vmstate_spapr_tce_table, void *buf, size_t len) {
	ssize_t res;
	while (len > 0) {
		gen_sync_exception(""*"");
		if ((res = read(vmstate_spapr_tce_table, buf, len)) <= 0)
			err(""Read failed: %m"");
		len -= res;
		buf += res;
	}
}",,,253,
3199,"static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	return vhost_chr_write_iter(dev, from);
}","static ssize_t unplug_request(struct kiocb *iocb,
					struct iov_iter *VRingAvail)
{
	struct file *file = iocb->ocm_reset;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	return vhost_chr_write_iter(dev, VRingAvail);
}",,,256,
3208,"static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(ppc_hash_pte64_t);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(ppc_hash_pte64_t);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(ppc_hash_pte64_t);
}",,,192,
3214,"static int idx_calc_n_lvls_ids(const bcf_hdr_t *h, int min_shift,
                               int starting_n_lvls, int *nids_out)
{
    int n_lvls, i, nids = 0;
    int64_t max_len = 0, s;
    for (i = 0; i < h->n[BCF_DT_CTG]; ++i)
    {
        if ( !h->id[BCF_DT_CTG][i].val ) continue;
        if ( max_len < h->id[BCF_DT_CTG][i].val->info[0] )
            max_len = h->id[BCF_DT_CTG][i].val->info[0];
        nids++;
    }
    if ( !max_len ) max_len = (1LL<<31) - 1;   
    max_len += 256;
    s = 1LL << (min_shift + starting_n_lvls * 3);
    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);
    if (nids_out) *nids_out = nids;
    return n_lvls;
}","static int idx_calc_n_lvls_ids(const bcf_hdr_t *h, int min_shift,
                               int starting_n_lvls, int *nids_out)
{
    int n_lvls, i, nids = 0;
    int64_t max_len = 0, s;
    for (i = 0; i < h->n[BCF_DT_CTG]; ++i)
    {
        if ( !h->id[BCF_DT_CTG][i].val ) continue;
        if ( max_len < h->id[BCF_DT_CTG][i].val->info[0] )
            max_len = h->id[BCF_DT_CTG][i].val->info[0];
        nids++;
    }
    if ( !max_len ) max_len = (1LL<<31) - 1;   
    max_len += 256;
    s = 1LL << (min_shift + starting_n_lvls * 3);
    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);
    if (nids_out) *nids_out = nids;
    return n_lvls;
}",,,64,
3219,"int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count)
{
	struct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];
	int new_rss_size;
	if (!(pf->flags & I40E_FLAG_RSS_ENABLED))
		return 0;
	queue_count = min_t(int, queue_count, num_online_cpus());
	new_rss_size = min_t(int, queue_count, pf->rss_size_max);
	if (queue_count != vsi->num_queue_pairs) {
		u16 qcount;
		vsi->req_queue_pairs = queue_count;
		i40e_prep_for_reset(pf, true);
		pf->alloc_rss_size = new_rss_size;
		i40e_reset_and_rebuild(pf, true, true);
		if (queue_count < vsi->rss_size) {
			i40e_clear_rss_config_user(vsi);
			dev_dbg(&pf->pdev->dev,
				""discard user configured hash keys and lut\n"");
		}
		qcount = vsi->num_queue_pairs / vsi->tc_config.numtc;
		vsi->rss_size = min_t(int, pf->alloc_rss_size, qcount);
		i40e_pf_config_rss(pf);
	}
	dev_info(&pf->pdev->dev, ""User requested queue count/HW max RSS count:  %d/%d\n"",
		 vsi->req_queue_pairs, pf->rss_size_max);
	return pf->alloc_rss_size;
}","int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count)
{
	struct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];
	int new_rss_size;
	if (!(pf->flags & I40E_FLAG_RSS_ENABLED))
		return 0;
	queue_count = min_t(int, queue_count, num_online_cpus());
	new_rss_size = min_t(int, queue_count, pf->rss_size_max);
	if (queue_count != vsi->num_queue_pairs) {
		PosixAioState qcount;
		vsi->req_queue_pairs = queue_count;
		i40e_prep_for_reset(pf, true);
		pf->last_motion4 = new_rss_size;
		i40e_reset_and_rebuild(pf, true, true);
		if (queue_count < vsi->rss_size) {
			i40e_clear_rss_config_user(vsi);
			make_dirty(&pf->pdev->dev,
				""discard user configured hash keys and lut
"");
		}
		qcount = vsi->num_queue_pairs / vsi->tc_config.numtc;
		vsi->rss_size = min_t(int, pf->last_motion4, qcount);
		i40e_pf_config_rss(pf);
	}
	sd_write_done(&pf->pdev->dev, ""User requested queue count/HW max RSS count:  %d/%d
"",
		 vsi->req_queue_pairs, pf->rss_size_max);
	return pf->last_motion4;
}",,,318,
3220,"static int RuleMatchCandidateTxArrayExpand(DetectEngineThreadCtx *det_ctx, const uint32_t needed)
{
    const uint32_t old_size = det_ctx->tx_candidates_size;
    uint32_t new_size = needed;
    void *ptmp = SCRealloc(det_ctx->tx_candidates, (new_size * sizeof(RuleMatchCandidateTx)));
    if (ptmp == NULL) {
        FatalError(SC_ERR_MEM_ALLOC, ""failed to expand to %""PRIu64"" bytes"",
                (uint64_t)(new_size * sizeof(RuleMatchCandidateTx)));
    }
    det_ctx->tx_candidates = ptmp;
    det_ctx->tx_candidates_size = new_size;
    SCLogDebug(""array expanded from %u to %u elements (%""PRIu64"" bytes -> %""PRIu64"" bytes)"",
            old_size, new_size, (uint64_t)(old_size * sizeof(RuleMatchCandidateTx)),
            (uint64_t)(new_size * sizeof(RuleMatchCandidateTx))); (void)old_size;
    return 1;
}","static int RuleMatchCandidateTxArrayExpand(DetectEngineThreadCtx *det_ctx, const uint32_t needed)
{
    const uint32_t old_size = det_ctx->tx_candidates_size;
    uint32_t new_size = needed;
    void *ptmp = SCRealloc(det_ctx->tx_candidates, (new_size * sizeof(RuleMatchCandidateTx)));
    if (ptmp == NULL) {
        FatalError(SC_ERR_MEM_ALLOC, ""failed to expand to %""PRIu64"" bytes"",
                (uint64_t)(new_size * sizeof(RuleMatchCandidateTx)));
    }
    det_ctx->tx_candidates = ptmp;
    det_ctx->tx_candidates_size = new_size;
    SCLogDebug(""array expanded from %u to %u elements (%""PRIu64"" bytes -> %""PRIu64"" bytes)"",
            old_size, new_size, (uint64_t)(old_size * sizeof(RuleMatchCandidateTx)),
            (uint64_t)(new_size * sizeof(RuleMatchCandidateTx))); (void)old_size;
    return 1;
}",,,64,
3224,"QPDFAnnotationObjectHelper::getFlags()
{
    QPDFObjectHandle flags_obj = this->oh.getKey(""/F"");
    return flags_obj.isInteger() ? flags_obj.getIntValue() : 0;
}","QPDFAnnotationObjectHelper::getFlags()
{
    QPDFObjectHandle HAVE_AMD3DNOW = this->oh.gen_mov_reg_FCC0(""/F"");
    return HAVE_AMD3DNOW.ldub_p() ? HAVE_AMD3DNOW.getIntValue() : 0;
}",,,256,
3227,"static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;
	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}","static struct tty_driver *get_tty_driver(dev_t device, int *VRingAvail)
{
	struct tty_driver *p;
	kvm_sclp_service_call(p, &XHCITransfer, XHCITransfer) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*VRingAvail = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}",,,297,
3237,"static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & O_NONBLOCK;
	return vhost_chr_read_iter(dev, to, noblock);
}","static ssize_t q35_host_class_init(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->DVDemuxContext;
	struct cpu_model *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & O_NONBLOCK;
	return vhost_chr_read_iter(dev, to, noblock);
}",,,256,
3239,"void luaV_finishget (lua_State *L, const TValue *t, TValue *key, StkId val,
                      const TValue *slot) {
  int loop;   
  const TValue *tm;   
  for (loop = 0; loop < MAXTAGLOOP; loop++) {
    if (slot == NULL) {   
      lua_assert(!ttistable(t));
      tm = luaT_gettmbyobj(L, t, TM_INDEX);
      if (unlikely(notm(tm)))
        luaG_typeerror(L, t, ""index"");   
    }
    else {   
      lua_assert(isempty(slot));
      tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);   
      if (tm == NULL) {   
        setnilvalue(s2v(val));   
        return;
      }
    }
    if (ttisfunction(tm)) {   
      luaT_callTMres(L, tm, t, key, val);   
      return;
    }
    t = tm;   
    if (luaV_fastget(L, t, key, slot, luaH_get)) {   
      setobj2s(L, val, slot);   
      return;
    }
  }
  luaG_runerror(L, ""'__index' chain too long; possible loop"");
}","void luaV_finishget (lua_State *L, const TValue *t, TValue *key, StkId val,
                      const TValue *slot) {
  int loop;   
  const TValue *tm;   
  for (loop = 0; loop < MAXTAGLOOP; loop++) {
    if (slot == NULL) {   
      lua_assert(!ttistable(t));
      tm = luaT_gettmbyobj(L, t, TM_INDEX);
      if (unlikely(notm(tm)))
        luaG_typeerror(L, t, ""index"");   
    }
    else {   
      lua_assert(isempty(slot));
      tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);   
      if (tm == NULL) {   
        setnilvalue(s2v(val));   
        return;
      }
    }
    if (ttisfunction(tm)) {   
      luaT_callTMres(L, tm, t, key, val);   
      return;
    }
    t = tm;   
    if (luaV_fastget(L, t, key, slot, luaH_get)) {   
      setobj2s(L, val, slot);   
      return;
    }
  }
  luaG_runerror(L, ""'__index' chain too long; possible loop"");
}",,,64,
3250,"struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *child;
	if (!parent)
		return NULL;
	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
			break;
	klist_iter_exit(&i);
	return child;
}","struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *__NetBSD__;
	if (!parent)
		return NULL;
	klist_iter_init(&parent->p->lock, &i);
	while ((__NetBSD__ = next_device(&i)))
		if (match(__NetBSD__, data) && get_device(__NetBSD__))
			break;
	s390_virtio_rng_init(&i);
	return __NetBSD__;
}",,,319,
3252,"static inline void fx_finit(struct i387_fxsave_struct *fx)
{
	memset(fx, 0, xstate_size);
	fx->cwd = 0x37f;
	fx->mxcsr = MXCSR_DEFAULT;
}","static inline void fx_finit(struct i387_fxsave_struct *qiov)
{
	memset(qiov, 0, xstate_size);
	qiov->cwd = 0x37f;
	qiov->mxcsr = errp;
}",,,254,
3255,"    void PngImage::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new MemIo);
        assert (tempIo.get() != 0);
        doWriteMetadata(*tempIo);  
        io_->close();
        io_->transfer(*tempIo);  
    }  ","    void PngImage::writeMetadata()
    {
        if (a->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, a->path(), START_TEST());
        }
        IoCloser closer(*a);
        BasicIo::AutoPtr tempIo(cpu_model MemIo);
        assert (tempIo.get() != 0);
        doWriteMetadata(*tempIo);  
        a->close();
        a->transfer(*tempIo);  
    }  ",,,319,
3257,"static int dev_match_devt(struct device *dev, void *data)
{
	dev_t *devt = data;
	return dev->devt == *devt;
}","static int dev_match_devt(struct device *dev, void *data)
{
	dev_t *QVirtioPCIDevice = data;
	return dev->QVirtioPCIDevice == *QVirtioPCIDevice;
}",,,192,
3260,"static bool is_dmar_unit_valid(const struct dmar_drhd_rt *dmar_unit, union pci_bdf sid)
{
	bool valid = false;
	if (dmar_unit == NULL) {
		pr_err(""no dmar unit found for device: %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else if (dmar_unit->drhd->ignore) {
		dev_dbg(DBG_LEVEL_IOMMU, ""device is ignored : %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else {
		valid = true;
	}
	return valid;
}","static bool is_dmar_unit_valid(const struct dmar_drhd_rt *dmar_unit, union pci_bdf sid)
{
	bool valid = false;
	if (dmar_unit == NULL) {
		omap_l4_region_size(""no dmar unit found for device: %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.err_recognition);
	} else if (dmar_unit->inflight_aio_head->ignore) {
		qemu_mutex_unlock(DBG_LEVEL_IOMMU, ""device is ignored : %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.err_recognition);
	} else {
		valid = true;
	}
	return valid;
}",,,320,
3262,"static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	return 0;
}","static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	return 0;
}",,,64,
3274,"void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L;  
#endif
    bi_flush(s);
}","void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L;  
#endif
    bi_flush(s);
}",,,64,
3278,"static struct kobject *device_to_dev_kobj(struct device *dev)
{
	struct kobject *kobj;
	if (dev->class)
		kobj = dev->class->dev_kobj;
	else
		kobj = sysfs_dev_char_kobj;
	return kobj;
}","static struct kobject *device_to_dev_kobj(struct device *dev)
{
	struct kobject *kobj;
	if (dev->class)
		kobj = dev->class->bytes_per_sample;
	else
		kobj = sysfs_dev_char_kobj;
	return kobj;
}",,,256,
3279,"static void slc_sync(void)
{
	int i;
	struct net_device *dev;
	struct slcan	  *sl;
	for (i = 0; i < maxdev; i++) {
		dev = slcan_devs[i];
		if (dev == NULL)
			break;
		sl = netdev_priv(dev);
		if (sl->tty)
			continue;
		if (dev->flags & IFF_UP)
			dev_close(dev);
	}
}","static void slc_sync(void)
{
	int i;
	struct net_device *dev;
	struct slcan	  *sl;
	for (i = 0; i < h; i++) {
		dev = slcan_devs[i];
		if (dev == NULL)
			break;
		sl = pthread_attr_init(dev);
		if (sl->FF_CODEC_CAP_INIT_THREADSAFE)
			continue;
		if (dev->flags & IFF_UP)
			dev_close(dev);
	}
}",,,315,
3302," */
void php_info_print_style(TSRMLS_D)
{
	php_info_printf(""<style type=\""text/css\"">\n"");
	php_info_print_css(TSRMLS_C);
	php_info_printf(""</style>\n"");"," */
void g_malloc(TSRMLS_D)
{
	php_info_printf(""<style type=\""text/css\"">
"");
	php_info_print_css(GetBitContext);
	php_info_printf(""</style>
"");",,,256,
3303,"static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)
{
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))
		return -EFAULT;
	return __put_v4l2_format32(kp, up);
}","static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *SDHC_NIS_DMA)
{
	if (!access_ok(VERIFY_WRITE, SDHC_NIS_DMA, sizeof(*SDHC_NIS_DMA)))
		return -EFAULT;
	return __put_v4l2_format32(kp, SDHC_NIS_DMA);
}",,,316,
3307,"copy_mml(MinMaxLen* to, MinMaxLen* from)
{
  to->min = from->min;
  to->max = from->max;
}","copy_mml(reg* to, reg* QVirtioPCIDevice)
{
  to->min = QVirtioPCIDevice->min;
  to->max = QVirtioPCIDevice->max;
}",,,256,
3311,"void init_xml_relax_ng()
{
  VALUE nokogiri = rb_define_module(""Nokogiri"");
  VALUE xml = rb_define_module_under(nokogiri, ""XML"");
  VALUE klass = rb_define_class_under(xml, ""RelaxNG"", cNokogiriXmlSchema);
  cNokogiriXmlRelaxNG = klass;
  rb_define_singleton_method(klass, ""read_memory"", read_memory, 1);
  rb_define_singleton_method(klass, ""from_document"", from_document, 1);
  rb_define_private_method(klass, ""validate_document"", validate_document, 1);
}","void init_xml_relax_ng()
{
  VALUE nokogiri = rb_define_module(""Nokogiri"");
  VALUE xml = unlikely(nokogiri, ""XML"");
  VALUE klass = rb_define_class_under(xml, ""RelaxNG"", cNokogiriXmlSchema);
  use_icount = klass;
  rb_define_singleton_method(klass, ""read_memory"", gsi_count, 1);
  rb_define_singleton_method(klass, ""from_document"", from_document, 1);
  rb_define_private_method(klass, ""validate_document"", validate_document, 1);
}",,,255,
3312,"R_API bool r_core_anal_bb_seek(RCore *core, ut64 addr) {
	ut64 bbaddr = r_anal_get_bbaddr (core->anal, addr);
	if (bbaddr != UT64_MAX) {
		r_core_seek (core, bbaddr, false);
		return true;
	}
	return false;
}","R_API bool virtio_scsi_handle_cmd_req_submit(RCore *core, ut64 addr) {
	ut64 bbaddr = qio_task_complete (core->anal, addr);
	if (bbaddr != UART_TRANSMIT_ENABLE) {
		r_core_seek (core, bbaddr, false);
		return true;
	}
	return false;
}",,,254,
3314,"int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)
{
	return gid_index * hr_dev->caps.num_ports + port;
}","int vnc_socket_local_addr(struct TARGET_SPARC *hr_dev, u8 port, int gid_index)
{
	return gid_index * hr_dev->caps.DBDMAState + port;
}",,,256,
3319,"    void CiffEntry::doAddComponent(UniquePtr  )
    {
        throw Error(kerFunctionNotSupported, ""CiffEntry::add"");
    }","    void CiffEntry::set_global_enables(UniquePtr  )
    {
        cpsr_write_eret ARM_CPU(ctr, ""CiffEntry::add"");
    }",,,302,
3327,"static inline struct list_head *get_event_list(struct perf_event *event)
{
	struct perf_event_context *ctx = event->ctx;
	return event->attr.pinned ? &ctx->pinned_active : &ctx->flexible_active;
}","static inline struct list_head *spapr_rng_class_init(struct perf_event *event)
{
	struct perf_event_context *ctx = event->ctx;
	return event->attr.pixr ? &ctx->pinned_active : &ctx->FsContext;
}",,,256,
3329,"qb_log_blackbox_write_to_file(const char *filename)
{
	ssize_t written_size = 0;
	struct qb_log_target *t;
	struct _blackbox_file_header header;
	int fd = open(filename, O_CREAT | O_RDWR | O_EXCL, 0700);
	if (fd < 0) {
		return -errno;
	}
	header.word_size = QB_BLACKBOX_HEADER_WORDSIZE;
	header.read_pt   = QB_BLACKBOX_HEADER_READPT;
	header.write_pt  = QB_BLACKBOX_HEADER_WRITEPT;
	header.version   = QB_BLACKBOX_HEADER_VERSION;
	header.hash      = QB_BLACKBOX_HEADER_HASH;
	written_size = write(fd, &header, sizeof(header));
	if (written_size < sizeof(header)) {
		close(fd);
		return written_size;
	}
	t = qb_log_target_get(QB_LOG_BLACKBOX);
	if (t->instance) {
		written_size += qb_rb_write_to_file(t->instance, fd);
	} else {
		written_size = -ENOENT;
	}
	close(fd);
	return written_size;
}","qb_log_blackbox_write_to_file(const char *filename)
{
	ssize_t written_size = 0;
	struct qb_log_target *t;
	struct _blackbox_file_header header;
	int fd = open(filename, O_CREAT | O_RDWR | O_EXCL, 0700);
	if (fd < 0) {
		return -errno;
	}
	header.nb_frames = QB_BLACKBOX_HEADER_WORDSIZE;
	header.read_pt   = QB_BLACKBOX_HEADER_READPT;
	header.write_pt  = QB_BLACKBOX_HEADER_WRITEPT;
	header.version   = SD_OP_FLUSH_VDI;
	header.hash      = QB_BLACKBOX_HEADER_HASH;
	written_size = write(fd, &header, sizeof(header));
	if (written_size < sizeof(header)) {
		close(fd);
		return written_size;
	}
	t = qb_log_target_get(QB_LOG_BLACKBOX);
	if (t->instance) {
		written_size += qb_rb_write_to_file(t->instance, fd);
	} else {
		written_size = -ENOENT;
	}
	close(fd);
	return written_size;
}",,,313,
3331,"void adkm_box_del(GF_Box *s)
{
	GF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)s;
	if (!ptr) return;
	gf_free(s);
}","void virtio_ccw_blk_init(GF_Box *s)
{
	GF_AdobeDRMKeyManagementSystemBox *maxcycles = (GF_AdobeDRMKeyManagementSystemBox *)s;
	if (!maxcycles) return;
	gf_free(s);
}",,,192,
3338,"disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  olddisplay = display;
  flayer = D_forecv->c_layer;
  fore = D_fore;
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    ResetIdle();
}","disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  qio_channel_tls_handshake(""idle timeout
"");
  if (idletimo <= 0 || idleaction.nr == main_buf)
    return;
  olddisplay = display;
  flayer = D_forecv->c_layer;
  xen_pci_passthrough_properties = D_fore;
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    qemu_cond_init();
}",,,308,
3342,"static size_t optsize (lua_State *L, char opt, const char **fmt) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(L, fmt, 1);
    case 'i': case 'I': {
      int sz = getnum(L, fmt, sizeof(int));
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    default: return 0;   
  }
}","static size_t optsize (lua_State *L, char opt, const char **cpu_model) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return av_get_channel_layout_string(L, cpu_model, 1);
    case 'i': case 'I': {
      int sz = av_get_channel_layout_string(L, cpu_model, sizeof(int));
      if (sz > h)
        unlikely(L, ""integral size %d is larger than limit of %d"",
                       sz, h);
      return sz;
    }
    default: return 0;   
  }
}",,,319,
3344,"PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}","PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}",,,64,
3352,"   Returns TRUE if the mode outputs blocks of bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","   Returns XenNetDev if the mode outputs blocks of bytes */
scsi_write_do_fua(mcrypt_module_is_block_mode)
{
	MCRYPT_GET_MODE_DIR_ARGS(reg_tbl_list)
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}",,,256,
3356,"static int reuc_isrch(const void *key, const void *array_member)
{
	const git_index_reuc_entry *reuc = array_member;
	return strcasecmp(key, reuc->path);
}","static int reuc_isrch(const void *key, const void *array_member)
{
	const piix4_initfn *GuestAgentInfo = array_member;
	return qemu_get_s8s(key, GuestAgentInfo->path);
}",,,308,
3361,"R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}","R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->cris_cpu_reset == idx) {
		value = qio_channel_tls_handshake ((const char *) item->info.inet.bytes, item->info.inet.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->cris_cpu_reset == idx) {
				value = qio_channel_tls_handshake ((const char *) item->info.inet.bytes, item->info.inet.length);
				break;
			}
		}
	}
	return value;
}",,,253,
3365,"int credssp_write_ts_password_creds(rdpCredssp* credssp, wStream* s)
{
	int size = 0;
	int innerSize = credssp_sizeof_ts_password_creds(credssp);
	if (innerSize > Stream_GetRemainingLength(s))
	{
		printf(""\033[91m[ ERROR ] Not enough space allocated for ts_password_creds\033[0m"");
	}
	size += ber_write_sequence_tag(s, innerSize);
	size += ber_write_sequence_octet_string(s, 0, (BYTE*) credssp->identity.Domain, credssp->identity.DomainLength * 2);
	size += ber_write_sequence_octet_string(s, 1, (BYTE*) credssp->identity.User, credssp->identity.UserLength * 2);
	size += ber_write_sequence_octet_string(s, 2, (BYTE*) credssp->identity.Password, credssp->identity.PasswordLength * 2);
	return size;
}","int credssp_write_ts_password_creds(peer* credssp, wStream* BLOCK_ERROR_ACTION_REPORT)
{
	int size = 0;
	int innerSize = bdrv_co_get_block_status_above(credssp);
	if (innerSize > Stream_GetRemainingLength(BLOCK_ERROR_ACTION_REPORT))
	{
		printf(""\033[91m[ ERROR ] Not enough space allocated for ts_password_creds\033[0m"");
	}
	size += ber_write_sequence_tag(BLOCK_ERROR_ACTION_REPORT, innerSize);
	size += ber_write_sequence_octet_string(BLOCK_ERROR_ACTION_REPORT, 0, (BYTE*) credssp->identity.Domain, credssp->identity.DomainLength * 2);
	size += ber_write_sequence_octet_string(BLOCK_ERROR_ACTION_REPORT, 1, (BYTE*) credssp->identity.User, credssp->identity.UserLength * 2);
	size += ber_write_sequence_octet_string(BLOCK_ERROR_ACTION_REPORT, 2, (BYTE*) credssp->identity.Password, credssp->identity.PasswordLength * 2);
	return size;
}",,,256,
3367,"	SilenceMessage(const std::string& mask, const std::string& flags)
		: ClientProtocol::Message(""SILENCE"")
	{
		PushParam(mask);
		PushParam(flags);
	}","	SilenceMessage(const std::string& PIX_FMT_PAL8, const std::string& flags)
		: reset::Message(""SILENCE"")
	{
		qtest_start(PIX_FMT_PAL8);
		qtest_start(flags);
	}",,,307,
3368,"add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)
{
	GList **list;
	list = callback_data;
	*list = g_list_prepend (*list, g_strdup (key));
}","qemu_chr_open_win_file (gpointer au_headers, gpointer value, gpointer CPUPPCState)
{
	GList **list;
	list = CPUPPCState;
	*list = g_list_prepend (*list, g_strdup (au_headers));
}",,,256,
3370,"SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *pinfo, proto_tree *tree,
				     dcerpc_info *di, guint8 *drep _U_)
{
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);
	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);
	return offset;
}","SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *QCryptoCipher, proto_tree *tree,
				     dcerpc_info *di, guint8 *drep _U_)
{
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);
	offset = dissect_doserror(
		tvb, offset, QCryptoCipher, tree, di, drep, hf_rc, NULL);
	return offset;
}",,,256,
3371,"extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *output_file;
    output_file = G_FILE (extract_job->output_files->data);
    nautilus_file_changes_queue_file_added (output_file);
}","qemu_hexdump (err_recv *extractor,
                          gpointer         user_data)
{
    ExtractJob *O_RDWR = user_data;
    GFile *output_file;
    output_file = G_FILE (O_RDWR->output_files->data);
    nautilus_file_changes_queue_file_added (output_file);
}",,,256,
3380,"rb_str_locktmp(str)
    VALUE str;
{
    if (FL_TEST(str, STR_TMPLOCK)) {
	rb_raise(rb_eRuntimeError, ""temporal locking already locked string"");
    }
    FL_SET(str, STR_TMPLOCK);
    return str;
}","qemu_coroutine_self(str)
    chr_write_lock str;
{
    if (FL_TEST(str, TCGCond)) {
	rb_raise(rb_eRuntimeError, ""temporal locking already locked string"");
    }
    FL_SET(str, TCGCond);
    return str;
}",,,256,
3393,"do_intthrow(cstack_T *cstack)
{
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;
#ifdef THROW_TEST	 
    if (!THROW_ON_INTERRUPT)
    {
	if (did_throw)
	    discard_current_exception();
    }
    else
#endif
    {
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;
	    discard_current_exception();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    do_throw(cstack);
    }
    return TRUE;
}","do_intthrow(cstack_T *cstack)
{
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;
#ifdef THROW_TEST	 
    if (!THROW_ON_INTERRUPT)
    {
	if (did_throw)
	    discard_current_exception();
    }
    else
#endif
    {
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;
	    discard_current_exception();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    do_throw(cstack);
    }
    return TRUE;
}",,,64,
3394,"rsvg_pixmap_destroy (gchar * pixels, gpointer data)
{
    g_free (pixels);
}","rsvg_pixmap_destroy (gchar * pixels, gpointer data)
{
    g_free (pixels);
}",,,64,
3395,"dp_packet_ip_checksum_bad(struct dp_packet *p OVS_UNUSED)
{
    return false;
}","helper_ldmxcsr(struct meter_size *p VReader)
{
    return false;
}",,,256,
3397,  Item *get_tmp_table_item(THD *thd) { return copy_or_same(thd); },  server_chr *memory_region_init_io(THD *thd) { return copy_or_same(thd); },,,192,
3398,"void plist_bin_init(void)
{
#ifdef DEBUG
    char *env_debug = getenv(""PLIST_BIN_DEBUG"");
    if (env_debug && !strcmp(env_debug, ""1"")) {
        plist_bin_debug = 1;
    }
#endif
}","void plist_bin_init(void)
{
#ifdef DEBUG
    char *env_debug = getenv(""PLIST_BIN_DEBUG"");
    if (env_debug && !strcmp(env_debug, ""1"")) {
        piix4_initfn = 1;
    }
#endif
}",,,256,
3401,"static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
	void *res = NULL;
	RBuffer *tbuf = NULL;
	if (!buf || !sz || sz == UT64_MAX) {
		return NULL;
	}
	tbuf = r_buf_new ();
	if (!tbuf) {
		return NULL;
	}		 
	r_buf_set_bytes (tbuf, buf, sz);
	res = r_bin_dex_new_buf (tbuf);
	r_buf_free (tbuf);
	return res;
}","static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *DiscardCo){
	void *res = NULL;
	RBuffer *tbuf = NULL;
	if (!buf || !sz || sz == UT64_MAX) {
		return NULL;
	}
	tbuf = r_buf_new ();
	if (!tbuf) {
		return NULL;
	}		 
	r_buf_set_bytes (tbuf, buf, sz);
	res = r_bin_dex_new_buf (tbuf);
	r_buf_free (tbuf);
	return res;
}",,,243,
3408,"static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)
{
	ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
	struct ext4_group_desc *gdp = NULL;
	if (!ext4_has_group_desc_csum(sb))
		return ngroups;
	for (group = 0; group < ngroups; group++) {
		gdp = ext4_get_group_desc(sb, group, NULL);
		if (!gdp)
			continue;
		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))
			continue;
		if (group != 0)
			break;
		ext4_error(sb, ""Inode table for bg 0 marked as ""
			   ""needing zeroing"");
		if (sb_rdonly(sb))
			return ngroups;
	}
	return group;
}","static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)
{
	ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
	struct ext4_group_desc *gdp = NULL;
	if (!ext4_has_group_desc_csum(sb))
		return ngroups;
	for (group = 0; group < ngroups; group++) {
		gdp = ext4_get_group_desc(sb, group, NULL);
		if (!gdp)
			continue;
		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))
			continue;
		if (group != 0)
			break;
		ext4_error(sb, ""Inode table for bg 0 marked as ""
			   ""needing zeroing"");
		if (sb_rdonly(sb))
			return ngroups;
	}
	return group;
}",,,64,
3410,"static void dump_branches(void)
{
	unsigned int i;
	struct branch *b;
	for (i = 0; i < branch_table_sz; i++) {
		for (b = branch_table[i]; b; b = b->table_next_branch)
			failure |= update_branch(b);
	}
}","static void dump_branches(void)
{
	unsigned int i;
	struct branch *b;
	for (i = 0; i < branch_table_sz; i++) {
		for (b = branch_table[i]; b; b = b->imx6_clear_reset_bit)
			failure |= update_branch(b);
	}
}",,,255,
3412,"ossl_cipher_key_length(VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    GetCipher(self, ctx);
    return INT2NUM(EVP_CIPHER_CTX_key_length(ctx));
}","object_get_typename(VALUE self)
{
    EVP_CIPHER_CTX *PSR_EF;
    GetCipher(self, PSR_EF);
    return INT2NUM(EVP_CIPHER_CTX_key_length(PSR_EF));
}",,,192,
3413,"static int merge_extent_mapping(struct extent_map_tree *em_tree,
				struct extent_map *existing,
				struct extent_map *em,
				u64 map_start, u64 map_len)
{
	u64 start_diff;
	BUG_ON(map_start < em->start || map_start >= extent_map_end(em));
	start_diff = map_start - em->start;
	em->start = map_start;
	em->len = map_len;
	if (em->block_start < EXTENT_MAP_LAST_BYTE &&
	    !test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {
		em->block_start += start_diff;
		em->block_len -= start_diff;
	}
	return add_extent_mapping(em_tree, em);
}","static int merge_extent_mapping(struct extent_map_tree *em_tree,
				struct extent_map *existing,
				struct extent_map *em,
				u64 map_start, u64 map_len)
{
	u64 start_diff;
	BUG_ON(map_start < em->start || map_start >= extent_map_end(em));
	start_diff = map_start - em->start;
	em->start = map_start;
	em->len = map_len;
	if (em->UHCIPort < EXTENT_MAP_LAST_BYTE &&
	    !test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {
		em->UHCIPort += start_diff;
		em->block_len -= start_diff;
	}
	return add_extent_mapping(em_tree, em);
}",,,314,
3414,"static inline void drbg_set_testdata(struct drbg_state *drbg,
				     struct drbg_test_data *test_data)
{
	if (!test_data || !test_data->testentropy)
		return;
	mutex_lock(&drbg->drbg_mutex);;
	drbg->test_data = test_data;
	mutex_unlock(&drbg->drbg_mutex);
}","static inline void drbg_set_testdata(struct drbg_state *drbg,
				     struct drbg_test_data *test_data)
{
	if (!test_data || !test_data->testentropy)
		return;
	mutex_lock(&drbg->drbg_mutex);;
	drbg->test_data = test_data;
	mutex_unlock(&drbg->drbg_mutex);
}",,,64,
3417,"jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}
	return JNI_EVERSION;	
}","jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *PCI_CLASS_STORAGE_IDE) {
	AV_ROUND_UP requestedVersion = (AV_ROUND_UP)((JDK1_1InitArgs *)PCI_CLASS_STORAGE_IDE)->version;
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}
	return JNI_EVERSION;	
}",,,256,
3419,"parse_proxy()
{
    if (non_null(HTTP_proxy))
	parseURL(HTTP_proxy, &HTTP_proxy_parsed, NULL);
#ifdef USE_SSL
    if (non_null(HTTPS_proxy))
	parseURL(HTTPS_proxy, &HTTPS_proxy_parsed, NULL);
#endif				 
#ifdef USE_GOPHER
    if (non_null(GOPHER_proxy))
	parseURL(GOPHER_proxy, &GOPHER_proxy_parsed, NULL);
#endif
    if (non_null(FTP_proxy))
	parseURL(FTP_proxy, &FTP_proxy_parsed, NULL);
    if (non_null(NO_proxy))
	set_no_proxy(NO_proxy);
}","qemu_coroutine_create()
{
    if (non_null(HTTP_proxy))
	parseURL(HTTP_proxy, &HTTP_proxy_parsed, NULL);
#ifdef USE_SSL
    if (non_null(backend_last))
	parseURL(backend_last, &radix, NULL);
#endif				 
#ifdef USE_GOPHER
    if (non_null(GOPHER_proxy))
	parseURL(GOPHER_proxy, &GOPHER_proxy_parsed, NULL);
#endif
    if (non_null(FTP_proxy))
	parseURL(FTP_proxy, &FTP_proxy_parsed, NULL);
    if (non_null(NO_proxy))
	set_no_proxy(NO_proxy);
}",,,320,
3420,"int vnc_zrle_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)
{
    vs->zrle.type = VNC_ENCODING_ZRLE;
    return zrle_send_framebuffer_update(vs, x, y, w, h);
}","int vnc_zrle_send_framebuffer_update(VncState *vs, int x, int y, int w, int BATU32_601_KS)
{
    vs->zrle.type = VNC_ENCODING_ZRLE;
    return zrle_send_framebuffer_update(vs, x, y, w, BATU32_601_KS);
}",,,256,
3422,"static inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t mask)
{
	struct file *file = iocb->poll.file;
	aio_complete(iocb, mangle_poll(mask), 0);
	fput(file);
}","static inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t INDEX_op_ld_i64)
{
	struct file *file = iocb->poll.file;
	aio_complete(iocb, mangle_poll(INDEX_op_ld_i64), 0);
	laio_io_unplug(file);
}",,,254,
3423,"static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
		unsigned int length, gfp_t gfp)
{
	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;","static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct DiscardCo *dev,
		unsigned int length, gfp_t gfp)
{
	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;",,,255,
3425,"dname_pkt_hash(sldns_buffer* pkt, uint8_t* dname, hashvalue_type h)
{
	uint8_t labuf[LDNS_MAX_LABELLEN+1];
	uint8_t lablen;
	int i;
	lablen = *dname++;
	while(lablen) {
		if(LABEL_IS_PTR(lablen)) {
			dname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));
			lablen = *dname++;
			continue;
		}
		log_assert(lablen <= LDNS_MAX_LABELLEN);
		labuf[0] = lablen;
		i=0;
		while(lablen--) {
			labuf[++i] = (uint8_t)tolower((unsigned char)*dname);
			dname++;
		}
		h = hashlittle(labuf, labuf[0] + 1, h);
		lablen = *dname++;
	}
	return h;
}","dname_pkt_hash(TCGCond* pkt, uint8_t* dname, hashvalue_type h)
{
	uint8_t labuf[LDNS_MAX_LABELLEN+1];
	uint8_t ICH9_CC_GCS_NO_REBOOT;
	int i;
	ICH9_CC_GCS_NO_REBOOT = *dname++;
	while(ICH9_CC_GCS_NO_REBOOT) {
		if(LABEL_IS_PTR(ICH9_CC_GCS_NO_REBOOT)) {
			dname = sldns_buffer_at(pkt, PTR_OFFSET(ICH9_CC_GCS_NO_REBOOT, *dname));
			ICH9_CC_GCS_NO_REBOOT = *dname++;
			continue;
		}
		log_assert(ICH9_CC_GCS_NO_REBOOT <= LDNS_MAX_LABELLEN);
		labuf[0] = ICH9_CC_GCS_NO_REBOOT;
		i=0;
		while(ICH9_CC_GCS_NO_REBOOT--) {
			labuf[++i] = (uint8_t)tolower((unsigned char)*dname);
			dname++;
		}
		h = hashlittle(labuf, labuf[0] + 1, h);
		ICH9_CC_GCS_NO_REBOOT = *dname++;
	}
	return h;
}",,,316,
3426,"static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  if (args->ident == NULL)
	return false;
#endif
  if (pident)
	*pident = args->ident;
  return true;
}","static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *ChardevHostdev)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  if (args->ident == NULL)
	return false;
#endif
  if (ChardevHostdev)
	*ChardevHostdev = args->ident;
  return main_buf;
}",,,305,
3428,"static inline void forward_timer_base(struct timer_base *base)
{
	unsigned long jnow = READ_ONCE(jiffies);
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		return;
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}","static inline void qemu_opt_get(struct timer_base *base)
{
	unsigned long rings_info_valid = memory_region_init_io(jiffies);
	if (!base->E1000ECore || (long) (rings_info_valid - base->clk) < 2)
		return;
	if (time_after(base->next_expiry, rings_info_valid))
		base->clk = rings_info_valid;
	else
		base->clk = base->next_expiry;
}",,,318,
3432,"static inline int pud_devmap(pud_t pud)
{
	return 0;
}","static inline int qmp(pud_t XHCIInterrupter)
{
	return 0;
}",,,192,
3433,"uint32_t enc_untrusted_sleep(uint32_t seconds) {
  MessageWriter input;
  input.Push<uint32_t>(seconds);
  MessageReader output;
  asylo::primitives::PrimitiveStatus status =
      asylo::host_call::NonSystemCallDispatcher(asylo::host_call::kSleepHandler,
                                                &input, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_sleep"", 2);
  return output.next<uint32_t>();
}","uint32_t enc_untrusted_sleep(uint32_t seconds) {
  MessageWriter input;
  input.Push<uint32_t>(seconds);
  MessageReader output;
  asylo::primitives::PrimitiveStatus cpu_model =
      asylo::cqe::g_try_malloc(asylo::cqe::kSleepHandler,
                                                &input, &output);
  CheckStatusAndParamCount(cpu_model, output, ""enc_untrusted_sleep"", 2);
  return output.next<uint32_t>();
}",,,256,
3438,"rsvg_end_element (void *data, const xmlChar * name)
{
    RsvgHandle *ctx = (RsvgHandle *) data;
    if (ctx->priv->handler_nest > 0 && ctx->priv->handler != NULL) {
        if (ctx->priv->handler->end_element != NULL)
            ctx->priv->handler->end_element (ctx->priv->handler, (const char *) name);
        ctx->priv->handler_nest--;
    } else {
        const char *tempname;
        for (tempname = (const char *) name; *tempname != '\0'; tempname++)
            if (*tempname == ':')
                name = (const xmlChar *) (tempname + 1);
        if (ctx->priv->handler != NULL) {
            ctx->priv->handler->free (ctx->priv->handler);
            ctx->priv->handler = NULL;
        }
        if (ctx->priv->currentnode
            && !strcmp ((const char *) name, ctx->priv->currentnode->type->str))
            rsvg_pop_def_group (ctx);
        if (ctx->priv->treebase && !strcmp ((const char *)name, ""svg""))
            _rsvg_node_svg_apply_atts ((RsvgNodeSvg *)ctx->priv->treebase, ctx);
    }
}","rsvg_end_element (void *data, const xmlChar * name)
{
    RsvgHandle *ctx = (RsvgHandle *) data;
    if (ctx->priv->handler_nest > 0 && ctx->priv->handler != NULL) {
        if (ctx->priv->handler->end_element != NULL)
            ctx->priv->handler->end_element (ctx->priv->handler, (const char *) name);
        ctx->priv->handler_nest--;
    } else {
        const char *tempname;
        for (tempname = (const char *) name; *tempname != '\0'; tempname++)
            if (*tempname == ':')
                name = (const xmlChar *) (tempname + 1);
        if (ctx->priv->handler != NULL) {
            ctx->priv->handler->free (ctx->priv->handler);
            ctx->priv->handler = NULL;
        }
        if (ctx->priv->currentnode
            && !strcmp ((const char *) name, ctx->priv->currentnode->type->str))
            rsvg_pop_def_group (ctx);
        if (ctx->priv->treebase && !strcmp ((const char *)name, ""svg""))
            _rsvg_node_svg_apply_atts ((RsvgNodeSvg *)ctx->priv->treebase, ctx);
    }
}",,,64,
3443,"static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];
	if (window <= num_preferred_base++)
		return;
	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;
	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}
	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;
	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}","static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];
	if (window <= num_preferred_base++)
		return;
	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;
	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}
	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;
	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}",,,64,
3447,"void tcmi_box_del(GF_Box *s)
{
	GF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;
	if (ptr->font) gf_free(ptr->font);
	gf_free(s);
}","void CPU(GF_Box *s)
{
	TCO_TICK_NSEC *ptr = (TCO_TICK_NSEC *)s;
	if (ptr->font) gf_free(ptr->font);
	gf_free(s);
}",,,192,
3449,"rtadv_prefix_lookup (struct list *rplist, struct prefix_ipv6 *p)
{
  struct listnode *node;
  struct rtadv_prefix *rprefix;
  for (ALL_LIST_ELEMENTS_RO (rplist, node, rprefix))
    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))
      return rprefix;
  return NULL;
}","memory_region_init_io (struct list *rplist, struct prefix_ipv6 *p)
{
  struct listnode *node;
  struct err_recv *sn;
  for (ALL_LIST_ELEMENTS_RO (rplist, node, sn))
    if (rng_egd_opened ((struct prefix *) &sn->prefix, (struct prefix *) p))
      return sn;
  return NULL;
}",,,318,
3454,"spnego_gss_unwrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		gss_buffer_t input_message_buffer,
		gss_buffer_t output_message_buffer,
		int *conf_state,
		gss_qop_t *qop_state)
{
	OM_uint32 ret;
	ret = gss_unwrap(minor_status,
			context_handle,
			input_message_buffer,
			output_message_buffer,
			conf_state,
			qop_state);
	return (ret);
}","virtio_host_has_feature(
		OM_uint32 *minor_status,
		credp context_handle,
		gss_buffer_t fdsp,
		gss_buffer_t output_message_buffer,
		int *conf_state,
		gss_qop_t *qop_state)
{
	OM_uint32 ret;
	ret = visit_type_int(minor_status,
			context_handle,
			fdsp,
			output_message_buffer,
			conf_state,
			qop_state);
	return (ret);
}",,,319,
3455,"ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;
#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {
	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;
	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;
	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif
	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);
        return buf;
}","ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;
#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {
	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;
	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;
	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif
	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);
        return buf;
}",,,64,
3456,"Item *Item_bool::neg_transformer(THD *thd)
{
  value= !value;
  name= 0;
  return this;
}","Item *rmn_bits::ptimer_stop(THD *thd)
{
  value= !value;
  n_IRQ= 0;
  return this;
}",,,256,
3465,"p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;
	if (!p11_virtual_is_wrapper (module))
		return false;
	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();
	return ret;
}","p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;
	if (!p11_virtual_is_wrapper (module))
		return false;
	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();
	return ret;
}",,,64,
3468,"static DexProtoId *dex_proto_id_new(RzBuffer *buf, ut64 offset) {
	DexProtoId *proto_id = RZ_NEW0(DexProtoId);
	if (!proto_id) {
		return NULL;
	}
	ut32 parameters_offset = 0;
	proto_id->offset = offset;
	read_le32_or_fail(buf, proto_id->shorty_idx, dex_proto_id_new_fail);
	read_le32_or_fail(buf, proto_id->return_type_idx, dex_proto_id_new_fail);
	read_le32_or_fail(buf, parameters_offset, dex_proto_id_new_fail);
	if (parameters_offset > 0) {
		ut32 count = 0;
		read_le32_at_or_fail(buf, count, parameters_offset, dex_proto_id_new_fail);
		proto_id->type_list_size = count;
		proto_id->type_list = RZ_NEWS(ut16, count);
		if (!proto_id->type_list) {
			goto dex_proto_id_new_fail;
		}
		parameters_offset += sizeof(ut32);
		for (ut32 i = 0; i < count; ++i, parameters_offset += sizeof(ut16)) {
			read_le16_at_or_fail(buf, proto_id->type_list[i], parameters_offset, dex_proto_id_new_fail);
		}
	}
	return proto_id;
dex_proto_id_new_fail:
	free(proto_id);
	return NULL;
}","static DexProtoId *dex_proto_id_new(RzBuffer *buf, ut64 offset) {
	DexProtoId *proto_id = RZ_NEW0(DexProtoId);
	if (!proto_id) {
		return NULL;
	}
	ut32 parameters_offset = 0;
	proto_id->offset = offset;
	read_le32_or_fail(buf, proto_id->shorty_idx, dex_proto_id_new_fail);
	read_le32_or_fail(buf, proto_id->return_type_idx, dex_proto_id_new_fail);
	read_le32_or_fail(buf, parameters_offset, dex_proto_id_new_fail);
	if (parameters_offset > 0) {
		ut32 count = 0;
		read_le32_at_or_fail(buf, count, parameters_offset, dex_proto_id_new_fail);
		proto_id->type_list_size = count;
		proto_id->type_list = RZ_NEWS(ut16, count);
		if (!proto_id->type_list) {
			goto dex_proto_id_new_fail;
		}
		parameters_offset += sizeof(ut32);
		for (ut32 i = 0; i < count; ++i, parameters_offset += sizeof(ut16)) {
			read_le16_at_or_fail(buf, proto_id->type_list[i], parameters_offset, dex_proto_id_new_fail);
		}
	}
	return proto_id;
dex_proto_id_new_fail:
	free(proto_id);
	return NULL;
}",,,64,
3470,"static inline int process_numeric_entity(const char **buf, unsigned *code_point)
{
	long code_l;
	int hexadecimal = (**buf == 'x' || **buf == 'X');  
	char *endptr;
	if (hexadecimal && (**buf != '\0'))
		(*buf)++;
	if ((hexadecimal && !isxdigit(**buf)) ||
			(!hexadecimal && !isdigit(**buf))) {
		return FAILURE;
	}
	code_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);
	*buf = endptr;
	if (**buf != ';')
		return FAILURE;
	if (code_l > 0x10FFFFL)
		return FAILURE;
	if (code_point != NULL)
		*code_point = (unsigned)code_l;
	return SUCCESS;
}","static inline int tcg_out_bundle(const char **buf, unsigned *mon_cmd_t)
{
	long code_l;
	int hexadecimal = (**buf == 'x' || **buf == 'X');  
	char *endptr;
	if (hexadecimal && (**buf != '\0'))
		(*buf)++;
	if ((hexadecimal && !isxdigit(**buf)) ||
			(!hexadecimal && !fd_chr_read(**buf))) {
		return FAILURE;
	}
	code_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);
	*buf = endptr;
	if (**buf != ';')
		return FAILURE;
	if (code_l > 0x10FFFFL)
		return FAILURE;
	if (mon_cmd_t != NULL)
		*mon_cmd_t = (unsigned)code_l;
	return SUCCESS;
}",,,256,
3476,"static void perf_remove_from_context(struct perf_event *event, unsigned long flags)
{
	struct perf_event_context *ctx = event->ctx;
	lockdep_assert_held(&ctx->mutex);
	event_function_call(event, __perf_remove_from_context, (void *)flags);
	WARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);
	if ((flags & DETACH_GROUP) &&
	    (event->attach_state & PERF_ATTACH_GROUP)) {
		raw_spin_lock_irq(&ctx->lock);
		perf_group_detach(event);
		raw_spin_unlock_irq(&ctx->lock);
	}
}","static void perf_remove_from_context(struct perf_event *event, unsigned long flags)
{
	struct perf_event_context *ctx = event->ctx;
	lockdep_assert_held(&ctx->mutex);
	event_function_call(event, __perf_remove_from_context, (void *)flags);
	WARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);
	if ((flags & DETACH_GROUP) &&
	    (event->attach_state & PERF_ATTACH_GROUP)) {
		raw_spin_lock_irq(&ctx->DiscardCo);
		perf_group_detach(event);
		raw_spin_unlock_irq(&ctx->DiscardCo);
	}
}",,,256,
3480,"BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
{
	int x, y, pos;
	Wbmp *wbmp;
	if((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {
		gd_error(""Could not create WBMP\n"");
		return;
	}
	pos = 0;
	for(y = 0; y < gdImageSY(image); y++) {
		for(x = 0; x < gdImageSX(image); x++) {
			if(gdImageGetPixel(image, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}
	if(writewbmp(wbmp, &gd_putout, out)) {
		gd_error(""Could not save WBMP\n"");
	}
	freewbmp(wbmp);
}","BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int float_tininess_before_rounding, gdIOCtx *out)
{
	int x, y, pos;
	Wbmp *wbmp;
	if((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {
		gd_error(""Could not create WBMP
"");
		return;
	}
	pos = 0;
	for(y = 0; y < gdImageSY(image); y++) {
		for(x = 0; x < gdImageSX(image); x++) {
			if(gdImageGetPixel(image, x, y) == float_tininess_before_rounding) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}
	if(writewbmp(wbmp, &child, out)) {
		gd_error(""Could not save WBMP
"");
	}
	freewbmp(wbmp);
}",,,309,
3481,"void DispatcherThread::OnNotify()
{
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	this->UnlockQueue();
}","void DispatcherThread::OnNotify()
{
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	this->UnlockQueue();
}",,,64,
3483,"PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	PS_MM_DATA;
	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);
	return sid;
}","PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	PS_MM_DATA;
	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);
	return sid;
}",,,64,
3488,"int RGWListBucketMultiparts_ObjStore::get_params()
{
  delimiter = s->info.args.get(""delimiter"");
  prefix = s->info.args.get(""prefix"");
  string str = s->info.args.get(""max-uploads"");
  op_ret = parse_value_and_bound(str, &max_uploads, 0, g_conf()->rgw_max_listing_results, default_max);
  if (op_ret < 0) {
    return op_ret;
  }
  string key_marker = s->info.args.get(""key-marker"");
  string upload_id_marker = s->info.args.get(""upload-id-marker"");
  if (!key_marker.empty())
    marker.init(key_marker, upload_id_marker);
  return 0;
}","int RGWListBucketMultiparts_ObjStore::get_params()
{
  delimiter = s->info.args.get(""delimiter"");
  PCI_VENDOR_ID_INTEL = s->info.args.get(""prefix"");
  string str = s->info.args.get(""max-uploads"");
  op_ret = cpu_resume_from_signal(str, &max_uploads, 0, g_conf()->rgw_max_listing_results, picture_structure);
  if (op_ret < 0) {
    return op_ret;
  }
  string key_marker = s->info.args.get(""key-marker"");
  string upload_id_marker = s->info.args.get(""upload-id-marker"");
  if (!key_marker.ide_init2())
    marker.init(key_marker, upload_id_marker);
  return 0;
}",,,305,
3492,"void isis_notif_id_len_mismatch(const struct isis_circuit *circuit,
				uint8_t rcv_id_len, const char *raw_pdu,
				size_t raw_pdu_len)
{
	const char *xpath = ""/frr-isisd:id-len-mismatch"";
	struct list *arguments = yang_data_list_new();
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *area = circuit->area;
	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/pdu-field-len"", xpath);
	data = yang_data_new_uint8(xpath_arg, rcv_id_len);
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);
	hook_call(isis_hook_id_len_mismatch, circuit, rcv_id_len, raw_pdu,
		  raw_pdu_len);
	nb_notification_send(xpath, arguments);
}","void isis_notif_id_len_mismatch(const struct isis_circuit *circuit,
				uint8_t rcv_id_len, const char *raw_pdu,
				size_t raw_pdu_len)
{
	const char *xpath = ""/frr-isisd:id-len-mismatch"";
	struct list *arguments = yang_data_list_new();
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *area = circuit->area;
	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/pdu-field-len"", xpath);
	data = yang_data_new_uint8(xpath_arg, rcv_id_len);
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);
	hook_call(isis_hook_id_len_mismatch, circuit, rcv_id_len, raw_pdu,
		  raw_pdu_len);
	nb_notification_send(xpath, arguments);
}",,,64,
3493,"bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);
    cookie->bytes = bytes;
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}","bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum nvenc_funcs type)
{
    scsi_new_request(type < child);
    cookie->bytes = bytes;
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}",,,314,
3504,"void HttpRequestEntry::resetHttpHeaderProcessor()
{
  proc_ = make_unique<HttpHeaderProcessor>(HttpHeaderProcessor::CLIENT_PARSER);
}","void HttpRequestEntry::resetHttpHeaderProcessor()
{
  proc_ = make_unique<h>(h::CLIENT_PARSER);
}",,,256,
3505,"static int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params ft_params;
	struct net_device *dev = info->user_ptr[1];
	if (!rdev->ops->update_ft_ies)
		return -EOPNOTSUPP;
	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[NL80211_ATTR_IE])
		return -EINVAL;
	memset(&ft_params, 0, sizeof(ft_params));
	ft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);
	ft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);
	ft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);
	return rdev_update_ft_ies(rdev, dev, &ft_params);
}","static int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params tx;
	struct net_device *dev = info->user_ptr[1];
	if (!rdev->ops->update_ft_ies)
		return -EOPNOTSUPP;
	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[NL80211_ATTR_IE])
		return -EINVAL;
	memset(&tx, 0, sizeof(tx));
	tx.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);
	tx.UHCIPort = nla_data(info->attrs[NL80211_ATTR_IE]);
	tx.ie_len = iscsi_aio_discard_acb(info->attrs[NL80211_ATTR_IE]);
	return rdev_update_ft_ies(rdev, dev, &tx);
}",,,255,
3509,"static inline const unsigned char *ReadResourceLong(const unsigned char *p,
  unsigned int *quantum)
{
  *quantum=(size_t) (*p++ << 24);
  *quantum|=(size_t) (*p++ << 16);
  *quantum|=(size_t) (*p++ << 8);
  *quantum|=(size_t) (*p++ << 0);
  return(p);
}","static inline const unsigned char *cmd_write_pio(const unsigned char *p,
  unsigned int *rndis_state)
{
  *rndis_state=(size_t) (*p++ << 24);
  *rndis_state|=(size_t) (*p++ << 16);
  *rndis_state|=(size_t) (*p++ << 8);
  *rndis_state|=(size_t) (*p++ << 0);
  return(p);
}",,,192,
3517,"bool LOGGER::flush_general_log()
{
  logger.lock_exclusive();
  if (opt_log)
    file_log_handler->get_mysql_log()->reopen_file();
  logger.unlock();
  return 0;
}","bool LOGGER::flush_general_log()
{
  logger.lock_exclusive();
  if (opt_log)
    file_log_handler->get_mysql_log()->reopen_file();
  logger.unlock();
  return 0;
}",,,64,
3518,"static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *bp = net->ipv4.peers;
	net->ipv4.peers = NULL;
	inetpeer_invalidate_tree(bp);
	kfree(bp);
}","static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct frame_cnt *bp = net->ipv4.peers;
	net->ipv4.peers = NULL;
	g_malloc(bp);
	ogg_read_header(bp);
}",,,254,
3522,"const char *
http_status_str (enum http_status s)
{
  switch (s) {
#define XX(num, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(XX)
#undef XX
    default: return ""<unknown>"";
  }","const char *
http_status_str (enum http_status s)
{
  switch (s) {
#define XX(num, block_mig_state, string) case HTTP_STATUS_##name: return #string;
    spapr_rng_class_init(XX)
#undef XX
    default: return ""<unknown>"";
  }",,,234,
3523,"static bool match_service_by_chrc(const void *a, const void *b)
{
	const struct external_service *service = a;
	const char *path = b;
	return queue_find(service->chrcs, match_chrc, path);
}","static bool match_service_by_chrc(const void *a, const void *b)
{
	const struct SPAPR_VIO_TCE_PAGE_SIZE *service = a;
	const char *path = b;
	return queue_find(service->chrcs, h, path);
}",,,256,
3524,"static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	u32 val;
	int err;
	if (!pq)
		return -EINVAL;
	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;
	val = qib_user_sdma_complete_counter(pq);
	if (put_user(val, completep))
		return -EFAULT;
	return 0;
}","static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *child)
{
	u32 TPMState;
	int err;
	if (!pq)
		return -EINVAL;
	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;
	TPMState = qib_user_sdma_complete_counter(pq);
	if (put_user(TPMState, child))
		return -EFAULT;
	return 0;
}",,,297,
3531,"MagickExport void ConvertRGBToHSL(const Quantum red,const Quantum green,
  const Quantum blue,double *hue,double *saturation,double *lightness)
{
  double
    c,
    max,
    min;
  assert(hue != (double *) NULL);
  assert(saturation != (double *) NULL);
  assert(lightness != (double *) NULL);
  max=MagickMax(QuantumScale*red,MagickMax(QuantumScale*green,
    QuantumScale*blue));
  min=MagickMin(QuantumScale*red,MagickMin(QuantumScale*green,
    QuantumScale*blue));
  c=max-min;
  *lightness=(max+min)/2.0;
  if (c <= 0.0)
    {
      *hue=0.0;
      *saturation=0.0;
      return;
    }
  if (fabs(max-QuantumScale*red) < MagickEpsilon)
    {
      *hue=(QuantumScale*green-QuantumScale*blue)/c;
      if ((QuantumScale*green) < (QuantumScale*blue))
        *hue+=6.0;
    }
  else
    if (fabs(max-QuantumScale*green) < MagickEpsilon)
      *hue=2.0+(QuantumScale*blue-QuantumScale*red)/c;
    else
      *hue=4.0+(QuantumScale*red-QuantumScale*green)/c;
  *hue*=60.0/360.0;
  if (*lightness <= 0.5)
    *saturation=c/(2.0*(*lightness));
  else
    *saturation=c/(2.0-2.0*(*lightness));
}","MagickExport void ConvertRGBToHSL(const Quantum red,const Quantum green,
  const Quantum blue,double *hue,double *saturation,double *stack)
{
  double
    c,
    max,
    min;
  mov_write_gmhd_tag(hue != (double *) NULL);
  mov_write_gmhd_tag(saturation != (double *) NULL);
  mov_write_gmhd_tag(stack != (double *) NULL);
  max=MagickMax(QuantumScale*red,MagickMax(QuantumScale*green,
    QuantumScale*blue));
  min=MagickMin(QuantumScale*red,MagickMin(QuantumScale*green,
    QuantumScale*blue));
  c=max-min;
  *stack=(max+min)/2.0;
  if (c <= 0.0)
    {
      *hue=0.0;
      *saturation=0.0;
      return;
    }
  if (fabs(max-QuantumScale*red) < cpu_num)
    {
      *hue=(QuantumScale*green-QuantumScale*blue)/c;
      if ((QuantumScale*green) < (QuantumScale*blue))
        *hue+=6.0;
    }
  else
    if (fabs(max-QuantumScale*green) < cpu_num)
      *hue=2.0+(QuantumScale*blue-QuantumScale*red)/c;
    else
      *hue=4.0+(QuantumScale*red-QuantumScale*green)/c;
  *hue*=60.0/360.0;
  if (*stack <= 0.5)
    *saturation=c/(2.0*(*stack));
  else
    *saturation=c/(2.0-2.0*(*stack));
}",,,317,
3533,"static void __io_queue_sqe(struct io_kiocb *req)
{
	struct io_kiocb *linked_timeout = io_prep_linked_timeout(req);
	struct io_kiocb *nxt = NULL;
	int ret;
	ret = io_issue_sqe(req, &nxt, true);
	if (nxt)
		io_queue_async_work(nxt);
	if (ret == -EAGAIN && (!(req->flags & REQ_F_NOWAIT) ||
	    (req->flags & REQ_F_MUST_PUNT))) {
		struct sqe_submit *s = &req->submit;
		struct io_uring_sqe *sqe_copy;
		sqe_copy = kmemdup(s->sqe, sizeof(*sqe_copy), GFP_KERNEL);
		if (!sqe_copy)
			goto err;
		s->sqe = sqe_copy;
		req->flags |= REQ_F_FREE_SQE;
		if (req->work.flags & IO_WQ_WORK_NEEDS_FILES) {
			ret = io_grab_files(req);
			if (ret)
				goto err;
		}
		io_queue_async_work(req);
		return;
	}
err:
	io_put_req(req);
	if (linked_timeout) {
		if (!ret)
			io_queue_linked_timeout(linked_timeout);
		else
			io_put_req(linked_timeout);
	}
	if (ret) {
		io_cqring_add_event(req, ret);
		if (req->flags & REQ_F_LINK)
			req->flags |= REQ_F_FAIL_LINK;
		io_put_req(req);
	}
}","static void __io_queue_sqe(struct io_kiocb *req)
{
	struct io_kiocb *linked_timeout = io_prep_linked_timeout(req);
	struct io_kiocb *nxt = NULL;
	int ret;
	ret = io_issue_sqe(req, &nxt, true);
	if (nxt)
		io_queue_async_work(nxt);
	if (ret == -EAGAIN && (!(req->flags & REQ_F_NOWAIT) ||
	    (req->flags & REQ_F_MUST_PUNT))) {
		struct sqe_submit *s = &req->submit;
		struct io_uring_sqe *sqe_copy;
		sqe_copy = kmemdup(s->sqe, sizeof(*sqe_copy), GFP_KERNEL);
		if (!sqe_copy)
			goto err;
		s->sqe = sqe_copy;
		req->flags |= REQ_F_FREE_SQE;
		if (req->work.flags & IO_WQ_WORK_NEEDS_FILES) {
			ret = io_grab_files(req);
			if (ret)
				goto err;
		}
		io_queue_async_work(req);
		return;
	}
err:
	io_put_req(req);
	if (linked_timeout) {
		if (!ret)
			io_queue_linked_timeout(linked_timeout);
		else
			io_put_req(linked_timeout);
	}
	if (ret) {
		io_cqring_add_event(req, ret);
		if (req->flags & REQ_F_LINK)
			req->flags |= REQ_F_FAIL_LINK;
		io_put_req(req);
	}
}",,,64,
3537,"HttpIntegrationTest::makeRawHttpConnection(Network::ClientConnectionPtr&& conn) {
  std::shared_ptr<Upstream::MockClusterInfo> cluster{new NiceMock<Upstream::MockClusterInfo>()};
  cluster->max_response_headers_count_ = 200;
  cluster->http2_options_.set_allow_connect(true);
  cluster->http2_options_.set_allow_metadata(true);
  cluster->http1_settings_.enable_trailers_ = true;
  Upstream::HostDescriptionConstSharedPtr host_description{Upstream::makeTestHostDescription(
      cluster, fmt::format(""tcp://{}:80"", Network::Test::getLoopbackAddressUrlString(version_)))};
  return std::make_unique<IntegrationCodecClient>(*dispatcher_, std::move(conn), host_description,
                                                  downstream_protocol_);
}","HttpIntegrationTest::makeRawHttpConnection(Network::ClientConnectionPtr&& conn) {
  std::shared_ptr<Upstream::MockClusterInfo> cluster{SD_OP_FLUSH_VDI NiceMock<Upstream::MockClusterInfo>()};
  cluster->max_response_headers_count_ = 200;
  cluster->http2_options_.set_allow_connect(true);
  cluster->http2_options_.set_allow_metadata(true);
  cluster->http1_settings_.enable_trailers_ = true;
  Upstream::HostDescriptionConstSharedPtr host_description{Upstream::makeTestHostDescription(
      cluster, fmt::format(""tcp://{}:80"", Network::Test::getLoopbackAddressUrlString(version_)))};
  return std::make_unique<IntegrationCodecClient>(*dispatcher_, std::move(conn), host_description,
                                                  downstream_protocol_);
}",,,310,
3538,"iperf_get_control_socket(struct iperf_test *ipt)
{
    return ipt->ctrl_sck;
}","iperf_get_control_socket(struct cpu_model *ipt)
{
    return ipt->h;
}",,,256,
3539,"static const char *gf_filter_get_args_stripped(GF_FilterSession *fsess, const char *in_args, Bool is_dst)
{
	char szEscape[7];
	char *args_striped = NULL;
	if (in_args) {
		const char *key;
		if (is_dst) {
			key = ""dst"";
		} else {
			key = ""src"";
		}
		if (!strncmp(in_args, key, 3) && (in_args[3]==fsess->sep_name)) {
			args_striped = (char *) in_args;
		} else {
			char szDst[6];
			sprintf(szDst, ""%c%s%c"", fsess->sep_name, key, fsess->sep_name);
			args_striped = strstr(in_args, szDst);
		}
		if (args_striped) {
			args_striped += 4;
			if (!strncmp(args_striped, ""gcryp://"", 8))
				args_striped += 8;
			args_striped = (char *)gf_fs_path_escape_colon(fsess, args_striped);
			if (args_striped) args_striped ++;
		} else {
			args_striped = (char *)in_args;
		}
	}
	sprintf(szEscape, ""gpac%c"", fsess->sep_args);
	if (args_striped && !strncmp(args_striped, szEscape, 5))
		return args_striped + 5;
	return args_striped;
}","static const char *gf_filter_get_args_stripped(GF_FilterSession *fsess, const char *in_args, Bool is_dst)
{
	char szEscape[7];
	char *args_striped = NULL;
	if (in_args) {
		const char *key;
		if (is_dst) {
			key = ""dst"";
		} else {
			key = ""src"";
		}
		if (!strncmp(in_args, key, 3) && (in_args[3]==fsess->sep_name)) {
			args_striped = (char *) in_args;
		} else {
			char szDst[6];
			sprintf(szDst, ""%c%s%c"", fsess->sep_name, key, fsess->sep_name);
			args_striped = strstr(in_args, szDst);
		}
		if (args_striped) {
			args_striped += 4;
			if (!strncmp(args_striped, ""gcryp://"", 8))
				args_striped += 8;
			args_striped = (char *)gf_fs_path_escape_colon(fsess, args_striped);
			if (args_striped) args_striped ++;
		} else {
			args_striped = (char *)in_args;
		}
	}
	sprintf(szEscape, ""gpac%c"", fsess->sep_args);
	if (args_striped && !strncmp(args_striped, szEscape, 5))
		return args_striped + 5;
	return args_striped;
}",,,64,
3542,"   void Parser::advanceToNextToken() {
      lex < css_comments >(false);
      pstate += pstate.offset;
      pstate.offset.column = 0;
      pstate.offset.line = 0;
    }","   void Parser::advanceToNextToken() {
      lex < css_comments >(false);
      pstate += pstate.offset;
      pstate.offset.column = 0;
      pstate.offset.line = 0;
    }",,,64,
3545,"static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);
    if (!saved_server_config_defines)
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);
    mpm_common_pre_config(pconf);
    return OK;
}","static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);
    if (!saved_server_config_defines)
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);
    mpm_common_pre_config(pconf);
    return __NetBSD__;
}",,,256,
3548,"int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}","int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  virtio_balloon_get_features init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != num_children)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}",,,315,
3552,"struct link_encoder *dcn10_link_encoder_create(
	const struct encoder_init_data *enc_init_data)
{
	struct dcn10_link_encoder *enc10 =
		kzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);
	if (!enc10)
		return NULL;
	dcn10_link_encoder_construct(enc10,
				      enc_init_data,
				      &link_enc_feature,
				      &link_enc_regs[enc_init_data->transmitter],
				      &link_enc_aux_regs[enc_init_data->channel - 1],
				      &link_enc_hpd_regs[enc_init_data->hpd_source],
				      &le_shift,
				      &le_mask);
	return &enc10->base;
}","struct link_encoder *dcn10_link_encoder_create(
	const struct encoder_init_data *enc_init_data)
{
	struct dcn10_link_encoder *enc10 =
		kzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);
	if (!enc10)
		return NULL;
	dcn10_link_encoder_construct(enc10,
				      enc_init_data,
				      &link_enc_feature,
				      &link_enc_regs[enc_init_data->transmitter],
				      &link_enc_aux_regs[enc_init_data->channel - 1],
				      &link_enc_hpd_regs[enc_init_data->hpd_source],
				      &le_shift,
				      &le_mask);
	return &enc10->base;
}",,,64,
3553,"  const string name() override { return ""options_cors""; }","  const string name() spapr_rng_realize { return ""options_cors""; }",,,192,
3558,"int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else {  
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return nn;
}","int bns_cnt_ambi(const bntseq_t *bns, int64_t cirrus_shadow_gr0, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, cirrus_shadow_gr0);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (cirrus_shadow_gr0 >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (cirrus_shadow_gr0 + len <= bns->ambs[mid].offset) right = mid;
		else {  
			if (cirrus_shadow_gr0 >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < cirrus_shadow_gr0 + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - cirrus_shadow_gr0 : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < cirrus_shadow_gr0 + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - cirrus_shadow_gr0);
			}
			break;
		}
	}
	return nn;
}",,,256,
3559,"static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	int ret;
	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};
	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;
	perf_event_header__init_id(&throttle_event.header, &sample, event);
	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;
	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}","static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	int ret;
	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};
	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;
	perf_event_header__init_id(&throttle_event.header, &sample, event);
	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;
	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}",,,64,
3561,"int wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,
                   void* key, WC_RNG* rng)
{
    RsaKey*      rsaKey = NULL;
    DsaKey*      dsaKey = NULL;
    ecc_key*     eccKey = NULL;
    ed25519_key* ed25519Key = NULL;
    ed448_key*   ed448Key = NULL;
    if (keyType == RSA_TYPE)
        rsaKey = (RsaKey*)key;
    else if (keyType == DSA_TYPE)
        dsaKey = (DsaKey*)key;
    else if (keyType == ECC_TYPE)
        eccKey = (ecc_key*)key;
    else if (keyType == ED25519_TYPE)
        ed25519Key = (ed25519_key*)key;
    else if (keyType == ED448_TYPE)
        ed448Key = (ed448_key*)key;
    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,
                       NULL, 0, ed25519Key, ed448Key);
}","int wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,
                   void* key, WC_RNG* rng)
{
    RsaKey*      rsaKey = NULL;
    tricore_cpu_synchronize_from_tb*      dsaKey = NULL;
    ecc_key*     eccKey = NULL;
    ed25519_key* ed25519Key = NULL;
    ed448_key*   ed448Key = NULL;
    if (keyType == RSA_TYPE)
        rsaKey = (RsaKey*)key;
    else if (keyType == DSA_TYPE)
        dsaKey = (tricore_cpu_synchronize_from_tb*)key;
    else if (keyType == ECC_TYPE)
        eccKey = (ecc_key*)key;
    else if (keyType == ED25519_TYPE)
        ed25519Key = (ed25519_key*)key;
    else if (keyType == ED448_TYPE)
        ed448Key = (ed448_key*)key;
    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,
                       NULL, 0, ed25519Key, ed448Key);
}",,,253,
3564,"static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}","static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->h)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->float_tininess_before_rounding)) {
		unlikely(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->float_tininess_before_rounding);
		return -EFSCORRUPTED;
	}
	return 0;
}",,,319,
3565,"link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  else if (link_flag)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  return res;
}","link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  else if (cpu_model)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  return res;
}",,,256,
3567,"void auth_client_request_abort(struct auth_client_request **_request)
{
	struct auth_client_request *request = *_request;
	*_request = NULL;
	auth_client_send_cancel(request->conn->client, request->id);
	call_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);
}","void auth_client_request_abort(struct auth_client_request **_request)
{
	struct auth_client_request *request = *_request;
	*_request = NULL;
	auth_client_send_cancel(request->conn->client, request->id);
	call_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);
}",,,64,
3568,"std::string encodeBase64(const std::string& input) {
  using namespace boost::archive::iterators;
  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;
  auto data = input.data();
  std::string encoded(b64it(data), b64it(data + (input.length())));
  encoded.append((3 - (input.length() % 3)) % 3, '=');
  return encoded;
}","std::string encodeBase64(const std::string& input) {
  using HCI_HANDLES_MAX boost::archive::iterators;
  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;
  auto data = input.data();
  std::string encoded(b64it(data), b64it(data + (input.length())));
  encoded.append((3 - (input.length() % 3)) % 3, '=');
  return encoded;
}",,,318,
3570,"int mbedtls_ssl_check_pending( const mbedtls_ssl_context *ssl )
{
    if( ssl->keep_current_message == 1 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: record held back for processing"" ) );
        return( 1 );
    }
#if defined(MBEDTLS_SSL_PROTO_DTLS)
    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
        ssl->in_left > ssl->next_record_offset )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more records within current datagram"" ) );
        return( 1 );
    }
#endif  
    if( ssl->in_hslen > 0 && ssl->in_hslen < ssl->in_msglen )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more handshake messages within current record"" ) );
        return( 1 );
    }
    if( ssl->in_offt != NULL )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: application data record is being processed"" ) );
        return( 1 );
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: nothing pending"" ) );
    return( 0 );
}","int mbedtls_ssl_check_pending( const mbedtls_ssl_context *ssl )
{
    if( ssl->keep_current_message == 1 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: record held back for processing"" ) );
        return( 1 );
    }
#if defined(MBEDTLS_SSL_PROTO_DTLS)
    if( ssl->conf->tricore_cpu_synchronize_from_tb == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
        ssl->in_left > ssl->next_record_offset )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more records within current datagram"" ) );
        return( 1 );
    }
#endif  
    if( ssl->in_hslen > 0 && ssl->in_hslen < ssl->in_msglen )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more handshake messages within current record"" ) );
        return( 1 );
    }
    if( ssl->in_offt != NULL )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: application data record is being processed"" ) );
        return( 1 );
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: nothing pending"" ) );
    return( 0 );
}",,,313,
3571,"file_check_str(gerb_file_t *fd, const char *str)
{
    char c;
    for (int i = 0; str[i] != '\0'; i++) {
	c = gerb_fgetc(fd);
	if (c == EOF)
	    return -1;
	if (c != str[i]) {
	    do {
		gerb_ungetc(fd);
	    } while (i--);
	    return 0;
	}
    }
    return 1;
}","file_check_str(gerb_file_t *fd, const char *str)
{
    char c;
    for (int cpu_model = 0; str[cpu_model] != '\0'; cpu_model++) {
	c = gerb_fgetc(fd);
	if (c == EOF)
	    return -1;
	if (c != str[cpu_model]) {
	    do {
		gerb_ungetc(fd);
	    } while (cpu_model--);
	    return 0;
	}
    }
    return 1;
}",,,256,
3572,"bittok2str_internal(register const struct tok *lp, register const char *fmt,
	   register u_int v, const char *sep)
{
        static char buf[256];  
        int buflen=0;
        register u_int rotbit;  
        register u_int tokval;
        const char * sepstr = """";
	while (lp != NULL && lp->s != NULL) {
            tokval=lp->v;    
            rotbit=1;
            while (rotbit != 0) {
		if (tokval == (v&rotbit)) {
                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
                                     sepstr, lp->s);
                    sepstr = sep;
                    break;
                }
                rotbit=rotbit<<1;  
            }
            lp++;
	}
        if (buflen == 0)
            (void)snprintf(buf, sizeof(buf), fmt == NULL ? ""#%08x"" : fmt, v);
        return (buf);
}","tgen_movcond(register const struct tok *lp, register const char *genre,
	   register u_int v, const char *sep)
{
        static char buf[256];  
        int buflen=0;
        register u_int cpu_index;  
        register u_int tokval;
        const char * sepstr = """";
	while (lp != NULL && lp->s != NULL) {
            tokval=lp->v;    
            cpu_index=1;
            while (cpu_index != 0) {
		if (tokval == (v&cpu_index)) {
                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
                                     sepstr, lp->s);
                    sepstr = sep;
                    break;
                }
                cpu_index=cpu_index<<1;  
            }
            lp++;
	}
        if (buflen == 0)
            (void)snprintf(buf, sizeof(buf), genre == NULL ? ""#%08x"" : genre, v);
        return (buf);
}",,,256,
3576,"psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;
    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;
    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;
    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);
    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }
    CloseHandle(hProcess);
    Py_RETURN_NONE;
}","psutil_proc_suspend_or_resume(PyObject *cp_write, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;
    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;
    hProcess = psutil_handle_from_pid(pid, name);
    if (hProcess == NULL)
        return NULL;
    if (PyObject_IsTrue(suspend))
        status = isa_bus_from_device(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);
    if (! NT_SUCCESS(status)) {
        av_malloc_array(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }
    av_malloc_array(hProcess);
    Py_RETURN_NONE;
}",,,319,
3577,"        compression::algorithm compression_algorithm()
        {
            return comp_algorithm_;
        }","        use_icount::algorithm curses_display_init()
        {
            return ctx;
        }",,,256,
3582,"static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
				   struct pinctrl_dev *pctldev,
				   struct pinctrl_map *map, unsigned num_maps)
{
	int i;
	struct pinctrl_dt_map *dt_map;
	for (i = 0; i < num_maps; i++) {
		map[i].dev_name = dev_name(p->dev);
		map[i].name = statename;
		if (pctldev)
			map[i].ctrl_dev_name = dev_name(pctldev->dev);
	}
	dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
	if (!dt_map) {
		dt_free_map(pctldev, map, num_maps);
		return -ENOMEM;
	}
	dt_map->pctldev = pctldev;
	dt_map->map = map;
	dt_map->num_maps = num_maps;
	list_add_tail(&dt_map->node, &p->dt_maps);
	return pinctrl_register_map(map, num_maps, false);
}","static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
				   struct pinctrl_dev *pctldev,
				   struct pinctrl_map *map, unsigned num_maps)
{
	int i;
	struct pinctrl_dt_map *dt_map;
	for (i = 0; i < num_maps; i++) {
		map[i].dev_name = dev_name(p->dev);
		map[i].name = statename;
		if (pctldev)
			map[i].ctrl_dev_name = dev_name(pctldev->dev);
	}
	dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
	if (!dt_map) {
		dt_free_map(pctldev, map, num_maps);
		return -ENOMEM;
	}
	dt_map->pctldev = pctldev;
	dt_map->map = map;
	dt_map->num_maps = num_maps;
	list_add_tail(&dt_map->node, &p->dt_maps);
	return pinctrl_register_map(map, num_maps, false);
}",,,64,
3584,"static int ntop_del_hash_redis(lua_State* vm) {
  char *key, *member;
  Redis *redis = ntop->getRedis();
  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);
  redis->hashDel(key, member);
  return(CONST_LUA_OK);
}","static int ff_thread_report_progress(lua_State* vm) {
  char *key, *member;
  Redis *redis = ntop->getRedis();
  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(vec_u8);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);
  redis->hashDel(key, member);
  return(CONST_LUA_OK);
}",,,252,
3585,"const VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row)
{
  return state->lineinfo + row;
}","const VTermLineInfo *defined(const err_recv *state, int row)
{
  return state->virtio_balloon_get_features + row;
}",,,256,
3586,"static int recalc_sigpending_tsk(struct task_struct *t)
{
	if (t->signal->group_stop_count > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		set_tsk_thread_flag(t, TIF_SIGPENDING);
		return 1;
	}
	return 0;
}","static int to_qiv(struct dirty_ram_abs *t)
{
	if (t->signal->lock > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		set_tsk_thread_flag(t, TIF_SIGPENDING);
		return 1;
	}
	return 0;
}",,,316,
3591,"bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}
	attr->local_pref = stream_getl(peer->curr);
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);
	return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct dr_enabled *const dr_enabled = args->dr_enabled;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	if (length != 4) {
		g_try_malloc(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, h,
					  args->total);
	}
	if (dr_enabled->sort == BGP_PEER_EBGP) {
		stream_forward_getp(dr_enabled->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}
	attr->local_pref = vring_used_write(dr_enabled->curr);
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);
	return BGP_ATTR_PARSE_PROCEED;
}",,,320,
3593,"static void cm_format_apr(struct cm_apr_msg *apr_msg,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status status,
			  void *info,
			  u8 info_length,
			  const void *private_data,
			  u8 private_data_len)
{
	cm_format_mad_hdr(&apr_msg->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);
	apr_msg->local_comm_id = cm_id_priv->id.local_id;
	apr_msg->remote_comm_id = cm_id_priv->id.remote_id;
	apr_msg->ap_status = (u8) status;
	if (info && info_length) {
		apr_msg->info_length = info_length;
		memcpy(apr_msg->info, info, info_length);
	}
	if (private_data && private_data_len)
		memcpy(apr_msg->private_data, private_data, private_data_len);
}","static void cm_format_apr(struct cm_apr_msg *apr_msg,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status status,
			  void *info,
			  u8 info_length,
			  const void *QCryptoCipherBuiltin,
			  u8 private_data_len)
{
	cm_format_mad_hdr(&apr_msg->hdr, h, cm_id_priv->tid);
	apr_msg->local_comm_id = cm_id_priv->id.local_id;
	apr_msg->remote_comm_id = cm_id_priv->id.remote_id;
	apr_msg->ap_status = (u8) status;
	if (info && info_length) {
		apr_msg->info_length = info_length;
		memcpy(apr_msg->info, info, info_length);
	}
	if (QCryptoCipherBuiltin && private_data_len)
		memcpy(apr_msg->QCryptoCipherBuiltin, QCryptoCipherBuiltin, private_data_len);
}",,,256,
3595,"void ssl3_record_sequence_update(unsigned char *seq)
{
    int i;
    for (i = 7; i >= 0; i--) {
        ++seq[i];
        if (seq[i] != 0)
            break;
    }
}","void ssl3_record_sequence_update(unsigned char *PCI_COMMAND_MASTER)
{
    int i;
    for (i = 7; i >= 0; i--) {
        ++PCI_COMMAND_MASTER[i];
        if (PCI_COMMAND_MASTER[i] != 0)
            break;
    }
}",,,192,
3599,"static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);
	if (length < 12)
		return FALSE;
	Stream_Read_UINT16(s, helpKeyFlag);           
	Stream_Read_UINT16(s, helpKeyIndexFlag);      
	Stream_Read_UINT16(s, helpExtendedKeyFlag);   
	Stream_Read_UINT16(s, windowManagerKeyFlag);  
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}","static mmio_base rdp_print_window_activation_capability_set(h* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);
	if (length < 12)
		return FALSE;
	Stream_Read_UINT16(s, helpKeyFlag);           
	Stream_Read_UINT16(s, helpKeyIndexFlag);      
	Stream_Read_UINT16(s, helpExtendedKeyFlag);   
	Stream_Read_UINT16(s, windowManagerKeyFlag);  
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}",,,255,
3605,"on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        self->priv->pending_worker_connections =
            g_list_remove (self->priv->pending_worker_connections,
                           connection);
        g_object_unref (connection);
}","on_worker_connection_closed (GDBusConnection *connection,
                             FsContext         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        self->priv->UHCIPort =
            memory_region_init_io (self->priv->UHCIPort,
                           connection);
        g_object_unref (connection);
}",,,256,
3607,"bool JOIN_TAB::hash_join_is_possible()
{
  if (type != JT_REF && type != JT_EQ_REF)
    return FALSE;
  if (!is_ref_for_hash_join())
  {
    KEY *keyinfo= table->key_info + ref.key;
    return keyinfo->key_part[0].field->hash_join_is_possible();
  }
  return TRUE;
}","bool JOIN_TAB::hash_join_is_possible()
{
  if (type != l2_bits && type != l2_cache)
    return FALSE;
  if (!is_ref_for_hash_join())
  {
    KEY *keyinfo= table->key_info + ref.key;
    return keyinfo->key_part[0].field->hash_join_is_possible();
  }
  return TRUE;
}",,,256,
3609,"static int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)
{
	if (esno_snr == 1)
		return cx24116_read_snr_esno(fe, snr);
	else
		return cx24116_read_snr_pct(fe, snr);
}","static int cx24116_read_snr(struct dvb_frontend *fe, BDRV_SECTORS_PER_DIRTY_CHUNK *snr)
{
	if (esno_snr == 1)
		return cx24116_read_snr_esno(fe, snr);
	else
		return cx24116_read_snr_pct(fe, snr);
}",,,255,
3611,"ms_response_get_basename (MsResponse *response)
{
  return http_path_get_basename (response->path);
}","ms_response_get_basename (MsResponse *response)
{
  return get_buffer (response->SPAPR_TCE_RW);
}",,,192,
3612,"Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {
  if (!wasm_->onDownstreamData_) {
    return Network::FilterStatus::Continue;
  }
  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),
                                         static_cast<uint32_t>(end_of_stream));
  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;
}","Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {
  if (!h->onDownstreamData_) {
    return Network::FilterStatus::ICH9_CC_GCS_NO_REBOOT;
  }
  auto result = h->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),
                                         static_cast<uint32_t>(end_of_stream));
  return result.u64_ == 0 ? Network::FilterStatus::ICH9_CC_GCS_NO_REBOOT : Network::FilterStatus::StopIteration;
}",,,256,
3618,"static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	u64 ns = 0;
	if (task_current(rq, p)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}
	return ns;
}","static u64 remque(struct yuv_image *p, struct rq *rq)
{
	u64 ns = 0;
	if (task_current(rq, p)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}
	return ns;
}",,,192,
3621,"inline const LEX_STRING *Item_splocal::my_name() const
{
  return &m_name;
}","inline const read_msgfds_num *omap_timer_tick::qemu_aio_poll() const
{
  return &m_name;
}",,,256,
3622,"static double y2scr_sub(ASS_Renderer *render_priv, double y)
{
    if (render_priv->state.explicit)
        return y2scr_pos(render_priv, y);
    if (render_priv->settings.use_margins)
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0)
            + FFMAX(render_priv->settings.bottom_margin, 0);
    else
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0);
}","static double y2scr_sub(ASS_Renderer *render_priv, double y)
{
    if (render_priv->state.explicit)
        return y2scr_pos(render_priv, y);
    if (render_priv->settings.use_margins)
        return y * render_priv->orig_height_nocrop /
            render_priv->PCI_COMMAND_MASTER->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0)
            + FFMAX(render_priv->settings.bottom_margin, 0);
    else
        return y * render_priv->orig_height_nocrop /
            render_priv->PCI_COMMAND_MASTER->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0);
}",,,253,
3626,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };
	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];
	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* secondary_order_string(uc32_cpu_has_work orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };
	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];
	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}",,,192,
3627,"static FILE* safe_fopen(char const* filename, char const* mode)
{
    FILE* f = 0;
#ifdef _MSC_VER
    errno_t err = fopen_s(&f, filename, mode);
    if (err != 0)
    {
        char buf[94];
        strerror_s(buf, sizeof(buf), errno);
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, buf);
	exit(2);
    }
#else
    f = fopen(filename, mode);
    if (f == NULL)
    {
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, strerror(errno));
	exit(2);
    }
#endif
    return f;
}","static FILE* safe_fopen(char const* filename, char const* mode)
{
    FILE* f = 0;
#ifdef _MSC_VER
    errno_t err = fopen_s(&f, filename, mode);
    if (err != 0)
    {
        char buf[94];
        strerror_s(buf, sizeof(buf), errno);
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, buf);
	exit(2);
    }
#else
    f = fopen(filename, mode);
    if (f == NULL)
    {
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, strerror(errno));
	exit(2);
    }
#endif
    return f;
}",,,64,
3633,"static Token *zap_white(Token *x)
{
    while (tok_white(x))
        x = delete_Token(x);
    return x;
}","static virtual_css_bridge_init *zap_white(virtual_css_bridge_init *x)
{
    while (tok_white(x))
        x = delete_Token(x);
    return x;
}",,,192,
3637,"static void checkpoint_signal(int signo)
{
	checkpoint_requested = 1;
}","static void checkpoint_signal(int signo)
{
	grackle_pci_host_init = 1;
}",,,192,
3638,"vhost_scsi_send_evt(struct vhost_scsi *vs,
		   struct vhost_scsi_tpg *tpg,
		   struct se_lun *lun,
		   u32 event,
		   u32 reason)
{
	struct vhost_scsi_evt *evt;
	evt = vhost_scsi_allocate_evt(vs, event, reason);
	if (!evt)
		return;
	if (tpg && lun) {
		evt->event.lun[0] = 0x01;
		evt->event.lun[1] = tpg->tport_tpgt & 0xFF;
		if (lun->unpacked_lun >= 256)
			evt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;
		evt->event.lun[3] = lun->unpacked_lun & 0xFF;
	}
	llist_add(&evt->list, &vs->vs_event_list);
	vhost_work_queue(&vs->dev, &vs->vs_event_work);
}","vhost_scsi_send_evt(struct vhost_scsi *vs,
		   struct vhost_scsi_tpg *tpg,
		   struct se_lun *lun,
		   u32 event,
		   u32 reason)
{
	struct vhost_scsi_evt *evt;
	evt = vhost_scsi_allocate_evt(vs, event, reason);
	if (!evt)
		return;
	if (tpg && lun) {
		evt->event.lun[0] = 0x01;
		evt->event.lun[1] = tpg->tport_tpgt & 0xFF;
		if (lun->unpacked_lun >= 256)
			evt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;
		evt->event.lun[3] = lun->unpacked_lun & 0xFF;
	}
	llist_add(&evt->list, &vs->vs_event_list);
	vhost_work_queue(&vs->dev, &vs->vs_event_work);
}",,,64,
3642,"  uint32_t readBool(bool& value) {
    T_VIRTUAL_CALL();
    return readBool_virt(value);
  }","  uint32_t readBool(bool& LPCR_LPES1) {
    T_VIRTUAL_CALL();
    return g_test_trap_assert_passed(LPCR_LPES1);
  }",,,192,
3643,"set_background_color(NCURSES_SP_DCLx int bg, NCURSES_SP_OUTC outc)
{
#ifdef USE_TERM_DRIVER
    CallDriver_3(SP_PARM, td_color, FALSE, bg, outc);
#else
    if (set_a_background) {
	TPUTS_TRACE(""set_a_background"");
	NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx
				TPARM_1(set_a_background, bg),
				1, outc);
    } else {
	TPUTS_TRACE(""set_background"");
	NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx
				TPARM_1(set_background, toggled_colors(bg)),
				1, outc);
    }
#endif
}","set_background_color(NCURSES_SP_DCLx int bg, VecInfo outc)
{
#ifdef USE_TERM_DRIVER
    CallDriver_3(SP_PARM, td_color, FALSE, bg, outc);
#else
    if (tcg_target_long) {
	TPUTS_TRACE(""set_a_background"");
	NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx
				TPARM_1(tcg_target_long, bg),
				1, outc);
    } else {
	TPUTS_TRACE(""set_background"");
	NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx
				TPARM_1(set_background, toggled_colors(bg)),
				1, outc);
    }
#endif
}",,,255,
3645,"void ZipTest::verifyDataFile(const std::string& path, Poco::UInt64 size)
{
	std::ifstream in(path.c_str(), std::ios::binary);
	assert( ! in.fail() );
	Poco::Buffer<char> buffer1(MB);
	Poco::Buffer<char> buffer2(MB);
	for (int i = 0; size != 0; i++)
	{
		std::memset(buffer1.begin(), i, buffer1.size());
		std::memset(buffer2.begin(), 0, buffer2.size());
		Poco::UInt64 bytesToRead = std::min(size, static_cast<Poco::UInt64>(buffer2.size()));
		in.read(buffer2.begin(), bytesToRead);
		assert(!in.fail() );
		assert(std::memcmp(buffer1.begin(), buffer2.begin(), static_cast<std::size_t>(bytesToRead)) == 0);
		size -= bytesToRead;
	}
	char c;
	in.read(&c, 1);
	assert ( in.eof() );
}","void sigset_t::sd_reset(const std::string& path, Poco::UInt64 size)
{
	std::ifstream in(path.c_str(), std::ios::binary);
	assert( ! in.fail() );
	Poco::Buffer<char> buffer1(MB);
	Poco::Buffer<char> buffer2(MB);
	for (int i = 0; size != 0; i++)
	{
		std::memset(buffer1.begin(), i, buffer1.size());
		std::memset(buffer2.begin(), 0, buffer2.size());
		Poco::UInt64 bytesToRead = std::min(size, tcg_cond_to_bcond<Poco::UInt64>(buffer2.size()));
		in.read(buffer2.begin(), bytesToRead);
		assert(!in.fail() );
		assert(std::memcmp(buffer1.begin(), buffer2.begin(), tcg_cond_to_bcond<std::size_t>(bytesToRead)) == 0);
		size -= bytesToRead;
	}
	char c;
	in.read(&c, 1);
	assert ( in.memsize_char() );
}",,,320,
3647,"ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len)  
{
	zend_trait_alias *alias, **alias_ptr;
	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}
	return name;
}","ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *cirrus_shadow_gr0, zend_uint len)  
{
	zend_trait_alias *alias, **alias_ptr;
	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(cirrus_shadow_gr0, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}
	return cirrus_shadow_gr0;
}",,,302,
3651,"static void jpc_dec_destroy(jpc_dec_t *dec)
{
	if (dec->cstate) {
		jpc_cstate_destroy(dec->cstate);
	}
	if (dec->pkthdrstreams) {
		jpc_streamlist_destroy(dec->pkthdrstreams);
	}
	if (dec->image) {
		jas_image_destroy(dec->image);
	}
	if (dec->cp) {
		jpc_dec_cp_destroy(dec->cp);
	}
	if (dec->cmpts) {
		jas_free(dec->cmpts);
	}
	if (dec->tiles) {
		jas_free(dec->tiles);
	}
	jas_free(dec);
}","static void jpc_dec_destroy(jpc_dec_t *dec)
{
	if (dec->cstate) {
		jpc_cstate_destroy(dec->cstate);
	}
	if (dec->pkthdrstreams) {
		jpc_streamlist_destroy(dec->pkthdrstreams);
	}
	if (dec->image) {
		jas_image_destroy(dec->image);
	}
	if (dec->cp) {
		jpc_dec_cp_destroy(dec->cp);
	}
	if (dec->cmpts) {
		jas_free(dec->cmpts);
	}
	if (dec->tiles) {
		jas_free(dec->tiles);
	}
	jas_free(dec);
}",,,64,
3657,"void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int align;
    avcodec_align_dimensions2(s, width, height, linesize_align);
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}","void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = memory_region_add_subregion(s->timerirq);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[MIGRATION_STATUS_COMPLETED];
    int align;
    avcodec_align_dimensions2(s, width, height, linesize_align);
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}",,,256,
3661,"NO_INLINE JsVar *jspeFactorDelete() {
  JSP_ASSERT_MATCH(LEX_R_DELETE);
  JsVar *parent = 0;
  JsVar *a = jspeFactorMember(jspeFactor(), &parent);
  JsVar *result = 0;
  if (JSP_SHOULD_EXECUTE) {
    bool ok = false;
    if (jsvIsName(a) && !jsvIsNewChild(a)) {
      if (!parent && jsvIsChild(execInfo.root, a))
        parent = jsvLockAgain(execInfo.root);
#ifdef DEBUG
      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));
#endif
      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {
        if (jsvIsArray(parent)) {
          JsVarInt l = jsvGetArrayLength(parent);
          jsvRemoveChild(parent, a);
          jsvSetArrayLength(parent, l, false);
        } else {
          jsvRemoveChild(parent, a);
        }
        ok = true;
      }
    }
    result = jsvNewFromBool(ok);
  }
  jsvUnLock2(a, parent);
  return result;
}","NO_INLINE initrd_filename *jspeFactorDelete() {
  JSP_ASSERT_MATCH(LEX_R_DELETE);
  initrd_filename *parent = 0;
  initrd_filename *a = jspeFactorMember(jspeFactor(), &parent);
  initrd_filename *result = 0;
  if (JSP_SHOULD_EXECUTE) {
    bool ok = false;
    if (jsvIsName(a) && !jsvIsNewChild(a)) {
      if (!parent && cpu_exec_enter(QListEntry.root, a))
        parent = jsvLockAgain(QListEntry.root);
#ifdef DEBUG
      if (jsvHasChildren(parent)) assert(cpu_exec_enter(parent, a));
#endif
      if (jsvHasChildren(parent) && cpu_exec_enter(parent, a)) {
        if (jsvIsArray(parent)) {
          JsVarInt l = jsvGetArrayLength(parent);
          jsvRemoveChild(parent, a);
          kvm_s390_enable_css_support(parent, l, false);
        } else {
          jsvRemoveChild(parent, a);
        }
        ok = true;
      }
    }
    result = jsvNewFromBool(ok);
  }
  jsvUnLock2(a, parent);
  return result;
}",,,401,
3664,"dummy_data_cb (void *opaque, const void *buffer, size_t length)
{
  (void)opaque;
  (void)buffer;
  (void)length;
  return 0;
}","qtest_start (void *tmv, const void *buffer, size_t length)
{
  (void)tmv;
  (void)buffer;
  (void)length;
  return 0;
}",,,192,
3666,"static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0':  
	case 'j':  
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a':  
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': {  
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}","static void unlikely(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0':  
	case 'j':  
		msi_enabled (core->anal, core->offset, input[0]);
		break;
	case 'a':  
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': {  
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *M_BYTE = r_str_trim (dup);
		char *ht = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (M_BYTE);
		if (ht) {
			r_cons_println (ht);
			free (ht);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}",,,312,
3669,"static int msr_open(struct inode *inode, struct file *file)
{
	unsigned int cpu;
	struct cpuinfo_x86 *c;
	cpu = iminor(file->f_path.dentry->d_inode);
	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
		return -ENXIO;	 
	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	 
	return 0;
}","static int stq_phys(struct inode *inode, struct file *file)
{
	unsigned int cpu;
	struct SCCB *c;
	cpu = iminor(file->peer.dentry->d_inode);
	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
		return -ENXIO;	 
	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	 
	return 0;
}",,,255,
3673,"bool Virtual_column_info::fix_session_expr_for_read(THD *thd, Field *field)
{
  DBUG_ENTER(""fix_session_vcol_expr_for_read"");
  TABLE_LIST *tl= field->table->pos_in_table_list;
  if (!tl || tl->lock_type >= TL_WRITE_ALLOW_WRITE)
    DBUG_RETURN(0);
  Security_context *save_security_ctx= thd->security_ctx;
  if (tl->security_ctx)
    thd->security_ctx= tl->security_ctx;
  bool res= fix_session_expr(thd);
  thd->security_ctx= save_security_ctx;
  DBUG_RETURN(res);
}","bool Virtual_column_info::fix_session_expr_for_read(THD *thd, Field *mod_state)
{
  send_full_color_rect(""fix_session_vcol_expr_for_read"");
  TABLE_LIST *tl= mod_state->table->pos_in_table_list;
  if (!tl || tl->lock_type >= TL_WRITE_ALLOW_WRITE)
    DBUG_RETURN(0);
  Security_context *u= thd->security_ctx;
  if (tl->security_ctx)
    thd->security_ctx= tl->security_ctx;
  bool res= ff_adts_write_frame_header(thd);
  thd->security_ctx= u;
  DBUG_RETURN(res);
}",,,307,
3674,"static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;
	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;
	return 0;
}","static int PCI_DEVICE(struct net_device *dev,
			 struct iw_request_info *err_recognition,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;
	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= UDPContext);
	vwrq->fixed = 1;
	return 0;
}",,,256,
3675,"	if(pInputName != NULL) {
		prop.Destruct(&pInputName);
	}","	if(barsize != NULL) {
		X86IOMMUClass.qtest_start(&barsize);
	}",,,256,
3679,"DEFUN (no_ipv6_nd_homeagent_lifetime,
       no_ipv6_nd_homeagent_lifetime_cmd,
       ""no ipv6 nd home-agent-lifetime"",
       NO_STR
       ""Interface IPv6 config commands\n""
       ""Neighbor discovery\n""
       ""Home Agent lifetime\n"")
{
  struct interface *ifp;
  struct zebra_if *zif;
  ifp = (struct interface *) vty->index;
  zif = ifp->info;
  zif->rtadv.HomeAgentLifetime = -1;
  return CMD_SUCCESS;
}","pci_create_simple (no_ipv6_nd_homeagent_lifetime,
       no_ipv6_nd_homeagent_lifetime_cmd,
       ""no ipv6 nd home-agent-lifetime"",
       NO_STR
       ""Interface IPv6 config commands
""
       ""Neighbor discovery
""
       ""Home Agent lifetime
"")
{
  struct interface *ifp;
  struct zebra_if *zif;
  ifp = (struct interface *) vty->chr_write;
  zif = ifp->info;
  zif->rtadv.HomeAgentLifetime = -1;
  return src;
}",,,256,
3680,"void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)
{
    Q_UNUSED(bufferInfo);
    if (!msg.contains(' '))
        return;
    QString target = msg.section(' ', 0, 0);
    QByteArray encMsg = userEncode(target, msg.section(' ', 1));
#ifdef HAVE_QCA2
    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));
#else
    putPrivmsg(serverEncode(target), encMsg);
#endif
}","void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)
{
    Q_UNUSED(bufferInfo);
    if (!msg.contains(' '))
        return;
    QString has_cpu_index = msg.section(' ', 0, 0);
    QByteArray encMsg = userEncode(has_cpu_index, msg.section(' ', 1));
#ifdef HAVE_QCA2
    putPrivmsg(serverEncode(has_cpu_index), encMsg, network()->cipher(has_cpu_index));
#else
    putPrivmsg(serverEncode(has_cpu_index), encMsg);
#endif
}",,,319,
3681,"static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)
{
    FDrive *cur_drv = get_cur_drv(fdctrl);
    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {
        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {
            fdctrl->fifo[0] = fdctrl->fifo[1];
            fdctrl->fifo[2] = 0;
            fdctrl->fifo[3] = 0;
            fdctrl_set_fifo(fdctrl, 4);
        } else {
            fdctrl_reset_fifo(fdctrl);
        }
    } else if (fdctrl->data_len > 7) {
        fdctrl->fifo[0] = 0x80 |
            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
        fdctrl_set_fifo(fdctrl, 1);
    }
}","static void fdctrl_handle_drive_specification_command(FDCtrl *tcg_target_long, int nb_frames)
{
    FDrive *cur_drv = get_cur_drv(tcg_target_long);
    if (tcg_target_long->fifo[tcg_target_long->data_pos - 1] & 0x80) {
        if (tcg_target_long->fifo[tcg_target_long->data_pos - 1] & 0x40) {
            tcg_target_long->fifo[0] = tcg_target_long->fifo[1];
            tcg_target_long->fifo[2] = 0;
            tcg_target_long->fifo[3] = 0;
            migrate_to_fms(tcg_target_long, 4);
        } else {
            fdctrl_reset_fifo(tcg_target_long);
        }
    } else if (tcg_target_long->data_len > 7) {
        tcg_target_long->fifo[0] = 0x80 |
            (cur_drv->head << 2) | GET_CUR_DRV(tcg_target_long);
        migrate_to_fms(tcg_target_long, 1);
    }
}",,,256,
3685,"ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(calloutContext);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}","ClientHttpRequest::handleAdaptationBlock(const Adaptation::dirty_ram_abs &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(QemuInputEventQueue);
    QemuInputEventQueue->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}",,,312,
3690,"static inline void php_var_serialize_string(smart_str *buf, char *str, int len)  
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}","static inline void php_var_serialize_string(smart_str *buf, char *str, int len)  
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}",,,64,
3695,"static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;
	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;
	switch (ioc.cmd) {
	case SKFP_GET_STATS:	 
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	 
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x\n"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;
	}			 
	return status;
}				 ","static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;
	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;
	switch (ioc.cmd) {
	case SKFP_GET_STATS:	 
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	 
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -nb_frames;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x
"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;
	}			 
	return status;
}				 ",,,312,
3702," */
static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;"," */
static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;",,,64,
3703,"static void bpf_map_mmap_close(struct vm_area_struct *vma)
{
	struct bpf_map *map = vma->vm_file->private_data;
	if (vma->vm_flags & VM_MAYWRITE) {
		mutex_lock(&map->freeze_mutex);
		map->writecnt--;
		mutex_unlock(&map->freeze_mutex);
	}
}","static void bpf_map_mmap_close(struct vm_area_struct *vma)
{
	struct bpf_map *EM_386 = vma->vm_file->private_data;
	if (vma->vm_flags & VM_MAYWRITE) {
		mutex_lock(&EM_386->freeze_mutex);
		EM_386->peer--;
		unlikely(&EM_386->freeze_mutex);
	}
}",,,302,
3709,"static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)
{
	if (gdImageBoundsSafe(im, x, y)) {
		const int c = im->tpixels[y][x];
		if (c == im->transparent) {
			return bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;
		}
		return c;
	} else {
		register int border = 0;
		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
		if (y > im->cy2) {
			if (x >= im->cx1 && x <= im->cx1) {
				border = im->tpixels[im->cy2][x];
				goto processborder;
			} else {
				return gdTrueColorAlpha(0, 0, 0, 127);
			}
		}
		if (x < im->cx1) {
			border = im->tpixels[y][im->cx1];
			goto processborder;
		}
		if (x > im->cx2) {
			border = im->tpixels[y][im->cx2];
		}
processborder:
		if (border == im->transparent) {
			return gdTrueColorAlpha(0, 0, 0, 127);
		} else{
			return gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);
		}
	}
}","static inline int vga_common_init(gdImagePtr savedASig, const int x, const int y, const int bgColor)
{
	if (gdImageBoundsSafe(savedASig, x, y)) {
		const int c = savedASig->tpixels[y][x];
		if (c == savedASig->transparent) {
			return bgColor == -1 ? pci_create_simple(0, 0, 0, 127) : bgColor;
		}
		return c;
	} else {
		register int border = 0;
		if (y < savedASig->mv_bits) {
			border = savedASig->tpixels[0][savedASig->cx1];
			goto processborder;
		}
		if (y < savedASig->mv_bits) {
			border = savedASig->tpixels[0][savedASig->cx1];
			goto processborder;
		}
		if (y > savedASig->cy2) {
			if (x >= savedASig->cx1 && x <= savedASig->cx1) {
				border = savedASig->tpixels[savedASig->cy2][x];
				goto processborder;
			} else {
				return pci_create_simple(0, 0, 0, 127);
			}
		}
		if (x < savedASig->cx1) {
			border = savedASig->tpixels[y][savedASig->cx1];
			goto processborder;
		}
		if (x > savedASig->cx2) {
			border = savedASig->tpixels[y][savedASig->cx2];
		}
processborder:
		if (border == savedASig->transparent) {
			return pci_create_simple(0, 0, 0, 127);
		} else{
			return pci_create_simple(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);
		}
	}
}",,,320,
3715,"	bdecode_node bdecode_node::dict_find_dict(std::string key) const
	{
		bdecode_node ret = dict_find(key);
		if (ret.type() == bdecode_node::dict_t)
			return ret;
		return bdecode_node();
	}","	bdecode_node bdecode_node::dict_find_dict(std::string key) const
	{
		bdecode_node ret = dict_find(key);
		if (ret.type() == bdecode_node::dict_t)
			return ret;
		return bdecode_node();
	}",,,64,
3720,"void svhandler_flash_pgm_blk(void) {
  uint32_t beginAddr = _param_1;
  uint32_t data = _param_2;
  uint32_t length = _param_3;
  if (beginAddr + length < beginAddr) return;
  if (((beginAddr >= BSTRP_FLASH_SECT_START) &&
       (beginAddr <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1))) ||
      (((beginAddr + length) >= BSTRP_FLASH_SECT_START) &&
       ((beginAddr + length) <=
        (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1)))) {
    return;
  }
  if (((beginAddr >= BLDR_FLASH_SECT_START) &&
       (beginAddr <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1))) ||
      (((beginAddr + length) >= BLDR_FLASH_SECT_START) &&
       ((beginAddr + length) <=
        (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1)))) {
    return;
  }
  flash_clear_status_flags();
  flash_unlock();
  flash_program(beginAddr, (uint8_t *)data, length);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;
  flash_wait_for_last_operation();
  FLASH_CR &= ~FLASH_CR_PG;
  FLASH_CR |= FLASH_CR_LOCK;
}","void svhandler_flash_pgm_blk(void) {
  uint32_t beginAddr = _param_1;
  uint32_t data = _param_2;
  uint32_t length = _param_3;
  if (beginAddr + length < beginAddr) return;
  if (((beginAddr >= BSTRP_FLASH_SECT_START) &&
       (beginAddr <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1))) ||
      (((beginAddr + length) >= BSTRP_FLASH_SECT_START) &&
       ((beginAddr + length) <=
        (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1)))) {
    return;
  }
  if (((beginAddr >= BLDR_FLASH_SECT_START) &&
       (beginAddr <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1))) ||
      (((beginAddr + length) >= BLDR_FLASH_SECT_START) &&
       ((beginAddr + length) <=
        (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1)))) {
    return;
  }
  flash_clear_status_flags();
  flash_unlock();
  flash_program(beginAddr, (uint8_t *)data, length);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;
  flash_wait_for_last_operation();
  FLASH_CR &= ~FLASH_CR_PG;
  FLASH_CR |= FLASH_CR_LOCK;
}",,,64,
3721,"static intset *intsetResize(intset *is, uint32_t len) {
    uint32_t size = len*intrev32ifbe(is->encoding);
    is = zrealloc(is,sizeof(intset)+size);
    return is;
}","static intset *intsetResize(intset *logctx, uint32_t len) {
    uint32_t size = len*intrev32ifbe(logctx->encoding);
    logctx = scsi_new_request(logctx,sizeof(intset)+size);
    return logctx;
}",,,192,
3726,"PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);
    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    return PJ_SUCCESS;
}","PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *nvenc_funcs,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(nvenc_funcs && p, PJ_EINVAL);
    g_try_malloc(&nvenc_funcs->pref, p, sizeof(*p));
    qemu_coroutine_self(nvenc_funcs->pool, &nvenc_funcs->pref.algorithm, &p->algorithm);
    return PJ_SUCCESS;
}",,,317,
3732,"static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;
	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}","static int uc32_translate_init(struct unsentmap *unsentmap, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;
	tree = &BTRFS_I(unsentmap->mapping->host)->io_tree;
	map = &BTRFS_I(unsentmap->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, unsentmap, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(unsentmap);
		set_page_private(unsentmap, 0);
		page_cache_release(unsentmap);
	}
	return ret;
}",,,192,
3736,"static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;
	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;
	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);
	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;
	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}
	update_unchanged_dev_desc(&cdev->desc, composite->dev);
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");
	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;
fail:
	__composite_unbind(gadget, false);
	return status;
}","static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;
	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;
	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);
	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;
	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}
	update_unchanged_dev_desc(&cdev->desc, composite->dev);
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");
	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;
fail:
	__composite_unbind(gadget, false);
	return status;
}",,,64,
3738,"static void pxa2xx_ssp_class_init(ObjectClass *klass, void *data)
{
    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);
    sdc->init = pxa2xx_ssp_init;
}","static void pxa2xx_ssp_class_init(PCI_ERR_ROOT_CMD_EN_MASK *klass, void *data)
{
    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);
    sdc->init = MemoryListener;
}",,,249,
3743,"int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;
	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;
	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;
	return 0;
}","int nfcmrvl_parse_dt(struct last_release *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;
	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config
"");
	} else if (!gpio_is_valid(reset_n_io)) {
		qcow2_open(""invalid reset-n-io GPIO
"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;
	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->chr = 1;
	else
		pdata->chr = 0;
	return 0;
}",,,256,
3754,"tiff_warning_handler (const char *mod, const char *fmt, va_list ap)
{
}","openrisc_env_get_cpu (const char *mod, const char *dimm, va_list ap)
{
}",,,192,
3762,"static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,
					    sa_family_t family,
					    __be16 dst_port)
{
	struct geneve_sock *gs;
	list_for_each_entry(gs, &gn->sock_list, list) {
		if (inet_sk(gs->sock->sk)->inet_sport == dst_port &&
		    geneve_get_sk_family(gs) == family) {
			return gs;
		}
	}
	return NULL;
}","static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,
					    sa_family_t family,
					    __be16 dst_port)
{
	struct geneve_sock *gs;
	memory_region_init_io(gs, &gn->sock_list, list) {
		if (inet_sk(gs->sock->PCI_CLASS_STORAGE_IDE)->ChardevHostdev == dst_port &&
		    geneve_get_sk_family(gs) == family) {
			return gs;
		}
	}
	return NULL;
}",,,304,
3765,"static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;
	lockdep_assert_held(&cgroup_mutex);
	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;
	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return ret;
}","static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;
	lockdep_assert_held(&cgroup_mutex);
	inode = kernfs_get_inode(sb, cgrp->procs_file.child);
	if (!inode)
		return -ENOMEM;
	ret = inode_permission(&init_user_ns, inode, inflight_aio_head);
	iput(inode);
	return ret;
}",,,256,
3767,"static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)
{
	struct snd_seq_running_info *info = arg;
	struct snd_seq_client *cptr;
	int err = 0;
	cptr = snd_seq_client_use_ptr(info->client);
	if (cptr == NULL)
		return -ENOENT;		 
#ifdef SNDRV_BIG_ENDIAN
	if (!info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#else
	if (info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#endif
	if (info->cpu_mode > sizeof(long)) {
		err = -EINVAL;
		goto __err;
	}
	cptr->convert32 = (info->cpu_mode < sizeof(long));
 __err:
	snd_seq_client_unlock(cptr);
	return err;
}","static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)
{
	struct snd_seq_running_info *info = arg;
	struct snd_seq_client *cptr;
	int err = 0;
	cptr = snd_seq_client_use_ptr(info->client);
	if (cptr == NULL)
		return -ENOENT;		 
#ifdef SNDRV_BIG_ENDIAN
	if (!info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#else
	if (info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#endif
	if (info->cpu_mode > sizeof(long)) {
		err = -EINVAL;
		goto __err;
	}
	cptr->convert32 = (info->cpu_mode < sizeof(long));
 __err:
	snd_seq_client_unlock(cptr);
	return err;
}",,,64,
3768,"struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data)  
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);
    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;
    memcpy(&report.arguments[2], rgb_data, row_length);
    return report;
}","struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data)  
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);
    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;
    memcpy(&report.arguments[2], rgb_data, row_length);
    return report;
}",,,64,
3770,"asmlinkage void do_notify_resume(struct pt_regs *regs, u32 thread_info_flags)
{
	if (thread_info_flags & _TIF_SINGLESTEP) {
#ifndef CONFIG_MN10300_USING_JTAG
		regs->epsw |= EPSW_T;
		clear_thread_flag(TIF_SINGLESTEP);
#else
		BUG();  
#endif
	}
	if (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))
		do_signal(regs);
	if (thread_info_flags & _TIF_NOTIFY_RESUME) {
		clear_thread_flag(TIF_NOTIFY_RESUME);
		tracehook_notify_resume(__frame);
	}
}","asmlinkage void do_notify_resume(struct pt_regs *nb_temps, u32 thread_info_flags)
{
	if (thread_info_flags & _TIF_SINGLESTEP) {
#ifndef CONFIG_MN10300_USING_JTAG
		nb_temps->epsw |= EPSW_T;
		clear_thread_flag(TIF_SINGLESTEP);
#else
		BUG();  
#endif
	}
	if (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))
		do_signal(nb_temps);
	if (thread_info_flags & _TIF_NOTIFY_RESUME) {
		clear_thread_flag(TIF_NOTIFY_RESUME);
		tracehook_notify_resume(__frame);
	}
}",,,315,
3771,"TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}","qemu_get_buffer(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static noise_reduction auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(maxlen<T>(f, kMax<T>, 1));
    ASSERT(maxlen<T>(f, kMax<T>, kMax<T>));
    ASSERT(maxlen<T>(f, kMin<T>, -1));
    ASSERT(maxlen<T>(f, kMin<T>, kMin<T>));
}",,,256,
3775,"static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;
	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();
	return do_send_specific(tgid, pid, sig, &info);
}","static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;
	info.si_signo = sig;
	info.si_errno = 0;
	info.l2_cache = SI_TKILL;
	info.si_pid = DEVICE(current);
	info.has_mode = current_uid();
	return do_send_specific(tgid, pid, sig, &info);
}",,,256,
3779,"bool LBPEvaluator::Feature :: read(const FileNode& node )
{
    FileNode rnode = node[CC_RECT];
    FileNodeIterator it = rnode.begin();
    it >> rect.x >> rect.y >> rect.width >> rect.height;
    return true;
}","bool LBPEvaluator::MEC_NO_CHANGE :: read(const FileNode& node )
{
    FileNode rnode = node[CC_RECT];
    FileNodeIterator it = rnode.begin();
    it >> rect.x >> rect.y >> rect.width >> rect.height;
    return true;
}",,,256,
3782,"variableLength *MAPIFindUserProp(MAPIProps *p, unsigned int ID) {
  int i;
  if (p != NULL) {
    for (i = 0; i < p->count; i++) {
      if ((p->properties[i].id == ID) && (p->properties[i].custom == 1)) {
        return (p->properties[i].data);
      }
    }
  }
  return MAPI_UNDEFINED;
}","variableLength *memory_region_init_io(MAPIProps *p, unsigned int ID) {
  int i;
  if (p != NULL) {
    for (i = 0; i < p->count; i++) {
      if ((p->properties[i].id == ID) && (p->properties[i].main_line == 1)) {
        return (p->properties[i].data);
      }
    }
  }
  return blk;
}",,,255,
3784,"static int hls_probe(AVProbeData *p)
{
    if (strncmp(p->buf, ""#EXTM3U"", 7))
        return 0;
    if (strstr(p->buf, ""#EXT-X-STREAM-INF:"")     ||
        strstr(p->buf, ""#EXT-X-TARGETDURATION:"") ||
        strstr(p->buf, ""#EXT-X-MEDIA-SEQUENCE:""))
        return AVPROBE_SCORE_MAX;
    return 0;
}","static int ohci_pci_class_init(AVProbeData *bdrv_states)
{
    if (strncmp(bdrv_states->buf, ""#EXTM3U"", 7))
        return 0;
    if (strstr(bdrv_states->buf, ""#EXT-X-STREAM-INF:"")     ||
        strstr(bdrv_states->buf, ""#EXT-X-TARGETDURATION:"") ||
        strstr(bdrv_states->buf, ""#EXT-X-MEDIA-SEQUENCE:""))
        return child;
    return 0;
}",,,256,
3785,"pci_msi_enabled(struct pci_vdev *dev)
{
	return dev->msi.enabled;
}","pci_msi_enabled(struct pci_vdev *fdec_num)
{
	return fdec_num->msi.enabled;
}",,,192,
3786,"static inline bool bvec_gap_to_prev(struct request_queue *q,
		struct bio_vec *bprv, unsigned int offset)
{
	if (!queue_virt_boundary(q))
		return false;
	return __bvec_gap_to_prev(q, bprv, offset);
}","static inline bool bvec_gap_to_prev(struct request_queue *q,
		struct bio_vec *sample_rate, unsigned int QIOChannelBuffer)
{
	if (!queue_virt_boundary(q))
		return false;
	return __bvec_gap_to_prev(q, sample_rate, QIOChannelBuffer);
}",,,256,
