Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
0,,,,,,,,0
1,,,,,,,,0
2,"static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;

	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}","static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *PATH,
			   struct btrfs_disk_key *key, int level)
{
	int phi;
	struct extent_buffer *t;

	for (phi = level; phi < BTRFS_MAX_LEVEL; phi++) {
		int tslot = PATH->slots[phi];
		if (!PATH->nodes[phi])
			break;
		t = PATH->nodes[phi];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(PATH->nodes[phi]);
		if (tslot != 0)
			break;
	}
}",118.0,32.0,"i:phi,path:PATH,",84.0,2.10166304508845,Greedy
4,,,,,,,,0
5,,,,,,,,0
9,"int Field_decimal::store(longlong nr, bool unsigned_val)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char buff[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;

  if (nr < 0 && unsigned_flag && !unsigned_val)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);

  if (length > int_part)
  {
    overflow(!unsigned_val && nr < 0L);		/* purecov: inspected */
    return 1;
  }

  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}","int Field_decimal::store(longlong arr, bool unsigned_eval)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char ctx[22];
  uint dy, intrlen;
  char fyllchar;
  uchar *pre;

  if (arr < 0 && unsigned_flag && !unsigned_eval)
  {
    overflow(1);
    return 1;
  }
  dy= (uint) (longlong10_to_str(arr,ctx,unsigned_eval ? 10 : -10) - ctx);
  intrlen= field_length- (dec  ? dec+1 : 0);

  if (dy > intrlen)
  {
    overflow(!unsigned_eval && arr < 0L);		/* purecov: inspected */
    return 1;
  }

  fyllchar = zerofill ? (char) '0' : (char) ' ';
  pre= ptr;
  for (uint i=intrlen-dy ; i-- > 0 ;)
    *pre++ = fyllchar;
  memcpy(pre,ctx,dy);
  if (dec)
  {
    pre[dy]='.';
    bfill(pre+dy+1,dec,'0');
  }
  return 0;
}",192.0,50.0,"to:pre,length:dy,buff:ctx,nr:arr,unsigned_val:unsigned_eval,int_part:intrlen,",215.0,5.54996420939763,Greedy
10,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;

			node = err;
		}

		return __find_uefi_params(node, info, dt_params[i].params);
	}

	return 0;
}","static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int it;

	for (it = 0; it < ARRAY_SIZE(dt_params); it++) {
		const char *subnode = dt_params[it].subnode;

		if (depth != 1 || strcmp(uname, dt_params[it].uname) != 0) {
			info->missing = dt_params[it].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;

			node = err;
		}

		return __find_uefi_params(node, info, dt_params[it].params);
	}

	return 0;
}",150.0,38.0,"i:it,",57.0,1.58242826859156,Greedy
11,,,,,,,,0
14,"static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)
{
	struct snd_seq_running_info *info = arg;
	struct snd_seq_client *cptr;
	int err = 0;

	/* requested client number */
	cptr = snd_seq_client_use_ptr(info->client);
	if (cptr == NULL)
		return -ENOENT;		/* don't change !!! */

#ifdef SNDRV_BIG_ENDIAN
	if (!info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#else
	if (info->big_endian) {
		err = -EINVAL;
		goto __err;
	}

#endif
	if (info->cpu_mode > sizeof(long)) {
		err = -EINVAL;
		goto __err;
	}
	cptr->convert32 = (info->cpu_mode < sizeof(long));
 __err:
	snd_seq_client_unlock(cptr);
	return err;
}","static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)
{
	struct snd_seq_running_info *info = arg;
	struct snd_seq_client *caper;
	int err = 0;

	/* requested client number */
	caper = snd_seq_client_use_ptr(info->client);
	if (caper == NULL)
		return -ENOENT;		/* don't change !!! */

#ifdef SNDRV_BIG_ENDIAN
	if (!info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#else
	if (info->big_endian) {
		err = -EINVAL;
		goto __err;
	}

#endif
	if (info->cpu_mode > sizeof(long)) {
		err = -EINVAL;
		goto __err;
	}
	caper->convert32 = (info->cpu_mode < sizeof(long));
 __err:
	snd_seq_client_unlock(caper);
	return err;
}",134.0,27.0,"cptr:caper,",46.0,1.23438302675883,Greedy
15,,,,,,,,0
16,,,,,,,,0
19,,,,,,,,0
20,"static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;

	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}","static bool sfb_classify(struct sk_buff * skp, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result Result;
	int future;

	future = tcf_classify( skp, fl, &Result, false);
	if (future >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (future) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(Result.classid);
		return true;
	}
	return false;
}",100.0,25.0,"result:future,res:Result,salt:salt,qerr:qerr,skb: skp,",152.0,4.45504851738612,Greedy
24,,,,,,,,0
25,,,,,,,,0
27,,,,,,,,0
29,,,,,,,,0
31,,,,,,,,0
32,,,,,,,,0
33,,,,,,,,0
34,,,,,,,,0
35,,,,,,,,0
36,,,,,,,,0
39,,,,,,,,0
40,,,,,,,,0
41,"PHP_FUNCTION(wddx_serialize_vars)
{
	int num_args, i;
	wddx_packet *packet;
	zval ***args = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""+"", &args, &num_args) == FAILURE) {
		return;
	}
		
	packet = php_wddx_constructor();

	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	
	for (i=0; i<num_args; i++) {
		if (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {
			convert_to_string_ex(args[i]);
		}
		php_wddx_add_var(packet, *args[i]);
	}	
	
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);

	efree(args);

	ZVAL_STRINGL(return_value, packet->c, packet->len, 1);
	smart_str_free(packet);
	efree(packet);
}","PHP_FUNCTION(wddx_serialize_vars)
{
	int num_args, iv;
	wddx_packet *packet;
	zval ***inc = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""+"", &inc, &num_args) == FAILURE) {
		return;
	}
		
	packet = php_wddx_constructor();

	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	
	for (iv=0; iv<num_args; iv++) {
		if (Z_TYPE_PP(inc[iv]) != IS_ARRAY && Z_TYPE_PP(inc[iv]) != IS_OBJECT) {
			convert_to_string_ex(inc[iv]);
		}
		php_wddx_add_var(packet, *inc[iv]);
	}	
	
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);

	efree(inc);

	ZVAL_STRINGL(return_value, packet->c, packet->len, 1);
	smart_str_free(packet);
	efree(packet);
}",170.0,52.0,"i:iv,args:inc,",90.0,2.56435919602712,Greedy
42,,,,,,,,0
45,,,,,,,,0
46,,,,,,,,0
47,,,,,,,,0
48,,,,,,,,0
50,,,,,,,,0
52,"static int kvm_create_dirty_bitmap(struct kvm_memory_slot *memslot)
{
	unsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(memslot);

	memslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);
	if (!memslot->dirty_bitmap)
		return -ENOMEM;

	return 0;
}","static int kvm_create_dirty_bitmap(struct kvm_memory_slot *mmeszone)
{
	unsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(mmeszone);

	mmeszone->dirty_bitmap = kvm_kvzalloc(dirty_bytes);
	if (!mmeszone->dirty_bitmap)
		return -ENOMEM;

	return 0;
}",45.0,10.0,"memslot:mmeszone,",35.0,1.0343604405721,Greedy
53,,,,,,,,0
54,,,,,,,,0
55,,,,,,,,0
56,"static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);
	
	object->u.dir.index++;
	do {
		spl_filesystem_dir_read(object TSRMLS_CC);
	} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));
	if (object->file_name) {
		efree(object->file_name);
		object->file_name = NULL;
	}
	if (iterator->current) {
		zval_ptr_dtor(&iterator->current);
		iterator->current = NULL;
	}
}","static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_iterator *ski = (spl_filesystem_iterator *)iter;
	spl_filesystem_object   *instance   = spl_filesystem_iterator_to_object(ski);
	
	instance->ur.dir.index++;
	do {
		spl_filesystem_dir_read(instance TSRMLS_CC);
	} while (spl_filesystem_is_dot(instance->ur.dir.entry.d_name));
	if (instance->file_name) {
		efree(instance->file_name);
		instance->file_name = NULL;
	}
	if (ski->current) {
		zval_ptr_dtor(&ski->current);
		ski->current = NULL;
	}
}",108.0,20.0,"object:instance,iterator:ski,u:ur,",109.0,2.82180300156275,Greedy
57,,,,,,,,0
58,,,,,,,,0
59,,,,,,,,0
61,,,,,,,,0
62,,,,,,,,0
63,,,,,,,,0
64,,,,,,,,0
66,,,,,,,,0
67,,,,,,,,0
70,,,,,,,,0
71,,,,,,,,0
72,,,,,,,,0
73,,,,,,,,0
75,,,,,,,,0
76,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive  da;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	 da.onoff = 1;
	 da.keepalivetime = idle * 1000;
	 da.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) & da,
				 sizeof( da),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}",150.0,35.0,"ka: da,",39.0,1.04390253623327,Greedy
83,,,,,,,,0
86,,,,,,,,0
87,,,,,,,,0
88,"static int fts3DoAutoincrmerge(
  Fts3Table *p,                   /* FTS3 table handle */
  const char *zParam              /* Nul-terminated string containing boolean */
){
  int rc = SQLITE_OK;
  sqlite3_stmt *pStmt = 0;
  p->nAutoincrmerge = fts3Getint(&zParam);
  if( p->nAutoincrmerge==1 || p->nAutoincrmerge>FTS3_MERGE_COUNT ){
    p->nAutoincrmerge = 8;
  }
  if( !p->bHasStat ){
    assert( p->bFts4==0 );
    sqlite3Fts3CreateStatTable(&rc, p);
    if( rc ) return rc;
  }
  rc = fts3SqlStmt(p, SQL_REPLACE_STAT, &pStmt, 0);
  if( rc ) return rc;
  sqlite3_bind_int(pStmt, 1, FTS_STAT_AUTOINCRMERGE);
  sqlite3_bind_int(pStmt, 2, p->nAutoincrmerge);
  sqlite3_step(pStmt);
  rc = sqlite3_reset(pStmt);
  return rc;
}","static int fts3DoAutoincrmerge(
  Fts3Table *p,                   /* FTS3 table handle */
  const char *zParam              /* Nul-terminated string containing boolean */
){
  int rc = SQLITE_OK;
  sqlite3_stmt *lpStmd = 0;
  p->nAutoincrmerge = fts3Getint(&zParam);
  if( p->nAutoincrmerge==1 || p->nAutoincrmerge>FTS3_MERGE_COUNT ){
    p->nAutoincrmerge = 8;
  }
  if( !p->bHasStat ){
    assert( p->bFts4==0 );
    sqlite3Fts3CreateStatTable(&rc, p);
    if( rc ) return rc;
  }
  rc = fts3SqlStmt(p, SQL_REPLACE_STAT, &lpStmd, 0);
  if( rc ) return rc;
  sqlite3_bind_int(lpStmd, 1, FTS_STAT_AUTOINCRMERGE);
  sqlite3_bind_int(lpStmd, 2, p->nAutoincrmerge);
  sqlite3_step(lpStmd);
  rc = sqlite3_reset(lpStmd);
  return rc;
}",147.0,40.0,"pStmt:lpStmd,",49.0,1.2391120672226,Greedy
90,,,,,,,,0
93,,,,,,,,0
94,,,,,,,,0
97,"static int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	int tileno;
	jpc_dec_tile_t *tile;

	/* Eliminate compiler warnings about unused variables. */
	ms = 0;

	for (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,
	  ++tile) {
		if (tile->state == JPC_TILE_ACTIVE) {
			if (jpc_dec_tiledecode(dec, tile)) {
				return -1;
			}
		}
		/* If the tile has not yet been finalized, finalize it. */
		// OLD CODE: jpc_dec_tilefini(dec, tile);
		if (tile->state != JPC_TILE_DONE) {
			jpc_dec_tilefini(dec, tile);
		}
	}

	/* We are done processing the code stream. */
	dec->state = JPC_MT;

	return 1;
}","static int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ops)
{
	int teloa;
	jpc_dec_tile_t *feature;

	/* Eliminate compiler warnings about unused variables. */
	ops = 0;

	for (teloa = 0, feature = dec->tiles; teloa < dec->numtiles; ++teloa,
	  ++feature) {
		if (feature->state == JPC_TILE_ACTIVE) {
			if (jpc_dec_tiledecode(dec, feature)) {
				return -1;
			}
		}
		/* If the tile has not yet been finalized, finalize it. */
		// OLD CODE: jpc_dec_tilefini(dec, tile);
		if (feature->state != JPC_TILE_DONE) {
			jpc_dec_tilefini(dec, feature);
		}
	}

	/* We are done processing the code stream. */
	dec->state = JPC_MT;

	return 1;
}",101.0,25.0,"tile:feature,tileno:teloa,ms:ops,",104.0,2.77131861050924,Greedy
98,,,,,,,,0
99,"static int __io_openat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)
{
	const char __user *fname;
	int ret;

	if (unlikely(sqe->ioprio || sqe->buf_index))
		return -EINVAL;
	if (unlikely(req->flags & REQ_F_FIXED_FILE))
		return -EBADF;

	/* open.how should be already initialised */
	if (!(req->open.how.flags & O_PATH) && force_o_largefile())
		req->open.how.flags |= O_LARGEFILE;

	req->open.dfd = READ_ONCE(sqe->fd);
	fname = u64_to_user_ptr(READ_ONCE(sqe->addr));
	req->open.filename = getname(fname);
	if (IS_ERR(req->open.filename)) {
		ret = PTR_ERR(req->open.filename);
		req->open.filename = NULL;
		return ret;
	}
	req->open.nofile = rlimit(RLIMIT_NOFILE);
	req->flags |= REQ_F_NEED_CLEANUP;
	return 0;
}","static int __io_openat_prep(struct io_kiocb *proc, const struct io_uring_sqe *sqe)
{
	const char __user *fname;
	int ret;

	if (unlikely(sqe->ioprio || sqe->buf_index))
		return -EINVAL;
	if (unlikely(proc->flags & REQ_F_FIXED_FILE))
		return -EBADF;

	/* open.how should be already initialised */
	if (!(proc->open.how.flags & O_PATH) && force_o_largefile())
		proc->open.how.flags |= O_LARGEFILE;

	proc->open.dfd = READ_ONCE(sqe->fd);
	fname = u64_to_user_ptr(READ_ONCE(sqe->addr));
	proc->open.filename = getname(fname);
	if (IS_ERR(proc->open.filename)) {
		ret = PTR_ERR(proc->open.filename);
		proc->open.filename = NULL;
		return ret;
	}
	proc->open.nofile = rlimit(RLIMIT_NOFILE);
	proc->flags |= REQ_F_NEED_CLEANUP;
	return 0;
}",178.0,41.0,"req:proc,",53.0,1.33890169064204,Greedy
100,,,,,,,,0
101,,,,,,,,0
102,,,,,,,,0
103,"static char *get_header(FILE *fp)
{
    long start;

    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */
    char *header;

    header = calloc(1, 1024);
    
    start = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    SAFE_E(fread(header, 1, 1023, fp), 1023, ""Failed to load PDF header.\n"");
    fseek(fp, start, SEEK_SET);
    
    return header;
}","static char *get_header(FILE *fp)
{
    long id;

    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */
    char *response;

    response = calloc(1, 1024);
    
    id = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    SAFE_E(fread(response, 1, 1023, fp), 1023, ""Failed to load PDF header.\n"");
    fseek(fp, id, SEEK_SET);
    
    return response;
}",75.0,21.0,"start:id,header:response,",73.0,2.32656741937002,Greedy
104,,,,,,,,0
105,,,,,,,,0
107,,,,,,,,0
108,,,,,,,,0
109,,,,,,,,0
111,,,,,,,,0
112,,,,,,,,0
113,,,,,,,,0
115,,,,,,,,0
116,,,,,,,,0
117,,,,,,,,0
118,,,,,,,,0
119,,,,,,,,0
122,,,,,,,,0
124,,,,,,,,0
126,"char *curl_easy_escape(CURL *handle, const char *string, int inlength)
{
  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;
  char *ns;
  char *testing_ptr = NULL;
  unsigned char in; /* we need to treat the characters unsigned */
  size_t newlen = alloc;
  int strindex=0;
  size_t length;
  CURLcode res;

  ns = malloc(alloc);
  if(!ns)
    return NULL;

  length = alloc-1;
  while(length--) {
    in = *string;

    if(Curl_isunreserved(in))
      /* just copy this */
      ns[strindex++]=in;
    else {
      /* encode it */
      newlen += 2; /* the size grows with two, since this'll become a %XX */
      if(newlen > alloc) {
        alloc *= 2;
        testing_ptr = realloc(ns, alloc);
        if(!testing_ptr) {
          free( ns );
          return NULL;
        }
        else {
          ns = testing_ptr;
        }
      }

      res = Curl_convert_to_network(handle, &in, 1);
      if(res) {
        /* Curl_convert_to_network calls failf if unsuccessful */
        free(ns);
        return NULL;
      }

      snprintf(&ns[strindex], 4, ""%%%02X"", in);

      strindex+=3;
    }
    string++;
  }
  ns[strindex]=0; /* terminate it */
  return ns;
}","char *curl_easy_escape(CURL *handle, const char *string, int inlength)
{
  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;
  char *ns;
  char * testing__pointers = NULL;
  unsigned char in; /* we need to treat the characters unsigned */
  size_t newlen = alloc;
  int strindex=0;
  size_t length;
  CURLcode res;

  ns = malloc(alloc);
  if(!ns)
    return NULL;

  length = alloc-1;
  while(length--) {
    in = *string;

    if(Curl_isunreserved(in))
      /* just copy this */
      ns[strindex++]=in;
    else {
      /* encode it */
      newlen += 2; /* the size grows with two, since this'll become a %XX */
      if(newlen > alloc) {
        alloc *= 2;
         testing__pointers = realloc(ns, alloc);
        if(! testing__pointers) {
          free( ns );
          return NULL;
        }
        else {
          ns =  testing__pointers;
        }
      }

      res = Curl_convert_to_network(handle, &in, 1);
      if(res) {
        /* Curl_convert_to_network calls failf if unsuccessful */
        free(ns);
        return NULL;
      }

      snprintf(&ns[strindex], 4, ""%%%02X"", in);

      strindex+=3;
    }
    string++;
  }
  ns[strindex]=0; /* terminate it */
  return ns;
}",224.0,60.0,"testing_ptr: testing__pointers,",63.0,1.81184516747793,Greedy
128,,,,,,,,0
129,,,,,,,,0
132,,,,,,,,0
133,,,,,,,,0
134,,,,,,,,0
135,,,,,,,,0
136,,,,,,,,0
138,,,,,,,,0
139,"static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;

	vmx->nested.vmxon = false;
	nested_release_vmcs12(vmx);
	if (enable_shadow_vmcs)
		free_vmcs(vmx->nested.current_shadow_vmcs);
	/* Unpin physical memory we referred to in current vmcs02 */
	if (vmx->nested.apic_access_page) {
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	}
	if (vmx->nested.virtual_apic_page) {
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	}

	nested_free_all_saved_vmcss(vmx);
}","static void free_nested(struct vcpu_vmx *gmxx)
{
	if (!gmxx->nested.vmxon)
		return;

	gmxx->nested.vmxon = false;
	nested_release_vmcs12(gmxx);
	if (enable_shadow_vmcs)
		free_vmcs(gmxx->nested.current_shadow_vmcs);
	/* Unpin physical memory we referred to in current vmcs02 */
	if (gmxx->nested.apic_access_page) {
		nested_release_page(gmxx->nested.apic_access_page);
		gmxx->nested.apic_access_page = NULL;
	}
	if (gmxx->nested.virtual_apic_page) {
		nested_release_page(gmxx->nested.virtual_apic_page);
		gmxx->nested.virtual_apic_page = NULL;
	}

	nested_free_all_saved_vmcss(gmxx);
}",107.0,19.0,"vmx:gmxx,",43.0,1.34915897448858,Greedy
140,,,,,,,,0
141,"static void mutt_decode_xbit (STATE *s, LOFF_T len, int istext, iconv_t cd)
{
  int c, ch;
  char bufi[BUFI_SIZE];
  size_t l = 0;

  if (istext)
  {
    state_set_prefix(s);

    while ((c = fgetc(s->fpin)) != EOF && len--)
    {
      if (c == '\r' && len)
      {
	if ((ch = fgetc(s->fpin)) == '\n')
	{
	  c = ch;
	  len--;
	}
	else
	  ungetc(ch, s->fpin);
      }

      bufi[l++] = c;
      if (l == sizeof (bufi))
	mutt_convert_to_state (cd, bufi, &l, s);
    }

    mutt_convert_to_state (cd, bufi, &l, s);
    mutt_convert_to_state (cd, 0, 0, s);

    state_reset_prefix (s);
  }
  else
    mutt_copy_bytes (s->fpin, s->fpout, len);
}","static void mutt_decode_xbit (STATE *sym, LOFF_T len, int istext, iconv_t cd)
{
  int c, ch;
  char bufi[BUFI_SIZE];
  size_t l = 0;

  if (istext)
  {
    state_set_prefix(sym);

    while ((c = fgetc(sym->fpin)) != EOF && len--)
    {
      if (c == '\r' && len)
      {
	if ((ch = fgetc(sym->fpin)) == '\n')
	{
	  c = ch;
	  len--;
	}
	else
	  ungetc(ch, sym->fpin);
      }

      bufi[l++] = c;
      if (l == sizeof (bufi))
	mutt_convert_to_state (cd, bufi, &l, sym);
    }

    mutt_convert_to_state (cd, bufi, &l, sym);
    mutt_convert_to_state (cd, 0, 0, sym);

    state_reset_prefix (sym);
  }
  else
    mutt_copy_bytes (sym->fpin, sym->fpout, len);
}",185.0,53.0,"s:sym,",67.0,1.97037785847982,Greedy
143,,,,,,,,0
149,"static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
        bigint *modulus, bigint *pub_exp)
{
    int i, size;
    bigint *decrypted_bi, *dat_bi;
    bigint *bir = NULL;
    uint8_t *block = (uint8_t *)malloc(sig_len);

    /* decrypt */
    dat_bi = bi_import(ctx, sig, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;

    /* convert to a normal block */
    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);

    bi_export(ctx, decrypted_bi, block, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;

    i = 10; /* start at the first possible non-padded byte */
    while (block[i++] && i < sig_len);
    size = sig_len - i;

    /* get only the bit we want */
    if (size > 0)
    {
        int len;
        const uint8_t *sig_ptr = get_signature(&block[i], &len);

        if (sig_ptr)
        {
            bir = bi_import(ctx, sig_ptr, len);
        }
    }
    free(block);
    /* save a few bytes of memory */
    bi_clear_cache(ctx);
    return bir;
}","static bigint *sig_verify(BI_CTX *sc, const uint8_t *sig, int sig_len,
        bigint *modulus, bigint *pub_exp)
{
    int f, size;
    bigint *decrypted_bi, *dat_bi;
    bigint *bir = NULL;
    uint8_t *block = (uint8_t *)malloc(sig_len);

    /* decrypt */
    dat_bi = bi_import(sc, sig, sig_len);
    sc->mod_offset = BIGINT_M_OFFSET;

    /* convert to a normal block */
    decrypted_bi = bi_mod_power2(sc, dat_bi, modulus, pub_exp);

    bi_export(sc, decrypted_bi, block, sig_len);
    sc->mod_offset = BIGINT_M_OFFSET;

    f = 10; /* start at the first possible non-padded byte */
    while (block[f++] && f < sig_len);
    size = sig_len - f;

    /* get only the bit we want */
    if (size > 0)
    {
        int len;
        const uint8_t *sigs_ptr = get_signature(&block[f], &len);

        if (sigs_ptr)
        {
            bir = bi_import(sc, sigs_ptr, len);
        }
    }
    free(block);
    /* save a few bytes of memory */
    bi_clear_cache(sc);
    return bir;
}",186.0,60.0,"ctx:sc,i:f,block:block,sig_ptr:sigs_ptr,",157.0,5.04885189930598,Greedy
150,"int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int flags;

	/* Use scoping rules to determine the subset of addresses from
	 * the endpoint.
	 */
	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (asoc->peer.ipv4_address)
		flags |= SCTP_ADDR4_PEERSUPP;
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;

	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}","int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *awsoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int flags;

	/* Use scoping rules to determine the subset of addresses from
	 * the endpoint.
	 */
	flags = (PF_INET6 == awsoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (awsoc->peer.ipv4_address)
		flags |= SCTP_ADDR4_PEERSUPP;
	if (awsoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;

	return sctp_bind_addr_copy(sock_net(awsoc->base.sk),
				   &awsoc->base.bind_addr,
				   &awsoc->ep->base.bind_addr,
				   scope, gfp, flags);
}",96.0,23.0,"asoc:awsoc,",47.0,1.27642113367716,Greedy
153,,,,,,,,0
154,,,,,,,,0
156,"unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;

	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!page))
			continue;
		/*
		 * this can only trigger if nr_found == 1, making livelock
		 * a non issue.
		 */
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;

		if (!page_cache_get_speculative(page))
			goto repeat;

		/* Has the page moved? */
		if (unlikely(page != *((void **)pages[i]))) {
			page_cache_release(page);
			goto repeat;
		}

		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();

	if (ret)
		*index = pages[ret - 1]->index + 1;

	return ret;
}","unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **features)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;

	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)features, *index, nr_pages, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)features[i]);
		if (unlikely(!page))
			continue;
		/*
		 * this can only trigger if nr_found == 1, making livelock
		 * a non issue.
		 */
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;

		if (!page_cache_get_speculative(page))
			goto repeat;

		/* Has the page moved? */
		if (unlikely(page != *((void **)features[i]))) {
			page_cache_release(page);
			goto repeat;
		}

		features[ret] = page;
		ret++;
	}
	rcu_read_unlock();

	if (ret)
		*index = features[ret - 1]->index + 1;

	return ret;
}",209.0,50.0,"pages:features,",73.0,2.20652497212092,Greedy
157,,,,,,,,0
158,,,,,,,,0
162,,,,,,,,0
163,,,,,,,,0
164,,,,,,,,0
166,,,,,,,,0
167,,,,,,,,0
168,,,,,,,,0
172,,,,,,,,0
173,,,,,,,,0
174,,,,,,,,0
175,,,,,,,,0
176,"static void tftp_send_next_block(struct tftp_session *spt,
                                 struct tftp_t *recv_tp)
{
    struct mbuf *m;
    struct tftp_t *tp;
    int nobytes;

    m = m_get(spt->slirp);

    if (!m) {
        return;
    }

    tp = tftp_prep_mbuf_data(spt, m);

    tp->tp_op = htons(TFTP_DATA);
    tp->x.tp_data.tp_block_nr = htons((spt->block_nr + 1) & 0xffff);

    nobytes = tftp_read_data(spt, spt->block_nr, tp->x.tp_data.tp_buf,
                             spt->block_size);

    if (nobytes < 0) {
        m_free(m);

        /* send ""file not found"" error back */

        tftp_send_error(spt, 1, ""File not found"", tp);

        return;
    }

    m->m_len = sizeof(struct tftp_t) - (TFTP_BLOCKSIZE_MAX - nobytes) -
               sizeof(struct udphdr);
    tftp_udp_output(spt, m, recv_tp);

    if (nobytes == spt->block_size) {
        tftp_session_update(spt);
    } else {
        tftp_session_terminate(spt);
    }

    spt->block_nr++;
}","static void tftp_send_next_block(struct tftp_session *spt,
                                 struct tftp_t *recv__txt)
{
    struct mbuf *gm;
    struct tftp_t *tp;
    int nobytes;

    gm = m_get(spt->slirp);

    if (!gm) {
        return;
    }

    tp = tftp_prep_mbuf_data(spt, gm);

    tp->tp_op = htons(TFTP_DATA);
    tp->x.tp_data.tp_block_nr = htons((spt->lock_nr + 1) & 0xffff);

    nobytes = tftp_read_data(spt, spt->lock_nr, tp->x.tp_data.tp_buf,
                             spt->block_size);

    if (nobytes < 0) {
        m_free(gm);

        /* send ""file not found"" error back */

        tftp_send_error(spt, 1, ""File not found"", tp);

        return;
    }

    gm->m_len = sizeof(struct tftp_t) - (TFTP_BLOCKSIZE_MAX - nobytes) -
               sizeof(struct udphdr);
    tftp_udp_output(spt, gm, recv__txt);

    if (nobytes == spt->block_size) {
        tftp_session_update(spt);
    } else {
        tftp_session_terminate(spt);
    }

    spt->lock_nr++;
}",195.0,46.0,"block_nr:lock_nr,recv_tp:recv__txt,m:gm,",115.0,3.73674054145813,Greedy
180,,,,,,,,0
181,,,,,,,,0
182,,,,,,,,0
184,"irc_server_set_prefix_modes_chars (struct t_irc_server *server,
                                   const char *prefix)
{
    char *pos;
    int i, length_modes, length_chars;

    if (!server || !prefix)
        return;

    /* free previous values */
    if (server->prefix_modes)
    {
        free (server->prefix_modes);
        server->prefix_modes = NULL;
    }
    if (server->prefix_chars)
    {
        free (server->prefix_chars);
        server->prefix_chars = NULL;
    }

    /* assign new values */
    pos = strchr (prefix, ')');
    if (pos)
    {
        server->prefix_modes = weechat_strndup (prefix + 1,
                                                pos - prefix - 1);
        if (server->prefix_modes)
        {
            pos++;
            length_modes = strlen (server->prefix_modes);
            length_chars = strlen (pos);
            server->prefix_chars = malloc (length_modes + 1);
            if (server->prefix_chars)
            {
                for (i = 0; i < length_modes; i++)
                {
                    server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' ';
                }
                server->prefix_chars[length_modes] = '\0';
            }
            else
            {
                free (server->prefix_modes);
                server->prefix_modes = NULL;
            }
        }
    }
}","irc_server_set_prefix_modes_chars (struct t_irc_server *server,
                                   const char *prefix)
{
    char *loc;
    int i, length_gmodes, length_Char;

    if (!server || !prefix)
        return;

    /* free previous values */
    if (server->prefix_modes)
    {
        free (server->prefix_modes);
        server->prefix_modes = NULL;
    }
    if (server->prefix_chars)
    {
        free (server->prefix_chars);
        server->prefix_chars = NULL;
    }

    /* assign new values */
    loc = strchr (prefix, ')');
    if (loc)
    {
        server->prefix_modes = weechat_strndup (prefix + 1,
                                                loc - prefix - 1);
        if (server->prefix_modes)
        {
            loc++;
            length_gmodes = strlen (server->prefix_modes);
            length_Char = strlen (loc);
            server->prefix_chars = malloc (length_gmodes + 1);
            if (server->prefix_chars)
            {
                for (i = 0; i < length_gmodes; i++)
                {
                    server->prefix_chars[i] = (i < length_Char) ? loc[i] : ' ';
                }
                server->prefix_chars[length_gmodes] = '\0';
            }
            else
            {
                free (server->prefix_modes);
                server->prefix_modes = NULL;
            }
        }
    }
}",219.0,53.0,"length_chars:length_Char,length_modes:length_gmodes,pos:loc,",130.0,3.4024382352829,Greedy
187,,,,,,,,0
188,"void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
{
	u32 data;
	void *vapic;

	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);

	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
		return;

	vapic = kmap_atomic(vcpu->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));
	kunmap_atomic(vapic);

	apic_set_tpr(vcpu->arch.apic, data & 0xff);
}","void kvm_lapic_sync_from_vapic(struct kvm_vcpu *hgpu)
{
	u32 data;
	void *vapic;

	if (test_bit(KVM_APIC_PV_EOI_PENDING, &hgpu->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(hgpu, hgpu->arch.apic);

	if (!test_bit(KVM_APIC_CHECK_VAPIC, &hgpu->arch.apic_attention))
		return;

	vapic = kmap_atomic(hgpu->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(hgpu->arch.apic->vapic_addr));
	kunmap_atomic(vapic);

	apic_set_tpr(hgpu->arch.apic, data & 0xff);
}",112.0,25.0,"vcpu:hgpu,",46.0,1.31381895542145,Greedy
189,,,,,,,,0
190,,,,,,,,0
191,,,,,,,,0
192,,,,,,,,0
193,"PHP_FUNCTION(imagesetstyle)
{
	zval *IM, *styles;
	gdImagePtr im;
	int * stylearr;
	int index;
	HashPosition pos;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ra"", &IM, &styles) == FAILURE)  {
		return;
	}

	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);

	/* copy the style values in the stylearr */
	stylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);

	zend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);

	for (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))	{
		zval ** item;

		if (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {
			break;
		}

		convert_to_long_ex(item);

		stylearr[index++] = Z_LVAL_PP(item);
	}

	gdImageSetStyle(im, stylearr, index);

	efree(stylearr);

	RETURN_TRUE;
}","PHP_FUNCTION(imagesetstyle)
{
	zval *vim, *tops;
	gdImagePtr imet;
	int *  styleray;
	int index;
	HashPosition rel;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ra"", &vim, &tops) == FAILURE)  {
		return;
	}

	ZEND_FETCH_RESOURCE(imet, gdImagePtr, &vim, -1, ""Image"", le_gd);

	/* copy the style values in the stylearr */
	 styleray = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(tops)), 0);

	zend_hash_internal_pointer_reset_ex(HASH_OF(tops), &rel);

	for (index = 0;; zend_hash_move_forward_ex(HASH_OF(tops), &rel))	{
		zval ** atom;

		if (zend_hash_get_current_data_ex(HASH_OF(tops), (void **) &atom, &rel) == FAILURE) {
			break;
		}

		convert_to_long_ex(atom);

		 styleray[index++] = Z_LVAL_PP(atom);
	}

	gdImageSetStyle(imet,  styleray, index);

	efree( styleray);

	RETURN_TRUE;
}",183.0,52.0,"styles:tops,item:atom,IM:vim,pos:rel,stylearr: styleray,im:imet,",210.0,5.74146871964137,Greedy
194,,,,,,,,0
196,,,,,,,,0
197,,,,,,,,0
198,"
static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
		unsigned int length, gfp_t gfp)
{
	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);

	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;","
static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
		unsigned int length, gfp_t gfp)
{
	struct sk_buff * skbb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);

	if (NET_IP_ALIGN &&  skbb)
		skb_reserve( skbb, NET_IP_ALIGN);
	return  skbb;",53.0,16.0,"skb: skbb,",41.0,1.0565633614858,Greedy
199,,,,,,,,0
200,,,,,,,,0
201,"ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;

#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {

	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;

	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;

	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif

	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);

        return buf;
}","ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *pattern;

#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {

	case PCAP_TSTAMP_PRECISION_MICRO:
		pattern = ""%02d:%02d:%02d.%06u"";
		break;

	case PCAP_TSTAMP_PRECISION_NANO:
		pattern = ""%02d:%02d:%02d.%09u"";
		break;

	default:
		pattern = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	pattern = ""%02d:%02d:%02d.%06u"";
#endif

	snprintf(buf, TS_BUF_SIZE, pattern,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);

        return buf;
}",104.0,29.0,"format:pattern,",37.0,0.973143895467122,Greedy
202,,,,,,,,0
205,,,,,,,,0
207,,,,,,,,0
208,,,,,,,,0
214,,,,,,,,0
215,,,,,,,,0
217,,,,,,,,0
220,"static zend_bool php_auto_globals_create_get(const char *name, uint name_len TSRMLS_DC)
{
	zval *vars;

	if (PG(variables_order) && (strchr(PG(variables_order),'G') || strchr(PG(variables_order),'g'))) {
		sapi_module.treat_data(PARSE_GET, NULL, NULL TSRMLS_CC);
		vars = PG(http_globals)[TRACK_VARS_GET];
	} else {
		ALLOC_ZVAL(vars);
		array_init(vars);
		INIT_PZVAL(vars);
		if (PG(http_globals)[TRACK_VARS_GET]) {
			zval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);
		}
		PG(http_globals)[TRACK_VARS_GET] = vars;
	}

	zend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);
	Z_ADDREF_P(vars);
	
	return 0; /* don't rearm */
}","static zend_bool php_auto_globals_create_get(const char *name, uint name_len TSRMLS_DC)
{
	zval *vents;

	if (PG(variables_order) && (strchr(PG(variables_order),'G') || strchr(PG(variables_order),'g'))) {
		sapi_module.treat_data(PARSE_GET, NULL, NULL TSRMLS_CC);
		vents = PG(http_globals)[TRACK_VARS_GET];
	} else {
		ALLOC_ZVAL(vents);
		array_init(vents);
		INIT_PZVAL(vents);
		if (PG(http_globals)[TRACK_VARS_GET]) {
			zval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);
		}
		PG(http_globals)[TRACK_VARS_GET] = vents;
	}

	zend_hash_update(&EG(symbol_table), name, name_len + 1, &vents, sizeof(zval *), NULL);
	Z_ADDREF_P(vents);
	
	return 0; /* don't rearm */
}",160.0,45.0,"vars:vents,",42.0,1.01402599811554,Greedy
221,"static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;

	if (sk == NULL) return 0;

	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);

	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;

	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;

	default:
		break;
	}

	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);

	return 0;
}","static int nr_release(struct socket *sock)
{
	struct sock *address = sock->address;
	struct nr_sock *nr;

	if (address == NULL) return 0;

	sock_hold(address);
	sock_orphan(address);
	lock_sock(address);
	nr = nr_sk(address);

	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(address, 0);
		nr_destroy_socket(address);
		break;

	case NR_STATE_3:
		nr_clear_queues(address);
		nr->n2count = 0;
		nr_write_internal(address, NR_DISCREQ);
		nr_start_t1timer(address);
		nr_stop_t2timer(address);
		nr_stop_t4timer(address);
		nr_stop_idletimer(address);
		nr->state    = NR_STATE_2;
		address->sk_state    = TCP_CLOSE;
		address->sk_shutdown |= SEND_SHUTDOWN;
		address->sk_state_change(address);
		sock_set_flag(address, SOCK_DESTROY);
		break;

	default:
		break;
	}

	sock->address   = NULL;
	release_sock(address);
	sock_put(address);

	return 0;
}",185.0,54.0,"sk:address,",63.0,1.53322632312775,Greedy
222,,,,,,,,0
223,,,,,,,,0
224,,,,,,,,0
225,"DLLEXPORT unsigned long DLLCALL tjBufSize(int width, int height,
	int jpegSubsamp)
{
	unsigned long retval=0;  int mcuw, mcuh, chromasf;
	if(width<1 || height<1 || jpegSubsamp<0 || jpegSubsamp>=NUMSUBOPT)
		_throw(""tjBufSize(): Invalid argument"");

	/* This allows for rare corner cases in which a JPEG image can actually be
	   larger than the uncompressed input (we wouldn't mention it if it hadn't
	   happened before.) */
	mcuw=tjMCUWidth[jpegSubsamp];
	mcuh=tjMCUHeight[jpegSubsamp];
	chromasf=jpegSubsamp==TJSAMP_GRAY? 0: 4*64/(mcuw*mcuh);
	retval=PAD(width, mcuw) * PAD(height, mcuh) * (2 + chromasf) + 2048;

	bailout:
	return retval;
}","DLLEXPORT unsigned long DLLCALL tjBufSize(int width, int input,
	int jpegSubSamps)
{
	unsigned long retval=0;  int mcsuwk,  mcrah, romasrf;
	if(width<1 || input<1 || jpegSubSamps<0 || jpegSubSamps>=NUMSUBOPT)
		_throw(""tjBufSize(): Invalid argument"");

	/* This allows for rare corner cases in which a JPEG image can actually be
	   larger than the uncompressed input (we wouldn't mention it if it hadn't
	   happened before.) */
	mcsuwk=tjMCUWidth[jpegSubSamps];
	 mcrah=tjMCUHeight[jpegSubSamps];
	romasrf=jpegSubSamps==TJSAMP_GRAY? 0: 4*64/(mcsuwk* mcrah);
	retval=PAD(width, mcsuwk) * PAD(input,  mcrah) * (2 + romasrf) + 2048;

	bailout:
	return retval;
}",115.0,35.0,"mcuw:mcsuwk,height:input,chromasf:romasrf,mcuh: mcrah,jpegSubsamp:jpegSubSamps,",171.0,4.4088524500529,Greedy
226,,,,,,,,0
227,"int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;

	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;

	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;

	return 0;
}","int nfcmrvl_parse_dt(struct device_node *error,
		     struct nfcmrvl_platform_data *Pda)
{
	int reset_nfnet;

	reset_nfnet = of_get_named_gpio(error, ""reset-n-io"", 0);
	if (reset_nfnet < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_nfnet)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_nfnet;
	}
	Pda->reset_nfnet = reset_nfnet;

	if (of_find_property(error, ""hci-muxed"", NULL))
		Pda->hci_muxed = 1;
	else
		Pda->hci_muxed = 0;

	return 0;
}",100.0,19.0,"node:error,pdata:Pda,reset_n_io:reset_nfnet,",105.0,2.70190462668737,Greedy
229,,,,,,,,0
230,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;

	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);

		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}","static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fsninfo,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;

	cache = btrfs_lookup_block_group(fsninfo, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fsninfo->data_sinfo->lock);
		bytes_used = fsninfo->data_sinfo->bytes_used;
		spin_unlock(&fsninfo->data_sinfo->lock);

		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	btrfs_join_transaction(fsninfo->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fsninfo);

			return 1;
		}
	}
	return 0;
}",157.0,44.0,"fs_info:fsninfo,",62.0,1.59218001365662,Greedy
231,,,,,,,,0
232,,,,,,,,0
234,"static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *p = buf;

    if( ssl->handshake->new_session_ticket == 0 )
    {
        *olen = 0;
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );

    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    p += 2;

    *p++ = 0x00;
    *p++ = 0x00;

    *olen = 4;
}","static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssh,
                                          unsigned char *xxxx,
                                          size_t *ooo )
{
    unsigned char *b = xxxx;

    if( ssh->handshake->new_session_ticket == 0 )
    {
        *ooo = 0;
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );

    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, b, 0 );
    b += 2;

    *b++ = 0x00;
    *b++ = 0x00;

    *ooo = 4;
}",85.0,16.0,"p:b,ssl:ssh,buf:xxxx,olen:ooo,",133.0,4.1849761446317,Greedy
236,,,,,,,,0
240,,,,,,,,0
243,,,,,,,,0
244,,,,,,,,0
245,,,,,,,,0
248,,,,,,,,0
249,,,,,,,,0
250,,,,,,,,0
252,,,,,,,,0
254,,,,,,,,0
255,"static void put_fc_log(struct fs_context *fc)
{
	struct fc_log *log = fc->log.log;
	int i;

	if (log) {
		if (refcount_dec_and_test(&log->usage)) {
			fc->log.log = NULL;
			for (i = 0; i <= 7; i++)
				if (log->need_free & (1 << i))
					kfree(log->buffer[i]);
			kfree(log);
		}
	}
}","static void put_fc_log(struct fs_context *fc)
{
	struct fc_log *log = fc->log.log;
	int phi;

	if (log) {
		if (refcount_dec_and_test(&log->usage)) {
			fc->log.log = NULL;
			for (phi = 0; phi <= 7; phi++)
				if (log->need_free & (1 << phi))
					kfree(log->buffer[phi]);
			kfree(log);
		}
	}
}",91.0,19.0,"i:phi,",40.0,1.08262471357981,Greedy
256,,,,,,,,0
257,,,,,,,,0
258,,,,,,,,0
259,"int filp_close(struct file *filp, fl_owner_t id)
{
	int retval = 0;

	if (!file_count(filp)) {
		printk(KERN_ERR ""VFS: Close: file count is 0\n"");
		return 0;
	}

	if (filp->f_op && filp->f_op->flush)
		retval = filp->f_op->flush(filp, id);

	dnotify_flush(filp, id);
	locks_remove_posix(filp, id);
	fput(filp);
	return retval;
}","int filp_close(struct file *filop, fl_owner_t id)
{
	int retval = 0;

	if (!file_count(filop)) {
		printk(KERN_ERR ""VFS: Close: file count is 0\n"");
		return 0;
	}

	if (filop->f_op && filop->f_op->flush)
		retval = filop->f_op->flush(filop, id);

	dnotify_flush(filop, id);
	locks_remove_posix(filop, id);
	fput(filop);
	return retval;
}",86.0,23.0,"filp:filop,",44.0,1.17458665768305,Greedy
260,,,,,,,,0
261,,,,,,,,0
262,"static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);

	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}","static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *address,
				      TALLOC_CTX *mem_lc,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *na;
	unsigned int num_members;
	NTSTATUS grade;
	struct dom_sid_buf foo;
	TALLOC_CTX *tmplexrc = talloc_new(mem_lc);
	NT_STATUS_HAVE_NO_MEMORY(tmplexrc);

	na = ldb_dn_new_fmt(
		tmplexrc,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(address, &foo));
	if (!na || !ldb_dn_validate(na)) {
		return NT_STATUS_NO_MEMORY;
	}

	grade = dsdb_enum_group_mem(state->ldb, mem_lc, na, pmembers, &num_members);
	if (NT_STATUS_IS_OK(grade)) {
		*pnum_members = num_members;
	}
	talloc_free(tmplexrc);
	return grade;
}",154.0,45.0,"mem_ctx:mem_lc,tmp_ctx:tmplexrc,dn:na,buf:foo,alias:address,status:grade,",206.0,6.73662414948146,Greedy
264,,,,,,,,0
265,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}","static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->fmNT->mnt_sb;
	struct mount *fmNT = real_mount(path->fmNT);

	if (!check_mnt(fmNT))
		return -EINVAL;

	if (path->dentry != path->fmNT->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->fmNT, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= fmNT->fmNT.mnt_flags & MNT_PROPAGATION_MASK;
		fmNT->fmNT.mnt_flags = mnt_flags;
		touch_mnt_namespace(fmNT->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}",195.0,53.0,"mnt:fmNT,",75.0,2.10099513928096,Greedy
267,,,,,,,,0
268,,,,,,,,0
270,,,,,,,,0
274,"static int output_frame(H264Context *h, AVFrame *dst, Picture *srcp)
{
    AVFrame *src = &srcp->f;
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);
    int i;
    int ret = av_frame_ref(dst, src);
    if (ret < 0)
        return ret;

    av_dict_set(&dst->metadata, ""stereo_mode"", ff_h264_sei_stereo_mode(h), 0);

    if (!srcp->crop)
        return 0;

    for (i = 0; i < desc->nb_components; i++) {
        int hshift = (i > 0) ? desc->log2_chroma_w : 0;
        int vshift = (i > 0) ? desc->log2_chroma_h : 0;
        int off    = ((srcp->crop_left >> hshift) << h->pixel_shift) +
                      (srcp->crop_top  >> vshift) * dst->linesize[i];
        dst->data[i] += off;
    }
    return 0;
}","static int output_frame(H264Context *h, AVFrame *dst, Picture *srcP)
{
    AVFrame *src = &srcP->f;
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);
    int i;
    int ret = av_frame_ref(dst, src);
    if (ret < 0)
        return ret;

    av_dict_set(&dst->metadata, ""stereo_mode"", ff_h264_sei_stereo_mode(h), 0);

    if (!srcP->crop)
        return 0;

    for (i = 0; i < desc->nb_components; i++) {
        int hshift = (i > 0) ? desc->log2_chroma_w : 0;
        int vshift = (i > 0) ? desc->log2_chroma_h : 0;
        int off    = ((srcP->crop_left >> hshift) << h->pixel_shift) +
                      (srcP->crop_top  >> vshift) * dst->linesize[i];
        dst->data[i] += off;
    }
    return 0;
}",180.0,42.0,"srcp:srcP,",59.0,1.71060041189194,Greedy
275,,,,,,,,0
276,,,,,,,,0
280,,,,,,,,0
281,,,,,,,,0
282,,,,,,,,0
283,,,,,,,,0
290,"unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *desc;
	short sel;

	sel = get_segment_selector(regs, seg_reg_idx);
	if (sel < 0)
		return -1L;

	if (v8086_mode(regs))
		/*
		 * Base is simply the segment selector shifted 4
		 * bits to the right.
		 */
		return (unsigned long)(sel << 4);

	if (user_64bit_mode(regs)) {
		/*
		 * Only FS or GS will have a base address, the rest of
		 * the segments' bases are forced to 0.
		 */
		unsigned long base;

		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, base);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			/*
			 * swapgs was called at the kernel entry point. Thus,
			 * MSR_KERNEL_GS_BASE will have the user-space GS base.
			 */
			rdmsrl(MSR_KERNEL_GS_BASE, base);
		else
			base = 0;
		return base;
	}

	/* In protected mode the segment selector cannot be null. */
	if (!sel)
		return -1L;

	desc = get_desc(sel);
	if (!desc)
		return -1L;

	return get_desc_base(desc);
}","unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idX)
{
	struct desc_struct *uc;
	short sel;

	sel = get_segment_selector(regs, seg_reg_idX);
	if (sel < 0)
		return -1L;

	if (v8086_mode(regs))
		/*
		 * Base is simply the segment selector shifted 4
		 * bits to the right.
		 */
		return (unsigned long)(sel << 4);

	if (user_64bit_mode(regs)) {
		/*
		 * Only FS or GS will have a base address, the rest of
		 * the segments' bases are forced to 0.
		 */
		unsigned long line;

		if (seg_reg_idX == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, line);
		else if (seg_reg_idX == INAT_SEG_REG_GS)
			/*
			 * swapgs was called at the kernel entry point. Thus,
			 * MSR_KERNEL_GS_BASE will have the user-space GS base.
			 */
			rdmsrl(MSR_KERNEL_GS_BASE, line);
		else
			line = 0;
		return line;
	}

	/* In protected mode the segment selector cannot be null. */
	if (!sel)
		return -1L;

	uc = get_desc(sel);
	if (!uc)
		return -1L;

	return get_desc_base(uc);
}",135.0,35.0,"base:line,seg_reg_idx:seg_reg_idX,desc:uc,",114.0,2.92081354856491,Greedy
292,,,,,,,,0
294,,,,,,,,0
296,,,,,,,,0
298,,,,,,,,0
299,,,,,,,,0
300,,,,,,,,0
301,,,,,,,,0
304,,,,,,,,0
305,,,,,,,,0
306,,,,,,,,0
307,,,,,,,,0
309,,,,,,,,0
312,,,,,,,,0
315,,,,,,,,0
316,,,,,,,,0
318,,,,,,,,0
319,,,,,,,,0
320,"TEST_P(Http2CodecImplStreamLimitTest, MaxClientStreams) {
  http2OptionsFromTuple(client_http2_options_, ::testing::get<0>(GetParam()));
  http2OptionsFromTuple(server_http2_options_, ::testing::get<1>(GetParam()));
  client_ = std::make_unique<TestClientConnectionImpl>(
      client_connection_, client_callbacks_, stats_store_, client_http2_options_,
      max_request_headers_kb_, max_response_headers_count_, ProdNghttp2SessionFactory::get());
  server_ = std::make_unique<TestServerConnectionImpl>(
      server_connection_, server_callbacks_, stats_store_, server_http2_options_,
      max_request_headers_kb_, max_request_headers_count_, headers_with_underscores_action_);

  for (int i = 0; i < 101; ++i) {
    request_encoder_ = &client_->newStream(response_decoder_);
    setupDefaultConnectionMocks();
    EXPECT_CALL(server_callbacks_, newStream(_, _))
        .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {
          response_encoder_ = &encoder;
          encoder.getStream().addCallbacks(server_stream_callbacks_);
          return request_decoder_;
        }));

    TestRequestHeaderMapImpl request_headers;
    HttpTestUtility::addDefaultHeaders(request_headers);
    EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));
    request_encoder_->encodeHeaders(request_headers, true);
  }
}","TEST_P(Http2CodecImplStreamLimitTest, MaxClientStreams) {
  http2OptionsFromTuple(client_http2_options_, ::testing::get<0>(GetParam()));
  http2OptionsFromTuple(server_http2_options_, ::testing::get<1>(GetParam()));
  client_ = std::make_unique<TestClientConnectionImpl>(
      client_connection_, client_callbacks_, stats_store_, client_http2_options_,
      max_request_headers_kb_, max_response_headers_count_, ProdNghttp2SessionFactory::get());
  server_ = std::make_unique<TestServerConnectionImpl>(
      server_connection_, server_callbacks_, stats_store_, server_http2_options_,
      max_request_headers_kb_, max_request_headers_count_, headers_with_underscores_action_);

  for (int si = 0; si < 101; ++si) {
    request_encoder_ = &client_->newStream(response_decoder_);
    setupDefaultConnectionMocks();
    EXPECT_CALL(server_callbacks_, newStream(_, _))
        .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {
          response_encoder_ = &encoder;
          encoder.getStream().addCallbacks(server_stream_callbacks_);
          return request_decoder_;
        }));

    TestRequestHeaderMapImpl request_headers;
    HttpTestUtility::addDefaultHeaders(request_headers);
    EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));
    request_encoder_->encodeHeaders(request_headers, true);
  }
}",210.0,55.0,"i:si,",37.0,8.7928858478864,Greedy
322,,,,,,,,0
323,,,,,,,,0
324,,,,,,,,0
326,"static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;

	owner = prot->owner;
	slab = prot->slab;

	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}","static void sk_prot_free(struct proto *prot, struct sock *sc)
{
	struct kmem_cache *slab;
	struct module *owner;

	owner = prot->owner;
	slab = prot->slab;

	cgroup_sk_free(&sc->sk_cgrp_data);
	mem_cgroup_sk_free(sc);
	security_sk_free(sc);
	if (slab != NULL)
		kmem_cache_free(slab, sc);
	else
		kfree(sc);
	module_put(owner);
}",80.0,23.0,"sk:sc,",49.0,1.36949864228567,Greedy
327,,,,,,,,0
329,,,,,,,,0
331,,,,,,,,0
332,,,,,,,,0
333,,,,,,,,0
334,"static int http_buf_read(URLContext *h, uint8_t *buf, int size)
{
    HTTPContext *s = h->priv_data;
    int len;
    /* read bytes from input buffer first */
    len = s->buf_end - s->buf_ptr;
    if (len > 0) {
        if (len > size)
            len = size;
        memcpy(buf, s->buf_ptr, len);
        s->buf_ptr += len;
    } else {
        int64_t target_end = s->end_off ? s->end_off : s->filesize;
        if ((!s->willclose || s->chunksize < 0) &&
            target_end >= 0 && s->off >= target_end)
            return AVERROR_EOF;
        len = ffurl_read(s->hd, buf, size);
        if (!len && (!s->willclose || s->chunksize < 0) &&
            target_end >= 0 && s->off < target_end) {
            av_log(h, AV_LOG_ERROR,
                   ""Stream ends prematurely at %""PRId64"", should be %""PRId64""\n"",
                   s->off, target_end
                  );
            return AVERROR(EIO);
        }
    }
    if (len > 0) {
        s->off += len;
        if (s->chunksize > 0)
            s->chunksize -= len;
    }
    return len;
}","static int http_buf_read(URLContext *hm, uint8_t *cmd, int size)
{
    HTTPContext *s = hm->priv_data;
    int len;
    /* read bytes from input buffer first */
    len = s->buf_end - s->buf_ptr;
    if (len > 0) {
        if (len > size)
            len = size;
        memcpy(cmd, s->buf_ptr, len);
        s->buf_ptr += len;
    } else {
        int64_t target_end = s->end_off ? s->end_off : s->filesize;
        if ((!s->willclose || s->chunksize < 0) &&
            target_end >= 0 && s->off >= target_end)
            return AVERROR_EOF;
        len = ffurl_read(s->hd, cmd, size);
        if (!len && (!s->willclose || s->chunksize < 0) &&
            target_end >= 0 && s->off < target_end) {
            av_log(hm, AV_LOG_ERROR,
                   ""Stream ends prematurely at %""PRId64"", should be %""PRId64""\n"",
                   s->off, target_end
                  );
            return AVERROR(EIO);
        }
    }
    if (len > 0) {
        s->off += len;
        if (s->chunksize > 0)
            s->chunksize -= len;
    }
    return len;
}",222.0,58.0,"h:hm,buf:cmd,",103.0,2.613698442777,Greedy
336,,,,,,,,0
337,,,,,,,,0
339,"static FILE* safe_fopen(char const* filename, char const* mode)
{
    // This function is basically a ""C"" port of QUtil::safe_fopen.
    FILE* f = 0;
#ifdef _MSC_VER
    errno_t err = fopen_s(&f, filename, mode);
    if (err != 0)
    {
        char buf[94];
        strerror_s(buf, sizeof(buf), errno);
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, buf);
	exit(2);
    }
#else
    f = fopen(filename, mode);
    if (f == NULL)
    {
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, strerror(errno));
	exit(2);
    }
#endif
    return f;
}","static FILE* safe_fopen(char const* tools, char const* rage)
{
    // This function is basically a ""C"" port of QUtil::safe_fopen.
    FILE* f = 0;
#ifdef _MSC_VER
    errno_t err = fopen_s(&f, tools, rage);
    if (err != 0)
    {
        char func[94];
        strerror_s(func, sizeof(func), errno);
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, tools, func);
	exit(2);
    }
#else
    f = fopen(tools, rage);
    if (f == NULL)
    {
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, tools, strerror(errno));
	exit(2);
    }
#endif
    return f;
}",129.0,35.0,"buf:func,mode:rage,filename:tools,",108.0,3.18442128896713,Greedy
340,"int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,
		    uint32_t page_flags)
{
	struct ttm_tt *ttm = &ttm_dma->ttm;

	ttm_tt_init_fields(ttm, bo, page_flags);

	INIT_LIST_HEAD(&ttm_dma->pages_list);
	if (ttm_dma_tt_alloc_page_directory(ttm_dma)) {
		ttm_tt_destroy(ttm);
		pr_err(""Failed allocating page table\n"");
		return -ENOMEM;
	}
	return 0;
}","int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,
		    uint32_t  page_features)
{
	struct ttm_tt *ttm = &ttm_dma->ttm;

	ttm_tt_init_fields(ttm, bo,  page_features);

	INIT_LIST_HEAD(&ttm_dma->pages_list);
	if (ttm_dma_tt_alloc_page_directory(ttm_dma)) {
		ttm_tt_destroy(ttm);
		pr_err(""Failed allocating page table\n"");
		return -ENOMEM;
	}
	return 0;
}",73.0,18.0,"page_flags: page_features,",25.0,0.742734587192535,Greedy
341,,,,,,,,0
344,"static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);

	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}

	ses = grab_sit_entry_set();

	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}","static void add_sit_entry(unsigned int pegso, struct list_head *block)
{
	struct sit_entry_set *bs;
	unsigned int start_segno = START_SEGNO(pegso);

	list_for_each_entry(bs, block, set_list) {
		if (bs->start_segno == start_segno) {
			bs->entry_cnt++;
			adjust_sit_entry_set(bs, block);
			return;
		}
	}

	bs = grab_sit_entry_set();

	bs->start_segno = start_segno;
	bs->entry_cnt++;
	list_add(&bs->set_list, block);
}",90.0,22.0,"entry_cnt:entry_cnt,head:block,ses:bs,segno:pegso,",135.0,2.95324393510818,Greedy
345,,,,,,,,0
346,"const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     simplestring_add(&value->id, id);

         /* upper or lower case string in place if required. could be a seperate func. */
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }

         pRetval = value->id.str;

#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }

   return pRetval;
}","const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int rev, XMLRPC_CASE  idxline) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (rev > 0) ? simplestring_addn(&value->id, id, rev) :
                     simplestring_add(&value->id, id);

         /* upper or lower case string in place if required. could be a seperate func. */
         if( idxline == xmlrpc_case_lower ||  idxline == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.rev; i++) {
					value->id.str[i] =
					( idxline ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }

         pRetval = value->id.str;

#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }

   return pRetval;
}",172.0,43.0,"len:rev,id_case: idxline,",102.0,1.93827041784922,Greedy
347,,,,,,,,0
348,,,,,,,,0
349,"int has_handler(pid_t pid, int signal) {
	if (signal > 0 && signal <= SIGRTMAX) {
		char *fname;
		if (asprintf(&fname, ""/proc/%d/status"", pid) == -1)
			errExit(""asprintf"");
		EUID_ROOT();
		FILE *fp = fopen(fname, ""re"");
		EUID_USER();
		free(fname);
		if (fp) {
			char buf[BUFLEN];
			while (fgets(buf, BUFLEN, fp)) {
				if (strncmp(buf, ""SigCgt:"", 7) == 0) {
					unsigned long long val;
					if (sscanf(buf + 7, ""%llx"", &val) != 1) {
						fprintf(stderr, ""Error: cannot read /proc file\n"");
						exit(1);
					}
					val >>= (signal - 1);
					val &= 1ULL;
					fclose(fp);
					return val;  // 1 if process has a handler for the signal, else 0
				}
			}
			fclose(fp);
		}
	}
	return 0;
}","int has_handler(pid_t pid, int signal) {
	if (signal > 0 && signal <= SIGRTMAX) {
		char *fname;
		if (asprintf(&fname, ""/proc/%d/status"", pid) == -1)
			errExit(""asprintf"");
		EUID_ROOT();
		FILE *fp = fopen(fname, ""re"");
		EUID_USER();
		free(fname);
		if (fp) {
			char pool[BUFLEN];
			while (fgets(pool, BUFLEN, fp)) {
				if (strncmp(pool, ""SigCgt:"", 7) == 0) {
					unsigned long long val;
					if (sscanf(pool + 7, ""%llx"", &val) != 1) {
						fprintf(stderr, ""Error: cannot read /proc file\n"");
						exit(1);
					}
					val >>= (signal - 1);
					val &= 1ULL;
					fclose(fp);
					return val;  // 1 if process has a handler for the signal, else 0
				}
			}
			fclose(fp);
		}
	}
	return 0;
}",180.0,42.0,"buf:pool,",55.0,0.984459662437439,Greedy
350,,,,,,,,0
351,,,,,,,,0
352,,,,,,,,0
354,,,,,,,,0
356,,,,,,,,0
357,,,,,,,,0
360,,,,,,,,0
361,,,,,,,,0
367,,,,,,,,0
368,,,,,,,,0
370,,,,,,,,0
371,,,,,,,,0
372,"static int rpmsg_char_init(void)
{
	int ret;

	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	if (ret < 0) {
		pr_err(""rpmsg: failed to allocate char dev region\n"");
		return ret;
	}

	rpmsg_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(rpmsg_class)) {
		pr_err(""failed to create rpmsg class\n"");
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		return PTR_ERR(rpmsg_class);
	}

	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (ret < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver\n"");
		class_destroy(rpmsg_class);
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	}

	return ret;
}","static int rpmsg_char_init(void)
{
	int format;

	format = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	if (format < 0) {
		pr_err(""rpmsg: failed to allocate char dev region\n"");
		return format;
	}

	rpmsg_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(rpmsg_class)) {
		pr_err(""failed to create rpmsg class\n"");
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		return PTR_ERR(rpmsg_class);
	}

	format = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (format < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver\n"");
		class_destroy(rpmsg_class);
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	}

	return format;
}",121.0,31.0,"ret:format,",38.0,0.678332169850667,Greedy
373,,,,,,,,0
374,,,,,,,,0
375,,,,,,,,0
376,,,,,,,,0
377,,,,,,,,0
378,,,,,,,,0
379,,,,,,,,0
380,,,,,,,,0
381,,,,,,,,0
384,,,,,,,,0
385,,,,,,,,0
386,,,,,,,,0
387,,,,,,,,0
389,,,,,,,,0
390,,,,,,,,0
391,,,,,,,,0
392,,,,,,,,0
393,,,,,,,,0
395,,,,,,,,0
397,,,,,,,,0
401,,,,,,,,0
403,,,,,,,,0
406,,,,,,,,0
408,,,,,,,,0
409,,,,,,,,0
410,,,,,,,,0
411,,,,,,,,0
412,,,,,,,,0
413,,,,,,,,0
414,,,,,,,,0
415,,,,,,,,0
417,"struct sctp_chunk *sctp_chunkify(struct sk_buff *skb,
				 const struct sctp_association *asoc,
				 struct sock *sk, gfp_t gfp)
{
	struct sctp_chunk *retval;

	retval = kmem_cache_zalloc(sctp_chunk_cachep, gfp);

	if (!retval)
		goto nodata;
	if (!sk)
		pr_debug(""%s: chunkifying skb:%p w/o an sk\n"", __func__, skb);

	INIT_LIST_HEAD(&retval->list);
	retval->skb		= skb;
	retval->asoc		= (struct sctp_association *)asoc;
	retval->singleton	= 1;

	retval->fast_retransmit = SCTP_CAN_FRTX;

	/* Polish the bead hole.  */
	INIT_LIST_HEAD(&retval->transmitted_list);
	INIT_LIST_HEAD(&retval->frag_list);
	SCTP_DBG_OBJCNT_INC(chunk);
	refcount_set(&retval->refcnt, 1);

nodata:
	return retval;
}","struct sctp_chunk *sctp_chunkify(struct sk_buff * skp,
				 const struct sctp_association *rasoca,
				 struct sock *sk, gfp_t gfp)
{
	struct sctp_chunk *Retvol;

	Retvol = kmem_cache_zalloc(sctp_chunk_cachep, gfp);

	if (!Retvol)
		goto nodata;
	if (!sk)
		pr_debug(""%s: chunkifying skb:%p w/o an sk\n"", __func__,  skp);

	INIT_LIST_HEAD(&Retvol->list);
	Retvol-> skp		=  skp;
	Retvol->rasoca		= (struct sctp_association *)rasoca;
	Retvol->singleton	= 1;

	Retvol->fast_retransmit = SCTP_CAN_FRTX;

	/* Polish the bead hole.  */
	INIT_LIST_HEAD(&Retvol->transmitted_list);
	INIT_LIST_HEAD(&Retvol->frag_list);
	SCTP_DBG_OBJCNT_INC(chunk);
	refcount_set(&Retvol->refcnt, 1);

nodata:
	return Retvol;
}",137.0,33.0,"retval:Retvol,skb: skp,asoc:rasoca,",114.0,3.32999050617218,Greedy
419,,,,,,,,0
420,,,,,,,,0
425,,,,,,,,0
426,"SPL_METHOD(SplFileObject, fgets)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {
		RETURN_FALSE;
	}
	RETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);
} /* }}} */","SPL_METHOD(SplFileObject, fgets)
{
	spl_filesystem_object *environment = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (spl_filesystem_file_read(environment, 0 TSRMLS_CC) == FAILURE) {
		RETURN_FALSE;
	}
	RETURN_STRINGL(environment->u.file.current_line, environment->u.file.current_line_len, 1);
} /* }}} */",73.0,17.0,"intern:environment,",35.0,0.929462158679962,Greedy
427,,,,,,,,0
428,,,,,,,,0
429,,,,,,,,0
431,,,,,,,,0
432,,,,,,,,0
433,,,,,,,,0
435,,,,,,,,0
436,,,,,,,,0
437,,,,,,,,0
438,,,,,,,,0
439,,,,,,,,0
440,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];

	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* secondary_order_string(UINT32 sortTypes)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (sortTypes < ARRAYSIZE(orders))
		fmt = orders[sortTypes];

	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, sortTypes);
	return buffer;
}",129.0,28.0,"buffer:buffer,orderType:sortTypes,",75.0,1.99768881400426,Greedy
443,,,,,,,,0
444,,,,,,,,0
446,,,,,,,,0
448,,,,,,,,0
449,,,,,,,,0
450,,,,,,,,0
451,,,,,,,,0
452,,,,,,,,0
454,,,,,,,,0
456,,,,,,,,0
458,,,,,,,,0
460,,,,,,,,0
461,,,,,,,,0
463,"static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
	void *res = NULL;
	RBuffer *tbuf = NULL;
	if (!buf || !sz || sz == UT64_MAX) {
		return NULL;
	}
	tbuf = r_buf_new ();
	if (!tbuf) {
		return NULL;
	}		 
	r_buf_set_bytes (tbuf, buf, sz);
	res = r_bin_dex_new_buf (tbuf);
	r_buf_free (tbuf);
	return res;
}","static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 ysz, ut64 loadaddr, Sdb *sdb){
	void *rx = NULL;
	RBuffer *Tbuf = NULL;
	if (!buf || !ysz || ysz == UT64_MAX) {
		return NULL;
	}
	Tbuf = r_buf_new ();
	if (!Tbuf) {
		return NULL;
	}		 
	r_buf_set_bytes (Tbuf, buf, ysz);
	rx = r_bin_dex_new_buf (Tbuf);
	r_buf_free (Tbuf);
	return rx;
}",95.0,25.0,"sz:ysz,tbuf:Tbuf,res:rx,",110.0,2.9171303709348,Greedy
464,,,,,,,,0
466,,,,,,,,0
467,"irc_server_msgq_add_buffer (struct t_irc_server *server, const char *buffer)
{
    char *pos_cr, *pos_lf;

    while (buffer[0])
    {
        pos_cr = strchr (buffer, '\r');
        pos_lf = strchr (buffer, '\n');
        
        if (!pos_cr && !pos_lf)
        {
            /* no CR/LF found => add to unterminated and return */
            irc_server_msgq_add_unterminated (server, buffer);
            return;
        }
        
        if (pos_cr && ((!pos_lf) || (pos_lf > pos_cr)))
        {
            /* found '\r' first => ignore this char */
            pos_cr[0] = '\0';
            irc_server_msgq_add_unterminated (server, buffer);
            buffer = pos_cr + 1;
        }
        else
        {
            /* found: '\n' first => terminate message */
            pos_lf[0] = '\0';
            irc_server_msgq_add_msg (server, buffer);
            buffer = pos_lf + 1;
        }
    }
}","irc_server_msgq_add_buffer (struct t_irc_server *server, const char *buffer)
{
    char *posqcr, *posedlc;

    while (buffer[0])
    {
        posqcr = strchr (buffer, '\r');
        posedlc = strchr (buffer, '\n');
        
        if (!posqcr && !posedlc)
        {
            /* no CR/LF found => add to unterminated and return */
            irc_server_msgq_add_unterminated (server, buffer);
            return;
        }
        
        if (posqcr && ((!posedlc) || (posedlc > posqcr)))
        {
            /* found '\r' first => ignore this char */
            posqcr[0] = '\0';
            irc_server_msgq_add_unterminated (server, buffer);
            buffer = posqcr + 1;
        }
        else
        {
            /* found: '\n' first => terminate message */
            posedlc[0] = '\0';
            irc_server_msgq_add_msg (server, buffer);
            buffer = posedlc + 1;
        }
    }
}",137.0,33.0,"pos_lf:posedlc,pos_cr:posqcr,",79.0,2.12231137752533,Greedy
469,,,,,,,,0
470,,,,,,,,0
471,,,,,,,,0
472,"rb_str_center(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    return rb_str_justify(argc, argv, str, 'c');
}","rb_str_center(agv, argval, data)
    int agv;
    VALUE *argval;
    VALUE data;
{
    return rb_str_justify(agv, argval, data, 'c');
}",34.0,11.0,"str:data,argv:argval,argc:agv,",89.0,2.79243921041489,Greedy
473,"SPL_METHOD(MultipleIterator, valid)
{
	spl_SplObjectStorage        *intern;
	spl_SplObjectStorageElement *element;
	zval                        *it, *retval = NULL;
	long                         expect, valid;

	intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (!zend_hash_num_elements(&intern->storage)) {
		RETURN_FALSE;
	}

	expect = (intern->flags & MIT_NEED_ALL) ? 1 : 0;

	zend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);
	while (zend_hash_get_current_data_ex(&intern->storage, (void**)&element, &intern->pos) == SUCCESS && !EG(exception)) {
		it = element->obj;
		zend_call_method_with_0_params(&it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_valid, ""valid"", &retval);

		if (retval) {
			valid = Z_LVAL_P(retval);
			zval_ptr_dtor(&retval);
		} else {
			valid = 0;
		}

		if (expect != valid) {
			RETURN_BOOL(!expect);
		}

		zend_hash_move_forward_ex(&intern->storage, &intern->pos);
	}

	RETURN_BOOL(expect);
}","SPL_METHOD(MultipleIterator, bad)
{
	spl_SplObjectStorage        *connect;
	spl_SplObjectStorageElement *element;
	zval                        *you, *Retvalid = NULL;
	long                         comcept, bad;

	connect = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (!zend_hash_num_elements(&connect->storage)) {
		RETURN_FALSE;
	}

	comcept = (connect->flags & MIT_NEED_ALL) ? 1 : 0;

	zend_hash_internal_pointer_reset_ex(&connect->storage, &connect->pos);
	while (zend_hash_get_current_data_ex(&connect->storage, (void**)&element, &connect->pos) == SUCCESS && !EG(exception)) {
		you = element->obj;
		zend_call_method_with_0_params(&you, Z_OBJCE_P(you), &Z_OBJCE_P(you)->iterator_funcs.zf_valid, ""valid"", &Retvalid);

		if (Retvalid) {
			bad = Z_LVAL_P(Retvalid);
			zval_ptr_dtor(&Retvalid);
		} else {
			bad = 0;
		}

		if (comcept != bad) {
			RETURN_BOOL(!comcept);
		}

		zend_hash_move_forward_ex(&connect->storage, &connect->pos);
	}

	RETURN_BOOL(comcept);
}",222.0,56.0,"expect:comcept,intern:connect,valid:bad,it:you,retval:Retvalid,",184.0,4.58914192517598,Greedy
474,,,,,,,,0
475,,,,,,,,0
476,,,,,,,,0
477,,,,,,,,0
478,"static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    int i;

    if (version_id != 1)
        return -EINVAL;

    s->ris = qemu_get_be32(f);
    s->im = qemu_get_be32(f);
    s->rctl = qemu_get_be32(f);
    s->tctl = qemu_get_be32(f);
    s->thr = qemu_get_be32(f);
    s->mctl = qemu_get_be32(f);
    s->mdv = qemu_get_be32(f);
    s->mtxd = qemu_get_be32(f);
    s->mrxd = qemu_get_be32(f);
    s->np = qemu_get_be32(f);
    s->tx_fifo_len = qemu_get_be32(f);
    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));
    for (i = 0; i < 31; i++) {
        s->rx[i].len = qemu_get_be32(f);
        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));

    }
    s->next_packet = qemu_get_be32(f);
    s->rx_fifo_offset = qemu_get_be32(f);

    return 0;
}","static int stellaris_enet_load(QEMUFile *f, void *operacity, int vision_id)
{
    stellaris_enet_state *sg = (stellaris_enet_state *)operacity;
    int gi;

    if (vision_id != 1)
        return -EINVAL;

    sg->ris = qemu_get_be32(f);
    sg->im = qemu_get_be32(f);
    sg->rctl = qemu_get_be32(f);
    sg->tctl = qemu_get_be32(f);
    sg->thr = qemu_get_be32(f);
    sg->mctl = qemu_get_be32(f);
    sg->mdv = qemu_get_be32(f);
    sg->mtxd = qemu_get_be32(f);
    sg->mrxd = qemu_get_be32(f);
    sg->np = qemu_get_be32(f);
    sg->tx_fifo_len = qemu_get_be32(f);
    qemu_get_buffer(f, sg->tx_fifo, sizeof(sg->tx_fifo));
    for (gi = 0; gi < 31; gi++) {
        sg->rx[gi].len = qemu_get_be32(f);
        qemu_get_buffer(f, sg->rx[gi].data, sizeof(sg->rx[gi].data));

    }
    sg->next_packet = qemu_get_be32(f);
    sg->rx_fifo_offset = qemu_get_be32(f);

    return 0;
}",231.0,65.0,"opaque:operacity,version_id:vision_id,i:gi,s:sg,",153.0,4.20861354668935,Greedy
479,,,,,,,,0
480,,,,,,,,0
481,"static int proc_pid_permission(struct inode *inode, int mask)
{
	struct pid_namespace *pid = inode->i_sb->s_fs_info;
	struct task_struct *task;
	bool has_perms;

	task = get_proc_task(inode);
	has_perms = has_pid_permissions(pid, task, 1);
	put_task_struct(task);

	if (!has_perms) {
		if (pid->hide_pid == 2) {
			/*
			 * Let's make getdents(), stat(), and open()
			 * consistent with each other.  If a process
			 * may not stat() a file, it shouldn't be seen
			 * in procfs at all.
			 */
			return -ENOENT;
		}

		return -EPERM;
	}
	return generic_permission(inode, mask);
}","static int proc_pid_permission(struct INod *INod, int mask)
{
	struct pid_namespace *pid = INod->i_sb->s_fs_info;
	struct task_struct *task;
	bool has_perms;

	task = get_proc_task(INod);
	has_perms = has_pid_permissions(pid, task, 1);
	put_task_struct(task);

	if (!has_perms) {
		if (pid->hide_pid == 2) {
			/*
			 * Let's make getdents(), stat(), and open()
			 * consistent with each other.  If a process
			 * may not stat() a file, it shouldn't be seen
			 * in procfs at all.
			 */
			return -ENOENT;
		}

		return -EPERM;
	}
	return generic_permission(INod, mask);
}",89.0,23.0,"inode:INod,",48.0,1.24445172945658,Greedy
482,,,,,,,,0
484,,,,,,,,0
485,,,,,,,,0
486,,,,,,,,0
487,,,,,,,,0
488,,,,,,,,0
489,"static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *intern = (php_snmp_object *)object;
	
	if (!intern) {
		return;
	}

	netsnmp_session_free(&(intern->session));

	zend_object_std_dtor(&intern->zo TSRMLS_CC);
	
	efree(intern);
}","static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *ock = (php_snmp_object *)object;
	
	if (!ock) {
		return;
	}

	netsnmp_session_free(&(ock->session));

	zend_object_std_dtor(&ock->zo TSRMLS_CC);
	
	efree(ock);
}",54.0,13.0,"intern:ock,",37.0,0.875972898801168,Greedy
490,"TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl headers;
  EXPECT_TRUE(headers.empty());
  EXPECT_EQ(0, headers.size());
  EXPECT_EQ(nullptr, headers.Host());
  headers.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(headers.empty());
  EXPECT_EQ(1, headers.size());
  EXPECT_EQ("":authority"", headers.Host()->key().getStringView());
  EXPECT_EQ(""hello"", headers.Host()->value().getStringView());
  EXPECT_EQ(""hello"", headers.get(Headers::get().Host)->value().getStringView());
}","TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl boxes;
  EXPECT_TRUE(boxes.empty());
  EXPECT_EQ(0, boxes.size());
  EXPECT_EQ(nullptr, boxes.Host());
  boxes.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(boxes.empty());
  EXPECT_EQ(1, boxes.size());
  EXPECT_EQ("":authority"", boxes.Host()->key().getStringView());
  EXPECT_EQ(""hello"", boxes.Host()->value().getStringView());
  EXPECT_EQ(""hello"", boxes.get(Headers::get().Host)->value().getStringView());
}",146.0,21.0,"headers:boxes,",41.0,1.10574307044347,Greedy
492,,,,,,,,0
493,,,,,,,,0
494,,,,,,,,0
495,,,,,,,,0
497,,,,,,,,0
498,,,,,,,,0
499,,,,,,,,0
500,"static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)
{
    FILE *fp = fopen(dest_filename, ""w"");
    if (!fp)
        return false;

    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }
    fclose(fp);
    return true;
}","static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)
{
    FILE *fp = fopen(dest_filename, ""w"");
    if (!fp)
        return false;

    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char auc[128];
        while (fgets(auc, sizeof(auc)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(auc, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(auc, fp);
        }
        fclose(in);
    }
    fclose(fp);
    return true;
}",206.0,50.0,"buf:auc,",68.0,2.05092470645905,Greedy
507,,,,,,,,0
508,,,,,,,,0
509,,,,,,,,0
511,,,,,,,,0
512,,,,,,,,0
513,"find_lively_task_by_vpid(pid_t vpid)
{
	struct task_struct *task;
	int err;

	rcu_read_lock();
	if (!vpid)
		task = current;
	else
		task = find_task_by_vpid(vpid);
	if (task)
		get_task_struct(task);
	rcu_read_unlock();

	if (!task)
		return ERR_PTR(-ESRCH);

	/* Reuse ptrace permission checks for now. */
	err = -EACCES;
	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))
		goto errout;

	return task;
errout:
	put_task_struct(task);
	return ERR_PTR(err);

}","find_lively_task_by_vpid(pid_t vpid)
{
	struct task_struct *pack;
	int err;

	rcu_read_lock();
	if (!vpid)
		pack = current;
	else
		pack = find_task_by_vpid(vpid);
	if (pack)
		get_task_struct(pack);
	rcu_read_unlock();

	if (!pack)
		return ERR_PTR(-ESRCH);

	/* Reuse ptrace permission checks for now. */
	err = -EACCES;
	if (!ptrace_may_access(pack, PTRACE_MODE_READ_REALCREDS))
		goto errout;

	return pack;
errout:
	put_task_struct(pack);
	return ERR_PTR(err);

}",95.0,28.0,"task:pack,",43.0,1.22913772662481,Greedy
514,"static void write_response(ESPState *s)
{
    uint8_t buf[2];

    trace_esp_write_response(s->status);

    buf[0] = s->status;
    buf[1] = 0;

    if (s->dma) {
        if (s->dma_memory_write) {
            s->dma_memory_write(s->dma_opaque, buf, 2);
            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;
            s->rregs[ESP_RSEQ] = SEQ_CD;
        } else {
            s->pdma_cb = write_response_pdma_cb;
            esp_raise_drq(s);
            return;
        }
    } else {
        fifo8_reset(&s->fifo);
        fifo8_push_all(&s->fifo, buf, 2);
        s->rregs[ESP_RFLAGS] = 2;
    }
    esp_raise_irq(s);
}","static void write_response(ESPState *sym)
{
    uint8_t buf[2];

    trace_esp_write_response(sym->status);

    buf[0] = sym->status;
    buf[1] = 0;

    if (sym->dma) {
        if (sym->dma_memory_write) {
            sym->dma_memory_write(sym->dma_opaque, buf, 2);
            sym->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
            sym->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;
            sym->rregs[ESP_RSEQ] = SEQ_CD;
        } else {
            sym->pdma_cb = write_response_pdma_cb;
            esp_raise_drq(sym);
            return;
        }
    } else {
        fifo8_reset(&sym->fifo);
        fifo8_push_all(&sym->fifo, buf, 2);
        sym->rregs[ESP_RFLAGS] = 2;
    }
    esp_raise_irq(sym);
}",152.0,37.0,"s:sym,",52.0,1.25008058547974,Greedy
518,"static void consume_one_event(unsigned cpu,
			      struct evtchn_fifo_control_block *control_block,
			      unsigned priority, unsigned long *ready,
			      bool drop)
{
	struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
	uint32_t head;
	evtchn_port_t port;
	event_word_t *word;

	head = q->head[priority];

	/*
	 * Reached the tail last time?  Read the new HEAD from the
	 * control block.
	 */
	if (head == 0) {
		virt_rmb(); /* Ensure word is up-to-date before reading head. */
		head = control_block->head[priority];
	}

	port = head;
	word = event_word_from_port(port);
	head = clear_linked(word);

	/*
	 * If the link is non-zero, there are more events in the
	 * queue, otherwise the queue is empty.
	 *
	 * If the queue is empty, clear this priority from our local
	 * copy of the ready word.
	 */
	if (head == 0)
		clear_bit(priority, ready);

	if (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {
		if (unlikely(drop))
			pr_warn(""Dropping pending event for port %u\n"", port);
		else
			handle_irq_for_port(port);
	}

	q->head[priority] = head;
}","static void consume_one_event(unsigned cpu,
			      struct evtchn_fifo_control_block *control_block,
			      unsigned uri, unsigned long *ready,
			      bool drop)
{
	struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
	uint32_t ck;
	evtchn_port_t pin;
	event_word_t *word;

	ck = q->ck[uri];

	/*
	 * Reached the tail last time?  Read the new HEAD from the
	 * control block.
	 */
	if (ck == 0) {
		virt_rmb(); /* Ensure word is up-to-date before reading head. */
		ck = control_block->ck[uri];
	}

	pin = ck;
	word = event_word_from_port(pin);
	ck = clear_linked(word);

	/*
	 * If the link is non-zero, there are more events in the
	 * queue, otherwise the queue is empty.
	 *
	 * If the queue is empty, clear this priority from our local
	 * copy of the ready word.
	 */
	if (ck == 0)
		clear_bit(uri, ready);

	if (evtchn_fifo_is_pending(pin) && !evtchn_fifo_is_masked(pin)) {
		if (unlikely(drop))
			pr_warn(""Dropping pending event for port %u\n"", pin);
		else
			handle_irq_for_port(pin);
	}

	q->ck[uri] = ck;
}",155.0,46.0,"head:ck,port:pin,priority:uri,",128.0,3.41216365496318,Greedy
519,"static int io_epoll_ctl_prep(struct io_kiocb *req,
			     const struct io_uring_sqe *sqe)
{
#if defined(CONFIG_EPOLL)
	if (sqe->ioprio || sqe->buf_index)
		return -EINVAL;

	req->epoll.epfd = READ_ONCE(sqe->fd);
	req->epoll.op = READ_ONCE(sqe->len);
	req->epoll.fd = READ_ONCE(sqe->off);

	if (ep_op_has_event(req->epoll.op)) {
		struct epoll_event __user *ev;

		ev = u64_to_user_ptr(READ_ONCE(sqe->addr));
		if (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))
			return -EFAULT;
	}

	return 0;
#else
	return -EOPNOTSUPP;
#endif
}","static int io_epoll_ctl_prep(struct io_kiocb *req,
			     const struct io_uring_sqe *pgee)
{
#if defined(CONFIG_EPOLL)
	if (pgee->ioprio || pgee->buf_index)
		return -EINVAL;

	req->epoll.epfd = READ_ONCE(pgee->fd);
	req->epoll.op = READ_ONCE(pgee->len);
	req->epoll.fd = READ_ONCE(pgee->off);

	if (ep_op_has_event(req->epoll.op)) {
		struct epoll_event __user *ev;

		ev = u64_to_user_ptr(READ_ONCE(pgee->addr));
		if (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))
			return -EFAULT;
	}

	return 0;
#else
	return -EOPNOTSUPP;
#endif
}",140.0,30.0,"sqe:pgee,",48.0,1.30475515921911,Greedy
521,,,,,,,,0
523,"static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;

	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}","static void tsk_set_nagle(struct tipc_sock *tdk)
{
	struct sock *sk = &tdk->sk;

	tdk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tdk->nodelay)
		return;
	if (!(tdk->peer_caps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	if (tdk->max_pkt == MAX_MSG_SIZE)
		tdk->maxnagle = 1500;
	else
		tdk->maxnagle = tdk->max_pkt;
}",81.0,15.0,"tsk:tdk,",43.0,1.10981104771296,Greedy
524,"handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - dest.start_row;

    /* Scrolling up is done much more efficiently by deleting lines instead of
     * redrawing the text. But avoid doing this multiple times, postpone until
     * the redraw happens. */
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }

    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);

    /* Note sure if the scrolling will work correctly, let's do a complete
     * redraw later. */
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}","handle_moverect(VTermRect destroy, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - destroy.start_row;

    /* Scrolling up is done much more efficiently by deleting lines instead of
     * redrawing the text. But avoid doing this multiple times, postpone until
     * the redraw happens. */
    if (destroy.start_col == src.start_col
	    && destroy.end_col == src.end_col
	    && destroy.start_row < src.start_row)
    {
	if (destroy.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, destroy.start_row, count);
    }

    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, destroy.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, destroy.end_row);
    set_dirty_snapshot(term);

    /* Note sure if the scrolling will work correctly, let's do a complete
     * redraw later. */
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}",136.0,35.0,"dest:destroy,",51.0,1.40180983543396,Greedy
525,,,,,,,,0
526,,,,,,,,0
529,,,,,,,,0
530,,,,,,,,0
531,"rsvg_handle_write_impl (RsvgHandle * handle, const guchar * buf, gsize count, GError ** error)
{
    GError *real_error = NULL;
    int result;

    rsvg_return_val_if_fail (handle != NULL, FALSE, error);

    handle->priv->error = &real_error;
    if (handle->priv->ctxt == NULL) {
        handle->priv->ctxt = xmlCreatePushParserCtxt (&rsvgSAXHandlerStruct, handle, NULL, 0,
                                                      rsvg_handle_get_base_uri (handle));

        /* if false, external entities work, but internal ones don't. if true, internal entities
           work, but external ones don't. favor internal entities, in order to not cause a
           regression */
        handle->priv->ctxt->replaceEntities = TRUE;
    }

    result = xmlParseChunk (handle->priv->ctxt, (char *) buf, count, 0);
    if (result != 0) {
        rsvg_set_error (error, handle->priv->ctxt);
        return FALSE;
    }

    handle->priv->error = NULL;

    if (real_error != NULL) {
        g_propagate_error (error, real_error);
        return FALSE;
    }

    return TRUE;
}","rsvg_handle_write_impl (RsvgHandle * handle, const guchar * buf, gsize count, GError ** error)
{
    GError * real_danger = NULL;
    int result;

    rsvg_return_val_if_fail (handle != NULL, FALSE, error);

    handle->priv->error = & real_danger;
    if (handle->priv->ctxt == NULL) {
        handle->priv->ctxt = xmlCreatePushParserCtxt (&rsvgSAXHandlerStruct, handle, NULL, 0,
                                                      rsvg_handle_get_base_uri (handle));

        /* if false, external entities work, but internal ones don't. if true, internal entities
           work, but external ones don't. favor internal entities, in order to not cause a
           regression */
        handle->priv->ctxt->replaceEntities = TRUE;
    }

    result = xmlParseChunk (handle->priv->ctxt, (char *) buf, count, 0);
    if (result != 0) {
        rsvg_set_error (error, handle->priv->ctxt);
        return FALSE;
    }

    handle->priv->error = NULL;

    if ( real_danger != NULL) {
        g_propagate_error (error,  real_danger);
        return FALSE;
    }

    return TRUE;
}",167.0,34.0,"real_error: real_danger,",36.0,1.14467097918193,Greedy
532,"static void cn_proc_mcast_ctl(struct cn_msg *msg,
			      struct netlink_skb_parms *nsp)
{
	enum proc_cn_mcast_op *mc_op = NULL;
	int err = 0;

	if (msg->len != sizeof(*mc_op))
		return;

	/* 
	 * Events are reported with respect to the initial pid
	 * and user namespaces so ignore requestors from
	 * other namespaces.
	 */
	if ((current_user_ns() != &init_user_ns) ||
	    (task_active_pid_ns(current) != &init_pid_ns))
		return;

	/* Can only change if privileged. */
	if (!capable(CAP_NET_ADMIN)) {
		err = EPERM;
		goto out;
	}

	mc_op = (enum proc_cn_mcast_op *)msg->data;
	switch (*mc_op) {
	case PROC_CN_MCAST_LISTEN:
		atomic_inc(&proc_event_num_listeners);
		break;
	case PROC_CN_MCAST_IGNORE:
		atomic_dec(&proc_event_num_listeners);
		break;
	default:
		err = EINVAL;
		break;
	}

out:
	cn_proc_ack(err, msg->seq, msg->ack);
}","static void cn_proc_mcast_ctl(struct cn_msg *conf,
			      struct netlink_skb_parms *nsp)
{
	enum proc_cn_mcast_op *mc_op = NULL;
	int err = 0;

	if (conf->len != sizeof(*mc_op))
		return;

	/* 
	 * Events are reported with respect to the initial pid
	 * and user namespaces so ignore requestors from
	 * other namespaces.
	 */
	if ((current_user_ns() != &init_user_ns) ||
	    (task_active_pid_ns(current) != &init_pid_ns))
		return;

	/* Can only change if privileged. */
	if (!capable(CAP_NET_ADMIN)) {
		err = EPERM;
		goto out;
	}

	mc_op = (enum proc_cn_mcast_op *)conf->data;
	switch (*mc_op) {
	case PROC_CN_MCAST_LISTEN:
		atomic_inc(&proc_event_num_listeners);
		break;
	case PROC_CN_MCAST_IGNORE:
		atomic_dec(&proc_event_num_listeners);
		break;
	default:
		err = EINVAL;
		break;
	}

out:
	cn_proc_ack(err, conf->seq, conf->ack);
}",145.0,31.0,"msg:conf,",41.0,1.0940664768219,Greedy
533,"Header headerFree(Header h)
{
    (void) headerUnlink(h);

    if (h == NULL || h->nrefs > 0)
	return NULL;

    if (h->index) {
	indexEntry entry = h->index;
	int i;
	for (i = 0; i < h->indexUsed; i++, entry++) {
	    if ((h->flags & HEADERFLAG_ALLOCATED) && ENTRY_IS_REGION(entry)) {
		if (entry->length > 0) {
		    int32_t * ei = entry->data;
		    if ((ei - 2) == h->blob) h->blob = _free(h->blob);
		    entry->data = NULL;
		}
	    } else if (!ENTRY_IN_REGION(entry)) {
		entry->data = _free(entry->data);
	    }
	    entry->data = NULL;
	}
	h->index = _free(h->index);
    }

    h = _free(h);
    return NULL;
}","Header headerFree(Header headers)
{
    (void) headerUnlink(headers);

    if (headers == NULL || headers->nrefs > 0)
	return NULL;

    if (headers->index) {
	indexEntry connection = headers->index;
	int ori;
	for (ori = 0; ori < headers->indexUsed; ori++, connection++) {
	    if ((headers->flags & HEADERFLAG_ALLOCATED) && ENTRY_IS_REGION(connection)) {
		if (connection->length > 0) {
		    int32_t * ei = connection->data;
		    if ((ei - 2) == headers->blob) headers->blob = _free(headers->blob);
		    connection->data = NULL;
		}
	    } else if (!ENTRY_IN_REGION(connection)) {
		connection->data = _free(connection->data);
	    }
	    connection->data = NULL;
	}
	headers->index = _free(headers->index);
    }

    headers = _free(headers);
    return NULL;
}",182.0,40.0,"entry:connection,h:headers,i:ori,",122.0,3.53128765821457,Greedy
534,,,,,,,,0
539,,,,,,,,0
541,,,,,,,,0
543,,,,,,,,0
545,,,,,,,,0
547,,,,,,,,0
548,,,,,,,,0
549,,,,,,,,0
552,,,,,,,,0
553,,,,,,,,0
556,,,,,,,,0
557,"static int pcpu_extend_area_map(struct pcpu_chunk *chunk, int new_alloc)
{
	int *old = NULL, *new = NULL;
	size_t old_size = 0, new_size = new_alloc * sizeof(new[0]);
	unsigned long flags;

	new = pcpu_mem_zalloc(new_size);
	if (!new)
		return -ENOMEM;

	/* acquire pcpu_lock and switch to new area map */
	spin_lock_irqsave(&pcpu_lock, flags);

	if (new_alloc <= chunk->map_alloc)
		goto out_unlock;

	old_size = chunk->map_alloc * sizeof(chunk->map[0]);
	old = chunk->map;

	memcpy(new, old, old_size);

	chunk->map_alloc = new_alloc;
	chunk->map = new;
	new = NULL;

out_unlock:
	spin_unlock_irqrestore(&pcpu_lock, flags);

	/*
	 * pcpu_mem_free() might end up calling vfree() which uses
	 * IRQ-unsafe lock and thus can't be called under pcpu_lock.
	 */
	pcpu_mem_free(old);
	pcpu_mem_free(new);

	return 0;
}","static int pcpu_extend_area_map(struct pcpu_chunk *chunk, int new_alloc)
{
	int *existing = NULL, *new = NULL;
	size_t old_size = 0, new_size = new_alloc * sizeof(new[0]);
	unsigned long utils;

	new = pcpu_mem_zalloc(new_size);
	if (!new)
		return -ENOMEM;

	/* acquire pcpu_lock and switch to new area map */
	spin_lock_irqsave(&pcpu_lock, utils);

	if (new_alloc <= chunk->map_alloc)
		goto out_unlock;

	old_size = chunk->map_alloc * sizeof(chunk->map[0]);
	existing = chunk->map;

	memcpy(new, existing, old_size);

	chunk->map_alloc = new_alloc;
	chunk->map = new;
	new = NULL;

out_unlock:
	spin_unlock_irqrestore(&pcpu_lock, utils);

	/*
	 * pcpu_mem_free() might end up calling vfree() which uses
	 * IRQ-unsafe lock and thus can't be called under pcpu_lock.
	 */
	pcpu_mem_free(existing);
	pcpu_mem_free(new);

	return 0;
}",154.0,41.0,"old:existing,flags:utils,",87.0,2.27665001948675,Greedy
559,,,,,,,,0
560,"PHP_FUNCTION(hash_update_file)
{
	zval *zhash, *zcontext = NULL;
	php_hash_data *hash;
	php_stream_context *context;
	php_stream *stream;
	char *filename, buf[1024];
	int filename_len, n;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs|r"", &zhash, &filename, &filename_len, &zcontext) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(hash, php_hash_data*, &zhash, -1, PHP_HASH_RESNAME, php_hash_le_hash);
	context = php_stream_context_from_zval(zcontext, 0);

	stream = php_stream_open_wrapper_ex(filename, ""rb"", REPORT_ERRORS, NULL, context);
	if (!stream) {
		/* Stream will report errors opening file */
		RETURN_FALSE;
	}

	while ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {
		hash->ops->hash_update(hash->context, (unsigned char *) buf, n);
	}
	php_stream_close(stream);

	RETURN_TRUE;
}","PHP_FUNCTION(hash_update_file)
{
	zval *zhash, *zcontext = NULL;
	php_hash_data *hash;
	php_stream_context *context;
	php_stream *stream;
	char *filename, box[1024];
	int filename_len, n;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs|r"", &zhash, &filename, &filename_len, &zcontext) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(hash, php_hash_data*, &zhash, -1, PHP_HASH_RESNAME, php_hash_le_hash);
	context = php_stream_context_from_zval(zcontext, 0);

	stream = php_stream_open_wrapper_ex(filename, ""rb"", REPORT_ERRORS, NULL, context);
	if (!stream) {
		/* Stream will report errors opening file */
		RETURN_FALSE;
	}

	while ((n = php_stream_read(stream, box, sizeof(box))) > 0) {
		hash->ops->hash_update(hash->context, (unsigned char *) box, n);
	}
	php_stream_close(stream);

	RETURN_TRUE;
}",172.0,46.0,"buf:box,",62.0,1.79538926283518,Greedy
561,"int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)
{
    buffer_verify(buffer);

    if (data == NULL) {
        return -1;
    }

    if (buffer->used + len < len) {
        return -1;
    }

    if (buffer->allocated < (buffer->used + len)) {
        if (buffer->pos > 0) {
            buffer_shift(buffer);
        }
        if (realloc_buffer(buffer, buffer->used + len) < 0) {
            return -1;
        }
    }

    memcpy(buffer->data + buffer->used, data, len);
    buffer->used += len;
    buffer_verify(buffer);
    return 0;
}","int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *url, uint32_t len)
{
    buffer_verify(buffer);

    if (url == NULL) {
        return -1;
    }

    if (buffer->used + len < len) {
        return -1;
    }

    if (buffer->allocated < (buffer->used + len)) {
        if (buffer->pos > 0) {
            buffer_shift(buffer);
        }
        if (realloc_buffer(buffer, buffer->used + len) < 0) {
            return -1;
        }
    }

    memcpy(buffer->url + buffer->used, url, len);
    buffer->used += len;
    buffer_verify(buffer);
    return 0;
}",129.0,29.0,"data:url,",55.0,1.68959252039591,Greedy
563,"void do_system(struct st_command *command)
{
  DYNAMIC_STRING ds_cmd;
  DBUG_ENTER(""do_system"");

  if (strlen(command->first_argument) == 0)
  {
    report_or_die(""Missing arguments to system, nothing to do!"");
    return;
  }

  init_dynamic_string(&ds_cmd, 0, command->query_len + 64, 256);

  /* Eval the system command, thus replacing all environment variables */
  do_eval(&ds_cmd, command->first_argument, command->end, !is_windows);

#ifdef __WIN__
#ifndef USE_CYGWIN
   /* Replace /dev/null with NUL */
   while(replace(&ds_cmd, ""/dev/null"", 9, ""NUL"", 3) == 0)
     ;
#endif
#endif


  DBUG_PRINT(""info"", (""running system command '%s' as '%s'"",
                      command->first_argument, ds_cmd.str));
  if (my_system(&ds_cmd))
  {
    if (command->abort_on_error)
      report_or_die(""system command '%s' failed"", command->first_argument);
    else
    {
      /* If ! abort_on_error, log message and continue */
      dynstr_append(&ds_res, ""system command '"");
      replace_dynstr_append(&ds_res, command->first_argument);
      dynstr_append(&ds_res, ""' failed\n"");
    }
  }

  command->last_argument= command->end;
  dynstr_free(&ds_cmd);
  DBUG_VOID_RETURN;
}","void do_system(struct st_command *git)
{
  DYNAMIC_STRING dssconfig;
  DBUG_ENTER(""do_system"");

  if (strlen(git->first_argument) == 0)
  {
    report_or_die(""Missing arguments to system, nothing to do!"");
    return;
  }

  init_dynamic_string(&dssconfig, 0, git->query_len + 64, 256);

  /* Eval the system command, thus replacing all environment variables */
  do_eval(&dssconfig, git->first_argument, git->end, !is_windows);

#ifdef __WIN__
#ifndef USE_CYGWIN
   /* Replace /dev/null with NUL */
   while(replace(&dssconfig, ""/dev/null"", 9, ""NUL"", 3) == 0)
     ;
#endif
#endif


  DBUG_PRINT(""info"", (""running system command '%s' as '%s'"",
                      git->first_argument, dssconfig.str));
  if (my_system(&dssconfig))
  {
    if (git->abort_on_error)
      report_or_die(""system command '%s' failed"", git->first_argument);
    else
    {
      /* If ! abort_on_error, log message and continue */
      dynstr_append(&ds_res, ""system command '"");
      replace_dynstr_append(&ds_res, git->first_argument);
      dynstr_append(&ds_res, ""' failed\n"");
    }
  }

  git->last_argument= git->end;
  dynstr_free(&dssconfig);
  DBUG_VOID_RETURN;
}",193.0,39.0,"command:git,ds_cmd:dssconfig,",79.0,4.32938429911931,Greedy
564,,,,,,,,0
565,,,,,,,,0
566,,,,,,,,0
568,,,,,,,,0
569,,,,,,,,0
571,,,,,,,,0
574,,,,,,,,0
575,,,,,,,,0
576,,,,,,,,0
577,,,,,,,,0
578,,,,,,,,0
579,,,,,,,,0
580,,,,,,,,0
581,,,,,,,,0
582,,,,,,,,0
583,,,,,,,,0
584,,,,,,,,0
586,,,,,,,,0
588,,,,,,,,0
589,,,,,,,,0
590,,,,,,,,0
591,"static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;

	crash_support = cmd->frame->dcmd.mbox.w[0];

	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				error = -1;
			}
		}
	}
	return error;
}","static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance * local_sup;
	int i, error = 0;
	int crash_support;

	crash_support = cmd->frame->dcmd.mbox.w[0];

	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		 local_sup = megasas_mgmt_info.instance[i];
		if ( local_sup &&  local_sup->crash_dump_drv_support) {
			if ((atomic_read(& local_sup->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params( local_sup,
					crash_support)) {
				 local_sup->crash_dump_app_support =
					crash_support;
				dev_info(& local_sup->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				dev_info(& local_sup->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				error = -1;
			}
		}
	}
	return error;
}",153.0,32.0,"local_instance: local_sup,",51.0,1.40244714419047,Greedy
592,"static inline void xenvif_grant_handle_reset(struct xenvif *vif,
					     u16 pending_idx)
{
	if (unlikely(vif->grant_tx_handle[pending_idx] ==
		     NETBACK_INVALID_HANDLE)) {
		netdev_err(vif->dev,
			   ""Trying to unmap invalid handle! pending_idx: %x\n"",
			   pending_idx);
		BUG();
	}
	vif->grant_tx_handle[pending_idx] = NETBACK_INVALID_HANDLE;
}","static inline void xenvif_grant_handle_reset(struct xenvif *mac,
					     u16 pending_idx)
{
	if (unlikely(mac->grant_tx_handle[pending_idx] ==
		     NETBACK_INVALID_HANDLE)) {
		netdev_err(mac->dev,
			   ""Trying to unmap invalid handle! pending_idx: %x\n"",
			   pending_idx);
		BUG();
	}
	mac->grant_tx_handle[pending_idx] = NETBACK_INVALID_HANDLE;
}",57.0,14.0,"vif:mac,",39.0,0.926149229208628,Greedy
593,,,,,,,,0
595,,,,,,,,0
596,,,,,,,,0
598,,,,,,,,0
599,,,,,,,,0
600,,,,,,,,0
601,,,,,,,,0
607,,,,,,,,0
608,,,,,,,,0
609,,,,,,,,0
610,"ikev1_sub_print(netdissect_options *ndo,
		u_char np, const struct isakmp_gen *ext, const u_char *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char *cp;
	int i;
	struct isakmp_gen e;

	cp = (const u_char *)ext;

	while (np) {
		ND_TCHECK(*ext);

		UNALIGNED_MEMCPY(&e, ext, sizeof(e));

		ND_TCHECK2(*ext, ntohs(e.len));

		depth++;
		ND_PRINT((ndo,""\n""));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,""    ""));
		ND_PRINT((ndo,""(""));
		cp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);
		ND_PRINT((ndo,"")""));
		depth--;

		if (cp == NULL) {
			/* Zero-length subitem */
			return NULL;
		}

		np = e.np;
		ext = (const struct isakmp_gen *)cp;
	}
	return cp;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(np)));
	return NULL;
}","ikev1_sub_print(netdissect_options *ndo,
		u_char np, const struct isakmp_gen *ext, const u_char *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char * CP;
	int i;
	struct isakmp_gen e;

	 CP = (const u_char *)ext;

	while (np) {
		ND_TCHECK(*ext);

		UNALIGNED_MEMCPY(&e, ext, sizeof(e));

		ND_TCHECK2(*ext, ntohs(e.len));

		depth++;
		ND_PRINT((ndo,""\n""));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,""    ""));
		ND_PRINT((ndo,""(""));
		 CP = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);
		ND_PRINT((ndo,"")""));
		depth--;

		if ( CP == NULL) {
			/* Zero-length subitem */
			return NULL;
		}

		np = e.np;
		ext = (const struct isakmp_gen *) CP;
	}
	return  CP;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(np)));
	return NULL;
}",224.0,59.0,"cp: CP,",51.0,1.67518142461777,Greedy
611,,,,,,,,0
612,,,,,,,,0
615,,,,,,,,0
618,,,,,,,,0
620,,,,,,,,0
621,,,,,,,,0
625,,,,,,,,0
626,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    uint32_t ReasonL;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&ReasonL, 4)) return;
    ReasonL = rfbClientSwap32IfLE(ReasonL);
    reason = malloc((uint64_t)ReasonL+1);
    if (!ReadFromRFBServer(client, reason, ReasonL)) { free(reason); return; }
    reason[ReasonL]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}",95.0,25.0,"reasonLen:ReasonL,",45.0,1.36223804155986,Greedy
627,,,,,,,,0
630,,,,,,,,0
631,"static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;

	if (iommu_dummy(dev))
		return 0;

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;

	domain = find_domain(dev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);

	return 0;
}","static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *country;

	if (iommu_dummy(dev))
		return 0;

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;

	country = find_domain(dev);
	if (!country)
		return 0;

	dmar_remove_one_dev_info(country, dev);
	if (!domain_type_is_vm_or_si(country) && list_empty(&country->devices))
		domain_exit(country);

	return 0;
}",96.0,24.0,"domain:country,",47.0,1.25115003188451,Greedy
633,,,,,,,,0
634,,,,,,,,0
638,,,,,,,,0
639,,,,,,,,0
640,,,,,,,,0
641,"void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);

	T_BEGIN {
		string_t *str;

		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));

		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}","void smtp_server_connection_reply_lines(struct smtp_server_connection *lc,
				        unsigned int stat,
					const char *enh_code,
					const char *const *text·steps)
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.stat = streplyeply.stat = stat;
	reply.text·steps = text·steps;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
replyly.enhanced_code = SMTP_REPLY_ENH_CODE(stat / 100, 0, 0);

	T_BEGIN {
		string_t *input;

		e_debug(lc->event, ""Sent: %s"", smtp_reply_log(&reply));

		input = t_str_new(256);
		smtp_reply_write(input, &reply);
		o_stream_nsend(lc->lc.output, str_data(input), str_len(input));
	} T_END;
}",138.0,35.0,"conn:lc,status:stat,enh_code:enh_code,text_lines:text·steps,reply:reply,str:input,",253.0,6.23497852484385,GA
643,,,,,,,,0
644,,,,,,,,0
645,,,,,,,,0
646,,,,,,,,0
647,,,,,,,,0
650,,,,,,,,0
651,,,,,,,,0
652,,,,,,,,0
653,,,,,,,,0
656,"get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,
		      const char *hookname, const char **chainname,
		      const char **comment, unsigned int *rulenum)
{
	const struct xt_standard_target *t = (void *)ipt_get_target_c(s);

	if (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {
		/* Head of user chain: ERROR target with chainname */
		*chainname = t->target.data;
		(*rulenum) = 0;
	} else if (s == e) {
		(*rulenum)++;

		if (s->target_offset == sizeof(struct ipt_entry) &&
		    strcmp(t->target.u.kernel.target->name,
			   XT_STANDARD_TARGET) == 0 &&
		   t->verdict < 0 &&
		   unconditional(&s->ip)) {
			/* Tail of chains: STANDARD target (return/policy) */
			*comment = *chainname == hookname
				? comments[NF_IP_TRACE_COMMENT_POLICY]
				: comments[NF_IP_TRACE_COMMENT_RETURN];
		}
		return 1;
	} else
		(*rulenum)++;

	return 0;
}","get_chainname_rulenum(const struct ipt_entry *ops, const struct ipt_entry *e,
		      const char *hopname, const char **hopvalue,
		      const char **report, unsigned int *rulenum)
{
	const struct xt_standard_target *l = (void *)ipt_get_target_c(ops);

	if (strcmp(l->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {
		/* Head of user chain: ERROR target with chainname */
		*hopvalue = l->target.data;
		(*rulenum) = 0;
	} else if (ops == e) {
		(*rulenum)++;

		if (ops->target_offset == sizeof(struct ipt_entry) &&
		    strcmp(l->target.u.kernel.target->name,
			   XT_STANDARD_TARGET) == 0 &&
		   l->verdict < 0 &&
		   unconditional(&ops->ip)) {
			/* Tail of chains: STANDARD target (return/policy) */
			*report = *hopvalue == hopname
				? comments[NF_IP_TRACE_COMMENT_POLICY]
				: comments[NF_IP_TRACE_COMMENT_RETURN];
		}
		return 1;
	} else
		(*rulenum)++;

	return 0;
}",185.0,34.0,"t:l,s:ops,chainname:hopvalue,comment:report,hookname:hopname,",166.0,4.37048269510269,Greedy
657,,,,,,,,0
658,,,,,,,,0
659,"static int ext4_data_block_valid_rcu(struct ext4_sb_info *sbi,
				     struct ext4_system_blocks *system_blks,
				     ext4_fsblk_t start_blk,
				     unsigned int count)
{
	struct ext4_system_zone *entry;
	struct rb_node *n;

	if ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
	    (start_blk + count < start_blk) ||
	    (start_blk + count > ext4_blocks_count(sbi->s_es)))
		return 0;

	if (system_blks == NULL)
		return 1;

	n = system_blks->root.rb_node;
	while (n) {
		entry = rb_entry(n, struct ext4_system_zone, node);
		if (start_blk + count - 1 < entry->start_blk)
			n = n->rb_left;
		else if (start_blk >= (entry->start_blk + entry->count))
			n = n->rb_right;
		else
			return 0;
	}
	return 1;
}","static int ext4_data_block_valid_rcu(struct ext4_sb_info *sbi,
				     struct ext4_system_blocks *system_blks,
				     ext4_fsblk_t start_blk,
				     unsigned int count)
{
	struct ext4_system_zone *feed;
	struct rb_node *nor;

	if ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
	    (start_blk + count < start_blk) ||
	    (start_blk + count > ext4_blocks_count(sbi->s_es)))
		return 0;

	if (system_blks == NULL)
		return 1;

	nor = system_blks->root.rb_node;
	while (nor) {
		feed = rb_entry(nor, struct ext4_system_zone, node);
		if (start_blk + count - 1 < feed->start_blk)
			nor = nor->rb_left;
		else if (start_blk >= (feed->start_blk + feed->count))
			nor = nor->rb_right;
		else
			return 0;
	}
	return 1;
}",153.0,37.0,"n:nor,entry:feed,",94.0,2.51709051926931,Greedy
660,,,,,,,,0
662,"int blkcg_init_queue(struct request_queue *q)
{
	struct blkcg_gq *new_blkg, *blkg;
	bool preloaded;
	int ret;

	new_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);
	if (!new_blkg)
		return -ENOMEM;

	preloaded = !radix_tree_preload(GFP_KERNEL);

	/*
	 * Make sure the root blkg exists and count the existing blkgs.  As
	 * @q is bypassing at this point, blkg_lookup_create() can't be
	 * used.  Open code insertion.
	 */
	rcu_read_lock();
	spin_lock_irq(q->queue_lock);
	blkg = blkg_create(&blkcg_root, q, new_blkg);
	spin_unlock_irq(q->queue_lock);
	rcu_read_unlock();

	if (preloaded)
		radix_tree_preload_end();

	if (IS_ERR(blkg)) {
		blkg_free(new_blkg);
		return PTR_ERR(blkg);
	}

	q->root_blkg = blkg;
	q->root_rl.blkg = blkg;

	ret = blk_throtl_init(q);
	if (ret) {
		spin_lock_irq(q->queue_lock);
		blkg_destroy_all(q);
		spin_unlock_irq(q->queue_lock);
	}
	return ret;
}","int blkcg_init_queue(struct request_queue *q)
{
	struct blkcg_gq *new_flg, *lbug;
	bool ungraded;
	int rep;

	new_flg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);
	if (!new_flg)
		return -ENOMEM;

	ungraded = !radix_tree_preload(GFP_KERNEL);

	/*
	 * Make sure the root blkg exists and count the existing blkgs.  As
	 * @q is bypassing at this point, blkg_lookup_create() can't be
	 * used.  Open code insertion.
	 */
	rcu_read_lock();
	spin_lock_irq(q->queue_lock);
	lbug = blkg_create(&blkcg_root, q, new_flg);
	spin_unlock_irq(q->queue_lock);
	rcu_read_unlock();

	if (ungraded)
		radix_tree_preload_end();

	if (IS_ERR(lbug)) {
		blkg_free(new_flg);
		return PTR_ERR(lbug);
	}

	q->root_blkg = lbug;
	q->root_rl.lbug = lbug;

	rep = blk_throtl_init(q);
	if (rep) {
		spin_lock_irq(q->queue_lock);
		blkg_destroy_all(q);
		spin_unlock_irq(q->queue_lock);
	}
	return rep;
}",164.0,50.0,"blkg:lbug,new_blkg:new_flg,preloaded:ungraded,ret:rep,",151.0,4.06491099198659,Greedy
663,,,,,,,,0
664,,,,,,,,0
665,,,,,,,,0
666,,,,,,,,0
667,"PHP_FUNCTION(oci_lob_load)
{
	zval **tmp, *z_descriptor = getThis();
	php_oci_descriptor *descriptor;
	char *buffer = NULL;
	ub4 buffer_len;

	if (!getThis()) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""O"", &z_descriptor, oci_lob_class_entry_ptr) == FAILURE) {
			return;
		}	
	}
	
	if (zend_hash_find(Z_OBJPROP_P(z_descriptor), ""descriptor"", sizeof(""descriptor""), (void **)&tmp) == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to find descriptor property"");
		RETURN_FALSE;
	}
	
	PHP_OCI_ZVAL_TO_DESCRIPTOR(*tmp, descriptor);

	if (php_oci_lob_read(descriptor, -1, 0, &buffer, &buffer_len TSRMLS_CC)) {
		RETURN_FALSE;
	}
	if (buffer_len > 0) {
		RETURN_STRINGL(buffer, buffer_len, 0);
	}
	else {
		RETURN_EMPTY_STRING();
	}
}","PHP_FUNCTION(oci_lob_load)
{
	zval **tmp, *z_descriptor = getThis();
	php_oci_descriptor *descriptor;
	char *buf = NULL;
	ub4 buffer_len;

	if (!getThis()) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""O"", &z_descriptor, oci_lob_class_entry_ptr) == FAILURE) {
			return;
		}	
	}
	
	if (zend_hash_find(Z_OBJPROP_P(z_descriptor), ""descriptor"", sizeof(""descriptor""), (void **)&tmp) == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to find descriptor property"");
		RETURN_FALSE;
	}
	
	PHP_OCI_ZVAL_TO_DESCRIPTOR(*tmp, descriptor);

	if (php_oci_lob_read(descriptor, -1, 0, &buf, &buffer_len TSRMLS_CC)) {
		RETURN_FALSE;
	}
	if (buffer_len > 0) {
		RETURN_STRINGL(buf, buffer_len, 0);
	}
	else {
		RETURN_EMPTY_STRING();
	}
}",162.0,37.0,"buffer:buf,",47.0,1.19863971074422,Greedy
668,,,,,,,,0
669,,,,,,,,0
670,"static char *ask_new_field(struct chfn_control *ctl, const char *question,
			   char *def_val)
{
	int len;
	char *buf;
#ifndef HAVE_LIBREADLINE
	size_t dummy = 0;
#endif

	if (!def_val)
		def_val = """";
	while (true) {
		printf(""%s [%s]:"", question, def_val);
		__fpurge(stdin);
#ifdef HAVE_LIBREADLINE
		rl_bind_key('\t', rl_insert);
		if ((buf = readline("" "")) == NULL)
#else
		putchar(' ');
		if (getline(&buf, &dummy, stdin) < 0)
#endif
			errx(EXIT_FAILURE, _(""Aborted.""));
		/* remove white spaces from string end */
		ltrim_whitespace((unsigned char *) buf);
		len = rtrim_whitespace((unsigned char *) buf);
		if (len == 0) {
			free(buf);
			return xstrdup(def_val);
		}
		if (!strcasecmp(buf, ""none"")) {
			free(buf);
			ctl->changed = 1;
			return xstrdup("""");
		}
		if (check_gecos_string(question, buf) >= 0)
			break;
	}
	ctl->changed = 1;
	return buf;
}","static char *ask_new_field(struct chfn_control *ctl, const char *question,
			   char *def_val)
{
	int len;
	char *result;
#ifndef HAVE_LIBREADLINE
	size_t dummy = 0;
#endif

	if (!def_val)
		def_val = """";
	while (true) {
		printf(""%s [%s]:"", question, def_val);
		__fpurge(stdin);
#ifdef HAVE_LIBREADLINE
		rl_bind_key('\t', rl_insert);
		if ((result = readline("" "")) == NULL)
#else
		putchar(' ');
		if (getline(&result, &dummy, stdin) < 0)
#endif
			errx(EXIT_FAILURE, _(""Aborted.""));
		/* remove white spaces from string end */
		ltrim_whitespace((unsigned char *) result);
		len = rtrim_whitespace((unsigned char *) result);
		if (len == 0) {
			free(result);
			return xstrdup(def_val);
		}
		if (!strcasecmp(result, ""none"")) {
			free(result);
			ctl->changed = 1;
			return xstrdup("""");
		}
		if (check_gecos_string(question, result) >= 0)
			break;
	}
	ctl->changed = 1;
	return result;
}",221.0,49.0,"buf:result,",55.0,1.35636477470398,Greedy
671,,,,,,,,0
673,,,,,,,,0
674,,,,,,,,0
675,,,,,,,,0
676,"static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
{
    srpsrvparm *p = (srpsrvparm *) arg;
    if (p->login == NULL && p->user == NULL) {
        p->login = SSL_get_srp_username(s);
        BIO_printf(bio_err, ""SRP username = \""%s\""\n"", p->login);
        return (-1);
    }

    if (p->user == NULL) {
        BIO_printf(bio_err, ""User %s doesn't exist\n"", p->login);
        return SSL3_AL_FATAL;
    }
    if (SSL_set_srp_server_param
        (s, p->user->N, p->user->g, p->user->s, p->user->v,
         p->user->info) < 0) {
        *ad = SSL_AD_INTERNAL_ERROR;
        return SSL3_AL_FATAL;
    }
    BIO_printf(bio_err,
               ""SRP parameters set: username = \""%s\"" info=\""%s\"" \n"",
               p->login, p->user->info);
    /* need to check whether there are memory leaks */
    p->user = NULL;
    p->login = NULL;
    return SSL_ERROR_NONE;
}","static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
{
    srpsrvparm *proc = (srpsrvparm *) arg;
    if (proc->login == NULL && proc->user == NULL) {
        proc->login = SSL_get_srp_username(s);
        BIO_printf(bio_err, ""SRP username = \""%s\""\n"", proc->login);
        return (-1);
    }

    if (proc->user == NULL) {
        BIO_printf(bio_err, ""User %s doesn't exist\n"", proc->login);
        return SSL3_AL_FATAL;
    }
    if (SSL_set_srp_server_param
        (s, proc->user->N, proc->user->g, proc->user->s, proc->user->v,
         proc->user->info) < 0) {
        *ad = SSL_AD_INTERNAL_ERROR;
        return SSL3_AL_FATAL;
    }
    BIO_printf(bio_err,
               ""SRP parameters set: username = \""%s\"" info=\""%s\"" \n"",
               proc->login, proc->user->info);
    /* need to check whether there are memory leaks */
    proc->user = NULL;
    proc->login = NULL;
    return SSL_ERROR_NONE;
}",186.0,36.0,"p:proc,",55.0,1.5038858572642,Greedy
677,,,,,,,,0
678,,,,,,,,0
681,,,,,,,,0
682,,,,,,,,0
685,"static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
				   struct pinctrl_dev *pctldev,
				   struct pinctrl_map *map, unsigned num_maps)
{
	int i;
	struct pinctrl_dt_map *dt_map;

	/* Initialize common mapping table entry fields */
	for (i = 0; i < num_maps; i++) {
		map[i].dev_name = dev_name(p->dev);
		map[i].name = statename;
		if (pctldev)
			map[i].ctrl_dev_name = dev_name(pctldev->dev);
	}

	/* Remember the converted mapping table entries */
	dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
	if (!dt_map) {
		dt_free_map(pctldev, map, num_maps);
		return -ENOMEM;
	}

	dt_map->pctldev = pctldev;
	dt_map->map = map;
	dt_map->num_maps = num_maps;
	list_add_tail(&dt_map->node, &p->dt_maps);

	return pinctrl_register_map(map, num_maps, false);
}","static int dt_remember_or_free_map(struct pinctrl *vp, const char *statename,
				   struct pinctrl_dev *pctldeev,
				   struct pinctrl_map *place, unsigned num_maps)
{
	int index;
	struct pinctrl_dt_map *dm_parent;

	/* Initialize common mapping table entry fields */
	for (index = 0; index < num_maps; index++) {
		place[index].dev_name = dev_name(vp->dev);
		place[index].name = statename;
		if (pctldeev)
			place[index].ctrl_dev_name = dev_name(pctldeev->dev);
	}

	/* Remember the converted mapping table entries */
	dm_parent = kzalloc(sizeof(*dm_parent), GFP_KERNEL);
	if (!dm_parent) {
		dt_free_map(pctldeev, place, num_maps);
		return -ENOMEM;
	}

	dm_parent->pctldeev = pctldeev;
	dm_parent->place = place;
	dm_parent->num_maps = num_maps;
	list_add_tail(&dm_parent->node, &vp->dt_maps);

	return pinctrl_register_map(place, num_maps, false);
}",167.0,46.0,"i:index,map:place,p:vp,dt_map:dm_parent,statename:statename,pctldev:pctldeev,",217.0,5.67491776148478,Greedy
686,,,,,,,,0
687,,,,,,,,0
689,,,,,,,,0
690,"inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  if (stream == nullptr)
    stream = session->FindStream(id);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(id, stream->id());
  return stream;
}","inline Http2Stream* GetStream(Http2Session* input,
                              int32_t length,
                              nghttp2_data_source* source) {
  Http2Stream* draft = static_cast<Http2Stream*>(source->ptr);
  if (draft == nullptr)
    draft = input->FindStream(length);
  CHECK_NE(draft, nullptr);
  CHECK_EQ(length, draft->length());
  return draft;
}",69.0,17.0,"stream:draft,id:length,session:input,",105.0,2.48859257300695,Greedy
691,,,,,,,,0
692,,,,,,,,0
694,,,,,,,,0
697,,,,,,,,0
698,,,,,,,,0
699,"static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	load_vmcs12_host_state(vcpu, vmcs12);
	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}","static void nested_vmx_entry_failure(struct kvm_vcpu *cpu,
			struct vmrics52 *vmrics52,
			u32 type, unsigned long quantity)
{
	load_vmcs12_host_state(cpu, vmrics52);
	vmrics52->vm_exit_reason = type | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmrics52->exit_qualification = quantity;
	nested_vmx_succeed(cpu);
	if (enable_shadow_vmcs)
		to_vmx(cpu)->nested.sync_shadow_vmcs = true;
}",64.0,18.0,"vcpu:cpu,qualification:quantity,reason:type,vmcs12:vmrics52,",126.0,3.14784708023071,Greedy
700,"static void php_array_element_export(zval *zv, zend_ulong index, zend_string *key, int level, smart_str *buf) /* {{{ */
{
	if (key == NULL) { /* numeric key */
		buffer_append_spaces(buf, level+1);
		smart_str_append_long(buf, (zend_long) index);
		smart_str_appendl(buf, "" => "", 4);

	} else { /* string key */
		zend_string *tmp_str;
		zend_string *ckey = php_addcslashes(key, 0, ""'\\"", 2);
		tmp_str = php_str_to_str(ZSTR_VAL(ckey), ZSTR_LEN(ckey), ""\0"", 1, ""' . \""\\0\"" . '"", 12);

		buffer_append_spaces(buf, level + 1);

		smart_str_appendc(buf, '\'');
		smart_str_append(buf, tmp_str);
		smart_str_appendl(buf, ""' => "", 5);

		zend_string_free(ckey);
		zend_string_free(tmp_str);
	}
	php_var_export_ex(zv, level + 2, buf);

	smart_str_appendc(buf, ',');
	smart_str_appendc(buf, '\n');
}","static void php_array_element_export(zval *zv, zend_ulong index, zend_string *key, int level, smart_str *bc) /* {{{ */
{
	if (key == NULL) { /* numeric key */
		buffer_append_spaces(bc, level+1);
		smart_str_append_long(bc, (zend_long) index);
		smart_str_appendl(bc, "" => "", 4);

	} else { /* string key */
		zend_string *tmppyStr;
		zend_string *ckey = php_addcslashes(key, 0, ""'\\"", 2);
		tmppyStr = php_str_to_str(ZSTR_VAL(ckey), ZSTR_LEN(ckey), ""\0"", 1, ""' . \""\\0\"" . '"", 12);

		buffer_append_spaces(bc, level + 1);

		smart_str_appendc(bc, '\'');
		smart_str_append(bc, tmppyStr);
		smart_str_appendl(bc, ""' => "", 5);

		zend_string_free(ckey);
		zend_string_free(tmppyStr);
	}
	php_var_export_ex(zv, level + 2, bc);

	smart_str_appendc(bc, ',');
	smart_str_appendc(bc, '\n');
}",187.0,47.0,"buf:bc,tmp_str:tmppyStr,",91.0,2.26288193066915,Greedy
701,,,,,,,,0
702,"gboolean
mono_verifier_verify_class (MonoClass *class)
{
	/*Neither <Module>, object or ifaces have parent.*/
	if (!class->parent &&
		class != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/
		return FALSE;
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;","gboolean
mono_verifier_verify_class (MonoClass *call)
{
	/*Neither <Module>, object or ifaces have parent.*/
	if (!call->parent &&
		call != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (call) &&
		(!call->image->dynamic && call->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/
		return FALSE;
	if (call->parent) {
		if (MONO_CLASS_IS_INTERFACE (call->parent))
			return FALSE;
		if (!call->generic_class && call->parent->generic_container)
			return FALSE;
	}
	if (call->generic_container && (call->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (call->generic_container && !verify_generic_parameters (call))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (call))
		return FALSE;
	if (call->generic_class && !mono_class_is_valid_generic_instantiation (NULL, call))
		return FALSE;
	if (call->generic_class == NULL && !verify_class_fields (call))
		return FALSE;
	if (call->valuetype && !verify_valuetype_layout (call))
		return FALSE;
	if (!verify_interfaces (call))
		return FALSE;
	return TRUE;",193.0,34.0,"class:call,",53.0,1.55631317297618,Greedy
703,,,,,,,,0
704,,,,,,,,0
705,,,,,,,,0
706,,,,,,,,0
707,,,,,,,,0
708,,,,,,,,0
709,,,,,,,,0
710,,,,,,,,0
712,,,,,,,,0
713,,,,,,,,0
714,,,,,,,,0
715,"void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {
	bin->header_offset = r_buf_read_le16_at (buf, 0x3c);
	bin->ne_header = R_NEW0 (NE_image_header);
	if (!bin->ne_header) {
		return;
	}
	bin->buf = buf;
	r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));
	bin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;
	if (!bin->alignment) {
		bin->alignment = 1 << 9;
	}
	bin->os = __get_target_os (bin);

	ut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;
	ut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);
	bin->segment_entries = calloc (1, size);
	if (!bin->segment_entries) {
		return;
	}
	r_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);
	bin->entry_table = calloc (1, bin->ne_header->EntryTableLength);
	r_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);
	bin->imports = r_bin_ne_get_imports (bin);
	__ne_get_resources (bin);
}","void __init(RBuffer *buf, r_bin_ne_obj_t *obin) {
	obin->header_offset = r_buf_read_le16_at (buf, 0x3c);
	obin->ne_header = R_NEW0 (NE_image_header);
	if (!obin->ne_header) {
		return;
	}
	obin->buf = buf;
	r_buf_read_at (buf, obin->header_offset, (ut8 *)obin->ne_header, sizeof (NE_image_header));
	obin->alignment = 1 << obin->ne_header->FileAlnSzShftCnt;
	if (!obin->alignment) {
		obin->alignment = 1 << 9;
	}
	obin->os = __get_target_os (obin);

	ut16 offset = obin->ne_header->SegTableOffset + obin->header_offset;
	ut16 size = obin->ne_header->SegCount * sizeof (NE_image_segment_entry);
	obin->segment_entries = calloc (1, size);
	if (!obin->segment_entries) {
		return;
	}
	r_buf_read_at (buf, offset, (ut8 *)obin->segment_entries, size);
	obin->entry_table = calloc (1, obin->ne_header->EntryTableLength);
	r_buf_read_at (buf, (ut64)obin->header_offset + obin->ne_header->EntryTableOffset, obin->entry_table, obin->ne_header->EntryTableLength);
	obin->imports = r_bin_ne_get_imports (obin);
	__ne_get_resources (obin);
}",233.0,53.0,"bin:obin,",66.0,1.95956059296926,Greedy
716,,,,,,,,0
719,,,,,,,,0
720,,,,,,,,0
722,,,,,,,,0
723,,,,,,,,0
724,,,,,,,,0
725,,,,,,,,0
726,,,,,,,,0
730,,,,,,,,0
732,,,,,,,,0
733,,,,,,,,0
734,,,,,,,,0
735,,,,,,,,0
736,,,,,,,,0
737,,,,,,,,0
740,,,,,,,,0
741,,,,,,,,0
744,,,,,,,,0
745,"static void add_metadata(RCore *r, RBinReloc *reloc, ut64 addr, int mode) {
	RBinFile * binfile = r->bin->cur;
	RBinObject *binobj = binfile ? binfile->o: NULL;
	RBinInfo *info = binobj ? binobj->info: NULL;

	int cdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;
	if (cdsz == 0) {
		return;
	}

	RIOMap *map = r_io_map_get (r->io, addr);
	if (!map || map ->perm & R_PERM_X) {
		return;
	}
	if (IS_MODE_SET (mode)) {
		r_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr + cdsz, NULL);
	} else if (IS_MODE_RAD (mode)) {
		r_cons_printf (""Cd %d @ 0x%08"" PFMT64x ""\n"", cdsz, addr);
	}
}","static void add_metadata(RCore *rar, RBinReloc *RELog, ut64 off, int mode) {
	RBinFile *  binobject = rar->bin->cur;
	RBinObject *binobj =  binobject ?  binobject->o: NULL;
	RBinInfo *afi = binobj ? binobj->afi: NULL;

	int cdsz = afi? (afi->bits == 64? 8: afi->bits == 32? 4: afi->bits == 16 ? 4: 0): 0;
	if (cdsz == 0) {
		return;
	}

	RIOMap *map = r_io_map_get (rar->io, off);
	if (!map || map ->perm & R_PERM_X) {
		return;
	}
	if (IS_MODE_SET (mode)) {
		r_meta_add (rar->anal, R_META_TYPE_DATA, RELog->vaddr, RELog->vaddr + cdsz, NULL);
	} else if (IS_MODE_RAD (mode)) {
		r_cons_printf (""Cd %d @ 0x%08"" PFMT64x ""\n"", cdsz, off);
	}
}",181.0,40.0,"info:afi,reloc:RELog,r:rar,binfile: binobject,addr:off,",175.0,4.39560233354569,Greedy
746,,,,,,,,0
747,,,,,,,,0
748,,,,,,,,0
749,,,,,,,,0
751,"static void ext4_clear_inode(struct inode *inode)
{
	ext4_discard_preallocations(inode);
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,
				       &EXT4_I(inode)->jinode);
}","static void ext4_clear_inode(struct winode *winode)
{
	ext4_discard_preallocations(winode);
	if (EXT4_JOURNAL(winode))
		jbd2_journal_release_jbd_inode(EXT4_SB(winode->i_sb)->s_journal,
				       &EXT4_I(winode)->jinode);
}",43.0,11.0,"inode:winode,",37.0,1.05794501701991,Greedy
752,,,,,,,,0
753,"const char* RtmpProtocol::handle_C2(const char *data, size_t len) {
    if (len < C1_HANDSHARK_SIZE) {
        //need more data!
        return nullptr;
    }
    _next_step_func = [this](const char *data, size_t len) {
        return handle_rtmp(data, len);
    };

    //握手结束，进入命令模式
    return handle_rtmp(data + C1_HANDSHARK_SIZE, len - C1_HANDSHARK_SIZE);
}","const char* RtmpProtocol::handle_C2(const char *offset, size_t len) {
    if (len < C1_HANDSHARK_SIZE) {
        //need more data!
        return nullptr;
    }
    _next_step_func = [this](const char *offset, size_t len) {
        return handle_rtmp(offset, len);
    };

    //握手结束，进入命令模式
    return handle_rtmp(offset + C1_HANDSHARK_SIZE, len - C1_HANDSHARK_SIZE);
}",65.0,16.0,"data:offset,",40.0,1.25546044111252,Greedy
754,"static struct dentry *proc_mount(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data)
{
	int err;
	struct super_block *sb;
	struct pid_namespace *ns;
	char *options;

	if (flags & MS_KERNMOUNT) {
		ns = (struct pid_namespace *)data;
		options = NULL;
	} else {
		ns = task_active_pid_ns(current);
		options = data;

		/* Does the mounter have privilege over the pid namespace? */
		if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))
			return ERR_PTR(-EPERM);
	}

	sb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);
	if (IS_ERR(sb))
		return ERR_CAST(sb);

	if (!proc_parse_options(options, ns)) {
		deactivate_locked_super(sb);
		return ERR_PTR(-EINVAL);
	}

	if (!sb->s_root) {
		err = proc_fill_super(sb);
		if (err) {
			deactivate_locked_super(sb);
			return ERR_PTR(err);
		}

		sb->s_flags |= MS_ACTIVE;
		/* User space would break if executables appear on proc */
		sb->s_iflags |= SB_I_NOEXEC;
	}

	return dget(sb->s_root);
}","static struct dentry *proc_mount(struct file_system_type *fs_type,
	int flags, const char *dev_number, void *data)
{
	int err;
	struct super_block *sb;
	struct pid_namespace *ns;
	char *opt;

	if (flags & MS_KERNMOUNT) {
		ns = (struct pid_namespace *)data;
		opt = NULL;
	} else {
		ns = task_active_pid_ns(current);
		opt = data;

		/* Does the mounter have privilege over the pid namespace? */
		if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))
			return ERR_PTR(-EPERM);
	}

	sb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);
	if (IS_ERR(sb))
		return ERR_CAST(sb);

	if (!proc_parse_options(opt, ns)) {
		deactivate_locked_super(sb);
		return ERR_PTR(-EINVAL);
	}

	if (!sb->s_root) {
		err = proc_fill_super(sb);
		if (err) {
			deactivate_locked_super(sb);
			return ERR_PTR(err);
		}

		sb->s_flags |= MS_ACTIVE;
		/* User space would break if executables appear on proc */
		sb->s_iflags |= SB_I_NOEXEC;
	}

	return dget(sb->s_root);
}",201.0,57.0,"dev_name:dev_number,options:opt,",80.0,2.2432427684466,Greedy
756,,,,,,,,0
757,,,,,,,,0
759,,,,,,,,0
760,,,,,,,,0
761,,,,,,,,0
762,,,,,,,,0
764,,,,,,,,0
765,,,,,,,,0
767,,,,,,,,0
768,"void AbstractSqlStorage::addConnectionToPool()
{
    QMutexLocker locker(&_connectionPoolMutex);
    // we have to recheck if the connection pool already contains a connection for
    // this thread. Since now (after the lock) we can only tell for sure
    if (_connectionPool.contains(QThread::currentThread()))
        return;

    QThread *currentThread = QThread::currentThread();

    int connectionId = _nextConnectionId++;

    Connection *connection = new Connection(QLatin1String(QString(""quassel_%1_con_%2"").arg(driverName()).arg(connectionId).toLatin1()));
    connection->moveToThread(currentThread);
    connect(this, SIGNAL(destroyed()), connection, SLOT(deleteLater()));
    connect(currentThread, SIGNAL(destroyed()), connection, SLOT(deleteLater()));
    connect(connection, SIGNAL(destroyed()), this, SLOT(connectionDestroyed()));
    _connectionPool[currentThread] = connection;

    QSqlDatabase db = QSqlDatabase::addDatabase(driverName(), connection->name());
    db.setDatabaseName(databaseName());

    if (!hostName().isEmpty())
        db.setHostName(hostName());

    if (port() != -1)
        db.setPort(port());

    if (!userName().isEmpty()) {
        db.setUserName(userName());
        db.setPassword(password());
    }

    if (!db.open()) {
        qWarning() << ""Unable to open database"" << displayName() << ""for thread"" << QThread::currentThread();
        qWarning() << ""-"" << db.lastError().text();
    }
    else {
        initDbSession(db);
    }
}","void AbstractSqlStorage::addConnectionToPool()
{
    QMutexLocker locker(&_connectionPoolMutex);
    // we have to recheck if the connection pool already contains a connection for
    // this thread. Since now (after the lock) we can only tell for sure
    if (_connectionPool.contains(QThread::currentThread()))
        return;

    QThread *currentThread = QThread::currentThread();

    int connectionId = _lastConnectionIndex++;

    Connection *connection = new Connection(QLatin1String(QString(""quassel_%1_con_%2"").arg(driverName()).arg(connectionId).toLatin1()));
    connection->moveToThread(currentThread);
    connect(this, SIGNAL(destroyed()), connection, SLOT(deleteLater()));
    connect(currentThread, SIGNAL(destroyed()), connection, SLOT(deleteLater()));
    connect(connection, SIGNAL(destroyed()), this, SLOT(connectionDestroyed()));
    _connectionPool[currentThread] = connection;

    QSqlDatabase db = QSqlDatabase::addDatabase(driverName(), connection->name());
    db.setDatabaseName(databaseName());

    if (!hostName().isEmpty())
        db.setHostName(hostName());

    if (port() != -1)
        db.setPort(port());

    if (!userName().isEmpty()) {
        db.setUserName(userName());
        db.setPassword(password());
    }

    if (!db.open()) {
        qWarning() << ""Unable to open database"" << displayName() << ""for thread"" << QThread::currentThread();
        qWarning() << ""-"" << db.lastError().text();
    }
    else {
        initDbSession(db);
    }
}",307.0,63.0,"_nextConnectionId:_lastConnectionIndex,",39.0,5.97906825145086,Greedy
770,,,,,,,,0
771,"char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
{
	char *dst;

	if (!value.length)
		return NULL;

	/* allocate destination string, it will be at most 3 times the source */
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
		return NULL;
	}

	ldb_dn_escape_internal(dst, (const char *)value.data, value.length);

	dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);

	return dst;
}","char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
{
	char * dsc;

	if (!value.length)
		return NULL;

	/* allocate destination string, it will be at most 3 times the source */
	 dsc = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( !  dsc) {
		talloc_free( dsc);
		return NULL;
	}

	ldb_dn_escape_internal( dsc, (const char *)value.data, value.length);

	 dsc = talloc_realloc(mem_ctx,  dsc, char, strlen( dsc) + 1);

	return  dsc;
}",99.0,25.0,"dst: dsc,",48.0,1.52292660872142,Greedy
773,,,,,,,,0
774,,,,,,,,0
775,,,,,,,,0
776,"static void rq_attach_root(struct rq *rq, struct root_domain *rd)
{
	struct root_domain *old_rd = NULL;
	unsigned long flags;

	raw_spin_lock_irqsave(&rq->lock, flags);

	if (rq->rd) {
		old_rd = rq->rd;

		if (cpumask_test_cpu(rq->cpu, old_rd->online))
			set_rq_offline(rq);

		cpumask_clear_cpu(rq->cpu, old_rd->span);

		/*
		 * If we dont want to free the old_rd yet then
		 * set old_rd to NULL to skip the freeing later
		 * in this function:
		 */
		if (!atomic_dec_and_test(&old_rd->refcount))
			old_rd = NULL;
	}

	atomic_inc(&rd->refcount);
	rq->rd = rd;

	cpumask_set_cpu(rq->cpu, rd->span);
	if (cpumask_test_cpu(rq->cpu, cpu_active_mask))
		set_rq_online(rq);

	raw_spin_unlock_irqrestore(&rq->lock, flags);

	if (old_rd)
		call_rcu_sched(&old_rd->rcu, free_rootdomain);
}","static void rq_attach_root(struct rq *rq, struct root_domain *rd)
{
	struct root_domain *new_rost = NULL;
	unsigned long flags;

	raw_spin_lock_irqsave(&rq->lock, flags);

	if (rq->rd) {
		new_rost = rq->rd;

		if (cpumask_test_cpu(rq->cpu, new_rost->online))
			set_rq_offline(rq);

		cpumask_clear_cpu(rq->cpu, new_rost->span);

		/*
		 * If we dont want to free the old_rd yet then
		 * set old_rd to NULL to skip the freeing later
		 * in this function:
		 */
		if (!atomic_dec_and_test(&new_rost->refcount))
			new_rost = NULL;
	}

	atomic_inc(&rd->refcount);
	rq->rd = rd;

	cpumask_set_cpu(rq->cpu, rd->span);
	if (cpumask_test_cpu(rq->cpu, cpu_active_mask))
		set_rq_online(rq);

	raw_spin_unlock_irqrestore(&rq->lock, flags);

	if (new_rost)
		call_rcu_sched(&new_rost->rcu, free_rootdomain);
}",160.0,41.0,"old_rd:new_rost,",62.0,1.72187730868657,Greedy
778,,,,,,,,0
781,,,,,,,,0
782,"void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;

	device_links_write_lock();

	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;

		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);

		/*
		 * autoremove the links between this @dev and its consumer
		 * devices that are not active, i.e. where the link state
		 * has moved to DL_STATE_SUPPLIER_UNBIND.
		 */
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);

		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}

	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);

	device_links_write_unlock();
}","void device_links_driver_cleanup(struct device *dem)
{
	struct device_link *style, *n;

	device_links_write_lock();

	list_for_each_entry_safe(style, n, &dem->links.consumers, s_node) {
		if (!(style->flags & DL_FLAG_MANAGED))
			continue;

		WARN_ON(style->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(style->status != DL_STATE_SUPPLIER_UNBIND);

		/*
		 * autoremove the links between this @dev and its consumer
		 * devices that are not active, i.e. where the link state
		 * has moved to DL_STATE_SUPPLIER_UNBIND.
		 */
		if (style->status == DL_STATE_SUPPLIER_UNBIND &&
		    style->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(style);

		WRITE_ONCE(style->status, DL_STATE_DORMANT);
	}

	list_del_init(&dem->links.defer_hook);
	__device_links_no_driver(dem);

	device_links_write_unlock();
}",118.0,32.0,"link:style,dev:dem,ln:n,",106.0,2.79130179087321,Greedy
783,"g_vfs_daemon_finalize (GObject *object)
{
  GVfsDaemon *daemon;

  daemon = G_VFS_DAEMON (object);

  /* There may be some jobs outstanding if we've been force unmounted. */
  if (daemon->jobs)
    g_warning (""daemon->jobs != NULL when finalizing daemon!"");

  if (daemon->name_watcher)
    g_bus_unwatch_name (daemon->name_watcher);
  
  if (daemon->daemon_skeleton != NULL)
    {
      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->daemon_skeleton));
      g_object_unref (daemon->daemon_skeleton);
    }
  if (daemon->mountable_skeleton != NULL)
    {
      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->mountable_skeleton));
      g_object_unref (daemon->mountable_skeleton);
    }
  if (daemon->conn != NULL)
    g_object_unref (daemon->conn);
  
  g_hash_table_destroy (daemon->registered_paths);
  g_hash_table_destroy (daemon->client_connections);
  g_mutex_clear (&daemon->lock);

  if (G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize) (object);
}","g_vfs_daemon_finalize (GObject *object)
{
  GVfsDaemon *Daisy;

  Daisy = G_VFS_DAEMON (object);

  /* There may be some jobs outstanding if we've been force unmounted. */
  if (Daisy->jobs)
    g_warning (""daemon->jobs != NULL when finalizing daemon!"");

  if (Daisy->name_watcher)
    g_bus_unwatch_name (Daisy->name_watcher);
  
  if (Daisy->daemon_skeleton != NULL)
    {
      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (Daisy->daemon_skeleton));
      g_object_unref (Daisy->daemon_skeleton);
    }
  if (Daisy->mountable_skeleton != NULL)
    {
      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (Daisy->mountable_skeleton));
      g_object_unref (Daisy->mountable_skeleton);
    }
  if (Daisy->conn != NULL)
    g_object_unref (Daisy->conn);
  
  g_hash_table_destroy (Daisy->registered_paths);
  g_hash_table_destroy (Daisy->client_connections);
  g_mutex_clear (&Daisy->lock);

  if (G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize) (object);
}",157.0,37.0,"daemon:Daisy,",47.0,1.35421821673711,Greedy
785,,,,,,,,0
786,,,,,,,,0
787,,,,,,,,0
788,,,,,,,,0
789,,,,,,,,0
790,,,,,,,,0
792,,,,,,,,0
793,,,,,,,,0
794,,,,,,,,0
796,,,,,,,,0
797,"static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;

	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));

	border = 2 << sb->s_blocksize_bits;

	while (len > 0) {
		/* find how many blocks can be covered since this position */
		max = ffs(first | border) - 1;

		/* find how many blocks of power 2 we need to mark */
		min = fls(len) - 1;

		if (max < min)
			min = max;
		chunk = 1 << min;

		/* mark multiblock chunks only */
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);

		len -= chunk;
		first += chunk;
	}
}","static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *Grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;

	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));

	border = 2 << sb->s_blocksize_bits;

	while (len > 0) {
		/* find how many blocks can be covered since this position */
		max = ffs(first | border) - 1;

		/* find how many blocks of power 2 we need to mark */
		min = fls(len) - 1;

		if (max < min)
			min = max;
		chunk = 1 << min;

		/* mark multiblock chunks only */
		Grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);

		len -= chunk;
		first += chunk;
	}
}",149.0,46.0,"grp:Grp,",69.0,2.0656685590744,Greedy
798,,,,,,,,0
799,,,,,,,,0
800,,,,,,,,0
801,,,,,,,,0
804,,,,,,,,0
805,"int ssl3_send_alert(SSL *s, int level, int desc)
{
    /* Map tls/ssl alert value to correct one */
    desc = s->method->ssl3_enc->alert_value(desc);
    if (s->version == SSL3_VERSION && desc == SSL_AD_PROTOCOL_VERSION)
        desc = SSL_AD_HANDSHAKE_FAILURE; /* SSL 3.0 does not have
                                          * protocol_version alerts */
    if (desc < 0)
        return -1;
    /* If a fatal one, remove from cache */
    if ((level == 2) && (s->session != NULL))
        SSL_CTX_remove_session(s->session_ctx, s->session);

    s->s3->alert_dispatch = 1;
    s->s3->send_alert[0] = level;
    s->s3->send_alert[1] = desc;
    if (s->s3->wbuf.left == 0)  /* data still being written out? */
        return s->method->ssl_dispatch_alert(s);
    /*
     * else data is still being written out, we will get written some time in
     * the future
     */
    return -1;
}","int ssl3_send_alert(SSL *s, int level, int  description)
{
    /* Map tls/ssl alert value to correct one */
     description = s->method->ssl3_enc->alert_value( description);
    if (s->version == SSL3_VERSION &&  description == SSL_AD_PROTOCOL_VERSION)
         description = SSL_AD_HANDSHAKE_FAILURE; /* SSL 3.0 does not have
                                          * protocol_version alerts */
    if ( description < 0)
        return -1;
    /* If a fatal one, remove from cache */
    if ((level == 2) && (s->session != NULL))
        SSL_CTX_remove_session(s->session_ctx, s->session);

    s->s3->alert_dispatch = 1;
    s->s3->send_alert[0] = level;
    s->s3->send_alert[1] =  description;
    if (s->s3->wbuf.left == 0)  /* data still being written out? */
        return s->method->ssl_dispatch_alert(s);
    /*
     * else data is still being written out, we will get written some time in
     * the future
     */
    return -1;
}",135.0,27.0,"desc: description,",53.0,1.05330253044764,Greedy
806,"static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}","static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *address)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), address->m_pblk,
				   address->m_len)) {
		ext4_error_inode(inode, func, line, address->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) address->m_lblk,
				 address->m_pblk, address->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}",121.0,25.0,"map:address,",49.0,0.935051143169403,Greedy
807,,,,,,,,0
808,,,,,,,,0
809,,,,,,,,0
810,,,,,,,,0
812,"static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;

	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;

	switch (ioc.cmd) {
	case SKFP_GET_STATS:	/* Get the driver statistics */
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	/* Zero out the driver statistics */
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x\n"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;

	}			// switch

	return status;
}				// skfp_ioctl","static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl inioci;
	int status = 0;

	if (copy_from_user(&inioci, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;

	switch (inioci.cmd) {
	case SKFP_GET_STATS:	/* Get the driver statistics */
		inioci.len = sizeof(lp->MacStat);
		status = copy_to_user(inioci.data, skfp_ctl_get_stats(dev), inioci.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	/* Zero out the driver statistics */
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x\n"", dev->name, inioci.cmd);
		status = -EOPNOTSUPP;

	}			// switch

	return status;
}				// skfp_ioctl",181.0,40.0,"ioc:inioci,",53.0,1.07625959714254,Greedy
813,,,,,,,,0
814,,,,,,,,0
818,,,,,,,,0
820,,,,,,,,0
821,,,,,,,,0
822,,,,,,,,0
823,,,,,,,,0
825,,,,,,,,0
826,"static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;

	/*
	 * We set the bdi here to the queue backing, file systems can
	 * overwrite this in ->fill_super()
	 */
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}","static int set_bdev_super(struct super_block *members, void *data)
{
	members->s_bdev = data;
	members->s_dev = members->s_bdev->bd_dev;

	/*
	 * We set the bdi here to the queue backing, file systems can
	 * overwrite this in ->fill_super()
	 */
	members->s_bdi = &bdev_get_queue(members->s_bdev)->backing_dev_info;
	return 0;
}",48.0,10.0,"s:members,",39.0,0.699359504381816,Greedy
827,,,,,,,,0
830,,,,,,,,0
831,"static int coroutine_fn v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)
{
    int err;
    V9fsState *s = pdu->s;
    V9fsFidState *fidp, head_fid;

    head_fid.next = s->fid_list;
    for (fidp = s->fid_list; fidp; fidp = fidp->next) {
        if (fidp->path.size != path->size) {
            continue;
        }
        if (!memcmp(fidp->path.data, path->data, path->size)) {
            /* Mark the fid non reclaimable. */
            fidp->flags |= FID_NON_RECLAIMABLE;

            /* reopen the file/dir if already closed */
            err = v9fs_reopen_fid(pdu, fidp);
            if (err < 0) {
                return err;
            }
            /*
             * Go back to head of fid list because
             * the list could have got updated when
             * switched to the worker thread
             */
            if (err == 0) {
                fidp = &head_fid;
            }
        }
    }
    return 0;
}","static int coroutine_fn v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)
{
    int err;
    V9fsState *s = pdu->s;
    V9fsFidState *fidp, head_cip;

    head_cip.next = s->fid_list;
    for (fidp = s->fid_list; fidp; fidp = fidp->next) {
        if (fidp->path.size != path->size) {
            continue;
        }
        if (!memcmp(fidp->path.data, path->data, path->size)) {
            /* Mark the fid non reclaimable. */
            fidp->flags |= FID_NON_RECLAIMABLE;

            /* reopen the file/dir if already closed */
            err = v9fs_reopen_fid(pdu, fidp);
            if (err < 0) {
                return err;
            }
            /*
             * Go back to head of fid list because
             * the list could have got updated when
             * switched to the worker thread
             */
            if (err == 0) {
                fidp = &head_cip;
            }
        }
    }
    return 0;
}",139.0,33.0,"head_fid:head_cip,",62.0,1.25353928407033,Greedy
833,,,,,,,,0
834,,,,,,,,0
835,,,,,,,,0
836,,,,,,,,0
837,"static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,
			   unsigned long size)
{
	gfn_t end_gfn;
	pfn_t pfn;

	pfn     = gfn_to_pfn_memslot(slot, gfn);
	end_gfn = gfn + (size >> PAGE_SHIFT);
	gfn    += 1;

	if (is_error_noslot_pfn(pfn))
		return pfn;

	while (gfn < end_gfn)
		gfn_to_pfn_memslot(slot, gfn++);

	return pfn;
}","static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfunction,
			   unsigned long size)
{
	gfn_t end_gfn;
	pfn_t pfn;

	pfn     = gfn_to_pfn_memslot(slot, gfunction);
	end_gfn = gfunction + (size >> PAGE_SHIFT);
	gfunction    += 1;

	if (is_error_noslot_pfn(pfn))
		return pfn;

	while (gfunction < end_gfn)
		gfn_to_pfn_memslot(slot, gfunction++);

	return pfn;
}",74.0,24.0,"gfn:gfunction,",50.0,0.949755529562632,Greedy
839,,,,,,,,0
840,"static int alarm_timer_nsleep(const clockid_t which_clock, int flags,
			      const struct timespec64 *tsreq)
{
	enum  alarmtimer_type type = clock2alarm(which_clock);
	struct restart_block *restart = &current->restart_block;
	struct alarm alarm;
	ktime_t exp;
	int ret = 0;

	if (!alarmtimer_get_rtcdev())
		return -ENOTSUPP;

	if (flags & ~TIMER_ABSTIME)
		return -EINVAL;

	if (!capable(CAP_WAKE_ALARM))
		return -EPERM;

	alarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);

	exp = timespec64_to_ktime(*tsreq);
	/* Convert (if necessary) to absolute time */
	if (flags != TIMER_ABSTIME) {
		ktime_t now = alarm_bases[type].gettime();
		exp = ktime_add(now, exp);
	}

	ret = alarmtimer_do_nsleep(&alarm, exp, type);
	if (ret != -ERESTART_RESTARTBLOCK)
		return ret;

	/* abs timers don't set remaining time or restart */
	if (flags == TIMER_ABSTIME)
		return -ERESTARTNOHAND;

	restart->fn = alarm_timer_nsleep_restart;
	restart->nanosleep.clockid = type;
	restart->nanosleep.expires = exp;
	return ret;
}","static int alarm_timer_nsleep(const clockid_t which_clock, int bugs,
			      const struct timespec64 *tsreq)
{
	enum  alarmtimer_type type = clock2alarm(which_clock);
	struct restart_block *restart = &current->restart_block;
	struct alarm alarm;
	ktime_t exp;
	int ret = 0;

	if (!alarmtimer_get_rtcdev())
		return -ENOTSUPP;

	if (bugs & ~TIMER_ABSTIME)
		return -EINVAL;

	if (!capable(CAP_WAKE_ALARM))
		return -EPERM;

	alarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);

	exp = timespec64_to_ktime(*tsreq);
	/* Convert (if necessary) to absolute time */
	if (bugs != TIMER_ABSTIME) {
		ktime_t now = alarm_bases[type].gettime();
		exp = ktime_add(now, exp);
	}

	ret = alarmtimer_do_nsleep(&alarm, exp, type);
	if (ret != -ERESTART_RESTARTBLOCK)
		return ret;

	/* abs timers don't set remaining time or restart */
	if (bugs == TIMER_ABSTIME)
		return -ERESTARTNOHAND;

	restart->fn = alarm_timer_nsleep_restart;
	restart->nanosleep.clockid = type;
	restart->nanosleep.expires = exp;
	return ret;
}",188.0,54.0,"flags:bugs,",47.0,0.887073334058126,Greedy
841,,,,,,,,0
842,,,,,,,,0
843,,,,,,,,0
845,,,,,,,,0
846,,,,,,,,0
847,,,,,,,,0
848,,,,,,,,0
849,"ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len) /* {{{ */
{
	zend_trait_alias *alias, **alias_ptr;

	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}

	return name;
}","ZEND_API const char* zend_find_alias_name(zend_class_entry *coe, const char *call, zend_uint len) /* {{{ */
{
	zend_trait_alias *master, **alias_tmp;

	if ((alias_tmp = coe->trait_aliases)) {
		master = *alias_tmp;
		while (master) {
			if (master->alias_len == len &&
				!strncasecmp(call, master->master, master->alias_len)) {
				return master->master;
			}
			alias_tmp++;
			master = *alias_tmp;
		}
	}

	return call;
}",91.0,23.0,"alias:master,name:call,alias_ptr:alias_tmp,ce:coe,",143.0,2.6478346546491,Greedy
850,,,,,,,,0
851,,,,,,,,0
855,,,,,,,,0
856,,,,,,,,0
857,,,,,,,,0
860,,,,,,,,0
861,,,,,,,,0
862,,,,,,,,0
863,,,,,,,,0
864,,,,,,,,0
865,,,,,,,,0
866,"int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                /* Fts3 table handle */
  sqlite3_stmt **ppStmt           /* OUT: Statement handle */
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}","int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                /* Fts3 table handle */
  sqlite3_stmt **ppPtr           /* OUT: Statement handle */
){
  sqlite3_stmt *pSTmm = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pSTmm, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pSTmm, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pSTmm)!=SQLITE_ROW
     || sqlite3_column_type(pSTmm, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pSTmm);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pSTmm = 0;
    }
  }
  *ppPtr = pSTmm;
  return rc;
}",103.0,32.0,"ppStmt:ppPtr,pStmt:pSTmm,",80.0,1.58801117340724,Greedy
867,,,,,,,,0
868,,,,,,,,0
869,,,,,,,,0
870,,,,,,,,0
873,,,,,,,,0
874,,,,,,,,0
875,,,,,,,,0
876,,,,,,,,0
877,,,,,,,,0
878,,,,,,,,0
879,,,,,,,,0
880,,,,,,,,0
883,,,,,,,,0
887,,,,,,,,0
891,,,,,,,,0
893,,,,,,,,0
894,,,,,,,,0
895,,,,,,,,0
896,"inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)
{
	rr->type = (QueryType)((input[0] << 8) + input[1]);
	rr->rr_class = (input[2] << 8) + input[3];
	rr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];
	rr->rdlength = (input[8] << 8) + input[9];
}","inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *PUT)
{
	rr->type = (QueryType)((PUT[0] << 8) + PUT[1]);
	rr->rr_class = (PUT[2] << 8) + PUT[3];
	rr->ttl = (PUT[4] << 24) + (PUT[5] << 16) + (PUT[6] << 8) + PUT[7];
	rr->rdlength = (PUT[8] << 8) + PUT[9];
}",113.0,18.0,"input:PUT,",47.0,1.0067923506101,Greedy
898,,,,,,,,0
899,,,,,,,,0
901,,,,,,,,0
903,,,,,,,,0
905,,,,,,,,0
907,,,,,,,,0
908,,,,,,,,0
909,"bool Crypto::get_random_values(JSContext *cx, unsigned argc, JS::Value *vp) {
  JS::CallArgs args = CallArgsFromVp(argc, vp);
  if (!args.requireAtLeast(cx, ""crypto.getRandomValues"", 1))
    return false;

  if (!args[0].isObject() || !is_int_typed_array(&args[0].toObject())) {
    JS_ReportErrorUTF8(cx, ""crypto.getRandomValues: input must be an integer-typed TypedArray"");
    return false;
  }

  JS::RootedObject typed_array(cx, &args[0].toObject());
  size_t byte_length = JS_GetArrayBufferViewByteLength(typed_array);
  if (byte_length > MAX_BYTE_LENGTH) {
    JS_ReportErrorUTF8(cx,
                       ""crypto.getRandomValues: input byteLength must be at most %u, ""
                       ""but is %zu"",
                       MAX_BYTE_LENGTH, byte_length);
    return false;
  }

  JS::AutoCheckCannotGC noGC(cx);
  bool is_shared;
  void *buffer = JS_GetArrayBufferViewData(typed_array, &is_shared, noGC);
  arc4random_buf(buffer, byte_length);

  args.rval().setObject(*typed_array);
  return true;
}","bool Crypto::get_random_values(JSContext *cx, unsigned paramc, JS::Value *vc) {
  JS::CallArgs args = CallArgsFromVp(paramc, vc);
  if (!args.requireAtLeast(cx, ""crypto.getRandomValues"", 1))
    return false;

  if (!args[0].isObject() || !is_int_typed_array(&args[0].toObject())) {
    JS_ReportErrorUTF8(cx, ""crypto.getRandomValues: input must be an integer-typed TypedArray"");
    return false;
  }

  JS::RootedObject typed_array(cx, &args[0].toObject());
  size_t byte_length = JS_GetArrayBufferViewByteLength(typed_array);
  if (byte_length > MAX_BYTE_LENGTH) {
    JS_ReportErrorUTF8(cx,
                       ""crypto.getRandomValues: input byteLength must be at most %u, ""
                       ""but is %zu"",
                       MAX_BYTE_LENGTH, byte_length);
    return false;
  }

  JS::AutoCheckCannotGC noGC(cx);
  bool  is_ared;
  void *texture = JS_GetArrayBufferViewData(typed_array, & is_ared, noGC);
  arc4random_buf(texture, byte_length);

  args.rval().setObject(*typed_array);
  return true;
}",187.0,39.0,"buffer:texture,is_shared: is_ared,argc:paramc,vp:vc,",111.0,2.47830749352773,Greedy
910,,,,,,,,0
911,,,,,,,,0
916,,,,,,,,0
917,"static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;

	return vhost_chr_write_iter(dev, from);
}","static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct ile *ile = iocb->ki_filp;
	struct vhost_net *n = ile->private_data;
	struct vhost_dev *sk = &n->sk;

	return vhost_chr_write_iter(sk, from);
}",52.0,12.0,"file:ile,dev:sk,",73.0,1.26890147129695,Greedy
919,,,,,,,,0
920,,,,,,,,0
922,,,,,,,,0
924,,,,,,,,0
928,,,,,,,,0
930,,,,,,,,0
932,,,,,,,,0
933,,,,,,,,0
935,,,,,,,,0
936,,,,,,,,0
939,,,,,,,,0
940,,,,,,,,0
941,,,,,,,,0
943,"WriterProxyData(
            size_t max_unicast_locators,
            size_t max_multicast_locators,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locators, max_multicast_locators)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
    }","WriterProxyData(
            size_t max_unicast_locators,
            size_t max_multicast_collumbers,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locators, max_multicast_collumbers)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
    }",82.0,11.0,"max_multicast_locators:max_multicast_collumbers,",22.0,0.476407198111216,Greedy
944,,,,,,,,0
947,,,,,,,,0
948,,,,,,,,0
951,,,,,,,,0
953,,,,,,,,0
954,,,,,,,,0
957,,,,,,,,0
958,,,,,,,,0
959,,,,,,,,0
962,,,,,,,,0
963,,,,,,,,0
964,,,,,,,,0
965,,,,,,,,0
966,,,,,,,,0
968,,,,,,,,0
970,,,,,,,,0
971,,,,,,,,0
972,,,,,,,,0
973,,,,,,,,0
974,"static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;

	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;

	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
		return -ENOMEM;
	spin_lock_init(&tu->qlock);
	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
	tu->ticks = 1;
	tu->queue_size = 128;
	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	file->private_data = tu;
	return 0;
}","static int snd_timer_user_open(struct innode *innode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;

	err = nonseekable_open(innode, file);
	if (err < 0)
		return err;

	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
		return -ENOMEM;
	spin_lock_init(&tu->qlock);
	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
	tu->ticks = 1;
	tu->queue_size = 128;
	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	file->private_data = tu;
	return 0;
}",148.0,35.0,"inode:innode,",56.0,1.05626422166824,Greedy
975,"static void read_file_into_memory(
    char const* filename,
    PointerHolder<char>& file_buf, size_t& size)
{
    FILE* f = QUtil::safe_fopen(filename, ""rb"");
    fseek(f, 0, SEEK_END);
    size = QUtil::tell(f);
    fseek(f, 0, SEEK_SET);
    file_buf = PointerHolder<char>(true, new char[size]);
    char* buf_p = file_buf.getPointer();
    size_t bytes_read = 0;
    size_t len = 0;
    while ((len = fread(buf_p + bytes_read, 1, size - bytes_read, f)) > 0)
    {
        bytes_read += len;
    }
    if (bytes_read != size)
    {
        if (ferror(f))
        {
            throw std::runtime_error(
                std::string(""failure reading file "") + filename +
                "" into memory: read "" +
                QUtil::uint_to_string(bytes_read) + ""; wanted "" +
                QUtil::uint_to_string(size));
        }
        else
        {
            throw std::logic_error(
                std::string(""premature eof reading file "") + filename +
                "" into memory: read "" +
                QUtil::uint_to_string(bytes_read) + ""; wanted "" +
                QUtil::uint_to_string(size));
        }
    }
    fclose(f);
}","static void read_file_into_memory(
    char const* filename,
    PointerHolder<char>&  file___box, size_t& size)
{
    FILE* f = QUtil::safe_fopen(filename, ""rb"");
    fseek(f, 0, SEEK_END);
    size = QUtil::tell(f);
    fseek(f, 0, SEEK_SET);
     file___box = PointerHolder<char>(true, new char[size]);
    char* buf_p =  file___box.getPointer();
    size_t bytes_read = 0;
    size_t len = 0;
    while ((len = fread(buf_p + bytes_read, 1, size - bytes_read, f)) > 0)
    {
        bytes_read += len;
    }
    if (bytes_read != size)
    {
        if (ferror(f))
        {
            throw std::runtime_error(
                std::string(""failure reading file "") + filename +
                "" into memory: read "" +
                QUtil::uint_to_string(bytes_read) + ""; wanted "" +
                QUtil::uint_to_string(size));
        }
        else
        {
            throw std::logic_error(
                std::string(""premature eof reading file "") + filename +
                "" into memory: read "" +
                QUtil::uint_to_string(bytes_read) + ""; wanted "" +
                QUtil::uint_to_string(size));
        }
    }
    fclose(f);
}",225.0,70.0,"file_buf: file___box,",48.0,0.946661388874054,Greedy
976,,,,,,,,0
977,,,,,,,,0
978,,,,,,,,0
980,,,,,,,,0
981,"static u32 esp4_get_mtu(struct xfrm_state *x, int mtu)
{
	struct esp_data *esp = x->data;
	u32 blksize = ALIGN(crypto_aead_blocksize(esp->aead), 4);
	u32 align = max_t(u32, blksize, esp->padlen);
	u32 rem;

	mtu -= x->props.header_len + crypto_aead_authsize(esp->aead);
	rem = mtu & (align - 1);
	mtu &= ~(align - 1);

	switch (x->props.mode) {
	case XFRM_MODE_TUNNEL:
		break;
	default:
	case XFRM_MODE_TRANSPORT:
		/* The worst case */
		mtu -= blksize - 4;
		mtu += min_t(u32, blksize - 4, rem);
		break;
	case XFRM_MODE_BEET:
		/* The worst case. */
		mtu += min_t(u32, IPV4_BEET_PHMAXLEN, rem);
		break;
	}

	return mtu - 2;
}","static u32 esp4_get_mtu(struct xfrm_state *X, int mtu)
{
	struct esp_data *esp = X->data;
	u32 blksize = ALIGN(crypto_aead_blocksize(esp->aead), 4);
	u32 align = max_t(u32, blksize, esp->padlen);
	u32 rem;

	mtu -= X->props.header_len + crypto_aead_authsize(esp->aead);
	rem = mtu & (align - 1);
	mtu &= ~(align - 1);

	switch (X->props.mode) {
	case XFRM_MODE_TUNNEL:
		break;
	default:
	case XFRM_MODE_TRANSPORT:
		/* The worst case */
		mtu -= blksize - 4;
		mtu += min_t(u32, blksize - 4, rem);
		break;
	case XFRM_MODE_BEET:
		/* The worst case. */
		mtu += min_t(u32, IPV4_BEET_PHMAXLEN, rem);
		break;
	}

	return mtu - 2;
}",151.0,41.0,"x:X,",51.0,0.948172823588053,Greedy
983,,,,,,,,0
984,,,,,,,,0
985,,,,,,,,0
986,,,,,,,,0
987,,,,,,,,0
988,,,,,,,,0
990,,,,,,,,0
991,"static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
		struct msghdr *msg, size_t len, int noblock, int flags,
		int *addr_len)
{
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;
	struct sockaddr_ieee802154 *saddr;

	saddr = (struct sockaddr_ieee802154 *)msg->msg_name;

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	/* FIXME: skip headers if necessary ?! */
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_ts_and_drops(msg, sk, skb);

	if (saddr) {
		saddr->family = AF_IEEE802154;
		saddr->addr = mac_cb(skb)->sa;
	}
	if (addr_len)
		*addr_len = sizeof(*saddr);

	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	if (err)
		return err;
	return copied;
}","static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
		struct msghdr *msg, size_t len, int noblock, int flags,
		int *addr_len)
{
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *SKl;
	struct sockaddr_ieee802154 *saddr;

	saddr = (struct sockaddr_ieee802154 *)msg->msg_name;

	SKl = skb_recv_datagram(sk, flags, noblock, &err);
	if (!SKl)
		goto out;

	copied = SKl->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	/* FIXME: skip headers if necessary ?! */
	err = skb_copy_datagram_iovec(SKl, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_ts_and_drops(msg, sk, SKl);

	if (saddr) {
		saddr->family = AF_IEEE802154;
		saddr->addr = mac_cb(SKl)->sa;
	}
	if (addr_len)
		*addr_len = sizeof(*saddr);

	if (flags & MSG_TRUNC)
		copied = SKl->len;
done:
	skb_free_datagram(sk, SKl);
out:
	if (err)
		return err;
	return copied;
}",212.0,59.0,"skb:SKl,",69.0,1.36848049958547,Greedy
997,"static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)
{
	ext4_fsblk_t block = ext4_ext_pblock(ext);
	int len = ext4_ext_get_actual_len(ext);
	ext4_lblk_t lblock = le32_to_cpu(ext->ee_block);

	/*
	 * We allow neither:
	 *  - zero length
	 *  - overflow/wrap-around
	 */
	if (lblock + len <= lblock)
		return 0;
	return ext4_data_block_valid(EXT4_SB(inode->i_sb), block, len);
}","static int ext4_valid_extent(struct iniride *iniride, struct ext4_extent *EXT)
{
	ext4_fsblk_t block = ext4_ext_pblock(EXT);
	int len = ext4_ext_get_actual_len(EXT);
	ext4_lblk_t lblock = le32_to_cpu(EXT->ee_block);

	/*
	 * We allow neither:
	 *  - zero length
	 *  - overflow/wrap-around
	 */
	if (lblock + len <= lblock)
		return 0;
	return ext4_data_block_valid(EXT4_SB(iniride->i_sb), block, len);
}",68.0,20.0,"ext:EXT,inode:iniride,",68.0,1.16051070690155,Greedy
998,,,,,,,,0
999,,,,,,,,0
1001,"int main(int argc, char* argv[])
{
    whoami = QUtil::getWhoami(argv[0]);

    // For libtool's sake....
    if (strncmp(whoami, ""lt-"", 3) == 0)
    {
	whoami += 3;
    }

    if (argc != 3)
    {
	usage();
    }
    char const* filename = argv[1];
    int pageno = QUtil::string_to_int(argv[2]);

    try
    {
	QPDF pdf;
	pdf.processFile(filename);
        std::vector<QPDFPageObjectHelper> pages =
            QPDFPageDocumentHelper(pdf).getAllPages();
        if ((pageno < 1) || (static_cast<size_t>(pageno) > pages.size()))
        {
            usage();
        }

        QPDFPageObjectHelper& page = pages.at(pageno-1);
        ParserCallbacks cb;
        page.parsePageContents(&cb);
    }
    catch (std::exception& e)
    {
	std::cerr << whoami << "": "" << e.what() << std::endl;
	exit(2);
    }

    return 0;
}","int main(int argcount, char* argv[])
{
    whoami = QUtil::getWhoami(argv[0]);

    // For libtool's sake....
    if (strncmp(whoami, ""lt-"", 3) == 0)
    {
	whoami += 3;
    }

    if (argcount != 3)
    {
	usage();
    }
    char const* il = argv[1];
    int pageno = QUtil::string_to_int(argv[2]);

    try
    {
	QPDF PDF;
	PDF.processFile(il);
        std::vector<QPDFPageObjectHelper> pages =
            QPDFPageDocumentHelper(PDF).getAllPages();
        if ((pageno < 1) || (static_cast<size_t>(pageno) > pages.size()))
        {
            usage();
        }

        QPDFPageObjectHelper& page = pages.at(pageno-1);
        ParserCallbacks cgi;
        page.parsePageContents(&cgi);
    }
    catch (std::exception& e)
    {
	std::cerr << whoami << "": "" << e.what() << std::endl;
	exit(2);
    }

    return 0;
}",202.0,39.0,"cb:cgi,pdf:PDF,filename:il,argc:argcount,",126.0,2.16362172762553,Greedy
1002,"Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {
    const Tensor first_partition_tensor =
        context->input(kFirstPartitionInputIndex);
    const RowPartitionType first_partition_type = row_partition_types_[0];
    switch (first_partition_type) {
      case RowPartitionType::FIRST_DIM_SIZE:
        *result = first_partition_tensor.scalar<INDEX_TYPE>()();
        return Status::OK();
      case RowPartitionType::VALUE_ROWIDS:
        return errors::InvalidArgument(
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = first_partition_tensor.shape().dim_size(0) - 1;
        return Status::OK();
      default:
        return errors::InvalidArgument(
            ""Cannot handle type "",
            RowPartitionTypeToString(first_partition_type));
    }
  }","Status GetFirstDimensionSize(OpKernelContext* resource, INDEX_TYPE* result) {
    const Tensor first_partition_tensor =
        resource->input(kFirstPartitionInputIndex);
    const RowPartitionType first_partition_type = row_partition_types_[0];
    switch (first_partition_type) {
      case RowPartitionType::FIRST_DIM_SIZE:
        *result = first_partition_tensor.scalar<INDEX_TYPE>()();
        return Status::OK();
      case RowPartitionType::VALUE_ROWIDS:
        return errors::InvalidArgument(
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = first_partition_tensor.shape().dim_size(0) - 1;
        return Status::OK();
      default:
        return errors::InvalidArgument(
            ""Cannot handle type "",
            RowPartitionTypeToString(first_partition_type));
    }
  }",123.0,22.0,"context:resource,",36.0,0.761686849594116,Greedy
1003,,,,,,,,0
1004,,,,,,,,0
1006,,,,,,,,0
1007,,,,,,,,0
1010,"int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;

	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}","int emulator_write_phys(struct kvm_vcpu *lcpu, gpa_t gpa,
			  const void *b, int bytes)
{
	int ret;

	ret = kvm_write_guest(lcpu->kvm, gpa, b, bytes);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(lcpu, gpa, b, bytes, 1);
	return 1;
}",64.0,18.0,"val:b,ret:ret,vcpu:lcpu,",101.0,1.7449312766393,Greedy
1011,,,,,,,,0
1013,"TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
{
        static const char module[] = ""TIFFWriteDirectoryTagCheckedRational"";
	uint32 m[2];
	assert(sizeof(uint32)==4);
        if( value < 0 )
        {
            TIFFErrorExt(tif->tif_clientdata,module,""Negative value is illegal"");
            return 0;
        }
	else if (value==0.0)
	{
		m[0]=0;
		m[1]=1;
	}
	else if (value==(double)(uint32)value)
	{
		m[0]=(uint32)value;
		m[1]=1;
	}
	else if (value<1.0)
	{
		m[0]=(uint32)(value*0xFFFFFFFF);
		m[1]=0xFFFFFFFF;
	}
	else
	{
		m[0]=0xFFFFFFFF;
		m[1]=(uint32)(0xFFFFFFFF/value);
	}
	if (tif->tif_flags&TIFF_SWAB)
	{
		TIFFSwabLong(&m[0]);
		TIFFSwabLong(&m[1]);
	}
	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&m[0]));
}","TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
{
        static const char mac[] = ""TIFFWriteDirectoryTagCheckedRational"";
	uint32 media[2];
	assert(sizeof(uint32)==4);
        if( value < 0 )
        {
            TIFFErrorExt(tif->tif_clientdata,mac,""Negative value is illegal"");
            return 0;
        }
	else if (value==0.0)
	{
		media[0]=0;
		media[1]=1;
	}
	else if (value==(double)(uint32)value)
	{
		media[0]=(uint32)value;
		media[1]=1;
	}
	else if (value<1.0)
	{
		media[0]=(uint32)(value*0xFFFFFFFF);
		media[1]=0xFFFFFFFF;
	}
	else
	{
		media[0]=0xFFFFFFFF;
		media[1]=(uint32)(0xFFFFFFFF/value);
	}
	if (tif->tif_flags&TIFF_SWAB)
	{
		TIFFSwabLong(&media[0]);
		TIFFSwabLong(&media[1]);
	}
	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&media[0]));
}",234.0,44.0,"module:mac,m:media,",75.0,1.45458606878916,Greedy
1019,,,,,,,,0
1020,,,,,,,,0
1021,"int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else { // overlap
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return nn;
}","int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, bn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	left = 0; right = bns->n_holes; bn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else { // overlap
			if (pos_f >= bns->ambs[mid].offset) {
				bn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				bn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return bn;
}",243.0,66.0,"mid:mid,bns:bns,len:len,nn:bn,",180.0,3.50444507201513,Greedy
1023,,,,,,,,0
1027,,,,,,,,0
1029,,,,,,,,0
1030,,,,,,,,0
1033,,,,,,,,0
1035,,,,,,,,0
1036,,,,,,,,0
1037,,,,,,,,0
1039,,,,,,,,0
1042,"inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int diff_min, uint8* output_data,
                    const RuntimeShape& output_shape) {
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  params.input_left_shift = input_beta_left_shift;
  params.diff_min = diff_min;
  Softmax(params, input_shape, input_data, output_shape, output_data);
}","inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_leftoffoffset,
                    int diff_min, uint8*  output_images,
                    const RuntimeShape& Output_capacity) {
  SoftmaxParams Parameters;
  Parameters.input_multiplier = input_beta_multiplier;
  Parameters.input_left_shift = input_beta_leftoffoffset;
  Parameters.diff_min = diff_min;
  Softmax(Parameters, input_shape, input_data, Output_capacity,  output_images);
}",68.0,21.0,"params:Parameters,input_beta_left_shift:input_beta_leftoffoffset,output_shape:Output_capacity,output_data: output_images,",89.0,1.89348839521408,Greedy
1043,,,,,,,,0
1044,,,,,,,,0
1045,,,,,,,,0
1046,,,,,,,,0
1048,,,,,,,,0
1050,,,,,,,,0
1051,,,,,,,,0
1052,,,,,,,,0
1054,"static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;

	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	}

	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}","static void cleanup_queue(struct avdtp *lock, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;

	while ((l = g_slist_find_custom(lock->prio_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		lock->prio_queue = g_slist_remove(lock->prio_queue, req);
	}

	while ((l = g_slist_find_custom(lock->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		lock->req_queue = g_slist_remove(lock->req_queue, req);
	}
}",111.0,31.0,"session:lock,",53.0,1.09915726184845,Greedy
1055,,,,,,,,0
1056,,,,,,,,0
1058,,,,,,,,0
1060,,,,,,,,0
1062,,,,,,,,0
1063,,,,,,,,0
1064,,,,,,,,0
1068,,,,,,,,0
1069,,,,,,,,0
1070,,,,,,,,0
1072,,,,,,,,0
1073,,,,,,,,0
1074,,,,,,,,0
1075,,,,,,,,0
1076,,,,,,,,0
1077,,,,,,,,0
1079,,,,,,,,0
1081,,,,,,,,0
1082,,,,,,,,0
1084,"static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (window <= num_preferred_base++)
		return;

	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;

	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}

	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;

	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}","static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *op;
	void *DATA;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (window <= num_preferred_base++)
		return;

	DATA = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!DATA)
		return;

	for (op = pbase_tree; op; op = op->next) {
		if (!hashcmp(op->pcache.sha1, tree_sha1)) {
			free(DATA);
			return;
		}
	}

	op = xcalloc(1, sizeof(*op));
	op->next = pbase_tree;
	pbase_tree = op;

	hashcpy(op->pcache.sha1, tree_sha1);
	op->pcache.tree_data = DATA;
	op->pcache.tree_size = size;
}",150.0,39.0,"it:op,data:DATA,",91.0,1.88456775347392,Greedy
1086,,,,,,,,0
1088,,,,,,,,0
1089,,,,,,,,0
1090,,,,,,,,0
1092,,,,,,,,0
1093,,,,,,,,0
1094,,,,,,,,0
1096,"static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,
                                      X509_ALGOR **pmaskHash)
{
    const unsigned char *p;
    int plen;
    RSA_PSS_PARAMS *pss;

    *pmaskHash = NULL;

    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)
        return NULL;
    p = alg->parameter->value.sequence->data;
    plen = alg->parameter->value.sequence->length;
    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);

    if (!pss)
        return NULL;

    if (pss->maskGenAlgorithm) {
        ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;
        if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1
            && param->type == V_ASN1_SEQUENCE) {
            p = param->value.sequence->data;
            plen = param->value.sequence->length;
            *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);
        }
    }

    return pss;
}","static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,
                                      X509_ALGOR **pmaskHash)
{
    const unsigned char *p;
    int plen;
    RSA_PSS_PARAMS *pss;

    *pmaskHash = NULL;

    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)
        return NULL;
    p = alg->parameter->value.sequence->data;
    plen = alg->parameter->value.sequence->length;
    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);

    if (!pss)
        return NULL;

    if (pss->maskGenAlgorithm) {
        ASN1_TYPE *item = pss->maskGenAlgorithm->parameter;
        if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1
            && item->type == V_ASN1_SEQUENCE) {
            p = item->value.sequence->data;
            plen = item->value.sequence->length;
            *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);
        }
    }

    return pss;
}",172.0,36.0,"param:item,",60.0,1.24377272129059,Greedy
1099,,,,,,,,0
1100,"static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;

	sigandsets(&m, mask, &s->signal);
	if (sigisemptyset(&m))
		return;

	sigandnsets(&s->signal, &s->signal, mask);
	list_for_each_entry_safe(q, n, &s->list, list) {
		if (sigismember(mask, q->info.si_signo)) {
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	}
}","static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *sl)
{
	struct sigqueue *q, *n;
	sigset_t m;

	sigandsets(&m, mask, &sl->signal);
	if (sigisemptyset(&m))
		return;

	sigandnsets(&sl->signal, &sl->signal, mask);
	list_for_each_entry_safe(q, n, &sl->list, list) {
		if (sigismember(mask, q->info.si_signo)) {
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	}
}",108.0,28.0,"s:sl,",50.0,0.996636152267456,Greedy
1101,"check_user_string(optstr)
char *optstr;
{
    struct passwd *pw;
    int pwlen;
    char *eop, *w;
    char *pwname = 0;

    if (optstr[0] == '*')
        return TRUE; /* allow any user */
    if (sysopt.check_plname)
        pwname = plname;
    else if ((pw = get_unix_pw()) != 0)
        pwname = pw->pw_name;
    if (!pwname || !*pwname)
        return FALSE;
    pwlen = (int) strlen(pwname);
    eop = eos(optstr);
    w = optstr;
    while (w + pwlen <= eop) {
        if (!*w)
            break;
        if (isspace(*w)) {
            w++;
            continue;
        }
        if (!strncmp(w, pwname, pwlen)) {
            if (!w[pwlen] || isspace(w[pwlen]))
                return TRUE;
        }
        while (*w && !isspace(*w))
            w++;
    }
    return FALSE;
}","check_user_string(propstr)
char *propstr;
{
    struct passwd *tpwd;
    int pwdl;
    char *Eip, *y;
    char *pwnname = 0;

    if (propstr[0] == '*')
        return TRUE; /* allow any user */
    if (sysopt.check_plname)
        pwnname = plname;
    else if ((tpwd = get_unix_pw()) != 0)
        pwnname = tpwd->pw_name;
    if (!pwnname || !*pwnname)
        return FALSE;
    pwdl = (int) strlen(pwnname);
    Eip = eos(propstr);
    y = propstr;
    while (y + pwdl <= Eip) {
        if (!*y)
            break;
        if (isspace(*y)) {
            y++;
            continue;
        }
        if (!strncmp(y, pwnname, pwdl)) {
            if (!y[pwdl] || isspace(y[pwdl]))
                return TRUE;
        }
        while (*y && !isspace(*y))
            y++;
    }
    return FALSE;
}",190.0,46.0,"optstr:propstr,eop:Eip,w:y,pwlen:pwdl,pw:tpwd,pwname:pwnname,",213.0,4.01212329864502,Greedy
1102,,,,,,,,0
1103,"static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 j, tmp;

	*iret = 0;

	for (i = 0, j = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}

	for (i = 0, j = 0; i < testn; i++) {
		ret |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			return ret;

		j += inc;
	}

	*iret = 1;
	return ret;
}","static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 si, tmp;

	*iret = 0;

	for (i = 0, si = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + si, si);
		si += inc;
	}

	for (i = 0, si = 0; i < testn; i++) {
		ret |= READL(sisusb->vrambase + si, &tmp);
		if (tmp != si)
			return ret;

		si += inc;
	}

	*iret = 1;
	return ret;
}",128.0,39.0,"j:si,",62.0,1.29260034958522,Greedy
1105,"rb_push_glob(VALUE str, int flags) /* '\0' is delimiter */
{
    long offset = 0;
    VALUE ary;

    GlobPathValue(str, TRUE);
    ary = rb_ary_new();

    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }

    return ary;
}","rb_push_glob(VALUE str, int flags) /* '\0' is delimiter */
{
    long offset = 0;
    VALUE ary;

    GlobPathValue(str, TRUE);
    ary = rb_ary_new();

    while (offset < RSTRING_LEN(str)) {
	char *pat, *pend;
	int status;
	pat = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(pat, strlen(pat), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	pat += strlen(pat) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (pat < pend && !*pat)
	    pat++;
	offset = pat - RSTRING_PTR(str);
    }

    return ary;
}",151.0,52.0,"p:pat,",52.0,1.1530730287234,Greedy
1106,,,,,,,,0
1107,,,,,,,,0
1108,,,,,,,,0
1109,,,,,,,,0
1110,,,,,,,,0
1111,,,,,,,,0
1114,,,,,,,,0
1115,,,,,,,,0
1116,,,,,,,,0
1117,,,,,,,,0
1118,,,,,,,,0
1119,,,,,,,,0
1122,,,,,,,,0
1123,,,,,,,,0
1125,,,,,,,,0
1127,,,,,,,,0
1129,,,,,,,,0
1131,,,,,,,,0
1132,,,,,,,,0
1136,,,,,,,,0
1140,,,,,,,,0
1143,,,,,,,,0
1144,"static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;

	if (!is_sampling_event(event))
		return;

	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hwc->hrtimer.function = perf_swevent_hrtimer;

	/*
	 * Since hrtimers have a fixed rate, we can do a static freq->period
	 * mapping and avoid the whole period adjust feedback stuff.
	 */
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;

		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}","static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hawl = &event->hw;

	if (!is_sampling_event(event))
		return;

	hrtimer_init(&hawl->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hawl->hrtimer.function = perf_swevent_hrtimer;

	/*
	 * Since hrtimers have a fixed rate, we can do a static freq->period
	 * mapping and avoid the whole period adjust feedback stuff.
	 */
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;

		event->attr.sample_period = NSEC_PER_SEC / freq;
		hawl->sample_period = event->attr.sample_period;
		local64_set(&hawl->period_left, hawl->sample_period);
		hawl->last_period = hawl->sample_period;
		event->attr.freq = 0;
	}
}",118.0,26.0,"hwc:hawl,",47.0,0.87873717546463,Greedy
1146,"static int usb_disable_remote_wakeup(struct usb_device *udev)
{
	if (udev->speed < USB_SPEED_SUPER)
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
	else
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}","static int usb_disable_remote_wakeup(struct usb_device *uidem)
{
	if (uidem->speed < USB_SPEED_SUPER)
		return usb_control_msg(uidem, usb_sndctrlpipe(uidem, 0),
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
	else
		return usb_control_msg(uidem, usb_sndctrlpipe(uidem, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}",74.0,20.0,"udev:uidem,",37.0,0.773277310530345,Greedy
1147,,,,,,,,0
1150,,,,,,,,0
1151,,,,,,,,0
1153,"void CLASS foveon_dp_load_raw()
{
  unsigned c, roff[4], row, col, diff;
  ushort huff[258], vpred[2][2], hpred[2];

  fseek (ifp, 8, SEEK_CUR);
  foveon_huff (huff);
  roff[0] = 48;
  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);
  FORC3 {
    fseek (ifp, data_offset+roff[c], SEEK_SET);
    getbits(-1);
    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;
    for (row=0; row < height; row++) {
      for (col=0; col < width; col++) {
       diff = ljpeg_diff(huff);
       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
       else hpred[col & 1] += diff;
       image[row*width+col][c] = hpred[col & 1];
      }
    }
  }
}","void CLASS foveon_dp_load_raw()
{
  unsigned c, stroff[4], Row, col, message;
  ushort huff[258], vpred[2][2], hpred[2];

  fseek (ifp, 8, SEEK_CUR);
  foveon_huff (huff);
  stroff[0] = 48;
  FORC3 stroff[c+1] = -(-(stroff[c] + get4()) & -16);
  FORC3 {
    fseek (ifp, data_offset+stroff[c], SEEK_SET);
    getbits(-1);
    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;
    for (Row=0; Row < height; Row++) {
      for (col=0; col < width; col++) {
       message = ljpeg_diff(huff);
       if (col < 2) hpred[col] = vpred[Row & 1][col] += message;
       else hpred[col & 1] += message;
       image[Row*width+col][c] = hpred[col & 1];
      }
    }
  }
}",232.0,60.0,"roff:stroff,diff:message,row:Row,",134.0,3.13212719360987,Greedy
1155,,,,,,,,0
1159,,,,,,,,0
1161,"static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	int ret;

	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};

	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;

	perf_event_header__init_id(&throttle_event.header, &sample, event);

	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;

	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}","static void perf_log_throttle(struct perf_event *response, int enable)
{
	struct perf_output_handle side;
	struct perf_sample_data sample;
	int ret;

	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(response),
		.stream_id	= response->id,
	};

	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;

	perf_event_header__init_id(&throttle_event.header, &sample, response);

	ret = perf_output_begin(&side, response,
				throttle_event.header.size);
	if (ret)
		return;

	perf_output_put(&side, throttle_event);
	perf_event__output_id_sample(response, &side, &sample);
	perf_output_end(&side);
}",164.0,35.0,"event:response,handle:side,",80.0,1.47058785756429,Greedy
1162,,,,,,,,0
1163,,,,,,,,0
1164,,,,,,,,0
1165,,,,,,,,0
1168,,,,,,,,0
1169,,,,,,,,0
1170,,,,,,,,0
1171,,,,,,,,0
1172,,,,,,,,0
1173,,,,,,,,0
1176,,,,,,,,0
1178,,,,,,,,0
1181,,,,,,,,0
1182,,,,,,,,0
1185,,,,,,,,0
1188,,,,,,,,0
1189,,,,,,,,0
1190,,,,,,,,0
1191,"SPL_METHOD(SplDoublyLinkedList, current)
{
	spl_dllist_object     *intern  = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	spl_ptr_llist_element *element = intern->traverse_pointer;

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (element == NULL || element->data == NULL) {
		RETURN_NULL();
	} else {
		zval *data    = (zval *)element->data;
		RETURN_ZVAL(data, 1, 0);
	}
}","SPL_METHOD(SplDoublyLinkedList, current)
{
	spl_dllist_object     *export  = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	spl_ptr_llist_element *input = export->traverse_pointer;

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (input == NULL || input->Data == NULL) {
		RETURN_NULL();
	} else {
		zval *Data    = (zval *)input->Data;
		RETURN_ZVAL(Data, 1, 0);
	}
}",86.0,18.0,"element:input,data:Data,intern:export,",101.0,1.72192791700363,Greedy
1193,,,,,,,,0
1195,"static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}","static void fix_pmode_seg(struct kvm_vcpu *Vcpu, int  Sega,
		struct kvm_segment *escape)
{
	if (!emulate_invalid_guest_state) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if ( Sega == VCPU_SREG_CS ||  Sega == VCPU_SREG_SS)
			escape->selector &= ~SELECTOR_RPL_MASK;
		escape->dpl = escape->selector & SELECTOR_RPL_MASK;
		escape->s = 1;
	}
	vmx_set_segment(Vcpu, escape,  Sega);
}",68.0,19.0,"save:escape,seg: Sega,vcpu:Vcpu,",101.0,1.83412793874741,Greedy
1199,,,,,,,,0
1202,"static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	u32 imask;

	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		/* Clear IEVENT, so interrupts aren't called again
		 * because of the packets that have already arrived.
		 */
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
	}

	return IRQ_HANDLED;
}","static irqreturn_t gfar_transmit(int  irp, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long linux;
	u32 imask;

	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, linux);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, linux);
		__napi_schedule(&grp->napi_tx);
	} else {
		/* Clear IEVENT, so interrupts aren't called again
		 * because of the packets that have already arrived.
		 */
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
	}

	return IRQ_HANDLED;
}",121.0,30.0,"irq: irp,flags:linux,",65.0,1.21345198949178,Greedy
1203,,,,,,,,0
1204,,,,,,,,0
1206,,,,,,,,0
1208,,,,,,,,0
1211,"void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;

	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}","void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *ka,
			 struct hsr_port *port)
{
	struct hsr_node *node_nsts;

	if (!skb_mac_header_was_set(ka)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(ka)->h_dest))
		return;

	node_nsts = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(ka)->h_dest);
	if (!node_nsts) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_nsts->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(ka)->h_dest, node_nsts->MacAddressB);
}",128.0,26.0,"skb:ka,node_dst:node_nsts,",75.0,1.57433348496755,Greedy
1213,,,,,,,,0
1217,,,,,,,,0
1219,,,,,,,,0
1220,,,,,,,,0
1221,"static int get_string_opt(const char *s, unsigned len, const char *opt,
			  char **val)
{
	int i;
	unsigned opt_len = strlen(opt);
	char *d;

	if (*val)
		free(*val);
	*val = (char *) malloc(len - opt_len + 1);
	if (!*val) {
		fprintf(stderr, ""%s: failed to allocate memory\n"", progname);
		return 0;
	}

	d = *val;
	s += opt_len;
	len -= opt_len;
	for (i = 0; i < len; i++) {
		if (s[i] == '\\' && i + 1 < len)
			i++;
		*d++ = s[i];
	}
	*d = '\0';
	return 1;
}","static int get_string_opt(const char *ss, unsigned al, const char *err,
			  char **slot)
{
	int i;
	unsigned opt_len = strlen(err);
	char *j;

	if (*slot)
		free(*slot);
	*slot = (char *) malloc(al - opt_len + 1);
	if (!*slot) {
		fprintf(stderr, ""%s: failed to allocate memory\n"", progname);
		return 0;
	}

	j = *slot;
	ss += opt_len;
	al -= opt_len;
	for (i = 0; i < al; i++) {
		if (ss[i] == '\\' && i + 1 < al)
			i++;
		*j++ = ss[i];
	}
	*j = '\0';
	return 1;
}",155.0,40.0,"opt:err,val:slot,d:j,s:ss,len:al,",180.0,3.16827025810878,Greedy
1223,,,,,,,,0
1224,,,,,,,,0
1226,,,,,,,,0
1228,,,,,,,,0
1229,,,,,,,,0
1230,,,,,,,,0
1232,,,,,,,,0
1233,,,,,,,,0
1235,,,,,,,,0
1236,,,,,,,,0
1237,,,,,,,,0
1238,,,,,,,,0
1239,,,,,,,,0
1240,"static void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,
			    struct wait_queue_head *head,
			    struct io_poll_iocb **poll_ptr)
{
	struct io_kiocb *req = pt->req;

	/*
	 * If poll->head is already set, it's because the file being polled
	 * uses multiple waitqueues for poll handling (eg one for read, one
	 * for write). Setup a separate io_poll_iocb if this happens.
	 */
	if (unlikely(poll->head)) {
		struct io_poll_iocb *poll_one = poll;

		/* already have a 2nd entry, fail a third attempt */
		if (*poll_ptr) {
			pt->error = -EINVAL;
			return;
		}
		poll = kmalloc(sizeof(*poll), GFP_ATOMIC);
		if (!poll) {
			pt->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(poll, poll_one->events, io_poll_double_wake);
		refcount_inc(&req->refs);
		poll->wait.private = req;
		*poll_ptr = poll;
	}

	pt->error = 0;
	poll->head = head;

	if (poll->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(head, &poll->wait);
	else
		add_wait_queue(head, &poll->wait);","static void __io_queue_proc(struct io_poll_iocb *run, struct io_poll_table *ft,
			    struct wait_queue_head *head,
			    struct io_poll_iocb ** poll_ref)
{
	struct io_kiocb *req = ft->req;

	/*
	 * If poll->head is already set, it's because the file being polled
	 * uses multiple waitqueues for poll handling (eg one for read, one
	 * for write). Setup a separate io_poll_iocb if this happens.
	 */
	if (unlikely(run->head)) {
		struct io_poll_iocb * poll_1 = run;

		/* already have a 2nd entry, fail a third attempt */
		if (* poll_ref) {
			ft->error = -EINVAL;
			return;
		}
		run = kmalloc(sizeof(*run), GFP_ATOMIC);
		if (!run) {
			ft->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(run,  poll_1->events, io_poll_double_wake);
		refcount_inc(&req->refs);
		run->wait.private = req;
		* poll_ref = run;
	}

	ft->error = 0;
	run->head = head;

	if (run->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(head, &run->wait);
	else
		add_wait_queue(head, &run->wait);",172.0,42.0,"pt:ft,poll:run,poll_one: poll_1,poll_ptr: poll_ref,",116.0,2.08529402812322,Greedy
1241,,,,,,,,0
1243,,,,,,,,0
1246,,,,,,,,0
1247,,,,,,,,0
1249,,,,,,,,0
1250,,,,,,,,0
1251,,,,,,,,0
1253,,,,,,,,0
1259,,,,,,,,0
1260,"static void php_do_pcre_match(INTERNAL_FUNCTION_PARAMETERS, int global) /* {{{ */
{
	/* parameters */
	char			 *regex;			/* Regular expression */
	char			 *subject;			/* String to match against */
	int				  regex_len;
	int				  subject_len;
	pcre_cache_entry *pce;				/* Compiled regular expression */
	zval			 *subpats = NULL;	/* Array for subpatterns */
	long			  flags = 0;		/* Match control flags */
	long			  start_offset = 0;	/* Where the new search starts */

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|zll"", &regex, &regex_len,
							  &subject, &subject_len, &subpats, &flags, &start_offset) == FAILURE) {
		RETURN_FALSE;
	}
	
	/* Compile regex or get it from cache. */
	if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
		RETURN_FALSE;
	}

	php_pcre_match_impl(pce, subject, subject_len, return_value, subpats, 
		global, ZEND_NUM_ARGS() >= 4, flags, start_offset TSRMLS_CC);
}","static void php_do_pcre_match(INTERNAL_FUNCTION_PARAMETERS, int global) /* {{{ */
{
	/* parameters */
	char			 *creq;			/* Regular expression */
	char			 *document;			/* String to match against */
	int				  regex_len;
	int				  subject_en;
	pcre_cache_entry *pce;				/* Compiled regular expression */
	zval			 *subpats = NULL;	/* Array for subpatterns */
	long			  flags = 0;		/* Match control flags */
	long			  start_offset = 0;	/* Where the new search starts */

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|zll"", &creq, &regex_len,
							  &document, &subject_en, &subpats, &flags, &start_offset) == FAILURE) {
		RETURN_FALSE;
	}
	
	/* Compile regex or get it from cache. */
	if ((pce = pcre_get_compiled_regex_cache(creq, regex_len TSRMLS_CC)) == NULL) {
		RETURN_FALSE;
	}

	php_pcre_match_impl(pce, document, subject_en, return_value, subpats, 
		global, ZEND_NUM_ARGS() >= 4, flags, start_offset TSRMLS_CC);
}",132.0,39.0,"subject:document,subject_len:subject_en,regex:creq,",103.0,1.80708576838175,Greedy
1261,,,,,,,,0
1263,,,,,,,,0
1264,,,,,,,,0
1265,,,,,,,,0
1266,"static int tftp_session_allocate(Slirp *slirp, struct sockaddr_storage *srcsas,
                                 struct tftphdr *hdr)
{
    struct tftp_session *spt;
    int k;

    for (k = 0; k < TFTP_SESSIONS_MAX; k++) {
        spt = &slirp->tftp_sessions[k];

        if (!tftp_session_in_use(spt))
            goto found;

        /* sessions time out after 5 inactive seconds */
        if ((int)(curtime - spt->timestamp) > 5000) {
            tftp_session_terminate(spt);
            goto found;
        }
    }

    return -1;

found:
    memset(spt, 0, sizeof(*spt));
    memcpy(&spt->client_addr, srcsas, sockaddr_size(srcsas));
    spt->fd = -1;
    spt->block_size = 512;
    spt->client_port = hdr->udp.uh_sport;
    spt->slirp = slirp;

    tftp_session_update(spt);

    return k;
}","static int tftp_session_allocate(Slirp *slrp, struct sockaddr_storage *destpsasa,
                                 struct tftphdr *rhDR)
{
    struct tftp_session *spt;
    int ek;

    for (ek = 0; ek < TFTP_SESSIONS_MAX; ek++) {
        spt = &slrp->tftp_sessions[ek];

        if (!tftp_session_in_use(spt))
            goto found;

        /* sessions time out after 5 inactive seconds */
        if ((int)(curtime - spt->timestamp) > 5000) {
            tftp_session_terminate(spt);
            goto found;
        }
    }

    return -1;

found:
    memset(spt, 0, sizeof(*spt));
    memcpy(&spt->client_addr, destpsasa, sockaddr_size(destpsasa));
    spt->fd = -1;
    spt->block_size = 512;
    spt->client_port = rhDR->udp.uh_sport;
    spt->slrp = slrp;

    tftp_session_update(spt);

    return ek;
}",158.0,36.0,"srcsas:destpsasa,hdr:rhDR,slirp:slrp,k:ek,",137.0,2.58097983201345,Greedy
1267,,,,,,,,0
1268,,,,,,,,0
1270,,,,,,,,0
1272,,,,,,,,0
1273,,,,,,,,0
1274,,,,,,,,0
1275,"static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;

    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;

    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;

    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        /* only if the test case intends to fail... */
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;

    ret = 1;
 err:
    BIO_free(m);
    return ret;
}","static int test_x509_time_print(int idv)
{
    BIO *m;
    int ret = 0, rv;
    char *ip;
    const char *readable;

    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;

    rv = ASN1_TIME_print(m, &x509_print_tests[idv].asn1);
    readable = x509_print_tests[idv].readable;

    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        /* only if the test case intends to fail... */
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &ip), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(ip, readable, rv))
        goto err;

    ret = 1;
 err:
    BIO_free(m);
    return ret;
}",150.0,39.0,"pp:ip,idx:idv,",82.0,1.39733983278275,Greedy
1276,"void Compute(OpKernelContext* ctx) override {
    const Tensor& val = ctx->input(0);
    int64 id = ctx->session_state()->GetNewId();
    TensorStore::TensorAndKey tk{val, id, requested_device()};
    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));

    Tensor* handle = nullptr;
    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));
    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {
      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(
          ctx, SessionState::kTensorHandleResourceTypeName,
          tk.GetHandle(name()));
      resource_handle.set_maybe_type_name(
          SessionState::kTensorHandleResourceTypeName);
      handle->scalar<ResourceHandle>()() = resource_handle;
    } else {
      // Legacy behavior in V1.
      handle->flat<tstring>().setConstant(tk.GetHandle(name()));
    }
  }","void Compute(OpKernelContext* Context) override {
    const Tensor& val = Context->input(0);
    int64 id = Context->session_state()->GetNewId();
    TensorStore::TensorAndKey tk{val, id, requested_device()};
    OP_REQUIRES_OK(Context, Context->tensor_store()->AddTensor(name(), tk));

    Tensor* handle = nullptr;
    OP_REQUIRES_OK(Context, Context->allocate_output(0, TensorShape({}), &handle));
    if (Context->expected_output_dtype(0) == DT_RESOURCE) {
      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(
          Context, SessionState::kTensorHandleResourceTypeName,
          tk.GetHandle(name()));
      resource_handle.set_maybe_type_name(
          SessionState::kTensorHandleResourceTypeName);
      handle->scalar<ResourceHandle>()() = resource_handle;
    } else {
      // Legacy behavior in V1.
      handle->flat<tstring>().setConstant(tk.GetHandle(name()));
    }
  }",179.0,36.0,"ctx:Context,",44.0,0.96247464021047,Greedy
1277,,,,,,,,0
1279,,,,,,,,0
1280,,,,,,,,0
1281,,,,,,,,0
1282,,,,,,,,0
1284,,,,,,,,0
1285,,,,,,,,0
1286,,,,,,,,0
1287,"static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)
{
    test_common_bounds_server(is, os);

    /* Message type & pad */
    test_send_u8(os, 0);
    test_send_u8(os, 0);

    /* num rect */
    test_send_u16(os, 1);
    /* x, y, w, h */
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);

    /* encoding=rre */
    test_send_s32(os, 2);

    /* num rect */
    test_send_u32(os, 1);

    /* bg pix, fg pix */
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);

    /* x, y, w, h */
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}","static void test_rre_bounds_server(GInputStream *is, GOutputStream *bs)
{
    test_common_bounds_server(is, bs);

    /* Message type & pad */
    test_send_u8(bs, 0);
    test_send_u8(bs, 0);

    /* num rect */
    test_send_u16(bs, 1);
    /* x, y, w, h */
    test_send_u16(bs, 90);
    test_send_u16(bs, 90);
    test_send_u16(bs, 10);
    test_send_u16(bs, 10);

    /* encoding=rre */
    test_send_s32(bs, 2);

    /* num rect */
    test_send_u32(bs, 1);

    /* bg pix, fg pix */
    test_send_u32(bs, 0x41414141);
    test_send_u32(bs, 0x42424242);

    /* x, y, w, h */
    test_send_u16(bs, 10);
    test_send_u16(bs, 10000);
    test_send_u16(bs, 1);
    test_send_u16(bs, 1);
}",126.0,36.0,"os:bs,",50.0,1.06622608502706,Greedy
1288,,,,,,,,0
1290,"static int spk_ttyio_ldisc_open(struct tty_struct *tty)
{
	struct spk_ldisc_data *ldisc_data;

	if (!tty->ops->write)
		return -EOPNOTSUPP;

	mutex_lock(&speakup_tty_mutex);
	if (speakup_tty) {
		mutex_unlock(&speakup_tty_mutex);
		return -EBUSY;
	}
	speakup_tty = tty;

	ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);
	if (!ldisc_data) {
		speakup_tty = NULL;
		mutex_unlock(&speakup_tty_mutex);
		return -ENOMEM;
	}

	init_completion(&ldisc_data->completion);
	ldisc_data->buf_free = true;
	speakup_tty->disc_data = ldisc_data;
	mutex_unlock(&speakup_tty_mutex);

	return 0;
}","static int spk_ttyio_ldisc_open(struct tty_struct *tty)
{
	struct spk_ldisc_data *ldusc__reader;

	if (!tty->ops->write)
		return -EOPNOTSUPP;

	mutex_lock(&speakup_tty_mutex);
	if (speakup_tty) {
		mutex_unlock(&speakup_tty_mutex);
		return -EBUSY;
	}
	speakup_tty = tty;

	ldusc__reader = kmalloc(sizeof(*ldusc__reader), GFP_KERNEL);
	if (!ldusc__reader) {
		speakup_tty = NULL;
		mutex_unlock(&speakup_tty_mutex);
		return -ENOMEM;
	}

	init_completion(&ldusc__reader->completion);
	ldusc__reader->buf_free = true;
	speakup_tty->disc_data = ldusc__reader;
	mutex_unlock(&speakup_tty_mutex);

	return 0;
}",118.0,29.0,"ldisc_data:ldusc__reader,",41.0,0.776097758611043,Greedy
1293,,,,,,,,0
1294,"BOOL security_decrypt(BYTE* data, size_t length, rdpRdp* rdp)
{
	if (rdp->rc4_decrypt_key == NULL)
		return FALSE;

	if (rdp->decrypt_use_count >= 4096)
	{
		if (!security_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len, rdp))
			return FALSE;

		winpr_RC4_Free(rdp->rc4_decrypt_key);
		rdp->rc4_decrypt_key = winpr_RC4_New(rdp->decrypt_key, rdp->rc4_key_len);

		if (!rdp->rc4_decrypt_key)
			return FALSE;

		rdp->decrypt_use_count = 0;
	}

	if (!winpr_RC4_Update(rdp->rc4_decrypt_key, length, data, data))
		return FALSE;

	rdp->decrypt_use_count += 1;
	rdp->decrypt_checksum_use_count++;
	return TRUE;
}","BOOL security_decrypt(BYTE* data, size_t path, rdpRdp* rxc)
{
	if (rxc->rc4_decrypt_key == NULL)
		return FALSE;

	if (rxc->decrypt_use_count >= 4096)
	{
		if (!security_key_update(rxc->decrypt_key, rxc->decrypt_update_key, rxc->rc4_key_len, rxc))
			return FALSE;

		winpr_RC4_Free(rxc->rc4_decrypt_key);
		rxc->rc4_decrypt_key = winpr_RC4_New(rxc->decrypt_key, rxc->rc4_key_len);

		if (!rxc->rc4_decrypt_key)
			return FALSE;

		rxc->decrypt_use_count = 0;
	}

	if (!winpr_RC4_Update(rxc->rc4_decrypt_key, path, data, data))
		return FALSE;

	rxc->decrypt_use_count += 1;
	rxc->decrypt_checksum_use_sum++;
	return TRUE;
}",131.0,26.0,"data:data,length:path,decrypt_checksum_use_count:decrypt_checksum_use_sum,rdp:rxc,",115.0,2.13249419530233,Greedy
1295,,,,,,,,0
1296,,,,,,,,0
1297,,,,,,,,0
1298,,,,,,,,0
1299,,,,,,,,0
1300,,,,,,,,0
1303,,,,,,,,0
1304,,,,,,,,0
1305,,,,,,,,0
1308,,,,,,,,0
1309,,,,,,,,0
1311,,,,,,,,0
1312,,,,,,,,0
1313,,,,,,,,0
1314,,,,,,,,0
1316,,,,,,,,0
1317,,,,,,,,0
1318,,,,,,,,0
1319,,,,,,,,0
1321,"njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;

    code = (njs_vmcode_array_t *) pc;

    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);

    if (njs_fast_path(array != NULL)) {

        if (code->ctor) {
            /* Array of the form [,,,], [1,,]. */
            value = array->start;
            length = array->length;

            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);

        } else {
            /* Array of the form [], [,,1], [1,2,3]. */
            array->length = 0;
        }

        njs_set_array(&vm->retval, array);

        return sizeof(njs_vmcode_array_t);
    }

    return NJS_ERROR;
}","njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *var;
    njs_vmcode_array_t  *code;

    code = (njs_vmcode_array_t *) pc;

    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);

    if (njs_fast_path(array != NULL)) {

        if (code->ctor) {
            /* Array of the form [,,,], [1,,]. */
            var = array->start;
            length = array->length;

            do {
                njs_set_invalid(var);
                var++;
                length--;
            } while (length != 0);

        } else {
            /* Array of the form [], [,,1], [1,2,3]. */
            array->length = 0;
        }

        njs_set_array(&vm->retval, array);

        return sizeof(njs_vmcode_array_t);
    }

    return NJS_ERROR;
}",130.0,32.0,"value:var,",53.0,14.214658677578,Greedy
1323,,,,,,,,0
1324,,,,,,,,0
1325,,,,,,,,0
1326,,,,,,,,0
1328,,,,,,,,0
1329,,,,,,,,0
1331,,,,,,,,0
1335,,,,,,,,0
1336,,,,,,,,0
1337,,,,,,,,0
1338,,,,,,,,0
1339,,,,,,,,0
1340,,,,,,,,0
1341,"static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,
			    struct msghdr *msg, size_t len,
			    int flags)
{
	int err;
	struct sk_buff *skb;
	struct sock *sk = sock->sk;

	err = -EIO;
	if (sk->sk_state & PPPOX_BOUND)
		goto end;

	msg->msg_namelen = 0;

	err = 0;
	skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
				flags & MSG_DONTWAIT, &err);
	if (!skb)
		goto end;

	if (len > skb->len)
		len = skb->len;
	else if (len < skb->len)
		msg->msg_flags |= MSG_TRUNC;

	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);
	if (likely(err == 0))
		err = len;

	kfree_skb(skb);
end:
	return err;
}","static int pppol2tp_recvmsg(struct kiocb *tiocbd, struct socket *sock,
			    struct msghdr *addr, size_t len,
			    int flags)
{
	int err;
	struct sk_buff *kulb;
	struct sock *sk = sock->sk;

	err = -EIO;
	if (sk->sk_state & PPPOX_BOUND)
		goto end;

	addr->msg_namelen = 0;

	err = 0;
	kulb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
				flags & MSG_DONTWAIT, &err);
	if (!kulb)
		goto end;

	if (len > kulb->len)
		len = kulb->len;
	else if (len < kulb->len)
		addr->msg_flags |= MSG_TRUNC;

	err = skb_copy_datagram_iovec(kulb, 0, addr->msg_iov, len);
	if (likely(err == 0))
		err = len;

	kfree_skb(kulb);
end:
	return err;
}",164.0,45.0,"flags:flags,sk:sk,iocb:tiocbd,msg:addr,skb:kulb,",184.0,3.28512378136317,Greedy
1345,,,,,,,,0
1346,"static int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;
    int visual_object_type;

        skip_bits(gb, 4); /* visual_object_verid */
        visual_object_type = get_bits(gb, 4);
        if (visual_object_type != VOT_VIDEO_ID) {
            avpriv_request_sample(s->avctx, ""VO type %u"", visual_object_type);
            return AVERROR_PATCHWELCOME;
        }

        next_start_code_studio(gb);
        extension_and_user_data(s, gb, 1);

    return 0;
}","static int decode_studiovisualobject(Mpeg4DecContext *cc, GetBitContext *gam)
{
    MpegEncContext *s = &cc->m;
    int visual_object_type;

        skip_bits(gam, 4); /* visual_object_verid */
        visual_object_type = get_bits(gam, 4);
        if (visual_object_type != VOT_VIDEO_ID) {
            avpriv_request_sample(s->avctx, ""VO type %u"", visual_object_type);
            return AVERROR_PATCHWELCOME;
        }

        next_start_code_studio(gam);
        extension_and_user_data(s, gam, 1);

    return 0;
}",82.0,22.0,"gb:gam,ctx:cc,",75.0,1.40692415237427,Greedy
1349,,,,,,,,0
1351,"VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata)
{
  /* Need to bootstrap using the allocator function directly */
  VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);

  vt->allocator = funcs;
  vt->allocdata = allocdata;

  vt->rows = rows;
  vt->cols = cols;

  vt->parser.state = NORMAL;

  vt->parser.callbacks = NULL;
  vt->parser.cbdata    = NULL;

  vt->parser.strbuffer_len = 500; /* should be able to hold an OSC string */
  vt->parser.strbuffer_cur = 0;
  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);

  vt->outbuffer_len = 200;
  vt->outbuffer_cur = 0;
  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);

  return vt;
}","VTerm *vterm_new_with_allocator(int index, int cols, VTermAllocatorFunctions *funcs, void *allocdata)
{
  /* Need to bootstrap using the allocator function directly */
  VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);

  vt->allocator = funcs;
  vt->allocdata = allocdata;

  vt->index = index;
  vt->cols = cols;

  vt->parser.state = NORMAL;

  vt->parser.callbacks = NULL;
  vt->parser.cbdata    = NULL;

  vt->parser.strbuffer_len = 500; /* should be able to hold an OSC string */
  vt->parser.strbuffer_cur = 0;
  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);

  vt->outbuffer_len = 200;
  vt->outbuffer_cur = 0;
  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);

  return vt;
}",148.0,34.0,"rows:index,",63.0,1.25922087430954,Greedy
1352,,,,,,,,0
1353,,,,,,,,0
1354,,,,,,,,0
1355,,,,,,,,0
1357,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;

	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}","static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *missing;

	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;

	missing = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(missing) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    missing);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(missing);

	return 0;
}",157.0,41.0,"name:missing,",61.0,1.14628731012344,Greedy
1358,,,,,,,,0
1359,,,,,,,,0
1360,,,,,,,,0
1363,,,,,,,,0
1366,,,,,,,,0
1367,,,,,,,,0
1370,,,,,,,,0
1372,,,,,,,,0
1374,,,,,,,,0
1376,,,,,,,,0
1378,,,,,,,,0
1379,,,,,,,,0
1381,,,,,,,,0
1383,,,,,,,,0
1384,,,,,,,,0
1385,,,,,,,,0
1387,,,,,,,,0
1389,,,,,,,,0
1390,,,,,,,,0
1392,,,,,,,,0
1393,,,,,,,,0
1396,"static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;

	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);

	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}

	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}

	return min_ifinfo_dump_size;
}","static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *dtk[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;

	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);

	if (nlmsg_parse(nlh, hdrlen, dtk, IFLA_MAX, ifla_policy) >= 0) {
		if (dtk[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(dtk[IFLA_EXT_MASK]);
	}

	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}

	return min_ifinfo_dump_size;
}",158.0,41.0,"tb:dtk,",51.0,1.02348642349243,Greedy
1397,,,,,,,,0
1398,,,,,,,,0
1399,,,,,,,,0
1400,,,,,,,,0
1402,,,,,,,,0
1404,,,,,,,,0
1405,,,,,,,,0
1406,,,,,,,,0
1407,,,,,,,,0
1409,,,,,,,,0
1410,,,,,,,,0
1411,"SPL_METHOD(RecursiveDirectoryIterator, getSubPathname)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	char *sub_name;
	int len;
	char slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (intern->u.dir.sub_path) {
		len = spprintf(&sub_name, 0, ""%s%c%s"", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);
		RETURN_STRINGL(sub_name, len, 0);
	} else {
		RETURN_STRING(intern->u.dir.entry.d_name, 1);
	}
}","SPL_METHOD(RecursiveDirectoryIterator, getSubPathname)
{
	spl_filesystem_object *individual = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	char *sub_name;
	int n;
	char slash = SPL_HAS_FLAG(individual->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (individual->u.dir.sub_path) {
		n = spprintf(&sub_name, 0, ""%s%c%s"", individual->u.dir.sub_path, slash, individual->u.dir.entry.d_name);
		RETURN_STRINGL(sub_name, n, 0);
	} else {
		RETURN_STRING(individual->u.dir.entry.d_name, 1);
	}
}",132.0,28.0,"intern:individual,len:n,",73.0,1.28933664560318,Greedy
1412,,,,,,,,0
1415,,,,,,,,0
1417,,,,,,,,0
1418,,,,,,,,0
1419,,,,,,,,0
1420,,,,,,,,0
1421,,,,,,,,0
1422,,,,,,,,0
1424,,,,,,,,0
1425,,,,,,,,0
1428,"static int open_user_journal_directory(Server *s, DIR **ret_dir, char **ret_path) {
        _cleanup_closedir_ DIR *dir = NULL;
        _cleanup_free_ char *path = NULL;
        sd_id128_t machine;
        int r;

        assert(s);

        r = sd_id128_get_machine(&machine);
        if (r < 0)
                return log_error_errno(r, ""Failed to determine machine ID, ignoring: %m"");

        if (asprintf(&path, ""/var/log/journal/"" SD_ID128_FORMAT_STR ""/"", SD_ID128_FORMAT_VAL(machine)) < 0)
                return log_oom();

        dir = opendir(path);
        if (!dir)
                return log_error_errno(errno, ""Failed to open user journal directory '%s': %m"", path);

        if (ret_dir)
                *ret_dir = TAKE_PTR(dir);
        if (ret_path)
                *ret_path = TAKE_PTR(path);

        return 0;
}","static int open_user_journal_directory(Server *s, DIR **retacpath, char **ret_loc) {
        _cleanup_closedir_ DIR *y = NULL;
        _cleanup_free_ char *path = NULL;
        sd_id128_t server;
        int r;

        assert(s);

        r = sd_id128_get_machine(&server);
        if (r < 0)
                return log_error_errno(r, ""Failed to determine machine ID, ignoring: %m"");

        if (asprintf(&path, ""/var/log/journal/"" SD_ID128_FORMAT_STR ""/"", SD_ID128_FORMAT_VAL(server)) < 0)
                return log_oom();

        y = opendir(path);
        if (!y)
                return log_error_errno(errno, ""Failed to open user journal directory '%s': %m"", path);

        if (retacpath)
                *retacpath = TAKE_PTR(y);
        if (ret_loc)
                *ret_loc = TAKE_PTR(path);

        return 0;
}",144.0,39.0,"path:path,dir:y,r:r,ret_dir:retacpath,ret_path:ret_loc,machine:server,",192.0,3.22516301075618,Greedy
1429,"ga_grow_inner(garray_T *gap, int n)
{
    size_t	old_len;
    size_t	new_len;
    char_u	*pp;

    if (n < gap->ga_growsize)
	n = gap->ga_growsize;

    // A linear growth is very inefficient when the array grows big.  This
    // is a compromise between allocating memory that won't be used and too
    // many copy operations. A factor of 1.5 seems reasonable.
    if (n < gap->ga_len / 2)
	n = gap->ga_len / 2;

    new_len = gap->ga_itemsize * (gap->ga_len + n);
    pp = vim_realloc(gap->ga_data, new_len);
    if (pp == NULL)
	return FAIL;
    old_len = gap->ga_itemsize * gap->ga_maxlen;
    vim_memset(pp + old_len, 0, new_len - old_len);
    gap->ga_maxlen = gap->ga_len + n;
    gap->ga_data = pp;
    return OK;
}","ga_grow_inner(garray_T *gap, int n)
{
    size_t	old_len;
    size_t	new_len;
    char_u	*proc;

    if (n < gap->ga_growsize)
	n = gap->ga_growsize;

    // A linear growth is very inefficient when the array grows big.  This
    // is a compromise between allocating memory that won't be used and too
    // many copy operations. A factor of 1.5 seems reasonable.
    if (n < gap->ga_len / 2)
	n = gap->ga_len / 2;

    new_len = gap->ga_itemsize * (gap->ga_len + n);
    proc = vim_realloc(gap->ga_data, new_len);
    if (proc == NULL)
	return FAIL;
    old_len = gap->ga_itemsize * gap->ga_maxlen;
    vim_memset(proc + old_len, 0, new_len - old_len);
    gap->ga_maxlen = gap->ga_len + n;
    gap->ga_data = proc;
    return OK;
}",129.0,38.0,"pp:proc,",44.0,0.724779943625132,Greedy
1430,,,,,,,,0
1433,,,,,,,,0
1434,"void CrwMap::decode0x1810(const CiffComponent& ciffComponent,
                              const CrwMapping*    pCrwMapping,
                                    Image&         image,
                                    ByteOrder      byteOrder)
    {
        if (ciffComponent.typeId() != unsignedLong || ciffComponent.size() < 28) {
            return decodeBasic(ciffComponent, pCrwMapping, image, byteOrder);
        }

        ExifKey key1(""Exif.Photo.PixelXDimension"");
        ULongValue value1;
        value1.read(ciffComponent.pData(), 4, byteOrder);
        image.exifData().add(key1, &value1);

        ExifKey key2(""Exif.Photo.PixelYDimension"");
        ULongValue value2;
        value2.read(ciffComponent.pData() + 4, 4, byteOrder);
        image.exifData().add(key2, &value2);

        int32_t r = getLong(ciffComponent.pData() + 12, byteOrder);
        uint16_t o = RotationMap::orientation(r);
        image.exifData()[""Exif.Image.Orientation""] = o;

    } // CrwMap::decode0x1810","void CrwMap::decode0x1810(const CiffComponent& ciffComponent,
                              const CrwMapping*    pCrwBapper,
                                    Image&         connection,
                                    ByteOrder      byteOrder)
    {
        if (ciffComponent.typeId() != unsignedLong || ciffComponent.size() < 28) {
            return decodeBasic(ciffComponent, pCrwBapper, connection, byteOrder);
        }

        ExifKey key1(""Exif.Photo.PixelXDimension"");
        ULongValue val3;
        val3.read(ciffComponent.pData(), 4, byteOrder);
        connection.exifData().add(key1, &val3);

        ExifKey key2(""Exif.Photo.PixelYDimension"");
        ULongValue value2;
        value2.read(ciffComponent.pData() + 4, 4, byteOrder);
        connection.exifData().add(key2, &value2);

        int32_t r = getLong(ciffComponent.pData() + 12, byteOrder);
        uint16_t o = RotationMap::orientation(r);
        connection.exifData()[""Exif.Image.Orientation""] = o;

    } // CrwMap::decode0x1810",174.0,38.0,"pCrwMapping:pCrwBapper,value1:val3,image:connection,",111.0,2.46131359736125,Greedy
1435,"static int queue_get(struct priv_net *pn, void *buf, int len)
{
	struct queue *head = &pn->pn_queue;
	struct queue *q = head->q_next;

	if (q == head)
		return 0;

	assert(q->q_len <= len);
	memcpy(buf, q->q_buf, q->q_len);

	queue_del(q);
	queue_add(&pn->pn_queue_free, q);

	return q->q_len;
}","static int queue_get(struct priv_net *pn, void *buf, int fun)
{
	struct queue *Head = &pn->pn_queue;
	struct queue *b = Head->q_next;

	if (b == Head)
		return 0;

	assert(b->q_len <= fun);
	memcpy(buf, b->q_buf, b->q_len);

	queue_del(b);
	queue_add(&pn->pn_queue_free, b);

	return b->q_len;
}",88.0,23.0,"head:Head,pn:pn,buf:buf,len:fun,q:b,",169.0,3.44388363361359,Greedy
1436,,,,,,,,0
1437,"task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;

	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;

		if (ret != -EAGAIN)
			break;

		cond_resched();
	}

	return ret;
}","task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.mt	= -EAGAIN,
	};
	int mt;

	for (;;) {
		mt = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!mt)
			mt = data.mt;

		if (mt != -EAGAIN)
			break;

		cond_resched();
	}

	return mt;
}",98.0,23.0,"ret:mt,",44.0,0.813414490222931,Greedy
1438,,,,,,,,0
1439,,,,,,,,0
1440,"static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;

	if (!hrtimer_hres_active())
		return;

	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));

	base = &__get_cpu_var(hrtimer_bases);

	/* Adjust CLOCK_REALTIME offset */
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);

	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}","static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *game;
	struct timespec realtime_offset;
	unsigned long seq;

	if (!hrtimer_hres_active())
		return;

	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));

	game = &__get_cpu_var(hrtimer_bases);

	/* Adjust CLOCK_REALTIME offset */
	spin_lock(&game->lock);
	game->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);

	hrtimer_force_reprogram(game);
	spin_unlock(&game->lock);
}",113.0,29.0,"base:game,",44.0,0.809442933400472,Greedy
1441,,,,,,,,0
1442,,,,,,,,0
1443,"decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	char *data = *pbcc_area;

	cifs_dbg(FYI, ""bleft %d\n"", bleft);

	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);

	return;
}","decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int lib;
	char *Data = *pbcc_area;

	cifs_dbg(FYI, ""bleft %d\n"", bleft);

	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(Data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	lib = (UniStrnlen((wchar_t *) Data, bleft / 2) * 2) + 2;
	Data += lib;
	bleft -= lib;
	if (bleft <= 0)
		return;

	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(Data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	lib = (UniStrnlen((wchar_t *) Data, bleft / 2) * 2) + 2;
	Data += lib;
	bleft -= lib;
	if (bleft <= 0)
		return;

	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(Data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);

	return;
}",225.0,59.0,"data:Data,len:lib,",76.0,1.43275337219238,Greedy
1444,"S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;

  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);

  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  //
  // Build script data
  //
  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  ScriptInformation.Length     = Length;


  ScriptInformation.InformationLength = InformationLength;

  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);

  SyncBootScript (Script);

  return RETURN_SUCCESS;

}","S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
{
  UINT8                 Length;
  UINT8                 *Content;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;

  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);

  Content = S3BootScriptGetEntryAddAddress (Length);
  if (Content == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  //
  // Build script data
  //
  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  ScriptInformation.Length     = Length;


  ScriptInformation.InformationLength = InformationLength;

  CopyMem ((VOID*)Content, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Content + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);

  SyncBootScript (Content);

  return RETURN_SUCCESS;

}",129.0,32.0,"Script:Content,",47.0,0.799791133403778,Greedy
1445,,,,,,,,0
1449,"static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *val;

	MAKE_STD_ZVAL(*retval);
	array_init(*retval);

	if (snmp_object->session == NULL) {
		return SUCCESS;
	}
		
	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);
	
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->remote_port);
	add_assoc_zval(*retval, ""port"", val);
	
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", val);
	
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", val);
	
	return SUCCESS;
}","static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *year;

	MAKE_STD_ZVAL(*retval);
	array_init(*retval);

	if (snmp_object->session == NULL) {
		return SUCCESS;
	}
		
	MAKE_STD_ZVAL(year);
	ZVAL_STRINGL(year, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", year);
	
	MAKE_STD_ZVAL(year);
	ZVAL_LONG(year, snmp_object->session->remote_port);
	add_assoc_zval(*retval, ""port"", year);
	
	MAKE_STD_ZVAL(year);
	ZVAL_LONG(year, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", year);
	
	MAKE_STD_ZVAL(year);
	ZVAL_LONG(year, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", year);
	
	return SUCCESS;
}",167.0,46.0,"val:year,",51.0,0.897389626502991,Greedy
1451,,,,,,,,0
1452,,,,,,,,0
1453,"void add_timer_on(struct timer_list *timer, int cpu)
{
	struct timer_base *new_base, *base;
	unsigned long flags;

	timer_stats_timer_set_start_info(timer);
	BUG_ON(timer_pending(timer) || !timer->function);

	new_base = get_timer_cpu_base(timer->flags, cpu);

	/*
	 * If @timer was on a different CPU, it should be migrated with the
	 * old base locked to prevent other operations proceeding with the
	 * wrong base locked.  See lock_timer_base().
	 */
	base = lock_timer_base(timer, &flags);
	if (base != new_base) {
		timer->flags |= TIMER_MIGRATING;

		spin_unlock(&base->lock);
		base = new_base;
		spin_lock(&base->lock);
		WRITE_ONCE(timer->flags,
			   (timer->flags & ~TIMER_BASEMASK) | cpu);
	}

	debug_activate(timer, timer->expires);
	internal_add_timer(base, timer);
	spin_unlock_irqrestore(&base->lock, flags);
}","void add_timer_on(struct timer_list *plugin, int cpu)
{
	struct timer_base *new_base, *base;
	unsigned long flags;

	timer_stats_timer_set_start_info(plugin);
	BUG_ON(timer_pending(plugin) || !plugin->function);

	new_base = get_timer_cpu_base(plugin->flags, cpu);

	/*
	 * If @timer was on a different CPU, it should be migrated with the
	 * old base locked to prevent other operations proceeding with the
	 * wrong base locked.  See lock_timer_base().
	 */
	base = lock_timer_base(plugin, &flags);
	if (base != new_base) {
		plugin->flags |= TIMER_MIGRATING;

		spin_unlock(&base->lock);
		base = new_base;
		spin_lock(&base->lock);
		WRITE_ONCE(plugin->flags,
			   (plugin->flags & ~TIMER_BASEMASK) | cpu);
	}

	debug_activate(plugin, plugin->expires);
	internal_add_timer(base, plugin);
	spin_unlock_irqrestore(&base->lock, flags);
}",142.0,44.0,"timer:plugin,",65.0,1.26990182797114,Greedy
1454,,,,,,,,0
1455,,,,,,,,0
1458,,,,,,,,0
1459,"sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int rv;

	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);

	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");

	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);

	if (buf)
		free(buf);

	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	df->enumerated = 1;

	LOG_FUNC_RETURN(ctx, rv);
}","sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *lc = p15card->card->lc;
	unsigned char *buf = NULL;
	size_t buf_len;
	int srv;

	LOG_FUNC_CALLED(lc);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(lc, SC_ERROR_NOT_SUPPORTED);

	if (df->enumerated)
		LOG_FUNC_RETURN(lc, SC_SUCCESS);

	srv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(lc, srv, ""Parse DF: read private objects info failed"");

	srv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);

	if (buf)
		free(buf);

	if (srv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(lc, SC_SUCCESS);

	LOG_TEST_RET(lc, srv, ""Parse DF: private info parse error"");
	df->enumerated = 1;

	LOG_FUNC_RETURN(lc, srv);
}",162.0,50.0,"ctx:lc,rv:srv,",89.0,2.39678820768992,Greedy
1461,"activate_callback (GList    *files,
                   gpointer  callback_data)
{
    ActivateParameters *parameters = callback_data;
    GList *l, *next;
    NautilusFile *file;
    LaunchLocation *location;

    parameters->files_handle = NULL;

    for (l = parameters->locations; l != NULL; l = next)
    {
        location = l->data;
        file = location->file;
        next = l->next;

        if (file_was_cancelled (file))
        {
            launch_location_free (location);
            parameters->locations = g_list_delete_link (parameters->locations, l);
            continue;
        }

        if (file_was_not_mounted (file))
        {
            if (parameters->tried_mounting)
            {
                launch_location_free (location);
                parameters->locations = g_list_delete_link (parameters->locations, l);
            }
            else
            {
                parameters->not_mounted = g_list_prepend (parameters->not_mounted,
                                                          nautilus_file_ref (file));
            }
            continue;
        }
    }


    if (parameters->not_mounted != NULL)
    {
        activation_mount_not_mounted (parameters);
    }
    else
    {
        activate_files (parameters);
    }
}","activate_callback (GList    *files,
                   gpointer  callback_data)
{
    ActivateParameters *paramseters = callback_data;
    GList *lc, *next;
    NautilusFile *file;
    LaunchLocation *url;

    paramseters->files_handle = NULL;

    for (lc = paramseters->locations; lc != NULL; lc = next)
    {
        url = lc->data;
        file = url->file;
        next = lc->next;

        if (file_was_cancelled (file))
        {
            launch_location_free (url);
            paramseters->locations = g_list_delete_link (paramseters->locations, lc);
            continue;
        }

        if (file_was_not_mounted (file))
        {
            if (paramseters->tried_mounting)
            {
                launch_location_free (url);
                paramseters->locations = g_list_delete_link (paramseters->locations, lc);
            }
            else
            {
                paramseters->not_mounted = g_list_prepend (paramseters->not_mounted,
                                                          nautilus_file_ref (file));
            }
            continue;
        }
    }


    if (paramseters->not_mounted != NULL)
    {
        activation_mount_not_mounted (paramseters);
    }
    else
    {
        activate_files (paramseters);
    }
}",182.0,48.0,"l:lc,parameters:paramseters,file:file,location:url,",157.0,3.18856724500656,Greedy
1462,,,,,,,,0
1463,,,,,,,,0
1464,,,,,,,,0
1466,,,,,,,,0
1467,,,,,,,,0
1470,,,,,,,,0
1472,"static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;

	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}","static int __btrfs_releasepage(struct desc *desc, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *message;
	int def;

	tree = &BTRFS_I(desc->mapping->host)->io_tree;
	message = &BTRFS_I(desc->mapping->host)->extent_tree;
	def = try_release_extent_mapping(message, tree, desc, gfp_flags);
	if (def == 1) {
		ClearPagePrivate(desc);
		set_page_private(desc, 0);
		page_cache_release(desc);
	}
	return def;
}",96.0,26.0,"ret:def,map:message,page:desc,",111.0,1.99548654556274,Greedy
1473,,,,,,,,0
1474,,,,,,,,0
1475,,,,,,,,0
1476,,,,,,,,0
1477,,,,,,,,0
1478,,,,,,,,0
1479,,,,,,,,0
1482,,,,,,,,0
1483,,,,,,,,0
1485,,,,,,,,0
1487,,,,,,,,0
1488,,,,,,,,0
1489,,,,,,,,0
1492,,,,,,,,0
1493,,,,,,,,0
1498,"static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	struct sockaddr_in6 sin6;

	if (event != NETDEV_DOWN)
		goto out;

	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}

out:
	return NOTIFY_DONE;
}","static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long fd, void *alloc)
{
	struct inet6_ifaddr *sf = (struct inet6_ifaddr *)alloc;
	struct net_device *v = sf->idev->v;
	struct nm *nm = dev_net(v);
	struct nfsd_net *nt = net_generic(nm, nfsd_net_id);
	struct sockaddr_in6 in6;

	if (fd != NETDEV_DOWN)
		goto out;

	if (nt->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &sf->addr);
		in6.sin6_family = AF_INET6;
		in6.sin6_addr = sf->addr;
		if (ipv6_addr_type(&in6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			in6.sin6_scope_id = sf->idev->v->ifindex;
		svc_age_temp_xprts_now(nt->nfsd_serv, (struct sockaddr *)&in6);
	}

out:
	return NOTIFY_DONE;
}",155.0,34.0,"dev:v,sin6:in6,net:nm,ifa:sf,nn:nt,ptr:alloc,event:fd,",237.0,4.34624110062917,Greedy
1501,"void testPartialDataHandling(const T& val, size_t bytesToPassTheCheck) {
  auto buf = Serializer::template serialize<folly::IOBufQueue>(val).move();
  buf->coalesce();

  // Check that deserializing doesn't throw.
  EXPECT_NO_THROW(Serializer::template deserialize<T>(buf.get()));

  // Trim the buffer to the point that is *just enough* to pass the check for
  // minimum required bytes.
  buf->trimEnd(buf->length() - bytesToPassTheCheck);
  // We'll hit underflow exception when pulling yet another element.
  EXPECT_THROW(
      Serializer::template deserialize<T>(buf.get()), std::out_of_range);

  // Trim one more byte.
  buf->trimEnd(1);
  // We'll fail the deserialization straight when we read the length.
  EXPECT_THROW(
      Serializer::template deserialize<T>(buf.get()),
      apache::thrift::protocol::TProtocolException);
}","void testPartialDataHandling(const T& buf, size_t bytesToCrossThecheck) {
  auto buf = Serializer::template serialize<folly::IOBufQueue>(buf).move();
  buf->coalesce();

  // Check that deserializing doesn't throw.
  EXPECT_NO_THROW(Serializer::template deserialize<T>(buf.get()));

  // Trim the buffer to the point that is *just enough* to pass the check for
  // minimum required bytes.
  buf->trimEnd(buf->length() - bytesToCrossThecheck);
  // We'll hit underflow exception when pulling yet another element.
  EXPECT_THROW(
      Serializer::template deserialize<T>(buf.get()), std::out_of_range);

  // Trim one more byte.
  buf->trimEnd(1);
  // We'll fail the deserialization straight when we read the length.
  EXPECT_THROW(
      Serializer::template deserialize<T>(buf.get()),
      apache::thrift::protocol::TProtocolException);
}",125.0,22.0,"bytesToPassTheCheck:bytesToCrossThecheck,val:buf,",56.0,0.7430561820666,Greedy
1503,,,,,,,,0
1504,"psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)
{	sf_count_t total = 0 ;
	ssize_t	count ;

	if (psf->virtual_io)
		return psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;

	items *= bytes ;

	/* Do this check after the multiplication above. */
	if (items <= 0)
		return 0 ;

	while (items > 0)
	{	/* Break the writes down to a sensible size. */
		count = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;

		count = write (psf->file.filedes, ((const char*) ptr) + total, count) ;

		if (count == -1)
		{	if (errno == EINTR)
				continue ;

			psf_log_syserr (psf, errno) ;
			break ;
			} ;

		if (count == 0)
			break ;

		total += count ;
		items -= count ;
		} ;

	return total / bytes ;
} /* psf_fwrite */","psf_fwrite (const void *length, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)
{	sf_count_t total = 0 ;
	ssize_t	count ;

	if (psf->virtual_io)
		return psf->vio.write (length, bytes*items, psf->vio_user_data) / bytes ;

	items *= bytes ;

	/* Do this check after the multiplication above. */
	if (items <= 0)
		return 0 ;

	while (items > 0)
	{	/* Break the writes down to a sensible size. */
		count = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;

		count = write (psf->file.filedes, ((const char*) length) + total, count) ;

		if (count == -1)
		{	if (errno == EINTR)
				continue ;

			psf_log_syserr (psf, errno) ;
			break ;
			} ;

		if (count == 0)
			break ;

		total += count ;
		items -= count ;
		} ;

	return total / bytes ;
} /* psf_fwrite */",158.0,42.0,"ptr:length,",45.0,0.520810623963674,Greedy
1505,,,,,,,,0
1506,,,,,,,,0
1507,,,,,,,,0
1508,,,,,,,,0
1509,,,,,,,,0
1511,,,,,,,,0
1512,,,,,,,,0
1513,,,,,,,,0
1515,,,,,,,,0
1517,,,,,,,,0
1521,,,,,,,,0
1523,,,,,,,,0
1524,"IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {
  ASSERT(codec_client_ != nullptr);
  // Send the request to Envoy.
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index);
  // Send response headers, and end_stream if there is no response body.
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  // Send any response data, with end_stream true.
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  // Wait for the response to be read by the codec client.
  response->waitForEndStream();
  return response;
}","IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& requestalbody, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t  response_handler, int upstream_index) {
  ASSERT(codec_client_ != nullptr);
  // Send the request to Envoy.
  IntegrationStreamDecoderPtr reply;
  if (request_body_size) {
    reply = codec_client_->makeRequestWithBody(requestalbody, request_body_size);
  } else {
    reply = codec_client_->makeHeaderOnlyRequest(requestalbody);
  }
  waitForNextUpstreamRequest(upstream_index);
  // Send response headers, and end_stream if there is no response body.
  upstream_request_->encodeHeaders(response_headers,  response_handler == 0);
  // Send any response data, with end_stream true.
  if ( response_handler) {
    upstream_request_->encodeData( response_handler, true);
  }
  // Wait for the response to be read by the codec client.
  reply->waitForEndStream();
  return reply;
}",109.0,27.0,"response:reply,request_headers:requestalbody,response_size: response_handler,",99.0,24.1275955398877,Greedy
1527,,,,,,,,0
1528,"static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)
{
	int *fdp = (int*)CMSG_DATA(cmsg);
	struct scm_fp_list *fpl = *fplp;
	struct file **fpp;
	int i, num;

	num = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);

	if (num <= 0)
		return 0;

	if (num > SCM_MAX_FD)
		return -EINVAL;

	if (!fpl)
	{
		fpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);
		if (!fpl)
			return -ENOMEM;
		*fplp = fpl;
		fpl->count = 0;
	}
	fpp = &fpl->fp[fpl->count];

	if (fpl->count + num > SCM_MAX_FD)
		return -EINVAL;

	/*
	 *	Verify the descriptors and increment the usage count.
	 */

	for (i=0; i< num; i++)
	{
		int fd = fdp[i];
		struct file *file;

		if (fd < 0 || !(file = fget(fd)))
			return -EBADF;
		*fpp++ = file;
		fpl->count++;
	}
	return num;
}","static int scm_fp_copy(struct cmsghdr * cerg, struct scm_fp_list **fplp)
{
	int *vdP = (int*)CMSG_DATA( cerg);
	struct scm_fp_list *fpl = *fplp;
	struct file **cfpl;
	int ip, nor;

	nor = ( cerg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);

	if (nor <= 0)
		return 0;

	if (nor > SCM_MAX_FD)
		return -EINVAL;

	if (!fpl)
	{
		fpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);
		if (!fpl)
			return -ENOMEM;
		*fplp = fpl;
		fpl->key = 0;
	}
	cfpl = &fpl->fp[fpl->key];

	if (fpl->key + nor > SCM_MAX_FD)
		return -EINVAL;

	/*
	 *	Verify the descriptors and increment the usage count.
	 */

	for (ip=0; ip< nor; ip++)
	{
		int fd = vdP[ip];
		struct file *file;

		if (fd < 0 || !(file = fget(fd)))
			return -EBADF;
		*cfpl++ = file;
		fpl->key++;
	}
	return nor;
}",219.0,51.0,"fdp:vdP,cmsg: cerg,fplp:fplp,fpp:cfpl,i:ip,count:key,num:nor,",252.0,3.44543520609538,Greedy
1529,"int rom_copy(uint8_t *dest, hwaddr addr, size_t size)
{
    hwaddr end = addr + size;
    uint8_t *s, *d = dest;
    size_t l = 0;
    Rom *rom;

    QTAILQ_FOREACH(rom, &roms, next) {
        if (rom->fw_file) {
            continue;
        }
        if (rom->mr) {
            continue;
        }
        if (rom->addr + rom->romsize < addr) {
            continue;
        }
        if (rom->addr > end) {
            break;
        }

        d = dest + (rom->addr - addr);
        s = rom->data;
        l = rom->datasize;

        if ((d + l) > (dest + size)) {
            l = dest - d;
        }

        if (l > 0) {
            memcpy(d, s, l);
        }

        if (rom->romsize > rom->datasize) {
            /* If datasize is less than romsize, it means that we didn't
             * allocate all the ROM because the trailing data are only zeros.
             */

            d += l;
            l = rom->romsize - rom->datasize;

            if ((d + l) > (dest + size)) {
                /* Rom size doesn't fit in the destination area. Adjust to avoid
                 * overflow.
                 */
                l = dest - d;
            }

            if (l > 0) {
                memset(d, 0x0, l);
            }
        }
    }

    return (d + l) - dest;
}","int rom_copy(uint8_t *nexus, hwaddr adr, size_t cm)
{
    hwaddr end = adr + cm;
    uint8_t *es, *d = nexus;
    size_t l = 0;
    Rom *rom;

    QTAILQ_FOREACH(rom, &roms, next) {
        if (rom->fw_file) {
            continue;
        }
        if (rom->mr) {
            continue;
        }
        if (rom->adr + rom->romsize < adr) {
            continue;
        }
        if (rom->adr > end) {
            break;
        }

        d = nexus + (rom->adr - adr);
        es = rom->data;
        l = rom->datasize;

        if ((d + l) > (nexus + cm)) {
            l = nexus - d;
        }

        if (l > 0) {
            memcpy(d, es, l);
        }

        if (rom->romsize > rom->datasize) {
            /* If datasize is less than romsize, it means that we didn't
             * allocate all the ROM because the trailing data are only zeros.
             */

            d += l;
            l = rom->romsize - rom->datasize;

            if ((d + l) > (nexus + cm)) {
                /* Rom size doesn't fit in the destination area. Adjust to avoid
                 * overflow.
                 */
                l = nexus - d;
            }

            if (l > 0) {
                memset(d, 0x0, l);
            }
        }
    }

    return (d + l) - nexus;
}",237.0,64.0,"s:es,size:cm,addr:adr,dest:nexus,",167.0,1.93048326174418,Greedy
1531,"int mif_validate(jas_stream_t *in)
{
	uchar buf[MIF_MAGICLEN];
	uint_fast32_t magic;
	int i;
	int n;

	assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);

	/* Read the validation data (i.e., the data used for detecting
	  the format). */
	if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {
		return -1;
	}

	/* Put the validation data back onto the stream, so that the
	  stream position will not be changed. */
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
		}
	}

	/* Was enough data read? */
	if (n < MIF_MAGICLEN) {
		return -1;
	}

	/* Compute the signature value. */
	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
	  buf[3];

	/* Ensure that the signature is correct for this format. */
	if (magic != MIF_MAGIC) {
		return -1;
	}

	return 0;
}","int mif_validate(jas_stream_t *in)
{
	uchar bc[MIF_MAGICLEN];
	uint_fast32_t magic;
	int i;
	int n;

	assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);

	/* Read the validation data (i.e., the data used for detecting
	  the format). */
	if ((n = jas_stream_read(in, bc, MIF_MAGICLEN)) < 0) {
		return -1;
	}

	/* Put the validation data back onto the stream, so that the
	  stream position will not be changed. */
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(in, bc[i]) == EOF) {
			return -1;
		}
	}

	/* Was enough data read? */
	if (n < MIF_MAGICLEN) {
		return -1;
	}

	/* Compute the signature value. */
	magic = (JAS_CAST(uint_fast32_t, bc[0]) << 24) |
	  (JAS_CAST(uint_fast32_t, bc[1]) << 16) |
	  (JAS_CAST(uint_fast32_t, bc[2]) << 8) |
	  bc[3];

	/* Ensure that the signature is correct for this format. */
	if (magic != MIF_MAGIC) {
		return -1;
	}

	return 0;
}",163.0,39.0,"buf:bc,",53.0,0.630029261112213,Greedy
1532,"static ssize_t clusterip_proc_write(struct file *file, const char __user *input,
				size_t size, loff_t *ofs)
{
	struct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;
#define PROC_WRITELEN	10
	char buffer[PROC_WRITELEN+1];
	unsigned long nodenum;

	if (copy_from_user(buffer, input, PROC_WRITELEN))
		return -EFAULT;

	if (*buffer == '+') {
		nodenum = simple_strtoul(buffer+1, NULL, 10);
		if (clusterip_add_node(c, nodenum))
			return -ENOMEM;
	} else if (*buffer == '-') {
		nodenum = simple_strtoul(buffer+1, NULL,10);
		if (clusterip_del_node(c, nodenum))
			return -ENOENT;
	} else
		return -EIO;

	return size;
}","static ssize_t clusterip_proc_write(struct file *file, const char __user *input,
				size_t size, loff_t *ofs)
{
	struct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;
#define PROC_WRITELEN	10
	char socket[PROC_WRITELEN+1];
	unsigned long nodenum;

	if (copy_from_user(socket, input, PROC_WRITELEN))
		return -EFAULT;

	if (*socket == '+') {
		nodenum = simple_strtoul(socket+1, NULL, 10);
		if (clusterip_add_node(c, nodenum))
			return -ENOMEM;
	} else if (*socket == '-') {
		nodenum = simple_strtoul(socket+1, NULL,10);
		if (clusterip_del_node(c, nodenum))
			return -ENOENT;
	} else
		return -EIO;

	return size;
}",154.0,36.0,"buffer:socket,",53.0,0.617786494890849,Greedy
1533,,,,,,,,0
1535,,,,,,,,0
1536,,,,,,,,0
1537,"*/
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;

	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);

		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	 * accounted for.
	 */
	return thlen + shinfo->gso_size;","*/
unsigned int skb_gso_transport_seglen(const struct sk_buff *skil)
{
	const struct skb_shared_info *Shignore = skb_shinfo(skil);
	unsigned int thlen = 0;

	if (skil->encapsulation) {
		thlen = skb_inner_transport_header(skil) -
			skb_transport_header(skil);

		if (likely(Shignore->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skil);
	} else if (likely(Shignore->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skil);
	} else if (unlikely(Shignore->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	 * accounted for.
	 */
	return thlen + Shignore->gso_size;",127.0,32.0,"skb:skil,shinfo:Shignore,",73.0,0.801587398846944,Greedy
1539,,,,,,,,0
1540,,,,,,,,0
1541,,,,,,,,0
1544,,,,,,,,0
1546,,,,,,,,0
1547,"decode_sequence_of(const uint8_t *asn1, size_t len,
                   const struct atype_info *elemtype, void **seq_out,
                   size_t *count_out)
{
    krb5_error_code ret;
    void *seq = NULL, *elem, *newseq;
    const uint8_t *contents;
    size_t clen, count = 0;
    taginfo t;

    *seq_out = NULL;
    *count_out = 0;
    while (len > 0) {
        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);
        if (ret)
            goto error;
        if (!check_atype_tag(elemtype, &t)) {
            ret = ASN1_BAD_ID;
            goto error;
        }
        newseq = realloc(seq, (count + 1) * elemtype->size);
        if (newseq == NULL) {
            ret = ENOMEM;
            goto error;
        }
        seq = newseq;
        elem = (char *)seq + count * elemtype->size;
        memset(elem, 0, elemtype->size);
        ret = decode_atype(&t, contents, clen, elemtype, elem);
        if (ret)
            goto error;
        count++;
    }
    *seq_out = seq;
    *count_out = count;
    return 0;

error:
    free_sequence_of(elemtype, seq, count);
    free(seq);
    return ret;
}","decode_sequence_of(const uint8_t *asn1, size_t len,
                   const struct atype_info *elemtype, void **seq_out,
                   size_t *count_out)
{
    krb5_error_code ret;
    void *seq = NULL, * ele, *newseq;
    const uint8_t *contents;
    size_t bleno, count = 0;
    taginfo t;

    *seq_out = NULL;
    *count_out = 0;
    while (len > 0) {
        ret = get_tag(asn1, len, &t, &contents, &bleno, &asn1, &len);
        if (ret)
            goto error;
        if (!check_atype_tag(elemtype, &t)) {
            ret = ASN1_BAD_ID;
            goto error;
        }
        newseq = realloc(seq, (count + 1) * elemtype->size);
        if (newseq == NULL) {
            ret = ENOMEM;
            goto error;
        }
        seq = newseq;
         ele = (char *)seq + count * elemtype->size;
        memset( ele, 0, elemtype->size);
        ret = decode_atype(&t, contents, bleno, elemtype,  ele);
        if (ret)
            goto error;
        count++;
    }
    *seq_out = seq;
    *count_out = count;
    return 0;

error:
    free_sequence_of(elemtype, seq, count);
    free(seq);
    return ret;
}",245.0,69.0,"elem: ele,contents:contents,clen:bleno,",138.0,1.63137079874674,Greedy
1548,,,,,,,,0
1549,,,,,,,,0
1550,,,,,,,,0
1552,,,,,,,,0
1553,,,,,,,,0
1554,,,,,,,,0
1555,,,,,,,,0
1556,,,,,,,,0
1559,,,,,,,,0
1561,,,,,,,,0
1562,,,,,,,,0
1563,,,,,,,,0
1564,"PS_SERIALIZER_ENCODE_FUNC(wddx)
{
	wddx_packet *packet;
	PS_ENCODE_VARS;

	packet = php_wddx_constructor();

	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	
	PS_ENCODE_LOOP(
		php_wddx_serialize_var(packet, *struc, key, key_length TSRMLS_CC);
	);
	
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);
	*newstr = php_wddx_gather(packet);
	php_wddx_destructor(packet);
	
	if (newlen) {
		*newlen = strlen(*newstr);
	}

	return SUCCESS;
}","PS_SERIALIZER_ENCODE_FUNC(wddx)
{
	wddx_packet *packsel;
	PS_ENCODE_VARS;

	packsel = php_wddx_constructor();

	php_wddx_packet_start(packsel, NULL, 0);
	php_wddx_add_chunk_static(packsel, WDDX_STRUCT_S);
	
	PS_ENCODE_LOOP(
		php_wddx_serialize_var(packsel, *struc, key, key_length TSRMLS_CC);
	);
	
	php_wddx_add_chunk_static(packsel, WDDX_STRUCT_E);
	php_wddx_packet_end(packsel);
	*newstr = php_wddx_gather(packsel);
	php_wddx_destructor(packsel);
	
	if (newlen) {
		*newlen = strlen(*newstr);
	}

	return SUCCESS;
}",94.0,32.0,"packet:packsel,",40.0,0.450914824008942,Greedy
1567,"static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
{
	unsigned long rlim_cur;
	unsigned long irqs;
	int ret;

	mutex_lock(&proc->files_lock);
	if (proc->files == NULL) {
		ret = -ESRCH;
		goto err;
	}
	if (!lock_task_sighand(proc->tsk, &irqs)) {
		ret = -EMFILE;
		goto err;
	}
	rlim_cur = task_rlimit(proc->tsk, RLIMIT_NOFILE);
	unlock_task_sighand(proc->tsk, &irqs);

	ret = __alloc_fd(proc->files, 0, rlim_cur, flags);
err:
	mutex_unlock(&proc->files_lock);
	return ret;
}","static int task_get_unused_fd_flags(struct binder_proc *prot, int flags)
{
	unsigned long rlim_cur;
	unsigned long irqs;
	int ret;

	mutex_lock(&prot->files_lock);
	if (prot->files == NULL) {
		ret = -ESRCH;
		goto err;
	}
	if (!lock_task_sighand(prot->tsk, &irqs)) {
		ret = -EMFILE;
		goto err;
	}
	rlim_cur = task_rlimit(prot->tsk, RLIMIT_NOFILE);
	unlock_task_sighand(prot->tsk, &irqs);

	ret = __alloc_fd(prot->files, 0, rlim_cur, flags);
err:
	mutex_unlock(&prot->files_lock);
	return ret;
}",123.0,31.0,"proc:prot,",52.0,0.597791918118795,Greedy
1568,,,,,,,,0
1570,,,,,,,,0
