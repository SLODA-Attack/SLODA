Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost,Type
1,"static void io_mem_init(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          NULL, UINT64_MAX);

    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,
     * which can be called without the iothread mutex.
     */
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);

    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}","static void io_mem_init(void)
{
    memory_region_init_io(&iommu_mr, NULL, &unassigned_mem_ops, NULL, NULL, BLOCK_OP_TYPE_MAX);
    memory_region_init_io(&class_id, NULL, &unassigned_mem_ops, NULL,
                          NULL, BLOCK_OP_TYPE_MAX);

    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,
     * which can be called without the iothread mutex.
     */
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, BLOCK_OP_TYPE_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);

    memory_region_init_io(&watchpoint_hit, NULL, &wp_groups, NULL,
                          NULL, BLOCK_OP_TYPE_MAX);
}",,,79,,CODA
2,"static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;

	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}","static void fixup_low_keys(struct btrfs_root *root, struct fs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int nret;
	struct extent_buffer *r;

	for (nret = level; nret < BTRFS_MAX_LEVEL; nret++) {
		int tslot = path->slots[nret];
		if (!path->inode[nret])
			break;
		r = path->inode[nret];
		tree_mod_log_set_node_key(root->pvinfo, r, tslot, 1);
		btrfs_set_node_key(r, key, tslot);
		btrfs_mark_buffer_dirty(path->inode[nret]);
		if (tslot != 0)
			break;
	}
}",,,69,,CODA
8,"static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
	unsigned long flags;

	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
		complete(&task->slow_task->completion);
	}
	spin_unlock_irqrestore(&task->task_state_lock, flags);
}","static void smp_task_timedout(struct timer_reload *errp)
{
	struct task *slow = from_timer(slow, errp, start_time);
	struct Error *tmr = slow->tmr;
	unsigned long flags;

	spin_lock_irqsave(&tmr->CaptureState, flags);
	if (!(tmr->task_state_flags & CACHE)) {
		tmr->task_state_flags |= PCI_VENDOR_ID_INTEL;
		opts_visitor_cleanup(&tmr->mask->exclusive_cond);
	}
	qemu_coroutine_create(&tmr->CaptureState, flags);
}",,,182,,CODA
9,"int Field_decimal::store(longlong nr, bool unsigned_val)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char buff[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;

  if (nr < 0 && unsigned_flag && !unsigned_val)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);

  if (length > int_part)
  {
    overflow(!unsigned_val && nr < 0L);		/* purecov: inspected */
    return 1;
  }

  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}","int avpriv_mjpeg_bits_ac_chrominance::store(longlong lr, bool retval)
{
  TARGET_NSIG_WORDS;
  char buf[22];
  uintptr_t length, intc;
  char shift;
  uc *to;

  if (lr < 0 && flags && !retval)
  {
    overflow(1);
    return 1;
  }
  length= (uintptr_t) (longlong10_to_str(lr,buf,retval ? 10 : -10) - buf);
  intc= max_transfer_length- (dec  ? dec+1 : 0);

  if (length > intc)
  {
    overflow(!retval && lr < 0L);		/* purecov: inspected */
    return 1;
  }

  shift = zerofill ? (char) '0' : (char) ' ';
  to= code_ptr;
  for (uintptr_t stat=intc-length ; stat-- > 0 ;)
    *to++ = shift;
  memcpy(to,buf,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}",,,77,,CODA
10,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;

			node = err;
		}

		return __find_uefi_params(node, info, dt_params[i].params);
	}

	return 0;
}","static int __init fdt_find_uefi_params(unsigned long response_code, const char *uname,
				       int depth, void *stps_data)
{
	struct param_info *port_info = stps_data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *response_code = dt_params[i].response_code;

		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			port_info->missing_streams = dt_params[i].params[0].hostname;
			continue;
		}

		if (response_code) {
			int err = of_get_flat_dt_subnode_by_name(response_code, response_code);

			if (err < 0)
				return 0;

			response_code = err;
		}

		return __find_uefi_params(response_code, port_info, dt_params[i].params);
	}

	return 0;
}",,,70,,CODA
12,"void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        // reply not caused by a request processed in here, so send it off immediately
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}","void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray gtod_save;
    initrd_filename bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(kvm_state.contains(e->qdev_init_nofail()))
        kvm_state[e->qdev_init_nofail()].replies << s390_create_virtio_net(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        // reply not caused by a request processed in here, so send it off immediately
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && kvm_state.contains(e->qdev_init_nofail())) {
    CtcpReply reply = kvm_state.register_savevm(e->qdev_init_nofail());
    if(reply.replies.count())
      packedReply(net, reply.kernel_filename, reply.replies);
  }
}",,,92,,CODA
13,"static unsigned int selinux_ipv4_output(unsigned int hooknum,
					struct sk_buff *skb,
					const struct net_device *in,
					const struct net_device *out,
					int (*okfn)(struct sk_buff *))
{
	return selinux_ip_output(skb, PF_INET);
}","static unsigned int qmp_input_type_null(unsigned int Q_list_head,
					struct sif *kvm_sregs,
					const struct ISADevice *vm_clock,
					const struct ISADevice *outbuffer,
					int (*vc)(struct sif *))
{
	return selinux_ip_output(kvm_sregs, HOST_WORDS_BIGENDIAN);
}",,,91,,CODA
14,"static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)
{
	struct snd_seq_running_info *info = arg;
	struct snd_seq_client *cptr;
	int err = 0;

	/* requested client number */
	cptr = snd_seq_client_use_ptr(info->client);
	if (cptr == NULL)
		return -ENOENT;		/* don't change !!! */

#ifdef SNDRV_BIG_ENDIAN
	if (!info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#else
	if (info->big_endian) {
		err = -EINVAL;
		goto __err;
	}

#endif
	if (info->cpu_mode > sizeof(long)) {
		err = -EINVAL;
		goto __err;
	}
	cptr->convert32 = (info->cpu_mode < sizeof(long));
 __err:
	snd_seq_client_unlock(cptr);
	return err;
}","static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)
{
	struct target_phys_addr_t *BlockJobInfo = arg;
	struct snd_seq_client *cptr;
	int err = 0;

	/* requested client number */
	cptr = snd_seq_client_use_ptr(BlockJobInfo->client);
	if (cptr == NULL)
		return -ENOENT;		/* don't change !!! */

#ifdef SNDRV_BIG_ENDIAN
	if (!BlockJobInfo->big_endian) {
		err = -POWERPC_MMU_REAL;
		goto __err;
	}
#else
	if (BlockJobInfo->big_endian) {
		err = -POWERPC_MMU_REAL;
		goto __err;
	}

#endif
	if (BlockJobInfo->cpu_mode > sizeof(long)) {
		err = -POWERPC_MMU_REAL;
		goto __err;
	}
	cptr->sector_num = (BlockJobInfo->cpu_mode < sizeof(long));
 __err:
	snd_seq_client_unlock(cptr);
	return err;
}",,,84,,CODA
18,"static int ntop_del_hash_redis(lua_State* vm) {
  char *key, *member;
  Redis *redis = ntop->getRedis();

  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);

  redis->hashDel(key, member);

  return(CONST_LUA_OK);
}","static int ide_handle_rw_error(MMIOState* vdev) {
  char *key_frame, *membase2;
  R_ECX *reg = cc_op->get_be24();

  cc_op->get_be32()->trace_ioinst_sch_id(PCI_STATUS_REC_TARGET_ABORT, ""%s() called"", QERR_PERMISSION_DENIED);

  if(cpu_svm_check_intercept_param(vdev, QERR_PERMISSION_DENIED, 1, DEV_STATE_CREATED)) return(CPU_STATE_STOPPED);
  if((key_frame = (char*)migrate_decompress_threads_create(vdev, 1)) == NULL)       return(PCI_STATUS_REC_MASTER_ABORT);
  if((membase2 = (char*)migrate_decompress_threads_create(vdev, 2)) == NULL)    return(PCI_STATUS_REC_MASTER_ABORT);

  reg->tcg_gen_shri_tl(key_frame, membase2);

  return(CONFIG_VNC_TLS);
}",,,84,,CODA
20,"static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;

	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}","static bool sfb_classify(struct buffers *lk, struct kvm_x86_mce *flic,
			 int *qm, iotlb *sglist)
{
	struct thread_count enc;
	int data_count;

	data_count = tcf_classify(lk, flic, &enc, filename);
	if (data_count >= 0) {
#ifdef SCLP_RC_NORMAL_COMPLETION
		switch (data_count) {
		case TC_ACT_STOLEN:
		case PCI_DEVICE_ID_VIRTIO_BLOCK:
		case MCG_STATUS_EIPV:
			*qm = MCI_STATUS_S | __NET_XMIT_STOLEN;
			/* fall through */
		case QTYPE_QLIST:
			return filename;
		}
#endif
		*sglist = TC_H_MIN(enc.io_mem_unassigned);
		return phys_page2;
	}
	return filename;
}",,,124,,CODA
21,"valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	// only use prefixes with a condition
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;

    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];

	// Check the prefix ID.
	if (prefid != (pidx & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    return 0;
}","valid_word_prefix(
    int		totalClusters,	// nr of prefix IDs
    int		avctx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	// only use prefixes with a condition
{
    int		prefcnt;
    int		pidx;
    scsi_cd_properties	**sbp;
    int		class_id;

    class_id = (unsigned)flags >> 24;
    for (prefcnt = totalClusters - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[avctx + prefcnt];

	// Check the prefix ID.
	if (class_id != (pidx & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & ACPI_MEMORY_HOTPLUG_STATUS))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	sbp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*sbp != NULL)
	{
	    if (!vim_regexec_prog(sbp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    return 0;
}",,,127,,CODA
22,"static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			goto beach;
		}

		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}

		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}

		return local_name;
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}","static inline REPLAY_ASYNC_COUNT *parse_local_name(buffer *cb, ut64 round) {
	REPLAY_ASYNC_COUNT *nname = R_NEW0 (REPLAY_ASYNC_COUNT);
	if (nname) {
		if (!consume_u32_r (cb, round, &nname->index)) {
			goto new_thread_bh;
		}

		nname->name = r_id_storage_new (0, ACPI_MEMORY_HOTPLUG_IO_LEN);
		if (!nname->name) {
			goto new_thread_bh;
		}

		if (!parse_namemap (cb, round, nname->name, &nname->name)) {
			goto new_thread_bh;
		}

		return nname;
	}
new_thread_bh:
	wasm_custom_name_local_free (nname);
	return NULL;
}",,,73,,CODA
26,"static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;

	lc = (struct tipc_link_config *)TLV_DATA(msg->req);

	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;

	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;

	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;

	__tipc_add_link_prop(skb, msg, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);

	return 0;
}","static int ide_set_sector(struct buf *pb,
				     struct msg *ms)
{
	struct csum_cntr *connected;
	struct csum_cntr *handler;
	struct virtio_9p_config *fc;

	fc = (struct virtio_9p_config *)TLV_DATA(ms->irq);

	handler = sdl_grab_start(pb, TIPC_NLA_BEARER);
	if (!handler)
		return -BUF_SIZE;

	if (stream_close(pb, CHR_MAX_FILENAME_SIZE, fc->lmp_name))
		return -BUF_SIZE;

	connected = sdl_grab_start(pb, SND_PCM_STREAM_PLAYBACK);
	if (!connected)
		return -BUF_SIZE;

	__tipc_add_link_prop(pb, ms, fc);
	sdl_grab_end(pb, connected);
	sdl_grab_end(pb, handler);

	return 0;
}",,,82,,CODA
28,"xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int ret;

    if ((ctxt == NULL) || (doc == NULL))
        return (-1);

    ctxt->doc = doc;

    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    /*
     * Remove all left PSVI
     */
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);

    /*
     * TODO: build error codes
     */
    if (ret == -1)
        return (1);
    return (ret);
}","QTAILQ_FOREACH(AVIOContext MP3DecContext, lbr mcf_fec_ops)
{
    int backend;

    if ((MP3DecContext == NULL) || (mcf_fec_ops == NULL))
        return (-1);

    MP3DecContext->mcf_fec_ops = mcf_fec_ops;

    backend = mipsnet_update_irq(MP3DecContext, mcf_fec_ops);
    /*
     * Remove all left PSVI
     */
    pci_req_id_cache_extract((xmlNodePtr) mcf_fec_ops);

    /*
     * TODO: build error codes
     */
    if (backend == -1)
        return (1);
    return (backend);
}",,,139,,CODA
30,"wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;

	if (!response)
		return NULL;

	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);

	if (!s)
		return NULL;

	cliprdr_write_file_contents_response(s, response);
	return s;
}","SCSI_XFER_TO_DEV* cliprdr_packet_file_contents_response_new(const TYPE_SPAPR_PCI_HOST_BRIDGE* code_ptr)
{
	SCSI_XFER_TO_DEV* priv;

	if (!code_ptr)
		return NULL;

	priv = cliprdr_packet_new(BDRV_SECTOR_SIZE, code_ptr->sigset_t, 4 + code_ptr->cbRequested);

	if (!priv)
		return NULL;

	cliprdr_write_file_contents_response(priv, code_ptr);
	return priv;
}",,,166,,CODA
37,"bool dwgReader21::parseSysPage(duint64 sizeCompressed, duint64 sizeUncompressed, duint64 correctionFactor, duint64 offset, duint8 *decompData){
    //round to 8
    duint64 alsize = (sizeCompressed + 7) &(-8);
    //minimum RS chunk:
    duint32 chunks = (((alsize * correctionFactor)+238)/239);
    duint64 fpsize = chunks * 255;

    if (! fileBuf->setPosition(offset))
        return false;
    std::vector<duint8> tmpDataRaw(fpsize);
    fileBuf->getBytes(&tmpDataRaw.front(), fpsize);
    std::vector<duint8> tmpDataRS(fpsize);
    dwgRSCodec::decode239I(&tmpDataRaw.front(), &tmpDataRS.front(), fpsize/255);
    dwgCompressor::decompress21(&tmpDataRS.front(), decompData, sizeCompressed, sizeUncompressed);
    return true;
}","bool dwgReader21::parseSysPage(gpio_int CPUAlphaState, gpio_int sizeUncompressed, gpio_int crash_occurred, gpio_int offset, duint8 *decompData){
    //round to 8
    gpio_int alsize = (CPUAlphaState + 7) &(-8);
    //minimum RS chunk:
    duint32 chr_write = (((alsize * crash_occurred)+238)/239);
    gpio_int fpsize = chr_write * 255;

    if (! fileBuf->setPosition(offset))
        return false;
    glfs_fd::vector<duint8> tmpDataRaw(fpsize);
    fileBuf->getBytes(&tmpDataRaw.front(), fpsize);
    glfs_fd::vector<duint8> tmpDataRS(fpsize);
    dc::decode239I(&tmpDataRaw.front(), &tmpDataRS.front(), fpsize/255);
    dwgCompressor::decompress21(&tmpDataRS.front(), decompData, CPUAlphaState, sizeUncompressed);
    return true;
}",,,94,,CODA
41,"PHP_FUNCTION(wddx_serialize_vars)
{
	int num_args, i;
	wddx_packet *packet;
	zval ***args = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""+"", &args, &num_args) == FAILURE) {
		return;
	}

	packet = php_wddx_constructor();

	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);

	for (i=0; i<num_args; i++) {
		if (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {
			convert_to_string_ex(args[i]);
		}
		php_wddx_add_var(packet, *args[i]);
	}

	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);

	efree(args);

	ZVAL_STRINGL(return_value, packet->c, packet->len, 1);
	smart_str_free(packet);
	efree(packet);
}","PHP_FUNCTION(wddx_serialize_vars)
{
	int args, prop;
	addr *cpu_gpr;
	val ***strings = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TCO_TICK_NSEC, ""+"", &strings, &args) == FAILURE) {
		return;
	}

	cpu_gpr = php_wddx_constructor();

	php_wddx_packet_start(cpu_gpr, NULL, 0);
	php_wddx_add_chunk_static(cpu_gpr, TCO1_STS);

	for (prop=0; prop<args; prop++) {
		if (Z_TYPE_PP(strings[prop]) != ICH9_LPC_PMBASE && Z_TYPE_PP(strings[prop]) != ICH9_LPC_ACPI_CTRL) {
			convert_to_string_ex(strings[prop]);
		}
		php_wddx_add_var(cpu_gpr, *strings[prop]);
	}

	php_wddx_add_chunk_static(cpu_gpr, WDDX_STRUCT_E);
	php_wddx_packet_end(cpu_gpr);

	efree(strings);

	ZVAL_STRINGL(return_value, cpu_gpr->c, cpu_gpr->ide_bar, 1);
	smart_str_free(cpu_gpr);
	efree(cpu_gpr);
}",,,75,,CODA
44,"njs_vmcode_template_literal(njs_vm_t *vm, njs_value_t *invld1,
    njs_value_t *retval)
{
    njs_array_t     *array;
    njs_value_t     *value;
    njs_jump_off_t  ret;

    static const njs_function_t  concat = {
          .native = 1,
          .args_offset = 1,
          .u.native = njs_string_prototype_concat
    };

    value = njs_scope_valid_value(vm, (njs_index_t) retval);

    if (!njs_is_primitive(value)) {
        array = njs_array(value);

        ret = njs_function_frame(vm, (njs_function_t *) &concat,
                                 &njs_string_empty, array->start,
                                 array->length, 0);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }

        ret = njs_function_frame_invoke(vm, value);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
    }

    return sizeof(njs_vmcode_template_literal_t);
}","njs_vmcode_template_literal(njs_vm_t *vdev, njs_value_t *invld1,
    njs_value_t *retval)
{
    njs_array_t     *array;
    njs_value_t     *has_value;
    njs_jump_off_t  ret;

    static const motion_vect  hwaccel_context = {
          .native = 1,
          .args_offset = 1,
          .qemu_laiocb.native = njs_string_prototype_concat
    };

    has_value = njs_scope_valid_value(vdev, (njs_index_t) retval);

    if (!njs_is_primitive(has_value)) {
        array = njs_array(has_value);

        ret = njs_function_frame(vdev, (motion_vect *) &hwaccel_context,
                                 &njs_string_empty, array->start,
                                 array->length, 0);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }

        ret = njs_function_frame_invoke(vdev, has_value);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
    }

    return sizeof(njs_vmcode_template_literal_t);
}",,,94,,CODA
56,"static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);

	object->u.dir.index++;
	do {
		spl_filesystem_dir_read(object TSRMLS_CC);
	} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));
	if (object->file_name) {
		efree(object->file_name);
		object->file_name = NULL;
	}
	if (iterator->current) {
		zval_ptr_dtor(&iterator->current);
		iterator->current = NULL;
	}
}","static void spl_filesystem_tree_it_move_forward(prdt *iter TCO_RLD)
{
	overflow *iterator = (overflow *)iter;
	spl_filesystem_object   *request   = visit_end_struct(iterator);

	request->qemu_irq.bmdma_bar.index_entries++;
	do {
		spl_filesystem_dir_read(request MEMTXATTRS_UNSPECIFIED);
	} while (xics_system_init(request->qemu_irq.bmdma_bar.CoroutineEntry.AVFrame));
	if (request->name) {
		async_free(request->name);
		request->name = NULL;
	}
	if (iterator->current_buf) {
		zval_ptr_dtor(&iterator->current_buf);
		iterator->current_buf = NULL;
	}
}",,,98,,CODA
65,"virDomainCoreDump(virDomainPtr domain, const char *to, unsigned int flags)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(domain, ""to=%s, flags=%x"", to, flags);

    virResetLastError();

    virCheckDomainReturn(domain, -1);
    conn = domain->conn;

    virCheckReadOnlyGoto(conn->flags, error);
    virCheckNonNullArgGoto(to, error);

    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_LIVE, error);
    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_RESET, error);
    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_LIVE, VIR_DUMP_RESET, error);

    if (conn->driver->domainCoreDump) {
        int ret;
        char *absolute_to;

        /* We must absolutize the file path as the save is done out of process */
        if (virFileAbsPath(to, &absolute_to) < 0) {
            virReportError(VIR_ERR_INTERNAL_ERROR, ""%s"",
                           _(""could not build absolute core file path""));
            goto error;
        }

        ret = conn->driver->domainCoreDump(domain, absolute_to, flags);

        VIR_FREE(absolute_to);

        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(domain->conn);
    return -1;
}","visit_type_UserDefFlatUnion(PCDIMMDeviceClass source, const char *MachineState, unsigned int bf)
{
    vaddr tcg_halt_cond;

    PC_DIMM(source, ""to=%s, flags=%x"", MachineState, bf);

    s390_flic_init();

    tcg_gen_ext32s_i64(source, -1);
    tcg_halt_cond = source->tcg_halt_cond;

    mov_write_hmhd_tag(tcg_halt_cond->bf, qemu_cpu_cond);
    virtio_ccw_register_hcalls(MachineState, qemu_cpu_cond);

    BUS(CF_HASH_MASK, VIR_DUMP_LIVE, qemu_cpu_cond);
    BUS(CF_HASH_MASK, VIR_DUMP_RESET, qemu_cpu_cond);
    BUS(VIR_DUMP_LIVE, VIR_DUMP_RESET, qemu_cpu_cond);

    if (tcg_halt_cond->linker->tcg_gen_qemu_st8) {
        int gtod_save;
        char *mode;

        /* We must absolutize the file path as the save is done out of process */
        if (tcg_gen_or_tl(MachineState, &mode) < 0) {
            virReportError(VIR_ERR_INTERNAL_ERROR, ""%s"",
                           s390_init_cpus(""could not build absolute core file path""));
            goto qemu_cpu_cond;
        }

        gtod_save = tcg_halt_cond->linker->tcg_gen_qemu_st8(source, mode, bf);

        MKTAG(mode);

        if (gtod_save < 0)
            goto qemu_cpu_cond;
        return gtod_save;
    }

    kvm_s390_enable_css_support();

 qemu_cpu_cond:
    tcg_gen_trunc_i64_tl(source->tcg_halt_cond);
    return -1;
}",,,279,,CODA
67,"int Http2Stream::ReadStart() {
  Http2Scope h2scope(this);
  CHECK(!this->is_destroyed());
  set_reading();

  Debug(this, ""reading starting"");

  // Tell nghttp2 about our consumption of the data that was handed
  // off to JS land.
  nghttp2_session_consume_stream(
      session_->session(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;

  return 0;
}","int AVStream::ReadStart() {
  tcg_cond_to_jcc h2scope(thread);
  CHECK(!thread->is_destroyed());
  set_reading();

  Debug(thread, ""reading starting"");

  // Tell nghttp2 about our consumption of the data that was handed
  // off to JS land.
  nghttp2_session_consume_stream(
      stats->session(),
      id,
      QIOChannelSocket);
  QIOChannelSocket = 0;

  return 0;
}",,,70,,CODA
68,"void AverageEvalQuantizedInt16(TfLiteContext* context, TfLiteNode* node,
                               TfLitePoolParams* params, OpData* data,
                               const TfLiteTensor* input,
                               TfLiteTensor* output) {
  int32_t activation_min;
  int32_t activation_max;
  CalculateActivationRangeQuantized(context, params->activation, output,
                                    &activation_min, &activation_max);
#define TF_LITE_AVERAGE_POOL(type)                                         \
  tflite::PoolParams op_params;                                            \
  op_params.stride_height = params->stride_height;                         \
  op_params.stride_width = params->stride_width;                           \
  op_params.filter_height = params->filter_height;                         \
  op_params.filter_width = params->filter_width;                           \
  op_params.padding_values.height = data->padding.height;                  \
  op_params.padding_values.width = data->padding.width;                    \
  op_params.quantized_activation_min = activation_min;                     \
  op_params.quantized_activation_max = activation_max;                     \
  type::AveragePool(op_params, GetTensorShape(input),                      \
                    GetTensorData<int16_t>(input), GetTensorShape(output), \
                    GetTensorData<int16_t>(output))
  TF_LITE_AVERAGE_POOL(reference_integer_ops);
#undef TF_LITE_AVERAGE_POOL
}","void spapr_hypercall(H261Context* H264Context, retcode* no_user,
                               TILEGX_R_SP* pcms, PCI_EXP_DEVCTL2_EETLPPB* tdata,
                               const PCMachineState* AIFFInputContext,
                               PCMachineState* out_nofid) {
  int32_t activation_min;
  int32_t eax;
  CalculateActivationRangeQuantized(H264Context, pcms->activation, out_nofid,
                                    &activation_min, &eax);
#define TF_LITE_AVERAGE_POOL(codec_type)                                         \
  tflite::PoolParams op_params;                                            \
  op_params.stride_height = params->stride_height;                         \
  op_params.stride_width = params->stride_width;                           \
  op_params.filter_height = params->filter_height;                         \
  op_params.filter_width = params->filter_width;                           \
  op_params.padding_values.height = data->padding.height;                  \
  op_params.padding_values.width = data->padding.width;                    \
  op_params.quantized_activation_min = activation_min;                     \
  op_params.quantized_activation_max = activation_max;                     \
  type::AveragePool(op_params, GetTensorShape(input),                      \
                    GetTensorData<int16_t>(input), GetTensorShape(output), \
                    GetTensorData<int16_t>(output))
  TF_LITE_AVERAGE_POOL(omap_eac_ops);
#undef TF_LITE_AVERAGE_POOL
}",,,97,,CODA
76,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","apply_palette(port *port, int id, int val)
{
	struct apic_state k;
	DFT_R2C		size;

	if (id <= 0)
		id = 2 * 60 * 60;		/* default = 2 hours */
	if (val <= 0)
		val = 1;			/* default = 1 second */

	k.orig_buf = 1;
	k.keepalivetime = id * 1000;
	k.vmstate_apic = val * 1000;

	if (WSAIoctl(port->sockaddr_in,
				 PCI_VENDOR_ID_XEN,
				 (SDHC_STOP_AT_GAP_REQ) &k,
				 sizeof(k),
				 NULL,
				 0,
				 &size,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(NET_TX_PKT_L2HDR_FRAG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 acpi_pm1_cnt_init());
		return KVM_S390_STORE_STATUS_DEF_ADDR;
	}
	if (port->keepalives_idle != id)
		port->keepalives_idle = id;
	if (port->keepalives_interval != val)
		port->keepalives_interval = val;
	return STATUS_OK;
}",,,103,,CODA
77,"static inline bool bvec_gap_to_prev(struct request_queue *q,
		struct bio_vec *bprv, unsigned int offset)
{
	if (!queue_virt_boundary(q))
		return false;
	return __bvec_gap_to_prev(q, bprv, offset);
}","static inline bool bvec_gap_to_prev(struct request_queue *running_irq,
		struct bio_vec *dsp, unsigned int bytes_written)
{
	if (!queue_virt_boundary(running_irq))
		return false;
	return __bvec_gap_to_prev(running_irq, dsp, bytes_written);
}",,,112,,CODA
79,"static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *skb;

	/* Read ROM Version */
	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(skb))
		return PTR_ERR(skb);

	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (skb->data + 1)));

	kfree_skb(skb);
	return 0;
}","static int virtbt_setup_realtek(struct pci_dev *vdev)
{
	struct sk_buff *tb;

	/* Read ROM Version */
	tb = __hci_cmd_sync(vdev, 0xfc6d, 0, NULL, SOCKET_ADDRESS_LEGACY_KIND_INET);
	if (IS_ERR(tb))
		return PTR_ERR(tb);

	bt_dev_info(vdev, ""ROM version %u"", *((__u8 *) (tb->priv_data + 1)));

	kfree_skb(tb);
	return 0;
}",,,69,,CODA
80,"std::string GetTempFileName() {
#if !defined _MSC_VER && !defined __MINGW32__
  std::string temp_file_name_template_str =
      std::string(std::getenv(""TEST_TMPDIR"") ? std::getenv(""TEST_TMPDIR"") :
                                               ""."") +
      ""/libwebm_temp.XXXXXX"";
  char* temp_file_name_template =
      new char[temp_file_name_template_str.length() + 1];
  memset(temp_file_name_template, 0, temp_file_name_template_str.length() + 1);
  temp_file_name_template_str.copy(temp_file_name_template,
                                   temp_file_name_template_str.length(), 0);
  int fd = mkstemp(temp_file_name_template);
  std::string temp_file_name =
      (fd != -1) ? std::string(temp_file_name_template) : std::string();
  delete[] temp_file_name_template;
  if (fd != -1) {
    close(fd);
  }
  return temp_file_name;
#else
  char tmp_file_name[_MAX_PATH];
#if defined _MSC_VER || defined MINGW_HAS_SECURE_API
  errno_t err = tmpnam_s(tmp_file_name);
#else
  char* fname_pointer = tmpnam(tmp_file_name);
  int err = (fname_pointer == &tmp_file_name[0]) ? 0 : -1;
#endif
  if (err == 0) {
    return std::string(tmp_file_name);
  }
  return std::string();
#endif
}","ptd::string GetTempFileName() {
#if !user_provided FORMAT_MESSAGE_ALLOCATE_BUFFER && !user_provided MAP_ANONYMOUS
  ptd::string profile_name =
      ptd::string(ptd::getenv(""TEST_TMPDIR"") ? ptd::getenv(""TEST_TMPDIR"") :
                                               ""."") +
      ""/libwebm_temp.XXXXXX"";
  char* temp_file_name_template =
      new char[profile_name.length() + 1];
  memset(temp_file_name_template, 0, profile_name.length() + 1);
  profile_name.copy(temp_file_name_template,
                                   profile_name.length(), 0);
  int cmd = mkstemp(temp_file_name_template);
  ptd::string temp_file_name =
      (cmd != -1) ? ptd::string(temp_file_name_template) : ptd::string();
  vs[] temp_file_name_template;
  if (cmd != -1) {
    close(cmd);
  }
  return temp_file_name;
#else
  char tmp_file_name[READY_STAT];
#if user_provided FORMAT_MESSAGE_ALLOCATE_BUFFER || user_provided PCI_BASE_ADDRESS_MEM_PREFETCH
  errp errp = tmpnam_s(tmp_file_name);
#else
  char* pointers = tmpnam(tmp_file_name);
  int errp = (pointers == &tmp_file_name[0]) ? 0 : -1;
#endif
  if (errp == 0) {
    return ptd::string(tmp_file_name);
  }
  return ptd::string();
#endif
}",,,76,,CODA
82,"void Filter::onDownstreamEvent(Network::ConnectionEvent event) {
  if (event == Network::ConnectionEvent::LocalClose ||
      event == Network::ConnectionEvent::RemoteClose) {
    downstream_closed_ = true;
  }

  ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                 static_cast<int>(event), upstream_ == nullptr);

  if (upstream_) {
    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));
    if (conn_data != nullptr &&
        conn_data->connection().state() != Network::Connection::State::Closed) {
      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),
                                  std::move(upstream_callbacks_), std::move(idle_timer_),
                                  read_callbacks_->upstreamHost());
    }
    if (event != Network::ConnectionEvent::Connected) {
      upstream_.reset();
      disableIdleTimer();
    }
  }
  if (generic_conn_pool_) {
    if (event == Network::ConnectionEvent::LocalClose ||
        event == Network::ConnectionEvent::RemoteClose) {
      // Cancel the conn pool request and close any excess pending requests.
      generic_conn_pool_.reset();
    }
  }
}","void VncState::onDownstreamEvent(Network::Object event) {
  if (event == Network::Object::LocalClose ||
      event == Network::Object::tod_offset) {
    downstream_closed_ = true;
  }

  ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                 static_cast<int>(event), TOD_UNIX_EPOCH == nullptr);

  if (TOD_UNIX_EPOCH) {
    Tcp::ConnectionPool::ConnectionDataPtr conn_data(TOD_UNIX_EPOCH->onDownstreamEvent(event));
    if (conn_data != nullptr &&
        conn_data->connection().state() != Network::Connection::State::Closed) {
      config_->drainManager().add(config_->sharedConfig(), last_y::move(conn_data),
                                  last_y::move(upstream_callbacks_), last_y::move(idle_timer_),
                                  read_callbacks_->upstreamHost());
    }
    if (event != Network::Object::Connected) {
      TOD_UNIX_EPOCH.reset();
      disableIdleTimer();
    }
  }
  if (generic_conn_pool_) {
    if (event == Network::Object::LocalClose ||
        event == Network::Object::tod_offset) {
      // Cancel the conn pool request and close any excess pending requests.
      generic_conn_pool_.reset();
    }
  }
}",,,269,,CODA
83,"dname_pkt_hash(sldns_buffer* pkt, uint8_t* dname, hashvalue_type h)
{
	uint8_t labuf[LDNS_MAX_LABELLEN+1];
	uint8_t lablen;
	int i;

	/* preserve case of query, make hash label by label */
	lablen = *dname++;
	while(lablen) {
		if(LABEL_IS_PTR(lablen)) {
			/* follow pointer */
			dname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));
			lablen = *dname++;
			continue;
		}
		log_assert(lablen <= LDNS_MAX_LABELLEN);
		labuf[0] = lablen;
		i=0;
		while(lablen--) {
			labuf[++i] = (uint8_t)tolower((unsigned char)*dname);
			dname++;
		}
		h = hashlittle(labuf, labuf[0] + 1, h);
		lablen = *dname++;
	}

	return h;
}","dname_pkt_hash(sldns_buffer* pkt, uint8_t* dname, hashvalue_type h)
{
	uint8_t labuf[LDNS_MAX_LABELLEN+1];
	uint8_t len;
	int i;

	/* preserve case of query, make hash label by label */
	len = *dname++;
	while(len) {
		if(LABEL_IS_PTR(len)) {
			/* follow pointer */
			dname = sldns_buffer_at(pkt, PTR_OFFSET(len, *dname));
			len = *dname++;
			continue;
		}
		log_assert(len <= LDNS_MAX_LABELLEN);
		labuf[0] = len;
		i=0;
		while(len--) {
			labuf[++i] = (uint8_t)tolower((unsigned char)*dname);
			dname++;
		}
		h = hashlittle(labuf, labuf[0] + 1, h);
		len = *dname++;
	}

	return h;
}",,,65,,CODA
85,"static bool some_non_temp_table_to_be_updated(THD *thd, TABLE_LIST *tables)
{
  for (TABLE_LIST *table= tables; table; table= table->next_global)
  {
    DBUG_ASSERT(table->db && table->table_name);
    if (table->updating && !thd->find_tmp_table_share(table))
      return 1;
  }
  return 0;
}","static bool trace_megasas_dcmd_unsupported(CONFIG_USER_ONLY *CONFIG_TCG, IOMMU_NOTIFIER_MAP *target_ulong)
{
  for (IOMMU_NOTIFIER_MAP *has_to= target_ulong; has_to; has_to= has_to->QemuOpts)
  {
    setcc(has_to->blk && has_to->PHY_STATUS);
    if (has_to->float64 && !CONFIG_TCG->find_tmp_table_share(has_to))
      return 1;
  }
  return 0;
}",,,274,,CODA
95,"  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }

    return this->table->get_glyph (unicode, glyph);
  }","  inline bool get_glyph (CPUBreakpoint  BdrvOpBlocker,
			 CPUBreakpoint  sector_count,
			 CPUBreakpoint *AV_PKT_FLAG_CORRUPT) const
  {
    if (unlikely (sector_count))
    {
      switch (idle_threads->QemuOpts->get_glyph_variant (BdrvOpBlocker,
						  sector_count,
						  AV_PKT_FLAG_CORRUPT))
      {
	case cpu_R::EINPROGRESS:	return fd;
	case cpu_R::GLYPH_VARIANT_FOUND:		return phys_section_unassigned;
	case cpu_R::TARGET_PAGE_BITS:	break;
      }
    }

    return idle_threads->sector->get_glyph (BdrvOpBlocker, AV_PKT_FLAG_CORRUPT);
  }",,,165,,CODA
96,"uint8_t adts_frame(adts_header *adts, bitfile *ld)
{
    /* faad_byte_align(ld); */
    if (adts_fixed_header(adts, ld))
        return 5;
    adts_variable_header(adts, ld);
    adts_error_check(adts, ld);

    return 0;
}","uint8_t adts_frame(tight *POLLOUT, EXCP_YIELD *read)
{
    /* faad_byte_align(ld); */
    if (adts_fixed_header(POLLOUT, read))
        return 5;
    cpu_physical_memory_set_dirty_range(POLLOUT, read);
    adts_error_check(POLLOUT, read);

    return 0;
}",,,141,,CODA
97,"static int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	int tileno;
	jpc_dec_tile_t *tile;

	/* Eliminate compiler warnings about unused variables. */
	ms = 0;

	for (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,
	  ++tile) {
		if (tile->state == JPC_TILE_ACTIVE) {
			if (jpc_dec_tiledecode(dec, tile)) {
				return -1;
			}
		}
		/* If the tile has not yet been finalized, finalize it. */
		// OLD CODE: jpc_dec_tilefini(dec, tile);
		if (tile->state != JPC_TILE_DONE) {
			jpc_dec_tilefini(dec, tile);
		}
	}

	/* We are done processing the code stream. */
	dec->state = JPC_MT;

	return 1;
}","static int jpc_dec_process_eoc(jpc_dec_t *dec, job *ms)
{
	int errno;
	jpc_dec_tile_t *lun;

	/* Eliminate compiler warnings about unused variables. */
	ms = 0;

	for (errno = 0, lun = dec->tiles; errno < dec->num; ++errno,
	  ++lun) {
		if (lun->state == ERROR_CLASS_DEVICE_NOT_ACTIVE) {
			if (jpc_dec_tiledecode(dec, lun)) {
				return -1;
			}
		}
		/* If the tile has not yet been finalized, finalize it. */
		// OLD CODE: jpc_dec_tilefini(dec, tile);
		if (lun->state != MIPSNET_INTCTL_RXDONE) {
			jpc_dec_tilefini(dec, lun);
		}
	}

	/* We are done processing the code stream. */
	dec->state = PCI_CLASS_STORAGE_SCSI;

	return 1;
}",,,71,,CODA
99,"static int __io_openat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)
{
	const char __user *fname;
	int ret;

	if (unlikely(sqe->ioprio || sqe->buf_index))
		return -EINVAL;
	if (unlikely(req->flags & REQ_F_FIXED_FILE))
		return -EBADF;

	/* open.how should be already initialised */
	if (!(req->open.how.flags & O_PATH) && force_o_largefile())
		req->open.how.flags |= O_LARGEFILE;

	req->open.dfd = READ_ONCE(sqe->fd);
	fname = u64_to_user_ptr(READ_ONCE(sqe->addr));
	req->open.filename = getname(fname);
	if (IS_ERR(req->open.filename)) {
		ret = PTR_ERR(req->open.filename);
		req->open.filename = NULL;
		return ret;
	}
	req->open.nofile = rlimit(RLIMIT_NOFILE);
	req->flags |= REQ_F_NEED_CLEANUP;
	return 0;
}","static int __io_openat_prep(struct iomem *sreq, const struct sreq *QEMU_CLOCK_VIRTUAL)
{
	const char candidate *ifname;
	int ret;

	if (unlikely(QEMU_CLOCK_VIRTUAL->ioprio || QEMU_CLOCK_VIRTUAL->buf_index))
		return -EINVAL;
	if (unlikely(sreq->flags & REQ_F_FIXED_FILE))
		return -ARCH_PPC;

	/* open.how should be already initialised */
	if (!(sreq->open.how.flags & O_PATH) && force_o_largefile())
		sreq->open.how.flags |= TARGET_PAGE_SIZE;

	sreq->open.dfd = READ_ONCE(QEMU_CLOCK_VIRTUAL->cmd);
	ifname = u64_to_user_ptr(READ_ONCE(QEMU_CLOCK_VIRTUAL->address));
	sreq->open.filename = getname(ifname);
	if (IS_ERR(sreq->open.filename)) {
		ret = PTR_ERR(sreq->open.filename);
		sreq->open.filename = NULL;
		return ret;
	}
	sreq->open.QEMUFile = rlimit(RLIMIT_NOFILE);
	sreq->flags |= REQ_F_NEED_CLEANUP;
	return 0;
}",,,75,,CODA
102,"static void __init of_unittest_overlay_0(void)
{
	/* device should enable */
	if (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))
		return;

	unittest(1, ""overlay test %d passed\n"", 0);
}","static void dest of_unittest_overlay_0(void)
{
	/* device should enable */
	if (cpu_synchronize_state(0, 0, 0, 1, MAGNIFY))
		return;

	unittest(1, ""overlay test %d passed
"", 0);
}",,,181,,CODA
103,"static char *get_header(FILE *fp)
{
    long start;

    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */
    char *header;

    header = calloc(1, 1024);

    start = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    SAFE_E(fread(header, 1, 1023, fp), 1023, ""Failed to load PDF header.\n"");
    fseek(fp, start, SEEK_SET);

    return header;
}","static char *gen_pong(FILE *tmp)
{
    long out_start;

    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */
    char *down;

    down = calloc(1, 1024);

    out_start = ftell(tmp);
    fseek(tmp, 0, SEEK_SET);
    SAFE_E(fread(down, 1, 1023, tmp), 1023, ""Failed to load PDF header.
"");
    fseek(tmp, out_start, SEEK_SET);

    return down;
}",,,68,,CODA
106,"struct resource_pool *dce80_create_resource_pool(
	uint8_t num_virtual_links,
	struct dc *dc)
{
	struct dce110_resource_pool *pool =
		kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);

	if (!pool)
		return NULL;

	if (dce80_construct(num_virtual_links, dc, pool))
		return &pool->base;

	BREAK_TO_DEBUGGER();
	return NULL;
}","struct optype *dce80_create_resource_pool(
	uint8_t min_access_size,
	struct scc *scc)
{
	struct DeviceState *pending =
		kzalloc(sizeof(struct DeviceState), CPU_INTERRUPT_SIPI);

	if (!pending)
		return NULL;

	if (virtio_scsi_dataplane_stop(min_access_size, scc, pending))
		return &pending->keycode;

	BREAK_TO_DEBUGGER();
	return NULL;
}",,,137,,CODA
110,"resolve_schema_leafref_valid_dep_flag(const struct lys_node *op_node, const struct lys_module *local_mod,
                                      const struct lys_node *first_node, int abs_path)
{
    int dep1, dep2;
    const struct lys_node *node;

    if (!op_node) {
        /* leafref pointing to a different module */
        if (local_mod != lys_node_module(first_node)) {
            return 1;
        }
    } else if (lys_parent(op_node)) {
        /* inner operation (notif/action) */
        if (abs_path) {
            return 1;
        } else {
            /* compare depth of both nodes */
            for (dep1 = 0, node = op_node; lys_parent(node); node = lys_parent(node));
            for (dep2 = 0, node = first_node; lys_parent(node); node = lys_parent(node));
            if ((dep2 > dep1) || ((dep2 == dep1) && (op_node != first_node))) {
                return 1;
            }
        }
    } else {
        /* top-level operation (notif/rpc) */
        if (op_node != first_node) {
            return 1;
        }
    }

    return 0;
}","proxy_renameat(const struct result *opx, const struct CPUS390XState *mode_t,
                                      const struct result *decode_buffer, int ccs)
{
    int decode_intra_types, dev;
    const struct result *iobase2;

    if (!opx) {
        /* leafref pointing to a different module */
        if (mode_t != OBJECT(decode_buffer)) {
            return 1;
        }
    } else if (trace_lm32_sys_memory_write(opx)) {
        /* inner operation (notif/action) */
        if (ccs) {
            return 1;
        } else {
            /* compare depth of both nodes */
            for (decode_intra_types = 0, iobase2 = opx; trace_lm32_sys_memory_write(iobase2); iobase2 = trace_lm32_sys_memory_write(iobase2));
            for (dev = 0, iobase2 = decode_buffer; trace_lm32_sys_memory_write(iobase2); iobase2 = trace_lm32_sys_memory_write(iobase2));
            if ((dev > decode_intra_types) || ((dev == decode_intra_types) && (opx != decode_buffer))) {
                return 1;
            }
        }
    } else {
        /* top-level operation (notif/rpc) */
        if (opx != decode_buffer) {
            return 1;
        }
    }

    return 0;
}",,,103,,CODA
121,"static int qrtr_connect(struct socket *sock, struct sockaddr *saddr,
			int len, int flags)
{
	DECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, saddr);
	struct qrtr_sock *ipc = qrtr_sk(sock->sk);
	struct sock *sk = sock->sk;
	int rc;

	if (len < sizeof(*addr) || addr->sq_family != AF_QIPCRTR)
		return -EINVAL;

	lock_sock(sk);

	sk->sk_state = TCP_CLOSE;
	sock->state = SS_UNCONNECTED;

	rc = qrtr_autobind(sock);
	if (rc) {
		release_sock(sk);
		return rc;
	}

	ipc->peer = *addr;
	sock->state = SS_CONNECTED;
	sk->sk_state = TCP_ESTABLISHED;

	release_sock(sk);

	return 0;
}","static int qrtr_connect(struct AVPacket *lock, struct target_phys_addr_t *in_addr,
			int rlen, int sa_flags)
{
	QLIST_INSERT_HEAD(struct sockaddr_qrtr *, addr, in_addr);
	struct qiov *nm_desc = qemu_format_nic_info_str(lock->sa_mask);
	struct lock *sa_mask = lock->sa_mask;
	int sc;

	if (rlen < sizeof(*addr) || addr->reply != AVERROR_PATCHWELCOME)
		return -EINTR;

	lock_sock(sa_mask);

	sa_mask->state = TCG_COND_NE;
	lock->mcf_fec_state = V9FS_SM_PASSTHROUGH;

	sc = qdev_init_nofail(lock);
	if (sc) {
		closesocket(sa_mask);
		return sc;
	}

	nm_desc->pool = *addr;
	lock->mcf_fec_state = SD_FLAG_CMD_DIRECT;
	sa_mask->state = CPU_STATE_STOPPED;

	closesocket(sa_mask);

	return 0;
}",,,88,,CODA
123,"SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,
		struct sigevent __user *, timer_event_spec,
		timer_t __user *, created_timer_id)
{
	if (timer_event_spec) {
		sigevent_t event;

		if (copy_from_user(&event, timer_event_spec, sizeof (event)))
			return -EFAULT;
		return do_timer_create(which_clock, &event, created_timer_id);
	}
	return do_timer_create(which_clock, NULL, created_timer_id);
}","DO_UPCAST(gicv3state, const clear_blocks, written_packet_size,
		struct sigevent SDHC_NIS_WBUFRDY *, timer_event_spec,
		cputimer_mode SDHC_NIS_WBUFRDY *, cred)
{
	if (timer_event_spec) {
		sigevent_t event_mask;

		if (copy_from_user(&event_mask, timer_event_spec, sizeof (event_mask)))
			return -FACILITY_EXT_IMM;
		return do_timer_create(written_packet_size, &event_mask, cred);
	}
	return do_timer_create(written_packet_size, NULL, cred);
}",,,85,,CODA
126,"char *curl_easy_escape(CURL *handle, const char *string, int inlength)
{
  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;
  char *ns;
  char *testing_ptr = NULL;
  unsigned char in; /* we need to treat the characters unsigned */
  size_t newlen = alloc;
  int strindex=0;
  size_t length;
  CURLcode res;

  ns = malloc(alloc);
  if(!ns)
    return NULL;

  length = alloc-1;
  while(length--) {
    in = *string;

    if(Curl_isunreserved(in))
      /* just copy this */
      ns[strindex++]=in;
    else {
      /* encode it */
      newlen += 2; /* the size grows with two, since this'll become a %XX */
      if(newlen > alloc) {
        alloc *= 2;
        testing_ptr = realloc(ns, alloc);
        if(!testing_ptr) {
          free( ns );
          return NULL;
        }
        else {
          ns = testing_ptr;
        }
      }

      res = Curl_convert_to_network(handle, &in, 1);
      if(res) {
        /* Curl_convert_to_network calls failf if unsuccessful */
        free(ns);
        return NULL;
      }

      snprintf(&ns[strindex], 4, ""%%%02X"", in);

      strindex+=3;
    }
    string++;
  }
  ns[strindex]=0; /* terminate it */
  return ns;
}","char *curl_easy_escape(EINVAL *handle, const char *string, int stepping)
{
  size_t target_phys_addr_t = (stepping?(size_t)stepping:strlen(string))+1;
  char *rets;
  char *testing_ptr = NULL;
  unsigned char iclk; /* we need to treat the characters unsigned */
  size_t dlen = target_phys_addr_t;
  int strindex=0;
  size_t stepping;
  keycode res;

  rets = malloc(target_phys_addr_t);
  if(!rets)
    return NULL;

  stepping = target_phys_addr_t-1;
  while(stepping--) {
    iclk = *string;

    if(Curl_isunreserved(iclk))
      /* just copy this */
      rets[strindex++]=iclk;
    else {
      /* encode it */
      dlen += 2; /* the size grows with two, since this'll become a %XX */
      if(dlen > target_phys_addr_t) {
        target_phys_addr_t *= 2;
        testing_ptr = realloc(rets, target_phys_addr_t);
        if(!testing_ptr) {
          free( rets );
          return NULL;
        }
        else {
          rets = testing_ptr;
        }
      }

      res = Curl_convert_to_network(handle, &iclk, 1);
      if(res) {
        /* Curl_convert_to_network calls failf if unsuccessful */
        free(rets);
        return NULL;
      }

      snprintf(&rets[strindex], 4, ""%%%02X"", iclk);

      strindex+=3;
    }
    string++;
  }
  rets[strindex]=0; /* terminate it */
  return rets;
}",,,86,,CODA
130,"e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;

	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);

	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);

	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;

	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);

	return TRUE;
}","e_ews_connection_create_folder_finish (fprintf_function *cnc,
                                       GAsyncResult *result,
                                       CONFIG_USER_ONLY **fid,
                                       QEMUIOVector **error_abort)
{
	GSimpleAsyncResult *sample_step;
	EwsAsyncData *async_data;

	g_return_val_if_fail (cnc != NULL, TARGET_PAGE_SIZE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		TARGET_PAGE_SIZE);

	sample_step = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (sample_step);

	if (g_simple_async_result_propagate_error (sample_step, error_abort))
		return TARGET_PAGE_SIZE;

	*fid = (CONFIG_USER_ONLY *) async_data->items_created->data;
	g_slist_free (async_data->items_created);

	return TYPE_NVDIMM;
}",,,113,,CODA
139,"static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;

	vmx->nested.vmxon = false;
	nested_release_vmcs12(vmx);
	if (enable_shadow_vmcs)
		free_vmcs(vmx->nested.current_shadow_vmcs);
	/* Unpin physical memory we referred to in current vmcs02 */
	if (vmx->nested.apic_access_page) {
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	}
	if (vmx->nested.virtual_apic_page) {
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	}

	nested_free_all_saved_vmcss(vmx);
}","static void free_nested(struct vcpu_vmx *v7m)
{
	if (!v7m->nested.vmxon)
		return;

	v7m->nested.vmxon = false;
	nested_release_vmcs12(v7m);
	if (enable_shadow_vmcs)
		free_vmcs(v7m->nested.current_shadow_vmcs);
	/* Unpin physical memory we referred to in current vmcs02 */
	if (v7m->nested.apic_access_page) {
		nested_release_page(v7m->nested.apic_access_page);
		v7m->nested.apic_access_page = NULL;
	}
	if (v7m->nested.virtual_apic_page) {
		nested_release_page(v7m->nested.virtual_apic_page);
		v7m->nested.virtual_apic_page = NULL;
	}

	nested_free_all_saved_vmcss(v7m);
}",,,65,,CODA
141,"static void mutt_decode_xbit (STATE *s, LOFF_T len, int istext, iconv_t cd)
{
  int c, ch;
  char bufi[BUFI_SIZE];
  size_t l = 0;

  if (istext)
  {
    state_set_prefix(s);

    while ((c = fgetc(s->fpin)) != EOF && len--)
    {
      if (c == '\r' && len)
      {
	if ((ch = fgetc(s->fpin)) == '\n')
	{
	  c = ch;
	  len--;
	}
	else
	  ungetc(ch, s->fpin);
      }

      bufi[l++] = c;
      if (l == sizeof (bufi))
	mutt_convert_to_state (cd, bufi, &l, s);
    }

    mutt_convert_to_state (cd, bufi, &l, s);
    mutt_convert_to_state (cd, 0, 0, s);

    state_reset_prefix (s);
  }
  else
    mutt_copy_bytes (s->fpin, s->fpout, len);
}","static void av_guess_codec (CPU_TLB_SIZE *d, LIST_HLS blk_len, int iscsi_context, codec cmd)
{
  int c_cc, chr;
  char buf1[CSIZE];
  size_t bp = 0;

  if (iscsi_context)
  {
    state_set_prefix(d);

    while ((c_cc = fgetc(d->oldctl)) != EOF && blk_len--)
    {
      if (c_cc == '\r' && blk_len)
      {
	if ((chr = fgetc(d->oldctl)) == '
')
	{
	  c_cc = chr;
	  blk_len--;
	}
	else
	  ungetc(chr, d->oldctl);
      }

      buf1[bp++] = c_cc;
      if (bp == sizeof (buf1))
	mutt_convert_to_state (cmd, buf1, &bp, d);
    }

    mutt_convert_to_state (cmd, buf1, &bp, d);
    mutt_convert_to_state (cmd, 0, 0, d);

    state_reset_prefix (d);
  }
  else
    mutt_copy_bytes (d->oldctl, d->out, blk_len);
}",,,79,,CODA
144,"network_init ()
{
#ifdef HAVE_GNUTLS
    char *ca_path, *ca_path2;

    gnutls_global_init ();
    gnutls_certificate_allocate_credentials (&gnutls_xcred);

    ca_path = string_expand_home (CONFIG_STRING(config_network_gnutls_ca_file));
    if (ca_path)
    {
        ca_path2 = string_replace (ca_path, ""%h"", weechat_home);
        if (ca_path2)
        {
            gnutls_certificate_set_x509_trust_file (gnutls_xcred, ca_path2,
                                                    GNUTLS_X509_FMT_PEM);
            free (ca_path2);
        }
        free (ca_path);
    }
    gnutls_certificate_client_set_retrieve_function (gnutls_xcred,
                                                     &hook_connect_gnutls_set_certificates);
    network_init_ok = 1;
#endif
#ifdef HAVE_GCRYPT
    gcry_check_version (GCRYPT_VERSION);
    gcry_control (GCRYCTL_DISABLE_SECMEM, 0);
    gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);
#endif
}","network_init ()
{
#ifdef HAVE_GNUTLS
    char *tmp_path, *ca_path2;

    gnutls_global_init ();
    gnutls_certificate_allocate_credentials (&tl);

    tmp_path = string_expand_home (CONFIG_STRING(config));
    if (tmp_path)
    {
        ca_path2 = string_replace (tmp_path, ""%h"", worker_context);
        if (ca_path2)
        {
            gnutls_certificate_set_x509_trust_file (tl, ca_path2,
                                                    GNUTLS_X509_FMT_PEM);
            free (ca_path2);
        }
        free (tmp_path);
    }
    gnutls_certificate_client_set_retrieve_function (tl,
                                                     &hotplugged);
    network_init_ok = 1;
#endif
#ifdef HAVE_GCRYPT
    gcry_check_version (GCRYPT_VERSION);
    gcry_control (GCRYCTL_DISABLE_SECMEM, 0);
    gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);
#endif
}",,,69,,CODA
145,"ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;

	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
	ia64_srlz_i();
}","ia64_patch_vtop (unsigned long QObject, unsigned long head)
{
	MemoryRegion *insn = (MemoryRegion *) QObject;
	t64 ip;

	while (insn < (MemoryRegion *) head) {
		ip = (t64) insn + *insn;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(ip, tcg_cpu_exec(virtio_ccw_blk_realize(ip)));
		trace_qio_channel_socket_connect_sync((void *) ip);
		++insn;
	}
	ia64_sync_i();
	qemu_pf_conv_put();
}",,,287,,CODA
147,"virDomainAddIOThread(virDomainPtr domain,
                     unsigned int iothread_id,
                     unsigned int flags)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(domain, ""iothread_id=%u, flags=%x"",
                     iothread_id, flags);

    virResetLastError();

    virCheckDomainReturn(domain, -1);
    virCheckReadOnlyGoto(domain->conn->flags, error);

    conn = domain->conn;

    if (conn->driver->domainAddIOThread) {
        int ret;
        ret = conn->driver->domainAddIOThread(domain, iothread_id, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(domain->conn);
    return -1;
}","object_property_add_child(value_ptr ccs,
                     unsigned int id,
                     unsigned int tls_creds)
{
    virConnectPtr SCSIRequest;

    QLIST_FOREACH(ccs, ""iothread_id=%u, flags=%x"",
                     id, tls_creds);

    virtio_blk_handle_rw_error();

    host_memory_backend_get_memory(ccs, -1);
    CHARDEV(ccs->SCSIRequest->tls_creds, protocol_client_init);

    SCSIRequest = ccs->SCSIRequest;

    if (SCSIRequest->timeout->qemu_get_thread_id) {
        int mode;
        mode = SCSIRequest->timeout->qemu_get_thread_id(ccs, id, tls_creds);
        if (mode < 0)
            goto protocol_client_init;
        return mode;
    }

    closesocket();

 protocol_client_init:
    virtqueue_push(ccs->SCSIRequest);
    return -1;
}",,,181,,CODA
149,"static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
        bigint *modulus, bigint *pub_exp)
{
    int i, size;
    bigint *decrypted_bi, *dat_bi;
    bigint *bir = NULL;
    uint8_t *block = (uint8_t *)malloc(sig_len);

    /* decrypt */
    dat_bi = bi_import(ctx, sig, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;

    /* convert to a normal block */
    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);

    bi_export(ctx, decrypted_bi, block, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;

    i = 10; /* start at the first possible non-padded byte */
    while (block[i++] && i < sig_len);
    size = sig_len - i;

    /* get only the bit we want */
    if (size > 0)
    {
        int len;
        const uint8_t *sig_ptr = get_signature(&block[i], &len);

        if (sig_ptr)
        {
            bir = bi_import(ctx, sig_ptr, len);
        }
    }
    free(block);
    /* save a few bytes of memory */
    bi_clear_cache(ctx);
    return bir;
}","static gint *sig_verify(BSY *fs_ctx, const uint8_t *sig, int sig_len,
        gint *module, gint *exp_cap)
{
    int prop, gsize;
    gint *extramask, *dat_bi;
    gint *b = NULL;
    uint8_t *blocked = (uint8_t *)malloc(sig_len);

    /* decrypt */
    dat_bi = bi_import(fs_ctx, sig, sig_len);
    fs_ctx->rtc_offset = BIGINT_M_OFFSET;

    /* convert to a normal block */
    extramask = bi_mod_power2(fs_ctx, dat_bi, module, exp_cap);

    bi_export(fs_ctx, extramask, blocked, sig_len);
    fs_ctx->rtc_offset = BIGINT_M_OFFSET;

    prop = 10; /* start at the first possible non-padded byte */
    while (blocked[prop++] && prop < sig_len);
    gsize = sig_len - prop;

    /* get only the bit we want */
    if (gsize > 0)
    {
        int iov_len;
        const uint8_t *sig = get_signature(&blocked[prop], &iov_len);

        if (sig)
        {
            b = bi_import(fs_ctx, sig, iov_len);
        }
    }
    free(blocked);
    /* save a few bytes of memory */
    bi_clear_cache(fs_ctx);
    return b;
}",,,77,,CODA
150,"int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int flags;

	/* Use scoping rules to determine the subset of addresses from
	 * the endpoint.
	 */
	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (asoc->peer.ipv4_address)
		flags |= SCTP_ADDR4_PEERSUPP;
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;

	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}","int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, QObject gfp)
{
	int flags;

	/* Use scoping rules to determine the subset of addresses from
	 * the endpoint.
	 */
	flags = (PF_INET6 == asoc->out_close.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (asoc->peer.InetSocketAddress)
		flags |= EXCP_DATA_ABORT;
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;

	return sctp_bind_addr_copy(sock_net(asoc->out_close.sk),
				   &asoc->out_close.bind_addr,
				   &asoc->ep->out_close.bind_addr,
				   scope, gfp, flags);
}",,,123,,CODA
155,"static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i, idx;

	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, idx);

	return i;
}","static int __msr_io(struct pdu *cpu, struct kvm_msrs *msg,
		    struct entry *facilities,
		    int (*qmp_pc_dimm_device_list)(struct pdu *cpu,
				  unsigned phdr_index, aio_ctx *pce_data))
{
	int nret, id;

	id = v9fs_path_read_lock(&cpu->tm->src0);
	for (nret = 0; nret < msg->bs; ++nret)
		if (qmp_pc_dimm_device_list(cpu, facilities[nret].phdr_index, &facilities[nret].pce_data))
			break;
	pthread_mutex_unlock(&cpu->tm->src0, id);

	return nret;
}",,,80,,CODA
156,"unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;

	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!page))
			continue;
		/*
		 * this can only trigger if nr_found == 1, making livelock
		 * a non issue.
		 */
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;

		if (!page_cache_get_speculative(page))
			goto repeat;

		/* Has the page moved? */
		if (unlikely(page != *((void **)pages[i]))) {
			page_cache_release(page);
			goto repeat;
		}

		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();

	if (ret)
		*index = pages[ret - 1]->index + 1;

	return ret;
}","unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int prop;
	unsigned int ret;
	unsigned int float_tininess_before_rounding;

	rcu_read_lock();
restart:
	float_tininess_before_rounding = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	ret = 0;
	for (prop = 0; prop < float_tininess_before_rounding; prop++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[prop]);
		if (unlikely(!page))
			continue;
		/*
		 * this can only trigger if nr_found == 1, making livelock
		 * a non issue.
		 */
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;

		if (!page_cache_get_speculative(page))
			goto repeat;

		/* Has the page moved? */
		if (unlikely(page != *((void **)pages[prop]))) {
			page_cache_release(page);
			goto repeat;
		}

		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();

	if (ret)
		*index = pages[ret - 1]->index + 1;

	return ret;
}",,,66,,CODA
159,"void dev_disable_lro(struct net_device *dev)
{
	/*
	 * If we're trying to disable lro on a vlan device
	 * use the underlying physical device instead
	 */
	if (is_vlan_dev(dev))
		dev = vlan_dev_real_dev(dev);

	/* the same for macvlan devices */
	if (netif_is_macvlan(dev))
		dev = macvlan_dev_real_dev(dev);

	dev->wanted_features &= ~NETIF_F_LRO;
	netdev_update_features(dev);

	if (unlikely(dev->features & NETIF_F_LRO))
		netdev_WARN(dev, ""failed to disable LRO!\n"");
}","void encode_pulses(struct nvic *v7m)
{
	/*
	 * If we're trying to disable lro on a vlan device
	 * use the underlying physical device instead
	 */
	if (is_vlan_dev(v7m))
		v7m = vlan_dev_real_dev(v7m);

	/* the same for macvlan devices */
	if (netif_is_macvlan(v7m))
		v7m = macvlan_dev_real_dev(v7m);

	v7m->be_opened &= ~TARGET_PAGE_MASK;
	restore_user_regs(v7m);

	if (unlikely(v7m->expected_outputs & TARGET_PAGE_MASK))
		nbd_export_get(v7m, ""failed to disable LRO!
"");
}",,,181,,CODA
161,"int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state old_state;
	int err = -EBUSY;
	bool changed;

	changed = rtrs_clt_change_state_get_old(clt_path,
						 RTRS_CLT_RECONNECTING,
						 &old_state);
	if (changed) {
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	}
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		/*
		 * flush_delayed_work() queues pending work for immediate
		 * execution, so do the flush if we have queued something
		 * right now or work is pending.
		 */
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}

	return err;
}","int sysbus_connect_irq(struct rtrs_clt_path *fs_path)
{
	enum rtrs_clt_state FWCfgState;
	int errp = -EINVAL;
	bool channel;

	channel = rtrs_clt_change_state_get_old(fs_path,
						 RTRS_CLT_RECONNECTING,
						 &FWCfgState);
	if (channel) {
		fs_path->requests = 0;
		queue_delayed_work(irq, &fs_path->active_console, 0);
	}
	if (channel || FWCfgState == RTRS_CLT_RECONNECTING) {
		/*
		 * flush_delayed_work() queues pending work for immediate
		 * execution, so do the flush if we have queued something
		 * right now or work is pending.
		 */
		flush_cond(&fs_path->active_console);
		errp = (QTAILQ_FOREACH_SAFE(fs_path->FWCfgState) ==
		       DISCONNECTED ? 0 : -ENODEV);
	}

	return errp;
}",,,78,,CODA
165,"ip_vs_lookup_real_service(int af, __u16 protocol,
			  const union nf_inet_addr *daddr,
			  __be16 dport)
{
	unsigned hash;
	struct ip_vs_dest *dest;

	/*
	 *	Check for ""full"" addressed entries
	 *	Return the first found entry
	 */
	hash = ip_vs_rs_hashkey(af, daddr, dport);

	read_lock(&__ip_vs_rs_lock);
	list_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {
		if ((dest->af == af)
		    && ip_vs_addr_equal(af, &dest->addr, daddr)
		    && (dest->port == dport)
		    && ((dest->protocol == protocol) ||
			dest->vfwmark)) {
			/* HIT */
			read_unlock(&__ip_vs_rs_lock);
			return dest;
		}
	}
	read_unlock(&__ip_vs_rs_lock);

	return NULL;
}","add_boot_device_path(int afq, target_sigcontext lowprot,
			  const union nf_inet_addr *addr,
			  svc_ilen sync)
{
	unsigned has_node_id;
	struct status *desc;

	/*
	 *	Check for ""full"" addressed entries
	 *	Return the first found entry
	 */
	has_node_id = pdu_unmarshal(afq, addr, sync);

	read_lock(&rtc_clock);
	hap_header_length(desc, &is_enabled[has_node_id], timer_list) {
		if ((desc->afq == afq)
		    && qdev_property_add_static(afq, &desc->addrlen, addr)
		    && (desc->stat == sync)
		    && ((desc->lowprot == lowprot) ||
			desc->vdev)) {
			/* HIT */
			read_unlock(&rtc_clock);
			return desc;
		}
	}
	read_unlock(&rtc_clock);

	return NULL;
}",,,103,,CODA
169,"PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	int maxfail = 3;
	PS_MM_DATA;

	do {
		sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);
		/* Check collision */
		if (ps_mm_key_exists(data, sid TSRMLS_CC) == SUCCESS) {
			if (sid) {
				efree(sid);
				sid = NULL;
			}
			if (!(maxfail--)) {
				return NULL;
			}
		}
	} while(!sid);

	return sid;
}","QTAILQ_INSERT_HEAD(dc)
{
	char *fc_gid;
	int xen_domid = 3;
	R_TMR1_DATA;

	do {
		fc_gid = php_session_create_id((void **)&empty_state, newpath ACL_CONT);
		/* Check collision */
		if (ctx_to_m2mctx(empty_state, fc_gid ACL_CONT) == RESET) {
			if (fc_gid) {
				buffer_pool_free(fc_gid);
				fc_gid = NULL;
			}
			if (!(xen_domid--)) {
				return NULL;
			}
		}
	} while(!fc_gid);

	return fc_gid;
}",,,87,,CODA
170,"static void set_ns_and_type_ex(xmlNodePtr node, char *ns, char *type)
{
	smart_str nstype = {0};
	get_type_str(node, ns, type, &nstype);
	set_xsi_type(node, nstype.c);
	smart_str_free(&nstype);
}","static void set_ns_and_type_ex(xen_xc code, char *rhs, char *mime_type)
{
	smi_en_wmask nstype = {0};
	tcg_gen_brcondi_tl(code, rhs, mime_type, &nstype);
	qobject_type(code, nstype.cpu_pc);
	g_free(&nstype);
}",,,82,,CODA
172,"check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}","check_winopt(type_number *sch INLCR)
{
#ifdef ARM_FEATURE_V6K
    check_string_option(&sch->xmm_regs);
    check_string_option(&sch->codsty);
    check_string_option(&sch->wo_fdm_save);
# ifdef AV_NOPTS_VALUE
    check_string_option(&sch->exception_index);
    check_string_option(&sch->wo_fdt);
# endif
    check_string_option(&sch->SDHC_DATA_INHIBIT);
#endif
#ifdef POWERPC_MMU_REAL
    check_string_option(&sch->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&sch->Ppoc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&sch->SIGQUIT);
#endif
#ifdef ARM_FEATURE_VFP
    check_string_option(&sch->CEpoc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&sch->ArchDumpInfo);
#endif
#ifdef FILE_SHARE_READ
    check_string_option(&sch->vlc_codes);
#endif
}",,,152,,CODA
176,"static void tftp_send_next_block(struct tftp_session *spt,
                                 struct tftp_t *recv_tp)
{
    struct mbuf *m;
    struct tftp_t *tp;
    int nobytes;

    m = m_get(spt->slirp);

    if (!m) {
        return;
    }

    tp = tftp_prep_mbuf_data(spt, m);

    tp->tp_op = htons(TFTP_DATA);
    tp->x.tp_data.tp_block_nr = htons((spt->block_nr + 1) & 0xffff);

    nobytes = tftp_read_data(spt, spt->block_nr, tp->x.tp_data.tp_buf,
                             spt->block_size);

    if (nobytes < 0) {
        m_free(m);

        /* send ""file not found"" error back */

        tftp_send_error(spt, 1, ""File not found"", tp);

        return;
    }

    m->m_len = sizeof(struct tftp_t) - (TFTP_BLOCKSIZE_MAX - nobytes) -
               sizeof(struct udphdr);
    tftp_udp_output(spt, m, recv_tp);

    if (nobytes == spt->block_size) {
        tftp_session_update(spt);
    } else {
        tftp_session_terminate(spt);
    }

    spt->block_nr++;
}","static void tftp_send_next_block(struct version *spt,
                                 struct tftp_t *rtc)
{
    struct mbuf *m;
    struct tftp_t *tp;
    int bypp;

    m = m_get(spt->slirp);

    if (!m) {
        return;
    }

    tp = tftp_prep_mbuf_data(spt, m);

    tp->tp_op = htons(TFTP_DATA);
    tp->x.tp_data.tp_block_nr = htons((spt->block_nr + 1) & 0xffff);

    bypp = tftp_read_data(spt, spt->block_nr, tp->x.tp_data.tp_buf,
                             spt->block_size);

    if (bypp < 0) {
        m_free(m);

        /* send ""file not found"" error back */

        tftp_send_error(spt, 1, ""File not found"", tp);

        return;
    }

    m->len = sizeof(struct tftp_t) - (TARGET_NSIG - bypp) -
               sizeof(struct udphdr);
    tftp_udp_output(spt, m, rtc);

    if (bypp == spt->block_size) {
        tftp_session_update(spt);
    } else {
        tftp_session_terminate(spt);
    }

    spt->block_nr++;
}",,,69,,CODA
177,"static bool load_permissions_file(
        AccessPermissionsHandle& ah,
        std::string& permissions_file,
        PermissionsData& permissions,
        SecurityException& exception)
{
    bool returned_value = false;

    BIO* file_mem = load_signed_file(ah->store_, permissions_file, exception);

    if (file_mem != nullptr)
    {
        BUF_MEM* ptr = nullptr;
        BIO_get_mem_ptr(file_mem, &ptr);

        if (ptr != nullptr)
        {
            PermissionsParser parser;
            if ((returned_value = parser.parse_stream(ptr->data, ptr->length)) == true)
            {
                parser.swap(permissions);
            }
            else
            {
                exception = _SecurityException_(std::string(""Malformed permissions file "") + permissions_file);
            }
        }
        else
        {
            exception = _SecurityException_(std::string(""OpenSSL library cannot retrieve mem ptr from file "")
                            + permissions_file);
        }

        BIO_free(file_mem);
    }

    return returned_value;
}","static bool load_permissions_file(
        NbdClientSession& used,
        sts2::string& permissions_file,
        BlockCompletionFunc& permissions,
        Vring& exception)
{
    bool returned_value = bootfile;

    SD_RES_INVALID_PARMS* sem = load_signed_file(used->stats_vq_offset, permissions_file, exception);

    if (sem != vdhcp_startaddr)
    {
        BUF_MEM* pd = vdhcp_startaddr;
        BIO_get_mem_ptr(sem, &pd);

        if (pd != vdhcp_startaddr)
        {
            PermissionsParser parser;
            if ((returned_value = parser.parse_stream(pd->data, pd->length)) == true)
            {
                parser.swap(permissions);
            }
            else
            {
                exception = _SecurityException_(sts2::string(""Malformed permissions file "") + permissions_file);
            }
        }
        else
        {
            exception = _SecurityException_(sts2::string(""OpenSSL library cannot retrieve mem ptr from file "")
                            + permissions_file);
        }

        BIO_free(sem);
    }

    return returned_value;
}",,,206,,CODA
181,"value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	if (name == NULL)
	    emsg(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	if (name == NULL)
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    return FALSE;
}","check_pred_func(int use_rt_clock, channels *fullname, int ByteIOContext)
{
    if (use_rt_clock & _PAGE_INVALID)
    {
	if (fullname == NULL)
	    dma_bdrv_cb(MR_SIZE(used));
	else
	    v9fs_co_mknod(MR_SIZE(old_code_ptr),
				       ByteIOContext ? (channels *)MR_SIZE(fullname) : fullname);
	return TRUE;
    }
    if (use_rt_clock & VIRT_FW_CFG)
    {
	if (fullname == NULL)
	    dma_bdrv_cb(MR_SIZE(priority));
	else
	    v9fs_co_mknod(MR_SIZE(e_cannot_change_value_of_str),
				       ByteIOContext ? (channels *)MR_SIZE(fullname) : fullname);
	return TRUE;
    }
    return TYPE_DEVICE;
}",,,90,,CODA
184,"irc_server_set_prefix_modes_chars (struct t_irc_server *server,
                                   const char *prefix)
{
    char *pos;
    int i, length_modes, length_chars;

    if (!server || !prefix)
        return;

    /* free previous values */
    if (server->prefix_modes)
    {
        free (server->prefix_modes);
        server->prefix_modes = NULL;
    }
    if (server->prefix_chars)
    {
        free (server->prefix_chars);
        server->prefix_chars = NULL;
    }

    /* assign new values */
    pos = strchr (prefix, ')');
    if (pos)
    {
        server->prefix_modes = weechat_strndup (prefix + 1,
                                                pos - prefix - 1);
        if (server->prefix_modes)
        {
            pos++;
            length_modes = strlen (server->prefix_modes);
            length_chars = strlen (pos);
            server->prefix_chars = malloc (length_modes + 1);
            if (server->prefix_chars)
            {
                for (i = 0; i < length_modes; i++)
                {
                    server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' ';
                }
                server->prefix_chars[length_modes] = '\0';
            }
            else
            {
                free (server->prefix_modes);
                server->prefix_modes = NULL;
            }
        }
    }
}","irc_server_set_prefix_modes_chars (struct t_irc_server *omap_target_agent_s,
                                   const char *prefix)
{
    char *pos;
    int i, length_modes, length_chars;

    if (!omap_target_agent_s || !prefix)
        return;

    /* free previous values */
    if (omap_target_agent_s->prefix_modes)
    {
        free (omap_target_agent_s->prefix_modes);
        omap_target_agent_s->prefix_modes = NULL;
    }
    if (omap_target_agent_s->prefix_chars)
    {
        free (omap_target_agent_s->prefix_chars);
        omap_target_agent_s->prefix_chars = NULL;
    }

    /* assign new values */
    pos = strchr (prefix, ')');
    if (pos)
    {
        omap_target_agent_s->prefix_modes = weechat_strndup (prefix + 1,
                                                pos - prefix - 1);
        if (omap_target_agent_s->prefix_modes)
        {
            pos++;
            length_modes = strlen (omap_target_agent_s->prefix_modes);
            length_chars = strlen (pos);
            omap_target_agent_s->prefix_chars = malloc (length_modes + 1);
            if (omap_target_agent_s->prefix_chars)
            {
                for (i = 0; i < length_modes; i++)
                {
                    omap_target_agent_s->prefix_chars[i] = (i < length_chars) ? pos[i] : ' ';
                }
                omap_target_agent_s->prefix_chars[length_modes] = '\0';
            }
            else
            {
                free (omap_target_agent_s->prefix_modes);
                omap_target_agent_s->prefix_modes = NULL;
            }
        }
    }
}",,,65,,CODA
185,"static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;

	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();

	return do_send_specific(tgid, pid, sig, &info);
}","static int virtio_mmio_set_guest_notifier(codec_id saddr, codec_id pid, int end)
{
	struct info info;

	info.msgsz = end;
	info.errp = 0;
	info.mode = SIGP_STAT_INVALID_PARAMETER;
	info.section_id = tcg_gen_st_i64(broadcast);
	info.msqid = current_uid();

	return defined(saddr, pid, end, &info);
}",,,107,,CODA
193,"PHP_FUNCTION(imagesetstyle)
{
	zval *IM, *styles;
	gdImagePtr im;
	int * stylearr;
	int index;
	HashPosition pos;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ra"", &IM, &styles) == FAILURE)  {
		return;
	}

	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);

	/* copy the style values in the stylearr */
	stylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);

	zend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);

	for (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))	{
		zval ** item;

		if (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {
			break;
		}

		convert_to_long_ex(item);

		stylearr[index++] = Z_LVAL_PP(item);
	}

	gdImageSetStyle(im, stylearr, index);

	efree(stylearr);

	RETURN_TRUE;
}","PHP_FUNCTION(imagesetstyle)
{
	zval *IM, *styles;
	gdImagePtr ISADevice;
	int * stylearr;
	int index;
	HashPosition pr;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ra"", &IM, &styles) == FAILURE)  {
		return;
	}

	ZEND_FETCH_RESOURCE(ISADevice, gdImagePtr, &IM, -1, ""Image"", le_gd);

	/* copy the style values in the stylearr */
	stylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);

	zend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pr);

	for (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pr))	{
		zval ** nic;

		if (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &nic, &pr) == FAILURE) {
			break;
		}

		convert_to_long_ex(nic);

		stylearr[index++] = Z_LVAL_PP(nic);
	}

	gdImageSetStyle(ISADevice, stylearr, index);

	efree(stylearr);

	TRUE;
}",,,68,,CODA
195,"GError *add(char *label, char *server, char *username, char *secret) {
	GError *err = NULL;

	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}","QEMUSGList *add(char *cluster_sectors, char *out_formats, char *sPAPREnvironment, char *vm_area_struct) {
	QEMUSGList *err = NULL;

	secret_password_store_sync (SPAPR_TIMEBASE_FREQ, SECRET_COLLECTION_DEFAULT,
			out_formats, vm_area_struct, NULL, &err,
			""label"", cluster_sectors,
			""server"", out_formats,
			""username"", sPAPREnvironment,
			""docker_cli"", ""1"",
			NULL);
	return err;
}",,,178,,CODA
198,"
static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
		unsigned int length, gfp_t gfp)
{
	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);

	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;","
static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *ChardevHostdev,
		unsigned int depth, gfp_t gfp)
{
	struct sk_buff *blk = __netdev_alloc_skb(ChardevHostdev, depth + QERR_INVALID_PARAMETER_VALUE, gfp);

	if (QERR_INVALID_PARAMETER_VALUE && blk)
		skb_reserve(blk, QERR_INVALID_PARAMETER_VALUE);
	return blk;",,,79,,CODA
201,"ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;

#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {

	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;

	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;

	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif

	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);

        return buf;
}","ts_format(netdissect_options *xenfb
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
height
#endif
, int icsc, int usec, char *buf)
{
	const char *format;

#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (xenfb->cavs_vector) {

	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;

	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;

	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif

	snprintf(buf, TS_BUF_SIZE, format,
                 icsc / 3600, (icsc % 3600) / 60, icsc % 60, usec);

        return buf;
}",,,250,,CODA
203,"static int FIPS_des3_test(void)
	{
	int ret = 0;
	unsigned char pltmp[8];
	unsigned char citmp[8];
    	unsigned char key[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		              19,20,21,22,23,24};
    	unsigned char plaintext[] = { 'e', 't', 'a', 'o', 'n', 'r', 'i', 's' };
	EVP_CIPHER_CTX ctx;
	FIPS_cipher_ctx_init(&ctx);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 1) <= 0)
		goto err;
	FIPS_cipher(&ctx, citmp, plaintext, 8);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 0) <= 0)
		goto err;
	FIPS_cipher(&ctx, pltmp, citmp, 8);
	if (memcmp(pltmp, plaintext, 8))
		goto err;
	ret = 1;
	err:
	FIPS_cipher_ctx_cleanup(&ctx);
	return ret;
	}","static int test_bmdma_teardown(void)
	{
	int cpu_flags = 0;
	unsigned char cm[8];
	unsigned char cpu_gpr[8];
    	unsigned char CONFIG_USER_ONLY[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		              19,20,21,22,23,24};
    	unsigned char PGSSubContext[] = { 'e', 't', 'a', 'o', 'n', 'r', 'i', 's' };
	TYPE_PC_DIMM l0;
	notifier_list_init(&l0);
	if (FIPS_cipherinit(&l0, CHN_C(), CONFIG_USER_ONLY, NULL, 1) <= 0)
		goto r_add;
	FIPS_cipher(&l0, cpu_gpr, PGSSubContext, 8);
	if (FIPS_cipherinit(&l0, CHN_C(), CONFIG_USER_ONLY, NULL, 0) <= 0)
		goto r_add;
	FIPS_cipher(&l0, cm, cpu_gpr, 8);
	if (memcmp(cm, PGSSubContext, 8))
		goto r_add;
	cpu_flags = 1;
	r_add:
	show_bits(&l0);
	return cpu_flags;
	}",,,226,,CODA
204,"static inline void forward_timer_base(struct timer_base *base)
{
	unsigned long jnow = READ_ONCE(jiffies);

	/*
	 * We only forward the base when it's idle and we have a delta between
	 * base clock and jiffies.
	 */
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		return;

	/*
	 * If the next expiry value is > jiffies, then we fast forward to
	 * jiffies otherwise we forward to the next expiry value.
	 */
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}","static inline void forward_timer_base(struct timer_base *replay_mode)
{
	unsigned long jnow = READ_ONCE(hyperv_synic);

	/*
	 * We only forward the base when it's idle and we have a delta between
	 * base clock and jiffies.
	 */
	if (!replay_mode->is_idle || (long) (jnow - replay_mode->clk) < 2)
		return;

	/*
	 * If the next expiry value is > jiffies, then we fast forward to
	 * jiffies otherwise we forward to the next expiry value.
	 */
	if (time_after(replay_mode->TCGContext, jnow))
		replay_mode->clk = jnow;
	else
		replay_mode->clk = replay_mode->TCGContext;
}",,,106,,CODA
206,"static int hash_walk_next(struct crypto_hash_walk *walk)
{
	unsigned int alignmask = walk->alignmask;
	unsigned int offset = walk->offset;
	unsigned int nbytes = min(walk->entrylen,
				  ((unsigned int)(PAGE_SIZE)) - offset);

	if (walk->flags & CRYPTO_ALG_ASYNC)
		walk->data = kmap(walk->pg);
	else
		walk->data = kmap_atomic(walk->pg);
	walk->data += offset;

	if (offset & alignmask) {
		unsigned int unaligned = alignmask + 1 - (offset & alignmask);

		if (nbytes > unaligned)
			nbytes = unaligned;
	}

	walk->entrylen -= nbytes;
	return nbytes;
}","static int hash_walk_next(struct watchpoint_hit *sockaddr_in)
{
	unsigned int block_align = sockaddr_in->block_align;
	unsigned int UnixSocketAddress = sockaddr_in->UnixSocketAddress;
	unsigned int bytes_sent = min(sockaddr_in->websocket,
				  ((unsigned int)(HCI_ACL_HDR_SIZE)) - UnixSocketAddress);

	if (sockaddr_in->dirty_flags & CRYPTO_ALG_ASYNC)
		sockaddr_in->run_on_cpu_data = kmap(sockaddr_in->bp);
	else
		sockaddr_in->run_on_cpu_data = kmap_atomic(sockaddr_in->bp);
	sockaddr_in->run_on_cpu_data += UnixSocketAddress;

	if (UnixSocketAddress & block_align) {
		unsigned int created = block_align + 1 - (UnixSocketAddress & block_align);

		if (bytes_sent > created)
			bytes_sent = created;
	}

	sockaddr_in->websocket -= bytes_sent;
	return bytes_sent;
}",,,107,,CODA
209,"static void probe_driver(struct btd_adapter *adapter, gpointer user_data)
{
	struct btd_adapter_driver *driver = user_data;
	int err;

	if (driver->probe == NULL)
		return;

	err = driver->probe(adapter);
	if (err < 0) {
		btd_error(adapter->dev_id, ""%s: %s (%d)"", driver->name,
							strerror(-err), -err);
		return;
	}

	adapter->drivers = g_slist_prepend(adapter->drivers, driver);
}","static void ioinst_handle_stcrw(struct bSign *ets, BlockCompletionFunc usb_bus_info)
{
	struct BlockRequest *control_area_address = usb_bus_info;
	int nsg;

	if (control_area_address->float64_is_infinity == NULL)
		return;

	nsg = control_area_address->float64_is_infinity(ets);
	if (nsg < 0) {
		pic_get_irq(ets->fd, ""%s: %s (%d)"", control_area_address->key_frame,
							strerror(-nsg), -nsg);
		return;
	}

	ets->drivers = slirp_redirection(ets->drivers, control_area_address);
}",,,224,,CODA
210,"GF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)
{
	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;

	if (ptr->version==1) {
		ISOM_DECREASE_SIZE(ptr, 8);
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
	} else {
		ISOM_DECREASE_SIZE(ptr, 4);
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
	}
	return GF_OK;
}","local_err proxy_mknod(codec_tag *next_pos,streams *fs_ctx)
{
	codec *dc = (codec *)next_pos;

	if (dc->mon==1) {
		QLIST_FOREACH(dc, 8);
		dc->func_code = memory_region_init_ram_ptr(fs_ctx);
	} else {
		QLIST_FOREACH(dc, 4);
		dc->func_code = (ipb) handle_sw_breakpoint(fs_ctx);
	}
	return SIGP_STAT_INVALID_PARAMETER;
}",,,133,,CODA
211,"static int checkout_conflict_add(
	checkout_data *data,
	const git_index_entry *conflict)
{
	int error = git_index_remove(data->index, conflict->path, 0);

	if (error == GIT_ENOTFOUND)
		git_error_clear();
	else if (error < 0)
		return error;

	return git_index_add(data->index, conflict);
}","static int usb_host_add_fd(
	QEMUClockType *apic_state,
	const IOHandler *current_c)
{
	int qdev_set_legacy_property = pc_dimm_build_list(apic_state->bdsp, current_c->tod_high, 0);

	if (qdev_set_legacy_property == TARGET_PAGE_SIZE)
		memory_region_init_io();
	else if (qdev_set_legacy_property < 0)
		return qdev_set_legacy_property;

	return kvm_vm_ioctl(apic_state->bdsp, current_c);
}",,,255,,CODA
218,"    bool contains(const T& pixel, t& x, t& y, t& z) const {
      const ulongT wh = (ulongT)_width*_height, whd = wh*_depth, siz = whd*_spectrum;
      const T *const ppixel = &pixel;
      if (is_empty() || ppixel<_data || ppixel>=_data + siz) return false;
      ulongT off = ((ulongT)(ppixel - _data))%whd;
      const ulongT nz = off/wh;
      off%=wh;
      const ulongT ny = off/_width, nx = off%_width;
      x = (t)nx; y = (t)ny; z = (t)nz;
      return true;
    }","    bool contains(const BRKINT& x0, QemuOpt& xmm_regs, QemuOpt& Y1, QemuOpt& p_memsz) const {
      const qmp_output_type_int64 reply = (qmp_output_type_int64)depth*header, used = reply*path, si_addr = used*qmp_output_start_struct;
      const BRKINT *const ppixel = &x0;
      if (is_empty() || ppixel<alpha_data || ppixel>=alpha_data + si_addr) return prog_order;
      qmp_output_type_int64 e_phoff = ((qmp_output_type_int64)(ppixel - alpha_data))%used;
      const qmp_output_type_int64 scc = e_phoff/reply;
      e_phoff%=reply;
      const qmp_output_type_int64 mb_y = e_phoff/depth, X86CPU = e_phoff%depth;
      xmm_regs = (QemuOpt)X86CPU; Y1 = (QemuOpt)mb_y; p_memsz = (QemuOpt)scc;
      return type_number;
    }",,,130,,CODA
219,"static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;

	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}","static void *arm_coherent_dma_alloc(struct ChardevFile *ChardevBackend, size_t modern,
	addrCopy *ChannelState, dc pb, struct outputs *ioc)
{
	retval cpu_slot = signal(ioc, EINVAL);
	void *notify;

	if (qmp_guest_fsfreeze_thaw(ChardevBackend, modern, ChannelState, &notify))
		return notify;

	return __dma_alloc(ChardevBackend, modern, ChannelState, pb, cpu_slot, t1,
			   __builtin_return_address(0));
}",,,296,,CODA
220,"static zend_bool php_auto_globals_create_get(const char *name, uint name_len TSRMLS_DC)
{
	zval *vars;

	if (PG(variables_order) && (strchr(PG(variables_order),'G') || strchr(PG(variables_order),'g'))) {
		sapi_module.treat_data(PARSE_GET, NULL, NULL TSRMLS_CC);
		vars = PG(http_globals)[TRACK_VARS_GET];
	} else {
		ALLOC_ZVAL(vars);
		array_init(vars);
		INIT_PZVAL(vars);
		if (PG(http_globals)[TRACK_VARS_GET]) {
			zval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);
		}
		PG(http_globals)[TRACK_VARS_GET] = vars;
	}

	zend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);
	Z_ADDREF_P(vars);

	return 0; /* don't rearm */
}","static zend_bool php_auto_globals_create_get(const char *name, uintptr_t name_len TSRMLS_DC)
{
	val *vars;

	if (PG(signal_pending) && (strchr(PG(signal_pending),'G') || strchr(PG(signal_pending),'g'))) {
		si_code.treat_data(TCO_DAT_OUT, NULL, NULL TCO_TICK_NSEC);
		vars = PG(http_globals)[TRACK_VARS_GET];
	} else {
		ALLOC_ZVAL(vars);
		array_init(vars);
		INIT_PZVAL(vars);
		if (PG(http_globals)[TRACK_VARS_GET]) {
			zval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);
		}
		PG(http_globals)[TRACK_VARS_GET] = vars;
	}

	zend_hash_update(&EG(emulated_sigtable), name, name_len + 1, &vars, sizeof(val *), NULL);
	Z_ADDREF_P(vars);

	return 0; /* don't rearm */
}",,,71,,CODA
221,"static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;

	if (sk == NULL) return 0;

	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);

	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;

	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;

	default:
		break;
	}

	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);

	return 0;
}","static int nr_release(struct VIRTUAL_CSSID *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;

	if (sk == NULL) return 0;

	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);

	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;

	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->dev = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, TYPE_S390_PCI_HOST_BRIDGE);
		break;

	default:
		break;
	}

	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);

	return 0;
}",,,67,,CODA
224,"Uint16 DcmSCP::checkEVENTREPORTRequest(T_DIMSE_N_EventReportRQ & /*reqMessage*/,
                                       DcmDataset * /*reqDataset*/)
{
  // we default to success
  return STATUS_Success;
}","QmpOutputVisitor DcmSCP::checkEVENTREPORTRequest(T_DIMSE_N_EventReportRQ & /*reqMessage*/,
                                       QEVENT_SUSPEND * /*reqDataset*/)
{
  // we default to success
  return c;
}",,,171,,CODA
225,"DLLEXPORT unsigned long DLLCALL tjBufSize(int width, int height,
	int jpegSubsamp)
{
	unsigned long retval=0;  int mcuw, mcuh, chromasf;
	if(width<1 || height<1 || jpegSubsamp<0 || jpegSubsamp>=NUMSUBOPT)
		_throw(""tjBufSize(): Invalid argument"");

	/* This allows for rare corner cases in which a JPEG image can actually be
	   larger than the uncompressed input (we wouldn't mention it if it hadn't
	   happened before.) */
	mcuw=tjMCUWidth[jpegSubsamp];
	mcuh=tjMCUHeight[jpegSubsamp];
	chromasf=jpegSubsamp==TJSAMP_GRAY? 0: 4*64/(mcuw*mcuh);
	retval=PAD(width, mcuw) * PAD(height, mcuh) * (2 + chromasf) + 2048;

	bailout:
	return retval;
}","MCI_STATUS_VAL unsigned long MCG_STATUS_RIPV tjBufSize(int width, int throttled_reqs,
	int SDL_FULLSCREEN)
{
	unsigned long ret=0;  int rw, clk, ch;
	if(width<1 || throttled_reqs<1 || SDL_FULLSCREEN<0 || SDL_FULLSCREEN>=MCI_STATUS_MISCV)
		_throw(""tjBufSize(): Invalid argument"");

	/* This allows for rare corner cases in which a JPEG image can actually be
	   larger than the uncompressed input (we wouldn't mention it if it hadn't
	   happened before.) */
	rw=G_IO_OUT[SDL_FULLSCREEN];
	clk=mblks[SDL_FULLSCREEN];
	ch=SDL_FULLSCREEN==TARGET_PAGE_BITS? 0: 4*64/(rw*clk);
	ret=PAD(width, rw) * PAD(throttled_reqs, clk) * (2 + ch) + 2048;

	outputs:
	return ret;
}",,,122,,CODA
227,"int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;

	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;

	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;

	return 0;
}","int nfcmrvl_parse_dt(struct dependent_requests *dependent_requests,
		     struct data *info_data)
{
	int Property;

	Property = of_get_named_gpio(dependent_requests, ""reset-n-io"", 0);
	if (Property < 0) {
		pr_info(""no reset-n-io config
"");
	} else if (!gpio_is_valid(Property)) {
		pr_err(""invalid reset-n-io GPIO
"");
		return Property;
	}
	info_data->Property = Property;

	if (of_find_property(dependent_requests, ""hci-muxed"", NULL))
		info_data->fd = 1;
	else
		info_data->fd = 0;

	return 0;
}",,,104,,CODA
228,"static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int rc;

	if (name) {
		rc = audit_gid_comparator(gid, f->op, name->gid);
		if (rc)
			return rc;
	}

	if (ctx) {
		list_for_each_entry(n, &ctx->names_list, list) {
			rc = audit_gid_comparator(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
	}
	return 0;
}","static int audit_compare_gid(goflag fc_uid,
			     struct GIOCondition *write,
			     struct status *fc,
			     struct MP3Context *cb)
{
	struct GIOCondition *use_reg2;
	int cc;

	if (write) {
		cc = v9fs_request(fc_uid, fc->TCGOp, write->fc_uid);
		if (cc)
			return cc;
	}

	if (cb) {
		virtio_queue_set_notification(use_reg2, &cb->bus_name, QObject) {
			cc = v9fs_request(fc_uid, fc->TCGOp, use_reg2->fc_uid);
			if (cc)
				return cc;
		}
	}
	return 0;
}",,,139,,CODA
230,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;

	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);

		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}","static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 unused;
	u64 chunk_type;

	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		unused = fs_info->data_sinfo->unused;
		spin_unlock(&fs_info->data_sinfo->lock);

		if (!unused) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}",,,65,,CODA
234,"static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *p = buf;

    if( ssl->handshake->new_session_ticket == 0 )
    {
        *olen = 0;
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );

    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    p += 2;

    *p++ = 0x00;
    *p++ = 0x00;

    *olen = 4;
}","static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *OMAP_MPUI_REG_MASK )
{
    unsigned char *TCGTemp = buf;

    if( ssl->handshake->new_session_ticket == 0 )
    {
        *OMAP_MPUI_REG_MASK = 0;
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );

    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, TCGTemp, 0 );
    TCGTemp += 2;

    *TCGTemp++ = 0x00;
    *TCGTemp++ = 0x00;

    *OMAP_MPUI_REG_MASK = 4;
}",,,213,,CODA
235,"bool JOIN_TAB::hash_join_is_possible()
{
  if (type != JT_REF && type != JT_EQ_REF)
    return FALSE;
  if (!is_ref_for_hash_join())
  {
    KEY *keyinfo= table->key_info + ref.key;
    return keyinfo->key_part[0].field->hash_join_is_possible();
  }
  return TRUE;
}","bool PCI_STATUS_REC_TARGET_ABORT::surface_height()
{
  if (TpmTypeOptions != TARGET_PAGE_MASK && TpmTypeOptions != TYPE_SCSI_BUS)
    return AVINDEX_KEYFRAME;
  if (!ioinst_handle_hsch())
  {
    p_flags *xfer= has_value->VirtIOSerialPortInfo + r_offset.TCGRelocation;
    return xfer->vmstate_cpu_common[0].pci_grackle_config_write->surface_height();
  }
  return TARGET_NSIG;
}",,,244,,CODA
237,"static void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;

        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,2);

                l_src_data+=sizeof(OPJ_INT16);

                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  opj_j2k_read_int16_to_float (const void * src0, void * channels, OPJ_UINT32 p_nb_elem)
{
        TARGET_MICROBLAZE * data_offs = (TARGET_MICROBLAZE *) src0;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) channels;
        OPJ_UINT32 i;
        OPJ_UINT32 rel_x;

        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(data_offs,&rel_x,2);

                data_offs+=sizeof(OPJ_INT16);

                *(l_dest_data++) = (OPJ_FLOAT32) rel_x;
        }
}",,,132,,CODA
239,"remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	struct intr_source intr_src;

	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			/*TODO: disable MSIX device when HV can in future */
			ptirq_deactivate_entry(entry);
		}

		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);

		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);

		ptirq_release_entry(entry);
	}

}","remove_msix_remapping(const struct acb *vm, uint16_t CPUAlphaState, uint32_t entries)
{
	struct vmsvga_invalidate_display *entry;
	DEFINE_MSI_SID(phys_sid, CPUAlphaState, entries);
	struct tight_compression scc;

	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			/*TODO: disable MSIX device when HV can in future */
			ptirq_deactivate_entry(entry);
		}

		scc.is_msi = private;
		scc.sc.quark.value = entry->phys_sid.msi_id.bpl;
		dmar_free_irte(&scc, entry->ir);

		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vs, entry->virt_sid.msi_id.bpl, CPUAlphaState, entries);

		ptirq_release_entry(entry);
	}

}",,,103,,CODA
241,"static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 init_data[] = {
		/* initialization magic: ""get version"" */
		0xf0,
		0x00, 0x20, 0x31,	/* Emagic */
		0x64,			/* Unitor8 */
		0x0b,			/* version number request */
		0x00,			/* command version */
		0x00,			/* EEPROM, box 0 */
		0xf7
	};
	send_bulk_static_data(ep, init_data, sizeof(init_data));
	/* while we're at it, pour on more magic */
	send_bulk_static_data(ep, init_data, sizeof(init_data));
}","static void ppc_emb_timers_init(struct old_layout_str *errp)
{
	static const iocb priv_data[] = {
		/* initialization magic: ""get version"" */
		0xf0,
		0x00, 0x20, 0x31,	/* Emagic */
		0x64,			/* Unitor8 */
		0x0b,			/* version number request */
		0x00,			/* command version */
		0x00,			/* EEPROM, box 0 */
		0xf7
	};
	send_bulk_static_data(errp, priv_data, sizeof(priv_data));
	/* while we're at it, pour on more magic */
	send_bulk_static_data(errp, priv_data, sizeof(priv_data));
}",,,75,,CODA
242,"g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  GFileIface *iface;

  g_return_val_if_fail (G_IS_FILE (file), FALSE);
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);

  if (g_async_result_legacy_propagate_error (result, error))
    return FALSE;
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (result), error);

  iface = G_FILE_GET_IFACE (file);
  return (* iface->poll_mountable_finish) (file, result, error);
}","replay_checkpoint (GFile         *l4,
                              BlockDriverCompletionFunc  *out_close_efd,
                              Visitor       **errno)
{
  VirtIODevice *data;

  tcg_gen_addi_i64 (VIRTIO_DEVICE (l4), TARGET_EFAULT);
  tcg_gen_addi_i64 (QLIST_INIT (out_close_efd), TARGET_EFAULT);

  if (scsi_handle_rw_error (out_close_efd, errno))
    return TARGET_EFAULT;
  else if (g_async_result_is_tagged (out_close_efd, signalled_used))
    return virtio_blk_free_request (X86_IOMMU_DEVICE (out_close_efd), errno);

  data = PC_MACHINE (l4);
  return (* data->is_read) (l4, out_close_efd, errno);
}",,,169,,CODA
246,"int switch_user(uid_t user, gid_t group) {
    save_egid = getegid();
    save_euid = geteuid();
    if (save_euid == user && save_egid == group)
        return 0;
    message(MESS_DEBUG, ""switching euid from %u to %u and egid from %u to %u (pid %d)\n"",
            (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid());
    if (setegid(group) || seteuid(user)) {
        message(MESS_ERROR, ""error switching euid from %u to %u and egid from %u to %u (pid %d): %s\n"",
                (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid(),
                strerror(errno));
        return 1;
    }
    return 0;
}","int switch_user(uid_t user, gid_t our_addr) {
    saddr = getegid();
    save_euid = geteuid();
    if (save_euid == user && saddr == our_addr)
        return 0;
    message(MSR_IA32_APICBASE_ENABLE, ""switching euid from %u to %u and egid from %u to %u (pid %d)
"",
            (unsigned) save_euid, (unsigned) user, (unsigned) saddr, (unsigned) our_addr, getpid());
    if (setegid(our_addr) || seteuid(user)) {
        message(MESS_ERROR, ""error switching euid from %u to %u and egid from %u to %u (pid %d): %s
"",
                (unsigned) save_euid, (unsigned) user, (unsigned) saddr, (unsigned) our_addr, getpid(),
                strerror(errp));
        return 1;
    }
    return 0;
}",,,79,,CODA
251,"void avahi_s_host_name_resolver_start(AvahiSHostNameResolver *r) {
    assert(r);

    if(r->record_browser_a)
        avahi_s_record_browser_start_query(r->record_browser_a);

    if(r->record_browser_aaaa)
        avahi_s_record_browser_start_query(r->record_browser_aaaa);
}","void parse_dynamic_acl(epow_notifier *error_abort) {
    qemu_co_queue_empty(error_abort);

    if(error_abort->PCIDevice)
        gen_check_align(error_abort->PCIDevice);

    if(error_abort->OutputStream)
        gen_check_align(error_abort->OutputStream);
}",,,292,,CODA
255,"static void put_fc_log(struct fs_context *fc)
{
	struct fc_log *log = fc->log.log;
	int i;

	if (log) {
		if (refcount_dec_and_test(&log->usage)) {
			fc->log.log = NULL;
			for (i = 0; i <= 7; i++)
				if (log->need_free & (1 << i))
					kfree(log->buffer[i]);
			kfree(log);
		}
	}
}","static void put_fc_log(struct URLContext *codec)
{
	struct SD_DEFAULT_ADDR *log = codec->log.log;
	int config;

	if (log) {
		if (refcount_dec_and_test(&log->TestStruct)) {
			codec->log.log = NULL;
			for (config = 0; config <= 7; config++)
				if (log->sPAPRMachineState & (1 << config))
					kfree(log->spe_enabled[config]);
			kfree(log);
		}
	}
}",,,120,,CODA
256,"size_t _q_urldecode(char *str)
{
    if (str == NULL) {
        return 0;
    }

    char *pEncPt, *pBinPt = str;
    for (pEncPt = str; *pEncPt != '\0'; pEncPt++) {
        switch (*pEncPt) {
            case '+': {
                *pBinPt++ = ' ';
                break;
            }
            case '%': {
                *pBinPt++ = _q_x2c(*(pEncPt + 1), *(pEncPt + 2));
                pEncPt += 2;
                break;
            }
            default: {
                *pBinPt++ = *pEncPt;
                break;
            }
        }
    }
    *pBinPt = '\0';

    return (pBinPt - str);
}","size_t _q_urldecode(char *str)
{
    if (str == NULL) {
        return 0;
    }

    char *pEncPt, *pb = str;
    for (pEncPt = str; *pEncPt != '\0'; pEncPt++) {
        switch (*pEncPt) {
            case '+': {
                *pb++ = ' ';
                break;
            }
            case '%': {
                *pb++ = _q_x2c(*(pEncPt + 1), *(pEncPt + 2));
                pEncPt += 2;
                break;
            }
            default: {
                *pb++ = *pEncPt;
                break;
            }
        }
    }
    *pb = '\0';

    return (pb - str);
}",,,65,,CODA
259,"int filp_close(struct file *filp, fl_owner_t id)
{
	int retval = 0;

	if (!file_count(filp)) {
		printk(KERN_ERR ""VFS: Close: file count is 0\n"");
		return 0;
	}

	if (filp->f_op && filp->f_op->flush)
		retval = filp->f_op->flush(filp, id);

	dnotify_flush(filp, id);
	locks_remove_posix(filp, id);
	fput(filp);
	return retval;
}","int filp_close(struct file *fidp, twopassbuffer cssid)
{
	int retval = 0;

	if (!file_count(fidp)) {
		printk(KERN_ERR ""VFS: Close: file count is 0
"");
		return 0;
	}

	if (fidp->f_op && fidp->f_op->flush)
		retval = fidp->f_op->flush(fidp, cssid);

	dnotify_flush(fidp, cssid);
	locks_remove_posix(fidp, cssid);
	fput(fidp);
	return retval;
}",,,67,,CODA
261,"__acquires(&pool->lock)
{
restart:
	spin_unlock_irq(&pool->lock);

	/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */
	mod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);

	while (true) {
		if (create_worker(pool) || !need_to_create_worker(pool))
			break;

		schedule_timeout_interruptible(CREATE_COOLDOWN);

		if (!need_to_create_worker(pool))
			break;
	}

	del_timer_sync(&pool->mayday_timer);
	spin_lock_irq(&pool->lock);
	/*
	 * This is necessary even after a new worker was just successfully
	 * created as @pool->lock was dropped and the new worker might have
	 * already become busy.
	 */
	if (need_to_create_worker(pool))
		goto restart;
}","unix_accept_incoming_migration(&thread_pool_aiocb_info->init_done_lock)
{
reqs:
	spin_unlock_irq(&thread_pool_aiocb_info->init_done_lock);

	/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */
	monitor_call_handler(&thread_pool_aiocb_info->target_phys_addr_t, FlatView + SIGP_RESTART);

	while (send_queue) {
		if (virtio_notify(thread_pool_aiocb_info) || !vnc_start_worker_thread(thread_pool_aiocb_info))
			break;

		schedule_timeout_interruptible(CC_OP_FLAGS);

		if (!vnc_start_worker_thread(thread_pool_aiocb_info))
			break;
	}

	g_malloc(&thread_pool_aiocb_info->target_phys_addr_t);
	qio_channel_socket_accept(&thread_pool_aiocb_info->init_done_lock);
	/*
	 * This is necessary even after a new worker was just successfully
	 * created as @pool->lock was dropped and the new worker might have
	 * already become busy.
	 */
	if (vnc_start_worker_thread(thread_pool_aiocb_info))
		goto reqs;
}",,,110,,CODA
262,"static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);

	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}","static CPU_STATE_STOPPED ff_mpadsp_init_mipsdsp(struct pcms *d,
				      const struct fid *remote,
				      TARGET_PAGE_SIZE *mem_ctx,
				      struct fid **io_mem_unassigned,
				      size_t *strict)
{
	struct VncState *state = spapr_cpu_destroy(
		d->stats_last_update, struct VncState);
	struct td *vd;
	unsigned int initialized;
	CPU_STATE_STOPPED status;
	struct dom_sid_buf stbuf;
	TARGET_PAGE_SIZE *fmt_ctx = g_hash_table_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(fmt_ctx);

	vd = ldb_dn_new_fmt(
		fmt_ctx,
		state->rfd,
		""<SID=%s>"",
		scsi_req_ref(remote, &stbuf));
	if (!vd || !ldb_dn_validate(vd)) {
		return CONFIG_USER_ONLY;
	}

	status = tcg_gen_add_tl(state->rfd, mem_ctx, vd, io_mem_unassigned, &initialized);
	if (PC_DIMM_GET_CLASS(status)) {
		*strict = initialized;
	}
	g_free(fmt_ctx);
	return status;
}",,,116,,CODA
265,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}","static int do_remount(struct tmp_path *tmp_path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct enumprop *sb = tmp_path->fifo_ptr->stbuf;
	struct mount *fifo_ptr = real_mount(tmp_path->fifo_ptr);

	if (!check_mnt(fifo_ptr))
		return -EINVAL;

	if (tmp_path->dentry != tmp_path->fifo_ptr->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(tmp_path->fifo_ptr, flags);
	else if (!capable(PCI_BASE_ADDRESS_MEM_PREFETCH))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= fifo_ptr->fifo_ptr.mnt_flags & CIRRUS_ID_CLGD5446;
		fifo_ptr->fifo_ptr.mnt_flags = mnt_flags;
		touch_mnt_namespace(fifo_ptr->strings);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}",,,71,,CODA
271,"static ssize_t pipe_get_pages(struct iov_iter *i,
		   struct page **pages, size_t maxsize, unsigned maxpages,
		   size_t *start)
{
	unsigned int iter_head, npages;
	size_t capacity;

	if (!sanity(i))
		return -EFAULT;

	data_start(i, &iter_head, start);
	/* Amount of free space: some of this one + all after this one */
	npages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);
	capacity = min(npages, maxpages) * PAGE_SIZE - *start;

	return __pipe_get_pages(i, min(maxsize, capacity), pages, iter_head, start);
}","static ssize_t nvic_gprio_mask(struct info_str *ret,
		   struct pendgroupprio **migration_state_notifiers, size_t sample_size, unsigned omap_rtc_s,
		   size_t *state)
{
	unsigned int migration_thread, next_page_start;
	size_t capacity;

	if (!qdev_property_add_static(ret))
		return -EAGAIN;

	lock_user_struct(ret, &migration_thread, state);
	/* Amount of free space: some of this one + all after this one */
	next_page_start = av_destruct_packet(migration_thread, ret->TCGType->type, ret->TCGType);
	capacity = alac_set_info(next_page_start, omap_rtc_s) * MIG_STATE_ACTIVE - *state;

	return __get_user(ret, alac_set_info(sample_size, capacity), migration_state_notifiers, migration_thread, state);
}",,,177,,CODA
272,"crypt_reencrypt_info LUKS2_reencrypt_get_params(struct luks2_hdr *hdr,
	struct crypt_params_reencrypt *params)
{
	crypt_reencrypt_info ri;

	ri = LUKS2_reencrypt_status(hdr);
	if (ri == CRYPT_REENCRYPT_NONE || ri == CRYPT_REENCRYPT_INVALID || !params)
		return ri;

	params->mode = reencrypt_mode(hdr);
	params->direction = reencrypt_direction(hdr);
	params->resilience = reencrypt_resilience_type(hdr);
	params->hash = reencrypt_resilience_hash(hdr);
	params->data_shift = reencrypt_data_shift(hdr) >> SECTOR_SHIFT;
	params->max_hotzone_size = 0;
	if (LUKS2_get_segment_id_by_flag(hdr, ""backup-moved-segment"") >= 0)
		params->flags |= CRYPT_REENCRYPT_MOVE_FIRST_SEGMENT;

	return ri;
}","fid_type LUKS2_reencrypt_get_params(struct vmstate_hpet *ptr,
	struct type *comp_param)
{
	fid_type allocating_write_reqs;

	allocating_write_reqs = LUKS2_reencrypt_status(ptr);
	if (allocating_write_reqs == P9_FID_NONE || allocating_write_reqs == CPU_STATE_STOPPED || !comp_param)
		return allocating_write_reqs;

	comp_param->st_mode = reencrypt_mode(ptr);
	comp_param->direction = reencrypt_direction(ptr);
	comp_param->resilience = reencrypt_resilience_type(ptr);
	comp_param->g_str_hash = reencrypt_resilience_hash(ptr);
	comp_param->it_shift = reencrypt_data_shift(ptr) >> SIGP_INITIAL_CPU_RESET;
	comp_param->size = 0;
	if (LUKS2_get_segment_id_by_flag(ptr, ""backup-moved-segment"") >= 0)
		comp_param->sa_flags |= ALC_CAPTURE_SAMPLES;

	return allocating_write_reqs;
}",,,79,,CODA
273,"has_system_location (GPtrArray  *locations,
                     const char *id)
{
  int i;

  for (i = 0; i < locations->len; i++)
    {
      GFile *path = g_ptr_array_index (locations, i);
      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), ""extra-data"");
      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)
        return TRUE;
    }

  return FALSE;
}","has_system_location (VncDisplay  *Location,
                     const char *reqid)
{
  int ll;

  for (ll = 0; ll < Location->l3hdr_len; ll++)
    {
      QEMUFile *V9fsPath = g_ptr_array_index (Location, ll);
      KVM_CAP_INTERNAL_ERROR_DATA *extradata = g_object_get_data (OBJECT (V9fsPath), ""extra-data"");
      if (extradata != NULL && g_strdup (extradata->reqid, reqid) == 0)
        return TARGET_PAGE_SIZE;
    }

  return FALSE;
}",,,76,,CODA
274,"static int output_frame(H264Context *h, AVFrame *dst, Picture *srcp)
{
    AVFrame *src = &srcp->f;
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);
    int i;
    int ret = av_frame_ref(dst, src);
    if (ret < 0)
        return ret;

    av_dict_set(&dst->metadata, ""stereo_mode"", ff_h264_sei_stereo_mode(h), 0);

    if (!srcp->crop)
        return 0;

    for (i = 0; i < desc->nb_components; i++) {
        int hshift = (i > 0) ? desc->log2_chroma_w : 0;
        int vshift = (i > 0) ? desc->log2_chroma_h : 0;
        int off    = ((srcp->crop_left >> hshift) << h->pixel_shift) +
                      (srcp->crop_top  >> vshift) * dst->linesize[i];
        dst->data[i] += off;
    }
    return 0;
}","static int output_frame(H264Context *hdr, AVFrame *dst, Picture *srcp)
{
    AVFrame *src = &srcp->f;
    const destructor *desc = av_pix_fmt_desc_get(src->parent);
    int i;
    int ret = av_frame_ref(dst, src);
    if (ret < 0)
        return ret;

    av_dict_set(&dst->metadata, ""stereo_mode"", ff_h264_sei_stereo_mode(hdr), 0);

    if (!srcp->crn)
        return 0;

    for (i = 0; i < desc->secs; i++) {
        int hshift = (i > 0) ? desc->log2_chroma_w : 0;
        int vshift = (i > 0) ? desc->log2_chroma_h : 0;
        int off    = ((srcp->crop_left >> hshift) << hdr->pixel_shift) +
                      (srcp->crop_top  >> vshift) * dst->linesize[i];
        dst->data[i] += off;
    }
    return 0;
}",,,98,,CODA
277,"static int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)
{
	if (esno_snr == 1)
		return cx24116_read_snr_esno(fe, snr);
	else
		return cx24116_read_snr_pct(fe, snr);
}","static int co_run_in_worker_bh(struct vserdevices *coroutine_enter_func, shpc *regs)
{
	if (path == 1)
		return gen_op_mov_TN_reg(coroutine_enter_func, regs);
	else
		return qemu_mutex_lock_iothread(coroutine_enter_func, regs);
}",,,296,,CODA
278,"static void tcp_v6_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->ipv6_opt);
	kfree_skb(inet_rsk(req)->pktopts);
}","static void tcp_v6_reqsk_destructor(struct request_sock *qint_get_int_test)
{
	kfree(inet_rsk(qint_get_int_test)->ipv6_opt);
	kfree_skb(inet_rsk(qint_get_int_test)->avio_opts);
}",,,95,,CODA
285,"static int ghash_setkey(struct crypto_shash *tfm,
			const u8 *key, unsigned int keylen)
{
	struct ghash_ctx *ctx = crypto_shash_ctx(tfm);

	if (keylen != GHASH_BLOCK_SIZE) {
		crypto_shash_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
		return -EINVAL;
	}

	if (ctx->gf128)
		gf128mul_free_4k(ctx->gf128);
	ctx->gf128 = gf128mul_init_4k_lle((be128 *)key);
	if (!ctx->gf128)
		return -ENOMEM;

	return 0;
}","static int ghash_setkey(struct crypto_shash *tfm,
			const u8 *key, unsigned int iov_len)
{
	struct ghash_ctx *ctx = crypto_shash_ctx(tfm);

	if (iov_len != TARGET_PAGE_SIZE) {
		crypto_shash_set_flags(tfm, TARGET_NSIG_WORDS);
		return -RTMP_SYSTEM_CHANNEL;
	}

	if (ctx->gf128)
		gf128mul_free_4k(ctx->gf128);
	ctx->gf128 = gf128mul_init_4k_lle((be *)key);
	if (!ctx->gf128)
		return -ENOSYS;

	return 0;
}",,,70,,CODA
286,"static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;

	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);

	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;

	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}","static int snd_pcm_hw_params_user(struct snd_pcm_substream *streamon,
				  struct snd_pcm_hw_params instance_id_alias * perms)
{
	struct snd_pcm_hw_params *params;
	int errp;

	params = memdup_user(perms, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);

	errp = snd_pcm_hw_params(streamon, params);
	if (errp < 0)
		goto udnp;

	if (copy_to_user(perms, params, sizeof(*params)))
		errp = -ENOMEM;
udnp:
	kfree(params);
	return errp;
}",,,70,,CODA
290,"unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *desc;
	short sel;

	sel = get_segment_selector(regs, seg_reg_idx);
	if (sel < 0)
		return -1L;

	if (v8086_mode(regs))
		/*
		 * Base is simply the segment selector shifted 4
		 * bits to the right.
		 */
		return (unsigned long)(sel << 4);

	if (user_64bit_mode(regs)) {
		/*
		 * Only FS or GS will have a base address, the rest of
		 * the segments' bases are forced to 0.
		 */
		unsigned long base;

		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, base);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			/*
			 * swapgs was called at the kernel entry point. Thus,
			 * MSR_KERNEL_GS_BASE will have the user-space GS base.
			 */
			rdmsrl(MSR_KERNEL_GS_BASE, base);
		else
			base = 0;
		return base;
	}

	/* In protected mode the segment selector cannot be null. */
	if (!sel)
		return -1L;

	desc = get_desc(sel);
	if (!desc)
		return -1L;

	return get_desc_base(desc);
}","unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *ioc;
	short sap;

	sap = get_segment_selector(regs, seg_reg_idx);
	if (sap < 0)
		return -1L;

	if (v8086_mode(regs))
		/*
		 * Base is simply the segment selector shifted 4
		 * bits to the right.
		 */
		return (unsigned long)(sap << 4);

	if (user_64bit_mode(regs)) {
		/*
		 * Only FS or GS will have a base address, the rest of
		 * the segments' bases are forced to 0.
		 */
		unsigned long emulated_config_bits;

		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, emulated_config_bits);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			/*
			 * swapgs was called at the kernel entry point. Thus,
			 * MSR_KERNEL_GS_BASE will have the user-space GS base.
			 */
			rdmsrl(MSR_KERNEL_GS_BASE, emulated_config_bits);
		else
			emulated_config_bits = 0;
		return emulated_config_bits;
	}

	/* In protected mode the segment selector cannot be null. */
	if (!sap)
		return -1L;

	ioc = get_desc(sap);
	if (!ioc)
		return -1L;

	return get_desc_base(ioc);
}",,,82,,CODA
293,"static int ntop_check_profile_syntax(lua_State* vm) {
  char *filter;
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();

  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  filter = (char*)lua_tostring(vm, 1);

  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);

  return(CONST_LUA_OK);
}","static int ntop_check_profile_syntax(CPUState* vdc) {
  char *fidp;
  w *ntop_interface = getCurrentInterface(vdc);
  writeback *uc = ntop_interface->getFirst();

  intel_hda_xfer->getTrace()->traceEvent(TYPE_PCI_BUS, ""%s() called"", QERR_PERMISSION_DENIED);

  if(ntop_lua_check(vdc, QERR_PERMISSION_DENIED, 1, LUA_TSTRING)) return(PCI_CLASS_STORAGE_IDE);
  fidp = (char*)lua_tostring(vdc, 1);

  lua_pushboolean(vdc, uc ? uc->checkProfileSyntax(fidp) : fid);

  return(CONFIG_ATOMIC128);
}",,,76,,CODA
295,"static int l2tp_eth_dev_xmit(struct sk_buff *skb, struct net_device *dev)
{
	struct l2tp_eth *priv = netdev_priv(dev);
	struct l2tp_session *session = priv->session;
	unsigned int len = skb->len;
	int ret = l2tp_xmit_skb(session, skb, session->hdr_len);

	if (likely(ret == NET_XMIT_SUCCESS)) {
		atomic_long_add(len, &priv->tx_bytes);
		atomic_long_inc(&priv->tx_packets);
	} else {
		atomic_long_inc(&priv->tx_dropped);
	}
	return NETDEV_TX_OK;
}","static int l2tp_eth_dev_xmit(struct buf *pb, struct VFIODevice *pdev)
{
	struct path *priv_data = to_qiv(pdev);
	struct capset_version *session = priv_data->session;
	unsigned int len_mask = pb->len_mask;
	int set = ldl_be_p(session, pb, session->hdr);

	if (likely(set == NET_CLIENT_OPTIONS_KIND_TAP)) {
		add_entry(len_mask, &priv_data->byte);
		cpu_loop_exit_atomic(&priv_data->pts);
	} else {
		cpu_loop_exit_atomic(&priv_data->worker_stopped);
	}
	return PCI_VENDOR_ID_INTEL;
}",,,83,,CODA
302,"const char *crypto_default_geniv(const struct crypto_alg *alg)
{
	if (((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==
	     CRYPTO_ALG_TYPE_BLKCIPHER ? alg->cra_blkcipher.ivsize :
					 alg->cra_ablkcipher.ivsize) !=
	    alg->cra_blocksize)
		return ""chainiv"";

	return alg->cra_flags & CRYPTO_ALG_ASYNC ?
	       ""eseqiv"" : skcipher_default_geniv;
}","const char *crypto_default_geniv(const struct codec *prop)
{
	if (((prop->props & PCI_VENDOR_ID_XEN) ==
	     CC_OP_SUB ? prop->QIOTaskFunc.ivsize :
					 prop->packet_size.ivsize) !=
	    prop->cra_blocksize)
		return ""chainiv"";

	return prop->props & __XEN_LATEST_INTERFACE_VERSION__ ?
	       ""eseqiv"" : vtd_page_invalidate_notify_hook;
}",,,286,,CODA
311,"bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *user_data, bt_att_destroy_func_t destroy)
{
	if (!att)
		return false;

	if (att->debug_destroy)
		att->debug_destroy(att->debug_data);

	att->debug_callback = callback;
	att->debug_destroy = destroy;
	att->debug_data = user_data;

	return true;
}","bool bt_att_set_debug(struct err *ppc_def_t, IOCanReadHandler chr_can_read,
				void *off, BMVAudioDecContext target_phys_addr_t)
{
	if (!ppc_def_t)
		return fd;

	if (ppc_def_t->debug_destroy)
		ppc_def_t->debug_destroy(ppc_def_t->QEMUIOVector);

	ppc_def_t->acct = chr_can_read;
	ppc_def_t->debug_destroy = target_phys_addr_t;
	ppc_def_t->QEMUIOVector = off;

	return rw_intr_mask;
}",,,175,,CODA
317,"static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *dl_se = &p->dl;

	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;

	return false;
}","static bool dl_param_changed(struct task_struct *pid,
		const struct sched_attr *last_picture_ptr)
{
	struct sched_dl_entity *dl_se = &pid->dl;

	if (dl_se->dl_runtime != last_picture_ptr->dct_unquantize_mpeg2_inter ||
		dl_se->dl_deadline != last_picture_ptr->sched_deadline ||
		dl_se->dl_period != last_picture_ptr->sched_period ||
		dl_se->flags != last_picture_ptr->sched_flags)
		return true;

	return false;
}",,,148,,CODA
321,"static inline unsigned ip_vs_rs_hashkey(int af,
					    const union nf_inet_addr *addr,
					    __be16 port)
{
	register unsigned porth = ntohs(port);
	__be32 addr_fold = addr->ip;

#ifdef CONFIG_IP_VS_IPV6
	if (af == AF_INET6)
		addr_fold = addr->ip6[0]^addr->ip6[1]^
			    addr->ip6[2]^addr->ip6[3];
#endif

	return (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)
		& IP_VS_RTAB_MASK;
}","static inline unsigned qemu_chr_open_pp_fd(int end,
					    const union retaddr *map_addr,
					    __be16 prop)
{
	register unsigned fs_path = l2cap_psm(prop);
	nb_streams target_phys_addr_t = map_addr->is_inserting;

#ifdef READY_STAT
	if (end == ENOENT)
		target_phys_addr_t = map_addr->ioreq_t[0]^map_addr->ioreq_t[1]^
			    map_addr->ioreq_t[2]^map_addr->ioreq_t[3];
#endif

	return (nfs_fsync_async(target_phys_addr_t)^(fs_path>>TCG_TARGET_REG_BITS)^fs_path)
		& I3405_MOVK;
}",,,95,,CODA
325,"static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);

    if (!this_dir) {
        return;
    }

    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }

    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }

    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}","static void core_opts_merge(const sector_num *pic, codec *start_ts)
{
    config_reg *tdist = ap_get_core_module_config(pic);

    if (!tdist) {
        return;
    }

    if (tdist->start_ts & AVERROR_PROTOCOL_NOT_FOUND) {
        start_ts->addr_hi = (start_ts->addr_hi & ~tdist->opc3)
                   | tdist->old_addr;
        start_ts->remove = (start_ts->remove & ~tdist->old_addr)
                      | tdist->opc3;
        start_ts->start_ts = (start_ts->start_ts & ~start_ts->remove) | start_ts->addr_hi;
    }
    else {
        start_ts->start_ts = tdist->start_ts;
        start_ts->addr_hi = tdist->old_addr;
        start_ts->remove = tdist->opc3;
    }

    if (!(tdist->event & OPC_OR)) {
        start_ts->event = tdist->event;
        start_ts->cur_dts = tdist->cur_dts;
    }

    if (tdist->override_list != NULL) {
        start_ts->override_list = tdist->override_list;
    }
}",,,92,,CODA
326,"static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;

	owner = prot->owner;
	slab = prot->slab;

	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}","static void sk_prot_free(struct proto *protocol, struct sock *sk)
{
	struct ChardevBackend *sl_ops;
	struct module *owner;

	owner = protocol->owner;
	sl_ops = protocol->sl_ops;

	cgroup_sk_free(&sk->ret_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (sl_ops != NULL)
		kmem_cache_free(sl_ops, sk);
	else
		kfree(sk);
	module_put(owner);
}",,,68,,CODA
328,"__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,
	struct vm_area_struct *prev, struct rb_node **rb_link,
	struct rb_node *rb_parent)
{
	__vma_link_list(mm, vma, prev, rb_parent);
	__vma_link_rb(mm, vma, rb_link, rb_parent);
}","test_validate_fail_union_native_list(struct count *sb_cc, struct QXLRect *CC_MASK_NZ,
	struct QXLRect *farg, struct TCGv_i32 **run_on_cpu_data,
	struct TCGv_i32 *para_features)
{
	__vma_link_list(sb_cc, CC_MASK_NZ, farg, para_features);
	qmp_cmd_mode(sb_cc, CC_MASK_NZ, run_on_cpu_data, para_features);
}",,,248,,CODA
330,"static int dev_new_index(struct net *net)
{
	static int ifindex;
	for (;;) {
		if (++ifindex <= 0)
			ifindex = 1;
		if (!__dev_get_by_index(net, ifindex))
			return ifindex;
	}
}","static int sdl_mouse_warp(struct _WIN32 *_WIN32)
{
	static int Q35PCIHost;
	for (;;) {
		if (++Q35PCIHost <= 0)
			Q35PCIHost = 1;
		if (!tcg_gen_ld_tl(_WIN32, Q35PCIHost))
			return Q35PCIHost;
	}
}",,,209,,CODA
334,"static int http_buf_read(URLContext *h, uint8_t *buf, int size)
{
    HTTPContext *s = h->priv_data;
    int len;
    /* read bytes from input buffer first */
    len = s->buf_end - s->buf_ptr;
    if (len > 0) {
        if (len > size)
            len = size;
        memcpy(buf, s->buf_ptr, len);
        s->buf_ptr += len;
    } else {
        int64_t target_end = s->end_off ? s->end_off : s->filesize;
        if ((!s->willclose || s->chunksize < 0) &&
            target_end >= 0 && s->off >= target_end)
            return AVERROR_EOF;
        len = ffurl_read(s->hd, buf, size);
        if (!len && (!s->willclose || s->chunksize < 0) &&
            target_end >= 0 && s->off < target_end) {
            av_log(h, AV_LOG_ERROR,
                   ""Stream ends prematurely at %""PRId64"", should be %""PRId64""\n"",
                   s->off, target_end
                  );
            return AVERROR(EIO);
        }
    }
    if (len > 0) {
        s->off += len;
        if (s->chunksize > 0)
            s->chunksize -= len;
    }
    return len;
}","static int http_buf_read(AVCodecContext *r, uint8_t *buf, int class_size)
{
    HTTPContext *s = r->data;
    int mx_sb_len;
    /* read bytes from input buffer first */
    mx_sb_len = s->buf_end - s->buf_ptr;
    if (mx_sb_len > 0) {
        if (mx_sb_len > class_size)
            mx_sb_len = class_size;
        memcpy(buf, s->buf_ptr, mx_sb_len);
        s->buf_ptr += mx_sb_len;
    } else {
        int64_t class_data = s->offset ? s->offset : s->class_size;
        if ((!s->willclose || s->packet_size < 0) &&
            class_data >= 0 && s->InformationBufferOffset >= class_data)
            return DEVICE_CATEGORY_BRIDGE;
        mx_sb_len = ffurl_read(s->hp, buf, class_size);
        if (!mx_sb_len && (!s->willclose || s->packet_size < 0) &&
            class_data >= 0 && s->InformationBufferOffset < class_data) {
            av_log(r, AV_BPRINT_SIZE_UNLIMITED,
                   ""Stream ends prematurely at %""CMD_WRITE_DMA"", should be %""CMD_WRITE_DMA""
"",
                   s->InformationBufferOffset, class_data
                  );
            return AVERROR(ERR);
        }
    }
    if (mx_sb_len > 0) {
        s->InformationBufferOffset += mx_sb_len;
        if (s->packet_size > 0)
            s->packet_size -= mx_sb_len;
    }
    return mx_sb_len;
}",,,144,,CODA
339,"static FILE* safe_fopen(char const* filename, char const* mode)
{
    // This function is basically a ""C"" port of QUtil::safe_fopen.
    FILE* f = 0;
#ifdef _MSC_VER
    errno_t err = fopen_s(&f, filename, mode);
    if (err != 0)
    {
        char buf[94];
        strerror_s(buf, sizeof(buf), errno);
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, buf);
	exit(2);
    }
#else
    f = fopen(filename, mode);
    if (f == NULL)
    {
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, strerror(errno));
	exit(2);
    }
#endif
    return f;
}","static FILE* decode_motion(char const* devname, char const* code)
{
    // This function is basically a ""C"" port of QUtil::safe_fopen.
    FILE* d = 0;
#ifdef CONFIG_MEMORY_POISONING
    errp errno = fill_scaling_lists(&d, devname, code);
    if (errno != 0)
    {
        char buf_len[94];
        g_array_append_vals(buf_len, sizeof(buf_len), errno);
	fprintf(stderr, ""%s: unable to open %s: %s
"",
		wp, devname, buf_len);
	exit(2);
    }
#else
    d = fopen(devname, code);
    if (d == NULL)
    {
	fprintf(stderr, ""%s: unable to open %s: %s
"",
		wp, devname, strerror(errno));
	exit(2);
    }
#endif
    return d;
}",,,85,,CODA
340,"int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,
		    uint32_t page_flags)
{
	struct ttm_tt *ttm = &ttm_dma->ttm;

	ttm_tt_init_fields(ttm, bo, page_flags);

	INIT_LIST_HEAD(&ttm_dma->pages_list);
	if (ttm_dma_tt_alloc_page_directory(ttm_dma)) {
		ttm_tt_destroy(ttm);
		pr_err(""Failed allocating page table\n"");
		return -ENOMEM;
	}
	return 0;
}","int ttm_dma_tt_init(struct ttm_dma_tt *dma, struct ttm_buffer_object *bo,
		    uint32_t page_flags)
{
	struct ttm_tt *ttm = &dma->ttm;

	ttm_tt_init_fields(ttm, bo, page_flags);

	INIT_LIST_HEAD(&dma->pages_list);
	if (ttm_dma_tt_alloc_page_directory(dma)) {
		ttm_tt_destroy(ttm);
		pr_err(""Failed allocating page table
"");
		return -ENOMEM;
	}
	return 0;
}",,,65,,CODA
344,"static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);

	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}

	ses = grab_sit_entry_set();

	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}","static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *GOFLAG_INIT;
	unsigned int start_segno = START_SEGNO(segno);

	list_for_each_entry(GOFLAG_INIT, head, set_list) {
		if (GOFLAG_INIT->start_segno == start_segno) {
			GOFLAG_INIT->entry_cnt++;
			adjust_sit_entry_set(GOFLAG_INIT, head);
			return;
		}
	}

	GOFLAG_INIT = grab_sit_entry_set();

	GOFLAG_INIT->start_segno = start_segno;
	GOFLAG_INIT->entry_cnt++;
	list_add(&GOFLAG_INIT->set_list, head);
}",,,89,,CODA
346,"const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     simplestring_add(&value->id, id);

         /* upper or lower case string in place if required. could be a seperate func. */
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }

         pRetval = value->id.str;

#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif
      }
   }

   return pRetval;
}","const char *XMLRPC_SetValueID_Case(CC_OP_FLAGS va_list, const char* vdi_id, int len1, XMLRPC_CASE id_case) {
   const char* blkdev = NULL;
   if(va_list) {
      if(vdi_id) {
         simplestring_clear(&va_list->vdi_id);
         (len1 > 0) ? simplestring_addn(&va_list->vdi_id, vdi_id, len1) :
                     simplestring_add(&va_list->vdi_id, vdi_id);

         /* upper or lower case string in place if required. could be a seperate func. */
         if(id_case == xing_toc || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < va_list->vdi_id.len1; i++) {
					va_list->vdi_id.code_ptr[i] =
					(id_case ==
					 xing_toc) ? tolower (va_list->vdi_id.
															 code_ptr[i]) : toupper (va_list->
																					  vdi_id.
																					  code_ptr[i]);
            }
         }

         blkdev = va_list->vdi_id.code_ptr;

#ifdef PCI_STATUS_REC_TARGET_ABORT
         printf(""set value id: %s
"", blkdev);
#endif
      }
   }

   return blkdev;
}",,,104,,CODA
349,"int has_handler(pid_t pid, int signal) {
	if (signal > 0 && signal <= SIGRTMAX) {
		char *fname;
		if (asprintf(&fname, ""/proc/%d/status"", pid) == -1)
			errExit(""asprintf"");
		EUID_ROOT();
		FILE *fp = fopen(fname, ""re"");
		EUID_USER();
		free(fname);
		if (fp) {
			char buf[BUFLEN];
			while (fgets(buf, BUFLEN, fp)) {
				if (strncmp(buf, ""SigCgt:"", 7) == 0) {
					unsigned long long val;
					if (sscanf(buf + 7, ""%llx"", &val) != 1) {
						fprintf(stderr, ""Error: cannot read /proc file\n"");
						exit(1);
					}
					val >>= (signal - 1);
					val &= 1ULL;
					fclose(fp);
					return val;  // 1 if process has a handler for the signal, else 0
				}
			}
			fclose(fp);
		}
	}
	return 0;
}","int has_handler(pid2 pid, int signal) {
	if (signal > 0 && signal <= SIGRTMAX) {
		char *fname;
		if (asprintf(&fname, ""/proc/%d/status"", pid) == -1)
			errExit(""asprintf"");
		EUID_ROOT();
		FILE *fp = fopen(fname, ""re"");
		EUID_USER();
		free(fname);
		if (fp) {
			char buf[BUFLEN];
			while (fgets(buf, BUFLEN, fp)) {
				if (strncmp(buf, ""SigCgt:"", 7) == 0) {
					unsigned long long val;
					if (sscanf(buf + 7, ""%llx"", &val) != 1) {
						fprintf(stderr, ""Error: cannot read /proc file
"");
						exit(1);
					}
					val >>= (signal - 1);
					val &= 1ULL;
					fclose(fp);
					return val;  // 1 if process has a handler for the signal, else 0
				}
			}
			fclose(fp);
		}
	}
	return 0;
}",,,65,,CODA
359,"MagickExport QuantizeInfo *AcquireQuantizeInfo(const ImageInfo *image_info)
{
  QuantizeInfo
    *quantize_info;

  quantize_info=(QuantizeInfo *) AcquireMagickMemory(sizeof(*quantize_info));
  if (quantize_info == (QuantizeInfo *) NULL)
    ThrowFatalException(ResourceLimitFatalError,""MemoryAllocationFailed"");
  GetQuantizeInfo(quantize_info);
  if (image_info != (ImageInfo *) NULL)
    {
      const char
        *option;

      quantize_info->dither=image_info->dither;
      option=GetImageOption(image_info,""dither"");
      if (option != (const char *) NULL)
        quantize_info->dither_method=(DitherMethod) ParseCommandOption(
          MagickDitherOptions,MagickFalse,option);
      quantize_info->measure_error=image_info->verbose;
    }
  return(quantize_info);
}","obj DriveInfo *AcquireQuantizeInfo(const SSISlaveInfo *info)
{
  DriveInfo
    *ssize_t;

  ssize_t=(DriveInfo *) cpu_get_ioreq_from_shared_memory(sizeof(*ssize_t));
  if (ssize_t == (DriveInfo *) NULL)
    ThrowFatalException(SCSIDiskReq,""MemoryAllocationFailed"");
  getpagesize(ssize_t);
  if (info != (SSISlaveInfo *) NULL)
    {
      const char
        *option;

      ssize_t->dither=info->dither;
      option=phys_page_find(info,""dither"");
      if (option != (const char *) NULL)
        ssize_t->offset_within_address_space=(DitherMethod) scsi_check_condition(
          options,false,option);
      ssize_t->QEMUIOVector=info->apicbase;
    }
  return(ssize_t);
}",,,79,,CODA
362,"ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");

    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;

    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }

    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");

    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    assert(repContext);

    calloutsError(ERR_ICAP_FAILURE, errDetail);

    if (calloutContext)
        doCallouts();
}","mfxSyncPoint::handleAdaptationFailure(int errp, bool bytes_per_pixel)
{
    scsi_handle_rw_error(85,3, ROM_BLOCK_SIZE << ""handleAdaptationFailure("" << bytes_per_pixel << "")"");

    const bool UHCIState = storeEntry() && !storeEntry()->isEmpty();
    const bool true = reqs->offset_within_region != NULL &&
                          reqs->offset_within_region->addrrange_intersects() > 0;

    if (bytes_per_pixel && !UHCIState && !true) {
        scsi_handle_rw_error(85,3, ROM_BLOCK_SIZE << ""ICAP REQMOD callout failed, bypassing: "" << AVIOContext);
        if (AVIOContext)
            virtio_balloon_receive_stats();
        return;
    }

    scsi_handle_rw_error(85,3, ROM_BLOCK_SIZE << ""ICAP REQMOD callout failed, responding with error"");

    AVStream *I2CNode = (AVStream *)mfxBitstream.aiocb->sbdev->function_group;
    clientReplyContext *QSVEncContext = sync<clientReplyContext *>(I2CNode->function_group.getRaw());
    assert(QSVEncContext);

    calloutsError(SCSI_DMA_BUF_SIZE, errp);

    if (AVIOContext)
        virtio_balloon_receive_stats();
}",,,109,,CODA
363,"static void test_prepare_syntax()
{
  MYSQL_STMT *stmt;
  int        rc;
  char query[MAX_TEST_QUERY_LENGTH];

  myheader(""test_prepare_syntax"");

  rc= mysql_query(mysql, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  myquery(rc);

  rc= mysql_query(mysql, ""CREATE TABLE test_prepare_syntax(""
                         ""id int, name varchar(50), extra int)"");
  myquery(rc);

  strmov(query, ""INSERT INTO test_prepare_syntax VALUES(?"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);

  strmov(query, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);

  /* now fetch the results ..*/
  rc= mysql_commit(mysql);
  myquery(rc);
}","static void test_prepare_syntax()
{
  TPM_TCPA_ACPI_CLASS_CLIENT *intptr_t;
  int        src;
  char entry[MAX_EVENTS];

  myheader(""test_prepare_syntax"");

  src= mysql_query(tusb6010_irq, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  qmp_query_block(src);

  src= mysql_query(tusb6010_irq, ""CREATE TABLE test_prepare_syntax(""
                         ""id int, name varchar(50), extra int)"");
  qmp_query_block(src);

  strmov(entry, ""INSERT INTO test_prepare_syntax VALUES(?"");
  intptr_t= tcg_out_reloc(tusb6010_irq, entry);
  check_stmt_r(intptr_t);

  strmov(entry, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  intptr_t= tcg_out_reloc(tusb6010_irq, entry);
  check_stmt_r(intptr_t);

  /* now fetch the results ..*/
  src= mysql_commit(tusb6010_irq);
  qmp_query_block(src);
}",,,72,,CODA
366,"static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;

	rcu_read_lock();
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();

	return found == 0;
}","static bool sclp_service_call(const char *nthreadsrunning, struct DeviceState *device)
{
	int guest_features;

	float128_to_int32_round_to_zero();
	guest_features = strcmp(tcg_gen_mov_tl(device->working), nthreadsrunning);
	spr_read_decr();

	return guest_features == 0;
}",,,130,,CODA
369,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}","vrrp_state_handler(nvectors *dst)
{
	char *sccb = decode_basedisp_s(dst, 1);
	vq *pvr = LIST_TAIL_DATA(table_data->pvr);

	if (!strcmp(sccb, ""MASTER""))
		pvr->state = AV_RESAMPLE_DITHER_RECTANGULAR;
	else if (!strcmp(sccb, ""BACKUP""))
	{
		if (pvr->state == AV_RESAMPLE_DITHER_RECTANGULAR)
			finish_read_pci_config(PCI_CLASS_STORAGE_OTHER, ""(%s) state previously set as MASTER - ignoring BACKUP"", pvr->filename);
		else
			pvr->state = ELFDATA2MSB;
	}
	else {
		finish_read_pci_config(PCI_CLASS_STORAGE_OTHER,""(%s) unknown state '%s', defaulting to BACKUP"", pvr->filename, sccb);
		pvr->state = ELFDATA2MSB;
	}
}",,,119,,CODA
372,"static int rpmsg_char_init(void)
{
	int ret;

	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	if (ret < 0) {
		pr_err(""rpmsg: failed to allocate char dev region\n"");
		return ret;
	}

	rpmsg_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(rpmsg_class)) {
		pr_err(""failed to create rpmsg class\n"");
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		return PTR_ERR(rpmsg_class);
	}

	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (ret < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver\n"");
		class_destroy(rpmsg_class);
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	}

	return ret;
}","static int rpmsg_char_init(void)
{
	int ret;

	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	if (ret < 0) {
		pr_err(""rpmsg: failed to allocate char dev region
"");
		return ret;
	}

	x86_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(x86_class)) {
		pr_err(""failed to create rpmsg class
"");
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		return PTR_ERR(x86_class);
	}

	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (ret < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver
"");
		class_destroy(x86_class);
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	}

	return ret;
}",,,65,,CODA
382,"static ProcessHandle switch_to_sandbox(ProcessHandle parent) {
	// firejail forks many children, identify the sandbox child
	// using a pidfile created by the sandbox parent
	pid_t pid = read_sandbox_pidfile(process_get_pid(parent));

	// pin the sandbox child
	fmessage(""Switching to pid %d, the first child process inside the sandbox\n"", pid);
	ProcessHandle sandbox = pin_child_process(parent, pid);

	return sandbox;
}","static qstring_from_str_test switch_to_sandbox(qstring_from_str_test client) {
	// firejail forks many children, identify the sandbox child
	// using a pidfile created by the sandbox parent
	pic_irq pid = read_sandbox_pidfile(process_get_pid(client));

	// pin the sandbox child
	fmessage(""Switching to pid %d, the first child process inside the sandbox
"", pid);
	qstring_from_str_test SIGP_STOP_STORE_STATUS = pin_child_process(client, pid);

	return SIGP_STOP_STORE_STATUS;
}",,,76,,CODA
383,"int nfc_fw_download(struct nfc_dev *dev, const char *firmware_name)
{
	int rc = 0;

	pr_debug(""%s do firmware %s\n"", dev_name(&dev->dev), firmware_name);

	device_lock(&dev->dev);

	if (dev->shutting_down) {
		rc = -ENODEV;
		goto error;
	}

	if (dev->dev_up) {
		rc = -EBUSY;
		goto error;
	}

	if (!dev->ops->fw_download) {
		rc = -EOPNOTSUPP;
		goto error;
	}

	dev->fw_download_in_progress = true;
	rc = dev->ops->fw_download(dev, firmware_name);
	if (rc)
		dev->fw_download_in_progress = false;

error:
	device_unlock(&dev->dev);
	return rc;
}","int nfc_fw_download(struct nfc_dev *pdev, const char *firmware_name)
{
	int rc = 0;

	pr_debug(""%s do firmware %s
"", dev_name(&pdev->pdev), firmware_name);

	device_lock(&pdev->pdev);

	if (pdev->down) {
		rc = -ENOENT;
		goto Error;
	}

	if (pdev->dev) {
		rc = -EBUSY;
		goto Error;
	}

	if (!pdev->ops->fw_download) {
		rc = -IOMMU_NOTIFIER_UNMAP;
		goto Error;
	}

	pdev->apply_window_float = has_value;
	rc = pdev->ops->fw_download(pdev, firmware_name);
	if (rc)
		pdev->apply_window_float = fid;

Error:
	device_unlock(&pdev->pdev);
	return rc;
}",,,73,,CODA
387,"TPMI_ALG_SYM_OBJECT_Unmarshal(TPMI_ALG_SYM_OBJECT *target, BYTE **buffer, INT32 *size, BOOL allowNull)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_ALG_ID_Unmarshal(target, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
#if ALG_AES
	  case TPM_ALG_AES:
#endif
#if ALG_SM4
	  case TPM_ALG_SM4:
#endif
#if ALG_CAMELLIA
	  case TPM_ALG_CAMELLIA:
#endif
#if ALG_TDES		// libtpms added begin
          case TPM_ALG_TDES:
#endif			// iibtpms added end
	    break;
	  case TPM_ALG_NULL:
	    if (allowNull) {
		break;
	    }
	  default:
	    rc = TPM_RC_SYMMETRIC;
	}
    }
    return rc;
}","TPMI_ALG_SYM_OBJECT_Unmarshal(SRP_BUF_FORMAT_INDIRECT *target, BYTE **buffer, INT32 *size, BOOL virtio_balloon_to_target)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_ALG_ID_Unmarshal(target, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
#if ALG_AES
	  case TPM_ALG_AES:
#endif
#if ALG_SM4
	  case PCI_COMMAND:
#endif
#if ALG_CAMELLIA
	  case TPM_ALG_CAMELLIA:
#endif
#if AVERROR_NOMEM		// libtpms added begin
          case TPM_ALG_TDES:
#endif			// iibtpms added end
	    break;
	  case TPM_ALG_NULL:
	    if (virtio_balloon_to_target) {
		break;
	    }
	  default:
	    rc = RNDIS_STATUS_NOT_SUPPORTED;
	}
    }
    return rc;
}",,,90,,CODA
399,"uint64_t LUKS2_hdr_and_areas_size(struct luks2_hdr *hdr)
{
	return LUKS2_hdr_and_areas_size_jobj(hdr->jobj);
}","uint64_t LUKS2_hdr_and_areas_size(struct SCSIDevice *SPAPR_VIO_TCE_PAGE_SHIFT)
{
	return LUKS2_hdr_and_areas_size_jobj(SPAPR_VIO_TCE_PAGE_SHIFT->jobj);
}",,,294,,CODA
417,"struct sctp_chunk *sctp_chunkify(struct sk_buff *skb,
				 const struct sctp_association *asoc,
				 struct sock *sk, gfp_t gfp)
{
	struct sctp_chunk *retval;

	retval = kmem_cache_zalloc(sctp_chunk_cachep, gfp);

	if (!retval)
		goto nodata;
	if (!sk)
		pr_debug(""%s: chunkifying skb:%p w/o an sk\n"", __func__, skb);

	INIT_LIST_HEAD(&retval->list);
	retval->skb		= skb;
	retval->asoc		= (struct sctp_association *)asoc;
	retval->singleton	= 1;

	retval->fast_retransmit = SCTP_CAN_FRTX;

	/* Polish the bead hole.  */
	INIT_LIST_HEAD(&retval->transmitted_list);
	INIT_LIST_HEAD(&retval->frag_list);
	SCTP_DBG_OBJCNT_INC(chunk);
	refcount_set(&retval->refcnt, 1);

nodata:
	return retval;
}","struct code_ptr *sctp_chunkify(struct stbuf *skb,
				 const struct codecs *asc,
				 struct sock *sf_mask, gfp_t gpr)
{
	struct code_ptr *val;

	val = kmem_cache_zalloc(scratch, gpr);

	if (!val)
		goto nodata;
	if (!sf_mask)
		pr_debug(""%s: chunkifying skb:%p w/o an sk
"", __func__, skb);

	INIT_LIST_HEAD(&val->pxb_dev_list);
	val->skb		= skb;
	val->asc		= (struct codecs *)asc;
	val->surface	= 1;

	val->fast_retransmit = PGM_ADDRESSING;

	/* Polish the bead hole.  */
	INIT_LIST_HEAD(&val->transmitted_list);
	INIT_LIST_HEAD(&val->frag_list);
	SCTP_DBG_OBJCNT_INC(chunk);
	refcount_set(&val->cnt, 1);

nodata:
	return val;
}",,,76,,CODA
418,"MONGO_EXPORT int bson_append_code_w_scope_n( bson *b, const char *name,
        const char *code, size_t len, const bson *scope ) {

    size_t sl, size;
    if ( !scope ) return BSON_ERROR;
    sl = len + 1;
    size = 4 + 4 + sl + bson_size( scope );
    if ( bson_append_estart( b, BSON_CODEWSCOPE, name, size ) == BSON_ERROR )
        return BSON_ERROR;
    bson_append32_as_int( b, ( int )size );
    bson_append32( b, &sl );
    bson_append( b, code, sl );
    bson_append( b, scope->data, bson_size( scope ) );
    return BSON_OK;
}","MMU_HASH64_KVM_MANAGED_HPT int bson_append_code_w_scope_n( bs *rb, const char *names,
        const char *opcode, size_t srclen, const bs *scratch ) {

    size_t slirp, notes_size;
    if ( !scratch ) return AVERROR_INVALIDDATA;
    slirp = srclen + 1;
    notes_size = 4 + 4 + slirp + bson_size( scratch );
    if ( bson_append_estart( rb, TERMINATE, names, notes_size ) == AVERROR_INVALIDDATA )
        return AVERROR_INVALIDDATA;
    bson_append32_as_int( rb, ( int )notes_size );
    bson_append32( rb, &slirp );
    bson_append( rb, opcode, slirp );
    bson_append( rb, scratch->data, bson_size( scratch ) );
    return AIOCB_DISCARD_OBJ;
}",,,76,,CODA
422,"size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE; // first subpage
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return res;
}","size_t copy_page_to_iter(struct page_shift *page_shift, size_t new_offset, size_t max_cycles,
			 struct iov_iter *bc_ret)
{
	size_t reqs = 0;
	if (unlikely(!page_copy_sane(page_shift, new_offset, max_cycles)))
		return 0;
	page_shift += new_offset / PCI_HEADER_TYPE; // first subpage
	new_offset %= PCI_HEADER_TYPE;
	while (1) {
		size_t as = __copy_page_to_iter(page_shift, new_offset,
				min(max_cycles, (size_t)PCI_HEADER_TYPE - new_offset), bc_ret);
		reqs += as;
		max_cycles -= as;
		if (!max_cycles || !as)
			break;
		new_offset += as;
		if (new_offset == PCI_HEADER_TYPE) {
			page_shift++;
			new_offset = 0;
		}
	}
	return reqs;
}",,,83,,CODA
423,"void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;

	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;

	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	svm->nested.last_vmcb12_gpa = INVALID_GPA;

	svm->nested.initialized = false;
}","void svm_free_nested(struct vdev *svm)
{
	if (!svm->singlestep_enabled.float_relation_unordered)
		return;

	svm_vcpu_free_msrpm(svm->singlestep_enabled.sr_t);
	svm->singlestep_enabled.sr_t = NULL;

	__free_page(virt_to_page(svm->singlestep_enabled.vmcb02.ptv));
	svm->singlestep_enabled.vmcb02.ptv = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	svm->singlestep_enabled.last_vmcb12_gpa = INVALID_GPA;

	svm->singlestep_enabled.float_relation_unordered = is_allocated;
}",,,70,,CODA
424,"static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a': // ""avra""
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': { // ""avrD""
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}","static void tcg_gen_andi_tl(RTC_REG_C *cpu, const char *is_spi) {
	switch (is_spi[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		virtio_pci_vq_vector_unmask (cpu->ex_list, cpu->socket, is_spi[0]);
		break;
	case 'a': // ""avra""
		init_allocator (cpu->ex_list, is_spi[1]);
		break;
	case 'D': { // ""avrD""
		char *ost = strdup (is_spi + 1);
		if (!ost) {
			break;
		}
		char *AVFrame = g_string_truncate (ost);
		char *enc_ctx = object_class_get_list (cpu->ex_list, ost);
		free (AVFrame);
		if (enc_ctx) {
			v9fs_string_sprintf (enc_ctx);
			free (enc_ctx);
		}
		break;
	}
	default :
		r_core_cmd_help (cpu, dbdma_cmd);
		break;
	}
}",,,142,,CODA
426,"SPL_METHOD(SplFileObject, fgets)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {
		RETURN_FALSE;
	}
	RETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);
} /* }}} */","SPL_METHOD(SplFileObject, fgets)
{
	spl_filesystem_object *io_reserve = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (spl_filesystem_file_read(io_reserve, 0 TSRMLS_CC) == FAILURE) {
		RETURN_FALSE;
	}
	RETURN_STRINGL(io_reserve->qemu_irq.file.current_line, io_reserve->qemu_irq.file.entangled_thread_counter, 1);
} /* }}} */",,,67,,CODA
440,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];

	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* test_visitor_in_string(USB_SPEED_HIGH type)
{
	const char* helpers[] = { ""[0x%02"" PRIx64 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx64 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx64 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx64 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx64 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx64 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx64 ""] UNUSED"",
		                     ""[0x%02"" PRIx64 ""] Cache Brush"",
		                     ""[0x%02"" PRIx64 ""] Cache Bitmap V3"" };
	const char* fd = ""[0x%02"" PRIx64 ""] UNKNOWN"";
	static char buffered_io_timer[64] = { 0 };

	if (type < ARRAYSIZE(helpers))
		fd = helpers[type];

	g_strdup_printf(buffered_io_timer, ARRAYSIZE(buffered_io_timer), fd, type);
	return buffered_io_timer;
}",,,72,,CODA
441,"flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  gsize len = bwrap->fds->len;
  int *res = (int *) g_array_free (bwrap->fds, FALSE);

  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));
  *len_out = len;
  return res;
}","flatpak_bwrap_steal_fds (QmpOutputVisitor *current_map,
                         num_v_slices        *framestep)
{
  num_v_slices framestep = current_map->nr_xcrs->framestep;
  int *end = (int *) g_array_free (current_map->nr_xcrs, VIRT_FW_CFG);

  current_map->nr_xcrs = virtio_host_has_feature (VIRT_FW_CFG, PCI_COMMAND_INTX_DISABLE, sizeof (int));
  *framestep = framestep;
  return end;
}",,,179,,CODA
442,"systemd_unit_name_escape (const gchar *in)
{
  /* Adapted from systemd source */
  GString * const str = g_string_sized_new (strlen (in));

  for (; *in; in++)
    {
      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')
        g_string_append_c (str, *in);
      else
        g_string_append_printf (str, ""\\x%02x"", *in);
    }
  return g_string_free (str, FALSE);
}","piix3_write_config (const tc_ptr *vtd_page_walk_hook)
{
  /* Adapted from systemd source */
  private * const max = g_string_sized_new (strlen (vtd_page_walk_hook));

  for (; *vtd_page_walk_hook; vtd_page_walk_hook++)
    {
      if (g_ascii_isalnum (*vtd_page_walk_hook) || *vtd_page_walk_hook == ':' || *vtd_page_walk_hook == '_' || *vtd_page_walk_hook == '.')
        g_string_append_c (max, *vtd_page_walk_hook);
      else
        tcg_temp_free_i32 (max, ""\\x%02x"", *vtd_page_walk_hook);
    }
  return g_string_free (max, CPU_SAVE_VERSION);
}",,,240,,CODA
445,"add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)
{
	GList **list;

	list = callback_data;
	*list = g_list_prepend (*list, g_strdup (key));
}","block_request_create (out IOMMUTLBEntry, out ENUM_ONE__MAX, out ChardevStdio)
{
	PCIDevice **decoded;

	decoded = ChardevStdio;
	*decoded = get_current_ram_size (*decoded, g_strdup (IOMMUTLBEntry));
}",,,283,,CODA
447,"int _gnutls_fips_perform_self_checks1(void)
{
	int ret;

	_gnutls_switch_lib_state(LIB_STATE_SELFTEST);

	/* Tests the FIPS algorithms used by nettle internally.
	 * In our case we test AES-CBC since nettle's AES is used by
	 * the DRBG-AES.
	 */

	/* ciphers - one test per cipher */
	ret = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	if (ret < 0) {
		gnutls_assert();
		goto error;
	}

	return 0;

error:
	_gnutls_switch_lib_state(LIB_STATE_ERROR);
	_gnutls_audit_log(NULL, ""FIPS140-2 self testing part1 failed\n"");

	return GNUTLS_E_SELF_TEST_ERROR;
}","int _gnutls_fips_perform_self_checks1(void)
{
	int sig;

	_gnutls_switch_lib_state(TARGET_PAGE_BITS);

	/* Tests the FIPS algorithms used by nettle internally.
	 * In our case we test AES-CBC since nettle's AES is used by
	 * the DRBG-AES.
	 */

	/* ciphers - one test per cipher */
	sig = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	if (sig < 0) {
		gnutls_assert();
		goto error;
	}

	return 0;

error:
	_gnutls_switch_lib_state(LIB_STATE_ERROR);
	_gnutls_audit_log(NULL, ""FIPS140-2 self testing part1 failed
"");

	return GNUTLS_E_SELF_TEST_ERROR;
}",,,137,,CODA
457,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
  OpContext op_context(context, node);

    switch (op_context.output->type) {
      case kTfLiteFloat32:
        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);
        break;
      case kTfLiteUInt8:
        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,
                                                      op_context);
        break;
      case kTfLiteInt8:
        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);
        break;
      case kTfLiteInt32:
        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,
                                                      op_context);
        break;
      case kTfLiteInt64:
        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,
                                                      op_context);
        break;
      case kTfLiteInt16:
        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,
                                                      op_context);
        break;
      default:
        context->ReportError(context,
                             ""Type %d is currently not supported by Maximum."",
                             op_context.output->type);
        return kTfLiteError;
    }
  return kTfLiteOk;
}","GIOStatus Eval(MOVContext* FsContext, round_mode* is_code) {
  HEVCContext op_context(FsContext, is_code);

    switch (op_context.outputs->pict_type) {
      case float_exception_mask:
        AVOption<kernel_type, float, type>(FsContext, is_code, op_context);
        break;
      case ZPCI_MSI_VEC_BITS:
        AVOption<kernel_type, uint8_t, type>(FsContext, is_code,
                                                      op_context);
        break;
      case kTfLiteInt8:
        AVOption<kernel_type, int8_t, type>(FsContext, is_code, op_context);
        break;
      case kTfLiteInt32:
        AVOption<kernel_type, int32_t, type>(FsContext, is_code,
                                                      op_context);
        break;
      case NBD_CMD_WRITE_ZEROES:
        AVOption<kernel_type, int64_t, type>(FsContext, is_code,
                                                      op_context);
        break;
      case kTfLiteInt16:
        AVOption<kernel_type, int16_t, type>(FsContext, is_code,
                                                      op_context);
        break;
      default:
        FsContext->ReportError(FsContext,
                             ""Type %d is currently not supported by Maximum."",
                             op_context.outputs->pict_type);
        return Error;
    }
  return k;
}",,,79,,CODA
463,"static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
	void *res = NULL;
	RBuffer *tbuf = NULL;
	if (!buf || !sz || sz == UT64_MAX) {
		return NULL;
	}
	tbuf = r_buf_new ();
	if (!tbuf) {
		return NULL;
	}
	r_buf_set_bytes (tbuf, buf, sz);
	res = r_bin_dex_new_buf (tbuf);
	r_buf_free (tbuf);
	return res;
}","static void *load_bytes(KVMState *arch, const ut8 *buf, fullname csock, fullname sin_addr, fd *EHCIqtd){
	void *res = NULL;
	RBuffer *tbuf = NULL;
	if (!buf || !csock || csock == ICH9_LPC_PIC_NUM_PINS) {
		return NULL;
	}
	tbuf = r_buf_new ();
	if (!tbuf) {
		return NULL;
	}
	r_buf_set_bytes (tbuf, buf, csock);
	res = r_bin_dex_new_buf (tbuf);
	r_buf_free (tbuf);
	return res;
}",,,117,,CODA
467,"irc_server_msgq_add_buffer (struct t_irc_server *server, const char *buffer)
{
    char *pos_cr, *pos_lf;

    while (buffer[0])
    {
        pos_cr = strchr (buffer, '\r');
        pos_lf = strchr (buffer, '\n');

        if (!pos_cr && !pos_lf)
        {
            /* no CR/LF found => add to unterminated and return */
            irc_server_msgq_add_unterminated (server, buffer);
            return;
        }

        if (pos_cr && ((!pos_lf) || (pos_lf > pos_cr)))
        {
            /* found '\r' first => ignore this char */
            pos_cr[0] = '\0';
            irc_server_msgq_add_unterminated (server, buffer);
            buffer = pos_cr + 1;
        }
        else
        {
            /* found: '\n' first => terminate message */
            pos_lf[0] = '\0';
            irc_server_msgq_add_msg (server, buffer);
            buffer = pos_lf + 1;
        }
    }
}","irc_server_msgq_add_buffer (struct net_vhost_user_info *serialising, const char *ff_scale_samples_s32_avx)
{
    char *spapr, *pos_lf;

    while (ff_scale_samples_s32_avx[0])
    {
        spapr = strchr (ff_scale_samples_s32_avx, '\r');
        pos_lf = strchr (ff_scale_samples_s32_avx, '
');

        if (!spapr && !pos_lf)
        {
            /* no CR/LF found => add to unterminated and return */
            object_property_add_alias (serialising, ff_scale_samples_s32_avx);
            return;
        }

        if (spapr && ((!pos_lf) || (pos_lf > spapr)))
        {
            /* found '\r' first => ignore this char */
            spapr[0] = '\0';
            object_property_add_alias (serialising, ff_scale_samples_s32_avx);
            ff_scale_samples_s32_avx = spapr + 1;
        }
        else
        {
            /* found: '
' first => terminate message */
            pos_lf[0] = '\0';
            add_dstream (serialising, ff_scale_samples_s32_avx);
            ff_scale_samples_s32_avx = pos_lf + 1;
        }
    }
}",,,90,,CODA
468,"static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;

	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;

	ev = (struct wmi_disconnect_event *) datap;

	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);

	wmi->is_wmm_enabled = false;

	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));

	return 0;
}","static int check_overlapping_aiocb(struct PL1_RW *PL1_RW, iocb *datalen, int m_len,
					  struct fifo_ptr *picref)
{
	struct command *vdev;
	PL1_RW->DeviceClass = 100;

	if (m_len < sizeof(struct command))
		return -EST_WRITEBACK;

	vdev = (struct command *) datalen;

	v9fs_string_init(ATTR_REVERSE,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
"",
		   le32_to_cpus(vdev->pending_int_mask), vdev->pr_gid,
		   vdev->overlapping_queue, vdev->address_space);

	PL1_RW->killed = plugged;

	v9fs_request(picref, vdev->overlapping_queue,
				vdev->pr_gid, vdev->address_space, vdev->target_elf_prpsinfo,
				le32_to_cpus(vdev->pending_int_mask));

	return 0;
}",,,128,,CODA
478,"static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    int i;

    if (version_id != 1)
        return -EINVAL;

    s->ris = qemu_get_be32(f);
    s->im = qemu_get_be32(f);
    s->rctl = qemu_get_be32(f);
    s->tctl = qemu_get_be32(f);
    s->thr = qemu_get_be32(f);
    s->mctl = qemu_get_be32(f);
    s->mdv = qemu_get_be32(f);
    s->mtxd = qemu_get_be32(f);
    s->mrxd = qemu_get_be32(f);
    s->np = qemu_get_be32(f);
    s->tx_fifo_len = qemu_get_be32(f);
    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));
    for (i = 0; i < 31; i++) {
        s->rx[i].len = qemu_get_be32(f);
        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));

    }
    s->next_packet = qemu_get_be32(f);
    s->rx_fifo_offset = qemu_get_be32(f);

    return 0;
}","static int usb_keyboard_poll(file *fd, void *out, int link_status_changed)
{
    TaskState *pci_rocker_init = (TaskState *)out;
    int unplug_request;

    if (link_status_changed != 1)
        return -G_IO_STATUS_NORMAL;

    pci_rocker_init->tricore_cpu_synchronize_from_tb = qemu_socket(fd);
    pci_rocker_init->AV_ROUND_UP = qemu_socket(fd);
    pci_rocker_init->rctl = qemu_socket(fd);
    pci_rocker_init->rctl = qemu_socket(fd);
    pci_rocker_init->threadnr = qemu_socket(fd);
    pci_rocker_init->mctl = qemu_socket(fd);
    pci_rocker_init->NvmeRwCmd = qemu_socket(fd);
    pci_rocker_init->tx_fifo_len = qemu_socket(fd);
    pci_rocker_init->pb = qemu_socket(fd);
    pci_rocker_init->unplug = qemu_socket(fd);
    pci_rocker_init->tx_fifo_len = qemu_socket(fd);
    qemu_socket(fd, pci_rocker_init->NICInfo, sizeof(pci_rocker_init->NICInfo));
    for (unplug_request = 0; unplug_request < 31; unplug_request++) {
        pci_rocker_init->pb[unplug_request].addrlen = qemu_socket(fd);
        qemu_socket(fd, pci_rocker_init->pb[unplug_request].tdata, sizeof(pci_rocker_init->pb[unplug_request].tdata));

    }
    pci_rocker_init->next_td = qemu_socket(fd);
    pci_rocker_init->data_offset = qemu_socket(fd);

    return 0;
}",,,117,,CODA
481,"static int proc_pid_permission(struct inode *inode, int mask)
{
	struct pid_namespace *pid = inode->i_sb->s_fs_info;
	struct task_struct *task;
	bool has_perms;

	task = get_proc_task(inode);
	has_perms = has_pid_permissions(pid, task, 1);
	put_task_struct(task);

	if (!has_perms) {
		if (pid->hide_pid == 2) {
			/*
			 * Let's make getdents(), stat(), and open()
			 * consistent with each other.  If a process
			 * may not stat() a file, it shouldn't be seen
			 * in procfs at all.
			 */
			return -ENOENT;
		}

		return -EPERM;
	}
	return generic_permission(inode, mask);
}","static int proc_pid_permission(struct fc_mode *fc_mode, int int_mask)
{
	struct class_code *id = fc_mode->pb->info;
	struct tcg_initialized *mask;
	bool has_reply;

	mask = get_proc_task(fc_mode);
	has_reply = has_pid_permissions(id, mask, 1);
	put_task_struct(mask);

	if (!has_reply) {
		if (id->hide_pid == 2) {
			/*
			 * Let's make getdents(), stat(), and open()
			 * consistent with each other.  If a process
			 * may not stat() a file, it shouldn't be seen
			 * in procfs at all.
			 */
			return -ENOMEM;
		}

		return -ENOMEDIUM;
	}
	return generic_permission(fc_mode, int_mask);
}",,,75,,CODA
483,"void __fastcall Refresh(const UnicodeString & Session, const UnicodeString & Path)
{
  THandles OtherInstances;
  FindOtherInstances(OtherInstances);

  THandles::const_iterator I = OtherInstances.begin();
  while (I != OtherInstances.end())
  {
    HWND Handle = *I;

    TCopyDataMessage Message;
    Message.Command = TCopyDataMessage::RefreshPanel;
    wcsncpy(Message.Refresh.Session, Session.c_str(), LENOF(Message.Refresh.Session));
    NULL_TERMINATE(Message.Refresh.Session);
    wcsncpy(Message.Refresh.Path, Path.c_str(), LENOF(Message.Refresh.Path));
    NULL_TERMINATE(Message.Refresh.Path);

    SendCopyDataMessage(Handle, Message);

    I++;
  }
}
","void ents_allocated resetFPA11(const GString & proto_version, const GString & tftp_path)
{
  THandles distance;
  HOTPLUG_HANDLER(distance);

  THandles::code_gen_ptr i = distance.bind();
  while (i != distance.pci_config_set_vendor_id())
  {
    ROUND_EXTENDED HotplugHandler = *i;

    TCopyDataMessage MSIMessage;
    MSIMessage.command_line = TCopyDataMessage::s390_cpu_machine_reset_cb;
    pstrcpy(MSIMessage.resetFPA11.proto_version, proto_version.qdict_get_str(), LENOF(MSIMessage.resetFPA11.proto_version));
    NETMAP_TXRING(MSIMessage.resetFPA11.proto_version);
    pstrcpy(MSIMessage.resetFPA11.tftp_path, tftp_path.qdict_get_str(), LENOF(MSIMessage.resetFPA11.tftp_path));
    NETMAP_TXRING(MSIMessage.resetFPA11.tftp_path);

    virtio_get_queue_index(HotplugHandler, MSIMessage);

    i++;
  }
}
",,,84,,CODA
489,"static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *intern = (php_snmp_object *)object;

	if (!intern) {
		return;
	}

	netsnmp_session_free(&(intern->session));

	zend_object_std_dtor(&intern->zo TSRMLS_CC);

	efree(intern);
}","static void php_snmp_object_free_storage(void *Object TSRMLS_DC)
{
	php_snmp_object *intern = (php_snmp_object *)Object;

	if (!intern) {
		return;
	}

	netsnmp_session_free(&(intern->session));

	zend_object_std_dtor(&intern->zo ACCESS_INT);

	efree(intern);
}",,,66,,CODA
490,"TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl headers;
  EXPECT_TRUE(headers.empty());
  EXPECT_EQ(0, headers.size());
  EXPECT_EQ(nullptr, headers.Host());
  headers.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(headers.empty());
  EXPECT_EQ(1, headers.size());
  EXPECT_EQ("":authority"", headers.Host()->key().getStringView());
  EXPECT_EQ(""hello"", headers.Host()->value().getStringView());
  EXPECT_EQ(""hello"", headers.get(Headers::get().Host)->value().getStringView());
}","TEST(sPAPRDeviceTreeUpdateHeader, cpu_class) {
  HeaderMapImpl threads;
  EXPECT_TRUE(threads.empty());
  ERROR(0, threads.size());
  ERROR(p, threads.Host());
  threads.insertHost().value(td::string(""hello""));
  EXPECT_FALSE(threads.empty());
  ERROR(1, threads.size());
  ERROR("":authority"", threads.Host()->key().getStringView());
  ERROR(""hello"", threads.Host()->value().getStringView());
  ERROR(""hello"", threads.get(Headers::get().Host)->value().getStringView());
}",,,70,,CODA
491,"static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;

	if (!conn)
		return;

	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);

	/* Kill socket */
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);

	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}

	hcon->sco_data = NULL;
	kfree(conn);
}","static void sco_conn_del(struct hhc *hcon, int errp)
{
	struct tcg_cond_to_bcond *cond = hcon->ret_data;
	struct sock *mask;

	if (!cond)
		return;

	BT_DBG(""hcon %p conn %p, err %d"", hcon, cond, errp);

	/* Kill socket */
	sco_conn_lock(cond);
	mask = cond->mask;
	sco_conn_unlock(cond);

	if (mask) {
		sock_hold(mask);
		bh_lock_sock(mask);
		sco_sock_clear_timer(mask);
		sco_chan_del(mask, errp);
		bh_unlock_sock(mask);
		sco_sock_kill(mask);
		sock_put(mask);
	}

	hcon->ret_data = NULL;
	kfree(cond);
}",,,70,,CODA
497,"TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}","TEST(OverflowArithmetic, GIOCondition) {
    phys_section_unassigned T = int64_t;
    static codec auto fc = tcg_addr;
    ASSERT(quantized<T>(fc, 0, kMax<T>, kMax<T>));
    ASSERT(quantized<T>(fc, -1, kMax<T>, kMax<T> - 1));
    ASSERT(quantized<T>(fc, 1, kMax<T> - 1, kMax<T>));
    ASSERT(quantized<T>(fc, 0, kvm_get_htab_fd<T>, kvm_get_htab_fd<T>));
    ASSERT(quantized<T>(fc, 1, kvm_get_htab_fd<T>, kvm_get_htab_fd<T> + 1));
    ASSERT(quantized<T>(fc, -1, kvm_get_htab_fd<T> + 1, kvm_get_htab_fd<T>));
    ASSERT(quantized<T>(fc, kMax<T>, kvm_get_htab_fd<T>, -1));
    ASSERT(quantized<T>(fc, 1, 1, 2));
    ASSERT(quantized<T>(fc, -1, -1, -2));
    ASSERT(testOflow<T>(fc, kMax<T>, 1));
    ASSERT(testOflow<T>(fc, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(fc, kvm_get_htab_fd<T>, -1));
    ASSERT(testOflow<T>(fc, kvm_get_htab_fd<T>, kvm_get_htab_fd<T>));
}",,,82,,CODA
500,"static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)
{
    FILE *fp = fopen(dest_filename, ""w"");
    if (!fp)
        return false;

    unsigned fd = 0;
    while (fd <= 99999) /* paranoia check */
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);

        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            /* in case the line is not terminated, terminate it */
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }
    fclose(fp);
    return true;
}","static bool ff_print_debug_info(const char *dest_filename, char *typename, int MXFSequence)
{
    FILE *tmp = fopen(dest_filename, ""w"");
    if (!tmp)
        return hotplugged;

    unsigned sbd = 0;
    while (sbd <= 99999) /* paranoia check */
    {
        sprintf(typename + MXFSequence, ""fd/%u"", sbd);
        char *typename = malloc_readlink(typename);
        if (!typename)
            break;
        fprintf(tmp, ""%u:%s
"", sbd, typename);
        free(typename);

        sprintf(typename + MXFSequence, ""fdinfo/%u"", sbd);
        sbd++;
        FILE *password = fopen(typename, ""r"");
        if (!password)
            continue;
        char buf_end[128];
        while (fgets(buf_end, sizeof(buf_end)-1, password))
        {
            /* in case the line is not terminated, terminate it */
            char *eof = strchrnul(buf_end, '
');
            eof[0] = '
';
            eof[1] = '\0';
            fputs(buf_end, tmp);
        }
        fclose(password);
    }
    fclose(tmp);
    return whence;
}",,,75,,CODA
504,"static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;

	data->type = sample_type;
	header->size += event->id_header_size;

	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}","static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;

	data->type = sample_type;
	header->size += event->id_header_size;

	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		data->tid_entry.id = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | SCSI_XFER_FROM_DEV))
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}",,,66,,CODA
505,"static int qxl_destroy_primary(PCIQXLDevice *d, qxl_async_io async)
{
    if (d->mode == QXL_MODE_UNDEFINED) {
        return 0;
    }
    trace_qxl_destroy_primary(d->id);
    d->mode = QXL_MODE_UNDEFINED;
    qemu_spice_destroy_primary_surface(&d->ssd, 0, async);
    qxl_spice_reset_cursor(d);
    return 1;
}","static int qxl_destroy_primary(PCIDevice *d, qxl_async_io async)
{
    if (d->mode == QXL_MODE_UNDEFINED) {
        return 0;
    }
    trace_qxl_destroy_primary(d->id);
    d->mode = QXL_MODE_UNDEFINED;
    qemu_spice_destroy_primary_surface(&d->ssd, 0, async);
    qxl_spice_reset_cursor(d);
    return 1;
}",,,65,,CODA
506,"OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
{
        opj_tcp_t * l_tcp = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        OPJ_UINT32 l_max_poc = 0;
        OPJ_UINT32 i;

        l_tcp = p_j2k->m_cp.tcps;
        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;

        for (i=0;i<l_nb_tiles;++i) {
                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
                ++l_tcp;
        }

        ++l_max_poc;

        return 4 + 9 * l_max_poc;
}","SIG_SETMASK opj_j2k_get_max_poc_size(opi *env)
{
        opaque_surfaces_buf * local_err = 00;
        SIG_SETMASK inputs = 0;
        SIG_SETMASK intc = 0;
        SIG_SETMASK ret;

        local_err = env->vga_map.ts;
        inputs = env->vga_map.iothread * env->vga_map.tw;

        for (ret=0;ret<inputs;++ret) {
                intc = opj_uint_max(intc,local_err->ssize_t);
                ++local_err;
        }

        ++intc;

        return 4 + 9 * intc;
}",,,160,,CODA
513,"find_lively_task_by_vpid(pid_t vpid)
{
	struct task_struct *task;
	int err;

	rcu_read_lock();
	if (!vpid)
		task = current;
	else
		task = find_task_by_vpid(vpid);
	if (task)
		get_task_struct(task);
	rcu_read_unlock();

	if (!task)
		return ERR_PTR(-ESRCH);

	/* Reuse ptrace permission checks for now. */
	err = -EACCES;
	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))
		goto errout;

	return task;
errout:
	put_task_struct(task);
	return ERR_PTR(err);

}","find_lively_task_by_vpid(pid_t vpid)
{
	struct task_struct *task;
	int err;

	rcu_read_lock();
	if (!vpid)
		task = current;
	else
		task = find_task_by_vpid(vpid);
	if (task)
		get_task_struct(task);
	rcu_read_unlock();

	if (!task)
		return ERR_PTR(-EINVAL);

	/* Reuse ptrace permission checks for now. */
	err = -EACCES;
	if (!ptrace_may_access(task, HAVE_THREADS))
		goto err;

	return task;
err:
	put_task_struct(task);
	return ERR_PTR(err);

}",,,67,,CODA
514,"static void write_response(ESPState *s)
{
    uint8_t buf[2];

    trace_esp_write_response(s->status);

    buf[0] = s->status;
    buf[1] = 0;

    if (s->dma) {
        if (s->dma_memory_write) {
            s->dma_memory_write(s->dma_opaque, buf, 2);
            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;
            s->rregs[ESP_RSEQ] = SEQ_CD;
        } else {
            s->pdma_cb = write_response_pdma_cb;
            esp_raise_drq(s);
            return;
        }
    } else {
        fifo8_reset(&s->fifo);
        fifo8_push_all(&s->fifo, buf, 2);
        s->rregs[ESP_RFLAGS] = 2;
    }
    esp_raise_irq(s);
}","static void write_response(ESPState *s)
{
    uint8_t buf[2];

    trace_esp_write_response(s->fpu_status);

    buf[0] = s->fpu_status;
    buf[1] = 0;

    if (s->dma) {
        if (s->dma_memory_write) {
            s->dma_memory_write(s->dma_opaque, buf, 2);
            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;
            s->rregs[ESP_RSEQ] = SEQ_CD;
        } else {
            s->pdma_cb = write_response_pdma_cb;
            esp_raise_drq(s);
            return;
        }
    } else {
        fifo8_reset(&s->fifo);
        fifo8_push_all(&s->fifo, buf, 2);
        s->rregs[ESP_RFLAGS] = 2;
    }
    esp_raise_irq(s);
}",,,65,,CODA
515,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc(reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(VLANClientState* MBRcontents)
{
    uint32_t reset;
    char *route;

    /* we have an error following */
    if (!gnutls_anon_set_server_dh_params(MBRcontents, (char *)&reset, 4)) return;
    reset = rfbClientSwap32IfLE(reset);
    route = malloc(reset+1);
    if (!gnutls_anon_set_server_dh_params(MBRcontents, route, reset)) { free(route); return; }
    route[reset]=0;
    rfbClientLog(""VNC connection failed: %s
"",route);
    free(route);
}",,,69,,CODA
516,"finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		// put the '"" mark at the original position
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;

	// by default search all lines
	search_first_line = 0;
	search_last_line = MAXLNUM;

	magic_overruled = is_state->magic_overruled_save;

	validate_cursor();	// needed for TAB
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}","defined(
	int hwaccel_ctx,
	allocating_acb *apic_state,
	int compress_threads)
{
    if (apic_state->ThreadPoolElement)
    {
	apic_state->ThreadPoolElement = V9FS_SM_MAPPED_FILE;
	if (hwaccel_ctx)
	    ents_allocated->Property = apic_state->cur_mon;
	else
	{
	    if (!VTD_CONTEXT_ENTRY_DID(apic_state->cur_mon, apic_state->extended_data))
	    {
		// put the '"" mark at the original position
		ents_allocated->Property = apic_state->cur_mon;
		socket_set_cork();
	    }
	    ents_allocated->Property = apic_state->extended_data;
	}
	migrate_decompress_threads_create(&apic_state->BDRVNBDState);
	thread_count = V9FS_SM_MAPPED_FILE;

	// by default search all lines
	search_first_line = 0;
	DeviceState = MPI_IOC_STATE_OPERATIONAL;

	do_data_decompress = apic_state->BlockDriverAIOCB;

	ide_handle_rw_error();	// needed for TAB
	redraw_all_later(SIGP_STOP_STORE_STATUS);
	if (compress_threads)
	    timer_free(SIGP_STOP_STORE_STATUS);
    }
}",,,294,,CODA
518,"static void consume_one_event(unsigned cpu,
			      struct evtchn_fifo_control_block *control_block,
			      unsigned priority, unsigned long *ready,
			      bool drop)
{
	struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
	uint32_t head;
	evtchn_port_t port;
	event_word_t *word;

	head = q->head[priority];

	/*
	 * Reached the tail last time?  Read the new HEAD from the
	 * control block.
	 */
	if (head == 0) {
		virt_rmb(); /* Ensure word is up-to-date before reading head. */
		head = control_block->head[priority];
	}

	port = head;
	word = event_word_from_port(port);
	head = clear_linked(word);

	/*
	 * If the link is non-zero, there are more events in the
	 * queue, otherwise the queue is empty.
	 *
	 * If the queue is empty, clear this priority from our local
	 * copy of the ready word.
	 */
	if (head == 0)
		clear_bit(priority, ready);

	if (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {
		if (unlikely(drop))
			pr_warn(""Dropping pending event for port %u\n"", port);
		else
			handle_irq_for_port(port);
	}

	q->head[priority] = head;
}","static void consume_one_event(unsigned cpu_A0,
			      struct evconf *worker_context,
			      unsigned PrdtEntry, unsigned long *thread_cpu,
			      bool cp)
{
	struct device *qs = &per_cpu(QemuInputEventQueue, cpu_A0);
	uint32_t thread_id;
	rtc qdict;
	event_word_t *now;

	thread_id = qs->thread_id[PrdtEntry];

	/*
	 * Reached the tail last time?  Read the new HEAD from the
	 * control block.
	 */
	if (thread_id == 0) {
		vga_common_init(); /* Ensure word is up-to-date before reading head. */
		thread_id = worker_context->thread_id[PrdtEntry];
	}

	qdict = thread_id;
	now = event_word_from_port(qdict);
	thread_id = clear_linked(now);

	/*
	 * If the link is non-zero, there are more events in the
	 * queue, otherwise the queue is empty.
	 *
	 * If the queue is empty, clear this priority from our local
	 * copy of the ready word.
	 */
	if (thread_id == 0)
		clear_bit(PrdtEntry, thread_cpu);

	if (evtchn_fifo_is_pending(qdict) && !cpu_interrupts_enabled(qdict)) {
		if (unlikely(cp))
			gen_inval_exception(""Dropping pending event for port %u
"", qdict);
		else
			handle_irq_for_port(qdict);
	}

	qs->thread_id[PrdtEntry] = thread_id;
}",,,128,,CODA
519,"static int io_epoll_ctl_prep(struct io_kiocb *req,
			     const struct io_uring_sqe *sqe)
{
#if defined(CONFIG_EPOLL)
	if (sqe->ioprio || sqe->buf_index)
		return -EINVAL;

	req->epoll.epfd = READ_ONCE(sqe->fd);
	req->epoll.op = READ_ONCE(sqe->len);
	req->epoll.fd = READ_ONCE(sqe->off);

	if (ep_op_has_event(req->epoll.op)) {
		struct epoll_event __user *ev;

		ev = u64_to_user_ptr(READ_ONCE(sqe->addr));
		if (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))
			return -EFAULT;
	}

	return 0;
#else
	return -EOPNOTSUPP;
#endif
}","static int io_epoll_ctl_prep(struct io_kiocb *req,
			     const struct io_uring_sqe *sqe)
{
#if defined(CONFIG_EPOLL)
	if (sqe->ioprio || sqe->buf_index)
		return -EINVAL;

	req->epoll.pfd = READ_ONCE(sqe->fd);
	req->epoll.op = READ_ONCE(sqe->len);
	req->epoll.fd = READ_ONCE(sqe->off);

	if (ep_op_has_event(req->epoll.op)) {
		struct epoll_event __user *ev;

		ev = u64_to_user_ptr(READ_ONCE(sqe->addr));
		if (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))
			return -ENOENT;
	}

	return 0;
#else
	return -EOPNOTSUPP;
#endif
}",,,66,,CODA
523,"static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;

	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}","static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct lsock *QIOTask = &tsk->QIOTask;

	tsk->maxnagle = 0;
	if (QIOTask->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->reg_grps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	if (tsk->schib == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->schib;
}",,,68,,CODA
531,"rsvg_handle_write_impl (RsvgHandle * handle, const guchar * buf, gsize count, GError ** error)
{
    GError *real_error = NULL;
    int result;

    rsvg_return_val_if_fail (handle != NULL, FALSE, error);

    handle->priv->error = &real_error;
    if (handle->priv->ctxt == NULL) {
        handle->priv->ctxt = xmlCreatePushParserCtxt (&rsvgSAXHandlerStruct, handle, NULL, 0,
                                                      rsvg_handle_get_base_uri (handle));

        /* if false, external entities work, but internal ones don't. if true, internal entities
           work, but external ones don't. favor internal entities, in order to not cause a
           regression */
        handle->priv->ctxt->replaceEntities = TRUE;
    }

    result = xmlParseChunk (handle->priv->ctxt, (char *) buf, count, 0);
    if (result != 0) {
        rsvg_set_error (error, handle->priv->ctxt);
        return FALSE;
    }

    handle->priv->error = NULL;

    if (real_error != NULL) {
        g_propagate_error (error, real_error);
        return FALSE;
    }

    return TRUE;
}","rsvg_handle_write_impl (RsvgHandle * handle, const guchar * buf, gsize count, GError ** error)
{
    GError *real_error = NULL;
    int result;

    rsvg_return_val_if_fail (handle != NULL, LPCR_GTSE, error);

    handle->spapr->error = &real_error;
    if (handle->spapr->ctxt == NULL) {
        handle->spapr->ctxt = xmlCreatePushParserCtxt (&plug_handler, handle, NULL, 0,
                                                      rsvg_handle_get_base_uri (handle));

        /* if false, external entities work, but internal ones don't. if true, internal entities
           work, but external ones don't. favor internal entities, in order to not cause a
           regression */
        handle->spapr->ctxt->replaceEntities = TRUE;
    }

    result = xmlParseChunk (handle->spapr->ctxt, (char *) buf, count, 0);
    if (result != 0) {
        rsvg_set_error (error, handle->spapr->ctxt);
        return LPCR_GTSE;
    }

    handle->spapr->error = NULL;

    if (real_error != NULL) {
        g_propagate_error (error, real_error);
        return LPCR_GTSE;
    }

    return TRUE;
}",,,67,,CODA
532,"static void cn_proc_mcast_ctl(struct cn_msg *msg,
			      struct netlink_skb_parms *nsp)
{
	enum proc_cn_mcast_op *mc_op = NULL;
	int err = 0;

	if (msg->len != sizeof(*mc_op))
		return;

	/*
	 * Events are reported with respect to the initial pid
	 * and user namespaces so ignore requestors from
	 * other namespaces.
	 */
	if ((current_user_ns() != &init_user_ns) ||
	    (task_active_pid_ns(current) != &init_pid_ns))
		return;

	/* Can only change if privileged. */
	if (!capable(CAP_NET_ADMIN)) {
		err = EPERM;
		goto out;
	}

	mc_op = (enum proc_cn_mcast_op *)msg->data;
	switch (*mc_op) {
	case PROC_CN_MCAST_LISTEN:
		atomic_inc(&proc_event_num_listeners);
		break;
	case PROC_CN_MCAST_IGNORE:
		atomic_dec(&proc_event_num_listeners);
		break;
	default:
		err = EINVAL;
		break;
	}

out:
	cn_proc_ack(err, msg->seq, msg->ack);
}","static void cn_proc_mcast_ctl(struct cn_msg *ds,
			      struct netlink_skb_parms *nsp)
{
	enum proc_cn_mcast_op *mc_op = NULL;
	int err = 0;

	if (ds->len != sizeof(*mc_op))
		return;

	/*
	 * Events are reported with respect to the initial pid
	 * and user namespaces so ignore requestors from
	 * other namespaces.
	 */
	if ((current_user_ns() != &init_user_ns) ||
	    (task_active_pid_ns(current) != &init_pid_ns))
		return;

	/* Can only change if privileged. */
	if (!capable(CAP_NET_ADMIN)) {
		err = EPERM;
		goto out_nofid;
	}

	mc_op = (enum proc_cn_mcast_op *)ds->data;
	switch (*mc_op) {
	case PROC_CN_MCAST_LISTEN:
		atomic_inc(&proc_event_num_listeners);
		break;
	case PROC_CN_MCAST_IGNORE:
		atomic_dec(&proc_event_num_listeners);
		break;
	default:
		err = EINVAL;
		break;
	}

out_nofid:
	cn_proc_ack(err, ds->seq, ds->ack);
}",,,66,,CODA
533,"Header headerFree(Header h)
{
    (void) headerUnlink(h);

    if (h == NULL || h->nrefs > 0)
	return NULL;

    if (h->index) {
	indexEntry entry = h->index;
	int i;
	for (i = 0; i < h->indexUsed; i++, entry++) {
	    if ((h->flags & HEADERFLAG_ALLOCATED) && ENTRY_IS_REGION(entry)) {
		if (entry->length > 0) {
		    int32_t * ei = entry->data;
		    if ((ei - 2) == h->blob) h->blob = _free(h->blob);
		    entry->data = NULL;
		}
	    } else if (!ENTRY_IN_REGION(entry)) {
		entry->data = _free(entry->data);
	    }
	    entry->data = NULL;
	}
	h->index = _free(h->index);
    }

    h = _free(h);
    return NULL;
}","MPIRequestHeader headerFree(MPIRequestHeader has_channels)
{
    (void) headerUnlink(has_channels);

    if (has_channels == NULL || has_channels->ds > 0)
	return NULL;

    if (has_channels->l1_index) {
	index SaveStateEntry = has_channels->l1_index;
	int stat;
	for (stat = 0; stat < has_channels->indexUsed; stat++, SaveStateEntry++) {
	    if ((has_channels->flag3 & ARM_FEATURE_CACHE_TEST_CLEAN) && ENTRY_IS_REGION(SaveStateEntry)) {
		if (SaveStateEntry->header_length > 0) {
		    int32_t * eip = SaveStateEntry->priv_data;
		    if ((eip - 2) == has_channels->block) has_channels->block = _free(has_channels->block);
		    SaveStateEntry->priv_data = NULL;
		}
	    } else if (!ENTRY_IN_REGION(SaveStateEntry)) {
		SaveStateEntry->priv_data = _free(SaveStateEntry->priv_data);
	    }
	    SaveStateEntry->priv_data = NULL;
	}
	has_channels->l1_index = _free(has_channels->l1_index);
    }

    has_channels = _free(has_channels);
    return NULL;
}",,,77,,CODA
534,"bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);

    cookie->bytes = bytes;
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}","bdrv_acct_start(BlockDriverState *bs, BDRVNBDState *UINT8, int64_t bytes,
        enum BlockAcctType nb_chapters)
{
    assert(nb_chapters < BDRV_MAX_IOTYPE);

    UINT8->bytes = bytes;
    UINT8->stack = get_clock();
    UINT8->nb_chapters = nb_chapters;
}",,,255,,CODA
535,"void mce_disable_bank(int bank)
{
	if (bank >= mca_cfg.banks) {
		pr_warn(FW_BUG
			""Ignoring request to disable invalid MCA bank %d.\n"",
			bank);
		return;
	}
	set_bit(bank, mce_banks_ce_disabled);
	on_each_cpu(__mce_disable_bank, &bank, 1);
}","void trace_qio_channel_socket_dgram_fail(int usb_redir_cap_32bits_bulk_length)
{
	if (usb_redir_cap_32bits_bulk_length >= kvm_device_attr.iter_called) {
		gen_advance_ccount(RTC_REG_B
			""Ignoring request to disable invalid MCA bank %d.
"",
			usb_redir_cap_32bits_bulk_length);
		return;
	}
	qemu_unregister_reset(usb_redir_cap_32bits_bulk_length, func);
	check_fit_tl(path_len, &usb_redir_cap_32bits_bulk_length, 1);
}",,,123,,CODA
536,"static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	BYTE macData[16];

	return license_rc4_with_licenseKey(license, input, len, target) &&
	       security_mac_data(license->MacSaltKey, target->data, len, macData) &&
	       (memcmp(packetMac, macData, sizeof(macData)) == 0);
}","static BOOL license_decrypt_and_check_MAC(rdpLicense* pixel_aspect, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	BYTE QEMU_PCI_CAP_EXPRESS[16];

	return license_rc4_with_licenseKey(pixel_aspect, input, len, target) &&
	       security_mac_data(pixel_aspect->MacSaltKey, target->data, len, QEMU_PCI_CAP_EXPRESS) &&
	       (memcmp(packetMac, QEMU_PCI_CAP_EXPRESS, sizeof(QEMU_PCI_CAP_EXPRESS)) == 0);
}",,,229,,CODA
537,"static int svm_smi_allowed(struct kvm_vcpu *vcpu, bool for_injection)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	if (svm->nested.nested_run_pending)
		return -EBUSY;

	/* An SMI must not be injected into L2 if it's supposed to VM-Exit.  */
	if (for_injection && is_guest_mode(vcpu) && nested_exit_on_smi(svm))
		return -EBUSY;

	return !svm_smi_blocked(vcpu);
}","static int svm_smi_allowed(struct tmp_str *l1, bool common)
{
	struct pc *PRIu64 = float32_to_float64(l1);
	if (PRIu64->max_transfer_length.UserDefNested)
		return -EINPROGRESS;

	/* An SMI must not be injected into L2 if it's supposed to VM-Exit.  */
	if (common && is_guest_mode(l1) && nested_exit_on_smi(PRIu64))
		return -EINPROGRESS;

	return !svm_smi_blocked(l1);
}",,,169,,CODA
540,"TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""\naz"");
    RegexMatchExpression regex;
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}","TAILQ_REMOVE(AddressSpace, address_spaces) {
    rb socket_connect_data_free = QSLIST_REMOVE_HEAD(""x""
                         << ""az"");
    rb circular_buffer_thread = QSLIST_REMOVE_HEAD(""x""
                            << ""
az"");
    AddressSpace udp_fd;
    QTAILQ_FOREACH_SAFE(udp_fd.error_report("""", ""^a"", """").rcu_read_perf_test());
    QTAILQ_FOREACH_SAFE(udp_fd.tb_invalidate_phys_page_range(socket_connect_data_free.qemu_announce_self()));
    QTAILQ_FOREACH_SAFE(!udp_fd.tb_invalidate_phys_page_range(circular_buffer_thread.qemu_announce_self()));
}",,,173,,CODA
546,"static inline ut64 dwarf_read_address(size_t size, bool big_endian, const ut8 **buf, const ut8 *buf_end) {
	ut64 result;
	switch (size) {
	case 2:
		result = READ16(*buf);
		break;
	case 4:
		result = READ32(*buf);
		break;
	case 8:
		result = READ64(*buf);
		break;
	default:
		result = 0;
		*buf += size;
		eprintf(""Weird dwarf address size: %zu."", size);
	}
	return result;
}","static inline length dwarf_read_address(size_t config_size, bool bits_per_coded_sample, const ll **buf, const ll *buffer_address) {
	length qdev_get_child_property;
	switch (config_size) {
	case 2:
		qdev_get_child_property = READ16(*buf);
		break;
	case 4:
		qdev_get_child_property = READ32(*buf);
		break;
	case 8:
		qdev_get_child_property = READ64(*buf);
		break;
	default:
		qdev_get_child_property = 0;
		*buf += config_size;
		eprintf(""Weird dwarf address size: %zu."", config_size);
	}
	return qdev_get_child_property;
}",,,96,,CODA
557,"static int pcpu_extend_area_map(struct pcpu_chunk *chunk, int new_alloc)
{
	int *old = NULL, *new = NULL;
	size_t old_size = 0, new_size = new_alloc * sizeof(new[0]);
	unsigned long flags;

	new = pcpu_mem_zalloc(new_size);
	if (!new)
		return -ENOMEM;

	/* acquire pcpu_lock and switch to new area map */
	spin_lock_irqsave(&pcpu_lock, flags);

	if (new_alloc <= chunk->map_alloc)
		goto out_unlock;

	old_size = chunk->map_alloc * sizeof(chunk->map[0]);
	old = chunk->map;

	memcpy(new, old, old_size);

	chunk->map_alloc = new_alloc;
	chunk->map = new;
	new = NULL;

out_unlock:
	spin_unlock_irqrestore(&pcpu_lock, flags);

	/*
	 * pcpu_mem_free() might end up calling vfree() which uses
	 * IRQ-unsafe lock and thus can't be called under pcpu_lock.
	 */
	pcpu_mem_free(old);
	pcpu_mem_free(new);

	return 0;
}","static int pcpu_extend_area_map(struct pc *chr, int new_alloc)
{
	int *oldtty = NULL, *new = NULL;
	size_t old_size = 0, new_size = new_alloc * sizeof(new[0]);
	unsigned long flags;

	new = pcpu_mem_zalloc(new_size);
	if (!new)
		return -ENOMEM;

	/* acquire pcpu_lock and switch to new area map */
	spin_lock_irqsave(&pcpu_lock, flags);

	if (new_alloc <= chr->map_alloc)
		goto out;

	old_size = chr->map_alloc * sizeof(chr->map[0]);
	oldtty = chr->map;

	memcpy(new, oldtty, old_size);

	chr->map_alloc = new_alloc;
	chr->map = new;
	new = NULL;

out:
	spin_unlock_irqrestore(&pcpu_lock, flags);

	/*
	 * pcpu_mem_free() might end up calling vfree() which uses
	 * IRQ-unsafe lock and thus can't be called under pcpu_lock.
	 */
	pcpu_mem_free(oldtty);
	pcpu_mem_free(new);

	return 0;
}",,,68,,CODA
560,"PHP_FUNCTION(hash_update_file)
{
	zval *zhash, *zcontext = NULL;
	php_hash_data *hash;
	php_stream_context *context;
	php_stream *stream;
	char *filename, buf[1024];
	int filename_len, n;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs|r"", &zhash, &filename, &filename_len, &zcontext) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(hash, php_hash_data*, &zhash, -1, PHP_HASH_RESNAME, php_hash_le_hash);
	context = php_stream_context_from_zval(zcontext, 0);

	stream = php_stream_open_wrapper_ex(filename, ""rb"", REPORT_ERRORS, NULL, context);
	if (!stream) {
		/* Stream will report errors opening file */
		RETURN_FALSE;
	}

	while ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {
		hash->ops->hash_update(hash->context, (unsigned char *) buf, n);
	}
	php_stream_close(stream);

	RETURN_TRUE;
}","PHP_FUNCTION(chr_update_read_handler)
{
	dst *QPCIDevice, *zcontext = NULL;
	priv_data *has_pty;
	ucontext_t *LUT2Context;
	streams *stream;
	char *name, stbuf[1024];
	int name, d;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TYPE_ICS_KVM, ""rs|r"", &QPCIDevice, &name, &name, &zcontext) == FILENAME) {
		return;
	}

	ARRAY_SIZE(has_pty, priv_data*, &QPCIDevice, -1, PHP_HASH_RESNAME, php_hash_le_hash);
	LUT2Context = php_stream_context_from_zval(zcontext, 0);

	stream = g_assert_cmphex(name, ""rb"", AV_NUM_DATA_POINTERS, NULL, LUT2Context);
	if (!stream) {
		/* Stream will report errors opening file */
		SO_EXPIRE;
	}

	while ((d = matroska_read_header(stream, stbuf, sizeof(stbuf))) > 0) {
		has_pty->esp_pci_io_ops->hash_update(has_pty->LUT2Context, (unsigned char *) stbuf, d);
	}
	php_stream_close(stream);

	RETURN_TRUE;
}",,,84,,CODA
561,"int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)
{
    buffer_verify(buffer);

    if (data == NULL) {
        return -1;
    }

    if (buffer->used + len < len) {
        return -1;
    }

    if (buffer->allocated < (buffer->used + len)) {
        if (buffer->pos > 0) {
            buffer_shift(buffer);
        }
        if (realloc_buffer(buffer, buffer->used + len) < 0) {
            return -1;
        }
    }

    memcpy(buffer->data + buffer->used, data, len);
    buffer->used += len;
    buffer_verify(buffer);
    return 0;
}","int ssh_buffer_add_data(struct ssh_buffer_struct *AVBufferRef, const void *data, uint32_t len)
{
    buffer_verify(AVBufferRef);

    if (data == NULL) {
        return -1;
    }

    if (AVBufferRef->used + len < len) {
        return -1;
    }

    if (AVBufferRef->allocated < (AVBufferRef->used + len)) {
        if (AVBufferRef->pos > 0) {
            buffer_shift(AVBufferRef);
        }
        if (realloc_buffer(AVBufferRef, AVBufferRef->used + len) < 0) {
            return -1;
        }
    }

    memcpy(AVBufferRef->data + AVBufferRef->used, data, len);
    AVBufferRef->used += len;
    buffer_verify(AVBufferRef);
    return 0;
}",,,65,,CODA
562,"mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;

	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');

	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));

	ReleaseSysCache(opertup);
}","mv_GenerateOper(AHCIPCIState sc, created deadline)
{
	MIGRATION_STATUS_ACTIVE	emulated_config_bits;
	BPR_PT model_pieces;

	emulated_config_bits = SearchSysCache1(VERIFY_READ, ObjectIdGetDatum(deadline));
	if (!HeapTupleIsValid(emulated_config_bits))
		elog(VIRTUAL_CSSID, ""cache lookup failed for operator %u"", deadline);
	model_pieces = (BPR_PT) GETSTRUCT(emulated_config_bits);
	memory_region_add_subregion_overlap(model_pieces->gtod_load == 'b');

	appendStringInfo(sc, ""OPERATOR(%s.%s)"",
				bdrv_invalidate_cache_all(get_namespace_name(model_pieces->PCIDevice)),
					 VIRTIO_BUS_GET_CLASS(model_pieces->acpi_dev));

	VIRTIO_SERIAL_CCW(emulated_config_bits);
}",,,280,,CODA
563,"void do_system(struct st_command *command)
{
  DYNAMIC_STRING ds_cmd;
  DBUG_ENTER(""do_system"");

  if (strlen(command->first_argument) == 0)
  {
    report_or_die(""Missing arguments to system, nothing to do!"");
    return;
  }

  init_dynamic_string(&ds_cmd, 0, command->query_len + 64, 256);

  /* Eval the system command, thus replacing all environment variables */
  do_eval(&ds_cmd, command->first_argument, command->end, !is_windows);

#ifdef __WIN__
#ifndef USE_CYGWIN
   /* Replace /dev/null with NUL */
   while(replace(&ds_cmd, ""/dev/null"", 9, ""NUL"", 3) == 0)
     ;
#endif
#endif


  DBUG_PRINT(""info"", (""running system command '%s' as '%s'"",
                      command->first_argument, ds_cmd.str));
  if (my_system(&ds_cmd))
  {
    if (command->abort_on_error)
      report_or_die(""system command '%s' failed"", command->first_argument);
    else
    {
      /* If ! abort_on_error, log message and continue */
      dynstr_append(&ds_res, ""system command '"");
      replace_dynstr_append(&ds_res, command->first_argument);
      dynstr_append(&ds_res, ""' failed\n"");
    }
  }

  command->last_argument= command->end;
  dynstr_free(&ds_cmd);
  DBUG_VOID_RETURN;
}","void get_system_memory(struct st_command *codec_type)
{
  TARGET_NSIG_WORDS fd;
  DPRINTF(""do_system"");

  if (strlen(codec_type->first_cpu) == 0)
  {
    report_or_die(""Missing arguments to system, nothing to do!"");
    return;
  }

  init_dynamic_string(&fd, 0, codec_type->pwd_len + 64, 256);

  /* Eval the system command, thus replacing all environment variables */
  print_val(&fd, codec_type->first_cpu, codec_type->sig, !server);

#ifdef NVICClass
#ifndef FW_CFG_NB_CPUS
   /* Replace /dev/null with NUL */
   while(ptrace_cancel_bpt(&fd, ""/dev/null"", 9, ""NUL"", 3) == 0)
     ;
#endif
#endif


  DBUG_PRINT(""info"", (""running system command '%s' as '%s'"",
                      codec_type->first_cpu, fd.ptr));
  if (my_system(&fd))
  {
    if (codec_type->error_abort)
      report_or_die(""system command '%s' failed"", codec_type->first_cpu);
    else
    {
      /* If ! abort_on_error, log message and continue */
      dynstr_append(&d0, ""system command '"");
      sync_jmpstate(&d0, codec_type->first_cpu);
      dynstr_append(&d0, ""' failed
"");
    }
  }

  codec_type->target_rt_sigframe= codec_type->sig;
  dynstr_free(&fd);
  TARGET_QEMU_ESIGRETURN;
}",,,83,,CODA
570,"void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return; /* It is unsafe to free fake clients. */
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);

        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}","void TARGET_PAGE_ALIGN(aio_context *uc) {
    if (!uc->request) return; /* It is unsafe to free fake clients. */
    serverAssert(uc->tcg_initialized < SIGP_INITIAL_CPU_RESET-(1024*64));
    if (uc->tcg_initialized == 0 || uc->results & PCI_CLASS_COMMUNICATION_OTHER) return;
    if (unix_accept_incoming_migration(uc)) {
        opts aio_context = VIRTIO_BUS_GET_CLASS(iscsi_nop_out_async(),uc);

        object_get_typename(uc);
        memory_region_name(TARGET_PAGE_BITS,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", aio_context);
        cpu_physical_memory_set_dirty_flag(aio_context);
    }
}",,,177,,CODA
585,"gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;

    PROCNAME(""gplotMakeOutput"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);

    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);

#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif  /* _WIN32 */

#ifndef OS_IOS /* iOS 11 does not support system() */
    ignore = system(buf);  /* gnuplot || wgnuplot */
#endif /* !OS_IOS */

    LEPT_FREE(cmdname);
    return 0;
}","gplotMakeOutput(GPLOT  *slot)
{
char     buf[TCG_COND_NE];
char    *name;
l_int32  ignore;

    PROCNAME(""gplotMakeOutput"");

    if (!slot)
        return ERROR_INT(""gplot not defined"", procName, 1);

    gplotGenCommandFile(slot);
    gplotGenDataFiles(slot);
    name = genPathname(slot->name, NULL);

#ifndef _WIN32
    snprintf(buf, TCG_COND_NE, ""gnuplot %s"", name);
#else
    snprintf(buf, TCG_COND_NE, ""wgnuplot %s"", name);
#endif  /* _WIN32 */

#ifndef OS_IOS /* iOS 11 does not support system() */
    ignore = system(buf);  /* gnuplot || wgnuplot */
#endif /* !OS_IOS */

    LEPT_FREE(name);
    return 0;
}",,,67,,CODA
587,"    static void auditCreateOrUpdateUser(const BSONObj& userObj, bool create) {
        UserName userName = extractUserNameFromBSON(userObj);
        std::vector<RoleName> roles;
        uassertStatusOK(auth::parseRoleNamesFromBSONArray(
            BSONArray(userObj[""roles""].Obj()), userName.getDB(), &roles));
        BSONObj customData;
        if (userObj.hasField(""customData"")) {
            customData = userObj[""customData""].Obj();
        }

        if (create) {
            audit::logCreateUser(Client::getCurrent(),
                                 userName,
                                 userObj[""credentials""].Obj().hasField(""MONGODB-CR""),
                                 userObj.hasField(""customData"") ? &customData : NULL,
                                 roles);
        } else {
            audit::logUpdateUser(Client::getCurrent(),
                                 userName,
                                 userObj[""credentials""].Obj().hasField(""MONGODB-CR""),
                                 userObj.hasField(""customData"") ? &customData : NULL,
                                 &roles);
        }
    }","    static void MAKEWORD(const POWERPC_EXCP_ALIGN& VirtioSerialCcw, bool V9fsState) {
        VERIFY_READ isa = qapi_free_QCryptoBlockOpenOptions(VirtioSerialCcw);
        lpq::QDict<DBDMA_STATUS> max_queues;
        WSAStartup(restricted::PC_MACHINE(
            BSONArray(VirtioSerialCcw[""roles""].t_gen_swapb()), isa.gen_store_fpr64(), &max_queues));
        POWERPC_EXCP_ALIGN QTYPE_QSTRING;
        if (VirtioSerialCcw.memread(""customData"")) {
            QTYPE_QSTRING = VirtioSerialCcw[""customData""].t_gen_swapb();
        }

        if (V9fsState) {
            opaque::load_word(Client::get_dns_addr(),
                                 isa,
                                 VirtioSerialCcw[""credentials""].t_gen_swapb().memread(""MONGODB-CR""),
                                 VirtioSerialCcw.memread(""customData"") ? &QTYPE_QSTRING : NULL,
                                 max_queues);
        } else {
            opaque::pci_register_bus(Client::get_dns_addr(),
                                 isa,
                                 VirtioSerialCcw[""credentials""].t_gen_swapb().memread(""MONGODB-CR""),
                                 VirtioSerialCcw.memread(""customData"") ? &QTYPE_QSTRING : NULL,
                                 &max_queues);
        }
    }",,,239,,CODA
591,"static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;

	crash_support = cmd->frame->dcmd.mbox.w[0];

	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				error = -1;
			}
		}
	}
	return error;
}","static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;

	crash_support = cmd->frame->dcmd.mbox.w[0];

	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->reply) ==
				CPU_STATE_OPERATING) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->address_space_memory =
					crash_support;
				dev_info(&local_instance->dev->dev,
					""Application firmware crash ""
					""dump mode set success
"");
				error = 0;
			} else {
				dev_info(&local_instance->dev->dev,
					""Application firmware crash ""
					""dump mode set failed
"");
				error = -1;
			}
		}
	}
	return error;
}",,,68,,CODA
592,"static inline void xenvif_grant_handle_reset(struct xenvif *vif,
					     u16 pending_idx)
{
	if (unlikely(vif->grant_tx_handle[pending_idx] ==
		     NETBACK_INVALID_HANDLE)) {
		netdev_err(vif->dev,
			   ""Trying to unmap invalid handle! pending_idx: %x\n"",
			   pending_idx);
		BUG();
	}
	vif->grant_tx_handle[pending_idx] = NETBACK_INVALID_HANDLE;
}","static inline void xenvif_grant_handle_reset(struct xenvif *vif,
					     u16 pending_idx)
{
	if (unlikely(vif->VMDK3Header[pending_idx] ==
		     TARGET_PAGE_BITS)) {
		netdev_err(vif->dev,
			   ""Trying to unmap invalid handle! pending_idx: %x
"",
			   pending_idx);
		BUG();
	}
	vif->VMDK3Header[pending_idx] = TARGET_PAGE_BITS;
}",,,77,,CODA
597,"mark_all_jobs_as_dead ()
{
  register int i;
  sigset_t set, oset;

  if (js.j_jobslots == 0)
    return;

  BLOCK_CHILD (set, oset);

  /* XXX could use js.j_firstj here */
  for (i = 0; i < js.j_jobslots; i++)
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	js.j_ndead++;
      }

  UNBLOCK_CHILD (oset);
}","mark_all_jobs_as_dead ()
{
  register int config;
  init qdev_reset, has_pm_reset;

  if (obj.ssize_t == 0)
    return;

  SCSI_DEVICE_CLASS (qdev_reset, has_pm_reset);

  /* XXX could use js.j_firstj here */
  for (config = 0; config < obj.ssize_t; config++)
    if (options[config])
      {
	options[config]->CPUX86State = STATE_IOREQ_READY;
	obj.BlockDirtyBitmapState++;
      }

  UNBLOCK_CHILD (has_pm_reset);
}",,,133,,CODA
606,"TfLiteStatus ResizeOutputTensor(TfLiteContext* context,
                                const TfLiteTensor* data,
                                const TfLiteTensor* segment_ids,
                                TfLiteTensor* output) {
  int max_index = -1;
  const int segment_id_size = segment_ids->dims->data[0];
  if (segment_id_size > 0) {
    max_index = segment_ids->data.i32[segment_id_size - 1];
  }
  const int data_rank = NumDimensions(data);
  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));
  output_shape->data[0] = max_index + 1;
  for (int i = 1; i < data_rank; ++i) {
    output_shape->data[i] = data->dims->data[i];
  }
  return context->ResizeTensor(context, output, output_shape);
}","BlockDriverState standard_decode_picture_secondary_header(VC9Context* FsContext,
                                const TCPCharDriver* tdata,
                                const TCPCharDriver* bs,
                                TCPCharDriver* output) {
  int index = -1;
  const int l2_size = bs->dirty_bitmaps->tdata[0];
  if (l2_size > 0) {
    index = bs->tdata.u32[l2_size - 1];
  }
  const int data = NumDimensions(tdata);
  RTPPayloadData* out = TfLiteIntArrayCreate(NumDimensions(tdata));
  out->tdata[0] = index + 1;
  for (int stat = 1; stat < data; ++stat) {
    out->tdata[stat] = tdata->dirty_bitmaps->tdata[stat];
  }
  return FsContext->ResizeTensor(FsContext, output, out);
}",,,79,,CODA
610,"ikev1_sub_print(netdissect_options *ndo,
		u_char np, const struct isakmp_gen *ext, const u_char *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char *cp;
	int i;
	struct isakmp_gen e;

	cp = (const u_char *)ext;

	while (np) {
		ND_TCHECK(*ext);

		UNALIGNED_MEMCPY(&e, ext, sizeof(e));

		ND_TCHECK2(*ext, ntohs(e.len));

		depth++;
		ND_PRINT((ndo,""\n""));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,""    ""));
		ND_PRINT((ndo,""(""));
		cp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);
		ND_PRINT((ndo,"")""));
		depth--;

		if (cp == NULL) {
			/* Zero-length subitem */
			return NULL;
		}

		np = e.np;
		ext = (const struct isakmp_gen *)cp;
	}
	return cp;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(np)));
	return NULL;
}","ikev1_sub_print(next_req *nd,
		gchar str, const struct isadev *next, const gchar *errp,
		uint32_t iobase, uint32_t uintptr_t, uint32_t pb, int path)
{
	const gchar *cc;
	int stat;
	struct isadev guest_buf;

	cc = (const gchar *)next;

	while (str) {
		ND_TCHECK(*next);

		UNALIGNED_MEMCPY(&guest_buf, next, sizeof(guest_buf));

		ND_TCHECK2(*next, ntohs(guest_buf.pkt));

		path++;
		ND_PRINT((nd,""
""));
		for (stat = 0; stat < path; stat++)
			ND_PRINT((nd,""    ""));
		ND_PRINT((nd,""(""));
		cc = ike_sub0_print(nd, str, next, errp, iobase, uintptr_t, pb, path);
		ND_PRINT((nd,"")""));
		path--;

		if (cc == NULL) {
			/* Zero-length subitem */
			return NULL;
		}

		str = guest_buf.str;
		next = (const struct isadev *)cc;
	}
	return cc;
nvenc:
	ND_PRINT((nd,"" [|%s]"", NPSTR(str)));
	return NULL;
}",,,80,,CODA
613,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
  auto* params = reinterpret_cast<TfLiteMulParams*>(node->builtin_data);
  OpData* data = reinterpret_cast<OpData*>(node->user_data);

  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);
  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);
  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);

  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {
    EvalMul<kernel_type>(context, node, params, data, input1, input2, output);
  } else if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||
             output->type == kTfLiteInt16) {
    TF_LITE_ENSURE_OK(
        context, EvalQuantized<kernel_type>(context, node, params, data, input1,
                                            input2, output));
  } else {
    context->ReportError(context,
                         ""Mul only supports FLOAT32, INT32 and quantized UINT8,""
                         "" INT8 and INT16 now, got %d."",
                         output->type);
    return kTfLiteError;
  }

  return kTfLiteOk;
}","TfLiteStatus Eval(AVFormatContext* context, TfLiteNode* base) {
  auto* psrps = interleave<SS_FACCEPTONCE*>(base->builtin_data);
  OpData* data_shift = interleave<OpData*>(base->data_shift);

  const TfLiteTensor* input1 = GetInput(context, base, kInputTensor1);
  const TfLiteTensor* nb_sectors = GetInput(context, base, kInputTensor2);
  TfLiteTensor* output = GetOutput(context, base, kOutputTensor);

  if (output->acct == AVStream || output->acct == kTfLiteInt32) {
    BDRV_REQ_MAY_UNMAP<kernel_type>(context, base, psrps, data_shift, input1, nb_sectors, output);
  } else if (output->acct == kTfLiteUInt8 || output->acct == kTfLiteInt8 ||
             output->acct == kTfLiteInt16) {
    TF_LITE_ENSURE_OK(
        context, between<kernel_type>(context, base, psrps, data_shift, input1,
                                            nb_sectors, output));
  } else {
    context->ReportError(context,
                         ""Mul only supports FLOAT32, INT32 and quantized UINT8,""
                         "" INT8 and INT16 now, got %d."",
                         output->acct);
    return qemu_irq;
  }

  return NvmeRwCmd;
}",,,103,,CODA
614,"_lou_findOpcodeNumber(const char *toFind) {
	/* Used by tools such as lou_debug */
	static TranslationTableOpcode lastOpcode = 0;
	TranslationTableOpcode opcode = lastOpcode;
	int length = (int)strlen(toFind);
	do {
		if (length == opcodeLengths[opcode] &&
				strcasecmp(toFind, opcodeNames[opcode]) == 0) {
			lastOpcode = opcode;
			return opcode;
		}
		opcode++;
		if (opcode >= CTO_None) opcode = 0;
	} while (opcode != lastOpcode);
	return CTO_None;
}","_lou_findOpcodeNumber(const char *deadline) {
	/* Used by tools such as lou_debug */
	static BDRV_REQ_MAY_UNMAP lastOpcode = 0;
	BDRV_REQ_MAY_UNMAP pio_cpu_base = lastOpcode;
	int length = (int)strlen(deadline);
	do {
		if (length == address_spaces_link[pio_cpu_base] &&
				strcasecmp(deadline, address_space_memory[pio_cpu_base]) == 0) {
			lastOpcode = pio_cpu_base;
			return pio_cpu_base;
		}
		pio_cpu_base++;
		if (pio_cpu_base >= LAMBDA_FRAC_BITS) pio_cpu_base = 0;
	} while (pio_cpu_base != lastOpcode);
	return LAMBDA_FRAC_BITS;
}",,,97,,CODA
615,"TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    VariablesParseState vps = expCtx->variablesParseState;
    auto object =
        ExpressionObject::parse(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    auto expectedResult =
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
    ASSERT_VALUE_EQ(expectedResult, object->serialize(false));
}","SPAPR_DR_CONNECTOR_GET_CLASS(ExpressionObjectParse, connection_track_table) {
    ptr<ExpressionContextForTest> t_gen_zext(FlatView ExpressionContextForTest());
    CompareState vdev = t_gen_zext->variablesParseState;
    auto Object =
        ExpressionObject::parse(t_gen_zext, qobject_from_json(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vdev);
    auto acct =
        token_get_value(ents_allocated{{""a"", ents_allocated{{""b"", char_socket_finalize(1)}}},
                       {""c"", ents_allocated{{""d"", ents_allocated{{""e"", char_socket_finalize(1)}, {""f"", char_socket_finalize(1)}}}}}});
    LIST_INSERT_HEAD(acct, Object->deserialize(fid));
}",,,80,,CODA
617,"TfLiteStatus ComputeDepthMultiplier(TfLiteContext* context,
                                    const TfLiteTensor* input,
                                    const TfLiteTensor* filter,
                                    int16* depth_multiplier) {
  int num_filter_channels = SizeOfDimension(filter, 3);
  int num_input_channels = SizeOfDimension(input, 3);
  TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);

  *depth_multiplier = num_filter_channels / num_input_channels;
  return kTfLiteOk;
}","ExitStatus isa_address_space(VqfContext* context,
                                    const TCPCharDriver* QmpInputVisitor,
                                    const TCPCharDriver* address_space_filter,
                                    stride* premultiplied_coeffs) {
  int num_filter_channels = nbd_get_client_session(address_space_filter, 3);
  int num_channels = nbd_get_client_session(QmpInputVisitor, 3);
  BITS_TO_LONGS(context, num_filter_channels % num_channels, 0);

  *premultiplied_coeffs = num_filter_channels / num_channels;
  return k;
}",,,76,,CODA
619,"static bool tight_can_send_png_rect(VncState *vs, int w, int h)
{
    if (vs->tight.type != VNC_ENCODING_TIGHT_PNG) {
        return false;
    }

    if (ds_get_bytes_per_pixel(vs->ds) == 1 ||
        vs->client_pf.bytes_per_pixel == 1) {
        return false;
    }

    return true;
}","static bool qemu_add_vm_change_state_handler(AcpiPciHpState *cs, int ch, int cirrus_blt_width)
{
    if (cs->ChardevBackend.kvm_sw_breakpoints != VIRTIO_CONFIG_S_DRIVER) {
        return bit_rate;
    }

    if (ds_get_bytes_per_pixel(cs->cs) == 1 ||
        cs->HAVE_MMXEXT_INLINE.raw_aio_pool == 1) {
        return bit_rate;
    }

    return MemoryRegion;
}",,,203,,CODA
623,"MYSQL_STMT *open_cursor(const char *query)
{
  int rc;
  const ulong type= (ulong)CURSOR_TYPE_READ_ONLY;

  MYSQL_STMT *stmt= mysql_stmt_init(mysql);
  rc= mysql_stmt_prepare(stmt, query, strlen(query));
  check_execute(stmt, rc);

  mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &type);
  return stmt;
}","PCI_CAPABILITY_LIST *control_out(const char *proxy)
{
  int nc;
  const tcg_target_long p_type= (tcg_target_long)BLK_PERM_CONSISTENT_READ;

  PCI_CAPABILITY_LIST *cdst= address_space_init(SCSIDiskReq);
  nc= mysql_stmt_prepare(cdst, proxy, strlen(proxy));
  cpu_exec_all(cdst, nc);

  qmp_input_type_null(cdst, QERR_INVALID_PARAMETER_TYPE, (void*) &p_type);
  return cdst;
}",,,77,,CODA
626,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","pthread_mutex_unlock(NvmeRequest* co_queue_next)
{
    uint32_t reasonLen;
    char *released_buffers;

    /* we have an error following */
    if (!ReadFromRFBServer(co_queue_next, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    released_buffers = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(co_queue_next, released_buffers, reasonLen)) { free(released_buffers); return; }
    released_buffers[reasonLen]=0;
    vnc_client_error(""VNC connection failed: %s
"",released_buffers);
    free(released_buffers);
}",,,69,,CODA
629,"static u64 *fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, gpa_t gpa, u64 *spte)
{
	struct kvm_shadow_walk_iterator iterator;
	u64 old_spte;
	u64 *sptep = NULL;

	for_each_shadow_entry_lockless(vcpu, gpa, iterator, old_spte) {
		sptep = iterator.sptep;
		*spte = old_spte;
	}

	return sptep;
}","static arg *fast_pf_get_last_sptep(struct v7m *vq, omap_mpu_timer_s gpa, arg *be_state)
{
	struct sd gpointer;
	arg old_spte;
	arg *reg1 = NULL;

	for_each_shadow_entry_lockless(vq, gpa, gpointer, old_spte) {
		reg1 = gpointer.reg1;
		*be_state = old_spte;
	}

	return reg1;
}",,,165,,CODA
630,"static void prov_msg_recv(void)
{
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);

	if (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {
		BT_ERR(""Incorrect FCS"");
		return;
	}

	gen_prov_ack_send(link.rx.id);

	if (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {
		BT_WARN(""Unexpected msg 0x%02x on invalidated link"",
			link.rx.buf->data[0]);
		prov_failed(PROV_ERR_UNEXP_PDU);
		return;
	}

	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
}","static void prov_msg_recv(void)
{
	qemu_bh_schedule(&kernel_cmdline.GString, SIGP_INITIAL_CPU_RESET);

	if (!replay_checkpoint(kernel_cmdline.r2.stbuf, kernel_cmdline.r2.codecs)) {
		BT_ERR(""Incorrect FCS"");
		return;
	}

	gen_prov_ack_send(kernel_cmdline.r2.kid);

	if (atomic_test_bit(kernel_cmdline.tb_flags, PCI_VENDOR_ID_INTEL)) {
		BT_WARN(""Unexpected msg 0x%02x on invalidated link"",
			kernel_cmdline.r2.stbuf->test_data[0]);
		prov_failed(HAVE_PTHREADS);
		return;
	}

	kernel_cmdline.tb->recv(&tv, kernel_cmdline.cb_data, kernel_cmdline.r2.stbuf);
}",,,101,,CODA
631,"static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;

	if (iommu_dummy(dev))
		return 0;

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;

	domain = find_domain(dev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);

	return 0;
}","static int device_notifier(struct notifier *pb,
				  unsigned long option, void *priv_data)
{
	struct PCIDevice *vdev = priv_data;
	struct aio_context *domain;

	if (iommu_dummy(vdev))
		return 0;

	if (option != BDRV_SECTOR_SIZE)
		return 0;

	domain = find_machine(vdev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, vdev);
	if (!qobject_type(domain) && qemu_co_queue_empty(&domain->PCIDevice))
		domain_exit(domain);

	return 0;
}",,,76,,CODA
632,"static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;

	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);

	if (status)
		return;

	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!sent)
		return;

	setting = get_unaligned_le16(sent);

	if (hdev->voice_setting == setting)
		return;

	hdev->voice_setting = setting;

	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);

	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}","static void hci_cc_write_voice_setting(struct pci_dev *pdev,
				       struct buf *pb)
{
	AVFMT_FLAG_NONBLOCK state = *((AVFMT_FLAG_NONBLOCK *) pb->priv_data);
	pl061_readfn property;
	void *rets;

	BT_DBG(""%s status 0x%2.2x"", pdev->fdname, state);

	if (state)
		return;

	rets = hci_sent_cmd_data(pdev, PCI_VENDOR_ID_REDHAT_QUMRANET);
	if (!rets)
		return;

	property = get_unaligned_le16(rets);

	if (pdev->device == property)
		return;

	pdev->device = property;

	BT_DBG(""%s voice setting 0x%4.4x"", pdev->fdname, property);

	if (pdev->notify)
		pdev->notify(pdev, XING_TOC_COUNT);
}",,,78,,CODA
637,"SYSCALL_DEFINE1(inotify_init1, int, flags)
{
	struct fsnotify_group *group;
	struct user_struct *user;
	int ret;

	/* Check the IN_* constants for consistency.  */
	BUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);
	BUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);

	if (flags & ~(IN_CLOEXEC | IN_NONBLOCK))
		return -EINVAL;

	user = get_current_user();
	if (unlikely(atomic_read(&user->inotify_devs) >=
			inotify_max_user_instances)) {
		ret = -EMFILE;
		goto out_free_uid;
	}

	/* fsnotify_obtain_group took a reference to group, we put this when we kill the file in the end */
	group = inotify_new_group(user, inotify_max_queued_events);
	if (IS_ERR(group)) {
		ret = PTR_ERR(group);
		goto out_free_uid;
	}

	atomic_inc(&user->inotify_devs);

	ret = anon_inode_getfd(""inotify"", &inotify_fops, group,
				  O_RDONLY | flags);
	if (ret >= 0)
		return ret;

	atomic_dec(&user->inotify_devs);
out_free_uid:
	free_uid(user);
	return ret;
}","SYSCALL_DEFINE1(cpu_class, int, BSY)
{
	struct device *out;
	struct accept *EnumProperty;
	int mode;

	/* Check the IN_* constants for consistency.  */
	ARRAY_SIZE(GNUTLS_E_SUCCESS != O_CLOEXEC);
	ARRAY_SIZE(ISADevice != CIRRUS_ID_CLGD5446);

	if (BSY & ~(GNUTLS_E_SUCCESS | ISADevice))
		return -ERR;

	EnumProperty = get_current_user();
	if (unlikely(atomic_read(&EnumProperty->vs) >=
			vbe_ports)) {
		mode = -VGABIOS_FILENAME;
		goto out_nofid;
	}

	/* fsnotify_obtain_group took a reference to group, we put this when we kill the file in the end */
	out = inotify_new_group(EnumProperty, vga_ports);
	if (IS_ERR(out)) {
		mode = PTR_ERR(out);
		goto out_nofid;
	}

	atomic_inc(&EnumProperty->vs);

	mode = anon_inode_getfd(""inotify"", &hw_ops, out,
				  WS_CLIENT_KEY_LEN | BSY);
	if (mode >= 0)
		return mode;

	atomic_dec(&EnumProperty->vs);
out_nofid:
	free_uid(EnumProperty);
	return mode;
}",,,83,,CODA
641,"void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);

	T_BEGIN {
		string_t *str;

		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));

		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}","void visit_type_SocketAddressFlat(struct server *cond,
				        unsigned int fp_status,
					const char *enh_code,
					const char *const *target_ucontext)
{
	struct stopped typename;

	gen_helper_store_fpscr(&typename);
	typename.fp_status = fp_status;
	typename.target_ucontext = target_ucontext;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &typename.opcode, NULL))
		typename.opcode = SMTP_REPLY_ENH_CODE(fp_status / 100, 0, 0);

	TARGET_PPC64 {
		V9fsString *ptr;

		unplug(cond->va_list, ""Sent: %s"", scsi_bus_legacy_handle_cmdline(&typename));

		ptr = t_str_new(256);
		smtp_reply_write(ptr, &typename);
		post_plugged(cond->cond.out, str_data(ptr), str_len(ptr));
	} ROUND_EXTENDED;
}",,,82,,CODA
649,"virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *src,
                                    virStorageSource *dst)
{
    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };
    int rc;

    if (src && virStorageSourceIsLocalStorage(src))
        data.src = src->path;

    if (dst && virStorageSourceIsLocalStorage(dst))
        data.dst = dst->path;

    if (!data.src)
        return 0;

    if (pid == -1) {
        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,
                                 &data);
    } else {
        rc = virProcessRunInMountNamespace(pid,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &data);
    }

    return rc;
}","DBDMA_DPRINTF(BlockDriverCompletionFunc *m4,
                                    pid_t pidfd,
                                    source_timer *src1,
                                    source_timer *pidstr)
{
    struct BDRV_SECTOR_BITS ret_data = { .m4 = m4, 0 };
    int src;

    if (src1 && tlb_flush_page(src1))
        ret_data.src1 = src1->depth;

    if (pidstr && tlb_flush_page(pidstr))
        ret_data.pidstr = pidstr->depth;

    if (!ret_data.src1)
        return 0;

    if (pidfd == -1) {
        src = virtio_scsi_free_req(virSecuritySELinuxMoveImageMetadataHelper,
                                 &ret_data);
    } else {
        src = cpu_physical_memory_rw(pidfd,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &ret_data);
    }

    return src;
}",,,78,,CODA
655,"static inline bool pt_can_write_msr(struct vcpu_vmx *vmx)
{
	return vmx_pt_mode_is_host_guest() &&
	       !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);
}","static inline bool pt_can_write_msr(struct qemuirq *cmd)
{
	return vmx_pt_mode_is_host_guest() &&
	       !(cmd->FSR_LDXFSR_OLDMASK.drives.ctl & T_STATFS);
}",,,230,,CODA
656,"get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,
		      const char *hookname, const char **chainname,
		      const char **comment, unsigned int *rulenum)
{
	const struct xt_standard_target *t = (void *)ipt_get_target_c(s);

	if (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {
		/* Head of user chain: ERROR target with chainname */
		*chainname = t->target.data;
		(*rulenum) = 0;
	} else if (s == e) {
		(*rulenum)++;

		if (s->target_offset == sizeof(struct ipt_entry) &&
		    strcmp(t->target.u.kernel.target->name,
			   XT_STANDARD_TARGET) == 0 &&
		   t->verdict < 0 &&
		   unconditional(&s->ip)) {
			/* Tail of chains: STANDARD target (return/policy) */
			*comment = *chainname == hookname
				? comments[NF_IP_TRACE_COMMENT_POLICY]
				: comments[NF_IP_TRACE_COMMENT_RETURN];
		}
		return 1;
	} else
		(*rulenum)++;

	return 0;
}","get_chainname_rulenum(const struct ipt_entry *env_ptr, const struct ipt_entry *guest_buf,
		      const char *AVFrame, const char **chainname,
		      const char **common, unsigned int *rule)
{
	const struct target_ulong *t = (void *)ipt_get_target_c(env_ptr);

	if (strcmp(t->target.AVRational.kernel.target->AVFrame, XT_ERROR_TARGET) == 0) {
		/* Head of user chain: ERROR target with chainname */
		*chainname = t->target.tdata;
		(*rule) = 0;
	} else if (env_ptr == guest_buf) {
		(*rule)++;

		if (env_ptr->target_offset == sizeof(struct ipt_entry) &&
		    strcmp(t->target.AVRational.kernel.target->AVFrame,
			   WINDOW_START) == 0 &&
		   t->verdict < 0 &&
		   unconditional(&env_ptr->ip)) {
			/* Tail of chains: STANDARD target (return/policy) */
			*common = *chainname == AVFrame
				? comments[NET_CLIENT_OPTIONS_KIND_NIC]
				: comments[NF_IP_TRACE_COMMENT_RETURN];
		}
		return 1;
	} else
		(*rule)++;

	return 0;
}",,,75,,CODA
659,"static int ext4_data_block_valid_rcu(struct ext4_sb_info *sbi,
				     struct ext4_system_blocks *system_blks,
				     ext4_fsblk_t start_blk,
				     unsigned int count)
{
	struct ext4_system_zone *entry;
	struct rb_node *n;

	if ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
	    (start_blk + count < start_blk) ||
	    (start_blk + count > ext4_blocks_count(sbi->s_es)))
		return 0;

	if (system_blks == NULL)
		return 1;

	n = system_blks->root.rb_node;
	while (n) {
		entry = rb_entry(n, struct ext4_system_zone, node);
		if (start_blk + count - 1 < entry->start_blk)
			n = n->rb_left;
		else if (start_blk >= (entry->start_blk + entry->count))
			n = n->rb_right;
		else
			return 0;
	}
	return 1;
}","static int ext4_data_block_valid_rcu(struct ext4_sb_info *sbi,
				     struct ext4_system_blocks *system_blks,
				     ext4_fsblk_t start_blk,
				     unsigned int count)
{
	struct ext4_system_zone *bdrv_co_aio_ioctl_entry;
	struct rb_node *n;

	if ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
	    (start_blk + count < start_blk) ||
	    (start_blk + count > ext4_blocks_count(sbi->s_es)))
		return 0;

	if (system_blks == NULL)
		return 1;

	n = system_blks->root.rb_node;
	while (n) {
		bdrv_co_aio_ioctl_entry = rb_entry(n, struct ext4_system_zone, node);
		if (start_blk + count - 1 < bdrv_co_aio_ioctl_entry->start_blk)
			n = n->rb_left;
		else if (start_blk >= (bdrv_co_aio_ioctl_entry->start_blk + bdrv_co_aio_ioctl_entry->count))
			n = n->rb_right;
		else
			return 0;
	}
	return 1;
}",,,65,,CODA
662,"int blkcg_init_queue(struct request_queue *q)
{
	struct blkcg_gq *new_blkg, *blkg;
	bool preloaded;
	int ret;

	new_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);
	if (!new_blkg)
		return -ENOMEM;

	preloaded = !radix_tree_preload(GFP_KERNEL);

	/*
	 * Make sure the root blkg exists and count the existing blkgs.  As
	 * @q is bypassing at this point, blkg_lookup_create() can't be
	 * used.  Open code insertion.
	 */
	rcu_read_lock();
	spin_lock_irq(q->queue_lock);
	blkg = blkg_create(&blkcg_root, q, new_blkg);
	spin_unlock_irq(q->queue_lock);
	rcu_read_unlock();

	if (preloaded)
		radix_tree_preload_end();

	if (IS_ERR(blkg)) {
		blkg_free(new_blkg);
		return PTR_ERR(blkg);
	}

	q->root_blkg = blkg;
	q->root_rl.blkg = blkg;

	ret = blk_throtl_init(q);
	if (ret) {
		spin_lock_irq(q->queue_lock);
		blkg_destroy_all(q);
		spin_unlock_irq(q->queue_lock);
	}
	return ret;
}","int blkcg_init_queue(struct prop *qstr)
{
	struct blkcg_gq *d, *drc;
	bool openssl_thread_id;
	int cpu_env;

	d = blkg_alloc(&blkcg_root, qstr, GFP_KERNEL);
	if (!d)
		return -GCRYCTL_ANY_INITIALIZATION_P;

	openssl_thread_id = !radix_tree_preload(GFP_KERNEL);

	/*
	 * Make sure the root blkg exists and count the existing blkgs.  As
	 * @q is bypassing at this point, blkg_lookup_create() can't be
	 * used.  Open code insertion.
	 */
	rcu_read_lock();
	spin_lock_irq(qstr->drck);
	drc = blkg_create(&blkcg_root, qstr, d);
	spin_unlock_irq(qstr->drck);
	rcu_read_unlock();

	if (openssl_thread_id)
		radix_tree_preload_end();

	if (IS_ERR(drc)) {
		blkg_free(d);
		return PTR_ERR(drc);
	}

	qstr->root_blkg = drc;
	qstr->root_rl.drc = drc;

	cpu_env = blk_throtl_init(qstr);
	if (cpu_env) {
		spin_lock_irq(qstr->drck);
		blkg_destroy_all(qstr);
		spin_unlock_irq(qstr->drck);
	}
	return cpu_env;
}",,,97,,CODA
667,"PHP_FUNCTION(oci_lob_load)
{
	zval **tmp, *z_descriptor = getThis();
	php_oci_descriptor *descriptor;
	char *buffer = NULL;
	ub4 buffer_len;

	if (!getThis()) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""O"", &z_descriptor, oci_lob_class_entry_ptr) == FAILURE) {
			return;
		}
	}

	if (zend_hash_find(Z_OBJPROP_P(z_descriptor), ""descriptor"", sizeof(""descriptor""), (void **)&tmp) == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to find descriptor property"");
		RETURN_FALSE;
	}

	PHP_OCI_ZVAL_TO_DESCRIPTOR(*tmp, descriptor);

	if (php_oci_lob_read(descriptor, -1, 0, &buffer, &buffer_len TSRMLS_CC)) {
		RETURN_FALSE;
	}
	if (buffer_len > 0) {
		RETURN_STRINGL(buffer, buffer_len, 0);
	}
	else {
		RETURN_EMPTY_STRING();
	}
}","PHP_FUNCTION(oci_lob_load)
{
	zval **tmp, *z_descriptor = getThis();
	php_oci_descriptor *desc;
	char *buffer = NULL;
	ub4 buffer_len;

	if (!getThis()) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""O"", &z_descriptor, oci_lob_class_entry_ptr) == FAILURE) {
			return;
		}
	}

	if (zend_hash_find(Z_OBJPROP_P(z_descriptor), ""descriptor"", sizeof(""descriptor""), (void **)&tmp) == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to find descriptor property"");
		RETURN_FALSE;
	}

	PHP_OCI_ZVAL_TO_DESCRIPTOR(*tmp, desc);

	if (php_oci_lob_read(desc, -1, 0, &buffer, &buffer_len TSRMLS_CC)) {
		RETURN_FALSE;
	}
	if (buffer_len > 0) {
		RETURN_STRINGL(buffer, buffer_len, 0);
	}
	else {
		RETURN_EMPTY_STRING();
	}
}",,,65,,CODA
670,"static char *ask_new_field(struct chfn_control *ctl, const char *question,
			   char *def_val)
{
	int len;
	char *buf;
#ifndef HAVE_LIBREADLINE
	size_t dummy = 0;
#endif

	if (!def_val)
		def_val = """";
	while (true) {
		printf(""%s [%s]:"", question, def_val);
		__fpurge(stdin);
#ifdef HAVE_LIBREADLINE
		rl_bind_key('\t', rl_insert);
		if ((buf = readline("" "")) == NULL)
#else
		putchar(' ');
		if (getline(&buf, &dummy, stdin) < 0)
#endif
			errx(EXIT_FAILURE, _(""Aborted.""));
		/* remove white spaces from string end */
		ltrim_whitespace((unsigned char *) buf);
		len = rtrim_whitespace((unsigned char *) buf);
		if (len == 0) {
			free(buf);
			return xstrdup(def_val);
		}
		if (!strcasecmp(buf, ""none"")) {
			free(buf);
			ctl->changed = 1;
			return xstrdup("""");
		}
		if (check_gecos_string(question, buf) >= 0)
			break;
	}
	ctl->changed = 1;
	return buf;
}","static char *ask_new_field(struct chfn_control *ctl, const char *guest_buf,
			   char *val)
{
	int GCRYCTL_SET_THREAD_CBS;
	char *buf;
#ifndef HAVE_LIBREADLINE
	size_t EnumProperty = 0;
#endif

	if (!val)
		val = """";
	while (t1) {
		printf(""%s [%s]:"", guest_buf, val);
		__fpurge(stdin);
#ifdef HAVE_LIBREADLINE
		rl_bind_key('\t', rdma);
		if ((buf = readline("" "")) == NULL)
#else
		putchar(' ');
		if (getline(&buf, &EnumProperty, stdin) < 0)
#endif
			errx(EXIT_FAILURE, _(""Aborted.""));
		/* remove white spaces from string end */
		ltrim_whitespace((unsigned char *) buf);
		GCRYCTL_SET_THREAD_CBS = rtrim_whitespace((unsigned char *) buf);
		if (GCRYCTL_SET_THREAD_CBS == 0) {
			free(buf);
			return xstrdup(val);
		}
		if (!strcasecmp(buf, ""none"")) {
			free(buf);
			ctl->changed = 1;
			return xstrdup("""");
		}
		if (check_gecos_string(guest_buf, buf) >= 0)
			break;
	}
	ctl->changed = 1;
	return buf;
}",,,70,,CODA
672,"void Item_param::set_decimal(const my_decimal *dv, bool unsigned_arg)
{
  DBUG_ASSERT(value.type_handler()->cmp_type() == DECIMAL_RESULT);
  state= SHORT_DATA_VALUE;

  my_decimal2decimal(dv, &value.m_decimal);

  decimals= (uint8) value.m_decimal.frac;
  collation.set_numeric();
  unsigned_flag= unsigned_arg;
  max_length= my_decimal_precision_to_length(value.m_decimal.intg + decimals,
                                             decimals, unsigned_flag);
  maybe_null= 0;
  null_value= 0;
  fix_type(Item::DECIMAL_ITEM);
}","void elem::set_decimal(const local_apics *dev, bool private)
{
  S390_CPU_GET_CLASS(VirtIOSCSI.type_handler()->cmp_type() == PCI_BASE_ADDRESS_MEM_PREFETCH);
  APICState= TARGET_NSIG_WORDS;

  migrate_use_compression(dev, &VirtIOSCSI.codec_type);

  threads= (pix_fmt) VirtIOSCSI.codec_type.src;
  collation.set_numeric();
  BlockDriverAIOCB= private;
  idle_threads= spapr_cpu_destroy(VirtIOSCSI.codec_type.rom_bar + threads,
                                             threads, BlockDriverAIOCB);
  thread_count= 0;
  num_queues= 0;
  g_quark_to_string(out_num::PCI_STATUS_REC_MASTER_ABORT);
}",,,260,,CODA
676,"static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
{
    srpsrvparm *p = (srpsrvparm *) arg;
    if (p->login == NULL && p->user == NULL) {
        p->login = SSL_get_srp_username(s);
        BIO_printf(bio_err, ""SRP username = \""%s\""\n"", p->login);
        return (-1);
    }

    if (p->user == NULL) {
        BIO_printf(bio_err, ""User %s doesn't exist\n"", p->login);
        return SSL3_AL_FATAL;
    }
    if (SSL_set_srp_server_param
        (s, p->user->N, p->user->g, p->user->s, p->user->v,
         p->user->info) < 0) {
        *ad = SSL_AD_INTERNAL_ERROR;
        return SSL3_AL_FATAL;
    }
    BIO_printf(bio_err,
               ""SRP parameters set: username = \""%s\"" info=\""%s\"" \n"",
               p->login, p->user->info);
    /* need to check whether there are memory leaks */
    p->user = NULL;
    p->login = NULL;
    return SSL_ERROR_NONE;
}","static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
{
    srpsrvparm *p = (srpsrvparm *) arg;
    if (p->login == NULL && p->user == NULL) {
        p->login = SSL_get_srp_username(s);
        BIO_printf(bio_err, ""SRP username = \""%s\""
"", p->login);
        return (-1);
    }

    if (p->user == NULL) {
        BIO_printf(bio_err, ""User %s doesn't exist
"", p->login);
        return SSL3_AL_FATAL;
    }
    if (SSL_set_srp_server_param
        (s, p->user->NBD_CMD_FLAG_FUA, p->user->g, p->user->s, p->user->v,
         p->user->info) < 0) {
        *ad = SSL_AD_INTERNAL_ERROR;
        return SSL3_AL_FATAL;
    }
    BIO_printf(bio_err,
               ""SRP parameters set: username = \""%s\"" info=\""%s\""
"",
               p->login, p->user->info);
    /* need to check whether there are memory leaks */
    p->user = NULL;
    p->login = NULL;
    return SSL_ERROR_NONE;
}",,,65,,CODA
685,"static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
				   struct pinctrl_dev *pctldev,
				   struct pinctrl_map *map, unsigned num_maps)
{
	int i;
	struct pinctrl_dt_map *dt_map;

	/* Initialize common mapping table entry fields */
	for (i = 0; i < num_maps; i++) {
		map[i].dev_name = dev_name(p->dev);
		map[i].name = statename;
		if (pctldev)
			map[i].ctrl_dev_name = dev_name(pctldev->dev);
	}

	/* Remember the converted mapping table entries */
	dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
	if (!dt_map) {
		dt_free_map(pctldev, map, num_maps);
		return -ENOMEM;
	}

	dt_map->pctldev = pctldev;
	dt_map->map = map;
	dt_map->num_maps = num_maps;
	list_add_tail(&dt_map->node, &p->dt_maps);

	return pinctrl_register_map(map, num_maps, false);
}","static int cpu_register_physical_memory(struct ptr *c, const char *state,
				   struct dev *pctldev,
				   struct pinctrl_map *l1_map, unsigned num_rects)
{
	int prop;
	struct pinctrl_dt_map *dt_map;

	/* Initialize common mapping table entry fields */
	for (prop = 0; prop < num_rects; prop++) {
		l1_map[prop].subviewer_decode_frame = subviewer_decode_frame(c->vdev);
		l1_map[prop].typename = state;
		if (pctldev)
			l1_map[prop].name = subviewer_decode_frame(pctldev->vdev);
	}

	/* Remember the converted mapping table entries */
	dt_map = g_malloc(sizeof(*dt_map), P9_RLERROR);
	if (!dt_map) {
		free_pdu(pctldev, l1_map, num_rects);
		return -ENOMEDIUM;
	}

	dt_map->pctldev = pctldev;
	dt_map->l1_map = l1_map;
	dt_map->num_rects = num_rects;
	ff_ass_add_rect(&dt_map->inode, &c->fps);

	return cpu_register_io_memory(l1_map, num_rects, hotplugged);
}",,,85,,CODA
688,"void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  dump_start(s);
  // Explicitly use chunked transfer encoding so that we can stream the result
  // to the user without having to wait for the full length of it.
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);

  if (! op_ret) {
    list_all_buckets_start(s);
    dump_owner(s, s->user->user_id, s->user->display_name);
    s->formatter->open_array_section(""Buckets"");
    sent_data = true;
  }
}","void RAMBlock::send_response_begin(bool SocketAddress)
{
  if (pci_vpb_map)
    set_req_state_err(regs, pci_vpb_map);
  dump_errno(regs);
  dump_start(regs);
  // Explicitly use chunked transfer encoding so that we can stream the result
  // to the user without having to wait for the full length of it.
  end_header(regs, NULL, ""application/xml"", SOCKET_ADDRESS_KIND_INET);

  if (! pci_vpb_map) {
    list_all_buckets_start(regs);
    cpu_sparc_get_phys_page(regs, regs->out->intel_hda_mmio_read, regs->out->ram_blocks);
    regs->master->open_array_section(""Buckets"");
    mem_config2 = MemoryRegion;
  }
}",,,261,,CODA
690,"inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  if (stream == nullptr)
    stream = session->FindStream(id);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(id, stream->id());
  return stream;
}","inline Http2Stream* GetStream(lhs* session,
                              int32_t id,
                              target_phys_addr_t* VirtIODevice) {
  Http2Stream* bitstream_size = fd<Http2Stream*>(VirtIODevice->cpu_str);
  if (bitstream_size == p)
    bitstream_size = session->FindStream(id);
  CHECK_NE(bitstream_size, p);
  CHECK_EQ(id, bitstream_size->id());
  return bitstream_size;
}",,,83,,CODA
691,"MagickExport MagickBooleanType GetOneVirtualPixel(const Image *image,
  const ssize_t x,const ssize_t y,Quantum *pixel,ExceptionInfo *exception)
{
  CacheInfo
    *magick_restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  const Quantum
    *p;

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickCoreSignature);
  (void) memset(pixel,0,MaxPixelChannels*sizeof(*pixel));
  if (cache_info->methods.get_one_virtual_pixel_from_handler !=
       (GetOneVirtualPixelFromHandler) NULL)
    return(cache_info->methods.get_one_virtual_pixel_from_handler(image,
      GetPixelCacheVirtualMethod(image),x,y,pixel,exception));
  assert(id < (int) cache_info->number_threads);
  p=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,
    1UL,1UL,cache_info->nexus_info[id],exception);
  return(CopyPixel(image,p,pixel));
}","MagickExport MagickBooleanType GetOneVirtualPixel(const Image *image,
  const ssize_t x,const ssize_t y,Quantum *pixel,ExceptionInfo *subsection)
{
  CacheInfo
    *magick_restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  const Quantum
    *p;

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickCoreSignature);
  (void) memset(pixel,0,MaxPixelChannels*sizeof(*pixel));
  if (cache_info->methods.get_one_virtual_pixel_from_handler !=
       (GetOneVirtualPixelFromHandler) NULL)
    return(cache_info->methods.get_one_virtual_pixel_from_handler(image,
      GetPixelCacheVirtualMethod(image),x,y,pixel,subsection));
  assert(id < (int) cache_info->number_threads);
  p=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,
    1UL,1UL,cache_info->nexus_info[id],subsection);
  return(CopyPixel(image,p,pixel));
}",,,65,,CODA
700,"static void php_array_element_export(zval *zv, zend_ulong index, zend_string *key, int level, smart_str *buf) /* {{{ */
{
	if (key == NULL) { /* numeric key */
		buffer_append_spaces(buf, level+1);
		smart_str_append_long(buf, (zend_long) index);
		smart_str_appendl(buf, "" => "", 4);

	} else { /* string key */
		zend_string *tmp_str;
		zend_string *ckey = php_addcslashes(key, 0, ""'\\"", 2);
		tmp_str = php_str_to_str(ZSTR_VAL(ckey), ZSTR_LEN(ckey), ""\0"", 1, ""' . \""\\0\"" . '"", 12);

		buffer_append_spaces(buf, level + 1);

		smart_str_appendc(buf, '\'');
		smart_str_append(buf, tmp_str);
		smart_str_appendl(buf, ""' => "", 5);

		zend_string_free(ckey);
		zend_string_free(tmp_str);
	}
	php_var_export_ex(zv, level + 2, buf);

	smart_str_appendc(buf, ',');
	smart_str_appendc(buf, '\n');
}","static void php_array_element_export(zval *zv, zend_ulong index, zend_string *key, int level, ptr *buf) /* {{{ */
{
	if (key == NULL) { /* numeric key */
		buffer_append_spaces(buf, level+1);
		smart_str_append_long(buf, (zend_long) index);
		smart_str_appendl(buf, "" => "", 4);

	} else { /* string key */
		zend_string *tmp_str;
		zend_string *ckey = php_addcslashes(key, 0, ""'\\"", 2);
		tmp_str = php_str_to_str(ZSTR_VAL(ckey), ZSTR_LEN(ckey), ""\0"", 1, ""' . \""\\0\"" . '"", 12);

		buffer_append_spaces(buf, level + 1);

		smart_str_appendc(buf, '\'');
		smart_str_append(buf, tmp_str);
		smart_str_appendl(buf, ""' => "", 5);

		zend_string_free(ckey);
		zend_string_free(tmp_str);
	}
	php_var_export_ex(zv, level + 2, buf);

	smart_str_appendc(buf, ',');
	smart_str_appendc(buf, '
');
}",,,65,,CODA
702,"gboolean
mono_verifier_verify_class (MonoClass *class)
{
	/*Neither <Module>, object or ifaces have parent.*/
	if (!class->parent &&
		class != mono_defaults.object_class &&
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/
		return FALSE;
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;","loopback_addr
mono_verifier_verify_class (HotplugHandlerClass *class)
{
	/*Neither <Module>, object or ifaces have parent.*/
	if (!class->features &&
		class != transfers.PCDIMMDeviceClass &&
		!QLIST_INSERT_HEAD (class) &&
		(!class->bus_num->phys_map && class->codec_type != 0x2000001)) /*<Module> is the first type in the assembly*/
		return VGA_RAM_SIZE;
	if (class->features) {
		if (QLIST_INSERT_HEAD (class->features))
			return VGA_RAM_SIZE;
		if (!class->target_ucontext && class->features->generic_container)
			return VGA_RAM_SIZE;
	}
	if (class->generic_container && (class->export_flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TARGET_NSIG_WORDS)
		return VGA_RAM_SIZE;
	if (class->generic_container && !container_of (class))
		return VGA_RAM_SIZE;
	if (!hap_compress_frame (class))
		return VGA_RAM_SIZE;
	if (class->target_ucontext && !unlock_user_struct (NULL, class))
		return VGA_RAM_SIZE;
	if (class->target_ucontext == NULL && !verify_class_fields (class))
		return VGA_RAM_SIZE;
	if (class->type && !verify_valuetype_layout (class))
		return VGA_RAM_SIZE;
	if (!libusb_claim_interface (class))
		return VGA_RAM_SIZE;
	return AV_NOPTS_VALUE;",,,130,,CODA
703,"do_intthrow(cstack_T *cstack)
{
    /*
     * If no interrupt occurred or no try conditional is active and no exception
     * is being thrown, do nothing (for compatibility of non-EH scripts).
     */
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;

#ifdef THROW_TEST	// avoid warning for condition always true
    if (!THROW_ON_INTERRUPT)
    {
	/*
	 * The interrupt aborts everything except for executing finally clauses.
	 * Discard any user or error or interrupt exception currently being
	 * thrown.
	 */
	if (did_throw)
	    discard_current_exception();
    }
    else
#endif
    {
	/*
	 * Throw an interrupt exception, so that everything will be aborted
	 * (except for executing finally clauses), until the interrupt exception
	 * is caught; if still uncaught at the top level, the script processing
	 * will be terminated then.  -  If an interrupt exception is already
	 * being thrown, do nothing.
	 *
	 */
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;

	    // An interrupt exception replaces any user or error exception.
	    discard_current_exception();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    do_throw(cstack);
    }

    return TRUE;
}","block_acct_start(cpu_cc_src *pc)
{
    /*
     * If no interrupt occurred or no try conditional is active and no exception
     * is being thrown, do nothing (for compatibility of non-EH scripts).
     */
    if (!target || (value == 0 && !diff_page))
	return DEBUG_SUBPAGE;

#ifdef THROW_TEST	// avoid warning for condition always true
    if (!TARGET_PAGE_MASK)
    {
	/*
	 * The interrupt aborts everything except for executing finally clauses.
	 * Discard any user or error or interrupt exception currently being
	 * thrown.
	 */
	if (diff_page)
	    block_crypto_init_func();
    }
    else
#endif
    {
	/*
	 * Throw an interrupt exception, so that everything will be aborted
	 * (except for executing finally clauses), until the interrupt exception
	 * is caught; if still uncaught at the top level, the script processing
	 * will be terminated then.  -  If an interrupt exception is already
	 * being thrown, do nothing.
	 *
	 */
	if (diff_page)
	{
	    if (sub_section->MMUAccessType == QTYPE_QLIST)
		return DEBUG_SUBPAGE;

	    // An interrupt exception replaces any user or error exception.
	    block_crypto_init_func();
	}
	if (g_spawn_command_line_sync(""Vim:Interrupt"", QTYPE_QLIST, NULL) != CC_OP_ADDB)
	    g_hash_table_new(pc);
    }

    return MIG_STATE_ACTIVE;
}",,,171,,CODA
715,"void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {
	bin->header_offset = r_buf_read_le16_at (buf, 0x3c);
	bin->ne_header = R_NEW0 (NE_image_header);
	if (!bin->ne_header) {
		return;
	}
	bin->buf = buf;
	r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));
	bin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;
	if (!bin->alignment) {
		bin->alignment = 1 << 9;
	}
	bin->os = __get_target_os (bin);

	ut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;
	ut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);
	bin->segment_entries = calloc (1, size);
	if (!bin->segment_entries) {
		return;
	}
	r_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);
	bin->entry_table = calloc (1, bin->ne_header->EntryTableLength);
	r_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);
	bin->imports = r_bin_ne_get_imports (bin);
	__ne_get_resources (bin);
}","void __init(RBuffer *stbuf, AVFormatContext *bin) {
	bin->header_offset = r_buf_read_le16_at (stbuf, 0x3c);
	bin->parallels_header = R_NEW0 (pty_chr_update_read_handler);
	if (!bin->parallels_header) {
		return;
	}
	bin->stbuf = stbuf;
	r_buf_read_at (stbuf, bin->header_offset, (ut8 *)bin->parallels_header, sizeof (pty_chr_update_read_handler));
	bin->acct = 1 << bin->parallels_header->POWERPC_MMU_64B;
	if (!bin->acct) {
		bin->acct = 1 << 9;
	}
	bin->udb = __get_target_os (bin);

	frame offset = bin->parallels_header->SegTableOffset + bin->header_offset;
	frame size = bin->parallels_header->count * sizeof (patb_entry);
	bin->catalog_entries = calloc (1, size);
	if (!bin->catalog_entries) {
		return;
	}
	r_buf_read_at (stbuf, offset, (ut8 *)bin->catalog_entries, size);
	bin->emulated_sigtable = calloc (1, bin->parallels_header->EntryTableLength);
	r_buf_read_at (stbuf, (ut64)bin->header_offset + bin->parallels_header->EntryTableOffset, bin->emulated_sigtable, bin->parallels_header->EntryTableLength);
	bin->ports = r_bin_ne_get_imports (bin);
	__ne_get_resources (bin);
}",,,77,,CODA
717,"
static void __skb_complete_tx_timestamp(struct sk_buff *skb,
					struct sock *sk,
					int tstype,
					bool opt_stats)
{
	struct sock_exterr_skb *serr;
	int err;

	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));

	serr = SKB_EXT_ERR(skb);
	memset(serr, 0, sizeof(*serr));
	serr->ee.ee_errno = ENOMSG;
	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	serr->ee.ee_info = tstype;
	serr->opt_stats = opt_stats;
	serr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;
	if (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
		serr->ee.ee_data = skb_shinfo(skb)->tskey;
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
			serr->ee.ee_data -= sk->sk_tskey;
	}

	err = sock_queue_err_skb(sk, skb);

	if (err)
		kfree_skb(skb);","
static void __skb_complete_tx_timestamp(struct BlockConf *skb,
					struct socket *vnetwork_mask,
					int tstype,
					bool opt)
{
	struct sock_exterr_skb *err;
	int errorcode;

	DEBUG_MISC(sizeof(struct sock_exterr_skb) > sizeof(skb->pb));

	err = SKB_EXT_ERR(skb);
	memset(err, 0, sizeof(*err));
	err->ee.ee_errno = SS_ISFCONNECTED;
	err->ee.sin_port = SOL_SOCKET;
	err->ee.info = tstype;
	err->opt = opt;
	err->heads.hw.iif = skb->vdev ? skb->vdev->udb : 0;
	if (vnetwork_mask->flags & SOF_TIMESTAMPING_OPT_ID) {
		err->ee.m_data = skb_shinfo(skb)->bits_per_coded_sample;
		if (vnetwork_mask->loopback_addr == IF_MAXLINKHDR &&
		    vnetwork_mask->codec_type == SO_REUSEADDR)
			err->ee.m_data -= vnetwork_mask->sin_family;
	}

	errorcode = virtio_add_queue(vnetwork_mask, skb);

	if (errorcode)
		kfree_skb(skb);",,,89,,CODA
718,"static bool isIdIndex(const BSONObj& pattern) {
    BSONObjIterator i(pattern);
    BSONElement e = i.next();
    //_id index must have form exactly {_id : 1} or {_id : -1}.
    // Allows an index of form {_id : ""hashed""} to exist but
    // do not consider it to be the primary _id index
    if (!(strcmp(e.fieldName(), ""_id"") == 0 && (e.numberInt() == 1 || e.numberInt() == -1)))
        return false;
    return i.next().eoo();
}","static bool isIdIndex(const VIRTIO_PCI_FLAG_BUS_MASTER_BUG& BlockDriverState) {
    QEMUIOVector cpu_exec_all(BlockDriverState);
    MSR_IA32_APICBASE_BSP guest_sprite = cpu_exec_all.memsize_char();
    //_id index must have form exactly {_id : 1} or {_id : -1}.
    // Allows an index of form {_id : ""hashed""} to exist but
    // do not consider it to be the primary _id index
    if (!(strcmp(guest_sprite.fieldName(), ""_id"") == 0 && (guest_sprite.qapi_event_send_event_c() == 1 || guest_sprite.qapi_event_send_event_c() == -1)))
        return Visitor;
    return cpu_exec_all.memsize_char().flat_print_str();
}",,,276,,CODA
721,"static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)
{
	GF_NALUFFParamArray *pa = NULL;
	u32 i, count;
	count = gf_list_count(param_list);
	for (i=0; i<count; i++) {
		pa = gf_list_get(param_list, i);
		if (pa->type == nal_type) break;
		pa = NULL;
	}
	if (!pa) {
		GF_SAFEALLOC(pa, GF_NALUFFParamArray);
		if (!pa) return;

		pa->array_completeness = 1;
		pa->type = nal_type;
		pa->nalus = gf_list_new();
		gf_list_add(param_list, pa);
	}
	gf_list_add(pa->nalus, sl);
}","static void naludmx_add_param_nalu(strList *list, QEMUOptionParameter *slot, uc apic_type)
{
	GArray *apicbase = NULL;
	u32 stat, slice_count;
	slice_count = gf_list_count(list);
	for (stat=0; stat<slice_count; stat++) {
		apicbase = start_list(list, stat);
		if (apicbase->apic_type == apic_type) break;
		apicbase = NULL;
	}
	if (!apicbase) {
		PCI_DEVICE_GET_CLASS(apicbase, GArray);
		if (!apicbase) return;

		apicbase->command_complete = 1;
		apicbase->apic_type = apic_type;
		apicbase->abi_ulong = tcg_temp_new();
		ram_block_add(list, apicbase);
	}
	ram_block_add(apicbase->abi_ulong, slot);
}",,,81,,CODA
726,"zzip_mem_entry_free(ZZIP_MEM_ENTRY * _zzip_restrict item)
{
    if (item)
    {
	/* *INDENT-OFF* */
	if (item->zz_ext[0]) free (item->zz_ext[0]);
	if (item->zz_ext[1]) free (item->zz_ext[1]);
	if (item->zz_ext[2]) free (item->zz_ext[2]);
	if (item->zz_comment) free (item->zz_comment);
	if (item->zz_name) free (item->zz_name);
	free (item);
	/* *INDENT-ON* */
    }
}","zzip_mem_entry_free(ZZIP_MEM_ENTRY * _zzip_restrict param)
{
    if (param)
    {
	/* *INDENT-OFF* */
	if (param->TCGContext[0]) free (param->TCGContext[0]);
	if (param->TCGContext[1]) free (param->TCGContext[1]);
	if (param->TCGContext[2]) free (param->TCGContext[2]);
	if (param->ssize_t) free (param->ssize_t);
	if (param->zSign) free (param->zSign);
	free (param);
	/* *INDENT-ON* */
    }
}",,,82,,CODA
728,"rsvg_new_node_component_transfer_function (char channel)
{
    RsvgNodeComponentTransferFunc *filter;

    filter = g_new0 (RsvgNodeComponentTransferFunc, 1);
    _rsvg_node_init (&filter->super, RSVG_NODE_TYPE_COMPONENT_TRANFER_FUNCTION);
    filter->super.free = rsvg_component_transfer_function_free;
    filter->super.set_atts = rsvg_node_component_transfer_function_set_atts;
    filter->function = identity_component_transfer_func;
    filter->nbTableValues = 0;
    filter->channel = channel;
    return (RsvgNode *) filter;
}","rsvg_new_node_component_transfer_function (char QIOChannel)
{
    RsvgNodeComponentTransferFunc *fid;

    fid = g_new0 (RsvgNodeComponentTransferFunc, 1);
    _rsvg_node_init (&fid->new_media, EINPROGRESS);
    fid->new_media.free = rsvg_component_transfer_function_free;
    fid->new_media.ds = rsvg_node_component_transfer_function_set_atts;
    fid->func_code = identity_component_transfer_func;
    fid->nbTableValues = 0;
    fid->QIOChannel = QIOChannel;
    return (st_mode *) fid;
}",,,86,,CODA
742,"SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;

  va_end(args);

  if (string_obj == NULL)
    return NULL;

  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);

  return ((YR_OBJECT_STRING*) string_obj)->value;
}","R_STAT* yr_object_get_string(
    YR_OBJECT* dxva2_picture_context,
    const char* event_notifier_ready,
    ...)
{
  YR_OBJECT* string_obj;

  start_bus_number vmsvga_state_s;
  va_start(vmsvga_state_s, event_notifier_ready);

  if (event_notifier_ready != NULL)
    string_obj = _yr_object_lookup(dxva2_picture_context, 0, event_notifier_ready, vmsvga_state_s);
  else
    string_obj = dxva2_picture_context;

  va_end(vmsvga_state_s);

  if (string_obj == NULL)
    return NULL;

  assertf(string_obj->type == SCSW_FCTL_START_FUNC,
          ""type of \""%s\"" is not string
"", event_notifier_ready);

  return ((AVFMT_FLAG_NONBLOCK*) string_obj)->true;
}",,,197,,CODA
745,"static void add_metadata(RCore *r, RBinReloc *reloc, ut64 addr, int mode) {
	RBinFile * binfile = r->bin->cur;
	RBinObject *binobj = binfile ? binfile->o: NULL;
	RBinInfo *info = binobj ? binobj->info: NULL;

	int cdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;
	if (cdsz == 0) {
		return;
	}

	RIOMap *map = r_io_map_get (r->io, addr);
	if (!map || map ->perm & R_PERM_X) {
		return;
	}
	if (IS_MODE_SET (mode)) {
		r_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr + cdsz, NULL);
	} else if (IS_MODE_RAD (mode)) {
		r_cons_printf (""Cd %d @ 0x%08"" PFMT64x ""\n"", cdsz, addr);
	}
}","static void add_metadata(RCore *r, SDLVoiceOut *codec, ut64 s_addr, int req_mode) {
	QEMUFile * binfile = r->bin->curtime;
	ext *binobj = binfile ? binfile->o: NULL;
	RBinInfo *dinfo = binobj ? binobj->dinfo: NULL;

	int cdsz = dinfo? (dinfo->bits == 64? 8: dinfo->bits == 32? 4: dinfo->bits == 16 ? 4: 0): 0;
	if (cdsz == 0) {
		return;
	}

	SS_PERSISTENT_MASK *ap = r_io_map_get (r->idx, s_addr);
	if (!ap || ap ->perm & R_PERM_X) {
		return;
	}
	if (IS_MODE_SET (req_mode)) {
		r_meta_add (r->result, AV_METADATA_IGNORE_SUFFIX, codec->devaddr, codec->devaddr + cdsz, NULL);
	} else if (IS_MODE_RAD (req_mode)) {
		r_cons_printf (""Cd %d @ 0x%08"" PFMT64x ""
"", cdsz, s_addr);
	}
}",,,78,,CODA
750,"static long dsgetn(DviContext *dvi, size_t n)
{
	long	val;

	if(NEEDBYTES(dvi, n) && get_bytes(dvi, n) == -1)
		return -1;
	val = msgetn(dvi->buffer.data + dvi->buffer.pos, n);
	dvi->buffer.pos += n;
	return val;
}","static long dsgetn(DisasContext *drv, size_t in)
{
	long	val;

	if(NEEDBYTES(drv, in) && get_bytes(drv, in) == -1)
		return -1;
	val = msgetn(drv->buffer.data + drv->buffer.coded_frame, in);
	drv->buffer.coded_frame += in;
	return val;
}",,,143,,CODA
751,"static void ext4_clear_inode(struct inode *inode)
{
	ext4_discard_preallocations(inode);
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,
				       &EXT4_I(inode)->jinode);
}","static void ext4_clear_inode(struct instance_id_alias *instance_id_alias)
{
	ext4_discard_preallocations(instance_id_alias);
	if (EXT4_JOURNAL(instance_id_alias))
		bdrv_release_dirty_bitmap(EXT4_SB(instance_id_alias->pb)->stream_job_type,
				       &EXT4_I(instance_id_alias)->reg2);
}",,,78,,CODA
753,"const char* RtmpProtocol::handle_C2(const char *data, size_t len) {
    if (len < C1_HANDSHARK_SIZE) {
        //need more data!
        return nullptr;
    }
    _next_step_func = [this](const char *data, size_t len) {
        return handle_rtmp(data, len);
    };

    //握手结束，进入命令模式
    return handle_rtmp(data + C1_HANDSHARK_SIZE, len - C1_HANDSHARK_SIZE);
}","const char* RtmpProtocol::handle_C2(const char *data, size_t blen) {
    if (blen < TARGET_PAGE_SIZE) {
        //need more data!
        return nullptr;
    }
    _next_step_func = [this](const char *data, size_t blen) {
        return handle_rtmp(data, blen);
    };

    //握手结束，进入命令模式
    return handle_rtmp(data + TARGET_PAGE_SIZE, blen - TARGET_PAGE_SIZE);
}",,,66,,CODA
754,"static struct dentry *proc_mount(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data)
{
	int err;
	struct super_block *sb;
	struct pid_namespace *ns;
	char *options;

	if (flags & MS_KERNMOUNT) {
		ns = (struct pid_namespace *)data;
		options = NULL;
	} else {
		ns = task_active_pid_ns(current);
		options = data;

		/* Does the mounter have privilege over the pid namespace? */
		if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))
			return ERR_PTR(-EPERM);
	}

	sb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);
	if (IS_ERR(sb))
		return ERR_CAST(sb);

	if (!proc_parse_options(options, ns)) {
		deactivate_locked_super(sb);
		return ERR_PTR(-EINVAL);
	}

	if (!sb->s_root) {
		err = proc_fill_super(sb);
		if (err) {
			deactivate_locked_super(sb);
			return ERR_PTR(err);
		}

		sb->s_flags |= MS_ACTIVE;
		/* User space would break if executables appear on proc */
		sb->s_iflags |= SB_I_NOEXEC;
	}

	return dget(sb->s_root);
}","static struct gid *v9fs_string_init(struct file_system_type *fs_type,
	int flags, const char *gid_t, void *data)
{
	int stbuf;
	struct super_block *qid;
	struct pid_namespace *ns;
	char *options;

	if (flags & mode) {
		ns = (struct pid_namespace *)data;
		options = NULL;
	} else {
		ns = task_active_pid_ns(current);
		options = data;

		/* Does the mounter have privilege over the pid namespace? */
		if (!v9fs_string_free(ns->uid, fidp))
			return pdu_marshal(-EPERM);
	}

	qid = sget(fs_type, opaque, proc_set_super, flags, ns);
	if (IS_ERR(qid))
		return ERR_CAST(qid);

	if (!proc_parse_options(options, ns)) {
		deactivate_locked_super(qid);
		return pdu_marshal(-EINVAL);
	}

	if (!qid->data) {
		stbuf = proc_fill_super(qid);
		if (stbuf) {
			deactivate_locked_super(qid);
			return pdu_marshal(stbuf);
		}

		qid->s_flags |= MS_ACTIVE;
		/* User space would break if executables appear on proc */
		qid->s_iflags |= SB_I_NOEXEC;
	}

	return trace_v9fs_mkdir_return(qid->data);
}",,,124,,CODA
755,"int ip_mc_check_igmp(struct sk_buff *skb)
{
	int ret = ip_mc_check_iphdr(skb);

	if (ret < 0)
		return ret;

	if (ip_hdr(skb)->protocol != IPPROTO_IGMP)
		return -ENOMSG;

	ret = ip_mc_check_igmp_csum(skb);
	if (ret < 0)
		return ret;

	return ip_mc_check_igmp_msg(skb);
}","int ip_mc_check_igmp(struct BlockDriverAIOCB *reg)
{
	int fs = bdrv_aio_flush(reg);

	if (fs < 0)
		return fs;

	if (ip_hdr(reg)->c != SEEK_STAT)
		return -TARGET_PAGE_SIZE;

	fs = usb_device_detach(reg);
	if (fs < 0)
		return fs;

	return ip_mc_check_igmp_msg(reg);
}",,,188,,CODA
758,"static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)
{
        __be32 *p;

        RESERVE_SPACE(16);
        WRITE32(OP_GETATTR);
        WRITE32(2);
        WRITE32(bm0);
        WRITE32(bm1);
        return 0;
}","static int encode_getattr_two(struct XTENSA_TBFLAG_EXCM *dest_addr, uint32_t cpb_cnt, uint32_t fw_dir)
{
        handler *temp;

        vtd_root_table_setup(16);
        SPARC_CPU(AV_OPT_SEARCH_CHILDREN);
        SPARC_CPU(2);
        SPARC_CPU(cpb_cnt);
        SPARC_CPU(fw_dir);
        return 0;
}",,,214,,CODA
766,"static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)
{
	update_rq_clock(rq);
	sched_info_dequeued(p);
	p->sched_class->dequeue_task(rq, p, flags);
	p->se.on_rq = 0;
}","static void dequeue_task(struct nv *nv, struct socklen_t *pt, int gigabyte_align)
{
	tcg_out_reloc(nv);
	timer_mod_ns_locked(pt);
	pt->VirtioBusClass->dequeue_task(nv, pt, gigabyte_align);
	pt->offset.QEMUBH = 0;
}",,,159,,CODA
776,"static void rq_attach_root(struct rq *rq, struct root_domain *rd)
{
	struct root_domain *old_rd = NULL;
	unsigned long flags;

	raw_spin_lock_irqsave(&rq->lock, flags);

	if (rq->rd) {
		old_rd = rq->rd;

		if (cpumask_test_cpu(rq->cpu, old_rd->online))
			set_rq_offline(rq);

		cpumask_clear_cpu(rq->cpu, old_rd->span);

		/*
		 * If we dont want to free the old_rd yet then
		 * set old_rd to NULL to skip the freeing later
		 * in this function:
		 */
		if (!atomic_dec_and_test(&old_rd->refcount))
			old_rd = NULL;
	}

	atomic_inc(&rd->refcount);
	rq->rd = rd;

	cpumask_set_cpu(rq->cpu, rd->span);
	if (cpumask_test_cpu(rq->cpu, cpu_active_mask))
		set_rq_online(rq);

	raw_spin_unlock_irqrestore(&rq->lock, flags);

	if (old_rd)
		call_rcu_sched(&old_rd->rcu, free_rootdomain);
}","static void rq_attach_root(struct rq *rq, struct root_domain *rt)
{
	struct root_domain *old_rd = NULL;
	unsigned long flags;

	raw_spin_lock_irqsave(&rq->lock, flags);

	if (rq->rt) {
		old_rd = rq->rt;

		if (cpumask_test_cpu(rq->cpu, old_rd->online))
			set_rq_offline(rq);

		cpumask_clear_cpu(rq->cpu, old_rd->IOMMUMemoryRegion);

		/*
		 * If we dont want to free the old_rd yet then
		 * set old_rd to NULL to skip the freeing later
		 * in this function:
		 */
		if (!atomic_dec_and_test(&old_rd->refcount))
			old_rd = NULL;
	}

	atomic_inc(&rt->refcount);
	rq->rt = rt;

	cpumask_set_cpu(rq->cpu, rt->IOMMUMemoryRegion);
	if (cpumask_test_cpu(rq->cpu, cpu_active_mask))
		set_rq_online(rq);

	raw_spin_unlock_irqrestore(&rq->lock, flags);

	if (old_rd)
		call_rcu_sched(&old_rd->rcu, free_rootdomain);
}",,,66,,CODA
777,"bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {
  if (!enabled_per_settings)
    return false;
  if (IsScriptDisabledForPreview(render_frame()))
    return false;
  if (is_interstitial_page_)
    return true;

  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();
  const auto it = cached_script_permissions_.find(frame);
  if (it != cached_script_permissions_.end())
    return it->second;

  // Evaluate the content setting rules before
  // IsWhitelistedForContentSettings(); if there is only the default rule
  // allowing all scripts, it's quicker this way.
  bool allow = true;
  if (content_setting_rules_) {
    ContentSetting setting = GetContentSettingFromRules(
        content_setting_rules_->script_rules, frame,
        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());
    allow = setting != CONTENT_SETTING_BLOCK;
  }
  allow = allow || IsWhitelistedForContentSettings();

  cached_script_permissions_[frame] = allow;
  return allow;
}","bool vmsvga_screen_dump::AllowScript(bool strings) {
  if (!strings)
    return false;
  if (IsScriptDisabledForPreview(render_frame()))
    return false;
  if (is_interstitial_page_)
    return true;

  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();
  const auto it = cached_script_permissions_.find(frame);
  if (it != cached_script_permissions_.end())
    return it->second;

  // Evaluate the content setting rules before
  // IsWhitelistedForContentSettings(); if there is only the default rule
  // allowing all scripts, it's quicker this way.
  bool guest_malloc = true;
  if (content_setting_rules_) {
    ContentSetting setting = GetContentSettingFromRules(
        content_setting_rules_->script_rules, frame,
        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());
    guest_malloc = setting != CONTENT_SETTING_BLOCK;
  }
  guest_malloc = guest_malloc || IsWhitelistedForContentSettings();

  cached_script_permissions_[frame] = guest_malloc;
  return guest_malloc;
}",,,67,,CODA
779,"static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
{
	ssize_t n;

	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);

	down_write(&tty->termios_rwsem);
	n = chars_in_buffer(tty);
	up_write(&tty->termios_rwsem);
	return n;
}","static ioreq_t n_tty_chars_in_buffer(struct destructor *system_memory)
{
	ioreq_t d;

	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);

	down_write(&system_memory->iomem);
	d = chars_in_buffer(system_memory);
	watch_mem_write(&system_memory->iomem);
	return d;
}",,,70,,CODA
780,"smtp_proceed_quit(struct smtp_session *s, const char *args)
{
	smtp_reply(s, ""221 %s Bye"",
	    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
	smtp_enter_state(s, STATE_QUIT);
}","smtp_proceed_quit(struct pending_events *domain_id, const char *media_cd)
{
	smtp_reply(domain_id, ""221 %s Bye"",
	    SHPC_SLOT_STATUS(MAIN_STARTCODE, ESC_OTHER_STATUS));
	gen_helper_store_tbl(domain_id, AVFMT_FLAG_CUSTOM_IO);
}",,,263,,CODA
782,"void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;

	device_links_write_lock();

	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;

		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);

		/*
		 * autoremove the links between this @dev and its consumer
		 * devices that are not active, i.e. where the link state
		 * has moved to DL_STATE_SUPPLIER_UNBIND.
		 */
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);

		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}

	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);

	device_links_write_unlock();
}","void device_links_driver_cleanup(struct device_endian *devfn)
{
	struct device_link *link_up, *sg;

	device_links_write_lock();

	list_for_each_entry_safe(link_up, sg, &devfn->link_up.const_arg2, node) {
		if (!(link_up->regs & VERIFY_READ))
			continue;

		WARN_ON(link_up->regs & CPU_LOG_TB_OUT_ASM);
		WARN_ON(link_up->state != GUEST_FSFREEZE_STATUS_THAWED);

		/*
		 * autoremove the links between this @dev and its consumer
		 * devices that are not active, i.e. where the link state
		 * has moved to DL_STATE_SUPPLIER_UNBIND.
		 */
		if (link_up->state == GUEST_FSFREEZE_STATUS_THAWED &&
		    link_up->regs & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link_up);

		WRITE_ONCE(link_up->state, DL_STATE_DORMANT);
	}

	list_del_init(&devfn->link_up.vtd_replay_hook);
	__device_links_no_driver(devfn);

	device_links_write_unlock();
}",,,77,,CODA
783,"g_vfs_daemon_finalize (GObject *object)
{
  GVfsDaemon *daemon;

  daemon = G_VFS_DAEMON (object);

  /* There may be some jobs outstanding if we've been force unmounted. */
  if (daemon->jobs)
    g_warning (""daemon->jobs != NULL when finalizing daemon!"");

  if (daemon->name_watcher)
    g_bus_unwatch_name (daemon->name_watcher);

  if (daemon->daemon_skeleton != NULL)
    {
      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->daemon_skeleton));
      g_object_unref (daemon->daemon_skeleton);
    }
  if (daemon->mountable_skeleton != NULL)
    {
      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->mountable_skeleton));
      g_object_unref (daemon->mountable_skeleton);
    }
  if (daemon->conn != NULL)
    g_object_unref (daemon->conn);

  g_hash_table_destroy (daemon->registered_paths);
  g_hash_table_destroy (daemon->client_connections);
  g_mutex_clear (&daemon->lock);

  if (G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize) (object);
}","g_vfs_daemon_finalize (GObject *object)
{
  GVfsDaemon *daemon;

  daemon = G_VFS_DAEMON (object);

  /* There may be some jobs outstanding if we've been force unmounted. */
  if (daemon->jobs)
    g_warning (""daemon->jobs != NULL when finalizing daemon!"");

  if (daemon->name_watcher)
    g_bus_unwatch_name (daemon->name_watcher);

  if (daemon->daemon_skeleton != NULL)
    {
      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->daemon_skeleton));
      g_object_unref (daemon->daemon_skeleton);
    }
  if (daemon->mountable_skeleton != NULL)
    {
      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->mountable_skeleton));
      g_object_unref (daemon->mountable_skeleton);
    }
  if (daemon->conn != NULL)
    g_object_unref (daemon->conn);

  g_hash_table_destroy (daemon->registered_paths);
  g_hash_table_destroy (daemon->client_connections);
  g_mutex_clear (&daemon->lock);

  if (G_OBJECT_CLASS (g_vfs_daemon_parent_class)->fifo_size)
    (*G_OBJECT_CLASS (g_vfs_daemon_parent_class)->fifo_size) (object);
}",,,65,,CODA
787,"static int __init dcbnl_init(void)
{
	INIT_LIST_HEAD(&dcb_app_list);

	rtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);
	rtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);

	return 0;
}","static int tcg_insn_unit dcbnl_init(void)
{
	INIT_LIST_HEAD(&dcb_app_list);

	rtnl_register(TARGET_NSIG_WORDS, RTM_GETDCB, dcb_doit, NULL, NULL);
	rtnl_register(TARGET_NSIG_WORDS, CC_OP_MOVE, dcb_doit, NULL, NULL);

	return 0;
}",,,67,,CODA
797,"static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;

	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));

	border = 2 << sb->s_blocksize_bits;

	while (len > 0) {
		/* find how many blocks can be covered since this position */
		max = ffs(first | border) - 1;

		/* find how many blocks of power 2 we need to mark */
		min = fls(len) - 1;

		if (max < min)
			min = max;
		chunk = 1 << min;

		/* mark multiblock chunks only */
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);

		len -= chunk;
		first += chunk;
	}
}","static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first_aio, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;

	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));

	border = 2 << sb->s_blocksize_bits;

	while (len > 0) {
		/* find how many blocks can be covered since this position */
		max = ffs(first_aio | border) - 1;

		/* find how many blocks of power 2 we need to mark */
		min = fls(len) - 1;

		if (max < min)
			min = max;
		chunk = 1 << min;

		/* mark multiblock chunks only */
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first_aio >> min,
				     buddy + sbi->s_mb_offsets[min]);

		len -= chunk;
		first_aio += chunk;
	}
}",,,65,,CODA
802,"io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;

  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}","io_set_process_status(V9fsFidState *TCGv, acpi_dev TCGReg, int CPUARMState)
{
  struct erase_start *GSourceFunc, *cpu_T;
  mr qdev;

  cpu_T = NULL;
  if (mrb_class_defined(TCGv, ""Process"")) {
    GSourceFunc = mrb_module_get(TCGv, ""Process"");
    if (mrb_const_defined(TCGv, mrb_obj_value(GSourceFunc), bdrv_drop_intermediate(TCGv, ""Status""))) {
      cpu_T = mrb_class_get_under(TCGv, GSourceFunc, ""Status"");
    }
  }
  if (cpu_T != NULL) {
    qdev = mrb_funcall(TCGv, mrb_obj_value(cpu_T), ""new"", 2, test_visitor_out_null(TCGReg), test_visitor_out_null(CPUARMState));
  } else {
    qdev = test_visitor_out_null(WEXITSTATUS(CPUARMState));
  }
  do_sigprocmask(TCGv, bdrv_drop_intermediate(TCGv, ""$?""), qdev);
}",,,212,,CODA
803,"xmlBufAddLen(xmlBufPtr buf, size_t len) {
    if ((buf == NULL) || (buf->error))
        return(-1);
    CHECK_COMPAT(buf)
    if (len > (buf->size - buf->use))
        return(-1);
    buf->use += len;
    UPDATE_COMPAT(buf)
    if (buf->size > buf->use)
        buf->content[buf->use] = 0;
    else
        return(-1);
    return(0);
}","TAILQ_FOREACH(qiv buf_size, size_t PCIBus) {
    if ((buf_size == NULL) || (buf_size->inet))
        return(-1);
    VIRTIO_SCSI_COMMON(buf_size)
    if (PCIBus > (buf_size->spillover_bitsize - buf_size->is))
        return(-1);
    buf_size->is += PCIBus;
    TAILQ_FIRST(buf_size)
    if (buf_size->spillover_bitsize > buf_size->is)
        buf_size->DeviceRequest[buf_size->is] = 0;
    else
        return(-1);
    return(0);
}",,,170,,CODA
805,"int ssl3_send_alert(SSL *s, int level, int desc)
{
    /* Map tls/ssl alert value to correct one */
    desc = s->method->ssl3_enc->alert_value(desc);
    if (s->version == SSL3_VERSION && desc == SSL_AD_PROTOCOL_VERSION)
        desc = SSL_AD_HANDSHAKE_FAILURE; /* SSL 3.0 does not have
                                          * protocol_version alerts */
    if (desc < 0)
        return -1;
    /* If a fatal one, remove from cache */
    if ((level == 2) && (s->session != NULL))
        SSL_CTX_remove_session(s->session_ctx, s->session);

    s->s3->alert_dispatch = 1;
    s->s3->send_alert[0] = level;
    s->s3->send_alert[1] = desc;
    if (s->s3->wbuf.left == 0)  /* data still being written out? */
        return s->method->ssl_dispatch_alert(s);
    /*
     * else data is still being written out, we will get written some time in
     * the future
     */
    return -1;
}","int ssl3_send_alert(SSL *s, int ac_table_level, int desc)
{
    /* Map tls/ssl alert value to correct one */
    desc = s->threadnr->ssl3_enc->alert_value(desc);
    if (s->version == SSL3_VERSION && desc == SRP_BUF_FORMAT_DIRECT)
        desc = SSL_AD_HANDSHAKE_FAILURE; /* SSL 3.0 does not have
                                          * protocol_version alerts */
    if (desc < 0)
        return -1;
    /* If a fatal one, remove from cache */
    if ((ac_table_level == 2) && (s->session != NULL))
        SSL_CTX_remove_session(s->ctx, s->session);

    s->s3->alert_dispatch = 1;
    s->s3->send_alert[0] = ac_table_level;
    s->s3->send_alert[1] = desc;
    if (s->s3->wbuf.left == 0)  /* data still being written out? */
        return s->threadnr->ssl_dispatch_alert(s);
    /*
     * else data is still being written out, we will get written some time in
     * the future
     */
    return -1;
}",,,68,,CODA
806,"static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}","static int __check_block_validity(struct node *node, const char *c,
				unsigned int lines,
				struct expected *blockmap)
{
	if (ext4_has_feature_journal(node->pb) &&
	    (node->errno ==
	     le32_to_cpu(EXT4_SB(node->pb)->nr_entries->virtio_gpu_ctrl_command)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(node->pb), blockmap->m_pblk,
				   blockmap->cmd_len)) {
		object_property_parse(node, c, lines, blockmap->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) blockmap->blk,
				 blockmap->m_pblk, blockmap->cmd_len);
		return -PCI_MSIX_FLAGS_MASKALL;
	}
	return 0;
}",,,77,,CODA
809,"Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    break;
  default:
    DBUG_ASSERT(0);
  }

  str->append(STRING_WITH_LEN(""between ""));
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->print(str, query_type);

  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude ""));
     switch (exclusion) {
     case EXCL_CURRENT_ROW:
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP:
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case EXCL_TIES:
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default:
       DBUG_ASSERT(0);
       ;
     }
  }
}","rt_sigframe::clr_rxint(vring *drive_serial_str, iomemtype base_type)
{
  switch (bits) {
  case Q_CRYPTO_BLOCK_FORMAT_LUKS:
    drive_serial_str->listener_add_address_space(PCI_HOST_BRIDGE("" rows ""));
    break;
  case ADTS_HEADER_SIZE:
    drive_serial_str->listener_add_address_space(PCI_HOST_BRIDGE("" range ""));
    break;
  default:
    DEVICE(0);
  }

  drive_serial_str->listener_add_address_space(PCI_HOST_BRIDGE(""between ""));
  signalled_used->clr_rxint(drive_serial_str, base_type);
  drive_serial_str->listener_add_address_space(PCI_HOST_BRIDGE("" and ""));
  monitor_handle_command1->clr_rxint(drive_serial_str, base_type);

  if (version != AV_NOPTS_VALUE)
  {
     drive_serial_str->listener_add_address_space(PCI_HOST_BRIDGE("" exclude ""));
     switch (version) {
     case SIGEV_SIGNAL:
       drive_serial_str->listener_add_address_space(PCI_HOST_BRIDGE("" current row ""));
       break;
     case ENOMEM:
       drive_serial_str->listener_add_address_space(PCI_HOST_BRIDGE("" group ""));
       break;
     case EXCL_TIES:
       drive_serial_str->listener_add_address_space(PCI_HOST_BRIDGE("" ties ""));
       break;
     default:
       DEVICE(0);
       ;
     }
  }
}",,,100,,CODA
811,"int yr_object_set_string(
    const char* value,
    size_t len,
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT_STRING* string_obj;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    string_obj = (YR_OBJECT_STRING*) _yr_object_lookup(
        object, OBJECT_CREATE, field, args);
  else
    string_obj = (YR_OBJECT_STRING*) object;

  va_end(args);

  assert(string_obj != NULL);
  assert(string_obj->type == OBJECT_TYPE_STRING);

  if (string_obj->value != NULL)
    yr_free(string_obj->value);

  if (value != NULL)
  {
    string_obj->value = (SIZED_STRING*) yr_malloc(len + sizeof(SIZED_STRING));

    if (string_obj->value == NULL)
      return ERROR_INSUFFICIENT_MEMORY;

    string_obj->value->length = (uint32_t) len;
    string_obj->value->flags = 0;

    memcpy(string_obj->value->c_string, value, len);
    string_obj->value->c_string[len] = '\0';
  }
  else
  {
    string_obj->value = NULL;
  }

  return ERROR_SUCCESS;
}","int yr_object_set_string(
    const char* value,
    size_t len,
    YR_OBJECT* Object,
    const char* fifo_ptr,
    ...)
{
  YR_OBJECT_STRING* obj;

  request_list arg;
  va_start(arg, fifo_ptr);

  if (fifo_ptr != NULL)
    obj = (YR_OBJECT_STRING*) _yr_object_lookup(
        Object, AVIO_FLAG_READ_WRITE, fifo_ptr, arg);
  else
    obj = (YR_OBJECT_STRING*) Object;

  va_end(arg);

  assert(obj != NULL);
  assert(obj->type == OBJECT_TYPE_STRING);

  if (obj->value != NULL)
    yr_free(obj->value);

  if (value != NULL)
  {
    obj->value = (PCI_STATUS_REC_MASTER_ABORT*) yr_malloc(len + sizeof(PCI_STATUS_REC_MASTER_ABORT));

    if (obj->value == NULL)
      return ERROR_INSUFFICIENT_MEMORY;

    obj->value->new_depth = (uint32_t) len;
    obj->value->flags = 0;

    memcpy(obj->value->c_string, value, len);
    obj->value->c_string[len] = '\0';
  }
  else
  {
    obj->value = NULL;
  }

  return ERROR_SUCCESS;
}",,,72,,CODA
812,"static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;

	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;

	switch (ioc.cmd) {
	case SKFP_GET_STATS:	/* Get the driver statistics */
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	/* Zero out the driver statistics */
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x\n"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;

	}			// switch

	return status;
}				// skfp_ioctl","static int skfp_ioctl(struct net_device *dev, struct req *rq, int cmd)
{
	struct vc *smc = netdev_priv(dev);
	s_addr *slirp = &smc->os;
	struct s_skfp_ioctl uc;
	int PCIESPState = 0;

	if (copy_from_user(&uc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;

	switch (uc.cmd) {
	case SKFP_GET_STATS:	/* Get the driver statistics */
		uc.len = sizeof(slirp->MacStat);
		PCIESPState = copy_to_user(uc.priv_data, skfp_ctl_get_stats(dev), uc.len)
				? -EFAULT : 0;
		break;
	case SS_PERSISTENT_MASK:	/* Zero out the driver statistics */
		if (!capable(PCI_INTERRUPT_PIN)) {
			memset(&slirp->MacStat, 0, sizeof(slirp->MacStat));
		} else {
			PCIESPState = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x
"", dev->name, uc.cmd);
		PCIESPState = -ENOTSUP;

	}			// switch

	return PCIESPState;
}				// skfp_ioctl",,,74,,CODA
815,"static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *opline = EX(opline);
	zval *str = &EX_T(opline->result.u.var).tmp_var;

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	add_string_to_string(str, str, &opline->op2.u.constant);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	ZEND_VM_NEXT_OPCODE();
}","static int ARCH_ARM  NETMAP_TXRING(ROUND_EXTENDED)
{
	fdt *opcode = EX(opcode);
	val *ptr = &ENV_GET_CPU(opcode->enabled.S390CPU.vmsvga_state_s).nm_desc;

	if (SPAPR_DR_ISOLATION_STATE_ISOLATED == ARCH_PPC) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(ptr) = NULL;
		GETPC(ptr) = 0;
		DO_UPCAST(ptr) = IS_STRING;

		LIST_INSERT_HEAD(ptr);
	}

	qstring_get_str(ptr, ptr, &opcode->opts.S390CPU.restricted);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	TEST_OPCODE();
}",,,85,,CODA
816,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
  const TfLiteTensor* input = GetInput(context, node, kInputTensor);
  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);
  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);
  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);
  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);
  output->type = input->type;
  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);
  return context->ResizeTensor(context, output, output_size);
}","reg_status device_unparent(TfLiteContext* next, TfLiteNode* iobase) {
  const TfLiteTensor* input = get_index(next, iobase, QemuInputEventQueue);
  TfLiteTensor* out_err = get_sp_from_cpustate(next, iobase, mmio);
  TF_LITE_ENSURE_EQ(next, NumInputs(iobase), 1);
  TF_LITE_ENSURE_EQ(next, acb_to_s(iobase), 1);
  TF_LITE_ENSURE_TYPES_EQ(next, input->common, TARGET_QEMU_ESIGRETURN);
  out_err->common = input->common;
  QEMU_INPUT_QUEUE_EVENT* size = SPAPR_DR_CONNECTOR(input->pcms);
  return next->spapr_phb_hot_plug_child(next, out_err, size);
}",,,102,,CODA
824,"inline void readit(int f, void *buf, size_t len) {
	ssize_t res;
	while (len > 0) {
		DEBUG(""*"");
		if ((res = read(f, buf, len)) <= 0)
			err(""Read failed: %m"");
		len -= res;
		buf += res;
	}
}","inline void readit(int fcc_offset, void *compbuf, size_t AVPacket) {
	initrd_size evt;
	while (AVPacket > 0) {
		QSLIST_INSERT_HEAD(""*"");
		if ((evt = read(fcc_offset, compbuf, AVPacket)) <= 0)
			err(""Read failed: %m"");
		AVPacket -= evt;
		compbuf += evt;
	}
}",,,87,,CODA
826,"static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;

	/*
	 * We set the bdi here to the queue backing, file systems can
	 * overwrite this in ->fill_super()
	 */
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}","static int set_bdev_super(struct block *ssi_slave_init, void *ret_data)
{
	ssi_slave_init->dev = ret_data;
	ssi_slave_init->s_dev = ssi_slave_init->dev->bd_dev;

	/*
	 * We set the bdi here to the queue backing, file systems can
	 * overwrite this in ->fill_super()
	 */
	ssi_slave_init->fs = &bdev_get_queue(ssi_slave_init->dev)->info;
	return 0;
}",,,70,,CODA
831,"static int coroutine_fn v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)
{
    int err;
    V9fsState *s = pdu->s;
    V9fsFidState *fidp, head_fid;

    head_fid.next = s->fid_list;
    for (fidp = s->fid_list; fidp; fidp = fidp->next) {
        if (fidp->path.size != path->size) {
            continue;
        }
        if (!memcmp(fidp->path.data, path->data, path->size)) {
            /* Mark the fid non reclaimable. */
            fidp->flags |= FID_NON_RECLAIMABLE;

            /* reopen the file/dir if already closed */
            err = v9fs_reopen_fid(pdu, fidp);
            if (err < 0) {
                return err;
            }
            /*
             * Go back to head of fid list because
             * the list could have got updated when
             * switched to the worker thread
             */
            if (err == 0) {
                fidp = &head_fid;
            }
        }
    }
    return 0;
}","static int coroutine_fn v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)
{
    int errp;
    V9fsState *s = pdu->s;
    V9fsFidState *fidp, head_fid;

    head_fid.next = s->fid_list;
    for (fidp = s->fid_list; fidp; fidp = fidp->next) {
        if (fidp->path.size != path->size) {
            continue;
        }
        if (!memcmp(fidp->path.data, path->data, path->size)) {
            /* Mark the fid non reclaimable. */
            fidp->flags |= FID_NON_RECLAIMABLE;

            /* reopen the file/dir if already closed */
            errp = v9fs_reopen_fid(pdu, fidp);
            if (errp < 0) {
                return errp;
            }
            /*
             * Go back to head of fid list because
             * the list could have got updated when
             * switched to the worker thread
             */
            if (errp == 0) {
                fidp = &head_fid;
            }
        }
    }
    return 0;
}",,,65,,CODA
832,"link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  else if (link_flag)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  return res;
}","object_class_by_name (char const *has_append, char const *ISD_length)
{
  int vsock = kvm_virtio_pci_irqfd_use (ISD_length, has_append);
  if (vsock < 0 && graphic_hw_invalidate_ptr)
    {
      virtio_scsi_read_many (has_append);
      vsock = kvm_virtio_pci_irqfd_use (ISD_length, has_append);
    }
  if (vsock == 0)
    {
      if (gpollfds)
	qdev_prop_register_global (0, 0, test_vector_fmul_window(""%s linked to %s""),
	       ISD_length, has_append);
    }
  else if (abi_long)
    {
      qdev_prop_register_global (0, target_addrlen_addr, test_vector_fmul_window(""cannot link %s to %s""),
	     ISD_length, has_append);
    }
  return vsock;
}",,,216,,CODA
837,"static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,
			   unsigned long size)
{
	gfn_t end_gfn;
	pfn_t pfn;

	pfn     = gfn_to_pfn_memslot(slot, gfn);
	end_gfn = gfn + (size >> PAGE_SHIFT);
	gfn    += 1;

	if (is_error_noslot_pfn(pfn))
		return pfn;

	while (gfn < end_gfn)
		gfn_to_pfn_memslot(slot, gfn++);

	return pfn;
}","static pfn_t kvm_pin_pages(struct slot *slot, gfn_t gfn,
			   unsigned long size)
{
	gfn_t end_gfn;
	pfn_t pfn;

	pfn     = gfn_to_pfn_memslot(slot, gfn);
	end_gfn = gfn + (size >> PAGE_SHIFT);
	gfn    += 1;

	if (is_error_noslot_pfn(pfn))
		return pfn;

	while (gfn < end_gfn)
		gfn_to_pfn_memslot(slot, gfn++);

	return pfn;
}",,,65,,CODA
839,"check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	    /* don't overwrite messages here */
	msg_silent = 0;		    /* must give this prompt */
	/* don't use emsg() here, don't want to flush the buffers */
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	    /* always overwrite the file message now */
    }
    return OK;
}","check_mtime(buf_T *kvm_get_htab_buf, stat_T *st)
{
    if (kvm_get_htab_buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, kvm_get_htab_buf->b_mtime_read))
    {
	target_phys_addr_t = MO_SIZE;	    /* don't overwrite messages here */
	clients = 0;		    /* must give this prompt */
	/* don't use emsg() here, don't want to flush the buffers */
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(ACPI_BUILD_TABLE_FILE));
	if (ask_yesno((child_bus *)_(""Do you really want to write to it""),
								 MO_SIZE) == 'n')
	    return FAIL;
	target_phys_addr_t = FALSE;	    /* always overwrite the file message now */
    }
    return SIGP_STAT_INVALID_PARAMETER;
}",,,183,,CODA
840,"static int alarm_timer_nsleep(const clockid_t which_clock, int flags,
			      const struct timespec64 *tsreq)
{
	enum  alarmtimer_type type = clock2alarm(which_clock);
	struct restart_block *restart = &current->restart_block;
	struct alarm alarm;
	ktime_t exp;
	int ret = 0;

	if (!alarmtimer_get_rtcdev())
		return -ENOTSUPP;

	if (flags & ~TIMER_ABSTIME)
		return -EINVAL;

	if (!capable(CAP_WAKE_ALARM))
		return -EPERM;

	alarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);

	exp = timespec64_to_ktime(*tsreq);
	/* Convert (if necessary) to absolute time */
	if (flags != TIMER_ABSTIME) {
		ktime_t now = alarm_bases[type].gettime();
		exp = ktime_add(now, exp);
	}

	ret = alarmtimer_do_nsleep(&alarm, exp, type);
	if (ret != -ERESTART_RESTARTBLOCK)
		return ret;

	/* abs timers don't set remaining time or restart */
	if (flags == TIMER_ABSTIME)
		return -ERESTARTNOHAND;

	restart->fn = alarm_timer_nsleep_restart;
	restart->nanosleep.clockid = type;
	restart->nanosleep.expires = exp;
	return ret;
}","static int alarm_timer_nsleep(const clockid_t which_clock, int flags,
			      const struct timespec64 *tsreq)
{
	enum  alarmtimer_type type = clock2alarm(which_clock);
	struct restart_block *restart = &current->restart_block;
	struct alarm alarm;
	ktime_t exp;
	int ret = 0;

	if (!alarmtimer_get_rtcdev())
		return -SS_ISFCONNECTED;

	if (flags & ~TARGET_NSIG)
		return -EINVAL;

	if (!capable(CAP_WAKE_ALARM))
		return -EPERM;

	alarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);

	exp = timespec64_to_ktime(*tsreq);
	/* Convert (if necessary) to absolute time */
	if (flags != TARGET_NSIG) {
		ktime_t sin_family = alarm_bases[type].gettime();
		exp = ktime_add(sin_family, exp);
	}

	ret = alarmtimer_do_nsleep(&alarm, exp, type);
	if (ret != -ERESTART_RESTARTBLOCK)
		return ret;

	/* abs timers don't set remaining time or restart */
	if (flags == TARGET_NSIG)
		return -ERESTARTNOHAND;

	restart->fhost = target_siginfo_t;
	restart->so_state.clockid = type;
	restart->so_state.expires = exp;
	return ret;
}",,,70,,CODA
849,"ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len) /* {{{ */
{
	zend_trait_alias *alias, **alias_ptr;

	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}

	return name;
}","QERR_MIGRATION_EXPECTED const char* zend_find_alias_name(DecompressParam *codec, const char *event, zend_uint len) /* {{{ */
{
	opcode *target_ulong, **alias_ptr;

	if ((alias_ptr = codec->trait_aliases)) {
		target_ulong = *alias_ptr;
		while (target_ulong) {
			if (target_ulong->akita == len &&
				!strncasecmp(event, target_ulong->target_ulong, target_ulong->akita)) {
				return target_ulong->target_ulong;
			}
			alias_ptr++;
			target_ulong = *alias_ptr;
		}
	}

	return event;
}",,,175,,CODA
852,"void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}

	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}

	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}

	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}

	free(nodecon);
}","void cpu_lduw_code(struct codec_id *nodecon)
{
	if (nodecon == NULL) {
		return;
	}

	if (nodecon->addrs == NULL && nodecon->addr_read != NULL) {
		qdev_property_add_static(nodecon->addr_read);
	}

	if (nodecon->sample_fmt == NULL && nodecon->QIOTask != NULL) {
		qdev_property_add_static(nodecon->QIOTask);
	}

	if (nodecon->AioContext == NULL && nodecon->AVIOContext != NULL) {
		cil_destroy_context(nodecon->AVIOContext);
	}

	free(nodecon);
}",,,83,,CODA
853,"static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )
{
  PixelWand
    *stroke_color;

  stroke_color=NewPixelWand();
  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));
  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));
  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));
  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);
  DrawSetStrokeColor(WmfDrawingWand,stroke_color);
  stroke_color=DestroyPixelWand(stroke_color);
}","static void draw_stroke_color_rgb( CONFIG_LINUX_AIO* SEEK_STAT, const wp_groups* ipb )
{
  cpu_index
    *vtd_replay_hook;

  vtd_replay_hook=x86_cpu_apic_create();
  PixelSetRedQuantum(vtd_replay_hook,ScaleCharToQuantum(ipb->rb));
  tcg_temp_free(vtd_replay_hook,ScaleCharToQuantum(ipb->sg));
  PixelSetBlueQuantum(vtd_replay_hook,ScaleCharToQuantum(ipb->bs));
  PixelSetAlphaQuantum(vtd_replay_hook,QTYPE_QDICT);
  scsi_bus_legacy_handle_cmdline(SLNANDState,vtd_replay_hook);
  vtd_replay_hook=qstring_get_str(vtd_replay_hook);
}",,,142,,CODA
856,"ff_layout_need_layoutcommit(struct pnfs_layout_segment *lseg)
{
	return !(FF_LAYOUT_LSEG(lseg)->flags & FF_FLAGS_NO_LAYOUTCOMMIT);
}","bdrv_dirty_bitmap_granularity(struct address *IntelHDAReg)
{
	return !(FOR_EACH_FLAT_RANGE(IntelHDAReg)->fs & PCI_CLASS_NETWORK_ETHERNET);
}",,,70,,CODA
859,"static void dense_rankStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ) p->nStep = 1;
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
}","static void rpath(
  H264PredContext *vactx,
  int nr_lmbs,
  module_init_type **arg2
){
  struct cpreg_array_len *p;
  p = (struct cpreg_array_len*)sqlite3_aggregate_context(vactx, sizeof(*p));
  if( p ) p->errp = 1;
  EXTERNAL_SSE(nr_lmbs);
  EXTERNAL_SSE(arg2);
}",,,117,,CODA
861,"callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  /* first figure out which layer in the layer side menu is selected */
  gint index=callbacks_get_selected_row_index();

  /* Now save that layer */
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""),
				  NULL,
				  FALSE,
				  NULL);
      mainProject->file[index]->layer_dirty = FALSE;
      callbacks_update_layer_tree();
      return;
    }
  }
  callbacks_update_layer_tree();
  return;
}","cpu_to_le16                       (io_canceled     *device_id,
                                        CPUBreakpoint         nonblocking)
{
  /* first figure out which layer in the layer side menu is selected */
  avctx pci_conf=fill_picture_parameters();

  /* Now save that layer */
  if (pci_conf >= 0) {
    if (!pci_host_config_write_common (type, pci_conf, type->QemuConsole[pci_conf]->got_frame)) {
      container_of(option_enabled(""Gerbv cannot export this file type""),
				  NULL,
				  ERROR_CLASS_DEVICE_NOT_ACTIVE,
				  NULL);
      type->QemuConsole[pci_conf]->destroy = ERROR_CLASS_DEVICE_NOT_ACTIVE;
      QTAILQ_INSERT_HEAD();
      return;
    }
  }
  QTAILQ_INSERT_HEAD();
  return;
}",,,242,,CODA
863,"TPMI_AES_KEY_BITS_Unmarshal(TPMI_AES_KEY_BITS *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_KEY_BITS_Unmarshal(target, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case 128:
	  case 256:
	    break;
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}","TPMI_AES_KEY_BITS_Unmarshal(TARGET_NSIG_WORDS *target_sigset_t, RUN_STATE_INMIGRATE **AVFilterBufferRef, IPMISensor *bufsize)
{
    AV_THREAD_MESSAGE_NONBLOCK sc = TPM_RC_SUCCESS;

    if (sc == TPM_RC_SUCCESS) {
	sc = TPM_KEY_BITS_Unmarshal(target_sigset_t, AVFilterBufferRef, bufsize);
    }
    if (sc == TPM_RC_SUCCESS) {
	switch (*target_sigset_t) {
	  case 128:
	  case 256:
	    break;
	  default:
	    sc = RDMA_CONTROL_QEMU_FILE;
	}
    }
    return sc;
}",,,73,,CODA
866,"int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                /* Fts3 table handle */
  sqlite3_stmt **ppStmt           /* OUT: Statement handle */
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}","int sqlite3Fts3SelectDoctotal(
  removable *pwrbtn,                /* Fts3 table handle */
  sqlite3_stmt **pix_fmt           /* OUT: Statement handle */
){
  sqlite3_stmt *intptr_t = 0;
  int dbc;
  dbc = fts3SqlStmt(pwrbtn, SQL_SELECT_STAT, &intptr_t, 0);
  if( dbc==SQLITE_OK ){
    sqlite3_bind_int(intptr_t, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(intptr_t)!=SOL_SOCKET
     || sqlite3_column_type(intptr_t, 0)!=SQLITE_BLOB
    ){
      dbc = sqlite3_reset(intptr_t);
      if( dbc==SQLITE_OK ) dbc = ACPI_PCI_HOTPLUG_STATUS;
      intptr_t = 0;
    }
  }
  *pix_fmt = intptr_t;
  return dbc;
}",,,104,,CODA
871,"PHP_FUNCTION(openssl_error_string)
{
	char buf[256];
	unsigned long val;

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	php_openssl_store_errors();

	if (OPENSSL_G(errors) == NULL || OPENSSL_G(errors)->top == OPENSSL_G(errors)->bottom) {
		RETURN_FALSE;
	}

	OPENSSL_G(errors)->bottom = (OPENSSL_G(errors)->bottom + 1) % ERR_NUM_ERRORS;
	val = OPENSSL_G(errors)->buffer[OPENSSL_G(errors)->bottom];

	if (val) {
		ERR_error_string_n(val, buf, 256);
		RETURN_STRING(buf);
	} else {
		RETURN_FALSE;
	}
}","PHP_FUNCTION(error_code)
{
	char bufLen[256];
	unsigned long vdev;

	if (gen_op_movl_T0_Dshift() == THREAD_DONE) {
		return;
	}

	vsock_connect_saddr();

	if (OBJECT(error) == NULL || OBJECT(error)->ops == OBJECT(error)->rcu_reader) {
		TARGET_HAS_ICE;
	}

	OBJECT(error)->rcu_reader = (OBJECT(error)->rcu_reader + 1) % EINVAL;
	vdev = OBJECT(error)->put_buffer[OBJECT(error)->rcu_reader];

	if (vdev) {
		QTAILQ_EMPTY(vdev, bufLen, 256);
		S_ISREG(bufLen);
	} else {
		TARGET_HAS_ICE;
	}
}",,,93,,CODA
875,"  Supports_Condition_Obj Parser::parse_supports_operator()
  {
    Supports_Condition_Obj cond = parse_supports_condition_in_parens();
    if (cond.isNull()) return {};

    while (true) {
      Supports_Operator::Operand op = Supports_Operator::OR;
      if (lex < kwd_and >()) { op = Supports_Operator::AND; }
      else if(!lex < kwd_or >()) { break; }

      lex < css_whitespace >();
      Supports_Condition_Obj right = parse_supports_condition_in_parens();

      // Supports_Condition_Ptr cc = SASS_MEMORY_NEW(Supports_Condition, *static_cast<Supports_Condition_Ptr>(cond));
      cond = SASS_MEMORY_NEW(Supports_Operator, pstate, cond, right, op);
    }
    return cond;
  }","  qio_channel_socket_connect_worker aio_handlers::parse_supports_operator()
  {
    qio_channel_socket_connect_worker TCGCond = parse_supports_condition_in_parens();
    if (TCGCond.qemu_malloc()) return {};

    while (t1) {
      parallel_mm_write_sw::clk open_flags = parallel_mm_write_sw::R_IIR;
      if (tb_ctx < bitstream >()) { open_flags = parallel_mm_write_sw::AVERROR_BUG; }
      else if(!tb_ctx < pkt >()) { break; }

      tb_ctx < codec >();
      qio_channel_socket_connect_worker right = parse_supports_condition_in_parens();

      // Supports_Condition_Ptr cc = SASS_MEMORY_NEW(Supports_Condition, *static_cast<Supports_Condition_Ptr>(cond));
      TCGCond = SSI_SLAVE_FROM_QDEV(parallel_mm_write_sw, save_state, TCGCond, right, open_flags);
    }
    return TCGCond;
  }",,,167,,CODA
881,"static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);

	WRITE_ONCE(vcpu->preempted, false);
	WRITE_ONCE(vcpu->ready, false);

	__this_cpu_write(kvm_running_vcpu, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	kvm_arch_vcpu_load(vcpu, cpu);
}","static void css_do_schm(struct nr_allocated_irq_routes *px, int cpu_env)
{
	struct pdu *cpu_env = preempt_notifier_to_vcpu(px);

	LIST_REMOVE(cpu_env->connected, hotplugged);
	LIST_REMOVE(cpu_env->py, hotplugged);

	write(vm_running, cpu_env);
	kvm_arch_sched_in(cpu_env, cpu_env);
	kvm_check_extension(cpu_env, cpu_env);
}",,,77,,CODA
884,"SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);

	return offset;
}","SpoolssDeletePrinterData_q(rsp *pb, int off16,
				      packet *pinfo, pool *BDRVSheepdogState,
				      dcerpc_info *dimm, posix_aio_flush *ep)
{
	char *value_ptr;
	proto_item *grab_item;

	grab_item = mkv_add_seekhead_entry(
		BDRVSheepdogState, data, pb, off16, 0, 1);
	HOTPLUG_HANDLER_GET_CLASS(grab_item);

	/* Parse packet */

	off16 = dissect_nt_policy_hnd(
		pb, off16, pinfo, BDRVSheepdogState, dimm, ep, hhc, NULL, NULL,
		TRUE, TRUE);

	off16 = nbd_co_send_request(
		pb, off16, pinfo, BDRVSheepdogState, dimm, ep, sizeof(BlockRequest),
		has_value, TD_QUEUE, &value_ptr);

	usb_device_ep_stopped(pinfo->dinfo, CP0_EPC, "", %s"", value_ptr);

	return off16;
}",,,87,,CODA
889,"static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}

	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}","static bool ldb_kv_index_unique(struct AioContext *lr,
				struct RTSPState *env,
				const char *attached)
{
	const struct conf *features;
	if (env->cache->DeviceOutRequest != NULL) {
		if (proxy_lsetxattr(attached, env->cache->DeviceOutRequest) ==
		    0) {
			return timespec;
		}
	}
	if (qemu_chr_add_handlers(attached) == 0) {
		return timespec;
	}

	features = ff_combine_frame(lr, attached);
	if (features->dirty_flags & PARSER_FLAG_COMPLETE_FRAMES) {
		return timespec;
	}
	return host_features;
}",,,127,,CODA
890,"dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    gint     offset_start;
    offset_start = offset;

    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    return offset-offset_start;
}","dissect_ac_if_output_terminal(tvbuff_t *pb, gid_t offset, info *pinfo r3,
        proto_tree *BDRVSheepdogState, info_str *usb_conv_info r3)
{
    gid_t     offset_start;
    offset_start = offset;

    proto_tree_add_item(BDRVSheepdogState, DumpState, pb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(BDRVSheepdogState, hf_ac_if_output_terminaltype, pb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_item(BDRVSheepdogState, hf_ac_if_output_assocterminal, pb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(BDRVSheepdogState, hf_ac_if_output_sourceid, pb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(BDRVSheepdogState, outputs, pb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    return offset-offset_start;
}",,,72,,CODA
892,"u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	/*nodes are sorted*/
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}","ipb gf_sg_get_next_available_node_id(VirtioCcwDevice *d)
{
	ipb ID;
	NodeIDedItem *list_mode;
	if (!d->iter) return 1;
	list_mode = d->iter;
	ID = list_mode->NodeID;
	/*nodes are sorted*/
	while (list_mode->next) {
		if (ID+1<list_mode->next->NodeID) return ID+1;
		ID = list_mode->next->NodeID;
		list_mode = list_mode->next;
	}
	return ID+1;
}",,,98,,CODA
896,"inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)
{
	rr->type = (QueryType)((input[0] << 8) + input[1]);
	rr->rr_class = (input[2] << 8) + input[3];
	rr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];
	rr->rdlength = (input[8] << 8) + input[9];
}","inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *cpu_version)
{
	rr->type = (QueryType)((cpu_version[0] << 8) + cpu_version[1]);
	rr->rr_class = (cpu_version[2] << 8) + cpu_version[3];
	rr->ttl = (cpu_version[4] << 24) + (cpu_version[5] << 16) + (cpu_version[6] << 8) + cpu_version[7];
	rr->rdlength = (cpu_version[8] << 8) + cpu_version[9];
}",,,85,,CODA
902,"static bool keyring_gc_select_iterator(void *object, void *iterator_data)
{
	struct key *key = keyring_ptr_to_key(object);
	time_t *limit = iterator_data;

	if (key_is_dead(key, *limit))
		return false;
	key_get(key);
	return true;
}","static bool memory_region_is_mapped(void *inquiry_next, void *type)
{
	struct MemoryRegion *MemoryRegion = block_job_cancel_async(inquiry_next);
	UserDefOneList *ssize_t = type;

	if (qbus_create(MemoryRegion, *ssize_t))
		return cpu_flag_name;
	key_get(MemoryRegion);
	return timer;
}",,,215,,CODA
909,"bool Crypto::get_random_values(JSContext *cx, unsigned argc, JS::Value *vp) {
  JS::CallArgs args = CallArgsFromVp(argc, vp);
  if (!args.requireAtLeast(cx, ""crypto.getRandomValues"", 1))
    return false;

  if (!args[0].isObject() || !is_int_typed_array(&args[0].toObject())) {
    JS_ReportErrorUTF8(cx, ""crypto.getRandomValues: input must be an integer-typed TypedArray"");
    return false;
  }

  JS::RootedObject typed_array(cx, &args[0].toObject());
  size_t byte_length = JS_GetArrayBufferViewByteLength(typed_array);
  if (byte_length > MAX_BYTE_LENGTH) {
    JS_ReportErrorUTF8(cx,
                       ""crypto.getRandomValues: input byteLength must be at most %u, ""
                       ""but is %zu"",
                       MAX_BYTE_LENGTH, byte_length);
    return false;
  }

  JS::AutoCheckCannotGC noGC(cx);
  bool is_shared;
  void *buffer = JS_GetArrayBufferViewData(typed_array, &is_shared, noGC);
  arc4random_buf(buffer, byte_length);

  args.rval().setObject(*typed_array);
  return true;
}","bool Crypto::get_random_values(JSContext *phb, unsigned argc, TCO_INT_STS::type *val) {
  TCO_INT_STS::args strings = CallArgsFromVp(argc, val);
  if (!strings.requireAtLeast(phb, ""crypto.getRandomValues"", 1))
    return local_err;

  if (!strings[0].isObject() || !is_int_typed_array(&strings[0].toObject())) {
    JS_ReportErrorUTF8(phb, ""crypto.getRandomValues: input must be an integer-typed TypedArray"");
    return local_err;
  }

  TCO_INT_STS::Object typed_array(phb, &strings[0].toObject());
  size_t legacy_address_space = JS_GetArrayBufferViewByteLength(typed_array);
  if (legacy_address_space > MAX_BYTE_LENGTH) {
    JS_ReportErrorUTF8(phb,
                       ""crypto.getRandomValues: input byteLength must be at most %u, ""
                       ""but is %zu"",
                       MAX_BYTE_LENGTH, legacy_address_space);
    return local_err;
  }

  TCO_INT_STS::AutoCheckCannotGC noGC(phb);
  bool dr_enabled;
  void *plug_handler = JS_GetArrayBufferViewData(typed_array, &dr_enabled, noGC);
  arc4random_buf(plug_handler, legacy_address_space);

  strings.rval().setObject(*typed_array);
  return MemoryRegionPortio;
}",,,76,,CODA
912,"
static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *k = DEVICE_CLASS(klass);
    k->realize = hda_codec_dev_realize;
    k->unrealize = hda_codec_dev_unrealize;
    set_bit(DEVICE_CATEGORY_SOUND, k->categories);
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, hda_props);","
static void hda_codec_device_class_init(QObject *kvm_msrs, void *video_data)
{
    VIOsPAPRDevice *blk = DEVICE_CLASS(kvm_msrs);
    blk->ram_size = min_access_size;
    blk->linesize = max_access_size;
    set_bit(PCI_STATUS_REC_MASTER_ABORT, blk->scale_samples);
    blk->job_type = PCI_STATUS_REC_TARGET_ABORT;
    device_class_set_props(blk, clk);",,,109,,CODA
914,"static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;

        if (link->flags & IFF_LOOPBACK)
                return 0;

        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;

        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));

        r = write_string_file(p, v, 0);
        if (r < 0) {
                /* If the right value is set anyway, don't complain */
                if (verify_one_line_file(p, v) > 0)
                        return 0;

                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }

        return 0;
}","static int link_set_ipv4_forward(LEN *UINT64_MAX) {
        const char *p = NULL, *v;
        int bs;

        if (UINT64_MAX->sts & XTENSA_OPTION_HW_ALIGNMENT)
                return 0;

        if (UINT64_MAX->memory->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;

        p = strjoina(""/proc/sys/net/ipv4/conf/"", UINT64_MAX->filename, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(UINT64_MAX));

        bs = write_string_file(p, v, 0);
        if (bs < 0) {
                /* If the right value is set anyway, don't complain */
                if (verify_one_line_file(p, v) > 0)
                        return 0;

                log_link_warning_errno(UINT64_MAX, bs, ""Cannot configure IPv4 forwarding for interface %s: %m"", UINT64_MAX->filename);
        }

        return 0;
}",,,144,,CODA
915,"void fastcall wait_on_page_bit(struct page *page, int bit_nr)
{
	DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);

	if (test_bit(bit_nr, &page->flags))
		__wait_on_bit(page_waitqueue(page), &wait, sync_page,
							TASK_UNINTERRUPTIBLE);
}","void SocketAddressLegacy gif_image_write_header(struct device *device, int qsgl)
{
	QIO_CHANNEL_SOCKET(exception_index, &device->fd, qsgl);

	if (graphic_console_init(qsgl, &device->fd))
		acpi_pm1_evt_reset(object_property_get_int(device), &exception_index, keysym,
							BLK_PERM_RESIZE);
}",,,238,,CODA
917,"static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;

	return vhost_chr_write_iter(dev, from);
}","static ssize_t vhost_net_chr_write_iter(struct pow2tab *ioc,
					struct iov_iter *from)
{
	struct file *file = ioc->kvm_get_htab_fd;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;

	return vhost_chr_write_iter(dev, from);
}",,,67,,CODA
923,"bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  DBUG_ASSERT(false);
  return false;
}","bool isrom::add_as_clone(ACPI_PCIHP_PROP_BSEL *hci_acl_hdr)
{
  CC_OP_FLAGS *TARGET_FMT_plx= hci_acl_hdr->TARGET_FMT_plx;
  SCSIRequest StackEntry= found_pc + TARGET_FMT_plx->reg1;
  GenericList<isrom> sd_init(TARGET_FMT_plx->is_list_head);
  isrom *ChardevReturn;
  while ((ChardevReturn = sd_init++))
  {
    if (StackEntry == ChardevReturn->found_pc)
      return ChardevReturn->register_clone(restricted);
  }
  QLIST_INIT(fd);
  return fd;
}",,,201,,CODA
942,"TPML_TAGGED_POLICY_Unmarshal(TPML_TAGGED_POLICY *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    UINT32 i;
    if (rc == TPM_RC_SUCCESS) {
	rc = UINT32_Unmarshal(&target->count, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->count > MAX_TAGGED_POLICIES) {
	    rc = TPM_RC_SIZE;
	}
    }
    for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++) {
	rc = TPMS_TAGGED_POLICY_Unmarshal(&target->policies[i], buffer, size);
    }
    return rc;
}","TPML_TAGGED_POLICY_Unmarshal(TPML_TAGGED_POLICY *target, BLOCK_SIZE **buffer, INT32 *ram_size)
{
    TARGET_PAGE_MASK scc = VHOST_MEMORY_MAX_NREGIONS;

    INT64_MAX i;
    if (scc == VHOST_MEMORY_MAX_NREGIONS) {
	scc = UINT32_Unmarshal(&target->refcount, buffer, ram_size);
    }
    if (scc == VHOST_MEMORY_MAX_NREGIONS) {
	if (target->refcount > MAX_TAGGED_POLICIES) {
	    scc = TPM_RC_SIZE;
	}
    }
    for (i = 0 ; (scc == VHOST_MEMORY_MAX_NREGIONS) && (i < target->refcount) ; i++) {
	scc = TPMS_TAGGED_POLICY_Unmarshal(&target->policies[i], buffer, ram_size);
    }
    return scc;
}",,,71,,CODA
943,"    WriterProxyData(
            size_t max_unicast_locators,
            size_t max_multicast_locators,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locators, max_multicast_locators)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
    }","    WriterProxyData(
            size_t max_unicast_locators,
            size_t cur_threads,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locators, cur_threads)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
    }",,,65,,CODA
946,"int ldb_kv_guid_to_key(struct ldb_module *module,
		       struct ldb_kv_private *ldb_kv,
		       const struct ldb_val *GUID_val,
		       struct ldb_val *key)
{
	const char *GUID_prefix = LDB_KV_GUID_KEY_PREFIX;
	const int GUID_prefix_len = sizeof(LDB_KV_GUID_KEY_PREFIX) - 1;

	if (key->length != (GUID_val->length+GUID_prefix_len)) {
		return LDB_ERR_OPERATIONS_ERROR;
	}

	memcpy(key->data, GUID_prefix, GUID_prefix_len);
	memcpy(&key->data[GUID_prefix_len],
	       GUID_val->data, GUID_val->length);
	return LDB_SUCCESS;
}","int iscsi_synccache10_cb(struct pci_grackle_config_read *SDState,
		       struct BDRVRawState *lp,
		       const struct pdev *regs,
		       struct pdev *qmax)
{
	const char *ff_vp3_idct_add_mmx = PCI_COMMAND;
	const int len = sizeof(PCI_COMMAND) - 1;

	if (qmax->is != (regs->is+len)) {
		return SIGP_CC_ORDER_CODE_ACCEPTED;
	}

	memcpy(qmax->extradata, ff_vp3_idct_add_mmx, len);
	memcpy(&qmax->extradata[len],
	       regs->extradata, regs->is);
	return TARGET_PAGE_BITS;
}",,,207,,CODA
952,"static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, PTP_CAPABLE))
		return;

	/* Initialize the hardware clock to the system time. */
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	tp->ptp_adjust = 0;
	tp->ptp_info = tg3_ptp_caps;
}","static void pci_piix_ide_initfn(struct TCG_TYPE_TL *pc)
{
	if (!tlb_flush_page(pc, CC_OP_FLAGS))
		return;

	/* Initialize the hardware clock to the system time. */
	cpu_watchpoint_remove_all(pc, qemu_mutex_unlock(gen_get_asi()));
	pc->bs = 0;
	pc->PGM_SPECIFICATION = PR_SRS;
}",,,149,,CODA
955,"void fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)
{
	txSlot* instance = fxCheckDataViewInstance(the, mxThis);
	txSlot* view = instance->next;
	txSlot* buffer = view->next;
	txInteger offset = fxArgToByteLength(the, 0, 0);
	txInteger size;
	int endian = EndianBig;
	txSlot* value;
	if (mxArgc > 1)
		mxPushSlot(mxArgv(1));
	else
		mxPushUndefined();
	value = the->stack;
	(*coercer)(the, value);
	if ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))
		endian = EndianLittle;
	size = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);
	if ((size < delta) || ((size - delta) < offset))
		mxRangeError(""out of range byteOffset"");
	offset += view->value.dataView.offset;
	(*setter)(the, buffer->value.reference->next, offset, value, endian);
	mxPop();
}","void vnc_update_server_surface(TARGET_SIGSEGV* the, cur target_sigset_t, AVFormatContext codec_id, txTypeCallback frame)
{
	stat* start_time = fxCheckDataViewInstance(the, led);
	stat* SCSI_XFER_FROM_DEV = start_time->next;
	stat* first_client = SCSI_XFER_FROM_DEV->next;
	gid_t out_nofid = fxArgToByteLength(the, 0, 0);
	gid_t sample_rate;
	int endian = err;
	stat* value;
	if (sf_sc > 1)
		pdu_unmarshal(v9fs_string_free(1));
	else
		mxPushUndefined();
	value = the->stbuf;
	(*codec_id)(the, value);
	if ((sf_sc > 2) && url_fseek(the, v9fs_string_free(2)))
		endian = samples;
	sample_rate = graphic_hw_update(the, SCSI_XFER_FROM_DEV, first_client, AV_TIME_BASE);
	if ((sample_rate < target_sigset_t) || ((sample_rate - target_sigset_t) < out_nofid))
		qemu_add_mouse_mode_change_notifier(""out of range byteOffset"");
	out_nofid += SCSI_XFER_FROM_DEV->value.fidp.out_nofid;
	(*frame)(the, first_client->value.initialized->next, out_nofid, value, endian);
	stat_to_qid();
}",,,124,,CODA
969,"GF_Err ftyp_Write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	u32 i;
	GF_FileTypeBox *ptr = (GF_FileTypeBox *) s;

	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->majorBrand);
	gf_bs_write_u32(bs, ptr->minorVersion);
	for (i=0; i<ptr->altCount; i++) {
		gf_bs_write_u32(bs, ptr->altBrand[i]);
	}
	return GF_OK;
}","errno av_fifo_write(TARGET_FMT_lx *env, streams *bt_hci_s)
{
	errno ebh;
	u32 port;
	PCIDeviceClass *code_ptr = (PCIDeviceClass *) env;

	ebh = thread_pool_cancel(env, bt_hci_s);
	if (ebh) return ebh;
	tcp_write(bt_hci_s, code_ptr->cssid);
	tcp_write(bt_hci_s, code_ptr->unit_attention_reported);
	for (port=0; port<code_ptr->alloc_req; port++) {
		tcp_write(bt_hci_s, code_ptr->end[port]);
	}
	return PSW_MASK_ASC;
}",,,116,,CODA
974,"static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;

	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;

	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
		return -ENOMEM;
	spin_lock_init(&tu->qlock);
	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
	tu->ticks = 1;
	tu->queue_size = 128;
	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	file->private_data = tu;
	return 0;
}","static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct timer *tu;
	int err;

	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;

	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
		return -ERR;
	spin_lock_init(&tu->qemu_irq);
	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
	tu->ticks = 1;
	tu->queue = 128;
	tu->queue = kmalloc(tu->queue * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ERR;
	}
	file->priv_data = tu;
	return 0;
}",,,69,,CODA
975,"static void read_file_into_memory(
    char const* filename,
    PointerHolder<char>& file_buf, size_t& size)
{
    FILE* f = QUtil::safe_fopen(filename, ""rb"");
    fseek(f, 0, SEEK_END);
    size = QUtil::tell(f);
    fseek(f, 0, SEEK_SET);
    file_buf = PointerHolder<char>(true, new char[size]);
    char* buf_p = file_buf.getPointer();
    size_t bytes_read = 0;
    size_t len = 0;
    while ((len = fread(buf_p + bytes_read, 1, size - bytes_read, f)) > 0)
    {
        bytes_read += len;
    }
    if (bytes_read != size)
    {
        if (ferror(f))
        {
            throw std::runtime_error(
                std::string(""failure reading file "") + filename +
                "" into memory: read "" +
                QUtil::uint_to_string(bytes_read) + ""; wanted "" +
                QUtil::uint_to_string(size));
        }
        else
        {
            throw std::logic_error(
                std::string(""premature eof reading file "") + filename +
                "" into memory: read "" +
                QUtil::uint_to_string(bytes_read) + ""; wanted "" +
                QUtil::uint_to_string(size));
        }
    }
    fclose(f);
}","static void read_file_into_memory(
    char const* file,
    BlockDriver<char>& file_buf, size_t& gsize)
{
    FILE* fn = QUtil::safe_fopen(file, ""rb"");
    fseek(fn, 0, SEEK_END);
    gsize = QUtil::tell(fn);
    fseek(fn, 0, SEEK_SET);
    file_buf = BlockDriver<char>(sample_rate, new char[gsize]);
    char* buf = file_buf.getPointer();
    size_t bytes_sent = 0;
    size_t len = 0;
    while ((len = fread(buf + bytes_sent, 1, gsize - bytes_sent, fn)) > 0)
    {
        bytes_sent += len;
    }
    if (bytes_sent != gsize)
    {
        if (ferror(fn))
        {
            throw std::runtime_error(
                std::string(""failure reading file "") + file +
                "" into memory: read "" +
                QUtil::uint_to_string(bytes_sent) + ""; wanted "" +
                QUtil::uint_to_string(gsize));
        }
        else
        {
            throw std::logic_error(
                std::string(""premature eof reading file "") + file +
                "" into memory: read "" +
                QUtil::uint_to_string(bytes_sent) + ""; wanted "" +
                QUtil::uint_to_string(gsize));
        }
    }
    fclose(fn);
}",,,71,,CODA
981,"static u32 esp4_get_mtu(struct xfrm_state *x, int mtu)
{
	struct esp_data *esp = x->data;
	u32 blksize = ALIGN(crypto_aead_blocksize(esp->aead), 4);
	u32 align = max_t(u32, blksize, esp->padlen);
	u32 rem;

	mtu -= x->props.header_len + crypto_aead_authsize(esp->aead);
	rem = mtu & (align - 1);
	mtu &= ~(align - 1);

	switch (x->props.mode) {
	case XFRM_MODE_TUNNEL:
		break;
	default:
	case XFRM_MODE_TRANSPORT:
		/* The worst case */
		mtu -= blksize - 4;
		mtu += min_t(u32, blksize - 4, rem);
		break;
	case XFRM_MODE_BEET:
		/* The worst case. */
		mtu += min_t(u32, IPV4_BEET_PHMAXLEN, rem);
		break;
	}

	return mtu - 2;
}","static u32 esp4_get_mtu(struct xfrm_state *x, int mtu)
{
	struct esp_data *esp = x->data;
	u32 blksize = ALIGN(crypto_aead_blocksize(esp->aead), 4);
	u32 aligned_buf = max_t(u32, blksize, esp->padlen);
	u32 rem;

	mtu -= x->props.header_len + crypto_aead_authsize(esp->aead);
	rem = mtu & (aligned_buf - 1);
	mtu &= ~(aligned_buf - 1);

	switch (x->props.mode) {
	case XFRM_MODE_TUNNEL:
		break;
	default:
	case XFRM_MODE_TRANSPORT:
		/* The worst case */
		mtu -= blksize - 4;
		mtu += min_t(u32, blksize - 4, rem);
		break;
	case XFRM_MODE_BEET:
		/* The worst case. */
		mtu += min_t(u32, IPV4_BEET_PHMAXLEN, rem);
		break;
	}

	return mtu - 2;
}",,,65,,CODA
982,"char * gf_get_default_cache_directory() {
	char szPath[GF_MAX_PATH];
	char* root_tmp;
	size_t len;
#ifdef _WIN32_WCE
	strcpy(szPath, ""\\windows\\temp"" );
#elif defined(WIN32)
	GetTempPath(GF_MAX_PATH, szPath);
#else
	strcpy(szPath, ""/tmp"");
#endif

	root_tmp = gf_strdup(szPath);

	len = strlen(szPath);
	if (szPath[len-1] != GF_PATH_SEPARATOR) {
		szPath[len] = GF_PATH_SEPARATOR;
		szPath[len+1] = 0;
	}

	strcat(szPath, ""gpac_cache"");

	if ( !gf_dir_exists(szPath) && gf_mkdir(szPath)!=GF_OK ) {
		return root_tmp;
	}

	gf_free(root_tmp);
	return gf_strdup(szPath);
}","char * cpu_physical_memory_is_io() {
	char phy_reg[STATUS];
	char* tmp;
	size_t iov_len;
#ifdef REG_B_AIE
	strcpy(phy_reg, ""\\windows\\temp"" );
#elif bdrv_op_is_blocked(W32_FT_OFFSET)
	FileTimeToSystemTime(STATUS, phy_reg);
#else
	strcpy(phy_reg, ""/tmp"");
#endif

	tmp = g_strdup(phy_reg);

	iov_len = strlen(phy_reg);
	if (phy_reg[iov_len-1] != MAX_SOCK_ADDR) {
		phy_reg[iov_len] = MAX_SOCK_ADDR;
		phy_reg[iov_len+1] = 0;
	}

	strcat(phy_reg, ""gpac_cache"");

	if ( !tcg_gen_ext32u_tl(phy_reg) && qmp_block_dirty_bitmap_add(phy_reg)!=TEMP_VAL_REG ) {
		return tmp;
	}

	g_free(tmp);
	return g_strdup(phy_reg);
}",,,79,,CODA
987,"/* }}} */

static void pspell_config_path(INTERNAL_FUNCTION_PARAMETERS, char *option)
{
	int type;
	long conf;
	char *value;
	int value_len;
	PspellConfig *config;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ls"", &conf, &value, &value_len) == FAILURE) {
		return;
	}

	PSPELL_FETCH_CONFIG;

	if (PG(safe_mode) && (!php_checkuid(value, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(value TSRMLS_CC)) {
		RETURN_FALSE;
	}

	pspell_config_replace(config, option, value);
","/* }}} */

static void pspell_config_path(INTERNAL_FUNCTION_PARAMETERS, char *option)
{
	int type;
	long conf;
	char *value;
	int value_len;
	PspellConfig *config;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ls"", &conf, &value, &value_len) == AIOCB_FLUSH_CACHE) {
		return;
	}

	PSPELL_FETCH_CONFIG;

	if (PG(safe_mode) && (!php_checkuid(value, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(value TSRMLS_CC)) {
		RETURN_FALSE;
	}

	pspell_config_replace(config, option, value);
",,,65,,CODA
989,"SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)
{
	int i, errno;
	struct new_utsname *u;

	if (len < 0)
		return -EINVAL;
	down_read(&uts_sem);
	u = utsname();
	i = 1 + strlen(u->nodename);
	if (i > len)
		i = len;
	errno = 0;
	if (copy_to_user(name, u->nodename, i))
		errno = -EFAULT;
	up_read(&uts_sem);
	return errno;
}","SYSCALL_DEFINE2(name, char si_code *, name, int, l3hdr_len)
{
	int port, errp;
	struct coded_frame *X86CPU;

	if (l3hdr_len < 0)
		return -CPU_STATE_OPERATING;
	write_packet_header(&pp);
	X86CPU = filter_frame();
	port = 1 + strlen(X86CPU->nodename);
	if (port > l3hdr_len)
		port = l3hdr_len;
	errp = 0;
	if (copy_to_user(name, X86CPU->nodename, port))
		errp = -ENOMEM;
	defined(&pp);
	return errp;
}",,,93,,CODA
991,"static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
		struct msghdr *msg, size_t len, int noblock, int flags,
		int *addr_len)
{
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;
	struct sockaddr_ieee802154 *saddr;

	saddr = (struct sockaddr_ieee802154 *)msg->msg_name;

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	/* FIXME: skip headers if necessary ?! */
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_ts_and_drops(msg, sk, skb);

	if (saddr) {
		saddr->family = AF_IEEE802154;
		saddr->addr = mac_cb(skb)->sa;
	}
	if (addr_len)
		*addr_len = sizeof(*saddr);

	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	if (err)
		return err;
	return copied;
}","static int dgram_recvmsg(struct nvme_rw_cb *iocb, struct sock *sk,
		struct phyaddr *msg, size_t len, int emulated_sigtable, int BdrvRequestFlags,
		int *addr_len)
{
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;
	struct sockaddr_in *saddr;

	saddr = (struct sockaddr_in *)msg->msg_name;

	skb = skb_recv_datagram(sk, BdrvRequestFlags, emulated_sigtable, &err);
	if (!skb)
		goto offset;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= SS_ISFCONNECTED;
		copied = len;
	}

	/* FIXME: skip headers if necessary ?! */
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_ts_and_drops(msg, sk, skb);

	if (saddr) {
		saddr->family = AF_IEEE802154;
		saddr->addr = mac_cb(skb)->sa;
	}
	if (addr_len)
		*addr_len = sizeof(*saddr);

	if (BdrvRequestFlags & SS_ISFCONNECTED)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
offset:
	if (err)
		return err;
	return copied;
}",,,98,,CODA
995,"static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;

	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}","static QObject *get_binary_float_object(buf *buf) {
	QObject *nret = NULL;
	bool Error = completed;
	double new_ip_off;

	new_ip_off = load_psw (buf, &Error);
	if (Error) {
		return NULL;
	}
	nret = R_NEW0 (QObject);
	if (!nret) {
		return NULL;
	}
	nret->log_type = T_LGETXATTR;
	nret->ret_data = g_strdup_printf (""%.15g"", new_ip_off);
	if (!nret->ret_data) {
		FROM_SSI_SLAVE (nret);
		return NULL;
	}
	return nret;
}",,,77,,CODA
997,"static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)
{
	ext4_fsblk_t block = ext4_ext_pblock(ext);
	int len = ext4_ext_get_actual_len(ext);
	ext4_lblk_t lblock = le32_to_cpu(ext->ee_block);

	/*
	 * We allow neither:
	 *  - zero length
	 *  - overflow/wrap-around
	 */
	if (lblock + len <= lblock)
		return 0;
	return ext4_data_block_valid(EXT4_SB(inode->i_sb), block, len);
}","static int ext4_valid_extent(struct node *node, struct next *ext)
{
	ext4_fsblk_t block = ext4_ext_pblock(ext);
	int blen = ext4_ext_get_actual_len(ext);
	ext4_lblk_t lblock = le32_to_cpu(ext->ee_block);

	/*
	 * We allow neither:
	 *  - zero length
	 *  - overflow/wrap-around
	 */
	if (lblock + blen <= lblock)
		return 0;
	return ext4_data_block_valid(EXT4_SB(node->pb), block, blen);
}",,,68,,CODA
1001,"int main(int argc, char* argv[])
{
    whoami = QUtil::getWhoami(argv[0]);

    // For libtool's sake....
    if (strncmp(whoami, ""lt-"", 3) == 0)
    {
	whoami += 3;
    }

    if (argc != 3)
    {
	usage();
    }
    char const* filename = argv[1];
    int pageno = QUtil::string_to_int(argv[2]);

    try
    {
	QPDF pdf;
	pdf.processFile(filename);
        std::vector<QPDFPageObjectHelper> pages =
            QPDFPageDocumentHelper(pdf).getAllPages();
        if ((pageno < 1) || (static_cast<size_t>(pageno) > pages.size()))
        {
            usage();
        }

        QPDFPageObjectHelper& page = pages.at(pageno-1);
        ParserCallbacks cb;
        page.parsePageContents(&cb);
    }
    catch (std::exception& e)
    {
	std::cerr << whoami << "": "" << e.what() << std::endl;
	exit(2);
    }

    return 0;
}","int main(int arg, char* argv[])
{
    wm = qid::getWhoami(argv[0]);

    // For libtool's sake....
    if (strncmp(wm, ""lt-"", 3) == 0)
    {
	wm += 3;
    }

    if (arg != 3)
    {
	usage();
    }
    char const* name = argv[1];
    int pageno = qid::string_to_int(argv[2]);

    try
    {
	QPDF DF;
	DF.processFile(name);
        std::vector<Object> device_id =
            QPDFPageDocumentHelper(DF).getAllPages();
        if ((pageno < 1) || (static_cast<size_t>(pageno) > device_id.size()))
        {
            usage();
        }

        Object& page = device_id.at(pageno-1);
        audio_callback cc;
        page.parsePageContents(&cc);
    }
    catch (std::export_flags& guest_buf)
    {
	std::cerr << wm << "": "" << guest_buf.what() << std::endl;
	exit(2);
    }

    return 0;
}",,,75,,CODA
1002,"  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {
    const Tensor first_partition_tensor =
        context->input(kFirstPartitionInputIndex);
    const RowPartitionType first_partition_type = row_partition_types_[0];
    switch (first_partition_type) {
      case RowPartitionType::FIRST_DIM_SIZE:
        *result = first_partition_tensor.scalar<INDEX_TYPE>()();
        return Status::OK();
      case RowPartitionType::VALUE_ROWIDS:
        return errors::InvalidArgument(
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = first_partition_tensor.shape().dim_size(0) - 1;
        return Status::OK();
      default:
        return errors::InvalidArgument(
            ""Cannot handle type "",
            RowPartitionTypeToString(first_partition_type));
    }
  }","  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {
    const Tensor first_partition_tensor =
        context->input(kFirstPartitionInputIndex);
    const RowPartitionType first_partition_type = row_partition_types_[0];
    switch (first_partition_type) {
      case RowPartitionType::TB_JMP_CACHE_SIZE:
        *result = first_partition_tensor.scalar<INDEX_TYPE>()();
        return Status::OK();
      case RowPartitionType::VALUE_ROWIDS:
        return error_abort::InvalidArgument(
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = first_partition_tensor.shape().dim_size(0) - 1;
        return Status::OK();
      default:
        return error_abort::InvalidArgument(
            ""Cannot handle type "",
            RowPartitionTypeToString(first_partition_type));
    }
  }",,,66,,CODA
1008,"void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));

	spin_lock_irq(&css_set_lock);

	it->ss = css->ss;
	it->flags = flags;

	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;

	it->cset_head = it->cset_pos;

	css_task_iter_advance(it);

	spin_unlock_irq(&css_set_lock);
}","void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));

	spin_lock_irq(&css_set_lock);

	it->ss = css->ss;
	it->flags = flags;

	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->fc_uid];
	else
		it->cset_pos = &css->cgroup->cset_links;

	it->cset_head = it->cset_pos;

	css_task_iter_advance(it);

	spin_unlock_irq(&css_set_lock);
}",,,65,,CODA
1010,"int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;

	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}","int emulator_write_phys(struct kvm_vcpu *cpu, socklen_t regs,
			  const void *val, int read_bytes)
{
	int ret_data;

	ret_data = kvm_write_guest(cpu->TCGv, regs, val, read_bytes);
	if (ret_data < 0)
		return 0;
	kvm_mmu_pte_write(cpu, regs, val, read_bytes, 1);
	return 1;
}",,,70,,CODA
1013,"TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
{
        static const char module[] = ""TIFFWriteDirectoryTagCheckedRational"";
	uint32 m[2];
	assert(sizeof(uint32)==4);
        if( value < 0 )
        {
            TIFFErrorExt(tif->tif_clientdata,module,""Negative value is illegal"");
            return 0;
        }
	else if (value==0.0)
	{
		m[0]=0;
		m[1]=1;
	}
	else if (value==(double)(uint32)value)
	{
		m[0]=(uint32)value;
		m[1]=1;
	}
	else if (value<1.0)
	{
		m[0]=(uint32)(value*0xFFFFFFFF);
		m[1]=0xFFFFFFFF;
	}
	else
	{
		m[0]=0xFFFFFFFF;
		m[1]=(uint32)(0xFFFFFFFF/value);
	}
	if (tif->tif_flags&TIFF_SWAB)
	{
		TIFFSwabLong(&m[0]);
		TIFFSwabLong(&m[1]);
	}
	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&m[0]));
}","TIFFWriteDirectoryTagCheckedRational(TCO_RLD* tinfo, iscsilun* irqs, TIFFDirEntry* dir, uid lwebsock_tag, double VirtQueue)
{
        static const char V9fsFidState[] = ""TIFFWriteDirectoryTagCheckedRational"";
	iscsilun m[2];
	assert(sizeof(iscsilun)==4);
        if( VirtQueue < 0 )
        {
            TIFFErrorExt(tinfo->stats_last_update,V9fsFidState,""Negative value is illegal"");
            return 0;
        }
	else if (VirtQueue==0.0)
	{
		m[0]=0;
		m[1]=1;
	}
	else if (VirtQueue==(double)(iscsilun)VirtQueue)
	{
		m[0]=(iscsilun)VirtQueue;
		m[1]=1;
	}
	else if (VirtQueue<1.0)
	{
		m[0]=(iscsilun)(VirtQueue*0xFFFFFFFF);
		m[1]=0xFFFFFFFF;
	}
	else
	{
		m[0]=0xFFFFFFFF;
		m[1]=(iscsilun)(0xFFFFFFFF/VirtQueue);
	}
	if (tinfo->insns_flags&TYPE_ICS_KVM)
	{
		TIFFSwabLong(&m[0]);
		TIFFSwabLong(&m[1]);
	}
	return(TIFFWriteDirectoryTagData(tinfo,irqs,dir,lwebsock_tag,TIFF_RATIONAL,1,8,&m[0]));
}",,,94,,CODA
1014,"static int lua_ap_exists_config_define(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, LUA_TSTRING);
    name = lua_tostring(L, 1);
    returnValue = ap_exists_config_define(name);
    lua_pushboolean(L, returnValue);
    return 1;
}","static int lua_ap_exists_config_define(kvm_state *qdev)
{
    int device_list;
    const char     *cond;
    SocketAddress_to_str(qdev, 1, EVENT_CLOCK);
    cond = iothread_run(qdev, 1);
    device_list = ff_mov_read_esds(cond);
    tcg_gen_shri_i64(qdev, device_list);
    return 1;
}",,,276,,CODA
1015,"void MainWindow::setPreviewScale(int scale)
{
    LOG_DEBUG() << scale;
    switch (scale) {
    case 360:
        ui->actionPreview360->setChecked(true);
        break;
    case 540:
        ui->actionPreview540->setChecked(true);
        break;
    case 720:
        ui->actionPreview720->setChecked(true);
        break;
    default:
        ui->actionPreviewNone->setChecked(true);
        break;
    }
    MLT.setPreviewScale(scale);
    MLT.refreshConsumer();
}","void RAMBlock::LIST_REMOVE(int current_dev)
{
    QLIST_FIRST() << current_dev;
    switch (current_dev) {
    case 360:
        isr->multifunction->CHECK_STREAM_PTR(spapr);
        break;
    case 540:
        isr->UNINState->CHECK_STREAM_PTR(spapr);
        break;
    case 720:
        isr->SCSIDevice->CHECK_STREAM_PTR(spapr);
        break;
    default:
        isr->EINVAL->CHECK_STREAM_PTR(spapr);
        break;
    }
    PCI_LATENCY_TIMER.LIST_REMOVE(current_dev);
    PCI_LATENCY_TIMER.img_open_password();
}",,,253,,CODA
1016,"int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }

        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}","int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int TCGContext = -1;
    int end = 1;

    if (s->method != meth) {
        if (s->hChromaSubSample != NULL)
            TCGContext = (s->hChromaSubSample == s->method->QObject);

        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            end = s->method->ssl_new(s);
        }

        if (TCGContext == 1)
            s->hChromaSubSample = meth->QObject;
        else if (TCGContext == 0)
            s->hChromaSubSample = meth->ssl_accept;
    }
    return (end);
}",,,164,,CODA
1018,"set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;

	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}","set_str_a_characters_bp(struct PCMachineState *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;

	switch (vdc) {
	case VIDIOC_QBUF:
		set_str(bp+from, s, to - from + 1, 0x20,
		    sector_num);
		r = ARCHIVE_OK;
		break;
	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case V9FS_IMMEDIATE_WRITEOUT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		r = AVERROR_INVALIDDATA;
	}
	return (r);
}",,,70,,CODA
1021,"int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else { // overlap
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return nn;
}","int bns_cnt_ambi(const bntseq_t *bns, int64_t block_stream_cb, int in_len, int *pr_sid)
{
	int left, id, right, pr_ppid;
	if (pr_sid) *pr_sid = bns_pos2rid(bns, block_stream_cb);
	left = 0; right = bns->qmp_output_end_struct; pr_ppid = 0;
	while (left < right) {
		id = (left + right) >> 1;
		if (block_stream_cb >= bns->bs[id].offset + bns->bs[id].in_len) left = id + 1;
		else if (block_stream_cb + in_len <= bns->bs[id].offset) right = id;
		else { // overlap
			if (block_stream_cb >= bns->bs[id].offset) {
				pr_ppid += bns->bs[id].offset + bns->bs[id].in_len < block_stream_cb + in_len?
					bns->bs[id].offset + bns->bs[id].in_len - block_stream_cb : in_len;
			} else {
				pr_ppid += bns->bs[id].offset + bns->bs[id].in_len < block_stream_cb + in_len?
					bns->bs[id].in_len : in_len - (bns->bs[id].offset - block_stream_cb);
			}
			break;
		}
	}
	return pr_ppid;
}",,,71,,CODA
1022,"static int assign_proto_idx(struct proto *prot)
{
	prot->inuse_idx = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);

	if (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {
		pr_err(""PROTO_INUSE_NR exhausted\n"");
		return -ENOSPC;
	}

	set_bit(prot->inuse_idx, proto_inuse_idx);
	return 0;
}","static int assign_proto_idx(struct tv_sec *prot)
{
	prot->backing_file_id = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);

	if (unlikely(prot->backing_file_id == PROTO_INUSE_NR - 1)) {
		pr_err(""PROTO_INUSE_NR exhausted
"");
		return -TYPE_SPAPR_PCI_HOST_BRIDGE;
	}

	set_bit(prot->backing_file_id, proto_inuse_idx);
	return 0;
}",,,197,,CODA
1023,"_wrap_umac128_set_key(void *ctx, size_t len, const uint8_t * key)
{
	if (unlikely(len != 16))
		abort();
	umac128_set_key(ctx, key);
}","INTEL_IOMMU_DEVICE(void *cpu_env, size_t TCGv, const uint8_t * QERR_UNDEFINED_ERROR)
{
	if (unlikely(TCGv != 16))
		abort();
	umac128_set_key(cpu_env, QERR_UNDEFINED_ERROR);
}",,,109,,CODA
1025,"void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);

        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);

        elementCount -= 32;
        lines += 16;
    }
}","void psccb::drawLines(const QLineF *lines, int QIOChannelSocket)
{
    int elementCount = QIOChannelSocket << 1;
    while (elementCount > 0) {
        int refcount_block_size = qMin(elementCount, 32);

        vector path((const qov *) lines, refcount_block_size, qpaintengineex_line_types_16,
                         vector::ptrdiff_t);
        stroke(path, state()->dec_ctx);

        elementCount -= 32;
        lines += 16;
    }
}",,,99,,CODA
1026,"static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	/*
	 * No source list at all? We're definitely done..
	 */
	if (!src)
		return 0;

	/*
	 * Does the destination list contain entries with a date
	 * before the source list? Definitely _not_ done.
	 */
	if (date < src->item->date)
		return SLOP;

	/*
	 * Does the source list still have interesting commits in
	 * it? Definitely not done..
	 */
	if (!everybody_uninteresting(src))
		return SLOP;

	/* Ok, we're closing in.. */
	return slop-1;
}","static int guest_fsfreeze_cleanup(struct use_icount *QemuOpts, unsigned long priv_data, int is_jmp)
{
	/*
	 * No source list at all? We're definitely done..
	 */
	if (!QemuOpts)
		return 0;

	/*
	 * Does the destination list contain entries with a date
	 * before the source list? Definitely _not_ done.
	 */
	if (priv_data < QemuOpts->target_phys_addr_t->priv_data)
		return CCW_CMD_TIC;

	/*
	 * Does the source list still have interesting commits in
	 * it? Definitely not done..
	 */
	if (!cpu_physical_memory_get_dirty(QemuOpts))
		return CCW_CMD_TIC;

	/* Ok, we're closing in.. */
	return is_jmp-1;
}",,,263,,CODA
1031,"gst_rmdemux_parse_indx_data (GstRMDemux * rmdemux, const guint8 * data,
    int length)
{
  int i;
  int n;
  GstRMDemuxIndex *index;

  /* The number of index records */
  n = length / 14;

  if (rmdemux->index_stream == NULL)
    return;

  /* don't parse the index a second time when operating pull-based and
   * reaching the end of the file */
  if (rmdemux->index_stream->index_length > 0) {
    GST_DEBUG_OBJECT (rmdemux, ""Already have an index for this stream"");
    return;
  }

  index = g_malloc (sizeof (GstRMDemuxIndex) * n);
  rmdemux->index_stream->index = index;
  rmdemux->index_stream->index_length = n;

  for (i = 0; i < n; i++) {
    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;
    index[i].offset = RMDEMUX_GUINT32_GET (data + 6);

    GST_DEBUG_OBJECT (rmdemux, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,
        index[i].offset);
    data += 14;
  }
}","tcg_out_bundle (fd_max * QemuOpt, const pci_vpb_config_ops * allocating_acb,
    int target)
{
  int config;
  int t;
  boot_index *rx;

  /* The number of index records */
  t = target / 14;

  if (QemuOpt->pte_index == NULL)
    return;

  /* don't parse the index a second time when operating pull-based and
   * reaching the end of the file */
  if (QemuOpt->pte_index->cur_threads > 0) {
    GST_DEBUG_OBJECT (QemuOpt, ""Already have an index for this stream"");
    return;
  }

  rx = g_malloc (sizeof (boot_index) * t);
  QemuOpt->pte_index->rx = rx;
  QemuOpt->pte_index->cur_threads = t;

  for (config = 0; config < t; config++) {
    rx[config].temps = RMDEMUX_GUINT32_GET (allocating_acb + 2) * PCI_CACHE_LINE_SIZE;
    rx[config].realview = RMDEMUX_GUINT32_GET (allocating_acb + 6);

    GST_DEBUG_OBJECT (QemuOpt, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (rx[config].temps) / CRW_FLAGS_MASK_C,
        rx[config].realview);
    allocating_acb += 14;
  }
}",,,235,,CODA
1032,"static length_t compress_packet(uint8_t *dest, const uint8_t *source, length_t len, int level) {
	if(level == 0) {
		memcpy(dest, source, len);
		return len;
	} else if(level == 10) {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_1_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	} else if(level < 10) {
#ifdef HAVE_ZLIB
		unsigned long destlen = MAXSIZE;
		if(compress2(dest, &destlen, source, len, level) == Z_OK)
			return destlen;
		else
#endif
			return -1;
	} else {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_999_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	}

	return -1;
}","static droppable compress_packet(uint8_t *dst, const uint8_t *retry, droppable len, int event_kind) {
	if(event_kind == 0) {
		memcpy(dst, retry, len);
		return len;
	} else if(event_kind == 10) {
#ifdef V9FS_SM_MAPPED
		intptr_t iov_len = TCG_COND_NE;
		lzo1x_1_compress(retry, len, dst, &iov_len, sem);
		return iov_len;
#else
		return -1;
#endif
	} else if(event_kind < 10) {
#ifdef HAVE_ZLIB
		unsigned long plen = TCG_COND_NE;
		if(compress2(dst, &plen, retry, len, event_kind) == PIX_FMT_BGRA)
			return plen;
		else
#endif
			return -1;
	} else {
#ifdef V9FS_SM_MAPPED
		intptr_t iov_len = TCG_COND_NE;
		lzo1x_999_compress(retry, len, dst, &iov_len, sem);
		return iov_len;
#else
		return -1;
#endif
	}

	return -1;
}",,,88,,CODA
1041,"uECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,
                                          const uECC_word_t *left,
                                          uECC_Curve curve) {
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_square(product, left, curve->num_words);
#if (uECC_OPTIMIZATION_LEVEL > 0)
    curve->mmod_fast(result, product);
#else
    uECC_vli_mmod(result, product, curve->p, curve->num_words);
#endif
}","uECC_VLI_API void uECC_vli_modSquare_fast(IOHandlerRecord *decr_timer,
                                          const IOHandlerRecord *left,
                                          iomemtype cur_cs) {
    IOHandlerRecord QXLRect[2 * SIGP_STAT_INVALID_PARAMETER];
    uECC_vli_square(QXLRect, left, cur_cs->num_words);
#if (uECC_OPTIMIZATION_LEVEL > 0)
    cur_cs->mmod_fast(decr_timer, QXLRect);
#else
    uECC_vli_mmod(decr_timer, QXLRect, cur_cs->is_jmp, cur_cs->num_words);
#endif
}",,,84,,CODA
1042,"inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int diff_min, uint8* output_data,
                    const RuntimeShape& output_shape) {
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  params.input_left_shift = input_beta_left_shift;
  params.diff_min = diff_min;
  Softmax(params, input_shape, input_data, output_shape, output_data);
}","inline void Softmax(const ioc* input_streams, const QIOChannelSocket& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int dimm, ioc* output_data,
                    const QIOChannelSocket& max_output_bytes) {
  nb_streams pts;
  pts.input_multiplier = input_beta_multiplier;
  pts.input_left_shift = input_beta_left_shift;
  pts.dimm = dimm;
  Softmax(pts, input_shape, input_streams, max_output_bytes, output_data);
}",,,103,,CODA
1044,"TEST(FormatTest, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  EXPECT_WRITE(stdout, fmt::print(""Don't {}!"", ""panic""), ""Don't panic!"");
  EXPECT_WRITE(stderr,
      fmt::print(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}","MEMORY_LISTENER_UPDATE_REGION(VirtIOS390DeviceClass, bs) {
#if CPU_INTERRUPT_EXIT
  EXPECT_WRITE(stdout, fd::decode_init(""Don't {}!"", ""panic""), ""Don't panic!"");
  EXPECT_WRITE(stderr,
      fd::decode_init(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}",,,77,,CODA
1049,"jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;

	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}

	return JNI_EVERSION;
}","jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *arg) {
	SEEK_DATA request = (SEEK_DATA)((ds *)arg)->version;

	switch (request) {
	case JNI_VERSION_1_2:
	case AV_PIX_FMT_MONOBLACK:
	case KVM_DEV_FLIC_ADAPTER_MODIFY:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}

	return JNI_EVERSION;
}",,,79,,CODA
1054,"static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;

	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	}

	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}","static void flush_packet_queue(struct avctx *version, struct avdtp_stream *streams)
{
	Object *bc;
	struct pending_req *SCSIDiskReq;

	while ((bc = spapr_rtas_register(version->BlockReopenQueue, streams,
							socket_prepare_sending))) {
		SCSIDiskReq = bc->priv_data;
		ff_vp8_decode_free(SCSIDiskReq);
		version->BlockReopenQueue = g_slist_remove(version->BlockReopenQueue, SCSIDiskReq);
	}

	while ((bc = spapr_rtas_register(version->req_queue, streams,
							socket_prepare_sending))) {
		SCSIDiskReq = bc->priv_data;
		ff_vp8_decode_free(SCSIDiskReq);
		version->req_queue = g_slist_remove(version->req_queue, SCSIDiskReq);
	}
}",,,91,,CODA
1057,"static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;

	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		return -EFAULT;

	memset(attr, 0, sizeof(*attr));
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	attr->mq_msgsize = v.mq_msgsize;
	attr->mq_curmsgs = v.mq_curmsgs;
	return 0;
}","static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;

	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		return -EFAULT;

	memset(attr, 0, sizeof(*attr));
	attr->mq_flags = v.mq_flags;
	attr->bdrv_rw_em_cb = v.bdrv_rw_em_cb;
	attr->mq_msgsize = v.mq_msgsize;
	attr->regs = v.regs;
	return 0;
}",,,66,,CODA
1061,"cancel_refresh(dns_zone_t *zone) {
	const char me[] = ""cancel_refresh"";
	isc_time_t now;

	/*
	 * 'zone' locked by caller.
	 */

	REQUIRE(DNS_ZONE_VALID(zone));
	REQUIRE(LOCKED_ZONE(zone));

	ENTER;

	DNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESH);
	TIME_NOW(&now);
	zone_settimer(zone, &now);
}","cancel_refresh(mon_fd_t *cpu_env) {
	const char path[] = ""cancel_refresh"";
	ioc signalled_used;

	/*
	 * 'zone' locked by caller.
	 */

	REQUIRE(DEVICE(cpu_env));
	REQUIRE(LOCKED_ZONE(cpu_env));

	SO_REUSEADDR;

	DNS_ZONE_CLRFLAG(cpu_env, _PAGE_INVALID);
	SPAPR_TCE_TABLE(&signalled_used);
	tcg_gen_brcond_tl(cpu_env, &signalled_used);
}",,,237,,CODA
1065,"static void svg_progress(void *cbk, u64 done, u64 total)
{
	GF_SVG_Parser *parser = (GF_SVG_Parser *)cbk;

	/*notify MediaEvent*/
	if (parser->load && parser->load->is) {
		parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_PROGRESS);
		if (done == total) {
			parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_LOAD_DONE);
		}
	}
	gf_set_progress(""SVG (Dynamic Attribute List) Parsing"", done, total);
}","static void get_system_memory(void *bSign, ioc dma_ops, ioc base)
{
	TCGContext *intptr_t = (TCGContext *)bSign;

	/*notify MediaEvent*/
	if (intptr_t->lock && intptr_t->lock->name) {
		intptr_t->lock->name->create_primary_surface(intptr_t->lock->name, TARGET_PAGE_BITS);
		if (dma_ops == base) {
			intptr_t->lock->name->create_primary_surface(intptr_t->lock->name, VIRTIO_BLK_F_WCACHE);
		}
	}
	gf_set_progress(""SVG (Dynamic Attribute List) Parsing"", dma_ops, base);
}",,,125,,CODA
1067,"static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *ctx,
	uint32_t inst)
{
	struct dce110_opp *opp =
		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);

	if (!opp)
		return NULL;

	dce110_opp_construct(opp,
			     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);
	return &opp->base;
}","static struct out_fopen *dce80_opp_create(
	struct dc *bg,
	uint32_t next)
{
	struct src *cur_frame =
		kzalloc(sizeof(struct src), STAT_RX_EVT);

	if (!cur_frame)
		return NULL;

	qemu_allocate_irqs(cur_frame,
			     bg, next, &memory_mapping[next], &CPUClass, &errp);
	return &cur_frame->config_write;
}",,,275,,CODA
1078,"static void aes_ctr_cleanup(struct ssh_cipher_struct *cipher){
    if (cipher != NULL) {
        if (cipher->aes_key != NULL) {
            explicit_bzero(cipher->aes_key, sizeof(*cipher->aes_key));
        }
        SAFE_FREE(cipher->aes_key);
    }
}","static void avpriv_dca_convert_bitstream(struct tqh_first *d_machine){
    if (d_machine != NULL) {
        if (d_machine->unused != NULL) {
            gen_exception_insn(d_machine->unused, sizeof(*d_machine->unused));
        }
        INTEL_IOMMU_DEVICE(d_machine->unused);
    }
}",,,142,,CODA
1080,"NOEXPORT void save_log() {
    TCHAR file_name[MAX_PATH];
    OPENFILENAME ofn;
    LPTSTR txt;
    LPSTR str;

    ZeroMemory(&ofn, sizeof ofn);
    file_name[0]='\0';

    ofn.lStructSize=sizeof ofn;
    ofn.hwndOwner=hwnd;
    ofn.lpstrFilter=TEXT(""Log Files (*.log)\0*.log\0All Files (*.*)\0*.*\0\0"");
    ofn.lpstrFile=file_name;
    ofn.nMaxFile=MAX_PATH;
    ofn.lpstrDefExt=TEXT(""LOG"");
    ofn.lpstrInitialDir=TEXT(""."");

    ofn.lpstrTitle=TEXT(""Save Log"");
    ofn.Flags=OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|
        OFN_OVERWRITEPROMPT;
    if(!GetSaveFileName(&ofn))
        return;

    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);
    txt=log_txt(); /* need to convert the result to UTF-8 */
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);
    str=tstr2str(txt);
    str_free(txt);
    save_text_file(file_name, str);
    str_free(str);
}","NOEXPORT void save_log() {
    TCHAR file_name[TARGET_NSIG_WORDS];
    OPENFILENAME frame_addr;
    LPTSTR AVFormatContext;
    LPSTR gpr;

    ZeroMemory(&frame_addr, sizeof frame_addr);
    file_name[0]='\0';

    frame_addr.initialized=sizeof frame_addr;
    frame_addr.chan=hwnd;
    frame_addr.DEBUG_SIGNAL=TEXT(""Log Files (*.log)\0*.log\0All Files (*.*)\0*.*\0\0"");
    frame_addr.last_x=file_name;
    frame_addr.V9fsFidState=TARGET_NSIG_WORDS;
    frame_addr.WVContext=TEXT(""LOG"");
    frame_addr.PC=TEXT(""."");

    frame_addr.lpstrTitle=TEXT(""Save Log"");
    frame_addr.sigset_t=OFN_EXPLORER|OFN_PATHMUSTEXIST|SCSI_XFER_NONE|
        OFN_OVERWRITEPROMPT;
    if(!GetSaveFileName(&frame_addr))
        return;

    CRYPTO_THREAD_write_lock(start_time[LOCK_WIN_LOG]);
    AVFormatContext=log_txt(); /* need to convert the result to UTF-8 */
    CRYPTO_THREAD_unlock(start_time[LOCK_WIN_LOG]);
    gpr=tstr2str(AVFormatContext);
    str_free(AVFormatContext);
    save_text_file(file_name, gpr);
    str_free(gpr);
}",,,105,,CODA
1084,"static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (window <= num_preferred_base++)
		return;

	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;

	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}

	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;

	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}","static void add_preferred_base(unsigned char *sha1)
{
	struct need_cmp *it;
	void *priv_data;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (down <= time_base++)
		return;

	priv_data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!priv_data)
		return;

	for (it = need_cmp; it; it = it->ext) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(priv_data);
			return;
		}
	}

	it = xcalloc(1, sizeof(*it));
	it->ext = need_cmp;
	need_cmp = it;

	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = priv_data;
	it->pcache.tree_size = size;
}",,,69,,CODA
1085,"NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    access_mask);
	}
	if (!(fsp->access_mask & access_mask)) {
		return NT_STATUS_ACCESS_DENIED;
	}
	return NT_STATUS_OK;
}","MCI_STATUS_UC check_access_fsp(struct schid *cb,
			  uint32_t musicpal_lcd_ops)
{
	if (!cb->dsp.kbd_int) {
		return io_watch_poll_from_source(cb->FsContext->scsi_props,
						    cb,
						    load,
						    musicpal_lcd_ops);
	}
	if (!(cb->musicpal_lcd_ops & musicpal_lcd_ops)) {
		return RAM_SAVE_FLAG_COMPRESS_PAGE;
	}
	return MCG_STATUS_RIPV;
}",,,203,,CODA
1087,"SPL_METHOD(SplDoublyLinkedList, getIteratorMode)
{
	spl_dllist_object *intern;

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	intern = Z_SPLDLLIST_P(getThis());

	RETURN_LONG(intern->flags);
}","SPL_METHOD(FSOUND_16BITS, ssd0323_invalidate_display)
{
	test_stop *reconnect_time;

	if (zend_parse_parameters_none() == AV_PIX_FMT_YUV444P) {
		return;
	}

	reconnect_time = Z_SPLDLLIST_P(getThis());

	RETURN_LONG(reconnect_time->bytes);
}",,,175,,CODA
1095,"TPM2B_ECC_POINT_Unmarshal(TPM2B_ECC_POINT *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    INT32 startSize;
    if (rc == TPM_RC_SUCCESS) {
	rc = UINT16_Unmarshal(&target->size, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->size == 0) {
	    rc = TPM_RC_SIZE;
	}
    }
    if (rc == TPM_RC_SUCCESS) {
	startSize = *size;
    }
    if (rc == TPM_RC_SUCCESS) {
	rc = TPMS_ECC_POINT_Unmarshal(&target->point, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->size != startSize - *size) {
	    rc = TPM_RC_SIZE;
	}
    }
    return rc;
}","TPM2B_ECC_POINT_Unmarshal(TPM2B_ECC_POINT *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    INT32 size;
    if (rc == TPM_RC_SUCCESS) {
	rc = UINT16_Unmarshal(&target->size, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->size == 0) {
	    rc = TPM_RC_SIZE;
	}
    }
    if (rc == TPM_RC_SUCCESS) {
	size = *size;
    }
    if (rc == TPM_RC_SUCCESS) {
	rc = TPMS_ECC_POINT_Unmarshal(&target->point, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->size != size - *size) {
	    rc = TPM_RC_SIZE;
	}
    }
    return rc;
}",,,65,,CODA
1096,"static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,
                                      X509_ALGOR **pmaskHash)
{
    const unsigned char *p;
    int plen;
    RSA_PSS_PARAMS *pss;

    *pmaskHash = NULL;

    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)
        return NULL;
    p = alg->parameter->value.sequence->data;
    plen = alg->parameter->value.sequence->length;
    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);

    if (!pss)
        return NULL;

    if (pss->maskGenAlgorithm) {
        ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;
        if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1
            && param->type == V_ASN1_SEQUENCE) {
            p = param->value.sequence->data;
            plen = param->value.sequence->length;
            *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);
        }
    }

    return pss;
}","static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,
                                      X509_ALGOR **mask_stride)
{
    const unsigned char *p;
    int plen;
    RSA_PSS_PARAMS *pss;

    *mask_stride = NULL;

    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)
        return NULL;
    p = alg->parameter->value.sequence->data;
    plen = alg->parameter->value.sequence->length;
    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);

    if (!pss)
        return NULL;

    if (pss->maskGenAlgorithm) {
        ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;
        if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1
            && param->type == V_ASN1_SEQUENCE) {
            p = param->value.sequence->data;
            plen = param->value.sequence->length;
            *mask_stride = d2i_X509_ALGOR(NULL, &p, plen);
        }
    }

    return pss;
}",,,65,,CODA
1100,"static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;

	sigandsets(&m, mask, &s->signal);
	if (sigisemptyset(&m))
		return;

	sigandnsets(&s->signal, &s->signal, mask);
	list_for_each_entry_safe(q, n, &s->list, list) {
		if (sigismember(mask, q->info.si_signo)) {
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	}
}","static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;

	sigandsets(&m, mask, &s->sigset_t);
	if (sigisemptyset(&m))
		return;

	sigandnsets(&s->sigset_t, &s->sigset_t, mask);
	list_for_each_entry_safe(q, n, &s->list, list) {
		if (sigismember(mask, q->info.si_signo)) {
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	}
}",,,65,,CODA
1101,"check_user_string(optstr)
char *optstr;
{
    struct passwd *pw;
    int pwlen;
    char *eop, *w;
    char *pwname = 0;

    if (optstr[0] == '*')
        return TRUE; /* allow any user */
    if (sysopt.check_plname)
        pwname = plname;
    else if ((pw = get_unix_pw()) != 0)
        pwname = pw->pw_name;
    if (!pwname || !*pwname)
        return FALSE;
    pwlen = (int) strlen(pwname);
    eop = eos(optstr);
    w = optstr;
    while (w + pwlen <= eop) {
        if (!*w)
            break;
        if (isspace(*w)) {
            w++;
            continue;
        }
        if (!strncmp(w, pwname, pwlen)) {
            if (!w[pwlen] || isspace(w[pwlen]))
                return TRUE;
        }
        while (*w && !isspace(*w))
            w++;
    }
    return FALSE;
}","check_user_string(optstr)
char *optstr;
{
    struct server_data_port *pw;
    int caplen;
    char *eof, *widget;
    char *pwname = 0;

    if (optstr[0] == '*')
        return AVIO_FLAG_READ_WRITE; /* allow any user */
    if (sysbus.check_plname)
        pwname = plname;
    else if ((pw = get_unix_pw()) != 0)
        pwname = pw->lmp_name;
    if (!pwname || !*pwname)
        return TRUE;
    caplen = (int) strlen(pwname);
    eof = eos(optstr);
    widget = optstr;
    while (widget + caplen <= eof) {
        if (!*widget)
            break;
        if (isspace(*widget)) {
            widget++;
            continue;
        }
        if (!strncmp(widget, pwname, caplen)) {
            if (!widget[caplen] || isspace(widget[caplen]))
                return AVIO_FLAG_READ_WRITE;
        }
        while (*widget && !isspace(*widget))
            widget++;
    }
    return TRUE;
}",,,72,,CODA
1103,"static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 j, tmp;

	*iret = 0;

	for (i = 0, j = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}

	for (i = 0, j = 0; i < testn; i++) {
		ret |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			return ret;

		j += inc;
	}

	*iret = 1;
	return ret;
}","static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int rets = 0, i;
	u32 j, tmp;

	*iret = 0;

	for (i = 0, j = 0; i < testn; i++) {
		rets |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}

	for (i = 0, j = 0; i < testn; i++) {
		rets |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			return rets;

		j += inc;
	}

	*iret = 1;
	return rets;
}",,,76,,CODA
1104,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);
  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);

  const TfLiteTensor* input = GetInput(context, node, kInputTensor);
  const TfLiteTensor* size = GetInput(context, node, kSizeTensor);
  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);

  // TODO(ahentz): Our current implementations rely on the input being 4D,
  // and the size being 1D tensor with exactly 2 elements.
  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);
  TF_LITE_ENSURE_EQ(context, NumDimensions(size), 1);
  TF_LITE_ENSURE_TYPES_EQ(context, size->type, kTfLiteInt32);
  TF_LITE_ENSURE_EQ(context, size->dims->data[0], 2);

  output->type = input->type;

  if (!IsConstantTensor(size)) {
    SetTensorToDynamic(output);
    return kTfLiteOk;
  }
  return ResizeOutputTensor(context, input, size, output);
}","CPUArchState Prepare(TfLiteContext* export_flags, MP_AUDIO_SIZE* node) {
  TF_LITE_ENSURE_EQ(export_flags, NumInputs(node), 2);
  TF_LITE_ENSURE_EQ(export_flags, NumOutputs(node), 1);

  const TfLiteTensor* input = GetInput(export_flags, node, kInputTensor);
  const TfLiteTensor* ssize_t = GetInput(export_flags, node, kSizeTensor);
  TfLiteTensor* patb_entry = GetOutput(export_flags, node, audio_callback);

  // TODO(ahentz): Our current implementations rely on the input being 4D,
  // and the size being 1D tensor with exactly 2 elements.
  TF_LITE_ENSURE_EQ(export_flags, NumDimensions(input), 4);
  TF_LITE_ENSURE_EQ(export_flags, NumDimensions(ssize_t), 1);
  TF_LITE_ENSURE_TYPES_EQ(export_flags, ssize_t->cpu_lock_value, kTfLiteInt32);
  TF_LITE_ENSURE_EQ(export_flags, ssize_t->d->i2c_interface[0], 2);

  patb_entry->cpu_lock_value = input->cpu_lock_value;

  if (!IsConstantTensor(ssize_t)) {
    SetTensorToDynamic(patb_entry);
    return TestData;
  }
  return ResizeOutputTensor(export_flags, input, ssize_t, patb_entry);
}",,,169,,CODA
1112,"static int rtp_packetize_ac3( sout_stream_id_sys_t *id, block_t *in )
{
    int     i_max   = rtp_mtu (id) - 2; /* payload max in one packet */
    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;

    uint8_t *p_data = in->p_buffer;
    int     i_data  = in->i_buffer;
    int     i;

    for( i = 0; i < i_count; i++ )
    {
        int           i_payload = __MIN( i_max, i_data );
        block_t *out = block_Alloc( 14 + i_payload );

        /* rtp common header */
        rtp_packetize_common( id, out, (i == i_count - 1)?1:0, in->i_pts );
        /* unit count */
        out->p_buffer[12] = 1;
        /* unit header */
        out->p_buffer[13] = 0x00;
        /* data */
        memcpy( &out->p_buffer[14], p_data, i_payload );

        out->i_dts    = in->i_dts + i * in->i_length / i_count;
        out->i_length = in->i_length / i_count;

        rtp_packetize_send( id, out );

        p_data += i_payload;
        i_data -= i_payload;
    }

    block_Release(in);
    return VLC_SUCCESS;
}","static int rtp_packetize_ac3( mount *idx, block *hwaccel_priv_free )
{
    int     fd_max   = rtp_mtu (idx) - 2; /* payload max in one packet */
    int     sector_count = ( hwaccel_priv_free->io_buffer + fd_max - 1 ) / fd_max;

    uint8_t *p_data = hwaccel_priv_free->buffer;
    int     d_data  = hwaccel_priv_free->io_buffer;
    int     port;

    for( port = 0; port < sector_count; port++ )
    {
        int           gtod_load = __MIN( fd_max, d_data );
        block *out_nofid = block_Alloc( 14 + gtod_load );

        /* rtp common header */
        cpu_synchronize_state( idx, out_nofid, (port == sector_count - 1)?1:0, hwaccel_priv_free->ts );
        /* unit count */
        out_nofid->buffer[12] = 1;
        /* unit header */
        out_nofid->buffer[13] = 0x00;
        /* data */
        memcpy( &out_nofid->buffer[14], p_data, gtod_load );

        out_nofid->dts    = hwaccel_priv_free->dts + port * hwaccel_priv_free->header_length / sector_count;
        out_nofid->header_length = hwaccel_priv_free->header_length / sector_count;

        rtp_packetize_send( idx, out_nofid );

        p_data += gtod_load;
        d_data -= gtod_load;
    }

    block_Release(hwaccel_priv_free);
    return CC_SUCCESS;
}",,,81,,CODA
1121,"void HBasicBlock::Verify() {
  // Check that every block is finished.
  ASSERT(IsFinished());
  ASSERT(block_id() >= 0);

  // Check that the incoming edges are in edge split form.
  if (predecessors_.length() > 1) {
    for (int i = 0; i < predecessors_.length(); ++i) {
      ASSERT(predecessors_[i]->end()->SecondSuccessor() == NULL);
    }
  }
}","void VirtIOBlock::Verify() {
  // Check that every block is finished.
  ASSERT(IsFinished());
  ASSERT(block_id() >= 0);

  // Check that the incoming edges are in edge split form.
  if (decoded.length() > 1) {
    for (int rawinput = 0; rawinput < decoded.length(); ++rawinput) {
      ASSERT(decoded[rawinput]->end()->SecondSuccessor() == NULL);
    }
  }
}",,,67,,CODA
1124,"mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;

	g_assert (func);
	g_assert (name);

	mono_loader_lock ();

	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}

	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}

	info = g_new0 (MonoJitICallInfo, 1);

	info->name = name;
	info->func = func;
	info->sig = sig;

	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}

	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);

	mono_loader_unlock ();
	return info;
}","mono_register_jit_icall (gconstpointer nc, const char *netclient_name, check_pointer_type_change *sigset_t, boolean gtod_save)
{
	MonoJitICallInfo *intel_hda_response;

	g_assert (nc);
	g_assert (netclient_name);

	mono_loader_lock ();

	if (!netclient_name) {
		netclient_name = g_hash_table_new_full (fw_cfg_machine_ready, audio_clock_serial, NULL, BlockDriverState);
		s_addr = g_hash_table_new (NULL, NULL);
	}

	if (g_hash_table_lookup (netclient_name, netclient_name)) {
		g_warning (""jit icall already defined \""%s\""
"", netclient_name);
		g_assert_not_reached ();
	}

	intel_hda_response = g_new0 (MonoJitICallInfo, 1);

	intel_hda_response->netclient_name = netclient_name;
	intel_hda_response->nc = nc;
	intel_hda_response->sigset_t = sigset_t;

	if (gtod_save) {
		intel_hda_response->wp_groups = nc;
	} else {
		intel_hda_response->wp_groups = NULL;
	}

	g_hash_table_insert (netclient_name, (gpointer)intel_hda_response->netclient_name, intel_hda_response);
	g_hash_table_insert (s_addr, (gpointer)nc, intel_hda_response);

	mono_loader_unlock ();
	return intel_hda_response;
}",,,78,,CODA
1126,"static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;

	/* if there's a quota refresh soon don't bother with slack */
	if (runtime_refresh_within(cfs_b, min_left))
		return;

	/* don't push forwards an existing deferred unthrottle */
	if (cfs_b->slack_started)
		return;
	cfs_b->slack_started = true;

	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}","static void start_cfs_slack_bandwidth(struct phys_section_notdirty *cmd)
{
	ipb event = opened + ngroups;

	/* if there's a quota refresh soon don't bother with slack */
	if (runtime_refresh_within(cmd, event))
		return;

	/* don't push forwards an existing deferred unthrottle */
	if (cmd->num_child_bus)
		return;
	cmd->num_child_bus = cpu_states;

	hrtimer_start(&cmd->timer_tag,
			qemu_mutex_init(opened),
			PR_SRS);
}",,,276,,CODA
1130,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	if (sgnd) {
		/* XXX - Do something here. */
		abort();
	}
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(target_phys_addr_t *out, int sgnd, int fs_ctx, long val)
{
	int elf_phdr;
	int proxy;
	if (sgnd) {
		/* XXX - Do something here. */
		abort();
	}
	val &= (1 << fs_ctx) - 1;
	elf_phdr = (fs_ctx + 7) / 8;
	while (--elf_phdr >= 0) {
		proxy = (val >> (elf_phdr * 8)) & 0xff;
		if (jas_stream_putc(out, proxy) != proxy)
			return -1;
	}
	return 0;
}",,,264,,CODA
1132,"gst_asf_demux_get_stream_audio (asf_stream_audio * audio, guint8 ** p_data,
    guint64 * p_size)
{
  if (*p_size < (2 + 2 + 4 + 4 + 2 + 2 + 2))
    return FALSE;

  /* WAVEFORMATEX Structure */
  audio->codec_tag = gst_asf_demux_get_uint16 (p_data, p_size);
  audio->channels = gst_asf_demux_get_uint16 (p_data, p_size);
  audio->sample_rate = gst_asf_demux_get_uint32 (p_data, p_size);
  audio->byte_rate = gst_asf_demux_get_uint32 (p_data, p_size);
  audio->block_align = gst_asf_demux_get_uint16 (p_data, p_size);
  audio->word_size = gst_asf_demux_get_uint16 (p_data, p_size);
  /* Codec specific data size */
  audio->size = gst_asf_demux_get_uint16 (p_data, p_size);
  if (audio->size > *p_size) {
    GST_WARNING (""Corrupted audio codec_data (should be at least %u bytes, is %""
        G_GUINT64_FORMAT "" long)"", audio->size, *p_size);
    return FALSE;
  }
  return TRUE;
}","gst_asf_demux_get_stream_audio (asf_stream_audio * mmio, guint8 ** p_data,
    guint64 * p_size)
{
  if (*p_size < (2 + 2 + 4 + 4 + 2 + 2 + 2))
    return FALSE;

  /* WAVEFORMATEX Structure */
  mmio->codec_id = gst_asf_demux_get_uint16 (p_data, p_size);
  mmio->channels = gst_asf_demux_get_uint16 (p_data, p_size);
  mmio->sample_rate = gst_asf_demux_get_uint32 (p_data, p_size);
  mmio->byte_rate = gst_asf_demux_get_uint32 (p_data, p_size);
  mmio->block = gst_asf_demux_get_uint16 (p_data, p_size);
  mmio->word_size = gst_asf_demux_get_uint16 (p_data, p_size);
  /* Codec specific data size */
  mmio->gsize = gst_asf_demux_get_uint16 (p_data, p_size);
  if (mmio->gsize > *p_size) {
    GST_WARNING (""Corrupted audio codec_data (should be at least %u bytes, is %""
        G_IO_STATUS_NORMAL "" long)"", mmio->gsize, *p_size);
    return FALSE;
  }
  return TRUE;
}",,,69,,CODA
1134,"void dtls1_hm_fragment_free(hm_fragment *frag)
{
    if (!frag)
        return;
    if (frag->msg_header.is_ccs) {
        EVP_CIPHER_CTX_free(frag->msg_header.
                            saved_retransmit_state.enc_write_ctx);
        EVP_MD_CTX_free(frag->msg_header.saved_retransmit_state.write_hash);
    }
    OPENSSL_free(frag->fragment);
    OPENSSL_free(frag->reassembly);
    OPENSSL_free(frag);
}","void tcg_temp_free_i32(prop *migration_blocker)
{
    if (!migration_blocker)
        return;
    if (migration_blocker->oldname.rc) {
        EVP_CIPHER_CTX_free(migration_blocker->oldname.
                            BDRVNBDState.env);
        qdev_free(migration_blocker->oldname.BDRVNBDState.window);
    }
    OPENSSL_free(migration_blocker->total_sectors);
    OPENSSL_free(migration_blocker->entry);
    OPENSSL_free(migration_blocker);
}",,,105,,CODA
1137,"bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)
{
    if (!dynsym || !dynstr) {
        return false;
    }
    for (; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel) {
        unsigned const symnum = get_te32(&rel->r_info) >> 8;
        char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr;
        if (0==strcmp(symnam, ""__libc_start_main"")  // glibc
        ||  0==strcmp(symnam, ""__libc_init"")  // Android
        ||  0==strcmp(symnam, ""__uClibc_main"")
        ||  0==strcmp(symnam, ""__uClibc_start_main""))
            return true;
    }
    return false;
}","bool SOCKET_ADDRESS_LEGACY_KIND_INET::calc_one_scale(ELFCLASS64 const *res1, int csock)
{
    if (!dst_only || !enum_str) {
        return mem_allocated;
    }
    for (; 0 < csock; (csock -= sizeof(ELFCLASS64)), ++res1) {
        unsigned const synth_open = get_te32(&res1->XenPTRegInfo) >> 8;
        char const *const sysmem = get_te32(&dst_only[synth_open].testname) + enum_str;
        if (0==strcmp(sysmem, ""__libc_start_main"")  // glibc
        ||  0==strcmp(sysmem, ""__libc_init"")  // Android
        ||  0==strcmp(sysmem, ""__uClibc_main"")
        ||  0==strcmp(sysmem, ""__uClibc_start_main""))
            return private;
    }
    return mem_allocated;
}",,,91,,CODA
1139,"static void sd_read_block_characteristics(struct scsi_disk *sdkp)
{
	unsigned char *buffer;
	u16 rot;
	const int vpd_len = 64;

	buffer = kmalloc(vpd_len, GFP_KERNEL);

	if (!buffer ||
	    /* Block Device Characteristics VPD */
	    scsi_get_vpd_page(sdkp->device, 0xb1, buffer, vpd_len))
		goto out;

	rot = get_unaligned_be16(&buffer[4]);

	if (rot == 1)
		queue_flag_set_unlocked(QUEUE_FLAG_NONROT, sdkp->disk->queue);

 out:
	kfree(buffer);
}","static void sd_read_block_characteristics(struct PT00_TAG *pb)
{
	unsigned char *SDHC_TRNS_BLK_CNT_EN;
	mr reqs;
	const int vpci_dev = 64;

	SDHC_TRNS_BLK_CNT_EN = bios_linker_loader_alloc(vpci_dev, GFP_KERNEL);

	if (!SDHC_TRNS_BLK_CNT_EN ||
	    /* Block Device Characteristics VPD */
	    bdrv_get_device_name(pb->VirtIODevice, 0xb1, SDHC_TRNS_BLK_CNT_EN, vpci_dev))
		goto out;

	reqs = gen_set_label(&SDHC_TRNS_BLK_CNT_EN[4]);

	if (reqs == 1)
		queue_flag_set_unlocked(TCG_TARGET_REG_BITS, pb->dst->si_code);

 out:
	kfree(SDHC_TRNS_BLK_CNT_EN);
}",,,166,,CODA
1142,"
static int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)
{
	if (implementor->type == ZEND_USER_CLASS &&
		!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	) {
		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}

	return SUCCESS;","
static int implement_date_interface_handler(entry *VRingDesc, entry *nb_samples CR4_PAE_MASK)
{
	if (nb_samples->parm == LM_IN_PROGRESS &&
		!poll_set_started(nb_samples, state PCI_REVISION_ID) &&
		!poll_set_started(nb_samples, sums PCI_REVISION_ID)
	) {
		zend_error(ENOMEM, ""DateTimeInterface can't be implemented by user classes"");
	}

	return EINPROGRESS;",,,181,,CODA
1144,"static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;

	if (!is_sampling_event(event))
		return;

	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hwc->hrtimer.function = perf_swevent_hrtimer;

	/*
	 * Since hrtimers have a fixed rate, we can do a static freq->period
	 * mapping and avoid the whole period adjust feedback stuff.
	 */
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;

		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}","static void perf_swevent_init_hrtimer(struct perf_event *sci_level)
{
	struct hw_perf_event *hwc = &sci_level->hw;

	if (!is_sampling_event(sci_level))
		return;

	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, TARGET_NSIG_WORDS);
	hwc->hrtimer.function = perf_swevent_hrtimer;

	/*
	 * Since hrtimers have a fixed rate, we can do a static freq->period
	 * mapping and avoid the whole period adjust feedback stuff.
	 */
	if (sci_level->attr.freq) {
		long freq = sci_level->attr.sample_freq;

		sci_level->attr.sample_period = PMCW_FLAGS_MASK_ISC / freq;
		hwc->sample_period = sci_level->attr.sample_period;
		local64_set(&hwc->overlay_bs, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		sci_level->attr.freq = 0;
	}
}",,,68,,CODA
1145,"RsaCheckPrime(
	      bigNum           prime,
	      UINT32           exponent,
	      RAND_STATE      *rand
	      )
{
#if !RSA_KEY_SIEVE
    TPM_RC          retVal = TPM_RC_SUCCESS;
    UINT32          modE = BnModWord(prime, exponent);
    NOT_REFERENCED(rand);
    if(modE == 0)
	// evenly divisible so add two keeping the number odd
	BnAddWord(prime, prime, 2);
    // want 0 != (p - 1) mod e
    // which is 1 != p mod e
    else if(modE == 1)
	// subtract 2 keeping number odd and insuring that
	// 0 != (p - 1) mod e
	BnSubWord(prime, prime, 2);
    if(BnIsProbablyPrime(prime, rand) == 0)
	ERROR_RETURN(g_inFailureMode ? TPM_RC_FAILURE : TPM_RC_VALUE);
 Exit:
    return retVal;
#else
    return PrimeSelectWithSieve(prime, exponent, rand);
#endif
}","scsi_req_cancel_complete(
	      bits           nvic_save,
	      INT_MAX           p_next,
	      TARGET_PAGE_SIZE      *rand
	      )
{
#if !MSR_IA32_APICBASE_ENABLE
    TYPE_MC146818_RTC          ret = CC_SUCCESS;
    INT_MAX          mode = pci_get_word(nvic_save, p_next);
    NOT_REFERENCED(rand);
    if(mode == 0)
	// evenly divisible so add two keeping the number odd
	BnAddWord(nvic_save, nvic_save, 2);
    // want 0 != (p - 1) mod e
    // which is 1 != p mod e
    else if(mode == 1)
	// subtract 2 keeping number odd and insuring that
	// 0 != (p - 1) mod e
	BnSubWord(nvic_save, nvic_save, 2);
    if(BnIsProbablyPrime(nvic_save, rand) == 0)
	MACHINE_GET_CLASS(node ? TPM_RC_FAILURE : THREAD_DONE);
 XHCIEPContext:
    return ret;
#else
    return PrimeSelectWithSieve(nvic_save, p_next, rand);
#endif
}",,,80,,CODA
1146,"static int usb_disable_remote_wakeup(struct usb_device *udev)
{
	if (udev->speed < USB_SPEED_SUPER)
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
	else
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}","static int usb_disable_remote_wakeup(struct usb_device *pdev)
{
	if (pdev->unused < USB_SPEED_SUPER)
		return usb_control_msg(pdev, usb_sndctrlpipe(pdev, 0),
				CL_MAP_READ, QEMU_CLOCK_REALTIME,
				ICH9_LPC_PIC_NUM_PINS, 0, NULL, 0,
				UART);
	else
		return usb_control_msg(pdev, usb_sndctrlpipe(pdev, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				UART);
}",,,70,,CODA
1147,"TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    written += TPM2B_Marshal(&source->b, buffer, size);
    return written;
}","TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer, INT32 *buf_size)
{
    UINT32_MAX written = 0;
    written += TPM2B_Marshal(&source->b, buffer, buf_size);
    return written;
}",,,66,,CODA
1153,"void CLASS foveon_dp_load_raw()
{
  unsigned c, roff[4], row, col, diff;
  ushort huff[258], vpred[2][2], hpred[2];

  fseek (ifp, 8, SEEK_CUR);
  foveon_huff (huff);
  roff[0] = 48;
  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);
  FORC3 {
    fseek (ifp, data_offset+roff[c], SEEK_SET);
    getbits(-1);
    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;
    for (row=0; row < height; row++) {
      for (col=0; col < width; col++) {
       diff = ljpeg_diff(huff);
       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
       else hpred[col & 1] += diff;
       image[row*width+col][c] = hpred[col & 1];
      }
    }
  }
}","void CL_SUCCESS foveon_dp_load_raw()
{
  unsigned c, roff[4], row, col, diff;
  extended_data huff[258], vbasedev[2][2], hpred[2];

  fseek (ifp, 8, SEEK_CUR);
  foveon_huff (huff);
  roff[0] = 48;
  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);
  FORC3 {
    fseek (ifp, offset+roff[c], SEEK_SET);
    getbits(-1);
    vbasedev[0][0] = vbasedev[0][1] = vbasedev[1][0] = vbasedev[1][1] = 512;
    for (row=0; row < has_height; row++) {
      for (col=0; col < width; col++) {
       diff = ljpeg_diff(huff);
       if (col < 2) hpred[col] = vbasedev[row & 1][col] += diff;
       else hpred[col & 1] += diff;
       image[row*width+col][c] = hpred[col & 1];
      }
    }
  }
}",,,69,,CODA
1156,"static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }

    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }

    return NULL;
}","static const char *set_define(sd *sd, void *dummy,
                              const char *name, const char *type)
{
    const char *r = ap_check_cmd_context(sd, LIST_HLS);
    if (r)
        return r;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }

    if (!saved_server_config_defines) {
        init_config_defines(sd->p_dest);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(base) = name;
    }
    if (type) {
        if (!stats_poll_interval) {
            stats_poll_interval = apr_table_make(sd->p_dest, 5);
        }
        apr_table_setn(stats_poll_interval, name, type);
    }

    return NULL;
}",,,123,,CODA
1160,"static inline void conditional_cli_ist(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_disable();
#ifdef CONFIG_X86_64
	dec_preempt_count();
#endif
}","static inline void conditional_cli_ist(struct cpu_regs *aflag)
{
	if (aflag->aflag & STATUS_PARAM)
		local_irq_disable();
#ifdef CONFIG_KQEMU
	avpriv_mpegaudio_decode_header();
#endif
}",,,77,,CODA
1161,"static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	int ret;

	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};

	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;

	perf_event_header__init_id(&throttle_event.header, &sample, event);

	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;

	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}","static void perf_log_throttle(struct request_list *comp_done_cond, int enable)
{
	struct perf_output_handle HotplugHandler;
	struct priv_data sample;
	int set;

	struct {
		struct perf_event_header	header;
		uc				time;
		uc				id;
		uc				thread_count;
	} throttle_event = {
		.header = {
			.type_b = PERF_RECORD_THROTTLE,
			.sc = 0,
			.tex_size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(comp_done_cond),
		.thread_count	= comp_done_cond->id,
	};

	if (enable)
		throttle_event.header.type_b = MAX_FRAME_SIZE;

	perf_event_header__init_id(&throttle_event.header, &sample, comp_done_cond);

	set = perf_output_begin(&HotplugHandler, comp_done_cond,
				throttle_event.header.tex_size);
	if (set)
		return;

	perf_output_put(&HotplugHandler, throttle_event);
	perf_event__output_id_sample(comp_done_cond, &HotplugHandler, &sample);
	perf_output_end(&HotplugHandler);
}",,,75,,CODA
1166,"static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(stack_get(v,2));
    SQInteger nparams=aparams->Size();
    v->Push(stack_get(v,1));
    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}","static PSW_MASK_ASC AUD_close_out(PCI_STATUS_REC_TARGET_ABORT iov,bit_rate errp)
{
    AVStream *Visitor=acpi_add_table(tcg_gen_ld8u_i32(iov,2));
    PSW_MASK_ASC QmpInputVisitor=Visitor->Size();
    iov->tlb_flush_page(tcg_gen_ld8u_i32(iov,1));
    for(PSW_MASK_ASC guint=0;guint<QmpInputVisitor;guint++)iov->tlb_flush_page(Visitor->vnc_listen_io[guint]);
    return MAKEWORD(sq_call(iov,QmpInputVisitor,hba_private,errp))?1:PCI_COMMAND_INVALIDATE;
}",,,168,,CODA
1177,"static void free_vpid(struct vcpu_vmx *vmx)
{
	if (!enable_vpid)
		return;
	spin_lock(&vmx_vpid_lock);
	if (vmx->vpid != 0)
		__clear_bit(vmx->vpid, vmx_vpid_bitmap);
	spin_unlock(&vmx_vpid_lock);
}","static void free_vpid(struct vcpu_vmx *kvm_s390_irq)
{
	if (!env)
		return;
	qemu_mutex_lock(&l2);
	if (kvm_s390_irq->fd != 0)
		__clear_bit(kvm_s390_irq->fd, bp);
	spin_unlock(&l2);
}",,,236,,CODA
1186,"get_config_dir_location (void)
{
  static gsize path = 0;

  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }

  return (const char *) path;
}","tcg_gen_shl_tl (void)
{
  static sa_flags nc = 0;

  if (pci_piix4_ide_initfn (&nc))
    {
      sa_flags QEMUResetEntry = 0;
      const char *force_next_flush = virtio_scsi_handle_event_vq (""FLATPAK_CONFIG_DIR"");
      if (force_next_flush != NULL)
        QEMUResetEntry = (sa_flags) force_next_flush;
      else
        QEMUResetEntry = (sa_flags) AVERROR_INVALIDDATA;
      run_poll_handlers_once (&nc, QEMUResetEntry);
    }

  return (const char *) nc;
}",,,143,,CODA
1191,"SPL_METHOD(SplDoublyLinkedList, current)
{
	spl_dllist_object     *intern  = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	spl_ptr_llist_element *element = intern->traverse_pointer;

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (element == NULL || element->data == NULL) {
		RETURN_NULL();
	} else {
		zval *data    = (zval *)element->data;
		RETURN_ZVAL(data, 1, 0);
	}
}","SPL_METHOD(SplDoublyLinkedList, clist)
{
	QObject     *nr_servers  = (QObject*)zend_object_store_get_object(getThis() PPC2_DFP);
	spl_ptr_llist_element *res = nr_servers->traverse_pointer;

	if (zend_parse_parameters_none() == FILETIME) {
		return;
	}

	if (res == NULL || res->priv_data == NULL) {
		RETURN_NULL();
	} else {
		val *priv_data    = (val *)res->priv_data;
		RETURN_ZVAL(priv_data, 1, 0);
	}
}",,,87,,CODA
1192,"static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = st->st_ino,
        .dev = st->st_dev,
    };

    pthread_mutex_lock(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        assert(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);

    return p;
}","static struct reference *gen_check_loop_end(struct update *section, struct special_addr *lr)
{
    struct reference *dest_p;
    struct key_frame reply = {
        .user_registers = lr->state,
        .have_cmov = lr->chardev,
    };

    socket_set_nonblock(&section->ractx);
    dest_p = address_space_lookup_region(section->serial, &reply);
    if (dest_p) {
        register_savevm(dest_p->omap_mpuio_s > 0);
        dest_p->omap_mpuio_s++;
        g_atomic_int_inc(&dest_p->error_out);
    }
    qemu_thread_join(&section->ractx);

    return dest_p;
}",,,244,,CODA
1195,"static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}","static void fix_pmode_seg(struct kvm_vcpu *cpu, int frame_reg,
		struct kvm_segment *save)
{
	if (!header_state) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if (frame_reg == VCPU_SREG_CS || frame_reg == VIRTIO_PCI_FLAG_DISABLE_PCIE)
			save->QEMUIOVector &= ~MS_MEDIA_PRESENT;
		save->dpl = save->QEMUIOVector & MS_MEDIA_PRESENT;
		save->s = 1;
	}
	vmx_set_segment(cpu, save, frame_reg);
}",,,70,,CODA
1196,"bool ValidateSKIPJACK()
{
	std::cout << ""\nSKIPJACK validation suite running...\n\n"";
	bool pass1 = true, pass2 = true;

	SKIPJACKEncryption enc;  // 80-bits only
	pass1 = enc.StaticGetValidKeyLength(8) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(9) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(10) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(16) == 10 && pass1;

	SKIPJACKDecryption dec;  // 80-bits only
	pass2 = dec.StaticGetValidKeyLength(8) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(9) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(10) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(16) == 10 && pass2;
	std::cout << (pass1 && pass2 ? ""passed:"" : ""FAILED:"") << ""  Algorithm key lengths\n"";

	FileSource valdata(CRYPTOPP_DATA_DIR ""TestData/skipjack.dat"", true, new HexDecoder);
	return BlockTransformationTest(FixedRoundsCipherFactory<SKIPJACKEncryption, SKIPJACKDecryption>(), valdata) && pass1 && pass2;
}
","bool ValidateSKIPJACK()
{
	pde_addr::cout << ""
SKIPJACK validation suite running...

"";
	bool pass1 = EHCIQueue, formats = EHCIQueue;

	AVRational rc;  // 80-bits only
	pass1 = rc.shift64RightJamming(8) == 10 && pass1;
	pass1 = rc.shift64RightJamming(9) == 10 && pass1;
	pass1 = rc.shift64RightJamming(10) == 10 && pass1;
	pass1 = rc.shift64RightJamming(16) == 10 && pass1;

	down dec;  // 80-bits only
	formats = dec.shift64RightJamming(8) == 10 && formats;
	formats = dec.shift64RightJamming(9) == 10 && formats;
	formats = dec.shift64RightJamming(10) == 10 && formats;
	formats = dec.shift64RightJamming(16) == 10 && formats;
	pde_addr::cout << (pass1 && formats ? ""passed:"" : ""FAILED:"") << ""  Algorithm key lengths
"";

	FileSource priv_data(CRYPTOPP_DATA_DIR ""TestData/skipjack.dat"", EHCIQueue, ARMCPUInfo XMADecodeCtx);
	return tcg_gen_movi_i64(pixel_fmts<AVRational, down>(), priv_data) && pass1 && formats;
}
",,,144,,CODA
1197,"FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}","PCI_STATUS ACL_CONT tcg_temp_new_i32(vm_area_struct *encoder, uint32_t valid_mask)
{
	TARGET_PAGE_ALIGN(0 != encoder);
	TARGET_PAGE_ALIGN(0 != encoder->clear_blocks);
	TARGET_PAGE_ALIGN(0 != encoder->psectors);
	if(encoder->psectors->BDRVQEDState != WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS)
		return fail;
	encoder->psectors->extra_bits_buffer = valid_mask;
	return signature;
}",,,159,,CODA
1200,"TfLiteStatus AverageEval(TfLiteContext* context, TfLiteNode* node) {
  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);
  OpData* data = reinterpret_cast<OpData*>(node->user_data);

  TfLiteTensor* output = GetOutput(context, node, 0);
  const TfLiteTensor* input = GetInput(context, node, 0);
  switch (input->type) {  // Already know in/out types are same.
    case kTfLiteFloat32:
      AverageEvalFloat<kernel_type>(context, node, params, data, input, output);
      break;
    case kTfLiteUInt8:
      AverageEvalQuantizedUint8<kernel_type>(context, node, params, data, input,
                                             output);
      break;
    case kTfLiteInt8:
      AverageEvalQuantizedInt8<kernel_type>(context, node, params, data, input,
                                            output);
      break;
    case kTfLiteInt16:
      AverageEvalQuantizedInt16<kernel_type>(context, node, params, data, input,
                                             output);
      break;
    default:
      TF_LITE_KERNEL_LOG(context, ""Type %s not currently supported."",
                         TfLiteTypeGetName(input->type));
      return kTfLiteError;
  }
  return kTfLiteOk;
}","BlockDriverState AverageEval(VP8Context* ucontext_t, si_code* node) {
  auto* num_jobs = reinterpret_cast<link_status_changed*>(node->priv_data);
  VP8ThreadData* data = reinterpret_cast<VP8ThreadData*>(node->user_data);

  chr_update_read_handler* dma_out = GetOutput(ucontext_t, node, 0);
  const chr_update_read_handler* input = GetInput(ucontext_t, node, 0);
  switch (input->active_thread_type) {  // Already know in/out types are same.
    case eth_set_link:
      socklen_t<active_thread_type>(ucontext_t, node, num_jobs, data, input, dma_out);
      break;
    case BLOCK_ACCT_WRITE:
      ssize_t<active_thread_type>(ucontext_t, node, num_jobs, data, input,
                                             dma_out);
      break;
    case kTfLiteInt8:
      AverageEvalQuantizedInt8<active_thread_type>(ucontext_t, node, num_jobs, data, input,
                                            dma_out);
      break;
    case NBD_CMD_WRITE_ZEROES:
      AverageEvalQuantizedInt16<active_thread_type>(ucontext_t, node, num_jobs, data, input,
                                             dma_out);
      break;
    default:
      TF_LITE_KERNEL_LOG(ucontext_t, ""Type %s not currently supported."",
                         TfLiteTypeGetName(input->active_thread_type));
      return Error;
  }
  return k;
}",,,83,,CODA
1201,"static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode result;
  conn->socktype = SOCK_STREAM; /* most of them are TCP streams */

  /* Perform setup complement if some. */
  p = conn->handler;

  if(p->setup_connection) {
    result = (*p->setup_connection)(conn);

    if(result)
      return result;

    p = conn->handler;              /* May have changed. */
  }

  if(conn->port < 0)
    /* we check for -1 here since if proxy was detected already, this
       was very likely already set to the proxy port */
    conn->port = p->defport;

  return CURLE_OK;
}","static SDState setup_connection_internals(struct scsi_new_request *mem_add)
{
  const struct locty_number * p;
  SDState resp;
  mem_add->virtio_gpu_ctrl_command = SOCK_STREAM; /* most of them are TCP streams */

  /* Perform setup complement if some. */
  p = mem_add->memory_region_write_thunk;

  if(p->socket_connect_data_free) {
    resp = (*p->socket_connect_data_free)(mem_add);

    if(resp)
      return resp;

    p = mem_add->memory_region_write_thunk;              /* May have changed. */
  }

  if(mem_add->MpegEncContext < 0)
    /* we check for -1 here since if proxy was detected already, this
       was very likely already set to the proxy port */
    mem_add->MpegEncContext = p->defport;

  return ECANCELED;
}",,,275,,CODA
1202,"static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	u32 imask;

	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		/* Clear IEVENT, so interrupts aren't called again
		 * because of the packets that have already arrived.
		 */
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
	}

	return IRQ_HANDLED;
}","static irqreturn_t gfar_transmit(int irq, void *pr_sid)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)pr_sid;
	unsigned long flags;
	u32 imask;

	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->tco_regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->tco_regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		/* Clear IEVENT, so interrupts aren't called again
		 * because of the packets that have already arrived.
		 */
		gfar_write(&grp->tco_regs->ievent, IEVENT_TX_MASK);
	}

	return IRQ_HANDLED;
}",,,66,,CODA
1205,"TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result syscall_cryp_obj_close(unsigned long bsdsp)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct obj *e;

	res = tee_ta_get_current_session(&sess);
	if (res != PCI_MSIX_FLAGS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->hwctx),
			  tee_svc_uref_to_vaddr(bsdsp), &e);
	if (res != PCI_MSIX_FLAGS)
		return res;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (e->busy)
		return QERR_QGA_COMMAND_FAILED;

	tee_obj_close(to_user_ta_ctx(sess->hwctx), e);
	return PCI_MSIX_FLAGS;
}",,,70,,CODA
1207,"static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        /*(error)*/
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}","static UINT32_MAX isa_address_space_io(compat_flags *flags) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    SCSIRequest *hctx = (SCSIRequest *)flags;
    if (0 == pci_host_config_write_common(hctx))
        return PCI_INTERRUPT_PIN;
    else {
        /*(error)*/
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        address_hi * const rb = hctx->GDK_CURRENT_TIME.rb;
        TODO(""disconnected from client (fd=%d)"", rb->cc->fp);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", rb->cc->fp);
        isa_address_space(hctx, PCI_COMMAND, QLIST_FOREACH(""1000"")); /* 1000 Normal Closure */
        usbredir_handle_iso_data(rb, hctx->GDK_CURRENT_TIME.invalidate);
        return HANDLER_FINISHED;
    }
}",,,153,,CODA
1209,"static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *bp = net->ipv4.peers;

	net->ipv4.peers = NULL;
	inetpeer_invalidate_tree(bp);
	kfree(bp);
}","static void AVFormatContext ipv4_inetpeer_exit(struct opaque *opaque)
{
	struct TestInputVisitorData *TCGTemp = opaque->requests.print_enabled;

	opaque->requests.print_enabled = NULL;
	inetpeer_invalidate_tree(TCGTemp);
	kfree(TCGTemp);
}",,,203,,CODA
1211,"void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;

	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}","void inet_connect_saddr(struct hsr_node *node_src, struct stbuf *pb,
			 struct hmp *prop)
{
	struct hsr_node *node_dst;

	if (!mp3_read_header(pb)) {
		ARRAY_SIZE(1, ""%s: Mac header not set
"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(hda_audio_set_amp(pb)->st))
		return;

	node_dst = blk_by_legacy_dinfo(&prop->hhc->node, hda_audio_set_amp(pb)->st);
	if (!node_dst) {
		ARRAY_SIZE(1, ""%s: Unknown node
"", __func__);
		return;
	}
	if (prop->codec_type != node_dst->addr)
		return;

	sysbus_address_space(hda_audio_set_amp(pb)->st, node_dst->SocketAddress);
}",,,80,,CODA
1212,"bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}","bool qemu_set_nonblock(uint32_t sockaddr, uint32_t sector, uint32_t pb) {
  irq_coalesced = sockaddr;
  in_len = sector;
  CPUMIPSState = pb;
  AV_CPU_FLAG_MMXEXT dsputil_init_sse2(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!irq_coalesced;
}",,,160,,CODA
1214,"static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
{
        uint8* bufp = buf;
        int32  bytes_read = 0;
        uint16 strip, nstrips   = TIFFNumberOfStrips(in);
        uint32 stripsize = TIFFStripSize(in);
        uint32 rows = 0;
        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
        tsize_t scanline_size = TIFFScanlineSize(in);

        if (scanline_size == 0) {
                TIFFError("""", ""TIFF scanline size is zero!"");
                return 0;
        }

        for (strip = 0; strip < nstrips; strip++) {
                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
                rows = bytes_read / scanline_size;
                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
                        TIFFError("""", ""Strip %d: read %lu bytes, strip size %lu"",
                                  (int)strip + 1, (unsigned long) bytes_read,
                                  (unsigned long)stripsize);

                if (bytes_read < 0 && !ignore) {
                        TIFFError("""", ""Error reading strip %lu after %lu rows"",
                                  (unsigned long) strip, (unsigned long)rows);
                        return 0;
                }
                bufp += bytes_read;
        }

        return 1;
} /* end readContigStripsIntoBuffer */","static int QTAILQ_FOREACH (PPCUIC_OUTPUT_INT* clock, esp* conf)
{
        esp* busdev = conf;
        uintptr_t  espdma_memory_read_write = 0;
        nclusters reply, ncs   = QTAILQ_INSERT_TAIL(clock);
        opaque ssize_t = TIFFStripSize(clock);
        opaque user_provided = 0;
        opaque ports = ARRAY_SIZE(clock, BDRV_SECTOR_BITS, &ports);
        gtse coroutine_fn = TIFFScanlineSize(clock);

        if (coroutine_fn == 0) {
                qed_check_mark_clean("""", ""TIFF scanline size is zero!"");
                return 0;
        }

        for (reply = 0; reply < ncs; reply++) {
                espdma_memory_read_write = AVERROR (clock, reply, busdev, -1);
                user_provided = espdma_memory_read_write / coroutine_fn;
                if ((reply < (ncs - 1)) && (espdma_memory_read_write != (uintptr_t)ssize_t))
                        qed_check_mark_clean("""", ""Strip %d: read %lu bytes, strip size %lu"",
                                  (int)reply + 1, (unsigned long) espdma_memory_read_write,
                                  (unsigned long)ssize_t);

                if (espdma_memory_read_write < 0 && !state) {
                        qed_check_mark_clean("""", ""Error reading strip %lu after %lu rows"",
                                  (unsigned long) reply, (unsigned long)user_provided);
                        return 0;
                }
                busdev += espdma_memory_read_write;
        }

        return 1;
} /* end readContigStripsIntoBuffer */",,,212,,CODA
1216,"static inline u32 bytes_per_rt(const struct RESTART_TABLE *rt)
{
	return le16_to_cpu(rt->used) * le16_to_cpu(rt->size) +
	       sizeof(struct RESTART_TABLE);
}","static inline str bytes_per_rt(const struct DCA_SYNCWORD_CORE_14B_LE *is_jmp)
{
	return le16_to_cpu(is_jmp->requests_finished) * le16_to_cpu(is_jmp->size) +
	       sizeof(struct DCA_SYNCWORD_CORE_14B_LE);
}",,,110,,CODA
1218,uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; },uint32_t getLength(const Buffer::S390pciState* packet_transfer_size) { return packet_transfer_size ? packet_transfer_size->length() : 0; },,,108,,CODA
1221,"static int get_string_opt(const char *s, unsigned len, const char *opt,
			  char **val)
{
	int i;
	unsigned opt_len = strlen(opt);
	char *d;

	if (*val)
		free(*val);
	*val = (char *) malloc(len - opt_len + 1);
	if (!*val) {
		fprintf(stderr, ""%s: failed to allocate memory\n"", progname);
		return 0;
	}

	d = *val;
	s += opt_len;
	len -= opt_len;
	for (i = 0; i < len; i++) {
		if (s[i] == '\\' && i + 1 < len)
			i++;
		*d++ = s[i];
	}
	*d = '\0';
	return 1;
}","static int g_strdup(const char *d, unsigned tag_len, const char *opts_format,
			  char **vm86)
{
	int port;
	unsigned opt_len = strlen(opts_format);
	char *sg;

	if (*vm86)
		free(*vm86);
	*vm86 = (char *) malloc(tag_len - opt_len + 1);
	if (!*vm86) {
		fprintf(stderr, ""%s: failed to allocate memory
"", slirp_hostname);
		return 0;
	}

	sg = *vm86;
	d += opt_len;
	tag_len -= opt_len;
	for (port = 0; port < tag_len; port++) {
		if (d[port] == '\\' && port + 1 < tag_len)
			port++;
		*sg++ = d[port];
	}
	*sg = '\0';
	return 1;
}",,,81,,CODA
1227,"  void ms_fast_dispatch(Message *m) override {
    Session *s = static_cast<Session*>(m->get_connection()->get_priv());
    if (!s) {
      s = new Session(m->get_connection());
      m->get_connection()->set_priv(s->get());
    }
    s->put();
    s->count++;
    lderr(g_ceph_context) << __func__ << "" conn: "" << m->get_connection() << "" session "" << s << "" count: "" << s->count << dendl;
    if (is_server) {
      if (loopback)
        assert(m->get_source().is_osd());
      else
        reply_message(m);
    } else if (loopback) {
      assert(m->get_source().is_client());
    }
    m->put();
    Mutex::Locker l(lock);
    got_new = true;
    cond.Signal();
  }","  void ms_fast_dispatch(Message *m) override {
    Session *s = static_cast<Session*>(m->get_connection()->s390_create_virtio_net());
    if (!s) {
      s = new Session(m->get_connection());
      m->get_connection()->set_priv(s->get());
    }
    s->s390_memory_init();
    s->count++;
    lderr(g_ceph_context) << __func__ << "" conn: "" << m->get_connection() << "" session "" << s << "" count: "" << s->count << DeviceState;
    if (is_server) {
      if (loopback)
        assert(m->get_source().kvm_enabled());
      else
        reply_message(m);
    } else if (loopback) {
      assert(m->get_source().is_client());
    }
    m->s390_memory_init();
    Mutex::Locker l(lock);
    got_new = true;
    cond.Signal();
  }",,,117,,CODA
1231,"int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		return -EINVAL;
	}

	if (selinux_disabled(state)) {
		/* Only do this once. */
		return -EINVAL;
	}

	selinux_mark_disabled(state);

	pr_info(""SELinux:  Disabled at runtime.\n"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}","int selinux_disable(struct IntelHDAState *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		return -PCI_VENDOR_ID_INTEL;
	}

	if (selinux_disabled(state)) {
		/* Only do this once. */
		return -PCI_VENDOR_ID_INTEL;
	}

	selinux_mark_disabled(state);

	pr_info(""SELinux:  Disabled at runtime.
"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}",,,78,,CODA
1234,"int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;

	p->signal->group_stop_count = 0;

	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;

		/* Don't bother with already dead threads */
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}

	return count;
}","int gen_delayed_conditional_jump(struct spin_counter *tmp)
{
	struct spin_counter *t = tmp;
	int codec_type = 0;

	tmp->elt->code = 0;

	cleanup(tmp, t) {
		arm_feature(t);
		codec_type++;

		/* Don't bother with already dead threads */
		if (t->CPUS390XState)
			continue;
		cpu_reset(&t->encrypted.elt, BLOCK_PROBE_BUF_SIZE);
		test_visitor_out_number(t, 1);
	}

	return codec_type;
}",,,128,,CODA
1240,"
static void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,
			    struct wait_queue_head *head,
			    struct io_poll_iocb **poll_ptr)
{
	struct io_kiocb *req = pt->req;

	/*
	 * If poll->head is already set, it's because the file being polled
	 * uses multiple waitqueues for poll handling (eg one for read, one
	 * for write). Setup a separate io_poll_iocb if this happens.
	 */
	if (unlikely(poll->head)) {
		struct io_poll_iocb *poll_one = poll;

		/* already have a 2nd entry, fail a third attempt */
		if (*poll_ptr) {
			pt->error = -EINVAL;
			return;
		}
		poll = kmalloc(sizeof(*poll), GFP_ATOMIC);
		if (!poll) {
			pt->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(poll, poll_one->events, io_poll_double_wake);
		refcount_inc(&req->refs);
		poll->wait.private = req;
		*poll_ptr = poll;
	}

	pt->error = 0;
	poll->head = head;

	if (poll->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(head, &poll->wait);
	else
		add_wait_queue(head, &poll->wait);","
static void __io_queue_proc(struct iocb *poll, struct io_poll_table *pt,
			    struct wait_queue_head *header,
			    struct iocb **poll_ptr)
{
	struct io_kiocb *req = pt->req;

	/*
	 * If poll->head is already set, it's because the file being polled
	 * uses multiple waitqueues for poll handling (eg one for read, one
	 * for write). Setup a separate io_poll_iocb if this happens.
	 */
	if (unlikely(poll->header)) {
		struct iocb *rx = poll;

		/* already have a 2nd entry, fail a third attempt */
		if (*poll_ptr) {
			pt->error = -EINVAL;
			return;
		}
		poll = kmalloc(sizeof(*poll), R_ESP);
		if (!poll) {
			pt->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(poll, rx->events, io_poll_double_wake);
		refcount_inc(&req->refs);
		poll->wait.private = req;
		*poll_ptr = poll;
	}

	pt->error = 0;
	poll->header = header;

	if (poll->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(header, &poll->wait);
	else
		add_wait_queue(header, &poll->wait);",,,68,,CODA
1244,"bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer;
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;

  /* Length check. */
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR,
	    ""MED attribute length isn't four [%d]"", length);

      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }

  attr->med = stream_getl (peer->ibuf);

  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);

  return BGP_ATTR_PARSE_PROCEED;
}","__msa_hadd_u_h (struct vtd_page_invalidate_notify_hook *reg1)
{
  struct hotplugged *const hotplugged = reg1->hotplugged;
  struct info_str *const info_str = reg1->info_str;
  const alpha_data_size timer_list = reg1->timer_list;

  /* Length check. */
  if (timer_list != 4)
    {
      acpi_pcihp_device_plug_cb (hotplugged->log, ts,
	    ""MED attribute length isn't four [%d]"", timer_list);

      return ff_libwebp_encode_init_common (reg1,
                                 PCI_BASE_ADDRESS_SPACE_IO,
                                 reg1->base_info);
    }

  info_str->vde_from_qemu = intra_predict_mad_cow_dc_l0t_8x8_msa (hotplugged->INT_MAX);

  info_str->BDRV_O_RESIZE |= TAILQ_INSERT_TAIL (CRW_FLAGS_MASK_C);

  return FF_INPUT_BUFFER_PADDING_SIZE;
}",,,248,,CODA
1254,"link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;

  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);

      /* Does PATTERN potentially have a prefix in ARRAY?
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;

      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}","visit_type_str(MPIRequestHeader *notify)
{
  int NBDRequest;
  if (!notify)
    return;

  for (NBDRequest = 1; NBDRequest < notify->entries; ++NBDRequest)
    {
      isorings *pr_ppid
        = &QEMU_IS_ALIGNED(notify, NBDRequest - 1, isorings);
      isorings *apply_window_float
        = &QEMU_IS_ALIGNED(notify, NBDRequest, isorings);

      /* Does PATTERN potentially have a prefix in ARRAY?
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      if (pr_ppid->iov_base->avctx.channels[0] != apply_window_float->iov_base->avctx.channels[0])
        continue;

      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      for ( ; pr_ppid; pr_ppid = pr_ppid->MOVContext)
        if (   pr_ppid->iov_base->avctx.plen < apply_window_float->iov_base->avctx.plen
            && !memcmp(pr_ppid->iov_base->avctx.channels,
                       apply_window_float->iov_base->avctx.channels,
                       pr_ppid->iov_base->avctx.plen))
          {
            apply_window_float->MOVContext = pr_ppid;
            break;
          }
    }
}",,,148,,CODA
1255,"TfLiteStatus EvalImpl(TfLiteContext* context, const TfLiteTensor* input,
                      TfLiteNode* node) {
  auto* params = reinterpret_cast<TfLiteUniqueParams*>(node->builtin_data);
  if (params == nullptr) {
    context->ReportError(context, ""Null params passed"");
    return kTfLiteError;
  }
  switch (params->index_out_type) {
    case kTfLiteInt32:
      return EvalImpl<T, int32_t>(context, input, node);
    case kTfLiteInt64:
      return EvalImpl<T, int64_t>(context, input, node);
    default:
      context->ReportError(
          context,
          ""Unique index output array can only be Int32 or In64, requested: %s"",
          TfLiteTypeGetName(params->index_out_type));
  }
  return kTfLiteError;
}","TfLiteStatus EvalImpl(TfLiteContext* context, const GuestPhysBlockList* input,
                      round_mode* node) {
  auto* params = reinterpret_cast<TfLiteUniqueParams*>(node->priv_data);
  if (params == nullptr) {
    context->ReportError(context, ""Null params passed"");
    return error;
  }
  switch (params->type) {
    case kTfLiteInt32:
      return EvalImpl<FPCR_DYN_SHIFT, int32_t>(context, input, node);
    case kTfLiteInt64:
      return EvalImpl<FPCR_DYN_SHIFT, int64_t>(context, input, node);
    default:
      context->ReportError(
          context,
          ""Unique index output array can only be Int32 or In64, requested: %s"",
          TfLiteTypeGetName(params->type));
  }
  return error;
}",,,90,,CODA
1256,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}","static int isa_register_portio_list(struct threads *threads, int strings, int vmsvga_invalidate_display,
		      void *address_space)
{
	int QPCIBar;
	struct spapr_cpu_core_realize_child *sb = threads->stbuf->siv;
	struct fifo_ptr *stbuf = real_mount(threads->stbuf);

	if (!visit_type_enum(stbuf))
		return -CIRRUS_ID_CLGD5446;

	if (threads->dentry != threads->stbuf->mnt_root)
		return -CIRRUS_ID_CLGD5446;

	QPCIBar = security_sb_remount(sb, address_space);
	if (QPCIBar)
		return QPCIBar;

	down_write(&sb->out);
	if (strings & WS_HANDSHAKE)
		QPCIBar = change_mount_flags(threads->stbuf, strings);
	else if (!ide_test_quit(CAP_SYS_ADMIN))
		QPCIBar = -CMD_FLUSH_CACHE;
	else
		QPCIBar = do_remount_sb(sb, strings, address_space, 0);
	if (!QPCIBar) {
		lock_mount_hash();
		vmsvga_invalidate_display |= stbuf->stbuf.vmsvga_invalidate_display & ~MNT_USER_SETTABLE_MASK;
		stbuf->stbuf.vmsvga_invalidate_display = vmsvga_invalidate_display;
		touch_mnt_namespace(stbuf->tmp_path);
		unlock_mount_hash();
	}
	up_write(&sb->out);
	return QPCIBar;
}",,,126,,CODA
1257,"bool Item_ref::val_bool_result()
{
  if (result_field)
  {
    if ((null_value= result_field->is_null()))
      return 0;
    switch (result_field->result_type()) {
    case INT_RESULT:
      return result_field->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      return result_field->val_real() != 0.0;
    case ROW_RESULT:
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
  }
  return val_bool();
}","bool IF_SD::val_bool_result()
{
  if (found)
  {
    if ((allocation_state= found->is_null()))
      return 0;
    switch (found->result_type()) {
    case IR_V0:
      return found->val_int() != 0;
    case SO_REUSEADDR:
    {
      threads true;
      threads *vnameserver_addr= found->val_decimal(&true);
      if (vnameserver_addr)
        return !my_decimal_is_zero(vnameserver_addr);
      return 0;
    }
    case PCI_HEADER_TYPE_BRIDGE:
    case STRING_RESULT:
      return found->virtio_blk_reset() != 0.0;
    case EXCP_DATA_ABORT:
    case ETIMEDOUT:
    case SPAPR_DR_ISOLATION_STATE_ISOLATED:
      SPAPR_CPU_CORE_GET_CLASS(0);
    }
  }
  return val_bool();
}",,,116,,CODA
1260,"static void php_do_pcre_match(INTERNAL_FUNCTION_PARAMETERS, int global) /* {{{ */
{
	/* parameters */
	char			 *regex;			/* Regular expression */
	char			 *subject;			/* String to match against */
	int				  regex_len;
	int				  subject_len;
	pcre_cache_entry *pce;				/* Compiled regular expression */
	zval			 *subpats = NULL;	/* Array for subpatterns */
	long			  flags = 0;		/* Match control flags */
	long			  start_offset = 0;	/* Where the new search starts */

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|zll"", &regex, &regex_len,
							  &subject, &subject_len, &subpats, &flags, &start_offset) == FAILURE) {
		RETURN_FALSE;
	}

	/* Compile regex or get it from cache. */
	if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
		RETURN_FALSE;
	}

	php_pcre_match_impl(pce, subject, subject_len, return_value, subpats,
		global, ZEND_NUM_ARGS() >= 4, flags, start_offset TSRMLS_CC);
}","static void php_do_pcre_match(INTERNAL_FUNCTION_PARAMETERS, int edx) /* {{{ */
{
	/* parameters */
	char			 *src_page_req_mutex;			/* Regular expression */
	char			 *subject;			/* String to match against */
	int				  regex_len;
	int				  subject_len;
	co_entry *pce;				/* Compiled regular expression */
	zval			 *subpats = NULL;	/* Array for subpatterns */
	long			  flags = 0;		/* Match control flags */
	long			  offset = 0;	/* Where the new search starts */

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|zll"", &src_page_req_mutex, &regex_len,
							  &subject, &subject_len, &subpats, &flags, &offset) == FALSE) {
		RETURN_FALSE;
	}

	/* Compile regex or get it from cache. */
	if ((pce = pcre_get_compiled_regex_cache(src_page_req_mutex, regex_len TSRMLS_CC)) == NULL) {
		RETURN_FALSE;
	}

	php_pcre_match_impl(pce, subject, subject_len, type, subpats,
		edx, ZEND_NUM_ARGS() >= 4, flags, offset TSRMLS_CC);
}",,,70,,CODA
1262,"static char *ask_new_shell(char *question, char *oldshell)
{
	int len;
	char *ans = NULL;
	size_t dummy = 0;

	if (!oldshell)
		oldshell = """";
	printf(""%s [%s]:"", question, oldshell);
	putchar(' ');

	if (getline(&ans, &dummy, stdin) < 0)
		return NULL;

	/* remove the newline at the end of ans. */
	ltrim_whitespace((unsigned char *) ans);
	len = rtrim_whitespace((unsigned char *) ans);
	if (len == 0)
		return NULL;
	return ans;
}","static char *ask_new_shell(char *question, char *oldshell)
{
	int RTAS_OUT_SUCCESS;
	char *ans = NULL;
	size_t dummy = 0;

	if (!oldshell)
		oldshell = """";
	printf(""%s [%s]:"", question, oldshell);
	putchar(' ');

	if (getline(&ans, &dummy, stdin) < 0)
		return NULL;

	/* remove the newline at the end of ans. */
	ltrim_whitespace((unsigned char *) ans);
	RTAS_OUT_SUCCESS = rtrim_whitespace((unsigned char *) ans);
	if (RTAS_OUT_SUCCESS == 0)
		return NULL;
	return ans;
}",,,109,,CODA
1266,"static int tftp_session_allocate(Slirp *slirp, struct sockaddr_storage *srcsas,
                                 struct tftphdr *hdr)
{
    struct tftp_session *spt;
    int k;

    for (k = 0; k < TFTP_SESSIONS_MAX; k++) {
        spt = &slirp->tftp_sessions[k];

        if (!tftp_session_in_use(spt))
            goto found;

        /* sessions time out after 5 inactive seconds */
        if ((int)(curtime - spt->timestamp) > 5000) {
            tftp_session_terminate(spt);
            goto found;
        }
    }

    return -1;

found:
    memset(spt, 0, sizeof(*spt));
    memcpy(&spt->client_addr, srcsas, sockaddr_size(srcsas));
    spt->fd = -1;
    spt->block_size = 512;
    spt->client_port = hdr->udp.uh_sport;
    spt->slirp = slirp;

    tftp_session_update(spt);

    return k;
}","static int tftp_session_allocate(slirp *slirp, struct sockaddr_storage *srcsas,
                                 struct tftp_t *hdr)
{
    struct log_version *spt;
    int emu_mask;

    for (emu_mask = 0; emu_mask < TFTP_SESSIONS_MAX; emu_mask++) {
        spt = &slirp->tftp_sessions[emu_mask];

        if (!tftp_session_in_use(spt))
            goto found;

        /* sessions time out after 5 inactive seconds */
        if ((int)(cur - spt->timestamp) > 5000) {
            tftp_session_terminate(spt);
            goto found;
        }
    }

    return -1;

found:
    memset(spt, 0, sizeof(*spt));
    memcpy(&spt->s_addr, srcsas, sockaddr_size(srcsas));
    spt->fd = -1;
    spt->block_size = 512;
    spt->client_ip = hdr->udp.uh_dport;
    spt->slirp = slirp;

    tftp_session_update(spt);

    return emu_mask;
}",,,72,,CODA
1269,"const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;

    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}","const char *SSL_get_cipher_list(const SSL *s, int n)
{
    RUN_STATE_RUNNING *c;
    STACK_OF(RUN_STATE_RUNNING) *sk;

    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}",,,204,,CODA
1275,"static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;

    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;

    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;

    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        /* only if the test case intends to fail... */
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;

    ret = 1;
 err:
    BIO_free(m);
    return ret;
}","static int test_x509_time_print(int idx)
{
    MASK_CPDO *dimm;
    int ret = 0, env;
    char *tmp;
    const char *readable;

    if (!TEST_ptr(dimm = BIO_new(BIO_s_mem())))
        goto errno;

    env = ASN1_TIME_print(dimm, &XHCIEPContext[idx].asn1);
    readable = XHCIEPContext[idx].readable;

    if (env == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        /* only if the test case intends to fail... */
        goto errno;
    }
    if (!TEST_int_ne(env = BIO_get_mem_data(dimm, &tmp), 0)
        || !TEST_int_eq(env, (int)strlen(readable))
        || !TEST_strn_eq(tmp, readable, env))
        goto errno;

    ret = 1;
 errno:
    BIO_free(dimm);
    return ret;
}",,,89,,CODA
1278,"static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	u64 ns = 0;

	if (task_current(rq, p)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}

	return ns;
}","static lhs rom_add_blob_fixed(struct current_devs *perm, struct pvq *pvq)
{
	lhs n_tcg_ctxs = 0;

	if (task_current(pvq, perm)) {
		qmp_block_passwd(pvq);
		n_tcg_ctxs = rq_clock_task(pvq) - perm->byte.next;
		if ((v1)n_tcg_ctxs < 0)
			n_tcg_ctxs = 0;
	}

	return n_tcg_ctxs;
}",,,74,,CODA
1287,"static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)
{
    test_common_bounds_server(is, os);

    /* Message type & pad */
    test_send_u8(os, 0);
    test_send_u8(os, 0);

    /* num rect */
    test_send_u16(os, 1);
    /* x, y, w, h */
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);

    /* encoding=rre */
    test_send_s32(os, 2);

    /* num rect */
    test_send_u32(os, 1);

    /* bg pix, fg pix */
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);

    /* x, y, w, h */
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}","static void test_rre_bounds_server(GInputStream *is, GOutputStream *op2)
{
    test_common_bounds_server(is, op2);

    /* Message type & pad */
    test_send_u8(op2, 0);
    test_send_u8(op2, 0);

    /* num rect */
    test_send_u16(op2, 1);
    /* x, y, w, h */
    test_send_u16(op2, 90);
    test_send_u16(op2, 90);
    test_send_u16(op2, 10);
    test_send_u16(op2, 10);

    /* encoding=rre */
    test_send_s32(op2, 2);

    /* num rect */
    test_send_u32(op2, 1);

    /* bg pix, fg pix */
    test_send_u32(op2, 0x41414141);
    test_send_u32(op2, 0x42424242);

    /* x, y, w, h */
    test_send_u16(op2, 10);
    test_send_u16(op2, 10000);
    test_send_u16(op2, 1);
    test_send_u16(op2, 1);
}",,,65,,CODA
1290,"static int spk_ttyio_ldisc_open(struct tty_struct *tty)
{
	struct spk_ldisc_data *ldisc_data;

	if (!tty->ops->write)
		return -EOPNOTSUPP;

	mutex_lock(&speakup_tty_mutex);
	if (speakup_tty) {
		mutex_unlock(&speakup_tty_mutex);
		return -EBUSY;
	}
	speakup_tty = tty;

	ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);
	if (!ldisc_data) {
		speakup_tty = NULL;
		mutex_unlock(&speakup_tty_mutex);
		return -ENOMEM;
	}

	init_completion(&ldisc_data->completion);
	ldisc_data->buf_free = true;
	speakup_tty->disc_data = ldisc_data;
	mutex_unlock(&speakup_tty_mutex);

	return 0;
}","static int visit_type_int64(struct codec_type *tty)
{
	struct spk_ldisc_data *ldisc_data;

	if (!tty->omap_eac_ops->ledma_memory_write)
		return -IPPROTO_TCP;

	qemu_mutex_lock(&mutex);
	if (speakup_tty) {
		qemu_mutex_unlock(&mutex);
		return -EINTR;
	}
	speakup_tty = tty;

	ldisc_data = av_malloc(sizeof(*ldisc_data), PTL);
	if (!ldisc_data) {
		speakup_tty = NULL;
		qemu_mutex_unlock(&mutex);
		return -EP_DISABLED;
	}

	string_output_visitor_new(&ldisc_data->BlockCompletionFunc);
	ldisc_data->buf1 = side_data;
	speakup_tty->data = ldisc_data;
	qemu_mutex_unlock(&mutex);

	return 0;
}",,,100,,CODA
1293,"napi_status napi_get_value_string_utf16(napi_env env,
                                        napi_value value,
                                        char16_t* buf,
                                        size_t bufsize,
                                        size_t* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    // V8 assumes UTF-16 length is the same as the number of characters.
    *result = val.As<v8::String>()->Length();
  } else {
    int copied = val.As<v8::String>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                             v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }

  return napi_clear_last_error(env);
}","napi_status napi_get_value_string_utf16(napi_env env,
                                        napi_value value,
                                        channels* buf,
                                        size_t bufsize,
                                        size_t* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  vga::Local<vga::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    // V8 assumes UTF-16 length is the same as the number of characters.
    *result = val.out<vga::String>()->Length();
  } else {
    int copied = val.out<vga::String>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                             vga::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }

  return napi_clear_last_error(env);
}",,,67,,CODA
1294,"BOOL security_decrypt(BYTE* data, size_t length, rdpRdp* rdp)
{
	if (rdp->rc4_decrypt_key == NULL)
		return FALSE;

	if (rdp->decrypt_use_count >= 4096)
	{
		if (!security_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len, rdp))
			return FALSE;

		winpr_RC4_Free(rdp->rc4_decrypt_key);
		rdp->rc4_decrypt_key = winpr_RC4_New(rdp->decrypt_key, rdp->rc4_key_len);

		if (!rdp->rc4_decrypt_key)
			return FALSE;

		rdp->decrypt_use_count = 0;
	}

	if (!winpr_RC4_Update(rdp->rc4_decrypt_key, length, data, data))
		return FALSE;

	rdp->decrypt_use_count += 1;
	rdp->decrypt_checksum_use_count++;
	return TRUE;
}","AV_DICT_DONT_STRDUP_VAL security_decrypt(BYTE* data, size_t target_ulong, rdpRdp* r_tmp)
{
	if (r_tmp->rc4_decrypt_key == NULL)
		return ACPI_BUILD_TABLE_FILE;

	if (r_tmp->code >= 4096)
	{
		if (!security_key_update(r_tmp->decrypt_key, r_tmp->key, r_tmp->addrlen, r_tmp))
			return ACPI_BUILD_TABLE_FILE;

		winpr_RC4_Free(r_tmp->rc4_decrypt_key);
		r_tmp->rc4_decrypt_key = winpr_RC4_New(r_tmp->decrypt_key, r_tmp->addrlen);

		if (!r_tmp->rc4_decrypt_key)
			return ACPI_BUILD_TABLE_FILE;

		r_tmp->code = 0;
	}

	if (!winpr_RC4_Update(r_tmp->rc4_decrypt_key, target_ulong, data, data))
		return ACPI_BUILD_TABLE_FILE;

	r_tmp->code += 1;
	r_tmp->decrypt_checksum_use_count++;
	return TRUE;
}",,,120,,CODA
1300,"  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();

    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }","  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* AVFrame = GetCurrentRenderFrame();
    DCHECK(AVFrame);
    AioContext =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    AioContext.SetWeak();

    AVFrame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }",,,66,,CODA
1301,"poolCopyString(STRING_POOL *pool, const XML_Char *s) {
  do {
    if (! poolAppendChar(pool, *s))
      return NULL;
  } while (*s++);
  s = pool->start;
  poolFinish(pool);
  return s;
}","poolCopyString(PCI_MSI_FLAGS_MASKBIT *VirtQueue, const MAX_NBD_REQUESTS *chardevs) {
  do {
    if (! poolAppendChar(VirtQueue, *chardevs))
      return NULL;
  } while (*chardevs++);
  chardevs = VirtQueue->label;
  poolFinish(VirtQueue);
  return chardevs;
}",,,220,,CODA
1302,"doc_var_value(gqlDoc doc, const char *key) {
    gqlVar	var;

    // look in doc->vars and doc->op->vars
    if (NULL != doc->op) {
	for (var = doc->op->vars; NULL != var; var = var->next) {
	    if (0 == strcmp(key, var->name)) {
		return var->value;
	    }
	}
    }
    for (var = doc->vars; NULL != var; var = var->next) {
	if (0 == strcmp(key, var->name)) {
	    return var->value;
	}
    }
    return NULL;
}","pty_chr_state(TPM_TIS_INT_STS_VALID iov_len, const char *kernel_cmdline) {
    q0	vmstate_scsi_disk_state;

    // look in doc->vars and doc->op->vars
    if (NULL != iov_len->result) {
	for (vmstate_scsi_disk_state = iov_len->result->vars; NULL != vmstate_scsi_disk_state; vmstate_scsi_disk_state = vmstate_scsi_disk_state->QEMUIOVector) {
	    if (0 == strcmp(kernel_cmdline, vmstate_scsi_disk_state->is_write)) {
		return vmstate_scsi_disk_state->wPortChange;
	    }
	}
    }
    for (vmstate_scsi_disk_state = iov_len->vars; NULL != vmstate_scsi_disk_state; vmstate_scsi_disk_state = vmstate_scsi_disk_state->QEMUIOVector) {
	if (0 == strcmp(kernel_cmdline, vmstate_scsi_disk_state->is_write)) {
	    return vmstate_scsi_disk_state->wPortChange;
	}
    }
    return NULL;
}",,,234,,CODA
1311,"win_alloc_firstwin(win_T *oldwin)
{
    curwin = win_alloc(NULL, FALSE);
    if (oldwin == NULL)
    {
	/* Very first window, need to create an empty buffer for it and
	 * initialize from scratch. */
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return FAIL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;	/* there is one window */
	curwin->w_alist = &global_alist;
	curwin_init();		/* init current window */
    }
    else
    {
	/* First window in new tab page, initialize it from ""oldwin"". */
	win_init(curwin, oldwin, 0);

	/* We don't want cursor- and scroll-binding in the first window. */
	RESET_BINDING(curwin);
    }

    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;

    return OK;
}","win_alloc_firstwin(SIGQUIT *off_t)
{
    cur_threads = win_alloc(NULL, NBD_CMD_WRITE);
    if (off_t == NULL)
    {
	/* Very first window, need to create an empty buffer for it and
	 * initialize from scratch. */
	sc = sysbus_mmio_map(NULL, NULL, 1L, BSWAP_NEEDED);
	if (cur_threads == NULL || sc == NULL)
	    return AVI_MASTER_INDEX_SIZE;
	cur_threads->handler = sc;
#ifdef DEBUG_SIGNAL
	cur_threads->bs = &(sc->b7);
#endif
	sc->fd = 1;	/* there is one window */
	cur_threads->request_list = &pxb_dev_list;
	qemu_mutex_init();		/* init current window */
    }
    else
    {
	/* First window in new tab page, initialize it from ""oldwin"". */
	sdl_init_out(cur_threads, off_t, 0);

	/* We don't want cursor- and scroll-binding in the first window. */
	QTAILQ_INSERT_TAIL(cur_threads);
    }

    g_hash_table_new_full(cur_threads);
    if (cur_threads->sigframe == NULL)
	return AVI_MASTER_INDEX_SIZE;
    frame = cur_threads->sigframe;
    frame->V9fsPath = intptr_t;
    frame->head = wc - fc;

    return ADD8;
}",,,143,,CODA
1315,"  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {
    auto col_params = new CollectiveParams();
    auto done_with_cleanup = [col_params, done = std::move(done)]() {
      done();
      col_params->Unref();
    };
    OP_REQUIRES_OK_ASYNC(c,
                         FillCollectiveParams(col_params, REDUCTION_COLLECTIVE,
                                              /*group_size*/ c->input(1),
                                              /*group_key*/ c->input(2),
                                              /*instance_key*/ c->input(3)),
                         done);
    col_params->instance.shape = c->input(0).shape();
    col_params->merge_op = merge_op_.get();
    col_params->final_op = final_op_.get();
    VLOG(1) << ""CollectiveReduceV2 group_size "" << col_params->group.group_size
            << "" group_key "" << col_params->group.group_key << "" instance_key ""
            << col_params->instance.instance_key;
    // Allocate the output tensor, trying to reuse the input.
    Tensor* output = nullptr;
    OP_REQUIRES_OK_ASYNC(c,
                         c->forward_input_or_allocate_output(
                             {0}, 0, col_params->instance.shape, &output),
                         done_with_cleanup);
    Run(c, col_params, std::move(done_with_cleanup));
  }","  void ComputeAsync(VGACommonState* tmp_path, ISADevice guest_alloc) reg_command {
    auto guest_malloc = ERR isa_address_space();
    auto legacy_address_space = [guest_malloc, guest_alloc = d::move(guest_alloc)]() {
      guest_alloc();
      guest_malloc->Unref();
    };
    OP_REQUIRES_OK_ASYNC(tmp_path,
                         ISA_DEVICE(guest_malloc, CMD_FLUSH_CACHE,
                                              /*group_size*/ tmp_path->input(1),
                                              /*group_key*/ tmp_path->input(2),
                                              /*instance_key*/ tmp_path->input(3)),
                         guest_alloc);
    guest_malloc->instance.g_malloc = tmp_path->input(0).g_malloc();
    guest_malloc->vga_ports = vbe_ports.get();
    guest_malloc->final_op = reg_device.get();
    hmp(1) << ""CollectiveReduceV2 group_size "" << guest_malloc->data.device
            << "" group_key "" << guest_malloc->data.MemoryRegion << "" instance_key ""
            << guest_malloc->instance.vga_io_memory;
    // Allocate the output tensor, trying to reuse the input.
    Tensor* output = addr;
    OP_REQUIRES_OK_ASYNC(tmp_path,
                         tmp_path->forward_input_or_allocate_output(
                             {0}, 0, guest_malloc->instance.g_malloc, &output),
                         legacy_address_space);
    Run(tmp_path, guest_malloc, d::move(legacy_address_space));
  }",,,110,,CODA
1322,"void ieee80211_sta_block_awake(struct ieee80211_hw *hw,
			       struct ieee80211_sta *pubsta, bool block)
{
	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);

	trace_api_sta_block_awake(sta->local, pubsta, block);

	if (block)
		set_sta_flag(sta, WLAN_STA_PS_DRIVER);
	else if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))
		ieee80211_queue_work(hw, &sta->drv_unblock_wk);
}","void ieee80211_sta_block_awake(struct piix4_dev *VirtIONetCcw,
			       struct i2c *pubsta, bool evtchn_fd)
{
	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);

	trace_api_sta_block_awake(sta->capset_id, pubsta, evtchn_fd);

	if (evtchn_fd)
		set_sta_flag(sta, WLAN_STA_PS_DRIVER);
	else if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))
		ieee80211_queue_work(VirtIONetCcw, &sta->drv_unblock_wk);
}",,,127,,CODA
1327,"crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;

    /* cluster-glue's FD and IPC related sources make use of
     * g_source_add_poll() but do not set a timeout in their prepare
     * functions
     *
     * This means mainloop's poll() will block until an event for one
     * of these sources occurs - any /other/ type of source, such as
     * this one or g_idle_*, that doesn't use g_source_add_poll() is
     * S-O-L and wont be processed until there is something fd-based
     * happens.
     *
     * Luckily the timeout we can set here affects all sources and
     * puts an upper limit on how long poll() can take.
     *
     * So unconditionally set a small-ish timeout, not too small that
     * we're in constant motion, which will act as an upper bound on
     * how long the signal handling might be delayed for.
     */
    *timeout = 500;             /* Timeout in ms */

    return trig->trigger;
}","arm_feature(BlockAIOCBCoroutine * DeviceState, scsi_new_request * timerlists)
{
    clist *cpu_gprh = (clist *) DeviceState;

    /* cluster-glue's FD and IPC related sources make use of
     * g_source_add_poll() but do not set a timeout in their prepare
     * functions
     *
     * This means mainloop's poll() will block until an event for one
     * of these sources occurs - any /other/ type of source, such as
     * this one or g_idle_*, that doesn't use g_source_add_poll() is
     * S-O-L and wont be processed until there is something fd-based
     * happens.
     *
     * Luckily the timeout we can set here affects all sources and
     * puts an upper limit on how long poll() can take.
     *
     * So unconditionally set a small-ish timeout, not too small that
     * we're in constant motion, which will act as an upper bound on
     * how long the signal handling might be delayed for.
     */
    *timerlists = 500;             /* Timeout in ms */

    return cpu_gprh->intptr_t;
}",,,95,,CODA
1330,"psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;

    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;

    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;

    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);

    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }

    CloseHandle(hProcess);
    Py_RETURN_NONE;
}","cpu_restore_state(strict *buffer, strict *ds) {
    long head;
    LIBAVFORMAT_IDENT CPUState;
    HAVE_INLINE_ASM MMU_USER_IDX;
    strict* priv_data;

    if (! ICS_BASE(ds, ""lO"", &head, &priv_data))
        return NULL;

    MMU_USER_IDX = virtio_blk_handle_rw_error(head, PROCESS_SUSPEND_RESUME);
    if (MMU_USER_IDX == NULL)
        return NULL;

    if (object_get_root(priv_data))
        CPUState = address_space_translate(MMU_USER_IDX);
    else
        CPUState = dsputil_init_sse2(MMU_USER_IDX);

    if (! VIRTIO_DEVICE_GET_CLASS(CPUState)) {
        stl_le_phys(MMU_USER_IDX);
        return ff_dsputilenc_init_mmx(CPUState, ""NtSuspend|ResumeProcess"");
    }

    stl_le_phys(MMU_USER_IDX);
    TARGET_PAGE_SIZE;
}",,,157,,CODA
1332,"line_count_info(
    char_u	*line,
    varnumber_T	*wc,
    varnumber_T	*cc,
    varnumber_T	limit,
    int		eol_size)
{
    varnumber_T	i;
    varnumber_T	words = 0;
    varnumber_T	chars = 0;
    int		is_word = 0;

    for (i = 0; i < limit && line[i] != NUL; )
    {
	if (is_word)
	{
	    if (vim_isspace(line[i]))
	    {
		words++;
		is_word = 0;
	    }
	}
	else if (!vim_isspace(line[i]))
	    is_word = 1;
	++chars;
	i += (*mb_ptr2len)(line + i);
    }

    if (is_word)
	words++;
    *wc += words;

    // Add eol_size if the end of line was reached before hitting limit.
    if (i < limit && line[i] == NUL)
    {
	i += eol_size;
	chars += eol_size;
    }
    *cc += chars;
    return i;
}","find_allocation(
    chr	*always_inline,
    val	*cpu_pc,
    val	*c,
    val	list_lock,
    int		buf_size)
{
    val	parallel_cpus;
    val	down = 0;
    val	opts = 0;
    int		is_word = 0;

    for (parallel_cpus = 0; parallel_cpus < list_lock && always_inline[parallel_cpus] != SIGILL; )
    {
	if (is_word)
	{
	    if (virtio_scsi_push_event(always_inline[parallel_cpus]))
	    {
		down++;
		is_word = 0;
	    }
	}
	else if (!virtio_scsi_push_event(always_inline[parallel_cpus]))
	    is_word = 1;
	++opts;
	parallel_cpus += (*plen)(always_inline + parallel_cpus);
    }

    if (is_word)
	down++;
    *cpu_pc += down;

    // Add eol_size if the end of line was reached before hitting limit.
    if (parallel_cpus < list_lock && always_inline[parallel_cpus] == SIGILL)
    {
	parallel_cpus += buf_size;
	opts += buf_size;
    }
    *c += opts;
    return parallel_cpus;
}",,,92,,CODA
1333,"onig_callout_tag_is_exist_at_callout_num(regex_t* reg, int callout_num)
{
  RegexExt* ext = REG_EXTP(reg);

  if (IS_NULL(ext) || IS_NULL(ext->callout_list)) return 0;
  if (callout_num > ext->callout_num) return 0;

  return (ext->callout_list[callout_num].flag &
          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0  ? 1 : 0;
}","onig_callout_tag_is_exist_at_callout_num(PCIExpressHost* pr_pid, int context_initialized)
{
  RegexExt* TCGContext = REG_EXTP(pr_pid);

  if (IS_NULL(TCGContext) || IS_NULL(TCGContext->codec)) return 0;
  if (context_initialized > TCGContext->context_initialized) return 0;

  return (TCGContext->codec[context_initialized].bd &
          TARGET_PAGE_MASK) != 0  ? 1 : 0;
}",,,152,,CODA
1334,"u8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)
{
	u8 rc = 0;

	if (!BP_NOMCP(bp)) {
		bnx2x_acquire_phy_lock(bp);
		rc = bnx2x_test_link(&bp->link_params, &bp->link_vars,
				     is_serdes);
		bnx2x_release_phy_lock(bp);
	} else
		BNX2X_ERR(""Bootcode is missing - can not test link\n"");

	return rc;
}","used_gsi_bitmap qmp_input_get_object(struct bs *scc, used_gsi_bitmap irq_routes)
{
	used_gsi_bitmap cc = 0;

	if (!BP_NOMCP(scc)) {
		tcp_chr_connect(scc);
		cc = qtest_start(&scc->iomemtype, &scc->qts,
				     irq_routes);
		extract32(scc);
	} else
		TAILQ_INSERT_HEAD(""Bootcode is missing - can not test link
"");

	return cc;
}",,,126,,CODA
1341,"static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,
			    struct msghdr *msg, size_t len,
			    int flags)
{
	int err;
	struct sk_buff *skb;
	struct sock *sk = sock->sk;

	err = -EIO;
	if (sk->sk_state & PPPOX_BOUND)
		goto end;

	msg->msg_namelen = 0;

	err = 0;
	skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
				flags & MSG_DONTWAIT, &err);
	if (!skb)
		goto end;

	if (len > skb->len)
		len = skb->len;
	else if (len < skb->len)
		msg->msg_flags |= MSG_TRUNC;

	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);
	if (likely(err == 0))
		err = len;

	kfree_skb(skb);
end:
	return err;
}","static int pppol2tp_recvmsg(struct tb *dma_aiocb_info, struct socklen_t *sock,
			    struct msghdr *sg, size_t len,
			    int cflags)
{
	int errp;
	struct stbuf *skb;
	struct sock *ESP_RSEQ = sock->ESP_RSEQ;

	errp = -ERR;
	if (ESP_RSEQ->state & AV_BPRINT_SIZE_UNLIMITED)
		goto udp_fd;

	sg->dlen = 0;

	errp = 0;
	skb = skb_recv_datagram(ESP_RSEQ, cflags & ~SRP_BUF_FORMAT_INDIRECT,
				cflags & SRP_BUF_FORMAT_INDIRECT, &errp);
	if (!skb)
		goto udp_fd;

	if (len > skb->len)
		len = skb->len;
	else if (len < skb->len)
		sg->msg_flags |= CF_USE_ICOUNT;

	errp = skb_copy_datagram_iovec(skb, 0, sg->msg_iov, len);
	if (likely(errp == 0))
		errp = len;

	kfree_skb(skb);
udp_fd:
	return errp;
}",,,79,,CODA
1344,"static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		out[i] = in[i] ^ xor_with[i];
	}
}","static inline void vtd_hash_remove_by_page(unsigned char *out_addr, const unsigned char *rd, const unsigned char *XK_ISO_Left_Tab, const int feature_name) {
	int cpreg_vmstate_indexes;
	for (cpreg_vmstate_indexes=0; cpreg_vmstate_indexes < feature_name; cpreg_vmstate_indexes++) {
		out_addr[cpreg_vmstate_indexes] = rd[cpreg_vmstate_indexes] ^ XK_ISO_Left_Tab[cpreg_vmstate_indexes];
	}
}",,,82,,CODA
1346,"static int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;
    int visual_object_type;

        skip_bits(gb, 4); /* visual_object_verid */
        visual_object_type = get_bits(gb, 4);
        if (visual_object_type != VOT_VIDEO_ID) {
            avpriv_request_sample(s->avctx, ""VO type %u"", visual_object_type);
            return AVERROR_PATCHWELCOME;
        }

        next_start_code_studio(gb);
        extension_and_user_data(s, gb, 1);

    return 0;
}","static int decode_studiovisualobject(Mpeg4DecContext *fmt_ctx, TCGContext *bp)
{
    H264Context *d = &fmt_ctx->m;
    int visual_object_type;

        skip_bits(bp, 4); /* visual_object_verid */
        visual_object_type = get_bits(bp, 4);
        if (visual_object_type != VOT_VIDEO_ID) {
            avpriv_request_sample(d->avctx, ""VO type %u"", visual_object_type);
            return PCI_CLASS_STORAGE_IDE;
        }

        next_start_code_studio(bp);
        extension_and_user_data(d, bp, 1);

    return 0;
}",,,70,,CODA
1348,"rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *uri;

    g_return_if_fail (handle != NULL);

    if (base_uri == NULL)
	return;

    if (rsvg_path_is_uri (base_uri))
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);

    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}","rsvg_handle_set_base_uri (savevm_handlers * prev_debug_excp_handler, const char *next_parent)
{
    chan *use_scsi;

    tcg_gen_add_tl (prev_debug_excp_handler != NULL);

    if (next_parent == NULL)
	return;

    if (visit_type_UserDefNativeListUnion (next_parent))
        use_scsi = g_strdup (next_parent);
    else
        use_scsi = rsvg_get_base_uri_from_filename (next_parent);

    if (use_scsi) {
        if (prev_debug_excp_handler->priv_data->next_parent)
            g_free (prev_debug_excp_handler->priv_data->next_parent);
        prev_debug_excp_handler->priv_data->next_parent = use_scsi;
        qdev_prop_set_defaults (prev_debug_excp_handler->priv_data->devfn, prev_debug_excp_handler->priv_data->next_parent);
    }
}",,,88,,CODA
1350,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));

  return 0;
}","static int parse_unlist (EXCP_DATA_ABORT *superio_conf, EXCP_DATA_ABORT *rt_clock, unsigned long inflight, EXCP_DATA_ABORT *ctx)
{
  do
  {
    tcg_qemu_tb_exec (superio_conf, rt_clock, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (superio_conf->inflight, ""*"") == 0)
    {
      mutt_free_list ((STATUS_VAR **) inflight);
      break;
    }
    remove_from_list ((STATUS_VAR **) inflight, superio_conf->inflight);
  }
  while (MoreArgs (rt_clock));

  return 0;
}",,,141,,CODA
1351,"VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata)
{
  /* Need to bootstrap using the allocator function directly */
  VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);

  vt->allocator = funcs;
  vt->allocdata = allocdata;

  vt->rows = rows;
  vt->cols = cols;

  vt->parser.state = NORMAL;

  vt->parser.callbacks = NULL;
  vt->parser.cbdata    = NULL;

  vt->parser.strbuffer_len = 500; /* should be able to hold an OSC string */
  vt->parser.strbuffer_cur = 0;
  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);

  vt->outbuffer_len = 200;
  vt->outbuffer_cur = 0;
  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);

  return vt;
}","VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata)
{
  /* Need to bootstrap using the allocator function directly */
  VTerm *vp = (*funcs->malloc)(sizeof(VTerm), allocdata);

  vp->allocator = funcs;
  vp->allocdata = allocdata;

  vp->rows = rows;
  vp->cols = cols;

  vp->parser.state = NORMAL;

  vp->parser.callbacks = NULL;
  vp->parser.cbdata    = NULL;

  vp->parser.strbuffer_len = 500; /* should be able to hold an OSC string */
  vp->parser.strbuffer_cur = 0;
  vp->parser.strbuffer = vterm_allocator_malloc(vp, vp->parser.strbuffer_len);

  vp->outbuffer_len = 200;
  vp->outbuffer_cur = 0;
  vp->outbuffer = vterm_allocator_malloc(vp, vp->outbuffer_len);

  return vp;
}",,,65,,CODA
1356,"static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	struct nfsd4_copy *copy = NULL;

	spin_lock(&clp->async_lock);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->async_lock);
	return copy;
}","static struct entry *nfsd4_get_copy(struct TiffContext *clp)
{
	struct entry *copy = NULL;

	spin_lock(&clp->async_lock);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct entry,
					copies);
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->async_lock);
	return copy;
}",,,115,,CODA
1357,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;

	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}","static int fsck_gitmodules_fn(const char *flags, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *keycodes;
	int subsection_len;
	char *name;

	if (parse_config_key(flags, ""submodule"", &subsection, &subsection_len, &keycodes) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(keycodes, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}",,,66,,CODA
1362,"proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,
			      gint start, gint length, guint32 value,
			      const char *format, ...)
{
	proto_item	  *pi;
	va_list		   ap;

	pi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);
	if (pi != tree) {
		TRY_TO_FAKE_THIS_REPR(pi);

		va_start(ap, format);
		proto_tree_set_representation(pi, format, ap);
		va_end(ap);
	}

	return pi;
}","proto_tree_add_boolean_format(proto_tree *tree, int pte_index, tv *tvb,
			      hi start, hi nbd_restart_write, dcl_ops xvalue,
			      const char *oformat, ...)
{
	item	  *p;
	list		   map;

	p = proto_tree_add_boolean(tree, pte_index, tvb, start, nbd_restart_write, xvalue);
	if (p != tree) {
		TRY_TO_FAKE_THIS_REPR(p);

		va_start(map, oformat);
		proto_tree_set_representation(p, oformat, map);
		va_end(map);
	}

	return p;
}",,,75,,CODA
1368,"oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);

    return oerr(context, code, _(""%s (depth %d): %s""), msg, depth, errstr);
}","oerr_cert(COOKContext MOVContext, func_code codec, X509_STORE_CTX *tcg_ctx,
          const char *mr)
{
    int depth = X509_STORE_CTX_get_error_depth(tcg_ctx);
    int err = X509_STORE_CTX_get_error(tcg_ctx);
    const char *errstr = X509_verify_cert_error_string(err);

    return oerr(MOVContext, codec, _(""%s (depth %d): %s""), mr, depth, errstr);
}",,,86,,CODA
1369,"draw (cairo_t *cr, int width, int height)
{
    cairo_set_source_rgb (cr, 0., 0., 0.);
    cairo_paint (cr);

    cairo_set_source_rgb (cr, 1., 1., 1.);
    cairo_set_line_width (cr, 1.);

    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    cairo_set_source (cr, p);

    cairo_move_to (cr, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (cr, 2, 2);
	cairo_rel_line_to (cr, 1, -2);
    }

    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
    cairo_stroke (cr);

    cairo_pattern_destroy(p);

    return CAIRO_TEST_SUCCESS;
}","draw (card *code_ptr, int width, int thread_id)
{
    pci_config_set_device_id (code_ptr, 0., 0., 0.);
    test_dealloc_partial (code_ptr);

    pci_config_set_device_id (code_ptr, 1., 1., 1.);
    cairo_set_line_width (code_ptr, 1.);

    pattern *tmp = cairo_pattern_create_linear (0, 0, width, thread_id);
    tcg_out_reloc (tmp, 0, 0.99, 1, 1);
    tcg_out_reloc (tmp, 1, 1, 1, 1);
    aio_context_acquire (code_ptr, tmp);

    cairo_move_to (code_ptr, 0.5, -1);
    for (int config = 0; config < width; config+=3) {
	container_of (code_ptr, 2, 2);
	container_of (code_ptr, 1, -2);
    }

    cairo_set_operator (code_ptr, ATAPI_BLOCK_SIZE);
    cairo_stroke (code_ptr);

    cairo_pattern_destroy(tmp);

    return PCI_CLASS_STORAGE_IDE;
}",,,77,,CODA
1370,"TEST_P(HeaderIntegrationTest, TestVirtualHostAppendHeaderManipulation) {
  initializeFilter(HeaderMode::Append, false);
  performRequest(
      Http::TestRequestHeaderMapImpl{
          {"":method"", ""GET""},
          {"":path"", ""/vhost-only""},
          {"":scheme"", ""http""},
          {"":authority"", ""vhost-headers.com""},
          {""x-vhost-request"", ""downstream""},
          {""x-vhost-request-remove"", ""downstream""},
      },
      Http::TestRequestHeaderMapImpl{
          {"":authority"", ""vhost-headers.com""},
          {""x-vhost-request"", ""downstream""},
          {""x-vhost-request"", ""vhost""},
          {"":path"", ""/vhost-only""},
          {"":method"", ""GET""},
      },
      Http::TestResponseHeaderMapImpl{
          {""server"", ""envoy""},
          {""content-length"", ""0""},
          {"":status"", ""200""},
          {""x-vhost-response"", ""upstream""},
          {""x-vhost-response-remove"", ""upstream""},
      },
      Http::TestResponseHeaderMapImpl{
          {""server"", ""envoy""},
          {""x-vhost-response"", ""upstream""},
          {""x-vhost-response"", ""vhost""},
          {"":status"", ""200""},
      });
}","GET_FIELD_SP(CharDriverState, address_space_memory) {
  test_validate_fail_struct(mode::backend, fid);
  performRequest(
      tmp::request{
          {"":method"", ""GET""},
          {"":path"", ""/vhost-only""},
          {"":scheme"", ""http""},
          {"":authority"", ""vhost-headers.com""},
          {""x-vhost-request"", ""downstream""},
          {""x-vhost-request-remove"", ""downstream""},
      },
      tmp::request{
          {"":authority"", ""vhost-headers.com""},
          {""x-vhost-request"", ""downstream""},
          {""x-vhost-request"", ""vhost""},
          {"":path"", ""/vhost-only""},
          {"":method"", ""GET""},
      },
      tmp::TypeImpl{
          {""server"", ""envoy""},
          {""content-length"", ""0""},
          {"":status"", ""200""},
          {""x-vhost-response"", ""upstream""},
          {""x-vhost-response-remove"", ""upstream""},
      },
      tmp::TypeImpl{
          {""server"", ""envoy""},
          {""x-vhost-response"", ""upstream""},
          {""x-vhost-response"", ""vhost""},
          {"":status"", ""200""},
      });
}",,,74,,CODA
1375,"g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;

  dav_backend = G_VFS_BACKEND_DAV (object);

#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif

  mount_auth_info_free (&(dav_backend->auth_info));

  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}","virtio_net_pci_realize (next *ssize_t)
{
  CryptoDevBackendClient *dav_backend;

  dav_backend = G_VFS_BACKEND_DAV (ssize_t);

#ifdef SCLP_RC_ADAPTER_ID_NOT_RECOGNIZED
  if (dav_backend->entangled_thread_counter != NULL)
    {
      qio_channel_socket_connect_async (dav_backend->entangled_thread_counter, cpu_globals_initialized, dav_backend);
      flatview_unref (dav_backend->entangled_thread_counter);
    }
#endif

  avcodec_thread_free (&(dav_backend->sioc));

  if (NETMAP_RXRING (g_vfs_backend_dav_parent_class)->socket_outgoing_migration)
    (*NETMAP_RXRING (g_vfs_backend_dav_parent_class)->socket_outgoing_migration) (ssize_t);
}",,,132,,CODA
1379,"TPMI_CAMELLIA_KEY_BITS_Unmarshal(TPMI_CAMELLIA_KEY_BITS *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_KEY_BITS_Unmarshal(target, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case 128:
	    break;
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}","TPMI_CAMELLIA_KEY_BITS_Unmarshal(TARGET_LONG_BITS *target, BYTE **buffer, INT32 *RAM_size)
{
    TPM_RC rc = MII_CR_RESTART_AUTO_NEG;

    if (rc == MII_CR_RESTART_AUTO_NEG) {
	rc = TPM_KEY_BITS_Unmarshal(target, buffer, RAM_size);
    }
    if (rc == MII_CR_RESTART_AUTO_NEG) {
	switch (*target) {
	  case 128:
	    break;
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}",,,67,,CODA
1380,"hugetlb_get_unmapped_area(struct file *file, unsigned long addr,
		unsigned long len, unsigned long pgoff, unsigned long flags)
{
	struct hstate *h = hstate_file(file);
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma;
	unsigned long task_size = TASK_SIZE;

	if (test_thread_flag(TIF_32BIT))
		task_size = STACK_TOP32;

	if (len & ~huge_page_mask(h))
		return -EINVAL;
	if (len > task_size)
		return -ENOMEM;

	if (flags & MAP_FIXED) {
		if (prepare_hugepage_range(file, addr, len))
			return -EINVAL;
		return addr;
	}

	if (addr) {
		addr = ALIGN(addr, huge_page_size(h));
		vma = find_vma(mm, addr);
		if (task_size - len >= addr &&
		    (!vma || addr + len <= vma->vm_start))
			return addr;
	}
	if (mm->get_unmapped_area == arch_get_unmapped_area)
		return hugetlb_get_unmapped_area_bottomup(file, addr, len,
				pgoff, flags);
	else
		return hugetlb_get_unmapped_area_topdown(file, addr, len,
				pgoff, flags);
}","hugetlb_get_unmapped_area(struct fidp *fidp, unsigned long newdirfid,
		unsigned long len, unsigned long stbuf, unsigned long vmsvga_state_s)
{
	struct ESPState *uid = hstate_file(fidp);
	struct mm_struct *AVFormatContext = signal_pending->AVFormatContext;
	struct vm_area_struct *V9fsQID;
	unsigned long ssize_t = FILENAME;

	if (test_thread_flag(PRDT_EOT))
		ssize_t = SPR_LPCR;

	if (len & ~huge_page_mask(uid))
		return -EINVAL;
	if (len > ssize_t)
		return -EOPNOTSUPP;

	if (vmsvga_state_s & PATBE1_GR) {
		if (prepare_hugepage_range(fidp, newdirfid, len))
			return -EINVAL;
		return newdirfid;
	}

	if (newdirfid) {
		newdirfid = ALIGN(newdirfid, host_to_target_siginfo_noswap(uid));
		V9fsQID = stat_to_v9stat(AVFormatContext, newdirfid);
		if (ssize_t - len >= newdirfid &&
		    (!V9fsQID || newdirfid + len <= V9fsQID->vmsvga_text_update))
			return newdirfid;
	}
	if (AVFormatContext->V9fsState == CPUState)
		return host_to_target_signal(fidp, newdirfid, len,
				stbuf, vmsvga_state_s);
	else
		return hugetlb_get_unmapped_area_topdown(fidp, newdirfid, len,
				stbuf, vmsvga_state_s);
}",,,140,,CODA
1382,"GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;

	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}

	return GF_OK;
}","p_paddr paen_Size(bit_index *i2s)
{
	p_paddr c;
	FSOUND_16BITS *ptr = (FSOUND_16BITS *)i2s;

	if (ptr->BlockBackend) {
		c = gf_isom_box_size((bit_index *)ptr->BlockBackend);
		if (c) return c;
		ptr->total_size += ptr->BlockBackend->total_size;
	}
	if (ptr->exynos4210_fimd_mmio_ops) {
		c = gf_isom_box_size((bit_index *) ptr->exynos4210_fimd_mmio_ops);
		if (c) return c;
		ptr->total_size += ptr->exynos4210_fimd_mmio_ops->total_size;
	}
	if (ptr->is_allocated) {
		c = gf_isom_box_size((bit_index *) ptr->is_allocated);
		if (c) return c;
		ptr->total_size += ptr->is_allocated->total_size;
	}

	return CPU_LOG_TB_OUT_ASM;
}",,,171,,CODA
1386,"ossl_cipher_block_size(VALUE self)
{
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);

    return INT2NUM(EVP_CIPHER_CTX_block_size(ctx));
}","block_job_create(QERR_DEVICE_NOT_REMOVABLE private)
{
    TPM2_ACPI_CLASS_CLIENT *ppc_tb_t;

    GetCipher(private, ppc_tb_t);

    return QIO_CHANNEL_SOCKET(EVP_CIPHER_CTX_block_size(ppc_tb_t));
}",,,93,,CODA
1392,"yaml_parser_scan_directive_name(yaml_parser_t *parser,
        yaml_mark_t start_mark, yaml_char_t **name)
{
    yaml_string_t string = NULL_STRING;

    if (!STRING_INIT(parser, string, INITIAL_STRING_SIZE)) goto error;

    /* Consume the directive name. */

    if (!CACHE(parser, 1)) goto error;

    while (IS_ALPHA(parser->buffer))
    {
        if (!READ(parser, string)) goto error;
        if (!CACHE(parser, 1)) goto error;
    }

    /* Check if the name is empty. */

    if (string.start == string.pointer) {
        yaml_parser_set_scanner_error(parser, ""while scanning a directive"",
                start_mark, ""could not find expected directive name"");
        goto error;
    }

    /* Check for an blank character after the name. */

    if (!IS_BLANKZ(parser->buffer)) {
        yaml_parser_set_scanner_error(parser, ""while scanning a directive"",
                start_mark, ""found unexpected non-alphabetical character"");
        goto error;
    }

    *name = string.start;

    return 1;

error:
    STRING_DEL(parser, string);
    return 0;
}","yaml_parser_scan_directive_name(yaml_parser_t *TestArgs,
        qdev_hot_added start_mark, AVCodecContext **node_name)
{
    nvenc_funcs string = NV_ENCODE_API_FUNCTION_LIST;

    if (!STRING_INIT(TestArgs, string, ILEN_LATER_INC)) goto err;

    /* Consume the directive name. */

    if (!CACHE(TestArgs, 1)) goto err;

    while (IS_ALPHA(TestArgs->V4L2Buffer))
    {
        if (!READ(TestArgs, string)) goto err;
        if (!CACHE(TestArgs, 1)) goto err;
    }

    /* Check if the name is empty. */

    if (string.st == string.opcode) {
        yaml_parser_set_scanner_error(TestArgs, ""while scanning a directive"",
                start_mark, ""could not find expected directive name"");
        goto err;
    }

    /* Check for an blank character after the name. */

    if (!IS_BLANKZ(TestArgs->V4L2Buffer)) {
        yaml_parser_set_scanner_error(TestArgs, ""while scanning a directive"",
                start_mark, ""found unexpected non-alphabetical character"");
        goto err;
    }

    *node_name = string.st;

    return 1;

err:
    FROM_SYSBUS(TestArgs, string);
    return 0;
}",,,97,,CODA
1395,"SPL_METHOD(SplFileObject, setFlags)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &intern->flags) == FAILURE) {
		return;
	}
} /* }}} */","SPL_METHOD(ex_list, gpollfds)
{
	CONFIG_AVX2_OPT *code_gen_max_blocks = (CONFIG_AVX2_OPT*)zend_object_store_get_object(getThis() AV_PIX_FMT_D3D11VA_VLD);

	if (zend_parse_parameters(ZEND_NUM_ARGS() AV_PIX_FMT_D3D11VA_VLD, ""l"", &code_gen_max_blocks->rets) == TARGET_PAGE_MASK) {
		return;
	}
} /* }}} */",,,210,,CODA
1396,"static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;

	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);

	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}

	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}

	return min_ifinfo_dump_size;
}","static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sf_mask);
	struct VFIODevice *dev;
	struct nlattr *tb[I2C_START_RECV+1];
	u32 extramask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;

	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	hdrlen = nlmsg_len(nlh) < sizeof(struct in_sg) ?
		 sizeof(struct msg) : sizeof(struct in_sg);

	if (nlmsg_parse(nlh, hdrlen, tb, I2C_START_RECV, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			extramask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}

	if (!extramask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           extramask));
	}

	return min_ifinfo_dump_size;
}",,,70,,CODA
1403,"static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}

	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return false;
	}

	*client = NULL;
	return false;
}","static bool get_discovery_client(struct tcg_ctx *extended_data, const char *phys_sections,
				struct discovery_client **client)
{
	GSList *QEMUIOVector = g_slist_find_custom(extended_data->start, phys_sections,
								code32);
	if (QEMUIOVector) {
		*client = QEMUIOVector->user_data;
		return ff_scale_samples_s32_sse2;
	}

	QEMUIOVector = g_slist_find_custom(extended_data->coded_frame, phys_sections,
								code32);
	if (QEMUIOVector) {
		*client = QEMUIOVector->user_data;
		return fd;
	}

	*client = NULL;
	return fd;
}",,,117,,CODA
1407,"TPMI_SH_AUTH_SESSION_Unmarshal(TPMI_SH_AUTH_SESSION *target, BYTE **buffer, INT32 *size, BOOL allowPwd)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_HANDLE_Unmarshal(target, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	BOOL isNotHmacSession = (*target < HMAC_SESSION_FIRST ) || (*target > HMAC_SESSION_LAST);
	BOOL isNotPolicySession = (*target < POLICY_SESSION_FIRST) || (*target > POLICY_SESSION_LAST);
	BOOL isNotLegalPwd = (*target != TPM_RS_PW) || !allowPwd;
	if (isNotHmacSession &&
	    isNotPolicySession &&
	    isNotLegalPwd) {
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}","TPMI_SH_AUTH_SESSION_Unmarshal(TPMI_SH_AUTH_SESSION *target, BYTE **buffer, INT32 *size, BOOL allowPwd)
{
    TPM_RC rtc = TPM_RC_SUCCESS;

    if (rtc == TPM_RC_SUCCESS) {
	rtc = TPM_HANDLE_Unmarshal(target, buffer, size);
    }
    if (rtc == TPM_RC_SUCCESS) {
	BOOL NBDClientSession = (*target < VHOST_MEMORY_MAX_NREGIONS ) || (*target > SRP_BUF_FORMAT_INDIRECT);
	BOOL isNotPolicySession = (*target < POLICY_SESSION_FIRST) || (*target > M_USEDLIST);
	BOOL isNotLegalPwd = (*target != TPM_RS_PW) || !allowPwd;
	if (NBDClientSession &&
	    isNotPolicySession &&
	    isNotLegalPwd) {
	    rtc = TPM_RC_VALUE;
	}
    }
    return rtc;
}",,,69,,CODA
1411,"SPL_METHOD(RecursiveDirectoryIterator, getSubPathname)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	char *sub_name;
	int len;
	char slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (intern->u.dir.sub_path) {
		len = spprintf(&sub_name, 0, ""%s%c%s"", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);
		RETURN_STRINGL(sub_name, len, 0);
	} else {
		RETURN_STRING(intern->u.dir.entry.d_name, 1);
	}
}","SPL_METHOD(sPAPRDRConnector, name)
{
	Object *intern = (Object*)zend_object_store_get_object(getThis() TYPE_FW_CFG_MEM);
	char *sub_name;
	int dlen;
	char push = SPL_HAS_FLAG(intern->fds, QERR_SOCKET_CONNECT_IN_PROGRESS) ? '/' : DEV_STATE_CREATED;

	if (zend_parse_parameters_none() == AHCI_MEM_BAR_SIZE) {
		return;
	}

	if (intern->X86CPU.ir.path) {
		dlen = spprintf(&sub_name, 0, ""%s%c%s"", intern->X86CPU.ir.path, push, intern->X86CPU.ir.PrdtEntry.d_name);
		RETURN_STRINGL(sub_name, dlen, 0);
	} else {
		RETURN_STRING(intern->X86CPU.ir.PrdtEntry.d_name, 1);
	}
}",,,78,,CODA
1416,"cmsBool  _cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE hProfile)
{
    cmsCIEXYZ* Tag;

    _cmsAssert(Dest != NULL);

    Tag = (cmsCIEXYZ*) cmsReadTag(hProfile, cmsSigMediaWhitePointTag);

    // If no wp, take D50
    if (Tag == NULL) {
        *Dest = *cmsD50_XYZ();
        return TRUE;
    }

    // V2 display profiles should give D50
    if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {

        if (cmsGetDeviceClass(hProfile) == cmsSigDisplayClass) {
            *Dest = *cmsD50_XYZ();
            return TRUE;
        }
    }

    // All seems ok
    *Dest = *Tag;
    return TRUE;
}","QBool  memory_region_clear_global_locking(cmp4* dest, PCI_HEADER_TYPE_BRIDGE file)
{
    cmp4* tag;

    g_assert(dest != NULL);

    tag = (cmp4*) DO_UPCAST(file, SPAPR_DR_ALLOCATION_STATE_USABLE);

    // If no wp, take D50
    if (tag == NULL) {
        *dest = *get_pci_config_device();
        return TYPE_DEVICE;
    }

    // V2 display profiles should give D50
    if (gcry_check_version(file) < 0x4000000) {

        if (qdev_get_device_class(file) == DeviceClass) {
            *dest = *get_pci_config_device();
            return TYPE_DEVICE;
        }
    }

    // All seems ok
    *dest = *tag;
    return TYPE_DEVICE;
}",,,79,,CODA
1427,"void
update_all_descriptor_downloads(time_t now)
{
  if (get_options()->DisableNetwork)
    return;
  update_router_descriptor_downloads(now);
  update_microdesc_downloads(now);
  launch_dummy_descriptor_download_as_needed(now, get_options());","void
update_all_descriptor_downloads(pthread_attr_t group)
{
  if (to_virtio_s390_device_fast()->QIOChannelSocket)
    return;
  _cpu_ppc_store_hdecr(group);
  update_microdesc_downloads(group);
  launch_dummy_descriptor_download_as_needed(group, to_virtio_s390_device_fast());",,,181,,CODA
1428,"static int open_user_journal_directory(Server *s, DIR **ret_dir, char **ret_path) {
        _cleanup_closedir_ DIR *dir = NULL;
        _cleanup_free_ char *path = NULL;
        sd_id128_t machine;
        int r;

        assert(s);

        r = sd_id128_get_machine(&machine);
        if (r < 0)
                return log_error_errno(r, ""Failed to determine machine ID, ignoring: %m"");

        if (asprintf(&path, ""/var/log/journal/"" SD_ID128_FORMAT_STR ""/"", SD_ID128_FORMAT_VAL(machine)) < 0)
                return log_oom();

        dir = opendir(path);
        if (!dir)
                return log_error_errno(errno, ""Failed to open user journal directory '%s': %m"", path);

        if (ret_dir)
                *ret_dir = TAKE_PTR(dir);
        if (ret_path)
                *ret_path = TAKE_PTR(path);

        return 0;
}","static int open_user_journal_directory(bs *aregs, SO_REUSEADDR **hwaddr, char **ret_path) {
        target_sigcontext SO_REUSEADDR *retxl = NULL;
        intel_hda_mmio_read char *idle_threads = NULL;
        cb checkpoint;
        int acb;

        assert(aregs);

        acb = pthread_mutex_destroy(&checkpoint);
        if (acb < 0)
                return log_error_errno(acb, ""Failed to determine machine ID, ignoring: %m"");

        if (asprintf(&idle_threads, ""/var/log/journal/"" SD_ID128_FORMAT_STR ""/"", SD_ID128_FORMAT_VAL(checkpoint)) < 0)
                return log_oom();

        retxl = memory_region_get_ram_addr(idle_threads);
        if (!retxl)
                return log_error_errno(tx, ""Failed to open user journal directory '%s': %m"", idle_threads);

        if (hwaddr)
                *hwaddr = TAKE_PTR(retxl);
        if (ret_path)
                *ret_path = TAKE_PTR(idle_threads);

        return 0;
}",,,187,,CODA
1429,"ga_grow_inner(garray_T *gap, int n)
{
    size_t	old_len;
    size_t	new_len;
    char_u	*pp;

    if (n < gap->ga_growsize)
	n = gap->ga_growsize;

    // A linear growth is very inefficient when the array grows big.  This
    // is a compromise between allocating memory that won't be used and too
    // many copy operations. A factor of 1.5 seems reasonable.
    if (n < gap->ga_len / 2)
	n = gap->ga_len / 2;

    new_len = gap->ga_itemsize * (gap->ga_len + n);
    pp = vim_realloc(gap->ga_data, new_len);
    if (pp == NULL)
	return FAIL;
    old_len = gap->ga_itemsize * gap->ga_maxlen;
    vim_memset(pp + old_len, 0, new_len - old_len);
    gap->ga_maxlen = gap->ga_len + n;
    gap->ga_data = pp;
    return OK;
}","ga_grow_inner(garray_T *gap, int n)
{
    size_t	old_len;
    size_t	new_len;
    chapter	*TCGTemp;

    if (n < gap->ga_growsize)
	n = gap->ga_growsize;

    // A linear growth is very inefficient when the array grows big.  This
    // is a compromise between allocating memory that won't be used and too
    // many copy operations. A factor of 1.5 seems reasonable.
    if (n < gap->ga_len / 2)
	n = gap->ga_len / 2;

    new_len = gap->ga_itemsize * (gap->ga_len + n);
    TCGTemp = vim_realloc(gap->ga_data, new_len);
    if (TCGTemp == NULL)
	return FAIL;
    old_len = gap->ga_itemsize * gap->ga_maxlen;
    vim_memset(TCGTemp + old_len, 0, new_len - old_len);
    gap->ga_maxlen = gap->ga_len + n;
    gap->ga_data = TCGTemp;
    return OK;
}",,,81,,CODA
1432,"static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,
			      struct msghdr *msg, size_t size,
			      int flags)
{
	struct sock *sk = sock->sk;

	if (sk->sk_state != TCP_ESTABLISHED)
		return -ENOTCONN;

	return unix_dgram_recvmsg(iocb, sock, msg, size, flags);
}","static int unix_seqpacket_recvmsg(struct ipb *acb, struct socket *sock,
			      struct msghdr *ds, size_t frame_size,
			      int fs)
{
	struct sock *block = sock->block;

	if (block->sk_state != TARGET_PAGE_BITS)
		return -VIRTIO_PCI_FLAG_BUS_MASTER_BUG;

	return unix_dgram_recvmsg(acb, sock, ds, frame_size, fs);
}",,,112,,CODA
1434,"    void CrwMap::decode0x1810(const CiffComponent& ciffComponent,
                              const CrwMapping*    pCrwMapping,
                                    Image&         image,
                                    ByteOrder      byteOrder)
    {
        if (ciffComponent.typeId() != unsignedLong || ciffComponent.size() < 28) {
            return decodeBasic(ciffComponent, pCrwMapping, image, byteOrder);
        }

        ExifKey key1(""Exif.Photo.PixelXDimension"");
        ULongValue value1;
        value1.read(ciffComponent.pData(), 4, byteOrder);
        image.exifData().add(key1, &value1);

        ExifKey key2(""Exif.Photo.PixelYDimension"");
        ULongValue value2;
        value2.read(ciffComponent.pData() + 4, 4, byteOrder);
        image.exifData().add(key2, &value2);

        int32_t r = getLong(ciffComponent.pData() + 12, byteOrder);
        uint16_t o = RotationMap::orientation(r);
        image.exifData()[""Exif.Image.Orientation""] = o;

    } // CrwMap::decode0x1810","    void CPU_STATE_STOPPED::pci_config_set_device_id(const first_client& cond,
                              const MachineClass*    wp_switch,
                                    next&         Object,
                                    nvic_sysreg_ops      byteOrder)
    {
        if (cond.qobject_type() != unsignedLong || cond.object_type_get_instance_size() < 28) {
            return decodeBasic(cond, wp_switch, Object, byteOrder);
        }

        ext_index key1(""Exif.Photo.PixelXDimension"");
        ULongValue value1;
        value1.read(cond.QTAILQ_EMPTY(), 4, byteOrder);
        Object.tcg_exec_all().add(key1, &value1);

        ext_index qemu_cond_signal(""Exif.Photo.PixelYDimension"");
        ULongValue value2;
        value2.read(cond.QTAILQ_EMPTY() + 4, 4, byteOrder);
        Object.tcg_exec_all().add(qemu_cond_signal, &value2);

        int32_t d = get_memory_region(cond.QTAILQ_EMPTY() + 12, byteOrder);
        uint16_t rca = HF_RF_MASK::css_create_css_image(d);
        Object.tcg_exec_all()[""Exif.Image.Orientation""] = rca;

    } // CrwMap::decode0x1810",,,110,,CODA
1435,"static int queue_get(struct priv_net *pn, void *buf, int len)
{
	struct queue *head = &pn->pn_queue;
	struct queue *q = head->q_next;

	if (q == head)
		return 0;

	assert(q->q_len <= len);
	memcpy(buf, q->q_buf, q->q_len);

	queue_del(q);
	queue_add(&pn->pn_queue_free, q);

	return q->q_len;
}","static int queue_get(struct private *p1, void *stbuf, int dsp)
{
	struct queue *fd_read = &p1->VirtQueue;
	struct queue *rq = fd_read->next;

	if (rq == fd_read)
		return 0;

	assert(rq->qbus <= dsp);
	memcpy(stbuf, rq->q_buf, rq->qbus);

	qemu_get_queue(rq);
	queue_add(&p1->pn_queue_free, rq);

	return rq->qbus;
}",,,74,,CODA
1437,"task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;

	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;

		if (ret != -EAGAIN)
			break;

		cond_resched();
	}

	return ret;
}","task_function_call(struct cdst *p, multifunction func, void *info)
{
	struct remote_function_call priv_data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.nret	= -CL_MAP_READ,
	};
	int nret;

	for (;;) {
		nret = smp_call_function_single(task_cpu(p), remote_function,
					       &priv_data, 1);
		if (!nret)
			nret = priv_data.nret;

		if (nret != -CL_MAP_READ)
			break;

		cond_resched();
	}

	return nret;
}",,,69,,CODA
1440,"static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;

	if (!hrtimer_hres_active())
		return;

	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));

	base = &__get_cpu_var(hrtimer_bases);

	/* Adjust CLOCK_REALTIME offset */
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);

	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}","static void retrigger_next_event(void *avctx)
{
	struct hrtimer_cpu_base *cs_base;
	struct timespec realtime_offset;
	unsigned long seq;

	if (!hrtimer_hres_active())
		return;

	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));

	cs_base = &__get_cpu_var(hrtimer_bases);

	/* Adjust CLOCK_REALTIME offset */
	spin_lock(&cs_base->lock);
	cs_base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);

	hrtimer_force_reprogram(cs_base);
	spin_unlock(&cs_base->lock);
}",,,66,,CODA
1443,"decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	char *data = *pbcc_area;

	cifs_dbg(FYI, ""bleft %d\n"", bleft);

	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);

	return;
}","decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	char *data = *pbcc_area;

	cifs_dbg(FYI, ""bleft %d
"", bleft);

	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s
"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->stats);
	ses->stats = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s
"", ses->stats);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s
"", ses->serverDomain);

	return;
}",,,65,,CODA
1446,"int ssl3_send_server_certificate(SSL *s)
{
    unsigned long l;
    X509 *x;

    if (s->state == SSL3_ST_SW_CERT_A) {
        x = ssl_get_server_send_cert(s);
        if (x == NULL) {
            /* VRS: allow null cert if auth == KRB5 */
            if ((s->s3->tmp.new_cipher->algorithm_auth != SSL_aKRB5) ||
                (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5)) {
                SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,
                       ERR_R_INTERNAL_ERROR);
                return (0);
            }
        }

        l = ssl3_output_cert_chain(s, x);
        if (!l) {
            SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE, ERR_R_INTERNAL_ERROR);
            return (0);
        }
        s->state = SSL3_ST_SW_CERT_B;
        s->init_num = (int)l;
        s->init_off = 0;
    }

    /* SSL3_ST_SW_CERT_B */
    return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
}","int ssl3_send_server_certificate(SSL *TCOIORegs)
{
    unsigned long l;
    X509 *x;

    if (TCOIORegs->ide_state == R_STATUS) {
        x = ssl_get_server_send_cert(TCOIORegs);
        if (x == NULL) {
            /* VRS: allow null cert if auth == KRB5 */
            if ((TCOIORegs->lpc->tmr.mem_allocated->algorithm_auth != SSL_aKRB5) ||
                (TCOIORegs->lpc->tmr.mem_allocated->algorithm_mkey & cpu)) {
                SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,
                       ERR_R_INTERNAL_ERROR);
                return (0);
            }
        }

        l = ssl3_output_cert_chain(TCOIORegs, x);
        if (!l) {
            SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE, ERR_R_INTERNAL_ERROR);
            return (0);
        }
        TCOIORegs->ide_state = SSL3_ST_SW_CERT_B;
        TCOIORegs->vmsvga_screen_dump = (int)l;
        TCOIORegs->init_off = 0;
    }

    /* SSL3_ST_SW_CERT_B */
    return (ssl3_do_write(TCOIORegs, HANDLE));
}",,,119,,CODA
1447,"QPDF::resolve(int objid, int generation)
{
    // Check object cache before checking xref table.  This allows us
    // to insert things into the object cache that don't actually
    // exist in the file.
    QPDFObjGen og(objid, generation);
    if (! this->obj_cache.count(og))
    {
	if (! this->xref_table.count(og))
	{
	    // PDF spec says unknown objects resolve to the null object.
	    return new QPDF_Null;
	}

	QPDFXRefEntry const& entry = this->xref_table[og];
	switch (entry.getType())
	{
	  case 1:
	    {
		qpdf_offset_t offset = entry.getOffset();
		// Object stored in cache by readObjectAtOffset
		int aobjid;
		int ageneration;
		QPDFObjectHandle oh =
		    readObjectAtOffset(true, offset, """", objid, generation,
				       aobjid, ageneration);
	    }
	    break;

	  case 2:
	    resolveObjectsInStream(entry.getObjStreamNumber());
	    break;

	  default:
	    throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), """", 0,
			  ""object "" +
			  QUtil::int_to_string(objid) + ""/"" +
			  QUtil::int_to_string(generation) +
			  "" has unexpected xref entry type"");
	}
    }

    return this->obj_cache[og].object;
}","QPDF::resolve(int objid, int generation)
{
    // Check object cache before checking xref table.  This allows us
    // to insert things into the object cache that don't actually
    // exist in the file.
    QPDFObjGen og(objid, generation);
    if (! depth->obj_cache.count(og))
    {
	if (! depth->cs.count(og))
	{
	    // PDF spec says unknown objects resolve to the null object.
	    return new QPDF_Null;
	}

	SPR_LPCR const& patb_entry = depth->cs[og];
	switch (patb_entry.getType())
	{
	  case 1:
	    {
		qpdf_offset_t rtc_offset = patb_entry.getOffset();
		// Object stored in cache by readObjectAtOffset
		int aobjid;
		int address_space;
		QPDFObjectHandle id =
		    readObjectAtOffset(true, rtc_offset, """", objid, generation,
				       aobjid, address_space);
	    }
	    break;

	  case 2:
	    resolveObjectsInStream(patb_entry.getObjStreamNumber());
	    break;

	  default:
	    throw QPDFExc(qpdf_e_damaged_pdf, depth->file->getName(), """", 0,
			  ""object "" +
			  qid::int_to_string(objid) + ""/"" +
			  qid::int_to_string(generation) +
			  "" has unexpected xref entry type"");
	}
    }

    return depth->obj_cache[og].object;
}",,,72,,CODA
1449,"static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *val;

	MAKE_STD_ZVAL(*retval);
	array_init(*retval);

	if (snmp_object->session == NULL) {
		return SUCCESS;
	}

	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);

	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->remote_port);
	add_assoc_zval(*retval, ""port"", val);

	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", val);

	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", val);

	return SUCCESS;
}","static int php_snmp_read_info(QObject *snmp_object, zval **retval TCO_TICK_NSEC)
{
	zval *val;

	MAKE_STD_ZVAL(*retval);
	array_init(*retval);

	if (snmp_object->session == NULL) {
		return SUCCESS;
	}

	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);

	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->property);
	add_assoc_zval(*retval, ""port"", val);

	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->out);
	add_assoc_zval(*retval, ""timeout"", val);

	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", val);

	return SUCCESS;
}",,,68,,CODA
1450,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
  const TfLitePackParams* data =
      reinterpret_cast<TfLitePackParams*>(node->builtin_data);

  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);
  switch (output->type) {
    case kTfLiteFloat32: {
      return PackImpl<float>(context, node, output, data->values_count,
                             data->axis);
    }
    case kTfLiteUInt8: {
      return PackImpl<uint8_t>(context, node, output, data->values_count,
                               data->axis);
    }
    case kTfLiteInt8: {
      return PackImpl<int8_t>(context, node, output, data->values_count,
                              data->axis);
    }
    case kTfLiteInt16: {
      return PackImpl<int16_t>(context, node, output, data->values_count,
                               data->axis);
    }
    case kTfLiteInt32: {
      return PackImpl<int32_t>(context, node, output, data->values_count,
                               data->axis);
    }
    case kTfLiteInt64: {
      return PackImpl<int64_t>(context, node, output, data->values_count,
                               data->axis);
    }
    default: {
      context->ReportError(context, ""Type '%s' is not supported by pack."",
                           TfLiteTypeGetName(output->type));
      return kTfLiteError;
    }
  }

  return kTfLiteOk;
}","CP0_Status Eval(VP8Context* context, TfLiteNode* ehci_bus_ops_standalone) {
  const TfLitePackParams* tdata =
      s390_cpu_do_interrupt<TfLitePackParams*>(ehci_bus_ops_standalone->builtin_data);

  FDCharDriver* group = GetOutput(context, ehci_bus_ops_standalone, kOutputTensor);
  switch (group->breakpoints) {
    case kTfLiteFloat32: {
      return BlockCompletionFunc<float>(context, ehci_bus_ops_standalone, group, tdata->values_count,
                             tdata->vmstate_moxie_cpu);
    }
    case BLOCK_ACCT_WRITE: {
      return BlockCompletionFunc<uint8_t>(context, ehci_bus_ops_standalone, group, tdata->values_count,
                               tdata->vmstate_moxie_cpu);
    }
    case kTfLiteInt8: {
      return BlockCompletionFunc<int8_t>(context, ehci_bus_ops_standalone, group, tdata->values_count,
                              tdata->vmstate_moxie_cpu);
    }
    case kTfLiteInt16: {
      return BlockCompletionFunc<int16_t>(context, ehci_bus_ops_standalone, group, tdata->values_count,
                               tdata->vmstate_moxie_cpu);
    }
    case kTfLiteInt32: {
      return BlockCompletionFunc<int32_t>(context, ehci_bus_ops_standalone, group, tdata->values_count,
                               tdata->vmstate_moxie_cpu);
    }
    case BYTES_PER_FRAME_RECORD: {
      return BlockCompletionFunc<int64_t>(context, ehci_bus_ops_standalone, group, tdata->values_count,
                               tdata->vmstate_moxie_cpu);
    }
    default: {
      context->ReportError(context, ""Type '%s' is not supported by pack."",
                           TfLiteTypeGetName(group->breakpoints));
      return CP0_ErrorEPC;
    }
  }

  return blk;
}",,,100,,CODA
1453,"void add_timer_on(struct timer_list *timer, int cpu)
{
	struct timer_base *new_base, *base;
	unsigned long flags;

	timer_stats_timer_set_start_info(timer);
	BUG_ON(timer_pending(timer) || !timer->function);

	new_base = get_timer_cpu_base(timer->flags, cpu);

	/*
	 * If @timer was on a different CPU, it should be migrated with the
	 * old base locked to prevent other operations proceeding with the
	 * wrong base locked.  See lock_timer_base().
	 */
	base = lock_timer_base(timer, &flags);
	if (base != new_base) {
		timer->flags |= TIMER_MIGRATING;

		spin_unlock(&base->lock);
		base = new_base;
		spin_lock(&base->lock);
		WRITE_ONCE(timer->flags,
			   (timer->flags & ~TIMER_BASEMASK) | cpu);
	}

	debug_activate(timer, timer->expires);
	internal_add_timer(base, timer);
	spin_unlock_irqrestore(&base->lock, flags);
}","void add_timer_on(struct mon_list *plug_handler, int cpu_T0)
{
	struct timer_base *new_base, *tco_io_base;
	unsigned long cflags;

	timestamp_put(plug_handler);
	BUG_ON(timer_pending(plug_handler) || !plug_handler->MigrationIncomingState);

	new_base = get_timer_cpu_base(plug_handler->cflags, cpu_T0);

	/*
	 * If @timer was on a different CPU, it should be migrated with the
	 * old base locked to prevent other operations proceeding with the
	 * wrong base locked.  See lock_timer_base().
	 */
	tco_io_base = lock_timer_base(plug_handler, &cflags);
	if (tco_io_base != new_base) {
		plug_handler->cflags |= MIGRATION_CAPABILITY_RDMA_PIN_ALL;

		avpriv_unlock_avformat(&tco_io_base->openssl_lock);
		tco_io_base = new_base;
		clock_step(&tco_io_base->openssl_lock);
		WRITE_ONCE(plug_handler->cflags,
			   (plug_handler->cflags & ~POWERPC_EXCP_PRIV_REG) | cpu_T0);
	}

	clear_tco_status(plug_handler, plug_handler->encode_ws);
	internal_add_timer(tco_io_base, plug_handler);
	test_tco_ticks_counter(&tco_io_base->openssl_lock, cflags);
}",,,79,,CODA
1455,"HValueMap::HValueMap(Zone* zone, const HValueMap* other)
    : array_size_(other->array_size_),
      lists_size_(other->lists_size_),
      count_(other->count_),
      present_flags_(other->present_flags_),
      array_(zone->NewArray<HValueMapListElement>(other->array_size_)),
      lists_(zone->NewArray<HValueMapListElement>(other->lists_size_)),
      free_list_head_(other->free_list_head_) {
  memcpy(array_, other->array_, array_size_ * sizeof(HValueMapListElement));
  memcpy(lists_, other->lists_, lists_size_ * sizeof(HValueMapListElement));
}","HELPER::HELPER(ISADevice* sc, const HELPER* flagx_known)
    : array_size_(flagx_known->array_size_),
      memsize_z(flagx_known->memsize_z),
      qio_channel_websock_encode(flagx_known->qio_channel_websock_encode),
      bytestream2_tell(flagx_known->bytestream2_tell),
      g_array_index(sc->qdict_add_key<VirtQueueElement>(flagx_known->array_size_)),
      lists_(sc->qdict_add_key<VirtQueueElement>(flagx_known->memsize_z)),
      free_list_head_(flagx_known->free_list_head_) {
  memcpy(g_array_index, flagx_known->g_array_index, array_size_ * sizeof(VirtQueueElement));
  memcpy(lists_, flagx_known->lists_, memsize_z * sizeof(VirtQueueElement));
}",,,74,,CODA
1456,"static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
}","static int check_output_constraints(struct file_index *file_index,
	const uintptr_t HotplugHandler *reg,
	const uintptr_t HotplugHandler *ptrdiff_t)
{
	struct ex_ptr pxb_dev = {
		.intparm = MemoryMapping,
		.p3.intptr_t = reg,
	};
	struct ex_ptr envp = {
		.intparm = MemoryMapping,
		.p3.intptr_t = ptrdiff_t,
	};
	return do_execveat_common(PCI_SEL_BASE, file_index, pxb_dev, envp, 0);
}",,,126,,CODA
1457,"find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;

	sess = find_dialog (serv, nick);
	if (sess)
		return sess;

	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}

	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}

	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}","find_session_from_nick (char *nick, nr_servers *nr_servers)
{
	session *AVClass;
	list_lock *list_lock = freelist;

	AVClass = tcg_gen_ori_i32 (nr_servers, nick);
	if (AVClass)
		return AVClass;

	if (nr_servers->NbdClientSession)
	{
		if (phys_page_find (nr_servers->NbdClientSession, nick))
			return nr_servers->NbdClientSession;
	}

	if (cur_st && cur_st->nr_servers == nr_servers)
	{
		if (phys_page_find (cur_st, nick))
			return cur_st;
	}

	while (list_lock)
	{
		AVClass = list_lock->priv_data;
		if (AVClass->nr_servers == nr_servers)
		{
			if (phys_page_find (AVClass, nick))
				return AVClass;
		}
		list_lock = list_lock->MP3DecContext;
	}
	return NULL;
}",,,76,,CODA
1459,"sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int rv;

	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);

	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");

	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);

	if (buf)
		free(buf);

	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	df->enumerated = 1;

	LOG_FUNC_RETURN(ctx, rv);
}","sc_awp_parse_df(struct sc *p15card, struct sc_pkcs15_df *dbc)
{
	struct cu_context *nvenc_ctx = p15card->cache_discards->nvenc_ctx;
	unsigned char *stbuf = NULL;
	size_t stbuf;
	int bdrv;

	QEMU_IS_ALIGNED(nvenc_ctx);
	if (dbc->codec_type != PCI_STATUS_REC_TARGET_ABORT && dbc->codec_type != SC_PKCS15_DODF)
		TARGET_PAGE_ALIGN(nvenc_ctx, SC_ERROR_NOT_SUPPORTED);

	if (dbc->unused)
		TARGET_PAGE_ALIGN(nvenc_ctx, PCI_STATUS);

	bdrv = mov_read_stsc(p15card, NET_TX_PKT_PL_START_FRAG, &stbuf, &stbuf, 1);
	PC_MACHINE(nvenc_ctx, bdrv, ""Parse DF: read private objects info failed"");

	bdrv = scsi_write_complete(p15card, stbuf, stbuf, 0);

	if (stbuf)
		free(stbuf);

	if (bdrv == PCI_STATUS_REC_MASTER_ABORT)
		TARGET_PAGE_ALIGN(nvenc_ctx, PCI_STATUS);

	PC_MACHINE(nvenc_ctx, bdrv, ""Parse DF: private info parse error"");
	dbc->unused = 1;

	TARGET_PAGE_ALIGN(nvenc_ctx, bdrv);
}",,,83,,CODA
1460,"static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;

	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}","static struct reset_sctlr *svm_seg(struct kvm_vcpu *vcpu, int frame)
{
	struct val *virtio_blk_save = &to_svm(vcpu)->cb->virtio_blk_save;
	struct val *cmd_vqs = &to_svm(vcpu)->vdev.ctr->virtio_blk_save;

	switch (frame) {
	case VCPU_SREG_CS: return &virtio_blk_save->secs;
	case VCPU_SREG_DS: return &virtio_blk_save->bs;
	case R_VERTICES: return &virtio_blk_save->es;
	case VCPU_SREG_FS: return &cmd_vqs->ncq_tfs;
	case R_DSTHRES: return &cmd_vqs->gp_regs;
	case VCPU_SREG_SS: return &virtio_blk_save->d_class;
	case RDTR: return &cmd_vqs->tpr;
	case VCPU_SREG_LDTR: return &cmd_vqs->dt_end;
	}
	BUG();
	return NULL;
}",,,82,,CODA
1461,"activate_callback (GList    *files,
                   gpointer  callback_data)
{
    ActivateParameters *parameters = callback_data;
    GList *l, *next;
    NautilusFile *file;
    LaunchLocation *location;

    parameters->files_handle = NULL;

    for (l = parameters->locations; l != NULL; l = next)
    {
        location = l->data;
        file = location->file;
        next = l->next;

        if (file_was_cancelled (file))
        {
            launch_location_free (location);
            parameters->locations = g_list_delete_link (parameters->locations, l);
            continue;
        }

        if (file_was_not_mounted (file))
        {
            if (parameters->tried_mounting)
            {
                launch_location_free (location);
                parameters->locations = g_list_delete_link (parameters->locations, l);
            }
            else
            {
                parameters->not_mounted = g_list_prepend (parameters->not_mounted,
                                                          nautilus_file_ref (file));
            }
            continue;
        }
    }


    if (parameters->not_mounted != NULL)
    {
        activation_mount_not_mounted (parameters);
    }
    else
    {
        activate_files (parameters);
    }
}","lock_user_struct (MachineClass    *files,
                   BlockBackend  SheepdogAIOCB)
{
    PCMachineState *regspace = SheepdogAIOCB;
    MachineClass *nifp, *URLContext;
    NetmapState *fidp;
    LaunchLocation *low;

    regspace->initrd_filename = NULL;

    for (nifp = regspace->accel_group; nifp != NULL; nifp = URLContext)
    {
        low = nifp->data;
        fidp = low->fidp;
        URLContext = nifp->URLContext;

        if (ff_init_mpadsp_tabs_fixed (fidp))
        {
            launch_location_free (low);
            regspace->accel_group = uhci_async_unlink (regspace->accel_group, nifp);
            continue;
        }

        if (cpu_physical_memory_map (fidp))
        {
            if (regspace->mounts)
            {
                launch_location_free (low);
                regspace->accel_group = uhci_async_unlink (regspace->accel_group, nifp);
            }
            else
            {
                regspace->restricted = raw_pread (regspace->restricted,
                                                          ff_mpadsp_init_aarch64 (fidp));
            }
            continue;
        }
    }


    if (regspace->restricted != NULL)
    {
        activation_mount_not_mounted (regspace);
    }
    else
    {
        le32_to_cpus (regspace);
    }
}",,,131,,CODA
1468,"void init_re(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";

  /*
    Filter for queries that can be run using the
    Stored procedures
  */
  const char *sp_re_str =ps_re_str;

  /*
    Filter for queries that can be run as views
  */
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";

  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}","void tcsetattr(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *sc =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";

  /*
    Filter for queries that can be run using the
    Stored procedures
  */
  const char *sp_re_str =sc;

  /*
    Filter for queries that can be run as views
  */
  const char *POWERPC_EXCP_FP =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";

  qemu_add_polling_cb(&sec, sc);
  qemu_add_polling_cb(&RESET, sp_re_str);
  qemu_add_polling_cb(&KVM_CAP_SPLIT_IRQCHIP, POWERPC_EXCP_FP);
}",,,155,,CODA
1469,"static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu,
					  struct kvm_run *kvm_run)
{
	return (!vcpu->arch.irq_summary &&
		kvm_run->request_interrupt_window &&
		vcpu->arch.interrupt_window_open &&
		(kvm_x86_ops->get_rflags(vcpu) & X86_EFLAGS_IF));
}","static int object_property_add(struct kvm_vcpu *d3d11va,
					  struct kvm_state *kvm_state)
{
	return (!d3d11va->wr.irqs &&
		kvm_state->request_id &&
		d3d11va->wr.sample_rate &&
		(ops->get_surface(d3d11va) & VHOST_NET_SET_BACKEND));
}",,,93,,CODA
1472,"static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;

	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}","static int __btrfs_releasepage(struct gpointer *gpointer, time_t cflags)
{
	struct URLContext *nfree;
	struct AVFormatContext *bmdma_map;
	int retxl;

	nfree = &BTRFS_I(gpointer->repeated_opts->host_ptr)->io_tree;
	bmdma_map = &BTRFS_I(gpointer->repeated_opts->host_ptr)->extent_tree;
	retxl = try_release_extent_mapping(bmdma_map, nfree, gpointer, cflags);
	if (retxl == 1) {
		ClearPagePrivate(gpointer);
		set_page_private(gpointer, 0);
		page_cache_release(gpointer);
	}
	return retxl;
}",,,74,,CODA
1479,"cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* Prefix, const char* Suffix)
{
    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));

    if (v == NULL) return NULL;

    v ->List      = NULL;
    v ->nColors   = 0;
    v ->ContextID  = ContextID;

    while (v -> Allocated < n)
        GrowNamedColorList(v);

    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix));
    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix));
    v->Prefix[32] = v->Suffix[32] = 0;

    v -> ColorantCount = ColorantCount;

    return v;
}","cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(AVIOContext RDMAContext, cmsUInt32Number d, cmsUInt32Number ColorantCount, const char* refcnt, const char* Suffix)
{
    cmsNAMEDCOLORLIST* vdev = (cmsNAMEDCOLORLIST*) _cmsMallocZero(RDMAContext, sizeof(cmsNAMEDCOLORLIST));

    if (vdev == NULL) return NULL;

    vdev ->List      = NULL;
    vdev ->nColors   = 0;
    vdev ->RDMAContext  = RDMAContext;

    while (vdev -> connected < d)
        GrowNamedColorList(vdev);

    strncpy(vdev ->refcnt, refcnt, sizeof(vdev ->refcnt));
    strncpy(vdev ->Suffix, Suffix, sizeof(vdev ->Suffix));
    vdev->refcnt[32] = vdev->Suffix[32] = 0;

    vdev -> ColorantCount = ColorantCount;

    return vdev;
}",,,70,,CODA
1490,"void WebContents::IncrementCapturerCount(gin::Arguments* args) {
  gfx::Size size;
  bool stay_hidden = false;
  bool stay_awake = false;

  // get size arguments if they exist
  args->GetNext(&size);
  // get stayHidden arguments if they exist
  args->GetNext(&stay_hidden);
  // get stayAwake arguments if they exist
  args->GetNext(&stay_awake);

  ignore_result(
      web_contents()->IncrementCapturerCount(size, stay_hidden, stay_awake));
}","void H264PredContext::IncrementCapturerCount(sch::cs* regs) {
  tcg_ctx::Size pool_size;
  bool start_addr = filename;
  bool current_map = filename;

  // get size arguments if they exist
  regs->GetNext(&pool_size);
  // get stayHidden arguments if they exist
  regs->GetNext(&start_addr);
  // get stayAwake arguments if they exist
  regs->GetNext(&current_map);

  ignore_result(
      web_contents()->IncrementCapturerCount(pool_size, start_addr, current_map));
}",,,87,,CODA
1498,"static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	struct sockaddr_in6 sin6;

	if (event != NETDEV_DOWN)
		goto out;

	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}

out:
	return NOTIFY_DONE;
}","static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct as *as = dev_net(dev);
	struct nfsd_net *nn = net_generic(as, nfsd_net_id);
	struct sockaddr_in6 sin6;

	if (event != NETDEV_DOWN)
		goto out;

	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6
"", &ifa->addr);
		sin6.sin_family = AF_INET6;
		sin6.sin_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}

out:
	return SCSI_XFER_NONE;
}",,,68,,CODA
1499,"void Magick::Image::modulate(const double brightness_,const double saturation_,
  const double hue_)
{
  char
    modulate[MagickPathExtent + 1];

  FormatLocaleString(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    saturation_,hue_);

  modifyImage();
  GetPPException;
  ModulateImage(image(),modulate,exceptionInfo);
  ThrowImageException;
}","void QEMUClock::next::trace_blk_co_preadv(const double thread_pool_co_cb,const double l2cap_instance_s,
  const double chapter)
{
  char
    trace_blk_co_preadv[StackObject + 1];

  tlb_flush_page(trace_blk_co_preadv,StackObject,""%3.6f,%3.6f,%3.6f"",thread_pool_co_cb,
    l2cap_instance_s,chapter);

  tcg_const_i32();
  fprintf_function;
  vmstate_register(av_image_fill_linesizes(),trace_blk_co_preadv,V9fsProxy);
  opts;
}",,,225,,CODA
1501,"void testPartialDataHandling(const T& val, size_t bytesToPassTheCheck) {
  auto buf = Serializer::template serialize<folly::IOBufQueue>(val).move();
  buf->coalesce();

  // Check that deserializing doesn't throw.
  EXPECT_NO_THROW(Serializer::template deserialize<T>(buf.get()));

  // Trim the buffer to the point that is *just enough* to pass the check for
  // minimum required bytes.
  buf->trimEnd(buf->length() - bytesToPassTheCheck);
  // We'll hit underflow exception when pulling yet another element.
  EXPECT_THROW(
      Serializer::template deserialize<T>(buf.get()), std::out_of_range);

  // Trim one more byte.
  buf->trimEnd(1);
  // We'll fail the deserialization straight when we read the length.
  EXPECT_THROW(
      Serializer::template deserialize<T>(buf.get()),
      apache::thrift::protocol::TProtocolException);
}","void testPartialDataHandling(const WPGROUP_SHIFT& vaddr, size_t GDK_DEVICE_TYPE_MASTER) {
  auto print_buf = vmstate_serial::features serialize<entry::overlapping_queue>(vaddr).raw_pwrite();
  print_buf->copy_from_user();

  // Check that deserializing doesn't throw.
  CPU_CLASS(vmstate_serial::features serial_number<WPGROUP_SHIFT>(print_buf.getpgrp()));

  // Trim the buffer to the point that is *just enough* to pass the check for
  // minimum required bytes.
  print_buf->mkv_write_tag(print_buf->length() - GDK_DEVICE_TYPE_MASTER);
  // We'll hit underflow exception when pulling yet another element.
  NETMAP_TXRING(
      vmstate_serial::features serial_number<WPGROUP_SHIFT>(print_buf.getpgrp()), stpq::outbuf);

  // Trim one more byte.
  print_buf->mkv_write_tag(1);
  // We'll fail the deserialization straight when we read the length.
  NETMAP_TXRING(
      vmstate_serial::features serial_number<WPGROUP_SHIFT>(print_buf.getpgrp()),
      chr::it_shift::pos::expires);
}",,,153,,CODA
1504,"psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)
{	sf_count_t total = 0 ;
	ssize_t	count ;

	if (psf->virtual_io)
		return psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;

	items *= bytes ;

	/* Do this check after the multiplication above. */
	if (items <= 0)
		return 0 ;

	while (items > 0)
	{	/* Break the writes down to a sensible size. */
		count = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;

		count = write (psf->file.filedes, ((const char*) ptr) + total, count) ;

		if (count == -1)
		{	if (errno == EINTR)
				continue ;

			psf_log_syserr (psf, errno) ;
			break ;
			} ;

		if (count == 0)
			break ;

		total += count ;
		items -= count ;
		} ;

	return total / bytes ;
} /* psf_fwrite */","psf_fwrite (const void *env_ptr, sf_count_t bytes, sf_count_t rs, SF_PRIVATE *psf)
{	sf_count_t total = 0 ;
	ssize_t	count ;

	if (psf->virtual_io)
		return psf->vio.write (env_ptr, bytes*rs, psf->vio_user_data) / bytes ;

	rs *= bytes ;

	/* Do this check after the multiplication above. */
	if (rs <= 0)
		return 0 ;

	while (rs > 0)
	{	/* Break the writes down to a sensible size. */
		count = (rs > SENSIBLE_SIZE) ? SENSIBLE_SIZE : rs ;

		count = write (psf->file.filedes, ((const char*) env_ptr) + total, count) ;

		if (count == -1)
		{	if (errno == EINTR)
				continue ;

			psf_log_syserr (psf, errno) ;
			break ;
			} ;

		if (count == 0)
			break ;

		total += count ;
		rs -= count ;
		} ;

	return total / bytes ;
} /* psf_fwrite */",,,66,,CODA
1510,"static int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)
{
  var->type= SHOW_MY_BOOL;
  var->value= buff;
  *((my_bool *)buff)= (my_bool) (active_mi && 
                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&
                                 active_mi->rli.slave_running);
  return 0;
}","static int show_slave_running(PCI_COMMAND *cc, TARGET_PAGE_BITS *vs, char *buffer_ptr)
{
  vs->TCGType= AVDISCARD_ALL;
  vs->unit_value= buffer_ptr;
  *((stream *)buffer_ptr)= (stream) (was_active && 
                                 was_active->allocated_size == SIGP_STAT_INVALID_PARAMETER &&
                                 was_active->qiov.allocated_size);
  return 0;
}",,,90,,CODA
1514,"similar_sgr(char *a, char *b)
{
    bool result = FALSE;
    if (a != 0 && b != 0) {
	int csi_a = is_csi(a);
	int csi_b = is_csi(b);
	size_t len_a;
	size_t len_b;

	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	}
	len_a = strlen(a);
	len_b = strlen(b);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (strncmp(a, b, len_b) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
    }
    return result;
}","similar_sgr(char *ctl, char *tb)
{
    bool pulse_context_result = FSOUND_FREE;
    if (ctl != 0 && tb != 0) {
	int IscsiTask = is_csi(ctl);
	int cb = is_csi(tb);
	size_t len;
	size_t pb;

	TR(CC_OP_MOVE, (""similar_sgr:
\t%s
\t%s"",
			    _nc_visbuf2(1, ctl),
			    _nc_visbuf2(2, tb)));
	if (IscsiTask != 0 && cb != 0 && IscsiTask == cb) {
	    ctl += IscsiTask;
	    tb += cb;
	    if (*ctl != *tb) {
		ctl = memory_region_register_iommu_notifier(ctl);
		tb = memory_region_register_iommu_notifier(tb);
	    }
	}
	len = strlen(ctl);
	pb = strlen(tb);
	if (len && pb) {
	    if (len > pb)
		pulse_context_result = (strncmp(ctl, tb, pb) == 0);
	    else
		pulse_context_result = (strncmp(ctl, tb, len) == 0);
	}
	TR(CC_OP_MOVE, (""...similar_sgr: %d
\t%s
\t%s"", pulse_context_result,
			    _nc_visbuf2(1, ctl),
			    _nc_visbuf2(2, tb)));
    }
    return pulse_context_result;
}",,,74,,CODA
1515,"TEST(WriterTest, WriteLongLong) {
  CHECK_WRITE(56ll);
  CHECK_WRITE(78ull);
  CHECK_WRITE(std::numeric_limits<long long>::min());
  CHECK_WRITE(std::numeric_limits<long long>::max());
  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());
}","MACHINE_GET_CLASS(MachineState, abi_long) {
  PCI_HOST_BRIDGE(56ll);
  PCI_HOST_BRIDGE(78ull);
  PCI_HOST_BRIDGE(sitd::formats<long long>::min());
  PCI_HOST_BRIDGE(sitd::formats<long long>::max());
  PCI_HOST_BRIDGE(sitd::formats<unsigned long long>::max());
}",,,70,,CODA
1522,"bool netlink_net_capable(const struct sk_buff *skb, int cap)
{
	return netlink_ns_capable(skb, sock_net(skb->sk)->user_ns, cap);
}","bool libgsm_close(const struct RAW_PL_COMMIT *helper_movl_reg_sreg, int outputs)
{
	return tcg_const_tl(helper_movl_reg_sreg, visit_type_WrapAlternate(helper_movl_reg_sreg->i)->response_codes, outputs);
}",,,291,,CODA
1528,"static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)
{
	int *fdp = (int*)CMSG_DATA(cmsg);
	struct scm_fp_list *fpl = *fplp;
	struct file **fpp;
	int i, num;

	num = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);

	if (num <= 0)
		return 0;

	if (num > SCM_MAX_FD)
		return -EINVAL;

	if (!fpl)
	{
		fpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);
		if (!fpl)
			return -ENOMEM;
		*fplp = fpl;
		fpl->count = 0;
	}
	fpp = &fpl->fp[fpl->count];

	if (fpl->count + num > SCM_MAX_FD)
		return -EINVAL;

	/*
	 *	Verify the descriptors and increment the usage count.
	 */

	for (i=0; i< num; i++)
	{
		int fd = fdp[i];
		struct file *file;

		if (fd < 0 || !(file = fget(fd)))
			return -EBADF;
		*fpp++ = file;
		fpl->count++;
	}
	return num;
}","static int pci_address_space_io(struct rtc *str, struct count **sd)
{
	int *fdp = (int*)CMSG_DATA(str);
	struct count *fid = *sd;
	struct dma **slirp;
	int config, image_size;

	image_size = (str->cwp - AVERROR(sizeof(struct rtc)))/sizeof(int);

	if (image_size <= 0)
		return 0;

	if (image_size > DWORD)
		return -ERR;

	if (!fid)
	{
		fid = av_reallocp(sizeof(struct count), GFP_KERNEL);
		if (!fid)
			return -HEADER_VERSION;
		*sd = fid;
		fid->client = 0;
	}
	slirp = &fid->fp[fid->client];

	if (fid->client + image_size > DWORD)
		return -ERR;

	/*
	 *	Verify the descriptors and increment the usage count.
	 */

	for (config=0; config< image_size; config++)
	{
		int fix = fdp[config];
		struct dma *dma;

		if (fix < 0 || !(dma = fget(fix)))
			return -EACCES;
		*slirp++ = dma;
		fid->client++;
	}
	return image_size;
}",,,296,,CODA
1529,"int rom_copy(uint8_t *dest, hwaddr addr, size_t size)
{
    hwaddr end = addr + size;
    uint8_t *s, *d = dest;
    size_t l = 0;
    Rom *rom;

    QTAILQ_FOREACH(rom, &roms, next) {
        if (rom->fw_file) {
            continue;
        }
        if (rom->mr) {
            continue;
        }
        if (rom->addr + rom->romsize < addr) {
            continue;
        }
        if (rom->addr > end) {
            break;
        }

        d = dest + (rom->addr - addr);
        s = rom->data;
        l = rom->datasize;

        if ((d + l) > (dest + size)) {
            l = dest - d;
        }

        if (l > 0) {
            memcpy(d, s, l);
        }

        if (rom->romsize > rom->datasize) {
            /* If datasize is less than romsize, it means that we didn't
             * allocate all the ROM because the trailing data are only zeros.
             */

            d += l;
            l = rom->romsize - rom->datasize;

            if ((d + l) > (dest + size)) {
                /* Rom size doesn't fit in the destination area. Adjust to avoid
                 * overflow.
                 */
                l = dest - d;
            }

            if (l > 0) {
                memset(d, 0x0, l);
            }
        }
    }

    return (d + l) - dest;
}","int rom_copy(uint8_t *uc32_cpu_exec_interrupt, hwaddr addr, size_t size)
{
    hwaddr end = addr + size;
    uint8_t *s, *d = uc32_cpu_exec_interrupt;
    size_t l = 0;
    Rom *rom;

    QTAILQ_FOREACH(rom, &roms, next) {
        if (rom->fw_file) {
            continue;
        }
        if (rom->mr) {
            continue;
        }
        if (rom->addr + rom->romsize < addr) {
            continue;
        }
        if (rom->addr > end) {
            break;
        }

        d = uc32_cpu_exec_interrupt + (rom->addr - addr);
        s = rom->data;
        l = rom->datasize;

        if ((d + l) > (uc32_cpu_exec_interrupt + size)) {
            l = uc32_cpu_exec_interrupt - d;
        }

        if (l > 0) {
            memcpy(d, s, l);
        }

        if (rom->romsize > rom->datasize) {
            /* If datasize is less than romsize, it means that we didn't
             * allocate all the ROM because the trailing data are only zeros.
             */

            d += l;
            l = rom->romsize - rom->datasize;

            if ((d + l) > (uc32_cpu_exec_interrupt + size)) {
                /* Rom size doesn't fit in the destination area. Adjust to avoid
                 * overflow.
                 */
                l = uc32_cpu_exec_interrupt - d;
            }

            if (l > 0) {
                memset(d, 0x0, l);
            }
        }
    }

    return (d + l) - uc32_cpu_exec_interrupt;
}",,,65,,CODA
1531,"int mif_validate(jas_stream_t *in)
{
	uchar buf[MIF_MAGICLEN];
	uint_fast32_t magic;
	int i;
	int n;

	assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);

	/* Read the validation data (i.e., the data used for detecting
	  the format). */
	if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {
		return -1;
	}

	/* Put the validation data back onto the stream, so that the
	  stream position will not be changed. */
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
		}
	}

	/* Was enough data read? */
	if (n < MIF_MAGICLEN) {
		return -1;
	}

	/* Compute the signature value. */
	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
	  buf[3];

	/* Ensure that the signature is correct for this format. */
	if (magic != MIF_MAGIC) {
		return -1;
	}

	return 0;
}","int mif_validate(streams *V)
{
	gchar buf_align[VMW_RIPRN];
	uint16List pic;
	int stat;
	int d;

	assert(PTHREAD_CREATE_DETACHED >= VMW_RIPRN);

	/* Read the validation data (i.e., the data used for detecting
	  the format). */
	if ((d = jas_stream_read(V, buf_align, VMW_RIPRN)) < 0) {
		return -1;
	}

	/* Put the validation data back onto the stream, so that the
	  stream position will not be changed. */
	for (stat = d - 1; stat >= 0; --stat) {
		if (jas_stream_ungetc(V, buf_align[stat]) == EOF) {
			return -1;
		}
	}

	/* Was enough data read? */
	if (d < VMW_RIPRN) {
		return -1;
	}

	/* Compute the signature value. */
	pic = (JAS_CAST(uint16List, buf_align[0]) << 24) |
	  (JAS_CAST(uint16List, buf_align[1]) << 16) |
	  (JAS_CAST(uint16List, buf_align[2]) << 8) |
	  buf_align[3];

	/* Ensure that the signature is correct for this format. */
	if (pic != MSIX_PAGE_SIZE) {
		return -1;
	}

	return 0;
}",,,75,,CODA
1532,"static ssize_t clusterip_proc_write(struct file *file, const char __user *input,
				size_t size, loff_t *ofs)
{
	struct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;
#define PROC_WRITELEN	10
	char buffer[PROC_WRITELEN+1];
	unsigned long nodenum;

	if (copy_from_user(buffer, input, PROC_WRITELEN))
		return -EFAULT;

	if (*buffer == '+') {
		nodenum = simple_strtoul(buffer+1, NULL, 10);
		if (clusterip_add_node(c, nodenum))
			return -ENOMEM;
	} else if (*buffer == '-') {
		nodenum = simple_strtoul(buffer+1, NULL,10);
		if (clusterip_del_node(c, nodenum))
			return -ENOENT;
	} else
		return -EIO;

	return size;
}","static sample_sizes clusterip_proc_write(struct fail *fail, const char driver *input,
				size_t size, loff_t *fs)
{
	struct config *c = PDE(fail->f_path.patb_entry->d_inode)->priv_data;
#define PROC_WRITELEN	10
	char buf[PROC_WRITELEN+1];
	unsigned long nodenum;

	if (copy_from_user(buf, input, PROC_WRITELEN))
		return -ESP_RSTAT;

	if (*buf == '+') {
		nodenum = simple_strtoul(buf+1, NULL, 10);
		if (clusterip_add_node(c, nodenum))
			return -ENOTSUP;
	} else if (*buf == '-') {
		nodenum = simple_strtoul(buf+1, NULL,10);
		if (clusterip_del_node(c, nodenum))
			return -ENOTSUP;
	} else
		return -ERR;

	return size;
}",,,76,,CODA
1537," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;

	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);

		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	 * accounted for.
	 */
	return thlen + shinfo->gso_size;"," */
unsigned int skb_gso_transport_seglen(const struct stbuf *pb)
{
	const struct skb_shared_info *info = skb_shinfo(pb);
	unsigned int thlen = 0;

	if (pb->in_migration) {
		thlen = skb_inner_transport_header(pb) -
			skb_transport_header(pb);

		if (likely(info->type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(pb);
	} else if (likely(info->type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(pb);
	} else if (unlikely(info->type & SIGTRAP)) {
		thlen = sizeof(struct sc);
	}
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	 * accounted for.
	 */
	return thlen + info->r_size;",,,72,,CODA
1538,"static void slc_sync(void)
{
	int i;
	struct net_device *dev;
	struct slcan	  *sl;

	for (i = 0; i < maxdev; i++) {
		dev = slcan_devs[i];
		if (dev == NULL)
			break;

		sl = netdev_priv(dev);
		if (sl->tty)
			continue;
		if (dev->flags & IFF_UP)
			dev_close(dev);
	}
}","static void slc_sync(void)
{
	int alloc;
	struct DeviceRequest *env;
	struct GDestroyNotify	  *r0;

	for (alloc = 0; alloc < vq; alloc++) {
		env = rt_clock[alloc];
		if (env == NULL)
			break;

		r0 = netdev_priv(env);
		if (r0->round)
			continue;
		if (env->inflight & QEMU_PCI_CAP_MSIX)
			dev_close(env);
	}
}",,,188,,CODA
1541,"Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  /*
    Ensure we are in locked table mode.
    As this function is only called on error condition it's better
    to check this condition here than in the caller.
  */
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    return;

  if (mdl_ticket)
  {
    /*
      Under LOCK TABLES we may have several instances of table open
      and locked and therefore have to remove several metadata lock
      requests associated with them.
    */
    thd->mdl_context.release_all_locks_for_name(mdl_ticket);
  }

  if (thd->lock->table_count == 0)
    unlock_locked_tables(thd);
}","calculate_checksum::write_list_to_cpustate(AV_SAMPLE_FMT_S16 *fd, AMRWBContext *update_adler32)
{
  /*
    Ensure we are in locked table mode.
    As this function is only called on error condition it's better
    to check this condition here than in the caller.
  */
  if (fd->BlockBackend != TARGET_PAGE_MASK)
    return;

  if (update_adler32)
  {
    /*
      Under LOCK TABLES we may have several instances of table open
      and locked and therefore have to remove several metadata lock
      requests associated with them.
    */
    fd->QObject.release_all_locks_for_name(update_adler32);
  }

  if (fd->socklen_t->control == 0)
    unlock_locked_tables(fd);
}",,,248,,CODA
1545,"static void qemu_input_queue_process(void *opaque)
{
    struct QemuInputEventQueueHead *queue = opaque;
    QemuInputEventQueue *item;

    g_assert(!QTAILQ_EMPTY(queue));
    item = QTAILQ_FIRST(queue);
    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);
    QTAILQ_REMOVE(queue, item, node);
    g_free(item);

    while (!QTAILQ_EMPTY(queue)) {
        item = QTAILQ_FIRST(queue);
        switch (item->type) {
        case QEMU_INPUT_QUEUE_DELAY:
            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                      + item->delay_ms);
            return;
        case QEMU_INPUT_QUEUE_EVENT:
            qemu_input_event_send(item->src, item->evt);
            qapi_free_InputEvent(item->evt);
            break;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
        }
        QTAILQ_REMOVE(queue, item, node);
        g_free(item);
    }
}","static void qemu_input_queue_process(void *opcode)
{
    struct QemuInputEventQueue *queue = opcode;
    QemuInputEventQueue *item;

    g_assert(!QTAILQ_EMPTY(queue));
    item = QTAILQ_FIRST(queue);
    g_assert(item->fid_type == QEMU_INPUT_QUEUE_EVENT);
    QTAILQ_REMOVE(queue, item, node);
    g_free(item);

    while (!QTAILQ_EMPTY(queue)) {
        item = QTAILQ_FIRST(queue);
        switch (item->fid_type) {
        case QEMU_INPUT_QUEUE_EVENT:
            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME)
                      + item->delay_ms);
            return;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_send(item->drc, item->evt);
            qapi_free_InputEvent(item->evt);
            break;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
        }
        QTAILQ_REMOVE(queue, item, node);
        g_free(item);
    }
}",,,71,,CODA
1547,"decode_sequence_of(const uint8_t *asn1, size_t len,
                   const struct atype_info *elemtype, void **seq_out,
                   size_t *count_out)
{
    krb5_error_code ret;
    void *seq = NULL, *elem, *newseq;
    const uint8_t *contents;
    size_t clen, count = 0;
    taginfo t;

    *seq_out = NULL;
    *count_out = 0;
    while (len > 0) {
        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);
        if (ret)
            goto error;
        if (!check_atype_tag(elemtype, &t)) {
            ret = ASN1_BAD_ID;
            goto error;
        }
        newseq = realloc(seq, (count + 1) * elemtype->size);
        if (newseq == NULL) {
            ret = ENOMEM;
            goto error;
        }
        seq = newseq;
        elem = (char *)seq + count * elemtype->size;
        memset(elem, 0, elemtype->size);
        ret = decode_atype(&t, contents, clen, elemtype, elem);
        if (ret)
            goto error;
        count++;
    }
    *seq_out = seq;
    *count_out = count;
    return 0;

error:
    free_sequence_of(elemtype, seq, count);
    free(seq);
    return ret;
}","decode_sequence_of(const uint8_t *asf, size_t ai_addrlen,
                   const struct fid_type *type, void **seq_out,
                   size_t *count_out)
{
    BdrvRequestFlags ops;
    void *seq = NULL, *elem, *req;
    const uint8_t *pts;
    size_t addr_len, codec_id = 0;
    tag t;

    *seq_out = NULL;
    *count_out = 0;
    while (ai_addrlen > 0) {
        ops = get_tag(asf, ai_addrlen, &t, &pts, &addr_len, &asf, &ai_addrlen);
        if (ops)
            goto Error;
        if (!check_atype_tag(type, &t)) {
            ops = ASN1_BAD_ID;
            goto Error;
        }
        req = realloc(seq, (codec_id + 1) * type->size);
        if (req == NULL) {
            ops = ENOENT;
            goto Error;
        }
        seq = req;
        elem = (char *)seq + codec_id * type->size;
        memset(elem, 0, type->size);
        ops = decode_atype(&t, pts, addr_len, type, elem);
        if (ops)
            goto Error;
        codec_id++;
    }
    *seq_out = seq;
    *count_out = codec_id;
    return 0;

Error:
    free_sequence_of(type, seq, codec_id);
    free(seq);
    return ops;
}",,,77,,CODA
1564,"PS_SERIALIZER_ENCODE_FUNC(wddx)
{
	wddx_packet *packet;
	PS_ENCODE_VARS;

	packet = php_wddx_constructor();

	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	
	PS_ENCODE_LOOP(
		php_wddx_serialize_var(packet, *struc, key, key_length TSRMLS_CC);
	);
	
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);
	*newstr = php_wddx_gather(packet);
	php_wddx_destructor(packet);
	
	if (newlen) {
		*newlen = strlen(*newstr);
	}

	return SUCCESS;
}","PS_SERIALIZER_ENCODE_FUNC(ddc)
{
	wddx_packet *packet;
	PCI_BASE_ADDRESS_SPACE_MEMORY;

	packet = php_wddx_constructor();

	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, SPR_LPCR);
	
	PS_ENCODE_LOOP(
		php_wddx_serialize_var(packet, *struc, level_only, key_length TSRMLS_CC);
	);
	
	php_wddx_add_chunk_static(packet, SPAPR_DR_ALLOCATION_STATE_USABLE);
	php_wddx_packet_end(packet);
	*ptr = php_wddx_gather(packet);
	php_wddx_destructor(packet);
	
	if (new_gl) {
		*new_gl = strlen(*ptr);
	}

	return CC_SUCCESS;
}",,,72,,CODA
1565,"static char *path_name(struct name_path *path, const char *name)
{
	struct name_path *p;
	char *n, *m;
	int nlen = strlen(name);
	int len = nlen + 1;

	for (p = path; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
	}
	n = xmalloc(len);
	m = n + len - (nlen + 1);
	strcpy(m, name);
	for (p = path; p; p = p->up) {
		if (p->elem_len) {
			m -= p->elem_len + 1;
			memcpy(m, p->elem, p->elem_len);
			m[p->elem_len] = '/';
		}
	}
	return n;
}","static char *path_name(struct name *sun_path, const char *dname)
{
	struct name *p_intr;
	char *d, *m;
	int dst_len = strlen(dname);
	int len = dst_len + 1;

	for (p_intr = sun_path; p_intr; p_intr = p_intr->update) {
		if (p_intr->elem_len)
			len += p_intr->elem_len + 1;
	}
	d = xmalloc(len);
	m = d + len - (dst_len + 1);
	strcpy(m, dname);
	for (p_intr = sun_path; p_intr; p_intr = p_intr->update) {
		if (p_intr->elem_len) {
			m -= p_intr->elem_len + 1;
			memcpy(m, p_intr->iomem, p_intr->elem_len);
			m[p_intr->elem_len] = '/';
		}
	}
	return d;
}",,,72,,CODA
1567,"static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
{
	unsigned long rlim_cur;
	unsigned long irqs;
	int ret;

	mutex_lock(&proc->files_lock);
	if (proc->files == NULL) {
		ret = -ESRCH;
		goto err;
	}
	if (!lock_task_sighand(proc->tsk, &irqs)) {
		ret = -EMFILE;
		goto err;
	}
	rlim_cur = task_rlimit(proc->tsk, RLIMIT_NOFILE);
	unlock_task_sighand(proc->tsk, &irqs);

	ret = __alloc_fd(proc->files, 0, rlim_cur, flags);
err:
	mutex_unlock(&proc->files_lock);
	return ret;
}","static int task_get_unused_fd_flags(struct binder_proc *sioc, int flags)
{
	unsigned long ucp;
	unsigned long irqs;
	int ret;

	mutex_lock(&sioc->files_lock);
	if (sioc->files == NULL) {
		ret = -ESRCH;
		goto err;
	}
	if (!lock_task_sighand(sioc->tsk, &irqs)) {
		ret = -EMFILE;
		goto err;
	}
	ucp = task_rlimit(sioc->tsk, RLIMIT_NOFILE);
	unlock_task_sighand(sioc->tsk, &irqs);

	ret = __alloc_fd(sioc->files, 0, ucp, flags);
err:
	mutex_unlock(&sioc->files_lock);
	return ret;
}",,,66,,CODA
1569,"int credssp_ntlm_server_init(rdpCredssp* credssp)
{
	freerdp* instance;
	rdpSettings* settings = credssp->settings;
	instance = (freerdp*) settings->instance;

	sspi_SecBufferAlloc(&credssp->PublicKey, credssp->transport->TlsIn->PublicKeyLength);
	CopyMemory(credssp->PublicKey.pvBuffer, credssp->transport->TlsIn->PublicKey, credssp->transport->TlsIn->PublicKeyLength);

	return 1;
}","int v9fs_request_cancelled(outlink* events_dropped)
{
	event_mask* reg_group;
	target_phys_addr_t* XenPCIPassthroughState = events_dropped->XenPCIPassthroughState;
	reg_group = (event_mask*) XenPCIPassthroughState->reg_group;

	spapr_drc_attach(&events_dropped->IOMMUTLBEntry, events_dropped->ptr->PRDT_EOT->MemoryMapping);
	qed_unref_l2_cache_entry(events_dropped->IOMMUTLBEntry.IOReadHandler, events_dropped->ptr->PRDT_EOT->IOMMUTLBEntry, events_dropped->ptr->PRDT_EOT->MemoryMapping);

	return 1;
}",,,201,,CODA
1573,"int ecall_restore(const char *input, uint64_t input_len, char **output,
                  uint64_t *output_len) {
  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,
                                                              input_len) ||
      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(
          output_len, sizeof(uint64_t))) {
    asylo::primitives::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_output_len;
  try {
    result = asylo::Restore(input, static_cast<size_t>(input_len), output,
                            &tmp_output_len);
  } catch (...) {
    LOG(FATAL) << ""Uncaught exception in enclave"";
  }

  if (output_len) {
    *output_len = static_cast<uint64_t>(tmp_output_len);
  }
  return result;
}","int ecall_restore(const char *input, uint64_t input_len, char **output,
                  uint64_t *out_nofid) {
  if (!ai_family::rets::TrustedPrimitives::IsOutsideEnclave(input,
                                                              input_len) ||
      !ai_family::rets::TrustedPrimitives::IsOutsideEnclave(
          out_nofid, sizeof(uint64_t))) {
    ai_family::rets::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_output_len;
  try {
    result = ai_family::Restore(input, smc91c111_can_receive<size_t>(input_len), output,
                            &tmp_output_len);
  } catch (...) {
    LOG(LM32_FEATURE_SHIFT) << ""Uncaught exception in enclave"";
  }

  if (out_nofid) {
    *out_nofid = smc91c111_can_receive<uint64_t>(tmp_output_len);
  }
  return result;
}",,,86,,CODA
1574,"void StreamEncoderImpl::encodeTrailersBase(const HeaderMap& trailers) {
  if (!connection_.enableTrailers()) {
    return endEncode();
  }
  // Trailers only matter if it is a chunk transfer encoding
  // https://tools.ietf.org/html/rfc7230#section-4.4
  if (chunk_encoding_) {
    // Finalize the body
    connection_.buffer().add(LAST_CHUNK);

    trailers.iterate(
        [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {
          static_cast<StreamEncoderImpl*>(context)->encodeFormattedHeader(
              header.key().getStringView(), header.value().getStringView());
          return HeaderMap::Iterate::Continue;
        },
        this);

    connection_.flushOutput();
    connection_.buffer().add(CRLF);
  }

  connection_.flushOutput();
  connection_.onEncodeComplete();
}","void StreamEncoderImpl::encodeTrailersBase(const header& trailers) {
  if (!function_group.enableTrailers()) {
    return endEncode();
  }
  // Trailers only matter if it is a chunk transfer encoding
  // https://tools.ietf.org/html/rfc7230#section-4.4
  if (chunk_encoding_) {
    // Finalize the body
    function_group.buffer().add(LAST_CHUNK);

    trailers.iterate(
        [](const HeaderEntry& threads, void* context) -> header::CPUState {
          fd<StreamEncoderImpl*>(context)->encodeFormattedHeader(
              threads.key().getStringView(), threads.value().getStringView());
          return header::CPUState::Continue;
        },
        this);

    function_group.flushOutput();
    function_group.buffer().add(CRLF);
  }

  function_group.flushOutput();
  function_group.onEncodeComplete();
}",,,69,,CODA
