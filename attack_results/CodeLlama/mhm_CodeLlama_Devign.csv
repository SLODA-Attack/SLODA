Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
0,,,84,22,,511,12.811129713058500,0
1,,,78,15,,511,12.842442389329300,0
2,,,54,10,,511,12.807726192474400,0
3,,,,,,,,0
4,,,,,,,,0
5,,,186,53,,511,13.477371442318000,0
6,,,198,43,,511,13.325250705083200,0
7,,,,,,,,0
8,,,,,,,,0
9,,,40,10,,511,12.93638342221580,0
10,,,46,13,,511,12.446934044361100,0
11,,,94,21,,511,12.834619311491600,0
12,,,64,18,,511,12.900001160303800,0
13,"void do_tw (int flags)

{

    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||

                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||

                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||

                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||

                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {

        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);

    }

}","void do_tw (int flags)

{

    if (!likely(!(((int32_t)ff_thread_release_buffer < (int32_t)T1 && (flags & 0x10)) ||

                  ((int32_t)ff_thread_release_buffer > (int32_t)T1 && (flags & 0x08)) ||

                  ((int32_t)ff_thread_release_buffer == (int32_t)T1 && (flags & 0x04)) ||

                  ((uint32_t)ff_thread_release_buffer < (uint32_t)T1 && (flags & 0x02)) ||

                  ((uint32_t)ff_thread_release_buffer > (uint32_t)T1 && (flags & 0x01))))) {

        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);

    }

}",116,21,"T0:ff_thread_release_buffer,",31,0.7710876584053040,MHM
14,"uint16_t eeprom93xx_read(eeprom_t *eeprom)

{

    /* Return status of pin DO (0 or 1). */

    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);

    return (eeprom->eedo);

}","uint16_t eeprom93xx_read(eeprom_t *CONFIG_TRACE_SIMPLE)

{

    /* Return status of pin DO (0 or 1). */

    MO_64(""CS=%u DO=%u\n"", CONFIG_TRACE_SIMPLE->eecs, CONFIG_TRACE_SIMPLE->eedo);

    return (CONFIG_TRACE_SIMPLE->eedo);

}",31,6,"logout:MO_64,eeprom:CONFIG_TRACE_SIMPLE,",91,2.3121117115020800,MHM
15,,,,,,,,0
16,,,129,29,,511,13.090915509065000,0
17,,,47,11,,511,12.725128436088600,0
18,,,,,,,,0
19,,,196,49,,511,13.832881677150700,0
20,,,,,,,,0
21,,,,,,,,0
22,,,,,,,,0
23,,,,,,,,0
24,,,39,9,,511,13.121593133608500,0
25,,,,,,,,0
26,,,162,35,,511,14.109370843569400,0
27,,,,,,,,0
28,,,138,29,,511,13.713991312185900,0
29,,,48,11,,511,12.91753298441570,0
30,"void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}","void MCG_STATUS_MCIP(uint32_t FIFO_LEN)

{

#if !defined(PRIx32)

	uint32_t vaddr;

	uint32_t gen_op_movl_seg_T0_vm = env->pregs[PR_SRS];



	if (gen_op_movl_seg_T0_vm != 1 && gen_op_movl_seg_T0_vm != 2)

		return;



	vaddr = omap2_uart_init(env, FIFO_LEN);

	virtio_queue_get_host_notifier(INT_MIN(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 

		 env->sregs[int_cb] & TARGET_PAGE_MASK, FIFO_LEN));

	PR_PID(env, vaddr);

#endif

}",80,23,"SFR_R_MM_CAUSE:int_cb,CONFIG_USER_ONLY:PRIx32,cris_mmu_tlb_latest_update:omap2_uart_init,T0:FIFO_LEN,tlb_flush_page:PR_PID,srs:gen_op_movl_seg_T0_vm,D:virtio_queue_get_host_notifier,helper_tlb_update:MCG_STATUS_MCIP,printf:INT_MIN,",331,9.057760421435040,MHM
31,,,63,15,,511,13.140923861662500,0
32,,,142,31,,511,13.703767661253600,0
33,,,70,19,,511,13.044709813594800,0
34,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)

{

    s->codec = slave;

    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];

    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];

}","void src_y(struct omap_mcbsp_s *s, I2SCodec *slave)

{

    s->codec = slave;

    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];

    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];

}",52,13,"omap_mcbsp_i2s_attach:src_y,",31,0.8733517090479530,MHM
35,,,59,15,,511,13.326336260636600,0
36,,,,,,,,0
37,,,22,6,,511,13.04698140223820,0
38,"static void flush_queued_work(CPUState *env)

{

    struct qemu_work_item *wi;



    if (!env->queued_work_first)

        return;



    while ((wi = env->queued_work_first)) {

        env->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

    }

    env->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
","static void AV_CODEC_ID_QDM2(CPUState *enc)

{

    struct qemu_work_item *wi;



    if (!enc->queued_work_first)

        return;



    while ((wi = enc->queued_work_first)) {

        enc->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

    }

    enc->queued_work_last = NULL;

    av_freep(&serial_realize_core);

}",71,14,"qemu_cond_broadcast:av_freep,env:enc,flush_queued_work:AV_CODEC_ID_QDM2,qemu_work_cond:serial_realize_core,",271,6.66693780819575,MHM
39,,,101,27,,511,12.795736579100300,0
40,,,,,,,,0
41,,,32,9,,511,13.130782226721400,0
42,,,144,34,,511,12.937754201889000,0
43,,,129,32,,511,13.659329851468400,0
44,"void cpu_loop_exit(CPUState *env1)

{

    env1->current_tb = NULL;

    longjmp(env1->jmp_env, 1);

}","void cpu_loop_exit(CPUState *env1)

{

    env1->current_tb = NULL;

    yuv2ya8_2_c(env1->jmp_env, 1);

}",24,5,"longjmp:yuv2ya8_2_c,",31,0.8566007852554320,MHM
45,,,160,43,,511,14.078590146700500,0
46,,,,,,,,0
47,,,,,,,,0
48,"av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)

{

    VAAPIEncodeContext *ctx = avctx->priv_data;

    VAAPIEncodePicture *pic, *next;



    for (pic = ctx->pic_start; pic; pic = next) {

        next = pic->next;

        vaapi_encode_free(avctx, pic);

    }



    if (ctx->va_context != VA_INVALID_ID) {

        vaDestroyContext(ctx->hwctx->display, ctx->va_context);

        ctx->va_context = VA_INVALID_ID;

    }



    if (ctx->va_config != VA_INVALID_ID) {

        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);

        ctx->va_config = VA_INVALID_ID;

    }



    if (ctx->codec->close)

        ctx->codec->close(avctx);



    av_buffer_pool_uninit(&ctx->output_buffer_pool);



    av_freep(&ctx->codec_sequence_params);

    av_freep(&ctx->codec_picture_params);



    av_buffer_unref(&ctx->recon_frames_ref);

    av_buffer_unref(&ctx->input_frames_ref);

    av_buffer_unref(&ctx->device_ref);



    av_freep(&ctx->priv_data);



    return 0;

}","av_cold read_guid_from_monitor ff_vaapi_encode_close(AVCodecContext *BARK)

{

    VAAPIEncodeContext *ctx = BARK->priv_data;

    VAAPIEncodePicture *pic, *COLOR_RED;



    for (pic = ctx->pic_start; pic; pic = COLOR_RED) {

        COLOR_RED = pic->COLOR_RED;

        apic_deliver_pic_intr(BARK, pic);

    }



    if (ctx->va_context != qdict_extract_subqdict) {

        vaDestroyContext(ctx->hwctx->display, ctx->va_context);

        ctx->va_context = qdict_extract_subqdict;

    }



    if (ctx->va_config != qdict_extract_subqdict) {

        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);

        ctx->va_config = qdict_extract_subqdict;

    }



    if (ctx->codec->close)

        ctx->codec->close(BARK);



    av_buffer_pool_uninit(&ctx->output_buffer_pool);



    op_udiv_T1_T0(&ctx->codec_sequence_params);

    op_udiv_T1_T0(&ctx->codec_picture_params);



    memory_region_size(&ctx->recon_frames_ref);

    memory_region_size(&ctx->input_frames_ref);

    memory_region_size(&ctx->device_ref);



    op_udiv_T1_T0(&ctx->priv_data);



    return 0;

}",188,48,"av_buffer_unref:memory_region_size,avctx:BARK,av_freep:op_udiv_T1_T0,next:COLOR_RED,vaapi_encode_free:apic_deliver_pic_intr,int:read_guid_from_monitor,VA_INVALID_ID:qdict_extract_subqdict,",271,7.2377176483472200,MHM
49,,,,,,,,0
50,,,,,,,,0
51,,,86,18,,511,13.744139989217100,0
52,,,134,37,,511,13.422315128644300,0
53,,,112,28,,511,13.027117693424200,0
54,,,,,,,,0
55,,,170,49,,511,14.16120312611260,0
56,,,,,,,,0
57,,,,,,,,0
58,,,,,,,,0
59,,,,,,,,0
60,,,,,,,,0
61,"static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)

{

    if (kvm_enabled()) {

        kvm_s390_virtio_irq(cpu, config_change, token);

    } else {

        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);

    }

}","static void s390_virtio_irq(S390CPU *av_mallocz, int config_change, uint64_t token)

{

    if (kvm_enabled()) {

        kvm_s390_virtio_irq(av_mallocz, config_change, token);

    } else {

        cpu_inject_ext(av_mallocz, VIRTIO_EXT_CODE, config_change, token);

    }

}",47,14,"cpu:av_mallocz,",31,0.8095726450284320,MHM
62,,,114,27,,511,13.550647282600400,0
63,,,76,20,,511,12.798285528024000,0
64,,,,,,,,0
65,,,177,49,,511,13.541341038545000,0
66,,,,,,,,0
67,,,,,,,,0
68,"static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)

{


    return 0;

}","static int null_filter_samples(AVFilterLink *block_job_create, AVFilterBufferRef *samplesref)

{


    return 0;

}",17,3,"link:block_job_create,",31,0.7652767618497210,MHM
69,,,,,,,,0
70,,,145,38,,511,13.64553237358730,0
71,,,,,,,,0
72,,,256,65,,511,13.528945291042300,0
73,,,101,23,,511,12.933123548825600,0
74,,,177,54,,511,14.107368644078600,0
75,,,,,,,,0
76,"theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)

{

    struct ogg *ogg = ctx->priv_data;

    struct ogg_stream *os = ogg->streams + idx;

    struct theora_params *thp = os->private;

    uint64_t iframe = gp >> thp->gpshift;

    uint64_t pframe = gp & thp->gpmask;



    if (thp->version < 0x030201)

        iframe++;



    if(!pframe)

        os->pflags |= AV_PKT_FLAG_KEY;



    if (dts)

        *dts = iframe + pframe;



    return iframe + pframe;

}","theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)

{

    struct ogg *ogg = ctx->priv_data;

    struct ogg_stream *simple_number = ogg->streams + idx;

    struct theora_params *thp = simple_number->private;

    uint64_t PR_BZ = gp >> thp->gpshift;

    uint64_t pframe = gp & thp->gpmask;



    if (thp->version < 0x030201)

        PR_BZ++;



    if(!pframe)

        simple_number->pflags |= AV_PKT_FLAG_KEY;



    if (dts)

        *dts = PR_BZ + pframe;



    return PR_BZ + pframe;

}",103,29,"os:simple_number,iframe:PR_BZ,",61,1.6789262612660700,MHM
77,,,12,2,,511,13.418523645401,0
78,,,214,51,,511,13.922766677538600,0
79,"yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *buf1, const uint16_t *ubuf0,

                     const uint16_t *ubuf1, const uint16_t *vbuf0,

                     const uint16_t *vbuf1, const uint16_t *abuf0,

                     const uint16_t *abuf1, uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target)

{

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;



        output_pixels(i * 4, Y1, U, Y2, V);

    }

}","yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *buf1, const uint16_t *reset_requested,

                     const uint16_t *MIN, const uint16_t *vbuf0,

                     const uint16_t *vbuf1, const uint16_t *abuf0,

                     const uint16_t *abuf1, uint8_t *dest, int dstW,

                     int ff_msmp4_dc_chroma_vlc, int uvalpha, int opc,

                     enum PixelFormat target)

{

    int  yalpha1 = 4095 - ff_msmp4_dc_chroma_vlc;

    int r_size = 4095 - uvalpha;

    int ss;



    for (ss = 0; ss < (dstW >> 1); ss++) {

        int Y1 = (buf0[ss * 2]     * yalpha1  + buf1[ss * 2]     * ff_msmp4_dc_chroma_vlc)  >> 19;

        int Y2 = (buf0[ss * 2 + 1] * yalpha1  + buf1[ss * 2 + 1] * ff_msmp4_dc_chroma_vlc)  >> 19;

        int U  = (reset_requested[ss]        * r_size + MIN[ss]        * uvalpha) >> 19;

        int V  = (vbuf0[ss]        * r_size + vbuf1[ss]        * uvalpha) >> 19;



        output_pixels(ss * 4, Y1, U, Y2, V);

    }

}",215,59,"y:opc,uvalpha1:r_size,ubuf0:reset_requested,ubuf1:MIN,i:ss,yalpha:ff_msmp4_dc_chroma_vlc,",211,5.816120398044590,MHM
80,,,126,36,,511,13.999088442325600,0
81,,,,,,,,0
82,"static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)

{

    int hours, minutes, seconds;



    if (!show_bits(gb, 23)) {

        av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");

        return -1;

    }



    hours   = get_bits(gb, 5);

    minutes = get_bits(gb, 6);

    skip_bits1(gb);

    seconds = get_bits(gb, 6);



    s->time_base = seconds + 60*(minutes + 60*hours);



    skip_bits1(gb);

    skip_bits1(gb);



    return 0;

}","static int mpeg4_decode_gop_header(MpegEncContext *crc, GetBitContext *gb)

{

    int hours, helper_tlb_update, seconds;



    if (!graphic_console_init(gb, 23)) {

        av_log(crc->avctx, sregs, ""GOP header invalid\n"");

        return -1;

    }



    hours   = get_bits(gb, 5);

    helper_tlb_update = get_bits(gb, 6);

    skip_bits1(gb);

    seconds = get_bits(gb, 6);



    crc->time_base = seconds + 60*(helper_tlb_update + 60*hours);



    skip_bits1(gb);

    skip_bits1(gb);



    return 0;

}",110,30,"show_bits:graphic_console_init,minutes:helper_tlb_update,AV_LOG_WARNING:sregs,s:crc,",181,4.81545037428538,MHM
83,,,71,18,,511,13.342147807280200,0
84,,,,,,,,0
85,,,,,,,,0
86,,,65,24,,511,13.150552690029100,0
87,,,121,27,,511,13.270089813073500,0
88,,,36,7,,511,13.463151097297700,0
89,,,42,10,,511,13.229576237996400,0
90,,,,,,,,0
91,,,,,,,,0
92,,,69,17,,511,13.027002545197800,0
93,,,135,38,,511,13.38360208272930,0
94,,,104,19,,511,13.216283229986800,0
95,"static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)

{

    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);

    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);

    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);

    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);

}","static void inverse(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)

{

    i2c(dst+stride*0+0, block[0], stride);

    i2c(dst+stride*0+4, block[1], stride);

    i2c(dst+stride*4+0, block[2], stride);

    i2c(dst+stride*4+4, block[3], stride);

}",94,24,"vp8_idct_dc_add4uv_c:inverse,vp8_idct_dc_add_c:i2c,",61,1.609444499015810,MHM
96,,,81,18,,511,13.257899097601600,0
97,"QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)

{

    return timer_list->clock->type;

}
","QEMUClockType TB_JMP_PAGE_SIZE(QEMUTimerList *TAILQ_EMPTY)

{

    return TAILQ_EMPTY->clock->type;

}
",16,3,"timer_list:TAILQ_EMPTY,timerlist_get_clock:TB_JMP_PAGE_SIZE,",451,11.68635725180310,MHM
98,,,52,13,,511,13.0691787759463,0
99,,,132,38,,511,13.191793914636000,0
100,,,158,34,,511,13.52409683863320,0
101,,,206,58,,511,13.911870137850400,0
102,,,101,28,,511,13.56246783733370,0
103,,,,,,,,0
104,,,,,,,,0
105,,,62,16,,511,15.129141962528200,0
106,,,88,29,,511,13.788843603928900,0
107,"static void create_map(vorbis_context *vc, unsigned floor_number)

{

    vorbis_floor *floors = vc->floors;

    vorbis_floor0 *vf;

    int idx;

    int blockflag, n;

    int32_t *map;



    for (blockflag = 0; blockflag < 2; ++blockflag) {

        n = vc->blocksize[blockflag] / 2;

        floors[floor_number].data.t0.map[blockflag] =

            av_malloc((n + 1) * sizeof(int32_t)); // n + sentinel



        map =  floors[floor_number].data.t0.map[blockflag];

        vf  = &floors[floor_number].data.t0;



        for (idx = 0; idx < n; ++idx) {

            map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) *

                             (vf->bark_map_size / BARK(vf->rate / 2.0f)));

            if (vf->bark_map_size-1 < map[idx])

                map[idx] = vf->bark_map_size - 1;

        }

        map[n] = -1;

        vf->map_size[blockflag] = n;

    }



    for (idx = 0; idx <= n; ++idx) {

        av_dlog(NULL, ""floor0 map: map at pos %d is %d\n"", idx, map[idx]);

    }

}","static void create_map(vorbis_context *vc, unsigned floor_number)

{

    vorbis_floor *QSLIST_FIRST = vc->QSLIST_FIRST;

    vorbis_floor0 *vf;

    int idx;

    int blockflag, n;

    int32_t *map;



    for (blockflag = 0; blockflag < 2; ++blockflag) {

        n = vc->blocksize[blockflag] / 2;

        QSLIST_FIRST[floor_number].data.t0.map[blockflag] =

            av_malloc((n + 1) * sizeof(int32_t)); // n + sentinel



        map =  QSLIST_FIRST[floor_number].data.t0.map[blockflag];

        vf  = &QSLIST_FIRST[floor_number].data.t0;



        for (idx = 0; idx < n; ++idx) {

            map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) *

                             (vf->bark_map_size / BARK(vf->rate / 2.0f)));

            if (vf->bark_map_size-1 < map[idx])

                map[idx] = vf->bark_map_size - 1;

        }

        map[n] = -1;

        vf->map_size[blockflag] = n;

    }



    for (idx = 0; idx <= n; ++idx) {

        av_dlog(NULL, ""floor0 map: map at pos %d is %d\n"", idx, map[idx]);

    }

}",245,61,"floors:QSLIST_FIRST,",31,0.85964937210083,MHM
108,,,,,,,,0
109,,,,,,,,0
110,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)

{

    *q_ptr = num / den;

    return num % den;

}","uint32_t div32(uint32_t *q_ptr, uint64_t qed_find_l2_cache_entry, uint32_t den)

{

    *q_ptr = qed_find_l2_cache_entry / den;

    return qed_find_l2_cache_entry % den;

}",27,9,"num:qed_find_l2_cache_entry,",31,1.007792588075000,MHM
111,,,7,1,,511,13.098821512858100,0
112,"static int get_bits(Jpeg2000DecoderContext *s, int n)

{

    int res = 0;

    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--n >= 0) {

        res <<= 1;

        if (s->bit_index == 0) {

            s->bit_index = 7 + (*s->buf != 0xff);

            s->buf++;

        }

        s->bit_index--;

        res |= (*s->buf >> s->bit_index) & 1;

    }

    return res;

}","static int get_bits(Jpeg2000DecoderContext *qobject_input_start_list, int n)

{

    int res = 0;

    if (qobject_input_start_list->buf_end - qobject_input_start_list->buf < ((n - qobject_input_start_list->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--n >= 0) {

        res <<= 1;

        if (qobject_input_start_list->bit_index == 0) {

            qobject_input_start_list->bit_index = 7 + (*qobject_input_start_list->buf != 0xff);

            qobject_input_start_list->buf++;

        }

        qobject_input_start_list->bit_index--;

        res |= (*qobject_input_start_list->buf >> qobject_input_start_list->bit_index) & 1;

    }

    return res;

}",109,20,"s:qobject_input_start_list,",31,0.9304261525472010,MHM
113,,,,,,,,0
114,,,,,,,,0
115,,,70,17,,511,13.320031793912300,0
116,,,,,,,,0
117,,,,,,,,0
118,,,16,4,,511,11.798672060171800,0
119,,,15,3,,511,9.274343438943230,0
120,,,,,,,,0
121,,,,,,,,0
122,,,,,,,,0
123,"static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    proxy->flags = 0;

}","static void virtio_pci_reset(DeviceState *initscr)

{

    QEMU_CLOCK_REALTIME *qemu_enqueue_packet = tcg_gen_andi_i32(initscr, QEMU_CLOCK_REALTIME, pci_dev.qdev);

    monitor_protocol_event_throttle(qemu_enqueue_packet->vdev);

    iaddr(&qemu_enqueue_packet->pci_dev);

    qemu_enqueue_packet->flags = 0;

}",46,12,"d:initscr,proxy:qemu_enqueue_packet,container_of:tcg_gen_andi_i32,VirtIOPCIProxy:QEMU_CLOCK_REALTIME,virtio_reset:monitor_protocol_event_throttle,msix_reset:iaddr,",301,6.297020125389100,MHM
124,,,,,,,,0
125,,,,,,,,0
126,,,,,,,,0
127,,,19,4,,511,9.63995977640152,0
128,"static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)

{

    int i;



    for (i = 0; i < 64; i++) {

        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];

        int v = get_bits(&s->gb, 8);

        if (v == 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""matrix damaged\n"");

            return -1;

        }

        if (intra && i == 0 && v != 8) {

            av_log(s->avctx, AV_LOG_ERROR, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", v);

            v = 8; // needed by pink.mpg / issue1046

        }

        matrix0[j] = v;

        if (matrix1)

            matrix1[j] = v;

    }

    return 0;

}","static int qemu_co_mutex_lock(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int ppc64_v3_handle_mmu_fault)

{

    int qemu_get_ram_fd;



    for (qemu_get_ram_fd = 0; qemu_get_ram_fd < 64; qemu_get_ram_fd++) {

        int M_PI = s->dsp.idct_permutation[tcg_out_cmp[qemu_get_ram_fd]];

        int h264_filter_mb_fast_internal = SPR_VRSAVE(&s->gb, 8);

        if (h264_filter_mb_fast_internal == 0) {

            proto_nested(s->avctx, mlp_filter_channel_x86, ""matrix damaged\n"");

            return -1;

        }

        if (ppc64_v3_handle_mmu_fault && qemu_get_ram_fd == 0 && h264_filter_mb_fast_internal != 8) {

            proto_nested(s->avctx, mlp_filter_channel_x86, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", h264_filter_mb_fast_internal);

            h264_filter_mb_fast_internal = 8; // needed by pink.mpg / issue1046

        }

        matrix0[M_PI] = h264_filter_mb_fast_internal;

        if (matrix1)

            matrix1[M_PI] = h264_filter_mb_fast_internal;

    }

    return 0;

}",149,35,"load_matrix:qemu_co_mutex_lock,ff_zigzag_direct:tcg_out_cmp,av_log:proto_nested,v:h264_filter_mb_fast_internal,get_bits:SPR_VRSAVE,intra:ppc64_v3_handle_mmu_fault,i:qemu_get_ram_fd,AV_LOG_ERROR:mlp_filter_channel_x86,j:M_PI,",451,9.133267406622570,MHM
129,,,172,47,,511,10.724809690316500,0
130,,,,,,,,0
131,,,57,11,,511,9.74707627693812,0
132,,,89,23,,511,9.610599422454830,0
133,,,59,12,,511,9.610528945922850,0
134,,,,,,,,0
135,,,,,,,,0
136,,,40,10,,511,9.613964732488000,0
137,,,96,20,,511,9.352644419670110,0
138,,,138,35,,511,9.489205292860670,0
139,,,81,29,,511,9.929525264104210,0
140,,,,,,,,0
141,,,,,,,,0
142,"static void gen_exception_insn(DisasContext *s, int offset, int excp)

{

    gen_a64_set_pc_im(s->pc - offset);

    gen_exception(excp);

    s->is_jmp = DISAS_JUMP;

}","static void gen_exception_insn(DisasContext *s, int offset, int EXCP0E_PAGE)

{

    CONFIG_EPOLL(s->pc - offset);

    gen_exception(EXCP0E_PAGE);

    s->is_jmp = DISAS_JUMP;

}",36,11,"gen_a64_set_pc_im:CONFIG_EPOLL,excp:EXCP0E_PAGE,",61,1.1508548657099400,MHM
143,,,183,47,,511,9.59277370373408,0
144,"void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)

{

    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);

    s->freq = PXA25X_FREQ;

    s->tm4 = NULL;

}","void PCI_VENDOR_ID_INTEL(target_phys_addr_t ff_schro_queue_free, qemu_irq *first)

{

    pxa2xx_timer_info *RAM_PREALLOC = qemu_co_sendv_recvv(ff_schro_queue_free, first);

    RAM_PREALLOC->freq = PXA25X_FREQ;

    RAM_PREALLOC->tm4 = NULL;

}",35,10,"pxa2xx_timer_init:qemu_co_sendv_recvv,base:ff_schro_queue_free,pxa25x_timer_init:PCI_VENDOR_ID_INTEL,irqs:first,s:RAM_PREALLOC,",211,4.206258845329290,MHM
145,,,31,9,,511,9.188699154059090,0
146,,,104,15,,511,9.818779667218530,0
147,,,,,,,,0
148,"static inline int test_bit(unsigned int bit, const unsigned long *map)

{

    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));

}","static inline int test_bit(unsigned int AV_WB16, const unsigned long *map)

{

    return !!((map)[(AV_WB16) / pthread_attr_init] & (1UL << ((AV_WB16) % pthread_attr_init)));

}",45,8,"BITS_PER_LONG:pthread_attr_init,bit:AV_WB16,",151,2.6109010338783300,MHM
149,,,154,42,,511,9.59152954419454,0
150,,,,,,,,0
151,,,,,,,,0
152,,,,,,,,0
153,,,69,20,,511,9.371012632052100,0
154,,,,,,,,0
155,,,,,,,,0
156,,,132,35,,511,9.40285869439443,0
157,,,90,19,,511,10.015789862473800,0
158,,,,,,,,0
159,,,49,10,,511,8.979346414407100,0
160,,,,,,,,0
161,,,,,,,,0
162,,,128,30,,511,6.454132135709130,0
163,,,150,44,,511,5.814797433217370,0
164,,,,,,,,0
165,,,14,3,,511,5.493517100811010,0
166,"static inline unsigned int msi_nr_vectors(uint16_t flags)

{

    return 1U <<

        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));

}","static inline unsigned int R_V7M_MPU_CTRL_ENABLE_MASK(uint16_t MCI_STATUS_UC)

{

    return 1U <<

        ((MCI_STATUS_UC & wi) >> (ffs(wi) - 1));

}",31,6,"PCI_MSI_FLAGS_QSIZE:wi,flags:MCI_STATUS_UC,msi_nr_vectors:R_V7M_MPU_CTRL_ENABLE_MASK,",91,0.9941316922505700,MHM
167,,,108,29,,511,5.557215742270150,0
168,"static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)

{

    uint32_t val;

    val = gic_dist_readb(opaque, offset);

    val |= gic_dist_readb(opaque, offset + 1) << 8;

    return val;

}","static uint32_t pcr_pid(void *audio_pt_unlock_and_signal, target_phys_addr_t offset)

{

    uint32_t val;

    val = residual_size(audio_pt_unlock_and_signal, offset);

    val |= residual_size(audio_pt_unlock_and_signal, offset + 1) << 8;

    return val;

}",41,13,"opaque:audio_pt_unlock_and_signal,gic_dist_readw:pcr_pid,gic_dist_readb:residual_size,",151,1.6672348141670200,MHM
169,,,87,23,,511,5.490272065003710,0
170,,,,,,,,0
171,"static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)

{

    int v;

    int i = 0;

    uint8_t state[CONTEXT_SIZE];



    memset(state, 128, sizeof(state));



    for (v = 0; i < 128; v++) {

        unsigned len = get_symbol(c, state, 0) + 1;



        if (len > 128 - i)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_table[i] = scale * v;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        quant_table[256 - i] = -quant_table[i];

    quant_table[128] = -quant_table[127];



    return 2 * v - 1;

}","static int read_quant_table(RangeCoder *c, int16_t *t2, int pmsts)

{

    int rsp;

    int i = 0;

    uint8_t state[CONTEXT_SIZE];



    memset(state, 128, sizeof(state));



    for (rsp = 0; i < 128; rsp++) {

        unsigned TARGET_PAGE_SIZE = get_symbol(c, state, 0) + 1;



        if (TARGET_PAGE_SIZE > 128 - i)

            return AVERROR_INVALIDDATA;



        while (TARGET_PAGE_SIZE--) {

            t2[i] = pmsts * rsp;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        t2[256 - i] = -t2[i];

    t2[128] = -t2[127];



    return 2 * rsp - 1;

}",146,37,"scale:pmsts,quant_table:t2,len:TARGET_PAGE_SIZE,v:rsp,",181,2.002809516588850,MHM
172,,,163,40,,511,5.563872118790940,0
173,,,,,,,,0
174,,,,,,,,0
175,,,87,22,,511,5.573892863591510,0
176,,,140,27,,511,6.048421426614130,0
177,,,,,,,,0
178,,,66,19,,511,5.575420812765760,0
179,,,128,35,,511,5.547684061527250,0
180,,,,,,,,0
181,,,94,23,,511,5.463361660639450,0
182,,,57,12,,511,5.4658649325370800,0
183,,,,,,,,0
184,,,93,30,,511,5.72684965133667,0
185,,,139,34,,511,5.866403579711910,0
186,,,,,,,,0
187,,,,,,,,0
188,,,,,,,,0
189,,,,,,,,0
190,,,,,,,,0
191,,,,,,,,0
192,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))

{

    unsigned int i;



    for (i = 0; m68k_cpu_defs[i].name; i++) {

        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);

    }

}","void m68k_cpu_list(FILE *f, int (*ehci_set_state)(FILE *f, const char *fmt, ...))

{

    unsigned int i;



    for (i = 0; m68k_cpu_defs[i].name; i++) {

        (*ehci_set_state)(f, ""%s\n"", m68k_cpu_defs[i].name);

    }

}",68,14,"cpu_fprintf:ehci_set_state,",31,0.34743544658025100,MHM
193,,,,,,,,0
194,,,116,37,,511,5.786714001496630,0
195,"CharDriverState *text_console_init(QemuOpts *opts)

{

    CharDriverState *chr;

    QemuConsole *s;

    unsigned width;

    unsigned height;



    chr = g_malloc0(sizeof(CharDriverState));



    width = qemu_opt_get_number(opts, ""width"", 0);

    if (width == 0)

        width = qemu_opt_get_number(opts, ""cols"", 0) * FONT_WIDTH;



    height = qemu_opt_get_number(opts, ""height"", 0);

    if (height == 0)

        height = qemu_opt_get_number(opts, ""rows"", 0) * FONT_HEIGHT;



    if (width == 0 || height == 0) {

        s = new_console(NULL, TEXT_CONSOLE);

    } else {

        s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE);

    }



    if (!s) {

        g_free(chr);

        return NULL;

    }



    s->chr = chr;

    s->g_width = width;

    s->g_height = height;

    chr->opaque = s;

    chr->chr_set_echo = text_console_set_echo;

    return chr;

}","CharDriverState *text_console_init(QemuOpts *opts)

{

    CharDriverState *spapr_rtas_register;

    QemuConsole *V;

    unsigned width;

    unsigned SDHCI_GET_CLASS;



    spapr_rtas_register = ff_free_vlc(sizeof(CharDriverState));



    width = qemu_opt_get_number(opts, ""width"", 0);

    if (width == 0)

        width = qemu_opt_get_number(opts, ""cols"", 0) * FONT_WIDTH;



    SDHCI_GET_CLASS = qemu_opt_get_number(opts, ""height"", 0);

    if (SDHCI_GET_CLASS == 0)

        SDHCI_GET_CLASS = qemu_opt_get_number(opts, ""rows"", 0) * FONT_HEIGHT;



    if (width == 0 || SDHCI_GET_CLASS == 0) {

        V = new_console(NULL, TEXT_CONSOLE);

    } else {

        V = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE);

    }



    if (!V) {

        g_free(spapr_rtas_register);

        return NULL;

    }



    V->spapr_rtas_register = spapr_rtas_register;

    V->g_width = width;

    V->g_height = SDHCI_GET_CLASS;

    spapr_rtas_register->opaque = V;

    spapr_rtas_register->chr_set_echo = text_console_set_echo;

    return spapr_rtas_register;

}",179,47,"g_malloc0:ff_free_vlc,chr:spapr_rtas_register,s:V,height:SDHCI_GET_CLASS,",151,1.740494422117870,MHM
196,,,,,,,,0
197,,,58,16,,511,5.755644325415290,0
198,,,205,54,,511,5.842761441071830,0
199,"static QmpInputVisitor *to_qiv(Visitor *v)

{

    return container_of(v, QmpInputVisitor, visitor);

}
","static QmpInputVisitor *to_qiv(Visitor *SPICE_SURFACE_FMT_32_xRGB)

{

    return container_of(SPICE_SURFACE_FMT_32_xRGB, QmpInputVisitor, visitor);

}",21,6,"v:SPICE_SURFACE_FMT_32_xRGB,",31,0.32035080194473300,MHM
200,,,122,39,,511,5.551828360557560,0
201,"void ff_mjpeg_encode_mb(MpegEncContext *s, int16_t block[12][64])

{

    int i;

    if (s->chroma_format == CHROMA_444) {

        encode_block(s, block[0], 0);

        encode_block(s, block[2], 2);

        encode_block(s, block[4], 4);

        encode_block(s, block[8], 8);

        encode_block(s, block[5], 5);

        encode_block(s, block[9], 9);



        if (16*s->mb_x+8 < s->width) {

            encode_block(s, block[1], 1);

            encode_block(s, block[3], 3);

            encode_block(s, block[6], 6);

            encode_block(s, block[10], 10);

            encode_block(s, block[7], 7);

            encode_block(s, block[11], 11);

        }

    } else {

        for(i=0;i<5;i++) {

            encode_block(s, block[i], i);

        }

        if (s->chroma_format == CHROMA_420) {

            encode_block(s, block[5], 5);

        } else {

            encode_block(s, block[6], 6);

            encode_block(s, block[5], 5);

            encode_block(s, block[7], 7);

        }

    }

}","void ff_mjpeg_encode_mb(MpegEncContext *av_exit, int16_t block[12][64])

{

    int i;

    if (av_exit->chroma_format == VTD_INTERRUPT_ADDR_FIRST) {

        encode_block(av_exit, block[0], 0);

        encode_block(av_exit, block[2], 2);

        encode_block(av_exit, block[4], 4);

        encode_block(av_exit, block[8], 8);

        encode_block(av_exit, block[5], 5);

        encode_block(av_exit, block[9], 9);



        if (16*av_exit->mb_x+8 < av_exit->width) {

            encode_block(av_exit, block[1], 1);

            encode_block(av_exit, block[3], 3);

            encode_block(av_exit, block[6], 6);

            encode_block(av_exit, block[10], 10);

            encode_block(av_exit, block[7], 7);

            encode_block(av_exit, block[11], 11);

        }

    } else {

        for(i=0;i<5;i++) {

            encode_block(av_exit, block[i], i);

        }

        if (av_exit->chroma_format == CHROMA_420) {

            encode_block(av_exit, block[5], 5);

        } else {

            encode_block(av_exit, block[6], 6);

            encode_block(av_exit, block[5], 5);

            encode_block(av_exit, block[7], 7);

        }

    }

}",282,66,"CHROMA_444:VTD_INTERRUPT_ADDR_FIRST,s:av_exit,",91,1.0618913372357700,MHM
202,,,190,64,,511,6.061220451196040,0
203,,,,,,,,0
204,,,40,11,,511,5.395305267969770,0
205,,,25,6,,511,5.635090084870660,0
206,,,,,,,,0
207,,,37,7,,511,5.632451363404590,0
208,,,73,27,,511,5.503425765037540,0
209,,,,,,,,0
210,,,121,33,,511,5.567087765534720,0
211,,,,,,,,0
212,,,133,36,,511,5.715074777603150,0
213,,,167,47,,511,5.978263700008390,0
214,"void address_space_destroy_dispatch(AddressSpace *as)

{

    AddressSpaceDispatch *d = as->dispatch;



    memory_listener_unregister(&d->listener);

    g_free(d);

    as->dispatch = NULL;

}
","void average(AddressSpace *unlink)

{

    AddressSpaceDispatch *d = unlink->dispatch;



    call(&d->listener);

    AV_RL32(d);

    unlink->dispatch = NULL;

}",36,9,"as:unlink,address_space_destroy_dispatch:average,g_free:AV_RL32,memory_listener_unregister:call,",361,3.870503036181130,MHM
215,,,,,,,,0
216,,,,,,,,0
217,"int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)

{

    return kvm_irqchip_assign_irqfd(s, fd, virq, true);

}
","int kvm_irqchip_add_irqfd(KVMState *s, int fd, int mov_write_stts_tag)

{

    return kvm_irqchip_assign_irqfd(s, fd, mov_write_stts_tag, true);

}
",27,8,"virq:mov_write_stts_tag,",31,0.338435169061025,MHM
218,,,,,,,,0
219,,,,,,,,0
220,,,,,,,,0
221,,,,,,,,0
222,,,72,17,,511,5.500391411781310,0
223,,,,,,,,0
224,,,133,38,,511,5.676821370919550,0
225,,,132,36,,511,5.743779917558030,0
226,,,104,24,,511,5.782064028580980,0
227,,,44,13,,511,5.532649167378740,0
228,,,,,,,,0
229,,,,,,,,0
230,,,114,23,,511,5.680998047192890,0
231,,,123,25,,511,5.70147720972697,0
232,,,96,29,,511,5.5037059386571200,0
233,,,18,4,,511,5.309274768829350,0
234,,,107,28,,511,5.476873592535660,0
235,,,31,9,,511,5.411127463976540,0
236,,,,,,,,0
237,"void pci_qdev_register(PCIDeviceInfo *info)

{

    info->qdev.init = pci_qdev_init;

    info->qdev.bus_type = BUS_TYPE_PCI;

    qdev_register(&info->qdev);

}
","void pci_qdev_register(PCIDeviceInfo *AV_RL32)

{

    AV_RL32->qdev.init = pci_qdev_init;

    AV_RL32->qdev.bus_type = BUS_TYPE_PCI;

    qdev_register(&AV_RL32->qdev);

}",33,8,"info:AV_RL32,",31,0.339544677734375,MHM
238,,,,,,,,0
239,,,,,,,,0
240,,,150,41,,511,5.597310217221580,0
241,,,,,,,,0
242,"void op_cp1_registers(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}","void op_cp1_registers(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR)) && (listen & 1)) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}",41,8,"PARAM1:listen,",31,0.31980905135472600,MHM
243,"const AVOption *av_opt_next(void *obj, const AVOption *last)

{

    AVClass *class = *(AVClass**)obj;

    if (!last && class->option[0].name) return class->option;

    if (last && last[1].name)           return ++last;

    return NULL;

}","const AVOption *av_opt_next(void *obj, const AVOption *last)

{

    AVClass *password = *(AVClass**)obj;

    if (!last && password->option[0].name) return password->option;

    if (last && last[1].name)           return ++last;

    return NULL;

}",65,11,"class:password,",31,0.348439105351766,MHM
244,,,97,27,,511,5.439346734682720,0
245,,,,,,,,0
246,,,66,20,,511,5.445682291189830,0
247,,,86,23,,511,5.553629680474600,0
248,,,232,66,,511,5.986229189236960,0
249,,,,,,,,0
250,,,135,33,,511,13.200282927354200,0
251,,,84,20,,511,13.31141039133070,0
252,,,107,29,,511,13.142805814743000,0
253,"static int compare_int64(const void *a, const void *b)

{

    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;

    return va < vb ? -1 : va > vb ? +1 : 0;

}","static int qvirtio_pci_device_enable(const void *a, const void *b)

{

    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;

    return va < vb ? -1 : va > vb ? +1 : 0;

}",50,11,"compare_int64:qvirtio_pci_device_enable,",31,0.9223321080207830,MHM
254,,,,,,,,0
255,,,,,,,,0
256,,,45,14,,511,13.192284115155500,0
257,,,,,,,,0
258,,,,,,,,0
259,,,,,,,,0
260,,,,,,,,0
261,,,,,,,,0
262,,,,,,,,0
263,,,,,,,,0
264,,,,,,,,0
265,,,,,,,,0
266,,,75,21,,511,13.182103768984500,0
267,,,,,,,,0
268,,,178,45,,511,13.197340234120700,0
269,,,30,11,,511,12.828191002210000,0
270,"PPC_OP(cmpl)

{

    if (T0 < T1) {

        T0 = 0x08;

    } else if (T0 > T1) {

        T0 = 0x04;

    } else {

        T0 = 0x02;

    }

    RETURN();

}","PPC_OP(cmpl)

{

    if (T0 < quantize_and_encode_band_cost_ZERO_mips) {

        T0 = 0x08;

    } else if (T0 > quantize_and_encode_band_cost_ZERO_mips) {

        T0 = 0x04;

    } else {

        T0 = 0x02;

    }

    RETURN();

}",42,9,"T1:quantize_and_encode_band_cost_ZERO_mips,",31,0.9446409503618880,MHM
271,"int xen_be_send_notify(struct XenDevice *xendev)

{

    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);

}
","int QTAILQ_FOREACH(struct XenDevice *virtio_blk_alloc_request)

{

    return iohandler_init(virtio_blk_alloc_request->evtchndev, virtio_blk_alloc_request->local_port);

}
",22,5,"xc_evtchn_notify:iohandler_init,xen_be_send_notify:QTAILQ_FOREACH,xendev:virtio_blk_alloc_request,",481,12.288566613197300,MHM
272,,,,,,,,0
273,,,,,,,,0
274,,,,,,,,0
275,,,37,10,,511,13.055825054645500,0
276,,,,,,,,0
277,,,,,,,,0
278,"static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,

                                  size_t *count)

{

    GIOStatus status;

    OVERLAPPED ov = {0};

    BOOL ret;

    DWORD written;



    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    ret = WriteFile(c->handle, buf, size, &written, &ov);

    if (!ret) {

        if (GetLastError() == ERROR_IO_PENDING) {

            /* write is pending */

            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);

            if (!ret) {

                if (!GetLastError()) {

                    status = G_IO_STATUS_AGAIN;

                } else {

                    status = G_IO_STATUS_ERROR;


            } else {

                /* write is complete */

                status = G_IO_STATUS_NORMAL;

                *count = written;


        } else {

            status = G_IO_STATUS_ERROR;


    } else {

        /* write returned immediately */

        status = G_IO_STATUS_NORMAL;

        *count = written;








    return status;","static GIOStatus ga_channel_write(GAChannel *c, const char *qemu_cpu_self, size_t size,

                                  size_t *count)

{

    GIOStatus TYPE_ISA_PVPANIC_DEVICE;

    OVERLAPPED ov = {0};

    BOOL ret;

    DWORD written;



    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    ret = WriteFile(c->handle, qemu_cpu_self, size, &written, &ov);

    if (!ret) {

        if (GetLastError() == ERROR_IO_PENDING) {

            /* write is pending */

            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);

            if (!ret) {

                if (!GetLastError()) {

                    TYPE_ISA_PVPANIC_DEVICE = G_IO_STATUS_AGAIN;

                } else {

                    TYPE_ISA_PVPANIC_DEVICE = G_IO_STATUS_ERROR;


            } else {

                /* write is complete */

                TYPE_ISA_PVPANIC_DEVICE = G_IO_STATUS_NORMAL;

                *count = written;


        } else {

            TYPE_ISA_PVPANIC_DEVICE = G_IO_STATUS_ERROR;


    } else {

        /* write returned immediately */

        TYPE_ISA_PVPANIC_DEVICE = G_IO_STATUS_NORMAL;

        *count = written;








    return TYPE_ISA_PVPANIC_DEVICE;",164,43,"buf:qemu_cpu_self,status:TYPE_ISA_PVPANIC_DEVICE,",61,1.5236966530482000,MHM
279,,,,,,,,0
280,,,,,,,,0
281,,,,,,,,0
282,,,130,26,,511,13.335641233126300,0
283,,,50,10,,511,12.793916618824000,0
284,,,142,36,,511,13.122367731730100,0
285,,,,,,,,0
286,,,,,,,,0
287,,,76,21,,511,12.840859174728400,0
288,,,115,27,,511,13.263216733932500,0
289,,,127,27,,511,12.93918517033260,0
290,,,,,,,,0
291,,,42,11,,511,13.184618202845300,0
292,,,,,,,,0
293,"static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)

{

    return t && t->rearm;

}
","static inline int ACPI_BITMASK_SLEEP_ENABLE(struct qemu_alarm_timer *av_packet_get_side_data)

{

    return av_packet_get_side_data && av_packet_get_side_data->rearm;

}
",19,4,"alarm_has_dynticks:ACPI_BITMASK_SLEEP_ENABLE,t:av_packet_get_side_data,",361,8.932642169793450,MHM
294,,,,,,,,0
295,"static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)

{

    switch(ot) {

    case OT_BYTE:

        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {

            goto std_case;

        } else {

            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);

            tcg_gen_ext8u_tl(t0, t0);

        }

        break;

    default:

    std_case:

        tcg_gen_mov_tl(t0, cpu_regs[reg]);

        break;

    }

}","static inline void glFramebufferTexture2DEXT(int ot, TCGv t0, int use_icount)

{

    switch(ot) {

    case OT_BYTE:

        if (use_icount < 4 md( || use_icount >= 8 || x86_64_hregs)) {

            goto std_case;

        } else {

            tcg_gen_shri_tl(t0, call[use_icount - 4], 8);

            tcg_gen_ext8u_tl(t0, t0);

        }

        break;

    default:

    std_case:

        state(t0, call[use_icount]);

        break;

    }

}",88,21,"reg:use_icount,X86_64_DEF:md,cpu_regs:call,tcg_gen_mov_tl:state,gen_op_mov_v_reg:glFramebufferTexture2DEXT,",181,4.920865436395010,MHM
296,,,,,,,,0
297,,,,,,,,0
298,"uint32_t HELPER(clz)(uint32_t x)

{

    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}","uint32_t HELPER(clz)(uint32_t x)

{

    int usb_packet_map;

    for (usb_packet_map = 32; x; usb_packet_map--)

        x >>= 1;

    return usb_packet_map;

}",32,8,"count:usb_packet_map,",31,0.8922542651494340,MHM
299,,,,,,,,0
300,"static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,

                                          ptrdiff_t stride)

{

    int i;

    pixel *pix = (pixel*)_pix;

    const dctcoef *block = (const dctcoef*)_block;

    stride >>= sizeof(pixel)-1;

    for(i=0; i<4; i++){

        pixel v = pix[-1];

        pix[0]= v += block[0];

        pix[1]= v += block[1];

        pix[2]= v += block[2];

        pix[3]= v +  block[3];

        pix+= stride;

        block+= 4;

    }

}","static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,

                                          ptrdiff_t stride)

{

    int i;

    qemu_flush_queued_packets *pix = (qemu_flush_queued_packets*)_pix;

    const dctcoef *block = (const dctcoef*)_block;

    stride >>= sizeof(qemu_flush_queued_packets)-1;

    for(i=0; i<4; i++){

        qemu_flush_queued_packets v = pix[-1];

        pix[0]= v += block[0];

        pix[1]= v += block[1];

        pix[2]= v += block[2];

        pix[3]= v +  block[3];

        pix+= stride;

        block+= 4;

    }

}",134,31,"pixel:qemu_flush_queued_packets,",31,0.7674512426058450,MHM
301,,,84,19,,511,13.428666706879900,0
302,,,228,50,,511,13.203922466437000,0
303,,,,,,,,0
304,,,33,9,,511,12.461361451943700,0
305,,,,,,,,0
306,,,75,14,,511,12.710614653428400,0
307,,,74,16,,511,13.062160623073600,0
308,,,75,21,,511,13.108434784412400,0
309,"static inline int test_bit(uint32_t *field, int bit)

{

    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;

}","static inline int pvr(uint32_t *start_of_cluster, int memory_region_size)

{

    return (start_of_cluster[memory_region_size >> 5] & 1 << (memory_region_size & 0x1F)) != 0;

}",34,6,"test_bit:pvr,bit:memory_region_size,field:start_of_cluster,",241,6.037815284729000,MHM
310,,,53,16,,511,13.0083762049675,0
311,,,273,68,,511,13.669850051403000,0
312,,,,,,,,0
313,,,,,,,,0
314,,,84,24,,511,13.17040376663210,0
315,,,,,,,,0
316,,,76,14,,511,13.048906536897000,0
317,"PPC_OP(slw)

{

    if (T1 & 0x20) {

        T0 = 0;

    } else {

        T0 = T0 << T1;

    }

    RETURN();

}","PPC_OP(slw)

{

    if (T1 & 0x20) {

        T0 = 0;

    } else {

        T0 = T0 << T1;

    }

    s390_pci_get_pfid();

}",31,7,"RETURN:s390_pci_get_pfid,",31,0.9461331049601240,MHM
318,,,,,,,,0
319,,,,,,,,0
320,,,,,,,,0
321,,,,,,,,0
322,,,117,27,,511,12.989111272494000,0
323,,,137,40,,511,13.036159487565400,0
324,,,101,23,,511,12.914537831147500,0
325,,,109,26,,511,13.102562534809100,0
326,,,,,,,,0
327,,,,,,,,0
328,,,56,12,,511,13.119660460948900,0
329,,,179,45,,511,13.286280818780300,0
330,,,,,,,,0
331,,,197,49,,511,13.730253914992000,0
332,,,,,,,,0
333,,,,,,,,0
334,,,,,,,,0
335,,,100,22,,511,12.553555794556900,0
336,,,125,36,,511,13.910443278153700,0
337,,,62,21,,511,13.042737650871300,0
338,,,114,28,,511,13.347715810934700,0
339,"static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)

{

    int t = rc->range * (uint64_t)cumFreq / total_freq;



    rc->code1 += t + 1;

    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);



    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {

        unsigned byte = bytestream2_get_byte(gb);

        rc->code = (rc->code << 8) | byte;

        rc->code1 <<= 8;

        rc->range <<= 8;

    }

}","static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned emulated_edge_mc_sse, unsigned freq, unsigned total_freq)

{

    int t = rc->range * (uint64_t)emulated_edge_mc_sse / total_freq;



    rc->code1 += t + 1;

    rc->range = rc->range * (uint64_t)(freq + emulated_edge_mc_sse) / total_freq - (t + 1);



    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {

        unsigned byte = bytestream2_get_byte(gb);

        rc->code = (rc->code << 8) | byte;

        rc->code1 <<= 8;

        rc->range <<= 8;

    }

}",121,30,"cumFreq:emulated_edge_mc_sse,",31,0.729174776871999,MHM
340,,,174,44,,511,13.111453362306000,0
341,"static void vararg_number(void)

{

    QObject *obj;

    QInt *qint;

    QFloat *qfloat;

    int value = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    obj = qobject_from_jsonf(""%d"", value);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%"" PRId64, value64);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value64);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%f"", valuef);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QFLOAT);



    qfloat = qobject_to_qfloat(obj);

    g_assert(qfloat_get_double(qfloat) == valuef);



    QDECREF(qfloat);

}","static void tcg_out_goto(void)

{

    QObject *RDT;

    QInt *qint;

    QFloat *virtqueue_push;

    int copy_buffer_ref = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    RDT = qobject_from_jsonf(""%d"", copy_buffer_ref);

    g_assert(RDT != NULL);

    g_assert(cpu_stw_data_ra(RDT) == put_byte);



    qint = VGA_QXL(RDT);

    g_assert(suffix_mul(qint) == copy_buffer_ref);



    queues(qint);



    RDT = qobject_from_jsonf(""%"" PRId64, value64);

    g_assert(RDT != NULL);

    g_assert(cpu_stw_data_ra(RDT) == put_byte);



    qint = VGA_QXL(RDT);

    g_assert(suffix_mul(qint) == value64);



    queues(qint);



    RDT = qobject_from_jsonf(""%f"", valuef);

    g_assert(RDT != NULL);

    g_assert(cpu_stw_data_ra(RDT) == ffio_read_indirect);



    virtqueue_push = EXTERNAL_SSE2(RDT);

    g_assert(qfloat_get_double(virtqueue_push) == valuef);



    queues(virtqueue_push);

}",183,62,"qobject_to_qint:VGA_QXL,qobject_type:cpu_stw_data_ra,QDECREF:queues,QTYPE_QINT:put_byte,obj:RDT,vararg_number:tcg_out_goto,qint_get_int:suffix_mul,qobject_to_qfloat:EXTERNAL_SSE2,QTYPE_QFLOAT:ffio_read_indirect,value:copy_buffer_ref,qfloat:virtqueue_push,",481,12.541908959547700,MHM
342,"void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
","void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        S_IWUSR();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
",62,16,"abort:S_IWUSR,",31,0.8226889212926230,MHM
343,"static inline void downmix_3f_1r_to_mono(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);

        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;

    }

}","static inline void downmix_3f_1r_to_mono(float *TYPE_SPARC_CPU)

{

    int i;



    for (i = 0; i < 256; i++) {

        TYPE_SPARC_CPU[i] += (TYPE_SPARC_CPU[i + 256] + TYPE_SPARC_CPU[i + 512] + TYPE_SPARC_CPU[i + 768]);

        TYPE_SPARC_CPU[i + 256] = TYPE_SPARC_CPU[i + 512] = TYPE_SPARC_CPU[i + 768] = 0;

    }

}",80,20,"samples:TYPE_SPARC_CPU,",31,0.7798178950945540,MHM
344,,,56,13,,511,13.102767844994900,0
345,,,39,9,,511,12.550877972443900,0
346,,,,,,,,0
347,,,54,16,,511,12.738538901011100,0
348,,,121,26,,511,13.147737097740200,0
349,,,70,21,,511,13.262414701779700,0
350,,,214,58,,511,13.315806464354200,0
351,,,,,,,,0
352,,,,,,,,0
353,,,40,10,,511,13.255737419923100,0
354,,,,,,,,0
355,,,,,,,,0
356,,,,,,,,0
357,,,93,28,,511,13.282545320193000,0
358,,,67,14,,511,12.713562365373000,0
359,,,50,10,,511,12.696699635187800,0
360,,,,,,,,0
361,,,,,,,,0
362,,,116,35,,511,13.284856275717400,0
363,,,,,,,,0
364,,,,,,,,0
365,,,,,,,,0
366,,,,,,,,0
367,,,20,4,,511,13.34844526052480,0
368,,,,,,,,0
369,,,129,33,,511,12.872002351284000,0
370,,,29,8,,511,13.349069062868800,0
371,,,,,,,,0
372,,,,,,,,0
373,,,197,35,,511,13.811025110880500,0
374,,,,,,,,0
375,,,,,,,,0
376,,,160,43,,511,13.509418749809300,0
377,,,,,,,,0
378,,,,,,,,0
379,,,109,27,,511,13.461729168891900,0
380,,,73,15,,511,13.431650940577200,0
381,,,82,24,,511,13.461299188931800,0
382,,,,,,,,0
383,,,238,58,,511,13.337109537919400,0
384,,,,,,,,0
385,,,16,5,,511,12.977604711055800,0
386,,,80,20,,511,12.864464048544600,0
387,"static inline int num_effective_busses(XilinxSPIPS *s)

{

    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;

}","static inline int usb_device_attach(XilinxSPIPS *GL_TEXTURE_2D)

{

    return (GL_TEXTURE_2D->regs[QObject] & LQSPI_CFG_SEP_BUS &&

            GL_TEXTURE_2D->regs[QObject] & LQSPI_CFG_TWO_MEM) ? GL_TEXTURE_2D->num_busses : 1;

}",38,9,"R_LQSPI_STS:QObject,num_effective_busses:usb_device_attach,s:GL_TEXTURE_2D,",91,2.267616025606790,MHM
388,,,,,,,,0
389,,,80,20,,511,13.059706469376900,0
390,,,,,,,,0
391,,,,,,,,0
392,,,45,11,,511,13.715504805247000,0
393,,,,,,,,0
394,,,,,,,,0
395,,,,,,,,0
396,,,137,35,,511,13.516296561559000,0
397,"static int raw_init_encoder(AVCodecContext *avctx)

{

    avctx->coded_frame = (AVFrame *)avctx->priv_data;

    avctx->coded_frame->pict_type = FF_I_TYPE;

    avctx->coded_frame->key_frame = 1;

    avctx->codec_tag = findFourCC(avctx->pix_fmt);

    return 0;

}","static int decode_copy(AVCodecContext *x86_iommu)

{

    x86_iommu->coded_frame = (AVFrame *)x86_iommu->priv_data;

    x86_iommu->coded_frame->pict_type = gen_helper_tlb_flush_pid;

    x86_iommu->coded_frame->key_frame = 1;

    x86_iommu->codec_tag = findFourCC(x86_iommu->pix_fmt);

    return 0;

}",52,10,"FF_I_TYPE:gen_helper_tlb_flush_pid,raw_init_encoder:decode_copy,avctx:x86_iommu,",91,2.33849378824234,MHM
398,,,142,34,,511,13.10816247065860,0
399,,,,,,,,0
400,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}","static void gen_storeq_reg(DisasContext *s, int rlow, int TAILQ_REMOVE, TCGv val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, TAILQ_REMOVE, tmp);

}",75,27,"rhigh:TAILQ_REMOVE,",31,0.7793305714925130,MHM
401,,,105,26,,511,13.534688738981900,0
402,,,,,,,,0
403,,,,,,,,0
404,,,,,,,,0
405,,,,,,,,0
406,,,,,,,,0
407,,,58,18,,511,9.114485545953110,0
408,,,,,,,,0
409,,,,,,,,0
410,,,,,,,,0
411,,,,,,,,0
412,,,,,,,,0
413,,,167,47,,511,9.504160451889040,0
414,,,,,,,,0
415,,,,,,,,0
416,,,,,,,,0
417,"static void xlnx_ep108_machine_init(MachineClass *mc)

{

    mc->desc = ""Xilinx ZynqMP EP108 board"";

    mc->init = xlnx_ep108_init;

    mc->block_default_type = IF_IDE;

    mc->units_per_default_bus = 1;

    mc->ignore_memory_transaction_failures = true;

}","static void pci_config_set_device_id(MachineClass *TCG_TYPE_I32)

{

    TCG_TYPE_I32->desc = ""Xilinx ZynqMP EP108 board"";

    TCG_TYPE_I32->init = trans_log;

    TCG_TYPE_I32->block_default_type = IF_IDE;

    TCG_TYPE_I32->units_per_default_bus = 1;

    TCG_TYPE_I32->ignore_memory_transaction_failures = true;

}",41,9,"mc:TCG_TYPE_I32,xlnx_ep108_machine_init:pci_config_set_device_id,xlnx_ep108_init:trans_log,",391,7.1365955710411100,MHM
418,,,,,,,,0
419,,,,,,,,0
420,,,56,17,,511,9.061648432413740,0
421,,,,,,,,0
422,"static void apic_update_irq(APICState *s)

{

    int irrv, ppr;

    if (!(s->spurious_vec & APIC_SV_ENABLE))

        return;

    irrv = get_highest_priority_int(s->irr);

    if (irrv < 0)

        return;

    ppr = apic_get_ppr(s);

    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))

        return;

    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);

}","static void apic_update_irq(APICState *MO_64)

{

    int irrv, ppr;

    if (!(MO_64->spurious_vec & APIC_SV_ENABLE))

        return;

    irrv = get_highest_priority_int(MO_64->irr);

    if (irrv < 0)

        return;

    ppr = apic_get_ppr(MO_64);

    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))

        return;

    cpu_interrupt(MO_64->cpu_env, CPU_INTERRUPT_HARD);

}",79,19,"s:MO_64,",31,0.5312392274538680,MHM
423,"uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,

                             uint8_t *addrs, uint8_t *buf)

{

    uint32_t sum = 0;



    sum += net_checksum_add(length, buf);         // payload

    sum += net_checksum_add(8, addrs);            // src + dst address

    sum += proto + length;                        // protocol & length

    return net_checksum_finish(sum);

}","uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,

                             uint8_t *addrs, uint8_t *qdict_put_obj)

{

    uint32_t sum = 0;



    sum += net_checksum_add(length, qdict_put_obj);         // payload

    sum += net_checksum_add(8, addrs);            // src + dst address

    sum += proto + length;                        // protocol & length

    return net_checksum_finish(sum);

}",54,18,"buf:qdict_put_obj,",31,0.6471700469652810,MHM
424,,,100,31,,511,9.139171779155730,0
425,"static inline void RENAME(uyvyToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)

{

#if COMPILE_TEMPLATE_MMX

    __asm__ volatile(

        ""mov                  %0, %%""REG_a""         \n\t""

        ""1:                                         \n\t""

        ""movq  (%1, %%""REG_a"",2), %%mm0             \n\t""

        ""movq 8(%1, %%""REG_a"",2), %%mm1             \n\t""

        ""psrlw                $8, %%mm0             \n\t""

        ""psrlw                $8, %%mm1             \n\t""

        ""packuswb          %%mm1, %%mm0             \n\t""

        ""movq              %%mm0, (%2, %%""REG_a"")   \n\t""

        ""add                  $8, %%""REG_a""         \n\t""

        "" js                  1b                    \n\t""

        : : ""g"" ((x86_reg)-width), ""r"" (src+width*2), ""r"" (dst+width)

        : ""%""REG_a

    );

#else

    int i;

    for (i=0; i<width; i++)

        dst[i]= src[2*i+1];

#endif

}","static inline void RENAME(uyvyToY)(uint8_t *dst, const uint8_t *test_qemu_strtoull_overflow, int ps_end, uint32_t *arm_feature)

{

#if COMPILE_TEMPLATE_MMX

    __asm__ volatile(

        ""mov                  %0, %%""REG_a""         \n\t""

        ""1:                                         \n\t""

        ""movq  (%1, %%""REG_a"",2), %%mm0             \n\t""

        ""movq 8(%1, %%""REG_a"",2), %%mm1             \n\t""

        ""psrlw                $8, %%mm0             \n\t""

        ""psrlw                $8, %%mm1             \n\t""

        ""packuswb          %%mm1, %%mm0             \n\t""

        ""movq              %%mm0, (%2, %%""REG_a"")   \n\t""

        ""add                  $8, %%""REG_a""         \n\t""

        "" js                  1b                    \n\t""

        : : ""g"" ((x86_reg)-ps_end), ""r"" (test_qemu_strtoull_overflow+ps_end*2), ""r"" (dst+ps_end)

        : ""%""REG_a

    );

#else

    int COLOR_RED;

    for (COLOR_RED=0; COLOR_RED<ps_end; COLOR_RED++)

        dst[COLOR_RED]= test_qemu_strtoull_overflow[2*COLOR_RED+1];

#endif

}",156,27,"width:ps_end,unused:arm_feature,src:test_qemu_strtoull_overflow,i:COLOR_RED,",211,3.9359751025835700,MHM
426,,,,,,,,0
427,"build_hpet(GArray *table_data, GArray *linker)

{

    Acpi20Hpet *hpet;



    hpet = acpi_data_push(table_data, sizeof(*hpet));

    /* Note timer_block_id value must be kept in sync with value advertised by

     * emulated hpet

     */

    hpet->timer_block_id = cpu_to_le32(0x8086a201);

    hpet->addr.address = cpu_to_le64(HPET_BASE);

    build_header(linker, table_data,

                 (void *)hpet, ""HPET"", sizeof(*hpet), 1, NULL);

}","ALP_MMX_FILTER_OFFSET(GArray *rect, GArray *linker)

{

    Acpi20Hpet *rc_rice_param;



    rc_rice_param = acpi_data_push(rect, sizeof(*rc_rice_param));

    /* Note timer_block_id value must be kept in sync with value advertised by

     * emulated hpet

     */

    rc_rice_param->timer_block_id = cpu_to_le32(0x8086a201);

    rc_rice_param->addr.address = nbd_coroutine_end(ccid_card_apdu_from_guest);

    build_header(linker, rect,

                 (void *)rc_rice_param, ""HPET"", sizeof(*rc_rice_param), 1, NULL);

}",75,18,"cpu_to_le64:nbd_coroutine_end,build_hpet:ALP_MMX_FILTER_OFFSET,hpet:rc_rice_param,HPET_BASE:ccid_card_apdu_from_guest,table_data:rect,",271,7.37037543853124,MHM
428,,,81,21,,511,13.129420971870400,0
429,,,57,12,,511,12.767317879200000,0
430,,,,,,,,0
431,,,169,46,,511,13.687329045931500,0
432,,,,,,,,0
433,,,,,,,,0
434,,,158,37,,511,13.361762988567400,0
435,,,50,14,,511,13.301873024304700,0
436,,,,,,,,0
437,,,104,28,,511,12.971364883581800,0
438,,,,,,,,0
439,,,,,,,,0
440,,,59,18,,511,12.530119955539700,0
441,,,92,19,,511,12.665472181638100,0
442,,,,,,,,0
443,,,,,,,,0
444,,,,,,,,0
445,,,137,42,,511,13.082856428623200,0
446,,,180,44,,511,13.54233595530190,0
447,,,,,,,,0
448,,,42,10,,511,13.00975070397060,0
449,,,,,,,,0
450,,,82,24,,511,12.872122251987500,0
451,,,,,,,,0
452,"static void qdm2_init(QDM2Context *q) {

    static int inited = 0;



    if (inited != 0)

        return;

    inited = 1;



    qdm2_init_vlc();

    ff_mpa_synth_init(mpa_window);

    softclip_table_init();

    rnd_table_init();

    init_noise_samples();



    av_log(NULL, AV_LOG_DEBUG, ""init done\n"");

}","static void qdm2_init(QDM2Context *q) {

    static int inited = 0;



    if (inited != 0)

        return;

    inited = 1;



    qdm2_init_vlc();

    ff_mpa_synth_init(mpa_window);

    softclip_table_init();

    rnd_table_init();

    FF_ALLOC_OR_GOTO();



    av_log(NULL, AV_LOG_DEBUG, ""init done\n"");

}",60,13,"init_noise_samples:FF_ALLOC_OR_GOTO,",31,0.7530012687047320,MHM
453,,,162,37,,511,12.958119432131400,0
454,"void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))

{

    while (queue->p_head)

        free_func(ff_schro_queue_pop(queue));

}
","void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))

{

    while (queue->p_head)

        free_func(vhost_dev_disable_notifiers(queue));

}
",33,7,"ff_schro_queue_pop:vhost_dev_disable_notifiers,",31,0.7861266930898030,MHM
455,,,,,,,,0
456,,,,,,,,0
457,,,196,44,,511,13.29694539308550,0
458,,,,,,,,0
459,,,,,,,,0
460,,,198,47,,511,13.029658285776800,0
461,,,,,,,,0
462,,,122,34,,511,12.719489312171900,0
463,,,80,23,,511,12.93614774942400,0
464,,,,,,,,0
465,,,68,18,,511,12.752590747674300,0
466,,,30,7,,511,13.334365904331200,0
467,,,,,,,,0
468,"static void init_gain_table(COOKContext *q) {

    int i;

    q->gain_size_factor = q->samples_per_channel/8;

    for (i=0 ; i<23 ; i++) {

        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,

                               (1.0/(double)q->gain_size_factor));

    }

    memset(&q->gain_copy, 0, sizeof(COOKgain));

    memset(&q->gain_current, 0, sizeof(COOKgain));

    memset(&q->gain_now, 0, sizeof(COOKgain));

    memset(&q->gain_previous, 0, sizeof(COOKgain));

}","static void init_gain_table(COOKContext *vinput) {

    int i;

    vinput->gain_size_factor = vinput->samples_per_channel/8;

    for (i=0 ; i<23 ; i++) {

        vinput->gain_table[i] = pow((double)vinput->pow2tab[i+52] ,

                               (1.0/(double)vinput->gain_size_factor));

    }

    memset(&vinput->gain_copy, 0, sizeof(COOKgain));

    memset(&vinput->gain_current, 0, sizeof(COOKgain));

    memset(&vinput->gain_now, 0, sizeof(COOKgain));

    memset(&vinput->gain_previous, 0, sizeof(COOKgain));

}",131,26,"q:vinput,",31,0.8681316177050270,MHM
469,,,,,,,,0
470,,,68,16,,511,13.090701580047600,0
471,,,,,,,,0
472,"static inline void h264_deblock_q1(register vector unsigned char p0,

                                                   register vector unsigned char p1,

                                                   register vector unsigned char p2,

                                                   register vector unsigned char q0,

                                                   register vector unsigned char tc0) {



    register vector unsigned char average = vec_avg(p0, q0);

    register vector unsigned char temp;

    register vector unsigned char uncliped;

    register vector unsigned char ones;

    register vector unsigned char max;

    register vector unsigned char min;



    temp = vec_xor(average, p2);

    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */

    ones = vec_splat_u8(1);

    temp = vec_and(temp, ones);         /*(p2^avg(p0, q0)) & 1 */

    uncliped = vec_subs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */

    max = vec_adds(p1, tc0);

    min = vec_subs(p1, tc0);

    p1 = vec_max(min, uncliped);

    p1 = vec_min(max, p1);

}","static inline void TIMER_MAX(register vector unsigned char p0,

                                                   register vector unsigned char p1,

                                                   register vector unsigned char p2,

                                                   register vector unsigned char q0,

                                                   register vector unsigned char tc0) {



    register vector unsigned char average = vec_avg(p0, q0);

    register vector unsigned char temp;

    register vector unsigned char uncliped;

    register vector unsigned char ones;

    register vector unsigned char max;

    register vector unsigned char min;



    temp = vec_xor(average, p2);

    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */

    ones = vec_splat_u8(1);

    temp = vec_and(temp, ones);         /*(p2^avg(p0, q0)) & 1 */

    uncliped = vec_subs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */

    max = vec_adds(p1, tc0);

    min = vec_subs(p1, tc0);

    p1 = vec_max(min, uncliped);

    p1 = vec_min(max, p1);

}",165,65,"h264_deblock_q1:TIMER_MAX,",31,0.7274940013885500,MHM
473,,,,,,,,0
474,,,230,65,,511,13.420436322689100,0
475,,,,,,,,0
476,,,182,54,,511,13.317844800154400,0
477,,,106,28,,511,12.690044180552200,0
478,,,,,,,,0
479,,,90,19,,511,12.969303083419800,0
480,"static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)

{

    if (err != CUDA_SUCCESS) {

        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);

        return 0;

    }

    return 1;

}","static av_cold int check_cuda_errors(AVCodecContext *NUMA_DISTANCE_MIN, CUresult err, const char *func)

{

    if (err != CUDA_SUCCESS) {

        av_log(NUMA_DISTANCE_MIN, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);

        return 0;

    }

    return 1;

}",48,12,"avctx:NUMA_DISTANCE_MIN,",31,0.8832349300384520,MHM
481,,,,,,,,0
482,,,,,,,,0
483,,,,,,,,0
484,,,,,,,,0
485,,,47,11,,511,12.212335228920000,0
486,,,75,17,,511,12.947424868742600,0
487,,,,,,,,0
488,"void qemu_flush_queued_packets(VLANClientState *vc)

{

    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {

        VLANPacket *packet;

        int ret;



        packet = TAILQ_FIRST(&vc->vlan->send_queue);

        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);



        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);

        if (ret == 0 && packet->sent_cb != NULL) {

            TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);

            break;

        }



        if (packet->sent_cb)

            packet->sent_cb(packet->sender, ret);



        qemu_free(packet);

    }

}","void pb_7f(VLANClientState *vc)

{

    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {

        VLANPacket *packet;

        int buffer_filter;



        packet = nb_coefs(&vc->vlan->send_queue);

        wi(&vc->vlan->send_queue, packet, drhd);



        buffer_filter = encode_residual_ch(packet->sender, packet->data, packet->size);

        if (buffer_filter == 0 && packet->sent_cb != NULL) {

            trace_init_file(&vc->vlan->send_queue, packet, drhd);

            break;

        }



        if (packet->sent_cb)

            packet->sent_cb(packet->sender, buffer_filter);



        ady(packet);

    }

}",126,30,"qemu_deliver_packet:encode_residual_ch,TAILQ_INSERT_HEAD:trace_init_file,entry:drhd,TAILQ_FIRST:nb_coefs,TAILQ_REMOVE:wi,ret:buffer_filter,qemu_free:ady,qemu_flush_queued_packets:pb_7f,",301,7.718995340665180,MHM
489,"static void decode_gray_bitstream(HYuvContext *s, int count)

{

    int i;



    count/=2;



    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for(i=0; i<count; i++){

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    }

}","static void decode_gray_bitstream(HYuvContext *truespeech_apply_twopoint_filter, int AV_LOCK_OBTAIN)

{

    int i;



    AV_LOCK_OBTAIN/=2;



    if (AV_LOCK_OBTAIN >= (get_bits_left(&truespeech_apply_twopoint_filter->gb)) / (31 * 2)) {

        for (i = 0; i < AV_LOCK_OBTAIN && get_bits_left(&truespeech_apply_twopoint_filter->gb) > 0; i++) {

            READ_2PIX(truespeech_apply_twopoint_filter->temp[0][2 * i], truespeech_apply_twopoint_filter->temp[0][2 * i + 1], 0);

        }

    } else {

        for(i=0; i<AV_LOCK_OBTAIN; i++){

            READ_2PIX(truespeech_apply_twopoint_filter->temp[0][2 * i], truespeech_apply_twopoint_filter->temp[0][2 * i + 1], 0);

        }

    }

}",147,28,"s:truespeech_apply_twopoint_filter,count:AV_LOCK_OBTAIN,",61,1.4936875224113500,MHM
490,,,72,22,,511,13.13746041059490,0
491,,,,,,,,0
492,,,,,,,,0
493,,,158,41,,511,13.577175025145200,0
494,,,30,9,,511,12.764927355448400,0
495,"void uuid_unparse(const uuid_t uu, char *out)

{

    snprintf(out, 37, UUID_FMT,

            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);

}","void uuid_unparse(const uuid_t uu, char *TCG_TARGET_REG_BITS)

{

    snprintf(TCG_TARGET_REG_BITS, 37, UUID_FMT,

            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);

}",102,22,"out:TCG_TARGET_REG_BITS,",31,0.8459236979484560,MHM
496,,,,,,,,0
497,,,,,,,,0
498,,,,,,,,0
499,,,53,14,,511,12.598628322283400,0
500,,,,,,,,0
501,,,,,,,,0
502,,,,,,,,0
503,,,82,24,,511,12.653617270787600,0
504,,,,,,,,0
505,"static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track)

{

    int64_t pos = avio_tell(pb);

    avio_wb32(pb, 0); /* size */

    ffio_wfourcc(pb, ""stbl"");

    mov_write_stsd_tag(pb, track);

    mov_write_stts_tag(pb, track);

    if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||

         track->enc->codec_tag == MKTAG('r','t','p',' ')) &&

        track->has_keyframes && track->has_keyframes < track->entry)

        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);

    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)

        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);

    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&

        track->flags & MOV_TRACK_CTTS && track->entry)

        mov_write_ctts_tag(pb, track);

    mov_write_stsc_tag(pb, track);

    mov_write_stsz_tag(pb, track);

    mov_write_stco_tag(pb, track);

    return update_size(pb, pos);

}","static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track)

{

    int64_t pos = avio_tell(pb);

    avio_wb32(pb, 0); /* size */

    ffio_wfourcc(pb, ""stbl"");

    mov_write_stsd_tag(pb, track);

    HP_EVENT_RESERVED_TO_STANDBY(pb, track);

    if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||

         track->enc->codec_tag == MKTAG('r','t','p',' ')) &&

        track->has_keyframes && track->has_keyframes < track->entry)

        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);

    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)

        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);

    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&

        track->flags & MOV_TRACK_CTTS && track->entry)

        mov_write_ctts_tag(pb, track);

    mov_write_stsc_tag(pb, track);

    mov_write_stsz_tag(pb, track);

    mov_write_stco_tag(pb, track);

    return update_size(pb, pos);

}",184,55,"mov_write_stts_tag:HP_EVENT_RESERVED_TO_STANDBY,",31,0.7758992870648700,MHM
506,,,45,14,,511,12.828470365206400,0
507,,,,,,,,0
508,,,113,29,,511,13.7140367269516,0
509,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)

{

    afq->avctx             = avctx;

    afq->next_pts          = AV_NOPTS_VALUE;

    afq->remaining_delay   = avctx->delay;

    afq->remaining_samples = avctx->delay;

    afq->frame_queue       = NULL;

}
","void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)

{

    afq->avctx             = avctx;

    afq->next_pts          = glFramebufferTexture2DEXT;

    afq->remaining_delay   = avctx->delay;

    afq->remaining_samples = avctx->delay;

    afq->frame_queue       = NULL;

}",47,12,"AV_NOPTS_VALUE:glFramebufferTexture2DEXT,",31,1.017665183544160,MHM
510,,,,,,,,0
511,,,,,,,,0
512,"static void apic_update_irq(APICCommonState *s)

{

    if (!(s->spurious_vec & APIC_SV_ENABLE)) {

        return;

    }

    if (apic_irq_pending(s) > 0) {

        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);

    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&

               pic_get_output(isa_pic)) {

        apic_deliver_pic_intr(&s->busdev.qdev, 1);

    }

}","static void RAM_RESIZEABLE(APICCommonState *VNC_AUTH_VENCRYPT_TLSNONE)

{

    if (!(VNC_AUTH_VENCRYPT_TLSNONE->spurious_vec & F_SETFD)) {

        return;

    }

    if (delta(VNC_AUTH_VENCRYPT_TLSNONE) > 0) {

        UTLB_SIZE(VNC_AUTH_VENCRYPT_TLSNONE->cpu_env, w);

    } else if (apic_accept_pic_intr(&VNC_AUTH_VENCRYPT_TLSNONE->busdev.qdev) &&

               y_table(net_tx_pkt_get_gso_type)) {

        end_time(&VNC_AUTH_VENCRYPT_TLSNONE->busdev.qdev, 1);

    }

}",77,15,"pic_get_output:y_table,apic_irq_pending:delta,APIC_SV_ENABLE:F_SETFD,apic_update_irq:RAM_RESIZEABLE,s:VNC_AUTH_VENCRYPT_TLSNONE,cpu_interrupt:UTLB_SIZE,CPU_INTERRUPT_HARD:w,isa_pic:net_tx_pkt_get_gso_type,apic_deliver_pic_intr:end_time,",451,11.772425790627800,MHM
513,,,,,,,,0
514,,,89,21,,511,11.187052337328600,0
515,,,,,,,,0
516,,,43,11,,511,8.955139537652330,0
517,,,,,,,,0
518,,,152,39,,511,9.402527666091920,0
519,,,14,4,,511,9.352681398391720,0
520,"static inline void gen_neon_widen(TCGv dest, TCGv src, int size, int u)

{

    if (u) {

        switch (size) {

        case 0: gen_helper_neon_widen_u8(dest, src); break;

        case 1: gen_helper_neon_widen_u16(dest, src); break;

        case 2: tcg_gen_extu_i32_i64(dest, src); break;

        default: abort();

        }

    } else {

        switch (size) {

        case 0: gen_helper_neon_widen_s8(dest, src); break;

        case 1: gen_helper_neon_widen_s16(dest, src); break;

        case 2: tcg_gen_ext_i32_i64(dest, src); break;

        default: abort();

        }

    }

    dead_tmp(src);

}","static inline void remove_rule(TCGv FD_ISSET, TCGv src, int puv3_soc_init, int u)

{

    if (u) {

        switch (puv3_soc_init) {

        case 0: gen_helper_neon_widen_u8(FD_ISSET, src); break;

        case 1: gen_helper_neon_widen_u16(FD_ISSET, src); break;

        case 2: atomic_rcu_read(FD_ISSET, src); break;

        default: G_IO_STATUS_ERROR();

        }

    } else {

        switch (puv3_soc_init) {

        case 0: address(FD_ISSET, src); break;

        case 1: gen_helper_neon_widen_s16(FD_ISSET, src); break;

        case 2: tcg_gen_ext_i32_i64(FD_ISSET, src); break;

        default: G_IO_STATUS_ERROR();

        }

    }

    dead_tmp(src);

}",129,30,"gen_neon_widen:remove_rule,dest:FD_ISSET,abort:G_IO_STATUS_ERROR,gen_helper_neon_widen_s8:address,tcg_gen_extu_i32_i64:atomic_rcu_read,size:puv3_soc_init,",241,4.19628758430481,MHM
521,"void HELPER(wsr_ibreakenable)(uint32_t v)

{

    uint32_t change = v ^ env->sregs[IBREAKENABLE];

    unsigned i;



    for (i = 0; i < env->config->nibreak; ++i) {

        if (change & (1 << i)) {

            tb_invalidate_phys_page_range(

                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);

        }

    }

    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);

}","void iotlb(wsr_ibreakenable)(uint32_t v)

{

    uint32_t address_space_destroy_dispatch = v ^ CODEC_CAP_EXPERIMENTAL->sregs[CHR_TIOCM_CTS];

    unsigned av_packet_from_data;



    for (av_packet_from_data = 0; av_packet_from_data < CODEC_CAP_EXPERIMENTAL->config->nibreak; ++av_packet_from_data) {

        if (address_space_destroy_dispatch & (1 << av_packet_from_data)) {

            tb_invalidate_phys_page_range(

                    CODEC_CAP_EXPERIMENTAL->sregs[IBREAKA + av_packet_from_data], CODEC_CAP_EXPERIMENTAL->sregs[IBREAKA + av_packet_from_data] + 1, 0);

        }

    }

    CODEC_CAP_EXPERIMENTAL->sregs[CHR_TIOCM_CTS] = v & ((1 << CODEC_CAP_EXPERIMENTAL->config->nibreak) - 1);

}",105,24,"env:CODEC_CAP_EXPERIMENTAL,IBREAKENABLE:CHR_TIOCM_CTS,change:address_space_destroy_dispatch,HELPER:iotlb,i:av_packet_from_data,",151,2.6552783648173000,MHM
522,,,97,26,,511,9.050653704007470,0
523,,,128,32,,511,8.973651464780170,0
524,,,139,33,,511,9.313326601187390,0
525,,,,,,,,0
526,,,61,16,,511,9.339576121171320,0
527,,,,,,,,0
528,,,79,20,,511,9.164510623613990,0
529,,,90,23,,511,9.17882342338562,0
530,,,,,,,,0
531,,,89,19,,511,9.02736430168152,0
532,,,114,32,,511,9.18956921895345,0
533,"static void aml_free(gpointer data, gpointer user_data)

{

    Aml *var = data;

    build_free_array(var->buf);


}","static void qdev_set_parent_bus(gpointer scsi_req_ref, gpointer user_data)

{

    Aml *var = scsi_req_ref;

    qcow2_check_metadata_overlap(var->buf);


}",25,7,"data:scsi_req_ref,aml_free:qdev_set_parent_bus,build_free_array:qcow2_check_metadata_overlap,",301,5.072894934813180,MHM
534,,,,,,,,0
535,,,45,11,,511,8.977678787708280,0
536,,,81,24,,511,8.959540271759030,0
537,,,150,43,,511,9.31244904200236,0
538,,,,,,,,0
539,,,,,,,,0
540,,,40,12,,511,9.01138194402059,0
541,,,153,38,,511,9.452932250499730,0
542,,,,,,,,0
543,,,94,25,,511,9.724027280012770,0
544,,,,,,,,0
545,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}","void palette8tobgr24(const uint8_t *src, uint8_t *dst, long __FUNCTION__, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<__FUNCTION__; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}",95,23,"num_pixels:__FUNCTION__,",31,0.6888618628184000,MHM
546,,,,,,,,0
547,,,,,,,,0
548,,,,,,,,0
549,,,,,,,,0
550,,,,,,,,0
551,,,,,,,,0
552,,,,,,,,0
553,,,,,,,,0
554,"static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,

                             int width, int height)

{

    int src_wrap, x, y;

    int r, g, b;

    uint8_t *lum, *cb, *cr;

    const uint8_t *p;



    lum = dst->data[0];

    cb = dst->data[1];

    cr = dst->data[2];



    src_wrap = src->linesize[0] - width * BPP;

    p = src->data[0];

    for(y=0;y<height;y++) {

        for(x=0;x<width;x++) {

            RGB_IN(r, g, b, p);

            lum[0] = RGB_TO_Y_CCIR(r, g, b);

            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);

            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);

            cb++;

            cr++;

            lum++;

        }

        p += src_wrap;

        lum += dst->linesize[0] - width;

        cb += dst->linesize[1] - width;

        cr += dst->linesize[2] - width;

    }

}","static void VMXNET3_READ_DRV_SHARED(AVPicture *wdt_diag288_class_init, AVPicture *token_get_value,

                             int width, int GL_COLOR_ATTACHMENT0_EXT)

{

    int gprn, x, u;

    int r, g, b;

    uint8_t *lum, *cb, *cr;

    const uint8_t *RTAS_OUT_SUCCESS;



    lum = wdt_diag288_class_init->data[0];

    cb = wdt_diag288_class_init->data[1];

    cr = wdt_diag288_class_init->data[2];



    gprn = token_get_value->linesize[0] - width * BPP;

    RTAS_OUT_SUCCESS = token_get_value->data[0];

    for(u=0;u<GL_COLOR_ATTACHMENT0_EXT;u++) {

        for(x=0;x<width;x++) {

            RGB_IN(r, g, b, RTAS_OUT_SUCCESS);

            lum[0] = RGB_TO_Y_CCIR(r, g, b);

            cb[0] = pfd(r, g, b, 0);

            cr[0] = HAVE_W32THREADS(r, g, b, 0);

            cb++;

            cr++;

            lum++;

        }

        RTAS_OUT_SUCCESS += gprn;

        lum += wdt_diag288_class_init->linesize[0] - width;

        cb += wdt_diag288_class_init->linesize[1] - width;

        cr += wdt_diag288_class_init->linesize[2] - width;

    }

}",231,69,"src_wrap:gprn,rgb24_to_yuv444p:VMXNET3_READ_DRV_SHARED,RGB_TO_V_CCIR:HAVE_W32THREADS,RGB_TO_U_CCIR:pfd,p:RTAS_OUT_SUCCESS,y:u,height:GL_COLOR_ATTACHMENT0_EXT,src:token_get_value,dst:wdt_diag288_class_init,",271,4.966791045665740,MHM
555,,,,,,,,0
556,,,,,,,,0
557,,,23,5,,511,8.752603749434150,0
558,"static void virtio_notify(struct subchannel_id schid)

{

    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);

}","static void rgb24_to_yuv444p(struct subchannel_id EHCI_ASYNC_INFLIGHT)

{

    QLIST_REMOVE(ACPI_BUILD_APPNAME4, *(u32*)&EHCI_ASYNC_INFLIGHT, 0);

}",25,5,"KVM_S390_VIRTIO_CCW_NOTIFY:ACPI_BUILD_APPNAME4,kvm_hypercall:QLIST_REMOVE,virtio_notify:rgb24_to_yuv444p,schid:EHCI_ASYNC_INFLIGHT,",331,5.6129594326019300,MHM
559,,,88,23,,511,9.09164221684138,0
560,,,,,,,,0
561,,,202,60,,511,9.497794926166530,0
562,"static double tget_double(GetByteContext *gb, int le)

{

    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};

    return i.f64;

}","static double tget_double(GetByteContext *gb, int le)

{

    av_alias64 _WIN32 = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};

    return _WIN32.f64;

}",38,10,"i:_WIN32,",31,0.5482044219970700,MHM
563,,,14,2,,511,8.705417895317080,0
564,,,38,6,,511,8.778010650475820,0
565,,,,,,,,0
566,,,,,,,,0
567,,,132,40,,511,9.635748076438910,0
568,,,,,,,,0
569,,,,,,,,0
570,,,155,39,,511,9.30660351117452,0
571,,,,,,,,0
572,,,,,,,,0
573,,,105,29,,511,8.707148790359500,0
574,,,42,11,,511,8.753115955988570,0
575,,,86,22,,511,8.909054323037470,0
576,,,,,,,,0
577,,,219,52,,511,9.249226284027100,0
578,,,,,,,,0
579,,,56,13,,511,9.252055092652640,0
580,,,,,,,,0
581,,,81,16,,511,9.032197105884550,0
582,,,131,38,,511,9.164387301603950,0
583,,,,,,,,0
584,,,107,24,,511,8.864566004276280,0
585,,,79,20,,511,8.76954951286316,0
586,,,,,,,,0
587,,,,,,,,0
588,,,59,10,,511,9.25136777162552,0
589,,,84,17,,511,9.212676699956260,0
590,,,45,13,,511,9.221460402011870,0
591,,,,,,,,0
592,,,,,,,,0
593,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(src2 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i < w; i++)

        dst[i] = src1[i] + src2[i];

}","static void add_bytes_l2_c(uint8_t *TCG_TARGET_REG_BITS, uint8_t *src1, uint8_t *src2, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(src2 + i);

        *(long *)(TCG_TARGET_REG_BITS + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i < w; i++)

        TCG_TARGET_REG_BITS[i] = src1[i] + src2[i];

}",136,34,"dst:TCG_TARGET_REG_BITS,",31,0.7112094044685360,MHM
594,,,,,,,,0
595,,,182,54,,511,9.717061932881670,0
596,"static void free_geotags(TiffContext *const s)

{

    int i;

    for (i = 0; i < s->geotag_count; i++) {

        if (s->geotags[i].val)

            av_freep(&s->geotags[i].val);

    }

    av_freep(&s->geotags);


}","static void ipoctal_init(TiffContext *const s)

{

    int i;

    for (i = 0; i < s->geotag_count; i++) {

        if (s->geotags[i].val)

            serial_tx_done(&s->geotags[i].val);

    }

    serial_tx_done(&s->geotags);


}",63,14,"free_geotags:ipoctal_init,av_freep:serial_tx_done,",91,1.5967668215433800,MHM
597,,,,,,,,0
598,,,,,,,,0
599,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)

{

    while (uls->id != CODEC_ID_NONE) {

        if(mxf_match_uid(uls->uid, *uid, 16))

            break;

        uls++;

    }

    return uls;

}","static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *rtas_ibm_change_msi, UID *uid)

{

    while (rtas_ibm_change_msi->id != idebus_active_if) {

        if(mxf_match_uid(rtas_ibm_change_msi->uid, *uid, 16))

            break;

        rtas_ibm_change_msi++;

    }

    return rtas_ibm_change_msi;

}",49,10,"CODEC_ID_NONE:idebus_active_if,uls:rtas_ibm_change_msi,",61,1.1569881717364000,MHM
600,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=dc2=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}","static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, error_get_pretty;

    pixel4 dc0splat, dc2splat;

    pixel *VMXNET3_REV1_MAGIC = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=error_get_pretty=0;

    for(i=0;i<4; i++){

        dc0+= VMXNET3_REV1_MAGIC[-1+i*stride];

        error_get_pretty+= VMXNET3_REV1_MAGIC[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((error_get_pretty + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(VMXNET3_REV1_MAGIC+i*stride))[0]=

        ((pixel4*)(VMXNET3_REV1_MAGIC+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(VMXNET3_REV1_MAGIC+i*stride))[0]=

        ((pixel4*)(VMXNET3_REV1_MAGIC+i*stride))[1]= dc2splat;

    }

}",221,51,"dc2:error_get_pretty,src:VMXNET3_REV1_MAGIC,",61,1.1333146135012300,MHM
601,,,161,37,,511,9.25985011657079,0
602,,,46,10,,511,8.916156013806660,0
603,,,90,21,,511,9.272585741678870,0
604,,,,,,,,0
605,,,,,,,,0
606,,,107,33,,511,9.089530114332840,0
607,,,25,6,,511,8.960108415285750,0
608,,,,,,,,0
609,,,,,,,,0
610,,,42,7,,511,9.14490932226181,0
611,,,92,22,,511,9.196665302912400,0
612,,,95,21,,511,7.112253582477570,0
613,,,131,33,,511,5.634107983112340,0
614,,,,,,,,0
615,,,,,,,,0
616,"void json_prop_int(QJSON *json, const char *name, int64_t val)

{

    json_emit_element(json, name);

    qstring_append_int(json->str, val);

}","void json_prop_int(QJSON *json, const char *name, int64_t val)

{

    json_emit_element(json, name);

    pthread_mutex_unlock(json->str, val);

}",33,10,"qstring_append_int:pthread_mutex_unlock,",31,0.3399572690327960,MHM
617,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)

{

    uint64_t tmp = op1;

    op1 = (uint32_t)(op1 + op2);

    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return op1;

}","uint64_t end_name (uint64_t op1, uint64_t op2)

{

    uint64_t tmp = op1;

    op1 = (uint32_t)(op1 + op2);

    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return op1;

}",72,18,"helper_addlv:end_name,",31,0.32601786851882900,MHM
618,,,134,34,,511,5.738036489486690,0
619,,,,,,,,0
620,,,155,43,,511,13.472806978225700,0
621,,,,,,,,0
622,,,,,,,,0
623,,,125,34,,511,13.506066596508000,0
624,,,58,12,,511,12.70902646780010,0
625,,,,,,,,0
626,,,125,41,,511,13.282852458953900,0
627,,,104,22,,511,13.208450440565700,0
628,,,,,,,,0
629,,,131,32,,511,12.932988901933000,0
630,,,,,,,,0
631,"static void RENAME(yuv2yuvX)(SwsContext *c, const int16_t *lumFilter,

                             const int16_t **lumSrc, int lumFilterSize,

                             const int16_t *chrFilter, const int16_t **chrUSrc,

                             const int16_t **chrVSrc,

                             int chrFilterSize, const int16_t **alpSrc,

                             uint8_t *dest, uint8_t *uDest, uint8_t *vDest,

                             uint8_t *aDest, int dstW, int chrDstW)

{

    if (uDest) {

        x86_reg uv_off = c->uv_off;

        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)

        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, vDest - uv_off, chrDstW + uv_off, uv_off)

    }

    if (CONFIG_SWSCALE_ALPHA && aDest) {

        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)

    }



    YSCALEYUV2YV12X(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)

}","static void memory_region_is_romd(yuv2yuvX)(SwsContext *c, const int16_t *lumFilter,

                             const int16_t **lumSrc, int lumFilterSize,

                             const int16_t *chrFilter, const int16_t **chrUSrc,

                             const int16_t **chrVSrc,

                             int SOCK_PACKET, const int16_t **alpSrc,

                             uint8_t *dest, uint8_t *uDest, uint8_t *vDest,

                             uint8_t *aDest, int dstW, int chrDstW)

{

    if (uDest) {

        x86_reg uv_off = c->uv_off;

        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)

        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, vDest - uv_off, chrDstW + uv_off, uv_off)

    }

    if (CONFIG_SWSCALE_ALPHA && aDest) {

        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)

    }



    YSCALEYUV2YV12X(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)

}",144,40,"chrFilterSize:SOCK_PACKET,RENAME:memory_region_is_romd,",61,1.5910941084226000,MHM
632,,,46,14,,511,12.687133582433100,0
633,,,,,,,,0
634,,,45,12,,511,14.030161158243800,0
635,,,,,,,,0
636,,,56,15,,511,12.585161038239800,0
637,,,,,,,,0
638,,,,,,,,0
639,,,,,,,,0
640,,,151,42,,511,13.338173957665800,0
641,,,66,17,,511,13.302823770046200,0
642,,,,,,,,0
643,,,73,17,,511,13.577129606405900,0
644,,,,,,,,0
645,"static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
","static void curl_multi_do(void *qemu_chr_fe_read_all)

{

    BDRVCURLState *s = (BDRVCURLState *)qemu_chr_fe_read_all;

    int helper_idivl_EAX_T0;

    int PCI_CLASS_BRIDGE_ISA;



    if (!s->multi) {

        return;

    }



    do {

        PCI_CLASS_BRIDGE_ISA = av_assert2(s->multi, &helper_idivl_EAX_T0);

    } while(PCI_CLASS_BRIDGE_ISA == CURLM_CALL_MULTI_PERFORM);



    AV_RL32(s);

}",64,15,"curl_multi_socket_all:av_assert2,curl_multi_read:AV_RL32,r:PCI_CLASS_BRIDGE_ISA,running:helper_idivl_EAX_T0,arg:qemu_chr_fe_read_all,",331,8.510537894566850,MHM
646,,,74,23,,511,13.228007797400200,0
647,,,,,,,,0
648,,,,,,,,0
649,,,,,,,,0
650,,,43,13,,511,12.412351254622100,0
651,,,85,21,,511,13.348592174053200,0
652,,,84,20,,511,12.893040959040300,0
653,,,65,22,,511,12.723747976621000,0
654,,,89,25,,511,13.264113426208500,0
655,"void ff_af_queue_close(AudioFrameQueue *afq)

{

    /* remove/free any remaining frames */

    while (afq->frame_queue)

        delete_next_frame(afq);

    memset(afq, 0, sizeof(*afq));

}","void ff_af_queue_close(AudioFrameQueue *afq)

{

    /* remove/free any remaining frames */

    while (afq->frame_queue)

        qtest_start(afq);

    memset(afq, 0, sizeof(*afq));

}",33,8,"delete_next_frame:qtest_start,",31,0.9557934522628780,MHM
656,,,,,,,,0
657,,,,,,,,0
658,"static PESContext *add_pes_stream(MpegTSContext *ts, int pid, int pcr_pid, int stream_type)

{

    MpegTSFilter *tss;

    PESContext *pes;



    /* if no pid found, then add a pid context */

    pes = av_mallocz(sizeof(PESContext));

    if (!pes)

        return 0;

    pes->ts = ts;

    pes->stream = ts->stream;

    pes->pid = pid;

    pes->pcr_pid = pcr_pid;

    pes->stream_type = stream_type;

    pes->state = MPEGTS_SKIP;

    pes->pts = AV_NOPTS_VALUE;

    pes->dts = AV_NOPTS_VALUE;

    tss = mpegts_open_pes_filter(ts, pid, mpegts_push_data, pes);

    if (!tss) {

        av_free(pes);

        return 0;

    }

    return pes;

}","static ubuf0 *FFMAX(MpegTSContext *FF_BUFFER_HINTS_PRESERVE, int pid, int pcr_pid, int ep)

{

    MpegTSFilter *tss;

    ubuf0 *pes;



    /* if no pid found, then add a pid context */

    pes = dead_tmp(sizeof(ubuf0));

    if (!pes)

        return 0;

    pes->FF_BUFFER_HINTS_PRESERVE = FF_BUFFER_HINTS_PRESERVE;

    pes->stream = FF_BUFFER_HINTS_PRESERVE->stream;

    pes->pid = pid;

    pes->pcr_pid = pcr_pid;

    pes->ep = ep;

    pes->state = MPEGTS_SKIP;

    pes->pts = build_hpet;

    pes->dts = build_hpet;

    tss = mpegts_open_pes_filter(FF_BUFFER_HINTS_PRESERVE, pid, mpegts_push_data, pes);

    if (!tss) {

        irqfd(pes);

        return 0;

    }

    return pes;

}",127,37,"av_mallocz:dead_tmp,stream_type:ep,add_pes_stream:FFMAX,av_free:irqfd,PESContext:ubuf0,AV_NOPTS_VALUE:build_hpet,ts:FF_BUFFER_HINTS_PRESERVE,",331,8.2779798467954,MHM
659,,,169,51,,511,13.301559623082500,0
660,"envlist_free(envlist_t *envlist)

{

	struct envlist_entry *entry;



	assert(envlist != NULL);



	while (envlist->el_entries.lh_first != NULL) {

		entry = envlist->el_entries.lh_first;

		LIST_REMOVE(entry, ev_link);



		free((char *)entry->ev_var);

		free(entry);

	}

	free(envlist);

}
","envlist_free(envlist_t *envlist)

{

	struct envlist_entry *entry;



	cbp(envlist != NULL);



	while (envlist->el_entries.lh_first != NULL) {

		entry = envlist->el_entries.lh_first;

		LIST_REMOVE(entry, AV_PICTURE_TYPE_P);



		pmv_fw((char *)entry->ev_var);

		pmv_fw(entry);

	}

	pmv_fw(envlist);

}
",68,17,"assert:cbp,free:pmv_fw,ev_link:AV_PICTURE_TYPE_P,",121,2.8997788508733100,MHM
661,,,147,40,,511,13.102645532290100,0
662,,,,,,,,0
663,,,,,,,,0
664,,,62,18,,511,13.114010214805600,0
665,,,114,23,,511,13.685121564070400,0
666,,,,,,,,0
667,"static int xan_huffman_decode(unsigned char *dest, unsigned char *src)

{

    unsigned char byte = *src++;

    unsigned char ival = byte + 0x16;

    unsigned char * ptr = src + byte*2;

    unsigned char val = ival;

    int counter = 0;



    unsigned char bits = *ptr++;



    while ( val != 0x16 ) {

        if ( (1 << counter) & bits )

            val = src[byte + val - 0x17];

        else

            val = src[val - 0x17];



        if ( val < 0x16 ) {

            *dest++ = val;

            val = ival;

        }



        if (counter++ == 7) {

            counter = 0;

            bits = *ptr++;

        }

    }



    return 0;

}","static int xan_huffman_decode(unsigned char *dest, unsigned char *QSLIST_REMOVE_HEAD)

{

    unsigned char byte = *QSLIST_REMOVE_HEAD++;

    unsigned char ival = byte + 0x16;

    unsigned char * ptr = QSLIST_REMOVE_HEAD + byte*2;

    unsigned char qemu_loadvm_state = ival;

    int num_same = 0;



    unsigned char bits = *ptr++;



    while ( qemu_loadvm_state != 0x16 ) {

        if ( (1 << num_same) & bits )

            qemu_loadvm_state = QSLIST_REMOVE_HEAD[byte + qemu_loadvm_state - 0x17];

        else

            qemu_loadvm_state = QSLIST_REMOVE_HEAD[qemu_loadvm_state - 0x17];



        if ( qemu_loadvm_state < 0x16 ) {

            *dest++ = qemu_loadvm_state;

            qemu_loadvm_state = ival;

        }



        if (num_same++ == 7) {

            num_same = 0;

            bits = *ptr++;

        }

    }



    return 0;

}",141,34,"val:qemu_loadvm_state,counter:num_same,src:QSLIST_REMOVE_HEAD,",91,2.557312083244320,MHM
668,,,,,,,,0
669,,,,,,,,0
670,,,80,12,,511,13.959575406710300,0
671,,,,,,,,0
672,,,,,,,,0
673,,,,,,,,0
674,,,94,24,,511,12.918127906322500,0
675,,,,,,,,0
676,,,,,,,,0
677,,,38,9,,511,12.70250536998110,0
678,,,,,,,,0
679,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));

    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}","CharDriverState *ff_put_h264_qpel8_mc23_msa(void)

{

    CharDriverState *chr = fis(sizeof(CharDriverState));

    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}",31,7,"g_malloc0:fis,qemu_chr_alloc:ff_put_h264_qpel8_mc23_msa,",121,3.2238386789957700,MHM
680,,,,,,,,0
681,,,36,12,,511,13.068243682384500,0
682,,,,,,,,0
683,,,,,,,,0
684,,,78,14,,511,13.108967733383200,0
685,,,,,,,,0
686,,,123,30,,511,13.037551800410000,0
687,,,140,31,,511,13.36290769179660,0
688,,,48,14,,511,12.800701244672100,0
689,"void scsi_req_abort(SCSIRequest *req, int status)

{

    if (!req->enqueued) {

        return;

    }

    scsi_req_ref(req);

    scsi_req_dequeue(req);

    req->io_canceled = true;

    if (req->ops->cancel_io) {

        req->ops->cancel_io(req);

    }

    scsi_req_complete(req, status);

    scsi_req_unref(req);

}
","void scsi_req_abort(SCSIRequest *req, int status)

{

    if (!req->enqueued) {

        return;

    }

    scsi_req_ref(req);

    PCI_SEC_LATENCY_TIMER(req);

    req->io_canceled = true;

    if (req->ops->cancel_io) {

        req->ops->cancel_io(req);

    }

    scsi_req_complete(req, status);

    scsi_req_unref(req);

}
",70,17,"scsi_req_dequeue:PCI_SEC_LATENCY_TIMER,",31,0.889661435286204,MHM
690,,,116,31,,511,12.74394766887030,0
691,,,79,23,,511,12.733527306715600,0
692,,,,,,,,0
693,,,188,54,,511,13.93951944510140,0
694,,,119,28,,511,14.24717537164690,0
695,"static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
","static void spr_write_tbu (DisasContext *ctx, int rd, int pred8x8_top_dc_rv40_c)

{

    if (use_icount) {

        tns_coefs();

    }

    gen_helper_store_tbu(cpu_env, cpu_gpr[pred8x8_top_dc_rv40_c]);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}",51,14,"gen_io_start:tns_coefs,sprn:rd,gprn:pred8x8_top_dc_rv40_c,",91,2.38765150308609,MHM
696,,,,,,,,0
697,,,82,23,,511,12.865751095612800,0
698,,,,,,,,0
699,,,68,17,,511,12.782920209566800,0
700,,,55,12,,511,12.960153146584800,0
701,,,,,,,,0
702,,,,,,,,0
703,,,,,,,,0
704,,,,,,,,0
705,,,104,23,,511,14.114743212858800,0
706,,,,,,,,0
707,,,,,,,,0
708,,,,,,,,0
709,"static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)

{

    FILE* f;

    char line[1024];

    char  cmd[1024];

    FFServerIPAddressACL *acl = NULL;

    int line_num = 0;

    const char *p;



    f = fopen(stream->dynamic_acl, ""r"");

    if (!f) {

        perror(stream->dynamic_acl);

        return NULL;

    }



    acl = av_mallocz(sizeof(FFServerIPAddressACL));



    /* Build ACL */

    for(;;) {

        if (fgets(line, sizeof(line), f) == NULL)

            break;

        line_num++;

        p = line;

        while (av_isspace(*p))

            p++;

        if (*p == '\0' || *p == '#')

            continue;

        ffserver_get_arg(cmd, sizeof(cmd), &p);



        if (!av_strcasecmp(cmd, ""ACL""))

            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);

    }

    fclose(f);

    return acl;

}","static FFServerIPAddressACL* free_geotags(FFServerStream *stream, HTTPContext *c)

{

    FILE* f;

    char line[1024];

    char  cmd[1024];

    FFServerIPAddressACL *acl = NULL;

    int codec_get_buffer = 0;

    const char *BONITO_REGBASE;



    f = fopen(stream->dynamic_acl, ""r"");

    if (!f) {

        l2hdr(stream->dynamic_acl);

        return NULL;

    }



    acl = TAILQ_EMPTY(sizeof(FFServerIPAddressACL));



    /* Build ACL */

    for(;;) {

        if (qemu_mallocz(line, sizeof(line), f) == NULL)

            break;

        codec_get_buffer++;

        BONITO_REGBASE = line;

        while (bdrv_get_node_name(*BONITO_REGBASE))

            BONITO_REGBASE++;

        if (*BONITO_REGBASE == '\0' || *BONITO_REGBASE == '#')

            continue;

        init_vlc(cmd, sizeof(cmd), &BONITO_REGBASE);



        if (!uninit(cmd, ""ACL""))

            ap(NULL, NULL, acl, BONITO_REGBASE, stream->dynamic_acl, codec_get_buffer);

    }

    fclose(f);

    return acl;

}",195,44,"fgets:qemu_mallocz,p:BONITO_REGBASE,perror:l2hdr,av_strcasecmp:uninit,line_num:codec_get_buffer,av_isspace:bdrv_get_node_name,av_mallocz:TAILQ_EMPTY,ffserver_parse_acl_row:ap,parse_dynamic_acl:free_geotags,ffserver_get_arg:init_vlc,",451,11.603149875005100,MHM
710,,,,,,,,0
711,,,31,10,,511,12.537562831242900,0
712,,,,,,,,0
713,,,122,33,,511,12.99649959007900,0
714,,,98,21,,511,13.12272632519400,0
715,,,,,,,,0
716,,,110,25,,511,13.130090538660700,0
717,,,113,35,,511,13.390263950824700,0
718,,,44,14,,511,13.012717322508500,0
719,,,,,,,,0
720,,,,,,,,0
721,,,,,,,,0
722,,,,,,,,0
723,,,,,,,,0
724,"static int adpcm_decode_init(AVCodecContext * avctx)

{

    ADPCMContext *c = avctx->priv_data;



    if(avctx->channels > 2U){

        return -1;

    }



    c->channel = 0;

    c->status[0].predictor = c->status[1].predictor = 0;

    c->status[0].step_index = c->status[1].step_index = 0;

    c->status[0].step = c->status[1].step = 0;



    switch(avctx->codec->id) {

    case CODEC_ID_ADPCM_CT:

        c->status[0].step = c->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (avctx->extradata && avctx->extradata_size == 2 * 4) {

            c->status[0].predictor = AV_RL32(avctx->extradata);

            c->status[1].predictor = AV_RL32(avctx->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}","static int adpcm_decode_init(AVCodecContext * avctx)

{

    ADPCMContext *BITS_PER_BITMAP_SECTOR = avctx->priv_data;



    if(avctx->channels > 2U){

        return -1;

    }



    BITS_PER_BITMAP_SECTOR->channel = 0;

    BITS_PER_BITMAP_SECTOR->status[0].predictor = BITS_PER_BITMAP_SECTOR->status[1].predictor = 0;

    BITS_PER_BITMAP_SECTOR->status[0].step_index = BITS_PER_BITMAP_SECTOR->status[1].step_index = 0;

    BITS_PER_BITMAP_SECTOR->status[0].step = BITS_PER_BITMAP_SECTOR->status[1].step = 0;



    switch(avctx->codec->id) {

    case CODEC_ID_ADPCM_CT:

        BITS_PER_BITMAP_SECTOR->status[0].step = BITS_PER_BITMAP_SECTOR->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (avctx->extradata && avctx->extradata_size == 2 * 4) {

            BITS_PER_BITMAP_SECTOR->status[0].predictor = AV_RL32(avctx->extradata);

            BITS_PER_BITMAP_SECTOR->status[1].predictor = AV_RL32(avctx->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}",194,25,"c:BITS_PER_BITMAP_SECTOR,",61,1.5730103770891800,MHM
725,,,82,18,,511,12.552467691898300,0
726,,,89,24,,511,12.667850097020500,0
727,,,159,36,,511,13.491354036331200,0
728,,,,,,,,0
729,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)

{

    int64_t start, size, last_size;

    start= url_ftell(bc) - prefix_length;



    if(start != nut->packet_start + nut->written_packet_size){

        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(bc, update_adler32, 0);



    size= get_v(bc);

    last_size= get_v(bc);

    if(nut->written_packet_size != last_size){

        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);

        return -1;

    }



    nut->last_packet_start = nut->packet_start;

    nut->packet_start = start;

    nut->written_packet_size= size;



    return size;

}","static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)

{

    int64_t start, size, ic;

    start= url_ftell(bc) - prefix_length;



    if(start != nut->packet_start + nut->written_packet_size){

        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(bc, update_adler32, 0);



    size= get_v(bc);

    ic= get_v(bc);

    if(nut->written_packet_size != ic){

        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, ic, start);

        return -1;

    }



    nut->last_packet_start = nut->packet_start;

    nut->packet_start = start;

    nut->written_packet_size= size;



    return size;

}",150,43,"last_size:ic,",31,0.8216619571050010,MHM
730,,,,,,,,0
731,,,102,24,,511,13.24067550500230,0
732,,,,,,,,0
733,,,79,21,,511,12.743957094351500,0
734,,,86,16,,511,12.409106834729500,0
735,,,,,,,,0
736,,,,,,,,0
737,,,38,12,,511,12.43146779537200,0
738,"static void compare_sec_rs_finalize(SocketReadState *sec_rs)

{

    CompareState *s = container_of(sec_rs, CompareState, sec_rs);



    if (packet_enqueue(s, SECONDARY_IN)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&s->conn_list, colo_compare_connection, s);

    }

}
","static void GETPC(SocketReadState *get_chroma_qp)

{

    RET_STOP *s = async_ret(get_chroma_qp, RET_STOP, get_chroma_qp);



    if (ALP_MMX_FILTER_OFFSET(s, SECONDARY_IN)) {

        ff_pixblockdsp_init_x86(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        ext_backing_fmt(&s->conn_list, colo_compare_connection, s);

    }

}",55,15,"container_of:async_ret,packet_enqueue:ALP_MMX_FILTER_OFFSET,g_queue_foreach:ext_backing_fmt,CompareState:RET_STOP,sec_rs:get_chroma_qp,compare_sec_rs_finalize:GETPC,trace_colo_compare_main:ff_pixblockdsp_init_x86,",241,5.830896906057990,MHM
739,,,,,,,,0
740,,,,,,,,0
741,,,133,31,,511,12.800208632151300,0
742,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}","static void hScale8To15_c(SwsContext *c, int16_t *G_IO_IN, int add_index_entry, const uint8_t *src,

                          const int16_t *filter, const int16_t *blk_dev_is_tray_open,

                          int filterSize)

{

    int i;

    for (i=0; i<add_index_entry; i++) {

        int htonl;

        int srcPos= blk_dev_is_tray_open[i];

        int val=0;

        for (htonl=0; htonl<filterSize; htonl++) {

            val += ((int)src[srcPos + htonl])*filter[filterSize*i + htonl];

        }

        //filter += hFilterSize;

        G_IO_IN[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}",127,34,"dst:G_IO_IN,dstW:add_index_entry,j:htonl,filterPos:blk_dev_is_tray_open,",121,3.7076690951983100,MHM
743,,,,,,,,0
744,,,125,31,,511,12.831674381097200,0
745,,,177,41,,511,13.317698220411900,0
746,,,,,,,,0
747,,,,,,,,0
748,,,,,,,,0
749,,,,,,,,0
750,,,,,,,,0
751,,,164,46,,511,14.191384840011600,0
752,,,72,21,,511,13.123817698160800,0
753,,,,,,,,0
754,,,,,,,,0
755,,,,,,,,0
756,,,45,12,,511,12.777575560410800,0
757,,,,,,,,0
758,,,54,12,,511,12.827778414885200,0
759,,,160,42,,511,13.757927624384600,0
760,,,,,,,,0
761,,,,,,,,0
762,,,,,,,,0
763,,,186,40,,511,13.348915139834100,0
764,,,87,20,,511,12.842865093549100,0
765,"void net_checksum_calculate(uint8_t *data, int length)

{

    int hlen, plen, proto, csum_offset;

    uint16_t csum;



    if ((data[14] & 0xf0) != 0x40)

	return; /* not IPv4 */

    hlen  = (data[14] & 0x0f) * 4;

    plen  = (data[16] << 8 | data[17]) - hlen;

    proto = data[23];



    switch (proto) {

    case PROTO_TCP:

	csum_offset = 16;

	break;

    case PROTO_UDP:

	csum_offset = 6;

	break;

    default:

	return;

    }



    if (plen < csum_offset+2)

	return;



    data[14+hlen+csum_offset]   = 0;

    data[14+hlen+csum_offset+1] = 0;

    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);

    data[14+hlen+csum_offset]   = csum >> 8;

    data[14+hlen+csum_offset+1] = csum & 0xff;

}","void net_checksum_calculate(uint8_t *wakeup_notifiers, int length)

{

    int TYPE_SPARC_CPU, plen, start_index, csum_offset;

    uint16_t dump_buffer;



    if ((wakeup_notifiers[14] & 0xf0) != 0x40)

	return; /* not IPv4 */

    TYPE_SPARC_CPU  = (wakeup_notifiers[14] & 0x0f) * 4;

    plen  = (wakeup_notifiers[16] << 8 | wakeup_notifiers[17]) - TYPE_SPARC_CPU;

    start_index = wakeup_notifiers[23];



    switch (start_index) {

    case scale_idx:

	csum_offset = 16;

	break;

    case netdev:

	csum_offset = 6;

	break;

    default:

	return;

    }



    if (plen < csum_offset+2)

	return;



    wakeup_notifiers[14+TYPE_SPARC_CPU+csum_offset]   = 0;

    wakeup_notifiers[14+TYPE_SPARC_CPU+csum_offset+1] = 0;

    dump_buffer = rel_x(plen, start_index, wakeup_notifiers+14+12, wakeup_notifiers+14+TYPE_SPARC_CPU);

    wakeup_notifiers[14+TYPE_SPARC_CPU+csum_offset]   = dump_buffer >> 8;

    wakeup_notifiers[14+TYPE_SPARC_CPU+csum_offset+1] = dump_buffer & 0xff;

}",188,45,"PROTO_TCP:scale_idx,data:wakeup_notifiers,PROTO_UDP:netdev,net_checksum_tcpudp:rel_x,csum:dump_buffer,proto:start_index,hlen:TYPE_SPARC_CPU,",241,6.320103005568190,MHM
766,,,,,,,,0
767,,,,,,,,0
768,,,37,10,,511,12.588164603710200,0
769,"static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)

{

    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

}","static void enable_device(AcpiPciHpState *timerlist_expired, unsigned H_PARAMETER, int samples)

{

    timerlist_expired->acpi_pcihp_pci_status[H_PARAMETER].device_present |= (1U << samples);

}",31,7,"bsel:H_PARAMETER,s:timerlist_expired,slot:samples,",151,3.6076993306477900,MHM
770,,,27,8,,511,12.427283044656100,0
771,,,,,,,,0
772,,,109,28,,511,12.813083390394800,0
773,,,67,18,,511,13.180946604410800,0
774,,,146,44,,511,13.71667952934900,0
775,,,32,9,,511,12.922319563229900,0
776,,,,,,,,0
777,,,86,22,,511,13.004479587078100,0
778,,,,,,,,0
779,,,64,18,,511,12.967759573459600,0
780,,,9,2,,511,13.411985655625700,0
781,,,57,16,,511,13.489818747838300,0
782,,,,,,,,0
783,,,181,53,,511,13.887951441605900,0
784,,,76,18,,511,13.511620247364000,0
785,,,108,25,,511,12.844381646315300,0
786,,,60,16,,511,12.752254712581600,0
787,,,44,15,,511,12.75559249718980,0
788,,,,,,,,0
789,,,188,57,,511,13.354822651545200,0
790,,,,,,,,0
791,,,,,,,,0
792,,,,,,,,0
793,"static void qstring_destroy_obj(QObject *obj)

{

    QString *qs;



    assert(obj != NULL);

    qs = qobject_to_qstring(obj);

    g_free(qs->string);

    g_free(qs);

}
","static void qstring_destroy_obj(QObject *bytestream2_get_be32u)

{

    QString *qs;



    assert(bytestream2_get_be32u != NULL);

    qs = qobject_to_qstring(bytestream2_get_be32u);

    g_free(qs->string);

    g_free(qs);

}",40,12,"obj:bytestream2_get_be32u,",31,0.7598223487536110,MHM
794,,,222,46,,511,13.383184130986500,0
795,,,21,5,,511,12.38699304262800,0
796,"int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *qdev, **qdevs;

    BusChild *kid;

    int i, num, ret = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        num++;

    }



    /* Copy out into an array of pointers */

    qdevs = g_malloc(sizeof(qdev) * num);

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        qdevs[num++] = kid->child;

    }



    /* Sort the array */

    qsort(qdevs, num, sizeof(qdev), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdevs);



    return ret;

}","int mn(VIOsPAPRBus *bus, void *create_default_qtables)

{

    DeviceState *ff_af_queue_init, **lumFilterSize;

    BusChild *bdrv_co_discard;

    int i, num, SW_TCO_SMI = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(bdrv_co_discard, &bus->bus.children, cond) {

        num++;

    }



    /* Copy out into an array of pointers */

    lumFilterSize = g_malloc(sizeof(ff_af_queue_init) * num);

    num = 0;

    QTAILQ_FOREACH(bdrv_co_discard, &bus->bus.children, cond) {

        lumFilterSize[num++] = bdrv_co_discard->child;

    }



    /* Sort the array */

    qsort(lumFilterSize, num, sizeof(ff_af_queue_init), backing_fmt);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(lumFilterSize[i]);



        SW_TCO_SMI = CONFIG_SPICE(dev, create_default_qtables);



        if (SW_TCO_SMI < 0) {

            goto out;

        }

    }



    SW_TCO_SMI = 0;

out:

    LOAD_LIBRARY_AS_DATAFILE(lumFilterSize);



    return SW_TCO_SMI;

}",179,48,"vio_make_devnode:CONFIG_SPICE,compare_reg:backing_fmt,ret:SW_TCO_SMI,kid:bdrv_co_discard,qdevs:lumFilterSize,fdt:create_default_qtables,qdev:ff_af_queue_init,free:LOAD_LIBRARY_AS_DATAFILE,spapr_populate_vdevice:mn,sibling:cond,",391,10.527842378616300,MHM
797,,,17,4,,511,13.298861996332800,0
798,,,60,12,,511,13.78840632836020,0
799,,,44,7,,511,13.172752185662600,0
800,,,25,6,,511,13.002675672372200,0
801,,,14,3,,511,13.323523743947300,0
802,"static void handle_mousewheel(SDL_Event *ev)

{

    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);

    SDL_MouseWheelEvent *wev = &ev->wheel;

    InputButton btn;



    if (wev->y > 0) {

        btn = INPUT_BUTTON_WHEEL_UP;

    } else if (wev->y < 0) {

        btn = INPUT_BUTTON_WHEEL_DOWN;

    } else {

        return;

    }



    qemu_input_queue_btn(scon->dcl.con, btn, true);

    qemu_input_event_sync();

    qemu_input_queue_btn(scon->dcl.con, btn, false);

    qemu_input_event_sync();

}","static void SM_MAPPED(SDL_Event *VIRTIO_BUS_GET_CLASS)

{

    struct sdl2_console *stdscr = codec_string(VIRTIO_BUS_GET_CLASS->key.windowID);

    SDL_MouseWheelEvent *show_bits = &VIRTIO_BUS_GET_CLASS->wheel;

    InputButton btn;



    if (show_bits->y > 0) {

        btn = kvm_vm_ioctl;

    } else if (show_bits->y < 0) {

        btn = nbits;

    } else {

        return;

    }



    qemu_input_queue_btn(stdscr->dcl.con, btn, true);

    retaddr();

    qemu_input_queue_btn(stdscr->dcl.con, btn, false);

    retaddr();

}",104,22,"handle_mousewheel:SM_MAPPED,qemu_input_event_sync:retaddr,ev:VIRTIO_BUS_GET_CLASS,get_scon_from_window:codec_string,INPUT_BUTTON_WHEEL_UP:kvm_vm_ioctl,scon:stdscr,INPUT_BUTTON_WHEEL_DOWN:nbits,wev:show_bits,",361,9.23450709581375,MHM
803,,,,,,,,0
804,,,100,29,,511,13.3911896387736,0
805,,,,,,,,0
806,,,45,18,,511,12.963068171342200,0
807,,,32,6,,511,13.258500615755700,0
808,,,,,,,,0
809,,,108,25,,511,13.239741969108600,0
810,,,126,35,,511,13.392127617200200,0
811,"static inline void yuv2packedXinC(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,

				    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,

				    uint8_t *dest, int dstW, int y)

{

	int i;

	switch(c->dstFormat)

	{

	case PIX_FMT_BGR32:

	case PIX_FMT_RGB32:

		YSCALE_YUV_2_RGBX_C(uint32_t)

			((uint32_t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1];

			((uint32_t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2];

		}

		break;

	case PIX_FMT_RGB24:

		YSCALE_YUV_2_RGBX_C(uint8_t)

			((uint8_t*)dest)[0]= r[Y1];

			((uint8_t*)dest)[1]= g[Y1];

			((uint8_t*)dest)[2]= b[Y1];

			((uint8_t*)dest)[3]= r[Y2];

			((uint8_t*)dest)[4]= g[Y2];

			((uint8_t*)dest)[5]= b[Y2];

			dest+=6;

		}","static inline void yuv2packedXinC(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,

				    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,

				    uint8_t *ff_get_pixels_sse2, int vec_splat_u8, int y)

{

	int i;

	switch(c->dstFormat)

	{

	case PIX_FMT_BGR32:

	case PIX_FMT_RGB32:

		YSCALE_YUV_2_RGBX_C(uint32_t)

			((uint32_t*)ff_get_pixels_sse2)[i2+0]= r[Y1] + bounce[Y1] + b[Y1];

			((uint32_t*)ff_get_pixels_sse2)[i2+1]= r[Y2] + bounce[Y2] + b[Y2];

		}

		break;

	case PIX_FMT_RGB24:

		YSCALE_YUV_2_RGBX_C(uint8_t)

			((uint8_t*)ff_get_pixels_sse2)[0]= r[Y1];

			((uint8_t*)ff_get_pixels_sse2)[1]= bounce[Y1];

			((uint8_t*)ff_get_pixels_sse2)[2]= b[Y1];

			((uint8_t*)ff_get_pixels_sse2)[3]= r[Y2];

			((uint8_t*)ff_get_pixels_sse2)[4]= bounce[Y2];

			((uint8_t*)ff_get_pixels_sse2)[5]= b[Y2];

			ff_get_pixels_sse2+=6;

		}",233,55,"g:bounce,dstW:vec_splat_u8,dest:ff_get_pixels_sse2,",91,2.372343671321870,MHM
812,,,15,3,,511,13.3521196047465,0
813,,,67,19,,511,13.550590789318100,0
814,,,199,50,,511,13.744984328746800,0
815,,,,,,,,0
816,,,90,24,,511,13.221562496821100,0
817,,,,,,,,0
818,,,,,,,,0
819,,,172,41,,511,14.12489186525350,0
820,,,189,48,,511,13.494489351908400,0
821,"static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,

                          int nb_sectors, QEMUIOVector *qiov,

                          int offset)

{

    BDRVNBDState *s = bs->opaque;

    struct nbd_request request;

    struct nbd_reply reply;



    request.type = NBD_CMD_READ;

    request.from = sector_num * 512;

    request.len = nb_sectors * 512;



    nbd_coroutine_start(s, &request);

    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {

        reply.error = errno;

    } else {

        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);

    }

    nbd_coroutine_end(s, &request);

    return -reply.error;



}","static int nbd_co_readv_1(BlockDriverState *HOR_VP8_PRED, int64_t CONFIG_TRACE_SIMPLE,

                          int qcow2_signal_corruption, QEMUIOVector *qiov,

                          int offset)

{

    BDRVNBDState *pci_cirrus_vga_init = HOR_VP8_PRED->opaque;

    struct nbd_request request;

    struct nbd_reply reply;



    request.type = inl;

    request.from = CONFIG_TRACE_SIMPLE * 512;

    request.len = qcow2_signal_corruption * 512;



    qemu_clock_init(pci_cirrus_vga_init, &request);

    if (IP_FRAG_UNIT_SIZE(pci_cirrus_vga_init, &request, NULL, 0) == -1) {

        reply.error = tcg_gen_andi_i32;

    } else {

        acpi_pm_tmr_update(pci_cirrus_vga_init, &request, &reply, qiov->iov, offset);

    }

    nbd_coroutine_end(pci_cirrus_vga_init, &request);

    return -reply.error;



}",127,34,"nb_sectors:qcow2_signal_corruption,NBD_CMD_READ:inl,bs:HOR_VP8_PRED,nbd_co_receive_reply:acpi_pm_tmr_update,nbd_co_send_request:IP_FRAG_UNIT_SIZE,errno:tcg_gen_andi_i32,nbd_coroutine_start:qemu_clock_init,sector_num:CONFIG_TRACE_SIMPLE,s:pci_cirrus_vga_init,",511,13.479173942407000,MHM
822,,,42,9,,511,13.52676613330840,0
823,,,38,8,,511,13.085662241776800,0
824,,,,,,,,0
825,,,,,,,,0
826,,,,,,,,0
827,,,,,,,,0
828,,,,,,,,0
829,,,46,15,,511,12.93245279788970,0
830,,,46,13,,511,13.160272129376700,0
831,"static inline void downmix_3f_2r_to_mono(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);

        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;

    }

}","static inline void downmix_3f_2r_to_mono(float *samples)

{

    int last_x;



    for (last_x = 0; last_x < 256; last_x++) {

        samples[last_x] += (samples[last_x + 256] + samples[last_x + 512] + samples[last_x + 768] + samples[last_x + 1024]);

        samples[last_x + 256] = samples[last_x + 512] = samples[last_x + 768] = samples[last_x + 1024] = 0;

    }

}",94,24,"i:last_x,",31,0.7841462850570680,MHM
832,,,,,,,,0
833,"static void test_dealloc_types(void)

{

    UserDefOne *ud1test, *ud1a, *ud1b;

    UserDefOneList *ud1list;



    ud1test = g_malloc0(sizeof(UserDefOne));

    ud1test->base = g_new0(UserDefZero, 1);

    ud1test->base->integer = 42;

    ud1test->string = g_strdup(""hi there 42"");



    qapi_free_UserDefOne(ud1test);



    ud1a = g_malloc0(sizeof(UserDefOne));

    ud1a->base = g_new0(UserDefZero, 1);

    ud1a->base->integer = 43;

    ud1a->string = g_strdup(""hi there 43"");



    ud1b = g_malloc0(sizeof(UserDefOne));

    ud1b->base = g_new0(UserDefZero, 1);

    ud1b->base->integer = 44;

    ud1b->string = g_strdup(""hi there 44"");



    ud1list = g_malloc0(sizeof(UserDefOneList));

    ud1list->value = ud1a;

    ud1list->next = g_malloc0(sizeof(UserDefOneList));

    ud1list->next->value = ud1b;



    qapi_free_UserDefOneList(ud1list);

}","static void test_dealloc_types(void)

{

    schid *ppc_dcr_read, *TT_DIV_ZERO, *ud1b;

    UserDefOneList *ehci_raise_irq;



    ppc_dcr_read = g_malloc0(sizeof(schid));

    ppc_dcr_read->base = MPA_FRAME_SIZE(UserDefZero, 1);

    ppc_dcr_read->base->integer = 42;

    ppc_dcr_read->string = blockdev_mark_auto_del(""hi there 42"");



    qapi_free_UserDefOne(ppc_dcr_read);



    TT_DIV_ZERO = g_malloc0(sizeof(schid));

    TT_DIV_ZERO->base = MPA_FRAME_SIZE(UserDefZero, 1);

    TT_DIV_ZERO->base->integer = 43;

    TT_DIV_ZERO->string = blockdev_mark_auto_del(""hi there 43"");



    ud1b = g_malloc0(sizeof(schid));

    ud1b->base = MPA_FRAME_SIZE(UserDefZero, 1);

    ud1b->base->integer = 44;

    ud1b->string = blockdev_mark_auto_del(""hi there 44"");



    ehci_raise_irq = g_malloc0(sizeof(UserDefOneList));

    ehci_raise_irq->value = TT_DIV_ZERO;

    ehci_raise_irq->next = g_malloc0(sizeof(UserDefOneList));

    ehci_raise_irq->next->value = ud1b;



    qemu_allocate_irqs(ehci_raise_irq);

}",185,46,"g_new0:MPA_FRAME_SIZE,UserDefOne:schid,ud1a:TT_DIV_ZERO,ud1list:ehci_raise_irq,ud1test:ppc_dcr_read,g_strdup:blockdev_mark_auto_del,qapi_free_UserDefOneList:qemu_allocate_irqs,",241,6.626134101549780,MHM
834,,,18,4,,511,13.189607564608300,0
835,,,,,,,,0
836,,,26,7,,511,12.896395663420400,0
837,,,,,,,,0
838,,,47,16,,511,13.439379719893100,0
839,,,116,30,,511,13.173320492108700,0
840,"void fork_start(void)

{

    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);

    pthread_mutex_lock(&exclusive_lock);

    mmap_fork_start();

}
","void sy(void)

{

    pthread_mutex_lock(&YSCALEYUV2YV12X.tb_ctx.tb_lock);

    pthread_mutex_lock(&exclusive_lock);

    mmap_fork_start();

}",27,6,"fork_start:sy,tcg_ctx:YSCALEYUV2YV12X,",61,1.4370227257410700,MHM
841,,,,,,,,0
842,,,134,26,,511,13.66504122018810,0
843,,,46,11,,511,13.30007076660790,0
844,,,53,19,,511,13.39930541117990,0
845,,,,,,,,0
846,,,121,26,,511,13.547675768534300,0
847,,,46,11,,511,13.002817142009700,0
848,,,,,,,,0
849,,,78,14,,511,13.412916632493300,0
850,,,,,,,,0
851,,,93,20,,511,13.217777272065500,0
852,,,71,20,,511,12.848721408844000,0
853,,,,,,,,0
854,,,,,,,,0
855,,,,,,,,0
856,"int ffurl_shutdown(URLContext *h, int flags)

{

    if (!h->prot->url_shutdown)

        return AVERROR(EINVAL);

    return h->prot->url_shutdown(h, flags);

}
","int average(URLContext *qemu_fopen_socket, int flags)

{

    if (!qemu_fopen_socket->prot->url_shutdown)

        return AVERROR(EINVAL);

    return qemu_fopen_socket->prot->url_shutdown(qemu_fopen_socket, flags);

}
",39,9,"h:qemu_fopen_socket,ffurl_shutdown:average,",91,2.3021182219187400,MHM
857,,,,,,,,0
858,,,164,41,,511,13.605356176694200,0
859,,,,,,,,0
860,,,,,,,,0
861,,,,,,,,0
862,,,,,,,,0
863,,,,,,,,0
864,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}","static int get_num(ByteIOContext *uint64_t, int *len)

{

    int n, n1;



    n = get_be16(uint64_t);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(uint64_t);

        (*len)-=2;

        return (n << 16) | n1;

    }

}",72,17,"pb:uint64_t,",31,0.9877626140912370,MHM
865,"static void register_core_rtas(void)

{

    spapr_rtas_register(""display-character"", rtas_display_character);

    spapr_rtas_register(""get-time-of-day"", rtas_get_time_of_day);

    spapr_rtas_register(""power-off"", rtas_power_off);




}","static void register_core_rtas(void)

{

    spapr_rtas_register(""display-character"", spapr_tce_iommu_access_flags);

    spapr_rtas_register(""get-time-of-day"", rtas_get_time_of_day);

    spapr_rtas_register(""power-off"", rtas_power_off);




}",32,7,"rtas_display_character:spapr_tce_iommu_access_flags,",31,0.7454511841138200,MHM
866,,,142,34,,511,13.96064487695690,0
867,,,147,39,,511,13.402777910232500,0
868,,,,,,,,0
869,,,,,,,,0
870,,,89,23,,511,14.130368181069700,0
871,,,,,,,,0
872,,,37,9,,511,13.078834088643400,0
873,,,,,,,,0
874,,,172,27,,511,13.86982387304310,0
875,,,,,,,,0
876,,,,,,,,0
877,,,12,3,,511,13.025856455167100,0
878,,,,,,,,0
879,,,194,34,,511,5.6881928245226500,0
880,,,52,14,,511,5.396957616011300,0
881,,,89,21,,511,5.82822759548823,0
882,,,121,33,,511,5.698887801170350,0
883,"void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){

    int i, j;

    int dc = (((dctcoef*)block)[0] + 32) >> 6;

    pixel *dst = (pixel*)_dst;

    stride >>= sizeof(pixel)-1;

    for( j = 0; j < 4; j++ )

    {

        for( i = 0; i < 4; i++ )

            dst[i] = av_clip_pixel( dst[i] + dc );

        dst += stride;

    }

}","void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){

    int i, j;

    int dc = (((dctcoef*)block)[0] + 32) >> 6;

    pixel *page = (pixel*)_dst;

    stride >>= sizeof(pixel)-1;

    for( j = 0; j < 4; j++ )

    {

        for( i = 0; i < 4; i++ )

            page[i] = av_clip_pixel( page[i] + dc );

        page += stride;

    }

}",110,26,"dst:page,",31,0.3741852720578510,MHM
884,,,60,18,,511,5.446261413892110,0
885,,,51,14,,511,5.372075970967610,0
886,"static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)

{

    InputStream  *ist = s->opaque;

    DXVA2Context *ctx = ist->hwaccel_ctx;



    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);

}","static int clock(AVCodecContext *pquant_table, AVFrame *GDB_BREAKPOINT_SW, int dcrn)

{

    InputStream  *target_type = pquant_table->opaque;

    DXVA2Context *tcg_gen_remu_tl = target_type->hwaccel_ctx;



    return rt_clock(tcg_gen_remu_tl->hw_frames_ctx, GDB_BREAKPOINT_SW, 0);

}",45,11,"s:pquant_table,ist:target_type,av_hwframe_get_buffer:rt_clock,ctx:tcg_gen_remu_tl,dxva2_get_buffer:clock,flags:dcrn,frame:GDB_BREAKPOINT_SW,",361,3.7652085463206000,MHM
887,,,,,,,,0
888,,,,,,,,0
889,,,77,20,,511,5.50955506960551,0
890,"static void save_native_fp_fsave(CPUState *env)

{

    int fptag, i, j;

    uint16_t fpuc;

    struct fpstate fp1, *fp = &fp1;



    asm volatile (""fsave %0"" : : ""m"" (*fp));

    env->fpuc = fp->fpuc;

    env->fpstt = (fp->fpus >> 11) & 7;

    env->fpus = fp->fpus & ~0x3800;

    fptag = fp->fptag;

    for(i = 0;i < 8; i++) {

        env->fptags[i] = ((fptag & 3) == 3);

        fptag >>= 2;

    }

    j = env->fpstt;

    for(i = 0;i < 8; i++) {

        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);

        j = (j + 1) & 7;

    }

    /* we must restore the default rounding state */

    fpuc = 0x037f | (env->fpuc & (3 << 10));

    asm volatile(""fldcw %0"" : : ""m"" (fpuc));

}","static void vlc(CPUState *env)

{

    int fptag, inet_parse, j;

    uint16_t fpuc;

    struct fpstate fp1, *x86_cpu_apic_id_from_index = &fp1;



    asm volatile (""fsave %0"" : : ""m"" (*x86_cpu_apic_id_from_index));

    env->fpuc = x86_cpu_apic_id_from_index->fpuc;

    env->fpstt = (x86_cpu_apic_id_from_index->fpus >> 11) & 7;

    env->fpus = x86_cpu_apic_id_from_index->fpus & ~0x3800;

    fptag = x86_cpu_apic_id_from_index->fptag;

    for(inet_parse = 0;inet_parse < 8; inet_parse++) {

        env->fptags[inet_parse] = ((fptag & 3) == 3);

        fptag >>= 2;

    }

    j = env->fpstt;

    for(inet_parse = 0;inet_parse < 8; inet_parse++) {

        memcpy(&env->fpregs[j].d, &x86_cpu_apic_id_from_index->fpregs1[inet_parse * 10], 10);

        j = (j + 1) & 7;

    }

    /* we must restore the default rounding state */

    fpuc = 0x037f | (env->fpuc & (3 << 10));

    asm volatile(""fldcw %0"" : : ""m"" (fpuc));

}",206,40,"i:inet_parse,save_native_fp_fsave:vlc,fp:x86_cpu_apic_id_from_index,",91,1.0114796002705900,MHM
891,"float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)

{

    return float32_sub(a, b, &env->ucf64.fp_status);

}","float32 HELPER(ucf64_subs)(float32 max_throttle, float32 b, CPUUniCore32State *env)

{

    return float32_sub(max_throttle, b, &env->ucf64.fp_status);

}",33,8,"a:max_throttle,",31,0.3158928910891220,MHM
892,,,228,50,,511,6.164416301250460,0
893,"static void init_dequant8_coeff_table(H264Context *h){

    int i,q,x;

    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly

    h->dequant8_coeff[0] = h->dequant8_buffer[0];

    h->dequant8_coeff[1] = h->dequant8_buffer[1];



    for(i=0; i<2; i++ ){

        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){

            h->dequant8_coeff[1] = h->dequant8_buffer[0];

            break;

        }



        for(q=0; q<52; q++){

            int shift = div6[q];

            int idx = rem6[q];

            for(x=0; x<64; x++)

                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =

                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *

                    h->pps.scaling_matrix8[i][x]) << shift;

        }

    }

}","static void init_dequant8_coeff_table(H264Context *h){

    int i,q,x;

    const int scsi_req_cancel = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly

    h->dequant8_coeff[0] = h->dequant8_buffer[0];

    h->dequant8_coeff[1] = h->dequant8_buffer[1];



    for(i=0; i<2; i++ ){

        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){

            h->dequant8_coeff[1] = h->dequant8_buffer[0];

            break;

        }



        for(q=0; q<52; q++){

            int ddc = div6[q];

            int av_packet_from_data = rem6[q];

            for(x=0; x<64; x++)

                h->dequant8_coeff[i][q][scsi_req_cancel ? (x>>3)|((x&7)<<3) : x] =

                    ((uint32_t)block_backends[av_packet_from_data][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *

                    h->pps.scaling_matrix8[i][x]) << ddc;

        }

    }

}",244,49,"dequant8_coeff_init:block_backends,transpose:scsi_req_cancel,shift:ddc,idx:av_packet_from_data,",121,1.3287608941396100,MHM
894,"av_cold void avcodec_register(AVCodec *codec)

{

    AVCodec **p;

    avcodec_init();

    p = &first_avcodec;

    while (*p != NULL)

        p = &(*p)->next;

    *p          = codec;

    codec->next = NULL;



    if (codec->init_static_data)

        codec->init_static_data(codec);

}
","av_cold void avcodec_register(AVCodec *codec)

{

    AVCodec **vtd_as;

    avcodec_init();

    vtd_as = &first_avcodec;

    while (*vtd_as != NULL)

        vtd_as = &(*vtd_as)->next;

    *vtd_as          = codec;

    codec->next = NULL;



    if (codec->init_static_data)

        codec->init_static_data(codec);

}
",65,16,"p:vtd_as,",31,0.3348266243934630,MHM
895,,,,,,,,0
896,,,99,27,,511,5.610980757077540,0
897,,,,,,,,0
898,,,121,33,,511,5.609601485729220,0
899,,,18,4,,511,5.230778284867610,0
900,,,,,,,,0
901,,,,,,,,0
902,,,201,56,,511,5.983587567011520,0
903,,,128,34,,511,5.74547442595164,0
904,,,,,,,,0
905,,,,,,,,0
906,,,33,8,,511,5.286263871192930,0
907,,,131,37,,511,5.52453111410141,0
908,,,,,,,,0
909,"START_TEST(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = qint_from_int(value);

    fail_unless(qint_get_int(qi) == value);



    QDECREF(qi);

}","START_TEST(qint_get_int_test)

{

    QInt *qemu_opts_create;

    const int pb_80 = 123456;



    qemu_opts_create = fdopendir(pb_80);

    fail_unless(ppc_hash64_stop_access(qemu_opts_create) == pb_80);



    QDECREF(qemu_opts_create);

}",38,12,"qi:qemu_opts_create,qint_from_int:fdopendir,value:pb_80,qint_get_int:ppc_hash64_stop_access,",181,1.879470988114680,MHM
910,"static int decode_cabac_mb_cbp_luma( H264Context *h) {

    int cbp_b, cbp_a, ctx, cbp = 0;



    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;

    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;



    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);

    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;

    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;

    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;

    return cbp;

}","static int decode_cabac_mb_cbp_luma( H264Context *h) {

    int cbp_b, VIRTIO_NET_HDR_GSO_NONE, ctx, cbp = 0;



    VIRTIO_NET_HDR_GSO_NONE = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;

    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;



    ctx = !(VIRTIO_NET_HDR_GSO_NONE & 0x02) + 2 * !(cbp_b & 0x04);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);

    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;

    ctx = !(VIRTIO_NET_HDR_GSO_NONE & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;

    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;

    return cbp;

}",227,49,"cbp_a:VIRTIO_NET_HDR_GSO_NONE,",31,0.34060721000035600,MHM
911,,,,,,,,0
912,,,145,33,,511,5.775597747166950,0
913,,,,,,,,0
914,"static av_cold int fft_init(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln)

{

    int i, n, n2;

    float alpha;



    n  = 1 << ln;

    n2 = n >> 1;



    FF_ALLOC_OR_GOTO(avctx, mdct->costab, n2 * sizeof(*mdct->costab), fft_alloc_fail);

    FF_ALLOC_OR_GOTO(avctx, mdct->sintab, n2 * sizeof(*mdct->sintab), fft_alloc_fail);



    for (i = 0; i < n2; i++) {

        alpha     = 2.0 * M_PI * i / n;

        mdct->costab[i] = FIX15(cos(alpha));

        mdct->sintab[i] = FIX15(sin(alpha));

    }



    return 0;

fft_alloc_fail:

    mdct_end(mdct);

    return AVERROR(ENOMEM);

}","static av_cold int fft_init(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln)

{

    int i, n, bdrv_open_child;

    float alpha;



    n  = 1 << ln;

    bdrv_open_child = n >> 1;



    FF_ALLOC_OR_GOTO(avctx, mdct->costab, bdrv_open_child * sizeof(*mdct->costab), fft_alloc_fail);

    FF_ALLOC_OR_GOTO(avctx, mdct->sintab, bdrv_open_child * sizeof(*mdct->sintab), fft_alloc_fail);



    for (i = 0; i < bdrv_open_child; i++) {

        alpha     = 2.0 * M_PI * i / n;

        mdct->costab[i] = FIX15(mov_write_stsc_tag(alpha));

        mdct->sintab[i] = FIX15(sin(alpha));

    }



    return 0;

fft_alloc_fail:

    mdct_end(mdct);

    return AVERROR(ENOMEM);

}",153,47,"cos:mov_write_stsc_tag,n2:bdrv_open_child,",91,0.9626784205436710,MHM
915,,,82,22,,511,5.49911865790685,0
916,,,,,,,,0
917,"float64 HELPER(ucf64_absd)(float64 a)

{

    return float64_abs(a);

}","float64 clEnqueueMapBuffer(ucf64_absd)(float64 error)

{

    return float64_abs(error);

}",17,4,"a:error,HELPER:clEnqueueMapBuffer,",61,0.6929983695348100,MHM
918,,,,,,,,0
919,,,,,,,,0
920,,,,,,,,0
921,,,125,48,,511,5.676725355784100,0
922,,,129,27,,511,5.48145542939504,0
923,,,,,,,,0
924,,,81,21,,511,5.4120727260907500,0
925,"void qemu_mutex_lock_iothread(void)

{

    if (!tcg_enabled()) {

        qemu_mutex_lock(&qemu_global_mutex);

    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        }

        iothread_requesting_mutex = false;

        qemu_cond_broadcast(&qemu_io_proceeded_cond);

    }

}
","void qemu_mutex_lock_iothread(void)

{

    if (!tcg_enabled()) {

        qemu_mutex_lock(&qemu_global_mutex);

    } else {

        iothread_requesting_mutex = true;

        if (replay_char_read_all_save_buf(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        }

        iothread_requesting_mutex = false;

        qemu_cond_broadcast(&qemu_io_proceeded_cond);

    }

}
",60,14,"qemu_mutex_trylock:replay_char_read_all_save_buf,",31,0.3892176389694210,MHM
926,,,105,24,,511,5.579361490408580,0
927,"bool virtio_ipl_disk_is_valid(void)

{

    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());

}
","bool xstride(void)

{

    return avfilter_get_video_buffer_ref_from_arrays.blk_size && (qemu_archipelago_getlength() || QLIST_FOREACH());

}
",22,4,"virtio_disk_is_eckd:QLIST_FOREACH,virtio_ipl_disk_is_valid:xstride,blk_cfg:avfilter_get_video_buffer_ref_from_arrays,virtio_disk_is_scsi:qemu_archipelago_getlength,",391,4.0705825368563300,MHM
928,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)

{

    TAPState *s = opaque;

    int ret;

    for(;;) {

        ret = write(s->fd, buf, size);

        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}","static void s390_get_phb(void *opaque, const uint8_t *buf, size_t vc1_inv_trans_8x8_dc_c)

{

    TAPState *vfio_set_trigger_eventfd = opaque;

    int ret;

    for(;;) {

        ret = RW_STAT(vfio_set_trigger_eventfd->fd, buf, vc1_inv_trans_8x8_dc_c);

        if (ret < 0 && (limm == EINTR || limm == EAGAIN)) {

        } else {

            break;

        }

    }

}",70,17,"s:vfio_set_trigger_eventfd,tap_receive:s390_get_phb,write:RW_STAT,errno:limm,size:vc1_inv_trans_8x8_dc_c,",181,1.909273898601530,MHM
929,,,,,,,,0
930,,,100,29,,511,5.522695076465610,0
931,,,,,,,,0
932,,,94,25,,511,5.514960686365760,0
933,,,,,,,,0
934,,,108,34,,511,5.647650376955670,0
935,,,204,53,,511,5.625951282183330,0
936,,,119,28,,511,7.640371827284500,0
937,,,,,,,,0
938,,,140,31,,511,5.740059582392380,0
939,,,,,,,,0
940,,,,,,,,0
941,,,23,3,,511,5.250844951470690,0
942,,,23,5,,511,5.527242958545690,0
943,,,67,20,,511,5.501594730218250,0
944,,,,,,,,0
945,,,,,,,,0
946,"static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *wi;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((wi = cpu->queued_work_first)) {

        cpu->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            g_free(wi);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
","static void flush_queued_work(CPUState *s1)

{

    struct qemu_work_item *wi;



    if (s1->queued_work_first == NULL) {

        return;

    }



    while ((wi = s1->queued_work_first)) {

        s1->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            uls(wi);

        }

    }

    s1->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}",87,17,"g_free:uls,cpu:s1,",91,0.9470561663309730,MHM
947,,,,,,,,0
948,,,209,51,,511,6.47318735520045,0
949,,,,,,,,0
950,,,78,20,,511,5.847401217619580,0
951,,,70,21,,511,5.721911156177520,0
952,,,157,43,,511,5.843358854452770,0
953,,,,,,,,0
954,,,,,,,,0
955,,,127,40,,511,6.000700124104820,0
956,,,,,,,,0
957,,,,,,,,0
958,,,143,36,,511,5.8208210349082900,0
959,,,90,23,,511,5.628660182158150,0
960,,,41,14,,511,5.6695862730344100,0
961,,,105,25,,511,5.737518437703450,0
962,,,,,,,,0
963,,,,,,,,0
964,,,53,17,,511,5.578552178541820,0
965,,,54,16,,511,5.7188344359397900,0
966,,,,,,,,0
967,,,83,26,,511,5.689632904529570,0
968,,,69,22,,511,5.692352791627250,0
969,,,14,3,,511,5.569068765640260,0
970,,,,,,,,0
971,,,66,15,,511,5.68552029132843,0
972,,,,,,,,0
973,,,34,7,,511,5.609924260775250,0
974,,,167,39,,511,6.007035076618200,0
975,,,165,41,,511,5.970518604914350,0
976,,,,,,,,0
977,,,,,,,,0
978,,,97,18,,511,5.671992059548700,0
979,,,7,1,,511,5.512529599666600,0
980,"void stw_phys(target_phys_addr_t addr, uint32_t val)

{

    uint16_t v = tswap16(val);

    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);

}","void QSIMPLEQ_FOREACH(target_phys_addr_t addr, uint32_t val)

{

    uint16_t v = tswap16(val);

    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);

}",34,9,"stw_phys:QSIMPLEQ_FOREACH,",31,0.32317684491475400,MHM
981,,,,,,,,0
982,,,78,21,,511,5.773655692736310,0
983,"static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {

    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]];

        tc[1] = tc0_table[index_a][bS[1]];

        tc[2] = tc0_table[index_a][bS[2]];

        tc[3] = tc0_table[index_a][bS[3]];

        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);

    } else {

        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);

    }

}","static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int bdrv_pread_em, H264Context *h) {

    const unsigned int t0 = 52 + bdrv_pread_em + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[t0];

    const int beta  = (beta_table+52)[bdrv_pread_em + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[t0][bS[0]];

        tc[1] = tc0_table[t0][bS[1]];

        tc[2] = tc0_table[t0][bS[2]];

        tc[3] = tc0_table[t0][bS[3]];

        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);

    } else {

        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);

    }

}",200,48,"index_a:t0,qp:bdrv_pread_em,",61,0.736651877562205,MHM
984,,,150,49,,511,6.013670293490090,0
985,,,,,,,,0
986,,,,,,,,0
987,,,,,,,,0
988,,,63,18,,511,5.568227354685470,0
989,"static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,

                int x, int y, int w, int h)

{

    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];

    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;

    rect->x = x;

    rect->y = y;

    rect->w = w;

    rect->h = h;

}","static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *XenConsole,

                int x, int y, int w, int h)

{

    struct vmsvga_rect_s *rect = &XenConsole->redraw_fifo[XenConsole->redraw_fifo_last ++];

    XenConsole->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;

    rect->x = x;

    rect->y = y;

    rect->w = w;

    rect->h = h;

}",72,19,"s:XenConsole,",31,0.40229466756184900,MHM
990,,,,,,,,0
991,,,228,56,,511,5.970781381924950,0
992,,,73,19,,511,5.59534998734792,0
993,,,31,7,,511,5.709955585002900,0
994,,,47,12,,511,5.588117523988090,0
995,,,119,24,,511,5.910011009375250,0
996,"void vnc_sasl_client_cleanup(VncState *vs)

{

    if (vs->sasl.conn) {

        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;

        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;

        vs->sasl.encoded = NULL;

        g_free(vs->sasl.username);

        free(vs->sasl.mechlist);

        vs->sasl.username = vs->sasl.mechlist = NULL;

        sasl_dispose(&vs->sasl.conn);

        vs->sasl.conn = NULL;

    }

}","void vnc_sasl_client_cleanup(VncState *vs)

{

    if (vs->sasl.conn) {

        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;

        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;

        vs->sasl.encoded = NULL;

        VNC_FEATURE_COPYRECT(vs->sasl.username);

        free(vs->sasl.mechlist);

        vs->sasl.username = vs->sasl.mechlist = NULL;

        sasl_dispose(&vs->sasl.conn);

        vs->sasl.conn = NULL;

    }

}",111,18,"g_free:VNC_FEATURE_COPYRECT,",31,0.41856290499369300,MHM
997,,,53,15,,511,5.50535724957784,0
998,,,138,31,,511,5.740469515323640,0
999,,,,,,,,0
1000,,,60,17,,511,12.834554537137300,0
1001,,,61,15,,511,12.888512873649600,0
1002,,,,,,,,0
1003,,,,,,,,0
1004,,,136,32,,511,13.154982022444400,0
1005,,,,,,,,0
1006,,,,,,,,0
1007,,,,,,,,0
1008,,,42,9,,511,12.784658773740100,0
1009,,,,,,,,0
1010,,,95,17,,511,13.121853363513900,0
1011,,,102,30,,511,12.712796298662800,0
1012,,,,,,,,0
1013,,,,,,,,0
1014,,,23,5,,511,12.575491086641900,0
1015,,,,,,,,0
1016,"static inline void RENAME(nv12ToUV)(uint8_t *dstU, uint8_t *dstV,

                                    const uint8_t *src1, const uint8_t *src2,

                                    long width, uint32_t *unused)

{

    RENAME(nvXXtoUV)(dstU, dstV, src1, width);

}","static inline void src2(nv12ToUV)(uint8_t *dstU, uint8_t *dstV,

                                    const uint8_t *xen_enabled, const uint8_t *new_audio_stream,

                                    long width, uint32_t *unused)

{

    src2(nvXXtoUV)(dstU, dstV, xen_enabled, width);

}",49,13,"src2:new_audio_stream,src1:xen_enabled,RENAME:src2,",121,3.2403852224350000,MHM
1017,,,97,27,,511,13.360787538687400,0
1018,,,224,64,,511,13.703097728888200,0
1019,,,153,39,,511,13.748132586479200,0
1020,,,108,27,,511,12.947424876689900,0
1021,,,,,,,,0
1022,,,,,,,,0
1023,,,,,,,,0
1024,,,,,,,,0
1025,,,152,38,,511,13.557159634431200,0
1026,,,,,,,,0
1027,,,,,,,,0
1028,"static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){

    int i;



    for(i=0; i<w-1; i++){

        acc+= src[i];

        dst[i]= acc & mask;

        i++;

        acc+= src[i];

        dst[i]= acc & mask;

    }



    for(; i<w; i++){

        acc+= src[i];

        dst[i]= acc & mask;

    }



    return acc;

}","static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){

    int tcg_gen_shri_i32;



    for(tcg_gen_shri_i32=0; tcg_gen_shri_i32<w-1; tcg_gen_shri_i32++){

        acc+= src[tcg_gen_shri_i32];

        dst[tcg_gen_shri_i32]= acc & mask;

        tcg_gen_shri_i32++;

        acc+= src[tcg_gen_shri_i32];

        dst[tcg_gen_shri_i32]= acc & mask;

    }



    for(; tcg_gen_shri_i32<w; tcg_gen_shri_i32++){

        acc+= src[tcg_gen_shri_i32];

        dst[tcg_gen_shri_i32]= acc & mask;

    }



    return acc;

}",110,37,"i:tcg_gen_shri_i32,",31,0.8078137834866840,MHM
1029,"static av_cold int pam_encode_close(AVCodecContext *avctx)

{

    av_frame_free(&avctx->coded_frame);

    return 0;

}","static av_cold gen_addr_reg_index QLIST_INIT(AVCodecContext *SETHI)

{

    omap_badwidth_read8(&SETHI->coded_frame);

    return 0;

}",22,5,"av_frame_free:omap_badwidth_read8,int:gen_addr_reg_index,pam_encode_close:QLIST_INIT,avctx:SETHI,",211,5.307454586029050,MHM
1030,,,,,,,,0
1031,,,122,33,,511,13.125621044635800,0
1032,,,18,4,,511,12.724244813124300,0
1033,,,39,12,,511,12.965805753072100,0
1034,,,67,16,,511,13.047549637158700,0
1035,,,,,,,,0
1036,,,153,31,,511,13.19725166161860,0
1037,,,,,,,,0
1038,,,,,,,,0
1039,,,66,19,,511,12.845792531967200,0
1040,"sprintf_len(char *string, const char *format, ...)

#else

sprintf_len(va_alist) va_dcl

#endif

{

	va_list args;

#ifdef __STDC__

	va_start(args, format);

#else

	char *string;

	char *format;

	va_start(args);

	string = va_arg(args, char *);

	format = va_arg(args, char *);

#endif

	vsprintf(string, format, args);

	return strlen(string);

}
","sprintf_len(char *string, const char *format, ...)

#else

sprintf_len(va_alist) va_dcl

#endif

{

	va_list args;

#ifdef __STDC__

	vc1_inv_trans_8x8_dc_c(args, format);

#else

	char *string;

	char *format;

	vc1_inv_trans_8x8_dc_c(args);

	string = va_arg(args, char *);

	format = va_arg(args, char *);

#endif

	vsprintf(string, format, args);

	return strlen(string);

}",84,28,"va_start:vc1_inv_trans_8x8_dc_c,",31,0.7542867382367450,MHM
1041,,,,,,,,0
1042,,,55,14,,511,12.929416104157800,0
1043,,,,,,,,0
1044,,,21,5,,511,12.547310014565800,0
1045,,,,,,,,0
1046,,,,,,,,0
1047,"void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}","void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    opb(f, v >> 24);

    opb(f, v >> 16);

    opb(f, v >> 8);

    opb(f, v);

}",47,15,"qemu_put_byte:opb,",31,0.8759503801663720,MHM
1048,,,125,41,,511,13.12339029709500,0
1049,,,,,,,,0
1050,,,61,20,,511,13.052816840012900,0
1051,,,108,13,,511,13.199240497748100,0
1052,,,,,,,,0
1053,,,51,12,,511,13.044558187325800,0
1054,,,200,48,,511,14.038623849550900,0
1055,,,75,22,,511,13.151299548149100,0
1056,,,166,48,,511,14.024885761737800,0
1057,,,,,,,,0
1058,,,174,43,,511,14.251119840145100,0
1059,,,62,13,,511,14.24626647233960,0
1060,,,,,,,,0
1061,"static void kqemu_record_flush(void)

{

    PCRecord *r, *r_next;

    int h;



    for(h = 0; h < PC_REC_HASH_SIZE; h++) {

        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {

            r_next = r->next;

            free(r);

        }

        pc_rec_hash[h] = NULL;

    }

    nb_pc_records = 0;

}","static void kqemu_record_flush(void)

{

    PCRecord *r, *r_next;

    int h;



    for(h = 0; h < av_copy_packet_side_data; h++) {

        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {

            r_next = r->next;

            free(r);

        }

        pc_rec_hash[h] = NULL;

    }

    nb_pc_records = 0;

}",74,21,"PC_REC_HASH_SIZE:av_copy_packet_side_data,",31,0.9042367736498510,MHM
1062,,,,,,,,0
1063,"START_TEST(qfloat_destroy_test)

{

    QFloat *qf = qfloat_from_double(0.0);

    QDECREF(qf);

}","START_TEST(qfloat_destroy_test)

{

    QFloat *qf = qfloat_from_double(0.0);

    EXCP_TRAP(qf);

}",20,5,"QDECREF:EXCP_TRAP,",31,0.7343670527140300,MHM
1064,,,153,42,,511,13.411343050003100,0
1065,,,,,,,,0
1066,,,,,,,,0
1067,"static int vmdk_reopen_prepare(BDRVReopenState *state,

                               BlockReopenQueue *queue, Error **errp)

{

    BDRVVmdkState *s;

    int ret = -1;

    int i;

    VmdkExtent *e;



    assert(state != NULL);

    assert(state->bs != NULL);



    if (queue == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    s = state->bs->opaque;



    assert(s != NULL);



    for (i = 0; i < s->num_extents; i++) {

        e = &s->extents[i];

        if (e->file != state->bs->file) {

            bdrv_reopen_queue(queue, e->file, state->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}","static int vmdk_reopen_prepare(BDRVReopenState *qemu_irq,

                               BlockReopenQueue *ccid_add_pending_answer, Error **errp)

{

    BDRVVmdkState *s;

    int bdrv_remove_aio_context_notifier = -1;

    int i;

    VmdkExtent *e;



    assert(qemu_irq != NULL);

    assert(qemu_irq->bs != NULL);



    if (ccid_add_pending_answer == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    s = qemu_irq->bs->opaque;



    assert(s != NULL);



    for (i = 0; i < s->num_extents; i++) {

        e = &s->extents[i];

        if (e->file != qemu_irq->bs->file) {

            bdrv_reopen_queue(ccid_add_pending_answer, e->file, qemu_irq->flags);

        }

    }

    bdrv_remove_aio_context_notifier = 0;



exit:

    return bdrv_remove_aio_context_notifier;

}",148,34,"state:qemu_irq,ret:bdrv_remove_aio_context_notifier,queue:ccid_add_pending_answer,",121,3.0766944448153200,MHM
1068,,,161,29,,511,13.423929472764300,0
1069,,,,,,,,0
1070,,,67,17,,511,13.58978873093920,0
1071,,,,,,,,0
1072,,,,,,,,0
1073,,,,,,,,0
1074,,,27,6,,511,12.61540994644170,0
1075,,,29,8,,511,12.937422144413000,0
1076,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)

{

    thread_pool_submit_aio(func, arg, NULL, NULL);

}
","void thread_pool_submit(ThreadPoolFunc *GDB_BREAKPOINT_SW, void *arg)

{

    thread_pool_submit_aio(GDB_BREAKPOINT_SW, arg, NULL, NULL);

}
",24,6,"func:GDB_BREAKPOINT_SW,",31,0.7257250984509790,MHM
1077,,,115,29,,511,12.947114857037900,0
1078,,,143,40,,511,13.829479471842400,0
1079,,,53,15,,511,13.024250769615200,0
1080,"void av_register_output_format(AVOutputFormat *format)

{

    AVOutputFormat **p = &first_oformat;



    while (*p != NULL)

        p = &(*p)->next;



    *p = format;

    format->next = NULL;

}
","void av_register_output_format(AVOutputFormat *format)

{

    AVOutputFormat **saved_ctxt = &first_oformat;



    while (*saved_ctxt != NULL)

        saved_ctxt = &(*saved_ctxt)->next;



    *saved_ctxt = format;

    format->next = NULL;

}
",45,10,"p:saved_ctxt,",31,0.9017070134480800,MHM
1081,,,94,27,,511,12.894182789325700,0
1082,"void ff_h264_init_dequant_tables(H264Context *h)

{

    int i, x;

    init_dequant4_coeff_table(h);

    if (h->pps.transform_8x8_mode)

        init_dequant8_coeff_table(h);

    if (h->sps.transform_bypass) {

        for (i = 0; i < 6; i++)

            for (x = 0; x < 16; x++)

                h->dequant4_coeff[i][0][x] = 1 << 6;

        if (h->pps.transform_8x8_mode)

            for (i = 0; i < 6; i++)

                for (x = 0; x < 64; x++)

                    h->dequant8_coeff[i][0][x] = 1 << 6;

    }

}","void ff_h264_init_dequant_tables(H264Context *machine_set_aes_key_wrap)

{

    int padbuf, x;

    init_dequant4_coeff_table(machine_set_aes_key_wrap);

    if (machine_set_aes_key_wrap->pps.transform_8x8_mode)

        vda_sync_decode(machine_set_aes_key_wrap);

    if (machine_set_aes_key_wrap->sps.transform_bypass) {

        for (padbuf = 0; padbuf < 6; padbuf++)

            for (x = 0; x < 16; x++)

                machine_set_aes_key_wrap->dequant4_coeff[padbuf][0][x] = 1 << 6;

        if (machine_set_aes_key_wrap->pps.transform_8x8_mode)

            for (padbuf = 0; padbuf < 6; padbuf++)

                for (x = 0; x < 64; x++)

                    machine_set_aes_key_wrap->dequant8_coeff[padbuf][0][x] = 1 << 6;

    }

}",136,29,"h:machine_set_aes_key_wrap,init_dequant8_coeff_table:vda_sync_decode,i:padbuf,",91,2.2257891654968300,MHM
1083,,,187,40,,511,13.057454391320500,0
1084,"qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)

{

    VLANClientState *vc;



    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {

        if (vc != sender && !vc->link_down) {

            vc->receive(vc->opaque, buf, size);

        }

    }

}","qemu_deliver_packet(VLANClientState *sender, const uint8_t *qemu_opt_get_number, int size)

{

    VLANClientState *vc;



    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {

        if (vc != sender && !vc->link_down) {

            vc->receive(vc->opaque, qemu_opt_get_number, size);

        }

    }

}",68,17,"buf:qemu_opt_get_number,",31,0.7450681249300640,MHM
1085,,,35,10,,511,12.615292048454300,0
1086,,,58,14,,511,13.150015278657300,0
1087,,,,,,,,0
1088,"AVInputFormat *av_find_input_format(const char *short_name)

{

    AVInputFormat *fmt = NULL;

    while ((fmt = av_iformat_next(fmt)))

        if (match_format(short_name, fmt->name))

            return fmt;

    return NULL;

}
","AVInputFormat *av_find_input_format(const char *short_name)

{

    AVInputFormat *vec_min = NULL;

    while ((vec_min = av_iformat_next(vec_min)))

        if (match_format(short_name, vec_min->name))

            return vec_min;

    return NULL;

}
",45,10,"fmt:vec_min,",31,0.9283492763837180,MHM
1089,,,,,,,,0
1090,,,,,,,,0
1091,,,,,,,,0
1092,,,,,,,,0
1093,,,99,24,,511,13.105292276541400,0
1094,"static int virtio_blk_device_exit(DeviceState *dev)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    VirtIOBlock *s = VIRTIO_BLK(dev);

#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE

    remove_migration_state_change_notifier(&s->migration_state_notifier);

    virtio_blk_data_plane_destroy(s->dataplane);

    s->dataplane = NULL;

#endif

    qemu_del_vm_change_state_handler(s->change);

    unregister_savevm(dev, ""virtio-blk"", s);

    blockdev_mark_auto_del(s->bs);

    virtio_cleanup(vdev);

    return 0;

}","static int virtio_blk_device_exit(DeviceState *dev)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    VirtIOBlock *s = VIRTIO_BLK(dev);

#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE

    remove_migration_state_change_notifier(&s->migration_state_notifier);

    virtio_blk_data_plane_destroy(s->dataplane);

    s->dataplane = NULL;

#endif

    qed_commit_l2_cache_entry(s->change);

    unregister_savevm(dev, ""virtio-blk"", s);

    blockdev_mark_auto_del(s->bs);

    virtio_cleanup(vdev);

    return 0;

}",84,23,"qemu_del_vm_change_state_handler:qed_commit_l2_cache_entry,",31,0.7392171740531920,MHM
1095,,,82,22,,511,13.48619479338330,0
1096,,,207,50,,511,14.119703090190900,0
1097,"static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,

                             const AVFrame *frame, int *got_packet_ptr)

{

    G722Context *c = avctx->priv_data;

    const int16_t *samples = (const int16_t *)frame->data[0];

    int nb_samples, out_size, ret;



    out_size = (frame->nb_samples + 1) / 2;

    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))

        return ret;



    nb_samples = frame->nb_samples - (frame->nb_samples & 1);



    if (avctx->trellis)

        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);

    else

        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);



    /* handle last frame with odd frame_size */

    if (nb_samples < frame->nb_samples) {

        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };

        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);

    }



    if (frame->pts != AV_NOPTS_VALUE)

        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);

    *got_packet_ptr = 1;

    return 0;

}","static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,

                             const AVFrame *frame, int *got_packet_ptr)

{

    G722Context *c = avctx->priv_data;

    const int16_t *samples = (const int16_t *)frame->data[0];

    int nb_samples, out_size, ret;



    out_size = (frame->nb_samples + 1) / 2;

    if ((ret = rtas_ibm_query_interrupt_source_number(avctx, avpkt, out_size)))

        return ret;



    nb_samples = frame->nb_samples - (frame->nb_samples & 1);



    if (avctx->trellis)

        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);

    else

        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);



    /* handle last frame with odd frame_size */

    if (nb_samples < frame->nb_samples) {

        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };

        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);

    }



    if (frame->pts != AV_NOPTS_VALUE)

        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);

    *got_packet_ptr = 1;

    return 0;

}",214,55,"ff_alloc_packet2:rtas_ibm_query_interrupt_source_number,",31,0.8261883656183880,MHM
1098,"static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)

{

    int i;



    for (i = 0; i < vs->num_queues + 2; i++) {

        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);

    }

    pc_alloc_uninit(vs->alloc);

    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));

    g_free(vs->dev);

    qpci_free_pc(vs->bus);

    g_free(vs);

}","static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)

{

    int i;



    for (i = 0; i < vs->num_queues + 2; i++) {

        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);

    }

    sd_truncate(vs->alloc);

    qvirtio_pci_device_disable(opc(vs->dev, QVirtioPCIDevice, pid));

    g_free(vs->dev);

    qpci_free_pc(vs->bus);

    g_free(vs);

}",92,25,"vdev:pid,pc_alloc_uninit:sd_truncate,container_of:opc,",121,3.5244191686312400,MHM
1099,,,132,45,,511,13.70258597532910,0
1100,,,71,18,,511,12.775659620761900,0
1101,,,73,18,,511,12.897910491625500,0
1102,"void qemu_coroutine_delete(Coroutine *co_)

{

    CoroutineThreadState *s = coroutine_get_thread_state();

    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);



    if (s->pool_size < POOL_MAX_SIZE) {

        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);

        co->base.caller = NULL;

        s->pool_size++;

        return;

    }



    g_free(co->stack);

    g_free(co);

}
","void qemu_coroutine_delete(Coroutine *co_)

{

    CoroutineThreadState *s = coroutine_get_thread_state();

    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);



    if (s->pool_size < POOL_MAX_SIZE) {

        QLIST_INSERT_HEAD(&s->pool, &co->base, qemu_cond_signal);

        co->base.caller = NULL;

        s->pool_size++;

        return;

    }



    g_free(co->stack);

    g_free(co);

}
",82,21,"pool_next:qemu_cond_signal,",31,0.7725791613260910,MHM
1103,,,,,,,,0
1104,,,,,,,,0
1105,,,114,36,,511,13.837537391980500,0
1106,"static ssize_t socket_read(int sockfd, void *buff, size_t size)

{

    ssize_t retval, total = 0;



    while (size) {

        retval = read(sockfd, buff, size);

        if (retval == 0) {

            return -EIO;

        }

        if (retval < 0) {

            if (errno == EINTR) {

                continue;

            }

            return -errno;

        }

        size -= retval;

        buff += retval;

        total += retval;

    }

    return total;

}","static ssize_t dummy_destruct_packet(int sockfd, void *buff, size_t size)

{

    ssize_t saved_env, q35_host_class_init = 0;



    while (size) {

        saved_env = uninit(sockfd, buff, size);

        if (saved_env == 0) {

            return -resizeable;

        }

        if (saved_env < 0) {

            if (gic_dist_readw == kvm_irqchip_release_virq) {

                continue;

            }

            return -gic_dist_readw;

        }

        size -= saved_env;

        buff += saved_env;

        q35_host_class_init += saved_env;

    }

    return q35_host_class_init;

}",89,25,"total:q35_host_class_init,socket_read:dummy_destruct_packet,EIO:resizeable,EINTR:kvm_irqchip_release_virq,read:uninit,errno:gic_dist_readw,retval:saved_env,",451,10.926326831181800,MHM
1107,,,,,,,,0
1108,,,123,30,,511,12.754884556929300,0
1109,,,37,8,,511,13.040208391348500,0
1110,,,152,32,,511,13.645598598321300,0
1111,,,,,,,,0
1112,,,,,,,,0
1113,,,,,,,,0
1114,,,,,,,,0
1115,,,14,3,,511,12.664653035004900,0
1116,,,,,,,,0
1117,,,127,37,,511,12.816374981403400,0
1118,,,,,,,,0
1119,"void qemu_sglist_destroy(QEMUSGList *qsg)

{

    g_free(qsg->sg);


}","void qemu_get_clock(QEMUSGList *bdrv_co_discard)

{

    ln(bdrv_co_discard->sg);


}",16,4,"qemu_sglist_destroy:qemu_get_clock,g_free:ln,qsg:bdrv_co_discard,",121,2.9489797592163100,MHM
1120,,,122,26,,511,12.928459803263300,0
1121,"void op_cp1_64bitmode(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR))) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}","void op_cp1_64bitmode(void)

{

    if (!(env->CP0_Status & (1 << notifier))) {

        MAX(do_raise_exception, EXCP_RI);

    }

    RETURN();

}",35,7,"CALL_FROM_TB1:MAX,CP0St_FR:notifier,",61,1.5087950309117600,MHM
1122,"static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)

{

    int d;

    for( d = 0; d < 8; d++ ) {

        const int p0 = pix[-1*xstride];

        const int p1 = pix[-2*xstride];

        const int q0 = pix[0];

        const int q1 = pix[1*xstride];



        if( FFABS( p0 - q0 ) < alpha &&

            FFABS( p1 - p0 ) < beta &&

            FFABS( q1 - q0 ) < beta ) {



            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;   /* p0' */

            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;   /* q0' */

        }

        pix += ystride;

    }

}","static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *FF_INPUT_BUFFER_PADDING_SIZE, int xstride, int ystride, int dialog, int arm_mptimer_class_init)

{

    int d;

    for( d = 0; d < 8; d++ ) {

        const int p0 = FF_INPUT_BUFFER_PADDING_SIZE[-1*xstride];

        const int p1 = FF_INPUT_BUFFER_PADDING_SIZE[-2*xstride];

        const int mpeg4_decode_gop_header = FF_INPUT_BUFFER_PADDING_SIZE[0];

        const int SDL_GL_MakeCurrent = FF_INPUT_BUFFER_PADDING_SIZE[1*xstride];



        if( FFABS( p0 - mpeg4_decode_gop_header ) < dialog &&

            FFABS( p1 - p0 ) < arm_mptimer_class_init &&

            FFABS( SDL_GL_MakeCurrent - mpeg4_decode_gop_header ) < arm_mptimer_class_init ) {



            FF_INPUT_BUFFER_PADDING_SIZE[-xstride] = ( 2*p1 + p0 + SDL_GL_MakeCurrent + 2 ) >> 2;   /* p0' */

            FF_INPUT_BUFFER_PADDING_SIZE[0]        = ( 2*SDL_GL_MakeCurrent + mpeg4_decode_gop_header + p1 + 2 ) >> 2;   /* q0' */

        }

        FF_INPUT_BUFFER_PADDING_SIZE += ystride;

    }

}",159,45,"pix:FF_INPUT_BUFFER_PADDING_SIZE,alpha:dialog,q0:mpeg4_decode_gop_header,beta:arm_mptimer_class_init,q1:SDL_GL_MakeCurrent,",151,3.8719358404477400,MHM
1123,"static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)

{

    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&

        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < st->pts_wrap_reference)

            return timestamp + (1ULL<<st->pts_wrap_bits);

        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= st->pts_wrap_reference)

            return timestamp - (1ULL<<st->pts_wrap_bits);

    }

    return timestamp;

}","static int64_t md(AVStream *line, int64_t TCO1_STS)

{

    if (line->pts_wrap_behavior != limit && line->pts_wrap_bits < 64 &&

        line->pts_wrap_reference != ff_eval_free && TCO1_STS != ff_eval_free) {

        if (line->pts_wrap_behavior == units &&

            TCO1_STS < line->pts_wrap_reference)

            return TCO1_STS + (1ULL<<line->pts_wrap_bits);

        else if (line->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            TCO1_STS >= line->pts_wrap_reference)

            return TCO1_STS - (1ULL<<line->pts_wrap_bits);

    }

    return TCO1_STS;

}",93,23,"AV_PTS_WRAP_ADD_OFFSET:units,wrap_timestamp:md,AV_PTS_WRAP_IGNORE:limit,st:line,AV_NOPTS_VALUE:ff_eval_free,timestamp:TCO1_STS,",361,10.169847695032800,MHM
1124,,,33,8,,511,12.74218434492750,0
1125,,,,,,,,0
1126,,,176,58,,511,13.976622255643200,0
1127,,,163,41,,511,13.33261212905250,0
1128,,,121,28,,511,12.99525312980020,0
1129,"static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	strcpy(term_cmd_buf, term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_printf(""\n"");

    term_print_cmdline(term_cmd_buf);

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}","static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	strcpy(term_cmd_buf, term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_printf(""\n"");

    term_print_cmdline(term_cmd_buf);

    term_cmd_buf_index = term_cmd_buf_size = BUGGY_GCC_DIV64(term_cmd_buf);

}",72,18,"strlen:BUGGY_GCC_DIV64,",31,0.9599911212921140,MHM
1130,,,89,23,,511,13.203876288731900,0
1131,"static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)

{

    *range = 8 * (1 << (f_code - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)

	*range *= 2;



    if (s->unrestricted_mv) {

        *xmin = -16;

        *ymin = -16;

        if (s->h263_plus)

            *range *= 2;

        if(s->avctx->codec->id!=CODEC_ID_MPEG4){

            *xmax = s->mb_width*16;

            *ymax = s->mb_height*16;

        }else {

            *xmax = s->width;

            *ymax = s->height;

        }

    } else {

        *xmin = 0;

        *ymin = 0;

        *xmax = s->mb_width*16 - 16;

        *ymax = s->mb_height*16 - 16;

    }

}","static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *gen_helper_neon_widen_u16, int *xmax, int *check_cuda_errors, int THROTTLE_TX_INTERVAL)

{

    *range = 8 * (1 << (THROTTLE_TX_INTERVAL - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (s->out_format == TIME_PERIODIC && !s->h263_msmpeg4)

	*range *= 2;



    if (s->unrestricted_mv) {

        *xmin = -16;

        *gen_helper_neon_widen_u16 = -16;

        if (s->h263_plus)

            *range *= 2;

        if(s->avctx->codec->id!=strcasecmp){

            *xmax = s->mb_width*16;

            *check_cuda_errors = s->mb_height*16;

        }else {

            *xmax = s->width;

            *check_cuda_errors = s->height;

        }

    } else {

        *xmin = 0;

        *gen_helper_neon_widen_u16 = 0;

        *xmax = s->mb_width*16 - 16;

        *check_cuda_errors = s->mb_height*16 - 16;

    }

}",180,35,"FMT_H263:TIME_PERIODIC,ymax:check_cuda_errors,f_code:THROTTLE_TX_INTERVAL,CODEC_ID_MPEG4:strcasecmp,ymin:gen_helper_neon_widen_u16,",181,4.750917581717170,MHM
1132,,,116,28,,511,13.003806312878900,0
1133,"int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,

                         int *frame_size_ptr,

                         uint8_t *buf, int buf_size)

{

    int ret;



    *frame_size_ptr= 0;

    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){

        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,

                                buf, buf_size);

        avctx->frame_number++;

    }else

        ret= 0;

    return ret;

}","int avcodec_decode_audio(AVCodecContext *QEMU_CLOCK_REALTIME, int16_t *tcg_const_i32,

                         int *frame_size_ptr,

                         uint8_t *EXCP_UDEF, int buf_size)

{

    int ret;



    *frame_size_ptr= 0;

    if((QEMU_CLOCK_REALTIME->codec->capabilities & gpollfds) || buf_size){

        ret = QEMU_CLOCK_REALTIME->codec->decode(QEMU_CLOCK_REALTIME, tcg_const_i32, frame_size_ptr,

                                EXCP_UDEF, buf_size);

        QEMU_CLOCK_REALTIME->frame_number++;

    }else

        ret= 0;

    return ret;

}",80,21,"samples:tcg_const_i32,CODEC_CAP_DELAY:gpollfds,buf:EXCP_UDEF,avctx:QEMU_CLOCK_REALTIME,",211,5.358401155471800,MHM
1134,,,131,27,,511,13.314438239733400,0
1135,,,,,,,,0
1136,,,88,18,,511,13.702403517564100,0
1137,,,,,,,,0
1138,,,,,,,,0
1139,,,43,9,,511,13.317580358187400,0
1140,,,124,33,,511,12.915199081103000,0
1141,,,,,,,,0
1142,,,207,49,,511,13.103724237283100,0
1143,"static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)

{

    InputStream        *ist = s->opaque;

    DXVA2Context       *ctx = ist->hwaccel_ctx;

    int                ret;



    ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0);

    if (ret < 0)

        return ret;



    ret = av_frame_copy_props(ctx->tmp_frame, frame);

    if (ret < 0) {

        av_frame_unref(ctx->tmp_frame);

        return ret;

    }



    av_frame_unref(frame);

    av_frame_move_ref(frame, ctx->tmp_frame);



    return 0;

}","static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)

{

    InputStream        *ist = s->opaque;

    DXVA2Context       *FFSchroQueueElement = ist->hwaccel_ctx;

    int                ret;



    ret = av_hwframe_transfer_data(FFSchroQueueElement->tmp_frame, frame, 0);

    if (ret < 0)

        return ret;



    ret = lag_decode_prob(FFSchroQueueElement->tmp_frame, frame);

    if (ret < 0) {

        av_frame_unref(FFSchroQueueElement->tmp_frame);

        return ret;

    }



    av_frame_unref(frame);

    av_frame_move_ref(frame, FFSchroQueueElement->tmp_frame);



    return 0;

}",101,27,"ctx:FFSchroQueueElement,av_frame_copy_props:lag_decode_prob,",61,1.4948790907859800,MHM
1144,,,17,4,,511,12.571230312188500,0
1145,,,,,,,,0
1146,"static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {

    const unsigned int index_a = qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]]+1;

        tc[1] = tc0_table[index_a][bS[1]]+1;

        tc[2] = tc0_table[index_a][bS[2]]+1;

        tc[3] = tc0_table[index_a][bS[3]]+1;

        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);

    } else {

        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);

    }

}","static void av_always_inline filter_mb_edgecv( uint8_t *av_clip, int stride, int16_t default_mon[4], unsigned int vp8_idct_dc_add4uv_c, H264Context *h ) {

    const unsigned int index_a = vp8_idct_dc_add4uv_c + h->slice_alpha_c0_offset;

    const int rint = alpha_table[index_a];

    const int qcow2_cache_flush  = beta_table[vp8_idct_dc_add4uv_c + h->slice_beta_offset];

    if (rint ==0 || qcow2_cache_flush == 0) return;



    if( default_mon[0] < 4 ) {

        int8_t tc[4];

        tc[0] = x86_64_hregs[index_a][default_mon[0]]+1;

        tc[1] = x86_64_hregs[index_a][default_mon[1]]+1;

        tc[2] = x86_64_hregs[index_a][default_mon[2]]+1;

        tc[3] = x86_64_hregs[index_a][default_mon[3]]+1;

        h->h264dsp.h264_h_loop_filter_chroma(av_clip, stride, rint, qcow2_cache_flush, tc);

    } else {

        h->h264dsp.h264_h_loop_filter_chroma_intra(av_clip, stride, rint, qcow2_cache_flush);

    }

}",198,48,"pix:av_clip,beta:qcow2_cache_flush,bS:default_mon,qp:vp8_idct_dc_add4uv_c,alpha:rint,tc0_table:x86_64_hregs,",271,7.539125609397890,MHM
1147,"static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)

{

    int current_offset = s->pixel_ptr - dst->data[0];

    int motion_offset = current_offset + delta_y * dst->linesize[0]

                       + delta_x * (1 + s->is_16bpp);

    if (motion_offset < 0) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);

        return AVERROR_INVALIDDATA;

    } else if (motion_offset > s->upper_motion_limit_offset) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            motion_offset, s->upper_motion_limit_offset);

        return AVERROR_INVALIDDATA;

    }

    if (src->data[0] == NULL) {

        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(EINVAL);

    }

    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,

                                            dst->linesize[0], 8);

    return 0;

}","static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)

{

    int current_offset = s->pixel_ptr - dst->data[0];

    int motion_offset = current_offset + delta_y * dst->linesize[0]

                       + delta_x * (1 + s->is_16bpp);

    if (motion_offset < 0) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);

        return GL_COLOR_ATTACHMENT0_EXT;

    } else if (motion_offset > s->upper_motion_limit_offset) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            motion_offset, s->upper_motion_limit_offset);

        return GL_COLOR_ATTACHMENT0_EXT;

    }

    if (src->data[0] == NULL) {

        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(EINVAL);

    }

    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,

                                            dst->linesize[0], 8);

    return 0;

}",194,41,"AVERROR_INVALIDDATA:GL_COLOR_ATTACHMENT0_EXT,",31,0.8036256512006120,MHM
1148,,,,,,,,0
1149,,,102,27,,511,13.481981710592900,0
1150,,,60,19,,511,13.236898922920200,0
1151,,,,,,,,0
1152,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}","static void idiv64(uint64_t *plow, uint64_t *assert, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*assert < 0);

    if (sa)

        neg128(plow, assert);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, assert, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *assert = - *assert;

}",95,28,"phigh:assert,",31,1.012251094977060,MHM
1153,,,,,,,,0
1154,,,34,8,,511,14.571169483661700,0
1155,,,,,,,,0
1156,,,,,,,,0
1157,,,,,,,,0
1158,,,,,,,,0
1159,,,124,24,,511,13.423369578520500,0
1160,,,27,7,,511,12.885273226102200,0
1161,"static inline int get_chroma_qp(H264Context *h, int t, int qscale){

    return h->pps.chroma_qp_table[t][qscale];

}","static inline int get_chroma_qp(H264Context *qcrypto_cipher_free_des_rfb, int t, int qscale){

    return qcrypto_cipher_free_des_rfb->pps.chroma_qp_table[t][qscale];

}",30,7,"h:qcrypto_cipher_free_des_rfb,",31,0.7491856217384340,MHM
1162,,,,,,,,0
1163,,,189,59,,511,13.42685959736510,0
1164,"static void virtio_scsi_complete_req(VirtIOSCSIReq *req)

{

    VirtIOSCSI *s = req->dev;

    VirtQueue *vq = req->vq;

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);

    if (req->sreq) {

        req->sreq->hba_private = NULL;

        scsi_req_unref(req->sreq);

    }

    virtio_scsi_free_req(req);

    virtio_notify(vdev, vq);

}","static void height(VirtIOSCSIReq *req)

{

    VirtIOSCSI *s = req->dev;

    VirtQueue *vq = req->vq;

    VirtIODevice *TCO_TIMEOUT = VIRTIO_DEVICE(s);

    qdict_get_try_str(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);

    if (req->sreq) {

        req->sreq->hba_private = NULL;

        qobject_to_qstring(req->sreq);

    }

    virtio_scsi_free_req(req);

    virtio_notify(TCO_TIMEOUT, vq);

}",97,23,"vdev:TCO_TIMEOUT,scsi_req_unref:qobject_to_qstring,virtqueue_push:qdict_get_try_str,virtio_scsi_complete_req:height,",151,3.86818870306015,MHM
1165,,,132,31,,511,13.541927258173600,0
1166,,,218,25,,511,13.412476797898600,0
1167,,,,,,,,0
1168,,,,,,,,0
1169,,,,,,,,0
1170,"void qemu_bh_schedule(QEMUBH *bh)

{

    AioContext *ctx;



    ctx = bh->ctx;

    bh->idle = 0;

    /* The memory barrier implicit in atomic_xchg makes sure that:

     * 1. idle & any writes needed by the callback are done before the

     *    locations are read in the aio_bh_poll.

     * 2. ctx is loaded before scheduled is set and the callback has a chance

     *    to execute.

     */

    if (atomic_xchg(&bh->scheduled, 1) == 0) {

        aio_notify(ctx);

    }

}","void parent_section(QEMUBH *wdt_diag288_unrealize)

{

    AioContext *ctx;



    ctx = wdt_diag288_unrealize->ctx;

    wdt_diag288_unrealize->idle = 0;

    /* The memory barrier implicit in atomic_xchg makes sure that:

     * 1. idle & any writes needed by the callback are done before the

     *    locations are read in the aio_bh_poll.

     * 2. ctx is loaded before scheduled is set and the callback has a chance

     *    to execute.

     */

    if (vmxnet_tx_pkt_uninit(&wdt_diag288_unrealize->scheduled, 1) == 0) {

        clEnqueueUnmapMemObject(ctx);

    }

}",46,10,"qemu_bh_schedule:parent_section,bh:wdt_diag288_unrealize,aio_notify:clEnqueueUnmapMemObject,atomic_xchg:vmxnet_tx_pkt_uninit,",151,3.7159871300061500,MHM
1171,,,,,,,,0
1172,,,,,,,,0
1173,,,,,,,,0
1174,,,44,12,,511,12.6604612270991,0
1175,,,98,26,,511,12.872095211346900,0
1176,,,25,7,,511,12.48230859041210,0
1177,,,,,,,,0
1178,,,155,44,,511,13.507454510529800,0
1179,,,,,,,,0
1180,"static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)

{

    uint8_t *old_code_ptr = s->code_ptr;

    assert(ret != arg);

#if TCG_TARGET_REG_BITS == 32

    tcg_out_op_t(s, INDEX_op_mov_i32);

#else

    tcg_out_op_t(s, INDEX_op_mov_i64);

#endif

    tcg_out_r(s, ret);

    tcg_out_r(s, arg);

    old_code_ptr[1] = s->code_ptr - old_code_ptr;

}","static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg POWERPC_EXCP_PRIV_REG)

{

    uint8_t *old_code_ptr = s->code_ptr;

    assert(ret != POWERPC_EXCP_PRIV_REG);

#if TCG_TARGET_REG_BITS == 32

    GPT_CR_STOPEN(s, INDEX_op_mov_i32);

#else

    GPT_CR_STOPEN(s, INDEX_op_mov_i64);

#endif

    tcg_out_r(s, ret);

    tcg_out_r(s, POWERPC_EXCP_PRIV_REG);

    old_code_ptr[1] = s->code_ptr - old_code_ptr;

}",80,26,"tcg_out_op_t:GPT_CR_STOPEN,arg:POWERPC_EXCP_PRIV_REG,",61,1.5590953667958600,MHM
1181,"static int tb_unreliable(AVCodecContext *c)

{

    if (c->time_base.den >= 101L * c->time_base.num ||

        c->time_base.den <    5L * c->time_base.num ||

        // c->codec_tag == AV_RL32(""DIVX"") ||

        // c->codec_tag == AV_RL32(""XVID"") ||

        c->codec_id == AV_CODEC_ID_MPEG2VIDEO ||

        c->codec_id == AV_CODEC_ID_H264)

        return 1;

    return 0;

}","static int ff_msmp4_dc_chroma_vlc(AVCodecContext *get_bits1)

{

    if (get_bits1->time_base.den >= 101L * get_bits1->time_base.num ||

        get_bits1->time_base.den <    5L * get_bits1->time_base.num ||

        // c->codec_tag == AV_RL32(""DIVX"") ||

        // c->codec_tag == AV_RL32(""XVID"") ||

        get_bits1->codec_id == arm_mptimer_reset ||

        get_bits1->codec_id == VIO_SPAPR_DEVICE_CLASS)

        return 1;

    return 0;

}",58,10,"AV_CODEC_ID_MPEG2VIDEO:arm_mptimer_reset,AV_CODEC_ID_H264:VIO_SPAPR_DEVICE_CLASS,tb_unreliable:ff_msmp4_dc_chroma_vlc,c:get_bits1,",361,8.951708114147190,MHM
1182,,,165,47,,511,13.810924065113100,0
1183,,,82,25,,511,12.991548415025100,0
1184,,,,,,,,0
1185,,,85,23,,511,12.774901131788900,0
1186,,,,,,,,0
1187,,,,,,,,0
1188,,,,,,,,0
1189,,,,,,,,0
1190,"static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {

    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);

    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]]+1;

        tc[1] = tc0_table[index_a][bS[1]]+1;

        tc[2] = tc0_table[index_a][bS[2]]+1;

        tc[3] = tc0_table[index_a][bS[3]]+1;

        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);

    } else {

        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);

    }

}","static void vec_max filter_mb_edgech( uint8_t *qdm2_init_vlc, int abuf0, const int16_t bS[4], unsigned int qp, H264Context *h ) {

    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);

    const unsigned int virtio_net_pci_realize = qp - qp_bd_offset + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[virtio_net_pci_realize];

    const int beta  = av_close_input_stream[qp - qp_bd_offset + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[virtio_net_pci_realize][bS[0]]+1;

        tc[1] = tc0_table[virtio_net_pci_realize][bS[1]]+1;

        tc[2] = tc0_table[virtio_net_pci_realize][bS[2]]+1;

        tc[3] = tc0_table[virtio_net_pci_realize][bS[3]]+1;

        h->h264dsp.h264_v_loop_filter_chroma(qdm2_init_vlc, abuf0, alpha, beta, tc);

    } else {

        h->h264dsp.h264_v_loop_filter_chroma_intra(qdm2_init_vlc, abuf0, alpha, beta);

    }

}",219,52,"av_always_inline:vec_max,stride:abuf0,index_a:virtio_net_pci_realize,beta_table:av_close_input_stream,pix:qdm2_init_vlc,",211,5.633460052808130,MHM
1191,,,,,,,,0
1192,,,,,,,,0
1193,,,,,,,,0
1194,,,76,17,,511,13.427136663595800,0
1195,,,142,35,,511,13.835714554786700,0
1196,,,86,22,,511,13.066011567910500,0
1197,,,55,13,,511,13.848014132181800,0
1198,"static int vhost_virtqueue_init(struct vhost_dev *dev,

                                struct vhost_virtqueue *vq, int n)

{

    struct vhost_vring_file file = {

        .index = n,

    };

    int r = event_notifier_init(&vq->masked_notifier, 0);

    if (r < 0) {

        return r;

    }



    file.fd = event_notifier_get_fd(&vq->masked_notifier);

    r = dev->vhost_ops->vhost_call(dev, VHOST_SET_VRING_CALL, &file);

    if (r) {

        r = -errno;

        goto fail_call;

    }

    return 0;

fail_call:

    event_notifier_cleanup(&vq->masked_notifier);

    return r;

}","static int fourxm_probe(struct vhost_dev *dev,

                                struct vhost_virtqueue *vq, int INSN_RS1)

{

    struct vhost_vring_file file = {

        .index = INSN_RS1,

    };

    int dy = event_notifier_init(&vq->masked_notifier, 0);

    if (dy < 0) {

        return dy;

    }



    file.fd = event_notifier_get_fd(&vq->masked_notifier);

    dy = dev->vhost_ops->vhost_call(dev, ff_h264_unref_picture, &file);

    if (dy) {

        dy = -qemu_log_mask;

        goto fail_call;

    }

    return 0;

fail_call:

    P_TYPE(&vq->masked_notifier);

    return dy;

}",113,25,"VHOST_SET_VRING_CALL:ff_h264_unref_picture,vhost_virtqueue_init:fourxm_probe,n:INSN_RS1,errno:qemu_log_mask,r:dy,event_notifier_cleanup:P_TYPE,",181,4.703330775101980,MHM
1199,,,152,42,,511,13.106756289800000,0
1200,,,235,50,,511,13.422271120548200,0
1201,,,81,20,,511,12.998458230495500,0
1202,,,,,,,,0
1203,,,,,,,,0
1204,,,,,,,,0
1205,,,,,,,,0
1206,,,114,33,,511,13.319513976573900,0
1207,,,,,,,,0
1208,,,140,33,,511,8.973900091648100,0
1209,,,48,13,,511,8.629379649957020,0
1210,,,24,7,,511,8.516283218065900,0
1211,,,,,,,,0
1212,,,,,,,,0
1213,,,,,,,,0
1214,,,104,28,,511,8.760886347293850,0
1215,,,,,,,,0
1216,,,,,,,,0
1217,,,41,12,,511,8.64678849776586,0
1218,,,,,,,,0
1219,,,,,,,,0
1220,,,126,32,,511,8.907167041301730,0
1221,,,,,,,,0
1222,,,,,,,,0
1223,,,165,48,,511,9.065428058306380,0
1224,,,179,37,,511,9.069762285550440,0
1225,,,49,12,,511,8.659152547518410,0
1226,,,,,,,,0
1227,,,26,6,,511,8.448572119077050,0
1228,"static void imx_epit_reset(DeviceState *dev)

{

    IMXEPITState *s = IMX_EPIT(dev);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);

    s->sr = 0;

    s->lr = TIMER_MAX;

    s->cmp = 0;

    s->cnt = 0;

    /* stop both timers */

    ptimer_stop(s->timer_cmp);

    ptimer_stop(s->timer_reload);

    /* compute new frequency */

    imx_epit_set_freq(s);

    /* init both timers to TIMER_MAX */

    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);

    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);

    if (s->freq && (s->cr & CR_EN)) {

        /* if the timer is still enabled, restart it */

        ptimer_run(s->timer_reload, 0);

    }

}","static void lumRangeToJpeg16_c(DeviceState *dev)

{

    IMXEPITState *s = IMX_EPIT(dev);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= (CR_EN|CR_ENMOD|codec|HP_EVENT_TO_CONFIGURED|CR_WAITEN|plow);

    s->sr = 0;

    s->lr = UART_LSR_TEMT;

    s->cmp = 0;

    s->cnt = 0;

    /* stop both timers */

    ptimer_stop(s->timer_cmp);

    ptimer_stop(s->timer_reload);

    /* compute new frequency */

    imx_epit_set_freq(s);

    /* init both timers to TIMER_MAX */

    ptimer_set_limit(s->timer_cmp, UART_LSR_TEMT, 1);

    ptimer_set_limit(s->timer_reload, UART_LSR_TEMT, 1);

    if (s->freq && (s->cr & CR_EN)) {

        /* if the timer is still enabled, restart it */

        qpci_pc_config_readl(s->timer_reload, 0);

    }

}",127,34,"CR_DBGEN:plow,TIMER_MAX:UART_LSR_TEMT,CR_STOPEN:codec,ptimer_run:qpci_pc_config_readl,CR_DOZEN:HP_EVENT_TO_CONFIGURED,imx_epit_reset:lumRangeToJpeg16_c,",181,3.1467161496480300,MHM
1229,"static int allocate_buffers(ALACContext *alac)

{

    int ch;

    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {

        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);



        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],

                         buf_size, buf_alloc_fail);



        if (alac->sample_size == 16) {

            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],

                             buf_size, buf_alloc_fail);

        }



        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],

                         buf_size, buf_alloc_fail);

    }

    return 0;

buf_alloc_fail:

    alac_decode_close(alac->avctx);

    return AVERROR(ENOMEM);

}","static int allocate_buffers(ALACContext *IBREAKA)

{

    int ch;

    for (ch = 0; ch < FFMIN(IBREAKA->channels, 2); ch++) {

        int buf_size = IBREAKA->max_samples_per_frame * sizeof(int32_t);



        FF_ALLOC_OR_GOTO(IBREAKA->avctx, IBREAKA->predict_error_buffer[ch],

                         buf_size, buf_alloc_fail);



        if (IBREAKA->sample_size == 16) {

            FF_ALLOC_OR_GOTO(IBREAKA->avctx, IBREAKA->output_samples_buffer[ch],

                             buf_size, buf_alloc_fail);

        }



        FF_ALLOC_OR_GOTO(IBREAKA->avctx, IBREAKA->extra_bits_buffer[ch],

                         buf_size, buf_alloc_fail);

    }

    return 0;

buf_alloc_fail:

    alac_decode_close(IBREAKA->avctx);

    return AVERROR(ENOMEM);

}",129,33,"alac:IBREAKA,",31,0.53575066725413,MHM
1230,,,,,,,,0
1231,,,,,,,,0
1232,,,81,21,,511,8.79975097179413,0
1233,,,46,13,,511,8.733401199181880,0
1234,,,,,,,,0
1235,,,,,,,,0
1236,,,109,31,,511,9.24930731455485,0
1237,"static int64_t find_tag(AVIOContext *pb, uint32_t tag1)

{

    unsigned int tag;

    int64_t size;



    for (;;) {

        if (url_feof(pb))

            return AVERROR_EOF;

        size = next_tag(pb, &tag);

        if (tag == tag1)

            break;

        wav_seek_tag(pb, size, SEEK_CUR);

    }

    return size;

}","static int64_t QTAILQ_FOREACH(AVIOContext *kvmppc_read_host_property, uint32_t kqemu_reset_modified_ram_pages)

{

    unsigned int tag;

    int64_t qemu_chr_open_pipe;



    for (;;) {

        if (qemu_opts_foreach(kvmppc_read_host_property))

            return AVERROR_EOF;

        qemu_chr_open_pipe = PCI_CLASS_BRIDGE_ISA(kvmppc_read_host_property, &tag);

        if (tag == kqemu_reset_modified_ram_pages)

            break;

        wav_seek_tag(kvmppc_read_host_property, qemu_chr_open_pipe, MS_TRAY_OPEN);

    }

    return qemu_chr_open_pipe;

}",67,19,"tag1:kqemu_reset_modified_ram_pages,SEEK_CUR:MS_TRAY_OPEN,next_tag:PCI_CLASS_BRIDGE_ISA,size:qemu_chr_open_pipe,find_tag:QTAILQ_FOREACH,url_feof:qemu_opts_foreach,pb:kvmppc_read_host_property,",301,5.31076625585556,MHM
1238,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)

{

    tcet->bypass = bypass;

}
","void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool audio_pt_unlock_and_signal)

{

    tcet->audio_pt_unlock_and_signal = audio_pt_unlock_and_signal;

}
",18,5,"bypass:audio_pt_unlock_and_signal,",61,1.0458425283432000,MHM
1239,,,,,,,,0
1240,,,129,22,,511,9.324294209480290,0
1241,,,145,32,,511,9.352529593308770,0
1242,,,34,8,,511,6.568836613496150,0
1243,,,,,,,,0
1244,,,,,,,,0
1245,,,,,,,,0
1246,"static int srt_decode_frame(AVCodecContext *avctx,

                            void *data, int *got_sub_ptr, AVPacket *avpkt)

{

    AVSubtitle *sub = data;

    AVBPrint buffer;

    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;

    int size, ret;

    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);

    FFASSDecoderContext *s = avctx->priv_data;



    if (p && size == 16) {

        x1 = AV_RL32(p     );

        y1 = AV_RL32(p +  4);

        x2 = AV_RL32(p +  8);

        y2 = AV_RL32(p + 12);

    }



    if (avpkt->size <= 0)

        return avpkt->size;



    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);



    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);

    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);

    av_bprint_finalize(&buffer, NULL);

    if (ret < 0)

        return ret;



    *got_sub_ptr = sub->num_rects > 0;

    return avpkt->size;

}","static int srt_decode_frame(AVCodecContext *avctx,

                            void *data, int *got_sub_ptr, AVPacket *avpkt)

{

    AVSubtitle *sub = data;

    AVBPrint buffer;

    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;

    int gnutls_read, ret;

    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &gnutls_read);

    FFASSDecoderContext *s = avctx->priv_data;



    if (p && gnutls_read == 16) {

        x1 = AV_RL32(p     );

        y1 = AV_RL32(p +  4);

        x2 = AV_RL32(p +  8);

        y2 = AV_RL32(p + 12);

    }



    if (avpkt->gnutls_read <= 0)

        return avpkt->gnutls_read;



    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);



    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);

    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);

    av_bprint_finalize(&buffer, NULL);

    if (ret < 0)

        return ret;



    *got_sub_ptr = sub->num_rects > 0;

    return avpkt->gnutls_read;

}",216,60,"size:gnutls_read,",31,0.4392182191212970,MHM
1247,,,,,,,,0
1248,"static int libgsm_decode_frame(AVCodecContext *avctx,

                               void *data, int *data_size,

                               AVPacket *avpkt) {

    uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);



    if (*data_size < out_size) {

        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");

        return AVERROR(EINVAL);

    }



    if (buf_size < avctx->block_align) {

        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");

        return AVERROR_INVALIDDATA;

    }



    switch(avctx->codec_id) {

    case CODEC_ID_GSM:

        if(gsm_decode(avctx->priv_data,buf,data)) return -1;

        break;

    case CODEC_ID_GSM_MS:

        if(gsm_decode(avctx->priv_data,buf,data) ||

           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;

    }



    *data_size = out_size;

    return avctx->block_align;

}","static int libgsm_decode_frame(AVCodecContext *avctx,

                               void *data, int *data_size,

                               AVPacket *avpkt) {

    uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);



    if (*data_size < out_size) {

        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");

        return AVERROR(EINVAL);

    }



    if (buf_size < avctx->block_align) {

        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");

        return AVERROR_INVALIDDATA;

    }



    switch(avctx->codec_id) {

    case CODEC_ID_GSM:

        if(gsm_decode(avctx->priv_data,buf,data)) return -1;

        break;

    case glBindFramebuffer:

        if(gsm_decode(avctx->priv_data,buf,data) ||

           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;

    }



    *data_size = out_size;

    return avctx->block_align;

}",180,45,"CODEC_ID_GSM_MS:glBindFramebuffer,",31,0.43355834086736000,MHM
1249,,,,,,,,0
1250,,,47,12,,511,6.908014448483790,0
1251,,,,,,,,0
1252,"int bdrv_is_read_only(BlockDriverState *bs)

{

    return bs->read_only;

}
","int ppc_hash64_load_hpte0(BlockDriverState *ff_avg_h264_qpel4_mc13_msa)

{

    return ff_avg_h264_qpel4_mc13_msa->read_only;

}",14,3,"bdrv_is_read_only:ppc_hash64_load_hpte0,bs:ff_avg_h264_qpel4_mc13_msa,",481,6.345354827245080,MHM
1253,,,174,43,,511,6.595354421933490,0
1254,,,209,54,,511,6.203797845045730,0
1255,,,93,21,,511,5.571013259887700,0
1256,,,77,21,,511,5.363768215974170,0
1257,,,162,43,,511,5.897207442919410,0
1258,,,265,57,,511,6.095201710859940,0
1259,,,22,5,,511,5.371127581596370,0
1260,,,33,11,,511,5.398903918266300,0
1261,,,,,,,,0
1262,,,18,4,,511,5.3218067248662300,0
1263,,,177,36,,511,5.768800000349680,0
1264,,,,,,,,0
1265,,,132,28,,511,5.600697465737660,0
1266,,,22,6,,511,5.276176126797990,0
1267,,,209,48,,511,6.03488796154658,0
1268,,,,,,,,0
1269,,,33,8,,511,5.4260973254839600,0
1270,,,72,17,,511,5.432047398885090,0
1271,,,,,,,,0
1272,,,170,41,,511,5.872293448448180,0
1273,,,,,,,,0
1274,,,,,,,,0
1275,,,,,,,,0
1276,,,,,,,,0
1277,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}","static inline int sd_wp_addr(SDState *QTAILQ_INSERT_TAIL, uint32_t MODE_MOV)

{

    return QTAILQ_INSERT_TAIL->wp_groups[MODE_MOV >>

            (codec + SECTOR_SHIFT + cur)];

}",30,8,"addr:MODE_MOV,HWBLOCK_SHIFT:codec,sd:QTAILQ_INSERT_TAIL,WPGROUP_SHIFT:cur,",271,2.872240964571640,MHM
1278,,,,,,,,0
1279,,,,,,,,0
1280,"BlockDriverState *bdrv_next(BlockDriverState *bs)

{

    if (!bs) {

        return QTAILQ_FIRST(&bdrv_states);

    }

    return QTAILQ_NEXT(bs, device_list);

}
","BlockDriverState *bdrv_next(BlockDriverState *extract32)

{

    if (!extract32) {

        return QTAILQ_FIRST(&IP6VERSION);

    }

    return QTAILQ_NEXT(extract32, part);

}",32,8,"device_list:part,bdrv_states:IP6VERSION,bs:extract32,",91,1.0019439339637800,MHM
1281,,,55,16,,511,5.473099672794340,0
1282,"CPUX86State *cpu_x86_init(void)

{

    CPUX86State *env;

    int i;

    static int inited;



    cpu_x86_tblocks_init();



    env = malloc(sizeof(CPUX86State));

    if (!env)

        return NULL;

    memset(env, 0, sizeof(CPUX86State));

    /* basic FPU init */

    for(i = 0;i < 8; i++)

        env->fptags[i] = 1;

    env->fpuc = 0x37f;

    /* flags setup */

    env->eflags = 0;



    /* init various static tables */

    if (!inited) {

        inited = 1;

        optimize_flags_init();

    }

    return env;

}","pthread_attr_destroy *cpu_x86_init(void)

{

    pthread_attr_destroy *env;

    int i;

    static int inited;



    cpu_x86_tblocks_init();



    env = malloc(sizeof(pthread_attr_destroy));

    if (!env)

        return NULL;

    memset(env, 0, sizeof(pthread_attr_destroy));

    /* basic FPU init */

    for(i = 0;i < 8; i++)

        env->fptags[i] = 1;

    env->fpuc = 0x37f;

    /* flags setup */

    env->eflags = 0;



    /* init various static tables */

    if (!inited) {

        inited = 1;

        optimize_flags_init();

    }

    return env;

}",105,23,"CPUX86State:pthread_attr_destroy,",31,0.3282621463139850,MHM
1283,,,,,,,,0
1284,,,27,6,,511,5.27894002199173,0
1285,,,,,,,,0
1286,,,67,19,,511,5.382368445396420,0
1287,,,,,,,,0
1288,,,,,,,,0
1289,,,130,35,,511,5.622004874547320,0
1290,,,,,,,,0
1291,"static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
","static void ppc_booke_timers_init (DisasContext *tcg_gen_ori_i32, int gprn, int socket_set_nonblock)

{

    if (use_icount) {

        qemu_mutex_init();

    }

    rA(cpu_gpr[gprn], menelaus_reset);

    if (use_icount) {

        gen_io_end();

        tcg_gen_add_i64(tcg_gen_ori_i32);

    }

}",51,14,"gen_helper_load_tbu:rA,gen_io_start:qemu_mutex_init,cpu_env:menelaus_reset,spr_read_tbu:ppc_booke_timers_init,sprn:socket_set_nonblock,gen_stop_exception:tcg_gen_add_i64,ctx:tcg_gen_ori_i32,",481,5.110812087853750,MHM
1292,,,,,,,,0
1293,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}","static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int vs  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, vs, ady, adx, buf);

    } else {

        int CONFIG_SOFTFLOAT  = dy / adx;

        int x     = x0;

        uint8_t qmp_for_each_command = y0;

        int err   = -adx;

        ady -= FFABS(CONFIG_SOFTFLOAT) * adx;

        while (++x < x1) {

            qmp_for_each_command += CONFIG_SOFTFLOAT;

            err += ady;

            if (err >= 0) {

                err -= adx;

                qmp_for_each_command   += vs;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[qmp_for_each_command];

        }

    }

}",170,59,"base:CONFIG_SOFTFLOAT,sy:vs,y:qmp_for_each_command,",91,1.0058594981829300,MHM
1294,,,179,45,,511,6.146556977430980,0
1295,,,,,,,,0
1296,,,89,18,,511,5.433254933357240,0
1297,,,,,,,,0
1298,,,,,,,,0
1299,,,,,,,,0
1300,,,61,12,,511,5.336312079429630,0
1301,,,,,,,,0
1302,,,,,,,,0
1303,,,20,5,,511,5.333191768328350,0
1304,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}","static void QSIMPLEQ_REMOVE(DisasContext *s, TCGv put_uint64)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(put_uint64, cpu_cc_src, 11);

    tcg_gen_andi_tl(put_uint64, put_uint64, 1);

}",36,11,"gen_compute_eflags_o:QSIMPLEQ_REMOVE,reg:put_uint64,",61,0.6262976805369060,MHM
1305,,,,,,,,0
1306,,,,,,,,0
1307,,,,,,,,0
1308,,,88,17,,511,5.4984647870063800,0
1309,,,,,,,,0
1310,,,,,,,,0
1311,,,,,,,,0