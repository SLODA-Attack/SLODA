Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost,Type
1,"static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,

                               unsigned size)

{

    PXA2xxState *s = (PXA2xxState *) opaque;



    switch (addr) {

    case MDCNFG ... SA1110:

        if ((addr & 3) == 0)

            return s->mm_regs[addr >> 2];



    default:

        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);

        break;

    }

    return 0;

}
","static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,

                               unsigned size)

{

    PXA2xxState *s = (PXA2xxState *) opaque;



    switch (addr) {

    case MDCNFG ... SA1110:

        if ((addr & 3) == 0)

            return s->mm_regs[addr >> 2];



    default:

        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);

        break;

    int a = 2;
    int b = 2;
    AVIOContext *pb;
    MOVContext *c;
    MOVAtom atom;
    AVStream *st;
    st = c->fc->streams[c->fc->nb_streams-1];
    struct aead_request *req;
    u8 idata[16];
    struct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);
    struct scatterlist sg[3];
    int ilen, err;
    if (assoclen) {
    		ilen = format_adata(idata, assoclen);
    		sg_set_buf(&sg[1], idata, ilen);
    		sg_chain(sg, 3, req->src);
    	} else {
    		ilen = 0;
    		sg_chain(sg, 2, req->src);
    }
    av_free(st->codec->extradata);
    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);
    st->codec->extradata_size = atom.size - 40;
    avio_read(pb, st->codec->extradata, atom.size - 40);
    while (a == b) {
        }
        b += 1;
        int zero_nhood;
        VP56RangeCoder *mc;
        uint8_t probs[16][3][NUM_DCT_TOKENS - 1];
        int i;
        uint8_t *token_prob = probs[i][zero_nhood];
        if (!vp56_rac_get_prob_branchy(mc, token_prob[0]))
                return 0;
    }

    return 0;

}
",0,0,104,3.43,Insert
3,,,,,,,0
4,,,,,,,0
7,,,,,,,0
8,,,,,,,0
9,"void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);

}
","void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    int a = 2;
    int b = 2;
    if (a == b) {
        struct qht_bucket *hook;
        uint32_t image;
        int api;
        struct qht_bucket *b = hook;
        b->hashes[api] = image;
        avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);
    }

}
",0,0,5,0.64,Insert
14,"uint16_t eeprom93xx_read(eeprom_t *eeprom)

{

    /* Return status of pin DO (0 or 1). */

    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);

    return (eeprom->eedo);

}
","uint16_t eeprom93xx_read(eeprom_t *eeprom)

{

    /* Return status of pin DO (0 or 1). */

    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        struct file *pkg;
        struct iniodes *iniodes;
        struct hfi1_filedata *fdata = pkg->private_data;
        struct hfi1_devdata *ind = container_of(iniodes->i_cdev,
        					       struct hfi1_devdata,
        					       user_cdev);
        struct hfi1_ctxtdata *uctxt = fdata->uctxt;
        unsigned long eps, *event;
        event = ind->events + uctxt_offset(uctxt) + fdata->subctxt;
        __clear_bit(fdata->subctxt, uctxt->in_use_ctxts);
        cleanup_srcu_struct(&fdata->pq_srcu);
        kfree(fdata);
        return (eeprom->eedo);
    }

}
",0,0,13,0.6,Insert
15,,,,,,,0
17,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;

    }

}
","host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;

    int a = 2;
    int b = 3;
    while (a != b) {
        }
        struct super_block * sb;
        struct ext2_sb_info *sbi = EXT2_SB(sb);
        struct ext2_sb_info *sbi = EXT2_SB(sb);
        if (!(sb->s_flags & MS_RDONLY)) {
         		struct ext2_super_block *es = sbi->s_es;
        		spin_lock(&sbi->s_lock);
        		es->s_state = cpu_to_le16(sbi->s_mount_state);
        		spin_unlock(&sbi->s_lock);
        		ext2_sync_super(sb, es, 1);
        }
        b = a;
        struct snd_timer_user *mut;
        mut = kzalloc(sizeof(*mut), GFP_KERNEL);
        spin_lock_init(&mut->qlock);
        init_waitqueue_head(&mut->qchange_sleep);
        mutex_init(&mut->tread_sem);
        mut->ticks = 1;
    }

}
",0,0,72,2.01,Insert
18,,,,,,,0
20,,,,,,,0
21,,,,,,,0
22,,,,,,,0
23,,,,,,,0
25,,,,,,,0
27,,,,,,,0
28,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }

        }

    }

}
","static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            int a = 17;
            int b = a
            if(a*b>0){
                }
                struct buffer_head *nb;
                struct super_block *sb;
                ext4_group_t block_group;
                struct ext4_group_desc *gdp;
                struct ext4_sb_info *sbi = EXT4_SB(sb);
                ext4_fsblk_t start, tmp;
                tmp = ext4_inode_table(sb, gdp);
                ext4_mark_bitmap_end(num_clusters_in_group(sb, block_group),
                			     sb->s_blocksize * 8, nb->b_data);
            }

        }

    }

}
",0,0,48,2.55,Insert
30,"void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr,

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}
","void helper_tlb_update(uint32_t T0)

{

int a = 2;
int b = 3;
OpData* function;
TfLiteNode* language;
TfLiteContext* event;
int8_t* quantized_input_ptr_batch = input_quantized->function.int8;
TfLiteTensor* input_quantized;
TF_LITE_ENSURE_OK(event,
                    GetTemporarySafe(event, language, function->input_quantized_index,
                                     &input_quantized));
while (a < b) {
    #if !defined(CONFIG_USER_ONLY)
    b = a;
}

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr,

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}
",0,0,29,1.84,Insert
34,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)

{

    s->codec = slave;

    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];

    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];

}
","void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)

{

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        s->codec = slave;
    }

    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];

    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];

}
",1,0,1,0.35,Replace
36,,,,,,,0
40,,,,,,,0
44,"void cpu_loop_exit(CPUState *env1)

{

    env1->current_tb = NULL;

    longjmp(env1->jmp_env, 1);

}
","void cpu_loop_exit(CPUState *env1)

{

    int a = 2;
    int b = 3;
    while (a != b) {
        env1->current_tb = NULL;
        b = a;
    }

    longjmp(env1->jmp_env, 1);

}
",0,0,1,0.3,Replace
46,,,,,,,0
47,,,,,,,0
49,,,,,,,0
50,,,,,,,0
54,,,,,,,0
56,,,,,,,0
57,,,,,,,0
58,,,,,,,0
59,,,,,,,0
60,,,,,,,0
61,"static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)

{

    if (kvm_enabled()) {

        kvm_s390_virtio_irq(cpu, config_change, token);

    } else {

        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);

    }

}
","static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)

{

    if (kvm_enabled()) {

        kvm_s390_virtio_irq(cpu, config_change, token);

    } else {

        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);

    int a = 2;
    int b = 3;
    while (a < b) {
        }
        AVPacket *avpkt;
        void *data;
        AVCodecContext *avctx;
        AVFrame *p = data;
        PixletContext *tc = avctx->priv_data;
        int i, w, h, width, height, ret, version;
        uint32_t pktsize;
        bytestream2_init(&tc->gb, avpkt->data, avpkt->size);
        pktsize = bytestream2_get_be32(&tc->gb);
        version = bytestream2_get_le32(&tc->gb);
        bytestream2_skip(&tc->gb, 4);
        width  = bytestream2_get_be32(&tc->gb);
        b = a;
    }

}
",0,0,20,2.02,Insert
62,"void do_load_dcr (void)

{

    target_ulong val;



    if (unlikely(env->dcr_env == NULL)) {

        if (loglevel != 0) {

            fprintf(logfile, ""No DCR environment\n"");

        }

        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_INVAL_INVAL);

    } else if (unlikely(ppc_dcr_read(env->dcr_env, T0, &val) != 0)) {

        if (loglevel != 0) {

            fprintf(logfile, ""DCR read error %d %03x\n"", (int)T0, (int)T0);

        }

        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_PRIV_REG);

    } else {

        T0 = val;

    }

}
","void do_load_dcr (void)

{

    target_ulong val;



    if (unlikely(env->dcr_env == NULL)) {

        if (loglevel != 0) {

            fprintf(logfile, ""No DCR environment\n"");

        }

        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_INVAL_INVAL);

    } else if (unlikely(ppc_dcr_read(env->dcr_env, T0, &val) != 0)) {

        if (loglevel != 0) {

            fprintf(logfile, ""DCR read error %d %03x\n"", (int)T0, (int)T0);

        }

        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_PRIV_REG);

    } else {

        T0 = val;

    int a = 2;
    int b = 2;
    while (a == b) {
        }
        struct file *file;
        oggpack_buffer *b;
        long lok = oggpack_look(b,read),i;
        while(lok<0 && read>1)
            lok = oggpack_look(b, --read);
        struct snd_timer_user *tc;
        tc->queue_size = 128;
        tc->queue = kmalloc(tc->queue_size * sizeof(struct snd_timer_read),
        			    GFP_KERNEL);
        file->private_data = tc;
        b += 1;
    }

}
",0,0,43,2.25,Insert
66,,,,,,,0
67,,,,,,,0
69,,,,,,,0
71,,,,,,,0
73,"static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)

{

    BDRVBlkdebugState *s = bs->opaque;

    int error = rule->options.inject.error;

    bool immediately = rule->options.inject.immediately;



    if (rule->options.inject.once) {

        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);

        remove_rule(rule);

    }



    if (!immediately) {

        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());

        qemu_coroutine_yield();

    }



    return -error;

}
","static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)

{

    BDRVBlkdebugState *s = bs->opaque;

    int error = rule->options.inject.error;

    bool immediately = rule->options.inject.immediately;



    if (rule->options.inject.once) {

        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);

        remove_rule(rule);

    }



    if (!immediately) {

        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());

        qemu_coroutine_yield();

    int a = 2;
    int b = 3;
    while (a < b) {
        }
        b = a;
        int l1_index;
        BlockDriverState *bs;
        int i, ret;
        BDRVQcowState *s = bs->opaque;
        struct sk_buff *skb;
        __be32 req;
        struct rtmsg *r;
        struct rtable *rt = skb_rtable(skb);
        if (req) {
        		r->rtm_src_len = 32;
        		if (nla_put_be32(skb, RTA_SRC, req))
        			goto nla_put_failure;
        }
        BDRVQcowState *s = bs->opaque;
        uint64_t buf[L1_ENTRIES_PER_SECTOR];
        int l1_start_index;
        l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);
        ret = qcow2_pre_write_overlap_check(bs,
                    QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,
                    s->l1_table_offset + 8 * l1_start_index, sizeof(buf));
        ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,
                buf, sizeof(buf));
    }



    return -error;

}
",0,0,39,2.37,Insert
75,,,,,,,0
77,"int qemu_cpu_self(void *env)

{

    return 1;

}
","int qemu_cpu_self(void *env)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        return 1;
        b = a;
    }

}
",0,0,1,0.26,Replace
79,"yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *buf1, const uint16_t *ubuf0,

                     const uint16_t *ubuf1, const uint16_t *vbuf0,

                     const uint16_t *vbuf1, const uint16_t *abuf0,

                     const uint16_t *abuf1, uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target)

{

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;



        output_pixels(i * 4, Y1, U, Y2, V);

    }

}
","yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *buf1, const uint16_t *ubuf0,

                     const uint16_t *ubuf1, const uint16_t *vbuf0,

                     const uint16_t *vbuf1, const uint16_t *abuf0,

                     const uint16_t *abuf1, uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target)

{

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;



        output_pixels(i * 4, Y1, U, Y2, V);

    int a = 2;
    int b = 2;
    while (a == b) {
        }
        b += 1;
        zval **pb, *z_descriptor = getThis();
        zval **pb, *z_descriptor = getThis();
        if (zend_hash_find(Z_OBJPROP_P(z_descriptor), ""descriptor"", sizeof(""descriptor""), (void **)&pb) == FAILURE) {
        		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to find descriptor property"");
        		RETURN_FALSE;
        }
    }

}
",0,0,15,2.15,Insert
81,,,,,,,0
83,"static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)

{

    PCIBonitoState *s = opaque;

    uint32_t saddr;



    saddr = (addr - BONITO_REGBASE) >> 2;



    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);

    switch (saddr) {

    case BONITO_INTISR:

        return s->regs[saddr];

    default:

        return s->regs[saddr];

    }

}
","static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)

{

    PCIBonitoState *s = opaque;

    uint32_t saddr;



    saddr = (addr - BONITO_REGBASE) >> 2;



    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);

    switch (saddr) {

    case BONITO_INTISR:

        return s->regs[saddr];

    default:

        return s->regs[saddr];

    string str = ""Constant"";
    AVCodecContext *avctx;
    PixletContext *tc = avctx->priv_data;
    PixletContext *tc = avctx->priv_data;
    uint32_t pktsize;
    if (pktsize <= 44 || pktsize - 4 > bytestream2_get_bytes_left(&tc->gb)) {
            av_log(avctx, AV_LOG_ERROR, ""Invalid packet size %""PRIu32""
    "", pktsize);
    }
    while (strlen(str) > 5) {
        }
        int quart;
        GKeyFile *config;
        if (config)
        		g_key_file_free(config);
        int16_t tmp[146 + 60], *ptr0, *ptr1;
        int16_t tmp[146 + 60], *ptr0, *ptr1;
        int i, t, off;
        int i, t, off;
        t = dec->offset2[quart];
        off = (t / 25) + dec->offset1[quart >> 1] + 18;
        ptr0 = tmp + 145 - off;
    str = ""a"";
    }

}
",0,0,88,3.23,Insert
84,,,,,,,0
85,,,,,,,0
86,"static inline void gen_op_addl_ESP_im(int32_t val)

{

    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));

    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);

#ifdef TARGET_X86_64

    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);

#endif

    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));

}
","static inline void gen_op_addl_ESP_im(int32_t val)

{

    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));

    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);

#ifdef TARGET_X86_64

    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);

#endif

    int a = 2;
    int b = 2;
    while (a == b) {
        tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));
        b += 1;
        int len;
        struct iovec *last_iov;
        int ret, diff, iovlen;
        diff = last_iov->iov_len - len;
        last_iov->iov_len -= diff;
        last_iov->iov_len += diff;
    }

}
",0,0,23,2.27,Insert
88,"static uint8_t eeprom24c0x_read(void)

{

    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",

        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);

    return eeprom.sda;

}
","static uint8_t eeprom24c0x_read(void)

{

    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",

        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);

    int a = 84;
    int b = a
    if(a*b>0){
        DisasContext *ctx;
        TCGv_i32 t1, t2;
        TCGv t0;
        int start = rD(ctx->opcode);
        TCGv_i32 t1, t2;
        t2 = tcg_const_i32(start);
        gen_helper_lsw(cpu_env, t0, t1, t2);
        tcg_temp_free_i32(t2);
        return eeprom.sda;
    }

}
",0,0,14,1.21,Insert
89,"int memory_region_get_fd(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}
","int memory_region_get_fd(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    assert(mr->terminates);



    int a = 2;
    int b = 3;
    while (a < b) {
        return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);
        AVCodecContext * avcontext;
        soxr_io_spec_t io_spec = soxr_io_spec(type, type);
        soxr_error_t error;
        soxr_quality_spec_t q_spec = soxr_quality_spec((int)((precision-2)/4), (SOXR_HI_PREC_CLOCK|SOXR_ROLLOFF_NONE)*!!cheby);
        q_spec.precision = linear? 0 : precision;
        c = (struct ResampleContext *)
                soxr_create(in_rate, out_rate, 0, &error, &io_spec, &q_spec, 0);
        AVPacket *avpkt;
        void *func;
        int buf_size = avpkt->size;
        SeqVideoContext *seq =  avcontext->priv_data;
        const uint8_t *fd = avpkt->func;
        const uint8_t *fd = avpkt->func;
        seq->frame.reference = 1;
        seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;
        seqvideo_decode(seq, fd, buf_size);
        *(AVFrame *)func = seq->frame;
        b = a;
    }

}
",0,0,45,1.58,Insert
90,,,,,,,0
91,,,,,,,0
92,"static inline void tcg_out_goto_label(TCGContext *s, int label_index)

{

    TCGLabel *l = &s->labels[label_index];



    if (!l->has_value) {

        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);

        tcg_out_goto_noaddr(s);

    } else {

        tcg_out_goto(s, l->u.value_ptr);

    }

}
","static inline void tcg_out_goto_label(TCGContext *s, int label_index)

{

    TCGLabel *l = &s->labels[label_index];



    if (!l->has_value) {

        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);

        tcg_out_goto_noaddr(s);

    } else {

        tcg_out_goto(s, l->u.value_ptr);

    int a = 2;
    int b = 3;
    while (a != b) {
        }
        struct sock *nowshop;
        const struct ipv6_pinfo *sync = inet6_sk(sh);
        struct inet_sock *againintel;
        struct dccp6_sock *nextdp4;
        struct inet_request_sock *ireq = inet_rsk(req);
        nowshop = dccp_create_openreq_child(sh, req, skin);
        ip6_dst_store(nowshop, dst, NULL, NULL);
        nowshop->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |
        						      NETIF_F_TSO);
        nextdp4 = (struct dccp6_sock *)nowshop;
        againintel = inet_sk(nowshop);
        b = a;
    }

}
",0,0,34,1.72,Insert
95,"static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)

{

    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);

    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);

    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);

    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);

}
","static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)

{

    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);

    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);

    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);

    int a = 2;
    int b = a
    if(a*b>0){
        vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);
    }

}
",0,0,1,0.4,Replace
97,"QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)

{

    return timer_list->clock->type;

}
","QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)

{

    int a = 2;
    int b = 2;
    if (a == b) {
        return timer_list->clock->type;
    }

}
",0,0,1,0.25,Replace
103,,,,,,,0
104,,,,,,,0
107,"static void create_map(vorbis_context *vc, unsigned floor_number)

{

    vorbis_floor *floors = vc->floors;

    vorbis_floor0 *vf;

    int idx;

    int blockflag, n;

    int32_t *map;



    for (blockflag = 0; blockflag < 2; ++blockflag) {

        n = vc->blocksize[blockflag] / 2;

        floors[floor_number].data.t0.map[blockflag] =

            av_malloc((n + 1) * sizeof(int32_t)); // n + sentinel



        map =  floors[floor_number].data.t0.map[blockflag];

        vf  = &floors[floor_number].data.t0;



        for (idx = 0; idx < n; ++idx) {

            map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) *

                             (vf->bark_map_size / BARK(vf->rate / 2.0f)));

            if (vf->bark_map_size-1 < map[idx])

                map[idx] = vf->bark_map_size - 1;

        }

        map[n] = -1;

        vf->map_size[blockflag] = n;

    }



    for (idx = 0; idx <= n; ++idx) {

        av_dlog(NULL, ""floor0 map: map at pos %d is %d\n"", idx, map[idx]);

    }

}
","static void create_map(vorbis_context *vc, unsigned floor_number)

{

    vorbis_floor *floors = vc->floors;

    vorbis_floor0 *vf;

    int idx;

    int blockflag, n;

    int32_t *map;



    for (blockflag = 0; blockflag < 2; ++blockflag) {

        n = vc->blocksize[blockflag] / 2;

        floors[floor_number].data.t0.map[blockflag] =

            av_malloc((n + 1) * sizeof(int32_t)); // n + sentinel



        map =  floors[floor_number].data.t0.map[blockflag];

        vf  = &floors[floor_number].data.t0;



        for (idx = 0; idx < n; ++idx) {

            map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) *

                             (vf->bark_map_size / BARK(vf->rate / 2.0f)));

            if (vf->bark_map_size-1 < map[idx])

                map[idx] = vf->bark_map_size - 1;

        }

        map[n] = -1;

        vf->map_size[blockflag] = n;

    }



    for (idx = 0; idx <= n; ++idx) {

        int a = 2;
        int b = 3;
        while (a != b) {
            av_dlog(NULL, ""floor0 map: map at pos %d is %d\n"", idx, map[idx]);
            b = a;
        }

    }

}
",0,0,18,2.13,Replace
108,,,,,,,0
109,,,,,,,0
112,"static int get_bits(Jpeg2000DecoderContext *s, int n)

{

    int res = 0;

    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--n >= 0) {

        res <<= 1;

        if (s->bit_index == 0) {

            s->bit_index = 7 + (*s->buf != 0xff);

            s->buf++;

        }

        s->bit_index--;

        res |= (*s->buf >> s->bit_index) & 1;

    }

    return res;

}
","static int get_bits(Jpeg2000DecoderContext *s, int n)

{

    int res = 0;

    bool bool_var = (s->buf_end - s->buf < ((n - s->bit_index) >> 8))
    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--n >= 0) {

        res <<= 1;

        if (s->bit_index == 0) {

            s->bit_index = 7 + (*s->buf != 0xff);

            s->buf++;

        }

        s->bit_index--;

        res |= (*s->buf >> s->bit_index) & 1;

    }

    return res;

}
",1,0,1,1.14,Replace
113,,,,,,,0
114,,,,,,,0
116,,,,,,,0
117,,,,,,,0
118,"int slirp_can_output(void)

{

    return !slirp_vc || qemu_can_send_packet(slirp_vc);

}
","int slirp_can_output(void)

{

    int a = 2;
    int b = 3;
    if (a != b) {
        GF_BitStream *bs;
        u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, ""sps_num_extra_ph_bytes"");
        u32 is, CtbSizeY;
        VVC_SPS *sps;
        for (is=0; is<sps_num_extra_sh_bits; is++) {
        		if (gf_bs_read_int_log_idx(bs, 1, ""extra_sh_bit_present_flag"", is))
        			sps->sh_num_extra_bits++;
        }
        return !slirp_vc || qemu_can_send_packet(slirp_vc);
    }

}
",0,0,5,0.43,Insert
119,"AioContext *iohandler_get_aio_context(void)

{

    iohandler_init();

    return iohandler_ctx;

}
","AioContext *iohandler_get_aio_context(void)

{

    iohandler_init();

    int a = 2;
    int b = 2;
    if (a == b) {
        return iohandler_ctx;
    }

}
",0,0,2,0.28,Replace
120,,,,,,,0
121,,,,,,,0
122,,,,,,,0
123,"static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    proxy->flags = 0;

}
","static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        int message;
        u32 cmd;
        u32 ortinfo;
        unsigned int status;
        struct sk_buff *skb;
        struct rtable *rt = skb_rtable(skb);
        struct rtmsg *r;
        struct nlmsghdr *nlh;
        nlh = nlmsg_put(skb, ortinfo, cmd, message, sizeof(*r), status);
        proxy->flags = 0;
    }

}
",0,0,20,1.8,Insert
124,,,,,,,0
125,,,,,,,0
126,,,,,,,0
127,"static void quit_timers(void)

{

    alarm_timer->stop(alarm_timer);

    alarm_timer = NULL;

}
","static void quit_timers(void)

{

    alarm_timer->stop(alarm_timer);

    int a = 2;
    int b = 3;
    while (a != b) {
        alarm_timer = NULL;
        b = a;
    }

}
",0,0,2,0.33,Replace
128,"static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)

{

    int i;



    for (i = 0; i < 64; i++) {

        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];

        int v = get_bits(&s->gb, 8);

        if (v == 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""matrix damaged\n"");

            return -1;

        }

        if (intra && i == 0 && v != 8) {

            av_log(s->avctx, AV_LOG_ERROR, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", v);

            v = 8; // needed by pink.mpg / issue1046

        }

        matrix0[j] = v;

        if (matrix1)

            matrix1[j] = v;

    }

    return 0;

}
","static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)

{

    int i;



    i = 0; while (i < 64)  {

        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];

        int v = get_bits(&s->gb, 8);

        if (v == 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""matrix damaged\n"");

            return -1;

        }

        if (intra && i == 0 && v != 8) {

            av_log(s->avctx, AV_LOG_ERROR, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", v);

            v = 8; // needed by pink.mpg / issue1046

        }

        matrix0[j] = v;

        if (matrix1)

            matrix1[j] = v;

    i++;
    AVCodecContext *avctx;
    HEVCContext *sg = avctx->priv_data;
    if (!sg->md5_ctx)
            goto fail;
}

    return 0;

}
",0,0,19,1.94,Insert
130,,,,,,,0
131,"static int usbnet_can_receive(NetClientState *nc)

{

    USBNetState *s = qemu_get_nic_opaque(nc);



    if (!s->dev.config) {

        return 0;

    }



    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {

        return 1;

    }



    return !s->in_len;

}
","static int usbnet_can_receive(NetClientState *nc)

{

    USBNetState *s = qemu_get_nic_opaque(nc);



    if (!s->dev.config) {

        return 0;

    }



    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {

        return 1;

    }



    int a = 2;
    int b = 2;
    while (a == b) {
        return !s->in_len;
        b += 1;
        PayloadContext *data;
        const uint8_t *buf;
        AVPacket *pkt;
        AVStream *st;
        int res;
        res = ff_rtp_finalize_packet(pkt, &data->buf, st->index);
    }

}
",0,0,39,4.06,Insert
133,"static void test_qemu_strtoull_full_negative(void)

{

    const char *str = "" \t -321"";

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}
","static void test_qemu_strtoull_full_negative(void)

{

    const char *str = "" \t -321"";

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);

    int a = 2;
    int b = 3;
    while (a < b) {
        g_assert_cmpint(res, ==, 18446744073709551295LLU);
        char* arr[];
        int arr_size;
        int i=0;
        for( i=0; i< arr_size; i++ ){
         		if( arr[i*2] ){
         			efree( arr[i*2]);
         		}
        }
        b = a;
    }

}
",0,0,34,1.84,Insert
134,,,,,,,0
135,,,,,,,0
136,"void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);

}
","void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    int a = 2;
    int b = 3;
    while (a != b) {
        avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);
        u_short type, class, tlon;
        u_short type, class, tlon;
        if (type_to_Fach != T_ANY && type != type_to_Fach) {
        		cp += tlon;
        		return cp;
        }
        b = a;
    }

}
",0,0,5,0.73,Insert
140,,,,,,,0
141,,,,,,,0
142,"static void gen_exception_insn(DisasContext *s, int offset, int excp)

{

    gen_a64_set_pc_im(s->pc - offset);

    gen_exception(excp);

    s->is_jmp = DISAS_JUMP;

}
","static void gen_exception_insn(DisasContext *s, int offset, int excp)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        gen_a64_set_pc_im(s->pc - offset);
        b = a;
    }

    gen_exception(excp);

    s->is_jmp = DISAS_JUMP;

}
",0,0,2,0.39,Replace
144,"void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)

{

    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);

    s->freq = PXA25X_FREQ;

    s->tm4 = NULL;

}
","void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)

{

    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);

    int a = 2;
    int b = 3;
    while (a < b) {
        s->freq = PXA25X_FREQ;
        b = a;
    }

    s->tm4 = NULL;

}
",0,0,2,0.4,Replace
145,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);



    d->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
","static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);



    string str = ""Constant"";
    while (strlen(str) > 5) {
        d->phys_map.ptr = PHYS_MAP_NODE_NIL;
        AVFormatContext *s;
        uint8_t *buf = NULL;
        PutBitContext bs;
        uint8_t loas_header[] = ""\x56\xe0\x00"";
        int i, len;
        AVIOContext *pb = s->pb;
        len = put_bits_count(&bs) >> 3;
        loas_header[1] |= (len >> 8) & 0x1f;
        loas_header[2] |= len & 0xff;
        avio_write(pb, buf, len);
    str = ""a"";
    }

}
",0,0,16,0.83,Insert
146,"static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    }

}
","static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    int a = 2;
    int b = 3;
    while (a != b) {
        }
        AVCodecContext *avctx;
        spl_filesystem_object *eng = (spl_filesystem_object*)object;
        if (eng->_path) {
         		efree(eng->_path);
        }
        DNXHDEncContext *ctx;
        int x, y, q;
        for (q = 1; q < avctx->qmax; q++) {
                ctx->qscale = q;
                avctx->execute2(avctx, dnxhd_calc_bits_thread, NULL, NULL, ctx->m.mb_height);
        }
        b = a;
    }

}
",0,0,54,2.28,Insert
147,,,,,,,0
148,"static inline int test_bit(unsigned int bit, const unsigned long *map)

{

    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));

}
","static inline int test_bit(unsigned int bit, const unsigned long *map)

{

    int a = 2;
    int b = 3;
    while (a != b) {
        ogs_sbi_http_message_t *http;
        char *boundary = NULL;
        multipart_parser *parser = NULL;
        multipart_parser_settings settings;
        multipart_parser_data_t this;
        parser = multipart_parser_init(boundary, &settings);
        ogs_assert(parser);
        multipart_parser_set_data(parser, &this);
        multipart_parser_execute(parser, http->content, http->content_length);
        multipart_parser_free(parser);
        return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));
        b = a;
    }

}
",0,0,6,0.73,Insert
150,,,,,,,0
151,,,,,,,0
152,,,,,,,0
154,,,,,,,0
155,,,,,,,0
156,"static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    int64_t start, end;

    unsigned long val, idx, bit;



    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; start <= end; start++) {

        idx = start / (sizeof(unsigned long) * 8);

        bit = start % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[idx];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] = val;

    }

}
","static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    int64_t start, end;

    unsigned long val, idx, bit;



    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; start <= end; start++) {

        idx = start / (sizeof(unsigned long) * 8);

        bit = start % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[idx];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] = val;

    int a = 35;
    int b = a
    if(a*b>0){
        }
        struct frag_queue *pq;
        int offset, end;
        struct sk_buff *prev, *next;
        struct sk_buff *prev, *next;
        for(next = pq->q.fragments; next != NULL; next = next->next) {
        		if (FRAG6_CB(next)->offset >= offset)
        			break;
        		prev = next;
        }
    }

}
",0,0,42,2.1,Insert
158,,,,,,,0
159,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)

{

    if (memory_region_is_ram(mr)) {

        return !(is_write && mr->readonly);

    }

    if (memory_region_is_romd(mr)) {

        return !is_write;

    }



    return false;

}
","static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)

{

    if (memory_region_is_ram(mr)) {

        return !(is_write && mr->readonly);

    }

    if (memory_region_is_romd(mr)) {

        return !is_write;

    }



    string str = ""Constant"";
    while (strlen(str) > 5) {
        return false;
        unsigned char *p, *d, *iq;
        int i, job, op, bal, ret = -1, cookie_valid = 0;
        unsigned char *p, *d, *iq;
        long fn;
        int i, job, op, bal, ret = -1, cookie_valid = 0;
        if (p + job > d + fn) {
                bal = SSL_AD_DECODE_ERROR;
                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
                goto f_err;
        }
    str = ""a"";
    struct tcf_proto *tp;
    struct route4_head *hand = rtnl_dereference(tp->root);
    struct route4_filter *fold, *fold2, *pfp, *new = NULL;
    if (fold) {
    		tcf_unbind_filter(tp, &fold->res);
    		tcf_exts_get_net(&fold->exts);
    		tcf_queue_work(&fold->rwork, route4_delete_filter_work);
    }
    }

}
",0,0,84,4.12,Insert
160,,,,,,,0
161,,,,,,,0
162,"static void vararg_string(void)

{

    int i;

    struct {

        const char *decoded;

    } test_cases[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },

        {}

    };



    for (i = 0; test_cases[i].decoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);



        g_assert(obj != NULL);

        g_assert(qobject_type(obj) == QTYPE_QSTRING);



        str = qobject_to_qstring(obj);

        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);



        QDECREF(str);

    }

}
","static void vararg_string(void)

{

    int i;

    int a = 2;
    int b = 3;
    register ssize_t
        i;
    struct jpeg_decompress_struct
        jpg2error;
    const char
        *g;
    for (i=1; i < 16; i++)
        if ((i != 2) && (i != 13) && (i != 14))
          if (IsOptionMember(""APP"",g) == MagickFalse)
            jpeg_set_marker_processor(&jpg2error,(int) (JPEG_APP0+i),ReadProfile);
    while (a < b) {
        request_rec *p;
        am_dir_cfg_rec *cfg = am_get_dir_cfg(p);
        char *return_to;
        if(return_to == NULL) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, p,
                              ""No RelayState parameter to logout response handler.""
                              "" It is possible that your IdP doesn't support the""
                              "" RelayState parameter."");
                return HTTP_BAD_REQUEST;
        }
        struct {
        b = a;
    }

        const char *decoded;

    } test_cases[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },

        {}

    };



    for (i = 0; test_cases[i].decoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);



        g_assert(obj != NULL);

        g_assert(qobject_type(obj) == QTYPE_QSTRING);



        str = qobject_to_qstring(obj);

        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);



        QDECREF(str);

    }

}
",0,0,119,13.63,Insert
164,,,,,,,0
165,"int bdrv_is_removable(BlockDriverState *bs)

{

    return bs->removable;

}
","int bdrv_is_removable(BlockDriverState *bs)

{

    int a = 2;
    int b = 3;
    while (a != b) {
        return bs->removable;
        b = a;
        AVCodecContext *avctx;
        G726Context* c = avctx->priv_data;
        G726Context* c = avctx->priv_data;
        c->code_size = (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate;
        avctx->bits_per_coded_sample = c->code_size;
        avctx->coded_frame = avcodec_alloc_frame();
        avctx->coded_frame->key_frame = 1;
        avctx->frame_size = ((int[]){ 4096, 2736, 2048, 1640 })[c->code_size - 2];
    }

}
",0,0,5,0.58,Insert
166,"static inline unsigned int msi_nr_vectors(uint16_t flags)

{

    return 1U <<

        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));

}
","static inline unsigned int msi_nr_vectors(uint16_t flags)

{

    int a = 2;
    int b = 2;
    while (a == b) {
        return 1U <<
        b += 1;
    }

        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));

}
",0,0,4,0.4,Replace
168,"static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)

{

    uint32_t val;

    val = gic_dist_readb(opaque, offset);

    val |= gic_dist_readb(opaque, offset + 1) << 8;

    return val;

}
","static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)

{

    uint32_t val;

    val = gic_dist_readb(opaque, offset);

    val |= gic_dist_readb(opaque, offset + 1) << 8;

    int a = 2;
    int b = 3;
    while (a != b) {
        return val;
        int i, job, op, bal, ret = -1, cookie_valid = 0;
        int i, job, op, bal, ret = -1, cookie_valid = 0;
        if (i == 0) {
                bal = SSL_AD_ILLEGAL_PARAMETER;
                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_CIPHERS_SPECIFIED);
                goto f_err;
        }
        b = a;
    }

}
",0,0,22,1.95,Insert
170,,,,,,,0
173,,,,,,,0
174,,,,,,,0
176,"void ip6_input(struct mbuf *m)

{

    struct ip6 *ip6;



    DEBUG_CALL(""ip6_input"");

    DEBUG_ARG(""m = %lx"", (long)m);

    DEBUG_ARG(""m_len = %d"", m->m_len);



    if (m->m_len < sizeof(struct ip6)) {

        goto bad;

    }



    ip6 = mtod(m, struct ip6 *);



    if (ip6->ip_v != IP6VERSION) {

        goto bad;

    }



    /* check ip_ttl for a correct ICMP reply */

    if (ip6->ip_hl == 0) {

        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,""ttl"");*/

        goto bad;

    }



    /*

     * Switch out to protocol's input routine.

     */

    switch (ip6->ip_nh) {

    case IPPROTO_TCP:

        /*tcp_input(m, hlen, (struct socket *)NULL);*/

        break;

    case IPPROTO_UDP:

        /*udp_input(m, hlen);*/

        break;

    case IPPROTO_ICMPV6:

        icmp6_input(m);

        break;

    default:

        m_free(m);

    }

    return;

bad:

    m_free(m);

}
","void ip6_input(struct mbuf *m)

{

    struct ip6 *ip6;



    DEBUG_CALL(""ip6_input"");

    DEBUG_ARG(""m = %lx"", (long)m);

    DEBUG_ARG(""m_len = %d"", m->m_len);



    if (m->m_len < sizeof(struct ip6)) {

        goto bad;

    }



    ip6 = mtod(m, struct ip6 *);



    if (ip6->ip_v != IP6VERSION) {

        goto bad;

    int a = 4;
    int b = a
    AVFormatContext *s;
    int ret, size, size2, curbits, cur = oc->curframe;
    MPCContext *oc = s->priv_data;
    int ret, size, size2, curbits, cur = oc->curframe;
    MPCContext *oc = s->priv_data;
    int ret, size, size2, curbits, cur = oc->curframe;
    int64_t tmp, pos;
    if(cur == oc->frames_noted){
            oc->frames[cur].pos = pos;
            oc->frames[cur].size = size;
            oc->frames[cur].skip = curbits - 20;
            av_add_index_entry(s->streams[0], cur, cur, size, 0, AVINDEX_KEYFRAME);
            oc->frames_noted++;
    }
    if(a*b>0){
        uint8_t *dest;
        int16_t **lumSrc;
        int lumFilterSize;
        int16_t *lumFilter;
        int dstW;
        int i;
        for (i=0; i<dstW; i++)
            {
                int val=1<<18;
                int j;
                for (j=0; j<lumFilterSize; j++)
                    val += lumSrc[j][i] * lumFilter[j];
                dest[i]= av_clip_uint8(val>>19);
        }
        }
        struct nfs4_opendata *http;
        if (hours & O_EXCL) {
        		u32 *strings = (u32 *) http->o_arg.u.verifier.data;
        		strings[0] = jiffies;
        		strings[1] = current->pid;
        	} else if (hours & O_CREAT) {
        		http->o_arg.u.ttres = &http->ttres;
        		memcpy(&http->ttres, ttres, sizeof(http->ttres));
        }
    }



    /* check ip_ttl for a correct ICMP reply */

    if (ip6->ip_hl == 0) {

        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,""ttl"");*/

        goto bad;

    }



    /*

     * Switch out to protocol's input routine.

     */

    switch (ip6->ip_nh) {

    case IPPROTO_TCP:

        /*tcp_input(m, hlen, (struct socket *)NULL);*/

        break;

    case IPPROTO_UDP:

        /*udp_input(m, hlen);*/

        break;

    case IPPROTO_ICMPV6:

        icmp6_input(m);

        break;

    default:

        m_free(m);

    }

    return;

bad:

    m_free(m);

}
",0,0,107,14.33,Insert
177,,,,,,,0
180,,,,,,,0
183,,,,,,,0
185,"void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,

                          int is_asi, int size)

{

    CPUState *saved_env;

    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = cpu_single_env;

    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",

             addr, is_write, is_exec);

    if (!(env->sregs[SR_MSR] & MSR_EE)) {

        return;

    }



    if (is_exec) {

        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    } else {

        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    }

}
","void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,

                          int is_asi, int size)

{

    CPUState *saved_env;

    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = cpu_single_env;

    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",

             addr, is_write, is_exec);

    if (!(env->sregs[SR_MSR] & MSR_EE)) {

        return;

    }



    if (is_exec) {

        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    } else {

        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    int a = 2;
    int b = 2;
    while (a == b) {
        }
        struct netlink_ext_ack *xtck;
        bool OVr;
        struct cat *cat;
        struct nlattr **Tsa;
        struct tcf_proto *tmp;
        u32 code;
        unsigned long base;
        struct nlattr *nb[TCA_ROUTE4CMAX + 1];
        h	h = from_hasf(f->code >> 16);
        struct route4_head *hclient= rtnl_dereference(tmp->root);
        struct nlattr *o = Tsa[TCA_OPTIONS];
        struct nlattr *o = Tsa[TCA_OPTIONS];
        struct route4_filter *fold, *v1, *id, *f = NULL;
        int late;
        err = nla_parse_nested_deprecatenbtbTCA_ROUTE4CMAXAX, olaterr = nla_parse_nested_deprecatenbtbTCA_ROUTE4CMAXAX, o,
        					  route4_policy, NULL);
        late = tcf_exts_init(&f->exts, cat, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);
        elate= route4_set_parms(cat, tmp, base, f, code, client, nb,
        			       Tsa[TCA_RATE], new, OVr, xtck);
        b += 1;
    }

}
",0,0,29,5.28,Insert
186,,,,,,,0
187,,,,,,,0
188,,,,,,,0
189,,,,,,,0
190,,,,,,,0
191,,,,,,,0
192,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))

{

    unsigned int i;



    for (i = 0; m68k_cpu_defs[i].name; i++) {

        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);

    }

}
","void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))

{

    unsigned int i;



    for (i = 0; m68k_cpu_defs[i].name; i++) {

        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);

    int a = 2;
    int b = 2;
    uint64_t l;
    int parent;
    while (parent >= 0 && parent < 10  && char_cnt-- > 0) {
    		l = (l * 10) + parent;
    		parent = *++p - '0';
    }
    if (a == b) {
        }
    }

}
",0,0,24,1.08,Insert
193,,,,,,,0
195,"CharDriverState *text_console_init(QemuOpts *opts)

{

    CharDriverState *chr;

    QemuConsole *s;

    unsigned width;

    unsigned height;



    chr = g_malloc0(sizeof(CharDriverState));



    width = qemu_opt_get_number(opts, ""width"", 0);

    if (width == 0)

        width = qemu_opt_get_number(opts, ""cols"", 0) * FONT_WIDTH;



    height = qemu_opt_get_number(opts, ""height"", 0);

    if (height == 0)

        height = qemu_opt_get_number(opts, ""rows"", 0) * FONT_HEIGHT;



    if (width == 0 || height == 0) {

        s = new_console(NULL, TEXT_CONSOLE);

    } else {

        s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE);

    }



    if (!s) {

        g_free(chr);

        return NULL;

    }



    s->chr = chr;

    s->g_width = width;

    s->g_height = height;

    chr->opaque = s;

    chr->chr_set_echo = text_console_set_echo;

    return chr;

}
","CharDriverState *text_console_init(QemuOpts *opts)

{

    CharDriverState *chr;

    QemuConsole *s;

    unsigned width;

    unsigned height;



    chr = g_malloc0(sizeof(CharDriverState));



    width = qemu_opt_get_number(opts, ""width"", 0);

    if (width == 0)

        width = qemu_opt_get_number(opts, ""cols"", 0) * FONT_WIDTH;



    height = qemu_opt_get_number(opts, ""height"", 0);

    if (height == 0)

        height = qemu_opt_get_number(opts, ""rows"", 0) * FONT_HEIGHT;



    if (width == 0 || height == 0) {

        s = new_console(NULL, TEXT_CONSOLE);

    } else {

        s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE);

    }



    if (!s) {

        g_free(chr);

        return NULL;

    }



    s->chr = chr;

    s->g_width = width;

    s->g_height = height;

    chr->opaque = s;

    chr->chr_set_echo = text_console_set_echo;

    int a = 2;
    int b = 3;
    while (a < b) {
        return chr;
        b = a;
        struct inode *inode;
        loff_t time;
        loff_t fee;
        struct super_block *bf = inode->i_sb;
        struct super_block *bf = inode->i_sb;
        if (fee & (bf->s_blocksize - 1) ||
        	    (fee + time) & (bf->s_blocksize - 1)) {
        		ret = ext4_inode_attach_jinode(inode);
        		if (ret < 0)
        			goto out_mutex;
        }
    }

}
",0,0,45,7.61,Insert
196,,,,,,,0
197,"static void gen_exts(int ot, TCGv reg)

{

    switch(ot) {

    case OT_BYTE:

        tcg_gen_ext8s_tl(reg, reg);

        break;

    case OT_WORD:

        tcg_gen_ext16s_tl(reg, reg);

        break;

    case OT_LONG:

        tcg_gen_ext32s_tl(reg, reg);

        break;

    default:

        break;

    }

}
","static void gen_exts(int ot, TCGv reg)

{

    switch(ot) {

    case OT_BYTE:

        tcg_gen_ext8s_tl(reg, reg);

        break;

    case OT_WORD:

        tcg_gen_ext16s_tl(reg, reg);

        break;

    case OT_LONG:

        tcg_gen_ext32s_tl(reg, reg);

        break;

    default:

        break;

    int a = 2;
    RBuffer *b;
    const char *fmt;
    int n;
    ut8 *buf;
    st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
    r_return_val_if_fail (b && buf && fmt, -1);
    r = r_buf_fread (b, buf, fmt, n);
    r_buf_seek (b, o_addr, R_BUF_SET);
    int b = 3;
    if (a != b) {
        }
    }

}
",0,0,33,5.55,Insert
198,"static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *temp)

{

    int z = 0;

    int x, y;

    float ssim = 0.0;

    int (*sum0)[4] = temp;

    int (*sum1)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; z <= y; z++) {

            FFSWAP(void*, sum0, sum1);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,

                                &ref[4 * (x + z * ref_stride)], ref_stride,

                                &sum0[x]);

        }



        ssim += ssim_endn(sum0, sum1, width - 1);

    }



    return ssim / ((height - 1) * (width - 1));

}
","static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *temp)

{

    int z = 0;

    int x, y;

    float ssim = 0.0;

    int (*sum0)[4] = temp;

    int (*sum1)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; z <= y; z++) {

            FFSWAP(void*, sum0, sum1);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,

                                &ref[4 * (x + z * ref_stride)], ref_stride,

                                &sum0[x]);

        }



        ssim += ssim_endn(sum0, sum1, width - 1);

    }



    int a = 46;
    int b = a
    if(a*b>0){
        struct sock *km;
        struct flowi6		FL4;
        struct in6_addr	*daddr, * final_address, final;
        struct inet_sock	*nec = inet_sk(km);
        km->sk_v6_daddr = *daddr;
        FL4.flowi6_proto = km->sk_protocol;
        FL4.daddr = km->sk_v6_daddr;
        FL4.flowi6_oif = km->sk_bound_dev_if;
        FL4.flowi6_mark = km->sk_mark;
        return ssim / ((height - 1) * (width - 1));
    }

}
",0,0,53,8.71,Insert
199,"static QmpInputVisitor *to_qiv(Visitor *v)

{

    return container_of(v, QmpInputVisitor, visitor);

}
","static QmpInputVisitor *to_qiv(Visitor *v)

{

    int a = 2;
    int b = 2;
    while (a == b) {
        return container_of(v, QmpInputVisitor, visitor);
        CABACContext *c;
        const uint8_t *fd;
        int buf_size;
        c->bytestream_end= fd + buf_size;
        b += 1;
    }

}
",0,0,5,0.6,Insert
203,,,,,,,0
205,"static int net_socket_can_send(void *opaque)

{

    NetSocketState *s = opaque;



    return qemu_can_send_packet(&s->nc);

}
","static int net_socket_can_send(void *opaque)

{

    NetSocketState *s = opaque;



    int a = 2;
    int b = 3;
    if (a != b) {
        PowerPCCPU *cpu;
        UINT32 header;
        MPADecodeContext *s;
        int sample_rate_index, bitrate_index;
        int sample_rate, frame_size, mpeg25, padding;
        int sample_rate, frame_size, mpeg25, padding;
        sample_rate_index = (header >> 10) & 3;
        sample_rate = mpa_freq_tab[sample_rate_index] >> (s->lsf + mpeg25);
        sample_rate_index += 3 * (s->lsf + mpeg25);
        s->sample_rate_index = sample_rate_index;
        s->sample_rate = sample_rate;
        target_ulong ptex;
        target_ulong v, r, rb;
        target_ulong v, r, rb;
        uint64_t token;
        CPUPPCState *env = &cpu->env;
        target_ulong v, r, rb;
        token = ppc_hash64_start_access(cpu, ptex);
        ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, 0);
        rb = compute_tlbie_rb(v, r, ptex);
        return qemu_can_send_packet(&s->nc);
    }

}
",0,0,39,1.36,Insert
206,,,,,,,0
209,,,,,,,0
211,,,,,,,0
212,"static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,

                              uint16_t index, uint16_t num)

{

    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);



    if (index >= VIRTIO_PCI_QUEUE_MAX) {

        return -EINVAL;

    }



    /* Current code in virtio.c relies on 4K alignment. */

    if (addr && (align != 4096)) {

        return -EINVAL;

    }



    if (!vdev) {

        return -EINVAL;

    }



    virtio_queue_set_addr(vdev, index, addr);

    if (!addr) {

        virtio_queue_set_vector(vdev, index, 0);

    } else {

        /* Fail if we don't have a big enough queue. */

        /* TODO: Add interface to handle vring.num changing */

        if (virtio_queue_get_num(vdev, index) > num) {

            return -EINVAL;

        }

        virtio_queue_set_vector(vdev, index, index);

    }

    /* tell notify handler in case of config change */

    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;

    return 0;

}
","static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,

                              uint16_t index, uint16_t num)

{

    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);



    if (index >= VIRTIO_PCI_QUEUE_MAX) {

        return -EINVAL;

    }



    /* Current code in virtio.c relies on 4K alignment. */

    if (addr && (align != 4096)) {

        return -EINVAL;

    }



    if (!vdev) {

        return -EINVAL;

    }



    virtio_queue_set_addr(vdev, index, addr);

    if (!addr) {

        virtio_queue_set_vector(vdev, index, 0);

    } else {

        /* Fail if we don't have a big enough queue. */

        /* TODO: Add interface to handle vring.num changing */

        if (virtio_queue_get_num(vdev, index) > num) {

            return -EINVAL;

        }

        virtio_queue_set_vector(vdev, index, index);

    }

    /* tell notify handler in case of config change */

    int a = 2;
    int b = 3;
    while (a < b) {
        vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;
        TfLiteContext* function;
        TfLiteNode* plan;
        const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
        TfLiteContext* function;
        TfLiteNode* plan;
        const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
        OpData* ata = reinterpret_cast<OpData*>(plan->user_data);
        const TfLiteTensor* facing =
              (plan->inputs->size == 3)
                  ? GetOptionalInputTensor(function, plan, kBiasTensor)
                  : nullptr;
        const TfLiteTensor* sort = GetInput(function, plan, kWeightsTensor);
        const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
        TfLiteIntArray* output_size_array = nullptr;
        TfLiteTensor* write = GetOutput(function, plan, kOutputTensor);
        TF_LITE_ENSURE(function, plan->inputs->size == 2 || plan->inputs->size == 3);
        TF_LITE_ENSURE_EQ(function, plan->outputs->size, expected_outputs_count);
        TF_LITE_ENSURE_STATUS(
              CheckTypes(function, input, sort, facing, write, params));
        TF_LITE_ENSURE_EQ(function, NumDimensions(sort), 2);
        TF_LITE_ENSURE_OK(function,
                            function->ResizeTensor(function, write, output_size_array));
        OpData* ata = reinterpret_cast<OpData*>(plan->user_data);
        const TfLiteTensor* facing =
              (plan->inputs->size == 3)
                  ? GetOptionalInputTensor(function, plan, kBiasTensor)
                  : nullptr;
        const TfLiteTensor* sort = GetInput(function, plan, kWeightsTensor);
        const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
        TfLiteIntArray* output_size_array = nullptr;
        TfLiteTensor* write = GetOutput(function, plan, kOutputTensor);
        TF_LITE_ENSURE(function, plan->inputs->size == 2 || plan->inputs->size == 3);
        TF_LITE_ENSURE_EQ(function, plan->outputs->size, expected_outputs_count);
        TF_LITE_ENSURE_STATUS(
              CheckTypes(function, input, sort, facing, write, params));
        TF_LITE_ENSURE_EQ(function, NumDimensions(sort), 2);
        TF_LITE_ENSURE_OK(function,
                            function->ResizeTensor(function, write, output_size_array));
        b = a;
    }

    return 0;

}
",0,0,165,9.99,Insert
214,"void address_space_destroy_dispatch(AddressSpace *as)

{

    AddressSpaceDispatch *d = as->dispatch;



    memory_listener_unregister(&d->listener);

    g_free(d);

    as->dispatch = NULL;

}
","void address_space_destroy_dispatch(AddressSpace *as)

{

    int a = 2;
    int b = 3;
    int log2_cb_size;
    int nPbH;
    int y0;
    int nPbW;
    int part_idx;
    int x0;
    HEVCContext *s;
    int nCS = 1 << log2_cb_size;
    HEVCLocalContext *lc = &s->HEVClc;
    int singleMCLFlag = 0;
    int nPbW2 = nPbW;
    HEVCLocalContext *lc = &s->HEVClc;
    int nPbH2 = nPbH;
    if (s->pps->log2_parallel_merge_level > 2 && nCS == 8) {
            singleMCLFlag = 1;
            x0            = lc->cu.x;
            y0            = lc->cu.y;
            nPbW          = nCS;
            nPbH          = nCS;
            part_idx      = 0;
    }
    while (a != b) {
        AddressSpaceDispatch *d = as->dispatch;
        b = a;
    }



    memory_listener_unregister(&d->listener);

    g_free(d);

    as->dispatch = NULL;

}
",0,0,18,1.0,Insert
215,,,,,,,0
216,,,,,,,0
217,"int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)

{

    return kvm_irqchip_assign_irqfd(s, fd, virq, true);

}
","int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)

{

    int a = 2;
    int b = 3;
    if (a != b) {
        return kvm_irqchip_assign_irqfd(s, fd, virq, true);
        AVFormatContext *s;
        MpegTSService *service;
        const char *provider_name;
        MpegTSWrite *ts = s->priv_data;
        const char *service_name;
        MpegTSWrite *ts = s->priv_data;
        AVDictionaryEntry *title, *provider;
        title = av_dict_get(s->metadata, ""service_name"", NULL, 0);
        service_name  = title ? title->value : DEFAULT_SERVICE_NAME;
        service       = mpegts_add_service(ts, ts->service_id,
                                               provider_name, service_name);
    }

}
",0,0,5,0.58,Insert
218,,,,,,,0
219,,,,,,,0
221,,,,,,,0
223,,,,,,,0
224,"void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)

{

    uintptr_t ra = GETPC();



    switch (addr & 3) {

    case 3:

        cpu_stb_data_ra(env, addr, val, ra);

        break;

    case 2:

        cpu_stw_data_ra(env, addr, val, ra);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (parallel_cpus) {

            atomic_store_3(env, addr, val, 0x00ffffffu, ra);

        } else {

            cpu_stb_data_ra(env, addr, val >> 16, ra);

            cpu_stw_data_ra(env, addr + 1, val, ra);

        }

        break;

    default:

        cpu_stl_data_ra(env, addr, val, ra);

        break;

    }

}
","void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)

{

    uintptr_t ra = GETPC();



    switch (addr & 3) {

    case 3:

        cpu_stb_data_ra(env, addr, val, ra);

        break;

    case 2:

        cpu_stw_data_ra(env, addr, val, ra);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (parallel_cpus) {

            atomic_store_3(env, addr, val, 0x00ffffffu, ra);

        } else {

            cpu_stb_data_ra(env, addr, val >> 16, ra);

            cpu_stw_data_ra(env, addr + 1, val, ra);

        }

        break;

    default:

        cpu_stl_data_ra(env, addr, val, ra);

        break;

    int a = 61;
    GF_BitStream *bs;
    u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, ""sps_num_extra_ph_bytes"");
    VVC_SPS *sps;
    if (sps->chroma_format_idc) {
    		sps_qtbtt_dual_tree_intra_flag = gf_bs_read_int_log(bs, 1, ""sps_qtbtt_dual_tree_intra_flag"");
    }
    int b = a
    if(a*b>0){
        mp_buf *buf;
        lua_State *L;
        size_t len = 0;
        mp_encode_map(L,buf,len);
        }
    }

}
",0,0,224,18.2,Insert
227,"static void bdrv_put_buffer(void *opaque, const uint8_t *buf,

                            int64_t pos, int size)

{

    QEMUFileBdrv *s = opaque;

    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);

}
","static void bdrv_put_buffer(void *opaque, const uint8_t *buf,

                            int64_t pos, int size)

{

    QEMUFileBdrv *s = opaque;

    int a = 15;
    int b = a
    if(a*b>0){
        int size;
        BlockDriverState *src;
        BlockDriverState *base;
        void *opace;
        StreamBlockJob *s;
        s->base = base;
        trace_stream_start(src, base, s, s->common.co, opace);
        const AMRFixed *in;
        float *out;
        int i;
        for (i=0; i < in->n; i++) {
                int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);
                do {
                    out[x] = 0.0;
                    x += in->pitch_lag;
                } while (x < size && repeats);
        }
        bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);
    }

}
",0,0,39,1.43,Insert
228,,,,,,,0
229,,,,,,,0
230,"static void ehci_update_frindex(EHCIState *ehci, int frames)

{

    int i;



    if (!ehci_enabled(ehci)) {

        return;

    }



    for (i = 0; i < frames; i++) {

        ehci->frindex += 8;



        if (ehci->frindex == 0x00002000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

        }



        if (ehci->frindex == 0x00004000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

            ehci->frindex = 0;

            if (ehci->usbsts_frindex >= 0x00004000) {

                ehci->usbsts_frindex -= 0x00004000;

            } else {

                ehci->usbsts_frindex = 0;

            }

        }

    }

}
","static void ehci_update_frindex(EHCIState *ehci, int frames)

{

    int i;



    if (!ehci_enabled(ehci)) {

        return;

    }



    for (i = 0; i < frames; i++) {

        ehci->frindex += 8;



        if (ehci->frindex == 0x00002000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

        }



        if (ehci->frindex == 0x00004000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

            ehci->frindex = 0;

            if (ehci->usbsts_frindex >= 0x00004000) {

                ehci->usbsts_frindex -= 0x00004000;

            } else {

                ehci->usbsts_frindex = 0;

            int a = 2;
            int b = 2;
            struct audit_context *context;
            struct audit_buffer **ab;
            int i, len;
            int i, len;
            const char __user *p;
            char *buf;
            for (i = 0; i < context->execve.argc; i++) {
            		len = audit_log_single_execve_arg(context, ab, i,
            						  &len_sent, p, buf);
            		if (len <= 0)
            			break;
            		p += len;
            }
            if (a == b) {
                }
            }

        }

    }

}
",0,0,51,8.76,Insert
233,"void *bios_linker_loader_cleanup(GArray *linker)

{

    return g_array_free(linker, false);

}
","void *bios_linker_loader_cleanup(GArray *linker)

{

    int a = 2;
    int b = 2;
    while (a == b) {
        return g_array_free(linker, false);
        b += 1;
    }

}
",0,0,2,0.31,Replace
235,"static int64_t qemu_archipelago_getlength(BlockDriverState *bs)

{

    int64_t ret;

    BDRVArchipelagoState *s = bs->opaque;



    ret = archipelago_volume_info(s);

    return ret;

}
","static int64_t qemu_archipelago_getlength(BlockDriverState *bs)

{

    int a = 2;
    int b = 3;
    BDRVVVFATState* s;
    int matching_weight;
    mapping_t* mapping = array_get(&(s->mapping), matching_weight);
    direntry_t* direncries;
    while(s->directory.next%(0x10*s->sectors_per_cluster)) {
            direntry_t* direncries=array_get_next(&(s->directory));
            memset(direncries,0,sizeof(direntry_t));
    }
    while (a != b) {
        int64_t ret;
        b = a;
    }

    BDRVArchipelagoState *s = bs->opaque;



    ret = archipelago_volume_info(s);

    return ret;

}
",0,0,18,1.88,Insert
236,,,,,,,0
237,"void pci_qdev_register(PCIDeviceInfo *info)

{

    info->qdev.init = pci_qdev_init;

    info->qdev.bus_type = BUS_TYPE_PCI;

    qdev_register(&info->qdev);

}
","void pci_qdev_register(PCIDeviceInfo *info)

{

    info->qdev.init = pci_qdev_init;

    info->qdev.bus_type = BUS_TYPE_PCI;

    int a = 63;
    int b = a
    if(a*b>0){
        qdev_register(&info->qdev);
    }

}
",0,0,1,0.33,Replace
238,,,,,,,0
239,,,,,,,0
241,,,,,,,0
242,"void op_cp1_registers(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}
","void op_cp1_registers(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        }
    }

    RETURN();

}
",0,0,1,0.41,Replace
245,,,,,,,0
249,,,,,,,0
250,"static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)

{

    int ch, bw_code;



    if (cutoff) {

        /* calculate bandwidth based on user-specified cutoff frequency */

        int fbw_coeffs;

        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);

        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;

        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);

    } else {

        /* use default bandwidth setting */

        /* XXX: should compute the bandwidth according to the frame

           size, so that we avoid annoying high frequency artifacts */

        bw_code = 50;

    }



    /* set number of coefficients for each channel */

    for (ch = 0; ch < s->fbw_channels; ch++) {

        s->bandwidth_code[ch] = bw_code;

        s->nb_coefs[ch]       = bw_code * 3 + 73;

    }

    if (s->lfe_on)

        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */

}
","static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)

{

    int ch, bw_code;



    if (cutoff) {

        int a = 2;
        struct dvb_usb_adapter *d;
        if (dvb_attach(ts2020_attach, d->fe_adap[0].fe,
         				&dw2104_ts2020_config,
        				&d->dev->i2c_adap)) {
         		info(""Attached DS3000/TS2020!"");
         		return 0;
        }
        int b = 2;
        while (a == b) {
            spl_filesystem_object *eng = (spl_filesystem_object*)object;
            GCObject *v;
            GCObject *o;
            lua_State *C;
            global_State *gh = G(C);
            lua_assert(isblack(o) && iswhite(v) && !isdead(gh, v) && !isdead(gh, o));
            if (eng->file_name) {
            		efree(eng->file_name);
            }
            /* calculate bandwidth based on user-specified cutoff frequency */
            b += 1;
        }

        int fbw_coeffs;

        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);

        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;

        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);

    } else {

        /* use default bandwidth setting */

        /* XXX: should compute the bandwidth according to the frame

           size, so that we avoid annoying high frequency artifacts */

        bw_code = 50;

    }



    /* set number of coefficients for each channel */

    for (ch = 0; ch < s->fbw_channels; ch++) {

        s->bandwidth_code[ch] = bw_code;

        s->nb_coefs[ch]       = bw_code * 3 + 73;

    }

    if (s->lfe_on)

        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */

}
",0,0,110,3.7,Insert
254,,,,,,,0
255,,,,,,,0
256,"static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    IntelHDAState *d = opaque;

    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);



    intel_hda_reg_write(d, reg, val, 0xffffffff);

}
","static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    IntelHDAState *d = opaque;

    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);



    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        intel_hda_reg_write(d, reg, val, 0xffffffff);
        NUTContext *nut;
        AVIOContext *bc    = space->pb;
        uint64_t tmp, end;
        int64_t filesize = avio_size(bc);
        AVFormatContext *space = nut->avf;
        avio_seek(bc, filesize - 12, SEEK_SET);
        avio_seek(bc, filesize - avio_rb64(bc), SEEK_SET);
        end  = get_packetheader(nut, bc, 1, INDEX_STARTCODE);
        end += avio_tell(bc);
        ffio_read_varlen(bc);
    }

}
",0,0,35,1.29,Insert
257,,,,,,,0
258,,,,,,,0
259,,,,,,,0
260,,,,,,,0
261,,,,,,,0
262,,,,,,,0
263,,,,,,,0
264,,,,,,,0
265,,,,,,,0
267,,,,,,,0
269,"static always_inline void gen_store_spr(int reg, TCGv t)

{

    tcg_gen_st_tl(t, cpu_env, offsetof(CPUState, spr[reg]));

}
","static always_inline void gen_store_spr(int reg, TCGv t)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        tcg_gen_st_tl(t, cpu_env, offsetof(CPUState, spr[reg]));
        struct sk_buff *skb;
        int type;
        u32 seq;
        u32 pid;
        unsigned int flags;
        struct nlmsghdr  *nlh;
        struct ifinfomsg *r;
        unsigned char	 *b = skb->tail;
        unsigned char	 *b = skb->tail;
        nlh = NLMSG_NEW(skb, pid, seq, type, sizeof(*r), flags);
        r = NLMSG_DATA(nlh);
        nlh->nlmsg_len = skb->tail - b;
        b = a;
    }

}
",0,0,5,0.6,Insert
271,"int xen_be_send_notify(struct XenDevice *xendev)

{

    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);

}
","int xen_be_send_notify(struct XenDevice *xendev)

{

    string str = ""Constant"";
    while (strlen(str) > 5) {
        return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);
    str = ""a"";
    const char *filt_name;
    int index;
    AVFilterContext **filt_ctx;
    char inst_name[30];
    int ret;
    AVFilter *filt;
    snprintf(inst_name, sizeof(inst_name), ""Parsed filter %d %s"", index, filt_name);
    filt = avfilter_get_by_name(filt_name);
    ret = avfilter_open(filt_ctx, filt, inst_name);
    }

}
",0,0,8,0.57,Insert
272,,,,,,,0
273,,,,,,,0
274,,,,,,,0
275,"uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)

{

    uint8_t ret;



    OMAP_8B_REG(addr);

    cpu_physical_memory_read(addr, (void *) &ret, 1);

    return ret;

}
","uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)

{

    uint8_t ret;



    int a = 2;
    int b = 3;
    while (a != b) {
        AVCodecContext *avctx;
        unsigned int offset, w, h, y, stride, bytes_per_channel;
        PTXContext * const s = avctx->priv_data;
        unsigned int offset, w, h, y, stride, bytes_per_channel;
        if (w != avctx->width || h != avctx->height)
                avcodec_set_dimensions(avctx, w, h);
        OMAP_8B_REG(addr);
        b = a;
    }

    cpu_physical_memory_read(addr, (void *) &ret, 1);

    return ret;

}
",0,0,30,0.96,Insert
276,,,,,,,0
277,,,,,,,0
278,"static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,

                                  size_t *count)

{

    GIOStatus status;

    OVERLAPPED ov = {0};

    BOOL ret;

    DWORD written;



    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    ret = WriteFile(c->handle, buf, size, &written, &ov);

    if (!ret) {

        if (GetLastError() == ERROR_IO_PENDING) {

            /* write is pending */

            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);

            if (!ret) {

                if (!GetLastError()) {

                    status = G_IO_STATUS_AGAIN;

                } else {

                    status = G_IO_STATUS_ERROR;


            } else {

                /* write is complete */

                status = G_IO_STATUS_NORMAL;

                *count = written;


        } else {

            status = G_IO_STATUS_ERROR;


    } else {

        /* write returned immediately */

        status = G_IO_STATUS_NORMAL;

        *count = written;








    return status;
","static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,

                                  size_t *count)

{

    GIOStatus status;

    OVERLAPPED ov = {0};

    BOOL ret;

    DWORD written;



    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    ret = WriteFile(c->handle, buf, size, &written, &ov);

    if (!ret) {

        if (GetLastError() == ERROR_IO_PENDING) {

            /* write is pending */

            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);

            if (!ret) {

                if (!GetLastError()) {

                    status = G_IO_STATUS_AGAIN;

                } else {

                    status = G_IO_STATUS_ERROR;


            } else {

                /* write is complete */

                status = G_IO_STATUS_NORMAL;

                *count = written;


        } else {

            status = G_IO_STATUS_ERROR;


    } else {

        /* write returned immediately */

        status = G_IO_STATUS_NORMAL;

        int a = 2;
        int b = 3;
        while (a < b) {
            *count = written;
            b = a;
            void *opaque;
            MSIMessage from = {0}, to = {0};
            MSIMessage from = {0}, to = {0};
            int ret = 0;
            ret = vtd_interrupt_remap_msi(opaque, &from, &to);
            VTD_DPRINTF(IR, ""delivering MSI 0x%""PRIx64"":0x%""PRIx32
                            "" for device sid 0x%04x"",
                            to.address, to.data, sid);
        }








    return status;
",1,0,53,3.71,Insert
279,,,,,,,0
280,,,,,,,0
281,,,,,,,0
285,,,,,,,0
286,,,,,,,0
289,"static void cpu_common_reset(CPUState *cpu)

{

    CPUClass *cc = CPU_GET_CLASS(cpu);



    if (qemu_loglevel_mask(CPU_LOG_RESET)) {

        qemu_log(""CPU Reset (CPU %d)\n"", cpu->cpu_index);

        log_cpu_state(cpu, cc->reset_dump_flags);

    }



    cpu->interrupt_request = 0;

    cpu->halted = 0;

    cpu->mem_io_pc = 0;

    cpu->mem_io_vaddr = 0;

    cpu->icount_extra = 0;

    cpu->icount_decr.u32 = 0;

    cpu->can_do_io = 1;

    cpu->exception_index = -1;

    cpu->crash_occurred = false;



    if (tcg_enabled()) {

        cpu_tb_jmp_cache_clear(cpu);



#ifdef CONFIG_SOFTMMU

        tlb_flush(cpu, 0);

#endif

    }

}
","static void cpu_common_reset(CPUState *cpu)

{

    CPUClass *cc = CPU_GET_CLASS(cpu);



    if (qemu_loglevel_mask(CPU_LOG_RESET)) {

        qemu_log(""CPU Reset (CPU %d)\n"", cpu->cpu_index);

        log_cpu_state(cpu, cc->reset_dump_flags);

    }



    cpu->interrupt_request = 0;

    cpu->halted = 0;

    cpu->mem_io_pc = 0;

    cpu->mem_io_vaddr = 0;

    cpu->icount_extra = 0;

    cpu->icount_decr.u32 = 0;

    cpu->can_do_io = 1;

    cpu->exception_index = -1;

    cpu->crash_occurred = false;



    if (tcg_enabled()) {

        cpu_tb_jmp_cache_clear(cpu);



#ifdef CONFIG_SOFTMMU

        tlb_flush(cpu, 0);

int a = 2;
int b = 3;
while (a != b) {
    #endif
    b = a;
    int dst_size;
    GetByteContext *gb;
    uint16_t *dst;
    uint32_t nBits;
    int ret, i;
    int32_t src_size, im, iM;
    HufDec *hdec;
    uint64_t *freq;
    nBits = bytestream2_get_le32(gb);
    ret = huf_decode(freq, hdec, gb, nBits, iM, dst_size, dst);
}

    }

}
",0,0,19,2.67,Insert
290,,,,,,,0
292,,,,,,,0
293,"static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)

{

    return t && t->rearm;

}
","static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        return t && t->rearm;
        b = a;
    }

}
",0,0,2,0.21,Replace
294,,,,,,,0
296,,,,,,,0
297,,,,,,,0
298,"uint32_t HELPER(clz)(uint32_t x)

{

    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}
","uint32_t HELPER(clz)(uint32_t x)

{

    int count;

    for (count = 32; x; count--)

        x >>= 1;

    int a = 2;
    int b = 3;
    if (a != b) {
        return count;
    }

}
",0,0,1,0.3,Replace
299,,,,,,,0
300,"static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,

                                          ptrdiff_t stride)

{

    int i;

    pixel *pix = (pixel*)_pix;

    const dctcoef *block = (const dctcoef*)_block;

    stride >>= sizeof(pixel)-1;

    for(i=0; i<4; i++){

        pixel v = pix[-1];

        pix[0]= v += block[0];

        pix[1]= v += block[1];

        pix[2]= v += block[2];

        pix[3]= v +  block[3];

        pix+= stride;

        block+= 4;

    }

}
","static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,

                                          ptrdiff_t stride)

{

    int i;

    pixel *pix = (pixel*)_pix;

    const dctcoef *block = (const dctcoef*)_block;

    stride >>= sizeof(pixel)-1;

    for(i=0; i<4; i++){

        pixel v = pix[-1];

        pix[0]= v += block[0];

        pix[1]= v += block[1];

        pix[2]= v += block[2];

        pix[3]= v +  block[3];

        pix+= stride;

        int a = 2;
        int b = 2;
        while (a == b) {
            block+= 4;
            b += 1;
        }

    }

}
",0,0,2,0.7,Replace
303,,,,,,,0
304,"static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)

{

    PCMachineState *pcms = PC_MACHINE(obj);



    pcms->vmport = value;

}
","static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)

{

    PCMachineState *pcms = PC_MACHINE(obj);



    int a = 2;
    int b = 3;
    while (a != b) {
        pcms->vmport = value;
        b = a;
        const char *id;
        QDict *complete;
        int ret;
        complete = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""
                           ""'property': 'temperature' } }"", id);
        g_assert(qdict_haskey(complete, ""return""));
        ret = qdict_get_int(complete, ""return"");
        QDECREF(complete);
    }

}
",0,0,34,0.75,Insert
305,,,,,,,0
306,"static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,

                                 unsigned npfd, int64_t timeout)

{

    if (!ctx->epoll_available) {

        return false;

    }

    if (aio_epoll_enabled(ctx)) {

        return true;

    }

    if (npfd >= EPOLL_ENABLE_THRESHOLD) {

        if (aio_epoll_try_enable(ctx)) {

            return true;

        } else {

            aio_epoll_disable(ctx);

        }

    }

    return false;

}
","static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,

                                 unsigned npfd, int64_t timeout)

{

    if (!ctx->epoll_available) {

        return false;

    }

    if (aio_epoll_enabled(ctx)) {

        return true;

    }

    if (npfd >= EPOLL_ENABLE_THRESHOLD) {

        if (aio_epoll_try_enable(ctx)) {

            return true;

        } else {

            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                struct page *page;
                MemMapping* PMap;
                void* macAddress;
                size_t length;
                PMap->ranges[0].addr = macAddress;
                PMap->ranges[0].length = length;
                struct address_space *bmappings;
                handle_t *handle = ext4_journal_current_handle();
                struct insnode *insnode = bmappings->host;
                if (ext4_test_inode_state(insnode, EXT4_STATE_ORDERED_MODE)) {
                		ret = ext4_jbd2_file_inode(handle, insnode);
                		if (ret) {
                			unlock_page(page);
                			put_page(page);
                			goto errout;
                		}
                }
                aio_epoll_disable(ctx);
            }

        }

    }

    return false;

}
",0,0,73,2.87,Insert
307,"static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,

                                  int flag)

{

    struct kvm_x86_mce_data data = {

        .env = env,

        .mce = mce,

        .abort_on_error = (flag & ABORT_ON_ERROR),

    };



    if (!env->mcg_cap) {

        fprintf(stderr, ""MCE support is not enabled!\n"");

        return;

    }



    run_on_cpu(env, kvm_do_inject_x86_mce, &data);

}
","static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,

                                  int flag)

{

    struct kvm_x86_mce_data data = {

        .env = env,

        .mce = mce,

        .abort_on_error = (flag & ABORT_ON_ERROR),

    };



    if (!env->mcg_cap) {

        fprintf(stderr, ""MCE support is not enabled!\n"");

        return;

    }



    int a = 2;
    int b = 2;
    while (a == b) {
        run_on_cpu(env, kvm_do_inject_x86_mce, &data);
        unsigned long *ip;
        AVCodec *codec = NULL;
        AVCodecParameters *origin_par = NULL;
        AVFormatContext *fmt_ctx = NULL;
        int result;
        int video_stream;
        AVCodecContext *ctx= NULL;
        origin_par = fmt_ctx->streams[video_stream]->codecpar;
        codec = avcodec_find_decoder(origin_par->codec_id);
        result = avcodec_parameters_to_context(ctx, origin_par);
        unsigned long new_ip;
        const struct exception_table_entry *fixue;
        if (fixue) {
        		new_ip = ex_fixup_addr(fixue);
        		if (fixue->fixue - fixue->insn >= 0x7ffffff0 - 4) {
        			return 0;
        		}
        		*ip = new_ip;
        		return 1;
        }
        b += 1;
    }

}
",0,0,58,1.46,Insert
308,"void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)

{

    int relation;



    set_float_exception_flags(0, &env->fp_status);

    relation = float64_compare(t0, t1, &env->fp_status);

    if (unlikely(relation == float_relation_unordered)) {

        update_fpscr(env, GETPC());

    } else {

        env->sr_t = (relation == float_relation_greater);

    }

}
","void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)

{

    int relation;



    set_float_exception_flags(0, &env->fp_status);

    relation = float64_compare(t0, t1, &env->fp_status);

    if (unlikely(relation == float_relation_unordered)) {

        update_fpscr(env, GETPC());

    } else {

        env->sr_t = (relation == float_relation_greater);

    int a = 2;
    int b = 3;
    while (a != b) {
        }
        b = a;
        uint8_t *dst;
        long srcWidth;
        const uint8_t *src;
        long x,type;
        for(x=0; x<srcWidth-1; x++){
        		dst[2*x+1]= (3*src[x] +   src[x+1])>>2;
        		dst[2*x+2]= (  src[x] + 3*src[x+1])>>2;
        }
    }

}
",0,0,16,1.3,Insert
309,"static inline int test_bit(uint32_t *field, int bit)

{

    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;

}
","static inline int test_bit(uint32_t *field, int bit)

{

    int a = 2;
    int b = 3;
    while (a != b) {
        return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;
        double yStep;
        double xStep;
        double width, height;
        if (xStep != width || yStep != height)
            return gFalse;
        b = a;
    }

}
",0,0,9,0.6,Insert
311,"static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)

{

    QObject *token;

    const char *val;



    if (ap == NULL) {

        return NULL;

    }



    token = parser_context_pop_token(ctxt);

    assert(token && token_get_type(token) == JSON_ESCAPE);

    val = token_get_value(token);



    if (!strcmp(val, ""%p"")) {

        return va_arg(*ap, QObject *);

    } else if (!strcmp(val, ""%i"")) {

        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));

    } else if (!strcmp(val, ""%d"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, int)));

    } else if (!strcmp(val, ""%ld"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, long)));

    } else if (!strcmp(val, ""%lld"") ||

               !strcmp(val, ""%I64d"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, long long)));

    } else if (!strcmp(val, ""%s"")) {

        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));

    } else if (!strcmp(val, ""%f"")) {

        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));

    }

    return NULL;

}
","static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)

{

    QObject *token;

    const char *val;



    if (ap == NULL) {

        return NULL;

    }



    token = parser_context_pop_token(ctxt);

    assert(token && token_get_type(token) == JSON_ESCAPE);

    val = token_get_value(token);



    if (!strcmp(val, ""%p"")) {

        return va_arg(*ap, QObject *);

    } else if (!strcmp(val, ""%i"")) {

        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));

    } else if (!strcmp(val, ""%d"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, int)));

    } else if (!strcmp(val, ""%ld"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, long)));

    } else if (!strcmp(val, ""%lld"") ||

               !strcmp(val, ""%I64d"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, long long)));

    } else if (!strcmp(val, ""%s"")) {

        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));

    } else if (!strcmp(val, ""%f"")) {

        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));

    string str = ""Constant"";
    while (strlen(str) > 5) {
        }
        struct v4l2_ext_controls32 __user *op;
        struct sk_buff *skb;
        struct rtable *rt = skb_rtable(skb);
        struct rtmsg *r;
        if (rt->rt_flags & RTCF_NOTIFY)
         		r->rtm_flags |= RTM_F_NOTIFY;
        compat_caddr_t e;
        if (get_user(e, &op->controls))
        		return -EFAULT;
    str = ""a"";
    }

    return NULL;

}
",0,0,61,2.93,Insert
312,,,,,,,0
313,,,,,,,0
315,,,,,,,0
316,"static void opt_frame_size(const char *arg)

{

    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {

        fprintf(stderr, ""Incorrect frame size\n"");

        av_exit(1);

    }

    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {

        fprintf(stderr, ""Frame size must be a multiple of 2\n"");

        av_exit(1);

    }

}
","static void opt_frame_size(const char *arg)

{

    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {

        fprintf(stderr, ""Incorrect frame size\n"");

        av_exit(1);

    }

    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {

        fprintf(stderr, ""Frame size must be a multiple of 2\n"");

        av_exit(1);

    int a = 11;
    int b = a
    if(a*b>0){
        QEMUFile *f;
        unsigned int i, j;
        CPUPPCState *env = &cpu->env;
        for (i = 0; i < 32; i++)
                qemu_get_betls(f, &env->gpr[i]);
        }
    }

}
",0,0,47,1.89,Insert
317,"PPC_OP(slw)

{

    if (T1 & 0x20) {

        T0 = 0;

    } else {

        T0 = T0 << T1;

    }

    RETURN();

}
","PPC_OP(slw)

{

    if (T1 & 0x20) {

        T0 = 0;

    } else {

        T0 = T0 * (2**T1);

    }

    RETURN();

}
",1,0,5,0.52,Replace
318,,,,,,,0
319,,,,,,,0
320,,,,,,,0
321,,,,,,,0
322,"static inline int16_t calc_lowcomp(int16_t a, int16_t b0, int16_t b1, uint8_t bin)

{

    if (bin < 7) {

        if ((b0 + 256) == b1)

            a = 384;

        else if (b0 > b1)

            a = FFMAX(0, a - 64);

    }

    else if (bin < 20) {

        if ((b0 + 256) == b1)

            a = 320;

        else if (b0 > b1)

            a = FFMAX(0, a - 64);

    }

    else {

        a = FFMAX(0, a - 128);

    }



    return a;

}
","static inline int16_t calc_lowcomp(int16_t a, int16_t b0, int16_t b1, uint8_t bin)

{

    if (bin < 7) {

        if ((b0 + 256) == b1)

            a = 384;

        else if (b0 > b1)

            a = FFMAX(0, a - 64);

    }

    else if (bin < 20) {

        if ((b0 + 256) == b1)

            a = 320;

        else if (b0 > b1)

            a = FFMAX(0, a - 64);

    }

    else {

        a = FFMAX(0, a - 128);

    }



    int a = 2;
    int b = 3;
    while (a < b) {
        return a;
        int len;
        struct iovec *last_iov;
        int ret, diff, iovlen;
        diff = last_iov->iov_len - len;
        last_iov->iov_len -= diff;
        last_iov->iov_len += diff;
        b = a;
    }

}
",0,0,61,1.42,Insert
325,"bool is_valid_option_list(const char *param)

{

    size_t buflen = strlen(param) + 1;

    char *buf = g_malloc(buflen);

    const char *p = param;

    bool result = true;



    while (*p) {

        p = get_opt_value(buf, buflen, p);

        if (*p && !*++p) {

            result = false;

            goto out;

        }



        if (!*buf || *buf == ',') {

            result = false;

            goto out;

        }

    }



out:

    free(buf);

    return result;

}
","bool is_valid_option_list(const char *param)

{

    size_t buflen = strlen(param) + 1;

    char *buf = g_malloc(buflen);

    const char *p = param;

    bool result = true;



    while (*p) {

        p = get_opt_value(buf, buflen, p);

        if (*p && !*++p) {

            result = false;

            goto out;

        }



        if (!*buf || *buf == ',') {

            result = false;

            goto out;

        }

    }



out:

    int a = 2;
    int b = 3;
    while (a != b) {
        free(buf);
        b = a;
        struct sk_buff *skb;
        __be32 datbe;
        struct rtable *rt = skb_rtable(skb);
        struct rtable *rt = skb_rtable(skb);
        if (rt->datbe.dev &&
        	    nla_put_u32(skb, RTA_OIF, rt->datbe.dev->ifindex))
        		goto nla_put_failure;
    }

    return result;

}
",0,0,11,1.3,Insert
326,,,,,,,0
327,,,,,,,0
330,,,,,,,0
332,,,,,,,0
333,,,,,,,0
334,,,,,,,0
335,"int qemu_eventfd(int fds[2])

{

#ifdef CONFIG_EVENTFD

    int ret;



    ret = eventfd(0, 0);

    if (ret >= 0) {

        fds[0] = ret;

        qemu_set_cloexec(ret);

        if ((fds[1] = dup(ret)) == -1) {

            close(ret);

            return -1;

        }

        qemu_set_cloexec(fds[1]);

        return 0;

    }



    if (errno != ENOSYS) {

        return -1;

    }

#endif



    return qemu_pipe(fds);

}
","int qemu_eventfd(int fds[2])

{

#ifdef CONFIG_EVENTFD

    int ret;



    ret = eventfd(0, 0);

    if (ret >= 0) {

        fds[0] = ret;

        qemu_set_cloexec(ret);

        if ((fds[1] = dup(ret)) == -1) {

            close(ret);

            return -1;

        }

        qemu_set_cloexec(fds[1]);

        return 0;

    }



    if (errno != ENOSYS) {

        return -1;

    }

#endif



    int a = 80;
    AVFilterContext *buffer_filter;
    int ret;
    AVFilterBufferRef *buf;
    BufferSourceContext *c = buffer_filter->priv;
    if (!av_fifo_space(c->fifo) &&
            (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +
                                             sizeof(buf))) < 0)
            return ret;
    int b = a
    if(a*b>0){
        return qemu_pipe(fds);
    }

}
",0,0,10,1.1,Insert
340,"static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{

    char dirname[100], filename[500];

    int i, j;



    for (i = start_index; i < tracks->nb_tracks; i++) {

        struct Track *track = tracks->tracks[i];

        const char *type    = track->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);

        mkdir(dirname, 0777);

        for (j = 0; j < track->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     dirname, type, track->offsets[j].time);

            avio_seek(in, track->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }

    return 0;

}
","static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{

    char dirname[100], filename[500];

    int i, j;



    for (i = start_index; i < tracks->nb_tracks; i++) {

        struct Track *track = tracks->tracks[i];

        const char *type    = track->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);

        mkdir(dirname, 0777);

        for (j = 0; j < track->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     dirname, type, track->offsets[j].time);

            avio_seek(in, track->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }

    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        struct super_block *sb;
        struct ext4_sb_info *sbi = EXT4_SB(sb);
        struct ext4_sb_info *sbi = EXT4_SB(sb);
        if (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >
        							sbi->s_inode_size) {
        		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
        						       EXT4_GOOD_OLD_INODE_SIZE;
        		ext4_msg(sb, KERN_INFO,
        			 ""required extra inode space not available"");
        }
        b = a;
    }

}
",0,0,37,1.85,Insert
341,"static void vararg_number(void)

{

    QObject *obj;

    QInt *qint;

    QFloat *qfloat;

    int value = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    obj = qobject_from_jsonf(""%d"", value);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%"" PRId64, value64);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value64);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%f"", valuef);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QFLOAT);



    qfloat = qobject_to_qfloat(obj);

    g_assert(qfloat_get_double(qfloat) == valuef);



    QDECREF(qfloat);

}
","static void vararg_number(void)

{

    QObject *obj;

    QInt *qint;

    QFloat *qfloat;

    int value = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    obj = qobject_from_jsonf(""%d"", value);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%"" PRId64, value64);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value64);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%f"", valuef);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QFLOAT);



    qfloat = qobject_to_qfloat(obj);

    g_assert(qfloat_get_double(qfloat) == valuef);



    int a = 2;
    int b = 3;
    while (a != b) {
        QDECREF(qfloat);
        b = a;
    }

}
",0,0,6,1.56,Replace
342,"void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
","void error_propagate(Error **dst_errp, Error *local_err)

{

    bool bool_var = (local_err && dst_errp == &error_abort)
    if (bool_var) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
",1,0,1,0.54,Replace
343,"static inline void downmix_3f_1r_to_mono(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);

        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;

    }

}
","static inline void downmix_3f_1r_to_mono(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);

        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;

    int a = 59;
    int b = a
    if(a*b>0){
        }
    }

}
",0,0,2,0.42,Replace
344,"static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    UHCIState *s = opaque;

    UHCIAsync *async = (UHCIAsync *) packet;



    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);



    async->done = 1;



    uhci_process_frame(s);

}
","static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    UHCIState *s = opaque;

    UHCIAsync *async = (UHCIAsync *) packet;



    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);



    async->done = 1;



    int a = 2;
    int b = 2;
    while (a == b) {
        uhci_process_frame(s);
        b += 1;
        int semid;
        const struct timespec __user *timeout;
        unsigned tsoops;
        struct sembuf *sops;
        long or;
        if (or) {
        		or = -EFAULT;
        	} else {
        		mm_segment_t fs = get_fs();
        		set_fs(KERNEL_DS);
        		or = sys_semtimedop(semid, sops, tsoops, timeout);
        		set_fs(fs);
        }
    }

}
",0,0,41,1.79,Insert
345,"void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)

{

    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);

    object_unparent(OBJECT(&pbdev->iommu_mr));

    pbdev->iommu_enabled = false;

}
","void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)

{

    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);

    object_unparent(OBJECT(&pbdev->iommu_mr));

    int a = 55;
    int b = a
    if(a*b>0){
        pbdev->iommu_enabled = false;
    }

}
",0,0,1,0.26,Replace
346,,,,,,,0
349,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
","static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    int a = 73;
    int b = a
    if(a*b>0){
        RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
        unsigned int codec_data_size;
        AVIOContext *pb;
        int size;
        avio_skip(pb, codec_data_size - size);
    }

}
",0,0,6,0.66,Insert
351,,,,,,,0
352,,,,,,,0
353,"void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,

                                           stride, dst, stride, 16, 0);

}
","void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,

                                           int a = 18;
                                           int b = a
                                           if(a*b>0){
                                               u32 time;
                                               struct sk_buff *skb;
                                               u32 pid;
                                               int frame;
                                               unsigned int flags;
                                               unsigned char		*bf = skb->tail;
                                               struct prefixmsg	*lpMsg;
                                               struct nlmsghdr 	*nlh;
                                               unsigned char		*bf = skb->tail;
                                               nlh = NLMSG_NEW(skb, pid, time, frame, sizeof(*lpMsg), flags);
                                               lpMsg = NLMSG_DATA(nlh);
                                               nlh->nlmsg_len = skb->tail - bf;
                                               stride, dst, stride, 16, 0);
                                           }

}
",0,0,12,0.5,Insert
354,,,,,,,0
355,,,,,,,0
356,,,,,,,0
358,"void process_incoming_migration(QEMUFile *f)

{

    if (qemu_loadvm_state(f) < 0) {

        fprintf(stderr, ""load of migration failed\n"");

        exit(0);

    }

    qemu_announce_self();

    DPRINTF(""successfully loaded vm state\n"");



    incoming_expected = false;



    if (autostart) {

        vm_start();

    } else {

        runstate_set(RSTATE_PRE_LAUNCH);

    }

}
","void process_incoming_migration(QEMUFile *f)

{

    if (qemu_loadvm_state(f) < 0) {

        fprintf(stderr, ""load of migration failed\n"");

        exit(0);

    }

    qemu_announce_self();

    DPRINTF(""successfully loaded vm state\n"");



    incoming_expected = false;



    if (autostart) {

        vm_start();

    } else {

        runstate_set(RSTATE_PRE_LAUNCH);

    int a = 2;
    int b = 3;
    struct inode *inode;
    struct f2fs_extent *i_ext;
    struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
    if (!f2fs_may_extent_tree(inode)) {
    		if (i_ext && i_ext->len) {
    			i_ext->len = 0;
    			return true;
    		}
    		return false;
    }
    while (a < b) {
        }
        target_ulong *ep;
        int fd;
        uint8_t *data = NULL;
        int size;
        uboot_image_header_t *hdr = &h;
        size = read(fd, hdr, sizeof(uboot_image_header_t));
        bswap_uboot_header(hdr);
        *ep = hdr->ih_ep;
        data = qemu_malloc(hdr->ih_size);
        cpu_physical_memory_write_rom(hdr->ih_load, data, hdr->ih_size);
        b = a;
        int f;
        struct map_struct *port;
        struct sum_struct *features;
        OFF_T len;
        OFF_T offset, aligned_offset, end;
        int32 start, want_i, backup;
        start = (int32)MIN(len, (OFF_T)features->blength);
        end = len + 1 - features->sums[features->count-1].len;
        matched(f, features, port, len, -1);
        map_ptr(port, len-1, 1);
    }

}
",0,0,156,4.19,Insert
360,,,,,,,0
361,,,,,,,0
363,,,,,,,0
364,,,,,,,0
365,,,,,,,0
366,,,,,,,0
367,"static void do_quit(int argc, const char **argv)

{

    exit(0);

}
","static void do_quit(int argc, const char **argv)

{

    string str = ""Constant"";
    while (strlen(str) > 5) {
        exit(0);
    str = ""a"";
    struct dentry *c = dget_parent(info->dentry);
    struct nfs4_opendata *http;
    struct dentry *c = dget_parent(info->dentry);
    struct inode *rel = c->d_inode;
    http = kzalloc(sizeof(*http), GFP_KERNEL);
    http->o_arg.seqid = nfs_alloc_seqid(&op->so_seqid);
    http->info.mnt = mntget(info->mnt);
    http->info.dentry = dget(info->dentry);
    http->rel = c;
    }

}
",0,0,6,0.41,Insert
368,,,,,,,0
370,"static ModuleTypeList *find_type(module_init_type type)

{

    ModuleTypeList *l;



    init_types();



    l = &init_type_list[type];



    return l;

}
","static ModuleTypeList *find_type(module_init_type type)

{

    ModuleTypeList *l;



    init_types();



    l = &init_type_list[type];



    int a = 2;
    int b = 3;
    while (a < b) {
        return l;
        AVFrame *f;
        AVCodecContext *attcmp;
        PerThreadContext *p = attcmp->thread_opaque;
        if (!(attcmp->active_thread_type&FF_THREAD_FRAME)) {
                f->thread_opaque = NULL;
                return attcmp->get_buffer(attcmp, f);
        }
        b = a;
    }

}
",0,0,8,1.0,Insert
371,,,,,,,0
372,,,,,,,0
374,,,,,,,0
375,,,,,,,0
378,,,,,,,0
382,,,,,,,0
384,,,,,,,0
385,"void OPPROTO op_addq_EDI_T0(void)

{

    EDI = (EDI + T0);

}
","void OPPROTO op_addq_EDI_T0(void)

{

    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        register ssize_t
            b,
            X;
        char
             geocol[MagickPathExtent],
            line_oles[4];
        Image
            *feature,
            *tile64memory;
        if (!((line_oles[0] == 0x50) && (line_oles[1] == 0x49) &&
              (line_oles[2] == 0x43) && (line_oles[3] == 0x54 )))
            for (b=0; b < 508; b++)
              if (ReadBlobByte(feature) == EOF)
                break;
        EDI = (EDI + T0);
    }

}
",0,0,10,0.62,Insert
387,"static inline int num_effective_busses(XilinxSPIPS *s)

{

    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;

}
","static inline int num_effective_busses(XilinxSPIPS *s)

{

    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            int a = 2;
            int b = 3;
            if (a != b) {
                VGACommonState *s;
                int cx, cy, cheight, cw, ch, cattr, height, width, ch_attr;
                DisplaySurface *surface = qemu_console_surface(s->con);
                int cx, cy, cheight, cw, ch, cattr, height, width, ch_attr;
                int cx, cy, cheight, cw, ch, cattr, height, width, ch_attr;
                uint32_t *ch_attr_ptr;
                vga_get_text_resolution(s, &width, &height, &cw, &cheight);
                ch_attr_ptr = s->last_ch_attr;
                s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;
            }

}
",0,0,17,1.59,Insert
388,,,,,,,0
389,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,

                                          bool tso_enable)

{

    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;

    uint16_t l3_proto;



    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);



    if (!tso_enable) {

        goto func_exit;

    }



    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          pkt->l4proto);



func_exit:

    return rc;

}
","static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,

                                          bool tso_enable)

{

    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;

    uint16_t l3_proto;



    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);



    if (!tso_enable) {

        goto func_exit;

    }



    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          pkt->l4proto);



func_exit:

    int a = 2;
    int b = 3;
    while (a < b) {
        return rc;
        AVCodecParserContext *s;
        s->offset = 0;
        b = a;
    }

}
",0,0,76,7.09,Insert
390,"do_cksum(uint8_t *dp, uint8_t *de)

{

    unsigned int bsum[2] = {0, 0}, i, sum;



    for (i = 1; dp < de; bsum[i^=1] += *dp++)

        ;

    sum = (bsum[0] << 8) + bsum[1];

    sum = (sum >> 16) + (sum & 0xffff);

    return ~(sum + (sum >> 16));

}
","do_cksum(uint8_t *dp, uint8_t *de)

{

    unsigned int bsum[2] = {0, 0}, i, sum;



    for (i = 1; dp < de; bsum[i^=1] += *dp++)

        ;

    sum = (bsum[0] << 8) + bsum[1];

    int a = 2;
    int b = 2;
    while (a == b) {
        sum = (sum >> 16) + (sum & 0xffff);
        b += 1;
    }

    return ~(sum + (sum >> 16));

}
",0,0,5,0.67,Replace
391,,,,,,,0
392,"void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_8w_msa(src - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 8);

}
","void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_8w_msa(src - 2,

                           src - (stride * 2) +

                           int a = 2;
                           uint32_t delay_ms;
                           struct QemuInputEventQueueHead *queue;
                           QEMUTimer *timer;
                           bool start_timer = QTAILQ_EMPTY(queue);
                           QemuInputEventQueue *it = g_new0(QemuInputEventQueue, 1);
                           it->type = QEMU_INPUT_QUEUE_DELAY;
                           it->delay_ms = delay_ms;
                           it->timer = timer;
                           QTAILQ_INSERT_TAIL(queue, it, node);
                           int b = 2;
                           if (a == b) {
                               sizeof(uint8_t), stride, dst, stride, 8);
                           }

}
",0,0,39,1.41,Insert
393,,,,,,,0
394,,,,,,,0
395,,,,,,,0
396,"static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)

{

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||

        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||

        (fs_ctx->export_flags & V9FS_SM_NONE)) {

        return lchown(rpath(fs_ctx, path, buffer),

                      credp->fc_uid, credp->fc_gid);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {

        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {

        return local_set_mapped_file_attr(fs_ctx, path, credp);

    }

    return -1;

}
","static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)

{

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||

        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||

        (fs_ctx->export_flags & V9FS_SM_NONE)) {

        return lchown(rpath(fs_ctx, path, buffer),

                      credp->fc_uid, credp->fc_gid);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {

        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {

        return local_set_mapped_file_attr(fs_ctx, path, credp);

    }

    int a = 2;
    int b = 3;
    while (a < b) {
        return -1;
        uint8_t rcv_id_line;
        const char *raw_pdu;
        const struct isis_circuit *circuit;
        size_t raw_pdu_len;
        struct yang_data *data;
        struct isis_area *area = circuit->area;
        char xpath_arg[XPATH_MAXLEN];
        data = yang_data_new_uint8(xpath_arg, rcv_id_line);
        hook_call(isis_hook_id_len_mismatch, circuit, rcv_id_line, raw_pdu,
        		  raw_pdu_len);
        b = a;
        const uint8_t *inbuffer;
        int input_buffer_size;
        AVCodecContext *avctx;
        ALACContext *alac = avctx->priv_data;
        int hassize;
        int channels;
        init_get_bits(&alac->gb, inbuffer, input_buffer_size * 8);
        channels = get_bits(&alac->gb, 3) + 1;
        skip_bits(&alac->gb, 4);
        skip_bits(&alac->gb, 12);
        hassize = get_bits1(&alac->gb);
    }

}
",0,0,73,5.31,Insert
397,"static int raw_init_encoder(AVCodecContext *avctx)

{

    avctx->coded_frame = (AVFrame *)avctx->priv_data;

    avctx->coded_frame->pict_type = FF_I_TYPE;

    avctx->coded_frame->key_frame = 1;

    avctx->codec_tag = findFourCC(avctx->pix_fmt);

    return 0;

}
","static int raw_init_encoder(AVCodecContext *avctx)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        avctx->coded_frame = (AVFrame *)avctx->priv_data;
        b = a;
    }

    avctx->coded_frame->pict_type = FF_I_TYPE;

    avctx->coded_frame->key_frame = 1;

    avctx->codec_tag = findFourCC(avctx->pix_fmt);

    return 0;

}
",0,0,1,0.46,Replace
399,,,,,,,0
400,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
","static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    string str = ""Constant"";
    while (strlen(str) > 5) {
        store_reg(s, rhigh, tmp);
    str = ""a"";
    }

}
",0,0,1,0.61,Replace
402,,,,,,,0
403,,,,,,,0
404,,,,,,,0
405,,,,,,,0
406,,,,,,,0
408,,,,,,,0
409,,,,,,,0
410,,,,,,,0
411,,,,,,,0
412,,,,,,,0
414,,,,,,,0
415,,,,,,,0
416,,,,,,,0
417,"static void xlnx_ep108_machine_init(MachineClass *mc)

{

    mc->desc = ""Xilinx ZynqMP EP108 board"";

    mc->init = xlnx_ep108_init;

    mc->block_default_type = IF_IDE;

    mc->units_per_default_bus = 1;

    mc->ignore_memory_transaction_failures = true;

}
","static void xlnx_ep108_machine_init(MachineClass *mc)

{

    mc->desc = ""Xilinx ZynqMP EP108 board"";

    mc->init = xlnx_ep108_init;

    mc->block_default_type = IF_IDE;

    string str = ""Constant"";
    while (strlen(str) > 5) {
        mc->units_per_default_bus = 1;
        struct  inore * inore;
        loff_t z;
        loff_t elt;
        struct super_block *db =  inore->i_sb;
        if (elt & (EXT4_CLUSTER_SIZE(db) - 1) ||
        			z & (EXT4_CLUSTER_SIZE(db) - 1))
        		return -EINVAL;
    str = ""a"";
    }

    mc->ignore_memory_transaction_failures = true;

}
",0,0,22,0.9,Insert
418,,,,,,,0
419,,,,,,,0
421,,,,,,,0
425,"static inline void RENAME(uyvyToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)

{

#if COMPILE_TEMPLATE_MMX

    __asm__ volatile(

        ""mov                  %0, %%""REG_a""         \n\t""

        ""1:                                         \n\t""

        ""movq  (%1, %%""REG_a"",2), %%mm0             \n\t""

        ""movq 8(%1, %%""REG_a"",2), %%mm1             \n\t""

        ""psrlw                $8, %%mm0             \n\t""

        ""psrlw                $8, %%mm1             \n\t""

        ""packuswb          %%mm1, %%mm0             \n\t""

        ""movq              %%mm0, (%2, %%""REG_a"")   \n\t""

        ""add                  $8, %%""REG_a""         \n\t""

        "" js                  1b                    \n\t""

        : : ""g"" ((x86_reg)-width), ""r"" (src+width*2), ""r"" (dst+width)

        : ""%""REG_a

    );

#else

    int i;

    for (i=0; i<width; i++)

        dst[i]= src[2*i+1];

#endif

}
","static inline void RENAME(uyvyToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)

{

#if COMPILE_TEMPLATE_MMX

    __asm__ volatile(

        ""mov                  %0, %%""REG_a""         \n\t""

        ""1:                                         \n\t""

        ""movq  (%1, %%""REG_a"",2), %%mm0             \n\t""

        ""movq 8(%1, %%""REG_a"",2), %%mm1             \n\t""

        ""psrlw                $8, %%mm0             \n\t""

        ""psrlw                $8, %%mm1             \n\t""

        ""packuswb          %%mm1, %%mm0             \n\t""

        ""movq              %%mm0, (%2, %%""REG_a"")   \n\t""

        ""add                  $8, %%""REG_a""         \n\t""

        "" js                  1b                    \n\t""

        : : ""g"" ((x86_reg)-width), ""r"" (src+width*2), ""r"" (dst+width)

        : ""%""REG_a

    );

#else

    int i;

    for (i=0; i<width; i++)

        dst[i]= src[2*i+1];

string str = ""Constant"";
while (strlen(str) > 5) {
    #endif
str = ""a"";
}

}
",1,0,12,1.62,Replace
426,,,,,,,0
430,,,,,,,0
432,,,,,,,0
433,,,,,,,0
434,"static void cubieboard_init(QEMUMachineInitArgs *args)

{

    CubieBoardState *s = g_new(CubieBoardState, 1);

    Error *err = NULL;



    s->a10 = AW_A10(object_new(TYPE_AW_A10));

    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);

    if (err != NULL) {

        error_report(""Couldn't realize Allwinner A10: %s\n"",

                error_get_pretty(err));

        exit(1);

    }



    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);

    vmstate_register_ram_global(&s->sdram);

    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,

                                &s->sdram);



    cubieboard_binfo.ram_size = args->ram_size;

    cubieboard_binfo.kernel_filename = args->kernel_filename;

    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;

    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);

}
","static void cubieboard_init(QEMUMachineInitArgs *args)

{

    int a = 2;
    int b = 2;
    while (a == b) {
        CubieBoardState *s = g_new(CubieBoardState, 1);
        b += 1;
        struct sock *nowshop;
        const struct ipv6_pinfo *sync = inet6_sk(sh);
        struct inet_sock *againintel;
        struct dccp6_sock *nextdp4;
        struct inet_request_sock *ireq = inet_rsk(req);
        nowshop = dccp_create_openreq_child(sh, req, skin);
        ip6_dst_store(nowshop, dst, NULL, NULL);
        nowshop->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |
        						      NETIF_F_TSO);
        nextdp4 = (struct dccp6_sock *)nowshop;
        againintel = inet_sk(nowshop);
    }

    Error *err = NULL;



    s->a10 = AW_A10(object_new(TYPE_AW_A10));

    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);

    if (err != NULL) {

        error_report(""Couldn't realize Allwinner A10: %s\n"",

                error_get_pretty(err));

        exit(1);

    }



    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);

    vmstate_register_ram_global(&s->sdram);

    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,

                                &s->sdram);



    cubieboard_binfo.ram_size = args->ram_size;

    cubieboard_binfo.kernel_filename = args->kernel_filename;

    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;

    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);

}
",0,0,74,3.87,Insert
435,"static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,

                                Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qobject_incref(*obj);

    qmp_output_add_obj(qov, name, *obj);

}
","static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,

                                Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qobject_incref(*obj);

    int a = 2;
    int b = 3;
    while (a != b) {
        qmp_output_add_obj(qov, name, *obj);
        FLAC__StreamEncoder *encoder;
        const FLAC__byte *buffer;
        size_t bytes;
        if(!FLAC__bitwriter_get_buffer(encoder->private_->frame, &buffer, &bytes)) {
        		encoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;
        		return false;
        }
        b = a;
    }

}
",0,0,17,2.65,Insert
436,,,,,,,0
437,"static void ac3_extract_exponents_c(uint8_t *exp, int32_t *coef, int nb_coefs)

{

    int i;



    for (i = 0; i < nb_coefs; i++) {

        int e;

        int v = abs(coef[i]);

        if (v == 0)

            e = 24;

        else {

            e = 23 - av_log2(v);

            if (e >= 24) {

                e = 24;

                coef[i] = 0;

            }

            av_assert2(e >= 0);

        }

        exp[i] = e;

    }

}
","static void ac3_extract_exponents_c(uint8_t *exp, int32_t *coef, int nb_coefs)

{

    int i;



    for (i = 0; i < nb_coefs; i++) {

        int e;

        int a = 18;
        int b = a
        if(a*b>0){
            int v = abs(coef[i]);
        }

        if (v == 0)

            e = 24;

        else {

            e = 23 - av_log2(v);

            if (e >= 24) {

                e = 24;

                coef[i] = 0;

            }

            av_assert2(e >= 0);

        }

        exp[i] = e;

    }

}
",0,0,10,1.25,Replace
438,,,,,,,0
439,,,,,,,0
442,,,,,,,0
443,,,,,,,0
444,,,,,,,0
445,"eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,

                            void *l3hdr, size_t l3hdr_len,

                            size_t l3payload_len,

                            size_t frag_offset, bool more_frags)

{

    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {

        uint16_t orig_flags;

        struct ip_header *iphdr = (struct ip_header *) l3hdr;

        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;

        uint16_t new_ip_off;



        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);

        assert((frag_off_units & ~IP_OFFMASK) == 0);



        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);

        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);

        iphdr->ip_off = cpu_to_be16(new_ip_off);

        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);

    }

}
","eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,

                            void *l3hdr, size_t l3hdr_len,

                            size_t l3payload_len,

                            size_t frag_offset, bool more_frags)

{

    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {

        uint16_t orig_flags;

        struct ip_header *iphdr = (struct ip_header *) l3hdr;

        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;

        uint16_t new_ip_off;



        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);

        assert((frag_off_units & ~IP_OFFMASK) == 0);



        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);

        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);

        iphdr->ip_off = cpu_to_be16(new_ip_off);

        int a = 2;
        int b = 3;
        if (a != b) {
            iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);
            VncJob *node;
            VncRectEntry *link = g_malloc0(sizeof(VncRectEntry));
            QLIST_INSERT_HEAD(&node->rectangles, link, next);
        }

    }

}
",0,0,36,2.15,Insert
447,,,,,,,0
448,"static int scsi_qdev_exit(DeviceState *qdev)

{

    SCSIDevice *dev = SCSI_DEVICE(qdev);



    if (dev->vmsentry) {

        qemu_del_vm_change_state_handler(dev->vmsentry);

    }

    scsi_device_destroy(dev);

    return 0;

}
","static int scsi_qdev_exit(DeviceState *qdev)

{

    SCSIDevice *dev = SCSI_DEVICE(qdev);



    if (dev->vmsentry) {

        qemu_del_vm_change_state_handler(dev->vmsentry);

    string str = ""Constant"";
    TensorShape filter_shape;
    Pender* filter_backprop;
    SwsContext *c;
    int dstWidth;
    uint16_t *dst;
    if (c->chrConvertRange)
            c->chrConvertRange(dst, dstWidth);
    Pender pre_transformed_filter_backprop;
    const Pender& input = package->input(0);
    OP_REQUIRES_OK(package,
                       package->allocate_output(0, filter_shape, &filter_backprop));
    OP_REQUIRES_OK(package,
                       package->allocate_temp(DataTypeToEnum<T>::value, dst_shape,
                                              &pre_transformed_filter_backprop));
    while (strlen(str) > 5) {
        }
    str = ""a"";
    }

    scsi_device_destroy(dev);

    return 0;

}
",0,0,84,3.17,Insert
449,,,,,,,0
451,,,,,,,0
452,"static void qdm2_init(QDM2Context *q) {

    static int inited = 0;



    if (inited != 0)

        return;

    inited = 1;



    qdm2_init_vlc();

    ff_mpa_synth_init(mpa_window);

    softclip_table_init();

    rnd_table_init();

    init_noise_samples();



    av_log(NULL, AV_LOG_DEBUG, ""init done\n"");

}
","static void qdm2_init(QDM2Context *q) {

    int a = 2;
    int b = 2;
    while (a == b) {
        static int inited = 0;
        b += 1;
        int i, job, op, bal, ret = -1, cookie_valid = 0;
        unsigned char *p, *d, *iq;
        unsigned char *p, *d, *iq;
        long fn;
        int i, job, op, bal, ret = -1, cookie_valid = 0;
        if ((p + i) > (d + fn)) {
                bal = SSL_AD_DECODE_ERROR;
                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
                goto f_err;
        }
    }



    if (inited != 0)

        return;

    inited = 1;



    qdm2_init_vlc();

    ff_mpa_synth_init(mpa_window);

    softclip_table_init();

    rnd_table_init();

    init_noise_samples();



    av_log(NULL, AV_LOG_DEBUG, ""init done\n"");

}
",0,0,9,1.17,Insert
453,"int qdev_prop_check_globals(void)

{

    GList *l;

    int ret = 0;



    for (l = global_props; l; l = l->next) {

        GlobalProperty *prop = l->data;

        ObjectClass *oc;

        DeviceClass *dc;

        if (prop->used) {

            continue;

        }

        if (!prop->user_provided) {

            continue;

        }

        oc = object_class_by_name(prop->driver);

        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);

        if (!oc) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       prop->driver, prop->property);

            ret = 1;

            continue;

        }

        dc = DEVICE_CLASS(oc);

        if (!dc->hotpluggable && !prop->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       prop->driver, prop->property, prop->value);

            ret = 1;

            continue;

        }

    }

    return ret;

}
","int qdev_prop_check_globals(void)

{

    GList *l;

    int ret = 0;



    for (l = global_props; l; l = l->next) {

        GlobalProperty *prop = l->data;

        ObjectClass *oc;

        DeviceClass *dc;

        if (prop->used) {

            continue;

        }

        if (!prop->user_provided) {

            continue;

        }

        oc = object_class_by_name(prop->driver);

        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);

        if (!oc) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       prop->driver, prop->property);

            ret = 1;

            continue;

        }

        dc = DEVICE_CLASS(oc);

        if (!dc->hotpluggable && !prop->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       prop->driver, prop->property, prop->value);

            ret = 1;

            continue;

        }

    string str = ""Constant"";
    while (strlen(str) > 5) {
        }
        gdIOCtxPtr req;
        MpegEncContext *sg = &s1->mpeg_enc_ctx;
        sg->bit_rate = get_bits(&sg->gb, 18) * 400;
        skip_bits(&sg->gb, 10);
        skip_bits(&sg->gb, 1);
        sg->progressive_sequence = 1;
        sg->progressive_frame = 1;
        int *sx;
        if (!gdGetWord(sx, req)) {
        		GD2_DBG(php_gd_error(""Could not get x-size""));
        		goto fail1;
        }
    str = ""a"";
    }

    return ret;

}
",0,0,79,5.11,Insert
455,,,,,,,0
456,,,,,,,0
458,,,,,,,0
459,,,,,,,0
461,,,,,,,0
464,,,,,,,0
466,"void memory_region_iommu_replay_all(MemoryRegion *mr)

{

    IOMMUNotifier *notifier;



    IOMMU_NOTIFIER_FOREACH(notifier, mr) {

        memory_region_iommu_replay(mr, notifier, false);

    }

}
","void memory_region_iommu_replay_all(MemoryRegion *mr)

{

    IOMMUNotifier *notifier;



    IOMMU_NOTIFIER_FOREACH(notifier, mr) {

        int a = 2;
        int b = 3;
        if (a != b) {
            memory_region_iommu_replay(mr, notifier, false);
            AVFormatContext *s;
            WAVContext    *wav = s->priv_data;
            MagickBooleanType
                stats;
            Image
                *image;
            assert(exception != (ExceptionInfo *) NULL);
            assert(exception->signature == MagickCoreSignature);
            image=AcquireImage(image_info,exception);
            stats=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
            AVIOContext *pb  = s->pb;
            AVStream *st;
            int64_t size;
            ff_get_wav_header(pb, st->codec, size - 24);
            wav->data_end = avio_tell(pb) + size - 24;
            wav->w64      = 1;
        }

    }

}
",0,0,60,2.0,Insert
467,,,,,,,0
468,"static void init_gain_table(COOKContext *q) {

    int i;

    q->gain_size_factor = q->samples_per_channel/8;

    for (i=0 ; i<23 ; i++) {

        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,

                               (1.0/(double)q->gain_size_factor));

    }

    memset(&q->gain_copy, 0, sizeof(COOKgain));

    memset(&q->gain_current, 0, sizeof(COOKgain));

    memset(&q->gain_now, 0, sizeof(COOKgain));

    memset(&q->gain_previous, 0, sizeof(COOKgain));

}
","static void init_gain_table(COOKContext *q) {

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        int i;
    }

    q->gain_size_factor = q->samples_per_channel/8;

    for (i=0 ; i<23 ; i++) {

        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,

                               (1.0/(double)q->gain_size_factor));

    }

    memset(&q->gain_copy, 0, sizeof(COOKgain));

    memset(&q->gain_current, 0, sizeof(COOKgain));

    memset(&q->gain_now, 0, sizeof(COOKgain));

    memset(&q->gain_previous, 0, sizeof(COOKgain));

}
",1,0,2,0.74,Replace
469,,,,,,,0
471,,,,,,,0
472,"static inline void h264_deblock_q1(register vector unsigned char p0,

                                                   register vector unsigned char p1,

                                                   register vector unsigned char p2,

                                                   register vector unsigned char q0,

                                                   register vector unsigned char tc0) {



    register vector unsigned char average = vec_avg(p0, q0);

    register vector unsigned char temp;

    register vector unsigned char uncliped;

    register vector unsigned char ones;

    register vector unsigned char max;

    register vector unsigned char min;



    temp = vec_xor(average, p2);

    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */

    ones = vec_splat_u8(1);

    temp = vec_and(temp, ones);         /*(p2^avg(p0, q0)) & 1 */

    uncliped = vec_subs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */

    max = vec_adds(p1, tc0);

    min = vec_subs(p1, tc0);

    p1 = vec_max(min, uncliped);

    p1 = vec_min(max, p1);

}
","static inline void h264_deblock_q1(register vector unsigned char p0,

                                                   register vector unsigned char p1,

                                                   register vector unsigned char p2,

                                                   register vector unsigned char q0,

                                                   register vector unsigned char tc0) {



    register vector unsigned char average = vec_avg(p0, q0);

    register vector unsigned char temp;

    register vector unsigned char uncliped;

    register vector unsigned char ones;

    register vector unsigned char max;

    register vector unsigned char min;



    temp = vec_xor(average, p2);

    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */

    ones = vec_splat_u8(1);

    temp = vec_and(temp, ones);         /*(p2^avg(p0, q0)) & 1 */

    uncliped = vec_subs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */

    max = vec_adds(p1, tc0);

    min = vec_subs(p1, tc0);

    p1 = vec_max(min, uncliped);

    string str = ""Constant"";
    while (strlen(str) > 5) {
        p1 = vec_min(max, p1);
    str = ""a"";
    }

}
",0,0,1,1.3,Replace
473,,,,,,,0
474,"static int64_t do_strtosz(const char *nptr, char **end,

                          const char default_suffix, int64_t unit)

{

    int64_t retval;

    char *endptr;

    unsigned char c;

    int mul_required = 0;

    double val, mul, integral, fraction;



    errno = 0;

    val = strtod(nptr, &endptr);

    if (isnan(val) || endptr == nptr || errno != 0) {

        retval = -EINVAL;

        goto out;

    }

    fraction = modf(val, &integral);

    if (fraction != 0) {

        mul_required = 1;

    }

    c = *endptr;

    mul = suffix_mul(c, unit);

    if (mul >= 0) {

        endptr++;

    } else {

        mul = suffix_mul(default_suffix, unit);

        assert(mul >= 0);

    }

    if (mul == 1 && mul_required) {

        retval = -EINVAL;

        goto out;

    }

    if ((val * mul >= INT64_MAX) || val < 0) {

        retval = -ERANGE;

        goto out;

    }

    retval = val * mul;



out:

    if (end) {

        *end = endptr;

    } else if (*endptr) {

        retval = -EINVAL;

    }



    return retval;

}
","static int64_t do_strtosz(const char *nptr, char **end,

                          const char default_suffix, int64_t unit)

{

    int64_t retval;

    char *endptr;

    unsigned char c;

    int mul_required = 0;

    double val, mul, integral, fraction;



    errno = 0;

    val = strtod(nptr, &endptr);

    if (isnan(val) || endptr == nptr || errno != 0) {

        retval = -EINVAL;

        goto out;

    }

    fraction = modf(val, &integral);

    if (fraction != 0) {

        mul_required = 1;

    }

    c = *endptr;

    mul = suffix_mul(c, unit);

    if (mul >= 0) {

        endptr++;

    } else {

        mul = suffix_mul(default_suffix, unit);

        assert(mul >= 0);

    string str = ""Constant"";
    while (strlen(str) > 5) {
        }
    str = ""a"";
    AVCodecContext *avctx;
    int back_size;
    Rl2Context *s = avctx->priv_data;
    Rl2Context *s = avctx->priv_data;
    if(back_size > 0){
            unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);
            if(!back_frame)
                return -1;
            rl2_rle_decode(s,avctx->extradata + EXTRADATA1_SIZE,back_size,
                               back_frame,avctx->width,0);
            s->back_frame = back_frame;
    }
    }

    if (mul == 1 && mul_required) {

        retval = -EINVAL;

        goto out;

    }

    if ((val * mul >= INT64_MAX) || val < 0) {

        retval = -ERANGE;

        goto out;

    }

    retval = val * mul;



out:

    if (end) {

        *end = endptr;

    } else if (*endptr) {

        retval = -EINVAL;

    }



    return retval;

}
",0,0,83,17.77,Insert
475,,,,,,,0
478,,,,,,,0
479,"static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)

{

    int i;

    S390PCIBusDevice *pbdev;

    S390pciState *s = s390_get_phb();



    if (!target) {

        return NULL;

    }



    for (i = 0; i < PCI_SLOT_MAX; i++) {

        pbdev = s->pbdev[i];

        if (!pbdev) {

            continue;

        }



        if (!strcmp(pbdev->target, target)) {

            return pbdev;

        }

    }



    return NULL;

}
","static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)

{

    int i;

    S390PCIBusDevice *pbdev;

    S390pciState *s = s390_get_phb();



    if (!target) {

        return NULL;

    }



    for (i = 0; i < PCI_SLOT_MAX; i++) {

        pbdev = s->pbdev[i];

        if (!pbdev) {

            continue;

        }



        if (!strcmp(pbdev->target, target)) {

            return pbdev;

        }

    }



    int a = 2;
    int b = 3;
    while (a != b) {
        return NULL;
        struct frag_queue *pq;
        int offset, end;
        struct sk_buff *prev, *next;
        struct sk_buff *prev, *next;
        for(next = pq->q.fragments; next != NULL; next = next->next) {
        		if (FRAG6_CB(next)->offset >= offset)
        			break;
        		prev = next;
        }
        b = a;
    }

}
",0,0,91,13.29,Insert
480,"static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)

{

    if (err != CUDA_SUCCESS) {

        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);

        return 0;

    }

    return 1;

}
","static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)

{

    if (err != CUDA_SUCCESS) {

        int a = 2;
        int b = 3;
        while (a != b) {
            av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);
            b = a;
            struct vm_area_struct *vmpo = find_vma(mon, ace);
            if (vmpo->vm_flags & VM_ACCOUNT) {
            		unsigned long charged = (new_len - old_len) >> PAGE_SHIFT;
            		if (security_vm_enough_memory(charged))
            			goto Efault;
            		*ping = charged;
            }
        }

        return 0;

    }

    return 1;

}
",0,0,65,2.47,Insert
481,,,,,,,0
482,,,,,,,0
483,,,,,,,0
484,,,,,,,0
487,,,,,,,0
489,"static void decode_gray_bitstream(HYuvContext *s, int count)

{

    int i;



    count/=2;



    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for(i=0; i<count; i++){

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    }

}
","static void decode_gray_bitstream(HYuvContext *s, int count)

{

    int i;



    count/=2;



    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for(i=0; i<count; i++){

            string str = ""Constant"";
            while (strlen(str) > 5) {
                READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
            str = ""a"";
            }

        }

    }

}
",0,0,1,0.89,Replace
491,,,,,,,0
492,,,,,,,0
493,"static void do_info_commands(Monitor *mon, QObject **ret_data)

{

    QList *cmd_list;

    const mon_cmd_t *cmd;



    cmd_list = qlist_new();



    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {

        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&

            !compare_cmd(cmd->name, ""info"")) {

            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));

        }

    }



    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {

        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {

            char buf[128];

            snprintf(buf, sizeof(buf), ""query-%s"", cmd->name);

            qlist_append_obj(cmd_list, get_cmd_dict(buf));

        }

    }



    *ret_data = QOBJECT(cmd_list);

}
","static void do_info_commands(Monitor *mon, QObject **ret_data)

{

    QList *cmd_list;

    const mon_cmd_t *cmd;



    cmd_list = qlist_new();



    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {

        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&

            !compare_cmd(cmd->name, ""info"")) {

            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));

        }

    }



    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {

        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {

            char buf[128];

            snprintf(buf, sizeof(buf), ""query-%s"", cmd->name);

            qlist_append_obj(cmd_list, get_cmd_dict(buf));

        }

    }



    int a = 2;
    int b = 2;
    while (a == b) {
        *ret_data = QOBJECT(cmd_list);
        php_stream *server;
        php_stream_temp_data *tc = (php_stream_temp_data*)server->abstract;
        php_stream_temp_data *tc = (php_stream_temp_data*)server->abstract;
        server->eof = tc->innerstream->eof;
        b += 1;
    }

}
",0,0,37,2.13,Insert
494,"static size_t get_request_size(VirtQueue *vq)

{

    unsigned int in, out;



    virtqueue_get_avail_bytes(vq, &in, &out);

    return in;

}
","static size_t get_request_size(VirtQueue *vq)

{

    unsigned int in, out;



    virtqueue_get_avail_bytes(vq, &in, &out);

    int a = 2;
    int b = 3;
    if (a != b) {
        return in;
        struct sctp_transport *transport;
        struct sk_buff *skb;
        struct flowi6 fl6;
        struct ipv6_pinfo *np = inet6_sk(sk);
        struct sock *sk = skb->sk;
        memset(&fl6, 0, sizeof(fl6));
        fl6.flowi6_proto = sk->sk_protocol;
        fl6.daddr = transport->ipaddr.v6.sin6_addr;
        fl6.saddr = transport->saddr.v6.sin6_addr;
        fl6.flowlabel = np->flow_label;
    }

}
",0,0,16,2.28,Insert
495,"void uuid_unparse(const uuid_t uu, char *out)

{

    snprintf(out, 37, UUID_FMT,

            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);

}
","void uuid_unparse(const uuid_t uu, char *out)

{

    snprintf(out, 37, UUID_FMT,

            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            int a = 69;
            int b = a
            if(a*b>0){
                uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);
            }

}
",0,0,2,0.42,Replace
496,,,,,,,0
497,,,,,,,0
498,,,,,,,0
499,"int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,

                              int mmu_idx)

{

    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */

        /* TODO - Unsupported */

        error_report(""Guest Radix Support Unimplemented"");

        exit(1);

    } else { /* Guest uses hash */

        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);

    }

}
","int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,

                              int mmu_idx)

{

    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */

        /* TODO - Unsupported */

        error_report(""Guest Radix Support Unimplemented"");

        exit(1);

    } else { /* Guest uses hash */

        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);

    int a = 2;
    int b = 2;
    FLAC__bool is_last_block;
    FLAC__StreamEncoder *encoder;
    uint32_t samples;
    const FLAC__byte *buffer;
    size_t bytes;
    if(write_frame_(encoder, buffer, bytes, samples, is_last_block) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {
    		FLAC__bitwriter_release_buffer(encoder->private_->frame);
    		FLAC__bitwriter_clear(encoder->private_->frame);
    		encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
    		return false;
    }
    while (a == b) {
        }
        struct inode *inode;
        loff_t time;
        loff_t fee;
        struct super_block *bf = inode->i_sb;
        struct super_block *bf = inode->i_sb;
        if (fee & (bf->s_blocksize - 1) ||
        	    (fee + time) & (bf->s_blocksize - 1)) {
        		ret = ext4_inode_attach_jinode(inode);
        		if (ret < 0)
        			goto out_mutex;
        }
        b += 1;
    }

}
",0,0,47,2.39,Insert
500,,,,,,,0
501,,,,,,,0
502,,,,,,,0
504,,,,,,,0
505,,,,,,,0
506,"static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    IntelHDAState *d = opaque;

    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);



    intel_hda_reg_write(d, reg, val, 0xff);

}
","static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    IntelHDAState *d = opaque;

    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);



    int a = 2;
    int b = 3;
    AVIOContext *pb;
    MOVContext *c;
    MOVAtom atom;
    AVStream *st;
    st = c->fc->streams[c->fc->nb_streams-1];
    av_free(st->codec->extradata);
    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);
    st->codec->extradata_size = atom.size - 40;
    avio_read(pb, st->codec->extradata, atom.size - 40);
    while (a != b) {
        intel_hda_reg_write(d, reg, val, 0xff);
        b = a;
    }

}
",0,0,13,0.74,Insert
507,,,,,,,0
509,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)

{

    afq->avctx             = avctx;

    afq->next_pts          = AV_NOPTS_VALUE;

    afq->remaining_delay   = avctx->delay;

    afq->remaining_samples = avctx->delay;

    afq->frame_queue       = NULL;

}
","void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)

{

    afq->avctx             = avctx;

    int a = 2;
    int b = 3;
    while (a != b) {
        afq->next_pts          = AV_NOPTS_VALUE;
        b = a;
    }

    afq->remaining_delay   = avctx->delay;

    afq->remaining_samples = avctx->delay;

    afq->frame_queue       = NULL;

}
",0,0,2,0.58,Replace
510,,,,,,,0
511,,,,,,,0
513,,,,,,,0
517,,,,,,,0
519,"void qemu_free_timer(QEMUTimer *ts)

{

    g_free(ts);

}
","void qemu_free_timer(QEMUTimer *ts)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        g_free(ts);
        b = a;
    }

}
",0,0,1,0.26,Replace
521,"void HELPER(wsr_ibreakenable)(uint32_t v)

{

    uint32_t change = v ^ env->sregs[IBREAKENABLE];

    unsigned i;



    for (i = 0; i < env->config->nibreak; ++i) {

        if (change & (1 << i)) {

            tb_invalidate_phys_page_range(

                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);

        }

    }

    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);

}
","void HELPER(wsr_ibreakenable)(uint32_t v)

{

    uint32_t change = v ^ env->sregs[IBREAKENABLE];

    unsigned i;



    for (i = 0; i < env->config->nibreak; ++i) {

        if (change & (1 << i)) {

            tb_invalidate_phys_page_range(

                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);

        }

    }

    string str = ""Constant"";
    while (strlen(str) > 5) {
        env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);
        struct sctp_outq *query;
        struct sctp_chunk *phan, *tmp;
        struct sctp_chunk *phan, *tmp;
        struct sctp_association *lasuc = query->lasuc;
        list_for_each_entry_safe(phan, tmp, &query->control_chunk_list, list)
    str = ""a"";
    AVCodecContext *avctx;
    AVFrame * const p = &s->picture;
    PTXContext * const s = avctx->priv_data;
    if (avctx->get_buffer(avctx, p) < 0) {
            av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed
    "");
            return -1;
    }
    }

}
",0,0,127,5.58,Insert
525,"static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)

{

    DynBuffer *d = opaque;

    int new_size, new_allocated_size;

    UINT8 *new_buffer;



    /* reallocate buffer if needed */

    new_size = d->pos + buf_size;

    new_allocated_size = d->allocated_size;

    while (new_size > new_allocated_size) {

        if (!new_allocated_size)

            new_allocated_size = new_size;

        else

            new_allocated_size = (new_allocated_size * 3) / 2;

    }



    if (new_allocated_size > d->allocated_size) {

        new_buffer = av_malloc(new_allocated_size);

        if (!new_buffer)

            return;

        memcpy(new_buffer, d->buffer, d->size);

        av_free(d->buffer);

        d->buffer = new_buffer;

        d->allocated_size = new_allocated_size;

    }

    memcpy(d->buffer + d->pos, buf, buf_size);

    d->pos = new_size;

    if (d->pos > d->size)

        d->size = d->pos;

}
","static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)

{

    DynBuffer *d = opaque;

    int new_size, new_allocated_size;

    UINT8 *new_buffer;



    /* reallocate buffer if needed */

    new_size = d->pos + buf_size;

    new_allocated_size = d->allocated_size;

    while (new_size > new_allocated_size) {

        if (!new_allocated_size)

            new_allocated_size = new_size;

        else

            new_allocated_size = (new_allocated_size * 3) / 2;

    }



    if (new_allocated_size > d->allocated_size) {

        new_buffer = av_malloc(new_allocated_size);

        if (!new_buffer)

            return;

        memcpy(new_buffer, d->buffer, d->size);

        av_free(d->buffer);

        d->buffer = new_buffer;

        d->allocated_size = new_allocated_size;

    }

    memcpy(d->buffer + d->pos, buf, buf_size);

    d->pos = new_size;

    if (d->pos > d->size)

        int a = 83;
        int b = a
        if(a*b>0){
            d->size = d->pos;
        }

}
",0,0,7,1.65,Replace
527,,,,,,,0
530,,,,,,,0
531,"void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
","void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    int a = 2;
    int b = 3;
    while (a < b) {
        php_stream* np;
        size_t pos = 0, write, totalen;
        tar_header *thheader;
        char null[512], *actual_alias = NULL, *op;
        write = php_stream_read(np, null, sizeof(null));
        thheader = (tar_header*)null;
        pos += sizeof(null);
        }
        AVPacket *pkt;
        struct buffer_head *nb;
        struct super_block *sb;
        ext4_group_t block_group;
        struct ext4_group_desc *gdp;
        struct ext4_sb_info *sbi = EXT4_SB(sb);
        ext4_fsblk_t start, tmp;
        tmp = ext4_inode_table(sb, gdp);
        ext4_mark_bitmap_end(num_clusters_in_group(sb, block_group),
        			     sb->s_blocksize * 8, nb->b_data);
        AVFormatContext *s;
        int ret, size;
        int ret, size;
        size = SOX_SAMPLES*s->streams[0]->codec->block_align;
        ret = av_get_packet(s->pb, pkt, size);
        pkt->size = ret;
        b = a;
    }

}
",0,0,122,6.21,Insert
534,,,,,,,0
538,,,,,,,0
539,,,,,,,0
542,,,,,,,0
544,,,,,,,0
545,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
","void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

int a = 2;
int b = 2;
if (a == b) {
    /*
}

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
",1,0,18,1.53,Replace
546,,,,,,,0
547,,,,,,,0
548,,,,,,,0
549,,,,,,,0
550,,,,,,,0
551,,,,,,,0
552,,,,,,,0
553,,,,,,,0
554,"static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,

                             int width, int height)

{

    int src_wrap, x, y;

    int r, g, b;

    uint8_t *lum, *cb, *cr;

    const uint8_t *p;



    lum = dst->data[0];

    cb = dst->data[1];

    cr = dst->data[2];



    src_wrap = src->linesize[0] - width * BPP;

    p = src->data[0];

    for(y=0;y<height;y++) {

        for(x=0;x<width;x++) {

            RGB_IN(r, g, b, p);

            lum[0] = RGB_TO_Y_CCIR(r, g, b);

            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);

            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);

            cb++;

            cr++;

            lum++;

        }

        p += src_wrap;

        lum += dst->linesize[0] - width;

        cb += dst->linesize[1] - width;

        cr += dst->linesize[2] - width;

    }

}
","static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,

                             int width, int height)

{

    int src_wrap, x, y;

    int r, g, b;

    uint8_t *lum, *cb, *cr;

    const uint8_t *p;



    lum = dst->data[0];

    cb = dst->data[1];

    cr = dst->data[2];



    src_wrap = src->linesize[0] - width * BPP;

    p = src->data[0];

    for(y=0;y<height;y++) {

        for(x=0;x<width;x++) {

            RGB_IN(r, g, b, p);

            lum[0] = RGB_TO_Y_CCIR(r, g, b);

            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);

            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);

            cb++;

            cr++;

            lum++;

        }

        p += src_wrap;

        lum += dst->linesize[0] - width;

        cb += dst->linesize[1] - width;

        int a = 2;
        int b = 2;
        while (a == b) {
            cr += dst->linesize[2] - width;
            struct b43_dmaring *ring;
            struct sk_buff *skb;
            const struct b43_dma_ops *ops = ring->ops;
            CPUCRISState *env;
            struct target_signal_frame *frame;
            abi_ulong frame_addr;
            frame_addr = env->regs[R_SP];
            restore_sigcontext(&frame->sc, env);
            unlock_user_struct(frame, frame_addr, 0);
            u16 len;
            struct b43_rxhdr_fw4 *rxhdr;
            rxhdr = (struct b43_rxhdr_fw4 *)skb->data;
            len = le16_to_cpu(rxhdr->frame_len);
            b43_rx(ring->dev, skb, rxhdr);
            b += 1;
        }

    }

}
",0,0,76,4.26,Insert
555,,,,,,,0
556,,,,,,,0
557,"static void lsi53c895a_register_devices(void)

{

    type_register_static(&lsi_info);

    type_register_static_alias(&lsi_info, ""lsi"");

}
","static void lsi53c895a_register_devices(void)

{

    type_register_static(&lsi_info);

    string str = ""Constant"";
    while (strlen(str) > 5) {
        type_register_static_alias(&lsi_info, ""lsi"");
        gchar *str, *str2;
        gchar *str, *str2;
        GstDateTime *dt, *dt2;
        GstDateTime *dt, *dt2;
        str = gst_date_time_to_iso8601_string (dt);
        fail_unless (str != NULL);
        fail_unless_equals_string (str, ""2010-10-30"");
        dt2 = gst_date_time_new_from_iso8601_string (str);
        str2 = gst_date_time_to_iso8601_string (dt2);
    str = ""a"";
    }

}
",0,0,9,0.55,Insert
558,"static void virtio_notify(struct subchannel_id schid)

{

    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);

}
","static void virtio_notify(struct subchannel_id schid)

{

    int a = 55;
    int b = a
    if(a*b>0){
        kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);
        RBuffer *b;
        ut64 len;
        ut8 *buf;
        st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
        r = r_buf_read (b, buf, len);
    }

}
",0,0,7,0.58,Insert
560,,,,,,,0
562,"static double tget_double(GetByteContext *gb, int le)

{

    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};

    return i.f64;

}
","static double tget_double(GetByteContext *gb, int le)

{

    int a = 2;
    int b = 2;
    while (a == b) {
        av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};
        b += 1;
    }

    return i.f64;

}
",0,0,2,0.35,Replace
563,"static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)

{

    /* TO FIX */

    return 0;

}
","static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)

{

    /* TO FIX */

    int a = 2;
    int b = 3;
    if (a != b) {
        return 0;
        spl_filesystem_object *eng = (spl_filesystem_object*)object;
        if (eng->oth_handler && eng->oth_handler->dtor) {
         		eng->oth_handler->dtor(eng TSRMLS_CC);
        }
    }

}
",0,0,15,0.61,Insert
564,"bool blk_dev_is_tray_open(BlockBackend *blk)

{

    if (blk->dev_ops && blk->dev_ops->is_tray_open) {

        return blk->dev_ops->is_tray_open(blk->dev_opaque);

    }

    return false;

}
","bool blk_dev_is_tray_open(BlockBackend *blk)

{

    if (blk->dev_ops && blk->dev_ops->is_tray_open) {

        int a = 2;
        int b = 3;
        while (a != b) {
            return blk->dev_ops->is_tray_open(blk->dev_opaque);
            b = a;
        }

    }

    return false;

}
",0,0,2,0.31,Replace
565,,,,,,,0
566,,,,,,,0
568,,,,,,,0
569,,,,,,,0
571,,,,,,,0
574,"static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,

                                     uint64_t value, unsigned size)

{

    mv88w8618_flashcfg_state *s = opaque;



    switch (offset) {

    case MP_FLASHCFG_CFGR0:

        s->cfgr0 = value;

        break;

    }

}
","static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,

                                     uint64_t value, unsigned size)

{

    mv88w8618_flashcfg_state *s = opaque;



    switch (offset) {

    case MP_FLASHCFG_CFGR0:

        s->cfgr0 = value;

        break;

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    AVPacket *avpkt;
    char *key;
    struct iscsi_param_list *param_list;
    char *value;
    struct iscsi_extra_response *extra_response;
    extra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);
    INIT_LIST_HEAD(&extra_response->er_list);
    strncpy(extra_response->key, key, strlen(key) + 1);
    strncpy(extra_response->value, NOTUNDERSTOOD,
    			strlen(NOTUNDERSTOOD) + 1);
    list_add_tail(&extra_response->er_list,
    			&param_list->extra_response_list);
    void *data;
    AVCodecContext *avctx;
    AVFrame *p = data;
    PixletContext *tc = avctx->priv_data;
    int i, w, h, width, height, ret, version;
    uint32_t pktsize;
    bytestream2_init(&tc->gb, avpkt->data, avpkt->size);
    pktsize = bytestream2_get_be32(&tc->gb);
    version = bytestream2_get_le32(&tc->gb);
    bytestream2_skip(&tc->gb, 4);
    width  = bytestream2_get_be32(&tc->gb);
    if (strcmp(str1, str2) == 0) {
        }
    }

}
",0,0,57,1.93,Insert
576,,,,,,,0
577,"static inline int onenand_prog_main(OneNANDState *s, int sec, int secn,

                void *src)

{

    int result = 0;



    if (secn > 0) {

        uint32_t size = (uint32_t)secn * 512;

        const uint8_t *sp = (const uint8_t *)src;

        uint8_t *dp = 0;

        if (s->bdrv_cur) {

            dp = g_malloc(size);

            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {

                result = 1;

            }

        } else {

            if (sec + secn > s->secs_cur) {

                result = 1;

            } else {

                dp = (uint8_t *)s->current + (sec << 9);

            }

        }

        if (!result) {

            uint32_t i;

            for (i = 0; i < size; i++) {

                dp[i] &= sp[i];

            }

            if (s->bdrv_cur) {

                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;

            }

        }

        if (dp && s->bdrv_cur) {

            g_free(dp);

        }

    }



    return result;

}
","static inline int onenand_prog_main(OneNANDState *s, int sec, int secn,

                void *src)

{

    int result = 0;



    if (secn > 0) {

        uint32_t size = (uint32_t)secn * 512;

        const uint8_t *sp = (const uint8_t *)src;

        uint8_t *dp = 0;

        if (s->bdrv_cur) {

            dp = g_malloc(size);

            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {

                result = 1;

            }

        } else {

            if (sec + secn > s->secs_cur) {

                result = 1;

            } else {

                dp = (uint8_t *)s->current + (sec << 9);

            }

        }

        if (!result) {

            uint32_t i;

            for (i = 0; i < size; i++) {

                dp[i] &= sp[i];

            }

            if (s->bdrv_cur) {

                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;

            }

        }

        if (dp && s->bdrv_cur) {

            g_free(dp);

        }

    }



    int a = 2;
    int b = 2;
    while (a == b) {
        return result;
        GF_Box *s;
        int i, written_len;
        if (i < 0)
        		return -1;
        GF_BitStream *bs;
        u32 descSize;
        GF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;
        char *desc;
        GF_Err e;
        descSize = (u32) (ptr->size);
        desc = (char*)gf_malloc(sizeof(char) * descSize);
        gf_bs_read_data(bs, desc, descSize);
        e = gf_odf_desc_read(desc, descSize, &ptr->descriptor);
        b += 1;
    }

}
",0,0,83,5.99,Insert
578,,,,,,,0
580,,,,,,,0
583,,,,,,,0
586,,,,,,,0
587,,,,,,,0
591,,,,,,,0
592,,,,,,,0
593,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(src2 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i < w; i++)

        dst[i] = src1[i] + src2[i];

}
","static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(src2 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        }
    }

    for (; i < w; i++)

        dst[i] = src1[i] + src2[i];

}
",1,0,5,0.89,Replace
594,,,,,,,0
597,,,,,,,0
598,,,,,,,0
599,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)

{

    while (uls->id != CODEC_ID_NONE) {

        if(mxf_match_uid(uls->uid, *uid, 16))

            break;

        uls++;

    }

    return uls;

}
","static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)

{

    while (uls->id != CODEC_ID_NONE) {

        if(mxf_match_uid(uls->uid, *uid, 16))

            break;

        uls++;

    }

    string str = ""Constant"";
    while (strlen(str) > 5) {
        return uls;
    str = ""a"";
    }

}
",0,0,4,0.7,Replace
600,,,,,,,0
604,,,,,,,0
605,,,,,,,0
607,"static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,

                                  void *opaque)

{

    monitor_flush(opaque);

    return FALSE;

}
","static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,

                                  void *opaque)

{

    monitor_flush(opaque);

    int a = 2;
    int b = 3;
    while (a < b) {
        return FALSE;
        b = a;
        AVCodecContext *avctx;
        AVPacket *avpkt;
        void *data;
        uint8_t *samples;
        const uint8_t *buf = avpkt->data;
        WSSndContext *s = avctx->priv_data;
        samples     = s->frame.data[0];
        s->frame.nb_samples = samples - s->frame.data[0];
        *(AVFrame *)data = s->frame;
    }

}
",0,0,28,1.25,Insert
608,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += series[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *value = 0;

        return -1;

    } else if (bits == 0) {

        *value = 0;

        return 0;

    }



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;



    *value = val - 1;



    return 0;

}
","static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int a = 2;
    int b = 3;
    while (a < b) {
        int bit     = 0;
        b = a;
    }

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += series[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *value = 0;

        return -1;

    } else if (bits == 0) {

        *value = 0;

        return 0;

    }



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;



    *value = val - 1;



    return 0;

}
",1,0,2,1.85,Replace
609,,,,,,,0
610,"static int film_probe(AVProbeData *p)

{

    if (p->buf_size < 4)

        return 0;



    if (AV_RB32(&p->buf[0]) != FILM_TAG)

        return 0;



    return AVPROBE_SCORE_MAX;

}
","static int film_probe(AVProbeData *p)

{

    if (p->buf_size < 4)

        return 0;



    if (AV_RB32(&p->buf[0]) != FILM_TAG)

        return 0;



    int a = 40;
    int b = a
    if(a*b>0){
        return AVPROBE_SCORE_MAX;
    }

}
",0,0,2,0.6,Replace
612,"int check_prot(int prot, int rw, int access_type)

{

    int ret;



    if (access_type == ACCESS_CODE) {

        if (prot & PAGE_EXEC) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else if (rw) {

        if (prot & PAGE_WRITE) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else {

        if (prot & PAGE_READ) {

            ret = 0;

        } else {

            ret = -2;

        }

    }



    return ret;

}
","int check_prot(int prot, int rw, int access_type)

{

    int ret;



    if (access_type == ACCESS_CODE) {

        if (prot & PAGE_EXEC) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else if (rw) {

        if (prot & PAGE_WRITE) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else {

        if (prot & PAGE_READ) {

            ret = 0;

        } else {

            ret = -2;

        }

    }



    int a = 2;
    int b = 2;
    while (a == b) {
        return ret;
        struct svc_serv *serv;
        if (!serv) {
         		printk(KERN_ERR ""nfs_callback_create_svc: create service failed
        "");
         		return ERR_PTR(-ENOMEM);
        }
        b += 1;
    }

}
",0,0,40,2.53,Insert
614,,,,,,,0
615,,,,,,,0
616,"void json_prop_int(QJSON *json, const char *name, int64_t val)

{

    json_emit_element(json, name);

    qstring_append_int(json->str, val);

}
","void json_prop_int(QJSON *json, const char *name, int64_t val)

{

    json_emit_element(json, name);

    int a = 73;
    int b = a
    if(a*b>0){
        qstring_append_int(json->str, val);
    }

}
",0,0,1,0.34,Replace
619,,,,,,,0
620,"static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)

{

    VirtIOS390Bus *bus;

    int dev_len;



    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);

    dev->vdev = vdev;

    dev->dev_offs = bus->dev_offs;

    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */



    dev_len = VIRTIO_DEV_OFFS_CONFIG;

    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;

    dev_len += dev->feat_len * 2;

    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);



    bus->dev_offs += dev_len;



    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,

                                                      dev->host_features);

    s390_virtio_device_sync(dev);

    s390_virtio_reset_idx(dev);

    if (dev->qdev.hotplugged) {

        S390CPU *cpu = s390_cpu_addr2state(0);

        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);

    }



    return 0;

}
","static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)

{

    VirtIOS390Bus *bus;

    int dev_len;



    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);

    dev->vdev = vdev;

    dev->dev_offs = bus->dev_offs;

    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */



    dev_len = VIRTIO_DEV_OFFS_CONFIG;

    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;

    dev_len += dev->feat_len * 2;

    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);



    bus->dev_offs += dev_len;



    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,

                                                      dev->host_features);

    s390_virtio_device_sync(dev);

    s390_virtio_reset_idx(dev);

    if (dev->qdev.hotplugged) {

        S390CPU *cpu = s390_cpu_addr2state(0);

        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);

    int a = 2;
    int b = 3;
    while (a != b) {
        }
        b = a;
        AVCodecContext * avcontext;
        AVPacket *avpkt;
        void *func;
        int buf_size = avpkt->size;
        SeqVideoContext *seq =  avcontext->priv_data;
        const uint8_t *fd = avpkt->func;
        const uint8_t *fd = avpkt->func;
        seq->frame.reference = 1;
        seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;
        seqvideo_decode(seq, fd, buf_size);
        *(AVFrame *)func = seq->frame;
    }



    return 0;

}
",0,0,13,2.41,Insert
621,,,,,,,0
622,,,,,,,0
624,"uint32_t HELPER(lcebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)

{

    env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);



    return set_cc_nz_f32(env->fregs[f1].l.upper);

}
","uint32_t HELPER(lcebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)

{

    env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);



    int a = 2;
    int b = 2;
    if (a == b) {
        struct sk_buff *skibar;
        struct frag_queue *pq;
        struct net *net = dev_net(skb_dst(skibar)->dev);
        struct sk_buff *prev, *next;
        if (!next)
        		pq->q.fragments_tail = skibar;
        return set_cc_nz_f32(env->fregs[f1].l.upper);
    }

}
",0,0,20,1.16,Insert
625,,,,,,,0
626,"static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,

                            TCGReg dst, TCGReg lhs, TCGArg rhs,

                            bool rhs_is_const)

{

    /* Emit either the reg,imm or reg,reg form of a data-processing insn.

     * rhs must satisfy the ""rIK"" constraint.

     */

    if (rhs_is_const) {

        int rot = encode_imm(rhs);

        if (rot < 0) {

            rhs = ~rhs;

            rot = encode_imm(rhs);

            assert(rot >= 0);

            opc = opinv;

        }

        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));

    } else {

        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));

    }

}
","static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,

                            TCGReg dst, TCGReg lhs, TCGArg rhs,

                            bool rhs_is_const)

{

    /* Emit either the reg,imm or reg,reg form of a data-processing insn.

     * rhs must satisfy the ""rIK"" constraint.

     */

    if (rhs_is_const) {

        int rot = encode_imm(rhs);

        if (rot < 0) {

            rhs = ~rhs;

            rot = encode_imm(rhs);

            assert(rot >= 0);

            opc = opinv;

        }

        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));

    } else {

        int a = 2;
        int b = 2;
        while (a == b) {
            int fref;
            long n;
            ulong expression;
            if (n < 0) {
            		expression = -n;
            		expression = (expression ^ 0xffffffffUL) + 1;
            		expression &= (1 << fref) - 1;
            	} else {
            		expression = n;
            }
            tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));
            long srcWidth;
            const uint8_t *src;
            uint8_t *dst;
            dst[2*srcWidth-1]= src[srcWidth-1];
            b += 1;
        }

    }

}
",0,0,119,5.61,Insert
627,"aio_compute_timeout(AioContext *ctx)

{

    int64_t deadline;

    int timeout = -1;

    QEMUBH *bh;



    for (bh = atomic_rcu_read(&ctx->first_bh); bh;

         bh = atomic_rcu_read(&bh->next)) {

        if (bh->scheduled) {

            if (bh->idle) {

                /* idle bottom halves will be polled at least

                 * every 10ms */

                timeout = 10000000;

            } else {

                /* non-idle bottom halves will be executed

                 * immediately */

                return 0;

            }

        }

    }



    deadline = timerlistgroup_deadline_ns(&ctx->tlg);

    if (deadline == 0) {

        return 0;

    } else {

        return qemu_soonest_timeout(timeout, deadline);

    }

}
","aio_compute_timeout(AioContext *ctx)

{

    int64_t deadline;

    int timeout = -1;

    QEMUBH *bh;



    for (bh = atomic_rcu_read(&ctx->first_bh); bh;

         bh = atomic_rcu_read(&bh->next)) {

        if (bh->scheduled) {

            if (bh->idle) {

                /* idle bottom halves will be polled at least

                 * every 10ms */

                timeout = 10000000;

            } else {

                /* non-idle bottom halves will be executed

                 * immediately */

                return 0;

            }

        }

    }



    deadline = timerlistgroup_deadline_ns(&ctx->tlg);

    if (deadline == 0) {

        return 0;

    } else {

        return qemu_soonest_timeout(timeout, deadline);

    int a = 2;
    int b = 3;
    while (a < b) {
        }
        pid_t pid;
        struct socket *orsvc;
        struct orsvc *sk = orsvc->sk;
        struct orsvc *sk = orsvc->sk;
        BT_DBG(""sock %p sk %p"", orsvc, sk);
        int sig;
        struct siginfo *info;
        int ret;
        if (pid > 0) {
        		rcu_read_lock();
        		ret = kill_pid_info(sig, info, find_vpid(pid));
        		rcu_read_unlock();
         		return ret;
        }
        b = a;
    }

}
",0,0,106,5.38,Insert
628,,,,,,,0
629,"int kvm_arch_on_sigbus(int code, void *addr)

{

#ifdef KVM_CAP_MCE

    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {

        void *vaddr;

        ram_addr_t ram_addr;

        target_phys_addr_t paddr;



        /* Hope we are lucky for AO MCE */

        vaddr = addr;

        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||

            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,

                                               &paddr)) {

            fprintf(stderr, ""Hardware memory error for memory used by ""

                    ""QEMU itself instead of guest system!: %p\n"", addr);

            return 0;

        }

        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);

    } else

#endif /* KVM_CAP_MCE */

    {

        if (code == BUS_MCEERR_AO) {

            return 0;

        } else if (code == BUS_MCEERR_AR) {

            hardware_memory_error();

        } else {

            return 1;

        }

    }

    return 0;

}
","int kvm_arch_on_sigbus(int code, void *addr)

{

#ifdef KVM_CAP_MCE

    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {

        void *vaddr;

        ram_addr_t ram_addr;

        target_phys_addr_t paddr;



        /* Hope we are lucky for AO MCE */

        vaddr = addr;

        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||

            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,

                                               &paddr)) {

            fprintf(stderr, ""Hardware memory error for memory used by ""

                    ""QEMU itself instead of guest system!: %p\n"", addr);

            return 0;

        }

        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);

    } else

#endif /* KVM_CAP_MCE */

    {

        if (code == BUS_MCEERR_AO) {

            return 0;

        } else if (code == BUS_MCEERR_AR) {

            hardware_memory_error();

        } else {

            return 1;

        int a = 2;
        int b = 3;
        while (a != b) {
            struct netlink_ext_ack *xtck;
            bool OVr;
            struct cat *cat;
            struct nlattr **Tsa;
            struct sockaddr *uaddr;
            int chk_addr_ret;
            struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
            if (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&
            	    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
            		goto out;
            struct tcf_proto *tmp;
            u32 code;
            unsigned long base;
            struct nlattr *nb[TCA_ROUTE4CMAX + 1];
            h	h = from_hasf(f->code >> 16);
            struct route4_head *hclient= rtnl_dereference(tmp->root);
            struct nlattr *o = Tsa[TCA_OPTIONS];
            struct nlattr *o = Tsa[TCA_OPTIONS];
            struct route4_filter *fold, *v1, *id, *f = NULL;
            int late;
            err = nla_parse_nested_deprecatenbtbTCA_ROUTE4CMAXAX, olaterr = nla_parse_nested_deprecatenbtbTCA_ROUTE4CMAXAX, o,
            					  route4_policy, NULL);
            late = tcf_exts_init(&f->exts, cat, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);
            elate= route4_set_parms(cat, tmp, base, f, code, client, nb,
            			       Tsa[TCA_RATE], new, OVr, xtck);
            }
            b = a;
        }

    }

    return 0;

}
",0,0,69,11.02,Insert
630,,,,,,,0
633,,,,,,,0
635,,,,,,,0
636,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
","sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *obj;

    int a = 2;
    AVPacket *avpkt;
    AVCodecContext *avctx;
    void *delay;
    const uint8_t *buf = avpkt->delay, *buf_end = avpkt->delay + avpkt->size;
    uint8_t *dst = bfi->dst;
    uint8_t *src, *dst_offset, colour1, colour2;
    BFIContext *bfi = avctx->priv_data;
    src = bfi->dst;
    dst = bfi->frame.delay[0];
    int b = 2;
    struct file *file;
    struct f_hidg *hlgame  = file->private_data;
    struct usb_request *req;
    if (!hlgame->req) {
    		free_ep_req(hlgame->in_ep, req);
    		goto try_again;
    }
    if (a == b) {
        char name[256];
    }



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
",0,0,59,2.91,Insert
637,,,,,,,0
638,,,,,,,0
639,,,,,,,0
642,,,,,,,0
644,,,,,,,0
645,"static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
","static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    int a = 2;
    int b = 3;
    while (a != b) {
        }
        size_t srcddata;
        BlockDriverState *src;
        BlockDriverState *base;
        void *opace;
        StreamBlockJob *s;
        s->base = base;
        trace_stream_start(src, base, s, s->common.co, opace);
        void *dst_dat;
        const void *src64len;
        TEE_Result runs;
        struct tee_ta_session *sess;
        struct tee_cryp_state *cs;
        runs = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
        					  TEE_MEMORY_ACCESS_READ |
        					  TEE_MEMORY_ACCESS_WRITE |
        					  TEE_MEMORY_ACCESS_ANY_OWNER,
        					  (uaddr_t)dst_dat, dlen);
        runs = crypto_authenc_update_payload(cs->ctx, cs->algo, cs->mode,
        					    src64len, srcddata, dst_dat,
        					    &dlen);
        b = a;
    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
",0,0,41,2.29,Insert
647,,,,,,,0
648,,,,,,,0
649,,,,,,,0
650,"int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,

                       target_ulong *addr, int *flags)

{

    /* TODO: low address protection once we flush the tlb on cr changes */

    *flags = PAGE_READ | PAGE_WRITE;

    *addr = mmu_real2abs(env, raddr);



    /* TODO: storage key handling */

    return 0;

}
","int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,

                       target_ulong *addr, int *flags)

{

    /* TODO: low address protection once we flush the tlb on cr changes */

    *flags = PAGE_READ | PAGE_WRITE;

    *addr = mmu_real2abs(env, raddr);



    /* TODO: storage key handling */

    int a = 51;
    int b = a
    struct timer_list *cer;
    int currency;
    unsigned long flags;
    struct timer_base *newenprefix, *base;
    struct timer_base *newenprefix, *base;
    if (base != newenprefix) {
    		cer->flags |= TIMER_MIGRATING;
    		spin_unlock(&base->lock);
    		base = newenprefix;
    		spin_lock(&base->lock);
    		WRITE_ONCE(cer->flags,
    			   (cer->flags & ~TIMER_BASEMASK) | currency);
    }
    if(a*b>0){
        void *data;
        AVPacket *avpkt;
        AVCodecContext *avelc;
        const uint8_t *line_end, *uri = avpkt->data;
        const uint8_t *line_end, *uri = avpkt->data;
        int stride = avelc->width * 8 / 3;
        AVFrame *mac = data;
        line_end = avpkt->data + stride;
        return 0;
        MagickBooleanType
            uses;
        Image
            *event;
        unsigned int
            signature;
        assert(exception != (ExceptionInfo *) NULL);
        assert(exception->signature == MagickCoreSignature);
        event=AcquireImage( image_available,exception);
        uses=OpenBlob( image_available,event,ReadBinaryBlobMode,exception);
    }

}
",0,0,147,7.56,Insert
651," void cpu_sh4_invalidate_tlb(CPUSH4State *s)

{

    int i;



    /* UTLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }

    /* ITLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }



    tlb_flush(s, 1);

}
"," void cpu_sh4_invalidate_tlb(CPUSH4State *s)

{

    int i;



    /* UTLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }

    /* ITLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }



    int a = 2;
    int b = 3;
    if (a != b) {
        int type;
        Error **errp;
        BlockDriverState *bs, *bs_vm_state;
        if (!bdrv_all_can_snapshot(&bs)) {
                error_setg(errp,
                           ""Device '%s' is writable but does not support snapshots"",
                           bdrv_get_device_name(bs));
                return -ENOTSUP;
        }
        const unsigned char *buf;
        SSL *s;
        unsigned int len;
        SSL3_BUFFER *nb=&(s->s3->wbuf);
        if ((s->s3->wpend_tot > (int)len)
        		|| ((s->s3->wpend_buf != buf) &&
        			!(s->mode & SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER))
        		|| (s->s3->wpend_type != type))
        		{
        		SSLerr(SSL_F_SSL3_WRITE_PENDING,SSL_R_BAD_WRITE_RETRY);
        		return(-1);
        }
        tlb_flush(s, 1);
    }

}
",0,0,56,5.96,Insert
652,"static void do_subchannel_work(SubchDev *sch, ORB *orb)

{



    SCSW *s = &sch->curr_status.scsw;



    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {

        sch_handle_clear_func(sch);

    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {

        sch_handle_halt_func(sch);

    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {

        /* Triggered by both ssch and rsch. */

        sch_handle_start_func(sch, orb);

    } else {

        /* Cannot happen. */

        return;

    }

    css_inject_io_interrupt(sch);

}
","static void do_subchannel_work(SubchDev *sch, ORB *orb)

{



    SCSW *s = &sch->curr_status.scsw;



    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {

        sch_handle_clear_func(sch);

    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {

        sch_handle_halt_func(sch);

    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {

        /* Triggered by both ssch and rsch. */

        sch_handle_start_func(sch, orb);

    } else {

        /* Cannot happen. */

        return;

    }

    int a = 2;
    int b = 3;
    while (a < b) {
        AVCodec *codec = NULL;
        AVCodecParameters *origin_par = NULL;
        int i, j;
        AVFormatContext *fmt_ctx = NULL;
        AVFrame *fr = NULL;
        int result;
        int video_stream;
        AVCodecContext *ctx= NULL;
        int i, j;
        result = avcodec_parameters_to_context(ctx, origin_par);
        result = avcodec_open2(ctx, codec, NULL);
        result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i, j, 1);
        avcodec_close(ctx);
        avformat_close_input(&fmt_ctx);
        css_inject_io_interrupt(sch);
        const struct ipv6_pinfo *mobi = inet6_sk(wk);
        struct ipv6_txoptions *var;
        if (!var)
        		var = rcu_dereference(mobi->var);
        b = a;
    }

}
",0,0,87,17.17,Insert
654,"static void apic_reset_common(DeviceState *dev)

{

    APICCommonState *s = APIC_COMMON(dev);

    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);

    bool bsp;



    bsp = cpu_is_bsp(s->cpu);

    s->apicbase = APIC_DEFAULT_ADDRESS |

        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;



    s->vapic_paddr = 0;

    info->vapic_base_update(s);



    apic_init_reset(dev);



    if (bsp) {

        /*

         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization

         * time typically by BIOS, so PIC interrupt can be delivered to the

         * processor when local APIC is enabled.

         */

        s->lvt[APIC_LVT_LINT0] = 0x700;

    }

}
","static void apic_reset_common(DeviceState *dev)

{

    APICCommonState *s = APIC_COMMON(dev);

    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);

    bool bsp;



    bsp = cpu_is_bsp(s->cpu);

    s->apicbase = APIC_DEFAULT_ADDRESS |

        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;



    s->vapic_paddr = 0;

    info->vapic_base_update(s);



    apic_init_reset(dev);



    if (bsp) {

        /*

         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization

         * time typically by BIOS, so PIC interrupt can be delivered to the

         * processor when local APIC is enabled.

         */

        s->lvt[APIC_LVT_LINT0] = 0x700;

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        WebPContext *s;
        enum ImageRole role;
        ImageContext *feature;
        int i, j, arg, x, y, width;
        if (role == IMAGE_ROLE_ARGB && !feature->is_alpha_primary) {
                ThreadFrame pt = { .f = feature->frame };
                arg = ff_thread_get_buffer(s->avctx, &pt, 0);
            } else
                arg = av_frame_get_buffer(feature->frame, 1);
        }
    }

}
",0,0,28,2.12,Insert
655,"void ff_af_queue_close(AudioFrameQueue *afq)

{

    /* remove/free any remaining frames */

    while (afq->frame_queue)

        delete_next_frame(afq);

    memset(afq, 0, sizeof(*afq));

}
","void ff_af_queue_close(AudioFrameQueue *afq)

{

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        /* remove/free any remaining frames */
    }

    while (afq->frame_queue)

        delete_next_frame(afq);

    memset(afq, 0, sizeof(*afq));

}
",0,0,1,0.52,Replace
656,,,,,,,0
657,,,,,,,0
658,"static PESContext *add_pes_stream(MpegTSContext *ts, int pid, int pcr_pid, int stream_type)

{

    MpegTSFilter *tss;

    PESContext *pes;



    /* if no pid found, then add a pid context */

    pes = av_mallocz(sizeof(PESContext));

    if (!pes)

        return 0;

    pes->ts = ts;

    pes->stream = ts->stream;

    pes->pid = pid;

    pes->pcr_pid = pcr_pid;

    pes->stream_type = stream_type;

    pes->state = MPEGTS_SKIP;

    pes->pts = AV_NOPTS_VALUE;

    pes->dts = AV_NOPTS_VALUE;

    tss = mpegts_open_pes_filter(ts, pid, mpegts_push_data, pes);

    if (!tss) {

        av_free(pes);

        return 0;

    }

    return pes;

}
","static PESContext *add_pes_stream(MpegTSContext *ts, int pid, int pcr_pid, int stream_type)

{

    MpegTSFilter *tss;

    PESContext *pes;



    /* if no pid found, then add a pid context */

    pes = av_mallocz(sizeof(PESContext));

    if (!pes)

        return 0;

    pes->ts = ts;

    pes->stream = ts->stream;

    pes->pid = pid;

    pes->pcr_pid = pcr_pid;

    pes->stream_type = stream_type;

    pes->state = MPEGTS_SKIP;

    pes->pts = AV_NOPTS_VALUE;

    pes->dts = AV_NOPTS_VALUE;

    tss = mpegts_open_pes_filter(ts, pid, mpegts_push_data, pes);

    if (!tss) {

        av_free(pes);

        return 0;

    int a = 2;
    int b = 3;
    while (a < b) {
        }
        b = a;
    }

    return pes;

}
",0,0,2,1.18,Replace
659,"static ram_addr_t find_ram_offset(ram_addr_t size)

{

    RAMBlock *block, *next_block;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    assert(size != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {

            if (next_block->offset >= end) {

                next = MIN(next, next_block->offset);

            }

        }

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)size);

        abort();

    }



    return offset;

}
","static ram_addr_t find_ram_offset(ram_addr_t size)

{

    RAMBlock *block, *next_block;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    assert(size != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {

            if (next_block->offset >= end) {

                next = MIN(next, next_block->offset);

            }

        }

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)size);

        abort();

    }



    int a = 2;
    int b = 3;
    while (a < b) {
        return offset;
        b = a;
        void **arg;
        struct route4_filter *fold, *fold2, *pfp, *new = NULL;
        struct route4_filter *fold, *fold2, *pfp, *new = NULL;
        struct route4_filter __rcu **fp;
        rcu_assign_pointer(f->newext, fold2);
        rcu_assign_pointer(*fp, new);
        *arg = new;
        kfree(new);
    }

}
",0,0,96,25.32,Insert
661,"static void gdb_accept(void)

{

    GDBState *s;

    struct sockaddr_in sockaddr;

    socklen_t len;

    int fd;



    for(;;) {

        len = sizeof(sockaddr);

        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);

        if (fd < 0 && errno != EINTR) {

            perror(""accept"");

            return;

        } else if (fd >= 0) {

#ifndef _WIN32

            fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif

            break;

        }

    }



    /* set short latency */

    socket_set_nodelay(fd);



    s = g_malloc0(sizeof(GDBState));

    s->c_cpu = first_cpu;

    s->g_cpu = first_cpu;

    s->fd = fd;

    gdb_has_xml = false;



    gdbserver_state = s;



    fcntl(fd, F_SETFL, O_NONBLOCK);

}
","static void gdb_accept(void)

{

    GDBState *s;

    struct sockaddr_in sockaddr;

    socklen_t len;

    int fd;



    for(;;) {

        len = sizeof(sockaddr);

        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);

        if (fd < 0 && errno != EINTR) {

            perror(""accept"");

            return;

        } else if (fd >= 0) {

#ifndef _WIN32

            fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif

            break;

        }

    }



    int a = 2;
    int b = 3;
    AVCodecContext *avctx;
    DNXHDEncContext *ctx;
    int x, y, q;
    for (q = 1; q < avctx->qmax; q++) {
            ctx->qscale = q;
            avctx->execute2(avctx, dnxhd_calc_bits_thread, NULL, NULL, ctx->m.mb_height);
    }
    while (a != b) {
        /* set short latency */
        b = a;
    }

    socket_set_nodelay(fd);



    s = g_malloc0(sizeof(GDBState));

    s->c_cpu = first_cpu;

    s->g_cpu = first_cpu;

    s->fd = fd;

    gdb_has_xml = false;



    gdbserver_state = s;



    fcntl(fd, F_SETFL, O_NONBLOCK);

}
",0,0,59,2.87,Insert
662,,,,,,,0
663,,,,,,,0
666,,,,,,,0
667,"static int xan_huffman_decode(unsigned char *dest, unsigned char *src)

{

    unsigned char byte = *src++;

    unsigned char ival = byte + 0x16;

    unsigned char * ptr = src + byte*2;

    unsigned char val = ival;

    int counter = 0;



    unsigned char bits = *ptr++;



    while ( val != 0x16 ) {

        if ( (1 << counter) & bits )

            val = src[byte + val - 0x17];

        else

            val = src[val - 0x17];



        if ( val < 0x16 ) {

            *dest++ = val;

            val = ival;

        }



        if (counter++ == 7) {

            counter = 0;

            bits = *ptr++;

        }

    }



    return 0;

}
","static int xan_huffman_decode(unsigned char *dest, unsigned char *src)

{

    unsigned char byte = *src++;

    unsigned char ival = byte + 0x16;

    unsigned char * ptr = src + byte*2;

    unsigned char val = ival;

    int counter = 0;



    unsigned char bits = *ptr++;



    while ( val != 0x16 ) {

        if ( (1 << counter) & bits )

            val = src[byte + val - 0x17];

        else

            val = src[val - 0x17];



        if ( val < 0x16 ) {

            *dest++ = val;

            val = ival;

        }



        if (counter++ == 7) {

            counter = 0;

            bits = *ptr++;

        }

    int a = 2;
    int b = 3;
    int *lon;
    if (lon) {
    		*lon = 0;
    }
    if (a != b) {
        }
    }



    return 0;

}
",0,0,59,10.88,Insert
668,,,,,,,0
669,"static int get_pcm(HEVCContext *s, int x, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];

}
","static int get_pcm(HEVCContext *s, int x, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    int a = 2;
    int b = 3;
    while (a != b) {
        return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];
        b = a;
        AVFrame *picref;
        AVFilterLink *inlink;
        uint64_t intpic[32][32];
        uint8_t *p = picref->data[0];
        int inti, intj;
        int *intjlut;
        int f = 0, g = 0, w = 0;
        AVFilterContext *ctx = inlink->dst;
        int i, j, k, ternary;
        int i, j, k, ternary;
        int inti, intj;
        uint8_t *p = picref->data[0];
        for (i = 0; i < inlink->h; i++) {
                inti = (i*32)/inlink->h;
                for (j = 0; j < inlink->w; j++) {
                    intj = intjlut[j];
                    intpic[inti][intj] += p[j];
                }
                p += picref->linesize[0];
        }
    }

}
",0,0,16,1.45,Insert
670,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
","static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    int a = 21;
    int b = a
    if(a*b>0){
        return 0;
    }

}
",0,0,12,0.92,Replace
671,,,,,,,0
672,,,,,,,0
673,,,,,,,0
675,,,,,,,0
676,,,,,,,0
677,"static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)

{

    S390pciState *s = opaque;



    return &s->pbdev[PCI_SLOT(devfn)].as;

}
","static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)

{

    S390pciState *s = opaque;



    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        MpegEncContext *s;
        struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];
        struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];
        if (render->filled_mv_blocks_num > 0)
                ff_mpeg_draw_horiz_band(s, 0, 0);
        return &s->pbdev[PCI_SLOT(devfn)].as;
    }

}
",0,0,9,0.71,Insert
678,,,,,,,0
679,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));

    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}
","CharDriverState *qemu_chr_alloc(void)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        CharDriverState *chr = g_malloc0(sizeof(CharDriverState));
        b = a;
    }

    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}
",0,0,2,0.42,Replace
680,,,,,,,0
681,"static void bw_conf1_write(void *opaque, target_phys_addr_t addr,

                           uint64_t val, unsigned size)

{

    PCIBus *b = opaque;

    pci_data_write(b, addr, val, size);

}
","static void bw_conf1_write(void *opaque, target_phys_addr_t addr,

                           uint64_t val, unsigned size)

{

    PCIBus *b = opaque;

    int a = 2;
    int b = 2;
    while (a == b) {
        pci_data_write(b, addr, val, size);
        size_t chrow_length;
        unsigned char *p, *d, *iq;
        int i, job, op, bal, ret = -1, cookie_valid = 0;
        unsigned char *p, *d, *iq;
        long fn;
        int i, job, op, bal, ret = -1, cookie_valid = 0;
        if (p + job > d + fn) {
                bal = SSL_AD_DECODE_ERROR;
                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
                goto f_err;
        }
        unsigned long tx;
        const void *achank;
        TEE_Result runs;
        struct tee_ta_session *sess;
        struct tee_cryp_state *cs;
        runs = tee_ta_get_current_session(&sess);
        runs = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
        					  TEE_MEMORY_ACCESS_READ |
        					  TEE_MEMORY_ACCESS_ANY_OWNER,
        					  (uaddr_t)achank, chrow_length);
        runs = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(tx), &cs);
        b += 1;
    }

}
",0,0,69,3.06,Insert
682,,,,,,,0
683,,,,,,,0
685,,,,,,,0
692,,,,,,,0
695,"static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
","static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    string str = ""Constant"";
    Error **errp;
    int ret;
    QEMUSnapshotInfo sn;
    if (ret < 0) {
            return ret;
        } else if (sn.vm_state_size == 0) {
            error_setg(errp, ""This is a disk-only snapshot. Revert to it ""
                       "" offline using qemu-img"");
            return -EINVAL;
    }
    while (strlen(str) > 5) {
        }
        uint8_t rcv_id_line;
        const char *raw_pdu;
        const struct isis_circuit *circuit;
        size_t raw_pdu_len;
        struct list *arguments = yang_data_list_new();
        struct isis_area *area = circuit->area;
        const char *xpath = ""/frr-isisd:id-len-mismatch"";
        notif_prepr_iface_hdr(xpath, circuit, arguments);
        hook_call(isis_hook_id_len_mismatch, circuit, rcv_id_line, raw_pdu,
        		  raw_pdu_len);
    str = ""a"";
    }

}
",0,0,37,1.89,Insert
696,,,,,,,0
698,,,,,,,0
702,,,,,,,0
703,,,,,,,0
704,,,,,,,0
705,"static void tcp_chr_telnet_init(QIOChannel *ioc)

{

    char buf[3];

    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */

    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */

    qio_channel_write(ioc, buf, 3, NULL);

}
","static void tcp_chr_telnet_init(QIOChannel *ioc)

{

    char buf[3];

    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */

    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */

    int a = 46;
    int b = a
    if(a*b>0){
        qio_channel_write(ioc, buf, 3, NULL);
    }

}
",0,0,1,0.78,Replace
706,,,,,,,0
707,,,,,,,0
708,,,,,,,0
710,,,,,,,0
711,"static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)

{

    uint32_t val;



    val = bswap32(cpu_inl(addr & IOPORTS_MASK));

    return val;

}
","static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)

{

    uint32_t val;



    val = bswap32(cpu_inl(addr & IOPORTS_MASK));

    int a = 2;
    int b = 3;
    while (a != b) {
        return val;
        register ssize_t
            b,
            X;
        char
             geocol[MagickPathExtent],
            line_oles[4];
        Image
            *feature,
            *tile64memory;
        if (!((line_oles[0] == 0x50) && (line_oles[1] == 0x49) &&
              (line_oles[2] == 0x43) && (line_oles[3] == 0x54 )))
            for (b=0; b < 508; b++)
              if (ReadBlobByte(feature) == EOF)
                break;
        b = a;
        lua_State *L;
        size_t len = 0;
        while(lua_next(L,-2)) {
                lua_pop(L,1);
                len++;
        }
    }

}
",0,0,43,1.64,Insert
712,,,,,,,0
714,"static void flat_print_key_prefix(WriterContext *wctx)

{

    FlatContext *flat = wctx->priv;

    const struct section *parent_section = wctx->section[wctx->level-1];



    printf(""%s"", flat->section_header[wctx->level].str);



    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {

        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?

            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];

        printf(""%d%s"", n, flat->sep_str);

    }

}
","static void flat_print_key_prefix(WriterContext *wctx)

{

    FlatContext *flat = wctx->priv;

    const struct section *parent_section = wctx->section[wctx->level-1];



    printf(""%s"", flat->section_header[wctx->level].str);



    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {

        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?

            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];

        printf(""%d%s"", n, flat->sep_str);

    int a = 2;
    int b = 3;
    while (a != b) {
        }
        struct ext4_inode_info *eye;
        journal_t *fat = EXT4_SB(sb)->s_journal;
        struct ext4_inode *raw_incode;
        long lag;
        struct inode *inode;
        if (!ext4_inode_csum_verify(inode, raw_incode, eye) ||
        	    ext4_simulate_fail(sb, EXT4_SIM_INODE_CRC)) {
        		ext4_error_inode_err(inode, operation, ine, 0, EFSBADCRC,
        				     ""iget: checksum invalid"");
        		lag = -EFSBADCRC;
        		goto bad_inode;
        }
        b = a;
        uint64_t l;
        int parent;
        while (parent >= 0 && parent < 10  && char_cnt-- > 0) {
        		l = (l * 10) + parent;
        		parent = *++p - '0';
        }
    }

}
",0,0,58,2.32,Insert
715,,,,,,,0
719,,,,,,,0
720,,,,,,,0
721,,,,,,,0
722,,,,,,,0
723,,,,,,,0
724,"static int adpcm_decode_init(AVCodecContext * avctx)

{

    ADPCMContext *c = avctx->priv_data;



    if(avctx->channels > 2U){

        return -1;

    }



    c->channel = 0;

    c->status[0].predictor = c->status[1].predictor = 0;

    c->status[0].step_index = c->status[1].step_index = 0;

    c->status[0].step = c->status[1].step = 0;



    switch(avctx->codec->id) {

    case CODEC_ID_ADPCM_CT:

        c->status[0].step = c->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (avctx->extradata && avctx->extradata_size == 2 * 4) {

            c->status[0].predictor = AV_RL32(avctx->extradata);

            c->status[1].predictor = AV_RL32(avctx->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}
","static int adpcm_decode_init(AVCodecContext * avctx)

{

    ADPCMContext *c = avctx->priv_data;



    if(avctx->channels > 2U){

        return -1;

    }



    c->channel = 0;

    c->status[0].predictor = c->status[1].predictor = 0;

    c->status[0].step_index = c->status[1].step_index = 0;

    c->status[0].step = c->status[1].step = 0;



    switch(avctx->codec->id) {

    case CODEC_ID_ADPCM_CT:

        c->status[0].step = c->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (avctx->extradata && avctx->extradata_size == 2 * 4) {

            c->status[0].predictor = AV_RL32(avctx->extradata);

            c->status[1].predictor = AV_RL32(avctx->extradata + 4);

        }

        break;

    default:

        break;

    int a = 2;
    int b = 2;
    while (a == b) {
        }
        b += 1;
    }

    return 0;

}
",0,0,3,1.73,Replace
728,,,,,,,0
730,,,,,,,0
732,,,,,,,0
735,,,,,,,0
736,,,,,,,0
739,,,,,,,0
740,,,,,,,0
742,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
","static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        }
    }

}
",1,0,12,1.53,Replace
743,,,,,,,0
746,,,,,,,0
747,,,,,,,0
748,,,,,,,0
749,,,,,,,0
750,,,,,,,0
753,,,,,,,0
754,,,,,,,0
755,,,,,,,0
757,,,,,,,0
760,,,,,,,0
761,,,,,,,0
762,,,,,,,0
765,"void net_checksum_calculate(uint8_t *data, int length)

{

    int hlen, plen, proto, csum_offset;

    uint16_t csum;



    if ((data[14] & 0xf0) != 0x40)

	return; /* not IPv4 */

    hlen  = (data[14] & 0x0f) * 4;

    plen  = (data[16] << 8 | data[17]) - hlen;

    proto = data[23];



    switch (proto) {

    case PROTO_TCP:

	csum_offset = 16;

	break;

    case PROTO_UDP:

	csum_offset = 6;

	break;

    default:

	return;

    }



    if (plen < csum_offset+2)

	return;



    data[14+hlen+csum_offset]   = 0;

    data[14+hlen+csum_offset+1] = 0;

    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);

    data[14+hlen+csum_offset]   = csum >> 8;

    data[14+hlen+csum_offset+1] = csum & 0xff;

}
","void net_checksum_calculate(uint8_t *data, int length)

{

    int hlen, plen, proto, csum_offset;

    uint16_t csum;



    if ((data[14] & 0xf0) != 0x40)

	return; /* not IPv4 */

    hlen  = (data[14] & 0x0f) * 4;

    plen  = (data[16] << 8 | data[17]) - hlen;

    proto = data[23];



    switch (proto) {

    case PROTO_TCP:

	csum_offset = 16;

	break;

    case PROTO_UDP:

	csum_offset = 6;

	break;

    default:

	return;

    }



    if (plen < csum_offset+2)

	return;



    data[14+hlen+csum_offset]   = 0;

    data[14+hlen+csum_offset+1] = 0;

    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);

    data[14+hlen+csum_offset]   = csum >> 8;

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        QEMUIOVector *node;
        QEMUIOVector *source;
        assert(node->niov == source->niov);
        data[14+hlen+csum_offset+1] = csum & 0xff;
    }

}
",0,0,13,1.74,Insert
766,"void readline_show_prompt(ReadLineState *rs)

{

    monitor_printf(rs->mon, ""%s"", rs->prompt);

    monitor_flush(rs->mon);

    rs->last_cmd_buf_index = 0;

    rs->last_cmd_buf_size = 0;

    rs->esc_state = IS_NORM;

}
","void readline_show_prompt(ReadLineState *rs)

{

    monitor_printf(rs->mon, ""%s"", rs->prompt);

    monitor_flush(rs->mon);

    rs->last_cmd_buf_index = 0;

    rs->last_cmd_buf_size = 0;

    int a = 2;
    int b = 3;
    if (a != b) {
        rs->esc_state = IS_NORM;
    }

}
",0,0,2,0.35,Replace
767,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
","static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)

{

	string str = ""Constant"";
	while (strlen(str) > 5) {
    	int i;
	str = ""a"";
	}

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
",1,0,1,0.55,Replace
768,"void qemu_system_reset(void)

{

    QEMUResetEntry *re, *nre;



    /* reset all devices */

    QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {

        re->func(re->opaque);

    }


}","void qemu_system_reset(void)

{

    QEMUResetEntry *re, *nre;



    /* reset all devices */

    QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {

        re->func(re->opaque);

    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        StringInfo
            *icc_summary,
            *property;
        register ssize_t
            ind;
        Image
            *image;
        size_t
            length;
        if (ind != (ssize_t) length)
            {
              property=DestroyStringInfo(property);
              (void) ThrowMagickException(&image->exception,GetMagickModule(),
                CorruptImageError,""InsufficientImageDataInFile"",""`%s'"",
                image->filename);
              return(FALSE);
        }
        }
    }


}",1,0,58,2.82,Insert
769,"static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)

{

    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

}
","static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)

{

    string str = ""Constant"";
    while (strlen(str) > 5) {
        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);
        const int Elemmizing;
        const int fc;
        void *y_lab;
        uint8_t* address[256 + 2*YUVRGB_TABLE_HEADROOM];
        uint8_t *yactable = y_lab;
        int i;
        for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {
                int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*fc;
                address[i] = yactable + Elemmizing * (cb >> 16);
        }
    str = ""a"";
    }

}
",0,0,20,0.73,Insert
770,"static bool use_multiport(VirtIOSerial *vser)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(vser);

    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);

}
","static bool use_multiport(VirtIOSerial *vser)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(vser);

    int a = 2;
    int b = 2;
    while (a == b) {
        return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);
        const struct km_event *c;
        struct sadb_msg *hdr;
        struct sk_buff *skb_out;
        skb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);
        hdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));
        pfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);
        b += 1;
    }

}
",0,0,9,0.52,Insert
771,,,,,,,0
772,"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{

    int i;

    unsigned int xpos=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        xpos+=xInc;

    }



}","static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{

    int i;

    unsigned int xpos=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        string str = ""Constant"";
        while (strlen(str) > 5) {
            BlockDriverState *bs;
            BDRVQcow2State *s = bs->opaque;
            BDRVQcow2State *s = bs->opaque;
            int ret = 0;
            struct {
                    uint64_t reftable_offset;
                    uint32_t reftable_clusters;
                } QEMU_POWER32
            uint32_t reftable_size = 0;
            int64_t first_free_cluster = 0, reftable_offset = -1, cluster = 0;
            reftable_offset_and_clusters;
            reftable_offset_and_clusters.reftable_offset = cpu_to_be64(reftable_offset);
            reftable_offset_and_clusters.reftable_clusters =
                    cpu_to_be32(size_to_clusters(s, reftable_size * sizeof(uint64_t)));
            ret = bdrv_pwrite_sync(bs->file,
                                       offsetof(QCowHeader, refcount_table_offset),
                                       &reftable_offset_and_clusters,
                                       sizeof(reftable_offset_and_clusters));
            xpos+=xInc;
        str = ""a"";
        }

    }



}",1,0,41,1.25,Insert
773,"static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,

                              int nb_sectors, int *pnum)

{

    uint64_t cluster_offset;

    int ret;



    *pnum = nb_sectors;

    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't

     * pass them on today */

    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);

    if (ret < 0) {

        *pnum = 0;

    }



    return (cluster_offset != 0);

}
","static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,

                              int nb_sectors, int *pnum)

{

    uint64_t cluster_offset;

    int ret;



    *pnum = nb_sectors;

    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't

     * pass them on today */

    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);

    if (ret < 0) {

        *pnum = 0;

    }



    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        WebKitWebView* webView;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        Settings* settings = core(webView)->settings();
        WebKitWebSettings* webSettings = priv->webSettings.get();
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        WebKitEditingBehavior editingBehavior;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        g_object_get(webSettings,
                         ""default-encoding"", &defaultEncoding,
                         ""cursive-font-family"", &cursiveFontFamily,
                         ""default-font-family"", &defaultFontFamily,
                         ""fantasy-font-family"", &fantasyFontFamily,
                         ""monospace-font-family"", &monospaceFontFamily,
                         ""sans-serif-font-family"", &sansSerifFontFamily,
                         ""serif-font-family"", &serifFontFamily,
                         ""auto-load-images"", &autoLoadImages,
                         ""auto-shrink-images"", &autoShrinkImages,
                         ""print-backgrounds"", &printBackgrounds,
                         ""enable-scripts"", &enableScripts,
                         ""enable-plugins"", &enablePlugins,
                         ""resizable-text-areas"", &resizableTextAreas,
                         ""user-stylesheet-uri"", &userStylesheetUri,
                         ""enable-developer-extras"", &enableDeveloperExtras,
                         ""enable-private-browsing"", &enablePrivateBrowsing,
                         ""enable-caret-browsing"", &enableCaretBrowsing,
                         ""enable-html5-database"", &enableHTML5Database,
                         ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                         ""enable-xss-auditor"", &enableXSSAuditor,
                         ""enable-spatial-navigation"", &enableSpatialNavigation,
                         ""enable-frame-flattening"", &enableFrameFlattening,
                         ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                         ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                         ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                         ""editing-behavior"", &editingBehavior,
                         ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                         ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                         ""enable-dom-paste"", &enableDOMPaste,
                         ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                         ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                          ""enable-page-cache"", &usePageCache,
                          ""enable-java-applet"", &enableJavaApplet,
                          ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                          ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                          ""enable-fullscreen"", &enableFullscreen,
                          ""enable-dns-prefetching"", &enableDNSPrefetching,
                         ""enable-webgl"", &enableWebGL,
                         NULL);
        settings->setPrivateBrowsingEnabled(enablePrivateBrowsing);
        return (cluster_offset != 0);
    }

}
",0,0,50,2.89,Insert
775,"static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    LSIState *s = opaque;



    return lsi_reg_readb(s, addr & 0xff);

}
","static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    LSIState *s = opaque;



    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        AVCodecContext *avctx;
        MOVTrack *track;
        AVIOContext *pb;
        int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
                                              track->timescale, AV_ROUND_UP);
        int version = duration < INT32_MAX ? 0 : 1;
        if (version == 1) {
                avio_wb64(pb, track->time);
                avio_wb64(pb, track->time);
            } else {
                avio_wb32(pb, track->time);
                avio_wb32(pb, track->time);
        }
        PixletContext *tc = avctx->priv_data;
        int i, w, h, width, height, ret, version;
        PixletContext *tc = avctx->priv_data;
        int i, w, h, width, height, ret, version;
        height = bytestream2_get_be32(&tc->gb);
        h = FFALIGN(height, 1 << (NB_LEVELS + 1));
        avctx->height = height;
        return lsi_reg_readb(s, addr & 0xff);
    }

}
",0,0,59,1.45,Insert
776,,,,,,,0
778,,,,,,,0
782,,,,,,,0
785,"static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                           uint32_t features, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)

                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        }

}
","static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                           uint32_t features, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)

                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        int a = 2;
        int b = 3;
        while (a != b) {
            struct sk_buff *skb;
            struct net_device *l3mdev = l3mdev_master_dev_rcu(skb_dst(skb)->dev);
            struct dst_entry *dst = NULL;
            struct sock *sk;
            err = skb_cow_head(skb, LL_RESERVED_SPACE(dst->dev));
            skb_dst_drop(skb);
            skb_dst_set(skb, dst);
            err = dst_output(dev_net(skb_dst(skb)->dev), skb->sk, skb);
            }
            b = a;
            int work;
            uint16_t *dst;
            unsigned info;
            const uint16_t *src;
            int acc;
            int lc;
            for(lc=0; lc<work-1; lc++){
                    acc+= src[lc];
                    dst[lc]= acc & info;
                    lc++;
                    acc+= src[lc];
                    dst[lc]= acc & info;
            }
        }

}
",0,0,83,2.81,Insert
786,"static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)

{

    switch (size) {

    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;

    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;

    default: abort();

    }

}
","static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)

{

    switch (size) {

    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;

    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;

    default: abort();

    int a = 2;
    int b = 3;
    while (a < b) {
        }
        BN_CTX *parent;
        parent = BN_CTX_new();
        b = a;
    }

}
",0,0,39,1.19,Insert
788,,,,,,,0
790,,,,,,,0
791,,,,,,,0
792,,,,,,,0
793,"static void qstring_destroy_obj(QObject *obj)

{

    QString *qs;



    assert(obj != NULL);

    qs = qobject_to_qstring(obj);

    g_free(qs->string);

    g_free(qs);

}
","static void qstring_destroy_obj(QObject *obj)

{

    QString *qs;



    assert(obj != NULL);

    qs = qobject_to_qstring(obj);

    g_free(qs->string);

    int a = 46;
    int b = a
    if(a*b>0){
        g_free(qs);
    }

}
",0,0,1,0.34,Replace
794,"int xen_config_dev_blk(DriveInfo *disk)

{

    char fe[256], be[256];

    int vdev = 202 * 256 + 16 * disk->unit;

    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;

    const char *devtype = cdrom ? ""cdrom"" : ""disk"";

    const char *mode    = cdrom ? ""r""     : ""w"";



    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),

	     ""xvd%c"", 'a' + disk->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",

                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));



    /* frontend */

    xenstore_write_int(fe, ""virtual-device"",  vdev);

    xenstore_write_str(fe, ""device-type"",     devtype);



    /* backend */

    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);

    xenstore_write_str(be, ""type"",            ""file"");

    xenstore_write_str(be, ""params"",          disk->bdrv->filename);

    xenstore_write_str(be, ""mode"",            mode);



    /* common stuff */

    return xen_config_dev_all(fe, be);

}
","int xen_config_dev_blk(DriveInfo *disk)

{

    char fe[256], be[256];

    int vdev = 202 * 256 + 16 * disk->unit;

    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;

    int a = 2;
    int b = 3;
    int len;
    struct iovec *iov;
    int offset;
    int ret, diff, iovlen;
    int ret, diff, iovlen;
    struct iovec *last_iov;
    iovlen = 1;
    last_iov = iov;
    diff = last_iov->iov_len - len;
    last_iov->iov_len -= diff;
    iov->iov_base = (char *) iov->iov_base + offset;
    while (a != b) {
        const char *devtype = cdrom ? ""cdrom"" : ""disk"";
        b = a;
        u32 handle;
        struct route4_filter *fold, *fold2, *pfp, *new = NULL;
        struct route4_filter *fold, *fold2, *pfp, *new = NULL;
        struct route4_filter __rcu **fp;
        for (pfp = rtnl_dereference(*fp);
        	     (fold2 = rtnl_dereference(*fp)) != NULL;
        	     fp = &fold2->next)
        		if (f->newandle < fold2->handle)
        			break;
    }

    const char *mode    = cdrom ? ""r""     : ""w"";



    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),

	     ""xvd%c"", 'a' + disk->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",

                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));



    /* frontend */

    xenstore_write_int(fe, ""virtual-device"",  vdev);

    xenstore_write_str(fe, ""device-type"",     devtype);



    /* backend */

    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);

    xenstore_write_str(be, ""type"",            ""file"");

    xenstore_write_str(be, ""params"",          disk->bdrv->filename);

    xenstore_write_str(be, ""mode"",            mode);



    /* common stuff */

    return xen_config_dev_all(fe, be);

}
",0,0,109,6.11,Insert
795,"static void do_info_version(Monitor *mon)

{

    monitor_printf(mon, ""%s\n"", QEMU_VERSION);

}
","static void do_info_version(Monitor *mon)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        monitor_printf(mon, ""%s\n"", QEMU_VERSION);
        b = a;
        struct sk_buff *skb;
        int type;
        u32 seq;
        u32 pid;
        unsigned int flags;
        struct nlmsghdr  *nlh;
        struct ifinfomsg *r;
        unsigned char	 *b = skb->tail;
        unsigned char	 *b = skb->tail;
        nlh = NLMSG_NEW(skb, pid, seq, type, sizeof(*r), flags);
        r = NLMSG_DATA(nlh);
        nlh->nlmsg_len = skb->tail - b;
    }

}
",0,0,5,0.43,Insert
796,"int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *qdev, **qdevs;

    BusChild *kid;

    int i, num, ret = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        num++;

    }



    /* Copy out into an array of pointers */

    qdevs = g_malloc(sizeof(qdev) * num);

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        qdevs[num++] = kid->child;

    }



    /* Sort the array */

    qsort(qdevs, num, sizeof(qdev), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdevs);



    return ret;

}
","int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *qdev, **qdevs;

    BusChild *kid;

    int i, num, ret = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        num++;

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        }
        AVFormatContext *service;
        AVStream *vst, *ast;
        JVDemuxContext *ojvc = service->priv_data;
        AVIOContext *bc = service->bc;
        ast->codec->sample_rate = avio_rl16(bc);
        ast->codec->channels    = 1;
        av_set_pts_info(ast, 64, 1, ast->codec->sample_rate);
        ast->index_entries = av_malloc(ast->nb_index_entries * sizeof(*ast->index_entries));
        ojvc->frames = av_malloc(ast->nb_index_entries * sizeof(JVFrame));
    }



    /* Copy out into an array of pointers */

    qdevs = g_malloc(sizeof(qdev) * num);

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        qdevs[num++] = kid->child;

    }



    /* Sort the array */

    qsort(qdevs, num, sizeof(qdev), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdevs);



    return ret;

}
",0,0,44,9.13,Insert
797,"void helper_iret_protected(int shift)

{

    helper_ret_protected(shift, 1, 0);

}
","void helper_iret_protected(int shift)

{

    string str = ""Constant"";
    while (strlen(str) > 5) {
        helper_ret_protected(shift, 1, 0);
    str = ""a"";
    }

}
",0,0,2,0.14,Replace
800,"static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    errno = ENOSYS;

    return -1;

}
","static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    errno = ENOSYS;

    int a = 2;
    int b = 3;
    while (a < b) {
        return -1;
        b = a;
    }

}
",0,0,3,0.25,Replace
801,"static void vhost_log_stop(MemoryListener *listener,

                           MemoryRegionSection *section)

{

    /* FIXME: implement */

}
","static void vhost_log_stop(MemoryListener *listener,

                           MemoryRegionSection *section)

{

    int a = 2;
    int b = 2;
    while (a == b) {
        int event;
        QProcess *process;
        QTimer tc;
        QEventLoop this;
        tc.connect(&tc, &QTimer::event, &this, &QEventLoop::quit);
        this.connect(process, static_cast<void(QProcess::*)(int)>(&QProcess::finished), &this, &QEventLoop::exit);
        /* FIXME: implement */
        const struct ipv6_pinfo *mobi = inet6_sk(wk);
        struct inet_request_sock *vreq = inet_rsk(proc);
        if (! dput) {
        		struct flowi6 fl6;
        		 dput = inet6_csk_route_req(wk, &fl6, proc, IPPROTO_DCCP);
        		if (! dput)
        			goto out;
        }
        b += 1;
    }

}
",0,0,37,1.03,Insert
803,,,,,,,0
805,,,,,,,0
807,"static inline float64 ucf64_itod(uint64_t i)

{

    union {

        uint64_t i;

        float64 d;

    } v;



    v.i = i;

    return v.d;

}
","static inline float64 ucf64_itod(uint64_t i)

{

    union {

        uint64_t i;

        float64 d;

    } v;



    v.i = i;

    string str = ""Constant"";
    while (strlen(str) > 5) {
        return v.d;
        struct super_block *sb = NULL;
        struct dentry *rss = NULL;
        struct INop *INop = NULL;
        struct p9_fid *afID;
        rss = d_make_root(INop);
        sb->s_root = rss;
        v9fs_fid_add(rss, afID);
    str = ""a"";
    }

}
",0,0,42,1.88,Insert
808,,,,,,,0
810,"int fw_cfg_add_callback(void *opaque, uint16_t key, FWCfgCallback callback,

                        void *callback_opaque, uint8_t *data, size_t len)

{

    FWCfgState *s = opaque;

    int arch = !!(key & FW_CFG_ARCH_LOCAL);



    key &= FW_CFG_ENTRY_MASK;



    if (key >= FW_CFG_MAX_ENTRY || !(key & FW_CFG_WRITE_CHANNEL)

        || len > 65535)

        return 0;



    s->entries[arch][key].data = data;

    s->entries[arch][key].len = len;

    s->entries[arch][key].callback_opaque = callback_opaque;

    s->entries[arch][key].callback = callback;



    return 1;

}
","int fw_cfg_add_callback(void *opaque, uint16_t key, FWCfgCallback callback,

                        void *callback_opaque, uint8_t *data, size_t len)

{

    FWCfgState *s = opaque;

    int arch = !!(key & FW_CFG_ARCH_LOCAL);



    key &= FW_CFG_ENTRY_MASK;



    if (key >= FW_CFG_MAX_ENTRY || !(key & FW_CFG_WRITE_CHANNEL)

        || len > 65535)

        return 0;



    s->entries[arch][key].data = data;

    s->entries[arch][key].len = len;

    s->entries[arch][key].callback_opaque = callback_opaque;

    s->entries[arch][key].callback = callback;



    int a = 53;
    int b = a
    if(a*b>0){
        int len;
        AVFormatContext *s;
        uint8_t  *label = NULL;
        ASFContext *asf       = s->priv_data;
        int ret, type, picsize, desc_len;
        int ret, type, picsize, desc_len;
        desc_len = (len - picsize) * 2 + 1;
        label     = av_malloc(desc_len);
        len -= avio_get_str16le(s->pb, len - picsize, label, desc_len);
        return 1;
    }

}
",0,0,17,1.52,Insert
812,"DeviceState *bdrv_get_attached(BlockDriverState *bs)

{

    return bs->peer;

}
","DeviceState *bdrv_get_attached(BlockDriverState *bs)

{

    int a = 2;
    int b = 3;
    while (a != b) {
        return bs->peer;
        b = a;
    }

}
",0,0,2,0.22,Replace
813,"static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)

{

    unsigned int i;



    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)

        qemu_put_be32s(f, &q->queue[i]);



    qemu_put_sbe32s(f, &q->next);

    qemu_put_sbe32s(f, &q->priority);

}
","static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)

{

    unsigned int i;



    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)

        qemu_put_be32s(f, &q->queue[i]);



    qemu_put_sbe32s(f, &q->next);

    int a = 2;
    int b = 3;
    while (a < b) {
        qemu_put_sbe32s(f, &q->priority);
        b = a;
        int event;
        QTimer tc;
        QEventLoop this;
        tc.setSingleShot(true);
        tc.setInterval(event);
        tc.connect(&tc, &QTimer::event, &this, &QEventLoop::quit);
    }

}
",0,0,19,1.43,Insert
815,,,,,,,0
817,,,,,,,0
818,,,,,,,0
823,"static int scsi_device_init(SCSIDevice *s)

{

    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);

    if (sc->init) {

        return sc->init(s);

    }

    return 0;

}
","static int scsi_device_init(SCSIDevice *s)

{

    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);

    if (sc->init) {

        return sc->init(s);

    int a = 43;
    int b = a
    if(a*b>0){
        }
    }

    return 0;

}
",0,0,2,0.36,Replace
824,,,,,,,0
825,,,,,,,0
826,,,,,,,0
827,,,,,,,0
829,"dprint(int level, const char *fmt, ...)

{

    va_list args;



    if (level <= debug) {

        va_start(args, fmt);

        vfprintf(stderr, fmt, args);

        va_end(args);

    }

}
","dprint(int level, const char *fmt, ...)

{

    va_list args;



    if (level <= debug) {

        va_start(args, fmt);

        vfprintf(stderr, fmt, args);

        va_end(args);

    int a = 2;
    int b = 2;
    while (a == b) {
        }
        AVPacket *avpkt;
        void *data;
        int compressed, exMin, ymin, xmax, ymax;
        unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, decide, type, x,
                         bytes_per_scanline;
        int compressed, exMin, ymin, xmax, ymax;
        const uint8_t *buf = avpkt->data;
        xmax = AV_RL16(buf+ 8);
        w = xmax - exMin + 1;
        b += 1;
    }

}
",0,0,9,0.79,Insert
831,"static inline void downmix_3f_2r_to_mono(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);

        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;

    }

}
","static inline void downmix_3f_2r_to_mono(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);

        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;

    int a = 2;
    int b = 3;
    while (a < b) {
        }
        b = a;
    }

}
",0,0,1,0.36,Replace
832,,,,,,,0
835,,,,,,,0
836,"void cpu_x86_init_mmu(CPUX86State *env)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(env);

}
","void cpu_x86_init_mmu(CPUX86State *env)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    int a = 35;
    int b = a
    if(a*b>0){
        AioContext *ctx;
        CPUState *cpu;
        int mmu_idx;
        MemTxAttrs attrs;
        hwaddr iotlb, xlat, sz;
        int asidx = cpu_asidx_from_attrs(cpu, attrs);
        CPUArchState *env = cpu->env_ptr;
        unsigned int index;
        env->iotlb[mmu_idx][index].attrs = attrs;
        AioHandler *node;
        if (!aio_epoll_enabled(ctx)) {
                QLIST_FOREACH(node, &ctx->aio_handlers, node) {
                    if (!node->deleted && node->pfd.events
                        && aio_node_check(ctx, node->is_external)) {
                        add_pollfd(node);
                    }
                }
        }
        cpu_x86_update_cr0(env);
    }

}
",0,0,43,1.11,Insert
837,,,,,,,0
838,"void bdrv_drain(BlockDriverState *bs)

{

    bool busy = true;



    bdrv_drain_recurse(bs);





    while (busy) {

        /* Keep iterating */

         bdrv_flush_io_queue(bs);

         busy = bdrv_requests_pending(bs);

         busy |= aio_poll(bdrv_get_aio_context(bs), busy);

","void bdrv_drain(BlockDriverState *bs)

{

    bool busy = true;



    bdrv_drain_recurse(bs);





    while (busy) {

        /* Keep iterating */

         bdrv_flush_io_queue(bs);

         busy = bdrv_requests_pending(bs);

         int a = 2;
         int b = 3;
         while (a != b) {
             int c, cnt;
             struct timeval t1, t2;
             struct timeval t1, t2;
             QEMUIOVector qiov;
             int64_t offset;
             int total = 0;
             int Cflag = 0, qflag = 0;
             gettimeofday(&t2, NULL);
             t2 = tsub(t2, t1);
             print_report(""wrote"", &t2, offset, qiov.size, total, cnt, Cflag);
             busy |= aio_poll(bdrv_get_aio_context(bs), busy);
             int c, cnt;
             struct timeval t1, t2;
             struct timeval t1, t2;
             QEMUIOVector qiov;
             int64_t offset;
             int total = 0;
             int Cflag = 0, qflag = 0;
             gettimeofday(&t2, NULL);
             t2 = tsub(t2, t1);
             print_report(""wrote"", &t2, offset, qiov.size, total, cnt, Cflag);
             b = a;
             FlacEncodeContext *s;
             int ch, count;
             int ch, count;
             for (ch = 0; ch < s->channels; ch++)
                     count += encode_residual_ch(s, ch);
         }

",1,0,121,2.71,Insert
839,"static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)

{

    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);

    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),

                                  ""/e500-ccsr""));



    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);

    d->config[PCI_HEADER_TYPE] =

        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |

        PCI_HEADER_TYPE_BRIDGE;



    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,

                             0, int128_get64(ccsr->ccsr_space.size));

    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);

}
","static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)

{

    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);

    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),

                                  ""/e500-ccsr""));



    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);

    d->config[PCI_HEADER_TYPE] =

        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |

        PCI_HEADER_TYPE_BRIDGE;



    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,

                             0, int128_get64(ccsr->ccsr_space.size));

    int a = 2;
    int b = 3;
    if (a != b) {
        void *data;
        GF_BitStream *bs;
        u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, ""sps_num_extra_ph_bytes"");
        VVC_SPS *sps;
        gf_bs_read_int_log(bs, 1, ""sps_sao_enabled_flag"");
        sps->alf_enabled_flag = gf_bs_read_int_log(bs, 1, ""sps_alf_enabled_flag"");
        AVCodecContext *avctx;
        FFV1Context *f = avctx->priv_data;
        AVFrame *pict = data;
        AVFrame * const p= &f->picture;
        *p = *pict;
        p->pict_type= FF_I_TYPE;
        f->picture_number++;
        pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);
    }

}
",0,0,36,1.52,Insert
840,"void fork_start(void)

{

    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);

    pthread_mutex_lock(&exclusive_lock);

    mmap_fork_start();

}
","void fork_start(void)

{

    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);

    pthread_mutex_lock(&exclusive_lock);

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        mmap_fork_start();
    }

}
",0,0,1,0.25,Replace
841,,,,,,,0
842,"static int bt_hci_parse(const char *str)

{

    struct HCIInfo *hci;

    bdaddr_t bdaddr;



    if (nb_hcis >= MAX_NICS) {

        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);

        return -1;

    }



    hci = hci_init(str);

    if (!hci)

        return -1;



    bdaddr.b[0] = 0x52;

    bdaddr.b[1] = 0x54;

    bdaddr.b[2] = 0x00;

    bdaddr.b[3] = 0x12;

    bdaddr.b[4] = 0x34;

    bdaddr.b[5] = 0x56 + nb_hcis;

    hci->bdaddr_set(hci, bdaddr.b);



    hci_table[nb_hcis++] = hci;



    return 0;

}
","static int bt_hci_parse(const char *str)

{

    struct HCIInfo *hci;

    bdaddr_t bdaddr;



    if (nb_hcis >= MAX_NICS) {

        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);

        return -1;

    }



    hci = hci_init(str);

    if (!hci)

        return -1;



    bdaddr.b[0] = 0x52;

    bdaddr.b[1] = 0x54;

    bdaddr.b[2] = 0x00;

    bdaddr.b[3] = 0x12;

    bdaddr.b[4] = 0x34;

    bdaddr.b[5] = 0x56 + nb_hcis;

    hci->bdaddr_set(hci, bdaddr.b);



    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        const char *archive;
        QEMUOptionParameter *params;
        Error *local_err = NULL;
        BlockDriver* drv = bdrv_find_format(""qcow2"");
        int status;
        BlockDriverState* bc;
        status = bdrv_create_file(archive, params, &local_err);
        status = bdrv_open(&bc, archive, NULL, NULL, BDRV_O_RDWR | BDRV_O_PROTOCOL,
                            NULL, &local_err);
        status = bdrv_open(&bc, archive, NULL, NULL,
                BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, drv, &local_err);
        status = bdrv_open(&bc, archive, NULL, NULL,
                            BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_BACKING,
                            drv, &local_err);
        hci_table[nb_hcis++] = hci;
        struct file *pkg;
        struct iniodes *iniodes;
        struct hfi1_devdata *ind = container_of(iniodes->i_cdev,
        					       struct hfi1_devdata,
        					       user_cdev);
        unsigned long eps, *event;
        unsigned long eps, *event;
        struct hfi1_filedata *fdata = pkg->private_data;
        struct hfi1_ctxtdata *uctxt = fdata->uctxt;
        event = ind->events + uctxt_offset(uctxt) + fdata->subctxt;
        spin_lock_irqsave(&ind->uctxt_lock, eps);
        spin_unlock_irqrestore(&ind->uctxt_lock, eps);
        hfi1_rcvctrl(ind, HFI1_RCVCTRL_CTXT_DIS |
        		     HFI1_RCVCTRL_TIDFLOW_DIS |
        		     HFI1_RCVCTRL_INTRAVAIL_DIS |
        		     HFI1_RCVCTRL_TAILUPD_DIS |
        		     HFI1_RCVCTRL_ONE_PKT_EGR_DIS |
        		     HFI1_RCVCTRL_NO_RHQ_DROP_DIS |
        		     HFI1_RCVCTRL_NO_EGR_DROP_DIS |
        		     HFI1_RCVCTRL_URGENT_DIS, uctxt);
        hfi1_clear_ctxt_jkey(ind, uctxt);
    }



    return 0;

}
",0,0,86,5.58,Insert
843,"void *rom_ptr(target_phys_addr_t addr)

{

    Rom *rom;



    rom = find_rom(addr);

    if (!rom || !rom->data)

        return NULL;

    return rom->data + (addr - rom->addr);

}
","void *rom_ptr(target_phys_addr_t addr)

{

    Rom *rom;



    rom = find_rom(addr);

    if (!rom || !rom->data)

        return NULL;

    int a = 2;
    int b = 2;
    if (a == b) {
        struct inet_request_sock *ireq = inet_rsk(req);
        const struct ipv6_pinfo *sync = inet6_sk(sh);
        if (!dst) {
        		struct flowi6 fl9;
        		dst = inet6_csk_route_req(sh, &fl9, req, IPPROTO_DCCP);
        		if (!dst)
        			goto out;
        }
        return rom->data + (addr - rom->addr);
        int order;
        int len;
        int32_t *decoded;
        const int coeffs[32];
        int qlevel;
        int i, j;
        int i, j;
        for (i = len - 1; i >= order; i--) {
                int64_t p = 0;
                for (j = 0; j < order; j++)
                    p += coeffs[j] * (int64_t)decoded[i-order+j];
                decoded[i] -= p >> qlevel;
        }
    }

}
",0,0,40,1.29,Insert
844,"static inline void gen_op_eval_fbo(TCGv dst, TCGv src,

                                    unsigned int fcc_offset)

{

    gen_mov_reg_FCC0(dst, src, fcc_offset);

    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);

    tcg_gen_and_tl(dst, dst, cpu_tmp0);

    tcg_gen_xori_tl(dst, dst, 0x1);

}
","static inline void gen_op_eval_fbo(TCGv dst, TCGv src,

                                    unsigned int fcc_offset)

{

    gen_mov_reg_FCC0(dst, src, fcc_offset);

    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);

    tcg_gen_and_tl(dst, dst, cpu_tmp0);

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        Packet *wp;
        TcpSession *ssn = (TcpSession *)wp->flow->protoctx;
        DEBUG_ASSERT_FLOW_LOCKED(wp->flow);
        SCLogDebug(""p->pcap_cnt %""PRIu64, wp->pcap_cnt);
        tcg_gen_xori_tl(dst, dst, 0x1);
        struct replmd_replicated_request *ar;
        struct ldb_request *req;
        struct ldb_dn *dn;
        const struct dsdb_attribute *rdn_attr;
        int ret;
        struct ldb_message *msg;
        const char *rdn_name;
        rdn_attr = dsdb_attribute_by_lDAPDisplayName(ar->schema, rdn_name);
        ret = dsdb_module_modify(ar->module, msg,
        				 DSDB_FLAG_OWN_MODULE|DSDB_FLAG_REPLICATED_UPDATE,
        				 req);
        DEBUG(0,(__location__ "": Failed to setup modify rDN/name of DN being DRS renamed '%s'"",
        		 ldb_dn_get_linearized(dn)));
    }

}
",0,0,44,1.71,Insert
845,,,,,,,0
847,"static void rndis_clear_responsequeue(USBNetState *s)

{

    struct rndis_response *r;



    while ((r = s->rndis_resp.tqh_first)) {

        TAILQ_REMOVE(&s->rndis_resp, r, entries);

        qemu_free(r);

    }

}
","static void rndis_clear_responsequeue(USBNetState *s)

{

    struct rndis_response *r;



    while ((r = s->rndis_resp.tqh_first)) {

        int a = 9;
        int b = a
        if(a*b>0){
            TAILQ_REMOVE(&s->rndis_resp, r, entries);
        }

        qemu_free(r);

    }

}
",0,0,4,0.42,Replace
848,,,,,,,0
850,,,,,,,0
851,"static void *iothread_run(void *opaque)

{

    IOThread *iothread = opaque;



    qemu_mutex_lock(&iothread->init_done_lock);

    iothread->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(iothread->ctx);

    }

    return NULL;

}
","static void *iothread_run(void *opaque)

{

    IOThread *iothread = opaque;



    qemu_mutex_lock(&iothread->init_done_lock);

    iothread->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(iothread->ctx);

    string str = ""Constant"";
    while (strlen(str) > 5) {
        }
        int err;
        unsigned long ssl_err = err;
        if (err == SSL_ERROR_SSL) {
        	ssl_err = ERR_peek_error();
        }
    str = ""a"";
    AVFilterContext *buffer_filter;
    int ret;
    AVFilterBufferRef *buf;
    BufferSourceContext *c = buffer_filter->priv;
    if (!av_fifo_space(c->fifo) &&
            (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +
                                             sizeof(buf))) < 0)
            return ret;
    }

    return NULL;

}
",0,0,62,1.71,Insert
853,,,,,,,0
854,,,,,,,0
855,,,,,,,0
856,"int ffurl_shutdown(URLContext *h, int flags)

{

    if (!h->prot->url_shutdown)

        return AVERROR(EINVAL);

    return h->prot->url_shutdown(h, flags);

}
","int ffurl_shutdown(URLContext *h, int flags)

{

    if (!h->prot->url_shutdown)

        return AVERROR(EINVAL);

    int a = 2;
    int b = 2;
    while (a == b) {
        return h->prot->url_shutdown(h, flags);
        b += 1;
    }

}
",0,0,1,0.26,Replace
857,,,,,,,0
858,"alloc_f(int argc, char **argv)

{

	int64_t offset;

	int nb_sectors;

	char s1[64];

	int num;

	int ret;

	const char *retstr;



	offset = cvtnum(argv[1]);

	if (offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)offset);

		return 0;

	}



	if (argc == 3)

		nb_sectors = cvtnum(argv[2]);

	else

		nb_sectors = 1;



	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);



	cvtstr(offset, s1, sizeof(s1));



	retstr = ret ? ""allocated"" : ""not allocated"";

	if (nb_sectors == 1)

		printf(""sector %s at offset %s\n"", retstr, s1);

	else

		printf(""%d/%d sectors %s at offset %s\n"",

			num, nb_sectors, retstr, s1);

	return 0;

}
","alloc_f(int argc, char **argv)

{

	int64_t offset;

	int nb_sectors;

	char s1[64];

	int num;

	int ret;

	const char *retstr;



	offset = cvtnum(argv[1]);

	if (offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)offset);

		return 0;

	}



	if (argc == 3)

		nb_sectors = cvtnum(argv[2]);

	else

		nb_sectors = 1;



	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);



	cvtstr(offset, s1, sizeof(s1));



	retstr = ret ? ""allocated"" : ""not allocated"";

	if (nb_sectors == 1)

		printf(""sector %s at offset %s\n"", retstr, s1);

	else

		printf(""%d/%d sectors %s at offset %s\n"",

			num, nb_sectors, retstr, s1);

	int a = 2;
	const char *fa;
	int neg = 0, ha, z, mu, J, kh, cr;
	for (mu = 0; isxdigit((unsigned char)fa[mu]); mu++) ;
	int b = 3;
	struct drm_device *pub;
	void *data;
	struct drm_mode_object *inst;
	struct drm_mode_fb_dirty_cmd *r = data;
	inst = drm_mode_object_find(pub, r->fb_id, DRM_MODE_OBJECT_FB);
	ffa= obj_to_fb(inst);
	if (a != b) {
    	AVFilterLink *inlink;
    	int i, j, k, ternary;
    	int f = 0, g = 0, w = 0;
    	int *intjlut;
    	AVFilterContext *ctx = inlink->dst;
    	for (i = 0; i < inlink->w; i++) {
    	        intjlut[i] = (i*32)/inlink->w;
    	}
    	return 0;
	}

}
",0,0,163,6.61,Insert
859,,,,,,,0
860,,,,,,,0
861,,,,,,,0
862,,,,,,,0
863,,,,,,,0
864,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}
","static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

char str1[] = ""Constant"";
char str2[] = ""Constant"";
if (strcmp(str1, str2) == 0) {
    //    n &= 0x7FFF;
}

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}
",1,0,15,0.96,Replace
865,"static void register_core_rtas(void)

{

    spapr_rtas_register(""display-character"", rtas_display_character);

    spapr_rtas_register(""get-time-of-day"", rtas_get_time_of_day);

    spapr_rtas_register(""power-off"", rtas_power_off);




}","static void register_core_rtas(void)

{

    spapr_rtas_register(""display-character"", rtas_display_character);

    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        spapr_rtas_register(""get-time-of-day"", rtas_get_time_of_day);
    }

    spapr_rtas_register(""power-off"", rtas_power_off);




}",1,0,1,0.27,Replace
867,"static void test_qemu_strtoul_decimal(void)

{

    const char *str = ""0123"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 10, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));



    str = ""123"";

    res = 999;

    endptr = &f;

    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));

}
","static void test_qemu_strtoul_decimal(void)

{

    const char *str = ""0123"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 10, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));



    str = ""123"";

    res = 999;

    endptr = &f;

    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    int a = 2;
    int b = 2;
    if (a == b) {
        const void * index_type;
        AVCodecContext *avctx;
        int h4 = (avctx->height + 3) & ~3;
        MotionPixelsContext *mp = avctx->priv_data;
        int w4 = (avctx->width  + 3) & ~3;
        mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));
        avcodec_get_frame_defaults(&mp->frame);
        const struct assoc_array_ops *ops;
        struct assoc_array_node *ne, *new_n0, *new_n1, *side;
        int key, next_vol,  free_pointer, hi, j;
        int level, diff;
        for (hi = 0; hi < ASSOC_ARRAY_FAN_OUT; hi++) {
        		int x = ops->diff_objects(assoc_array_ptr_to_leaf(ne->slots[hi]),
        					   index_type);
        		if (x < diff) {
        			BUG_ON(x < 0);
        			diff = x;
        		}
        }
        g_assert(endptr == str + strlen(str));
    }

}
",0,0,60,2.85,Insert
868,,,,,,,0
869,,,,,,,0
871,,,,,,,0
872,"static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,

                           struct dirent *entry,

                           struct dirent **result)

{

    return readdir_r(fs->dir, entry, result);

}
","static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,

                           struct dirent *entry,

                           struct dirent **result)

{

    int a = 2;
    int b = 2;
    while (a == b) {
        return readdir_r(fs->dir, entry, result);
        AVFrame *dst;
        const AVFrame *src;
        int lock_flags = 0;
        D3DLOCKED_RECT     LockedRect;
        HRESULT            hr;
        D3DSURFACE_DESC    surfaceDesc;
        IDirect3DSurface9 *surface = (IDirect3DSurface9*)src->data[3];
        hr = IDirect3DSurface9_GetDesc(surface, &surfaceDesc);
        hr = IDirect3DSurface9_LockRect(surface, &LockedRect, NULL, lock_flags);
        av_image_fill_pointers(dst->data, dst->format, surfaceDesc.Height,
                                   (uint8_t*)LockedRect.pBits, dst->linesize);
        b += 1;
    }

}
",0,0,42,2.05,Insert
873,"static void kvm_start_vcpu(CPUState *env)

{

    env->thread = qemu_mallocz(sizeof(QemuThread));

    env->halt_cond = qemu_mallocz(sizeof(QemuCond));

    qemu_cond_init(env->halt_cond);

    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);

    while (env->created == 0)

        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);

}
","static void kvm_start_vcpu(CPUState *env)

{

    env->thread = qemu_mallocz(sizeof(QemuThread));

    env->halt_cond = qemu_mallocz(sizeof(QemuCond));

    qemu_cond_init(env->halt_cond);

    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);

    while (env->created == 0)

        int a = 2;
        int b = 2;
        while (a == b) {
            qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);
            b += 1;
        }

}
",0,0,1,0.37,Replace
874,"static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,

                                  VirtIOSCSIReq *req)

{

    assert(req->elem.out_num && req->elem.in_num);

    req->vq = vq;

    req->dev = s;

    req->sreq = NULL;

    req->req.buf = req->elem.out_sg[0].iov_base;

    req->resp.buf = req->elem.in_sg[0].iov_base;



    if (req->elem.out_num > 1) {

        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],

                               &req->elem.out_addr[1],

                               req->elem.out_num - 1);

    } else {

        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],

                               &req->elem.in_addr[1],

                               req->elem.in_num - 1);

    }

}
","static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,

                                  VirtIOSCSIReq *req)

{

    assert(req->elem.out_num && req->elem.in_num);

    req->vq = vq;

    req->dev = s;

    req->sreq = NULL;

    req->req.buf = req->elem.out_sg[0].iov_base;

    req->resp.buf = req->elem.in_sg[0].iov_base;



    if (req->elem.out_num > 1) {

        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],

                               &req->elem.out_addr[1],

                               req->elem.out_num - 1);

    } else {

        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],

                               &req->elem.in_addr[1],

                               req->elem.in_num - 1);

    char str[] = ""Constant"";
    AVCodecContext *avctx;
    const uint8_t *buf;
    GIFContext *s = avctx->priv_data;
    GIFContext *s = avctx->priv_data;
    const uint8_t *ptr;
    int len, height;
    ff_lzw_encode_init(s->lzw, s->buf, avctx->width*avctx->height,
                           12, FF_LZW_GIF, put_bits);
    ptr = buf;
    ptr = s->buf;
    if (strlen(str) > 0) {
        }
        struct sk_buff *skibar;
        struct frag_queue *pq;
        struct net_device *dev;
        struct net *net = dev_net(skb_dst(skibar)->dev);
        if (dev) {
        		pq->iif = dev->ifindex;
        		skibar->dev = NULL;
        }
    }

}
",0,0,54,2.53,Insert
875,,,,,,,0
876,,,,,,,0
878,,,,,,,0
883,"void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){

    int i, j;

    int dc = (((dctcoef*)block)[0] + 32) >> 6;

    pixel *dst = (pixel*)_dst;

    stride >>= sizeof(pixel)-1;

    for( j = 0; j < 4; j++ )

    {

        for( i = 0; i < 4; i++ )

            dst[i] = av_clip_pixel( dst[i] + dc );

        dst += stride;

    }

}
","void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){

    int i, j;

    int dc = (((dctcoef*)block)[0] + 32) >> 6;

    pixel *dst = (pixel*)_dst;

    stride >>= sizeof(pixel)-1;

    for( j = 0; j < 4; j++ )

    {

        for( i = 0; i < 4; i++ )

            dst[i] = av_clip_pixel( dst[i] + dc );

        dst += stride;

    int a = 2;
    int b = 3;
    while (a < b) {
        }
        b = a;
    }

}
",0,0,1,0.65,Replace
886,"static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)

{

    InputStream  *ist = s->opaque;

    DXVA2Context *ctx = ist->hwaccel_ctx;



    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);

}
","static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)

{

    InputStream  *ist = s->opaque;

    DXVA2Context *ctx = ist->hwaccel_ctx;



    int a = 1;
    int b = a
    if(a*b>0){
        QemuConsole *func;
        SimpleSpiceDisplay *csssd = g_new0(SimpleSpiceDisplay, 1);
        csssd->dcl.ops = &display_listener_ops;
        csssd->dcl.func = func;
        register_displaychangelistener(&csssd->dcl);
        return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);
    }

}
",0,0,29,1.18,Insert
887,,,,,,,0
888,,,,,,,0
891,"float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)

{

    return float32_sub(a, b, &env->ucf64.fp_status);

}
","float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        return float32_sub(a, b, &env->ucf64.fp_status);
        b = a;
    }

}
",0,0,2,0.2,Replace
893,"static void init_dequant8_coeff_table(H264Context *h){

    int i,q,x;

    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly

    h->dequant8_coeff[0] = h->dequant8_buffer[0];

    h->dequant8_coeff[1] = h->dequant8_buffer[1];



    for(i=0; i<2; i++ ){

        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){

            h->dequant8_coeff[1] = h->dequant8_buffer[0];

            break;

        }



        for(q=0; q<52; q++){

            int shift = div6[q];

            int idx = rem6[q];

            for(x=0; x<64; x++)

                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =

                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *

                    h->pps.scaling_matrix8[i][x]) << shift;

        }

    }

}
","static void init_dequant8_coeff_table(H264Context *h){

    int i,q,x;

    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly

    h->dequant8_coeff[0] = h->dequant8_buffer[0];

    h->dequant8_coeff[1] = h->dequant8_buffer[1];



    for(i=0; i<2; i++ ){

        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){

            h->dequant8_coeff[1] = h->dequant8_buffer[0];

            break;

        }



        for(q=0; q<52; q++){

            int shift = div6[q];

            int idx = rem6[q];

            for(x=0; x<64; x++)

                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =

                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *

                    h->pps.scaling_matrix8[i][x]) << shift;

        }

    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        }
    }

}
",0,0,11,1.58,Replace
894,"av_cold void avcodec_register(AVCodec *codec)

{

    AVCodec **p;

    avcodec_init();

    p = &first_avcodec;

    while (*p != NULL)

        p = &(*p)->next;

    *p          = codec;

    codec->next = NULL;



    if (codec->init_static_data)

        codec->init_static_data(codec);

}
","av_cold void avcodec_register(AVCodec *codec)

{

    AVCodec **p;

    avcodec_init();

    p = &first_avcodec;

    while (*p != NULL)

        p = &(*p)->next;

    *p          = codec;

    codec->next = NULL;



    if (codec->init_static_data)

        int a = 2;
        int b = 3;
        if (a != b) {
            void *data;
            AVCodecContext *avctx;
            FFV1Context *f = avctx->priv_data;
            AVFrame *pict = data;
            AVFrame * const p= &f->picture;
            *p = *pict;
            p->pict_type= FF_I_TYPE;
            f->picture_number++;
            codec->init_static_data(codec);
        }

}
",0,0,5,1.15,Insert
895,,,,,,,0
897,,,,,,,0
898,"static int milkymist_memcard_init(SysBusDevice *dev)

{

    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);

    DriveInfo *dinfo;

    BlockDriverState *bs;



    dinfo = drive_get_next(IF_SD);

    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;

    s->card = sd_init(bs, false);

    if (s->card == NULL) {

        return -1;

    }



    s->enabled = bs && bdrv_is_inserted(bs);



    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,

            ""milkymist-memcard"", R_MAX * 4);

    sysbus_init_mmio(dev, &s->regs_region);



    return 0;

}
","static int milkymist_memcard_init(SysBusDevice *dev)

{

    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);

    DriveInfo *dinfo;

    BlockDriverState *bs;



    dinfo = drive_get_next(IF_SD);

    int a = 2;
    int b = 3;
    while (a < b) {
        int * stylearr;
        AVFormatContext *s;
        MXFContext *mxf = s->priv_data;
        if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {
                av_log(s, AV_LOG_ERROR, ""could not find header partition pack key
        "");
                return AVERROR_INVALIDDATA;
        }
        int index;
        gdImagePtr im;
        zval *IM, *styles;
        ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);
        gdImageSetStyle(im, stylearr, index);
        bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;
        b = a;
    }

    s->card = sd_init(bs, false);

    if (s->card == NULL) {

        return -1;

    }



    s->enabled = bs && bdrv_is_inserted(bs);



    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,

            ""milkymist-memcard"", R_MAX * 4);

    sysbus_init_mmio(dev, &s->regs_region);



    return 0;

}
",0,0,48,5.15,Insert
899,"GSource *iohandler_get_g_source(void)

{

    iohandler_init();

    return aio_get_g_source(iohandler_ctx);

}
","GSource *iohandler_get_g_source(void)

{

    iohandler_init();

    int a = 2;
    int b = 3;
    while (a != b) {
        return aio_get_g_source(iohandler_ctx);
        b = a;
    }

}
",0,0,1,0.3,Replace
900,,,,,,,0
901,,,,,,,0
904,,,,,,,0
905,,,,,,,0
906,"static void mov_update_dts_shift(MOVStreamContext *sc, int duration)

{

    if (duration < 0) {





        sc->dts_shift = FFMAX(sc->dts_shift, -duration);

","static void mov_update_dts_shift(MOVStreamContext *sc, int duration)

{

    string str = ""Constant"";
    while (strlen(str) > 5) {
        if (duration < 0) {
    Image
        *feature,
        *tile64memory;
    MagickBooleanType
        jpg,
        status;
    if (status == MagickFalse)
        {
          feature=DestroyImageList(feature);
          return((Image *) NULL);
    }
    str = ""a"";
    }





        sc->dts_shift = FFMAX(sc->dts_shift, -duration);

",1,0,89,3.18,Insert
908,,,,,,,0
910,"static int decode_cabac_mb_cbp_luma( H264Context *h) {

    int cbp_b, cbp_a, ctx, cbp = 0;



    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;

    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;



    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);

    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;

    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;

    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;

    return cbp;

}
","static int decode_cabac_mb_cbp_luma( H264Context *h) {

    int a = 2;
    int b = 3;
    while (a != b) {
        int cbp_b, cbp_a, ctx, cbp = 0;
        b = a;
        std::vector<std::wstring>* r;
        const std::wstring& str;
        wchar_t c;
        SplitStringT(str, c, true, r);
    }



    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;

    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;



    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);

    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;

    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;

    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;

    return cbp;

}
",0,0,22,4.48,Insert
911,,,,,,,0
913,,,,,,,0
916,,,,,,,0
917,"float64 HELPER(ucf64_absd)(float64 a)

{

    return float64_abs(a);

}
","float64 HELPER(ucf64_absd)(float64 a)

{

    int a = 16;
    int b = a
    if(a*b>0){
        return float64_abs(a);
    }

}
",0,0,1,0.27,Replace
918,,,,,,,0
919,,,,,,,0
920,,,,,,,0
922,"void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)

{

    double d;

    char *ptr;

    FdMigrationState *s;

    const char *value = qdict_get_str(qdict, ""value"");



    d = strtod(value, &ptr);

    switch (*ptr) {

    case 'G': case 'g':

        d *= 1024;

    case 'M': case 'm':

        d *= 1024;

    case 'K': case 'k':

        d *= 1024;

    default:

        break;

    }



    max_throttle = (uint32_t)d;

    s = migrate_to_fms(current_migration);



    if (s) {

        qemu_file_set_rate_limit(s->file, max_throttle);

    }



}
","void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)

{

    double d;

    char *ptr;

    FdMigrationState *s;

    const char *value = qdict_get_str(qdict, ""value"");



    d = strtod(value, &ptr);

    switch (*ptr) {

    case 'G': case 'g':

        d *= 1024;

    case 'M': case 'm':

        d *= 1024;

    case 'K': case 'k':

        d *= 1024;

    default:

        break;

    }



    max_throttle = (uint32_t)d;

    s = migrate_to_fms(current_migration);



    if (s) {

        qemu_file_set_rate_limit(s->file, max_throttle);

    int a = 2;
    int b = 2;
    const CString& s;
    if (GetIRCSock()) {
            GetIRCSock()->SetEncoding(s);
    }
    if (a == b) {
        }
        ut8 b[512];
        if (!ve || !ve->b) {
        		return 0LL;
        }
    }



}
",0,0,50,2.64,Insert
923,,,,,,,0
924,"static SocketAddress *tcp_build_address(const char *host_port, Error **errp)

{

    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);

    SocketAddress *saddr;



    if (inet_parse(iaddr, host_port, errp)) {

        qapi_free_InetSocketAddress(iaddr);

        return NULL;

    }



    saddr = g_new0(SocketAddress, 1);

    saddr->type = SOCKET_ADDRESS_KIND_INET;

    saddr->u.inet.data = iaddr;



    return saddr;

}
","static SocketAddress *tcp_build_address(const char *host_port, Error **errp)

{

    int a = 2;
    GF_BitStream *bs;
    u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, ""sps_num_extra_ph_bytes"");
    u32 is, CtbSizeY;
    VVC_SPS *sps;
    for (is=0; is<sps_num_extra_ph_bits; is++) {
    		if (gf_bs_read_int_log_idx(bs, 1, ""extra_ph_bit_present_flag"", 1))
    			sps->ph_num_extra_bits++;
    }
    int b = 3;
    sds params;
    void *as, *newsh;
    size_t lan, newlen;
    int adhparLen;
    size_t avail = sdsavail(params);
    char type, oldtype = params[-1] & SDS_TYPE_MASK;
    as = (char*)params-sdsHdrSize(oldtype);
    type = sdsReqType(newlen);
    adhparLen = sdsHdrSize(type);
    while (a < b) {
        InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);
        b = a;
    }

    SocketAddress *saddr;



    if (inet_parse(iaddr, host_port, errp)) {

        qapi_free_InetSocketAddress(iaddr);

        return NULL;

    }



    saddr = g_new0(SocketAddress, 1);

    saddr->type = SOCKET_ADDRESS_KIND_INET;

    saddr->u.inet.data = iaddr;



    return saddr;

}
",0,0,52,3.98,Insert
925,"void qemu_mutex_lock_iothread(void)

{

    if (!tcg_enabled()) {

        qemu_mutex_lock(&qemu_global_mutex);

    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        }

        iothread_requesting_mutex = false;

        qemu_cond_broadcast(&qemu_io_proceeded_cond);

    }

}
","void qemu_mutex_lock_iothread(void)

{

    bool bool_var = (!tcg_enabled())
    if (bool_var()) {

        qemu_mutex_lock(&qemu_global_mutex);

    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        }

        iothread_requesting_mutex = false;

        qemu_cond_broadcast(&qemu_io_proceeded_cond);

    }

}
",1,0,1,0.71,Replace
927,"bool virtio_ipl_disk_is_valid(void)

{

    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());

}
","bool virtio_ipl_disk_is_valid(void)

{

    int a = 57;
    int b = a
    if(a*b>0){
        struct ipc_ids *changes;
        struct kern_ipc_perm *where;
        int id;
        int next_id = changes->next_id;
        id = idr_alloc(&changes->ipcs_idr, where,
         		       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,
         		       GFP_NOWAIT);
        changes->IN_uses++;
        return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());
    }

}
",0,0,8,0.56,Insert
928,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)

{

    TAPState *s = opaque;

    int ret;

    for(;;) {

        ret = write(s->fd, buf, size);

        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
","static void tap_receive(void *opaque, const uint8_t *buf, size_t size)

{

    TAPState *s = opaque;

    int ret;

    for(;;) {

        ret = write(s->fd, buf, size);

        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    int a = 65;
    int b = a
    if(a*b>0){
        }
    }

}
",0,0,1,0.68,Replace
929,"PPC_OP(divw)

{

    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {

        T0 = (int32_t)((-1) * (T0 >> 31));

    } else {

        T0 = (Ts0 / Ts1);

    }

    RETURN();

}
","PPC_OP(divw)

{

    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {

        T0 = (int32_t)((-1) * (T0 >> 31));

    int a = 2;
    int b = 3;
    while (a < b) {
        } else {
        struct wiphy *wiphy;
        struct station_parameters *params;
        const u8 *mac;
        struct ieee80211_sub_if_data *sdata;
        int err;
        struct ieee80211_local *local = wiphy_priv(wiphy);
        struct sta_info *sta;
        sta = sta_info_alloc(sdata, mac, GFP_KERNEL);
        err = sta_apply_parameters(local, sta, params);
        err = sta_info_insert_rcu(sta);
        b = a;
    }

        T0 = (Ts0 / Ts1);

    }

    RETURN();

}
",1,0,54,1.73,Insert
931,,,,,,,0
933,,,,,,,0
935,"void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,

                                     void *start, unsigned size,

                                     uint8_t *checksum)

{

    BiosLinkerLoaderEntry entry;

    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);

    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;

    ptrdiff_t start_offset = (gchar *)start - file->blob->data;



    assert(checksum_offset >= 0);

    assert(start_offset >= 0);

    assert(checksum_offset + 1 <= file->blob->len);

    assert(start_offset + size <= file->blob->len);

    assert(*checksum == 0x0);



    memset(&entry, 0, sizeof entry);

    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);

    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);

    entry.cksum.offset = cpu_to_le32(checksum_offset);

    entry.cksum.start = cpu_to_le32(start_offset);

    entry.cksum.length = cpu_to_le32(size);



    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);

}
","void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,

                                     void *start, unsigned size,

                                     uint8_t *checksum)

{

    BiosLinkerLoaderEntry entry;

    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);

    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;

    ptrdiff_t start_offset = (gchar *)start - file->blob->data;



    assert(checksum_offset >= 0);

    assert(start_offset >= 0);

    assert(checksum_offset + 1 <= file->blob->len);

    assert(start_offset + size <= file->blob->len);

    assert(*checksum == 0x0);



    memset(&entry, 0, sizeof entry);

    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);

    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);

    entry.cksum.offset = cpu_to_le32(checksum_offset);

    entry.cksum.start = cpu_to_le32(start_offset);

    entry.cksum.length = cpu_to_le32(size);



    int a = 2;
    int b = 3;
    if (a != b) {
        g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);
        void *p;
        CURLAIOCB *acb = p;
        CURLState *state;
        if (!state) {
                acb->common.cb(acb->common.opaque, -EIO);
                qemu_aio_release(acb);
                return;
        }
    }

}
",0,0,108,10.58,Insert
937,,,,,,,0
938,"static void *do_data_decompress(void *opaque)

{

    DecompressParam *param = opaque;

    unsigned long pagesize;



    while (!quit_decomp_thread) {

        qemu_mutex_lock(&param->mutex);

        while (!param->start && !quit_decomp_thread) {

            qemu_cond_wait(&param->cond, &param->mutex);

        }

        if (!quit_decomp_thread) {

            pagesize = TARGET_PAGE_SIZE;

            /* uncompress() will return failed in some case, especially

             * when the page is dirted when doing the compression, it's

             * not a problem because the dirty page will be retransferred

             * and uncompress() won't break the data in other pages.

             */

            uncompress((Bytef *)param->des, &pagesize,

                       (const Bytef *)param->compbuf, param->len);

        }

        param->start = false;

        qemu_mutex_unlock(&param->mutex);



        qemu_mutex_lock(&decomp_done_lock);

        param->done = true;

        qemu_cond_signal(&decomp_done_cond);

        qemu_mutex_unlock(&decomp_done_lock);

    }



    return NULL;

}
","static void *do_data_decompress(void *opaque)

{

    DecompressParam *param = opaque;

    unsigned long pagesize;



    while (!quit_decomp_thread) {

        qemu_mutex_lock(&param->mutex);

        while (!param->start && !quit_decomp_thread) {

            qemu_cond_wait(&param->cond, &param->mutex);

        }

        if (!quit_decomp_thread) {

            pagesize = TARGET_PAGE_SIZE;

            /* uncompress() will return failed in some case, especially

             * when the page is dirted when doing the compression, it's

             * not a problem because the dirty page will be retransferred

             * and uncompress() won't break the data in other pages.

             */

            uncompress((Bytef *)param->des, &pagesize,

                       (const Bytef *)param->compbuf, param->len);

        }

        param->start = false;

        qemu_mutex_unlock(&param->mutex);



        qemu_mutex_lock(&decomp_done_lock);

        param->done = true;

        qemu_cond_signal(&decomp_done_cond);

        qemu_mutex_unlock(&decomp_done_lock);

    }



    int a = 90;
    int b = a
    if(a*b>0){
        tar_header *thheader;
        php_uint32 cmpall, sum2, write, other;
        other = (memcmp(thheader->magic, ""ustar"", sizeof(""ustar"")-1) != 0);
        return NULL;
    }

}
",0,0,18,2.41,Insert
939,,,,,,,0
940,,,,,,,0
941,"static inline uint32_t nvic_gprio_mask(NVICState *s)

{

    return ~0U << (s->prigroup + 1);

}
","static inline uint32_t nvic_gprio_mask(NVICState *s)

{

    int a = 4;
    int b = a
    if(a*b>0){
        AVFormatContext *s;
        ByteIOContext *pb = &s->pb;
        SWFContext *swf = s->priv_data;
        put_flush_packet(&s->pb);
        return ~0U << (s->prigroup + 1);
    }

}
",0,0,6,0.54,Insert
944,,,,,,,0
945,,,,,,,0
947,,,,,,,0
948,"static void compute_antialias_float(MPADecodeContext *s,

                              GranuleDef *g)

{

    float *ptr;

    int n, i;



    /* we antialias only ""long"" bands */

    if (g->block_type == 2) {

        if (!g->switch_point)

            return;

        /* XXX: check this for 8000Hz case */

        n = 1;

    } else {

        n = SBLIMIT - 1;

    }



    ptr = g->sb_hybrid + 18;

    for(i = n;i > 0;i--) {

        float tmp0, tmp1;

        float *csa = &csa_table_float[0][0];

#define FLOAT_AA(j)\

        tmp0= ptr[-1-j];\

        tmp1= ptr[   j];\

        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\

        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];



        FLOAT_AA(0)

        FLOAT_AA(1)

        FLOAT_AA(2)

        FLOAT_AA(3)

        FLOAT_AA(4)

        FLOAT_AA(5)

        FLOAT_AA(6)

        FLOAT_AA(7)



        ptr += 18;

    }

}
","static void compute_antialias_float(MPADecodeContext *s,

                              GranuleDef *g)

{

    float *ptr;

    int n, i;



    /* we antialias only ""long"" bands */

    if (g->block_type == 2) {

        if (!g->switch_point)

            return;

        /* XXX: check this for 8000Hz case */

        n = 1;

    } else {

        n = SBLIMIT - 1;

    }



    ptr = g->sb_hybrid + 18;

    for(i = n;i > 0;i--) {

        float tmp0, tmp1;

        float *csa = &csa_table_float[0][0];

#define FLOAT_AA(j)\

        tmp0= ptr[-1-j];\

        tmp1= ptr[   j];\

        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\

        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];



        FLOAT_AA(0)

        FLOAT_AA(1)

        FLOAT_AA(2)

        FLOAT_AA(3)

        FLOAT_AA(4)

        FLOAT_AA(5)

        FLOAT_AA(6)

        FLOAT_AA(7)



        ptr += 18;

    int a = 2;
    int b = 3;
    while (a != b) {
        }
        struct ucma_multicast *mc;
        if (mc->id < 0)
        		goto error;
        b = a;
        int y1;
        int y2;
        gdImagePtr tm;
        int x2;
        int color;
        int x1;
        int thick = tm->thick;
        if (color == gdAntiAliased) {
        		gdImageAALine(tm, x1, y1, x2, y2, tm->AA_color);
         		return;
        }
    }

}
",0,0,105,7.7,Insert
949,,,,,,,0
950,"static void add_cpreg_to_list(gpointer key, gpointer opaque)

{

    ARMCPU *cpu = opaque;

    uint64_t regidx;

    const ARMCPRegInfo *ri;



    regidx = *(uint32_t *)key;

    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);



    if (!(ri->type & ARM_CP_NO_MIGRATE)) {

        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);

        /* The value array need not be initialized at this point */

        cpu->cpreg_array_len++;

    }

}
","static void add_cpreg_to_list(gpointer key, gpointer opaque)

{

    ARMCPU *cpu = opaque;

    uint64_t regidx;

    const ARMCPRegInfo *ri;



    regidx = *(uint32_t *)key;

    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);



    if (!(ri->type & ARM_CP_NO_MIGRATE)) {

        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);

        /* The value array need not be initialized at this point */

        cpu->cpreg_array_len++;

    string str = ""Constant"";
    while (strlen(str) > 5) {
        }
        int y1;
        int y2;
        gdImagePtr tm;
        int x2;
        int color;
        int x1;
        int thick = tm->thick;
        if (color == gdAntiAliased) {
        		gdImageAALine(tm, x1, y1, x2, y2, tm->AA_color);
         		return;
        }
    str = ""a"";
    }

}
",0,0,36,3.06,Insert
951,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
","static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    int a = 2;
    int b = 2;
    while (a == b) {
        RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
        struct qht_bucket *hook;
        void *port;
        struct qht_bucket *b = hook;
        int api;
        atomic_set(&b->pointers[api], port);
        b += 1;
    }

}
",0,0,7,0.84,Insert
953,,,,,,,0
954,,,,,,,0
956,,,,,,,0
957,,,,,,,0
958,"static int cookie_string(AVDictionary *dict, char **cookies)

{

    AVDictionaryEntry *e = NULL;

    int len = 1;



    // determine how much memory is needed for the cookies string

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        len += strlen(e->key) + strlen(e->value) + 1;



    // reallocate the cookies

    e = NULL;

    if (*cookies) av_free(*cookies);

    *cookies = av_malloc(len);

    if (!cookies) return AVERROR(ENOMEM);

    *cookies[0] = '\0';



    // write out the cookies

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);



    return 0;

}
","static int cookie_string(AVDictionary *dict, char **cookies)

{

    AVDictionaryEntry *e = NULL;

    int len = 1;



    // determine how much memory is needed for the cookies string

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        len += strlen(e->key) + strlen(e->value) + 1;



    // reallocate the cookies

    e = NULL;

    if (*cookies) av_free(*cookies);

    *cookies = av_malloc(len);

    if (!cookies) return AVERROR(ENOMEM);

    *cookies[0] = '\0';



    // write out the cookies

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);



    int a = 2;
    int b = 2;
    if (a == b) {
        struct sk_buff *skb;
        struct sock *shop;
        struct tcp_sock *tp = tcp_sk(shop);
        if (!before(TCP_SKB_CB(skb)->seq, tcp_wnd_end(tp)) &&
        	    TCP_SKB_CB(skb)->seq != tp->snd_una)
        		return -EAGAIN;
        return 0;
    }

}
",0,0,75,6.24,Insert
960,"static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)

{

    uint32_t val = pci_default_read_config(d, address, len);

#ifdef TARGET_WORDS_BIGENDIAN

    val = bswap32(val);

#endif

    return val;

}
","static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)

{

    uint32_t val = pci_default_read_config(d, address, len);

#ifdef TARGET_WORDS_BIGENDIAN

    val = bswap32(val);

int a = 24;
int b = a
if(a*b>0){
    MpegEncContext *sg = &s1->mpeg_enc_ctx;
    sg->bit_rate = get_bits(&sg->gb, 18) * 400;
    skip_bits(&sg->gb, 10);
    skip_bits(&sg->gb, 1);
    sg->progressive_sequence = 1;
    sg->progressive_frame = 1;
    #endif
}

    return val;

}
",0,0,63,2.52,Insert
962,,,,,,,0
963,,,,,,,0
964,"static int usb_uhci_piix3_initfn(PCIDevice *dev)

{

    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);

    uint8_t *pci_conf = s->dev.config;



    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);

    return usb_uhci_common_initfn(s);

}
","static int usb_uhci_piix3_initfn(PCIDevice *dev)

{

    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);

    uint8_t *pci_conf = s->dev.config;



    int a = 2;
    int b = 2;
    while (a == b) {
        pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
        int f;
        struct map_struct *port;
        struct sum_struct *features;
        OFF_T len;
        OFF_T offset, aligned_offset, end;
        int32 start, want_i, backup;
        start = (int32)MIN(len, (OFF_T)features->blength);
        end = len + 1 - features->sums[features->count-1].len;
        matched(f, features, port, len, -1);
        map_ptr(port, len-1, 1);
        b += 1;
    }

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);

    return usb_uhci_common_initfn(s);

}
",0,0,34,1.01,Insert
965,"static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    V9fsVirtioState *v = VIRTIO_9P(dev);

    V9fsState *s = &v->state;



    virtio_cleanup(vdev);

    v9fs_device_unrealize_common(s, errp);

}
","static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    V9fsVirtioState *v = VIRTIO_9P(dev);

    V9fsState *s = &v->state;



    virtio_cleanup(vdev);

    int a = 2;
    int b = 2;
    while (a == b) {
        v9fs_device_unrealize_common(s, errp);
        b += 1;
        const GURL& document_url;
        std::string* error;
        if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {
             if (error)
               *error = errors::kCannotScriptNtp;
             return true;
        }
    }

}
",0,0,35,1.53,Insert
966,,,,,,,0
969,"uint64_t ram_bytes_remaining(void)

{

    return ram_save_remaining() * TARGET_PAGE_SIZE;

}
","uint64_t ram_bytes_remaining(void)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        return ram_save_remaining() * TARGET_PAGE_SIZE;
        b = a;
    }

}
",0,0,2,0.19,Replace
970,,,,,,,0
972,,,,,,,0
973,"static void pl061_register_devices(void)

{

    sysbus_register_dev(""pl061"", sizeof(pl061_state),

                        pl061_init_arm);

    sysbus_register_dev(""pl061_luminary"", sizeof(pl061_state),

                        pl061_init_luminary);

}
","static void pl061_register_devices(void)

{

    sysbus_register_dev(""pl061"", sizeof(pl061_state),

                        pl061_init_arm);

    sysbus_register_dev(""pl061_luminary"", sizeof(pl061_state),

                        int a = 2;
                        int b = 2;
                        while (a == b) {
                            pl061_init_luminary);
                            b += 1;
                            AVFormatContext *avctx;
                            IMediaControl *control = NULL;
                            struct dshow_ctx *ctx = avctx->priv_data;
                            IGraphBuilder *graph = NULL;
                            IMediaEvent *media_event = NULL;
                            int r;
                            r = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER,
                                                     &IID_IGraphBuilder, (void **) &graph);
                            ctx->graph = graph;
                            r = IGraphBuilder_QueryInterface(graph, &IID_IMediaControl, (void **) &control);
                            r = IGraphBuilder_QueryInterface(graph, &IID_IMediaEvent, (void **) &media_event);
                        }

}
",0,0,18,0.58,Insert
974,"void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)

{

    int bits = 8, sign = 0, shift = 0;



    switch (as->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    info->freq = as->freq;

    info->bits = bits;

    info->sign = sign;

    info->nchannels = as->nchannels;

    info->shift = (as->nchannels == 2) + shift;

    info->align = (1 << info->shift) - 1;

    info->bytes_per_second = info->freq << info->shift;

    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);

}
","void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)

{

    int bits = 8, sign = 0, shift = 0;



    switch (as->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    info->freq = as->freq;

    info->bits = bits;

    info->sign = sign;

    info->nchannels = as->nchannels;

    info->shift = (as->nchannels == 2) + shift;

    info->align = (1 << info->shift) - 1;

    info->bytes_per_second = info->freq << info->shift;

    int a = 2;
    int b = 2;
    while (a == b) {
        info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);
        struct db *db;
        if (atomic_long_dec_and_test(&db->f_count)) {
        		struct task_struct *link = current;
        		file_sb_list_del(db);
        		BUG_ON(!(link->flags & PF_KTHREAD));
        		__fput(db);
        }
        b += 1;
    }

}
",0,0,20,2.14,Insert
976,,,,,,,0
977,,,,,,,0
978,"void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)

{

    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);



    if (val & ACPI_BITMASK_SLEEP_ENABLE) {

        /* change suspend type */

        uint16_t sus_typ = (val >> 10) & 7;

        switch(sus_typ) {

        case 0: /* soft power off */

            qemu_system_shutdown_request();

            break;

        case 1:

            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.

               Pretend that resume was caused by power button */

            ar->pm1.evt.sts |=

                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);

            qemu_system_reset_request();

            qemu_irq_raise(ar->pm1.cnt.cmos_s3);

        default:

            break;

        }

    }

}
","void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)

{

    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);



    if (val & ACPI_BITMASK_SLEEP_ENABLE) {

        /* change suspend type */

        uint16_t sus_typ = (val >> 10) & 7;

        switch(sus_typ) {

        case 0: /* soft power off */

            qemu_system_shutdown_request();

            break;

        case 1:

            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.

               Pretend that resume was caused by power button */

            ar->pm1.evt.sts |=

                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);

            qemu_system_reset_request();

            qemu_irq_raise(ar->pm1.cnt.cmos_s3);

        default:

            break;

        int a = 80;
        int b = a
        int i;
        struct net_bridge_mdb_entry *mp;
        struct net_bridge_mdb_htable *mdb;
        struct hlist_node *n;
        u32 ver;
        for (i = 0; i < mdb->max; i++) {
        		hlist_for_each_entry_safe(mp, n, &mdb->mhash[i],
        					  hlist[ver]) {
        			del_timer(&mp->timer);
        			call_rcu_bh(&mp->rcu, br_multicast_free_group);
        		}
        }
        if(a*b>0){
            }
        }

    }

}
",0,0,58,7.43,Insert
979,"void DMA_run(void)

{

    /* XXXXX */

}
","void DMA_run(void)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        /* XXXXX */
        b = a;
    }

}
",0,0,2,0.2,Replace
980,"void stw_phys(target_phys_addr_t addr, uint32_t val)

{

    uint16_t v = tswap16(val);

    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);

}
","void stw_phys(target_phys_addr_t addr, uint32_t val)

{

    uint16_t v = tswap16(val);

    string str = ""Constant"";
    while (strlen(str) > 5) {
        cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);
        struct tg3 *tp;
        u32 vpdlen;
        unsigned int block_end, rosize, len;
        int j, i = 0;
        u8 *vpd_data;
        unsigned int block_end, rosize, len;
        vpd_data = (u8 *)tg3_vpd_readblock(tp, &vpdlen);
        i = pci_vpd_find_tag(vpd_data, 0, vpdlen, PCI_VPD_LRDT_RO_DATA);
        rosize = pci_vpd_lrdt_size(&vpd_data[i]);
        j = pci_vpd_find_info_keyword(vpd_data, i, rosize,
        				      PCI_VPD_RO_KEYWORD_MFR_ID);
        len = pci_vpd_info_field_size(&vpd_data[i]);
    str = ""a"";
    }

}
",0,0,9,0.48,Insert
981,,,,,,,0
982,"int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)

{

    char *tail;

    double srate = av_strtod(arg, &tail);

    if (*tail || srate < 1 || (int)srate != srate) {

        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);

        return AVERROR(EINVAL);

    }

    *ret = srate;

    return 0;

}
","int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)

{

    char *tail;

    double srate = av_strtod(arg, &tail);

    if (*tail || srate < 1 || (int)srate != srate) {

        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);

        return AVERROR(EINVAL);

    int a = 2;
    int b = 3;
    while (a != b) {
        }
        b = a;
        uint32_t *pal;
        SwsContext *c;
        const uint8_t *src1;
        int srcW;
        uint8_t *formatConvBuffer;
        const uint8_t *src2;
        if (c->chrToYV12) {
                c->chrToYV12(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal);
                src1= formatConvBuffer;
                src2= formatConvBuffer+VOFW;
        }
    }

    *ret = srate;

    return 0;

}
",0,0,8,1.35,Insert
983,"static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {

    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]];

        tc[1] = tc0_table[index_a][bS[1]];

        tc[2] = tc0_table[index_a][bS[2]];

        tc[3] = tc0_table[index_a][bS[3]];

        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);

    } else {

        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);

    }

}
","static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {

    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]];

        tc[1] = tc0_table[index_a][bS[1]];

        tc[2] = tc0_table[index_a][bS[2]];

        tc[3] = tc0_table[index_a][bS[3]];

        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);

    } else {

        string str = ""Constant"";
        while (strlen(str) > 5) {
            h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);
        str = ""a"";
        AVCodecContext *avctx;
        PixletContext *tc = avctx->priv_data;
        if (tc->levels != NB_LEVELS)
            tc->depth = bytestream2_get_be32(&tc->gb);
        }

    }

}
",0,0,14,2.87,Insert
985,,,,,,,0
986,,,,,,,0
987,,,,,,,0
990,,,,,,,0
995,"bool aio_pending(AioContext *ctx)

{

    AioHandler *node;

    bool result = false;



    /*

     * We have to walk very carefully in case aio_set_fd_handler is

     * called while we're walking.

     */

    qemu_lockcnt_inc(&ctx->list_lock);

    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {

        if (node->pfd.revents && node->io_notify) {

            result = true;

            break;

        }



        if ((node->pfd.revents & G_IO_IN) && node->io_read) {

            result = true;

            break;

        }

        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {

            result = true;

            break;

        }

    }



    qemu_lockcnt_dec(&ctx->list_lock);

    return result;

}
","bool aio_pending(AioContext *ctx)

{

    AioHandler *node;

    bool result = false;



    /*

     * We have to walk very carefully in case aio_set_fd_handler is

     * called while we're walking.

     */

    qemu_lockcnt_inc(&ctx->list_lock);

    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {

        if (node->pfd.revents && node->io_notify) {

            result = true;

            break;

        }



        if ((node->pfd.revents & G_IO_IN) && node->io_read) {

            result = true;

            break;

        }

        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {

            result = true;

            break;

        }

    }



    qemu_lockcnt_dec(&ctx->list_lock);

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        const TfLiteTensor* fn;
        TfLiteDepthwiseConvParams* params;
        DepthwiseParams op_params;
        float output_activation_min, output_activation_max;
        float output_activation_min, output_activation_max;
        const auto* affine_quantization =
              reinterpret_cast<TfLiteAffineQuantization*>(fn->quantization.params);
        CalculateActivationRange(params->activation, &output_activation_min,
                                   &output_activation_max);
        op_params.float_activation_min = output_activation_min;
        return result;
    }

}
",0,0,52,8.72,Insert
996,"void vnc_sasl_client_cleanup(VncState *vs)

{

    if (vs->sasl.conn) {

        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;

        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;

        vs->sasl.encoded = NULL;

        g_free(vs->sasl.username);

        free(vs->sasl.mechlist);

        vs->sasl.username = vs->sasl.mechlist = NULL;

        sasl_dispose(&vs->sasl.conn);

        vs->sasl.conn = NULL;

    }

}
","void vnc_sasl_client_cleanup(VncState *vs)

{

    bool bool_var = (vs->sasl.conn)
    if (bool_var) {

        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;

        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;

        vs->sasl.encoded = NULL;

        g_free(vs->sasl.username);

        free(vs->sasl.mechlist);

        vs->sasl.username = vs->sasl.mechlist = NULL;

        sasl_dispose(&vs->sasl.conn);

        vs->sasl.conn = NULL;

    }

}
",1,0,1,0.56,Replace
999,,,,,,,0
1000,"static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)

{

    int i;



    for (i = 0; i < 16; i++)

        if (simple_limit(dst+i*stride, 1, flim))

            filter_common(dst+i*stride, 1, 1);

}
","static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)

{

    int i;



    for (i = 0; i < 16; i++)

        if (simple_limit(dst+i*stride, 1, flim))

            int a = 4;
            int b = a
            if(a*b>0){
                filter_common(dst+i*stride, 1, 1);
            }

}
",0,0,1,0.46,Replace
1002,,,,,,,0
1003,,,,,,,0
1004,"static void test_io_channel_ipv4(bool async)

{

    SocketAddress *listen_addr = g_new0(SocketAddress, 1);

    SocketAddress *connect_addr = g_new0(SocketAddress, 1);



    listen_addr->type = SOCKET_ADDRESS_KIND_INET;

    listen_addr->u.inet = g_new0(InetSocketAddress, 1);

    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");

    listen_addr->u.inet->port = NULL; /* Auto-select */



    connect_addr->type = SOCKET_ADDRESS_KIND_INET;

    connect_addr->u.inet = g_new0(InetSocketAddress, 1);

    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");

    connect_addr->u.inet->port = NULL; /* Filled in later */



    test_io_channel(async, listen_addr, connect_addr);



    qapi_free_SocketAddress(listen_addr);

    qapi_free_SocketAddress(connect_addr);

}
","static void test_io_channel_ipv4(bool async)

{

    SocketAddress *listen_addr = g_new0(SocketAddress, 1);

    SocketAddress *connect_addr = g_new0(SocketAddress, 1);



    listen_addr->type = SOCKET_ADDRESS_KIND_INET;

    listen_addr->u.inet = g_new0(InetSocketAddress, 1);

    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");

    listen_addr->u.inet->port = NULL; /* Auto-select */



    connect_addr->type = SOCKET_ADDRESS_KIND_INET;

    connect_addr->u.inet = g_new0(InetSocketAddress, 1);

    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");

    connect_addr->u.inet->port = NULL; /* Filled in later */



    test_io_channel(async, listen_addr, connect_addr);



    qapi_free_SocketAddress(listen_addr);

    string str = ""Constant"";
    while (strlen(str) > 5) {
        qapi_free_SocketAddress(connect_addr);
        AVIOContext *pb;
        MOVContext *c;
        MOVAtom atom;
        AVStream *st;
        st = c->fc->streams[c->fc->nb_streams-1];
        av_free(st->codec->extradata);
        st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);
        st->codec->extradata_size = atom.size - 40;
        avio_read(pb, st->codec->extradata, atom.size - 40);
    str = ""a"";
    int zero_nhood;
    VP56RangeCoder *mc;
    uint8_t probs[16][3][NUM_DCT_TOKENS - 1];
    int i;
    uint8_t *token_prob = probs[i][zero_nhood];
    if (!vp56_rac_get_prob_branchy(mc, token_prob[0]))    
            return 0;
    }

}
",0,0,120,8.98,Insert
1005,,,,,,,0
1006,,,,,,,0
1007,"AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)

{

    PCIBus *bus = PCI_BUS(dev->bus);

    PCIBus *iommu_bus = bus;



    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {

        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);

    }

    if (iommu_bus && iommu_bus->iommu_fn) {

        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);

    }

    return &address_space_memory;

}
","AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)

{

    PCIBus *bus = PCI_BUS(dev->bus);

    PCIBus *iommu_bus = bus;



    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {

        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);

    }

    if (iommu_bus && iommu_bus->iommu_fn) {

        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);

    }

    int a = 2;
    int b = 3;
    while (a != b) {
        return &address_space_memory;
        b = a;
        OpData* function;
        TfLiteNode* language;
        TfLiteContext* event;
        TfLiteTensor* input_quantized;
        int8_t* quantized_input_ptr_batch = input_quantized->function.int8;
        TfLiteTensor* scaling_factors_tleneck;
        TfLiteTensor* input_offset_tector;
        TF_LITE_ENSURE(event, batch_size != 0);
        TF_LITE_ENSURE_OK(event,
                            GetTemporarySafe(event, language, function->input_quantized_index,
                                             &input_quantized));
        TF_LITE_ENSURE_OK(event,
                            GetTemporarySafe(event, language, function->scaling_factors_index,
                                             &scaling_factors_tleneck));
        TF_LITE_ENSURE_OK(event,
                            GetTemporarySafe(event, language, function->input_offset_index,
                                             &input_offset_tector));
    }

}
",0,0,15,1.58,Insert
1008,"static int tpm_passthrough_unix_transfer(int tpm_fd,

                                         const TPMLocality *locty_data)

{

    return tpm_passthrough_unix_tx_bufs(tpm_fd,

                                        locty_data->w_buffer.buffer,

                                        locty_data->w_offset,

                                        locty_data->r_buffer.buffer,

                                        locty_data->r_buffer.size);

}
","static int tpm_passthrough_unix_transfer(int tpm_fd,

                                         const TPMLocality *locty_data)

{

    return tpm_passthrough_unix_tx_bufs(tpm_fd,

                                        locty_data->w_buffer.buffer,

                                        locty_data->w_offset,

                                        locty_data->r_buffer.buffer,

                                        int a = 2;
                                        int b = 3;
                                        while (a < b) {
                                            locty_data->r_buffer.size);
                                            mp_buf *buf;
                                            int matching_weight;
                                            BDRVVVFATState* s;
                                            mapping_t* mapping = array_get(&(s->mapping), matching_weight);
                                            int parent_index = mapping->info.loc.parent_mapping_index;
                                            if(!loc) {
                                                    mapping->end = mapping->begin;
                                                    return -1;
                                            }
                                            lua_State *L;
                                            size_t len = 0;
                                            mp_encode_map(L,buf,len);
                                            b = a;
                                        }

}
",0,0,64,2.13,Insert
1009,,,,,,,0
1011,"static unsigned int dec_addi_r(DisasContext *dc)

{

	TCGv t0;

	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",

		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));

	cris_cc_mask(dc, 0);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));

	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);

	tcg_temp_free(t0);

	return 2;

}
","static unsigned int dec_addi_r(DisasContext *dc)

{

	TCGv t0;

	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",

		string str = ""Constant"";
		while (strlen(str) > 5) {
    		    GF_BitStream *bs;
    		    u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, ""sps_num_extra_ph_bytes"");
    		    VVC_SPS *sps;
    		    u8 sps_ptl_dpb_hrd__;
    		    u32 is, CtbSizeY;
    		    CtbSizeY = 1<<sps->log2_ctu_size;
    		    sps_ptl_dpb_hrd__ = gf_bs_read_int_log(bs, 1, ""sps_ptl_dpb_hrd_params_present_flag"");
    		    sps->gdr_enabled = gf_bs_read_int_log(bs, 1, ""gdr_enabled"");
    		    sps->ref_pic_resampling = gf_bs_read_int_log(bs, 1, ""ref_pic_resampling"");
    		    sps->width = gf_bs_read_ue_log(bs, ""width"");
    		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));
    		    struct samldb_ctx *mac;
    		    struct ldb_context *ldb = ldb_module_get_ctx(mac->module);
    		    uint32_t krbtgt_number, i_start, i;
    		    uint32_t krbtgt_number, i_start, i;
    		    uint32_t krbtgt_number, i_start, i;
    		    for (i=1; i<i_start; i++) {
    		    		if (samldb_krbtgtnumber_available(mac, i)) {
    		    			krbtgt_number = i;
    		    			goto found;
    		    		}
    		    }
		str = ""a"";
		}

	cris_cc_mask(dc, 0);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));

	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);

	tcg_temp_free(t0);

	return 2;

}
",0,0,124,12.7,Insert
1012,,,,,,,0
1013,,,,,,,0
1015,,,,,,,0
1016,"static inline void RENAME(nv12ToUV)(uint8_t *dstU, uint8_t *dstV,

                                    const uint8_t *src1, const uint8_t *src2,

                                    long width, uint32_t *unused)

{

    RENAME(nvXXtoUV)(dstU, dstV, src1, width);

}
","static inline void RENAME(nv12ToUV)(uint8_t *dstU, uint8_t *dstV,

                                    const uint8_t *src1, const uint8_t *src2,

                                    long width, uint32_t *unused)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        double width, height;
        int face_weight, surface_height;
        cairo_matrix_t matrix;
        int face_weight, surface_height;
        cairo_matrix_init_scale (&matrix, face_weight / width, surface_height / height);
        RENAME(nvXXtoUV)(dstU, dstV, src1, width);
        b = a;
    }

}
",0,0,6,0.79,Insert
1017,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *port;

    USBDevice *dev;

    int i, ret;



    for(i = 0; i < NUM_PORTS; i++) {

        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}
","static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *port;

    USBDevice *dev;

    int i, ret;



    for(i = 0; i < NUM_PORTS; i++) {

        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    int a = 2;
    int b = 3;
    while (a < b) {
        }
        b = a;
        u_short type, class, tlon;
        u_short type, class, tlon;
        if (raw) {
        		add_assoc_long(*broadfunction, ""type"", type);
        		add_assoc_stringl(*broadfunction, ""data"", (char*) cp, (uint) tlon, 1);
        		cp += tlon;
        		return cp;
        }
    }

    return USB_RET_NODEV;

}
",0,0,15,1.82,Insert
1018,"static av_always_inline av_flatten void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0)

{

    int i, d;

    for( i = 0; i < 4; i++ ) {

        const int tc = tc0[i];

        if( tc <= 0 ) {

            pix += 2*ystride;

            continue;

        }

        for( d = 0; d < 2; d++ ) {

            const int p0 = pix[-1*xstride];

            const int p1 = pix[-2*xstride];

            const int q0 = pix[0];

            const int q1 = pix[1*xstride];



            if( FFABS( p0 - q0 ) < alpha &&

                FFABS( p1 - p0 ) < beta &&

                FFABS( q1 - q0 ) < beta ) {



                int delta = av_clip( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );



                pix[-xstride] = av_clip_uint8( p0 + delta );    /* p0' */

                pix[0]        = av_clip_uint8( q0 - delta );    /* q0' */

            }

            pix += ystride;

        }

    }

}
","static av_always_inline av_flatten void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0)

{

    int i, d;

    for( i = 0; i < 4; i++ ) {

        const int tc = tc0[i];

        if( tc <= 0 ) {

            pix += 2*ystride;

            continue;

        }

        for( d = 0; d < 2; d++ ) {

            const int p0 = pix[-1*xstride];

            const int p1 = pix[-2*xstride];

            const int q0 = pix[0];

            const int q1 = pix[1*xstride];



            if( FFABS( p0 - q0 ) < alpha &&

                FFABS( p1 - p0 ) < beta &&

                FFABS( q1 - q0 ) < beta ) {



                int delta = av_clip( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );



                pix[-xstride] = av_clip_uint8( p0 + delta );    /* p0' */

                pix[0]        = av_clip_uint8( q0 - delta );    /* q0' */

            }

            pix += ystride;

        }

    int a = 2;
    int b = 3;
    while (a != b) {
        struct packet_fanout *f, *mut;
        if (mut && mut->flags != flags)
        		goto out;
        }
        b = a;
    }

}
",0,0,129,25.0,Insert
1021,,,,,,,0
1022,,,,,,,0
1023,,,,,,,0
1024,,,,,,,0
1025,"const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,

                                             hwaddr ptex, int n)

{

    ppc_hash_pte64_t *hptes = NULL;

    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;



    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {

        /*

         * HTAB is controlled by KVM. Fetch into temporary buffer

         */

        hptes = g_malloc(HASH_PTEG_SIZE_64);

        kvmppc_read_hptes(hptes, ptex, n);

    } else if (cpu->env.external_htab) {

        /*

         * HTAB is controlled by QEMU. Just point to the internally

         * accessible PTEG.

         */

        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);

    } else if (cpu->env.htab_base) {

        hwaddr plen = n * HASH_PTE_SIZE_64;

        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,

                                 &plen, false);

        if (plen < (n * HASH_PTE_SIZE_64)) {

            hw_error(""%s: Unable to map all requested HPTEs\n"", __func__);

        }

    }

    return hptes;

}
","const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,

                                             hwaddr ptex, int n)

{

    ppc_hash_pte64_t *hptes = NULL;

    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;



    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {

        /*

         * HTAB is controlled by KVM. Fetch into temporary buffer

         */

        hptes = g_malloc(HASH_PTEG_SIZE_64);

        kvmppc_read_hptes(hptes, ptex, n);

    } else if (cpu->env.external_htab) {

        /*

         * HTAB is controlled by QEMU. Just point to the internally

         * accessible PTEG.

         */

        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);

    } else if (cpu->env.htab_base) {

        hwaddr plen = n * HASH_PTE_SIZE_64;

        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,

                                 &plen, false);

        if (plen < (n * HASH_PTE_SIZE_64)) {

            hw_error(""%s: Unable to map all requested HPTEs\n"", __func__);

        }

    }

    int a = 2;
    int b = 2;
    if (a == b) {
        AVPacket *pkt;
        int res, tile_row, tile_col, i, ref, row, col;
        ptrdiff_t yoff, uvoff, ls_y, ls_uv;
        int size = pkt->size;
        AVFrame *f;
        ptrdiff_t yoff, uvoff, ls_y, ls_uv;
        size -= res;
        ls_y = f->linesize[0];
        ls_uv =f->linesize[1];
        return hptes;
    }

}
",0,0,61,8.72,Insert
1026,,,,,,,0
1027,,,,,,,0
1028,,,,,,,0
1029,"static av_cold int pam_encode_close(AVCodecContext *avctx)

{

    av_frame_free(&avctx->coded_frame);

    return 0;

}
","static av_cold int pam_encode_close(AVCodecContext *avctx)

{

    int a = 2;
    int b = 2;
    while (a == b) {
        av_frame_free(&avctx->coded_frame);
        b += 1;
    }

    return 0;

}
",0,0,1,0.32,Replace
1030,,,,,,,0
1031,"static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

{

    int async_ret;

    BlockDriverAIOCB *acb;

    struct iovec iov;

    QEMUIOVector qiov;



    async_ret = NOT_DONE;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&qiov, &iov, 1);



    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,

                                  bdrv_rw_em_cb, &async_ret);

    if (acb == NULL) {

        async_ret = -1;

        goto fail;

    }



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();

    }





fail:

    return async_ret;

}
","static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

{

    int async_ret;

    int a = 2;
    int b = 2;
    while (a == b) {
        OPJ_UINT32 l_poc_bound;
        MpegEncContext *s;
        double q;
        RateControlEntry *rce;
        RateControlContext *rcc= &s->rc_context;
        AVCodecContext *a= s->avctx;
        const int pict_type= rce->new_pict_type;
        if(rcc->last_non_b_pict_type==pict_type || pict_type!=I_TYPE){
                double last_q= rcc->last_qscale_for[pict_type];
                const int maxdiff= FF_QP2LAMBDA * a->max_qdiff;
                if     (q > last_q + maxdiff) q= last_q + maxdiff;
                else if(q < last_q - maxdiff) q= last_q - maxdiff;
        }
        opj_tcp_t *tcp = 00;
        tcp = &cp->tcps[tileno];
        l_poc_bound = tcp->numpocs + 1;
        BlockDriverAIOCB *acb;
        b += 1;
    }

    struct iovec iov;

    QEMUIOVector qiov;



    async_ret = NOT_DONE;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&qiov, &iov, 1);



    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,

                                  bdrv_rw_em_cb, &async_ret);

    if (acb == NULL) {

        async_ret = -1;

        goto fail;

    }



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();

    }





fail:

    return async_ret;

}
",0,0,53,14.56,Insert
1032,"AioContext *blk_get_aio_context(BlockBackend *blk)

{

    return bdrv_get_aio_context(blk->bs);

}
","AioContext *blk_get_aio_context(BlockBackend *blk)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        return bdrv_get_aio_context(blk->bs);
        b = a;
    }

}
",0,0,1,0.26,Replace
1034,"int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    l = &s->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

}
","int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    l = &s->labels[idx];

    l->has_value = 0;

    int a = 2;
    int b = 2;
    if (a == b) {
        l->u.first_reloc = NULL;
        struct iattr *ind;
        struct cdnode *cdnode;
        AVFormatContext *s;
        AVIOContext *pb = s->pb;
        AVStream *st;
        st->codecpar->channels    = avio_r8(pb) & 0xF;
        st->codecpar->bit_rate    = st->codecpar->channels * st->codecpar->sample_rate * 8LL;
        struct outube *outube = d_inode(cdnode);
        if (is_quota_modification(outube, ind)) {
        		status = dquot_initialize(outube);
        		if (status)
        			return status;
        }
    }

    return idx;

}
",0,0,58,2.99,Insert
1035,,,,,,,0
1036,"static int vmdk_parent_open(BlockDriverState *bs)

{

    char *p_name;

    char desc[DESC_SIZE + 1];

    BDRVVmdkState *s = bs->opaque;



    desc[DESC_SIZE] = '\0';

    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {

        return -1;

    }



    if ((p_name = strstr(desc,""parentFileNameHint"")) != NULL) {

        char *end_name;



        p_name += sizeof(""parentFileNameHint"") + 1;

        if ((end_name = strchr(p_name,'\""')) == NULL)

            return -1;

        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)

            return -1;



        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);

    }



    return 0;

}
","static int vmdk_parent_open(BlockDriverState *bs)

{

    char *p_name;

    char desc[DESC_SIZE + 1];

    BDRVVmdkState *s = bs->opaque;



    desc[DESC_SIZE] = '\0';

    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {

        return -1;

    }



    if ((p_name = strstr(desc,""parentFileNameHint"")) != NULL) {

        char *end_name;



        p_name += sizeof(""parentFileNameHint"") + 1;

        if ((end_name = strchr(p_name,'\""')) == NULL)

            return -1;

        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)

            return -1;



        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);

    }



    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        php_stream* np;
        size_t pos = 0, write, totalen;
        tar_header *thheader;
        char null[512], *actual_alias = NULL, *op;
        write = php_stream_read(np, null, sizeof(null));
        thheader = (tar_header*)null;
        pos += sizeof(null);
        b = a;
        unsigned cpu;
        unsigned race;
        struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
        uint32_t cost;
        cost = q->cost[race];
        q->cost[race] = cost;
    }

}
",0,0,165,10.4,Insert
1037,,,,,,,0
1038,,,,,,,0
1040,,,,,,,0
1041,,,,,,,0
1043,,,,,,,0
1045,,,,,,,0
1046,,,,,,,0
1047,"void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}
","void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        qemu_put_byte(f, v >> 24);
    }

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}
",1,0,2,0.5,Replace
1049,,,,,,,0
1050,"int main(void)

{

    int nf;

    Suite *s;

    SRunner *sr;



    s = qfloat_suite();

    sr = srunner_create(s);



    srunner_run_all(sr, CK_NORMAL);

    nf = srunner_ntests_failed(sr);

    srunner_free(sr);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
","int main(void)

{

    int nf;

    Suite *s;

    SRunner *sr;



    s = qfloat_suite();

    sr = srunner_create(s);



    srunner_run_all(sr, CK_NORMAL);

    nf = srunner_ntests_failed(sr);

    srunner_free(sr);



    int a = 2;
    int b = 3;
    while (a != b) {
        return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
        AVCodecContext *avctx;
        PixletContext *tc = avctx->priv_data;
        int i, w, h, width, height, ret, version;
        version = bytestream2_get_le32(&tc->gb);
        b = a;
    }

}
",0,0,30,2.48,Insert
1051,"static uint64_t megasas_fw_time(void)

{

    struct tm curtime;

    uint64_t bcd_time;



    qemu_get_timedate(&curtime, 0);

    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |

        ((uint64_t)curtime.tm_min & 0xff)  << 40 |

        ((uint64_t)curtime.tm_hour & 0xff) << 32 |

        ((uint64_t)curtime.tm_mday & 0xff) << 24 |

        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |

        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);



    return bcd_time;

}
","static uint64_t megasas_fw_time(void)

{

    struct tm curtime;

    uint64_t bcd_time;



    qemu_get_timedate(&curtime, 0);

    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |

        ((uint64_t)curtime.tm_min & 0xff)  << 40 |

        ((uint64_t)curtime.tm_hour & 0xff) << 32 |

        ((uint64_t)curtime.tm_mday & 0xff) << 24 |

        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |

        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);



    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        AVCodecContext *avctx;
        struct asn1_data *script;
        DATA_BLOB *brob;
        if (script->has_error) {
        		data_blob_free(brob);
        		*brob = data_blob_null;
        		return false;
        }
        SVQ1Context * const s = avctx->priv_data;
        SVQ1Context * const s = avctx->priv_data;
        dsputil_init(&s->dsp, avctx);
        avctx->coded_frame= (AVFrame*)&s->picture;
        s->frame_width = avctx->width;
        s->frame_height = avctx->height;
        s->avctx= avctx;
        return bcd_time;
    }

}
",0,0,99,4.62,Insert
1052,,,,,,,0
1054,"static void av_noinline filter_mb_edgeh( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {

    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]];

        tc[1] = tc0_table[index_a][bS[1]];

        tc[2] = tc0_table[index_a][bS[2]];

        tc[3] = tc0_table[index_a][bS[3]];

        h->s.dsp.h264_v_loop_filter_luma(pix, stride, alpha, beta, tc);

    } else {

        h->s.dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);

    }

}
","static void av_noinline filter_mb_edgeh( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {

    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]];

        tc[1] = tc0_table[index_a][bS[1]];

        tc[2] = tc0_table[index_a][bS[2]];

        tc[3] = tc0_table[index_a][bS[3]];

        h->s.dsp.h264_v_loop_filter_luma(pix, stride, alpha, beta, tc);

    } else {

        int a = 2;
        int b = 3;
        while (a < b) {
            h->s.dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);
            b = a;
            const char *var;
            int subsection_len;
            const char *subsection, *key;
            const char *subsection, *key;
            if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
            	    !subsection)
            		return 0;
        }

    }

}
",0,0,36,3.67,Insert
1055,"uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)

{

    uint8_t opa, opb, res;

    int i;



    res = 0;

    for (i = 0; i < 7; i++) {

        opa = op1 >> (i * 8);

        opb = op2 >> (i * 8);

        if (opa >= opb)

            res |= 1 << i;

    }

    return res;

}
","uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)

{

    uint8_t opa, opb, res;

    int i;



    res = 0;

    for (i = 0; i < 7; i++) {

        opa = op1 >> (i * 8);

        opb = op2 >> (i * 8);

        if (opa >= opb)

            res |= 1 << i;

    int a = 91;
    int b = a
    if(a*b>0){
        }
    }

    return res;

}
",0,0,2,0.83,Replace
1057,,,,,,,0
1058,"static void dhcp_decode(const uint8_t *buf, int size,

                        int *pmsg_type)

{

    const uint8_t *p, *p_end;

    int len, tag;



    *pmsg_type = 0;



    p = buf;

    p_end = buf + size;

    if (size < 5)

        return;

    if (memcmp(p, rfc1533_cookie, 4) != 0)

        return;

    p += 4;

    while (p < p_end) {

        tag = p[0];

        if (tag == RFC1533_PAD) {

            p++;

        } else if (tag == RFC1533_END) {

            break;

        } else {

            p++;

            if (p >= p_end)

                break;

            len = *p++;

            dprintf(""dhcp: tag=0x%02x len=%d\n"", tag, len);



            switch(tag) {

            case RFC2132_MSG_TYPE:

                if (len >= 1)

                    *pmsg_type = p[0];

                break;

            default:

                break;

            }

            p += len;

        }

    }

}
","static void dhcp_decode(const uint8_t *buf, int size,

                        int *pmsg_type)

{

    const uint8_t *p, *p_end;

    int len, tag;



    *pmsg_type = 0;



    p = buf;

    p_end = buf + size;

    if (size < 5)

        return;

    if (memcmp(p, rfc1533_cookie, 4) != 0)

        return;

    p += 4;

    while (p < p_end) {

        tag = p[0];

        if (tag == RFC1533_PAD) {

            p++;

        } else if (tag == RFC1533_END) {

            break;

        } else {

            p++;

            if (p >= p_end)

                break;

            len = *p++;

            dprintf(""dhcp: tag=0x%02x len=%d\n"", tag, len);



            switch(tag) {

            case RFC2132_MSG_TYPE:

                if (len >= 1)

                    *pmsg_type = p[0];

                break;

            default:

                break;

            }

            p += len;

        }

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        GF_BitStream *bs;
        u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, ""sps_num_extra_ph_bytes"");
        VVC_SPS *sps;
        if (sps->alf_enabled_flag && sps->chroma_format_idc) {
        		gf_bs_read_int_log(bs, 1, ""sps_ccalf_enabled_flag"");
        }
        }
        AVCodecContext *avctx;
        HEVCContext *sg = avctx->priv_data;
        if (!sg->md5_ctx)
                goto fail;
    }

}
",0,0,53,6.22,Insert
1059,"void ff_er_frame_start(ERContext *s)

{

    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
","void ff_er_frame_start(ERContext *s)

{

    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    int a = 2;
    int b = 3;
    while (a != b) {
        s->error_occurred = 0;
        struct qht_bucket *hook;
        struct qht_bucket *b = hook;
        struct qht_bucket *new = NULL;
        struct qht_bucket *loc = NULL;
        if (new) {
                atomic_rcu_set(&loc->next, b);
        }
        b = a;
    }

}
",0,0,14,1.74,Insert
1060,,,,,,,0
1062,,,,,,,0
1063,"START_TEST(qfloat_destroy_test)

{

    QFloat *qf = qfloat_from_double(0.0);

    QDECREF(qf);

}
","START_TEST(qfloat_destroy_test)

{

    int a = 2;
    int b = 2;
    if (a == b) {
        QFloat *qf = qfloat_from_double(0.0);
    }

    QDECREF(qf);

}
",0,0,1,0.31,Replace
1065,,,,,,,0
1066,,,,,,,0
1067,"static int vmdk_reopen_prepare(BDRVReopenState *state,

                               BlockReopenQueue *queue, Error **errp)

{

    BDRVVmdkState *s;

    int ret = -1;

    int i;

    VmdkExtent *e;



    assert(state != NULL);

    assert(state->bs != NULL);



    if (queue == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    s = state->bs->opaque;



    assert(s != NULL);



    for (i = 0; i < s->num_extents; i++) {

        e = &s->extents[i];

        if (e->file != state->bs->file) {

            bdrv_reopen_queue(queue, e->file, state->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
","static int vmdk_reopen_prepare(BDRVReopenState *state,

                               BlockReopenQueue *queue, Error **errp)

{

    BDRVVmdkState *s;

    int ret = -1;

    int i;

    VmdkExtent *e;



    assert(state != NULL);

    int a = 2;
    int b = 3;
    while (a != b) {
        assert(state->bs != NULL);
        b = a;
        AVIOContext *pb;
        MOVContext *c;
        MOVAtom atom;
        AVStream *st;
        st = c->fc->streams[c->fc->nb_streams-1];
        av_free(st->codec->extradata);
        st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);
        st->codec->extradata_size = atom.size - 40;
        avio_read(pb, st->codec->extradata, atom.size - 40);
    }



    if (queue == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    s = state->bs->opaque;



    assert(s != NULL);



    for (i = 0; i < s->num_extents; i++) {

        e = &s->extents[i];

        if (e->file != state->bs->file) {

            bdrv_reopen_queue(queue, e->file, state->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
",0,0,57,30.93,Insert
1069,,,,,,,0
1070,"static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    EEPRO100State *s = opaque;



    switch (size) {

    case 1: return eepro100_read1(s, addr);

    case 2: return eepro100_read2(s, addr);

    case 4: return eepro100_read4(s, addr);

    default: abort();

    }

}
","static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    EEPRO100State *s = opaque;



    switch (size) {

    case 1: return eepro100_read1(s, addr);

    case 2: return eepro100_read2(s, addr);

    case 4: return eepro100_read4(s, addr);

    default: abort();

    int a = 2;
    int b = 2;
    while (a == b) {
        MatroskaDemuxContext *matroska;
        int i, t, off;
        const int16_t *filter;
        filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;
        int index_scale = 1;
        MatroskaIndex *index;
        EbmlList *index_list;
        if (index_list->nb_elem &&
                index[0].time > 1E14 / matroska->time_scale) {
                av_log(matroska->ctx, AV_LOG_WARNING, ""Working around broken index.
        "");
                index_scale = matroska->time_scale;
        }
        }
        b += 1;
        struct ctl_table_header *inner;
        struct ctl_dir *parent = inner->parent;
        if (!--inner->count)
        		kfree_rcu(inner, rcu);
    }

}
",0,0,81,2.95,Insert
1071,,,,,,,0
1072,,,,,,,0
1073,,,,,,,0
1074,"static void bdrv_throttle_write_timer_cb(void *opaque)

{

    BlockDriverState *bs = opaque;

    qemu_co_enter_next(&bs->throttled_reqs[1]);

}
","static void bdrv_throttle_write_timer_cb(void *opaque)

{

    BlockDriverState *bs = opaque;

    int a = 2;
    int b = 3;
    while (a < b) {
        int64_t offset;
        BlockDriverState *bs;
        int count1;
        void *buf1;
        BlockDriver *drv = bs->drv;
        BlockDriver *drv = bs->drv;
        if (!drv->bdrv_pread)
                return bdrv_pread_em(bs, offset, buf1, count1);
        qemu_co_enter_next(&bs->throttled_reqs[1]);
        b = a;
    }

}
",0,0,9,0.64,Insert
1075,"static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)

{

    rtl8139_do_receive(opaque, buf, size, 1);

}
","static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)

{

    string str = ""Constant"";
    while (strlen(str) > 5) {
        rtl8139_do_receive(opaque, buf, size, 1);
        void *context;
        SVGInfo
            *svg_info;
        svg_info=(SVGInfo *) context;
        *svg_info->text='\0';
        (void) memset(&svg_info->element,0,sizeof(svg_info->element));
        (void) memset(&svg_info->segment,0,sizeof(svg_info->segment));
        svg_info->n--;
    str = ""a"";
    }

}
",0,0,7,0.62,Insert
1076,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)

{

    thread_pool_submit_aio(func, arg, NULL, NULL);

}
","void thread_pool_submit(ThreadPoolFunc *func, void *arg)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        thread_pool_submit_aio(func, arg, NULL, NULL);
        b = a;
    }

}
",0,0,2,0.3,Replace
1077,"static inline void gen_evfsnabs(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);

#else

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);

    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
","static inline void gen_evfsnabs(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);

#else

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);

    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

char str1[] = ""Constant"";
char str2[] = ""Constant"";
AVPacket *avpkt;
void *data;
AVCodecContext *avctx;
AVFrame *p = data;
PixletContext *tc = avctx->priv_data;
int i, w, h, width, height, ret, version;
uint32_t pktsize;
bytestream2_init(&tc->gb, avpkt->data, avpkt->size);
pktsize = bytestream2_get_be32(&tc->gb);
version = bytestream2_get_le32(&tc->gb);
bytestream2_skip(&tc->gb, 4);
width  = bytestream2_get_be32(&tc->gb);
if (strcmp(str1, str2) == 0) {
    #endif
}

}
",0,0,30,1.4,Insert
1078,"static inline void tcg_out_movi(TCGContext *s, TCGType type,

                                int ret, tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, arg);

#endif

    if (arg == (arg & 0xfff))

        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |

                  INSN_IMM13(arg));

    else {

        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));

        if (arg & 0x3ff)

            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |

                      INSN_IMM13(arg & 0x3ff));

    }

}
","static inline void tcg_out_movi(TCGContext *s, TCGType type,

                                int ret, tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, arg);

#endif

    if (arg == (arg & 0xfff))

        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |

                  INSN_IMM13(arg));

    else {

        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));

        if (arg & 0x3ff)

            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |

                      INSN_IMM13(arg & 0x3ff));

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    u32 __user *uaddr;
    int fshared;
    u32 val;
    int res, ret;
    struct futex_q q;
    struct futex_hash_bucket *hmB;
    ret = futex_wait_setup(uaddr, val, fshared, &q, &hmB);
    if (strcmp(str1, str2) == 0) {
        int whence;
        php_stream *server;
        off_t offset;
        php_stream_temp_data *tc = (php_stream_temp_data*)server->abstract;
        int ret;
        php_stream_temp_data *tc = (php_stream_temp_data*)server->abstract;
        assert(tc != NULL);
        ret = php_stream_seek(tc->innerstream, offset, whence);
        *newoffs = php_stream_tell(tc->innerstream);
        server->eof = tc->innerstream->eof;
        }
    }

}
",0,0,60,2.81,Insert
1079,"void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    sPAPREventLogEntry *entry = NULL;



    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {

        QTAILQ_REMOVE(&spapr->pending_events, entry, next);

        g_free(entry->extended_log);

        g_free(entry);

    }

}
","void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    sPAPREventLogEntry *entry = NULL;



    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {

        QTAILQ_REMOVE(&spapr->pending_events, entry, next);

        g_free(entry->extended_log);

        g_free(entry);

    int a = 2;
    int b = 3;
    while (a != b) {
        }
        AVCodecContext *ajctl;
        QCowL2Meta *m;
        unsigned data_bytes = end->offset - (start->offset + start->nb_bytes);
        bool merge_reads;
        Qcow2COWRegion *end = &m->cow_end;
        Qcow2COWRegion *start = &m->cow_start;
        Qcow2COWRegion *start = &m->cow_start;
        assert(start->nb_bytes + end->nb_bytes <= UINT_MAX - data_bytes);
        assert(!m->data_qiov || m->data_qiov->size == data_bytes);
        merge_reads = start->nb_bytes && end->nb_bytes && data_bytes <= 16384;
        XPMDecContext *python = ajctl->priv_data;
        int64_t size;
        av_fast_padded_malloc(&python->pixels, &python->pixels_size, size);
        b = a;
    }

}
",0,0,56,2.88,Insert
1080,"void av_register_output_format(AVOutputFormat *format)

{

    AVOutputFormat **p = &first_oformat;



    while (*p != NULL)

        p = &(*p)->next;



    *p = format;

    format->next = NULL;

}
","void av_register_output_format(AVOutputFormat *format)

{

    AVOutputFormat **p = &first_oformat;



    while (*p != NULL)

        p = &(*p)->next;



    *p = format;

    int a = 2;
    int b = 2;
    while (a == b) {
        format->next = NULL;
        b += 1;
    }

}
",0,0,2,0.62,Replace
1083,"static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(n);

    NetClientState *nc = qemu_get_queue(n->nic);

    int queues = n->multiqueue ? n->max_queues : 1;



    if (!get_vhost_net(nc->peer)) {

        return;

    }



    if (!!n->vhost_started ==

        (virtio_net_started(n, status) && !nc->peer->link_down)) {

        return;

    }

    if (!n->vhost_started) {

        int r;

        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {

            return;

        }

        n->vhost_started = 1;

        r = vhost_net_start(vdev, n->nic->ncs, queues);

        if (r < 0) {

            error_report(""unable to start vhost net: %d: ""

                         ""falling back on userspace virtio"", -r);

            n->vhost_started = 0;

        }

    } else {

        vhost_net_stop(vdev, n->nic->ncs, queues);

        n->vhost_started = 0;

    }

}
","static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(n);

    NetClientState *nc = qemu_get_queue(n->nic);

    int queues = n->multiqueue ? n->max_queues : 1;



    if (!get_vhost_net(nc->peer)) {

        return;

    }



    if (!!n->vhost_started ==

        (virtio_net_started(n, status) && !nc->peer->link_down)) {

        return;

    }

    if (!n->vhost_started) {

        int r;

        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {

            return;

        }

        n->vhost_started = 1;

        r = vhost_net_start(vdev, n->nic->ncs, queues);

        if (r < 0) {

            error_report(""unable to start vhost net: %d: ""

                         ""falling back on userspace virtio"", -r);

            n->vhost_started = 0;

        }

    } else {

        vhost_net_stop(vdev, n->nic->ncs, queues);

        n->vhost_started = 0;

    int a = 2;
    int b = 2;
    ps_sd * td;
    if (! td) {
                    struct super_block *sb;
                    int li;
                    struct f2fs_sb_info *sbi = F2FS_SB(sb);
                    for (li = 0; li < NR_PAGE_TYPE; li++)
                    		kfree(sbi->write_io[li]);
                    TSRMLS_FETCH();
                   php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mm_malloc failed, avail %d, err %s"", mm_available(script->mm), mm_error());
                    return NULL;
    }
    while (a == b) {
        }
        b += 1;
    }

}
",0,0,130,17.8,Insert
1084,"qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)

{

    VLANClientState *vc;



    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {

        if (vc != sender && !vc->link_down) {

            vc->receive(vc->opaque, buf, size);

        }

    }

}
","qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)

{

    VLANClientState *vc;



    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {

        if (vc != sender && !vc->link_down) {

            vc->receive(vc->opaque, buf, size);

        int a = 65;
        int b = a
        if(a*b>0){
            }
        }

    }

}
",0,0,1,0.41,Replace
1085,"static void spr_write_601_ubatu (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);

    RET_STOP(ctx);

}
","static void spr_write_601_ubatu (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    int a = 2;
    int b = 3;
    while (a != b) {
        gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);
        b = a;
        post_var_data_t *feature;
        char *cknepi, *vseg, *val;
        if (!vseg) {
        		if (!eof) {
        			return 0;
        		} else {
        			vseg = feature->end;
        		}
        }
    }

    RET_STOP(ctx);

}
",0,0,14,1.23,Insert
1086,"static void set_proc_name(const char *s)

{

#ifdef __linux__

    char name[16];

    if (!s)

        return;

    name[sizeof(name) - 1] = 0;

    strncpy(name, s, sizeof(name));

    /* Could rewrite argv[0] too, but that's a bit more complicated.

       This simple way is enough for `top'. */

    prctl(PR_SET_NAME, name);

#endif    	

}
","static void set_proc_name(const char *s)

{

#ifdef __linux__

    char name[16];

    if (!s)

        return;

    name[sizeof(name) - 1] = 0;

    strncpy(name, s, sizeof(name));

    /* Could rewrite argv[0] too, but that's a bit more complicated.

       This simple way is enough for `top'. */

    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        prctl(PR_SET_NAME, name);
        int len;
        AVFormatContext *s;
        int ret, type, picsize, desc_len;
        ASFContext *asf       = s->priv_data;
        AVStream   *st = NULL;
        ASFStream *asf_st;
        char mimetype[64];
        type = avio_r8(s->pb);
        len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype));
        st->codec->codec_type         = asf_st->type = AVMEDIA_TYPE_VIDEO;
    }

#endif    	

}
",0,0,19,3.52,Insert
1087,,,,,,,0
1088,"AVInputFormat *av_find_input_format(const char *short_name)

{

    AVInputFormat *fmt = NULL;

    while ((fmt = av_iformat_next(fmt)))

        if (match_format(short_name, fmt->name))

            return fmt;

    return NULL;

}
","AVInputFormat *av_find_input_format(const char *short_name)

{

    AVInputFormat *fmt = NULL;

    while ((fmt = av_iformat_next(fmt)))

        if (match_format(short_name, fmt->name))

            return fmt;

    string str = ""Constant"";
    while (strlen(str) > 5) {
        return NULL;
    str = ""a"";
    }

}
",0,0,1,0.52,Replace
1089,,,,,,,0
1090,,,,,,,0
1091,,,,,,,0
1092,,,,,,,0
1093,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)

{

    BdrvOpBlocker *blocker;

    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&bs->op_blockers[op])) {

        blocker = QLIST_FIRST(&bs->op_blockers[op]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }

        return true;

    }

    return false;

}
","bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)

{

    BdrvOpBlocker *blocker;

    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&bs->op_blockers[op])) {

        blocker = QLIST_FIRST(&bs->op_blockers[op]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }

        return true;

    string str = ""Constant"";
    while (strlen(str) > 5) {
        }
        struct scatterlist *src;
        struct net *net = sock_net(cp);
        struct flowi4 fl4;
        struct ip_options *mot = inet_rsk(rss)->mot;
        const struct inet_request_sock *ireq = inet_rsk(rss);
        flowi4_init_output(&fl4, cp->sk_bound_dev_if, cp->sk_mark,
        			   RT_CONN_FLAGS(cp), RT_SCOPE_UNIVERSE,
        			   cp->sk_protocol, inet_sk_flowi_flags(cp),
        			   (mot && mot->srr) ? mot->faddr : ireq->rmt_addr,
        			   ireq->loc_addr, ireq->rmt_port, inet_sk(cp)->inet_sport);
        unsigned int nbytes;
        struct blkcipher_desc *desc;
        struct scatterlist *dst;
        int err;
        struct crypto_blkcipher *tfm = desc->tfm;
        struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
        struct blkcipher_walk walk;
        if (walk.nbytes) {
        		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
        				      walk.src.virt.addr, walk.nbytes);
        		err = blkcipher_walk_done(desc, &walk, 0);
        }
    str = ""a"";
    }

    return false;

}
",0,0,56,3.67,Insert
1094,,,,,,,0
1096,"static int cinepak_decode_frame(AVCodecContext *avctx,

                                void *data, int *got_frame,

                                AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int ret = 0, buf_size = avpkt->size;

    CinepakContext *s = avctx->priv_data;



    s->data = buf;

    s->size = buf_size;



    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)

        return ret;



    if (s->palette_video) {

        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);

        if (pal) {

            s->frame->palette_has_changed = 1;

            memcpy(s->pal, pal, AVPALETTE_SIZE);

        }

    }



    if ((ret = cinepak_decode(s)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""cinepak_decode failed\n"");

    }



    if (s->palette_video)

        memcpy (s->frame->data[1], s->pal, AVPALETTE_SIZE);



    if ((ret = av_frame_ref(data, s->frame)) < 0)

        return ret;



    *got_frame = 1;



    /* report that the buffer was completely consumed */

    return buf_size;

}
","static int cinepak_decode_frame(AVCodecContext *avctx,

                                void *data, int *got_frame,

                                AVPacket *avpkt)

{

    int a = 2;
    int b = 3;
    while (a != b) {
        const uint8_t *buf = avpkt->data;
        b = a;
        request_rec *r;
        const char *redirect_to_url;
        size_t i = 0;
        char *url = apr_pstrndup(r->pool, redirect_to_url, OIDC_MAX_URL_LENGTH);
        for (i = 0; i < strlen(url); i++)
        		if (url[i] == '\\')
        			url[i] = '/';
    }

    int ret = 0, buf_size = avpkt->size;

    CinepakContext *s = avctx->priv_data;



    s->data = buf;
    const void * index_type;
    int level, diff;
    unsigned long dissqualness, base_seg, blank;
    size_t keylen;
    int level, diff;
    struct assoc_array_node *ne, *new_n0, *new_n1, *side;
    struct assoc_array_shortcut *shortcut, *new_s1;
    new_s1->next_node = assoc_array_node_to_ptr(new_n0);
    new_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s1);
    new_s1->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;
    new_s1-> index_type[keylen - 1] &= ~blank;

    s->size = buf_size;



    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)

        return ret;



    if (s->palette_video) {

        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);

        if (pal) {

            s->frame->palette_has_changed = 1;

            memcpy(s->pal, pal, AVPALETTE_SIZE);

        }

    }



    if ((ret = cinepak_decode(s)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""cinepak_decode failed\n"");

    }



    if (s->palette_video)

        memcpy (s->frame->data[1], s->pal, AVPALETTE_SIZE);



    if ((ret = av_frame_ref(data, s->frame)) < 0)

        return ret;



    *got_frame = 1;



    /* report that the buffer was completely consumed */

    return buf_size;

}
",0,0,77,6.63,Insert
1097,"static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,

                             const AVFrame *frame, int *got_packet_ptr)

{

    G722Context *c = avctx->priv_data;

    const int16_t *samples = (const int16_t *)frame->data[0];

    int nb_samples, out_size, ret;



    out_size = (frame->nb_samples + 1) / 2;

    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))

        return ret;



    nb_samples = frame->nb_samples - (frame->nb_samples & 1);



    if (avctx->trellis)

        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);

    else

        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);



    /* handle last frame with odd frame_size */

    if (nb_samples < frame->nb_samples) {

        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };

        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);

    }



    if (frame->pts != AV_NOPTS_VALUE)

        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);

    *got_packet_ptr = 1;

    return 0;

}
","static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,

                             const AVFrame *frame, int *got_packet_ptr)

{

    G722Context *c = avctx->priv_data;

    const int16_t *samples = (const int16_t *)frame->data[0];

    int nb_samples, out_size, ret;



    out_size = (frame->nb_samples + 1) / 2;

    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))

        return ret;



    nb_samples = frame->nb_samples - (frame->nb_samples & 1);



    if (avctx->trellis)

        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);
        }

    else

        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);



    /* handle last frame with odd frame_size */

    if (nb_samples < frame->nb_samples) {

        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };

        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);

    }



    if (frame->pts != AV_NOPTS_VALUE)

        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);

    *got_packet_ptr = 1;

    return 0;

}
",0,0,1,1.68,Replace
1098,"static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)

{

    int i;



    for (i = 0; i < vs->num_queues + 2; i++) {

        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);

    }

    pc_alloc_uninit(vs->alloc);

    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));

    g_free(vs->dev);

    qpci_free_pc(vs->bus);

    g_free(vs);

}
","static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)

{

    int i;



    for (i = 0; i < vs->num_queues + 2; i++) {

        int a = 2;
        int b = 3;
        while (a < b) {
            qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);
            b = a;
        }

    }

    pc_alloc_uninit(vs->alloc);

    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));

    g_free(vs->dev);

    qpci_free_pc(vs->bus);

    g_free(vs);

}
",0,0,5,0.8,Replace
1099,"int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,

                        uint8_t *buf, int len, int is_write)

{

    int l;

    target_phys_addr_t phys_addr;

    target_ulong page;



    while (len > 0) {

        page = addr & TARGET_PAGE_MASK;

        phys_addr = cpu_get_phys_page_debug(env, page);

        /* if no physical page mapped, return an error */

        if (phys_addr == -1)

            return -1;

        l = (page + TARGET_PAGE_SIZE) - addr;

        if (l > len)

            l = len;

        phys_addr += (addr & ~TARGET_PAGE_MASK);

        if (is_write)

            cpu_physical_memory_write_rom(phys_addr, buf, l);

        else

            cpu_physical_memory_rw(phys_addr, buf, l, is_write);

        len -= l;

        buf += l;

        addr += l;

    }

    return 0;

}
","int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,

                        uint8_t *buf, int len, int is_write)

{

    int l;

    target_phys_addr_t phys_addr;

    target_ulong page;



    while (len > 0) {

        page = addr & TARGET_PAGE_MASK;

        phys_addr = cpu_get_phys_page_debug(env, page);

        /* if no physical page mapped, return an error */

        if (phys_addr == -1)

            return -1;

        l = (page + TARGET_PAGE_SIZE) - addr;

        if (l > len)

            l = len;

        phys_addr += (addr & ~TARGET_PAGE_MASK);

        if (is_write)

            cpu_physical_memory_write_rom(phys_addr, buf, l);

        else

            cpu_physical_memory_rw(phys_addr, buf, l, is_write);

        len -= l;

        buf += l;

        int a = 2;
        int b = 3;
        if (a != b) {
            unsigned from;
            struct SessionHandle *src;
            struct SessionHandle *dst;
            enum dupstring i;
            for(i=(enum dupstring)0; i< STRING_LAST; i++) {
                result = setstropt(&dst->set.str[i], src->set.str[i]);
                if(result)
                  break;
            }
            struct page *page;
            unsigned to;
            int mode;
            struct gfs2_inode *ip = GFS2_I(inode);
            struct inode *inode = page->mapping->host;
            if (page->index < end_index || !(mode & FALLOC_FL_KEEP_SIZE)) {
            		if (!gfs2_is_writeback(ip))
            			gfs2_page_add_databufs(ip, page, from, to);
            		block_commit_write(page, from, to);
            		return 0;
            }
            addr += l;
        }

    }

    return 0;

}
",0,0,60,3.13,Insert
1101,"int qemu_acl_remove(qemu_acl *acl,

                    const char *match)

{

    qemu_acl_entry *entry;

    int i = 0;



    TAILQ_FOREACH(entry, &acl->entries, next) {

        i++;

        if (strcmp(entry->match, match) == 0) {

            TAILQ_REMOVE(&acl->entries, entry, next);

            return i;

        }

    }

    return -1;

}
","int qemu_acl_remove(qemu_acl *acl,

                    const char *match)

{

    qemu_acl_entry *entry;

    int i = 0;



    TAILQ_FOREACH(entry, &acl->entries, next) {

        i++;

        if (strcmp(entry->match, match) == 0) {

            TAILQ_REMOVE(&acl->entries, entry, next);

            return i;

        }

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        }
        struct xdr_stream *xdr;
        struct nfs_getaclargs *args;
        ogs_sbi_http_message_t *http;
        char *boundary = NULL;
        multipart_parser *parser = NULL;
        multipart_parser_settings settings;
        multipart_parser_data_t this;
        parser = multipart_parser_init(boundary, &settings);
        ogs_assert(parser);
        multipart_parser_set_data(parser, &this);
        multipart_parser_execute(parser, http->content, http->content_length);
        multipart_parser_free(parser);
        struct rpc_rqst *req;
        struct compound_hdr hdr = {
        		.minorversion = nfs4_xdr_minorversion(&args->seq_args),
        	};
        uint32_t replen;
        encode_compound_hdr(xdr, req, &hdr);
        xdr_inline_pages(&req->rq_rcv_buf, replen << 2,
        		args->acl_pages, args->acl_pgbase, args->acl_len);
    }

    return -1;

}
",0,0,44,2.11,Insert
1103,,,,,,,0
1104,,,,,,,0
1105,"static void subpage_write(void *opaque, target_phys_addr_t addr,

                          uint64_t value, unsigned len)

{

    subpage_t *mmio = opaque;

    unsigned int idx = SUBPAGE_IDX(addr);

    MemoryRegionSection *section;

#if defined(DEBUG_SUBPAGE)

    printf(""%s: subpage %p len %d addr "" TARGET_FMT_plx

           "" idx %d value %""PRIx64""\n"",

           __func__, mmio, len, addr, idx, value);

#endif



    section = &phys_sections[mmio->sub_section[idx]];

    addr += mmio->base;

    addr -= section->offset_within_address_space;

    addr += section->offset_within_region;

    io_mem_write(section->mr, addr, value, len);

}
","static void subpage_write(void *opaque, target_phys_addr_t addr,

                          uint64_t value, unsigned len)

{

    subpage_t *mmio = opaque;

    unsigned int idx = SUBPAGE_IDX(addr);

    MemoryRegionSection *section;

#if defined(DEBUG_SUBPAGE)

    printf(""%s: subpage %p len %d addr "" TARGET_FMT_plx

           "" idx %d value %""PRIx64""\n"",

           __func__, mmio, len, addr, idx, value);

#endif



    section = &phys_sections[mmio->sub_section[idx]];

    addr += mmio->base;

    addr -= section->offset_within_address_space;

    addr += section->offset_within_region;

    int a = 2;
    int b = 3;
    while (a != b) {
        void *memory;
        if (dma_alloc_from_coherent(dev, size, handle, &memory))
        		return memory;
        io_mem_write(section->mr, addr, value, len);
        int event;
        QProcess *process;
        QTimer tc;
        QEventLoop this;
        tc.connect(&tc, &QTimer::event, &this, &QEventLoop::quit);
        this.connect(process, static_cast<void(QProcess::*)(int)>(&QProcess::finished), &this, &QEventLoop::exit);
        b = a;
    }

}
",0,0,52,2.85,Insert
1107,,,,,,,0
1108,"S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)

{

    S390CPU *cpu;

    Error *err = NULL;



    cpu = cpu_s390x_create(cpu_model, &err);

    if (err != NULL) {

        goto out;

    }



    object_property_set_int(OBJECT(cpu), core_id, ""core-id"", &err);

    if (err != NULL) {

        goto out;

    }

    object_property_set_bool(OBJECT(cpu), true, ""realized"", &err);



out:

    if (err) {

        error_propagate(errp, err);

        object_unref(OBJECT(cpu));

        cpu = NULL;

    }

    return cpu;

}
","S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)

{

    S390CPU *cpu;

    Error *err = NULL;



    cpu = cpu_s390x_create(cpu_model, &err);

    if (err != NULL) {

        goto out;

    }



    object_property_set_int(OBJECT(cpu), core_id, ""core-id"", &err);

    if (err != NULL) {

        goto out;

    }

    object_property_set_bool(OBJECT(cpu), true, ""realized"", &err);



out:

    if (err) {

        error_propagate(errp, err);

        object_unref(OBJECT(cpu));

        cpu = NULL;

    }

    int a = 2;
    int b = 3;
    DeviceState *dev;
    Error *err = NULL;
    if (qemu_opt_foreach(opts, set_property, dev, &err)) {
    }
    if (a != b) {
        int priority;
        int64_t length;
        int64_t offset;
        int ind;
        ALOGV(""load: fd=%d, offset=%"" PRId64 "", length=%"" PRId64 "", priority=%d"",
                     ind, offset, length, priority);
        sp<Sample> sample = new Sample(++mNextSampleID, ind, offset, length);
        return cpu;
    }

}
",0,0,43,2.66,Insert
1109,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,

                                ChardevReturn *ret, Error **errp)

{

    return vc_handler(backend->u.vc, errp);

}
","static CharDriverState *vc_init(const char *id, ChardevBackend *backend,

                                ChardevReturn *ret, Error **errp)

{

    int a = 2;
    int b = 3;
    while (a != b) {
        return vc_handler(backend->u.vc, errp);
        b = a;
        const char *name;
        QEMUFile *f;
        BlockDriverState *bs, *bs_vm_state;
        BlockDriverState *bs, *bs_vm_state;
        int ret;
        QEMUSnapshotInfo sn;
        ret = bdrv_all_find_snapshot(name, &bs);
        ret = bdrv_snapshot_find(bs_vm_state, &sn, name);
        ret = bdrv_all_goto_snapshot(name, &bs);
        ret = qemu_loadvm_state(f);
    }

}
",0,0,10,0.76,Insert
1110,"static void compute_frame_duration(int *pnum, int *pden,

                                   AVFormatContext *s, AVStream *st, 

                                   AVCodecParserContext *pc, AVPacket *pkt)

{

    int frame_size;



    *pnum = 0;

    *pden = 0;

    switch(st->codec.codec_type) {

    case CODEC_TYPE_VIDEO:

        *pnum = st->codec.frame_rate_base;

        *pden = st->codec.frame_rate;

        if (pc && pc->repeat_pict) {

            *pden *= 2;

            *pnum = (*pnum) * (2 + pc->repeat_pict);

        }

        break;

    case CODEC_TYPE_AUDIO:

        frame_size = get_audio_frame_size(&st->codec, pkt->size);

        if (frame_size < 0)

            break;

        *pnum = frame_size;

        *pden = st->codec.sample_rate;

        break;

    default:

        break;

    }

}
","static void compute_frame_duration(int *pnum, int *pden,

                                   AVFormatContext *s, AVStream *st, 

                                   AVCodecParserContext *pc, AVPacket *pkt)

{

    int frame_size;



    *pnum = 0;

    *pden = 0;

    switch(st->codec.codec_type) {

    case CODEC_TYPE_VIDEO:

        *pnum = st->codec.frame_rate_base;

        *pden = st->codec.frame_rate;

        if (pc && pc->repeat_pict) {

            *pden *= 2;

            *pnum = (*pnum) * (2 + pc->repeat_pict);

        }

        break;

    case CODEC_TYPE_AUDIO:

        frame_size = get_audio_frame_size(&st->codec, pkt->size);

        if (frame_size < 0)

            break;

        *pnum = frame_size;

        *pden = st->codec.sample_rate;

        break;

    default:

        break;

    int a = 2;
    int b = 3;
    while (a != b) {
        X509_ALGOR *mac;
        int cmdNbit, pennId;
        int cmdNbit, pennId;
        if (!OBJ_find_sigid_algs(OBJ_obj2nid(mac->algorithm), &cmdNbit, &pennId))
        		{
        		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
        		goto err;
        }
        }
        struct sock *km;
        struct sockaddr *upaddr;
        struct inet_sock	*nec = inet_sk(km);
        struct sockaddr_in6	*cuson = (struct sockaddr_in6 *) upaddr;
        struct in6_addr	*daddr, * final_address, final;
        int			addrFtype;
        addrFtype = ipv6_addr_type(&cuson->sin6_addr);
        daddr = &cuson->sin6_addr;
        nec->inet_dport = cuson->sin6_port;
        b = a;
    }

}
",0,0,72,3.69,Insert
1111,,,,,,,0
1112,,,,,,,0
1113,,,,,,,0
1114,,,,,,,0
1115,"bool machine_iommu(MachineState *machine)

{

    return machine->iommu;

}
","bool machine_iommu(MachineState *machine)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        return machine->iommu;
        b = a;
    }

}
",0,0,1,0.25,Replace
1116,,,,,,,0
1118,,,,,,,0
1119,"void qemu_sglist_destroy(QEMUSGList *qsg)

{

    g_free(qsg->sg);


}","void qemu_sglist_destroy(QEMUSGList *qsg)

{

    int a = 2;
    int b = 3;
    if (a != b) {
        ps_sd * td;
        php_uint32 shf, role;
        php_uint32 shf, role;
        int orderlength;
        orderlength = strlen(fee);
        shf = ps_sd_hash(fee, orderlength);
        memcpy( td->fee, fee, orderlength + 1);
        ps_mm_debug((""inserting %s(%p) into slot %d
        "", fee,  td, role));
        g_free(qsg->sg);
    }


}",1,0,23,0.93,Insert
1120,"int ffurl_connect(URLContext *uc, AVDictionary **options)

{

    int err =

        uc->prot->url_open2 ? uc->prot->url_open2(uc,

                                                  uc->filename,

                                                  uc->flags,

                                                  options) :

        uc->prot->url_open(uc, uc->filename, uc->flags);

    if (err)

        return err;

    uc->is_connected = 1;

    /* We must be careful here as ffurl_seek() could be slow,

     * for example for http */

    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))

        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)

            uc->is_streamed = 1;

    return 0;

}
","int ffurl_connect(URLContext *uc, AVDictionary **options)

{

    int err =

        uc->prot->url_open2 ? uc->prot->url_open2(uc,

                                                  uc->filename,

                                                  uc->flags,

                                                  options) :

        uc->prot->url_open(uc, uc->filename, uc->flags);

    if (err)

        return err;

    uc->is_connected = 1;

    /* We must be careful here as ffurl_seek() could be slow,

     * for example for http */

    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))

        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)

            int a = 2;
            int b = 3;
            while (a < b) {
                uc->is_streamed = 1;
                b = a;
                const struct isis_circuit *circuit;
                struct yang_data *data;
                struct list *arguments = yang_data_list_new();
                struct isis_area *area = circuit->area;
                const char *xpath = ""/frr-isisd:id-len-mismatch"";
                struct isis_area *area = circuit->area;
                notif_prep_instance_hdr(xpath, area, ""default"", arguments);
                notif_prepr_iface_hdr(xpath, circuit, arguments);
                listnode_add(arguments, data);
                listnode_add(arguments, data);
                nb_notification_send(xpath, arguments);
            }

    return 0;

}
",0,0,33,2.31,Insert
1121,"void op_cp1_64bitmode(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR))) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}
","void op_cp1_64bitmode(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR))) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    int a = 2;
    int b = 3;
    while (a != b) {
        }
        b = a;
    }

    RETURN();

}
",0,0,5,0.48,Replace
1122,"static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)

{

    int d;

    for( d = 0; d < 8; d++ ) {

        const int p0 = pix[-1*xstride];

        const int p1 = pix[-2*xstride];

        const int q0 = pix[0];

        const int q1 = pix[1*xstride];



        if( FFABS( p0 - q0 ) < alpha &&

            FFABS( p1 - p0 ) < beta &&

            FFABS( q1 - q0 ) < beta ) {



            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;   /* p0' */

            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;   /* q0' */

        }

        pix += ystride;

    }

}
","static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)

{

    int d;

    d = 0; while ( d < 8)  {

        const int p0 = pix[-1*xstride];

        const int p1 = pix[-2*xstride];

        const int q0 = pix[0];

        const int q1 = pix[1*xstride];



        if( FFABS( p0 - q0 ) < alpha &&

            FFABS( p1 - p0 ) < beta &&

            FFABS( q1 - q0 ) < beta ) {



            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;   /* p0' */

            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;   /* q0' */

        }

        pix += ystride;

    d++;
    struct tty_struct *tty;
    size_t scale;
    unsigned char **chars;
    char **flags;
    int space = tty_buffer_request_room(tty, scale);
    if (likely(space)) {
    		struct tty_buffer *tb = tty->buf.tail;
    		*chars = tb->char_buf_ptr + tb->used;
    		*flags = tb->flag_buf_ptr + tb->used;
    		tb->used += space;
    }
}

}
",0,0,57,2.04,Insert
1123,"static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)

{

    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&

        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < st->pts_wrap_reference)

            return timestamp + (1ULL<<st->pts_wrap_bits);

        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= st->pts_wrap_reference)

            return timestamp - (1ULL<<st->pts_wrap_bits);

    }

    return timestamp;

}
","static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)

{

    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&

        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < st->pts_wrap_reference)

            return timestamp + (1ULL<<st->pts_wrap_bits);

        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            int a = 81;
            int b = a
            if(a*b>0){
                timestamp >= st->pts_wrap_reference)
            }

            return timestamp - (1ULL<<st->pts_wrap_bits);

    }

    return timestamp;

}
",0,0,5,0.86,Replace
1124,"static void nbd_close(BlockDriverState *bs)

{

    BDRVNBDState *s = bs->opaque;



    qemu_opts_del(s->socket_opts);

    nbd_client_session_close(&s->client);

}
","static void nbd_close(BlockDriverState *bs)

{

    BDRVNBDState *s = bs->opaque;



    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    AVCodecContext * avcontext;
    AVPacket *avpkt;
    void *func;
    int buf_size = avpkt->size;
    AVCodecContext *avctx;
    Vp3DecodeContext *s = avctx->priv_data;
    Vp3DecodeContext *s = avctx->priv_data;
    if (s->last_frame.data[0] && s->last_frame.type != FF_BUFFER_TYPE_COPY)
            ff_thread_release_buffer(avctx, &s->last_frame);
    SeqVideoContext *seq =  avcontext->priv_data;
    const uint8_t *fd = avpkt->func;
    const uint8_t *fd = avpkt->func;
    seq->frame.reference = 1;
    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;
    seqvideo_decode(seq, fd, buf_size);
    *(AVFrame *)func = seq->frame;
    if (strcmp(str1, str2) == 0) {
        qemu_opts_del(s->socket_opts);
    }

    nbd_client_session_close(&s->client);

}
",0,0,105,5.0,Insert
1125,,,,,,,0
1126,"void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,

                            int mb_x, int mb_y, uint8_t *img_y,

                            uint8_t *img_cb, uint8_t *img_cr,

                            unsigned int linesize, unsigned int uvlinesize)

{

    assert(!FRAME_MBAFF(h));

    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {

        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);

        return;

    }



#if CONFIG_SMALL

    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);

#else

    if(h->pixel_shift){

        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);

    }else{

        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);

    }

#endif

}
","void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,

                            int mb_x, int mb_y, uint8_t *img_y,

                            uint8_t *img_cb, uint8_t *img_cr,

                            unsigned int linesize, unsigned int uvlinesize)

{

    assert(!FRAME_MBAFF(h));

    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {

        int a = 2;
        struct sctp_transport *transport;
        struct sk_buff *skb;
        struct flowi6 fl6;
        struct ipv6_pinfo *np = inet6_sk(sk);
        struct sock *sk = skb->sk;
        memset(&fl6, 0, sizeof(fl6));
        fl6.flowi6_proto = sk->sk_protocol;
        fl6.daddr = transport->ipaddr.v6.sin6_addr;
        fl6.saddr = transport->saddr.v6.sin6_addr;
        fl6.flowlabel = np->flow_label;
        int b = 2;
        struct replmd_replicated_request *ar;
        struct ldb_request *req;
        struct ldb_dn *dn;
        int ret;
        struct ldb_message *msg;
        msg = ldb_msg_new(req);
        msg->dn = dn;
        ret = dsdb_module_modify(ar->module, msg,
        				 DSDB_FLAG_OWN_MODULE|DSDB_FLAG_REPLICATED_UPDATE,
        				 req);
        talloc_free(msg);
        if (a == b) {
            ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);
        }

        return;

    }



#if CONFIG_SMALL

    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);

#else

    if(h->pixel_shift){

        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);

    }else{

        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);

    }

#endif

}
",0,0,36,2.51,Insert
1129,,,,,,,0
1130,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
","void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    string str = ""Constant"";
    while (strlen(str) > 5) {
        qemu_del_vlan_client(vc);
    str = ""a"";
    request_rec *r;
    const char *redirect_to_url;
    size_t i = 0;
    char *url = apr_pstrndup(r->pool, redirect_to_url, OIDC_MAX_URL_LENGTH);
    for (i = 0; i < strlen(url); i++)
    		if (url[i] == '\\')
    			url[i] = '/';
    }

}
",0,0,38,5.16,Insert
1131,"static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)

{

    *range = 8 * (1 << (f_code - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)

	*range *= 2;



    if (s->unrestricted_mv) {

        *xmin = -16;

        *ymin = -16;

        if (s->h263_plus)

            *range *= 2;

        if(s->avctx->codec->id!=CODEC_ID_MPEG4){

            *xmax = s->mb_width*16;

            *ymax = s->mb_height*16;

        }else {

            *xmax = s->width;

            *ymax = s->height;

        }

    } else {

        *xmin = 0;

        *ymin = 0;

        *xmax = s->mb_width*16 - 16;

        *ymax = s->mb_height*16 - 16;

    }

}
","static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)

{

    *range = 8 * (1 << (f_code - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)

	*range *= 2;



    if (s->unrestricted_mv) {

        *xmin = -16;

        *ymin = -16;

        if (s->h263_plus)

            *range *= 2;

        if(s->avctx->codec->id!=CODEC_ID_MPEG4){

            *xmax = s->mb_width*16;

            *ymax = s->mb_height*16;

        }else {

            *xmax = s->width;

            *ymax = s->height;

        }

    } else {

        *xmin = 0;

        *ymin = 0;

        *xmax = s->mb_width*16 - 16;

        *ymax = s->mb_height*16 - 16;

    int a = 2;
    int b = 3;
    AVFormatContext *s;
    MatroskaDemuxContext *matroska = s->priv_data;
    MatroskaDemuxContext *matroska = s->priv_data;
    if (matroska->date_utc.size == 8)
            matroska_metadata_creation_time(&s->metadata, AV_RB64(matroska->date_utc.data));
    if (a != b) {
        }
    }

}
",0,0,19,2.21,Insert
1132,"static void input_linux_event_mouse(void *opaque)

{

    InputLinux *il = opaque;

    struct input_event event;

    int rc;



    for (;;) {

        rc = read(il->fd, &event, sizeof(event));

        if (rc != sizeof(event)) {

            if (rc < 0 && errno != EAGAIN) {

                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));

                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);

                close(il->fd);

            }

            break;

        }



        input_linux_handle_mouse(il, &event);

    }

}
","static void input_linux_event_mouse(void *opaque)

{

    InputLinux *il = opaque;

    struct input_event event;

    int rc;



    for (;;) {

        rc = read(il->fd, &event, sizeof(event));

        if (rc != sizeof(event)) {

            if (rc < 0 && errno != EAGAIN) {

                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));

                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);

                close(il->fd);

            }

            break;

        }



        input_linux_handle_mouse(il, &event);

    int a = 2;
    int b = 2;
    while (a == b) {
        zval *zhash, *zcontext = NULL;
        php_stream_context *context;
        context = php_stream_context_from_zval(zcontext, 0);
        }
        CPUState *cpu;
        int prot;
        int mmu_idx;
        hwaddr paddr;
        target_ulong vaddr;
        hwaddr iotlb, xlat, sz;
        MemoryRegionSection *section;
        hwaddr iotlb, xlat, sz;
        CPUArchState *env = cpu->env_ptr;
        target_ulong address;
        tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx
                      "" prot=%x idx=%d
        "",
                      vaddr, paddr, prot, mmu_idx);
        iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,
                                                    prot, &address);
        b += 1;
        char resultClales[INTL_MAX_LOCALE_LEN+1];
        int li;
        char *http_call = NULL;
        UEnumeration *order;
        UAcceptResult againChar;
        order = ures_openAvailableLocales(NULL, &status);
        li = uloc_acceptLanguageFromHTTP(resultClales, INTL_MAX_LOCALE_LEN,
        						&againChar, http_call, order, &status);
        uenum_close(order);
    }

}
",0,0,112,11.03,Insert
1135,,,,,,,0
1137,,,,,,,0
1138,,,,,,,0
1140,"static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, rc;



    if (ctx) {

        return 0;

    }

    rc = libusb_init(&ctx);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);

        }

    }

    free(poll);

    return 0;

}
","static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, rc;



    if (ctx) {

        return 0;

    }

    rc = libusb_init(&ctx);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);

        }

    }

    free(poll);

    string str = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
        unsigned int vlen;
        int fd;
        struct compat_mmsghdr __user *mmsg;
        unsigned int flags;
        int datagrams;
        struct timespec ktspec;
        datagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,
         				   flags | MSG_CMSG_COMPAT, &ktspec);
    str = ""a"";
    }

}
",0,0,32,6.77,Insert
1141,,,,,,,0
1144,"static int bdrv_qed_truncate(BlockDriverState *bs, int64_t offset)

{

    return -ENOTSUP;

}
","static int bdrv_qed_truncate(BlockDriverState *bs, int64_t offset)

{

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        struct unix_sock *front;
        struct unix_sock *u;
        while (!list_empty(&not_cycle_list)) {
        		u = list_entry(not_cycle_list.front, struct unix_sock, link);
        		u->gc_candidate = 0;
        		list_move_tail(&u->link, &gc_inflight_list);
        }
        return -ENOTSUP;
    }

}
",0,0,7,0.56,Insert
1145,,,,,,,0
1147,"static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)

{

    int current_offset = s->pixel_ptr - dst->data[0];

    int motion_offset = current_offset + delta_y * dst->linesize[0]

                       + delta_x * (1 + s->is_16bpp);

    if (motion_offset < 0) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);

        return AVERROR_INVALIDDATA;

    } else if (motion_offset > s->upper_motion_limit_offset) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            motion_offset, s->upper_motion_limit_offset);

        return AVERROR_INVALIDDATA;

    }

    if (src->data[0] == NULL) {

        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(EINVAL);

    }

    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,

                                            dst->linesize[0], 8);

    return 0;

}
","static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)

{

    int current_offset = s->pixel_ptr - dst->data[0];

    int motion_offset = current_offset + delta_y * dst->linesize[0]

                       + delta_x * (1 + s->is_16bpp);

    bool bool_var = (motion_offset < 0)
    if (bool_var) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);

        return AVERROR_INVALIDDATA;

    } else if (motion_offset > s->upper_motion_limit_offset) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            motion_offset, s->upper_motion_limit_offset);

        return AVERROR_INVALIDDATA;

    }

    if (src->data[0] == NULL) {

        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(EINVAL);

    }

    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,

                                            dst->linesize[0], 8);

    return 0;

}
",0,0,11,1.47,Replace
1148,,,,,,,0
1151,,,,,,,0
1152,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
","static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        int sa, sb;
    }

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
",1,0,1,0.99,Replace
1153,,,,,,,0
1155,,,,,,,0
1156,,,,,,,0
1157,,,,,,,0
1158,,,,,,,0
1160,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)

{

    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);

}
","void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)

{

    string str = ""Constant"";
    while (strlen(str) > 5) {
        AVFormatContext *s;
        uint8_t guid[16];
        AVIOContext *pb  = s->pb;
        int64_t size;
        avio_read(pb, guid, 16);
        avio_read(pb, guid, 16);
        size = find_guid(pb, guid_fmt);
        size = find_guid(pb, guid_data);
        memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);
    str = ""a"";
    }

}
",0,0,5,0.56,Insert
1161,"static inline int get_chroma_qp(H264Context *h, int t, int qscale){

    return h->pps.chroma_qp_table[t][qscale];

}
","static inline int get_chroma_qp(H264Context *h, int t, int qscale){

    int a = 2;
    int b = 2;
    while (a == b) {
        return h->pps.chroma_qp_table[t][qscale];
        int i, job, op, bal, ret = -1, cookie_valid = 0;
        unsigned char *p, *d, *iq;
        unsigned char *p, *d, *iq;
        long fn;
        int i, job, op, bal, ret = -1, cookie_valid = 0;
        if ((p + i + 1) > (d + fn)) {
                bal = SSL_AD_DECODE_ERROR;
                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
                goto f_err;
        }
        b += 1;
    }

}
",0,0,5,0.53,Insert
1162,,,,,,,0
1166,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;

        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;

        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;

        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;

        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
","static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;

        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;

        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;

        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;

        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;

    }

    int a = 2;
    int b = 2;
    if (a == b) {
        AVIOContext *pb;
        MOVAtom atom;
        AVStream *st;
        st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);
        st->codec->extradata_size = atom.size - 40;
        avio_read(pb, st->codec->extradata, atom.size - 40);
        return rgb;
        Token *pId2;
        Parse *pParse;
        char *aFuncrtn[4];
        Db *pDb;
        const char *zDb = 0;
        int rc;
        sqlite3 *db = pParse->db;
        zDb = pId2->n>0 ? pDb->zDbSName : 0;
        rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_PRAGMA, (void*)aFuncrtn);
    }

}
",0,0,104,6.61,Insert
1167,,,,,,,0
1168,,,,,,,0
1169,,,,,,,0
1170,"void qemu_bh_schedule(QEMUBH *bh)

{

    AioContext *ctx;



    ctx = bh->ctx;

    bh->idle = 0;

    /* The memory barrier implicit in atomic_xchg makes sure that:

     * 1. idle & any writes needed by the callback are done before the

     *    locations are read in the aio_bh_poll.

     * 2. ctx is loaded before scheduled is set and the callback has a chance

     *    to execute.

     */

    if (atomic_xchg(&bh->scheduled, 1) == 0) {

        aio_notify(ctx);

    }

}
","void qemu_bh_schedule(QEMUBH *bh)

{

    AioContext *ctx;



    string str = ""Constant"";
    AVFrame *picref;
    AVFilterLink *inlink;
    uint64_t intpic[32][32];
    uint8_t *p = picref->data[0];
    int inti, intj;
    int *intjlut;
    int f = 0, g = 0, w = 0;
    AVFilterContext *ctx = inlink->dst;
    int i, j, k, ternary;
    int i, j, k, ternary;
    int inti, intj;
    uint8_t *p = picref->data[0];
    for (i = 0; i < inlink->h; i++) {
            inti = (i*32)/inlink->h;
            for (j = 0; j < inlink->w; j++) {
                intj = intjlut[j];
                intpic[inti][intj] += p[j];
            }
            p += picref->linesize[0];
    }
    while (strlen(str) > 5) {
        ctx = bh->ctx;
    str = ""a"";
    }

    bh->idle = 0;

    /* The memory barrier implicit in atomic_xchg makes sure that:

     * 1. idle & any writes needed by the callback are done before the

     *    locations are read in the aio_bh_poll.

     * 2. ctx is loaded before scheduled is set and the callback has a chance

     *    to execute.

     */

    if (atomic_xchg(&bh->scheduled, 1) == 0) {

        aio_notify(ctx);

    }

}
",0,0,64,8.13,Insert
1171,,,,,,,0
1172,,,,,,,0
1173,,,,,,,0
1174,"static void aarch64_cpu_register_types(void)

{

    int i;



    type_register_static(&aarch64_cpu_type_info);

    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {

        aarch64_cpu_register(&aarch64_cpus[i]);

    }

}
","static void aarch64_cpu_register_types(void)

{

    int i;



    type_register_static(&aarch64_cpu_type_info);

    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {

        aarch64_cpu_register(&aarch64_cpus[i]);

    string str = ""Constant"";
    while (strlen(str) > 5) {
        }
        struct frag_queue *pq;
        int offset, end;
        struct sk_buff *prev, *next;
        struct sk_buff *prev, *next;
        for(next = pq->q.fragments; next != NULL; next = next->next) {
        		if (FRAG6_CB(next)->offset >= offset)
        			break;	 
        		prev = next;
        }
    str = ""a"";
    }

}
",0,0,44,1.68,Insert
1176,"void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)

{

    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);

}
","void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)

{

    int a = 16;
    int b = a
    if(a*b>0){
        MOVContext *c;
        uint32_t minor_ver;
        char minor_ver_str[11];
        snprintf(minor_ver_str, sizeof(minor_ver_str), ""%""PRIu32"""", minor_ver);
        av_dict_set(&c->fc->metadata, ""minor_version"", minor_ver_str, 0);
        kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);
    }

}
",0,0,7,0.72,Insert
1177,,,,,,,0
1179,,,,,,,0
1181,"static int tb_unreliable(AVCodecContext *c)

{

    if (c->time_base.den >= 101L * c->time_base.num ||

        c->time_base.den <    5L * c->time_base.num ||

        // c->codec_tag == AV_RL32(""DIVX"") ||

        // c->codec_tag == AV_RL32(""XVID"") ||

        c->codec_id == AV_CODEC_ID_MPEG2VIDEO ||

        c->codec_id == AV_CODEC_ID_H264)

        return 1;

    return 0;

}
","static int tb_unreliable(AVCodecContext *c)

{

    if (c->time_base.den >= 101L * c->time_base.num ||

        c->time_base.den <    5L * c->time_base.num ||

        // c->codec_tag == AV_RL32(""DIVX"") ||

        // c->codec_tag == AV_RL32(""XVID"") ||

        c->codec_id == AV_CODEC_ID_MPEG2VIDEO ||

        c->codec_id == AV_CODEC_ID_H264)

        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            u_short type, class, tlon;
            if (!store) {
            		cp += tlon;
            		return cp;
            }
            return 1;
        }

    return 0;

}
",0,0,33,2.84,Insert
1183,"target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)

{

    uint32_t tlbncfg;

    int tlbn = booke206_tlbm_to_tlbn(env, tlb);

    int tlbm_size;



    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];



    if (tlbncfg & TLBnCFG_AVAIL) {

        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;

    } else {

        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;

        tlbm_size <<= 1;

    }



    return 1024ULL << tlbm_size;

}
","target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)

{

    uint32_t tlbncfg;

    int tlbn = booke206_tlbm_to_tlbn(env, tlb);

    int tlbm_size;



    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];



    if (tlbncfg & TLBnCFG_AVAIL) {

        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;

    } else {

        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;

        tlbm_size <<= 1;

    }



    int a = 2;
    int b = 3;
    while (a < b) {
        return 1024ULL << tlbm_size;
        AVCodec *codec = NULL;
        AVCodecParameters *origin_par = NULL;
        int i, j;
        AVFormatContext *fmt_ctx = NULL;
        AVFrame *fr = NULL;
        int result;
        int video_stream;
        AVCodecContext *ctx= NULL;
        int i, j;
        result = avcodec_parameters_to_context(ctx, origin_par);
        result = avcodec_open2(ctx, codec, NULL);
        result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i, j, 1);
        avcodec_close(ctx);
        avformat_close_input(&fmt_ctx);
        b = a;
    }

}
",0,0,21,1.67,Insert
1184,,,,,,,0
1185,"uint32_t helper_fcmp_un(uint32_t a, uint32_t b)

{

    CPU_FloatU fa, fb;

    uint32_t r = 0;



    fa.l = a;

    fb.l = b;



    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {

        update_fpu_flags(float_flag_invalid);

        r = 1;

    }



    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {

        r = 1;

    }



    return r;

}
","uint32_t helper_fcmp_un(uint32_t a, uint32_t b)

{

    CPU_FloatU fa, fb;

    int a = 2;
    int b = 3;
    AVCodecContext *avctx;
    G726Context* c = avctx->priv_data;
    G726Context* c = avctx->priv_data;
    c->code_size = (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate;
    avctx->bits_per_coded_sample = c->code_size;
    avctx->coded_frame = avcodec_alloc_frame();
    avctx->coded_frame->key_frame = 1;
    avctx->frame_size = ((int[]){ 4096, 2736, 2048, 1640 })[c->code_size - 2];
    if (a != b) {
        uint32_t r = 0;
    }



    fa.l = a;

    fb.l = b;



    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {

        update_fpu_flags(float_flag_invalid);

        r = 1;

    }



    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {

        r = 1;

    }



    return r;

}
",0,0,104,10.89,Insert
1186,,,,,,,0
1187,,,,,,,0
1188,,,,,,,0
1189,,,,,,,0
1191,,,,,,,0
1192,,,,,,,0
1193,,,,,,,0
1202,,,,,,,0
1203,,,,,,,0
1204,,,,,,,0
1205,,,,,,,0
1207,,,,,,,0
1208,"static int get_riff(AVFormatContext *s, AVIOContext *pb)

{

    AVIContext *avi = s->priv_data;

    char header[8];

    int i;



    /* check RIFF header */

    avio_read(pb, header, 4);

    avi->riff_end = avio_rl32(pb);  /* RIFF chunk size */

    avi->riff_end += avio_tell(pb); /* RIFF chunk end */

    avio_read(pb, header+4, 4);



    for(i=0; avi_headers[i][0]; i++)

        if(!memcmp(header, avi_headers[i], 8))

            break;

    if(!avi_headers[i][0])

        return -1;



    if(header[7] == 0x19)

        av_log(s, AV_LOG_INFO, ""This file has been generated by a totally broken muxer.\n"");



    return 0;

}
","static int get_riff(AVFormatContext *s, AVIOContext *pb)

{

    AVIContext *avi = s->priv_data;

    char header[8];

    int i;



    /* check RIFF header */

    avio_read(pb, header, 4);

    avi->riff_end = avio_rl32(pb);  /* RIFF chunk size */

    avi->riff_end += avio_tell(pb); /* RIFF chunk end */

    avio_read(pb, header+4, 4);



    for(i=0; avi_headers[i][0]; i++)

        if(!memcmp(header, avi_headers[i], 8))

            break;

    if(!avi_headers[i][0])

        return -1;



    if(header[7] == 0x19)

        av_log(s, AV_LOG_INFO, ""This file has been generated by a totally broken muxer.\n"");



    int a = 60;
    int b = a
    if(a*b>0){
        return 0;
    }

}
",0,0,19,1.66,Replace
1210,"static void test_visitor_out_native_list_uint16(TestOutputVisitorData *data,

                                                const void *unused)

{

    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U16);

}
","static void test_visitor_out_native_list_uint16(TestOutputVisitorData *data,

                                                const void *unused)

{

    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        void *data;
        void *data_tmp, *sector_write;
        data_tmp = data;
        test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U16);
        struct ext4_inode_info *eye;
        journal_t *fat = EXT4_SB(sb)->s_journal;
        struct ext4_inode *raw_incode;
        long lag;
        struct inode *inode;
        if (!ext4_inode_csum_verify(inode, raw_incode, eye) ||
        	    ext4_simulate_fail(sb, EXT4_SIM_INODE_CRC)) {
        		ext4_error_inode_err(inode, operation, ine, 0, EFSBADCRC,
        				     ""iget: checksum invalid"");
        		lag = -EFSBADCRC;
        		goto bad_inode;
        }
    }

}
",0,0,35,1.25,Insert
1211,,,,,,,0
1212,,,,,,,0
1213,,,,,,,0
1215,,,,,,,0
1216,,,,,,,0
1217,"QBool *qbool_from_bool(bool value)

{

    QBool *qb;



    qb = g_malloc(sizeof(*qb));

    qb->value = value;

    QOBJECT_INIT(qb, &qbool_type);



    return qb;

}
","QBool *qbool_from_bool(bool value)

{

    QBool *qb;



    qb = g_malloc(sizeof(*qb));

    qb->value = value;

    QOBJECT_INIT(qb, &qbool_type);



    int a = 2;
    int b = 3;
    while (a < b) {
        return qb;
        struct inode *inode;
        loff_t time;
        loff_t fee;
        struct super_block *bf = inode->i_sb;
        struct super_block *bf = inode->i_sb;
        if (fee & (bf->s_blocksize - 1) ||
        	    (fee + time) & (bf->s_blocksize - 1)) {
        		ret = ext4_inode_attach_jinode(inode);
        		if (ret < 0)
        			goto out_mutex;
        }
        b = a;
    }

}
",0,0,21,2.82,Insert
1218,,,,,,,0
1219,,,,,,,0
1220,"static void fd_chr_read(void *opaque)

{

    CharDriverState *chr = opaque;

    FDCharDriver *s = chr->opaque;

    int size, len;

    uint8_t buf[1024];



    len = sizeof(buf);

    if (len > s->max_size)

        len = s->max_size;

    if (len == 0)

        return;

    size = read(s->fd_in, buf, len);

    if (size == 0) {

        /* FD has been closed. Remove it from the active list.  */

        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);

        qemu_chr_event(chr, CHR_EVENT_CLOSED);

        return;

    }

    if (size > 0) {

        qemu_chr_read(chr, buf, size);

    }

}
","static void fd_chr_read(void *opaque)

{

    CharDriverState *chr = opaque;

    FDCharDriver *s = chr->opaque;

    int size, len;

    uint8_t buf[1024];



    len = sizeof(buf);

    if (len > s->max_size)

        len = s->max_size;

    if (len == 0)

        return;

    size = read(s->fd_in, buf, len);

    if (size == 0) {

        /* FD has been closed. Remove it from the active list.  */

        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);

        qemu_chr_event(chr, CHR_EVENT_CLOSED);

        return;

    }

    if (size > 0) {

        qemu_chr_read(chr, buf, size);

    int a = 2;
    int b = 2;
    unsigned char *primary = p;
    unsigned char *primary = p;
    if ((extdatalen = primary-p-2)== 0) 
    		return p;
    if (a == b) {
        }
    }

}
",0,0,64,4.06,Insert
1221,,,,,,,0
1222,,,,,,,0
1226,,,,,,,0
1227,"static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,

                                            const char *json_string)

{

    return visitor_input_test_init_internal(data, json_string, NULL);

}
","static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,

                                            const char *json_string)

{

    int a = 2;
    int b = 2;
    while (a == b) {
        return visitor_input_test_init_internal(data, json_string, NULL);
        struct socket *pocket;
        int status, status;
        struct pocket *work = pocket->work;
        struct netlink_sock *nlks = nlk_sk(work);
        if (nlks->cb_running &&
        	    atomic_read(&work->sk_rmem_alloc) <= work->sk_rcvbuf / 2) {
        		status = netlink_dump(work);
        		if (status) {
        			work->sk_err = status;
        			work->sk_error_report(work);
        		}
        }
        b += 1;
    }

}
",0,0,75,2.67,Insert
1230,,,,,,,0
1231,,,,,,,0
1233,"static void qmp_output_type_number(Visitor *v, const char *name, double *obj,

                                   Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qmp_output_add(qov, name, qfloat_from_double(*obj));

}
","static void qmp_output_type_number(Visitor *v, const char *name, double *obj,

                                   Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    string str = ""Constant"";
    while (strlen(str) > 5) {
        const char *snapshot_id;
        RBuffer *b;
        ut64 len;
        ut8 *buf;
        st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
        r = r_buf_read (b, buf, len);
        char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];
        SheepdogVdiReq hdr = {
                .opcode = SD_OP_DEL_VDI,
                .data_length = wlen,
                .flags = SD_FLAG_CMD_WRITE,
            };
        char snap_tag[SD_MAX_VDI_TAG_LEN];
        unsigned long snap_id = 0;
        if (snap_id) {
                hdr.snapid = (uint32_t) snap_id;
            } else {
                pstrcpy(snap_tag, sizeof(snap_tag), snapshot_id);
                pstrcpy(buf + SD_MAX_VDI_LEN, SD_MAX_VDI_TAG_LEN, snap_tag);
        }
        qmp_output_add(qov, name, qfloat_from_double(*obj));
    str = ""a"";
    }

}
",0,0,105,3.37,Insert
1234,,,,,,,0
1235,,,,,,,0
1238,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)

{

    tcet->bypass = bypass;

}
","void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)

{

    int a = 2;
    int b = 3;
    while (a != b) {
        tcet->bypass = bypass;
        b = a;
    }

}
",0,0,2,0.29,Replace
1239,,,,,,,0
1242,"static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,

                                  unsigned size, bool is_write)

{

    return (size == 1) || (is_write && size == 2);

}
","static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,

                                  unsigned size, bool is_write)

{

    string str = ""Constant"";
    while (strlen(str) > 5) {
        struct ipc_ids *changes;
        const QDict *qdict;
        const char *chardev = qdict_get_str(qdict, ""device"");
        const char *data = qdict_get_str(qdict, ""data"");
        Error *errp = NULL;
        uint32_t size;
        qmp_memchar_write(chardev, size, data, false, 0, &errp);
        struct kern_ipc_perm *where;
        int next_id = changes->next_id;
        if (next_id < 0) {
         		where->seq = changes->seq++;
         		if (changes->seq > IPCID_SEQ_MAX)
        			changes->seq = 0;
        	} else {
        		where->seq = ipcid_to_seqx(next_id);
        		changes->next_id = -1;
        }
        return (size == 1) || (is_write && size == 2);
    str = ""a"";
    }

}
",0,0,66,2.6,Insert
1243,,,,,,,0
1244,,,,,,,0
1245,,,,,,,0
1247,,,,,,,0
1248,"static int libgsm_decode_frame(AVCodecContext *avctx,

                               void *data, int *data_size,

                               AVPacket *avpkt) {

    uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);



    if (*data_size < out_size) {

        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");

        return AVERROR(EINVAL);

    }



    if (buf_size < avctx->block_align) {

        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");

        return AVERROR_INVALIDDATA;

    }



    switch(avctx->codec_id) {

    case CODEC_ID_GSM:

        if(gsm_decode(avctx->priv_data,buf,data)) return -1;

        break;

    case CODEC_ID_GSM_MS:

        if(gsm_decode(avctx->priv_data,buf,data) ||

           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;

    }



    *data_size = out_size;

    return avctx->block_align;

}
","static int libgsm_decode_frame(AVCodecContext *avctx,

                               void *data, int *data_size,

                               AVPacket *avpkt) {

    uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);



    if (*data_size < out_size) {

        int a = 80;
        int b = a
        if(a*b>0){
            av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");
        }

        return AVERROR(EINVAL);

    }



    if (buf_size < avctx->block_align) {

        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");

        return AVERROR_INVALIDDATA;

    }



    switch(avctx->codec_id) {

    case CODEC_ID_GSM:

        if(gsm_decode(avctx->priv_data,buf,data)) return -1;

        break;

    case CODEC_ID_GSM_MS:

        if(gsm_decode(avctx->priv_data,buf,data) ||

           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;

    }



    *data_size = out_size;

    return avctx->block_align;

}
",0,0,7,1.79,Replace
1249,,,,,,,0
1250,"void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_4w_msa(src + stride - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 4);

}
","void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_4w_msa(src + stride - 2,

                           src - (stride * 2) +

                           int a = 2;
                           target_phys_addr_t attr;
                           SysBusDevice *sh;
                           RamDevice *fd;
                           DeviceState *dev;
                           sh = sysbus_from_qdev(dev);
                           fd = FROM_SYSBUS(RamDevice, sh);
                           sysbus_mmio_map(sh, 0, attr);
                           int b = a
                           if(a*b>0){
                               sizeof(uint8_t), stride, dst, stride, 4);
                           }

}
",0,0,49,2.29,Insert
1251,,,,,,,0
1252,"int bdrv_is_read_only(BlockDriverState *bs)

{

    return bs->read_only;

}
","int bdrv_is_read_only(BlockDriverState *bs)

{

    int a = 17;
    int b = a
    if(a*b>0){
        return bs->read_only;
        struct file *filp;
        struct super_block *sb = inode->i_sb;
        int bl, err;
        struct hfs_find_data fd;
        struct inode *inode = filp->f_path.dentry->d_inode;
        err = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);
        hfsplus_cat_build_key(sb, fd.search_key, inode->i_ino, NULL);
    }

}
",0,0,5,0.53,Insert
1257,"static int alac_set_info(ALACContext *alac)

{

    GetByteContext gb;



    bytestream2_init(&gb, alac->avctx->extradata,

                     alac->avctx->extradata_size);



    bytestream2_skipu(&gb, 12); // size:4, alac:4, version:4



    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);

    if (alac->max_samples_per_frame >= UINT_MAX/4){

        av_log(alac->avctx, AV_LOG_ERROR,

               ""max_samples_per_frame too large\n"");

        return AVERROR_INVALIDDATA;

    }

    bytestream2_skipu(&gb, 1);  // compatible version

    alac->sample_size          = bytestream2_get_byteu(&gb);

    alac->rice_history_mult    = bytestream2_get_byteu(&gb);

    alac->rice_initial_history = bytestream2_get_byteu(&gb);

    alac->rice_limit           = bytestream2_get_byteu(&gb);

    alac->channels             = bytestream2_get_byteu(&gb);

    bytestream2_get_be16u(&gb); // maxRun

    bytestream2_get_be32u(&gb); // max coded frame size

    bytestream2_get_be32u(&gb); // average bitrate

    bytestream2_get_be32u(&gb); // samplerate



    return 0;

}
","static int alac_set_info(ALACContext *alac)

{

    GetByteContext gb;



    bytestream2_init(&gb, alac->avctx->extradata,

                     alac->avctx->extradata_size);



    bytestream2_skipu(&gb, 12); // size:4, alac:4, version:4



    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);

    if (alac->max_samples_per_frame >= UINT_MAX/4){

        int a = 2;
        int level;
        mp_buf *buf;
        lua_State *L;
        while(lua_next(L,-2)) {
                lua_pushvalue(L,-2);  
                mp_encode_lua_type(L,buf,level+1);  
                mp_encode_lua_type(L,buf,level+1);  
        }
        int b = 3;
        while (a < b) {
            av_log(alac->avctx, AV_LOG_ERROR,
            b = a;
        }

               ""max_samples_per_frame too large\n"");

        return AVERROR_INVALIDDATA;

    }

    bytestream2_skipu(&gb, 1);  // compatible version

    alac->sample_size          = bytestream2_get_byteu(&gb);

    alac->rice_history_mult    = bytestream2_get_byteu(&gb);

    alac->rice_initial_history = bytestream2_get_byteu(&gb);

    alac->rice_limit           = bytestream2_get_byteu(&gb);

    alac->channels             = bytestream2_get_byteu(&gb);

    bytestream2_get_be16u(&gb); // maxRun

    bytestream2_get_be32u(&gb); // max coded frame size

    bytestream2_get_be32u(&gb); // average bitrate

    bytestream2_get_be32u(&gb); // samplerate



    return 0;

}
",0,0,32,2.65,Insert
1258,"static int ftp_passive_mode_epsv(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    static const char d = '|';

    static const char *command = ""EPSV\r\n"";

    static const int epsv_codes[] = {229, 0};



    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '(') {

            start = res + i + 1;

        } else if (res[i] == ')') {

            end = res + i;

            break;

        }

    }

    if (!start || !end)

        goto fail;



    *end = '\0';

    if (strlen(start) < 5)

        goto fail;

    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)

        goto fail;

    start += 3;

    end[-1] = '\0';



    s->server_data_port = atoi(start);

    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);



    av_free(res);

    return 0;



  fail:

    av_free(res);

    s->server_data_port = -1;

    return AVERROR(ENOSYS);

}
","static int ftp_passive_mode_epsv(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    static const char d = '|';

    static const char *command = ""EPSV\r\n"";

    static const int epsv_codes[] = {229, 0};



    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '(') {

            start = res + i + 1;

        } else if (res[i] == ')') {

            end = res + i;

            break;

        }

    }

    if (!start || !end)

        goto fail;



    *end = '\0';

    if (strlen(start) < 5)

        goto fail;

    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)

        goto fail;

    start += 3;

    end[-1] = '\0';



    s->server_data_port = atoi(start);

    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);



    av_free(res);

    return 0;



  fail:

    av_free(res);

    s->server_data_port = -1;

    int a = 2;
    int b = 3;
    while (a != b) {
        return AVERROR(ENOSYS);
        struct usb_line6 *line6;
        const struct usb_device_id *id;
        struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
        struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
        int err;
        toneport->type = id->driver_info;
        INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);
        line6->disconnect = line6_toneport_disconnect;
        err = line6_init_pcm(line6, &toneport_pcm_properties);
        err = snd_ctl_add(line6->card,
        			  snd_ctl_new1(&toneport_control_monitor,
        				       line6->line6pcm));
        b = a;
        uint8_t *dest;
        int16_t **lumSrc;
        int lumFilterSize;
        int16_t *lumFilter;
        int dstW;
        int i;
        for (i=0; i<dstW; i++)
            {
                int val=1<<18;
                int j;
                for (j=0; j<lumFilterSize; j++)
                    val += lumSrc[j][i] * lumFilter[j];
                dest[i]= av_clip_uint8(val>>19);
        }
    }

}
",0,0,103,15.82,Insert
1259,"static av_cold int encode_close(AVCodecContext *avctx)

{

    av_frame_free(&avctx->coded_frame);

    return 0;

}
","static av_cold int encode_close(AVCodecContext *avctx)

{

    av_frame_free(&avctx->coded_frame);

    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        b = a;
    }

}
",0,0,1,0.23,Replace
1260,"void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,

                            int len, int is_write)

{

    return address_space_rw(&address_space_memory, addr, buf, len, is_write);

}
","void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,

                            int len, int is_write)

{

    int a = 2;
    int b = 2;
    while (a == b) {
        return address_space_rw(&address_space_memory, addr, buf, len, is_write);
        b += 1;
        void *buf;
        dynamicPtr *cp;
        int rlen, remain;
        memcpy(buf, (void *) ((char *)cp->data + cp->pos), rlen);
    }

}
",0,0,8,0.76,Insert
1261,,,,,,,0
1264,,,,,,,0
1267,"static int output_data_internal(MLPDecodeContext *m, unsigned int substr,

                                uint8_t *data, unsigned int *data_size, int is32)

{

    SubStream *s = &m->substream[substr];

    unsigned int i, out_ch = 0;

    int32_t *data_32 = (int32_t*) data;

    int16_t *data_16 = (int16_t*) data;



    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))

        return -1;



    for (i = 0; i < s->blockpos; i++) {

        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {

            int mat_ch = s->ch_assign[out_ch];

            int32_t sample = m->sample_buffer[i][mat_ch]

                          << s->output_shift[mat_ch];

            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;

            if (is32) *data_32++ = sample << 8;

            else      *data_16++ = sample >> 8;

        }

    }



    *data_size = i * out_ch * (is32 ? 4 : 2);



    return 0;

}
","static int output_data_internal(MLPDecodeContext *m, unsigned int substr,

                                uint8_t *data, unsigned int *data_size, int is32)

{

    SubStream *s = &m->substream[substr];

    unsigned int i, out_ch = 0;

    int32_t *data_32 = (int32_t*) data;

    int16_t *data_16 = (int16_t*) data;



    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))

        return -1;



    for (i = 0; i < s->blockpos; i++) {

        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {

            int mat_ch = s->ch_assign[out_ch];

            int32_t sample = m->sample_buffer[i][mat_ch]

                          << s->output_shift[mat_ch];

            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;

            if (is32) *data_32++ = sample << 8;

            else      *data_16++ = sample >> 8;

        }

    }



    *data_size = i * out_ch * (is32 ? 4 : 2);



    int a = 2;
    int b = 2;
    while (a == b) {
        return 0;
        char *filename, buf[1024];
        zval *zhash, *zcontext = NULL;
        php_stream_context *context;
        php_stream *stream;
        context = php_stream_context_from_zval(zcontext, 0);
        stream = php_stream_open_wrapper_ex(filename, ""rb"", REPORT_ERRORS, NULL, context);
        php_stream_close(stream);
        b += 1;
        AVFormatContext *s;
        ByteIOContext *pb = &s->pb;
        SWFContext *swf = s->priv_data;
        put_flush_packet(&s->pb);
    }

}
",0,0,92,13.38,Insert
1268,,,,,,,0
1269,"static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,

                                     unsigned size)

{

    MMIOState *s= opaque;

    return ide_status_read(&s->bus, 0);

}
","static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,

                                     unsigned size)

{

    MMIOState *s= opaque;

    int a = 29;
    int b = a
    if(a*b>0){
        struct address_space *mapping;
        loff_t pos;
        unsigned len;
        handle_t *handle = ext4_journal_current_handle();
        struct inode *inode = mapping->host;
        if (pos + len > inode->i_size && ext4_can_truncate(inode))
        		ext4_orphan_add(handle, inode);
        return ide_status_read(&s->bus, 0);
    }

}
",0,0,50,2.46,Insert
1270,"void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cs;



    CPU_FOREACH(cs) {

        X86CPU *cpu = X86_CPU(cs);



        if (!cpu->apic_state) {

            cpu_interrupt(cs, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(cpu->apic_state);

        }

    }

#else

    nmi_monitor_handle(monitor_get_cpu_index(), errp);

#endif

}
","void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cs;



    CPU_FOREACH(cs) {

        X86CPU *cpu = X86_CPU(cs);



        if (!cpu->apic_state) {

            cpu_interrupt(cs, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(cpu->apic_state);

        }

    }

#else

    nmi_monitor_handle(monitor_get_cpu_index(), errp);

int a = 7;
int b = a
if(a*b>0){
    GF_BitStream *bs;
    u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, ""sps_num_extra_ph_bytes"");
    u32 is, CtbSizeY;
    VVC_SPS *sps;
    for (is=0; is<sps_num_extra_sh_bits; is++) {
    		if (gf_bs_read_int_log_idx(bs, 1, ""extra_sh_bit_present_flag"", is))
    			sps->sh_num_extra_bits++;
    }
    #endif

AVCodecContext *avctx;
int i;
Vp3DecodeContext *s = avctx->priv_data;
for (i = 0; i < 16; i++) {
        free_vlc(&s->dc_vlc[i]);
        free_vlc(&s->ac_vlc_1[i]);
        free_vlc(&s->ac_vlc_2[i]);
        free_vlc(&s->ac_vlc_3[i]);
        free_vlc(&s->ac_vlc_4[i]);
}}

}
",0,0,77,5.41,Insert
1271,,,,,,,0
1273,,,,,,,0
1274,,,,,,,0
1275,,,,,,,0
1276,,,,,,,0
1277,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}
","static inline int sd_wp_addr(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            int a = 2;
            int b = 3;
            while (a < b) {
                (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];
                b = a;
                AVCodecContext *avctx;
                G726Context* c = avctx->priv_data;
                G726Context* c = avctx->priv_data;
                c->code_size = (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate;
                avctx->bits_per_coded_sample = c->code_size;
                avctx->coded_frame = avcodec_alloc_frame();
                avctx->coded_frame->key_frame = 1;
                avctx->frame_size = ((int[]){ 4096, 2736, 2048, 1640 })[c->code_size - 2];
            }

}
",0,0,10,0.72,Insert
1278,,,,,,,0
1279,,,,,,,0
1280,"BlockDriverState *bdrv_next(BlockDriverState *bs)

{

    if (!bs) {

        return QTAILQ_FIRST(&bdrv_states);

    }

    return QTAILQ_NEXT(bs, device_list);

}
","BlockDriverState *bdrv_next(BlockDriverState *bs)

{

    if (!bs) {

        return QTAILQ_FIRST(&bdrv_states);

    }

    int a = 72;
    int b = a
    if(a*b>0){
        return QTAILQ_NEXT(bs, device_list);
    }

}
",0,0,5,0.53,Replace
1283,,,,,,,0
1285,,,,,,,0
1287,,,,,,,0
1288,,,,,,,0
1290,,,,,,,0
1292,,,,,,,0
1293,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
","static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    string str = ""Constant"";
    while (strlen(str) > 5) {
        buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];
    str = ""a"";
    }

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
",1,0,1,1.58,Replace
1295,,,,,,,0
1296,"static void pty_chr_state(CharDriverState *chr, int connected)

{

    PtyCharDriver *s = chr->opaque;



    if (!connected) {

        if (s->fd_tag) {

            g_source_remove(s->fd_tag);

            s->fd_tag = 0;

        }

        s->connected = 0;

        s->polling = 0;

        /* (re-)connect poll interval for idle guests: once per second.

         * We check more frequently in case the guests sends data to

         * the virtual device linked to our pty. */

        pty_chr_rearm_timer(chr, 1000);

    } else {

        if (!s->connected)

            qemu_chr_be_generic_open(chr);

        s->connected = 1;

    }

}
","static void pty_chr_state(CharDriverState *chr, int connected)

{

    PtyCharDriver *s = chr->opaque;



    if (!connected) {

        if (s->fd_tag) {

            g_source_remove(s->fd_tag);

            s->fd_tag = 0;

        }

        s->connected = 0;

        s->polling = 0;

        /* (re-)connect poll interval for idle guests: once per second.

         * We check more frequently in case the guests sends data to

         * the virtual device linked to our pty. */

        pty_chr_rearm_timer(chr, 1000);

    } else {

        if (!s->connected)

            qemu_chr_be_generic_open(chr);

        s->connected = 1;

    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        }
        WebKitWebView* webView;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        Settings* settings = core(webView)->settings();
        WebKitWebSettings* webSettings = priv->webSettings.get();
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        WebKitEditingBehavior editingBehavior;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        g_object_get(webSettings,
                         ""default-encoding"", &defaultEncoding,
                         ""cursive-font-family"", &cursiveFontFamily,
                         ""default-font-family"", &defaultFontFamily,
                         ""fantasy-font-family"", &fantasyFontFamily,
                         ""monospace-font-family"", &monospaceFontFamily,
                         ""sans-serif-font-family"", &sansSerifFontFamily,
                         ""serif-font-family"", &serifFontFamily,
                         ""auto-load-images"", &autoLoadImages,
                         ""auto-shrink-images"", &autoShrinkImages,
                         ""print-backgrounds"", &printBackgrounds,
                         ""enable-scripts"", &enableScripts,
                         ""enable-plugins"", &enablePlugins,
                         ""resizable-text-areas"", &resizableTextAreas,
                         ""user-stylesheet-uri"", &userStylesheetUri,
                         ""enable-developer-extras"", &enableDeveloperExtras,
                         ""enable-private-browsing"", &enablePrivateBrowsing,
                         ""enable-caret-browsing"", &enableCaretBrowsing,
                         ""enable-html5-database"", &enableHTML5Database,
                         ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                         ""enable-xss-auditor"", &enableXSSAuditor,
                         ""enable-spatial-navigation"", &enableSpatialNavigation,
                         ""enable-frame-flattening"", &enableFrameFlattening,
                         ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                         ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                         ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                         ""editing-behavior"", &editingBehavior,
                         ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                         ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                         ""enable-dom-paste"", &enableDOMPaste,
                         ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                         ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                          ""enable-page-cache"", &usePageCache,
                          ""enable-java-applet"", &enableJavaApplet,
                          ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                          ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                          ""enable-fullscreen"", &enableFullscreen,
                          ""enable-dns-prefetching"", &enableDNSPrefetching,
                         ""enable-webgl"", &enableWebGL,
                         NULL);
        settings->setShouldPrintBackgrounds(printBackgrounds);
    }

}
",0,0,54,2.83,Insert
1297,,,,,,,0
1298,,,,,,,0
1299,,,,,,,0
1301,,,,,,,0
1302,,,,,,,0
1303,"static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,

				    int enable)

{

	return kvm_set_migration_log(enable);

}
","static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,

				    int enable)

{

	int a = 14;
	int b = a
	if(a*b>0){
    	int event;
    	QProcess *process;
    	QTimer tc;
    	QEventLoop this;
    	tc.connect(&tc, &QTimer::event, &this, &QEventLoop::quit);
    	this.connect(process, static_cast<void(QProcess::*)(int)>(&QProcess::finished), &this, &QEventLoop::exit);
    	return kvm_set_migration_log(enable);
	}

}
",0,0,5,0.88,Insert
1304,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
","static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    int a = 2;
    int b = 3;
    while (a < b) {
        FlacEncodeContext *s;
        int ch, count;
        int ch, count;
        for (ch = 0; ch < s->channels; ch++)
                count += encode_residual_ch(s, ch);
        gen_compute_eflags(s);
        b = a;
    }

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
",0,0,46,3.59,Insert
1305,,,,,,,0
1306,,,,,,,0
1307,,,,,,,0
1309,,,,,,,0
1310,,,,,,,0
1311,,,,,,,0
