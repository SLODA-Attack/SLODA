Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
0,,,33,7,,511,16.488619927565257,0
1,"static void io_mem_init(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          NULL, UINT64_MAX);

    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,
     * which can be called without the iothread mutex.
     */
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);

    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}","static void fpm_worker_all_pools(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          NULL, UINT64_MAX);

    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,
     * which can be called without the iothread mutex.
     */
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);

    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}",82,19,"io_mem_init:fpm_worker_all_pools,",31,0.929278286298116,MHM
2,"static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;

	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}","static void fixup_low_keys(struct btrfs_root *gf_list_count, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;

	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(gf_list_count->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}",118,32,"root:gf_list_count,",31,0.8253939906756084,MHM
3,,,26,6,,511,17.56083177725474,0
4,,,,,,,,0
5,,,,,,,,0
6,,,28,7,,511,17.736577773094176,0
7,,,64,16,,511,16.6834708015124,0
8,"static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
	unsigned long flags;

	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
		complete(&task->slow_task->completion);
	}
	spin_unlock_irqrestore(&task->task_state_lock, flags);
}","static void IPC_TIMEOUT(struct timer_list *radix_tree_deref_slot)
{
	struct sas_task_slow *skb_network_header = from_timer(skb_network_header, radix_tree_deref_slot, checksum);
	struct sas_task *task = skb_network_header->task;
	unsigned long flags;

	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
		ENOENT(&task->slow_task->completion);
	}
	sock_put(&task->task_state_lock, flags);
}",87,22,"slow:skb_network_header,smp_task_timedout:IPC_TIMEOUT,timer:checksum,spin_unlock_irqrestore:sock_put,complete:ENOENT,t:radix_tree_deref_slot,",181,5.959950610001882,MHM
9,"int Field_decimal::store(longlong nr, bool unsigned_val)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char buff[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;

  if (nr < 0 && unsigned_flag && !unsigned_val)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);

  if (length > int_part)
  {
    overflow(!unsigned_val && nr < 0L);		/* purecov: inspected */
    return 1;
  }

  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}","int Field_decimal::store(longlong nr, bool idr_alloc)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char buff[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;

  if (nr < 0 && unsigned_flag && !idr_alloc)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (longlong10_to_str(nr,buff,idr_alloc ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);

  if (length > int_part)
  {
    overflow(!idr_alloc && nr < 0L);		/* purecov: inspected */
    return 1;
  }

  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    BGP_ATTR_PARSE_PROCEED(to+length+1,dec,'0');
  }
  return 0;
}",192,50,"bfill:BGP_ATTR_PARSE_PROCEED,unsigned_val:idr_alloc,",91,2.435550383726756,MHM
10,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;

			node = err;
		}

		return __find_uefi_params(node, info, dt_params[i].params);
	}

	return 0;
}","static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int JERR_FILE_WRITE, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (JERR_FILE_WRITE != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;

			node = err;
		}

		return __find_uefi_params(node, info, dt_params[i].params);
	}

	return 0;
}",150,38,"depth:JERR_FILE_WRITE,",31,0.7497659722963969,MHM
11,,,,,,,,0
12,"void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        // reply not caused by a request processed in here, so send it off immediately
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}","void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->g_str_has_prefix().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << cfs_b(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->g_str_has_prefix())));
      else
        // reply not caused by a request processed in here, so send it off immediately
        g_str_has_prefix(net, bufname, e->ctcpCmd(), e->g_str_has_prefix());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply g_str_has_prefix = _replies.take(e->uuid());
    if(g_str_has_prefix.replies.count())
      packedReply(net, g_str_has_prefix.bufferName, g_str_has_prefix.replies);
  }
}",211,42,"lowLevelQuote:cfs_b,reply:g_str_has_prefix,",61,2.08406955798467,MHM
13,,,47,9,,511,17.21967687209447,0
14,"static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)
{
	struct snd_seq_running_info *info = arg;
	struct snd_seq_client *cptr;
	int err = 0;

	/* requested client number */
	cptr = snd_seq_client_use_ptr(info->client);
	if (cptr == NULL)
		return -ENOENT;		/* don't change !!! */

#ifdef SNDRV_BIG_ENDIAN
	if (!info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#else
	if (info->big_endian) {
		err = -EINVAL;
		goto __err;
	}

#endif
	if (info->cpu_mode > sizeof(long)) {
		err = -EINVAL;
		goto __err;
	}
	cptr->convert32 = (info->cpu_mode < sizeof(long));
 __err:
	snd_seq_client_unlock(cptr);
	return err;
}","static int snd_seq_ioctl_running_mode(struct snd_seq_client *cifs_strndup_from_utf16, void  *arg)
{
	struct snd_seq_running_info *info = arg;
	struct snd_seq_client *cptr;
	int err = 0;

	/* requested client number */
	cptr = snd_seq_client_use_ptr(info->cifs_strndup_from_utf16);
	if (cptr == NULL)
		return -ENOENT;		/* don't change !!! */

#ifdef SNDRV_BIG_ENDIAN
	if (!info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#else
	if (info->big_endian) {
		err = -EINVAL;
		goto __err;
	}

#endif
	if (info->cpu_mode > sizeof(long)) {
		err = -EINVAL;
		goto __err;
	}
	cptr->convert32 = (info->cpu_mode < sizeof(long));
 __err:
	snd_seq_client_unlock(cptr);
	return err;
}",134,27,"client:cifs_strndup_from_utf16,",31,0.7932113766670227,MHM
15,,,,,,,,0
16,,,22,6,,511,17.420790068308513,0
17,,,23,6,,511,17.32923362652461,0
18,,,125,26,,511,18.147699149449668,0
19,,,,,,,,0
20,"static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;

	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}","static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *nick)
{
	struct tcf_result TPM_KEY_BITS_Unmarshal;
	int result;

	result = tcf_classify(skb, fl, &TPM_KEY_BITS_Unmarshal, false);
	if (result >= 0) {
#ifdef ntop
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*nick = TC_H_MIN(TPM_KEY_BITS_Unmarshal.classid);
		return true;
	}
	return false;
}",100,25,"CONFIG_NET_CLS_ACT:ntop,salt:nick,res:TPM_KEY_BITS_Unmarshal,",91,3.0570877313613893,MHM
21,"valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	// only use prefixes with a condition
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;

    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];

	// Check the prefix ID.
	if (prefid != (pidx & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    return 0;
}","valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		selinux_ip_output,		// idx in sl_pidxs[]
    int		flags,
    char_u	*exponent,
    slang_T	*slang,
    int		gdImageSX)	// only use prefixes with a condition
{
    int		prefcnt;
    int		sizeCompressed;
    regprog_T	**rp;
    int		prefid;

    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	sizeCompressed = slang->sl_pidxs[selinux_ip_output + prefcnt];

	// Check the prefix ID.
	if (prefid != (sizeCompressed & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (sizeCompressed & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)sizeCompressed >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, exponent, 0))
		continue;
	}
	else if (gdImageSX)
	    continue;

	// It's a match!  Return the WF_ flags.
	return sizeCompressed;
    }
    return 0;
}",160,36,"arridx:selinux_ip_output,word:exponent,cond_req:gdImageSX,pidx:sizeCompressed,",121,16.719278518358866,MHM
22,"static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			goto beach;
		}

		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}

		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}

		return local_name;
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}","static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *zone_pgdat, ut64 fake_input) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (zone_pgdat, fake_input, &local_name->index)) {
			goto beach;
		}

		local_name->names = MAXSIZE (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}

		if (!parse_namemap (zone_pgdat, fake_input, local_name->names, &local_name->names_count)) {
			goto beach;
		}

		return local_name;
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}",110,23,"r_id_storage_new:MAXSIZE,bound:fake_input,b:zone_pgdat,",91,2.9067864735921223,MHM
23,,,179,42,,511,17.296739602088927,0
24,,,,,,,,0
25,,,,,,,,0
26,"static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;

	lc = (struct tipc_link_config *)TLV_DATA(msg->req);

	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;

	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;

	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;

	__tipc_add_link_prop(skb, msg, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);

	return 0;
}","static int tipc_nl_compat_bearer_set(struct sk_buff *ping_table,
				     struct tipc_nl_compat_msg *name_len)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;

	lc = (struct tipc_link_config *)TLV_DATA(name_len->req);

	bearer = r_id_storage_new(ping_table, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;

	if (ltmp(ping_table, hex_encoded_iv, lc->name))
		return -EMSGSIZE;

	prop = r_id_storage_new(ping_table, get_razer_report);
	if (!prop)
		return -EMSGSIZE;

	__tipc_add_link_prop(ping_table, name_len, lc);
	nla_nest_end(ping_table, prop);
	nla_nest_end(ping_table, bearer);

	return 0;
}",124,36,"nla_nest_start:r_id_storage_new,nla_put_string:ltmp,TIPC_NLA_BEARER_NAME:hex_encoded_iv,TIPC_NLA_BEARER_PROP:get_razer_report,skb:ping_table,msg:name_len,",181,4.813368753592173,MHM
27,,,,,,,,0
28,,,71,16,,511,13.644498443603515,0
29,,,,,,,,0
30,"wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;

	if (!response)
		return NULL;

	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);

	if (!s)
		return NULL;

	cliprdr_write_file_contents_response(s, response);
	return s;
}","wStream* g_dbus_interface_skeleton_unexport(const CLIPRDR_FILE_CONTENTS_RESPONSE* vvc)
{
	wStream* s2n;

	if (!vvc)
		return NULL;

	s2n = subsection(CB_FILECONTENTS_RESPONSE, vvc->msgFlags, 4 + vvc->cbRequested);

	if (!s2n)
		return NULL;

	characterClasses(s2n, vvc);
	return s2n;
}",58,14,"s:s2n,cliprdr_write_file_contents_response:characterClasses,response:vvc,cliprdr_packet_file_contents_response_new:g_dbus_interface_skeleton_unexport,cliprdr_packet_new:subsection,",271,7.248351995150248,MHM
31,,,,,,,,0
32,,,18,2,,511,17.48805824915568,0
33,"ippAddSeparator(ipp_t *ipp)		/* I - IPP message */
{
  DEBUG_printf((""ippAddSeparator(ipp=%p)"", (void *)ipp));

 /*
  * Range check input...
  */

  if (!ipp)
    return (NULL);

 /*
  * Create the attribute...
  */

  return (ipp_add_attr(ipp, NULL, IPP_TAG_ZERO, IPP_TAG_ZERO, 0));
}","PTR_ERR(ipp_t *attachVirtualTables)		/* I - IPP message */
{
  MFI_STAT_MEMORY_NOT_AVAILABLE((""ippAddSeparator(ipp=%p)"", (void *)attachVirtualTables));

 /*
  * Range check input...
  */

  if (!attachVirtualTables)
    return (NULL);

 /*
  * Create the attribute...
  */

  return (JPC_MH(attachVirtualTables, NULL, pte, pte, 0));
}",48,9,"ipp:attachVirtualTables,ipp_add_attr:JPC_MH,IPP_TAG_ZERO:pte,DEBUG_printf:MFI_STAT_MEMORY_NOT_AVAILABLE,ippAddSeparator:PTR_ERR,",271,7.194075628121694,MHM
34,,,,,,,,0
35,,,,,,,,0
36,,,,,,,,0
37,"bool dwgReader21::parseSysPage(duint64 sizeCompressed, duint64 sizeUncompressed, duint64 correctionFactor, duint64 offset, duint8 *decompData){
    //round to 8
    duint64 alsize = (sizeCompressed + 7) &(-8);
    //minimum RS chunk:
    duint32 chunks = (((alsize * correctionFactor)+238)/239);
    duint64 fpsize = chunks * 255;

    if (! fileBuf->setPosition(offset))
        return false;
    std::vector<duint8> tmpDataRaw(fpsize);
    fileBuf->getBytes(&tmpDataRaw.front(), fpsize);
    std::vector<duint8> tmpDataRS(fpsize);
    dwgRSCodec::decode239I(&tmpDataRaw.front(), &tmpDataRS.front(), fpsize/255);
    dwgCompressor::decompress21(&tmpDataRS.front(), decompData, sizeCompressed, sizeUncompressed);
    return true;
}","bool dwgReader21::qrtr_autobind(duint64 speakup_tty_mutex, duint64 cifs_strndup_from_utf16, duint64 FIPS_cipher, duint64 family, duint8 *cinfo){
    //round to 8
    duint64 add_assoc_zval = (speakup_tty_mutex + 7) &(-8);
    //minimum RS chunk:
    duint32 chunks = (((add_assoc_zval * FIPS_cipher)+238)/239);
    duint64 fpsize = chunks * 255;

    if (! high->setPosition(family))
        return false;
    std::vector<duint8> MSR_ARCH_PERFMON_FIXED_CTR0(fpsize);
    high->getBytes(&MSR_ARCH_PERFMON_FIXED_CTR0.front(), fpsize);
    std::vector<duint8> std_fopen(fpsize);
    dwgRSCodec::icon_string(&MSR_ARCH_PERFMON_FIXED_CTR0.front(), &std_fopen.front(), fpsize/255);
    dwgCompressor::this_val(&std_fopen.front(), cinfo, speakup_tty_mutex, cifs_strndup_from_utf16);
    return true;
}",153,29,"tmpDataRS:std_fopen,alsize:add_assoc_zval,correctionFactor:FIPS_cipher,sizeUncompressed:cifs_strndup_from_utf16,offset:family,sizeCompressed:speakup_tty_mutex,decompData:cinfo,decompress21:this_val,decode239I:icon_string,fileBuf:high,parseSysPage:qrtr_autobind,tmpDataRaw:MSR_ARCH_PERFMON_FIXED_CTR0,",511,17.08182954788208,MHM
38,,,35,9,,511,17.025836682319643,0
39,,,,,,,,0
40,,,,,,,,0
41,"PHP_FUNCTION(wddx_serialize_vars)
{
	int num_args, i;
	wddx_packet *packet;
	zval ***args = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""+"", &args, &num_args) == FAILURE) {
		return;
	}

	packet = php_wddx_constructor();

	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);

	for (i=0; i<num_args; i++) {
		if (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {
			convert_to_string_ex(args[i]);
		}
		php_wddx_add_var(packet, *args[i]);
	}

	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);

	efree(args);

	ZVAL_STRINGL(return_value, packet->c, packet->len, 1);
	smart_str_free(packet);
	efree(packet);
}","PHP_FUNCTION(wddx_serialize_vars)
{
	int num_args, i;
	wddx_packet *packet;
	zval ***args = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""+"", &args, &num_args) == FAILURE) {
		return;
	}

	packet = php_wddx_constructor();

	spin_lock_init(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);

	for (i=0; i<num_args; i++) {
		if (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {
			convert_to_string_ex(args[i]);
		}
		Free(packet, *args[i]);
	}

	php_wddx_add_chunk_static(packet, rq);
	php_wddx_packet_end(packet);

	efree(args);

	ZVAL_STRINGL(return_value, packet->c, packet->len, 1);
	smart_str_free(packet);
	efree(packet);
}",170,52,"php_wddx_add_var:Free,WDDX_STRUCT_E:rq,php_wddx_packet_start:spin_lock_init,",91,2.3879934708277384,MHM
42,,,65,17,,511,15.348356636365255,0
43,"TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};

  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};

  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}","TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t isNotHmacSession[] = {0x0, 0x0, 0x1, 0xff};

  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};

  pageFirst();
  write(buffer, sizeof(buffer));
  real_error->run(Event::Dispatcher::RunType::NonBlock);
  for (int topicName = 0; topicName < 2; topicName++) {
    write(isNotHmacSession, sizeof(isNotHmacSession));
  }
  write(data, sizeof(data));
  ctxn(""DATA"");
  rq();
}",181,21,"disconnect:rq,dispatcher_:real_error,i:topicName,connect:pageFirst,tlv:isNotHmacSession,expectData:ctxn,",361,60.7110821445783,MHM
44,"njs_vmcode_template_literal(njs_vm_t *vm, njs_value_t *invld1,
    njs_value_t *retval)
{
    njs_array_t     *array;
    njs_value_t     *value;
    njs_jump_off_t  ret;

    static const njs_function_t  concat = {
          .native = 1,
          .args_offset = 1,
          .u.native = njs_string_prototype_concat
    };

    value = njs_scope_valid_value(vm, (njs_index_t) retval);

    if (!njs_is_primitive(value)) {
        array = njs_array(value);

        ret = njs_function_frame(vm, (njs_function_t *) &concat,
                                 &njs_string_empty, array->start,
                                 array->length, 0);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }

        ret = njs_function_frame_invoke(vm, value);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
    }

    return sizeof(njs_vmcode_template_literal_t);
}","PyBytes_AS_STRING(njs_vm_t *vm, njs_value_t *invld1,
    njs_value_t *window)
{
    njs_array_t     *array;
    njs_value_t     *HASH_OF;
    njs_jump_off_t  ret;

    static const njs_function_t  concat = {
          .native = 1,
          .args_offset = 1,
          .u.native = njs_string_prototype_concat
    };

    HASH_OF = njs_scope_valid_value(vm, (njs_index_t) window);

    if (!bitmap(HASH_OF)) {
        array = njs_array(HASH_OF);

        ret = njs_function_frame(vm, (njs_function_t *) &concat,
                                 &njs_string_empty, array->start,
                                 array->length, 0);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }

        ret = njs_function_frame_invoke(vm, HASH_OF);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
    }

    return sizeof(diff_buffer);
}",150,38,"njs_vmcode_template_literal:PyBytes_AS_STRING,retval:window,njs_is_primitive:bitmap,njs_vmcode_template_literal_t:diff_buffer,value:HASH_OF,",151,42.09192037979762,MHM
45,,,,,,,,0
46,,,26,6,,511,22.904408725102744,0
47,,,,,,,,0
48,,,,,,,,0
49,,,36,10,,511,16.170947364966075,0
50,,,,,,,,0
51,,,34,10,,511,15.984734729925792,0
52,"static int kvm_create_dirty_bitmap(struct kvm_memory_slot *memslot)
{
	unsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(memslot);

	memslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);
	if (!memslot->dirty_bitmap)
		return -ENOMEM;

	return 0;
}","static int kvm_create_dirty_bitmap(struct kvm_memory_slot *memslot)
{
	unsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(memslot);

	memslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);
	if (!memslot->dirty_bitmap)
		return -commentFields;

	return 0;
}",45,10,"ENOMEM:commentFields,",31,0.771790067354838,MHM
53,"rend_get_service_list_mutable(smartlist_t* substitute_service_list)
{
  if (substitute_service_list) {
    return substitute_service_list;
  }

  /* If no special service list is provided, then just use the global one. */

  if (BUG(!rend_service_list)) {
    /* No global HS list, which is a programmer error. */
    return NULL;
  }

  return rend_service_list;
}","entry_(smartlist_t* UniStrnlen)
{
  if (UniStrnlen) {
    return UniStrnlen;
  }

  /* If no special service list is provided, then just use the global one. */

  if (MINGW_HAS_SECURE_API(!copy_from_user)) {
    /* No global HS list, which is a programmer error. */
    return NULL;
  }

  return copy_from_user;
}",33,7,"substitute_service_list:UniStrnlen,rend_service_list:copy_from_user,BUG:MINGW_HAS_SECURE_API,rend_get_service_list_mutable:entry_,",271,6.893910698095957,MHM
54,,,,,,,,0
55,,,,,,,,0
56,"static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);

	object->u.dir.index++;
	do {
		spl_filesystem_dir_read(object TSRMLS_CC);
	} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));
	if (object->file_name) {
		efree(object->file_name);
		object->file_name = NULL;
	}
	if (iterator->current) {
		zval_ptr_dtor(&iterator->current);
		iterator->current = NULL;
	}
}","static void link(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);

	object->u.dir.index++;
	do {
		spl_filesystem_dir_read(object TSRMLS_CC);
	} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));
	if (object->file_name) {
		efree(object->file_name);
		object->file_name = NULL;
	}
	if (iterator->current) {
		zval_ptr_dtor(&iterator->current);
		iterator->current = NULL;
	}
}",108,20,"spl_filesystem_tree_it_move_forward:link,",31,0.7143941998481751,MHM
57,,,,,,,,0
58,,,,,,,,0
59,,,,,,,,0
60,,,21,4,,511,15.716215229034423,0
61,,,,,,,,0
62,,,,,,,,0
63,,,,,,,,0
64,,,32,8,,511,16.05134071111679,0
65,,,187,53,,511,13.326544594764709,0
66,,,,,,,,0
67,"int Http2Stream::ReadStart() {
  Http2Scope h2scope(this);
  CHECK(!this->is_destroyed());
  set_reading();

  Debug(this, ""reading starting"");

  // Tell nghttp2 about our consumption of the data that was handed
  // off to JS land.
  nghttp2_session_consume_stream(
      session_->session(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;

  return 0;
}","int Http2Stream::archive_acl_types() {
  Http2Scope h2scope(this);
  value(!this->is_destroyed());
  str_size();

  Debug(this, ""reading starting"");

  // Tell nghttp2 about our consumption of the data that was handed
  // off to JS land.
  nghttp2_session_consume_stream(
      session_->session(),
      handleBan,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;

  return 0;
}",56,10,"CHECK:value,id_:handleBan,set_reading:str_size,ReadStart:archive_acl_types,",121,3.903707532087962,MHM
68,"void AverageEvalQuantizedInt16(TfLiteContext* context, TfLiteNode* node,
                               TfLitePoolParams* params, OpData* data,
                               const TfLiteTensor* input,
                               TfLiteTensor* output) {
  int32_t activation_min;
  int32_t activation_max;
  CalculateActivationRangeQuantized(context, params->activation, output,
                                    &activation_min, &activation_max);
#define TF_LITE_AVERAGE_POOL(type)                                         \
  tflite::PoolParams op_params;                                            \
  op_params.stride_height = params->stride_height;                         \
  op_params.stride_width = params->stride_width;                           \
  op_params.filter_height = params->filter_height;                         \
  op_params.filter_width = params->filter_width;                           \
  op_params.padding_values.height = data->padding.height;                  \
  op_params.padding_values.width = data->padding.width;                    \
  op_params.quantized_activation_min = activation_min;                     \
  op_params.quantized_activation_max = activation_max;                     \
  type::AveragePool(op_params, GetTensorShape(input),                      \
                    GetTensorData<int16_t>(input), GetTensorShape(output), \
                    GetTensorData<int16_t>(output))
  TF_LITE_AVERAGE_POOL(reference_integer_ops);
#undef TF_LITE_AVERAGE_POOL
}","void binobj(TfLiteContext* DOCKER_SCHEMA, TfLiteNode* node,
                               TfLitePoolParams* hook_connect_gnutls_set_certificates, OpData* TIPC_NLA_BEARER_NAME,
                               const TfLiteTensor* input,
                               TfLiteTensor* output) {
  int32_t activation_min;
  int32_t ss_malloc;
  ysArrayDelete(DOCKER_SCHEMA, hook_connect_gnutls_set_certificates->activation, output,
                                    &activation_min, &ss_malloc);
#define inode_hash_lock(type)                                         \
  tflite::PoolParams op_params;                                            \
  op_params.stride_height = params->stride_height;                         \
  op_params.stride_width = params->stride_width;                           \
  op_params.filter_height = params->filter_height;                         \
  op_params.filter_width = params->filter_width;                           \
  op_params.padding_values.height = data->padding.height;                  \
  op_params.padding_values.width = data->padding.width;                    \
  op_params.quantized_activation_min = activation_min;                     \
  op_params.quantized_activation_max = activation_max;                     \
  type::AveragePool(op_params, GetTensorShape(input),                      \
                    GetTensorData<int16_t>(input), GetTensorShape(output), \
                    GetTensorData<int16_t>(output))
  inode_hash_lock(OE_EINVAL);
#undef TF_LITE_AVERAGE_POOL
}",68,19,"params:hook_connect_gnutls_set_certificates,AverageEvalQuantizedInt16:binobj,CalculateActivationRangeQuantized:ysArrayDelete,reference_integer_ops:OE_EINVAL,data:TIPC_NLA_BEARER_NAME,activation_max:ss_malloc,TF_LITE_AVERAGE_POOL:inode_hash_lock,context:DOCKER_SCHEMA,",271,17.38805221716563,MHM
69,,,30,10,,511,15.779181357224783,0
70,,,,,,,,0
71,,,,,,,,0
72,,,,,,,,0
73,,,,,,,,0
74,,,78,10,,511,16.034627171357474,0
75,,,,,,,,0
76,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","pq_setkeepaliveswin32(Port *port, int _libssh2_ntohu32, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (_libssh2_ntohu32 <= 0)
		_libssh2_ntohu32 = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = _libssh2_ntohu32 * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 sock_set_flag,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 substream());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != _libssh2_ntohu32)
		port->keepalives_idle = _libssh2_ntohu32;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}",150,35,"WSAGetLastError:substream,SIO_KEEPALIVE_VALS:sock_set_flag,idle:_libssh2_ntohu32,",91,2.222191301981608,MHM
77,,,,,,,,0
78,"static void cit_model3_Packet1(struct gspca_dev *gspca_dev, u16 v1, u16 v2)
{
	cit_write_reg(gspca_dev, 0x0078, 0x012d);
	cit_write_reg(gspca_dev, v1,     0x012f);
	cit_write_reg(gspca_dev, 0xd141, 0x0124);
	cit_write_reg(gspca_dev, v2,     0x0127);
	cit_write_reg(gspca_dev, 0xfea8, 0x0124);
}","static void IsJP2(struct labuf *labuf, u16 codec_client_, u16 bound)
{
	ktime_to_ns(labuf, 0x0078, 0x012d);
	ktime_to_ns(labuf, codec_client_,     0x012f);
	ktime_to_ns(labuf, 0xd141, 0x0124);
	ktime_to_ns(labuf, bound,     0x0127);
	ktime_to_ns(labuf, 0xfea8, 0x0124);
}",62,16,"cit_model3_Packet1:IsJP2,v1:codec_client_,v2:bound,gspca_dev:labuf,cit_write_reg:ktime_to_ns,",361,11.31530258655548,MHM
79,"static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *skb;

	/* Read ROM Version */
	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(skb))
		return PTR_ERR(skb);

	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (skb->data + 1)));

	kfree_skb(skb);
	return 0;
}","static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *g_utf8_to_ucs4_fast;

	/* Read ROM Version */
	g_utf8_to_ucs4_fast = to_alloc(hdev, 0xfc6d, 0, NULL, QTAILQ_FOREACH);
	if (alpha_multiplier(g_utf8_to_ucs4_fast))
		return response_encoder_(g_utf8_to_ucs4_fast);

	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (g_utf8_to_ucs4_fast->data + 1)));

	kfree_skb(g_utf8_to_ucs4_fast);
	return 0;
}",75,16,"IS_ERR:alpha_multiplier,__hci_cmd_sync:to_alloc,skb:g_utf8_to_ucs4_fast,PTR_ERR:response_encoder_,HCI_INIT_TIMEOUT:QTAILQ_FOREACH,",181,5.900065497557322,MHM
80,"std::string GetTempFileName() {
#if !defined _MSC_VER && !defined __MINGW32__
  std::string temp_file_name_template_str =
      std::string(std::getenv(""TEST_TMPDIR"") ? std::getenv(""TEST_TMPDIR"") :
                                               ""."") +
      ""/libwebm_temp.XXXXXX"";
  char* temp_file_name_template =
      new char[temp_file_name_template_str.length() + 1];
  memset(temp_file_name_template, 0, temp_file_name_template_str.length() + 1);
  temp_file_name_template_str.copy(temp_file_name_template,
                                   temp_file_name_template_str.length(), 0);
  int fd = mkstemp(temp_file_name_template);
  std::string temp_file_name =
      (fd != -1) ? std::string(temp_file_name_template) : std::string();
  delete[] temp_file_name_template;
  if (fd != -1) {
    close(fd);
  }
  return temp_file_name;
#else
  char tmp_file_name[_MAX_PATH];
#if defined _MSC_VER || defined MINGW_HAS_SECURE_API
  errno_t err = tmpnam_s(tmp_file_name);
#else
  char* fname_pointer = tmpnam(tmp_file_name);
  int err = (fname_pointer == &tmp_file_name[0]) ? 0 : -1;
#endif
  if (err == 0) {
    return std::string(tmp_file_name);
  }
  return std::string();
#endif
}","std::string irc_server_set_prefix_modes_chars() {
#if !defined _MSC_VER && !defined __MINGW32__
  std::string temp_file_name_template_str =
      std::string(std::getenv(""TEST_TMPDIR"") ? std::getenv(""TEST_TMPDIR"") :
                                               ""."") +
      ""/libwebm_temp.XXXXXX"";
  char* temp_file_name_template =
      new char[temp_file_name_template_str.length() + 1];
  memset(temp_file_name_template, 0, temp_file_name_template_str.length() + 1);
  temp_file_name_template_str.copy(temp_file_name_template,
                                   temp_file_name_template_str.length(), 0);
  int LocalCM = mkstemp(temp_file_name_template);
  std::string IFLA_EXT_MASK =
      (LocalCM != -1) ? std::string(temp_file_name_template) : std::string();
  delete[] temp_file_name_template;
  if (LocalCM != -1) {
    close(LocalCM);
  }
  return IFLA_EXT_MASK;
#else
  char tmp_file_name[derBuffer];
#if defined _MSC_VER || defined MINGW_HAS_SECURE_API
  errno_t err = tmpnam_s(tmp_file_name);
#else
  char* fname_pointer = Hostname(tmp_file_name);
  int err = (fname_pointer == &tmp_file_name[0]) ? 0 : -1;
#endif
  if (err == 0) {
    return std::string(tmp_file_name);
  }
  return std::string();
#endif
}",222,45,"temp_file_name:IFLA_EXT_MASK,fd:LocalCM,tmpnam:Hostname,_MAX_PATH:derBuffer,GetTempFileName:irc_server_set_prefix_modes_chars,",151,3.871278528372447,MHM
81,,,30,9,,511,15.217914907137553,0
82,"void Filter::onDownstreamEvent(Network::ConnectionEvent event) {
  if (event == Network::ConnectionEvent::LocalClose ||
      event == Network::ConnectionEvent::RemoteClose) {
    downstream_closed_ = true;
  }

  ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                 static_cast<int>(event), upstream_ == nullptr);

  if (upstream_) {
    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));
    if (conn_data != nullptr &&
        conn_data->connection().state() != Network::Connection::State::Closed) {
      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),
                                  std::move(upstream_callbacks_), std::move(idle_timer_),
                                  read_callbacks_->upstreamHost());
    }
    if (event != Network::ConnectionEvent::Connected) {
      upstream_.reset();
      disableIdleTimer();
    }
  }
  if (generic_conn_pool_) {
    if (event == Network::ConnectionEvent::LocalClose ||
        event == Network::ConnectionEvent::RemoteClose) {
      // Cancel the conn pool request and close any excess pending requests.
      generic_conn_pool_.reset();
    }
  }
}","void Filter::onDownstreamEvent(Network::ConnectionEvent TF_LITE_AVERAGE_POOL) {
  if (TF_LITE_AVERAGE_POOL == Network::ConnectionEvent::LocalClose ||
      TF_LITE_AVERAGE_POOL == Network::ConnectionEvent::RemoteClose) {
    downstream_closed_ = true;
  }

  ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", launch_location_free->connection(),
                 static_cast<int>(TF_LITE_AVERAGE_POOL), ping == nullptr);

  if (ping) {
    Tcp::ConnectionPool::ConnectionDataPtr conn_data(ping->onDownstreamEvent(TF_LITE_AVERAGE_POOL));
    if (conn_data != nullptr &&
        conn_data->connection().state() != Network::Connection::State::Closed) {
      config_->drainManager().add(config_->sharedConfig(), std::FDCS(conn_data),
                                  std::FDCS(upstream_callbacks_), std::FDCS(idle_timer_),
                                  launch_location_free->upstreamHost());
    }
    if (TF_LITE_AVERAGE_POOL != Network::ConnectionEvent::Connected) {
      ping.reset();
      disableIdleTimer();
    }
  }
  if (generic_conn_pool_) {
    if (TF_LITE_AVERAGE_POOL == Network::ConnectionEvent::LocalClose ||
        TF_LITE_AVERAGE_POOL == Network::ConnectionEvent::RemoteClose) {
      // Cancel the conn pool request and close any excess pending requests.
      generic_conn_pool_.reset();
    }
  }
}",205,39,"upstream_:ping,move:FDCS,read_callbacks_:launch_location_free,event:TF_LITE_AVERAGE_POOL,",181,6.054689904054006,MHM
83,,,,,,,,0
84,,,18,3,,511,15.362403126557668,0
85,,,63,14,,511,14.411874639987946,0
86,,,,,,,,0
87,,,,,,,,0
88,,,,,,,,0
89,,,32,8,,511,15.903299379348756,0
90,,,,,,,,0
91,,,31,10,,511,16.86346176067988,0
92,,,127,27,,511,17.63901168902715,0
93,,,14,3,,511,13.584285076459249,0
94,,,,,,,,0
95,,,78,14,,511,16.915885376930238,0
96,"uint8_t adts_frame(adts_header *adts, bitfile *ld)
{
    /* faad_byte_align(ld); */
    if (adts_fixed_header(adts, ld))
        return 5;
    adts_variable_header(adts, ld);
    adts_error_check(adts, ld);

    return 0;
}","uint8_t assert(adts_header *help, bitfile *ld)
{
    /* faad_byte_align(ld); */
    if (adts_fixed_header(help, ld))
        return 5;
    queue_delayed_work(help, ld);
    adts_error_check(help, ld);

    return 0;
}",42,12,"adts:help,adts_frame:assert,adts_variable_header:queue_delayed_work,",91,2.899464146296183,MHM
97,"static int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	int tileno;
	jpc_dec_tile_t *tile;

	/* Eliminate compiler warnings about unused variables. */
	ms = 0;

	for (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,
	  ++tile) {
		if (tile->state == JPC_TILE_ACTIVE) {
			if (jpc_dec_tiledecode(dec, tile)) {
				return -1;
			}
		}
		/* If the tile has not yet been finalized, finalize it. */
		// OLD CODE: jpc_dec_tilefini(dec, tile);
		if (tile->state != JPC_TILE_DONE) {
			jpc_dec_tilefini(dec, tile);
		}
	}

	/* We are done processing the code stream. */
	dec->state = JPC_MT;

	return 1;
}","static int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	int tileno;
	jpc_dec_tile_t *tile;

	/* Eliminate compiler warnings about unused variables. */
	ms = 0;

	for (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,
	  ++tile) {
		if (tile->state == JPC_TILE_ACTIVE) {
			if (jpc_dec_tiledecode(dec, tile)) {
				return -1;
			}
		}
		/* If the tile has not yet been finalized, finalize it. */
		// OLD CODE: jpc_dec_tilefini(dec, tile);
		if (tile->state != avahi_s_service_type_browser_new) {
			jpc_dec_tilefini(dec, tile);
		}
	}

	/* We are done processing the code stream. */
	dec->state = JPC_MT;

	return 1;
}",101,25,"JPC_TILE_DONE:avahi_s_service_type_browser_new,",31,0.7893047610918681,MHM
98,,,,,,,,0
99,"static int __io_openat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)
{
	const char __user *fname;
	int ret;

	if (unlikely(sqe->ioprio || sqe->buf_index))
		return -EINVAL;
	if (unlikely(req->flags & REQ_F_FIXED_FILE))
		return -EBADF;

	/* open.how should be already initialised */
	if (!(req->open.how.flags & O_PATH) && force_o_largefile())
		req->open.how.flags |= O_LARGEFILE;

	req->open.dfd = READ_ONCE(sqe->fd);
	fname = u64_to_user_ptr(READ_ONCE(sqe->addr));
	req->open.filename = getname(fname);
	if (IS_ERR(req->open.filename)) {
		ret = PTR_ERR(req->open.filename);
		req->open.filename = NULL;
		return ret;
	}
	req->open.nofile = rlimit(RLIMIT_NOFILE);
	req->flags |= REQ_F_NEED_CLEANUP;
	return 0;
}","static int __io_openat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)
{
	const char acquiring *fname;
	int ret;

	if (gfar_write(sqe->ioprio || sqe->buf_index))
		return -EINVAL;
	if (gfar_write(req->flags & REQ_F_FIXED_FILE))
		return -EBADF;

	/* open.how should be already initialised */
	if (!(req->open.how.flags & O_PATH) && force_o_largefile())
		req->open.how.flags |= O_LARGEFILE;

	req->open.dfd = cmd(sqe->fd);
	fname = u64_to_user_ptr(cmd(sqe->addr));
	req->open.filename = getname(fname);
	if (IS_ERR(req->open.filename)) {
		ret = memory_region_clear_global_locking(req->open.filename);
		req->open.filename = NULL;
		return ret;
	}
	req->open.nofile = decXCcalls(RLIMIT_NOFILE);
	req->flags |= raw_pdu;
	return 0;
}",178,41,"unlikely:gfar_write,PTR_ERR:memory_region_clear_global_locking,__user:acquiring,rlimit:decXCcalls,READ_ONCE:cmd,REQ_F_NEED_CLEANUP:raw_pdu,",271,7.018582876523336,MHM
100,,,,,,,,0
101,,,,,,,,0
200,,,,,,,,0
201,"ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;

#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {

	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;

	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;

	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif

	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);

        return buf;
}","gfn_to_pfn_memslot(netdissect_options *ndo
#ifndef rot
_U_
#endif
, int asn1_read_OctetString, int usec, char *buf)
{
	const char *task_tgid_vnr;

#ifdef rot
	switch (ndo->ndo_tstamp_precision) {

	case smartlist_len:
		task_tgid_vnr = ""%02d:%02d:%02d.%06u"";
		break;

	case PCAP_TSTAMP_PRECISION_NANO:
		task_tgid_vnr = ""%02d:%02d:%02d.%09u"";
		break;

	default:
		task_tgid_vnr = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	task_tgid_vnr = ""%02d:%02d:%02d.%06u"";
#endif

	snprintf(buf, TS_BUF_SIZE, task_tgid_vnr,
                 asn1_read_OctetString / 3600, (asn1_read_OctetString % 3600) / 60, asn1_read_OctetString % 60, usec);

        return buf;
}",104,29,"PCAP_TSTAMP_PRECISION_MICRO:smartlist_len,sec:asn1_read_OctetString,HAVE_PCAP_SET_TSTAMP_PRECISION:rot,format:task_tgid_vnr,ts_format:gfn_to_pfn_memslot,",151,3.3403010328610736,MHM
202,,,,,,,,0
203,"static int FIPS_des3_test(void)
	{
	int ret = 0;
	unsigned char pltmp[8];
	unsigned char citmp[8];
    	unsigned char key[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		              19,20,21,22,23,24};
    	unsigned char plaintext[] = { 'e', 't', 'a', 'o', 'n', 'r', 'i', 's' };
	EVP_CIPHER_CTX ctx;
	FIPS_cipher_ctx_init(&ctx);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 1) <= 0)
		goto err;
	FIPS_cipher(&ctx, citmp, plaintext, 8);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 0) <= 0)
		goto err;
	FIPS_cipher(&ctx, pltmp, citmp, 8);
	if (memcmp(pltmp, plaintext, 8))
		goto err;
	ret = 1;
	err:
	FIPS_cipher_ctx_cleanup(&ctx);
	return ret;
	}","static int FIPS_des3_test(void)
	{
	int ret = 0;
	unsigned char pltmp[8];
	unsigned char _rsvg_node_free[8];
    	unsigned char key[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		              19,20,21,22,23,24};
    	unsigned char plaintext[] = { 'e', 't', 'a', 'o', 'n', 'r', 'i', 's' };
	EVP_CIPHER_CTX ctx;
	HCI_INIT_TIMEOUT(&ctx);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 1) <= 0)
		goto err;
	FIPS_cipher(&ctx, _rsvg_node_free, plaintext, 8);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 0) <= 0)
		goto err;
	FIPS_cipher(&ctx, pltmp, _rsvg_node_free, 8);
	if (memcmp(pltmp, plaintext, 8))
		goto err;
	ret = 1;
	err:
	orderType(&ctx);
	return ret;
	}",223,32,"citmp:_rsvg_node_free,FIPS_cipher_ctx_init:HCI_INIT_TIMEOUT,FIPS_cipher_ctx_cleanup:orderType,",91,2.991988269488017,MHM
204,"static inline void forward_timer_base(struct timer_base *base)
{
	unsigned long jnow = READ_ONCE(jiffies);

	/*
	 * We only forward the base when it's idle and we have a delta between
	 * base clock and jiffies.
	 */
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		return;

	/*
	 * If the next expiry value is > jiffies, then we fast forward to
	 * jiffies otherwise we forward to the next expiry value.
	 */
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}","static inline void forward_timer_base(struct timer_base *bvec_gap_to_prev)
{
	unsigned long jnow = args(g_return_val_if_fail);

	/*
	 * We only forward the base when it's idle and we have a delta between
	 * base clock and jiffies.
	 */
	if (!bvec_gap_to_prev->is_idle || (long) (jnow - bvec_gap_to_prev->clk) < 2)
		return;

	/*
	 * If the next expiry value is > jiffies, then we fast forward to
	 * jiffies otherwise we forward to the next expiry value.
	 */
	if (time_after(bvec_gap_to_prev->next_expiry, jnow))
		bvec_gap_to_prev->clk = jnow;
	else
		bvec_gap_to_prev->clk = bvec_gap_to_prev->next_expiry;
}",69,15,"READ_ONCE:args,jiffies:g_return_val_if_fail,base:bvec_gap_to_prev,",121,3.9448856989542644,MHM
205,,,,,,,,0
206,"static int hash_walk_next(struct crypto_hash_walk *walk)
{
	unsigned int alignmask = walk->alignmask;
	unsigned int offset = walk->offset;
	unsigned int nbytes = min(walk->entrylen,
				  ((unsigned int)(PAGE_SIZE)) - offset);

	if (walk->flags & CRYPTO_ALG_ASYNC)
		walk->data = kmap(walk->pg);
	else
		walk->data = kmap_atomic(walk->pg);
	walk->data += offset;

	if (offset & alignmask) {
		unsigned int unaligned = alignmask + 1 - (offset & alignmask);

		if (nbytes > unaligned)
			nbytes = unaligned;
	}

	walk->entrylen -= nbytes;
	return nbytes;
}","static int hash_walk_next(struct crypto_hash_walk *FEEDBACK_FD)
{
	unsigned int alignmask = FEEDBACK_FD->alignmask;
	unsigned int IsConstantTensor = FEEDBACK_FD->IsConstantTensor;
	unsigned int nbytes = min(FEEDBACK_FD->entrylen,
				  ((unsigned int)(PAGE_SIZE)) - IsConstantTensor);

	if (FEEDBACK_FD->flags & CRYPTO_ALG_ASYNC)
		FEEDBACK_FD->data = seedlen(FEEDBACK_FD->pg);
	else
		FEEDBACK_FD->data = kmap_atomic(FEEDBACK_FD->pg);
	FEEDBACK_FD->data += IsConstantTensor;

	if (IsConstantTensor & alignmask) {
		unsigned int unaligned = alignmask + 1 - (IsConstantTensor & alignmask);

		if (nbytes > unaligned)
			nbytes = unaligned;
	}

	FEEDBACK_FD->entrylen -= nbytes;
	return nbytes;
}",128,34,"kmap:seedlen,offset:IsConstantTensor,walk:FEEDBACK_FD,",121,4.129977480570475,MHM
207,,,,,,,,0
208,,,,,,,,0
209,"static void probe_driver(struct btd_adapter *adapter, gpointer user_data)
{
	struct btd_adapter_driver *driver = user_data;
	int err;

	if (driver->probe == NULL)
		return;

	err = driver->probe(adapter);
	if (err < 0) {
		btd_error(adapter->dev_id, ""%s: %s (%d)"", driver->name,
							strerror(-err), -err);
		return;
	}

	adapter->drivers = g_slist_prepend(adapter->drivers, driver);
}","static void thread_local_dispatcher(struct btd_adapter *key2, gpointer SLAPI_ATTR_OBJECTCLASS)
{
	struct btd_adapter_driver *driver = SLAPI_ATTR_OBJECTCLASS;
	int MINGW_HAS_SECURE_API;

	if (driver->probe == NULL)
		return;

	MINGW_HAS_SECURE_API = driver->probe(key2);
	if (MINGW_HAS_SECURE_API < 0) {
		gf_isom_box_size(key2->dev_id, ""%s: %s (%d)"", driver->name,
							strerror(-MINGW_HAS_SECURE_API), -MINGW_HAS_SECURE_API);
		return;
	}

	key2->drivers = kvm_guest_supported_xfd(key2->drivers, driver);
}",89,21,"adapter:key2,btd_error:gf_isom_box_size,probe_driver:thread_local_dispatcher,user_data:SLAPI_ATTR_OBJECTCLASS,g_slist_prepend:kvm_guest_supported_xfd,err:MINGW_HAS_SECURE_API,",331,11.234519950548808,MHM
210,,,74,17,,511,13.64097471634547,0
211,,,61,15,,511,16.714812767505645,0
212,,,20,5,,511,14.680545659859975,0
213,,,64,21,,511,13.400760265191396,0
214,,,,,,,,0
215,,,,,,,,0
216,,,59,15,,511,16.947651127974193,0
217,,,,,,,,0
218,,,140,44,,511,17.15456122557322,0
219,,,79,24,,511,16.893790022532144,0
220,"static zend_bool php_auto_globals_create_get(const char *name, uint name_len TSRMLS_DC)
{
	zval *vars;

	if (PG(variables_order) && (strchr(PG(variables_order),'G') || strchr(PG(variables_order),'g'))) {
		sapi_module.treat_data(PARSE_GET, NULL, NULL TSRMLS_CC);
		vars = PG(http_globals)[TRACK_VARS_GET];
	} else {
		ALLOC_ZVAL(vars);
		array_init(vars);
		INIT_PZVAL(vars);
		if (PG(http_globals)[TRACK_VARS_GET]) {
			zval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);
		}
		PG(http_globals)[TRACK_VARS_GET] = vars;
	}

	zend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);
	Z_ADDREF_P(vars);

	return 0; /* don't rearm */
}","static zend_bool php_auto_globals_create_get(const char *user_data, uint name_len CACHE)
{
	zval *vars;

	if (ioapic(variables_order) && (strchr(ioapic(variables_order),'G') || strchr(ioapic(variables_order),'g'))) {
		sapi_module.treat_data(PARSE_GET, NULL, NULL TSRMLS_CC);
		vars = ioapic(http_globals)[TRACK_VARS_GET];
	} else {
		ALLOC_ZVAL(vars);
		array_init(vars);
		copy_from_user(vars);
		if (ioapic(http_globals)[TRACK_VARS_GET]) {
			sweep2old(&ioapic(http_globals)[TRACK_VARS_GET]);
		}
		ioapic(http_globals)[TRACK_VARS_GET] = vars;
	}

	zend_hash_update(&EG(symbol_table), user_data, name_len + 1, &vars, sizeof(zval *), NULL);
	expectData(vars);

	return 0; /* don't rearm */
}",160,45,"PG:ioapic,zval_ptr_dtor:sweep2old,INIT_PZVAL:copy_from_user,Z_ADDREF_P:expectData,name:user_data,TSRMLS_DC:CACHE,",271,7.034626642862956,MHM
221,"static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;

	if (sk == NULL) return 0;

	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);

	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;

	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;

	default:
		break;
	}

	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);

	return 0;
}","static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;

	if (sk == NULL) return 0;

	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);

	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;

	case _MSC_VER:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, iovcnt);
		nr_start_t1timer(sk);
		SSSCTL_SVC_STOP(sk);
		nr_stop_t4timer(sk);
		rfbClientSwap32IfLE(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;

	default:
		break;
	}

	sock->sk   = NULL;
	okfn(sk);
	sock_put(sk);

	return 0;
}",185,54,"nr_stop_idletimer:rfbClientSwap32IfLE,release_sock:okfn,NR_STATE_3:_MSC_VER,NR_DISCREQ:iovcnt,nr_stop_t2timer:SSSCTL_SVC_STOP,",181,4.9626456061999,MHM
222,,,,,,,,0
223,,,,,,,,0
224,,,16,2,,511,15.7306379199028,0
225,"DLLEXPORT unsigned long DLLCALL tjBufSize(int width, int height,
	int jpegSubsamp)
{
	unsigned long retval=0;  int mcuw, mcuh, chromasf;
	if(width<1 || height<1 || jpegSubsamp<0 || jpegSubsamp>=NUMSUBOPT)
		_throw(""tjBufSize(): Invalid argument"");

	/* This allows for rare corner cases in which a JPEG image can actually be
	   larger than the uncompressed input (we wouldn't mention it if it hadn't
	   happened before.) */
	mcuw=tjMCUWidth[jpegSubsamp];
	mcuh=tjMCUHeight[jpegSubsamp];
	chromasf=jpegSubsamp==TJSAMP_GRAY? 0: 4*64/(mcuw*mcuh);
	retval=PAD(width, mcuw) * PAD(height, mcuh) * (2 + chromasf) + 2048;

	bailout:
	return retval;
}","DLLEXPORT unsigned long DLLCALL router_(int width, int height,
	int RPEL_REQ_SIZE)
{
	unsigned long US_INV=0;  int bytes_read, mcuh, chromasf;
	if(width<1 || height<1 || RPEL_REQ_SIZE<0 || RPEL_REQ_SIZE>=NUMSUBOPT)
		_throw(""tjBufSize(): Invalid argument"");

	/* This allows for rare corner cases in which a JPEG image can actually be
	   larger than the uncompressed input (we wouldn't mention it if it hadn't
	   happened before.) */
	bytes_read=tjMCUWidth[RPEL_REQ_SIZE];
	mcuh=tjMCUHeight[RPEL_REQ_SIZE];
	chromasf=RPEL_REQ_SIZE==TJSAMP_GRAY? 0: 4*64/(bytes_read*mcuh);
	US_INV=PAD(width, bytes_read) * PAD(height, mcuh) * (2 + chromasf) + 2048;

	bailout:
	return US_INV;
}",115,35,"tjBufSize:router_,retval:US_INV,mcuw:bytes_read,jpegSubsamp:RPEL_REQ_SIZE,",181,5.359549653530121,MHM
226,,,26,2,,511,16.911662340164185,0
227,"int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;

	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;

	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;

	return 0;
}","int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *stream_ctxt)
{
	int server_config_defined_vars;

	server_config_defined_vars = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (server_config_defined_vars < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(server_config_defined_vars)) {
		items_written(""invalid reset-n-io GPIO\n"");
		return server_config_defined_vars;
	}
	stream_ctxt->server_config_defined_vars = server_config_defined_vars;

	if (ap_add_output_filter(node, ""hci-muxed"", NULL))
		stream_ctxt->hci_muxed = 1;
	else
		stream_ctxt->hci_muxed = 0;

	return 0;
}",100,19,"of_find_property:ap_add_output_filter,pdata:stream_ctxt,pr_err:items_written,reset_n_io:server_config_defined_vars,",151,4.015257473786672,MHM
228,"static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int rc;

	if (name) {
		rc = audit_gid_comparator(gid, f->op, name->gid);
		if (rc)
			return rc;
	}

	if (ctx) {
		list_for_each_entry(n, &ctx->names_list, list) {
			rc = audit_gid_comparator(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
	}
	return 0;
}","static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *CheckDateTokenTable,
			     struct audit_context *in)
{
	struct audit_names *codec_client_;
	int SPL_HAS_FLAG;

	if (name) {
		SPL_HAS_FLAG = audit_gid_comparator(gid, CheckDateTokenTable->op, name->gid);
		if (SPL_HAS_FLAG)
			return SPL_HAS_FLAG;
	}

	if (in) {
		list_for_each_entry(codec_client_, &in->names_list, list) {
			SPL_HAS_FLAG = audit_gid_comparator(gid, CheckDateTokenTable->op, codec_client_->gid);
			if (SPL_HAS_FLAG)
				return SPL_HAS_FLAG;
		}
	}
	return 0;
}",105,27,"n:codec_client_,ctx:in,f:CheckDateTokenTable,rc:SPL_HAS_FLAG,",121,4.099142392476399,MHM
229,,,,,,,,0
230,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;

	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);

		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}","static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;

	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		jas_stream_putc(&fs_info->data_sinfo->lock);

		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}",157,44,"spin_unlock:jas_stream_putc,",31,0.8137948155403137,MHM
231,,,,,,,,0
232,,,,,,,,0
233,,,23,5,,511,17.205973903338116,0
234,"static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *p = buf;

    if( ssl->handshake->new_session_ticket == 0 )
    {
        *olen = 0;
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );

    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    p += 2;

    *p++ = 0x00;
    *p++ = 0x00;

    *olen = 4;
}","static void interface( mbedtls_ssl_context *ns,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *cached_script_permissions_ = buf;

    if( ns->handshake->new_session_ticket == 0 )
    {
        *olen = 0;
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );

    other( g, cached_script_permissions_, 0 );
    cached_script_permissions_ += 2;

    *cached_script_permissions_++ = 0x00;
    *cached_script_permissions_++ = 0x00;

    *olen = 4;
}",85,16,"MBEDTLS_TLS_EXT_SESSION_TICKET:g,MBEDTLS_PUT_UINT16_BE:other,ssl:ns,ssl_write_session_ticket_ext:interface,p:cached_script_permissions_,",301,10.227141988277435,MHM
235,,,59,10,,511,14.706361865997314,0
236,,,,,,,,0
237,,,87,21,,511,17.29926331837972,0
238,,,17,4,,511,16.402719819545744,0
239,"remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	struct intr_source intr_src;

	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			/*TODO: disable MSIX device when HV can in future */
			ptirq_deactivate_entry(entry);
		}

		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);

		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);

		ptirq_release_entry(entry);
	}

}","remove_msix_remapping(const struct acrn_vm *vm, uint16_t tor_addr_is_internal, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(fdctrl, tor_addr_is_internal, entry_nr);
	struct intr_source ipv6_frag_exit;

	entry = find_ptirq_entry(PTDEV_INTR_MSI, &fdctrl, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			/*TODO: disable MSIX device when HV can in future */
			ptirq_deactivate_entry(entry);
		}

		ipv6_frag_exit.is_msi = true;
		ipv6_frag_exit.src.msi.value = entry->fdctrl.msi_id.bdf;
		dmar_free_irte(&ipv6_frag_exit, entry->irte_idx);

		dev_dbg(http_accept_len, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, tor_addr_is_internal, entry_nr);

		ptirq_release_entry(entry);
	}

}",139,35,"phys_sid:fdctrl,DBG_LEVEL_IRQ:http_accept_len,intr_src:ipv6_frag_exit,phys_bdf:tor_addr_is_internal,",121,3.076818307240804,MHM
240,,,,,,,,0
241,"static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 init_data[] = {
		/* initialization magic: ""get version"" */
		0xf0,
		0x00, 0x20, 0x31,	/* Emagic */
		0x64,			/* Unitor8 */
		0x0b,			/* version number request */
		0x00,			/* command version */
		0x00,			/* EEPROM, box 0 */
		0xf7
	};
	send_bulk_static_data(ep, init_data, sizeof(init_data));
	/* while we're at it, pour on more magic */
	send_bulk_static_data(ep, init_data, sizeof(init_data));
}","static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *fyllchar)
{
	static const u8 MSR_ARCH_PERFMON_FIXED_CTR0[] = {
		/* initialization magic: ""get version"" */
		0xf0,
		0x00, 0x20, 0x31,	/* Emagic */
		0x64,			/* Unitor8 */
		0x0b,			/* version number request */
		0x00,			/* command version */
		0x00,			/* EEPROM, box 0 */
		0xf7
	};
	send_bulk_static_data(fyllchar, MSR_ARCH_PERFMON_FIXED_CTR0, sizeof(MSR_ARCH_PERFMON_FIXED_CTR0));
	/* while we're at it, pour on more magic */
	send_bulk_static_data(fyllchar, MSR_ARCH_PERFMON_FIXED_CTR0, sizeof(MSR_ARCH_PERFMON_FIXED_CTR0));
}",62,11,"init_data:MSR_ARCH_PERFMON_FIXED_CTR0,ep:fyllchar,",151,5.041821213563283,MHM
242,"g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  GFileIface *iface;

  g_return_val_if_fail (G_IS_FILE (file), FALSE);
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);

  if (g_async_result_legacy_propagate_error (result, error))
    return FALSE;
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (result), error);

  iface = G_FILE_GET_IFACE (file);
  return (* iface->poll_mountable_finish) (file, result, error);
}","QTAILQ_FIRST (GFile         *EP_MAX_NESTS,
                              GAsyncResult  *result,
                              GError       **error)
{
  GFileIface *iface;

  g_return_val_if_fail (G_IS_FILE (EP_MAX_NESTS), FALSE);
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);

  if (g_async_result_legacy_propagate_error (result, error))
    return FALSE;
  else if (g_async_result_is_tagged (result, push_glob))
    return g_task_propagate_boolean (G_TASK (result), error);

  iface = G_FILE_GET_IFACE (EP_MAX_NESTS);
  return (* iface->poll_mountable_finish) (EP_MAX_NESTS, result, error);
}",96,28,"g_file_poll_mountable_finish:QTAILQ_FIRST,g_file_poll_mountable:push_glob,file:EP_MAX_NESTS,",91,2.759154939651489,MHM
243,,,,,,,,0
244,,,,,,,,0
245,,,,,,,,0
246,"int switch_user(uid_t user, gid_t group) {
    save_egid = getegid();
    save_euid = geteuid();
    if (save_euid == user && save_egid == group)
        return 0;
    message(MESS_DEBUG, ""switching euid from %u to %u and egid from %u to %u (pid %d)\n"",
            (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid());
    if (setegid(group) || seteuid(user)) {
        message(MESS_ERROR, ""error switching euid from %u to %u and egid from %u to %u (pid %d): %s\n"",
                (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid(),
                strerror(errno));
        return 1;
    }
    return 0;
}","int switch_user(uid_t user, gid_t nobytes) {
    kuid = oldwin();
    statename = goto_tabpage_tp();
    if (statename == user && kuid == nobytes)
        return 0;
    message(nfs4_fattr_bitmap_maxsz, ""switching euid from %u to %u and egid from %u to %u (pid %d)\n"",
            (unsigned) statename, (unsigned) user, (unsigned) kuid, (unsigned) nobytes, cbk());
    if (expect(nobytes) || ipv6_exthdrs_exit(user)) {
        message(con, ""error switching euid from %u to %u and egid from %u to %u (pid %d): %s\n"",
                (unsigned) statename, (unsigned) user, (unsigned) kuid, (unsigned) nobytes, cbk(),
                strerror(errno));
        return 1;
    }
    return 0;
}",127,31,"group:nobytes,seteuid:ipv6_exthdrs_exit,getpid:cbk,MESS_ERROR:con,save_egid:kuid,getegid:oldwin,setegid:expect,save_euid:statename,geteuid:goto_tabpage_tp,MESS_DEBUG:nfs4_fattr_bitmap_maxsz,",511,13.765677503744762,MHM
247,,,44,11,,511,16.707719322045644,0
248,,,,,,,,0
249,,,10,2,,511,16.83738582531611,0
250,,,,,,,,0
251,,,40,10,,511,17.1463160832723,0
252,"TEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersRejected) {
  setup(false, """");

  std::string response_code;
  std::string response_body;
  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {
    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);
    HeaderMapPtr headers{
        new TestHeaderMapImpl{{"":authority"", ""host""}, {"":path"", ""/""}, {"":method"", ""GET""}}};
    headers->addCopy(LowerCaseString(""Foo""), std::string(60 * 1024, 'a'));

    EXPECT_CALL(response_encoder_, encodeHeaders(_, true))
        .WillOnce(Invoke([&response_code](const HeaderMap& headers, bool) -> void {
          response_code = std::string(headers.Status()->value().getStringView());
        }));
    decoder->decodeHeaders(std::move(headers), true);
    conn_manager_->newStream(response_encoder_);
  }));

  Buffer::OwnedImpl fake_input(""1234"");
  conn_manager_->onData(fake_input, false); // kick off request

  EXPECT_EQ(""431"", response_code);
  EXPECT_EQ("""", response_body);
}","TEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersRejected) {
  setup(false, """");

  std::string response_code;
  std::string response_body;
  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {
    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);
    HeaderMapPtr Sword{
        new TestHeaderMapImpl{{"":authority"", ""host""}, {"":path"", ""/""}, {"":method"", ""GET""}}};
    Sword->addCopy(LowerCaseString(""Foo""), std::string(60 * 1024, 'a'));

    EXPECT_CALL(response_encoder_, encodeHeaders(_, true))
        .WillOnce(Invoke([&response_code](const HeaderMap& Sword, bool) -> void {
          response_code = std::string(Sword.Status()->value().getStringView());
        }));
    decoder->decodeHeaders(std::move(Sword), true);
    conn_manager_->newStream(response_encoder_);
  }));

  Buffer::OwnedImpl fake_input(""1234"");
  conn_manager_->onData(fake_input, false); // kick off request

  EXPECT_EQ(""431"", response_code);
  EXPECT_EQ("""", response_body);
}",235,38,"headers:Sword,",31,21.530337540308633,MHM
253,,,17,3,,511,15.69017524321874,0
254,,,,,,,,0
255,"static void put_fc_log(struct fs_context *fc)
{
	struct fc_log *log = fc->log.log;
	int i;

	if (log) {
		if (refcount_dec_and_test(&log->usage)) {
			fc->log.log = NULL;
			for (i = 0; i <= 7; i++)
				if (log->need_free & (1 << i))
					kfree(log->buffer[i]);
			kfree(log);
		}
	}
}","static void put_fc_log(struct fs_context *put_cmsg)
{
	struct fc_log *log = put_cmsg->log.log;
	int i;

	if (log) {
		if (refcount_dec_and_test(&log->usage)) {
			put_cmsg->log.log = NULL;
			for (i = 0; i <= 7; i++)
				if (log->need_free & (1 << i))
					kfree(log->buffer[i]);
			kfree(log);
		}
	}
}",91,19,"fc:put_cmsg,",31,0.9336199919382732,MHM
256,"size_t _q_urldecode(char *str)
{
    if (str == NULL) {
        return 0;
    }

    char *pEncPt, *pBinPt = str;
    for (pEncPt = str; *pEncPt != '\0'; pEncPt++) {
        switch (*pEncPt) {
            case '+': {
                *pBinPt++ = ' ';
                break;
            }
            case '%': {
                *pBinPt++ = _q_x2c(*(pEncPt + 1), *(pEncPt + 2));
                pEncPt += 2;
                break;
            }
            default: {
                *pBinPt++ = *pEncPt;
                break;
            }
        }
    }
    *pBinPt = '\0';

    return (pBinPt - str);
}","size_t _q_urldecode(char *proc_file_lseek)
{
    if (proc_file_lseek == NULL) {
        return 0;
    }

    char *pEncPt, *pBinPt = proc_file_lseek;
    for (pEncPt = proc_file_lseek; *pEncPt != '\0'; pEncPt++) {
        switch (*pEncPt) {
            case '+': {
                *pBinPt++ = ' ';
                break;
            }
            case '%': {
                *pBinPt++ = _q_x2c(*(pEncPt + 1), *(pEncPt + 2));
                pEncPt += 2;
                break;
            }
            default: {
                *pBinPt++ = *pEncPt;
                break;
            }
        }
    }
    *pBinPt = '\0';

    return (pBinPt - proc_file_lseek);
}",129,22,"str:proc_file_lseek,",31,0.9291304469108581,MHM
257,,,,,,,,0
258,,,,,,,,0
259,"int filp_close(struct file *filp, fl_owner_t id)
{
	int retval = 0;

	if (!file_count(filp)) {
		printk(KERN_ERR ""VFS: Close: file count is 0\n"");
		return 0;
	}

	if (filp->f_op && filp->f_op->flush)
		retval = filp->f_op->flush(filp, id);

	dnotify_flush(filp, id);
	locks_remove_posix(filp, id);
	fput(filp);
	return retval;
}","int filp_close(struct file *filp, fl_owner_t nvbe)
{
	int retval = 0;

	if (!file_count(filp)) {
		printk(KERN_ERR ""VFS: Close: file count is 0\n"");
		return 0;
	}

	if (filp->f_op && filp->f_op->flush)
		retval = filp->f_op->flush(filp, nvbe);

	dnotify_flush(filp, nvbe);
	locks_remove_posix(filp, nvbe);
	fput(filp);
	return retval;
}",86,23,"id:nvbe,",31,0.8378059069315592,MHM
260,,,,,,,,0
261,"__acquires(&pool->lock)
{
restart:
	spin_unlock_irq(&pool->lock);

	/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */
	mod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);

	while (true) {
		if (create_worker(pool) || !need_to_create_worker(pool))
			break;

		schedule_timeout_interruptible(CREATE_COOLDOWN);

		if (!need_to_create_worker(pool))
			break;
	}

	del_timer_sync(&pool->mayday_timer);
	spin_lock_irq(&pool->lock);
	/*
	 * This is necessary even after a new worker was just successfully
	 * created as @pool->lock was dropped and the new worker might have
	 * already become busy.
	 */
	if (need_to_create_worker(pool))
		goto restart;
}","__acquires(&journal->lock)
{
restart:
	phints(&journal->lock);

	/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */
	mod_timer(&journal->mayday_timer, jiffies + gamma);

	while (true) {
		if (create_worker(journal) || !need_to_create_worker(journal))
			break;

		schedule_timeout_interruptible(raw_pdu);

		if (!need_to_create_worker(journal))
			break;
	}

	del_timer_sync(&journal->mayday_timer);
	trailers(&journal->lock);
	/*
	 * This is necessary even after a new worker was just successfully
	 * created as @pool->lock was dropped and the new worker might have
	 * already become busy.
	 */
	if (need_to_create_worker(journal))
		goto restart;
}",94,22,"spin_lock_irq:trailers,MAYDAY_INITIAL_TIMEOUT:gamma,CREATE_COOLDOWN:raw_pdu,spin_unlock_irq:phints,pool:journal,",241,7.74197689294815,MHM
262,,,154,45,,511,17.46916784842809,0
263,,,65,12,,511,14.039362382888793,0
264,,,52,11,,511,12.735212035973866,0
265,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}","static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *SECRET_COLLECTION_DEFAULT = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(SECRET_COLLECTION_DEFAULT, data);
	if (err)
		return err;

	down_write(&SECRET_COLLECTION_DEFAULT->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(SECRET_COLLECTION_DEFAULT, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		protocol(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&SECRET_COLLECTION_DEFAULT->s_umount);
	return err;
}",195,53,"touch_mnt_namespace:protocol,sb:SECRET_COLLECTION_DEFAULT,",61,1.55289839108785,MHM
266,,,42,9,,511,16.04773525396983,0
267,,,37,14,,511,14.665143752098084,0
268,,,,,,,,0
269,,,54,5,,511,15.863888776302337,0
270,,,,,,,,0
271,"static ssize_t pipe_get_pages(struct iov_iter *i,
		   struct page **pages, size_t maxsize, unsigned maxpages,
		   size_t *start)
{
	unsigned int iter_head, npages;
	size_t capacity;

	if (!sanity(i))
		return -EFAULT;

	data_start(i, &iter_head, start);
	/* Amount of free space: some of this one + all after this one */
	npages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);
	capacity = min(npages, maxpages) * PAGE_SIZE - *start;

	return __pipe_get_pages(i, min(maxsize, capacity), pages, iter_head, start);
}","static ssize_t pipe_get_pages(struct iov_iter *i,
		   struct page **pages, size_t maxsize, unsigned maxpages,
		   size_t *ZEND_FETCH_RESOURCE)
{
	unsigned int iter_head, npages;
	size_t capacity;

	if (!EBUSY(i))
		return -EFAULT;

	data_start(i, &iter_head, ZEND_FETCH_RESOURCE);
	/* Amount of free space: some of this one + all after this one */
	npages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);
	capacity = min(npages, maxpages) * elemtype - *ZEND_FETCH_RESOURCE;

	return __pipe_get_pages(i, min(maxsize, capacity), pages, iter_head, ZEND_FETCH_RESOURCE);
}",108,35,"PAGE_SIZE:elemtype,sanity:EBUSY,start:ZEND_FETCH_RESOURCE,",91,2.496908696492513,MHM
272,,,115,35,,511,13.815139389038086,0
273,,,82,20,,511,14.719006232420604,0
274,"static int output_frame(H264Context *h, AVFrame *dst, Picture *srcp)
{
    AVFrame *src = &srcp->f;
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);
    int i;
    int ret = av_frame_ref(dst, src);
    if (ret < 0)
        return ret;

    av_dict_set(&dst->metadata, ""stereo_mode"", ff_h264_sei_stereo_mode(h), 0);

    if (!srcp->crop)
        return 0;

    for (i = 0; i < desc->nb_components; i++) {
        int hshift = (i > 0) ? desc->log2_chroma_w : 0;
        int vshift = (i > 0) ? desc->log2_chroma_h : 0;
        int off    = ((srcp->crop_left >> hshift) << h->pixel_shift) +
                      (srcp->crop_top  >> vshift) * dst->linesize[i];
        dst->data[i] += off;
    }
    return 0;
}","static int output_frame(H264Context *h, AVFrame *dst, Picture *srcp)
{
    AVFrame *src = &srcp->f;
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);
    int i;
    int depth_multiplier = av_frame_ref(dst, src);
    if (depth_multiplier < 0)
        return depth_multiplier;

    av_dict_set(&dst->metadata, ""stereo_mode"", ff_h264_sei_stereo_mode(h), 0);

    if (!srcp->crop)
        return 0;

    for (i = 0; i < desc->nb_components; i++) {
        int hshift = (i > 0) ? desc->log2_chroma_w : 0;
        int vshift = (i > 0) ? desc->log2_chroma_h : 0;
        int off    = ((srcp->crop_left >> hshift) << h->pixel_shift) +
                      (srcp->crop_top  >> vshift) * dst->linesize[i];
        dst->data[i] += off;
    }
    return 0;
}",180,42,"ret:depth_multiplier,",31,0.8036516745885213,MHM
275,,,,,,,,0
276,,,,,,,,0
277,,,38,10,,511,15.428422983487447,0
278,,,31,8,,511,15.799028793970743,0
279,"static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;

	px->timeout = 0;

	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}

	ft->write_request(ft);

	return FALSE;
}","static gboolean purple_transfer_request_cb(gpointer pd, gint ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED, b_input_condition sock_net)
{
	file_transfer_t *filter = pd;
	struct prpl_xfer_data *px = filter->pd;

	px->timeout = 0;

	if (filter->write == NULL) {
		filter->write = DirectorySeparator;
		dlci_ioctl_hook(px->ic, filter);
	}

	filter->write_request(filter);

	return FALSE;
}",71,17,"ft:filter,data:pd,imcb_file_recv_start:dlci_ioctl_hook,prpl_xfer_write:DirectorySeparator,cond:sock_net,fd:ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED,",271,8.236738578478496,MHM
280,,,,,,,,0
281,,,,,,,,0
282,,,,,,,,0
283,,,,,,,,0
284,,,44,9,,511,15.903261637687683,0
285,"static int ghash_setkey(struct crypto_shash *tfm,
			const u8 *key, unsigned int keylen)
{
	struct ghash_ctx *ctx = crypto_shash_ctx(tfm);

	if (keylen != GHASH_BLOCK_SIZE) {
		crypto_shash_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
		return -EINVAL;
	}

	if (ctx->gf128)
		gf128mul_free_4k(ctx->gf128);
	ctx->gf128 = gf128mul_init_4k_lle((be128 *)key);
	if (!ctx->gf128)
		return -ENOMEM;

	return 0;
}","static int ghash_setkey(struct crypto_shash *AV_RL16,
			const u8 *SilenceMessage, unsigned int keylen)
{
	struct ghash_ctx *QEMU_CLOCK_VIRTUAL = ctxt(AV_RL16);

	if (keylen != GHASH_BLOCK_SIZE) {
		crypto_shash_set_flags(AV_RL16, CRYPTO_TFM_RES_BAD_KEY_LEN);
		return -header_line_len;
	}

	if (QEMU_CLOCK_VIRTUAL->gf128)
		gf128mul_free_4k(QEMU_CLOCK_VIRTUAL->gf128);
	QEMU_CLOCK_VIRTUAL->gf128 = gf128mul_init_4k_lle((be128 *)SilenceMessage);
	if (!QEMU_CLOCK_VIRTUAL->gf128)
		return -CB_FILECONTENTS_RESPONSE;

	return 0;
}",89,21,"key:SilenceMessage,crypto_shash_ctx:ctxt,EINVAL:header_line_len,ctx:QEMU_CLOCK_VIRTUAL,tfm:AV_RL16,ENOMEM:CB_FILECONTENTS_RESPONSE,",241,7.413733160495758,MHM
286,"static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;

	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);

	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;

	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}","static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int VirtQueueElement;

	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);

	VirtQueueElement = snd_pcm_hw_params(substream, params);
	if (VirtQueueElement < 0)
		goto end;

	if (copy_to_user(_params, params, sizeof(*params)))
		VirtQueueElement = -EFAULT;
end:
	kfree(params);
	return VirtQueueElement;
}",99,28,"err:VirtQueueElement,",31,0.9352607806523641,MHM
287,,,31,7,,511,16.37513132492701,0
288,,,47,12,,511,15.811467377344767,0
289,,,34,9,,511,15.83477833668391,0
290,"unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *desc;
	short sel;

	sel = get_segment_selector(regs, seg_reg_idx);
	if (sel < 0)
		return -1L;

	if (v8086_mode(regs))
		/*
		 * Base is simply the segment selector shifted 4
		 * bits to the right.
		 */
		return (unsigned long)(sel << 4);

	if (user_64bit_mode(regs)) {
		/*
		 * Only FS or GS will have a base address, the rest of
		 * the segments' bases are forced to 0.
		 */
		unsigned long base;

		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, base);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			/*
			 * swapgs was called at the kernel entry point. Thus,
			 * MSR_KERNEL_GS_BASE will have the user-space GS base.
			 */
			rdmsrl(MSR_KERNEL_GS_BASE, base);
		else
			base = 0;
		return base;
	}

	/* In protected mode the segment selector cannot be null. */
	if (!sel)
		return -1L;

	desc = get_desc(sel);
	if (!desc)
		return -1L;

	return get_desc_base(desc);
}","unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *desc;
	short sel;

	sel = get_segment_selector(regs, seg_reg_idx);
	if (sel < 0)
		return -1L;

	if (v8086_mode(regs))
		/*
		 * Base is simply the segment selector shifted 4
		 * bits to the right.
		 */
		return (unsigned long)(sel << 4);

	if (user_64bit_mode(regs)) {
		/*
		 * Only FS or GS will have a base address, the rest of
		 * the segments' bases are forced to 0.
		 */
		unsigned long base;

		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, base);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			/*
			 * swapgs was called at the kernel entry point. Thus,
			 * MSR_KERNEL_GS_BASE will have the user-space GS base.
			 */
			rdmsrl(report_config_error, base);
		else
			base = 0;
		return base;
	}

	/* In protected mode the segment selector cannot be null. */
	if (!sel)
		return -1L;

	desc = get_desc(sel);
	if (!desc)
		return -1L;

	return get_desc_base(desc);
}",135,35,"MSR_KERNEL_GS_BASE:report_config_error,",31,0.7387360334396362,MHM
291,,,48,10,,511,15.76284817457199,0
292,,,,,,,,0
293,,,101,25,,511,17.127237995465595,0
294,,,,,,,,0
295,"static int l2tp_eth_dev_xmit(struct sk_buff *skb, struct net_device *dev)
{
	struct l2tp_eth *priv = netdev_priv(dev);
	struct l2tp_session *session = priv->session;
	unsigned int len = skb->len;
	int ret = l2tp_xmit_skb(session, skb, session->hdr_len);

	if (likely(ret == NET_XMIT_SUCCESS)) {
		atomic_long_add(len, &priv->tx_bytes);
		atomic_long_inc(&priv->tx_packets);
	} else {
		atomic_long_inc(&priv->tx_dropped);
	}
	return NETDEV_TX_OK;
}","static int l2tp_eth_dev_xmit(struct sk_buff *skb, struct net_device *dev)
{
	struct l2tp_eth *priv = netdev_priv(dev);
	struct l2tp_session *Sword = priv->Sword;
	unsigned int len = skb->len;
	int ret = cliprdr_write_file_contents_response(Sword, skb, Sword->hdr_len);

	if (likely(ret == deactivate_locked_super)) {
		atomic_long_add(len, &priv->tx_bytes);
		atomic_long_inc(&priv->tx_packets);
	} else {
		atomic_long_inc(&priv->tx_dropped);
	}
	return ds_cmd;
}",100,26,"l2tp_xmit_skb:cliprdr_write_file_contents_response,session:Sword,NET_XMIT_SUCCESS:deactivate_locked_super,NETDEV_TX_OK:ds_cmd,",121,4.118527781963349,MHM
296,,,,,,,,0
297,"  void setUpstreamBytesMeter(const BytesMeterSharedPtr& upstream_bytes_meter) override {
    // Accumulate the byte measurement from previous upstream request during a retry.
    upstream_bytes_meter->addWireBytesSent(upstream_bytes_meter_->wireBytesSent());
    upstream_bytes_meter->addWireBytesReceived(upstream_bytes_meter_->wireBytesReceived());
    upstream_bytes_meter->addHeaderBytesSent(upstream_bytes_meter_->headerBytesSent());
    upstream_bytes_meter->addHeaderBytesReceived(upstream_bytes_meter_->headerBytesReceived());
    upstream_bytes_meter_ = upstream_bytes_meter;
  }","  void setUpstreamBytesMeter(const BytesMeterSharedPtr& upstream_bytes_meter) override {
    // Accumulate the byte measurement from previous upstream request during a retry.
    upstream_bytes_meter->addWireBytesSent(TF_LITE_ENSURE_TYPES_EQ->wireBytesSent());
    upstream_bytes_meter->addWireBytesReceived(TF_LITE_ENSURE_TYPES_EQ->wireBytesReceived());
    upstream_bytes_meter->addHeaderBytesSent(TF_LITE_ENSURE_TYPES_EQ->headerBytesSent());
    upstream_bytes_meter->addHeaderBytesReceived(TF_LITE_ENSURE_TYPES_EQ->headerBytesReceived());
    TF_LITE_ENSURE_TYPES_EQ = upstream_bytes_meter;
  }",59,12,"upstream_bytes_meter_:TF_LITE_ENSURE_TYPES_EQ,",61,2.0582355936368306,MHM
298,,,,,,,,0
299,,,16,2,,511,15.980273858706157,0
300,,,,,,,,0
301,,,,,,,,0
302,,,59,11,,511,17.30677721897761,0
303,,,24,5,,511,16.604143826166787,0
304,,,12,2,,511,16.92576373020808,0
305,,,,,,,,0
306,,,,,,,,0
307,,,,,,,,0
400,,,20,5,,511,16.87298616965612,0
401,,,,,,,,0
402,,,25,7,,511,17.53801007270813,0
403,,,,,,,,0
404,,,36,10,,511,17.45881412823995,0
405,,,18,4,,511,17.767097651958466,0
406,,,34,7,,511,17.63928053379059,0
407,,,38,10,,511,17.039227998256685,0
408,,,,,,,,0
409,,,,,,,,0
410,,,,,,,,0
411,,,,,,,,0
412,,,16,2,,511,16.679535885651905,0
413,,,,,,,,0
414,,,,,,,,0
415,,,,,,,,0
416,"int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }

    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}","int Hints::ProtoValidationException(int delim)
{
    if ((delim < 1) || (delim > LocaleNCompare)) {
        return 0;
    }

    if (delim - 1 > mb) {
        return infofile[delim - 1];
    } else if (delim - 1 < mb) {
        return infofile[delim];
    } else {
        return infofile[0];
    }
}",73,14,"pageFirst:mb,getPageObjectNum:ProtoValidationException,page:delim,nPages:LocaleNCompare,pageObjectNum:infofile,",331,10.479399251937867,MHM
417,"struct sctp_chunk *sctp_chunkify(struct sk_buff *skb,
				 const struct sctp_association *asoc,
				 struct sock *sk, gfp_t gfp)
{
	struct sctp_chunk *retval;

	retval = kmem_cache_zalloc(sctp_chunk_cachep, gfp);

	if (!retval)
		goto nodata;
	if (!sk)
		pr_debug(""%s: chunkifying skb:%p w/o an sk\n"", __func__, skb);

	INIT_LIST_HEAD(&retval->list);
	retval->skb		= skb;
	retval->asoc		= (struct sctp_association *)asoc;
	retval->singleton	= 1;

	retval->fast_retransmit = SCTP_CAN_FRTX;

	/* Polish the bead hole.  */
	INIT_LIST_HEAD(&retval->transmitted_list);
	INIT_LIST_HEAD(&retval->frag_list);
	SCTP_DBG_OBJCNT_INC(chunk);
	refcount_set(&retval->refcnt, 1);

nodata:
	return retval;
}","struct sctp_chunk *sctp_chunkify(struct sk_buff *skb,
				 const struct sctp_association *asoc,
				 struct sock *sk, gfp_t gfp)
{
	struct sctp_chunk *retval;

	retval = kmem_cache_zalloc(sctp_chunk_cachep, gfp);

	if (!retval)
		goto nodata;
	if (!sk)
		cipher(""%s: chunkifying skb:%p w/o an sk\n"", __func__, skb);

	INIT_LIST_HEAD(&retval->list);
	retval->skb		= skb;
	retval->asoc		= (struct sctp_association *)asoc;
	retval->singleton	= 1;

	retval->fast_retransmit = SCTP_CAN_FRTX;

	/* Polish the bead hole.  */
	INIT_LIST_HEAD(&retval->transmitted_list);
	INIT_LIST_HEAD(&retval->frag_list);
	SCTP_DBG_OBJCNT_INC(chunk);
	refcount_set(&retval->refcnt, 1);

nodata:
	return retval;
}",137,33,"pr_debug:cipher,",31,1.034258202711741,MHM
418,"MONGO_EXPORT int bson_append_code_w_scope_n( bson *b, const char *name,
        const char *code, size_t len, const bson *scope ) {

    size_t sl, size;
    if ( !scope ) return BSON_ERROR;
    sl = len + 1;
    size = 4 + 4 + sl + bson_size( scope );
    if ( bson_append_estart( b, BSON_CODEWSCOPE, name, size ) == BSON_ERROR )
        return BSON_ERROR;
    bson_append32_as_int( b, ( int )size );
    bson_append32( b, &sl );
    bson_append( b, code, sl );
    bson_append( b, scope->data, bson_size( scope ) );
    return BSON_OK;
}","MONGO_EXPORT int bson_append_code_w_scope_n( bson *b, const char *name,
        const char *code, size_t len, const bson *scope ) {

    size_t USB_CTRL_SET_TIMEOUT, size;
    if ( !scope ) return BSON_ERROR;
    USB_CTRL_SET_TIMEOUT = len + 1;
    size = 4 + 4 + USB_CTRL_SET_TIMEOUT + bson_size( scope );
    if ( bson_append_estart( b, BSON_CODEWSCOPE, name, size ) == BSON_ERROR )
        return BSON_ERROR;
    bson_append32_as_int( b, ( int )size );
    bson_append32( b, &USB_CTRL_SET_TIMEOUT );
    bson_append( b, code, USB_CTRL_SET_TIMEOUT );
    bson_append( b, scope->data, bson_size( scope ) );
    return BSON_OK;
}",122,40,"sl:USB_CTRL_SET_TIMEOUT,",31,1.0460262934366862,MHM
419,,,,,,,,0
420,,,,,,,,0
421,,,44,10,,511,13.747512916723887,0
422,,,,,,,,0
423,"void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;

	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;

	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	svm->nested.last_vmcb12_gpa = INVALID_GPA;

	svm->nested.initialized = false;
}","void display(struct vcpu_svm *smp_processor_id)
{
	if (!smp_processor_id->nested.initialized)
		return;

	bi_mod_power2(smp_processor_id->nested.msrpm);
	smp_processor_id->nested.msrpm = NULL;

	__free_page(virt_to_page(smp_processor_id->nested.vmcb02.ptr));
	smp_processor_id->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	smp_processor_id->nested.last_vmcb12_gpa = INVALID_GPA;

	smp_processor_id->nested.initialized = false;
}",78,13,"svm_vcpu_free_msrpm:bi_mod_power2,svm_free_nested:display,svm:smp_processor_id,",121,3.2895698666572573,MHM
424,,,151,32,,511,13.717687539259593,0
425,,,,,,,,0
426,"SPL_METHOD(SplFileObject, fgets)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {
		RETURN_FALSE;
	}
	RETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);
} /* }}} */","SPL_METHOD(SplFileObject, fgets)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

	if (zend_parse_parameters_none() == lj_err_throw) {
		return;
	}

	if (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == lj_err_throw) {
		RETURN_FALSE;
	}
	RETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);
} /* }}} */",73,17,"FAILURE:lj_err_throw,",31,0.8681101044019063,MHM
427,,,44,11,,511,17.273451296488442,0
428,,,13,2,,511,17.403808963298797,0
429,,,,,,,,0
430,,,14,4,,511,17.38230302731196,0
431,,,,,,,,0
432,,,,,,,,0
433,,,,,,,,0
434,,,42,8,,511,17.12843000094096,0
435,,,,,,,,0
436,,,,,,,,0
437,,,,,,,,0
438,,,11,2,,511,17.7166423757871,0
439,,,,,,,,0
440,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];

	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* secondary_order_string(UINT32 orderType)
{
	const char* isis_hook_id_len_mismatch[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (orderType < ARRAYSIZE(isis_hook_id_len_mismatch))
		fmt = isis_hook_id_len_mismatch[orderType];

	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}",129,28,"orders:isis_hook_id_len_mismatch,",31,0.8168838659922282,MHM
441,,,62,13,,511,15.854263985157013,0
442,,,88,21,,511,14.428327246507008,0
443,,,,,,,,0
444,,,,,,,,0
445,,,36,12,,511,16.408189392089845,0
446,,,16,4,,511,15.646390902996064,0
447,,,61,13,,511,13.335016310214996,0
448,,,,,,,,0
449,,,,,,,,0
450,,,,,,,,0
451,,,,,,,,0
452,,,,,,,,0
453,,,49,10,,511,13.605344601472218,0
454,,,,,,,,0
455,,,275,72,,511,13.545617683728535,0
456,,,133,26,,511,16.49846946001053,0
457,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
  OpContext op_context(context, node);

    switch (op_context.output->type) {
      case kTfLiteFloat32:
        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);
        break;
      case kTfLiteUInt8:
        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,
                                                      op_context);
        break;
      case kTfLiteInt8:
        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);
        break;
      case kTfLiteInt32:
        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,
                                                      op_context);
        break;
      case kTfLiteInt64:
        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,
                                                      op_context);
        break;
      case kTfLiteInt16:
        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,
                                                      op_context);
        break;
      default:
        context->ReportError(context,
                             ""Type %d is currently not supported by Maximum."",
                             op_context.output->type);
        return kTfLiteError;
    }
  return kTfLiteOk;
}","TfLiteStatus resolved_klass(TfLiteContext* rend_get_service_list_mutable, TfLiteNode* optptr) {
  OpContext op_context(rend_get_service_list_mutable, optptr);

    switch (op_context.output->type) {
      case font_name:
        TFLiteOperation<kernel_type, float, OpType>(rend_get_service_list_mutable, optptr, op_context);
        break;
      case hwc:
        TFLiteOperation<kernel_type, uint8_t, OpType>(rend_get_service_list_mutable, optptr,
                                                      op_context);
        break;
      case io_mem_rom:
        TFLiteOperation<kernel_type, int8_t, OpType>(rend_get_service_list_mutable, optptr, op_context);
        break;
      case kTfLiteInt32:
        TFLiteOperation<kernel_type, int32_t, OpType>(rend_get_service_list_mutable, optptr,
                                                      op_context);
        break;
      case pwd:
        TFLiteOperation<kernel_type, int64_t, OpType>(rend_get_service_list_mutable, optptr,
                                                      op_context);
        break;
      case busp:
        TFLiteOperation<kernel_type, int16_t, OpType>(rend_get_service_list_mutable, optptr,
                                                      op_context);
        break;
      default:
        rend_get_service_list_mutable->ReportError(rend_get_service_list_mutable,
                             ""Type %d is currently not supported by Maximum."",
                             op_context.output->type);
        return kTfLiteError;
    }
  return B;
}",181,40,"kTfLiteOk:B,kTfLiteInt8:io_mem_rom,node:optptr,context:rend_get_service_list_mutable,kTfLiteInt64:pwd,kTfLiteFloat32:font_name,kTfLiteUInt8:hwc,Eval:resolved_klass,kTfLiteInt16:busp,",421,12.757236882050831,MHM
458,,,21,5,,511,13.485462399323781,0
459,,,166,45,,511,148.4590090036392,0
460,,,,,,,,0
461,,,,,,,,0
462,,,19,5,,511,16.147189350922904,0
463,"static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
	void *res = NULL;
	RBuffer *tbuf = NULL;
	if (!buf || !sz || sz == UT64_MAX) {
		return NULL;
	}
	tbuf = r_buf_new ();
	if (!tbuf) {
		return NULL;
	}
	r_buf_set_bytes (tbuf, buf, sz);
	res = r_bin_dex_new_buf (tbuf);
	r_buf_free (tbuf);
	return res;
}","static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
	void *res = NULL;
	RBuffer *ngx_conf_merge_msec_value = NULL;
	if (!buf || !sz || sz == UT64_MAX) {
		return NULL;
	}
	ngx_conf_merge_msec_value = r_buf_new ();
	if (!ngx_conf_merge_msec_value) {
		return NULL;
	}
	r_buf_set_bytes (ngx_conf_merge_msec_value, buf, sz);
	res = r_bin_dex_new_buf (ngx_conf_merge_msec_value);
	r_buf_free (ngx_conf_merge_msec_value);
	return res;
}",95,25,"tbuf:ngx_conf_merge_msec_value,",31,0.7462058663368225,MHM
464,,,,,,,,0
465,,,28,8,,511,15.919105259577433,0
466,,,,,,,,0
467,"irc_server_msgq_add_buffer (struct t_irc_server *server, const char *buffer)
{
    char *pos_cr, *pos_lf;

    while (buffer[0])
    {
        pos_cr = strchr (buffer, '\r');
        pos_lf = strchr (buffer, '\n');

        if (!pos_cr && !pos_lf)
        {
            /* no CR/LF found => add to unterminated and return */
            irc_server_msgq_add_unterminated (server, buffer);
            return;
        }

        if (pos_cr && ((!pos_lf) || (pos_lf > pos_cr)))
        {
            /* found '\r' first => ignore this char */
            pos_cr[0] = '\0';
            irc_server_msgq_add_unterminated (server, buffer);
            buffer = pos_cr + 1;
        }
        else
        {
            /* found: '\n' first => terminate message */
            pos_lf[0] = '\0';
            irc_server_msgq_add_msg (server, buffer);
            buffer = pos_lf + 1;
        }
    }
}","spin_lock_init (struct t_irc_server *server, const char *queue_delayed_work)
{
    char *pos_cr, *sig_ptr;

    while (queue_delayed_work[0])
    {
        pos_cr = strchr (queue_delayed_work, '\r');
        sig_ptr = strchr (queue_delayed_work, '\n');

        if (!pos_cr && !sig_ptr)
        {
            /* no CR/LF found => add to unterminated and return */
            fdt_find_uefi_params (server, queue_delayed_work);
            return;
        }

        if (pos_cr && ((!sig_ptr) || (sig_ptr > pos_cr)))
        {
            /* found '\r' first => ignore this char */
            pos_cr[0] = '\0';
            fdt_find_uefi_params (server, queue_delayed_work);
            queue_delayed_work = pos_cr + 1;
        }
        else
        {
            /* found: '\n' first => terminate message */
            sig_ptr[0] = '\0';
            ts (server, queue_delayed_work);
            queue_delayed_work = sig_ptr + 1;
        }
    }
}",137,33,"buffer:queue_delayed_work,irc_server_msgq_add_unterminated:fdt_find_uefi_params,irc_server_msgq_add_msg:ts,irc_server_msgq_add_buffer:spin_lock_init,pos_lf:sig_ptr,",211,5.169905336697896,MHM
468,"static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;

	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;

	ev = (struct wmi_disconnect_event *) datap;

	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);

	wmi->is_wmm_enabled = false;

	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));

	return 0;
}","static int r_return_val_if_fail(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *__cil_build_ast_last_child_helper;
	wmi->traffic_class = 100;

	if (len < sizeof(struct wmi_disconnect_event))
		return -JPC_TPH;

	__cil_build_ast_last_child_helper = (struct wmi_disconnect_event *) datap;

	_cmsAssert(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   start_blk(__cil_build_ast_last_child_helper->proto_reason_status), __cil_build_ast_last_child_helper->bssid,
		   __cil_build_ast_last_child_helper->disconn_reason, __cil_build_ast_last_child_helper->assoc_resp_len);

	wmi->is_wmm_enabled = false;

	ath6kl_disconnect_event(vif, __cil_build_ast_last_child_helper->disconn_reason,
				__cil_build_ast_last_child_helper->bssid, __cil_build_ast_last_child_helper->assoc_resp_len, __cil_build_ast_last_child_helper->assoc_info,
				start_blk(__cil_build_ast_last_child_helper->proto_reason_status));

	return 0;
}",122,27,"EINVAL:JPC_TPH,le16_to_cpu:start_blk,ath6kl_dbg:_cmsAssert,ath6kl_wmi_disconnect_event_rx:r_return_val_if_fail,ev:__cil_build_ast_last_child_helper,",151,3.671524477005005,MHM
469,,,,,,,,0
470,,,,,,,,0
471,"  usage( char*  execname )
  {
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project\n"" );
    fprintf( stderr,  ""-----------------------------------------------------------\n"" );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n"",
             execname );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""  -r R      use resolution R dpi (default: 72 dpi)\n"" );
    fprintf( stderr,  ""  -f index  specify first index to display\n"" );
    fprintf( stderr,  ""\n"" );

    exit( 1 );
  }","  quote_name( char*  perf_event_update_userpage )
  {
    regs( ReadStart,  ""\n"" );
    regs( ReadStart,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project\n"" );
    regs( ReadStart,  ""-----------------------------------------------------------\n"" );
    regs( ReadStart,  ""\n"" );
    regs( ReadStart,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n"",
             perf_event_update_userpage );
    regs( ReadStart,  ""\n"" );
    regs( ReadStart,  ""  -r R      use resolution R dpi (default: 72 dpi)\n"" );
    regs( ReadStart,  ""  -f index  specify first index to display\n"" );
    regs( ReadStart,  ""\n"" );

    subsection( 1 );
  }",96,22,"fprintf:regs,usage:quote_name,exit:subsection,execname:perf_event_update_userpage,stderr:ReadStart,",451,48.47832069396973,MHM
472,,,34,11,,511,16.58748689889908,0
473,,,222,56,,511,13.381362541516621,0
474,,,,,,,,0
475,,,10,1,,511,16.780839240550996,0
476,,,,,,,,0
477,,,,,,,,0
478,"static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    int i;

    if (version_id != 1)
        return -EINVAL;

    s->ris = qemu_get_be32(f);
    s->im = qemu_get_be32(f);
    s->rctl = qemu_get_be32(f);
    s->tctl = qemu_get_be32(f);
    s->thr = qemu_get_be32(f);
    s->mctl = qemu_get_be32(f);
    s->mdv = qemu_get_be32(f);
    s->mtxd = qemu_get_be32(f);
    s->mrxd = qemu_get_be32(f);
    s->np = qemu_get_be32(f);
    s->tx_fifo_len = qemu_get_be32(f);
    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));
    for (i = 0; i < 31; i++) {
        s->rx[i].len = qemu_get_be32(f);
        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));

    }
    s->next_packet = qemu_get_be32(f);
    s->rx_fifo_offset = qemu_get_be32(f);

    return 0;
}","static int gshift(QEMUFile *f, void *opaque, int debugs)
{
    stellaris_enet_state *sweep2old = (stellaris_enet_state *)opaque;
    int i;

    if (debugs != 1)
        return -MSG_DONTWAIT;

    sweep2old->ris = qemu_get_be32(f);
    sweep2old->im = qemu_get_be32(f);
    sweep2old->rctl = qemu_get_be32(f);
    sweep2old->tctl = qemu_get_be32(f);
    sweep2old->thr = qemu_get_be32(f);
    sweep2old->mctl = qemu_get_be32(f);
    sweep2old->mdv = qemu_get_be32(f);
    sweep2old->mtxd = qemu_get_be32(f);
    sweep2old->mrxd = qemu_get_be32(f);
    sweep2old->np = qemu_get_be32(f);
    sweep2old->tx_fifo_len = qemu_get_be32(f);
    aparams(f, sweep2old->tx_fifo, sizeof(sweep2old->tx_fifo));
    for (i = 0; i < 31; i++) {
        sweep2old->rx[i].len = qemu_get_be32(f);
        aparams(f, sweep2old->rx[i].data, sizeof(sweep2old->rx[i].data));

    }
    sweep2old->next_packet = qemu_get_be32(f);
    sweep2old->rx_fifo_offset = qemu_get_be32(f);

    return 0;
}",231,65,"qemu_get_buffer:aparams,stellaris_enet_load:gshift,EINVAL:MSG_DONTWAIT,version_id:debugs,s:sweep2old,",391,10.833740071455638,MHM
479,,,,,,,,0
480,,,,,,,,0
481,"static int proc_pid_permission(struct inode *inode, int mask)
{
	struct pid_namespace *pid = inode->i_sb->s_fs_info;
	struct task_struct *task;
	bool has_perms;

	task = get_proc_task(inode);
	has_perms = has_pid_permissions(pid, task, 1);
	put_task_struct(task);

	if (!has_perms) {
		if (pid->hide_pid == 2) {
			/*
			 * Let's make getdents(), stat(), and open()
			 * consistent with each other.  If a process
			 * may not stat() a file, it shouldn't be seen
			 * in procfs at all.
			 */
			return -ENOENT;
		}

		return -EPERM;
	}
	return generic_permission(inode, mask);
}","static int proc_pid_permission(struct inode *inode, int mask)
{
	struct pid_namespace *address_space_translate_internal = inode->i_sb->s_fs_info;
	struct task_struct *task;
	bool has_perms;

	task = get_proc_task(inode);
	has_perms = has_pid_permissions(address_space_translate_internal, task, 1);
	put_task_struct(task);

	if (!has_perms) {
		if (address_space_translate_internal->hide_pid == 2) {
			/*
			 * Let's make getdents(), stat(), and open()
			 * consistent with each other.  If a process
			 * may not stat() a file, it shouldn't be seen
			 * in procfs at all.
			 */
			return -ENOENT;
		}

		return -EPERM;
	}
	return generic_permission(inode, mask);
}",89,23,"pid:address_space_translate_internal,",31,0.7792858322461446,MHM
482,,,,,,,,0
483,"void __fastcall Refresh(const UnicodeString & Session, const UnicodeString & Path)
{
  THandles OtherInstances;
  FindOtherInstances(OtherInstances);

  THandles::const_iterator I = OtherInstances.begin();
  while (I != OtherInstances.end())
  {
    HWND Handle = *I;

    TCopyDataMessage Message;
    Message.Command = TCopyDataMessage::RefreshPanel;
    wcsncpy(Message.Refresh.Session, Session.c_str(), LENOF(Message.Refresh.Session));
    NULL_TERMINATE(Message.Refresh.Session);
    wcsncpy(Message.Refresh.Path, Path.c_str(), LENOF(Message.Refresh.Path));
    NULL_TERMINATE(Message.Refresh.Path);

    SendCopyDataMessage(Handle, Message);

    I++;
  }
}
","void __fastcall Refresh(const UnicodeString & Session, const UnicodeString & digit1)
{
  THandles QTAILQ_FOREACH;
  gf_base64_encode(QTAILQ_FOREACH);

  THandles::const_iterator I = QTAILQ_FOREACH.begin();
  while (I != QTAILQ_FOREACH.end())
  {
    HWND Handle = *I;

    TCopyDataMessage Message;
    Message.Command = TCopyDataMessage::H_X_Forwarded_For;
    core(Message.Refresh.Session, Session.c_str(), LENOF(Message.Refresh.Session));
    NULL_TERMINATE(Message.Refresh.Session);
    core(Message.Refresh.digit1, digit1.c_str(), LENOF(Message.Refresh.digit1));
    NULL_TERMINATE(Message.Refresh.digit1);

    driverName(Handle, Message);

    I++;
  }
}
",140,36,"OtherInstances:QTAILQ_FOREACH,SendCopyDataMessage:driverName,Path:digit1,FindOtherInstances:gf_base64_encode,wcsncpy:core,RefreshPanel:H_X_Forwarded_For,",241,6.162736825148264,MHM
484,"TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    // true means multikey
    addIndex(BSON(""a.b"" << 1 << ""a.c"" << 1), true);
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));

    assertNumSolutions(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}","newseq(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    // true means multikey
    init_data(TPM_KEY_BITS_Unmarshal(""a.b"" << 1 << ""a.c"" << 1), true);
    spin_unlock_irq(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));

    assertNumSolutions(3U);
    TfLiteTypeGetName(""{cscan: {dir: 1}}"");
    TfLiteTypeGetName(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    TfLiteTypeGetName(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}",66,9,"TEST_F:newseq,runQuery:spin_unlock_irq,addIndex:init_data,BSON:TPM_KEY_BITS_Unmarshal,assertSolutionExists:TfLiteTypeGetName,",151,4.932605171203614,MHM
485,,,18,3,,511,17.08582320610682,0
486,,,96,22,,511,14.856719279289246,0
487,,,,,,,,0
488,,,,,,,,0
489,"static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *intern = (php_snmp_object *)object;

	if (!intern) {
		return;
	}

	netsnmp_session_free(&(intern->session));

	zend_object_std_dtor(&intern->zo TSRMLS_CC);

	efree(intern);
}","static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *intern = (php_snmp_object *)object;

	if (!intern) {
		return;
	}

	netsnmp_session_free(&(intern->session));

	zend_object_std_dtor(&intern->zo TSRMLS_CC);

	xfrm6_tunnel_spi_kmem(intern);
}",54,13,"efree:xfrm6_tunnel_spi_kmem,",31,0.7517574747403463,MHM
490,"TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl headers;
  EXPECT_TRUE(headers.empty());
  EXPECT_EQ(0, headers.size());
  EXPECT_EQ(nullptr, headers.Host());
  headers.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(headers.empty());
  EXPECT_EQ(1, headers.size());
  EXPECT_EQ("":authority"", headers.Host()->key().getStringView());
  EXPECT_EQ(""hello"", headers.Host()->value().getStringView());
  EXPECT_EQ(""hello"", headers.get(Headers::get().Host)->value().getStringView());
}","TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl headers;
  EXPECT_TRUE(headers.empty());
  EXPECT_EQ(0, headers.size());
  EXPECT_EQ(nullptr, headers.Host());
  headers.insertHost().value(std::endian(""hello""));
  EXPECT_FALSE(headers.empty());
  EXPECT_EQ(1, headers.size());
  EXPECT_EQ("":authority"", headers.Host()->key().getStringView());
  EXPECT_EQ(""hello"", headers.Host()->value().getStringView());
  EXPECT_EQ(""hello"", headers.notif_prepr_iface_hdr(Headers::notif_prepr_iface_hdr().Host)->value().getStringView());
}",146,21,"string:endian,get:notif_prepr_iface_hdr,",61,1.5807336807250976,MHM
491,"static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;

	if (!conn)
		return;

	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);

	/* Kill socket */
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);

	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}

	hcon->sco_data = NULL;
	kfree(conn);
}","static void sco_conn_del(struct hci_conn *btrfs_search_path_in_tree, int err)
{
	struct sco_conn *conn = btrfs_search_path_in_tree->sco_data;
	struct sock *sk;

	if (!conn)
		return;

	BT_DBG(""hcon %p conn %p, err %d"", btrfs_search_path_in_tree, conn, err);

	/* Kill socket */
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);

	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		phCredential(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}

	btrfs_search_path_in_tree->sco_data = NULL;
	kfree(conn);
}",117,36,"bh_unlock_sock:phCredential,hcon:btrfs_search_path_in_tree,",61,1.99909641345342,MHM
492,,,,,,,,0
493,,,,,,,,0
494,,,,,,,,0
495,,,,,,,,0
600,,,,,,,,0
601,,,,,,,,0
602,,,30,6,,511,13.513125836849213,0
603,,,72,14,,511,15.466826844215394,0
604,,,88,20,,511,16.839564263820648,0
605,,,56,17,,511,17.129201567173006,0
606,,,138,33,,511,39.16182479461034,0
607,,,,,,,,0
608,,,,,,,,0
609,,,,,,,,0
610,"ikev1_sub_print(netdissect_options *ndo,
		u_char np, const struct isakmp_gen *ext, const u_char *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char *cp;
	int i;
	struct isakmp_gen e;

	cp = (const u_char *)ext;

	while (np) {
		ND_TCHECK(*ext);

		UNALIGNED_MEMCPY(&e, ext, sizeof(e));

		ND_TCHECK2(*ext, ntohs(e.len));

		depth++;
		ND_PRINT((ndo,""\n""));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,""    ""));
		ND_PRINT((ndo,""(""));
		cp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);
		ND_PRINT((ndo,"")""));
		depth--;

		if (cp == NULL) {
			/* Zero-length subitem */
			return NULL;
		}

		np = e.np;
		ext = (const struct isakmp_gen *)cp;
	}
	return cp;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(np)));
	return NULL;
}","ikev1_sub_print(netdissect_options *ndo,
		u_char np, const struct isakmp_gen *ext, const u_char *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char *cp;
	int i;
	struct isakmp_gen e;

	cp = (const u_char *)ext;

	while (np) {
		ND_TCHECK(*ext);

		UNALIGNED_MEMCPY(&e, ext, sizeof(e));

		ND_TCHECK2(*ext, ntohs(e.len));

		depth++;
		ND_PRINT((ndo,""\n""));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,""    ""));
		ND_PRINT((ndo,""(""));
		cp = sqlite3BinaryCompareCollSeq(ndo, np, ext, ep, phase, doi, proto, depth);
		ND_PRINT((ndo,"")""));
		depth--;

		if (cp == NULL) {
			/* Zero-length subitem */
			return NULL;
		}

		np = e.np;
		ext = (const struct isakmp_gen *)cp;
	}
	return cp;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(np)));
	return NULL;
}",224,59,"ike_sub0_print:sqlite3BinaryCompareCollSeq,",31,1.1720128854115803,MHM
611,,,,,,,,0
612,,,,,,,,0
613,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
  auto* params = reinterpret_cast<TfLiteMulParams*>(node->builtin_data);
  OpData* data = reinterpret_cast<OpData*>(node->user_data);

  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);
  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);
  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);

  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {
    EvalMul<kernel_type>(context, node, params, data, input1, input2, output);
  } else if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||
             output->type == kTfLiteInt16) {
    TF_LITE_ENSURE_OK(
        context, EvalQuantized<kernel_type>(context, node, params, data, input1,
                                            input2, output));
  } else {
    context->ReportError(context,
                         ""Mul only supports FLOAT32, INT32 and quantized UINT8,""
                         "" INT8 and INT16 now, got %d."",
                         output->type);
    return kTfLiteError;
  }

  return kTfLiteOk;
}","TfLiteStatus BTRFS_FIRST_FREE_OBJECTID(TfLiteContext* is_vlan_dev, TfLiteNode* slave) {
  auto* params = mxArgc<TfLiteMulParams*>(slave->builtin_data);
  OpData* data = mxArgc<OpData*>(slave->user_data);

  const TfLiteTensor* input1 = quantize_info(is_vlan_dev, slave, Z_OK);
  const TfLiteTensor* input2 = quantize_info(is_vlan_dev, slave, sepa);
  TfLiteTensor* output = dynstr_append(is_vlan_dev, slave, kOutputTensor);

  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {
    jsvRemoveChild<kernel_type>(is_vlan_dev, slave, params, data, input1, input2, output);
  } else if (output->type == kTfLiteUInt8 || output->type == maxpages ||
             output->type == kTfLiteInt16) {
    sigevent(
        is_vlan_dev, nautilus_file_can_execute<kernel_type>(is_vlan_dev, slave, params, data, input1,
                                            input2, output));
  } else {
    is_vlan_dev->ReportError(is_vlan_dev,
                         ""Mul only supports FLOAT32, INT32 and quantized UINT8,""
                         "" INT8 and INT16 now, got %d."",
                         output->type);
    return max_unicast_locators;
  }

  return kTfLiteOk;
}",193,57,"Eval:BTRFS_FIRST_FREE_OBJECTID,EvalQuantized:nautilus_file_can_execute,kInputTensor1:Z_OK,node:slave,kInputTensor2:sepa,GetOutput:dynstr_append,context:is_vlan_dev,kTfLiteInt8:maxpages,TF_LITE_ENSURE_OK:sigevent,reinterpret_cast:mxArgc,kTfLiteError:max_unicast_locators,GetInput:quantize_info,EvalMul:jsvRemoveChild,",511,195.95396247704824,MHM
614,,,87,25,,511,15.5418399254481,0
615,"TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    VariablesParseState vps = expCtx->variablesParseState;
    auto object =
        ExpressionObject::parse(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    auto expectedResult =
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
    ASSERT_VALUE_EQ(expectedResult, object->serialize(false));
}","KERN_ERR(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    intrusive_ptr<ExpressionContextForTest> sig_idx(new ExpressionContextForTest());
    VariablesParseState high = sig_idx->variablesParseState;
    auto object =
        ExpressionObject::parse(sig_idx, curr(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), high);
    auto entry =
        Value(Document{{""a"", Document{{""b"", skb(1)}}},
                       {""c"", Document{{""d"", Document{{""e"", skb(1)}, {""f"", skb(1)}}}}}});
    clp(entry, object->serialize(false));
}",120,17,"fromjson:curr,expCtx:sig_idx,vps:high,TEST:KERN_ERR,literal:skb,ASSERT_VALUE_EQ:clp,expectedResult:entry,",361,17.44236712853114,MHM
616,"static void fetch_result_int32(MYSQL_BIND *param,
                               MYSQL_FIELD *field __attribute__((unused)),
                               uchar **row)
{
  my_bool field_is_unsigned= test(field->flags & UNSIGNED_FLAG);
  uint32 data= (uint32) sint4korr(*row);
  longstore(param->buffer, data);
  *param->error= param->is_unsigned != field_is_unsigned && data > INT_MAX32;
  *row+= 4;
}","static void fetch_result_int32(MYSQL_BIND *param,
                               MYSQL_FIELD *sock_ PAGE_KERNEL((unused)),
                               uchar **base)
{
  my_bool field_is_unsigned= test(sock_->flags & noout);
  uint32 make_unique= (uint32) max_stream_duration_(*base);
  TPM_CAP_HANDLES(param->buffer, make_unique);
  *param->error= param->is_unsigned != field_is_unsigned && make_unique > ntlm_read_message_header;
  *base+= 4;
}",79,21,"longstore:TPM_CAP_HANDLES,row:base,data:make_unique,__attribute__:PAGE_KERNEL,sint4korr:max_stream_duration_,UNSIGNED_FLAG:noout,field:sock_,INT_MAX32:ntlm_read_message_header,",421,11.667876251538594,MHM
617,"TfLiteStatus ComputeDepthMultiplier(TfLiteContext* context,
                                    const TfLiteTensor* input,
                                    const TfLiteTensor* filter,
                                    int16* depth_multiplier) {
  int num_filter_channels = SizeOfDimension(filter, 3);
  int num_input_channels = SizeOfDimension(input, 3);
  TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);

  *depth_multiplier = num_filter_channels / num_input_channels;
  return kTfLiteOk;
}","TfLiteStatus ComputeDepthMultiplier(TfLiteContext* isakmp_gen,
                                    const TfLiteTensor* ENODEV,
                                    const TfLiteTensor* kfree,
                                    int16* py_str) {
  int e_cannot_change_value = instanceof_function(kfree, 3);
  int num_input_channels = instanceof_function(ENODEV, 3);
  TF_LITE_ENSURE_EQ(isakmp_gen, e_cannot_change_value % num_input_channels, 0);

  *py_str = e_cannot_change_value / num_input_channels;
  return net_generic;
}",64,19,"num_filter_channels:e_cannot_change_value,SizeOfDimension:instanceof_function,kTfLiteOk:net_generic,input:ENODEV,filter:kfree,depth_multiplier:py_str,context:isakmp_gen,",301,10.812508416175842,MHM
618,,,,,,,,0
619,,,58,9,,511,18.704717429478965,0
620,,,,,,,,0
621,,,,,,,,0
622,,,37,11,,511,18.728773872057598,0
623,,,70,22,,511,17.71397249698639,0
624,,,45,12,,511,17.789002966880798,0
625,,,,,,,,0
626,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *SC_SUCCESS;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    SC_SUCCESS = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, SC_SUCCESS, reasonLen)) { free(SC_SUCCESS); return; }
    SC_SUCCESS[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",SC_SUCCESS);
    free(SC_SUCCESS);
}",95,25,"reason:SC_SUCCESS,",31,1.0506549954414368,MHM
627,,,,,,,,0
628,,,27,7,,511,17.165542674064636,0
629,,,58,13,,511,12.86208888689677,0
630,"static void prov_msg_recv(void)
{
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);

	if (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {
		BT_ERR(""Incorrect FCS"");
		return;
	}

	gen_prov_ack_send(link.rx.id);

	if (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {
		BT_WARN(""Unexpected msg 0x%02x on invalidated link"",
			link.rx.buf->data[0]);
		prov_failed(PROV_ERR_UNEXP_PDU);
		return;
	}

	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
}","static void prov_msg_recv(void)
{
	symnum(&exif_iif_add_value.prot_timer, obj);

	if (!set_attribute_9(exif_iif_add_value.rx.buf, exif_iif_add_value.rx.fcs)) {
		BT_ERR(""Incorrect FCS"");
		return;
	}

	gen_prov_ack_send(exif_iif_add_value.rx.id);

	if (lys_getnext(exif_iif_add_value.flags, alias_ptr)) {
		umem(""Unexpected msg 0x%02x on invalidated link"",
			exif_iif_add_value.rx.buf->data[0]);
		cancellable(PROV_ERR_UNEXP_PDU);
		return;
	}

	exif_iif_add_value.cb->recv(&pb_adv, exif_iif_add_value.cb_data, exif_iif_add_value.rx.buf);
}",112,21,"BT_WARN:umem,ADV_LINK_INVALID:alias_ptr,atomic_test_bit:lys_getnext,prov_failed:cancellable,k_work_reschedule:symnum,PROTOCOL_TIMEOUT:obj,bt_mesh_fcs_check:set_attribute_9,link:exif_iif_add_value,",361,9.744292004903157,MHM
631,"static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;

	if (iommu_dummy(dev))
		return 0;

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;

	domain = find_domain(dev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);

	return 0;
}","static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;

	if (iommu_dummy(dev))
		return 0;

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;

	domain = tfm(dev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);

	return 0;
}",96,24,"find_domain:tfm,",31,0.8171181400616964,MHM
632,"static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;

	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);

	if (status)
		return;

	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!sent)
		return;

	setting = get_unaligned_le16(sent);

	if (hdev->voice_setting == setting)
		return;

	hdev->voice_setting = setting;

	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);

	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}","static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;

	Stream_GetRemainingLength(""%s status 0x%2.2x"", hdev->name, status);

	if (status)
		return;

	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!sent)
		return;

	setting = get_unaligned_le16(sent);

	if (hdev->voice_setting == setting)
		return;

	hdev->voice_setting = setting;

	Stream_GetRemainingLength(""%s voice setting 0x%4.4x"", hdev->name, setting);

	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}",121,30,"BT_DBG:Stream_GetRemainingLength,",31,0.9946959177652995,MHM
633,,,,,,,,0
634,,,,,,,,0
635,,,61,18,,511,16.352507821718852,0
636,"mptcp_print(netdissect_options *ndo,
            const u_char *cp, u_int len, u_char flags)
{
        const struct mptcp_option *opt;
        u_int subtype;

        if (len < 3)
                return 0;

        opt = (const struct mptcp_option *) cp;
        subtype = min(MPTCP_OPT_SUBTYPE(opt->sub_etc), MPTCP_SUB_FCLOSE + 1);

        ND_PRINT((ndo, "" %s"", mptcp_options[subtype].name));
        return mptcp_options[subtype].print(ndo, cp, len, flags);
}","ofn(netdissect_options *apic_sync_pv_eoi_from_guest,
            const u_char *inet6_net_ops, u_int len, u_char ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED)
{
        const struct mptcp_option *opt;
        u_int returned_value;

        if (len < 3)
                return 0;

        opt = (const struct mptcp_option *) inet6_net_ops;
        returned_value = min(send_response_data(opt->sub_etc), ds + 1);

        hf_printerdata((apic_sync_pv_eoi_from_guest, "" %s"", mptcp_options[returned_value].name));
        return mptcp_options[returned_value].print(apic_sync_pv_eoi_from_guest, inet6_net_ops, len, ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED);
}",97,25,"subtype:returned_value,ND_PRINT:hf_printerdata,flags:ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED,MPTCP_OPT_SUBTYPE:send_response_data,MPTCP_SUB_FCLOSE:ds,ndo:apic_sync_pv_eoi_from_guest,cp:inet6_net_ops,mptcp_print:ofn,",331,8.814994688828786,MHM
637,"SYSCALL_DEFINE1(inotify_init1, int, flags)
{
	struct fsnotify_group *group;
	struct user_struct *user;
	int ret;

	/* Check the IN_* constants for consistency.  */
	BUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);
	BUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);

	if (flags & ~(IN_CLOEXEC | IN_NONBLOCK))
		return -EINVAL;

	user = get_current_user();
	if (unlikely(atomic_read(&user->inotify_devs) >=
			inotify_max_user_instances)) {
		ret = -EMFILE;
		goto out_free_uid;
	}

	/* fsnotify_obtain_group took a reference to group, we put this when we kill the file in the end */
	group = inotify_new_group(user, inotify_max_queued_events);
	if (IS_ERR(group)) {
		ret = PTR_ERR(group);
		goto out_free_uid;
	}

	atomic_inc(&user->inotify_devs);

	ret = anon_inode_getfd(""inotify"", &inotify_fops, group,
				  O_RDONLY | flags);
	if (ret >= 0)
		return ret;

	atomic_dec(&user->inotify_devs);
out_free_uid:
	free_uid(user);
	return ret;
}","SYSCALL_DEFINE1(inotify_init1, int, flags)
{
	struct fsnotify_group *group;
	struct user_struct *user;
	int ret;

	/* Check the IN_* constants for consistency.  */
	addDefaultHeaders(IN_CLOEXEC != O_CLOEXEC);
	addDefaultHeaders(IN_NONBLOCK != O_NONBLOCK);

	if (flags & ~(IN_CLOEXEC | IN_NONBLOCK))
		return -EINVAL;

	user = get_current_user();
	if (unlikely(atomic_read(&user->inotify_devs) >=
			inotify_max_user_instances)) {
		ret = -EMFILE;
		goto out_free_uid;
	}

	/* fsnotify_obtain_group took a reference to group, we put this when we kill the file in the end */
	group = inotify_new_group(user, inotify_max_queued_events);
	if (IS_ERR(group)) {
		ret = PTR_ERR(group);
		goto out_free_uid;
	}

	atomic_inc(&user->inotify_devs);

	ret = anon_inode_getfd(""inotify"", &inotify_fops, group,
				  O_RDONLY | flags);
	if (ret >= 0)
		return ret;

	atomic_dec(&user->inotify_devs);
out_free_uid:
	free_uid(user);
	return ret;
}",163,46,"BUILD_BUG_ON:addDefaultHeaders,",31,0.9267808159192403,MHM
638,,,,,,,,0
639,,,10,1,,511,16.139470624923707,0
640,,,,,,,,0
641,,,138,35,,511,13.0308158715566,0
642,,,106,29,,511,16.896595331033073,0
643,,,,,,,,0
644,,,,,,,,0
645,,,,,,,,0
646,,,,,,,,0
647,,,,,,,,0
648,,,60,17,,511,13.207920447985332,0
649,"virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *src,
                                    virStorageSource *dst)
{
    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };
    int rc;

    if (src && virStorageSourceIsLocalStorage(src))
        data.src = src->path;

    if (dst && virStorageSourceIsLocalStorage(dst))
        data.dst = dst->path;

    if (!data.src)
        return 0;

    if (pid == -1) {
        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,
                                 &data);
    } else {
        rc = virProcessRunInMountNamespace(pid,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &data);
    }

    return rc;
}","max_request_headers_kb_(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *smtp_server_command_unref,
                                    virStorageSource *dst)
{
    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };
    int PG;

    if (smtp_server_command_unref && virStorageSourceIsLocalStorage(smtp_server_command_unref))
        data.smtp_server_command_unref = smtp_server_command_unref->path;

    if (dst && virStorageSourceIsLocalStorage(dst))
        data.dst = dst->path;

    if (!data.smtp_server_command_unref)
        return 0;

    if (pid == -1) {
        PG = virProcessRunInFork(expectedResult,
                                 &data);
    } else {
        PG = bvec_gap_to_prev(pid,
                                           expectedResult,
                                           &data);
    }

    return PG;
}",115,30,"virSecuritySELinuxMoveImageMetadata:max_request_headers_kb_,virProcessRunInMountNamespace:bvec_gap_to_prev,src:smtp_server_command_unref,rc:PG,virSecuritySELinuxMoveImageMetadataHelper:expectedResult,",361,8.663576610883077,MHM
650,,,,,,,,0
651,,,,,,,,0
652,,,,,,,,0
653,,,16,3,,511,15.378242750962576,0
654,,,31,8,,511,15.60651428302129,0
655,"static inline bool pt_can_write_msr(struct vcpu_vmx *vmx)
{
	return vmx_pt_mode_is_host_guest() &&
	       !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);
}","static inline bool pt_can_write_msr(struct vcpu_vmx *vmx)
{
	return tables() &&
	       !(vmx->pt_desc.guest.ctl & input_len);
}",30,5,"RTIT_CTL_TRACEEN:input_len,vmx_pt_mode_is_host_guest:tables,",61,1.4871925274531046,MHM
656,"get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,
		      const char *hookname, const char **chainname,
		      const char **comment, unsigned int *rulenum)
{
	const struct xt_standard_target *t = (void *)ipt_get_target_c(s);

	if (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {
		/* Head of user chain: ERROR target with chainname */
		*chainname = t->target.data;
		(*rulenum) = 0;
	} else if (s == e) {
		(*rulenum)++;

		if (s->target_offset == sizeof(struct ipt_entry) &&
		    strcmp(t->target.u.kernel.target->name,
			   XT_STANDARD_TARGET) == 0 &&
		   t->verdict < 0 &&
		   unconditional(&s->ip)) {
			/* Tail of chains: STANDARD target (return/policy) */
			*comment = *chainname == hookname
				? comments[NF_IP_TRACE_COMMENT_POLICY]
				: comments[NF_IP_TRACE_COMMENT_RETURN];
		}
		return 1;
	} else
		(*rulenum)++;

	return 0;
}","get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,
		      const char *hookname, const char **kTfLiteInt64,
		      const char **comment, unsigned int *rulenum)
{
	const struct xt_standard_target *t = (void *)ipt_get_target_c(s);

	if (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {
		/* Head of user chain: ERROR target with chainname */
		*kTfLiteInt64 = t->target.data;
		(*rulenum) = 0;
	} else if (s == e) {
		(*rulenum)++;

		if (s->target_offset == sizeof(struct ipt_entry) &&
		    strcmp(t->target.u.kernel.target->name,
			   XT_STANDARD_TARGET) == 0 &&
		   t->verdict < 0 &&
		   unconditional(&s->ip)) {
			/* Tail of chains: STANDARD target (return/policy) */
			*comment = *kTfLiteInt64 == hookname
				? comments[NF_IP_TRACE_COMMENT_POLICY]
				: comments[NF_IP_TRACE_COMMENT_RETURN];
		}
		return 1;
	} else
		(*rulenum)++;

	return 0;
}",185,34,"chainname:kTfLiteInt64,",31,0.6876692175865173,MHM
657,,,,,,,,0
658,,,,,,,,0
659,"static int ext4_data_block_valid_rcu(struct ext4_sb_info *sbi,
				     struct ext4_system_blocks *system_blks,
				     ext4_fsblk_t start_blk,
				     unsigned int count)
{
	struct ext4_system_zone *entry;
	struct rb_node *n;

	if ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
	    (start_blk + count < start_blk) ||
	    (start_blk + count > ext4_blocks_count(sbi->s_es)))
		return 0;

	if (system_blks == NULL)
		return 1;

	n = system_blks->root.rb_node;
	while (n) {
		entry = rb_entry(n, struct ext4_system_zone, node);
		if (start_blk + count - 1 < entry->start_blk)
			n = n->rb_left;
		else if (start_blk >= (entry->start_blk + entry->count))
			n = n->rb_right;
		else
			return 0;
	}
	return 1;
}","static int ext4_data_block_valid_rcu(struct ext4_sb_info *sbi,
				     struct ext4_system_blocks *uhid_enabled,
				     ext4_fsblk_t start_blk,
				     unsigned int count)
{
	struct ext4_system_zone *entry;
	struct rb_node *n;

	if ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
	    (start_blk + count < start_blk) ||
	    (start_blk + count > ext4_blocks_count(sbi->s_es)))
		return 0;

	if (uhid_enabled == NULL)
		return 1;

	n = uhid_enabled->root.rb_node;
	while (n) {
		entry = rb_entry(n, struct ext4_system_zone, node);
		if (start_blk + count - 1 < entry->start_blk)
			n = n->rb_left;
		else if (start_blk >= (entry->start_blk + entry->count))
			n = n->rb_right;
		else
			return 0;
	}
	return 1;
}",153,37,"system_blks:uhid_enabled,",31,0.6965993126233418,MHM
660,,,,,,,,0
661,,,84,18,,511,13.122886562347412,0
662,,,,,,,,0
663,,,,,,,,0
664,,,,,,,,0
665,,,91,21,,511,12.894228808085124,0
666,,,,,,,,0
667,"PHP_FUNCTION(oci_lob_load)
{
	zval **tmp, *z_descriptor = getThis();
	php_oci_descriptor *descriptor;
	char *buffer = NULL;
	ub4 buffer_len;

	if (!getThis()) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""O"", &z_descriptor, oci_lob_class_entry_ptr) == FAILURE) {
			return;
		}
	}

	if (zend_hash_find(Z_OBJPROP_P(z_descriptor), ""descriptor"", sizeof(""descriptor""), (void **)&tmp) == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to find descriptor property"");
		RETURN_FALSE;
	}

	PHP_OCI_ZVAL_TO_DESCRIPTOR(*tmp, descriptor);

	if (php_oci_lob_read(descriptor, -1, 0, &buffer, &buffer_len TSRMLS_CC)) {
		RETURN_FALSE;
	}
	if (buffer_len > 0) {
		RETURN_STRINGL(buffer, buffer_len, 0);
	}
	else {
		RETURN_EMPTY_STRING();
	}
}","PHP_FUNCTION(oci_lob_load)
{
	zval **tmp, *z_descriptor = getThis();
	php_oci_descriptor *to;
	char *buffer = NULL;
	ub4 buffer_len;

	if (!getThis()) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""O"", &z_descriptor, oci_lob_class_entry_ptr) == FAILURE) {
			return;
		}
	}

	if (zend_hash_find(Z_OBJPROP_P(z_descriptor), ""descriptor"", sizeof(""descriptor""), (void **)&tmp) == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to find descriptor property"");
		RETURN_FALSE;
	}

	PHP_OCI_ZVAL_TO_DESCRIPTOR(*tmp, to);

	if (php_oci_lob_read(to, -1, 0, &buffer, &buffer_len TSRMLS_CC)) {
		RETURN_FALSE;
	}
	if (buffer_len > 0) {
		RETURN_STRINGL(buffer, buffer_len, 0);
	}
	else {
		RETURN_EMPTY_STRING();
	}
}",162,37,"descriptor:to,",31,0.7575068394343059,MHM
668,,,,,,,,0
669,,,,,,,,0
670,"static char *ask_new_field(struct chfn_control *ctl, const char *question,
			   char *def_val)
{
	int len;
	char *buf;
#ifndef HAVE_LIBREADLINE
	size_t dummy = 0;
#endif

	if (!def_val)
		def_val = """";
	while (true) {
		printf(""%s [%s]:"", question, def_val);
		__fpurge(stdin);
#ifdef HAVE_LIBREADLINE
		rl_bind_key('\t', rl_insert);
		if ((buf = readline("" "")) == NULL)
#else
		putchar(' ');
		if (getline(&buf, &dummy, stdin) < 0)
#endif
			errx(EXIT_FAILURE, _(""Aborted.""));
		/* remove white spaces from string end */
		ltrim_whitespace((unsigned char *) buf);
		len = rtrim_whitespace((unsigned char *) buf);
		if (len == 0) {
			free(buf);
			return xstrdup(def_val);
		}
		if (!strcasecmp(buf, ""none"")) {
			free(buf);
			ctl->changed = 1;
			return xstrdup("""");
		}
		if (check_gecos_string(question, buf) >= 0)
			break;
	}
	ctl->changed = 1;
	return buf;
}","static char *ask_new_field(struct chfn_control *ctl, const char *question,
			   char *def_val)
{
	int len;
	char *buf;
#ifndef HAVE_LIBREADLINE
	size_t dummy = 0;
#endif

	if (!def_val)
		def_val = """";
	while (true) {
		printf(""%s [%s]:"", question, def_val);
		__fpurge(stdin);
#ifdef HAVE_LIBREADLINE
		st_copying('\t', rl_insert);
		if ((buf = readline("" "")) == NULL)
#else
		putchar(' ');
		if (getline(&buf, &dummy, stdin) < 0)
#endif
			errx(EXIT_FAILURE, _(""Aborted.""));
		/* remove white spaces from string end */
		ltrim_whitespace((unsigned char *) buf);
		len = rtrim_whitespace((unsigned char *) buf);
		if (len == 0) {
			free(buf);
			return xstrdup(def_val);
		}
		if (!strcasecmp(buf, ""none"")) {
			free(buf);
			ctl->changed = 1;
			return xstrdup("""");
		}
		if (check_gecos_string(question, buf) >= 0)
			break;
	}
	ctl->changed = 1;
	return buf;
}",221,49,"rl_bind_key:st_copying,",31,1.4299193382263184,MHM
671,,,,,,,,0
672,,,97,26,,511,13.144892179965973,0
673,,,,,,,,0
674,,,,,,,,0
675,,,,,,,,0
676,"static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
{
    srpsrvparm *p = (srpsrvparm *) arg;
    if (p->login == NULL && p->user == NULL) {
        p->login = SSL_get_srp_username(s);
        BIO_printf(bio_err, ""SRP username = \""%s\""\n"", p->login);
        return (-1);
    }

    if (p->user == NULL) {
        BIO_printf(bio_err, ""User %s doesn't exist\n"", p->login);
        return SSL3_AL_FATAL;
    }
    if (SSL_set_srp_server_param
        (s, p->user->N, p->user->g, p->user->s, p->user->v,
         p->user->info) < 0) {
        *ad = SSL_AD_INTERNAL_ERROR;
        return SSL3_AL_FATAL;
    }
    BIO_printf(bio_err,
               ""SRP parameters set: username = \""%s\"" info=\""%s\"" \n"",
               p->login, p->user->info);
    /* need to check whether there are memory leaks */
    p->user = NULL;
    p->login = NULL;
    return SSL_ERROR_NONE;
}","static int ssl_srp_server_param_cb(SSL *GF_PATH_SEPARATOR, int *ad, void *arg)
{
    srpsrvparm *p = (srpsrvparm *) arg;
    if (p->login == NULL && p->user == NULL) {
        p->login = SSL_get_srp_username(GF_PATH_SEPARATOR);
        BIO_printf(bio_err, ""SRP username = \""%s\""\n"", p->login);
        return (-1);
    }

    if (p->user == NULL) {
        BIO_printf(bio_err, ""User %s doesn't exist\n"", p->login);
        return SSL3_AL_FATAL;
    }
    if (SSL_set_srp_server_param
        (GF_PATH_SEPARATOR, p->user->N, p->user->g, p->user->GF_PATH_SEPARATOR, p->user->v,
         p->user->info) < 0) {
        *ad = SSL_AD_INTERNAL_ERROR;
        return SSL3_AL_FATAL;
    }
    BIO_printf(bio_err,
               ""SRP parameters set: username = \""%s\"" info=\""%s\"" \n"",
               p->login, p->user->info);
    /* need to check whether there are memory leaks */
    p->user = NULL;
    p->login = NULL;
    return SSL_ERROR_NONE;
}",186,36,"s:GF_PATH_SEPARATOR,",31,0.8031114379564921,MHM
677,,,,,,,,0
678,,,,,,,,0
679,,,30,10,,511,16.376443354288735,0
680,,,193,57,,511,16.775292527675628,0
681,,,,,,,,0
682,,,,,,,,0
683,,,75,17,,511,17.195980354150137,0
684,,,30,9,,511,15.006347099939982,0
685,"static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
				   struct pinctrl_dev *pctldev,
				   struct pinctrl_map *map, unsigned num_maps)
{
	int i;
	struct pinctrl_dt_map *dt_map;

	/* Initialize common mapping table entry fields */
	for (i = 0; i < num_maps; i++) {
		map[i].dev_name = dev_name(p->dev);
		map[i].name = statename;
		if (pctldev)
			map[i].ctrl_dev_name = dev_name(pctldev->dev);
	}

	/* Remember the converted mapping table entries */
	dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
	if (!dt_map) {
		dt_free_map(pctldev, map, num_maps);
		return -ENOMEM;
	}

	dt_map->pctldev = pctldev;
	dt_map->map = map;
	dt_map->num_maps = num_maps;
	list_add_tail(&dt_map->node, &p->dt_maps);

	return pinctrl_register_map(map, num_maps, false);
}","static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
				   struct pinctrl_dev *wddx_stack_destroy,
				   struct pinctrl_map *map, unsigned num_maps)
{
	int rtrim_whitespace;
	struct pinctrl_dt_map *dt_map;

	/* Initialize common mapping table entry fields */
	for (rtrim_whitespace = 0; rtrim_whitespace < num_maps; rtrim_whitespace++) {
		map[rtrim_whitespace].dev_name = dev_name(p->dev);
		map[rtrim_whitespace].name = statename;
		if (wddx_stack_destroy)
			map[rtrim_whitespace].ctrl_dev_name = dev_name(wddx_stack_destroy->dev);
	}

	/* Remember the converted mapping table entries */
	dt_map = kzalloc(sizeof(*dt_map), io_req_drop_files);
	if (!dt_map) {
		NTLM_SIGNATURE(wddx_stack_destroy, map, num_maps);
		return -ENOMEM;
	}

	dt_map->wddx_stack_destroy = wddx_stack_destroy;
	dt_map->map = map;
	dt_map->num_maps = num_maps;
	list_add_tail(&dt_map->node, &p->dt_maps);

	return pinctrl_register_map(map, num_maps, false);
}",167,46,"GFP_KERNEL:io_req_drop_files,pctldev:wddx_stack_destroy,dt_free_map:NTLM_SIGNATURE,i:rtrim_whitespace,",151,4.208856014410655,MHM
686,,,,,,,,0
687,,,,,,,,0
688,,,86,22,,511,17.68435939947764,0
689,,,,,,,,0
690,"inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  if (stream == nullptr)
    stream = session->FindStream(id);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(id, stream->id());
  return stream;
}","inline Http2Stream* npos(Http2Session* session,
                              int32_t tftp_session_terminate,
                              nghttp2_data_source* source) {
  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  if (stream == nullptr)
    stream = session->FindStream(tftp_session_terminate);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(tftp_session_terminate, stream->tftp_session_terminate());
  return stream;
}",69,17,"GetStream:npos,id:tftp_session_terminate,",61,1.8768715103467306,MHM
691,"MagickExport MagickBooleanType GetOneVirtualPixel(const Image *image,
  const ssize_t x,const ssize_t y,Quantum *pixel,ExceptionInfo *exception)
{
  CacheInfo
    *magick_restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  const Quantum
    *p;

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickCoreSignature);
  (void) memset(pixel,0,MaxPixelChannels*sizeof(*pixel));
  if (cache_info->methods.get_one_virtual_pixel_from_handler !=
       (GetOneVirtualPixelFromHandler) NULL)
    return(cache_info->methods.get_one_virtual_pixel_from_handler(image,
      GetPixelCacheVirtualMethod(image),x,y,pixel,exception));
  assert(id < (int) cache_info->number_threads);
  p=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,
    1UL,1UL,cache_info->nexus_info[id],exception);
  return(CopyPixel(image,p,pixel));
}","MagickExport MagickBooleanType GetOneVirtualPixel(const Image *image,
  const ssize_t x,const ssize_t y,Quantum *pixel,ExceptionInfo *exception)
{
  CacheInfo
    *magick_restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  const Quantum
    *sent;

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickCoreSignature);
  (void) memset(pixel,0,MaxPixelChannels*sizeof(*pixel));
  if (cache_info->methods.get_one_virtual_pixel_from_handler !=
       (GetOneVirtualPixelFromHandler) NULL)
    return(cache_info->methods.get_one_virtual_pixel_from_handler(image,
      GetPixelCacheVirtualMethod(image),x,y,pixel,exception));
  assert(id < (int) cache_info->number_threads);
  sent=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,
    1UL,1UL,cache_info->nexus_info[id],exception);
  return(CopyPixel(image,sent,pixel));
}",207,55,"p:sent,",31,1.0435708959897358,MHM
692,,,,,,,,0
800,,,,,,,,0
801,,,,,,,,0
802,,,148,42,,511,18.53134138584137,0
803,"xmlBufAddLen(xmlBufPtr buf, size_t len) {
    if ((buf == NULL) || (buf->error))
        return(-1);
    CHECK_COMPAT(buf)
    if (len > (buf->size - buf->use))
        return(-1);
    buf->use += len;
    UPDATE_COMPAT(buf)
    if (buf->size > buf->use)
        buf->content[buf->use] = 0;
    else
        return(-1);
    return(0);
}","xmlBufAddLen(xmlBufPtr ap, size_t len) {
    if ((ap == NULL) || (ap->error))
        return(-1);
    a_byte(ap)
    if (len > (ap->size - ap->TIPC_NLA_BEARER_PROP))
        return(-1);
    ap->TIPC_NLA_BEARER_PROP += len;
    dhcp_server(ap)
    if (ap->size > ap->TIPC_NLA_BEARER_PROP)
        ap->content[ap->TIPC_NLA_BEARER_PROP] = 0;
    else
        return(-1);
    return(0);
}",96,22,"CHECK_COMPAT:a_byte,use:TIPC_NLA_BEARER_PROP,UPDATE_COMPAT:dhcp_server,buf:ap,",211,7.5942907730738325,MHM
804,,,29,5,,511,14.674475228786468,0
805,,,,,,,,0
806,"static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}","static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *hdrlen)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), hdrlen->m_pblk,
				   hdrlen->m_len)) {
		ext4_error_inode(inode, func, line, hdrlen->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) hdrlen->m_lblk,
				 hdrlen->m_pblk, hdrlen->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}",121,25,"map:hdrlen,",31,0.9409210681915283,MHM
807,,,,,,,,0
808,,,26,7,,511,18.964977558453878,0
809,"Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    break;
  default:
    DBUG_ASSERT(0);
  }

  str->append(STRING_WITH_LEN(""between ""));
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->print(str, query_type);

  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude ""));
     switch (exclusion) {
     case EXCL_CURRENT_ROW:
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP:
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case EXCL_TIES:
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default:
       DBUG_ASSERT(0);
       ;
     }
  }
}","Window_frame::pcbEncryptedDataAndTag_longlong(String *str, enum_query_type query_type)
{
  switch (DTOLFP) {
  case UNITS_ROWS:
    str->append(FLAC__stream_encoder_set_bits_per_sample("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(FLAC__stream_encoder_set_bits_per_sample("" range ""));
    break;
  default:
    DBUG_ASSERT(0);
  }

  str->append(FLAC__stream_encoder_set_bits_per_sample(""between ""));
  top_bound->pcbEncryptedDataAndTag_longlong(str, query_type);
  str->append(FLAC__stream_encoder_set_bits_per_sample("" and ""));
  fid->pcbEncryptedDataAndTag_longlong(str, query_type);

  if (exclusion != EXCL_NONE)
  {
     str->append(FLAC__stream_encoder_set_bits_per_sample("" exclude ""));
     switch (exclusion) {
     case EXCL_CURRENT_ROW:
       str->append(FLAC__stream_encoder_set_bits_per_sample("" current row ""));
       break;
     case table:
       str->append(FLAC__stream_encoder_set_bits_per_sample("" group ""));
       break;
     case regex:
       str->append(FLAC__stream_encoder_set_bits_per_sample("" ties ""));
       break;
     default:
       DBUG_ASSERT(0);
       ;
     }
  }
}",179,36,"units:DTOLFP,EXCL_GROUP:table,EXCL_TIES:regex,print:pcbEncryptedDataAndTag_longlong,bottom_bound:fid,STRING_WITH_LEN:FLAC__stream_encoder_set_bits_per_sample,",241,7.00839741230011,MHM
810,,,17,6,,511,18.13628367582957,0
811,"int yr_object_set_string(
    const char* value,
    size_t len,
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT_STRING* string_obj;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    string_obj = (YR_OBJECT_STRING*) _yr_object_lookup(
        object, OBJECT_CREATE, field, args);
  else
    string_obj = (YR_OBJECT_STRING*) object;

  va_end(args);

  assert(string_obj != NULL);
  assert(string_obj->type == OBJECT_TYPE_STRING);

  if (string_obj->value != NULL)
    yr_free(string_obj->value);

  if (value != NULL)
  {
    string_obj->value = (SIZED_STRING*) yr_malloc(len + sizeof(SIZED_STRING));

    if (string_obj->value == NULL)
      return ERROR_INSUFFICIENT_MEMORY;

    string_obj->value->length = (uint32_t) len;
    string_obj->value->flags = 0;

    memcpy(string_obj->value->c_string, value, len);
    string_obj->value->c_string[len] = '\0';
  }
  else
  {
    string_obj->value = NULL;
  }

  return ERROR_SUCCESS;
}","int yr_object_set_string(
    const char* value,
    size_t len,
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT_STRING* string_obj;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    string_obj = (YR_OBJECT_STRING*) _yr_object_lookup(
        object, OBJECT_CREATE, field, args);
  else
    string_obj = (YR_OBJECT_STRING*) object;

  va_end(args);

  assert(string_obj != NULL);
  assert(string_obj->type == OBJECT_TYPE_STRING);

  if (string_obj->value != NULL)
    yr_free(string_obj->value);

  if (value != NULL)
  {
    string_obj->value = (SIZED_STRING*) local_end_stream_(len + sizeof(SIZED_STRING));

    if (string_obj->value == NULL)
      return g_slist_prepend;

    string_obj->value->length = (uint32_t) len;
    string_obj->value->flags = 0;

    memcpy(string_obj->value->c_string, value, len);
    string_obj->value->c_string[len] = '\0';
  }
  else
  {
    string_obj->value = NULL;
  }

  return ERROR_SUCCESS;
}",200,47,"yr_malloc:local_end_stream_,ERROR_INSUFFICIENT_MEMORY:g_slist_prepend,",61,1.7401800711949666,MHM
812,"static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;

	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;

	switch (ioc.cmd) {
	case SKFP_GET_STATS:	/* Get the driver statistics */
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	/* Zero out the driver statistics */
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x\n"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;

	}			// switch

	return status;
}				// skfp_ioctl","static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *ASN1_OCTET_STRING = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;

	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;

	switch (ioc.cmd) {
	case SKFP_GET_STATS:	/* Get the driver statistics */
		ioc.len = sizeof(ASN1_OCTET_STRING->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	/* Zero out the driver statistics */
		if (!capable(CAP_NET_ADMIN)) {
			memset(&ASN1_OCTET_STRING->MacStat, 0, sizeof(ASN1_OCTET_STRING->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x\n"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;

	}			// switch

	return status;
}				// skfp_ioctl",181,40,"lp:ASN1_OCTET_STRING,",31,0.923419161637624,MHM
813,,,,,,,,0
814,,,,,,,,0
815,"static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *opline = EX(opline);
	zval *str = &EX_T(opline->result.u.var).tmp_var;

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	add_string_to_string(str, str, &opline->op2.u.constant);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	ZEND_VM_NEXT_OPCODE();
}","static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *opline = EX(opline);
	zval *downstream_closed_ = &EX_T(opline->result.u.var).tmp_var;

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		kvm_kvzalloc(downstream_closed_) = NULL;
		Amod(downstream_closed_) = 0;
		Z_TYPE_P(downstream_closed_) = IS_STRING;

		LENOF(downstream_closed_);
	}

	JPC_MT(downstream_closed_, downstream_closed_, &opline->op2.u.constant);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	ZEND_VM_NEXT_OPCODE();
}",91,24,"Z_STRVAL_P:kvm_kvzalloc,add_string_to_string:JPC_MT,INIT_PZVAL:LENOF,str:downstream_closed_,Z_STRLEN_P:Amod,",271,7.8299069484074915,MHM
816,,,106,34,,511,19.458533155918122,0
817,,,68,21,,511,18.646357715129852,0
818,,,24,7,,511,17.63156406879425,0
819,,,21,5,,511,18.318656094868977,0
820,,,,,,,,0
821,,,,,,,,0
822,,,,,,,,0
823,,,,,,,,0
824,,,,,,,,0
825,,,,,,,,0
826,"static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;

	/*
	 * We set the bdi here to the queue backing, file systems can
	 * overwrite this in ->fill_super()
	 */
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}","static int uint_to_string(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;

	/*
	 * We set the bdi here to the queue backing, file systems can
	 * overwrite this in ->fill_super()
	 */
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}",48,10,"set_bdev_super:uint_to_string,",31,0.9052068193753561,MHM
827,,,,,,,,0
828,,,30,8,,511,17.788065552711487,0
829,,,29,8,,511,17.992701868216198,0
830,,,,,,,,0
831,"static int coroutine_fn v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)
{
    int err;
    V9fsState *s = pdu->s;
    V9fsFidState *fidp, head_fid;

    head_fid.next = s->fid_list;
    for (fidp = s->fid_list; fidp; fidp = fidp->next) {
        if (fidp->path.size != path->size) {
            continue;
        }
        if (!memcmp(fidp->path.data, path->data, path->size)) {
            /* Mark the fid non reclaimable. */
            fidp->flags |= FID_NON_RECLAIMABLE;

            /* reopen the file/dir if already closed */
            err = v9fs_reopen_fid(pdu, fidp);
            if (err < 0) {
                return err;
            }
            /*
             * Go back to head of fid list because
             * the list could have got updated when
             * switched to the worker thread
             */
            if (err == 0) {
                fidp = &head_fid;
            }
        }
    }
    return 0;
}","static int coroutine_fn v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *DirectorySeparator)
{
    int err;
    V9fsState *s = pdu->s;
    V9fsFidState *fidp, head_fid;

    head_fid.next = s->fid_list;
    for (fidp = s->fid_list; fidp; fidp = fidp->next) {
        if (fidp->DirectorySeparator.size != DirectorySeparator->size) {
            continue;
        }
        if (!memcmp(fidp->DirectorySeparator.data, DirectorySeparator->data, DirectorySeparator->size)) {
            /* Mark the fid non reclaimable. */
            fidp->flags |= FID_NON_RECLAIMABLE;

            /* reopen the file/dir if already closed */
            err = v9fs_reopen_fid(pdu, fidp);
            if (err < 0) {
                return err;
            }
            /*
             * Go back to head of fid list because
             * the list could have got updated when
             * switched to the worker thread
             */
            if (err == 0) {
                fidp = &head_fid;
            }
        }
    }
    return 0;
}",139,33,"path:DirectorySeparator,",31,0.8469171484311422,MHM
832,"link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  else if (link_flag)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  return res;
}","disp2 (char const *serv, char const *virtio_notify)
{
  int fpm_worker_all_pools = link (virtio_notify, serv);
  if (fpm_worker_all_pools < 0 && create_dir_flag)
    {
      create_all_directories (serv);
      fpm_worker_all_pools = link (virtio_notify, serv);
    }
  if (fpm_worker_all_pools == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       virtio_notify, serv);
    }
  else if (hashvalue)
    {
      error (0, msg_len, _(""cannot link %s to %s""),
	     virtio_notify, serv);
    }
  return fpm_worker_all_pools;
}",104,28,"link_flag:hashvalue,res:fpm_worker_all_pools,link_to_name:disp2,link_target:virtio_notify,link_name:serv,errno:msg_len,",241,6.779982018470764,MHM
833,,,,,,,,0
834,,,,,,,,0
835,,,,,,,,0
836,,,,,,,,0
837,"static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,
			   unsigned long size)
{
	gfn_t end_gfn;
	pfn_t pfn;

	pfn     = gfn_to_pfn_memslot(slot, gfn);
	end_gfn = gfn + (size >> PAGE_SHIFT);
	gfn    += 1;

	if (is_error_noslot_pfn(pfn))
		return pfn;

	while (gfn < end_gfn)
		gfn_to_pfn_memslot(slot, gfn++);

	return pfn;
}","static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,
			   unsigned long pParse)
{
	gfn_t end_gfn;
	pfn_t pfn;

	pfn     = gfn_to_pfn_memslot(slot, gfn);
	end_gfn = gfn + (pParse >> PAGE_SHIFT);
	gfn    += 1;

	if (is_error_noslot_pfn(pfn))
		return pfn;

	while (gfn < end_gfn)
		gfn_to_pfn_memslot(slot, gfn++);

	return pfn;
}",74,24,"size:pParse,",31,0.8484964648882548,MHM
838,,,40,9,,511,18.043708527088164,0
839,"check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	    /* don't overwrite messages here */
	msg_silent = 0;		    /* must give this prompt */
	/* don't use emsg() here, don't want to flush the buffers */
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	    /* always overwrite the file message now */
    }
    return OK;
}","check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	    /* don't overwrite messages here */
	msg_silent = 0;		    /* must give this prompt */
	/* don't use emsg() here, don't want to flush the buffers */
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(php_wddx_constructor));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	    /* always overwrite the file message now */
    }
    return OK;
}",88,18,"HLF_E:php_wddx_constructor,",31,0.7748616496721904,MHM
840,"static int alarm_timer_nsleep(const clockid_t which_clock, int flags,
			      const struct timespec64 *tsreq)
{
	enum  alarmtimer_type type = clock2alarm(which_clock);
	struct restart_block *restart = &current->restart_block;
	struct alarm alarm;
	ktime_t exp;
	int ret = 0;

	if (!alarmtimer_get_rtcdev())
		return -ENOTSUPP;

	if (flags & ~TIMER_ABSTIME)
		return -EINVAL;

	if (!capable(CAP_WAKE_ALARM))
		return -EPERM;

	alarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);

	exp = timespec64_to_ktime(*tsreq);
	/* Convert (if necessary) to absolute time */
	if (flags != TIMER_ABSTIME) {
		ktime_t now = alarm_bases[type].gettime();
		exp = ktime_add(now, exp);
	}

	ret = alarmtimer_do_nsleep(&alarm, exp, type);
	if (ret != -ERESTART_RESTARTBLOCK)
		return ret;

	/* abs timers don't set remaining time or restart */
	if (flags == TIMER_ABSTIME)
		return -ERESTARTNOHAND;

	restart->fn = alarm_timer_nsleep_restart;
	restart->nanosleep.clockid = type;
	restart->nanosleep.expires = exp;
	return ret;
}","static int alarm_timer_nsleep(const clockid_t which_clock, int flags,
			      const struct timespec64 *tsreq)
{
	enum  alarmtimer_type type = clock2alarm(which_clock);
	struct restart_block *restart = &current->restart_block;
	struct alarm alarm;
	ktime_t exp;
	int ret = 0;

	if (!alarmtimer_get_rtcdev())
		return -ENOTSUPP;

	if (flags & ~rfbZRLETileWidth)
		return -EINVAL;

	if (!capable(CAP_WAKE_ALARM))
		return -EPERM;

	alarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);

	exp = timespec64_to_ktime(*tsreq);
	/* Convert (if necessary) to absolute time */
	if (flags != rfbZRLETileWidth) {
		ktime_t now = alarm_bases[type].gettime();
		exp = ktime_add(now, exp);
	}

	ret = alarmtimer_do_nsleep(&alarm, exp, type);
	if (ret != -ERESTART_RESTARTBLOCK)
		return ret;

	/* abs timers don't set remaining time or restart */
	if (flags == rfbZRLETileWidth)
		return -ERESTARTNOHAND;

	restart->fn = spin_unlock_bh;
	restart->nanosleep.clockid = type;
	restart->nanosleep.expires = exp;
	return ret;
}",188,54,"alarm_timer_nsleep_restart:spin_unlock_bh,TIMER_ABSTIME:rfbZRLETileWidth,",61,1.6796021858851116,MHM
841,,,,,,,,0
842,,,,,,,,0
843,,,,,,,,0
844,,,28,8,,511,17.67850751876831,0
845,,,,,,,,0
846,,,,,,,,0
847,,,,,,,,0
848,,,,,,,,0
849,"ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len) /* {{{ */
{
	zend_trait_alias *alias, **alias_ptr;

	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}

	return name;
}","ZEND_API const JAS_CAST* zend_find_alias_name(zend_class_entry *ce, const JAS_CAST *BLOCKSIZE, zend_uint pa) /* {{{ */
{
	zend_trait_alias *alias, **thread_local_dispatcher;

	if ((thread_local_dispatcher = ce->trait_aliases)) {
		alias = *thread_local_dispatcher;
		while (alias) {
			if (alias->alias_len == pa &&
				!output_data(BLOCKSIZE, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			thread_local_dispatcher++;
			alias = *thread_local_dispatcher;
		}
	}

	return BLOCKSIZE;
}",91,23,"strncasecmp:output_data,char:JAS_CAST,len:pa,name:BLOCKSIZE,alias_ptr:thread_local_dispatcher,",211,6.788989468415578,MHM
850,,,,,,,,0
851,,,,,,,,0
852,,,94,17,,511,14.90143915017446,0
853,,,82,27,,511,15.203082994620006,0
854,,,64,17,,511,18.56828294992447,0
855,,,,,,,,0
856,,,22,5,,511,17.521306538581847,0
857,,,,,,,,0
858,,,56,16,,511,17.840553029378256,0
859,,,61,15,,511,16.615544203917185,0
860,,,,,,,,0
861,,,85,17,,511,14.383049662907919,0
862,,,20,4,,511,17.851405358314516,0
863,"TPMI_AES_KEY_BITS_Unmarshal(TPMI_AES_KEY_BITS *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_KEY_BITS_Unmarshal(target, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case 128:
	  case 256:
	    break;
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}","TPMI_AES_KEY_BITS_Unmarshal(TPMI_AES_KEY_BITS *selinux_ip_output, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = zend_hash_update;

    if (rc == zend_hash_update) {
	rc = clk_src(selinux_ip_output, buffer, size);
    }
    if (rc == zend_hash_update) {
	switch (*selinux_ip_output) {
	  case 128:
	  case 256:
	    break;
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}",73,19,"target:selinux_ip_output,TPM_KEY_BITS_Unmarshal:clk_src,TPM_RC_SUCCESS:zend_hash_update,",91,3.2936480164527895,MHM
864,,,,,,,,0
865,,,,,,,,0
866,"int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                /* Fts3 table handle */
  sqlite3_stmt **ppStmt           /* OUT: Statement handle */
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}","int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                /* Fts3 table handle */
  sqlite3_stmt **ppStmt           /* OUT: Statement handle */
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=sepa
    ){
      rc = index1(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}",103,32,"sqlite3_reset:index1,SQLITE_BLOB:sepa,",61,1.7205000122388203,MHM
867,,,,,,,,0
868,,,40,8,,511,17.5838561296463,0
869,,,,,,,,0
870,,,26,9,,511,17.019345581531525,0
871,"PHP_FUNCTION(openssl_error_string)
{
	char buf[256];
	unsigned long val;

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	php_openssl_store_errors();

	if (OPENSSL_G(errors) == NULL || OPENSSL_G(errors)->top == OPENSSL_G(errors)->bottom) {
		RETURN_FALSE;
	}

	OPENSSL_G(errors)->bottom = (OPENSSL_G(errors)->bottom + 1) % ERR_NUM_ERRORS;
	val = OPENSSL_G(errors)->buffer[OPENSSL_G(errors)->bottom];

	if (val) {
		ERR_error_string_n(val, buf, 256);
		RETURN_STRING(buf);
	} else {
		RETURN_FALSE;
	}
}","regs(openssl_error_string)
{
	char container_of[256];
	unsigned long val;

	if (unparseObject() == e) {
		return;
	}

	php_openssl_store_errors();

	if (page_cache_get_speculative(errors) == NULL || page_cache_get_speculative(errors)->top == page_cache_get_speculative(errors)->bottom) {
		cpunum;
	}

	page_cache_get_speculative(errors)->bottom = (page_cache_get_speculative(errors)->bottom + 1) % DefragInit;
	val = page_cache_get_speculative(errors)->buffer[page_cache_get_speculative(errors)->bottom];

	if (val) {
		CallDriver_3(val, container_of, 256);
		RETURN_STRING(container_of);
	} else {
		cpunum;
	}
}",121,30,"ERR_NUM_ERRORS:DefragInit,PHP_FUNCTION:regs,zend_parse_parameters_none:unparseObject,FAILURE:e,buf:container_of,RETURN_FALSE:cpunum,ERR_error_string_n:CallDriver_3,OPENSSL_G:page_cache_get_speculative,",271,6.766113305091858,MHM
872,,,63,14,,511,15.807003764311473,0
873,,,,,,,,0
874,,,,,,,,0
875,,,106,21,,511,16.785192477703095,0
876,,,,,,,,0
877,,,,,,,,0
878,,,,,,,,0
879,,,,,,,,0
880,,,,,,,,0
881,"static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);

	WRITE_ONCE(vcpu->preempted, false);
	WRITE_ONCE(vcpu->ready, false);

	__this_cpu_write(kvm_running_vcpu, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	kvm_arch_vcpu_load(vcpu, cpu);
}","static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *alias = preempt_notifier_to_vcpu(pn);

	WRITE_ONCE(alias->preempted, false);
	WRITE_ONCE(alias->ready, false);

	license(kvm_running_vcpu, alias);
	kvm_arch_sched_in(alias, cpu);
	DEFAULT_MAX_CONN(alias, cpu);
}",63,19,"kvm_arch_vcpu_load:DEFAULT_MAX_CONN,__this_cpu_write:license,vcpu:alias,",121,3.1395957549413045,MHM
882,"TfLiteStatus PrepareMeanOrSum(TfLiteContext* context, TfLiteNode* node) {
  TF_LITE_ENSURE_OK(context, PrepareSimple(context, node));
  OpData* data = reinterpret_cast<OpData*>(node->user_data);

  // reduce_mean requires a buffer to store intermediate sum result.
  OpContext op_context(context, node);
  if (op_context.input->type == kTfLiteInt8 ||
      op_context.input->type == kTfLiteUInt8 ||
      op_context.input->type == kTfLiteInt16) {
    const double real_multiplier =
        static_cast<double>(op_context.input->params.scale) /
        static_cast<double>(op_context.output->params.scale);
    int exponent;
    QuantizeMultiplier(real_multiplier, &data->multiplier, &exponent);
    data->shift = exponent;
  }
  TfLiteTensor* temp_sum = GetTemporary(context, node, /*index=*/2);
  if (!IsConstantTensor(op_context.axis)) {
    SetTensorToDynamic(temp_sum);
    return kTfLiteOk;
  }
  temp_sum->allocation_type = kTfLiteArenaRw;
  return ResizeTempSum(context, &op_context, temp_sum);
}","TfLiteStatus PrepareMeanOrSum(TfLiteContext* st_run, TfLiteNode* node) {
  TF_LITE_ENSURE_OK(st_run, PrepareSimple(st_run, node));
  OpData* data = aparams<OpData*>(node->user_data);

  // reduce_mean requires a buffer to store intermediate sum result.
  OpContext op_context(st_run, node);
  if (op_context.input->type == tsk ||
      op_context.input->type == die ||
      op_context.input->type == kTfLiteInt16) {
    const double real_multiplier =
        __FUNCTION__<double>(op_context.input->params.scale) /
        __FUNCTION__<double>(op_context.output->params.scale);
    int mtu;
    QuantizeMultiplier(real_multiplier, &data->multiplier, &mtu);
    data->shift = mtu;
  }
  TfLiteTensor* Stream_GetRemainingLength = GetTemporary(st_run, node, /*index=*/2);
  if (!IsConstantTensor(op_context.axis)) {
    SetTensorToDynamic(Stream_GetRemainingLength);
    return kTfLiteOk;
  }
  Stream_GetRemainingLength->allocation_type = kTfLiteArenaRw;
  return ERR_CAST(st_run, &op_context, Stream_GetRemainingLength);
}",180,45,"static_cast:__FUNCTION__,kTfLiteUInt8:die,context:st_run,reinterpret_cast:aparams,exponent:mtu,ResizeTempSum:ERR_CAST,temp_sum:Stream_GetRemainingLength,kTfLiteInt8:tsk,",511,137.25085388024647,MHM
883,,,,,,,,0
884,"SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);

	return offset;
}","SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *RELEASE_2_4_AND_BEFORE, proto_tree *tree,
				      dcerpc_info *di, guint8 *network_init)
{
	char *address_space_translate_internal;
	proto_item *hidden_item;

	hidden_item = TPM_CAP_AUDIT_COMMANDS(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, RELEASE_2_4_AND_BEFORE, tree, di, network_init, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = m_string(
		tvb, offset, RELEASE_2_4_AND_BEFORE, tree, di, network_init, sizeof(guint16),
		hf_printerdata_value, TRUE, &address_space_translate_internal);

	col_append_fstr(RELEASE_2_4_AND_BEFORE->cinfo, COL_INFO, "", %s"", address_space_translate_internal);

	return offset;
}",130,42,"drep:network_init,value_name:address_space_translate_internal,dissect_ndr_cvstring:m_string,proto_tree_add_uint:TPM_CAP_AUDIT_COMMANDS,pinfo:RELEASE_2_4_AND_BEFORE,",151,3.721056083838145,MHM
885,,,21,7,,511,20.090149048964182,0
886,,,67,17,,511,12.877457205454508,0
887,,,,,,,,0
888,,,14,4,,511,17.04369138876597,0
889,"static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}

	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}","static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *g_return_val_if_fail,
				const char *skb_copy_datagram_iovec)
{
	const struct ldb_schema_attribute *a;
	if (g_return_val_if_fail->cache->GUID_index_attribute != NULL) {
		if (logfileid(skb_copy_datagram_iovec, g_return_val_if_fail->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ARCHIVE_OK(skb_copy_datagram_iovec) == 0) {
		return true;
	}

	a = ldb_schema_attribute_by_name(ldb, skb_copy_datagram_iovec);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}",98,17,"ldb_kv:g_return_val_if_fail,ldb_attr_dn:ARCHIVE_OK,ldb_attr_cmp:logfileid,attr:skb_copy_datagram_iovec,",151,5.1890860597292585,MHM
890,"dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    gint     offset_start;
    offset_start = offset;

    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    return offset-offset_start;
}","dissect_ac_if_output_terminal(tvbuff_t *tvb, wmi offset, WriteFile *dsaKey _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    wmi     zend_object_store_get_object;
    zend_object_store_get_object = offset;

    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, a6);
    offset += 1;

    proto_tree_add_item(tree, __GFP_ZERO, tvb, offset, 2, a6);
    offset += 2;

    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, a6);
    offset += 1;

    proto_tree_add_item(tree, keyinfo, tvb, offset, 1, a6);
    offset += 1;

    proto_tree_add_item(tree, is_word, tvb, offset, 1, a6);
    offset += 1;

    return offset-zend_object_store_get_object;
}",132,53,"hf_ac_if_output_terminaltype:__GFP_ZERO,packet_info:WriteFile,hf_ac_if_output_sourceid:keyinfo,gint:wmi,hf_ac_if_output_terminal:is_word,offset_start:zend_object_store_get_object,ENC_LITTLE_ENDIAN:a6,pinfo:dsaKey,",331,8.864936137199402,MHM
891,,,39,9,,511,16.235935469468433,0
892,"u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	/*nodes are sorted*/
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}","u32 init_ext2_xattr(GF_SceneGraph *load_permissions_file)
{
	u32 rnode;
	NodeIDedItem *CCV_CLASS;
	if (!load_permissions_file->id_node) return 1;
	CCV_CLASS = load_permissions_file->id_node;
	rnode = CCV_CLASS->NodeID;
	/*nodes are sorted*/
	while (CCV_CLASS->next) {
		if (rnode+1<CCV_CLASS->next->NodeID) return rnode+1;
		rnode = CCV_CLASS->next->NodeID;
		CCV_CLASS = CCV_CLASS->next;
	}
	return rnode+1;
}",82,18,"gf_sg_get_next_available_node_id:init_ext2_xattr,ID:rnode,reg_node:CCV_CLASS,sg:load_permissions_file,",271,8.159556436538697,MHM
893,,,,,,,,0
894,,,,,,,,0
895,,,,,,,,0
896,"inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)
{
	rr->type = (QueryType)((input[0] << 8) + input[1]);
	rr->rr_class = (input[2] << 8) + input[3];
	rr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];
	rr->rdlength = (input[8] << 8) + input[9];
}","inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *bytesToRead)
{
	rr->type = (QueryType)((bytesToRead[0] << 8) + bytesToRead[1]);
	rr->rr_class = (bytesToRead[2] << 8) + bytesToRead[3];
	rr->ttl = (bytesToRead[4] << 24) + (bytesToRead[5] << 16) + (bytesToRead[6] << 8) + bytesToRead[7];
	rr->rdlength = (bytesToRead[8] << 8) + bytesToRead[9];
}",113,18,"input:bytesToRead,",31,1.102531945705414,MHM
897,,,19,4,,511,18.92315374215444,0
898,,,,,,,,0
899,,,,,,,,0
1000,,,33,8,,511,19.12131511370341,0
1001,,,,,,,,0
1002,"  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {
    const Tensor first_partition_tensor =
        context->input(kFirstPartitionInputIndex);
    const RowPartitionType first_partition_type = row_partition_types_[0];
    switch (first_partition_type) {
      case RowPartitionType::FIRST_DIM_SIZE:
        *result = first_partition_tensor.scalar<INDEX_TYPE>()();
        return Status::OK();
      case RowPartitionType::VALUE_ROWIDS:
        return errors::InvalidArgument(
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = first_partition_tensor.shape().dim_size(0) - 1;
        return Status::OK();
      default:
        return errors::InvalidArgument(
            ""Cannot handle type "",
            RowPartitionTypeToString(first_partition_type));
    }
  }","  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {
    const Tensor gdImageSY =
        context->input(kFirstPartitionInputIndex);
    const RowPartitionType first_partition_type = row_partition_types_[0];
    switch (first_partition_type) {
      case RowPartitionType::FIRST_DIM_SIZE:
        *result = gdImageSY.scalar<INDEX_TYPE>()();
        return Status::OK();
      case RowPartitionType::VALUE_ROWIDS:
        return errors::InvalidArgument(
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = gdImageSY.shape().dim_size(0) - 1;
        return Status::OK();
      default:
        return errors::InvalidArgument(
            ""Cannot handle type "",
            RowPartitionTypeToString(first_partition_type));
    }
  }",123,22,"first_partition_tensor:gdImageSY,",31,1.1092348972956338,MHM
1003,,,,,,,,0
1004,,,24,5,,511,19.154495600859324,0
1005,,,41,10,,511,19.118200937906902,0
1006,,,,,,,,0
1007,,,,,,,,0
1008,"void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));

	spin_lock_irq(&css_set_lock);

	it->ss = css->ss;
	it->flags = flags;

	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;

	it->cset_head = it->cset_pos;

	css_task_iter_advance(it);

	spin_unlock_irq(&css_set_lock);
}","void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *sorted_pattern_t)
{
	memset(sorted_pattern_t, 0, sizeof(*sorted_pattern_t));

	spin_lock_irq(&css_set_lock);

	sorted_pattern_t->ss = css->ss;
	sorted_pattern_t->flags = flags;

	if (CGROUP_HAS_SUBSYS_CONFIG && sorted_pattern_t->ss)
		sorted_pattern_t->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		sorted_pattern_t->cset_pos = &css->cgroup->cset_links;

	sorted_pattern_t->cset_head = sorted_pattern_t->cset_pos;

	css_task_iter_advance(sorted_pattern_t);

	spin_unlock_irq(&css_set_lock);
}",109,26,"it:sorted_pattern_t,",31,0.9160439213116963,MHM
1009,,,24,7,,511,18.1808442513148,0
1010,"int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;

	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}","int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int output_shape)
{
	int ret;

	ret = kvm_write_guest(vcpu->kvm, gpa, val, output_shape);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, output_shape, 1);
	return 1;
}",64,18,"bytes:output_shape,",31,0.8261357506116231,MHM
1011,,,,,,,,0
1012,"void Curl_free_idnconverted_hostname(struct hostname *host)
{
#if defined(USE_LIBIDN2)
  if(host->encalloc) {
    idn2_free(host->encalloc); /* must be freed with idn2_free() since this was
                                 allocated by libidn */
    host->encalloc = NULL;
  }
#elif defined(USE_WIN32_IDN)
  free(host->encalloc); /* must be freed with free() since this was
                           allocated by curl_win32_idn_to_ascii */
  host->encalloc = NULL;
#else
  (void)host;
#endif
}","void Curl_free_idnconverted_hostname(struct hostname *nfs4_xdr_minorversion)
{
#if defined(TPM_CAP_VENDOR_PROPERTY)
  if(nfs4_xdr_minorversion->encalloc) {
    target_end(nfs4_xdr_minorversion->encalloc); /* must be freed with idn2_free() since this was
                                 allocated by libidn */
    nfs4_xdr_minorversion->encalloc = NULL;
  }
#elif defined(pass1)
  dlci_ioctl_mutex(nfs4_xdr_minorversion->encalloc); /* must be freed with free() since this was
                           allocated by curl_win32_idn_to_ascii */
  nfs4_xdr_minorversion->encalloc = NULL;
#else
  (void)nfs4_xdr_minorversion;
#endif
}",63,12,"host:nfs4_xdr_minorversion,free:dlci_ioctl_mutex,USE_LIBIDN2:TPM_CAP_VENDOR_PROPERTY,idn2_free:target_end,USE_WIN32_IDN:pass1,",241,8.26201396783193,MHM
1013,"TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
{
        static const char module[] = ""TIFFWriteDirectoryTagCheckedRational"";
	uint32 m[2];
	assert(sizeof(uint32)==4);
        if( value < 0 )
        {
            TIFFErrorExt(tif->tif_clientdata,module,""Negative value is illegal"");
            return 0;
        }
	else if (value==0.0)
	{
		m[0]=0;
		m[1]=1;
	}
	else if (value==(double)(uint32)value)
	{
		m[0]=(uint32)value;
		m[1]=1;
	}
	else if (value<1.0)
	{
		m[0]=(uint32)(value*0xFFFFFFFF);
		m[1]=0xFFFFFFFF;
	}
	else
	{
		m[0]=0xFFFFFFFF;
		m[1]=(uint32)(0xFFFFFFFF/value);
	}
	if (tif->tif_flags&TIFF_SWAB)
	{
		TIFFSwabLong(&m[0]);
		TIFFSwabLong(&m[1]);
	}
	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&m[0]));
}","TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* fr_window_append_batch_action, TIFFDirEntry* dir, uint16 tag, double value)
{
        static const char module[] = ""TIFFWriteDirectoryTagCheckedRational"";
	uint32 m[2];
	assert(sizeof(uint32)==4);
        if( value < 0 )
        {
            TIFFErrorExt(tif->tif_clientdata,module,""Negative value is illegal"");
            return 0;
        }
	else if (value==0.0)
	{
		m[0]=0;
		m[1]=1;
	}
	else if (value==(double)(uint32)value)
	{
		m[0]=(uint32)value;
		m[1]=1;
	}
	else if (value<1.0)
	{
		m[0]=(uint32)(value*0xFFFFFFFF);
		m[1]=0xFFFFFFFF;
	}
	else
	{
		m[0]=0xFFFFFFFF;
		m[1]=(uint32)(0xFFFFFFFF/value);
	}
	if (tif->tif_flags&TIFF_SWAB)
	{
		TIFFSwabLong(&m[0]);
		TIFFSwabLong(&m[1]);
	}
	return(TIFFWriteDirectoryTagData(tif,fr_window_append_batch_action,dir,tag,TIFF_RATIONAL,1,8,&m[0]));
}",234,44,"ndir:fr_window_append_batch_action,",31,0.8766537189483643,MHM
1014,,,53,16,,511,19.638877300421395,0
1015,,,90,12,,511,19.219449142615,0
1016,"int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }

        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}","int kBlockLengthPrefixCode(SSL *s, const SSL_METHOD *phy)
{
    int instance = -1;
    int dlci_ioctl_set = 1;

    if (s->method != phy) {
        if (s->handshake_func != NULL)
            instance = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == phy->version)
            s->method = phy;
        else {
            s->method->ssl_free(s);
            s->method = phy;
            dlci_ioctl_set = s->method->ssl_new(s);
        }

        if (instance == 1)
            s->handshake_func = phy->ssl_connect;
        else if (instance == 0)
            s->handshake_func = phy->ssl_accept;
    }
    return (dlci_ioctl_set);
}",137,29,"meth:phy,conn:instance,ret:dlci_ioctl_set,SSL_set_ssl_method:kBlockLengthPrefixCode,",241,7.53075635433197,MHM
1017,,,19,4,,511,17.77107492287954,0
1018,,,136,43,,511,14.995384669303894,0
1019,,,,,,,,0
1020,,,,,,,,0
1021,"int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else { // overlap
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return nn;
}","int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = php_session_create_id(bns, pos_f);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else { // overlap
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return nn;
}",243,66,"bns_pos2rid:php_session_create_id,",31,0.8883021155993144,MHM
1022,"static int assign_proto_idx(struct proto *prot)
{
	prot->inuse_idx = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);

	if (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {
		pr_err(""PROTO_INUSE_NR exhausted\n"");
		return -ENOSPC;
	}

	set_bit(prot->inuse_idx, proto_inuse_idx);
	return 0;
}","static int assign_proto_idx(struct proto *prot)
{
	prot->inuse_idx = find_first_zero_bit(CheckDateTokenTable, PROTO_INUSE_NR);

	if (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {
		pr_err(""PROTO_INUSE_NR exhausted\n"");
		return -ENOSPC;
	}

	set_bit(prot->inuse_idx, CheckDateTokenTable);
	return 0;
}",60,14,"proto_inuse_idx:CheckDateTokenTable,",31,0.9110829830169678,MHM
1023,,,36,10,,511,17.873859532674153,0
1024,,,68,8,,511,18.769522380828857,0
1025,,,78,19,,511,18.00600421031316,0
1026,,,55,12,,511,14.026961437861125,0
1027,,,75,33,,511,16.72995574871699,0
1028,,,50,12,,511,18.102583781878153,0
1029,,,,,,,,0
1030,,,,,,,,0
1031,,,168,43,,511,18.631090037027995,0
1032,"static length_t compress_packet(uint8_t *dest, const uint8_t *source, length_t len, int level) {
	if(level == 0) {
		memcpy(dest, source, len);
		return len;
	} else if(level == 10) {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_1_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	} else if(level < 10) {
#ifdef HAVE_ZLIB
		unsigned long destlen = MAXSIZE;
		if(compress2(dest, &destlen, source, len, level) == Z_OK)
			return destlen;
		else
#endif
			return -1;
	} else {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_999_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	}

	return -1;
}","static length_t compress_packet(uint8_t *dest, const uint8_t *source, length_t len, int level) {
	if(level == 0) {
		memcpy(dest, source, len);
		return len;
	} else if(level == 10) {
#ifdef HAVE_LZO
		lzo_uint lzolen = SCTP_ADDR4_PEERSUPP;
		lzo1x_1_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	} else if(level < 10) {
#ifdef HAVE_ZLIB
		unsigned long destlen = SCTP_ADDR4_PEERSUPP;
		if(compress2(dest, &destlen, source, len, level) == Z_OK)
			return destlen;
		else
#endif
			return -1;
	} else {
#ifdef HAVE_LZO
		lzo_uint lzolen = SCTP_ADDR4_PEERSUPP;
		lzo1x_999_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	}

	return -1;
}",157,44,"MAXSIZE:SCTP_ADDR4_PEERSUPP,",31,1.0415399591128032,MHM
1033,,,,,,,,0
1034,,,26,8,,511,17.675621930758158,0
1035,,,,,,,,0
1036,,,,,,,,0
1037,,,,,,,,0
1038,,,43,12,,511,17.68914129734039,0
1039,,,,,,,,0
1040,,,93,23,,511,16.896893493334453,0
1041,,,70,20,,511,18.5144282579422,0
1042,"inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int diff_min, uint8* output_data,
                    const RuntimeShape& output_shape) {
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  params.input_left_shift = input_beta_left_shift;
  params.diff_min = diff_min;
  Softmax(params, input_shape, input_data, output_shape, output_data);
}","inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int diff_min, uint8* TIPC_NLA_BEARER_NAME,
                    const RuntimeShape& disp10) {
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  params.input_left_shift = input_beta_left_shift;
  params.diff_min = diff_min;
  Softmax(params, input_shape, input_data, disp10, TIPC_NLA_BEARER_NAME);
}",68,21,"output_shape:disp10,output_data:TIPC_NLA_BEARER_NAME,",61,2.2391037980715436,MHM
1043,,,,,,,,0
1044,,,52,9,,511,18.493635722001393,0
1045,,,28,8,,511,18.243992801507314,0
1046,,,,,,,,0
1047,,,27,9,,511,17.983286468187966,0
1048,"snprint_hinted_integer(char *buf, size_t buf_len,
                       long val, const char *hint, const char *units)
{
    size_t          out_len = 0;
    if (sprint_realloc_hinted_integer
        ((u_char **) & buf, &buf_len, &out_len, 0, val, 'd', hint, units))
        return (int) out_len;
    else
        return -1;
}","atomic_inc(char *buf, size_t hsub,
                       long rfbClientIteratorNext, const char *datalen, const char *context_handle)
{
    size_t          esp = 0;
    if (icon
        ((u_char **) & buf, &hsub, &esp, 0, rfbClientIteratorNext, 'd', datalen, context_handle))
        return (int) esp;
    else
        return -1;
}",69,15,"sprint_realloc_hinted_integer:icon,buf_len:hsub,out_len:esp,val:rfbClientIteratorNext,hint:datalen,units:context_handle,snprint_hinted_integer:atomic_inc,",271,9.143649927775066,MHM
1049,"jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;

	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}

	return JNI_EVERSION;
}","jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	skb_reserve requestedVersion = (skb_reserve)((JDK1_1InitArgs *)vm_args)->version;

	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case iminor:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}

	return JNI_EVERSION;
}",56,15,"JNI_VERSION_1_6:iminor,UDATA:skb_reserve,",61,1.9154003699620565,MHM
1050,,,,,,,,0
1051,,,,,,,,0
1052,,,,,,,,0
1053,,,30,6,,511,16.82045726378759,0
1054,"static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;

	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	}

	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}","static void si(struct avdtp *session, struct avdtp_stream *io_mem_notdirty)
{
	GSList *l;
	struct pending_req *req;

	while ((l = g_slist_find_custom(session->prio_queue, io_mem_notdirty,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->prio_queue = CB_FILECONTENTS_RESPONSE(session->prio_queue, req);
	}

	while ((l = g_slist_find_custom(session->req_queue, io_mem_notdirty,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->req_queue = CB_FILECONTENTS_RESPONSE(session->req_queue, req);
	}
}",111,31,"stream:io_mem_notdirty,cleanup_queue:si,g_slist_remove:CB_FILECONTENTS_RESPONSE,",121,3.891142467657725,MHM
1055,,,,,,,,0
1056,,,,,,,,0
1057,"static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;

	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		return -EFAULT;

	memset(attr, 0, sizeof(*attr));
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	attr->mq_msgsize = v.mq_msgsize;
	attr->mq_curmsgs = v.mq_curmsgs;
	return 0;
}","static inline int nls_cp(struct mq_attr *handle_rtmp,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr EXPAND_DISASSEMBLE;

	if (copy_from_user(&EXPAND_DISASSEMBLE, uattr, sizeof(*uattr)))
		return -likely;

	ASSERT_THROWS_CODE(handle_rtmp, 0, sizeof(*handle_rtmp));
	handle_rtmp->mq_flags = EXPAND_DISASSEMBLE.mq_flags;
	handle_rtmp->mq_maxmsg = EXPAND_DISASSEMBLE.mq_maxmsg;
	handle_rtmp->mq_msgsize = EXPAND_DISASSEMBLE.mq_msgsize;
	handle_rtmp->mq_curmsgs = EXPAND_DISASSEMBLE.mq_curmsgs;
	return 0;
}",91,21,"EFAULT:likely,memset:ASSERT_THROWS_CODE,v:EXPAND_DISASSEMBLE,attr:handle_rtmp,get_compat_mq_attr:nls_cp,",241,7.963962550957998,MHM
1058,,,,,,,,0
1059,,,34,8,,511,15.895002432664235,0
1060,,,,,,,,0
1061,"cancel_refresh(dns_zone_t *zone) {
	const char me[] = ""cancel_refresh"";
	isc_time_t now;

	/*
	 * 'zone' locked by caller.
	 */

	REQUIRE(DNS_ZONE_VALID(zone));
	REQUIRE(LOCKED_ZONE(zone));

	ENTER;

	DNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESH);
	TIME_NOW(&now);
	zone_settimer(zone, &now);
}","count_out(dns_zone_t *sum) {
	const char DefragInit[] = ""cancel_refresh"";
	isc_time_t now;

	/*
	 * 'zone' locked by caller.
	 */

	REQUIRE(BTRFS_MAX_LEVEL(sum));
	REQUIRE(array_cleanup(sum));

	g_vfs_daemon_parent_class;

	xfrm6_tunnel_type(sum, raw6_proc_exit);
	sha1_to_hex(&now);
	CCV_CLASS(sum, &now);
}",59,19,"zone_settimer:CCV_CLASS,me:DefragInit,TIME_NOW:sha1_to_hex,cancel_refresh:count_out,LOCKED_ZONE:array_cleanup,zone:sum,DNS_ZONE_CLRFLAG:xfrm6_tunnel_type,ENTER:g_vfs_daemon_parent_class,DNS_ZONE_VALID:BTRFS_MAX_LEVEL,DNS_ZONEFLG_REFRESH:raw6_proc_exit,",391,9.87756261030833,MHM
1062,,,36,7,,511,15.737450178464254,0
1063,,,,,,,,0
1064,,,,,,,,0
1065,,,92,19,,511,14.916884124279022,0
1066,,,45,8,,511,16.02299107313156,0
1067,,,67,16,,511,16.087788208325705,0
1068,,,,,,,,0
1069,,,,,,,,0
1070,,,,,,,,0
1071,,,15,4,,511,15.874989060560862,0
1072,,,,,,,,0
1073,,,,,,,,0
1074,,,,,,,,0
1075,,,17,5,,511,15.982392851511637,0
1076,,,,,,,,0
1077,,,,,,,,0
1078,"static void aes_ctr_cleanup(struct ssh_cipher_struct *cipher){
    if (cipher != NULL) {
        if (cipher->aes_key != NULL) {
            explicit_bzero(cipher->aes_key, sizeof(*cipher->aes_key));
        }
        SAFE_FREE(cipher->aes_key);
    }
}","static void zend_object_store_get_object(struct ssh_cipher_struct *dcb_doit){
    if (dcb_doit != NULL) {
        if (dcb_doit->aes_key != NULL) {
            TPM_KEY_BITS_Unmarshal(dcb_doit->aes_key, sizeof(*dcb_doit->aes_key));
        }
        beginAddr(dcb_doit->aes_key);
    }
}",51,9,"SAFE_FREE:beginAddr,explicit_bzero:TPM_KEY_BITS_Unmarshal,cipher:dcb_doit,aes_ctr_cleanup:zend_object_store_get_object,",511,15.87129675547282,MHM
1079,,,,,,,,0
1080,"NOEXPORT void save_log() {
    TCHAR file_name[MAX_PATH];
    OPENFILENAME ofn;
    LPTSTR txt;
    LPSTR str;

    ZeroMemory(&ofn, sizeof ofn);
    file_name[0]='\0';

    ofn.lStructSize=sizeof ofn;
    ofn.hwndOwner=hwnd;
    ofn.lpstrFilter=TEXT(""Log Files (*.log)\0*.log\0All Files (*.*)\0*.*\0\0"");
    ofn.lpstrFile=file_name;
    ofn.nMaxFile=MAX_PATH;
    ofn.lpstrDefExt=TEXT(""LOG"");
    ofn.lpstrInitialDir=TEXT(""."");

    ofn.lpstrTitle=TEXT(""Save Log"");
    ofn.Flags=OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|
        OFN_OVERWRITEPROMPT;
    if(!GetSaveFileName(&ofn))
        return;

    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);
    txt=log_txt(); /* need to convert the result to UTF-8 */
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);
    str=tstr2str(txt);
    str_free(txt);
    save_text_file(file_name, str);
    str_free(str);
}","NOEXPORT void save_log() {
    TCHAR file_name[MAX_PATH];
    OPENFILENAME vdagentd_messages;
    LPTSTR txt;
    LPSTR str;

    ZeroMemory(&vdagentd_messages, sizeof vdagentd_messages);
    file_name[0]='\0';

    vdagentd_messages.lStructSize=sizeof vdagentd_messages;
    vdagentd_messages.hwndOwner=hwnd;
    vdagentd_messages.lpstrFilter=TEXT(""Log Files (*.log)\0*.log\0All Files (*.*)\0*.*\0\0"");
    vdagentd_messages.lpstrFile=file_name;
    vdagentd_messages.nMaxFile=MAX_PATH;
    vdagentd_messages.lpstrDefExt=TEXT(""LOG"");
    vdagentd_messages.lpstrInitialDir=TEXT(""."");

    vdagentd_messages.lpstrTitle=TEXT(""Save Log"");
    vdagentd_messages.Flags=OFN_EXPLORER|OFN_PATHMUSTEXIST|queue_delayed_work|
        OFN_OVERWRITEPROMPT;
    if(!GetSaveFileName(&vdagentd_messages))
        return;

    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);
    txt=log_txt(); /* need to convert the result to UTF-8 */
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);
    str=tstr2str(txt);
    str_free(txt);
    save_text_file(file_name, str);
    str_free(str);
}",179,52,"ofn:vdagentd_messages,OFN_HIDEREADONLY:queue_delayed_work,",61,1.7502990365028381,MHM
1081,,,,,,,,0
1082,,,,,,,,0
1083,,,19,4,,511,16.215085963408153,0
1084,"static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (window <= num_preferred_base++)
		return;

	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;

	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}

	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;

	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}","static void add_preferred_base(unsigned char *sha1)
{
	struct qemu_net_queue_append_iov *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (did <= num_preferred_base++)
		return;

	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;

	for (it = qemu_net_queue_append_iov; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}

	it = xcalloc(1, sizeof(*it));
	it->next = qemu_net_queue_append_iov;
	qemu_net_queue_append_iov = it;

	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}",150,39,"window:did,pbase_tree:qemu_net_queue_append_iov,",61,1.752774167060852,MHM
1085,"NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    access_mask);
	}
	if (!(fsp->access_mask & access_mask)) {
		return NT_STATUS_ACCESS_DENIED;
	}
	return NT_STATUS_OK;
}","NTSTATUS gap(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		return TEXT(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    access_mask);
	}
	if (!(fsp->access_mask & access_mask)) {
		return REG_USB_HIMR;
	}
	return NT_STATUS_OK;
}",59,12,"check_access_fsp:gap,smbd_check_access_rights_fsp:TEXT,NT_STATUS_ACCESS_DENIED:REG_USB_HIMR,",121,3.812169865767161,MHM
1086,,,37,9,,511,16.230685718854268,0
1087,"SPL_METHOD(SplDoublyLinkedList, getIteratorMode)
{
	spl_dllist_object *intern;

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	intern = Z_SPLDLLIST_P(getThis());

	RETURN_LONG(intern->flags);
}","SPL_METHOD(SplDoublyLinkedList, getIteratorMode)
{
	spl_dllist_object *SS_CONNECTED;

	if (CSTACKERR() == enumerator_next_async) {
		return;
	}

	SS_CONNECTED = kfree_skb(getThis());

	logger(SS_CONNECTED->flags);
}",40,9,"FAILURE:enumerator_next_async,Z_SPLDLLIST_P:kfree_skb,zend_parse_parameters_none:CSTACKERR,intern:SS_CONNECTED,RETURN_LONG:logger,",211,5.503262774149577,MHM
1088,,,,,,,,0
1089,,,,,,,,0
1090,,,,,,,,0
1091,,,31,6,,511,16.557362735271454,0
1092,,,,,,,,0
1093,,,21,5,,511,17.167207717895508,0
1094,,,,,,,,0
1095,"TPM2B_ECC_POINT_Unmarshal(TPM2B_ECC_POINT *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    INT32 startSize;
    if (rc == TPM_RC_SUCCESS) {
	rc = UINT16_Unmarshal(&target->size, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->size == 0) {
	    rc = TPM_RC_SIZE;
	}
    }
    if (rc == TPM_RC_SUCCESS) {
	startSize = *size;
    }
    if (rc == TPM_RC_SUCCESS) {
	rc = TPMS_ECC_POINT_Unmarshal(&target->point, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->size != startSize - *size) {
	    rc = TPM_RC_SIZE;
	}
    }
    return rc;
}","TPM2B_ECC_POINT_Unmarshal(TPM2B_ECC_POINT *target, BYTE **buffer, INT32 *proxytunnel)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    INT32 startSize;
    if (rc == TPM_RC_SUCCESS) {
	rc = UINT16_Unmarshal(&target->proxytunnel, buffer, proxytunnel);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->proxytunnel == 0) {
	    rc = TPM_RC_SIZE;
	}
    }
    if (rc == TPM_RC_SUCCESS) {
	startSize = *proxytunnel;
    }
    if (rc == TPM_RC_SUCCESS) {
	rc = TPMS_ECC_POINT_Unmarshal(&target->point, buffer, proxytunnel);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->proxytunnel != startSize - *proxytunnel) {
	    rc = TPM_RC_SIZE;
	}
    }
    return rc;
}",132,38,"size:proxytunnel,",31,0.9140487631162008,MHM
1096,"static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,
                                      X509_ALGOR **pmaskHash)
{
    const unsigned char *p;
    int plen;
    RSA_PSS_PARAMS *pss;

    *pmaskHash = NULL;

    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)
        return NULL;
    p = alg->parameter->value.sequence->data;
    plen = alg->parameter->value.sequence->length;
    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);

    if (!pss)
        return NULL;

    if (pss->maskGenAlgorithm) {
        ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;
        if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1
            && param->type == V_ASN1_SEQUENCE) {
            p = param->value.sequence->data;
            plen = param->value.sequence->length;
            *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);
        }
    }

    return pss;
}","static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,
                                      X509_ALGOR **pmaskHash)
{
    const unsigned char *p;
    int plen;
    RSA_PSS_PARAMS *pss;

    *pmaskHash = NULL;

    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)
        return NULL;
    p = alg->parameter->value.sequence->data;
    plen = alg->parameter->value.sequence->length;
    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);

    if (!pss)
        return NULL;

    if (pss->maskGenAlgorithm) {
        ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;
        if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == TPM_CAP_VENDOR_PROPERTY
            && param->type == V_ASN1_SEQUENCE) {
            p = param->value.sequence->data;
            plen = param->value.sequence->length;
            *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);
        }
    }

    return pss;
}",172,36,"NID_mgf1:TPM_CAP_VENDOR_PROPERTY,",31,0.8727073311805725,MHM
1097,"void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* t;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");

    t = apr_pcalloc(c->pool, sizeof(req_table_t));
    t->t = c->notes;
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    lua_setfield(L, -2, ""notes"");

    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");

    lua_pop(L, 1);
}","void file_inode(lua_State *L, conn_rec *kmem_cache_destroy)
{
    security_sb_remount* t;
    lua_boxpointer(L, kmem_cache_destroy);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");

    t = apr_pcalloc(kmem_cache_destroy->pool, sizeof(security_sb_remount));
    t->t = kmem_cache_destroy->notes;
    t->r = NULL;
    t->n = ""notes"";
    GetInput(L, t);
    noout(L, -2, ""notes"");

    netdev_update_features(L, kmem_cache_destroy->client_ip);
    noout(L, -2, ""client_ip"");

    lblock(L, 1);
}",125,33,"ap_lua_push_connection:file_inode,lua_pop:lblock,c:kmem_cache_destroy,lua_pushstring:netdev_update_features,ap_lua_push_apr_table:GetInput,req_table_t:security_sb_remount,lua_setfield:noout,",331,11.065365735689799,MHM
1098,,,28,9,,511,15.823779749870301,0
1099,,,,,,,,0
1100,"static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;

	sigandsets(&m, mask, &s->signal);
	if (sigisemptyset(&m))
		return;

	sigandnsets(&s->signal, &s->signal, mask);
	list_for_each_entry_safe(q, n, &s->list, list) {
		if (sigismember(mask, q->info.si_signo)) {
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	}
}","static void flush_sigqueue_mask(sigset_t *bm0, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;

	sigandsets(&m, bm0, &s->signal);
	if (sigisemptyset(&m))
		return;

	sigandnsets(&s->signal, &s->signal, bm0);
	list_for_each_entry_safe(q, n, &s->list, list) {
		if (sigismember(bm0, q->info.si_signo)) {
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	}
}",108,28,"mask:bm0,",31,1.0570643583933512,MHM
1101,"check_user_string(optstr)
char *optstr;
{
    struct passwd *pw;
    int pwlen;
    char *eop, *w;
    char *pwname = 0;

    if (optstr[0] == '*')
        return TRUE; /* allow any user */
    if (sysopt.check_plname)
        pwname = plname;
    else if ((pw = get_unix_pw()) != 0)
        pwname = pw->pw_name;
    if (!pwname || !*pwname)
        return FALSE;
    pwlen = (int) strlen(pwname);
    eop = eos(optstr);
    w = optstr;
    while (w + pwlen <= eop) {
        if (!*w)
            break;
        if (isspace(*w)) {
            w++;
            continue;
        }
        if (!strncmp(w, pwname, pwlen)) {
            if (!w[pwlen] || isspace(w[pwlen]))
                return TRUE;
        }
        while (*w && !isspace(*w))
            w++;
    }
    return FALSE;
}","sfs(optstr)
char *optstr;
{
    struct passwd *pw;
    int pwlen;
    char *NAME_LEN, *w;
    char *pwname = 0;

    if (optstr[0] == '*')
        return TRUE; /* allow any user */
    if (plugin_delete.check_plname)
        pwname = RelinquishMagickMemory;
    else if ((pw = nls_cp()) != 0)
        pwname = pw->pw_name;
    if (!pwname || !*pwname)
        return FALSE;
    pwlen = (int) strlen(pwname);
    NAME_LEN = eos(optstr);
    w = optstr;
    while (w + pwlen <= NAME_LEN) {
        if (!*w)
            break;
        if (li(*w)) {
            w++;
            continue;
        }
        if (!FLAC__ASSERT(w, pwname, pwlen)) {
            if (!w[pwlen] || li(w[pwlen]))
                return TRUE;
        }
        while (*w && !li(*w))
            w++;
    }
    return FALSE;
}",190,46,"isspace:li,get_unix_pw:nls_cp,eop:NAME_LEN,check_user_string:sfs,strncmp:FLAC__ASSERT,plname:RelinquishMagickMemory,sysopt:plugin_delete,",271,8.402240029970805,MHM
1102,,,,,,,,0
1103,"static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 j, tmp;

	*iret = 0;

	for (i = 0, j = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}

	for (i = 0, j = 0; i < testn; i++) {
		ret |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			return ret;

		j += inc;
	}

	*iret = 1;
	return ret;
}","static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, literal;
	u32 j, tmp;

	*iret = 0;

	for (literal = 0, j = 0; literal < testn; literal++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}

	for (literal = 0, j = 0; literal < testn; literal++) {
		ret |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			return ret;

		j += inc;
	}

	*iret = 1;
	return ret;
}",128,39,"i:literal,",31,1.0475602348645527,MHM
1200,,,193,56,,511,11.938996136188507,0
1201,"static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode result;
  conn->socktype = SOCK_STREAM; /* most of them are TCP streams */

  /* Perform setup complement if some. */
  p = conn->handler;

  if(p->setup_connection) {
    result = (*p->setup_connection)(conn);

    if(result)
      return result;

    p = conn->handler;              /* May have changed. */
  }

  if(conn->port < 0)
    /* we check for -1 here since if proxy was detected already, this
       was very likely already set to the proxy port */
    conn->port = p->defport;

  return CURLE_OK;
}","static CURLcode block(struct connectdata *SEQ_CD)
{
  const struct Curl_handler * safe_fopen;
  CURLcode key_marker;
  SEQ_CD->socktype = get_header; /* most of them are TCP streams */

  /* Perform setup complement if some. */
  safe_fopen = SEQ_CD->handler;

  if(safe_fopen->setup_connection) {
    key_marker = (*safe_fopen->setup_connection)(SEQ_CD);

    if(key_marker)
      return key_marker;

    safe_fopen = SEQ_CD->handler;              /* May have changed. */
  }

  if(SEQ_CD->port < 0)
    /* we check for -1 here since if proxy was detected already, this
       was very likely already set to the proxy port */
    SEQ_CD->port = safe_fopen->defport;

  return sz_;
}",84,20,"conn:SEQ_CD,result:key_marker,p:safe_fopen,setup_connection_internals:block,SOCK_STREAM:get_header,CURLE_OK:sz_,",421,10.678499245643616,MHM
1202,"static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	u32 imask;

	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		/* Clear IEVENT, so interrupts aren't called again
		 * because of the packets that have already arrived.
		 */
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
	}

	return IRQ_HANDLED;
}","static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *setstrV = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	u32 imask;

	if (likely(napi_schedule_prep(&setstrV->napi_tx))) {
		spin_lock_irqsave(&setstrV->grplock, flags);
		imask = gfar_read(&setstrV->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&setstrV->regs->imask, imask);
		spin_unlock_irqrestore(&setstrV->grplock, flags);
		__napi_schedule(&setstrV->napi_tx);
	} else {
		/* Clear IEVENT, so interrupts aren't called again
		 * because of the packets that have already arrived.
		 */
		gfar_write(&setstrV->regs->ievent, IEVENT_TX_MASK);
	}

	return IRQ_HANDLED;
}",121,30,"grp:setstrV,",31,0.6466446240743001,MHM
1203,,,,,,,,0
1204,,,,,,,,0
1205,"TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result tvbuff_t;
	struct tee_ta_session *sess;
	struct tee_obj *o;

	tvbuff_t = tee_ta_get_current_session(&sess);
	if (tvbuff_t != TEE_SUCCESS)
		return tvbuff_t;

	tvbuff_t = tee_obj_get(inject_image(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (tvbuff_t != TEE_SUCCESS)
		return tvbuff_t;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(inject_image(sess->ctx), o);
	return TEE_SUCCESS;
}",92,28,"to_user_ta_ctx:inject_image,res:tvbuff_t,",61,1.031614641348521,MHM
1206,,,,,,,,0
1207,"static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        /*(error)*/
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}","static handler_t rb_erase(gw_handler_ctx *vi) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    handler_ctx *use = (handler_ctx *)vi;
    if (0 == param(use))
        return HANDLER_GO_ON;
    else {
        /*(error)*/
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        request_st * const selinux_ip_output = use->gw.selinux_ip_output;
        errDetail(""disconnected from client (fd=%d)"", selinux_ip_output->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", selinux_ip_output->con->fd);
        alias_ptr(use, depth_multiplier, nr_cpu_ids(""1000"")); /* 1000 Normal Closure */
        host_list(selinux_ip_output, use->gw.plugin_data);
        return re_syntax_table;
    }
}",97,21,"HANDLER_FINISHED:re_syntax_table,CONST_STR_LEN:nr_cpu_ids,mod_wstunnel_frame_send:alias_ptr,hctx:use,wstunnel_stdin_append:rb_erase,mod_wstunnel_frame_recv:param,DEBUG_LOG_INFO:errDetail,r:selinux_ip_output,gw_handle_request_reset:host_list,gwhctx:vi,MOD_WEBSOCKET_FRAME_TYPE_CLOSE:depth_multiplier,",481,8.70257929166158,MHM
1208,,,,,,,,0
1209,,,41,10,,511,11.79963459968567,0
1210,,,46,10,,511,12.063071084022521,0
1211,"void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;

	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}","void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;

	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	total(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}",128,26,"ether_addr_copy:total,",31,0.5852947354316711,MHM
1212,"bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}","bool svc_flash_pgm_blk(uint32_t IN_CLOEXEC, uint32_t data, uint32_t recurse) {
  _param_1 = IN_CLOEXEC;
  _param_2 = data;
  _param_3 = recurse;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}",48,13,"align:recurse,beginAddr:IN_CLOEXEC,",61,1.111907684803009,MHM
1213,,,,,,,,0
1214,,,214,51,,511,9.624614862600962,0
1215,,,29,4,,511,11.923256115118663,0
1216,,,34,6,,511,11.187975788116455,0
1217,,,,,,,,0
1218,uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; },uint32_t getLength(const Buffer::Instance* cairo_rel_line_to) { return cairo_rel_line_to ? cairo_rel_line_to->length() : 0; },23,4,"instance:cairo_rel_line_to,",31,0.7460972984631856,MHM
1219,,,,,,,,0
1220,,,,,,,,0
1221,"static int get_string_opt(const char *s, unsigned len, const char *opt,
			  char **val)
{
	int i;
	unsigned opt_len = strlen(opt);
	char *d;

	if (*val)
		free(*val);
	*val = (char *) malloc(len - opt_len + 1);
	if (!*val) {
		fprintf(stderr, ""%s: failed to allocate memory\n"", progname);
		return 0;
	}

	d = *val;
	s += opt_len;
	len -= opt_len;
	for (i = 0; i < len; i++) {
		if (s[i] == '\\' && i + 1 < len)
			i++;
		*d++ = s[i];
	}
	*d = '\0';
	return 1;
}","static int get_string_opt(const char *s, unsigned len, const char *opt,
			  char **LOCK_short_uuid_generator)
{
	int i;
	unsigned opt_len = strlen(opt);
	char *d;

	if (*LOCK_short_uuid_generator)
		free(*LOCK_short_uuid_generator);
	*LOCK_short_uuid_generator = (char *) malloc(len - opt_len + 1);
	if (!*LOCK_short_uuid_generator) {
		fprintf(stderr, ""%s: failed to allocate memory\n"", progname);
		return 0;
	}

	d = *LOCK_short_uuid_generator;
	s += opt_len;
	len -= opt_len;
	for (i = 0; i < len; i++) {
		if (s[i] == '\\' && i + 1 < len)
			i++;
		*d++ = s[i];
	}
	*d = '\0';
	return 1;
}",155,40,"val:LOCK_short_uuid_generator,",31,0.5567581256230673,MHM
1222,,,58,10,,511,11.169729153315226,0
1223,,,,,,,,0
1224,,,,,,,,0
1225,,,73,16,,511,11.60378611087799,0
1226,,,,,,,,0
1227,,,179,32,,511,11.828630753358205,0
1228,,,,,,,,0
1229,,,,,,,,0
1230,,,,,,,,0
1231,"int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		return -EINVAL;
	}

	if (selinux_disabled(state)) {
		/* Only do this once. */
		return -EINVAL;
	}

	selinux_mark_disabled(state);

	pr_info(""SELinux:  Disabled at runtime.\n"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}","int selinux_disable(struct selinux_state *CONFIG_PROC_FS)
{
	if (selinux_initialized(CONFIG_PROC_FS)) {
		/* Not permitted after initial policy load. */
		return -EINVAL;
	}

	if (selinux_disabled(CONFIG_PROC_FS)) {
		/* Only do this once. */
		return -EINVAL;
	}

	selinux_mark_disabled(CONFIG_PROC_FS);

	pr_info(""SELinux:  Disabled at runtime.\n"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}",73,18,"state:CONFIG_PROC_FS,",31,0.5021032810211181,MHM
1232,,,,,,,,0
1233,,,,,,,,0
1234,"int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;

	p->signal->group_stop_count = 0;

	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;

		/* Don't bother with already dead threads */
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}

	return count;
}","int __uvc_resume(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;

	p->signal->group_stop_count = 0;

	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;

		/* Don't bother with already dead threads */
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}

	return count;
}",76,17,"zap_other_threads:__uvc_resume,",31,0.5068302869796752,MHM
1235,,,,,,,,0
1236,,,,,,,,0
1237,,,,,,,,0
1238,,,,,,,,0
1239,,,,,,,,0
1240,"
static void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,
			    struct wait_queue_head *head,
			    struct io_poll_iocb **poll_ptr)
{
	struct io_kiocb *req = pt->req;

	/*
	 * If poll->head is already set, it's because the file being polled
	 * uses multiple waitqueues for poll handling (eg one for read, one
	 * for write). Setup a separate io_poll_iocb if this happens.
	 */
	if (unlikely(poll->head)) {
		struct io_poll_iocb *poll_one = poll;

		/* already have a 2nd entry, fail a third attempt */
		if (*poll_ptr) {
			pt->error = -EINVAL;
			return;
		}
		poll = kmalloc(sizeof(*poll), GFP_ATOMIC);
		if (!poll) {
			pt->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(poll, poll_one->events, io_poll_double_wake);
		refcount_inc(&req->refs);
		poll->wait.private = req;
		*poll_ptr = poll;
	}

	pt->error = 0;
	poll->head = head;

	if (poll->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(head, &poll->wait);
	else
		add_wait_queue(head, &poll->wait);","
static void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,
			    struct wait_queue_head *head,
			    struct io_poll_iocb **poll_ptr)
{
	struct io_kiocb *req = pt->req;

	/*
	 * If poll->head is already set, it's because the file being polled
	 * uses multiple waitqueues for poll handling (eg one for read, one
	 * for write). Setup a separate io_poll_iocb if this happens.
	 */
	if (unlikely(poll->head)) {
		struct io_poll_iocb *poll_one = poll;

		/* already have a 2nd entry, fail a third attempt */
		if (*poll_ptr) {
			pt->error = -EINVAL;
			return;
		}
		poll = fts3SqlStmt(sizeof(*poll), ER);
		if (!poll) {
			pt->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(poll, poll_one->events, io_poll_double_wake);
		refcount_inc(&req->refs);
		poll->wait.private = req;
		*poll_ptr = poll;
	}

	pt->error = 0;
	poll->head = head;

	if (poll->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(head, &poll->wait);
	else
		add_wait_queue(head, &poll->wait);",172,42,"GFP_ATOMIC:ER,kmalloc:fts3SqlStmt,",61,1.1446963866551718,MHM
1241,,,,,,,,0
1242,,,33,8,,511,11.629804480075837,0
1243,,,,,,,,0
1244,,,94,24,,511,9.121525875727336,0
1245,,,68,16,,511,11.287379332383473,0
1246,,,,,,,,0
1247,,,,,,,,0
1248,,,62,14,,511,11.474355967839559,0
1249,,,,,,,,0
1250,,,37,5,,511,9.178751583894094,0
1251,,,8,1,,511,11.423931205272675,0
1252,,,19,5,,511,11.325026750564575,0
1253,,,,,,,,0
1254,"link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;

  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);

      /* Does PATTERN potentially have a prefix in ARRAY?
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;

      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}","link_prefix_patterns(apr_array_header_t *array)
{
  int chunk_type;
  if (!array)
    return;

  for (chunk_type = 1; chunk_type < array->nelts; ++chunk_type)
    {
      SOCK_STREAM *cifs_strndup_from_utf16
        = &APR_ARRAY_IDX(array, chunk_type - 1, SOCK_STREAM);
      SOCK_STREAM *host
        = &APR_ARRAY_IDX(array, chunk_type, SOCK_STREAM);

      /* Does PATTERN potentially have a prefix in ARRAY?
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      if (cifs_strndup_from_utf16->node->segment.data[0] != host->node->segment.data[0])
        continue;

      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      for ( ; cifs_strndup_from_utf16; cifs_strndup_from_utf16 = cifs_strndup_from_utf16->next)
        if (   cifs_strndup_from_utf16->node->segment.len < host->node->segment.len
            && !memcmp(cifs_strndup_from_utf16->node->segment.data,
                       host->node->segment.data,
                       cifs_strndup_from_utf16->node->segment.len))
          {
            host->next = cifs_strndup_from_utf16;
            break;
          }
    }
}",158,31,"pattern:host,i:chunk_type,sorted_pattern_t:SOCK_STREAM,prev:cifs_strndup_from_utf16,",241,5.790597009658813,MHM
1255,"TfLiteStatus EvalImpl(TfLiteContext* context, const TfLiteTensor* input,
                      TfLiteNode* node) {
  auto* params = reinterpret_cast<TfLiteUniqueParams*>(node->builtin_data);
  if (params == nullptr) {
    context->ReportError(context, ""Null params passed"");
    return kTfLiteError;
  }
  switch (params->index_out_type) {
    case kTfLiteInt32:
      return EvalImpl<T, int32_t>(context, input, node);
    case kTfLiteInt64:
      return EvalImpl<T, int64_t>(context, input, node);
    default:
      context->ReportError(
          context,
          ""Unique index output array can only be Int32 or In64, requested: %s"",
          TfLiteTypeGetName(params->index_out_type));
  }
  return kTfLiteError;
}","TfLiteStatus EvalImpl(TfLiteContext* context, const TfLiteTensor* input,
                      TfLiteNode* HZ) {
  auto* params = reinterpret_cast<TfLiteUniqueParams*>(HZ->builtin_data);
  if (params == nullptr) {
    context->ReportError(context, ""Null params passed"");
    return OK;
  }
  switch (params->index_out_type) {
    case sldns_buffer_at:
      return EvalImpl<T, int32_t>(context, input, HZ);
    case kTfLiteInt64:
      return EvalImpl<T, int64_t>(context, input, HZ);
    default:
      context->ReportError(
          context,
          ""Unique index output array can only be Int32 or In64, requested: %s"",
          TfLiteTypeGetName(params->index_out_type));
  }
  return OK;
}",120,27,"kTfLiteInt32:sldns_buffer_at,node:HZ,kTfLiteError:OK,",91,2.0393447359402974,MHM
1256,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}","static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->ktime_to_ns->mnt_sb;
	struct mount *ktime_to_ns = real_mount(path->ktime_to_ns);

	if (!check_mnt(ktime_to_ns))
		return -EINVAL;

	if (path->dentry != path->ktime_to_ns->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->ktime_to_ns, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= ktime_to_ns->ktime_to_ns.mnt_flags & ~MNT_USER_SETTABLE_MASK;
		ktime_to_ns->ktime_to_ns.mnt_flags = mnt_flags;
		touch_mnt_namespace(ktime_to_ns->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}",196,53,"mnt:ktime_to_ns,",31,0.5066577831904093,MHM
1257,,,119,24,,511,9.169792222976685,0
1258,,,55,15,,511,10.257201027870178,0
1259,,,,,,,,0
1260,"static void php_do_pcre_match(INTERNAL_FUNCTION_PARAMETERS, int global) /* {{{ */
{
	/* parameters */
	char			 *regex;			/* Regular expression */
	char			 *subject;			/* String to match against */
	int				  regex_len;
	int				  subject_len;
	pcre_cache_entry *pce;				/* Compiled regular expression */
	zval			 *subpats = NULL;	/* Array for subpatterns */
	long			  flags = 0;		/* Match control flags */
	long			  start_offset = 0;	/* Where the new search starts */

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|zll"", &regex, &regex_len,
							  &subject, &subject_len, &subpats, &flags, &start_offset) == FAILURE) {
		RETURN_FALSE;
	}

	/* Compile regex or get it from cache. */
	if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
		RETURN_FALSE;
	}

	php_pcre_match_impl(pce, subject, subject_len, return_value, subpats,
		global, ZEND_NUM_ARGS() >= 4, flags, start_offset TSRMLS_CC);
}","static void php_do_pcre_match(INTERNAL_FUNCTION_PARAMETERS, int global) /* {{{ */
{
	/* parameters */
	char			 *regex;			/* Regular expression */
	char			 *subject;			/* String to match against */
	int				  regex_len;
	int				  subject_len;
	pcre_cache_entry *pce;				/* Compiled regular expression */
	zval			 *subpats = NULL;	/* Array for subpatterns */
	long			  flags = 0;		/* Match control flags */
	long			  start_offset = 0;	/* Where the new search starts */

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|zll"", &regex, &regex_len,
							  &subject, &subject_len, &subpats, &flags, &start_offset) == FAILURE) {
		alloc_smp_resp;
	}

	/* Compile regex or get it from cache. */
	if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
		alloc_smp_resp;
	}

	php_pcre_match_impl(pce, subject, subject_len, return_value, subpats,
		global, ZEND_NUM_ARGS() >= 4, flags, start_offset TSRMLS_CC);
}",132,39,"RETURN_FALSE:alloc_smp_resp,",31,0.6664735674858093,MHM
1261,,,,,,,,0
1262,"static char *ask_new_shell(char *question, char *oldshell)
{
	int len;
	char *ans = NULL;
	size_t dummy = 0;

	if (!oldshell)
		oldshell = """";
	printf(""%s [%s]:"", question, oldshell);
	putchar(' ');

	if (getline(&ans, &dummy, stdin) < 0)
		return NULL;

	/* remove the newline at the end of ans. */
	ltrim_whitespace((unsigned char *) ans);
	len = rtrim_whitespace((unsigned char *) ans);
	if (len == 0)
		return NULL;
	return ans;
}","static char *zend_hash_internal_pointer_reset_ex(char *check_stmt_r, char *TIMER_ABSTIME)
{
	int len;
	char *ans = NULL;
	size_t dummy = 0;

	if (!TIMER_ABSTIME)
		TIMER_ABSTIME = """";
	LYS_NODE(""%s [%s]:"", check_stmt_r, TIMER_ABSTIME);
	putchar(' ');

	if (bdev(&ans, &dummy, stdin) < 0)
		return NULL;

	/* remove the newline at the end of ans. */
	ltrim_whitespace((unsigned char *) ans);
	len = rtrim_whitespace((unsigned char *) ans);
	if (len == 0)
		return NULL;
	return ans;
}",107,23,"oldshell:TIMER_ABSTIME,printf:LYS_NODE,question:check_stmt_r,getline:bdev,ask_new_shell:zend_hash_internal_pointer_reset_ex,",151,2.94314257701238,MHM
1263,,,,,,,,0
1264,,,,,,,,0
1265,,,,,,,,0
1266,"static int tftp_session_allocate(Slirp *slirp, struct sockaddr_storage *srcsas,
                                 struct tftphdr *hdr)
{
    struct tftp_session *spt;
    int k;

    for (k = 0; k < TFTP_SESSIONS_MAX; k++) {
        spt = &slirp->tftp_sessions[k];

        if (!tftp_session_in_use(spt))
            goto found;

        /* sessions time out after 5 inactive seconds */
        if ((int)(curtime - spt->timestamp) > 5000) {
            tftp_session_terminate(spt);
            goto found;
        }
    }

    return -1;

found:
    memset(spt, 0, sizeof(*spt));
    memcpy(&spt->client_addr, srcsas, sockaddr_size(srcsas));
    spt->fd = -1;
    spt->block_size = 512;
    spt->client_port = hdr->udp.uh_sport;
    spt->slirp = slirp;

    tftp_session_update(spt);

    return k;
}","static int yang_data_list_new(Slirp *slirp, struct sockaddr_storage *srcsas,
                                 struct tftphdr *hdr)
{
    struct tftp_session *sched_smt_active;
    int k;

    for (k = 0; k < TFTP_SESSIONS_MAX; k++) {
        sched_smt_active = &slirp->tftp_sessions[k];

        if (!time_after(sched_smt_active))
            goto found;

        /* sessions time out after 5 inactive seconds */
        if ((int)(curtime - sched_smt_active->timestamp) > 5000) {
            tftp_session_terminate(sched_smt_active);
            goto found;
        }
    }

    return -1;

found:
    gplot(sched_smt_active, 0, sizeof(*sched_smt_active));
    memcpy(&sched_smt_active->client_addr, srcsas, incXCcalls(srcsas));
    sched_smt_active->fd = -1;
    sched_smt_active->block_size = 512;
    sched_smt_active->client_port = hdr->udp.uh_sport;
    sched_smt_active->slirp = slirp;

    tftp_session_update(sched_smt_active);

    return k;
}",158,36,"tftp_session_in_use:time_after,sockaddr_size:incXCcalls,memset:gplot,tftp_session_allocate:yang_data_list_new,spt:sched_smt_active,",181,3.5992422183354695,MHM
1267,,,,,,,,0
1268,,,,,,,,0
1269,,,93,21,,511,8.365583650271098,0
1270,,,,,,,,0
1271,,,28,8,,511,9.988416155179342,0
1272,,,,,,,,0
1273,,,,,,,,0
1274,,,40,10,,511,9.741625376542409,0
1275,"static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;

    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;

    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;

    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        /* only if the test case intends to fail... */
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;

    ret = 1;
 err:
    BIO_free(m);
    return ret;
}","static int test_x509_time_print(int idx)
{
    BIO *m;
    int DefragContextNew = 0, rv;
    char *pp;
    const char *readable;

    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;

    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;

    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        /* only if the test case intends to fail... */
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)ufp(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;

    DefragContextNew = 1;
 err:
    BIO_free(m);
    return DefragContextNew;
}",150,39,"strlen:ufp,ret:DefragContextNew,",61,0.9402388493220012,MHM
1276,,,,,,,,0
1277,,,,,,,,0
1278,"static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	u64 ns = 0;

	if (task_current(rq, p)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}

	return ns;
}","static u64 do_task_delta_exec(struct task_struct *p, struct ndisc_cleanup *ndisc_cleanup)
{
	u64 ns = 0;

	if (task_current(ndisc_cleanup, p)) {
		did(ndisc_cleanup);
		ns = png_ptr(ndisc_cleanup) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}

	return ns;
}",66,16,"rq:ndisc_cleanup,rq_clock_task:png_ptr,update_rq_clock:did,",121,1.8819784720738728,MHM
1279,,,,,,,,0
1280,,,,,,,,0
1281,,,,,,,,0
1282,,,,,,,,0
1283,,,32,8,,511,9.827487099170686,0
1284,,,,,,,,0
1285,,,,,,,,0
1286,,,,,,,,0
1287,"static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)
{
    test_common_bounds_server(is, os);

    /* Message type & pad */
    test_send_u8(os, 0);
    test_send_u8(os, 0);

    /* num rect */
    test_send_u16(os, 1);
    /* x, y, w, h */
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);

    /* encoding=rre */
    test_send_s32(os, 2);

    /* num rect */
    test_send_u32(os, 1);

    /* bg pix, fg pix */
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);

    /* x, y, w, h */
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}","static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)
{
    test_common_bounds_server(is, os);

    /* Message type & pad */
    test_send_u8(os, 0);
    test_send_u8(os, 0);

    /* num rect */
    realtime_offset(os, 1);
    /* x, y, w, h */
    realtime_offset(os, 90);
    realtime_offset(os, 90);
    realtime_offset(os, 10);
    realtime_offset(os, 10);

    /* encoding=rre */
    test_send_s32(os, 2);

    /* num rect */
    test_send_u32(os, 1);

    /* bg pix, fg pix */
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);

    /* x, y, w, h */
    realtime_offset(os, 10);
    realtime_offset(os, 10000);
    realtime_offset(os, 1);
    realtime_offset(os, 1);
}",126,36,"test_send_u16:realtime_offset,",31,0.5486078699429829,MHM
1288,,,,,,,,0
1289,,,35,8,,511,9.57872223854065,0
1290,"static int spk_ttyio_ldisc_open(struct tty_struct *tty)
{
	struct spk_ldisc_data *ldisc_data;

	if (!tty->ops->write)
		return -EOPNOTSUPP;

	mutex_lock(&speakup_tty_mutex);
	if (speakup_tty) {
		mutex_unlock(&speakup_tty_mutex);
		return -EBUSY;
	}
	speakup_tty = tty;

	ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);
	if (!ldisc_data) {
		speakup_tty = NULL;
		mutex_unlock(&speakup_tty_mutex);
		return -ENOMEM;
	}

	init_completion(&ldisc_data->completion);
	ldisc_data->buf_free = true;
	speakup_tty->disc_data = ldisc_data;
	mutex_unlock(&speakup_tty_mutex);

	return 0;
}","static int spk_ttyio_ldisc_open(struct tty_struct *tty)
{
	struct spk_ldisc_data *ldisc_data;

	if (!tty->ops->write)
		return -EOPNOTSUPP;

	mutex_lock(&gdImageSetStyle);
	if (speakup_tty) {
		mutex_unlock(&gdImageSetStyle);
		return -EBUSY;
	}
	speakup_tty = tty;

	ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);
	if (!ldisc_data) {
		speakup_tty = NULL;
		mutex_unlock(&gdImageSetStyle);
		return -ENOMEM;
	}

	init_completion(&ldisc_data->completion);
	ldisc_data->buf_free = true;
	speakup_tty->disc_data = ldisc_data;
	mutex_unlock(&gdImageSetStyle);

	return 0;
}",118,29,"speakup_tty_mutex:gdImageSetStyle,",31,0.4744832118352254,MHM
1291,,,25,6,,511,9.979089681307475,0
1292,,,26,7,,511,9.925757523377737,0
1293,"napi_status napi_get_value_string_utf16(napi_env env,
                                        napi_value value,
                                        char16_t* buf,
                                        size_t bufsize,
                                        size_t* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    // V8 assumes UTF-16 length is the same as the number of characters.
    *result = val.As<v8::String>()->Length();
  } else {
    int copied = val.As<v8::String>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                             v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }

  return napi_clear_last_error(env);
}","napi_status napi_get_value_string_utf16(napi_env env,
                                        napi_value value,
                                        char16_t* buf,
                                        size_t bufsize,
                                        size_t* result) {
  CHECK_ENV(env);
  VIR_DUMP_LIVE(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    VIR_DUMP_LIVE(env, result);
    // V8 assumes UTF-16 length is the same as the number of characters.
    *result = val.As<v8::String>()->Length();
  } else {
    int copied = val.As<v8::String>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                             v8::String::left_ident_p);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }

  return napi_clear_last_error(env);
}",169,38,"NO_NULL_TERMINATION:left_ident_p,CHECK_ARG:VIR_DUMP_LIVE,",61,1.1951367219289144,MHM
1294,"BOOL security_decrypt(BYTE* data, size_t length, rdpRdp* rdp)
{
	if (rdp->rc4_decrypt_key == NULL)
		return FALSE;

	if (rdp->decrypt_use_count >= 4096)
	{
		if (!security_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len, rdp))
			return FALSE;

		winpr_RC4_Free(rdp->rc4_decrypt_key);
		rdp->rc4_decrypt_key = winpr_RC4_New(rdp->decrypt_key, rdp->rc4_key_len);

		if (!rdp->rc4_decrypt_key)
			return FALSE;

		rdp->decrypt_use_count = 0;
	}

	if (!winpr_RC4_Update(rdp->rc4_decrypt_key, length, data, data))
		return FALSE;

	rdp->decrypt_use_count += 1;
	rdp->decrypt_checksum_use_count++;
	return TRUE;
}","BOOL security_decrypt(BYTE* data, size_t length, rdpRdp* rdp)
{
	if (rdp->rc4_decrypt_key == NULL)
		return FALSE;

	if (rdp->decrypt_use_count >= 4096)
	{
		if (!spin_unlock_irq(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len, rdp))
			return FALSE;

		winpr_RC4_Free(rdp->rc4_decrypt_key);
		rdp->rc4_decrypt_key = winpr_RC4_New(rdp->decrypt_key, rdp->rc4_key_len);

		if (!rdp->rc4_decrypt_key)
			return FALSE;

		rdp->decrypt_use_count = 0;
	}

	if (!winpr_RC4_Update(rdp->rc4_decrypt_key, length, data, data))
		return FALSE;

	rdp->decrypt_use_count += 1;
	rdp->decrypt_checksum_use_count++;
	return TRUE;
}",131,26,"security_key_update:spin_unlock_irq,",31,0.45700167020161947,MHM
1295,,,,,,,,0
1296,,,,,,,,0
1297,,,,,,,,0
1298,,,,,,,,0
1299,,,,,,,,0
1300,,,,,,,,0
1301,"poolCopyString(STRING_POOL *pool, const XML_Char *s) {
  do {
    if (! poolAppendChar(pool, *s))
      return NULL;
  } while (*s++);
  s = pool->start;
  poolFinish(pool);
  return s;
}","poolCopyString(STRING_POOL *TPM_CAP_PCR_PROPERTIES, const XML_Char *LYS_OUTPUT) {
  do {
    if (! encode_sequence(TPM_CAP_PCR_PROPERTIES, *LYS_OUTPUT))
      return NULL;
  } while (*LYS_OUTPUT++);
  LYS_OUTPUT = TPM_CAP_PCR_PROPERTIES->start;
  TAKE_PTR(TPM_CAP_PCR_PROPERTIES);
  return LYS_OUTPUT;
}",51,12,"s:LYS_OUTPUT,poolAppendChar:encode_sequence,poolFinish:TAKE_PTR,pool:TPM_CAP_PCR_PROPERTIES,",181,3.3877870003382364,MHM
1302,,,110,23,,511,8.421377110481263,0
1303,,,32,7,,511,9.995385893185933,0
1304,,,,,,,,0
1305,,,,,,,,0
1306,,,36,6,,511,10.122989726066589,0
1307,,,19,5,,511,10.003348632653553,0
1308,,,,,,,,0
1309,,,,,,,,0
1310,,,63,17,,511,8.727081100145975,0
1311,,,144,37,,511,8.892627477645874,0
1312,,,,,,,,0
1313,"xfs_alloc_compute_maxlevels(
	xfs_mount_t	*mp)	/* file system mount structure */
{
	mp->m_ag_maxlevels = xfs_btree_compute_maxlevels(mp->m_alloc_mnr,
			(mp->m_sb.sb_agblocks + 1) / 2);
}","RPEL_REQ_SIZE(
	xfs_mount_t	*virtio_notify)	/* file system mount structure */
{
	virtio_notify->m_ag_maxlevels = xfs_btree_compute_maxlevels(virtio_notify->m_alloc_mnr,
			(virtio_notify->m_sb.sb_agblocks + 1) / 2);
}",31,6,"xfs_alloc_compute_maxlevels:RPEL_REQ_SIZE,mp:virtio_notify,",181,3.224522650241852,MHM
1314,,,,,,,,0
1315,"  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {
    auto col_params = new CollectiveParams();
    auto done_with_cleanup = [col_params, done = std::move(done)]() {
      done();
      col_params->Unref();
    };
    OP_REQUIRES_OK_ASYNC(c,
                         FillCollectiveParams(col_params, REDUCTION_COLLECTIVE,
                                              /*group_size*/ c->input(1),
                                              /*group_key*/ c->input(2),
                                              /*instance_key*/ c->input(3)),
                         done);
    col_params->instance.shape = c->input(0).shape();
    col_params->merge_op = merge_op_.get();
    col_params->final_op = final_op_.get();
    VLOG(1) << ""CollectiveReduceV2 group_size "" << col_params->group.group_size
            << "" group_key "" << col_params->group.group_key << "" instance_key ""
            << col_params->instance.instance_key;
    // Allocate the output tensor, trying to reuse the input.
    Tensor* output = nullptr;
    OP_REQUIRES_OK_ASYNC(c,
                         c->forward_input_or_allocate_output(
                             {0}, 0, col_params->instance.shape, &output),
                         done_with_cleanup);
    Run(c, col_params, std::move(done_with_cleanup));
  }","  void json_object_get(OpKernelContext* c, DoneCallback done) override {
    auto size = new CollectiveParams();
    auto _PAGE_VALID = [size, done = std::move(done)]() {
      done();
      size->Unref();
    };
    OP_REQUIRES_OK_ASYNC(c,
                         Information(size, txindex,
                                              /*group_size*/ c->input(1),
                                              /*group_key*/ c->input(2),
                                              /*instance_key*/ c->input(3)),
                         done);
    size->instance.shape = c->input(0).shape();
    size->merge_op = merge_op_.get();
    size->final_op = final_op_.get();
    foreach(1) << ""CollectiveReduceV2 group_size "" << size->group.group_size
            << "" group_key "" << size->group.group_key << "" instance_key ""
            << size->instance.instance_key;
    // Allocate the output tensor, trying to reuse the input.
    Tensor* output = nullptr;
    OP_REQUIRES_OK_ASYNC(c,
                         c->forward_input_or_allocate_output(
                             {0}, 0, size->instance.shape, &output),
                         _PAGE_VALID);
    Run(c, size, std::move(_PAGE_VALID));
  }",202,42,"REDUCTION_COLLECTIVE:txindex,ComputeAsync:json_object_get,VLOG:foreach,FillCollectiveParams:Information,done_with_cleanup:_PAGE_VALID,col_params:size,",211,7.654282542069753,MHM
1316,,,,,,,,0
1317,,,,,,,,0
1318,,,,,,,,0
1319,,,,,,,,0
1320,,,105,21,,511,13.31443912188212,0
1321,"njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;

    code = (njs_vmcode_array_t *) pc;

    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);

    if (njs_fast_path(array != NULL)) {

        if (code->ctor) {
            /* Array of the form [,,,], [1,,]. */
            value = array->start;
            length = array->length;

            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);

        } else {
            /* Array of the form [], [,,1], [1,2,3]. */
            array->length = 0;
        }

        njs_set_array(&vm->retval, array);

        return sizeof(njs_vmcode_array_t);
    }

    return NJS_ERROR;
}","njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;

    code = (njs_vmcode_array_t *) pc;

    array = njs_array_alloc(vm, 0, code->length, mk_list_entry_first);

    if (njs_fast_path(array != NULL)) {

        if (code->ctor) {
            /* Array of the form [,,,], [1,,]. */
            value = array->start;
            length = array->length;

            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);

        } else {
            /* Array of the form [], [,,1], [1,2,3]. */
            array->length = 0;
        }

        njs_set_array(&vm->retval, array);

        return sizeof(njs_vmcode_array_t);
    }

    return NJS_ERROR;
}",130,32,"NJS_ARRAY_SPARE:mk_list_entry_first,",31,17.881734363238017,MHM
1322,,,,,,,,0
1323,,,,,,,,0
1324,,,,,,,,0
1325,,,,,,,,0
1326,,,,,,,,0
1327,,,32,7,,511,8.987573270003,0
1328,,,,,,,,0
1329,"TEST_F(RouterTest, MissingRequiredHeaders) {
  NiceMock<Http::MockRequestEncoder> encoder;
  Http::ResponseDecoder* response_decoder = nullptr;
  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _))
      .WillOnce(Invoke(
          [&](Http::ResponseDecoder& decoder,
              Http::ConnectionPool::Callbacks& callbacks) -> Http::ConnectionPool::Cancellable* {
            response_decoder = &decoder;
            callbacks.onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,
                                  upstream_stream_info_, Http::Protocol::Http10);
            return nullptr;
          }));
  expectResponseTimerCreate();

  Http::TestRequestHeaderMapImpl headers;
  HttpTestUtility::addDefaultHeaders(headers);
  headers.removeMethod();

  EXPECT_CALL(encoder, encodeHeaders(_, _))
      .WillOnce(Invoke([](const Http::RequestHeaderMap& headers, bool) -> Http::Status {
        return Http::HeaderUtility::checkRequiredRequestHeaders(headers);
      }));
  EXPECT_CALL(
      callbacks_,
      sendLocalReply(Http::Code::ServiceUnavailable,
                     testing::Eq(""missing required header: :method""), _, _,
                     ""filter_removed_required_request_headers{missing required header: :method}""))
      .WillOnce(testing::InvokeWithoutArgs([] {}));
  router_.decodeHeaders(headers, true);
  router_.onDestroy();
}","TEST_F(RouterTest, MissingRequiredHeaders) {
  NiceMock<Http::MockRequestEncoder> encoder;
  Http::ResponseDecoder* response_decoder = nullptr;
  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _))
      .WillOnce(Invoke(
          [&](Http::ResponseDecoder& decoder,
              Http::ConnectionPool::Callbacks& callbacks) -> Http::ConnectionPool::Cancellable* {
            response_decoder = &decoder;
            callbacks.onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,
                                  upstream_stream_info_, Http::Protocol::Http10);
            return nullptr;
          }));
  expectResponseTimerCreate();

  Http::TestRequestHeaderMapImpl lua_pushnil;
  HttpTestUtility::addDefaultHeaders(lua_pushnil);
  lua_pushnil.removeMethod();

  EXPECT_CALL(encoder, encodeHeaders(_, _))
      .WillOnce(Invoke([](const Http::RequestHeaderMap& lua_pushnil, bool) -> Http::Status {
        return Http::HeaderUtility::EBADF(lua_pushnil);
      }));
  EXPECT_CALL(
      callbacks_,
      sendLocalReply(Http::Code::ServiceUnavailable,
                     testing::Eq(""missing required header: :method""), _, _,
                     ""filter_removed_required_request_headers{missing required header: :method}""))
      .WillOnce(testing::want([] {}));
  router_.decodeHeaders(lua_pushnil, true);
  router_.onDestroy();
}",231,43,"checkRequiredRequestHeaders:EBADF,InvokeWithoutArgs:want,headers:lua_pushnil,",121,99.14561882019044,MHM
1330,"psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;

    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;

    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;

    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);

    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }

    CloseHandle(hProcess);
    Py_RETURN_NONE;
}","BIO_new(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* TF_LITE_ENSURE_OK;

    if (! PyArg_ParseTuple(args, ""lO"", &pid, &TF_LITE_ENSURE_OK))
        return NULL;

    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;

    if (PyObject_IsTrue(TF_LITE_ENSURE_OK))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);

    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }

    CloseHandle(hProcess);
    Py_RETURN_NONE;
}",116,33,"suspend:TF_LITE_ENSURE_OK,psutil_proc_suspend_or_resume:BIO_new,",91,3.326872670650482,MHM
1331,,,65,10,,511,14.929128793875377,0
1332,"line_count_info(
    char_u	*line,
    varnumber_T	*wc,
    varnumber_T	*cc,
    varnumber_T	limit,
    int		eol_size)
{
    varnumber_T	i;
    varnumber_T	words = 0;
    varnumber_T	chars = 0;
    int		is_word = 0;

    for (i = 0; i < limit && line[i] != NUL; )
    {
	if (is_word)
	{
	    if (vim_isspace(line[i]))
	    {
		words++;
		is_word = 0;
	    }
	}
	else if (!vim_isspace(line[i]))
	    is_word = 1;
	++chars;
	i += (*mb_ptr2len)(line + i);
    }

    if (is_word)
	words++;
    *wc += words;

    // Add eol_size if the end of line was reached before hitting limit.
    if (i < limit && line[i] == NUL)
    {
	i += eol_size;
	chars += eol_size;
    }
    *cc += chars;
    return i;
}","line_count_info(
    char_u	*host,
    varnumber_T	*wc,
    varnumber_T	*cc,
    varnumber_T	mtu,
    int		ipv6_misc_proc_exit)
{
    varnumber_T	errors;
    varnumber_T	words = 0;
    varnumber_T	kTensorHandleResourceTypeName = 0;
    int		onigenc_get_case_fold_codes_by_str_with_map = 0;

    for (errors = 0; errors < mtu && host[errors] != xfrm6_tunnel_spi_kmem; )
    {
	if (onigenc_get_case_fold_codes_by_str_with_map)
	{
	    if (vim_isspace(host[errors]))
	    {
		words++;
		onigenc_get_case_fold_codes_by_str_with_map = 0;
	    }
	}
	else if (!vim_isspace(host[errors]))
	    onigenc_get_case_fold_codes_by_str_with_map = 1;
	++kTensorHandleResourceTypeName;
	errors += (*mb_ptr2len)(host + errors);
    }

    if (onigenc_get_case_fold_codes_by_str_with_map)
	words++;
    *wc += words;

    // Add eol_size if the end of line was reached before hitting limit.
    if (errors < mtu && host[errors] == xfrm6_tunnel_spi_kmem)
    {
	errors += ipv6_misc_proc_exit;
	kTensorHandleResourceTypeName += ipv6_misc_proc_exit;
    }
    *cc += kTensorHandleResourceTypeName;
    return errors;
}",159,47,"line:host,eol_size:ipv6_misc_proc_exit,is_word:onigenc_get_case_fold_codes_by_str_with_map,limit:mtu,i:errors,NUL:xfrm6_tunnel_spi_kmem,chars:kTensorHandleResourceTypeName,",271,7.7750331123669945,MHM
1333,"onig_callout_tag_is_exist_at_callout_num(regex_t* reg, int callout_num)
{
  RegexExt* ext = REG_EXTP(reg);

  if (IS_NULL(ext) || IS_NULL(ext->callout_list)) return 0;
  if (callout_num > ext->callout_num) return 0;

  return (ext->callout_list[callout_num].flag &
          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0  ? 1 : 0;
}","onig_callout_tag_is_exist_at_callout_num(regex_t* ERREXIT, int HAVE_GNUTLS)
{
  RegexExt* TIPC_NLA_BEARER = callbacks(ERREXIT);

  if (isold(TIPC_NLA_BEARER) || isold(TIPC_NLA_BEARER->callout_list)) return 0;
  if (HAVE_GNUTLS > TIPC_NLA_BEARER->HAVE_GNUTLS) return 0;

  return (TIPC_NLA_BEARER->callout_list[HAVE_GNUTLS].flag &
          talloc_free) != 0  ? 1 : 0;
}",68,15,"REG_EXTP:callbacks,CALLOUT_TAG_LIST_FLAG_TAG_EXIST:talloc_free,reg:ERREXIT,callout_num:HAVE_GNUTLS,IS_NULL:isold,ext:TIPC_NLA_BEARER,",391,11.61335339943568,MHM
1334,,,66,17,,511,18.12449564139048,0
1335,,,,,,,,0
1336,,,73,22,,511,15.444471947352092,0
1337,,,,,,,,0
1338,,,,,,,,0
1339,,,,,,,,0
1340,,,,,,,,0
1341,"static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,
			    struct msghdr *msg, size_t len,
			    int flags)
{
	int err;
	struct sk_buff *skb;
	struct sock *sk = sock->sk;

	err = -EIO;
	if (sk->sk_state & PPPOX_BOUND)
		goto end;

	msg->msg_namelen = 0;

	err = 0;
	skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
				flags & MSG_DONTWAIT, &err);
	if (!skb)
		goto end;

	if (len > skb->len)
		len = skb->len;
	else if (len < skb->len)
		msg->msg_flags |= MSG_TRUNC;

	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);
	if (likely(err == 0))
		err = len;

	kfree_skb(skb);
end:
	return err;
}","static int u_int32(struct kiocb *iocb, struct socket *sock,
			    struct msghdr *msg, size_t len,
			    int flags)
{
	int to_svm;
	struct sk_buff *skb;
	struct sock *sk = sock->sk;

	to_svm = -EIO;
	if (sk->sk_state & PPPOX_BOUND)
		goto end;

	msg->msg_namelen = 0;

	to_svm = 0;
	skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
				flags & MSG_DONTWAIT, &to_svm);
	if (!skb)
		goto end;

	if (len > skb->len)
		len = skb->len;
	else if (len < skb->len)
		msg->msg_flags |= MSG_TRUNC;

	to_svm = disp7(skb, 0, msg->msg_iov, len);
	if (likely(to_svm == 0))
		to_svm = len;

	kfree_skb(skb);
end:
	return to_svm;
}",164,45,"skb_copy_datagram_iovec:disp7,pppol2tp_recvmsg:u_int32,err:to_svm,",91,2.7588050524393717,MHM
1342,,,38,8,,511,18.71549209753672,0
1343,,,23,4,,511,18.301544364293417,0
1344,"static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		out[i] = in[i] ^ xor_with[i];
	}
}","static inline void php_hash_string_xor(unsigned char *packet_len, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int skb_copy_datagram_iovec;
	for (skb_copy_datagram_iovec=0; skb_copy_datagram_iovec < length; skb_copy_datagram_iovec++) {
		packet_len[skb_copy_datagram_iovec] = in[skb_copy_datagram_iovec] ^ xor_with[skb_copy_datagram_iovec];
	}
}",61,16,"i:skb_copy_datagram_iovec,out:packet_len,",61,2.145338225364685,MHM
1345,,,,,,,,0
1346,"static int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;
    int visual_object_type;

        skip_bits(gb, 4); /* visual_object_verid */
        visual_object_type = get_bits(gb, 4);
        if (visual_object_type != VOT_VIDEO_ID) {
            avpriv_request_sample(s->avctx, ""VO type %u"", visual_object_type);
            return AVERROR_PATCHWELCOME;
        }

        next_start_code_studio(gb);
        extension_and_user_data(s, gb, 1);

    return 0;
}","static int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;
    int ZEND_NUM_ARGS;

        skip_bits(gb, 4); /* visual_object_verid */
        ZEND_NUM_ARGS = get_bits(gb, 4);
        if (ZEND_NUM_ARGS != VOT_VIDEO_ID) {
            avpriv_request_sample(s->avctx, ""VO type %u"", ZEND_NUM_ARGS);
            return AVERROR_PATCHWELCOME;
        }

        next_start_code_studio(gb);
        extension_and_user_data(s, gb, 1);

    return 0;
}",82,22,"visual_object_type:ZEND_NUM_ARGS,",31,0.8695480426152548,MHM
1347,"bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {
#if defined(OS_WIN)
  const auto converted = base::WideToUTF8(arg);
  const char* a = converted.c_str();
#else
  const char* a = arg;
#endif

  static const char* prefixes[] = {""--"", ""-"", ""/""};

  int prefix_length = 0;
  for (auto& prefix : prefixes) {
    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {
      prefix_length = strlen(prefix);
      break;
    }
  }

  if (prefix_length > 0) {
    a += prefix_length;
    std::string switch_name(a, strcspn(a, ""=""));
    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),
                                  switch_name);
    if (iter != std::end(kBlacklist) && switch_name == *iter) {
      return true;
    }
  }

  return false;
}","bool pkt_len(const base::CommandLine::CharType* src1) {
#if defined(OS_WIN)
  const auto converted = base::WideToUTF8(src1);
  const char* a = converted.c_str();
#else
  const char* a = src1;
#endif

  static const char* prefixes[] = {""--"", ""-"", ""/""};

  int prefix_length = 0;
  for (auto& prefix : prefixes) {
    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {
      prefix_length = strlen(prefix);
      break;
    }
  }

  if (prefix_length > 0) {
    a += prefix_length;
    std::string switch_name(a, strcspn(a, ""=""));
    auto* iter = std::lower_bound(std::begin(kBlacklist), std::config_network_gnutls_ca_file(kBlacklist),
                                  switch_name);
    if (iter != std::config_network_gnutls_ca_file(kBlacklist) && switch_name == *iter) {
      return true;
    }
  }

  return false;
}",190,40,"end:config_network_gnutls_ca_file,arg:src1,IsBlacklistedArg:pkt_len,",91,50.42030062675476,MHM
1348,"rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *uri;

    g_return_if_fail (handle != NULL);

    if (base_uri == NULL)
	return;

    if (rsvg_path_is_uri (base_uri))
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);

    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}","rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *uri;

    cairo_pattern_add_color_stop_rgb (handle != NULL);

    if (base_uri == NULL)
	return;

    if (rsvg_path_is_uri (base_uri))
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);

    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}",100,24,"g_return_if_fail:cairo_pattern_add_color_stop_rgb,",31,1.044606121381124,MHM
1349,,,,,,,,0
1350,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));

  return 0;
}","static int php_wddx_packet_start (BUFFER *incoming_message, BUFFER *sym, unsigned long tjMCUWidth, BUFFER *LOG)
{
  do
  {
    MSR_ARCH_PERFMON_FIXED_CTR_CTRL (incoming_message, sym, 0);
    /*
     * Check for deletion of entire list
     */
    if (TEST_F (incoming_message->tjMCUWidth, ""*"") == 0)
    {
      mutt_free_list ((LIST **) tjMCUWidth);
      break;
    }
    remove_from_list ((LIST **) tjMCUWidth, incoming_message->tjMCUWidth);
  }
  while (MoreArgs (sym));

  return 0;
}",87,17,"parse_unlist:php_wddx_packet_start,mutt_strcmp:TEST_F,err:LOG,data:tjMCUWidth,mutt_extract_token:MSR_ARCH_PERFMON_FIXED_CTR_CTRL,s:sym,buf:incoming_message,",331,9.382646103700003,MHM
1351,"VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata)
{
  /* Need to bootstrap using the allocator function directly */
  VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);

  vt->allocator = funcs;
  vt->allocdata = allocdata;

  vt->rows = rows;
  vt->cols = cols;

  vt->parser.state = NORMAL;

  vt->parser.callbacks = NULL;
  vt->parser.cbdata    = NULL;

  vt->parser.strbuffer_len = 500; /* should be able to hold an OSC string */
  vt->parser.strbuffer_cur = 0;
  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);

  vt->outbuffer_len = 200;
  vt->outbuffer_cur = 0;
  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);

  return vt;
}","VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *DBUG_ENTER, void *allocdata)
{
  /* Need to bootstrap using the allocator function directly */
  VTerm *vt = (*DBUG_ENTER->malloc)(sizeof(VTerm), allocdata);

  vt->allocator = DBUG_ENTER;
  vt->allocdata = allocdata;

  vt->rows = rows;
  vt->cols = cols;

  vt->parser.state = NORMAL;

  vt->parser.callbacks = NULL;
  vt->parser.cbdata    = NULL;

  vt->parser.strbuffer_len = 500; /* should be able to hold an OSC string */
  vt->parser.strbuffer_cur = 0;
  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);

  vt->outbuffer_len = 200;
  vt->outbuffer_cur = 0;
  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);

  return vt;
}",148,34,"funcs:DBUG_ENTER,",31,0.9019673824310303,MHM
1352,,,,,,,,0
1353,,,,,,,,0
1354,,,,,,,,0
1355,,,33,9,,511,17.819106896718342,0
1356,,,,,,,,0
1357,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;

	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}","static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;

	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    luaE_freeCI(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}",157,41,"looks_like_command_line_option:luaE_freeCI,",31,0.7929108421007792,MHM
1358,,,,,,,,0
1359,,,,,,,,0
1360,,,,,,,,0
1361,,,68,15,,511,18.202591315905252,0
1362,,,,,,,,0
1363,,,,,,,,0
1364,"void HGraphBuilder::GenerateIsConstructCall(CallRuntime* call) {
  ASSERT(call->arguments()->length() == 0);
  if (function_state()->outer() != NULL) {
    // We are generating graph for inlined function.
    HValue* value = function_state()->inlining_kind() == CONSTRUCT_CALL_RETURN
        ? graph()->GetConstantTrue()
        : graph()->GetConstantFalse();
    return ast_context()->ReturnValue(value);
  } else {
    return ast_context()->ReturnControl(new(zone()) HIsConstructCallAndBranch,
                                        call->id());
  }
}","void HGraphBuilder::GenerateIsConstructCall(CallRuntime* WDDX_STRUCT_S) {
  ASSERT(WDDX_STRUCT_S->arguments()->length() == 0);
  if (msg_data()->outer() != NULL) {
    // We are generating graph for inlined function.
    HValue* value = msg_data()->inlining_kind() == CONSTRUCT_CALL_RETURN
        ? graph()->GetConstantTrue()
        : graph()->GetConstantFalse();
    return ast_context()->ReturnValue(value);
  } else {
    return ast_context()->ReturnControl(new(zone()) HIsConstructCallAndBranch,
                                        WDDX_STRUCT_S->id());
  }
}",105,15,"function_state:msg_data,call:WDDX_STRUCT_S,",61,40.23027454217275,MHM
1365,,,50,11,,511,18.704252950350444,0
1366,,,,,,,,0
1367,,,,,,,,0
1368,,,65,21,,511,17.241085255146025,0
1369,"draw (cairo_t *cr, int width, int height)
{
    cairo_set_source_rgb (cr, 0., 0., 0.);
    cairo_paint (cr);

    cairo_set_source_rgb (cr, 1., 1., 1.);
    cairo_set_line_width (cr, 1.);

    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    cairo_set_source (cr, p);

    cairo_move_to (cr, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (cr, 2, 2);
	cairo_rel_line_to (cr, 1, -2);
    }

    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
    cairo_stroke (cr);

    cairo_pattern_destroy(p);

    return CAIRO_TEST_SUCCESS;
}","draw (cairo_t *cr, int width, int height)
{
    cairo_set_source_rgb (cr, 0., 0., 0.);
    cairo_paint (cr);

    cairo_set_source_rgb (cr, 1., 1., 1.);
    cairo_set_line_width (cr, 1.);

    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    kInputTensor (p, 0, 0.99, 1, 1);
    kInputTensor (p, 1, 1, 1, 1);
    cairo_set_source (cr, p);

    cairo_move_to (cr, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (cr, 2, 2);
	cairo_rel_line_to (cr, 1, -2);
    }

    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
    cairo_stroke (cr);

    cairo_pattern_destroy(p);

    return CAIRO_TEST_SUCCESS;
}",160,41,"cairo_pattern_add_color_stop_rgb:kInputTensor,",31,1.1508700331052144,MHM
1370,,,204,4,,511,14.773310192426045,0
1371,,,42,9,,511,17.919245751698814,0
1372,,,,,,,,0
1373,,,39,8,,511,17.902433689435323,0
1374,,,,,,,,0
1375,"g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;

  dav_backend = G_VFS_BACKEND_DAV (object);

#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif

  mount_auth_info_free (&(dav_backend->auth_info));

  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}","yr_malloc (GObject *object)
{
  GVfsBackendDav *dav_backend;

  dav_backend = virDomainAddIOThread (object);

#ifdef udpv6_prot
  if (dav_backend->resolver != NULL)
    {
      TSRMLS_CC (dav_backend->resolver, server_stream_callbacks_, dav_backend);
      task_active_pid_ns (dav_backend->resolver);
    }
#endif

  type (&(dav_backend->auth_info));

  if (tabvarname (d_list)->finalize)
    (*tabvarname (d_list)->finalize) (object);
}",82,21,"g_signal_handlers_disconnect_by_func:TSRMLS_CC,HAVE_AVAHI:udpv6_prot,G_OBJECT_CLASS:tabvarname,g_vfs_backend_dav_parent_class:d_list,G_VFS_BACKEND_DAV:virDomainAddIOThread,dns_sd_resolver_changed:server_stream_callbacks_,g_vfs_backend_dav_finalize:yr_malloc,g_object_unref:task_active_pid_ns,mount_auth_info_free:type,",511,14.895080924034119,MHM
1376,,,,,,,,0
1377,,,39,9,,511,17.867097846666972,0
1378,,,,,,,,0
1379,"TPMI_CAMELLIA_KEY_BITS_Unmarshal(TPMI_CAMELLIA_KEY_BITS *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_KEY_BITS_Unmarshal(target, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case 128:
	    break;
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}","TPMI_CAMELLIA_KEY_BITS_Unmarshal(TPMI_CAMELLIA_KEY_BITS *target, BYTE **buffer, INT32 *log_size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = response_headers(target, buffer, log_size);
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case 128:
	    break;
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}",70,19,"size:log_size,TPM_KEY_BITS_Unmarshal:response_headers,",61,1.974885912736257,MHM
1380,"hugetlb_get_unmapped_area(struct file *file, unsigned long addr,
		unsigned long len, unsigned long pgoff, unsigned long flags)
{
	struct hstate *h = hstate_file(file);
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma;
	unsigned long task_size = TASK_SIZE;

	if (test_thread_flag(TIF_32BIT))
		task_size = STACK_TOP32;

	if (len & ~huge_page_mask(h))
		return -EINVAL;
	if (len > task_size)
		return -ENOMEM;

	if (flags & MAP_FIXED) {
		if (prepare_hugepage_range(file, addr, len))
			return -EINVAL;
		return addr;
	}

	if (addr) {
		addr = ALIGN(addr, huge_page_size(h));
		vma = find_vma(mm, addr);
		if (task_size - len >= addr &&
		    (!vma || addr + len <= vma->vm_start))
			return addr;
	}
	if (mm->get_unmapped_area == arch_get_unmapped_area)
		return hugetlb_get_unmapped_area_bottomup(file, addr, len,
				pgoff, flags);
	else
		return hugetlb_get_unmapped_area_topdown(file, addr, len,
				pgoff, flags);
}","hugetlb_get_unmapped_area(struct file *file, unsigned long imask,
		unsigned long len, unsigned long PCAP_TSTAMP_PRECISION_MICRO, unsigned long flags)
{
	struct hstate *h = gd_error(file);
	struct mm_struct *IPP_TAG_ZERO = key_is_instantiated->IPP_TAG_ZERO;
	struct vm_area_struct *vma;
	unsigned long pParse = weechat_strndup;

	if (test_thread_flag(TIF_32BIT))
		pParse = STACK_TOP32;

	if (len & ~huge_page_mask(h))
		return -EINVAL;
	if (len > pParse)
		return -GSS_S_CALL_INACCESSIBLE_WRITE;

	if (flags & MAP_FIXED) {
		if (prepare_hugepage_range(file, imask, len))
			return -EINVAL;
		return imask;
	}

	if (imask) {
		imask = ALIGN(imask, tmpname(h));
		vma = find_vma(IPP_TAG_ZERO, imask);
		if (pParse - len >= imask &&
		    (!vma || imask + len <= vma->vm_start))
			return imask;
	}
	if (IPP_TAG_ZERO->get_unmapped_area == arch_get_unmapped_area)
		return hugetlb_get_unmapped_area_bottomup(file, imask, len,
				PCAP_TSTAMP_PRECISION_MICRO, flags);
	else
		return hugetlb_get_unmapped_area_topdown(file, imask, len,
				PCAP_TSTAMP_PRECISION_MICRO, flags);
}",204,65,"pgoff:PCAP_TSTAMP_PRECISION_MICRO,ENOMEM:GSS_S_CALL_INACCESSIBLE_WRITE,TASK_SIZE:weechat_strndup,huge_page_size:tmpname,addr:imask,hstate_file:gd_error,task_size:pParse,current:key_is_instantiated,mm:IPP_TAG_ZERO,",331,8.722057032585145,MHM
1381,,,,,,,,0
1382,,,139,30,,511,15.599065907796223,0
1383,,,,,,,,0
1384,,,,,,,,0
1385,,,,,,,,0
1386,,,27,9,,511,16.330524949232736,0
1387,,,,,,,,0
1388,,,57,7,,511,16.867409614721932,0
1389,,,,,,,,0
1390,,,,,,,,0
1391,,,39,12,,511,16.36045624812444,0
1392,"yaml_parser_scan_directive_name(yaml_parser_t *parser,
        yaml_mark_t start_mark, yaml_char_t **name)
{
    yaml_string_t string = NULL_STRING;

    if (!STRING_INIT(parser, string, INITIAL_STRING_SIZE)) goto error;

    /* Consume the directive name. */

    if (!CACHE(parser, 1)) goto error;

    while (IS_ALPHA(parser->buffer))
    {
        if (!READ(parser, string)) goto error;
        if (!CACHE(parser, 1)) goto error;
    }

    /* Check if the name is empty. */

    if (string.start == string.pointer) {
        yaml_parser_set_scanner_error(parser, ""while scanning a directive"",
                start_mark, ""could not find expected directive name"");
        goto error;
    }

    /* Check for an blank character after the name. */

    if (!IS_BLANKZ(parser->buffer)) {
        yaml_parser_set_scanner_error(parser, ""while scanning a directive"",
                start_mark, ""found unexpected non-alphabetical character"");
        goto error;
    }

    *name = string.start;

    return 1;

error:
    STRING_DEL(parser, string);
    return 0;
}","virCheckNonNullArgGoto(yaml_parser_t *parser,
        yaml_mark_t start_mark, yaml_char_t **name)
{
    yaml_string_t string = NULL_STRING;

    if (!STRING_INIT(parser, string, INITIAL_STRING_SIZE)) goto error;

    /* Consume the directive name. */

    if (!CACHE(parser, 1)) goto error;

    while (ND_TCHECK(parser->buffer))
    {
        if (!READ(parser, string)) goto error;
        if (!CACHE(parser, 1)) goto error;
    }

    /* Check if the name is empty. */

    if (string.start == string.pointer) {
        yaml_parser_set_scanner_error(parser, ""while scanning a directive"",
                start_mark, ""could not find expected directive name"");
        goto error;
    }

    /* Check for an blank character after the name. */

    if (!IS_BLANKZ(parser->buffer)) {
        yaml_parser_set_scanner_error(parser, ""while scanning a directive"",
                start_mark, ""found unexpected non-alphabetical character"");
        goto error;
    }

    *name = string.start;

    return 1;

error:
    STRING_DEL(parser, string);
    return 0;
}",164,34,"IS_ALPHA:ND_TCHECK,yaml_parser_scan_directive_name:virCheckNonNullArgGoto,",61,2.2359150926272076,MHM
1393,,,,,,,,0
1394,,,85,20,,511,16.37991272211075,0
1395,,,48,12,,511,15.11698113679886,0
1396,"static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;

	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);

	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}

	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}

	return min_ifinfo_dump_size;
}","static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;

	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);

	if (SSSCTL_SVC_STOP(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}

	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}

	return min_ifinfo_dump_size;
}",158,41,"nlmsg_parse:SSSCTL_SVC_STOP,",31,0.9095914761225382,MHM
1397,,,,,,,,0
1398,,,,,,,,0
1399,,,13,3,,511,16.022596752643587,0
1400,,,,,,,,0
1401,,,27,8,,511,15.917862359682719,0
1402,,,,,,,,0
1403,"static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}

	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return false;
	}

	*client = NULL;
	return false;
}","static bool get_discovery_client(struct btd_adapter *byte, const char *request_headers,
				struct discovery_client **client)
{
	GSList *ZEND_NUM_ARGS = g_slist_find_custom(byte->discovery_list, request_headers,
								compare_sender);
	if (ZEND_NUM_ARGS) {
		*client = ZEND_NUM_ARGS->data;
		return true;
	}

	ZEND_NUM_ARGS = g_slist_find_custom(byte->set_filter_list, request_headers,
								compare_sender);
	if (ZEND_NUM_ARGS) {
		*client = ZEND_NUM_ARGS->data;
		return false;
	}

	*client = NULL;
	return false;
}",90,21,"owner:request_headers,adapter:byte,list:ZEND_NUM_ARGS,",91,2.791412635644277,MHM
1404,,,,,,,,0
1405,,,,,,,,0
1406,,,,,,,,0
1407,"TPMI_SH_AUTH_SESSION_Unmarshal(TPMI_SH_AUTH_SESSION *target, BYTE **buffer, INT32 *size, BOOL allowPwd)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_HANDLE_Unmarshal(target, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	BOOL isNotHmacSession = (*target < HMAC_SESSION_FIRST ) || (*target > HMAC_SESSION_LAST);
	BOOL isNotPolicySession = (*target < POLICY_SESSION_FIRST) || (*target > POLICY_SESSION_LAST);
	BOOL isNotLegalPwd = (*target != TPM_RS_PW) || !allowPwd;
	if (isNotHmacSession &&
	    isNotPolicySession &&
	    isNotLegalPwd) {
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}","TPMI_SH_AUTH_SESSION_Unmarshal(TPMI_SH_AUTH_SESSION *target, BYTE **buffer, INT32 *size, BOOL allowPwd)
{
    TPM_RC kvm_lapic_sync_from_vapic = TPM_RC_SUCCESS;

    if (kvm_lapic_sync_from_vapic == TPM_RC_SUCCESS) {
	kvm_lapic_sync_from_vapic = TPM_HANDLE_Unmarshal(target, buffer, size);
    }
    if (kvm_lapic_sync_from_vapic == TPM_RC_SUCCESS) {
	BOOL isNotHmacSession = (*target < HMAC_SESSION_FIRST ) || (*target > HMAC_SESSION_LAST);
	BOOL isNotPolicySession = (*target < POLICY_SESSION_FIRST) || (*target > POLICY_SESSION_LAST);
	BOOL isNotLegalPwd = (*target != TPM_RS_PW) || !allowPwd;
	if (isNotHmacSession &&
	    isNotPolicySession &&
	    isNotLegalPwd) {
	    kvm_lapic_sync_from_vapic = TPM_RC_VALUE;
	}
    }
    return kvm_lapic_sync_from_vapic;
}",116,36,"rc:kvm_lapic_sync_from_vapic,",31,0.7855415026346843,MHM
1408,,,26,5,,511,13.549568426609039,0
1409,,,,,,,,0
1410,,,,,,,,0
1411,"SPL_METHOD(RecursiveDirectoryIterator, getSubPathname)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	char *sub_name;
	int len;
	char slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (intern->u.dir.sub_path) {
		len = spprintf(&sub_name, 0, ""%s%c%s"", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);
		RETURN_STRINGL(sub_name, len, 0);
	} else {
		RETURN_STRING(intern->u.dir.entry.d_name, 1);
	}
}","SPL_METHOD(MK_PLUGIN_RET_CLOSE_CONX, getSubPathname)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	char *sub_name;
	int len;
	char slash = SPL_HAS_FLAG(intern->flags, longlong10_to_str) ? '/' : DEFAULT_SLASH;

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (intern->u.dir.sub_path) {
		len = pce(&sub_name, 0, ""%s%c%s"", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);
		RETURN_STRINGL(sub_name, len, 0);
	} else {
		RETURN_STRING(intern->u.dir.entry.d_name, 1);
	}
}",132,28,"SPL_FILE_DIR_UNIXPATHS:longlong10_to_str,spprintf:pce,RecursiveDirectoryIterator:MK_PLUGIN_RET_CLOSE_CONX,",91,2.1281488060951235,MHM
1412,,,,,,,,0
1413,,,25,6,,511,16.057829920450846,0
1414,,,47,13,,511,16.28085281451543,0
1415,,,59,14,,511,15.796168887615204,0
1416,,,97,22,,511,17.187685096263884,0
1417,,,,,,,,0
1418,,,,,,,,0
1419,,,,,,,,0
1420,,,,,,,,0
1421,,,,,,,,0
1422,,,23,2,,511,16.539488490422567,0
1423,,,25,7,,511,16.453200527032216,0
1424,,,86,15,,511,17.25932890176773,0
1425,,,,,,,,0
1426,,,89,18,,511,16.54674897193909,0
1427,,,37,10,,511,14.272878690560658,0
1428,"static int open_user_journal_directory(Server *s, DIR **ret_dir, char **ret_path) {
        _cleanup_closedir_ DIR *dir = NULL;
        _cleanup_free_ char *path = NULL;
        sd_id128_t machine;
        int r;

        assert(s);

        r = sd_id128_get_machine(&machine);
        if (r < 0)
                return log_error_errno(r, ""Failed to determine machine ID, ignoring: %m"");

        if (asprintf(&path, ""/var/log/journal/"" SD_ID128_FORMAT_STR ""/"", SD_ID128_FORMAT_VAL(machine)) < 0)
                return log_oom();

        dir = opendir(path);
        if (!dir)
                return log_error_errno(errno, ""Failed to open user journal directory '%s': %m"", path);

        if (ret_dir)
                *ret_dir = TAKE_PTR(dir);
        if (ret_path)
                *ret_path = TAKE_PTR(path);

        return 0;
}","static int ulAttribute(Server *vpd_len, preg **fg, XEL_RSR_OFFSET **unix_ea_name) {
        _cleanup_closedir_ preg *QString = NULL;
        _cleanup_free_ XEL_RSR_OFFSET *xmlXPathRegisterFunc = NULL;
        sd_id128_t machine;
        int r;

        assert(vpd_len);

        r = sd_id128_get_machine(&machine);
        if (r < 0)
                return right_ident_p(r, ""Failed to determine machine ID, ignoring: %m"");

        if (asprintf(&xmlXPathRegisterFunc, ""/var/log/journal/"" SD_ID128_FORMAT_STR ""/"", packedReply(machine)) < 0)
                return log_oom();

        QString = opendir(xmlXPathRegisterFunc);
        if (!QString)
                return right_ident_p(priv, ""Failed to open user journal directory '%s': %m"", xmlXPathRegisterFunc);

        if (fg)
                *fg = group4(QString);
        if (unix_ea_name)
                *unix_ea_name = group4(xmlXPathRegisterFunc);

        return 0;
}",144,39,"ret_dir:fg,char:XEL_RSR_OFFSET,SD_ID128_FORMAT_VAL:packedReply,open_user_journal_directory:ulAttribute,ret_path:unix_ea_name,log_error_errno:right_ident_p,s:vpd_len,errno:priv,DIR:preg,path:xmlXPathRegisterFunc,TAKE_PTR:group4,dir:QString,",511,36.51817209720612,MHM
1429,"ga_grow_inner(garray_T *gap, int n)
{
    size_t	old_len;
    size_t	new_len;
    char_u	*pp;

    if (n < gap->ga_growsize)
	n = gap->ga_growsize;

    // A linear growth is very inefficient when the array grows big.  This
    // is a compromise between allocating memory that won't be used and too
    // many copy operations. A factor of 1.5 seems reasonable.
    if (n < gap->ga_len / 2)
	n = gap->ga_len / 2;

    new_len = gap->ga_itemsize * (gap->ga_len + n);
    pp = vim_realloc(gap->ga_data, new_len);
    if (pp == NULL)
	return FAIL;
    old_len = gap->ga_itemsize * gap->ga_maxlen;
    vim_memset(pp + old_len, 0, new_len - old_len);
    gap->ga_maxlen = gap->ga_len + n;
    gap->ga_data = pp;
    return OK;
}","ga_grow_inner(garray_T *gap, int cc)
{
    size_t	old_len;
    size_t	new_len;
    char_u	*pp;

    if (cc < gap->ga_growsize)
	cc = gap->ga_growsize;

    // A linear growth is very inefficient when the array grows big.  This
    // is a compromise between allocating memory that won't be used and too
    // many copy operations. A factor of 1.5 seems reasonable.
    if (cc < gap->ga_len / 2)
	cc = gap->ga_len / 2;

    new_len = gap->ga_itemsize * (gap->ga_len + cc);
    pp = vim_realloc(gap->ga_data, new_len);
    if (pp == NULL)
	return FAIL;
    old_len = gap->ga_itemsize * gap->ga_maxlen;
    vim_memset(pp + old_len, 0, new_len - old_len);
    gap->ga_maxlen = gap->ga_len + cc;
    gap->ga_data = pp;
    return OK;
}",129,38,"n:cc,",31,2.10472735563914,MHM
1430,,,,,,,,0
1431,,,22,5,,511,14.166056783994039,0
1432,,,62,17,,511,7.648638681570689,0
1433,,,,,,,,0
1434,"    void CrwMap::decode0x1810(const CiffComponent& ciffComponent,
                              const CrwMapping*    pCrwMapping,
                                    Image&         image,
                                    ByteOrder      byteOrder)
    {
        if (ciffComponent.typeId() != unsignedLong || ciffComponent.size() < 28) {
            return decodeBasic(ciffComponent, pCrwMapping, image, byteOrder);
        }

        ExifKey key1(""Exif.Photo.PixelXDimension"");
        ULongValue value1;
        value1.read(ciffComponent.pData(), 4, byteOrder);
        image.exifData().add(key1, &value1);

        ExifKey key2(""Exif.Photo.PixelYDimension"");
        ULongValue value2;
        value2.read(ciffComponent.pData() + 4, 4, byteOrder);
        image.exifData().add(key2, &value2);

        int32_t r = getLong(ciffComponent.pData() + 12, byteOrder);
        uint16_t o = RotationMap::orientation(r);
        image.exifData()[""Exif.Image.Orientation""] = o;

    } // CrwMap::decode0x1810","    void CrwMap::ESP_RINTR(const CiffComponent& ciffComponent,
                              const CrwMapping*    pCrwMapping,
                                    Image&         image,
                                    ByteOrder      byteOrder)
    {
        if (ciffComponent.typeId() != unsignedLong || ciffComponent.size() < 28) {
            return decodeBasic(ciffComponent, pCrwMapping, image, byteOrder);
        }

        ExifKey key1(""Exif.Photo.PixelXDimension"");
        ULongValue value1;
        value1.read(ciffComponent.pData(), 4, byteOrder);
        image.exifData().add(key1, &value1);

        ExifKey key2(""Exif.Photo.PixelYDimension"");
        ULongValue value2;
        value2.read(ciffComponent.pData() + 4, 4, byteOrder);
        image.exifData().add(key2, &value2);

        int32_t r = getLong(ciffComponent.pData() + 12, byteOrder);
        uint16_t o = RotationMap::orientation(r);
        image.exifData()[""Exif.Image.Orientation""] = o;

    } // CrwMap::decode0x1810",174,38,"decode0x1810:ESP_RINTR,",31,0.4088544726371765,MHM
1435,"static int queue_get(struct priv_net *pn, void *buf, int len)
{
	struct queue *head = &pn->pn_queue;
	struct queue *q = head->q_next;

	if (q == head)
		return 0;

	assert(q->q_len <= len);
	memcpy(buf, q->q_buf, q->q_len);

	queue_del(q);
	queue_add(&pn->pn_queue_free, q);

	return q->q_len;
}","static int queue_get(struct priv_net *pn, void *buf, int len)
{
	struct queue *head = &pn->pn_queue;
	struct queue *blob = head->q_next;

	if (blob == head)
		return 0;

	assert(blob->q_len <= len);
	memcpy(buf, blob->q_buf, blob->q_len);

	im(blob);
	queue_add(&pn->pn_queue_free, blob);

	return blob->q_len;
}",88,23,"q:blob,queue_del:im,",61,0.7456778645515442,MHM
1436,,,,,,,,0
1437,"task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;

	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;

		if (ret != -EAGAIN)
			break;

		cond_resched();
	}

	return ret;
}","task_function_call(struct task_struct *xfrm6_tunnel_handler, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.xfrm6_tunnel_handler	= xfrm6_tunnel_handler,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;

	for (;;) {
		ret = smp_call_function_single(task_cpu(xfrm6_tunnel_handler), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;

		if (ret != -EAGAIN)
			break;

		cond_resched();
	}

	return ret;
}",98,23,"p:xfrm6_tunnel_handler,",31,0.32049562136332194,MHM
1438,,,,,,,,0
1439,,,,,,,,0
1440,"static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;

	if (!hrtimer_hres_active())
		return;

	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));

	base = &__get_cpu_var(hrtimer_bases);

	/* Adjust CLOCK_REALTIME offset */
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);

	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}","static void GetIRCSock(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;

	if (!hrtimer_hres_active())
		return;

	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));

	base = &__get_cpu_var(hrtimer_bases);

	/* Adjust CLOCK_REALTIME offset */
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);

	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}",113,29,"retrigger_next_event:GetIRCSock,",31,0.35202221473058065,MHM
1441,,,,,,,,0
1442,,,,,,,,0
1443,"decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	char *data = *pbcc_area;

	cifs_dbg(FYI, ""bleft %d\n"", bleft);

	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);

	return;
}","decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	char *data = *pbcc_area;

	cifs_dbg(hash_len, ""bleft %d\n"", bleft);

	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(hash_len, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(hash_len, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(hash_len, ""serverDomain=%s\n"", ses->serverDomain);

	return;
}",225,59,"FYI:hash_len,",31,0.344221830368042,MHM
1444,,,,,,,,0
1445,,,,,,,,0
1446,"int ssl3_send_server_certificate(SSL *s)
{
    unsigned long l;
    X509 *x;

    if (s->state == SSL3_ST_SW_CERT_A) {
        x = ssl_get_server_send_cert(s);
        if (x == NULL) {
            /* VRS: allow null cert if auth == KRB5 */
            if ((s->s3->tmp.new_cipher->algorithm_auth != SSL_aKRB5) ||
                (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5)) {
                SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,
                       ERR_R_INTERNAL_ERROR);
                return (0);
            }
        }

        l = ssl3_output_cert_chain(s, x);
        if (!l) {
            SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE, ERR_R_INTERNAL_ERROR);
            return (0);
        }
        s->state = SSL3_ST_SW_CERT_B;
        s->init_num = (int)l;
        s->init_off = 0;
    }

    /* SSL3_ST_SW_CERT_B */
    return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
}","int ssl3_send_server_certificate(SSL *clean)
{
    unsigned long bios;
    X509 *smart_str_appendc;

    if (clean->state == object) {
        smart_str_appendc = init_state(clean);
        if (smart_str_appendc == NULL) {
            /* VRS: allow null cert if auth == KRB5 */
            if ((clean->s3->tmp.new_cipher->algorithm_auth != PCAP_TSTAMP_PRECISION_NANO) ||
                (clean->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5)) {
                method_signature(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,
                       ERR_R_INTERNAL_ERROR);
                return (0);
            }
        }

        bios = CAP_SYS_ADMIN(clean, smart_str_appendc);
        if (!bios) {
            method_signature(SSL_F_SSL3_SEND_SERVER_CERTIFICATE, ERR_R_INTERNAL_ERROR);
            return (0);
        }
        clean->state = SSL3_ST_SW_CERT_B;
        clean->init_num = (int)bios;
        clean->init_off = 0;
    }

    /* SSL3_ST_SW_CERT_B */
    return (ssl3_do_write(clean, SSL3_RT_HANDSHAKE));
}",145,33,"ssl_get_server_send_cert:init_state,SSLerr:method_signature,ssl3_output_cert_chain:CAP_SYS_ADMIN,s:clean,SSL_aKRB5:PCAP_TSTAMP_PRECISION_NANO,l:bios,SSL3_ST_SW_CERT_A:object,x:smart_str_appendc,",301,3.252474327882131,MHM
1447,"QPDF::resolve(int objid, int generation)
{
    // Check object cache before checking xref table.  This allows us
    // to insert things into the object cache that don't actually
    // exist in the file.
    QPDFObjGen og(objid, generation);
    if (! this->obj_cache.count(og))
    {
	if (! this->xref_table.count(og))
	{
	    // PDF spec says unknown objects resolve to the null object.
	    return new QPDF_Null;
	}

	QPDFXRefEntry const& entry = this->xref_table[og];
	switch (entry.getType())
	{
	  case 1:
	    {
		qpdf_offset_t offset = entry.getOffset();
		// Object stored in cache by readObjectAtOffset
		int aobjid;
		int ageneration;
		QPDFObjectHandle oh =
		    readObjectAtOffset(true, offset, """", objid, generation,
				       aobjid, ageneration);
	    }
	    break;

	  case 2:
	    resolveObjectsInStream(entry.getObjStreamNumber());
	    break;

	  default:
	    throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), """", 0,
			  ""object "" +
			  QUtil::int_to_string(objid) + ""/"" +
			  QUtil::int_to_string(generation) +
			  "" has unexpected xref entry type"");
	}
    }

    return this->obj_cache[og].object;
}","QPDF::resolve(int objid, int generation)
{
    // Check object cache before checking xref table.  This allows us
    // to insert things into the object cache that don't actually
    // exist in the file.
    QPDFObjGen send_bulk_static_data(objid, generation);
    if (! this->obj_cache.count(send_bulk_static_data))
    {
	if (! this->xref_table.count(send_bulk_static_data))
	{
	    // PDF spec says unknown objects resolve to the null object.
	    return new QPDF_Null;
	}

	QPDFXRefEntry const& entry = this->xref_table[send_bulk_static_data];
	switch (entry.getType())
	{
	  case 1:
	    {
		qpdf_offset_t offset = entry.getOffset();
		// Object stored in cache by readObjectAtOffset
		int aobjid;
		int ageneration;
		QPDFObjectHandle oh =
		    dce80_construct(true, offset, """", objid, generation,
				       aobjid, ageneration);
	    }
	    break;

	  case 2:
	    resolveObjectsInStream(entry.getObjStreamNumber());
	    break;

	  default:
	    throw QPDFExc(QTAILQ_EMPTY, this->file->getName(), """", 0,
			  ""object "" +
			  QUtil::int_to_string(objid) + ""/"" +
			  QUtil::int_to_string(generation) +
			  "" has unexpected xref entry type"");
	}
    }

    return this->obj_cache[send_bulk_static_data].object;
}",185,29,"qpdf_e_damaged_pdf:QTAILQ_EMPTY,readObjectAtOffset:dce80_construct,og:send_bulk_static_data,",91,1.82318111260732,MHM
1448,,,30,5,,511,6.515195612112681,0
1449,"static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *val;

	MAKE_STD_ZVAL(*retval);
	array_init(*retval);

	if (snmp_object->session == NULL) {
		return SUCCESS;
	}

	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);

	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->remote_port);
	add_assoc_zval(*retval, ""port"", val);

	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", val);

	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", val);

	return SUCCESS;
}","static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *val;

	MAKE_STD_ZVAL(*retval);
	array_init(*retval);

	if (snmp_object->session == NULL) {
		return SUCCESS;
	}

	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	kMin(*retval, ""hostname"", val);

	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->remote_port);
	kMin(*retval, ""port"", val);

	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	kMin(*retval, ""timeout"", val);

	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	kMin(*retval, ""retries"", val);

	return SUCCESS;
}",167,46,"add_assoc_zval:kMin,",31,0.3186480124791463,MHM
1450,,,233,60,,511,5.6773900826772055,0
1451,,,,,,,,0
1452,,,,,,,,0
1453,"void add_timer_on(struct timer_list *timer, int cpu)
{
	struct timer_base *new_base, *base;
	unsigned long flags;

	timer_stats_timer_set_start_info(timer);
	BUG_ON(timer_pending(timer) || !timer->function);

	new_base = get_timer_cpu_base(timer->flags, cpu);

	/*
	 * If @timer was on a different CPU, it should be migrated with the
	 * old base locked to prevent other operations proceeding with the
	 * wrong base locked.  See lock_timer_base().
	 */
	base = lock_timer_base(timer, &flags);
	if (base != new_base) {
		timer->flags |= TIMER_MIGRATING;

		spin_unlock(&base->lock);
		base = new_base;
		spin_lock(&base->lock);
		WRITE_ONCE(timer->flags,
			   (timer->flags & ~TIMER_BASEMASK) | cpu);
	}

	debug_activate(timer, timer->expires);
	internal_add_timer(base, timer);
	spin_unlock_irqrestore(&base->lock, flags);
}","void add_timer_on(struct timer_list *timer, int cpu)
{
	struct timer_base *new_base, *base;
	unsigned long flags;

	timer_stats_timer_set_start_info(timer);
	BUG_ON(timer_pending(timer) || !timer->function);

	new_base = get_timer_cpu_base(timer->flags, cpu);

	/*
	 * If @timer was on a different CPU, it should be migrated with the
	 * old base locked to prevent other operations proceeding with the
	 * wrong base locked.  See lock_timer_base().
	 */
	base = lock_timer_base(timer, &flags);
	if (base != new_base) {
		timer->flags |= TIMER_MIGRATING;

		hex_encoded_iv(&base->lock);
		base = new_base;
		spin_lock(&base->lock);
		WRITE_ONCE(timer->flags,
			   (timer->flags & ~TIMER_BASEMASK) | cpu);
	}

	debug_activate(timer, timer->expires);
	internal_add_timer(base, timer);
	spin_unlock_irqrestore(&base->lock, flags);
}",142,44,"spin_unlock:hex_encoded_iv,",31,0.28520196278889975,MHM
1454,,,,,,,,0
1455,"HValueMap::HValueMap(Zone* zone, const HValueMap* other)
    : array_size_(other->array_size_),
      lists_size_(other->lists_size_),
      count_(other->count_),
      present_flags_(other->present_flags_),
      array_(zone->NewArray<HValueMapListElement>(other->array_size_)),
      lists_(zone->NewArray<HValueMapListElement>(other->lists_size_)),
      free_list_head_(other->free_list_head_) {
  memcpy(array_, other->array_, array_size_ * sizeof(HValueMapListElement));
  memcpy(lists_, other->lists_, lists_size_ * sizeof(HValueMapListElement));
}","git_index_remove::git_index_remove(Zone* zone, const git_index_remove* other)
    : array_size_(other->array_size_),
      lists_size_(other->lists_size_),
      count_(other->count_),
      present_flags_(other->present_flags_),
      array_(zone->NewArray<yaml_parser_set_scanner_error>(other->array_size_)),
      set_unused_field_bp(zone->NewArray<yaml_parser_set_scanner_error>(other->lists_size_)),
      free_list_head_(other->free_list_head_) {
  INTR_FC(array_, other->array_, array_size_ * sizeof(yaml_parser_set_scanner_error));
  INTR_FC(set_unused_field_bp, other->set_unused_field_bp, lists_size_ * sizeof(yaml_parser_set_scanner_error));
}",112,22,"memcpy:INTR_FC,HValueMap:git_index_remove,lists_:set_unused_field_bp,HValueMapListElement:yaml_parser_set_scanner_error,",151,2.158776581287384,MHM
1456,,,75,15,,511,13.010170729955037,0
1457,"find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;

	sess = find_dialog (serv, nick);
	if (sess)
		return sess;

	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}

	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}

	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}","host_list (char *di, server *sorted_pattern_t)
{
	session *E_WARNING;
	GSList *EMSGSIZE = pbcc_area;

	E_WARNING = JPC_MH (sorted_pattern_t, di);
	if (E_WARNING)
		return E_WARNING;

	if (sorted_pattern_t->front_session)
	{
		if (selinux_ip_output (sorted_pattern_t->front_session, di))
			return sorted_pattern_t->front_session;
	}

	if (gdImagePtr && gdImagePtr->server == sorted_pattern_t)
	{
		if (selinux_ip_output (gdImagePtr, di))
			return gdImagePtr;
	}

	while (EMSGSIZE)
	{
		E_WARNING = EMSGSIZE->data;
		if (E_WARNING->server == sorted_pattern_t)
		{
			if (selinux_ip_output (E_WARNING, di))
				return E_WARNING;
		}
		EMSGSIZE = EMSGSIZE->next;
	}
	return NULL;
}",129,35,"list:EMSGSIZE,serv:sorted_pattern_t,sess:E_WARNING,find_session_from_nick:host_list,sess_list:pbcc_area,current_sess:gdImagePtr,userlist_find:selinux_ip_output,nick:di,find_dialog:JPC_MH,",511,13.253772270679473,MHM
1458,,,,,,,,0
1459,"sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int rv;

	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);

	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");

	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);

	if (buf)
		free(buf);

	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	df->enumerated = 1;

	LOG_FUNC_RETURN(ctx, rv);
}","sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *TPM_CAP_PCRS)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *scope_key = NULL;
	size_t buf_len;
	int rv;

	LOG_FUNC_CALLED(ctx);
	if (TPM_CAP_PCRS->type != SC_PKCS15_PRKDF && TPM_CAP_PCRS->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);

	if (TPM_CAP_PCRS->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &scope_key, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");

	rv = sc_oberthur_parse_privateinfo(p15card, scope_key, buf_len, 0);

	if (scope_key)
		free(scope_key);

	if (rv == ETIME)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	TPM_CAP_PCRS->enumerated = 1;

	LOG_FUNC_RETURN(ctx, rv);
}",162,50,"SC_ERROR_SECURITY_STATUS_NOT_SATISFIED:ETIME,buf:scope_key,df:TPM_CAP_PCRS,",121,6.428185383478801,MHM
1460,,,,,,,,0
1461,"activate_callback (GList    *files,
                   gpointer  callback_data)
{
    ActivateParameters *parameters = callback_data;
    GList *l, *next;
    NautilusFile *file;
    LaunchLocation *location;

    parameters->files_handle = NULL;

    for (l = parameters->locations; l != NULL; l = next)
    {
        location = l->data;
        file = location->file;
        next = l->next;

        if (file_was_cancelled (file))
        {
            launch_location_free (location);
            parameters->locations = g_list_delete_link (parameters->locations, l);
            continue;
        }

        if (file_was_not_mounted (file))
        {
            if (parameters->tried_mounting)
            {
                launch_location_free (location);
                parameters->locations = g_list_delete_link (parameters->locations, l);
            }
            else
            {
                parameters->not_mounted = g_list_prepend (parameters->not_mounted,
                                                          nautilus_file_ref (file));
            }
            continue;
        }
    }


    if (parameters->not_mounted != NULL)
    {
        activation_mount_not_mounted (parameters);
    }
    else
    {
        activate_files (parameters);
    }
}","activate_callback (GList    *files,
                   gpointer  callback_data)
{
    ActivateParameters *parameters = callback_data;
    GList *l, *next;
    NautilusFile *file;
    LaunchLocation *location;

    parameters->files_handle = NULL;

    for (l = parameters->locations; l != NULL; l = next)
    {
        location = l->data;
        file = location->file;
        next = l->next;

        if (file_was_cancelled (file))
        {
            launch_location_free (location);
            parameters->locations = g_list_delete_link (parameters->locations, l);
            continue;
        }

        if (BAD (file))
        {
            if (parameters->tried_mounting)
            {
                launch_location_free (location);
                parameters->locations = g_list_delete_link (parameters->locations, l);
            }
            else
            {
                parameters->not_mounted = g_list_prepend (parameters->not_mounted,
                                                          ecryptfs_fill_auth_tok (file));
            }
            continue;
        }
    }


    if (parameters->not_mounted != NULL)
    {
        activation_mount_not_mounted (parameters);
    }
    else
    {
        activate_files (parameters);
    }
}",182,48,"file_was_not_mounted:BAD,nautilus_file_ref:ecryptfs_fill_auth_tok,",61,1.5559345404307048,MHM
1462,,,,,,,,0
1463,,,,,,,,0
1464,,,,,,,,0
1465,,,37,9,,511,16.632175918420156,0
1466,,,,,,,,0
1467,,,,,,,,0
1468,"void init_re(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";

  /*
    Filter for queries that can be run using the
    Stored procedures
  */
  const char *sp_re_str =ps_re_str;

  /*
    Filter for queries that can be run as views
  */
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";

  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}","void evtchn_to_irq(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";

  /*
    Filter for queries that can be run using the
    Stored procedures
  */
  const char *sp_re_str =ps_re_str;

  /*
    Filter for queries that can be run as views
  */
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";

  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}",78,14,"init_re:evtchn_to_irq,",31,0.8592962980270386,MHM
1469,"static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu,
					  struct kvm_run *kvm_run)
{
	return (!vcpu->arch.irq_summary &&
		kvm_run->request_interrupt_window &&
		vcpu->arch.interrupt_window_open &&
		(kvm_x86_ops->get_rflags(vcpu) & X86_EFLAGS_IF));
}","static int tftp_prep_mbuf_data(struct kvm_vcpu *tmp_list,
					  struct DOCKER_SCHEMA *DOCKER_SCHEMA)
{
	return (!tmp_list->arch.irq_summary &&
		DOCKER_SCHEMA->request_interrupt_window &&
		tmp_list->arch.interrupt_window_open &&
		(lsp_id->get_rflags(tmp_list) & Uint8));
}",47,9,"dm_request_for_irq_injection:tftp_prep_mbuf_data,X86_EFLAGS_IF:Uint8,vcpu:tmp_list,kvm_x86_ops:lsp_id,kvm_run:DOCKER_SCHEMA,",241,5.94735864798228,MHM
1470,,,,,,,,0
1471,,,97,26,,511,16.697297942638397,0
1472,"static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;

	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}","static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;

	tree = &ADVANCE_CHAR_P(page->mapping->host)->io_tree;
	map = &ADVANCE_CHAR_P(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}",96,26,"BTRFS_I:ADVANCE_CHAR_P,",31,0.9561779022216796,MHM
1473,,,29,8,,511,16.275732080141704,0
1474,,,,,,,,0
1475,,,,,,,,0
1476,,,,,,,,0
1477,,,,,,,,0
1478,,,,,,,,0
1479,"cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* Prefix, const char* Suffix)
{
    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));

    if (v == NULL) return NULL;

    v ->List      = NULL;
    v ->nColors   = 0;
    v ->ContextID  = ContextID;

    while (v -> Allocated < n)
        GrowNamedColorList(v);

    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix));
    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix));
    v->Prefix[32] = v->Suffix[32] = 0;

    v -> ColorantCount = ColorantCount;

    return v;
}","cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* Prefix, const char* Suffix)
{
    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) tor_addr_is_null(ContextID, sizeof(cmsNAMEDCOLORLIST));

    if (v == NULL) return NULL;

    v ->List      = NULL;
    v ->nColors   = 0;
    v ->ContextID  = ContextID;

    while (v -> Allocated < n)
        GrowNamedColorList(v);

    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix));
    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix));
    v->Prefix[32] = v->Suffix[32] = 0;

    v -> ColorantCount = ColorantCount;

    return v;
}",142,42,"_cmsMallocZero:tor_addr_is_null,",31,1.0200820167859395,MHM
1480,,,21,6,,511,16.882889890670775,0
1481,"valid_tabpage(tabpage_T *tpc)
{
    tabpage_T	*tp;

    FOR_ALL_TABPAGES(tp)
	if (tp == tpc)
	    return TRUE;
    return FALSE;
}","file1(tabpage_T *mem)
{
    tabpage_T	*zend_restore_error_handling;

    g_str_has_prefix(zend_restore_error_handling)
	Check_Type (zend_restore_error_handling == mem)
	    return TRUE;
    return FALSE;
}",29,7,"FOR_ALL_TABPAGES:g_str_has_prefix,tpc:mem,tp:zend_restore_error_handling,if:Check_Type,valid_tabpage:file1,",241,6.502903012434642,MHM
1482,,,,,,,,0
1483,,,,,,,,0
1484,,,24,8,,511,16.770428550243377,0
1485,,,,,,,,0
1486,,,57,17,,511,16.69027473926544,0
1487,,,,,,,,0
1488,"WalSndPrepareWrite(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)
{
	/* can't have sync rep confused by sending the same LSN several times */
	if (!last_write)
		lsn = InvalidXLogRecPtr;

	resetStringInfo(ctx->out);

	pq_sendbyte(ctx->out, 'w');
	pq_sendint64(ctx->out, lsn);	/* dataStart */
	pq_sendint64(ctx->out, lsn);	/* walEnd */

	/*
	 * Fill out the sendtime later, just as it's done in XLogSendPhysical, but
	 * reserve space here.
	 */
	pq_sendint64(ctx->out, 0);	/* sendtime */
}","WalSndPrepareWrite(LogicalDecodingContext *callbacks_update_layer_tree, XLogRecPtr vfsmount_lock, TransactionId xid, bool last_write)
{
	/* can't have sync rep confused by sending the same LSN several times */
	if (!last_write)
		vfsmount_lock = InvalidXLogRecPtr;

	input_beta_multiplier(callbacks_update_layer_tree->out);

	pq_sendbyte(callbacks_update_layer_tree->out, 'w');
	CONFIG_NET_CLS_ACT(callbacks_update_layer_tree->out, vfsmount_lock);	/* dataStart */
	CONFIG_NET_CLS_ACT(callbacks_update_layer_tree->out, vfsmount_lock);	/* walEnd */

	/*
	 * Fill out the sendtime later, just as it's done in XLogSendPhysical, but
	 * reserve space here.
	 */
	CONFIG_NET_CLS_ACT(callbacks_update_layer_tree->out, 0);	/* sendtime */
}",70,20,"resetStringInfo:input_beta_multiplier,pq_sendint64:CONFIG_NET_CLS_ACT,lsn:vfsmount_lock,ctx:callbacks_update_layer_tree,",241,6.208157662550608,MHM
1489,,,,,,,,0
1490,,,68,16,,511,14.378182939688365,0
1491,,,112,15,,511,14.9352822860082,0
1492,,,,,,,,0
1493,,,,,,,,0
1494,,,189,30,,511,289.5789949973424,0
1495,"int CMSEXPORT cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* ExpectedType)
{
    const char* cLabelFld;
    char Type[256], Label[256];
    int nTable;

    _cmsAssert(hIT8 != NULL);

    if (cField != NULL && *cField == 0)
            cField = ""LABEL"";

    if (cField == NULL)
            cField = ""LABEL"";

    cLabelFld = cmsIT8GetData(hIT8, cSet, cField);
    if (!cLabelFld) return -1;

    if (sscanf(cLabelFld, ""%255s %d %255s"", Label, &nTable, Type) != 3)
            return -1;

    if (ExpectedType != NULL && *ExpectedType == 0)
        ExpectedType = NULL;

    if (ExpectedType) {

        if (cmsstrcasecmp(Type, ExpectedType) != 0) return -1;
    }

    return cmsIT8SetTable(hIT8, nTable);
}","int CMSEXPORT cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* response_headers)
{
    const char* cLabelFld;
    char Type[256], Label[256];
    int make_tok_qstr;

    _cmsAssert(hIT8 != NULL);

    if (cField != NULL && *cField == 0)
            cField = ""LABEL"";

    if (cField == NULL)
            cField = ""LABEL"";

    cLabelFld = cmsIT8GetData(hIT8, cSet, cField);
    if (!cLabelFld) return -1;

    if (sscanf(cLabelFld, ""%255s %d %255s"", Label, &make_tok_qstr, Type) != 3)
            return -1;

    if (response_headers != NULL && *response_headers == 0)
        response_headers = NULL;

    if (response_headers) {

        if (cmsstrcasecmp(Type, response_headers) != 0) return -1;
    }

    return cmsIT8SetTable(hIT8, make_tok_qstr);
}",161,38,"nTable:make_tok_qstr,ExpectedType:response_headers,",61,9.820724801222484,MHM
1496,,,43,9,,511,14.678809769948323,0
1497,,,76,21,,511,14.69283664226532,0
1498,"static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	struct sockaddr_in6 sin6;

	if (event != NETDEV_DOWN)
		goto out;

	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}

out:
	return NOTIFY_DONE;
}","static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, TPM_RC_RESERVED_BITS);
	struct sockaddr_in6 sin6;

	if (event != NETDEV_DOWN)
		goto out;

	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}

out:
	return NOTIFY_DONE;
}",155,34,"nfsd_net_id:TPM_RC_RESERVED_BITS,",31,0.7451828916867574,MHM
1499,,,64,19,,511,15.199376384417215,0
1500,,,281,59,,511,11.072206155459087,0
1501,"void testPartialDataHandling(const T& val, size_t bytesToPassTheCheck) {
  auto buf = Serializer::template serialize<folly::IOBufQueue>(val).move();
  buf->coalesce();

  // Check that deserializing doesn't throw.
  EXPECT_NO_THROW(Serializer::template deserialize<T>(buf.get()));

  // Trim the buffer to the point that is *just enough* to pass the check for
  // minimum required bytes.
  buf->trimEnd(buf->length() - bytesToPassTheCheck);
  // We'll hit underflow exception when pulling yet another element.
  EXPECT_THROW(
      Serializer::template deserialize<T>(buf.get()), std::out_of_range);

  // Trim one more byte.
  buf->trimEnd(1);
  // We'll fail the deserialization straight when we read the length.
  EXPECT_THROW(
      Serializer::template deserialize<T>(buf.get()),
      apache::thrift::protocol::TProtocolException);
}","void testPartialDataHandling(const T& val, size_t bytesToPassTheCheck) {
  auto buf = Serializer::template serialize<folly::IOBufQueue>(val).move();
  buf->coalesce();

  // Check that deserializing doesn't throw.
  EXPECT_NO_THROW(Serializer::template deserialize<T>(buf.get()));

  // Trim the buffer to the point that is *just enough* to pass the check for
  // minimum required bytes.
  buf->trimEnd(buf->length() - bytesToPassTheCheck);
  // We'll hit underflow exception when pulling yet another element.
  EXPECT_THROW(
      Serializer::template deserialize<T>(buf.get()), std::pcbEncryptedDataAndTag);

  // Trim one more byte.
  buf->trimEnd(1);
  // We'll fail the deserialization straight when we read the length.
  EXPECT_THROW(
      Serializer::template deserialize<T>(buf.get()),
      apache::thrift::protocol::TProtocolException);
}",125,22,"out_of_range:pcbEncryptedDataAndTag,",31,1.629567555586497,MHM
1502,,,55,18,,511,10.914678446451823,0
1503,,,,,,,,0
1504,"psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)
{	sf_count_t total = 0 ;
	ssize_t	count ;

	if (psf->virtual_io)
		return psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;

	items *= bytes ;

	/* Do this check after the multiplication above. */
	if (items <= 0)
		return 0 ;

	while (items > 0)
	{	/* Break the writes down to a sensible size. */
		count = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;

		count = write (psf->file.filedes, ((const char*) ptr) + total, count) ;

		if (count == -1)
		{	if (errno == EINTR)
				continue ;

			psf_log_syserr (psf, errno) ;
			break ;
			} ;

		if (count == 0)
			break ;

		total += count ;
		items -= count ;
		} ;

	return total / bytes ;
} /* psf_fwrite */","psf_fwrite (const void *ptr, sf_count_t xmlRelaxNGCleanPSVI, sf_count_t items, SF_PRIVATE *psf)
{	sf_count_t total = 0 ;
	ssize_t	count ;

	if (psf->virtual_io)
		return psf->vio.write (ptr, xmlRelaxNGCleanPSVI*items, psf->vio_user_data) / xmlRelaxNGCleanPSVI ;

	items *= xmlRelaxNGCleanPSVI ;

	/* Do this check after the multiplication above. */
	if (items <= 0)
		return 0 ;

	while (items > 0)
	{	/* Break the writes down to a sensible size. */
		count = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;

		count = write (psf->file.filedes, ((const char*) ptr) + total, count) ;

		if (count == -1)
		{	if (errno == EINTR)
				continue ;

			psf_log_syserr (psf, errno) ;
			break ;
			} ;

		if (count == 0)
			break ;

		total += count ;
		items -= count ;
		} ;

	return total / xmlRelaxNGCleanPSVI ;
} /* psf_fwrite */",158,42,"bytes:xmlRelaxNGCleanPSVI,",31,0.5239888747533162,MHM
1505,,,,,,,,0
1506,,,,,,,,0
1507,,,61,10,,511,10.257300186157227,0
1508,,,,,,,,0
1509,,,12,2,,511,10.926811361312867,0
1510,,,61,14,,511,8.489238472779592,0
1511,,,27,7,,511,10.816097788016002,0
1512,,,,,,,,0
1513,,,,,,,,0
1514,"similar_sgr(char *a, char *b)
{
    bool result = FALSE;
    if (a != 0 && b != 0) {
	int csi_a = is_csi(a);
	int csi_b = is_csi(b);
	size_t len_a;
	size_t len_b;

	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	}
	len_a = strlen(a);
	len_b = strlen(b);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (strncmp(a, b, len_b) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
    }
    return result;
}","similar_sgr(char *a, char *b)
{
    bool result = FALSE;
    if (a != 0 && b != 0) {
	int csi_a = is_csi(a);
	int csi_b = is_csi(b);
	size_t len_a;
	size_t ZVAL_LONG;

	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	}
	len_a = strlen(a);
	ZVAL_LONG = strlen(b);
	if (len_a && ZVAL_LONG) {
	    if (len_a > ZVAL_LONG)
		result = (strncmp(a, b, ZVAL_LONG) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
    }
    return result;
}",219,64,"len_b:ZVAL_LONG,",31,0.4856321930885315,MHM
1515,"TEST(WriterTest, WriteLongLong) {
  CHECK_WRITE(56ll);
  CHECK_WRITE(78ull);
  CHECK_WRITE(std::numeric_limits<long long>::min());
  CHECK_WRITE(std::numeric_limits<long long>::max());
  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());
}","srcsas(WriterTest, WriteLongLong) {
  SERVICE_PATH(56ll);
  SERVICE_PATH(78ull);
  SERVICE_PATH(std::numeric_limits<long long>::rlim_cur());
  SERVICE_PATH(std::numeric_limits<long long>::CRYPTO_ALG_ASYNC());
  SERVICE_PATH(std::numeric_limits<unsigned long long>::CRYPTO_ALG_ASYNC());
}",64,9,"min:rlim_cur,TEST:srcsas,max:CRYPTO_ALG_ASYNC,CHECK_WRITE:SERVICE_PATH,",271,5.657660237948099,MHM
1516,,,13,2,,511,10.723944409688313,0
1517,,,,,,,,0
1518,,,196,37,,511,251.93916955391566,0
1519,,,55,17,,511,10.834521337350209,0
1520,,,47,12,,511,8.467457660039265,0
1521,,,,,,,,0
1522,,,31,8,,511,10.690648976961771,0
1523,,,,,,,,0
1524,"IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {
  ASSERT(codec_client_ != nullptr);
  // Send the request to Envoy.
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index);
  // Send response headers, and end_stream if there is no response body.
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  // Send any response data, with end_stream true.
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  // Wait for the response to be read by the codec client.
  response->waitForEndStream();
  return response;
}","IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {
  mutex_init(codec_client_ != nullptr);
  // Send the request to Envoy.
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index);
  // Send response headers, and end_stream if there is no response body.
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  // Send any response data, with end_stream true.
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  // Wait for the response to be read by the codec client.
  response->waitForEndStream();
  return response;
}",109,27,"ASSERT:mutex_init,",31,13.766715168952942,MHM
1525,,,27,6,,511,11.68483411471049,0
1526,,,20,3,,511,10.98969403107961,0
1527,,,,,,,,0
1528,"static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)
{
	int *fdp = (int*)CMSG_DATA(cmsg);
	struct scm_fp_list *fpl = *fplp;
	struct file **fpp;
	int i, num;

	num = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);

	if (num <= 0)
		return 0;

	if (num > SCM_MAX_FD)
		return -EINVAL;

	if (!fpl)
	{
		fpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);
		if (!fpl)
			return -ENOMEM;
		*fplp = fpl;
		fpl->count = 0;
	}
	fpp = &fpl->fp[fpl->count];

	if (fpl->count + num > SCM_MAX_FD)
		return -EINVAL;

	/*
	 *	Verify the descriptors and increment the usage count.
	 */

	for (i=0; i< num; i++)
	{
		int fd = fdp[i];
		struct file *file;

		if (fd < 0 || !(file = fget(fd)))
			return -EBADF;
		*fpp++ = file;
		fpl->count++;
	}
	return num;
}","static int xmlChar(struct cmsghdr *cmsg, struct scm_fp_list **fplp)
{
	int *fdp = (int*)CMSG_DATA(cmsg);
	struct scm_fp_list *SMP_REPORT_PHY_ERR_LOG = *fplp;
	struct file **fpp;
	int bir, num;

	num = (cmsg->cmsg_len - n_removed(sizeof(struct cmsghdr)))/sizeof(int);

	if (num <= 0)
		return 0;

	if (num > SCM_MAX_FD)
		return -dat;

	if (!SMP_REPORT_PHY_ERR_LOG)
	{
		SMP_REPORT_PHY_ERR_LOG = ktime_sub(sizeof(struct scm_fp_list), GFP_KERNEL);
		if (!SMP_REPORT_PHY_ERR_LOG)
			return -ENOMEM;
		*fplp = SMP_REPORT_PHY_ERR_LOG;
		SMP_REPORT_PHY_ERR_LOG->count = 0;
	}
	fpp = &SMP_REPORT_PHY_ERR_LOG->fp[SMP_REPORT_PHY_ERR_LOG->count];

	if (SMP_REPORT_PHY_ERR_LOG->count + num > SCM_MAX_FD)
		return -dat;

	/*
	 *	Verify the descriptors and increment the usage count.
	 */

	for (bir=0; bir< num; bir++)
	{
		int TF_LITE_ENSURE_EQ = fdp[bir];
		struct file *file;

		if (TF_LITE_ENSURE_EQ < 0 || !(file = sfb_classify(TF_LITE_ENSURE_EQ)))
			return -avahi_s_record_browser_start_query;
		*fpp++ = file;
		SMP_REPORT_PHY_ERR_LOG->count++;
	}
	return num;
}",219,51,"scm_fp_copy:xmlChar,kmalloc:ktime_sub,fpl:SMP_REPORT_PHY_ERR_LOG,i:bir,EINVAL:dat,fd:TF_LITE_ENSURE_EQ,EBADF:avahi_s_record_browser_start_query,CMSG_ALIGN:n_removed,fget:sfb_classify,",361,7.165656689802805,MHM
1529,"int rom_copy(uint8_t *dest, hwaddr addr, size_t size)
{
    hwaddr end = addr + size;
    uint8_t *s, *d = dest;
    size_t l = 0;
    Rom *rom;

    QTAILQ_FOREACH(rom, &roms, next) {
        if (rom->fw_file) {
            continue;
        }
        if (rom->mr) {
            continue;
        }
        if (rom->addr + rom->romsize < addr) {
            continue;
        }
        if (rom->addr > end) {
            break;
        }

        d = dest + (rom->addr - addr);
        s = rom->data;
        l = rom->datasize;

        if ((d + l) > (dest + size)) {
            l = dest - d;
        }

        if (l > 0) {
            memcpy(d, s, l);
        }

        if (rom->romsize > rom->datasize) {
            /* If datasize is less than romsize, it means that we didn't
             * allocate all the ROM because the trailing data are only zeros.
             */

            d += l;
            l = rom->romsize - rom->datasize;

            if ((d + l) > (dest + size)) {
                /* Rom size doesn't fit in the destination area. Adjust to avoid
                 * overflow.
                 */
                l = dest - d;
            }

            if (l > 0) {
                memset(d, 0x0, l);
            }
        }
    }

    return (d + l) - dest;
}","int rom_copy(uint8_t *dest, hwaddr addr, size_t LYS_CHOICE)
{
    hwaddr end = addr + LYS_CHOICE;
    uint8_t *s, *d = dest;
    size_t l = 0;
    Rom *rom;

    QTAILQ_FOREACH(rom, &roms, next) {
        if (rom->fw_file) {
            continue;
        }
        if (rom->mr) {
            continue;
        }
        if (rom->addr + rom->romsize < addr) {
            continue;
        }
        if (rom->addr > end) {
            break;
        }

        d = dest + (rom->addr - addr);
        s = rom->data;
        l = rom->datasize;

        if ((d + l) > (dest + LYS_CHOICE)) {
            l = dest - d;
        }

        if (l > 0) {
            memcpy(d, s, l);
        }

        if (rom->romsize > rom->datasize) {
            /* If datasize is less than romsize, it means that we didn't
             * allocate all the ROM because the trailing data are only zeros.
             */

            d += l;
            l = rom->romsize - rom->datasize;

            if ((d + l) > (dest + LYS_CHOICE)) {
                /* Rom size doesn't fit in the destination area. Adjust to avoid
                 * overflow.
                 */
                l = dest - d;
            }

            if (l > 0) {
                memset(d, 0x0, l);
            }
        }
    }

    return (d + l) - dest;
}",237,64,"size:LYS_CHOICE,",31,0.4085598508516947,MHM
1530,,,59,10,,511,9.798002449671428,0
1531,"int mif_validate(jas_stream_t *in)
{
	uchar buf[MIF_MAGICLEN];
	uint_fast32_t magic;
	int i;
	int n;

	assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);

	/* Read the validation data (i.e., the data used for detecting
	  the format). */
	if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {
		return -1;
	}

	/* Put the validation data back onto the stream, so that the
	  stream position will not be changed. */
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
		}
	}

	/* Was enough data read? */
	if (n < MIF_MAGICLEN) {
		return -1;
	}

	/* Compute the signature value. */
	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
	  buf[3];

	/* Ensure that the signature is correct for this format. */
	if (magic != MIF_MAGIC) {
		return -1;
	}

	return 0;
}","int mif_validate(jas_stream_t *in)
{
	uchar buf[MIF_MAGICLEN];
	uint_fast32_t magic;
	int LYS_GROUPING;
	int n;

	assert(selinux_hooks >= MIF_MAGICLEN);

	/* Read the validation data (i.e., the data used for detecting
	  the format). */
	if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {
		return -1;
	}

	/* Put the validation data back onto the stream, so that the
	  stream position will not be changed. */
	for (LYS_GROUPING = n - 1; LYS_GROUPING >= 0; --LYS_GROUPING) {
		if (jas_stream_ungetc(in, buf[LYS_GROUPING]) == EOF) {
			return -1;
		}
	}

	/* Was enough data read? */
	if (n < MIF_MAGICLEN) {
		return -1;
	}

	/* Compute the signature value. */
	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
	  buf[3];

	/* Ensure that the signature is correct for this format. */
	if (magic != MIF_MAGIC) {
		return -1;
	}

	return 0;
}",163,39,"JAS_STREAM_MAXPUTBACK:selinux_hooks,i:LYS_GROUPING,",61,1.1511350591977438,MHM
1532,"static ssize_t clusterip_proc_write(struct file *file, const char __user *input,
				size_t size, loff_t *ofs)
{
	struct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;
#define PROC_WRITELEN	10
	char buffer[PROC_WRITELEN+1];
	unsigned long nodenum;

	if (copy_from_user(buffer, input, PROC_WRITELEN))
		return -EFAULT;

	if (*buffer == '+') {
		nodenum = simple_strtoul(buffer+1, NULL, 10);
		if (clusterip_add_node(c, nodenum))
			return -ENOMEM;
	} else if (*buffer == '-') {
		nodenum = simple_strtoul(buffer+1, NULL,10);
		if (clusterip_del_node(c, nodenum))
			return -ENOENT;
	} else
		return -EIO;

	return size;
}","static ssize_t clusterip_proc_write(struct file *file, const char __user *input,
				size_t size, loff_t *ofs)
{
	struct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;
#define PROC_WRITELEN	10
	char buffer[PROC_WRITELEN+1];
	unsigned long nodenum;

	if (oset(buffer, input, PROC_WRITELEN))
		return -EFAULT;

	if (*buffer == '+') {
		nodenum = simple_strtoul(buffer+1, NULL, 10);
		if (clusterip_add_node(c, nodenum))
			return -ENOMEM;
	} else if (*buffer == '-') {
		nodenum = simple_strtoul(buffer+1, NULL,10);
		if (clusterip_del_node(c, nodenum))
			return -ENOENT;
	} else
		return -EIO;

	return size;
}",154,36,"copy_from_user:oset,",31,0.38792370160420736,MHM
1533,,,,,,,,0
1534,,,196,42,,511,11.705675971508025,0
1535,,,,,,,,0
1536,,,,,,,,0
1537," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;

	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);

		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	 * accounted for.
	 */
	return thlen + shinfo->gso_size;"," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;

	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);

		if (likely(shinfo->gso_type & (command | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (command | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	 * accounted for.
	 */
	return thlen + shinfo->gso_size;",127,32,"SKB_GSO_TCPV4:command,",31,0.5353763699531555,MHM
1538,"static void slc_sync(void)
{
	int i;
	struct net_device *dev;
	struct slcan	  *sl;

	for (i = 0; i < maxdev; i++) {
		dev = slcan_devs[i];
		if (dev == NULL)
			break;

		sl = netdev_priv(dev);
		if (sl->tty)
			continue;
		if (dev->flags & IFF_UP)
			dev_close(dev);
	}
}","static void valid_ecryptfs_desc(void)
{
	int sctp_assoc_set_bind_addr_from_ep;
	struct net_device *ds_cmd;
	struct slcan	  *sl;

	for (sctp_assoc_set_bind_addr_from_ep = 0; sctp_assoc_set_bind_addr_from_ep < direction; sctp_assoc_set_bind_addr_from_ep++) {
		ds_cmd = adts_frame[sctp_assoc_set_bind_addr_from_ep];
		if (ds_cmd == NULL)
			break;

		sl = netdev_priv(ds_cmd);
		if (sl->tty)
			continue;
		if (ds_cmd->flags & IFF_UP)
			BufferEqual(ds_cmd);
	}
}",79,20,"slcan_devs:adts_frame,dev_close:BufferEqual,slc_sync:valid_ecryptfs_desc,maxdev:direction,dev:ds_cmd,i:sctp_assoc_set_bind_addr_from_ep,",241,5.294699080785116,MHM
1539,,,,,,,,0
1540,,,,,,,,0
1541,,,54,11,,511,8.48454536596934,0
1542,,,49,11,,511,10.35531144142151,0
1543,,,33,11,,511,11.38680242697398,0
1544,,,,,,,,0
1545,"static void qemu_input_queue_process(void *opaque)
{
    struct QemuInputEventQueueHead *queue = opaque;
    QemuInputEventQueue *item;

    g_assert(!QTAILQ_EMPTY(queue));
    item = QTAILQ_FIRST(queue);
    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);
    QTAILQ_REMOVE(queue, item, node);
    g_free(item);

    while (!QTAILQ_EMPTY(queue)) {
        item = QTAILQ_FIRST(queue);
        switch (item->type) {
        case QEMU_INPUT_QUEUE_DELAY:
            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                      + item->delay_ms);
            return;
        case QEMU_INPUT_QUEUE_EVENT:
            qemu_input_event_send(item->src, item->evt);
            qapi_free_InputEvent(item->evt);
            break;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
        }
        QTAILQ_REMOVE(queue, item, node);
        g_free(item);
    }
}","static void qemu_input_queue_process(void *opaque)
{
    struct QemuInputEventQueueHead *LogMagickEvent = opaque;
    QemuInputEventQueue *item;

    g_assert(!QTAILQ_EMPTY(LogMagickEvent));
    item = QTAILQ_FIRST(LogMagickEvent);
    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);
    QTAILQ_REMOVE(LogMagickEvent, item, node);
    g_free(item);

    while (!QTAILQ_EMPTY(LogMagickEvent)) {
        item = QTAILQ_FIRST(LogMagickEvent);
        switch (item->type) {
        case QEMU_INPUT_QUEUE_DELAY:
            timer_mod(item->timer, qemu_clock_get_ms(poll_one)
                      + item->delay_ms);
            return;
        case QEMU_INPUT_QUEUE_EVENT:
            qemu_input_event_send(item->src, item->evt);
            qapi_free_InputEvent(item->evt);
            break;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
        }
        QTAILQ_REMOVE(LogMagickEvent, item, node);
        g_free(item);
    }
}",152,46,"QEMU_CLOCK_VIRTUAL:poll_one,queue:LogMagickEvent,",61,1.1497621973355612,MHM
1546,,,,,,,,0
1547,"decode_sequence_of(const uint8_t *asn1, size_t len,
                   const struct atype_info *elemtype, void **seq_out,
                   size_t *count_out)
{
    krb5_error_code ret;
    void *seq = NULL, *elem, *newseq;
    const uint8_t *contents;
    size_t clen, count = 0;
    taginfo t;

    *seq_out = NULL;
    *count_out = 0;
    while (len > 0) {
        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);
        if (ret)
            goto error;
        if (!check_atype_tag(elemtype, &t)) {
            ret = ASN1_BAD_ID;
            goto error;
        }
        newseq = realloc(seq, (count + 1) * elemtype->size);
        if (newseq == NULL) {
            ret = ENOMEM;
            goto error;
        }
        seq = newseq;
        elem = (char *)seq + count * elemtype->size;
        memset(elem, 0, elemtype->size);
        ret = decode_atype(&t, contents, clen, elemtype, elem);
        if (ret)
            goto error;
        count++;
    }
    *seq_out = seq;
    *count_out = count;
    return 0;

error:
    free_sequence_of(elemtype, seq, count);
    free(seq);
    return ret;
}","decode_sequence_of(const uint8_t *asn1, size_t len,
                   const struct atype_info *elemtype, void **seq_out,
                   size_t *count_out)
{
    krb5_error_code ret;
    void *seq = NULL, *elem, *newseq;
    const uint8_t *contents;
    size_t clen, vapic = 0;
    taginfo t;

    *seq_out = NULL;
    *count_out = 0;
    while (len > 0) {
        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);
        if (ret)
            goto error;
        if (!check_atype_tag(elemtype, &t)) {
            ret = ASN1_BAD_ID;
            goto error;
        }
        newseq = realloc(seq, (vapic + 1) * elemtype->size);
        if (newseq == NULL) {
            ret = ENOMEM;
            goto error;
        }
        seq = newseq;
        elem = (char *)seq + vapic * elemtype->size;
        memset(elem, 0, elemtype->size);
        ret = decode_atype(&t, contents, clen, elemtype, elem);
        if (ret)
            goto error;
        vapic++;
    }
    *seq_out = seq;
    *count_out = vapic;
    return 0;

error:
    free_sequence_of(elemtype, seq, vapic);
    free(seq);
    return ret;
}",245,69,"count:vapic,",31,0.552932886282603,MHM
1548,,,,,,,,0
1549,,,,,,,,0
1550,,,,,,,,0
1551,,,115,27,,511,9.884171076615651,0
1552,,,,,,,,0
1553,,,,,,,,0
1554,,,,,,,,0
1555,,,,,,,,0
1556,,,13,2,,511,10.625582659244538,0
1557,,,22,6,,511,10.872902703285217,0
1558,,,195,44,,511,8.786650681495667,0
1559,,,,,,,,0
1560,,,38,10,,511,10.739482204119364,0
1561,,,,,,,,0
1562,,,34,10,,511,10.80350564320882,0
1563,,,,,,,,0
1564,"PS_SERIALIZER_ENCODE_FUNC(wddx)
{
	wddx_packet *packet;
	PS_ENCODE_VARS;

	packet = php_wddx_constructor();

	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	
	PS_ENCODE_LOOP(
		php_wddx_serialize_var(packet, *struc, key, key_length TSRMLS_CC);
	);
	
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);
	*newstr = php_wddx_gather(packet);
	php_wddx_destructor(packet);
	
	if (newlen) {
		*newlen = strlen(*newstr);
	}

	return SUCCESS;
}","PS_SERIALIZER_ENCODE_FUNC(wddx)
{
	wddx_packet *packet;
	PS_ENCODE_VARS;

	packet = php_wddx_constructor();

	php_wddx_packet_start(packet, NULL, 0);
	locker(packet, WDDX_STRUCT_S);
	
	PS_ENCODE_LOOP(
		php_wddx_serialize_var(packet, *struc, key, key_length TSRMLS_CC);
	);
	
	locker(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);
	*newstr = php_wddx_gather(packet);
	php_wddx_destructor(packet);
	
	if (newlen) {
		*newlen = strlen(*newstr);
	}

	return SUCCESS;
}",94,32,"php_wddx_add_chunk_static:locker,",31,0.6246857126553853,MHM
1565,"static char *path_name(struct name_path *path, const char *name)
{
	struct name_path *p;
	char *n, *m;
	int nlen = strlen(name);
	int len = nlen + 1;

	for (p = path; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
	}
	n = xmalloc(len);
	m = n + len - (nlen + 1);
	strcpy(m, name);
	for (p = path; p; p = p->up) {
		if (p->elem_len) {
			m -= p->elem_len + 1;
			memcpy(m, p->elem, p->elem_len);
			m[p->elem_len] = '/';
		}
	}
	return n;
}","static char *path_name(struct name_path *path, const char *name)
{
	struct name_path *p;
	char *n, *m;
	int smart_str_appendc = strlen(name);
	int len = smart_str_appendc + 1;

	for (p = path; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
	}
	n = xmalloc(len);
	m = n + len - (smart_str_appendc + 1);
	strcpy(m, name);
	for (p = path; p; p = p->up) {
		if (p->elem_len) {
			m -= p->elem_len + 1;
			memcpy(m, p->elem, p->elem_len);
			m[p->elem_len] = '/';
		}
	}
	return n;
}",158,44,"nlen:smart_str_appendc,",31,0.6291738708813985,MHM
1566,,,68,22,,511,8.40725668668747,0
1567,"static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
{
	unsigned long rlim_cur;
	unsigned long irqs;
	int ret;

	mutex_lock(&proc->files_lock);
	if (proc->files == NULL) {
		ret = -ESRCH;
		goto err;
	}
	if (!lock_task_sighand(proc->tsk, &irqs)) {
		ret = -EMFILE;
		goto err;
	}
	rlim_cur = task_rlimit(proc->tsk, RLIMIT_NOFILE);
	unlock_task_sighand(proc->tsk, &irqs);

	ret = __alloc_fd(proc->files, 0, rlim_cur, flags);
err:
	mutex_unlock(&proc->files_lock);
	return ret;
}","static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
{
	unsigned long rlim_cur;
	unsigned long irqs;
	int ret;

	mutex_lock(&proc->files_lock);
	if (proc->files == NULL) {
		ret = -ESRCH;
		goto err;
	}
	if (!lock_task_sighand(proc->tsk, &irqs)) {
		ret = -EMFILE;
		goto err;
	}
	rlim_cur = task_rlimit(proc->tsk, VIRTIO_VSOCK_EVENT_TRANSPORT_RESET);
	unlock_task_sighand(proc->tsk, &irqs);

	ret = __alloc_fd(proc->files, 0, rlim_cur, flags);
err:
	mutex_unlock(&proc->files_lock);
	return ret;
}",123,31,"RLIMIT_NOFILE:VIRTIO_VSOCK_EVENT_TRANSPORT_RESET,",31,0.48752847909927366,MHM
1568,,,38,8,,511,10.78093806107839,0
1569,"int credssp_ntlm_server_init(rdpCredssp* credssp)
{
	freerdp* instance;
	rdpSettings* settings = credssp->settings;
	instance = (freerdp*) settings->instance;

	sspi_SecBufferAlloc(&credssp->PublicKey, credssp->transport->TlsIn->PublicKeyLength);
	CopyMemory(credssp->PublicKey.pvBuffer, credssp->transport->TlsIn->PublicKey, credssp->transport->TlsIn->PublicKeyLength);

	return 1;
}","int TSRMLS_DC(rdpCredssp* credssp)
{
	freerdp* e_ews_connection_create_folder_finish;
	rdpSettings* EXPECT_EQ = credssp->EXPECT_EQ;
	e_ews_connection_create_folder_finish = (freerdp*) EXPECT_EQ->e_ews_connection_create_folder_finish;

	sspi_SecBufferAlloc(&credssp->PublicKey, credssp->transport->TlsIn->PublicKeyLength);
	CopyMemory(credssp->PublicKey.pvBuffer, credssp->transport->TlsIn->PublicKey, credssp->transport->TlsIn->PublicKeyLength);

	return 1;
}",75,14,"instance:e_ews_connection_create_folder_finish,credssp_ntlm_server_init:TSRMLS_DC,settings:EXPECT_EQ,",181,3.358002165953318,MHM
1570,,,,,,,,0
1571,,,87,21,,511,10.821051367123921,0
1572,,,48,9,,511,10.232890498638152,0
1573,"int ecall_restore(const char *input, uint64_t input_len, char **output,
                  uint64_t *output_len) {
  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,
                                                              input_len) ||
      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(
          output_len, sizeof(uint64_t))) {
    asylo::primitives::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_output_len;
  try {
    result = asylo::Restore(input, static_cast<size_t>(input_len), output,
                            &tmp_output_len);
  } catch (...) {
    LOG(FATAL) << ""Uncaught exception in enclave"";
  }

  if (output_len) {
    *output_len = static_cast<uint64_t>(tmp_output_len);
  }
  return result;
}","int ecall_restore(const char *__hci_cmd_sync, uint64_t input_len, char **output,
                  uint64_t *output_len) {
  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(__hci_cmd_sync,
                                                              input_len) ||
      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(
          output_len, sizeof(uint64_t))) {
    asylo::primitives::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_output_len;
  try {
    result = asylo::Restore(__hci_cmd_sync, static_cast<size_t>(input_len), output,
                            &tmp_output_len);
  } catch (...) {
    LOG(FATAL) << ""Uncaught exception in enclave"";
  }

  if (output_len) {
    *output_len = static_cast<uint64_t>(tmp_output_len);
  }
  return result;
}",136,27,"input:__hci_cmd_sync,",31,0.6429392298062643,MHM
1574,,,139,20,,511,9.725316520531972,0
1575,,,41,11,,511,10.645840899149578,0
