Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
5,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)

{

    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (drc->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS_OUT_SUCCESS;

}
","static uint32_t drc_set_unusable(sPAPRDRConnector *proc)

{

    proc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (proc->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(proc);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(proc);

    }



    return RTAS_OUT_SUCCESS;

}
",45.0,13.0,"drc:proc,",65.0,0.0302842855453491,Greedy
9,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
","static void vc1_inv_trans_8x8_dc_c(uint8_t *route, int codespace, DCTELEM *event)

{

    int api;

    int dc = event[0];

    const uint8_t *address;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    address = ff_cropTbl + MAX_NEG_CROP + dc;

    for(api = 0; api < 8; api++){

        route[0] = address[route[0]];

        route[1] = address[route[1]];

        route[2] = address[route[2]];

        route[3] = address[route[3]];

        route[4] = address[route[4]];

        route[5] = address[route[5]];

        route[6] = address[route[6]];

        route[7] = address[route[7]];

        route += codespace;

    }

}
",188.0,45.0,"block:event,i:api,linesize:codespace,cm:address,dest:route,",300.0,0.1423769831657409,Greedy
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    }

}
","static void net_vhost_link_down(VhostUserState *rs, bool link_down)

{

    rs->nc.link_down = link_down;



    if (rs->nc.peer) {

        rs->nc.peer->link_down = link_down;

    }



    if (rs->nc.info->link_status_changed) {

        rs->nc.info->link_status_changed(&rs->nc);

    }



    if (rs->nc.peer && rs->nc.peer->info->link_status_changed) {

        rs->nc.peer->info->link_status_changed(rs->nc.peer);

    }

}
",104.0,15.0,"s:rs,",78.0,0.0382810433705647,Greedy
24,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int n, i, r, g, b;



    if ((length % 3) != 0 || length > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    n = length / 3;

    for (i = 0; i < n; i++) {

        r = bytestream2_get_byte(&s->gb);

        g = bytestream2_get_byte(&s->gb);

        b = bytestream2_get_byte(&s->gb);

        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;

    }

    for (; i < 256; i++)

        s->palette[i] = (0xFFU << 24);

    s->state |= PNG_PLTE;

    bytestream2_skip(&s->gb, 4);     /* crc */



    return 0;

}
","static int decode_plte_chunk(AVCodecContext *afcontext, PNGDecContext *s,

                             uint32_t library)

{

    int j, i, w, k, lib;



    if ((library % 3) != 0 || library > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    j = library / 3;

    for (i = 0; i < j; i++) {

        w = bytestream2_get_byte(&s->gb);

        k = bytestream2_get_byte(&s->gb);

        lib = bytestream2_get_byte(&s->gb);

        s->palette[i] = (0xFFU << 24) | (w << 16) | (k << 8) | lib;

    }

    for (; i < 256; i++)

        s->palette[i] = (0xFFU << 24);

    s->state |= PNG_PLTE;

    bytestream2_skip(&s->gb, 4);     /* crc */



    return 0;

}
",167.0,40.0,"avctx:afcontext,b:lib,g:k,n:j,r:w,length:library,",260.0,0.1340498050053914,Greedy
28,"static size_t header_ext_add(char *buf, uint32_t magic, const void *s,

    size_t len, size_t buflen)

{

    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;

    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);



    if (buflen < ext_len) {

        return -ENOSPC;

    }



    *ext_backing_fmt = (QCowExtension) {

        .magic  = cpu_to_be32(magic),

        .len    = cpu_to_be32(len),

    };

    memcpy(buf + sizeof(QCowExtension), s, len);



    return ext_len;

}
","static size_t header_ext_add(char *func, uint32_t generic, const void *service,

    size_t len, size_t buflen)

{

    QCowExtension *ext_backing_fmt = (QCowExtension*) func;

    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);



    if (buflen < ext_len) {

        return -ENOSPC;

    }



    *ext_backing_fmt = (QCowExtension) {

        .generic  = cpu_to_be32(generic),

        .len    = cpu_to_be32(len),

    };

    memcpy(func + sizeof(QCowExtension), service, len);



    return ext_len;

}
",107.0,25.0,"buf:func,magic:generic,s:service,",158.0,0.0746642470359802,Greedy
30,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);



    d->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
","static void mem_begin(MemoryListener * listencer)

{

    AddressSpaceDispatch *ded = container_of( listencer, AddressSpaceDispatch,  listencer);



    ded->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",31.0,9.0,"d:ded,listener: listencer,",91.0,0.0441467682520548,Greedy
35,"static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *s = OMAP1_GPIO(dev);



    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}
","static int omap_gpio_init(SysBusDevice *lsbb)

{

    DeviceState *adv = DEVICE(lsbb);

    struct omap_gpif_s *service = OMAP1_GPIO(adv);



    if (!service->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(adv, omap_gpio_set, 16);

    qdev_init_gpio_out(adv, service->omap1.handler, 16);

    sysbus_init_irq(lsbb, &service->omap1.irq);

    memory_region_init_io(&service->iomem, OBJECT(service), &omap_gpio_ops, &service->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(lsbb, &service->iomem);

    return 0;

}
",118.0,28.0,"sbd:lsbb,dev:adv,s:service,",178.0,0.0832805275917053,Greedy
36,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)

{

    s->codec = slave;

    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];

    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];

}
","void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *address, I2SCodec *oe)

{

    address->codec = oe;

    oe->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, address, 1)[0];

    oe->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, address, 1)[0];

}
",52.0,13.0,"s:address,slave:oe,",113.0,0.0504344900449117,Greedy
39,"BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque, int type)

{

    struct qemu_paiocb *acb;



    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);

    if (!acb)

        return NULL;

    acb->aio_type = type;

    acb->aio_fildes = fd;

    acb->ev_signo = SIGUSR2;

    acb->async_context_id = get_async_context_id();



    if (qiov) {

        acb->aio_iov = qiov->iov;

        acb->aio_niov = qiov->niov;

    }

    acb->aio_nbytes = nb_sectors * 512;

    acb->aio_offset = sector_num * 512;



    acb->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = acb;



    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);

    qemu_paio_submit(acb);

    return &acb->common;

}
","BlockDriverAIOCB *paio_submit(BlockDriverState *db, int dB,

        int64_t sector_num, QEMUIOVector *qoby, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *OPaco, int type)

{

    struct qemu_paiocb * ace;



     ace = qemu_aio_get(&raw_aio_pool, db, cb, OPaco);

    if (! ace)

        return NULL;

     ace->aio_type = type;

     ace->aio_fildes = dB;

     ace->ev_signo = SIGUSR2;

     ace->async_context_id = get_async_context_id();



    if (qoby) {

         ace->aio_iov = qoby->iov;

         ace->aio_niov = qoby->niov;

    }

     ace->aio_nbytes = nb_sectors * 512;

     ace->aio_offset = sector_num * 512;



     ace->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio =  ace;



    trace_paio_submit( ace, OPaco, sector_num, nb_sectors, type);

    qemu_paio_submit( ace);

    return & ace->common;

}
",163.0,47.0,"acb: ace,qiov:qoby,bs:db,opaque:OPaco,fd:dB,",326.0,0.1544445991516113,Greedy
41,"int ff_alloc_entries(AVCodecContext *avctx, int count)

{

    int i;



    if (avctx->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *p = avctx->internal->thread_ctx;

        p->thread_count  = avctx->thread_count;

        p->entries       = av_mallocz_array(count, sizeof(int));



        if (!p->entries) {

            return AVERROR(ENOMEM);

        }



        p->entries_count  = count;

        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));

        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));



        for (i = 0; i < p->thread_count; i++) {

            pthread_mutex_init(&p->progress_mutex[i], NULL);

            pthread_cond_init(&p->progress_cond[i], NULL);

        }

    }



    return 0;

}
","int ff_alloc_entries(AVCodecContext *avctx, int list)

{

    int info;



    if (avctx->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *p = avctx->internal->thread_ctx;

        p->thread_count  = avctx->thread_count;

        p->entries       = av_mallocz_array(list, sizeof(int));



        if (!p->entries) {

            return AVERROR(ENOMEM);

        }



        p->entries_count  = list;

        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));

        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));



        for (info = 0; info < p->thread_count; info++) {

            pthread_mutex_init(&p->progress_mutex[info], NULL);

            pthread_cond_init(&p->progress_cond[info], NULL);

        }

    }



    return 0;

}
",156.0,36.0,"count:list,i:info,",127.0,0.0676539619763692,Greedy
44,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
","static void fpu_init (CPUMIPSState *gear, const mips_def_t *dep)

{

    int I;



    for (I = 0; I < MIPS_FPU_MAX; I++)

        gear->fpus[I].fcr0 = dep->CP1_fcr0;



    memcpy(&gear->active_fpu, &gear->fpus[0], sizeof(gear->active_fpu));

    if (gear->user_mode_only) {

        if (gear->CP0_Config1 & (1 << CP0C1_FP))

            gear->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (gear->active_fpu.fcr0 & (1 << FCR0_F64))

            gear->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",116.0,25.0,"env:gear,i:I,def:dep,",186.0,0.0857472459475199,Greedy
47,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)

{

    thread_pool_submit_aio(func, arg, NULL, NULL);

}
","void thread_pool_submit(ThreadPoolFunc *this, void *ass)

{

    thread_pool_submit_aio(this, ass, NULL, NULL);

}
",24.0,6.0,"arg:ass,func:this,",77.0,0.0376921296119689,Greedy
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
","void palette8tobgr24(const uint8_t *data, uint8_t *dst, long num_pipes, const uint8_t *holette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pipes; i++)

	{

		//FIXME slow?

		dst[0]= holette[ data[i]*4+0 ];

		dst[1]= holette[ data[i]*4+1 ];

		dst[2]= holette[ data[i]*4+2 ];

		dst+= 3;

	}

}
",95.0,23.0,"num_pixels:num_pipes,src:data,palette:holette,",163.0,0.0764305512110392,Greedy
67,"void tcp_start_incoming_migration(const char *host_port, Error **errp)

{

    int s;



    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);

    if (s < 0) {

        return;

    }



    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,

                         (void *)(intptr_t)s);

}
","void tcp_start_incoming_migration(const char *hostpport, Error **raisefp)

{

    int ss;



    ss = inet_listen(hostpport, NULL, 256, SOCK_STREAM, 0, raisefp);

    if (ss < 0) {

        return;

    }



    qemu_set_fd_handler2(ss, NULL, tcp_accept_incoming_migration, NULL,

                         (void *)(intptr_t)ss);

}
",65.0,14.0,"host_port:hostpport,errp:raisefp,s:ss,",117.0,0.058811064561208,Greedy
70,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
","static AVStream * init_stream(AVFormatContext *sg)

{

    BinDemuxContext *bin = sg->priv_data;

    AVStream *st = avformat_new_stream(sg, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
",129.0,24.0,"s:sg,",70.0,0.0397145350774129,Greedy
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
","static void idiv64(uint64_t *flows, uint64_t *phigh, int64_t length)

{

    int sea, nb;

    sea = ((int64_t)*phigh < 0);

    if (sea)

        neg128(flows, phigh);

    nb = (length < 0);

    if (nb)

        length = -length;

    div64(flows, phigh, length);

    if (sea ^ nb)

        *flows = - *flows;

    if (sea)

        *phigh = - *phigh;

}
",95.0,28.0,"b:length,plow:flows,sa:sea,sb:nb,",233.0,0.1082253654797871,Greedy
78,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)

{

    TAPState *s = opaque;

    int ret;

    for(;;) {

        ret = write(s->fd, buf, size);

        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
","static void tap_receive(void *opaque, const uint8_t *buf, size_t size)

{

    TAPState *s = opaque;

    int Len;

    for(;;) {

        Len = write(s->fd, buf, size);

        if (Len < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
",70.0,17.0,"ret:Len,",64.0,0.0335517366727193,Greedy
82,"static char *enumerate_cpus(unsigned long *cpus, int max_cpus)

{

    int cpu;

    bool first = true;

    GString *s = g_string_new(NULL);



    for (cpu = find_first_bit(cpus, max_cpus);

        cpu < max_cpus;

        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {

        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);

        first = false;

    }

    return g_string_free(s, FALSE);

}
","static char *enumerate_cpus(unsigned long *cpus, int max_dcus)

{

    int winner;

    bool first = true;

    GString *session = g_string_new(NULL);



    for (winner = find_first_bit(cpus, max_dcus);

        winner < max_dcus;

        winner = find_next_bit(cpus, max_dcus, winner + 1)) {

        g_string_append_printf(session, ""%s%d"", first ? """" : "" "", winner);

        first = false;

    }

    return g_string_free(session, FALSE);

}
",92.0,25.0,"s:session,max_cpus:max_dcus,cpu:winner,",174.0,0.0812970081965128,Greedy
86,"static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,

                                  const char *name, Error **errp)

{

    NvmeCtrl *s = NVME(obj);



    visit_type_int32(v, &s->conf.bootindex, name, errp);

}
","static void nvme_get_bootindex(Object *obj, Visitor *conv, void *opaque,

                                  const char *time, Error **errp)

{

    NvmeCtrl *s = NVME(obj);



    visit_type_int32(conv, &s->conf.bootindex, time, errp);

}
",53.0,14.0,"v:conv,name:time,",88.0,0.044884169101715,Greedy
89,"static void vscsi_process_login(VSCSIState *s, vscsi_req *req)

{

    union viosrp_iu *iu = &req->iu;

    struct srp_login_rsp *rsp = &iu->srp.login_rsp;

    uint64_t tag = iu->srp.rsp.tag;



    trace_spapr_vscsi__process_login();



    /* TODO handle case that requested size is wrong and

     * buffer format is wrong

     */

    memset(iu, 0, sizeof(struct srp_login_rsp));

    rsp->opcode = SRP_LOGIN_RSP;

    /* Don't advertise quite as many request as we support to

     * keep room for management stuff etc...

     */

    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);

    rsp->tag = tag;

    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));

    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));

    /* direct and indirect */

    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);



    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);

}
","static void vscsi_process_login(VSCSIState *server, vscsi_req *req)

{

    union viosrp_iu *iu = &req->iu;

    struct srp_login_rsp *rsp = &iu->srp.login_rsp;

    uint64_t tag = iu->srp.rsp.tag;



    trace_spapr_vscsi__process_login();



    /* TODO handle case that requested size is wrong and

     * buffer format is wrong

     */

    memset(iu, 0, sizeof(struct srp_login_rsp));

    rsp->opcode = SRP_LOGIN_RSP;

    /* Don't advertise quite as many request as we support to

     * keep room for management stuff etc...

     */

    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);

    rsp->tag = tag;

    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));

    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));

    /* direct and indirect */

    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);



    vscsi_send_iu(server, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);

}
",139.0,32.0,"s:server,",60.0,0.0353108485539754,Greedy
93,"static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)

{


    return 0;

}","static int null_filter_samples(AVFilterLink *light, AVFilterBufferRef *samplesref)

{


    return 0;

}",17.0,3.0,"link:light,",32.0,0.0201199928919474,Greedy
98,"static int check_checksum(ByteIOContext *bc){

    unsigned long checksum= get_checksum(bc);

//    return checksum != get_be32(bc);



    av_log(NULL, AV_LOG_ERROR, ""%08X %08X\n"", checksum, (int)get_be32(bc));



    return 0;

}
","static int check_checksum(ByteIOContext *ctx){

    unsigned long checksum= get_checksum(ctx);

//    return checksum != get_be32(bc);



    av_log(NULL, AV_LOG_ERROR, ""%08X %08X\n"", checksum, (int)get_be32(ctx));



    return 0;

}
",43.0,10.0,"bc:ctx,",47.0,0.0271799842516581,Greedy
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
","int vhost_backend_invalidate_device_iotlb(struct vhost_dev *priv,

                                                 uint64_t iova, uint64_t lon)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = lon;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return priv->vhost_ops->vhost_send_device_iotlb_msg(priv, &imsg);

}
",51.0,14.0,"len:lon,dev:priv,",110.0,0.0518059889475504,Greedy
104,"int usb_device_delete_addr(int busnr, int addr)

{

    USBBus *bus;

    USBPort *port;

    USBDevice *dev;



    bus = usb_bus_find(busnr);

    if (!bus)

        return -1;



    TAILQ_FOREACH(port, &bus->used, next) {

        if (port->dev->addr == addr)

            break;

    }

    if (!port)

        return -1;



    dev = port->dev;

    TAILQ_REMOVE(&bus->used, port, next);

    bus->nused--;



    usb_attach(port, NULL);

    dev->info->handle_destroy(dev);



    TAILQ_INSERT_TAIL(&bus->free, port, next);

    bus->nfree++;

    return 0;

}
","int usb_device_delete_addr(int bootsn, int sid)

{

    USBBus *mount;

    USBPort *project;

    USBDevice *DEV;



    mount = usb_bus_find(bootsn);

    if (!mount)

        return -1;



    TAILQ_FOREACH(project, &mount->used, next) {

        if (project->DEV->sid == sid)

            break;

    }

    if (!project)

        return -1;



    DEV = project->DEV;

    TAILQ_REMOVE(&mount->used, project, next);

    mount->nactive--;



    usb_attach(project, NULL);

    DEV->info->handle_destroy(DEV);



    TAILQ_INSERT_TAIL(&mount->free, project, next);

    mount->nfree++;

    return 0;

}
",131.0,33.0,"dev:DEV,bus:mount,port:project,addr:sid,busnr:bootsn,nused:nactive,",313.0,0.152874739964803,Greedy
105,"static void qmp_output_type_number(Visitor *v, const char *name, double *obj,

                                   Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qmp_output_add(qov, name, qfloat_from_double(*obj));

}
","static void qmp_output_type_number(Visitor *vim, const char *var, double *foo,

                                   Error **errp)

{

    QmpOutputVisitor *idovo = to_qov(vim);

    qmp_output_add(idovo, var, qfloat_from_double(*foo));

}
",46.0,13.0,"qov:idovo,name:var,obj:foo,v:vim,",150.0,0.075202190876007,Greedy
112,"static void temp_allocate_frame(TCGContext *s, int temp)

{

    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
","static void temp_allocate_frame(TCGContext *d, int temp)

{

    TCGTemp *ts;

    ts = &d->temps[temp];

    d->current_frame_offset = (d->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (d->current_frame_offset + sizeof(tcg_target_long) > d->frame_end)

        tcg_abort();

    ts->mem_offset = d->current_frame_offset;

    ts->mem_reg = d->frame_reg;

    ts->mem_allocated = 1;

    d->current_frame_offset += sizeof(tcg_target_long);

}
",104.0,22.0,"s:d,",85.0,0.0415194352467854,Greedy
113,"void qmp_block_stream(const char *device, bool has_base,

                      const char *base, Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    Error *local_err = NULL;



    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    if (base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, base);

            return;

        }

    }



    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(errp, local_err);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(bs));



    trace_qmp_block_stream(bs, bs->job);

}
","void qmp_block_stream(const char *device, bool has_base,

                      const char *base, Error **errp)

{

    BlockDriverState *null;

    BlockDriverState *base_bs = NULL;

    Error *local_err = NULL;



    null = bdrv_find(device);

    if (!null) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    if (base) {

        base_bs = bdrv_find_backing_image(null, base);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, base);

            return;

        }

    }



    stream_start(null, base_bs, base, block_stream_cb, null, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(errp, local_err);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(null));



    trace_qmp_block_stream(null, null->job);

}
",150.0,44.0,"bs:null,",93.0,0.0491905927658081,Greedy
122,"static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
","static uint32_t s390_pci_generate_fid(Error **rorp)

{

    uint32_t dbid = 0;



    while (dbid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(dbid)) {

            return dbid;

        }



        if (dbid == ZPCI_MAX_FID) {

            break;

        }



        dbid++;

    }



    error_setg(rorp, ""no free fid could be found"");

    return 0;

}
",61.0,13.0,"fid:dbid,errp:rorp,",101.0,0.0480479876200358,Greedy
124,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
","static int ipmovie_read_packet(AVFormatContext *services,

                               AVPacket *apqt)

{

    IPMVEContext *ippvideo = (IPMVEContext *)services->priv_data;

    ByteIOContext *lp = &services->lp;

    int fun;



    fun = process_ipmovie_chunk(ippvideo, lp, apqt);

    if (fun == CHUNK_BAD)

        fun = AVERROR_INVALIDDATA;

    else if (fun == CHUNK_EOF)

        fun = AVERROR_IO;

    else if (fun == CHUNK_NOMEM)

        fun = AVERROR_NOMEM;

    else

        fun = 0;



    return fun;

}
",89.0,27.0,"pb:lp,pkt:apqt,ipmovie:ippvideo,s:services,ret:fun,",234.0,0.1134214719136556,Greedy
126,"bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&queue->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
","bool qemu_co_enter_next(CoQueue *event)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&event->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&event->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
",53.0,12.0,"queue:event,",50.0,0.0280534068743387,Greedy
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[val];

}
","static target_long monitor_get_reg(const struct MonitorDef *m, int vol)

{

    CPUState *eu = mon_get_cpu();

    if (!eu)

        return 0;

    return eu->regwptr[vol];

}
",39.0,8.0,"md:m,val:vol,env:eu,",125.0,0.0579481442769368,Greedy
129,"static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)

{

    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);

    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);

    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);

    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);

}
","static void vp8_idct_dc_add4uv_c(uint8_t *sdost, int16_t block[4][16], ptrdiff_t stride)

{

    vp8_idct_dc_add_c(sdost+stride*0+0, block[0], stride);

    vp8_idct_dc_add_c(sdost+stride*0+4, block[1], stride);

    vp8_idct_dc_add_c(sdost+stride*4+0, block[2], stride);

    vp8_idct_dc_add_c(sdost+stride*4+4, block[3], stride);

}
",94.0,24.0,"dst:sdost,",76.0,0.0365616679191589,Greedy
133,"static void fd_chr_update_read_handler(CharDriverState *chr)

{

    FDCharDriver *s = chr->opaque;



    if (s->fd_in_tag) {

        g_source_remove(s->fd_in_tag);

        s->fd_in_tag = 0;

    }



    if (s->fd_in) {

        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);

    }

}
","static void fd_chr_update_read_handler(CharDriverState *Chrs)

{

    FDCharDriver *service = Chrs->opaque;



    if (service->fd_in_tag) {

        g_source_remove(service->fd_in_tag);

        service->fd_in_tag = 0;

    }



    if (service->fd_in) {

        service->fd_in_tag = io_add_watch_poll(service->fd_in, fd_chr_read_poll, fd_chr_read, Chrs);

    }

}
",64.0,15.0,"chr:Chrs,s:service,",115.0,0.0530589739481608,Greedy
138,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry entry;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = tce;



    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);



    return H_SUCCESS;

}
","static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry server;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = tce;



    server.target_as = &address_space_memory,

    server.iova = ioba & page_mask;

    server.translated_addr = tce & page_mask;

    server.addr_mask = ~page_mask;

    server.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, server);



    return H_SUCCESS;

}
",131.0,38.0,"entry:server,",93.0,0.0561510245005289,Greedy
143,"static int ftp_file_size(FTPContext *s)

{

    char command[CONTROL_BUFFER_SIZE];

    char *res = NULL;

    const int size_codes[] = {213, 0};



    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);

    if (ftp_send_command(s, command, size_codes, &res)) {

        s->filesize = strtoll(&res[4], NULL, 10);

    } else {

        s->filesize = -1;

        av_free(res);

        return AVERROR(EIO);

    }



    av_free(res);

    return 0;

}
","static int ftp_file_size(FTPContext *secondary)

{

    char name[CONTROL_BUFFER_SIZE];

    char *res = NULL;

    const int size_codes[] = {213, 0};



    snprintf(name, sizeof(name), ""SIZE %s\r\n"", secondary->path);

    if (ftp_send_command(secondary, name, size_codes, &res)) {

        secondary->filesize = strtoll(&res[4], NULL, 10);

    } else {

        secondary->filesize = -1;

        av_free(res);

        return AVERROR(EIO);

    }



    av_free(res);

    return 0;

}
",114.0,25.0,"s:secondary,command:name,",124.0,0.0599621971448262,Greedy
150,"static void gpollfds_from_select(void)

{

    int fd;

    for (fd = 0; fd <= nfds; fd++) {

        int events = 0;

        if (FD_ISSET(fd, &rfds)) {

            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;

        }

        if (FD_ISSET(fd, &wfds)) {

            events |= G_IO_OUT | G_IO_ERR;

        }

        if (FD_ISSET(fd, &xfds)) {

            events |= G_IO_PRI;

        }

        if (events) {

            GPollFD pfd = {

                .fd = fd,

                .events = events,

            };

            g_array_append_val(gpollfds, pfd);

        }

    }

}
","static void gpollfds_from_select(void)

{

    int dc;

    for (dc = 0; dc <= nfds; dc++) {

        int events = 0;

        if (FD_ISSET(dc, &rfds)) {

            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;

        }

        if (FD_ISSET(dc, &wfds)) {

            events |= G_IO_OUT | G_IO_ERR;

        }

        if (FD_ISSET(dc, &xfds)) {

            events |= G_IO_PRI;

        }

        if (events) {

            GPollFD pfd = {

                .dc = dc,

                .events = events,

            };

            g_array_append_val(gpollfds, pfd);

        }

    }

}
",114.0,32.0,"fd:dc,",81.0,0.0423889954884847,Greedy
156,"static int adpcm_decode_init(AVCodecContext * avctx)

{

    ADPCMContext *c = avctx->priv_data;



    if(avctx->channels > 2U){

        return -1;

    }



    c->channel = 0;

    c->status[0].predictor = c->status[1].predictor = 0;

    c->status[0].step_index = c->status[1].step_index = 0;

    c->status[0].step = c->status[1].step = 0;



    switch(avctx->codec->id) {

    case CODEC_ID_ADPCM_CT:

        c->status[0].step = c->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (avctx->extradata && avctx->extradata_size == 2 * 4) {

            c->status[0].predictor = AV_RL32(avctx->extradata);

            c->status[1].predictor = AV_RL32(avctx->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}
","static int adpcm_decode_init(AVCodecContext * ajctx)

{

    ADPCMContext *dc = ajctx->priv_data;



    if(ajctx->channels > 2U){

        return -1;

    }



    dc->channel = 0;

    dc->status[0].predictor = dc->status[1].predictor = 0;

    dc->status[0].step_index = dc->status[1].step_index = 0;

    dc->status[0].step = dc->status[1].step = 0;



    switch(ajctx->codec->id) {

    case CODEC_ID_ADPCM_CT:

        dc->status[0].step = dc->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (ajctx->extradata && ajctx->extradata_size == 2 * 4) {

            dc->status[0].predictor = AV_RL32(ajctx->extradata);

            dc->status[1].predictor = AV_RL32(ajctx->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}
",194.0,25.0,"c:dc,avctx:ajctx,",166.0,0.0876334945360819,Greedy
171,"static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,

                         V9fsPath *dir_path, const char *name, FsCred *credp)

{

    int retval;

    V9fsString fullname, target;



    v9fs_string_init(&fullname);

    v9fs_string_init(&target);



    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);

    v9fs_string_sprintf(&target, ""%s"", oldpath);



    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",

                          &target, &fullname, credp->fc_uid, credp->fc_gid);

    v9fs_string_free(&fullname);

    v9fs_string_free(&target);

    if (retval < 0) {

        errno = -retval;

        retval = -1;

    }

    return retval;

}
","static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,

                         V9fsPath *dir_path, const char *name, FsCred *creedpo)

{

    int rev;

    V9fsString fulpart, filename;



    v9fs_string_init(&fulpart);

    v9fs_string_init(&filename);



    v9fs_string_sprintf(&fulpart, ""%s/%s"", dir_path->data, name);

    v9fs_string_sprintf(&filename, ""%s"", oldpath);



    rev = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",

                          &filename, &fulpart, creedpo->fc_uid, creedpo->fc_gid);

    v9fs_string_free(&fulpart);

    v9fs_string_free(&filename);

    if (rev < 0) {

        errno = -rev;

        rev = -1;

    }

    return rev;

}
",136.0,37.0,"retval:rev,target:filename,fullname:fulpart,credp:creedpo,",243.0,0.1170105775197347,Greedy
174,"void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
","void helper_store_fpcr (uint64_t base)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((base >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((base >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
",89.0,19.0,"val:base,",48.0,0.0304929931958516,Greedy
175,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)

{

    tcet->bypass = bypass;

}
","void spapr_tce_set_bypass(sPAPRTCETable *tgen, bool bypass)

{

    tgen->bypass = bypass;

}
",18.0,5.0,"tcet:tgen,",35.0,0.0238802353541056,Greedy
176,"void qemu_system_wakeup_request(WakeupReason reason)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << reason))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &reason);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
","void qemu_system_wakeup_request(WakeupReason null)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << null))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &null);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
",67.0,15.0,"reason:null,",61.0,0.0312662601470947,Greedy
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
","static int parse_uint8(DeviceState *dev, Property *prot, const char *str)

{

    uint8_t *func = qdev_get_prop_ptr(dev, prot);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, func) != 1)

        return -EINVAL;

    return 0;

}
",77.0,19.0,"prop:prot,ptr:func,",88.0,0.0467360615730285,Greedy
199,"static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
","static inline int cpu_gdb_index(CPUState *fc)

{

#if defined(CONFIG_USER_ONLY)

    return fc->host_tid;

#else

    return fc->cpu_index + 1;

#endif

}
",31.0,5.0,"cpu:fc,",51.0,0.0264099200566609,Greedy
204,"static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
","static void curl_multi_do(void *arg)

{

    BDRVCURLState *d = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!d->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(d->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(d);

}
",64.0,15.0,"s:d,",69.0,0.0357814828554789,Greedy
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
","bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *Pett, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(Pett);

    assert(Pett->max_raw_frags > Pett->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &Pett->raw[Pett->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    Pett->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
",122.0,28.0,"pkt:Pett,",73.0,0.0387484192848205,Greedy
216,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}
","static av_cold int init_bundles(BinkContext *enc)

{

    int fwd, hp, waves;

    int interface;



    fwd = (enc->avctx->width  + 7) >> 3;

    hp = (enc->avctx->height + 7) >> 3;

    waves = fwd * hp;



    for (interface = 0; interface < BINKB_NB_SRC; interface++) {

        enc->bundle[interface].data = av_malloc(waves * 64);

        if (!enc->bundle[interface].data)

            return AVERROR(ENOMEM);

        enc->bundle[interface].data_end = enc->bundle[interface].data + waves * 64;

    }



    return 0;

}
",129.0,31.0,"blocks:waves,bw:fwd,bh:hp,i:interface,c:enc,",278.0,0.1363521377245585,Greedy
219,"void cpu_exec_init(CPUState *env)

{

    CPUState **penv;

    int cpu_index;



    if (!code_gen_ptr) {

        code_gen_ptr = code_gen_buffer;

        page_init();

        io_mem_init();

    }

    env->next_cpu = NULL;

    penv = &first_cpu;

    cpu_index = 0;

    while (*penv != NULL) {

        penv = (CPUState **)&(*penv)->next_cpu;

        cpu_index++;

    }

    env->cpu_index = cpu_index;


    *penv = env;

}","void cpu_exec_init(CPUState *env)

{

    CPUState **penv;

    int pc__size;



    if (!code_gen_ptr) {

        code_gen_ptr = code_gen_buffer;

        page_init();

        io_mem_init();

    }

    env->next_cpu = NULL;

    penv = &first_cpu;

    pc__size = 0;

    while (*penv != NULL) {

        penv = (CPUState **)&(*penv)->next_cpu;

        pc__size++;

    }

    env->pc__size = pc__size;


    *penv = env;

}",89.0,21.0,"cpu_index:pc__size,",72.0,0.0377654353777567,Greedy
220,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	long width, long height,

	long lumStride, long chromStride, long dstStride)

{

	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
","static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *fsl, uint8_t *dst,

	long width, long height,

	long lumStride, long chromStride, long dstTrip)

{

	RENAME(yuvPlanartoyuy2)(ysrc, usrc, fsl, dst, width, height, lumStride, chromStride, dstTrip, 1);

}
",70.0,21.0,"dstStride:dstTrip,vsrc:fsl,",84.0,0.0437553882598876,Greedy
225,"static int add_candidate_ref(HEVCContext *s, RefPicList *list,

                             int poc, int ref_flag)

{

    HEVCFrame *ref = find_ref_idx(s, poc);



    if (ref == s->ref)

        return AVERROR_INVALIDDATA;



    if (!ref) {

        ref = generate_missing_ref(s, poc);

        if (!ref)

            return AVERROR(ENOMEM);

    }



    list->list[list->nb_refs] = ref->poc;

    list->ref[list->nb_refs]  = ref;

    list->nb_refs++;



    mark_ref(ref, ref_flag);

    return 0;

}
","static int add_candidate_ref(HEVCContext *s, RefPicList *list,

                             int jpc, int ref2flags)

{

    HEVCFrame *ref = find_ref_idx(s, jpc);



    if (ref == s->ref)

        return AVERROR_INVALIDDATA;



    if (!ref) {

        ref = generate_missing_ref(s, jpc);

        if (!ref)

            return AVERROR(ENOMEM);

    }



    list->list[list->nb_refls] = ref->jpc;

    list->ref[list->nb_refls]  = ref;

    list->nb_refls++;



    mark_ref(ref, ref2flags);

    return 0;

}
",108.0,30.0,"nb_refs:nb_refls,ref_flag:ref2flags,poc:jpc,",122.0,0.0649505853652954,Greedy
228,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,

                                         src - (stride * 2) +

                                         sizeof(uint8_t), stride, dst, stride);

}
","void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *rec,

                                ptrdiff_t Strid)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(rec - 2,

                                         rec - (Strid * 2) +

                                         sizeof(uint8_t), Strid, dst, Strid);

}
",43.0,11.0,"stride:Strid,src:rec,",100.0,0.0482678294181823,Greedy
229,"static int net_vhost_user_init(NetClientState *peer, const char *device,

                               const char *name, CharDriverState *chr,

                               int queues)

{

    NetClientState *nc;

    VhostUserState *s;

    int i;



    for (i = 0; i < queues; i++) {

        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);



        snprintf(nc->info_str, sizeof(nc->info_str), ""vhost-user%d to %s"",

                 i, chr->label);



        nc->queue_index = i;



        s = DO_UPCAST(VhostUserState, nc, nc);

        s->chr = chr;

    }



    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);



    return 0;

}
","static int net_vhost_user_init(NetClientState *peer, const char *device,

                               const char *wrapper, CharDriverState *chr,

                               int queues)

{

    NetClientState *nc;

    VhostUserState *s;

    int i;



    for (i = 0; i < queues; i++) {

        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, wrapper);



        snprintf(nc->info_str, sizeof(nc->info_str), ""vhost-user%d to %s"",

                 i, chr->label);



        nc->queue_index = i;



        s = DO_UPCAST(VhostUserState, nc, nc);

        s->chr = chr;

    }



    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)wrapper);



    return 0;

}
",133.0,37.0,"name:wrapper,",80.0,0.0436408996582031,Greedy
230,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
","static int flv_probe(AVProbeData *p)

{

    const uint8_t *dc;



    if (p->buf_size < 6)

        return 0;

    dc = p->buf;

    if (dc[0] == 'F' && dc[1] == 'L' && dc[2] == 'V' && dc[3] < 5 && dc[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
",80.0,12.0,"d:dc,",64.0,0.0335456212361653,Greedy
233,"static int spawn_thread(void)

{

    pthread_attr_t attr;

    int ret;



    cur_threads++;

    idle_threads++;



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);

    pthread_attr_destroy(&attr);



    return ret;

}
","static int spawn_thread(void)

{

    pthread_attr_t arg;

    int ret;



    cur_threads++;

    idle_threads++;



    pthread_attr_init(&arg);

    pthread_attr_setdetachstate(&arg, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&thread_id, &arg, aio_thread, NULL);

    pthread_attr_destroy(&arg);



    return ret;

}
",58.0,18.0,"attr:arg,",71.0,0.0376573840777079,Greedy
240,"int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    l = &s->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

}
","int gen_new_label(void)

{

    TCGContext *rs = &tcg_ctx;

    int IDz;

    TCGLabel *la;



    if (rs->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    IDz = rs->nb_labels++;

    la = &rs->labels[IDz];

    la->has_value = 0;

    la->u.first_reloc = NULL;

    return IDz;

}
",67.0,16.0,"l:la,s:rs,idx:IDz,",147.0,0.0694096326828002,Greedy
241,"void bdrv_round_to_clusters(BlockDriverState *bs,

                            int64_t sector_num, int nb_sectors,

                            int64_t *cluster_sector_num,

                            int *cluster_nb_sectors)

{

    BlockDriverInfo bdi;



    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {

        *cluster_sector_num = sector_num;

        *cluster_nb_sectors = nb_sectors;

    } else {

        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;

        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);

        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +

                                            nb_sectors, c);

    }

}
","void bdrv_round_to_clusters(BlockDriverState *db,

                            int64_t section_name, int nb_verics,

                            int64_t *cluster_tier_size,

                            int *cluster_nb_secs)

{

    BlockDriverInfo dadi;



    if (bdrv_get_info(db, &dadi) < 0 || dadi.cluster_size == 0) {

        *cluster_tier_size = section_name;

        *cluster_nb_secs = nb_verics;

    } else {

        int64_t c = dadi.cluster_size / BDRV_SECTOR_SIZE;

        *cluster_tier_size = QEMU_ALIGN_DOWN(section_name, c);

        *cluster_nb_secs = QEMU_ALIGN_UP(section_name - *cluster_tier_size +

                                            nb_verics, c);

    }

}
",93.0,28.0,"bdi:dadi,cluster_sector_num:cluster_tier_size,bs:db,cluster_nb_sectors:cluster_nb_secs,nb_sectors:nb_verics,sector_num:section_name,",198.0,0.1034120281537373,Greedy
244,"static int idreg_init1(SysBusDevice *dev)

{

    IDRegState *s = MACIO_ID_REGISTER(dev);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&s->mem);

    memory_region_set_readonly(&s->mem, true);

    sysbus_init_mmio(dev, &s->mem);

    return 0;

}
","static int idreg_init1(SysBusDevice *ver)

{

    IDRegState *service = MACIO_ID_REGISTER(ver);



    memory_region_init_ram(&service->mem, OBJECT(service),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&service->mem);

    memory_region_set_readonly(&service->mem, true);

    sysbus_init_mmio(ver, &service->mem);

    return 0;

}
",74.0,18.0,"dev:ver,s:service,",112.0,0.0538394490877787,Greedy
257,"void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (ctx->cid_table->bit_depth == 8)

            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
","void ff_dnxhdenc_init_x86(DNXHDEncContext *cm)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (cm->cid_table->bit_depth == 8)

            cm->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
",39.0,8.0,"ctx:cm,",55.0,0.030143916606903,Greedy
266,"void disas_a64_insn(CPUARMState *env, DisasContext *s)

{

    uint32_t insn;



    insn = arm_ldl_code(env, s->pc, s->bswap_code);

    s->insn = insn;

    s->pc += 4;



    switch ((insn >> 24) & 0x1f) {

    default:

        unallocated_encoding(s);

        break;

    }



    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {

        /* go through the main loop for single step */

        s->is_jmp = DISAS_JUMP;

    }

}
","void disas_a64_insn(CPUARMState *viron, DisasContext *sym)

{

    uint32_t insn;



    insn = arm_ldl_code(viron, sym->pc, sym->bswap_code);

    sym->insn = insn;

    sym->pc += 4;



    switch ((insn >> 24) & 0x1f) {

    default:

        unallocated_encoding(sym);

        break;

    }



    if (unlikely(sym->singlestep_enabled) && (sym->is_jmp == DISAS_TB_JUMP)) {

        /* go through the main loop for single step */

        sym->is_jmp = DISAS_JUMP;

    }

}
",89.0,21.0,"s:sym,env:viron,",111.0,0.0541083455085754,Greedy
275,"void bdrv_delete(BlockDriverState *bs)

{

    assert(!bs->peer);



    /* remove from list, if necessary */

    if (bs->device_name[0] != '\0') {

        QTAILQ_REMOVE(&bdrv_states, bs, list);

    }



    bdrv_close(bs);

    if (bs->file != NULL) {

        bdrv_delete(bs->file);

    }



    assert(bs != bs_snapshots);

    qemu_free(bs);

}
","void bdrv_delete(BlockDriverState *base)

{

    assert(!base->peer);



    /* remove from list, if necessary */

    if (base->device_name[0] != '\0') {

        QTAILQ_REMOVE(&bdrv_states, base, list);

    }



    bdrv_close(base);

    if (base->file != NULL) {

        bdrv_delete(base->file);

    }



    assert(base != bs_snapshots);

    qemu_free(base);

}
",76.0,19.0,"bs:base,",75.0,0.0360374093055725,Greedy
283,"void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);

}
","void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *url,

                                ptrdiff_t STRine)

{

    avc_luma_midv_qrt_8w_msa(url - (2 * STRine) - 2, STRine, dst, STRine, 8, 0);

}
",40.0,10.0,"stride:STRine,src:url,",94.0,0.0459617257118225,Greedy
284,"static void serial_tx_done(void *opaque)

{

    SerialState *s = opaque;



    if (s->tx_burst < 0) {

        uint16_t divider;



        if (s->divider)

          divider = s->divider;

        else

          divider = 1;



        /* We assume 10 bits/char, OK for this purpose. */

        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /

            (1000000 * 10 / (s->baudbase / divider));

    }

    s->thr_ipending = 1;

    s->lsr |= UART_LSR_THRE;

    s->lsr |= UART_LSR_TEMT;

    serial_update_irq(s);

}
","static void serial_tx_done(void *paques)

{

    SerialState *s = paques;



    if (s->tx_burst < 0) {

        uint16_t divider;



        if (s->divider)

          divider = s->divider;

        else

          divider = 1;



        /* We assume 10 bits/char, OK for this purpose. */

        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /

            (1000000 * 10 / (s->baudbase / divider));

    }

    s->thr_ipending = 1;

    s->lsr |= UART_LSR_THRE;

    s->lsr |= UART_LSR_TEMT;

    serial_update_irq(s);

}
",91.0,21.0,"opaque:paques,",45.0,0.0302386840184529,Greedy
297,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)

{

    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
","static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)

{

    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access2string[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access2string) && access2string[access]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access2string[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
",170.0,39.0,"access_text:access2string,",59.0,0.0370949228604634,Greedy
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
","uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t vol, uint32_t power)

{

    uint64_t eff;

    uint32_t result;



    power &= 63;

    eff = (uint64_t)vol << 32 >> power;

    result = eff >> 32;



    env->cc_c = (eff >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = power ? env->cc_c : env->cc_x;



    return result;

}
",92.0,24.0,"val:vol,shift:power,temp:eff,",165.0,0.0790223320325215,Greedy
302,"static int decode_cabac_mb_cbp_luma( H264Context *h) {

    int cbp_b, cbp_a, ctx, cbp = 0;



    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;

    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;



    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);

    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;

    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;

    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;

    return cbp;

}
","static int decode_cabac_mb_cbp_luma( H264Context *c) {

    int cbp_b, cbp_a, ctx, cbp = 0;



    cbp_a = c->slice_table[c->left_mb_xy[0]] == c->slice_num ? c->left_cbp : -1;

    cbp_b = c->slice_table[c->top_mb_xy]     == c->slice_num ? c->top_cbp  : -1;



    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);

    cbp |= get_cabac_noinline(&c->cabac, &c->cabac_state[73 + ctx]);

    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);

    cbp |= get_cabac_noinline(&c->cabac, &c->cabac_state[73 + ctx]) << 1;

    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&c->cabac, &c->cabac_state[73 + ctx]) << 2;

    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&c->cabac, &c->cabac_state[73 + ctx]) << 3;

    return cbp;

}
",227.0,49.0,"h:c,",89.0,0.0537413597106933,Greedy
307,"void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}
","void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vwork;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vwork = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vwork, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vwork);

#endif

}
",80.0,23.0,"vaddr:vwork,",45.0,0.0291936198870341,Greedy
308,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)

{

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);

    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;

    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!eject) {

        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
","static void patch_pcihp(int slot, uint8_t *ssdc_pointer, uint32_t eject)

{

    ssdc_pointer[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);

    ssdc_pointer[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);

    ssdc_pointer[ACPI_PCIHP_OFFSET_ID] = slot;

    ssdc_pointer[ACPI_PCIHP_OFFSET_ADR + 2] = slot;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(ssdc_pointer + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!eject) {

        memcpy(ssdc_pointer + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
",91.0,26.0,"ssdt_ptr:ssdc_pointer,",49.0,0.0329391519228617,Greedy
310,"static void nvme_instance_init(Object *obj)

{

    object_property_add(obj, ""bootindex"", ""int32"",

                        nvme_get_bootindex,

                        nvme_set_bootindex, NULL, NULL, NULL);

    object_property_set_int(obj, -1, ""bootindex"", NULL);

}
","static void nvme_instance_init(Object *api)

{

    object_property_add(api, ""bootindex"", ""int32"",

                        nvme_get_bootindex,

                        nvme_set_bootindex, NULL, NULL, NULL);

    object_property_set_int(api, -1, ""bootindex"", NULL);

}
",43.0,8.0,"obj:api,",55.0,0.0311312079429626,Greedy
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
","static void hScale8To15_c(SwsContext *cy, int16_t * dft, int dstWeight, const uint8_t *support,

                          const int16_t *support, const int16_t *FilterType,

                          int sortSize)

{

    int i;

    for (i=0; i<dstWeight; i++) {

        int j;

        int srcPos= FilterType[i];

        int val=0;

        for (j=0; j<sortSize; j++) {

            val += ((int)support[srcPos + j])*support[sortSize*i + j];

        }

        //filter += hFilterSize;

         dft[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
",127.0,34.0,"c:cy,dst: dft,dstW:dstWeight,filterPos:FilterType,src:support,filter:support,filterSize:sortSize,",255.0,0.1340100606282552,Greedy
316,"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(sockfd, iov,

                            offset + done, bytes - done, do_send);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
","qemu_co_sendv_recvv(int socksfx, struct iovec *voice, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t fun;

    while (done < bytes) {

        fun = iov_send_recv(socksfx, voice,

                            offset + done, bytes - done, do_send);

        if (fun > 0) {

            done += fun;

        } else if (fun < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (fun == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
",126.0,31.0,"sockfd:socksfx,iov:voice,ret:fun,",162.0,0.0843045155207316,Greedy
329,"static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,

                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

                         BlockDriverCompletionFunc *cb, void *opaque)

{

    BDRVRawState *s = bs->opaque;

    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,

                       cb, opaque, QEMU_AIO_READ);

}
","static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bes,

                         int64_t sector_num, QEMUIOVector *qqdyl, int nb_sectors,

                         BlockDriverCompletionFunc *bf, void *opacity)

{

    BDRVRawState *secondary = bes->opacity;

    return paio_submit(bes, secondary->hfile, sector_num, qqdyl, nb_sectors,

                       bf, opacity, QEMU_AIO_READ);

}
",59.0,18.0,"qiov:qqdyl,cb:bf,bs:bes,s:secondary,opaque:opacity,",191.0,0.0923485279083251,Greedy
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
","static void gen_compute_eflags_o(DisasContext *s, TCGv rg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(rg, cpu_cc_src, 11);

    tcg_gen_andi_tl(rg, rg, 1);

}
",36.0,11.0,"reg:rg,",62.0,0.0315599004427592,Greedy
342,"static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int flags)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}
","static int tmv_read_seek(AVFormatContext *s, int streamerstring,

                         int64_t framcision, int fd)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (streamerstring)

        return -1;



    pos = framcision *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->streamerstring = 0;

    return 0;

}
",77.0,20.0,"timestamp:framcision,flags:fd,stream_index:streamerstring,",121.0,0.0629963795344034,Greedy
346,"static int64_t read_ts(char **line, int *duration)

{

    int64_t start, end;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *duration = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
","static int64_t read_ts(char **line, int *video)

{

    int64_t data, type;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &data, &type) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *video = type - data;

        return data;

    }

    return AV_NOPTS_VALUE;

}
",73.0,19.0,"duration:video,end:type,start:data,",145.0,0.0666478276252746,Greedy
350,"static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)

{

    char *path = NULL, *buf = NULL, *host = NULL;



    /* Get the PCI VFIO host id */

    host = object_property_get_str(OBJECT(pdev), ""host"", NULL);

    if (!host) {

        goto err_out;

    }



    /* Construct the path of the file that will give us the DT location */

    path = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", host);

    g_free(host);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    g_free(path);



    /* Construct and read from host device tree the loc-code */

    path = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);

    g_free(buf);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    return buf;



err_out:

    g_free(path);

    return NULL;

}
","static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphw,  PCIDevice *pserv)

{

    char *path = NULL, *broad = NULL, *route = NULL;



    /* Get the PCI VFIO host id */

    route = object_property_get_str(OBJECT(pserv), ""host"", NULL);

    if (!route) {

        goto err_out;

    }



    /* Construct the path of the file that will give us the DT location */

    path = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", route);

    g_free(route);

    if (!path || !g_file_get_contents(path, &broad, NULL, NULL)) {

        goto err_out;

    }

    g_free(path);



    /* Construct and read from host device tree the loc-code */

    path = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", broad);

    g_free(broad);

    if (!path || !g_file_get_contents(path, &broad, NULL, NULL)) {

        goto err_out;

    }

    return broad;



err_out:

    g_free(path);

    return NULL;

}
",150.0,34.0,"pdev:pserv,sphb:sphw,buf:broad,host:route,",198.0,0.1036371072133382,Greedy
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
","static void gen_storeq_reg(DisasContext *services, int plow, int rrhighest, TCGv_i64 func)

{

    TCGv property;

    property = new_tmp();

    tcg_gen_trunc_i64_i32(property, func);

    store_reg(services, plow, property);

    property = new_tmp();

    tcg_gen_shri_i64(func, func, 32);

    tcg_gen_trunc_i64_i32(property, func);

    store_reg(services, rrhighest, property);

}
",75.0,27.0,"rlow:plow,rhigh:rrhighest,s:services,val:func,tmp:property,",235.0,0.110265576839447,Greedy
355,"static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)

{

    int ret = 0;



    assert(len > 0);

    ccid_bulk_in_get(s);

    if (s->current_bulk_in != NULL) {

        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);

        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);

        s->current_bulk_in->pos += ret;

        if (s->current_bulk_in->pos == s->current_bulk_in->len) {

            ccid_bulk_in_release(s);

        }

    } else {

        /* return when device has no data - usb 2.0 spec Table 8-4 */

        ret = USB_RET_NAK;

    }

    if (ret > 0) {

        DPRINTF(s, D_MORE_INFO,

                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);

    }

    if (ret != USB_RET_NAK && ret < len) {

        DPRINTF(s, 1,

            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);

    }

    return ret;

}
","static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *info, int lan)

{

    int ret = 0;



    assert(lan > 0);

    ccid_bulk_in_get(s);

    if (s->current_bulk_in != NULL) {

        ret = MIN(s->current_bulk_in->lan - s->current_bulk_in->pos, lan);

        memcpy(info, s->current_bulk_in->info + s->current_bulk_in->pos, ret);

        s->current_bulk_in->pos += ret;

        if (s->current_bulk_in->pos == s->current_bulk_in->lan) {

            ccid_bulk_in_release(s);

        }

    } else {

        /* return when device has no data - usb 2.0 spec Table 8-4 */

        ret = USB_RET_NAK;

    }

    if (ret > 0) {

        DPRINTF(s, D_MORE_INFO,

                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, lan, ret);

    }

    if (ret != USB_RET_NAK && ret < lan) {

        DPRINTF(s, 1,

            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, lan);

    }

    return ret;

}
",175.0,45.0,"data:info,len:lan,",143.0,0.0757862607638041,Greedy
358,"static void decode_mclms(WmallDecodeCtx *s)

{

    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;

    s->mclms_scaling = get_bits(&s->gb, 4);

    if(get_bits1(&s->gb)) {

	// mclms_send_coef

	int i;

	int send_coef_bits;

	int cbits = av_log2(s->mclms_scaling + 1);

	assert(cbits == my_log2(s->mclms_scaling + 1));

	if(1 << cbits < s->mclms_scaling + 1)

	    cbits++;



	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;



	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {

	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);

	}



	for(i = 0; i < s->num_channels; i++) {

	    int c;

	    for(c = 0; c < i; c++) {

		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);

	    }

	}

    }

}
","static void decode_mclms(WmallDecodeCtx *features)

{

    features->mclms_order = (get_bits(&features->gb, 4) + 1) * 2;

    features->mclms_scaling = get_bits(&features->gb, 4);

    if(get_bits1(&features->gb)) {

	// mclms_send_coef

	int info;

	int send_coof_notes;

	int cfbs = av_log2(features->mclms_scaling + 1);

	assert(cfbs == my_log2(features->mclms_scaling + 1));

	if(1 << cfbs < features->mclms_scaling + 1)

	    cfbs++;



	send_coof_notes = (cfbs ? get_bits(&features->gb, cfbs) : 0) + 2;



	for(info = 0; info < features->mclms_order * features->num_channels * features->num_channels; info++) {

	    features->mclms_coeffs[info] = get_bits(&features->gb, send_coof_notes);

	}



	for(info = 0; info < features->num_channels; info++) {

	    int arc;

	    for(arc = 0; arc < info; arc++) {

		features->mclms_coeffs_cur[info * features->num_channels + arc] = get_bits(&features->gb, send_coof_notes);

	    }

	}

    }

}
",223.0,54.0,"send_coef_bits:send_coof_notes,cbits:cfbs,c:arc,i:info,s:features,",360.0,0.2028744061787923,Greedy
362,"void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)

{

    int bits = 8, sign = 0, shift = 0;



    switch (as->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    info->freq = as->freq;

    info->bits = bits;

    info->sign = sign;

    info->nchannels = as->nchannels;

    info->shift = (as->nchannels == 2) + shift;

    info->align = (1 << info->shift) - 1;

    info->bytes_per_second = info->freq << info->shift;

    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);

}
","void audio_pcm_init_info (struct audio_pcm_info *comment, audsettings_t *nas)

{

    int bits = 8, sign = 0, shift = 0;



    switch (nas->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    comment->freq = nas->freq;

    comment->bits = bits;

    comment->sign = sign;

    comment->nchannels = nas->nchannels;

    comment->shift = (nas->nchannels == 2) + shift;

    comment->align = (1 << comment->shift) - 1;

    comment->bytes_per_second = comment->freq << comment->shift;

    comment->swap_endianness = (nas->endianness != AUDIO_HOST_ENDIANNESS);

}
",167.0,39.0,"info:comment,as:nas,",155.0,0.0770407080650329,Greedy
364,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)

{

    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);

}
","void isa_mmio_setup(MemoryRegion *dr, target_phys_addr_t size)

{

    memory_region_init_io(dr, &isa_mmio_ops, NULL, ""isa-mmio"", size);

}
",27.0,7.0,"mr:dr,",44.0,0.0261477669080098,Greedy
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
","int qio_channel_socket_dgram_sync(QIOChannelSocket *antioci,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(antioci, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(antioci);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(antioci, fd);

    if (qio_channel_socket_set_fd(antioci, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
",94.0,27.0,"ioc:antioci,",80.0,0.0414529601732889,Greedy
367,"int memory_region_get_fd(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}
","int memory_region_get_fd(MemoryRegion *dr)

{

    if (dr->alias) {

        return memory_region_get_fd(dr->alias);

    }



    assert(dr->terminates);



    return qemu_get_ram_fd(dr->ram_addr & TARGET_PAGE_MASK);

}
",42.0,10.0,"mr:dr,",54.0,0.0283317724863688,Greedy
368,"static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,

                              TCGReg r1, TCGReg r2, TCGReg rn,

                              tcg_target_long ofs, bool pre, bool w)

{

    insn |= 1u << 31; /* ext */

    insn |= pre << 24;

    insn |= w << 23;



    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);

    insn |= (ofs & (0x7f << 3)) << (15 - 3);



    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);

}
","static void tcg_out_insn_3314(TCGContext *ses, AArch64Insn Inspn,

                              TCGReg rcOne, TCGReg r8, TCGReg rn,

                              tcg_target_long accountsup, bool PRE, bool r)

{

    Inspn |= 1u << 31; /* ext */

    Inspn |= PRE << 24;

    Inspn |= r << 23;



    assert(accountsup >= -0x200 && accountsup < 0x200 && (accountsup & 7) == 0);

    Inspn |= (accountsup & (0x7f << 3)) << (15 - 3);



    tcg_out32(ses, Inspn | r8 << 10 | rn << 5 | rcOne);

}
",103.0,26.0,"insn:Inspn,s:ses,ofs:accountsup,pre:PRE,w:r,r1:rcOne,r2:r8,",288.0,0.144057027498881,Greedy
369,"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,

                                   const char *name, Error **errp)

{

    X86CPU *cpu = X86_CPU(obj);

    const int64_t min = 0;

    const int64_t max = INT_MAX;

    int64_t value;



    visit_type_int(v, &value, name, errp);

    if (error_is_set(errp)) {

        return;

    }

    if (value < min || value > max) {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  name ? name : ""null"", value, min, max);

        return;

    }



    cpu->env.tsc_khz = value / 1000;

}
","static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,

                                   const char *name, Error **errp)

{

    X86CPU *cpu = X86_CPU(obj);

    const int64_t min = 0;

    const int64_t max = INT_MAX;

    int64_t total;



    visit_type_int(v, &total, name, errp);

    if (error_is_set(errp)) {

        return;

    }

    if (total < min || total > max) {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  name ? name : ""null"", total, min, max);

        return;

    }



    cpu->env.tsc_khz = total / 1000;

}
",122.0,34.0,"value:total,",86.0,0.0424946228663126,Greedy
371,"static av_cold int check_format(AVCodecContext *avctx)

{

    AVCodecParserContext *parser;

    uint8_t *pout;

    int psize;

    int index;

    H264Context *h;

    int ret = -1;



    /* init parser & parse file */

    parser = av_parser_init(avctx->codec->id);

    if (!parser) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to open H.264 parser.\n"");

        goto final;

    }

    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;

    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);

    if (index < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to parse this file.\n"");

        goto release_parser;

    }



    /* check if support */

    h = parser->priv_data;

    switch (h->sps.bit_depth_luma) {

    case 8:

        if (!CHROMA444(h) && !CHROMA422(h)) {

            // only this will H.264 decoder switch to hwaccel

            ret = 0;

            break;

        }

    default:

        av_log(avctx, AV_LOG_ERROR, ""Unsupported file.\n"");

    }



release_parser:

    av_parser_close(parser);



final:

    return ret;

}
","static av_cold int check_format(AVCodecContext *AVctx)

{

    AVCodecParserContext *fork;

    uint8_t *pout;

    int psize;

    int index;

    H264Context *h;

    int ret = -1;



    /* init parser & parse file */

    fork = av_parser_init(AVctx->codec->id);

    if (!fork) {

        av_log(AVctx, AV_LOG_ERROR, ""Failed to open H.264 parser.\n"");

        goto final;

    }

    fork->flags = PARSER_FLAG_COMPLETE_FRAMES;

    index = av_parser_parse2(fork, AVctx, &pout, &psize, NULL, 0, 0, 0, 0);

    if (index < 0) {

        av_log(AVctx, AV_LOG_ERROR, ""Failed to parse this file.\n"");

        goto release_parser;

    }



    /* check if support */

    h = fork->priv_data;

    switch (h->sps.bit_depth_luma) {

    case 8:

        if (!CHROMA444(h) && !CHROMA422(h)) {

            // only this will H.264 decoder switch to hwaccel

            ret = 0;

            break;

        }

    default:

        av_log(AVctx, AV_LOG_ERROR, ""Unsupported file.\n"");

    }



release_parser:

    av_parser_close(fork);



final:

    return ret;

}
",185.0,42.0,"parser:fork,avctx:AVctx,",144.0,0.0803178230921427,Greedy
372,"static unsigned int dec_move_mr(DisasContext *dc)

{

	int memsize = memsize_zz(dc);

	int insn_len;

	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",

		    memsize_char(memsize),

		    dc->op1, dc->postinc ? ""+]"" : ""]"",

		    dc->op2));



	if (memsize == 4) {

		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_update_cc_op(dc, CC_OP_MOVE, 4);

		cris_update_cc_x(dc);

		cris_update_result(dc, cpu_R[dc->op2]);

	}

	else {

		TCGv t0;



		t0 = tcg_temp_new(TCG_TYPE_TL);

		insn_len = dec_prep_move_m(dc, 0, memsize, t0);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_alu(dc, CC_OP_MOVE,

			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);

		tcg_temp_free(t0);

	}

	do_postinc(dc, memsize);

	return insn_len;

}
","static unsigned int dec_move_mr(DisasContext *coll)

{

	int memsize = memsize_zz(coll);

	int insnOxpre;

	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",

		    memsize_char(memsize),

		    coll->op1, coll->postinc ? ""+]"" : ""]"",

		    coll->op2));



	if (memsize == 4) {

		insnOxpre = dec_prep_move_m(coll, 0, 4, cpu_R[coll->op2]);

		cris_cc_mask(coll, CC_MASK_NZ);

		cris_update_cc_op(coll, CC_OP_MOVE, 4);

		cris_update_cc_x(coll);

		cris_update_result(coll, cpu_R[coll->op2]);

	}

	else {

		TCGv txfrom;



		txfrom = tcg_temp_new(TCG_TYPE_TL);

		insnOxpre = dec_prep_move_m(coll, 0, memsize, txfrom);

		cris_cc_mask(coll, CC_MASK_NZ);

		cris_alu(coll, CC_OP_MOVE,

			    cpu_R[coll->op2], cpu_R[coll->op2], txfrom, memsize);

		tcg_temp_free(txfrom);

	}

	do_postinc(coll, memsize);

	return insnOxpre;

}
",189.0,59.0,"dc:coll,insn_len:insnOxpre,t0:txfrom,",185.0,0.0984166264533996,Greedy
378,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,

        BlockCompletionFunc *cb, void *opaque)

{

    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);



    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,

                                 BDRV_REQ_ZERO_WRITE | flags,

                                 cb, opaque, true);

}
","BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *db,

        int64_t  sector_name, int nb_sectors, BdrvRequestFlags flags,

        BlockCompletionFunc *cc, void *compaque)

{

    trace_bdrv_aio_write_zeroes(db,  sector_name, nb_sectors, flags, compaque);



    return bdrv_co_aio_rw_vector(db,  sector_name, NULL, nb_sectors,

                                 BDRV_REQ_ZERO_WRITE | flags,

                                 cc, compaque, true);

}
",62.0,21.0,"bs:db,sector_num: sector_name,opaque:compaque,cb:cc,",139.0,0.0998708248138427,Greedy
379,"static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    proxy->flags = 0;

}
","static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *null = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(null->vdev);

    msix_reset(&null->pci_dev);

    null->flags = 0;

}
",46.0,12.0,"proxy:null,",65.0,0.0451693892478942,Greedy
380,"static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,

                            TCGReg dst, TCGReg lhs, TCGArg rhs,

                            bool rhs_is_const)

{

    /* Emit either the reg,imm or reg,reg form of a data-processing insn.

     * rhs must satisfy the ""rIK"" constraint.

     */

    if (rhs_is_const) {

        int rot = encode_imm(rhs);

        if (rot < 0) {

            rhs = ~rhs;

            rot = encode_imm(rhs);

            assert(rot >= 0);

            opc = opinv;

        }

        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));

    } else {

        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));

    }

}
","static void tcg_out_dat_rIK(TCGContext *ses, int cond, int OPci, int opinv,

                            TCGReg Dsc, TCGReg lhs, TCGArg prhh,

                            bool rhs_is_const)

{

    /* Emit either the reg,imm or reg,reg form of a data-processing insn.

     * rhs must satisfy the ""rIK"" constraint.

     */

    if (rhs_is_const) {

        int rot = encode_imm(prhh);

        if (rot < 0) {

            prhh = ~prhh;

            rot = encode_imm(prhh);

            assert(rot >= 0);

            OPci = opinv;

        }

        tcg_out_dat_imm(ses, cond, OPci, Dsc, lhs, rotl(prhh, rot) | (rot << 7));

    } else {

        tcg_out_dat_reg(ses, cond, OPci, Dsc, lhs, prhh, SHIFT_IMM_LSL(0));

    }

}
",125.0,41.0,"rhs:prhh,dst:Dsc,s:ses,opc:OPci,",213.0,0.1432365536689758,Greedy
386,"static inline int popcountl(unsigned long l)

{

    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);

}
","static inline int popcountl(unsigned long li)

{

    return BITS_PER_LONG == 32 ? ctpop32(li) : ctpop64(li);

}
",26.0,7.0,"l:li,",46.0,0.0361234267552693,Greedy
387,"static int32_t parse_gain(const char *gain)

{

    char *fraction;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int db;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    db = strtol(gain, &fraction, 0);

    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }



    if (abs(db) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return db * 100000 + sign * mb;

}
","static int32_t parse_gain(const char *gain)

{

    char *rfract;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int lib;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    lib = strtol(gain, &rfract, 0);

    if (*rfract++ == '.') {

        while (av_isdigit(*rfract) && scale) {

            mb += scale * (*rfract - '0');

            scale /= 10;

            rfract++;

        }

    }



    if (abs(lib) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return lib * 100000 + sign * mb;

}
",145.0,35.0,"db:lib,fraction:rfract,",120.0,0.0809932788213094,Greedy
388,"static inline void ide_dma_submit_check(IDEState *s,

          BlockDriverCompletionFunc *dma_cb)

{

    if (s->bus->dma->aiocb)

	return;

    dma_cb(s, -1);

}
","static inline void ide_dma_submit_check(IDEState *s,

          BlockDriverCompletionFunc *dfa_CB)

{

    if (s->bus->dma->aiocb)

	return;

    dfa_CB(s, -1);

}
",34.0,6.0,"dma_cb:dfa_CB,",17.0,0.0232540051142374,Greedy
402,"static void handle_mousewheel(SDL_Event *ev)

{

    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);

    SDL_MouseWheelEvent *wev = &ev->wheel;

    InputButton btn;



    if (wev->y > 0) {

        btn = INPUT_BUTTON_WHEEL_UP;

    } else if (wev->y < 0) {

        btn = INPUT_BUTTON_WHEEL_DOWN;

    } else {

        return;

    }



    qemu_input_queue_btn(scon->dcl.con, btn, true);

    qemu_input_event_sync();

    qemu_input_queue_btn(scon->dcl.con, btn, false);

    qemu_input_event_sync();

}
","static void handle_mousewheel(SDL_Event *eva)

{

    struct sdl2_console *Sco = get_scon_from_window(eva->key.windowID);

    SDL_MouseWheelEvent *WEw = &eva->wheel;

    InputButton btn;



    if (WEw->y > 0) {

        btn = INPUT_BUTTON_WHEEL_UP;

    } else if (WEw->y < 0) {

        btn = INPUT_BUTTON_WHEEL_DOWN;

    } else {

        return;

    }



    qemu_input_queue_btn(Sco->dcl.con, btn, true);

    qemu_input_event_sync();

    qemu_input_queue_btn(Sco->dcl.con, btn, false);

    qemu_input_event_sync();

}
",104.0,22.0,"scon:Sco,wev:WEw,ev:eva,",137.0,0.1105801264444987,Greedy
403,"static void init_virtio_dev(TestServer *s)

{

    QPCIBus *bus;

    QVirtioPCIDevice *dev;

    uint32_t features;



    bus = qpci_init_pc(NULL);

    g_assert_nonnull(bus);



    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);

    g_assert_nonnull(dev);



    qvirtio_pci_device_enable(dev);

    qvirtio_reset(&dev->vdev);

    qvirtio_set_acknowledge(&dev->vdev);

    qvirtio_set_driver(&dev->vdev);



    features = qvirtio_get_features(&dev->vdev);

    features = features & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&dev->vdev, features);



    qvirtio_set_driver_ok(&dev->vdev);

}
","static void init_virtio_dev(TestServer *fs)

{

    QPCIBus *bus;

    QVirtioPCIDevice *serv;

    uint32_t fts;



    bus = qpci_init_pc(NULL);

    g_assert_nonnull(bus);



    serv = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);

    g_assert_nonnull(serv);



    qvirtio_pci_device_enable(serv);

    qvirtio_reset(&serv->vdev);

    qvirtio_set_acknowledge(&serv->vdev);

    qvirtio_set_driver(&serv->vdev);



    fts = qvirtio_get_features(&serv->vdev);

    fts = fts & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&serv->vdev, fts);



    qvirtio_set_driver_ok(&serv->vdev);

}
",110.0,34.0,"s:fs,features:fts,bus:bus,dev:serv,",221.0,0.1639129161834716,Greedy
405,"static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)

{

    MSDState *s = DO_UPCAST(MSDState, dev, dev);

    scsi_req_cancel(s->req);

}
","static void usb_msd_cancel_io(USBDevice *dev, USBPacket *fp)

{

    MSDState *stats = DO_UPCAST(MSDState, dev, dev);

    scsi_req_cancel(stats->req);

}
",34.0,10.0,"p:fp,s:stats,",78.0,0.0573219855626424,Greedy
408,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)

{

    BlockDriverState *bs = opaque;

    int ret = 0;



    if (bdrv_set_key(bs, password) != 0) {

        monitor_printf(mon, ""invalid password\n"");

        ret = -EPERM;

    }

    if (mon->password_completion_cb)

        mon->password_completion_cb(mon->password_opaque, ret);



    monitor_read_command(mon, 1);

}
","static void bdrv_password_cb(Monitor *mid, const char *password, void *opaque)

{

    BlockDriverState *bs = opaque;

    int ret = 0;



    if (bdrv_set_key(bs, password) != 0) {

        monitor_printf(mid, ""invalid password\n"");

        ret = -EPERM;

    }

    if (mid->password_completion_cb)

        mid->password_completion_cb(mid->password_opaque, ret);



    monitor_read_command(mid, 1);

}
",81.0,20.0,"mon:mid,",78.0,0.0538316965103149,Greedy
411,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
","void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *rec;



    vlan = qemu_find_vlan(vlan_id);



   for(rec = vlan->first_client; rec != NULL; rec = rec->next)

        if (!strcmp(rec->name, device))

            break;



    if (!rec) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(rec);

}
",89.0,23.0,"vc:rec,",82.0,0.0586157441139221,Greedy
416,"void main_loop_wait(int nonblocking)

{

    fd_set rfds, wfds, xfds;

    int ret, nfds;

    struct timeval tv;

    int timeout;



    if (nonblocking)

        timeout = 0;

    else {

        timeout = qemu_calculate_timeout();

        qemu_bh_update_timeout(&timeout);

    }



    os_host_main_loop_wait(&timeout);



    tv.tv_sec = timeout / 1000;

    tv.tv_usec = (timeout % 1000) * 1000;



    /* poll any events */

    /* XXX: separate device handlers from system ones */

    nfds = -1;

    FD_ZERO(&rfds);

    FD_ZERO(&wfds);

    FD_ZERO(&xfds);

    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);

    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);



    qemu_mutex_unlock_iothread();

    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);

    qemu_mutex_lock_iothread();



    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);

    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));



    qemu_run_all_timers();



    /* Check bottom-halves last in case any of the earlier events triggered

       them.  */

    qemu_bh_poll();



}
","void main_loop_wait(int nonblocking)

{

    fd_set xfda, wfds, xfds;

    int ret, nfds;

    struct timeval dev;

    int timeout;



    if (nonblocking)

        timeout = 0;

    else {

        timeout = qemu_calculate_timeout();

        qemu_bh_update_timeout(&timeout);

    }



    os_host_main_loop_wait(&timeout);



    dev.tv_sec = timeout / 1000;

    dev.tv_usec = (timeout % 1000) * 1000;



    /* poll any events */

    /* XXX: separate device handlers from system ones */

    nfds = -1;

    FD_ZERO(&xfda);

    FD_ZERO(&wfds);

    FD_ZERO(&xfds);

    qemu_iohandler_fill(&nfds, &xfda, &wfds, &xfds);

    slirp_select_fill(&nfds, &xfda, &wfds, &xfds);



    qemu_mutex_unlock_iothread();

    ret = select(nfds + 1, &xfda, &wfds, &xfds, &dev);

    qemu_mutex_lock_iothread();



    qemu_iohandler_poll(&xfda, &wfds, &xfds, ret);

    slirp_select_poll(&xfda, &wfds, &xfds, (ret < 0));



    qemu_run_all_timers();



    /* Check bottom-halves last in case any of the earlier events triggered

       them.  */

    qemu_bh_poll();



}
",197.0,59.0,"tv:dev,rfds:xfda,",161.0,0.139556082089742,Greedy
427,"static void i440fx_update_memory_mappings(PCII440FXState *d)

{

    int i, r;

    uint32_t smram;

    bool smram_enabled;



    memory_region_transaction_begin();

    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,

               &d->pam_regions[0]);

    for(i = 0; i < 12; i++) {

        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;

        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,

                   &d->pam_regions[i+1]);

    }

    smram = d->dev.config[I440FX_SMRAM];

    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);

    memory_region_set_enabled(&d->smram_region, !smram_enabled);

    memory_region_transaction_commit();

}
","static void i440fx_update_memory_mappings(PCII440FXState *d)

{

    int i, f;

    uint32_t sbgram;

    bool smram_powered;



    memory_region_transaction_begin();

    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,

               &d->pam_regions[0]);

    for(i = 0; i < 12; i++) {

        f = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;

        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), f,

                   &d->pam_regions[i+1]);

    }

    sbgram = d->dev.config[I440FX_SMRAM];

    smram_powered = (d->smm_enabled && (sbgram & 0x08)) || (sbgram & 0x40);

    memory_region_set_enabled(&d->smram_region, !smram_powered);

    memory_region_transaction_commit();

}
",186.0,38.0,"smram_enabled:smram_powered,smram:sbgram,r:f,",149.0,0.1460872173309326,Greedy
429,"static void control_to_network(RDMAControlHeader *control)

{

    control->type = htonl(control->type);

    control->len = htonl(control->len);

    control->repeat = htonl(control->repeat);

}
","static void control_to_network(RDMAControlHeader *forward)

{

    forward->type = htonl(forward->type);

    forward->len = htonl(forward->len);

    forward->repeat = htonl(forward->repeat);

}
",43.0,11.0,"control:forward,",69.0,0.0626222372055053,Greedy
432,"void *memory_region_get_ram_ptr(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;

    }



    assert(mr->terminates);



    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);

}
","void *memory_region_get_ram_ptr(MemoryRegion *dr)

{

    if (dr->alias) {

        return memory_region_get_ram_ptr(dr->alias) + dr->alias_offset;

    }



    assert(dr->terminates);



    return qemu_get_ram_ptr(dr->ram_addr & TARGET_PAGE_MASK);

}
",47.0,11.0,"mr:dr,",63.0,0.0490410685539245,Greedy
433,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)

{

    afq->avctx             = avctx;

    afq->next_pts          = AV_NOPTS_VALUE;

    afq->remaining_delay   = avctx->delay;

    afq->remaining_samples = avctx->delay;

    afq->frame_queue       = NULL;

}
","void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *awQ)

{

    awQ->avctx             = avctx;

    awQ->next_pts          = AV_NOPTS_VALUE;

    awQ->remaining_delay   = avctx->delay;

    awQ->remaining_samples = avctx->delay;

    awQ->frame_queue       = NULL;

}
",47.0,12.0,"afq:awQ,",89.0,0.0641128500302632,Greedy
434,"void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)

{

    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);

}
","void kvm_s390_service_interrupt(S390CPU *cm, uint32_t park)

{

    kvm_s390_interrupt_internal(cm, KVM_S390_INT_SERVICE, park, 0 , 1);

}
",25.0,7.0,"cpu:cm,parm:park,",75.0,0.0651955246925354,Greedy
449,"enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)

{

    int i;

    for(i=0; i<4 && tags[i]; i++){

        enum CodecID id= codec_get_id(tags[i], tag);

        if(id!=CODEC_ID_NONE) return id;

    }

    return CODEC_ID_NONE;

}
","enum CodecID av_codec_get_id(const AVCodecTag *atts[4], unsigned int tag)

{

    int m;

    for(m=0; m<4 && atts[m]; m++){

        enum CodecID id= codec_get_id(atts[m], tag);

        if(id!=CODEC_ID_NONE) return id;

    }

    return CODEC_ID_NONE;

}
",67.0,18.0,"i:m,tags:atts,",119.0,0.078820780913035,Greedy
463,"void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line_size, const DCTELEM *block/*align 16*/){

    int i, dc = (block[0] + 15) >> 5;

    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;



    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += line_size;

    }

}
","void ff_vp3_idct_dc_add_c(uint8_t *shape/*align 8*/, int line_scale, const DCTELEM *event/*align 16*/){

    int info, dc = (event[0] + 15) >> 5;

    const uint8_t *address = ff_cropTbl + MAX_NEG_CROP + dc;



    for(info = 0; info < 8; info++){

        shape[0] = address[shape[0]];

        shape[1] = address[shape[1]];

        shape[2] = address[shape[2]];

        shape[3] = address[shape[3]];

        shape[4] = address[shape[4]];

        shape[5] = address[shape[5]];

        shape[6] = address[shape[6]];

        shape[7] = address[shape[7]];

        shape += line_scale;

    }

}
",167.0,40.0,"block:event,line_size:line_scale,i:info,cm:address,dest:shape,",304.0,0.2306000272432963,Greedy
464,"void object_property_add_bool(Object *obj, const char *name,

                              bool (*get)(Object *, Error **),

                              void (*set)(Object *, bool, Error **),

                              Error **errp)

{

    BoolProperty *prop = g_malloc0(sizeof(*prop));



    prop->get = get;

    prop->set = set;



    object_property_add(obj, name, ""bool"",

                        get ? property_get_bool : NULL,

                        set ? property_set_bool : NULL,

                        property_release_bool,

                        prop, errp);

}
","void object_property_add_bool(Object *api, const char *name,

                              bool (*service)(Object *, Error **),

                              void (*send)(Object *, bool, Error **),

                              Error **errp)

{

    BoolProperty *prop = g_malloc0(sizeof(*prop));



    prop->service = service;

    prop->send = send;



    object_property_add(api, name, ""bool"",

                        service ? property_get_bool : NULL,

                        send ? property_set_bool : NULL,

                        property_release_bool,

                        prop, errp);

}
",102.0,23.0,"obj:api,get:service,set:send,",154.0,0.1029333511988322,Greedy
465,"static inline int mirror(int v, int m){

    if     (v<0) return -v;

    else if(v>m) return 2*m-v;

    else         return v;

}
","static inline int mirror(int vol, int y){

    if     (vol<0) return -vol;

    else if(vol>y) return 2*y-vol;

    else         return vol;

}
",41.0,10.0,"m:y,v:vol,",107.0,0.0750279267628987,Greedy
475,"static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)

{

#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    struct video_data *s = s1->priv_data;

    AVFrame *frame = s1->streams[0]->codec->coded_frame;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    int res;



    av_init_packet(pkt);

    if ((res = mmap_read_frame(s1, pkt)) < 0) {

        return res;

    }



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    if (frame && s->interlaced) {

        frame->interlaced_frame = 1;

        frame->top_field_first = s->top_field_first;

    }

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    return pkt->size;

}
","static int v4l2_read_packet(AVFormatContext *s1, AVPacket *racket)

{

#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    struct video_data *session = s1->priv_data;

    AVFrame *fake = s1->streams[0]->codec->coded_frame;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    int res;



    av_init_packet(racket);

    if ((res = mmap_read_frame(s1, racket)) < 0) {

        return res;

    }



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    if (fake && session->interlaced) {

        fake->interlaced_frame = 1;

        fake->top_field_first = session->top_field_first;

    }

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    return racket->size;

}
",110.0,25.0,"s1:s1,frame:fake,pkt:racket,s:session,",219.0,0.1759631832440694,Greedy
479,"static int usb_uhci_piix3_initfn(PCIDevice *dev)

{

    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);

    uint8_t *pci_conf = s->dev.config;



    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);

    return usb_uhci_common_initfn(s);

}
","static int usb_uhci_piix3_initfn(PCIDevice *diff)

{

    UHCIState *s ssl DO_UPCAST(UHCIState, diff, diff);

    uint8_t *pcipki_connsssl>diff.config;



    pci_config_set_vendor_id(pki_conn, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pki_conn, PCI_DEVICE_ID_INTEL_82371SB_2);

    return usb_uhci_common_initfn(ssl);

}
",53.0,17.0,"dev:diff,s:ssl,pci_conf:pki_conn,",180.0,0.182565168539683,GA
481,"static unsigned int dec_addi_r(DisasContext *dc)

{

	TCGv t0;

	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",

		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));

	cris_cc_mask(dc, 0);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));

	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);

	tcg_temp_free(t0);

	return 2;

}
","static unsigned int dec_addi_r(DisasContext *db)

{

	TCGv T80;

	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",

		    memsize_char(memsize_zz(db)), db->op2, db->op1));

	cris_cc_mask(db, 0);

	T80 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(T80, cpu_R[db->op2], tcg_const_tl(db->zzsize));

	tcg_gen_add_tl(cpu_R[db->op1], cpu_R[db->op1], T80);

	tcg_temp_free(T80);

	return 2;

}
",102.0,30.0,"dc:db,t0:T80,",115.0,0.1045983672142028,Greedy
485,"static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)

{

    MigrationState *s = opaque;

    if (qemu_file_get_error(s->file)) {

        goto out;

    }



    s->xfer_limit = new_rate;



out:

    return s->xfer_limit;

}
","static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)

{

    MigrationState *S = opaque;

    if (qemu_file_get_error(S->file)) {

        goto out;

    }



    S->xfer_limit = new_rate;



out:

    return S->xfer_limit;

}
",46.0,10.0,"s:S,",67.0,0.061173399289449,Greedy
487,"static void scsi_disk_reset(DeviceState *dev)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);

    uint64_t nb_sectors;



    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));



    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    nb_sectors /= s->qdev.blocksize / 512;

    if (nb_sectors) {

        nb_sectors--;

    }

    s->qdev.max_lba = nb_sectors;

    /* reset tray statuses */

    s->tray_locked = 0;

    s->tray_open = 0;

}
","static void scsi_disk_reset(DeviceState *hw)

{

    SCSIDiskState ss = DO_UPCAST(SCSIDiskState, qdev.qdev, hw);

    uint64_t nb_seqs;



    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));



    bdrv_get_geometry(s->qdev.conf.bs, &nb_seqs);

    nb_seqs /= s->qdev.blocksize / 512;

    if (nb_seqs) {

        nb_seqs--;

    }

    s->qdev.max_lba = nb_seqs;

    /* reset tray statuses */

    s->tray_locked = 0;

    s->tray_open = 0;

}
",94.0,23.0,"dev:hw,s:s,nb_sectors:nb_seqs,",239.0,0.2255010525385538,GA
489,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= src[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;

    }

}
","static void pred8x8_top_dc_rv40_c(uint8_t *attr, int shrine){

    int info;

    int cx;



    cx=0;

    for(info=0;info<8; info++)

        cx+= attr[info-shrine];

    cx= 0x01010101*((cx + 4)>>3);



    for(info=0; info<8; info++){

        ((uint32_t*)(attr+info*shrine))[0]=

        ((uint32_t*)(attr+info*shrine))[1]= cx;

    }

}
",110.0,25.0,"src:attr,i:info,stride:shrine,dc0:cx,",238.0,0.2017351190249125,Greedy
492,"static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)

{

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||

        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||

        (fs_ctx->export_flags & V9FS_SM_NONE)) {

        return lchown(rpath(fs_ctx, path, buffer),

                      credp->fc_uid, credp->fc_gid);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {

        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {

        return local_set_mapped_file_attr(fs_ctx, path, credp);

    }

    return -1;

}
","static int local_chown(FsContext *FS_wcs, V9fsPath *fs_path, FsCred *cribP)

{

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    if ((cribP->fc_uid == -1 && cribP->fc_gid == -1) ||

        (FS_wcs->export_flags & V9FS_SM_PASSTHROUGH) ||

        (FS_wcs->export_flags & V9FS_SM_NONE)) {

        return lchown(rpath(FS_wcs, path, buffer),

                      cribP->fc_uid, cribP->fc_gid);

    } else if (FS_wcs->export_flags & V9FS_SM_MAPPED) {

        return local_set_xattr(rpath(FS_wcs, path, buffer), cribP);

    } else if (FS_wcs->export_flags & V9FS_SM_MAPPED_FILE) {

        return local_set_mapped_file_attr(FS_wcs, path, cribP);

    }

    return -1;

}
",137.0,35.0,"fs_ctx:FS_wcs,credp:cribP,",232.0,0.2018781622250874,Greedy
495,"static int qcow2_co_flush(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    int ret;



    qemu_co_mutex_lock(&s->lock);

    ret = qcow2_cache_flush(bs, s->l2_table_cache);

    if (ret < 0) {


        return ret;

    }



    ret = qcow2_cache_flush(bs, s->refcount_block_cache);

    if (ret < 0) {


        return ret;

    }




    return bdrv_co_flush(bs->file);

}","static int qcow2_co_flush(BlockDriverState *bs)

{

    BDRVQcowState *services = bs->opaque;

    int ret;



    qemu_co_mutex_lock(&services->lock);

    ret = qcow2_cache_flush(bs, services->l2_table_cache);

    if (ret < 0) {


        return ret;

    }



    ret = qcow2_cache_flush(bs, services->refcount_block_cache);

    if (ret < 0) {


        return ret;

    }




    return bdrv_co_flush(bs->file);

}",81.0,21.0,"s:services,",64.0,0.0518807888031005,Greedy
508,"uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)

{

    uint8_t ret;



    OMAP_8B_REG(addr);

    cpu_physical_memory_read(addr, (void *) &ret, 1);

    return ret;

}
","uint32_t omap_badwidth_read8(void *OPac, target_phys_addr_t dc)

{

    uint8_t base;



    OMAP_8B_REG(dc);

    cpu_physical_memory_read(dc, (void *) &base, 1);

    return base;

}
",37.0,10.0,"addr:dc,opaque:OPac,ret:base,",115.0,0.089412260055542,Greedy
515,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);

            break;

    }



    return 0;

}
","static int curl_sock_cb(CURL * cur, curl_socket_t fd, int action,

                        void *s, void *sp)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);

            break;

    }



    return 0;

}
",108.0,29.0,"curl: cur,",32.0,0.0367371439933776,Greedy
519,"void ff_er_frame_start(ERContext *s)

{

    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
","void ff_er_frame_start(ERContext *S)

{

    if (!S->avctx->err_recognition)

        return;



    memset(S->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           S->mb_stride * S->mb_height * sizeof(uint8_t));

    S->error_count    = 3 * S->mb_num;

    S->error_occurred = 0;

}
",62.0,13.0,"s:S,",71.0,0.0609570503234863,Greedy
528,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        track->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, track->sequence_ref, 16);

        break;

    }

    return 0;

}
","static int mxf_read_track(MXFTrack *track, ByteIOContext *cp, int event)

{

    switch(event) {

    case 0x4801:

        track->track_id = get_be32(cp);

        break;

    case 0x4804:

        get_buffer(cp, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(cp);

        track->edit_rate.num = get_be32(cp);

        break;

    case 0x4803:

        get_buffer(cp, track->sequence_ref, 16);

        break;

    }

    return 0;

}
",99.0,20.0,"tag:event,pb:cp,",108.0,0.0974916776021321,Greedy
534,"static Visitor *validate_test_init_raw(TestInputVisitorData *data,

                                       const char *json_string)

{

    Visitor *v;



    data->obj = qobject_from_json(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);



    v = qmp_input_get_visitor(data->qiv);

    g_assert(v != NULL);



    return v;

}
","static Visitor *validate_test_init_raw(TestInputVisitorData *data,

                                       const char *json_string)

{

    Visitor *conv;



    data->obj = qobject_from_json(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);



    conv = qmp_input_get_visitor(data->qiv);

    g_assert(conv != NULL);



    return conv;

}
",77.0,20.0,"v:conv,",70.0,0.0613117376963297,Greedy
535,"static int connect_namedsocket(const char *path)

{

    int sockfd, size;

    struct sockaddr_un helper;



    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

    if (sockfd < 0) {

        fprintf(stderr, ""socket %s\n"", strerror(errno));

        return -1;

    }

    strcpy(helper.sun_path, path);

    helper.sun_family = AF_UNIX;

    size = strlen(helper.sun_path) + sizeof(helper.sun_family);

    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {

        fprintf(stderr, ""socket error\n"");


        return -1;

    }



    /* remove the socket for security reasons */

    unlink(path);

    return sockfd;

}","static int connect_namedsocket(const char *path)

{

    int sockfd, address;

    struct sockaddr_un helper;



    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

    if (sockfd < 0) {

        fprintf(stderr, ""socket %s\n"", strerror(errno));

        return -1;

    }

    strcpy(helper.sun_path, path);

    helper.sun_family = AF_UNIX;

    address = strlen(helper.sun_path) + sizeof(helper.sun_family);

    if (connect(sockfd, (struct sockaddr *)&helper, address) < 0) {

        fprintf(stderr, ""socket error\n"");


        return -1;

    }



    /* remove the socket for security reasons */

    unlink(path);

    return sockfd;

}",128.0,32.0,"size:address,",61.0,0.0649481972058614,Greedy
539,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)

{

    bs->detect_zeroes = blk->root_state.detect_zeroes;

}
","void blk_apply_root_state(BlockBackend *blk, BlockDriverState *ns)

{

    ns->detect_zeroes = blk->root_state.detect_zeroes;

}
",23.0,5.0,"bs:ns,",48.0,0.0312161684036254,Greedy
542,"static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)

{

    OfDpaFlow *flow;

    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;



    flow = g_new0(OfDpaFlow, 1);

    if (!flow) {

        return NULL;

    }



    flow->cookie = cookie;

    flow->mask.tbl_id = 0xffffffff;



    flow->stats.install_time = flow->stats.refresh_time = now;



    return flow;

}
","static OfDpaFlow *of_dpa_flow_alloc(uint64_t label)

{

    OfDpaFlow *progress;

    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;



    progress = g_new0(OfDpaFlow, 1);

    if (!progress) {

        return NULL;

    }



    progress->label = label;

    progress->mask.tbl_id = 0xffffffff;



    progress->stats.install_time = progress->stats.refresh_time = now;



    return progress;

}
",74.0,17.0,"cookie:label,flow:progress,",144.0,0.0965393980344136,Greedy
547,"void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)

{

    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);

    s->freq = PXA25X_FREQ;

    s->tm4 = NULL;

}
","void pxa25x_timer_init(target_phys_addr_t kit, qemu_irq *mirviews)

{

    pxa2xx_timer_info *session = pxa2xx_timer_init(kit, mirviews);

    session->freq = PXA25X_FREQ;

    session->tm4 = NULL;

}
",35.0,10.0,"s:session,irqs:mirviews,base:kit,",115.0,0.0774764855702718,Greedy
554,"PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,

                        const char *default_devaddr)

{

    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;

    PCIDevice *pci_dev;

    DeviceState *dev;

    int i;



    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);

    pci_dev = pci_create(pci_nic_names[i], devaddr);

    dev = &pci_dev->qdev;

    if (nd->id)

        dev->id = qemu_strdup(nd->id);

    dev->nd = nd;

    qdev_init(dev);

    nd->private = dev;

    return pci_dev;

}
","PCIDevice *pci_nic_init(NICInfo *nn, const char *defaultingtype,

                        const char *default_evaddr)

{

    const char *devaddr = nn->devaddr ? nn->devaddr : default_evaddr;

    PCIDevice *pci_dev;

    DeviceState *dev;

    int i;



    i = qemu_check_nic_model_list(nn, pci_nic_models, defaultingtype);

    pci_dev = pci_create(pci_nic_names[i], devaddr);

    dev = &pci_dev->qdev;

    if (nn->id)

        dev->id = qemu_strdup(nn->id);

    dev->nn = nn;

    qdev_init(dev);

    nn->private = dev;

    return pci_dev;

}
",113.0,34.0,"default_model:defaultingtype,default_devaddr:default_evaddr,nd:nn,",126.0,0.0794459303220113,Greedy
557,"void ff_h264_flush_change(H264Context *h)

{

    int i, j;



    h->next_outputed_poc = INT_MIN;

    h->prev_interlaced_frame = 1;

    idr(h);



    h->poc.prev_frame_num = -1;

    if (h->cur_pic_ptr) {

        h->cur_pic_ptr->reference = 0;

        for (j=i=0; h->delayed_pic[i]; i++)

            if (h->delayed_pic[i] != h->cur_pic_ptr)

                h->delayed_pic[j++] = h->delayed_pic[i];

        h->delayed_pic[j] = NULL;

    }

    ff_h264_unref_picture(h, &h->last_pic_for_ec);



    h->first_field = 0;

    ff_h264_sei_uninit(&h->sei);

    h->recovery_frame = -1;

    h->frame_recovered = 0;

    h->current_slice = 0;

    h->mmco_reset = 1;

    for (i = 0; i < h->nb_slice_ctx; i++)

        h->slice_ctx[i].list_count = 0;

}
","void ff_h264_flush_change(H264Context *hp)

{

    int ie, jc;



    hp->next_outputed_poc = INT_MIN;

    hp->prev_interlaced_frame = 1;

    idr(hp);



    hp->poc.prev_frame_num = -1;

    if (hp->cur_pic_ptr) {

        hp->cur_pic_ptr->reference = 0;

        for (jc=ie=0; hp->delayed_pic[ie]; ie++)

            if (hp->delayed_pic[ie] != hp->cur_pic_ptr)

                hp->delayed_pic[jc++] = hp->delayed_pic[ie];

        hp->delayed_pic[jc] = NULL;

    }

    ff_h264_unref_picture(hp, &hp->last_pic_for_ec);



    hp->first_field = 0;

    ff_h264_sei_uninit(&hp->sei);

    hp->recovery_frame = -1;

    hp->frame_recovered = 0;

    hp->current_slice = 0;

    hp->mmco_reset = 1;

    for (ie = 0; ie < hp->nb_slice_ctx; ie++)

        hp->slice_ctx[ie].list_count = 0;

}
",184.0,42.0,"j:jc,i:ie,h:hp,",219.0,0.1268377105394999,Greedy
560,"static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
","static void vc1_inv_trans_8x4_dc_c(uint8_t *shape, int linsize, DCTELEM *event)

{

    int info;

    int dc = event[0];

    const uint8_t *address;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    address = ff_cropTbl + MAX_NEG_CROP + dc;

    for(info = 0; info < 4; info++){

        shape[0] = address[shape[0]];

        shape[1] = address[shape[1]];

        shape[2] = address[shape[2]];

        shape[3] = address[shape[3]];

        shape[4] = address[shape[4]];

        shape[5] = address[shape[5]];

        shape[6] = address[shape[6]];

        shape[7] = address[shape[7]];

        shape += linsize;

    }

}
",188.0,45.0,"block:event,i:info,linesize:linsize,cm:address,dest:shape,",305.0,0.1715241312980651,Greedy
561,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
","static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int plugin, int r)

{

    switch(plugin){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
",165.0,32.0,"mode:plugin,",74.0,0.0439432382583618,Greedy
562,"static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)

{

    OpenPICState *opp = opaque;

    uint32_t retval = -1;

    int idx;



    DPRINTF(""%s: addr %08x\n"", __func__, addr);

    if (addr & 0xF) {

        goto out;

    }

    idx = (addr >> 6) & 0x3;

    if (addr == 0x0) {

        /* TIFR (TFRR) */

        retval = opp->tifr;

        goto out;

    }

    switch (addr & 0x30) {

    case 0x00: /* TICC (GTCCR) */

        retval = opp->timers[idx].ticc;

        break;

    case 0x10: /* TIBC (GTBCR) */

        retval = opp->timers[idx].tibc;

        break;

    case 0x20: /* TIPV (TIPV) */

        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);

        break;

    case 0x30: /* TIDE (TIDR) */

        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);

        break;

    }



out:

    DPRINTF(""%s: => %08x\n"", __func__, retval);



    return retval;

}
","static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned lan)

{

    OpenPICState *opp = opaque;

    uint32_t retval = -1;

    int idx;



    DPRINTF(""%s: addr %08x\n"", __func__, addr);

    if (addr & 0xF) {

        goto out;

    }

    idx = (addr >> 6) & 0x3;

    if (addr == 0x0) {

        /* TIFR (TFRR) */

        retval = opp->tifr;

        goto out;

    }

    switch (addr & 0x30) {

    case 0x00: /* TICC (GTCCR) */

        retval = opp->timers[idx].ticc;

        break;

    case 0x10: /* TIBC (GTBCR) */

        retval = opp->timers[idx].tibc;

        break;

    case 0x20: /* TIPV (TIPV) */

        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);

        break;

    case 0x30: /* TIDE (TIDR) */

        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);

        break;

    }



out:

    DPRINTF(""%s: => %08x\n"", __func__, retval);



    return retval;

}
",171.0,38.0,"len:lan,",50.0,0.0413065830866495,Greedy
571,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}
","static int get_num(ByteIOContext *hub, int *len)

{

    int n, n1;



    n = get_be16(hub);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(hub);

        (*len)-=2;

        return (n << 16) | n1;

    }

}
",72.0,17.0,"pb:hub,",61.0,0.0391553163528442,Greedy
573,"static int piix4_initfn(PCIDevice *dev)

{

    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);

    uint8_t *pci_conf;



    isa_bus_new(&d->dev.qdev);



    pci_conf = d->dev.config;

    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge

    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);



    piix4_dev = &d->dev;

    qemu_register_reset(piix4_reset, d);

    return 0;

}
","static int piix4_initfn(PCIDevice *prom)

{

    PIIX4State *d draw DO_UPCAST(PIIX4State, prom, prom);

    uint8_t *pki_config;



    isa_bus_new(&ddraw>prom.qdev);



    pci_pki_configdraw>prom.config;

    pci_config_set_vendor_id(pki_config, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pki_config, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge

    pci_config_set_class(pki_config, PCI_CLASS_BRIDGE_ISA);



    piix4_dev = &ddraw>prom;

    qemu_register_reset(piix4_reset, draw);

    return 0;

}
",83.0,26.0,"dev:prom,d:draw,pci_conf:pki_config,",217.0,0.1508829712867737,GA
578,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)

{

    TCGv_i64 tmp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    tmp = tcg_temp_new_i64();

    tmp2 = load_reg(s, rlow);

    tcg_gen_extu_i32_i64(tmp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(val, val, tmp);

    tcg_temp_free_i64(tmp);

}
","static void gen_addq_lo(DisasContext *fs, TCGv_i64 grad, int  rflow)

{

    TCGv_i64 pot;

    TCGv bagTwo;



    /* Load value and extend to 64 bits.  */

    pot = tcg_temp_new_i64();

    bagTwo = load_reg(fs,  rflow);

    tcg_gen_extu_i32_i64(pot, bagTwo);

    dead_tmp(bagTwo);

    tcg_gen_add_i64(grad, grad, pot);

    tcg_temp_free_i64(pot);

}
",63.0,23.0,"rlow: rflow,s:fs,val:grad,tmp2:bagTwo,tmp:pot,",219.0,0.1460705240567525,Greedy
585,"static void sd_reset(SDState *sd, BlockDriverState *bdrv)

{

    uint64_t size;

    uint64_t sect;



    if (bdrv) {

        bdrv_get_geometry(bdrv, &sect);

    } else {

        sect = 0;

    }

    size = sect << 9;



    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;



    sd->state = sd_idle_state;

    sd->rca = 0x0000;

    sd_set_ocr(sd);

    sd_set_scr(sd);

    sd_set_cid(sd);

    sd_set_csd(sd, size);

    sd_set_cardstatus(sd);

    sd_set_sdstatus(sd);



    sd->bdrv = bdrv;



    if (sd->wp_groups)

        g_free(sd->wp_groups);

    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);

    memset(sd->function_group, 0, sizeof(int) * 6);

    sd->erase_start = 0;

    sd->erase_end = 0;

    sd->size = size;

    sd->blk_len = 0x200;

    sd->pwd_len = 0;

    sd->expecting_acmd = 0;

}
","static void sd_reset(SDState *dm, BlockDriverState *bdrv)

{

    uint64_t size;

    uint64_t sect;



    if (bdrv) {

        bdrv_get_geometry(bdrv, &sect);

    } else {

        sect = 0;

    }

    size = sect << 9;



    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;



    dm->state = sd_idle_state;

    dm->rca = 0x0000;

    sd_set_ocr(dm);

    sd_set_scr(dm);

    sd_set_cid(dm);

    sd_set_csd(dm, size);

    sd_set_cardstatus(dm);

    sd_set_sdstatus(dm);



    dm->bdrv = bdrv;



    if (dm->wp_groups)

        g_free(dm->wp_groups);

    dm->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    dm->wp_groups = (int *) g_malloc0(sizeof(int) * sect);

    memset(dm->function_group, 0, sizeof(int) * 6);

    dm->erase_start = 0;

    dm->erase_end = 0;

    dm->size = size;

    dm->blk_len = 0x200;

    dm->pwd_len = 0;

    dm->expecting_acmd = 0;

}
",209.0,54.0,"sd:dm,",114.0,0.1008241732915242,Greedy
586,"static void phys_page_set(AddressSpaceDispatch *d,

                          target_phys_addr_t index, target_phys_addr_t nb,

                          uint16_t leaf)

{

    /* Wildly overreserve - it doesn't matter much. */

    phys_map_node_reserve(3 * P_L2_LEVELS);



    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);

}
","static void phys_page_set(AddressSpaceDispatch *dc,

                          target_phys_addr_t base, target_phys_addr_t base,

                          uint16_t leaf)

{

    /* Wildly overreserve - it doesn't matter much. */

    phys_map_node_reserve(3 * P_L2_LEVELS);



    phys_page_set_level(&dc->phys_map, &base, &base, leaf, P_L2_LEVELS - 1);

}
",46.0,13.0,"d:dc,index:base,nb:base,",127.0,0.0906237443288167,Greedy
590,"static CharDriverState *qemu_chr_open_spice_port(const char *id,

                                                 ChardevBackend *backend,

                                                 ChardevReturn *ret,

                                                 Error **errp)

{

    const char *name = backend->spiceport->fqdn;

    CharDriverState *chr;

    SpiceCharDriver *s;



    if (name == NULL) {

        fprintf(stderr, ""spice-qemu-char: missing name parameter\n"");

        return NULL;

    }



    chr = chr_open(""port"", spice_port_set_fe_open);

    s = chr->opaque;

    s->sin.portname = g_strdup(name);



    return chr;

}
","static CharDriverState *qemu_chr_open_spice_port(const char *id,

                                                 ChardevBackend *BACKends,

                                                 ChardevReturn *ret,

                                                 Error **errp)

{

    const char *filename = BACKends->spiceport->fqdn;

    CharDriverState *Chr;

    SpiceCharDriver *session;



    if (filename == NULL) {

        fprintf(stderr, ""spice-qemu-char: missing name parameter\n"");

        return NULL;

    }



    Chr = chr_open(""port"", spice_port_set_fe_open);

    session = Chr->opaque;

    session->sin.portname = g_strdup(filename);



    return Chr;

}
",94.0,21.0,"s:session,name:filename,chr:Chr,backend:BACKends,",184.0,0.159304928779602,Greedy
591,"void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)

{

#if defined(TARGET_HAS_ICE)

    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);



    breakpoint_invalidate(cpu, breakpoint->pc);



    g_free(breakpoint);

#endif

}
","void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakdown)

{

#if defined(TARGET_HAS_ICE)

    QTAILQ_REMOVE(&cpu->breakpoints, breakdown, entry);



    breakpoint_invalidate(cpu, breakdown->pc);



    g_free(breakdown);

#endif

}
",46.0,13.0,"breakpoint:breakdown,",46.0,0.0497157931327819,Greedy
608,"static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],

                                   int order, int qlevel, int len, int bps)

{

    int i, j;

    int ebps = 1 << (bps-1);

    unsigned sigma = 0;



    for (i = order; i < len; i++)

        sigma |= decoded[i] + ebps;



    if (sigma < 2*ebps)

        return;



    for (i = len - 1; i >= order; i--) {

        int64_t p = 0;

        for (j = 0; j < order; j++)

            p += coeffs[j] * (int64_t)decoded[i-order+j];

        decoded[i] -= p >> qlevel;

    }

    for (i = order; i < len; i++, decoded++) {

        int32_t p = 0;

        for (j = 0; j < order; j++)

            p += coeffs[j] * (uint32_t)decoded[j];

        decoded[j] += p >> qlevel;

    }

}
","static void lpc_analyze_remodulate(int32_t *decoded, const int coEFFes[32],

                                   int order, int qlevel, int len, int pins)

{

    int i, j;

    int ebps = 1 << (pins-1);

    unsigned sigma = 0;



    for (i = order; i < len; i++)

        sigma |= decoded[i] + ebps;



    if (sigma < 2*ebps)

        return;



    for (i = len - 1; i >= order; i--) {

        int64_t p = 0;

        for (j = 0; j < order; j++)

            p += coEFFes[j] * (int64_t)decoded[i-order+j];

        decoded[i] -= p >> qlevel;

    }

    for (i = order; i < len; i++, decoded++) {

        int32_t p = 0;

        for (j = 0; j < order; j++)

            p += coEFFes[j] * (uint32_t)decoded[j];

        decoded[j] += p >> qlevel;

    }

}
",205.0,64.0,"coeffs:coEFFes,bps:pins,",149.0,0.1193309624989827,Greedy
612,"static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    tcg_gen_qemu_st16(val, addr, index);

    dead_tmp(val);

}
","static inline void gen_st16(TCGv reg, TCGv address, int ion)

{

    tcg_gen_qemu_st16(reg, address, ion);

    dead_tmp(reg);

}
",30.0,10.0,"val:reg,index:ion,addr:address,",130.0,0.1153275569279988,Greedy
618,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int res;

    for(i=0; i<8; i++){

        for(j=1; j<7; j++){

            xy = j * stride + i;

            yz = j * 8 + i;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        }

    }

}
","static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int rows;

    for(i=0; i<8; i++){

        for(j=1; j<7; j++){

            xy = j * stride + i;

            yz = j * 8 + i;

            rows = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            rows +=2;

            rows >>=2;

            dest[xy] = (uint8_t)rows;

        }

    }

}
",137.0,34.0,"res:rows,",90.0,0.0858134627342224,Greedy
622,"static int ccid_initfn(USBDevice *dev)

{

    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);



    s->bus = ccid_bus_new(&dev->qdev);

    s->card = NULL;

    s->cardinfo = NULL;

    s->migration_state = MIGRATION_NONE;

    s->migration_target_ip = 0;

    s->migration_target_port = 0;

    s->dev.speed = USB_SPEED_FULL;

    s->notify_slot_change = false;

    s->powered = true;

    s->pending_answers_num = 0;

    s->last_answer_error = 0;

    s->bulk_in_pending_start = 0;

    s->bulk_in_pending_end = 0;

    s->current_bulk_in = NULL;

    ccid_reset_error_status(s);

    s->bulk_out_pos = 0;

    ccid_reset_parameters(s);

    ccid_reset(s);

    return 0;

}
","static int ccid_initfn(USBDevice *pack)

{

    USBCCIDState *s = DO_UPCAST(USBCCIDState, pack, pack);



    s->bus = ccid_bus_new(&pack->qdev);

    s->card = NULL;

    s->cardinfo = NULL;

    s->migration_state = MIGRATION_NONE;

    s->migration_target_ip = 0;

    s->migration_target_port = 0;

    s->pack.speed = USB_SPEED_FULL;

    s->notify_slot_change = false;

    s->powered = true;

    s->pending_answers_num = 0;

    s->last_answer_error = 0;

    s->bulk_in_pending_start = 0;

    s->bulk_in_pending_end = 0;

    s->current_bulk_in = NULL;

    ccid_reset_error_status(s);

    s->bulk_out_pos = 0;

    ccid_reset_parameters(s);

    ccid_reset(s);

    return 0;

}
",139.0,32.0,"dev:pack,",91.0,0.0882374167442321,Greedy
623,"static void ppc4xx_pob_reset (void *opaque)

{

    ppc4xx_pob_t *pob;



    pob = opaque;

    /* No error */

    pob->bear = 0x00000000;

    pob->besr[0] = 0x0000000;

    pob->besr[1] = 0x0000000;

}
","static void ppc4xx_pob_reset (void *Opaque)

{

    ppc4xx_pob_t *spib;



    spib = Opaque;

    /* No error */

    spib->bear = 0x00000000;

    spib->besr[0] = 0x0000000;

    spib->besr[1] = 0x0000000;

}
",42.0,8.0,"opaque:Opaque,pob:spib,",79.0,0.0705054918924967,Greedy
625,"static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int dstStride)

{

	//FIXME interpolate chroma

	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);

}
","static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *fstat, uint8_t *dst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int dstRestro)

{

	//FIXME interpolate chroma

	RENAME(yuvPlanartouyvy)(ysrc, usrc, fstat, dst, width, height, lumStride, chromStride, dstRestro, 2);

}
",72.0,21.0,"dstStride:dstRestro,vsrc:fstat,",85.0,0.0792674303054809,Greedy
629,"static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)

{

    ASFContext *asf  = s->priv_data;

    AVIOContext *pb  = s->pb;

    uint64_t size    = avio_rl64(pb);

    uint16_t nb_desc = avio_rl16(pb);

    int i, ret;



    for (i = 0; i < nb_desc; i++) {

        uint16_t name_len, type, val_len;

        uint8_t *name = NULL;



        name_len = avio_rl16(pb);

        if (!name_len)

            return AVERROR_INVALIDDATA;

        name = av_malloc(name_len);

        if (!name)

            return AVERROR(ENOMEM);

        avio_get_str16le(pb, name_len, name,

                         name_len);

        type    = avio_rl16(pb);

        val_len = avio_rl16(pb);



        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)

            return ret;

    }



    align_position(pb, asf->offset, size);

    return 0;

}
","static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *org)

{

    ASFContext *assfm  = s->priv_data;

    AVIOContext *pb  = s->pb;

    uint64_t size    = avio_rl64(pb);

    uint16_t nb_desc = avio_rl16(pb);

    int chi, fun;



    for (chi = 0; chi < nb_desc; chi++) {

        uint16_t name_len, label, Val_lan;

        uint8_t *address = NULL;



        name_len = avio_rl16(pb);

        if (!name_len)

            return AVERROR_INVALIDDATA;

        address = av_malloc(name_len);

        if (!address)

            return AVERROR(ENOMEM);

        avio_get_str16le(pb, name_len, address,

                         name_len);

        label    = avio_rl16(pb);

        Val_lan = avio_rl16(pb);



        if ((fun = process_metadata(s, address, name_len, Val_lan, label, &s->metadata)) < 0)

            return fun;

    }



    align_position(pb, assfm->offset, size);

    return 0;

}
",181.0,58.0,"g:org,val_len:Val_lan,type:label,asf:assfm,ret:fun,i:chi,name:address,",331.0,0.3061550776163736,Greedy
631,"static void vmxnet3_net_uninit(VMXNET3State *s)

{

    g_free(s->mcast_list);

    vmxnet_tx_pkt_reset(s->tx_pkt);

    vmxnet_tx_pkt_uninit(s->tx_pkt);

    vmxnet_rx_pkt_uninit(s->rx_pkt);

    qemu_del_nic(s->nic);

}
","static void vmxnet3_net_uninit(VMXNET3State *services)

{

    g_free(services->mcast_list);

    vmxnet_tx_pkt_reset(services->tx_pkt);

    vmxnet_tx_pkt_uninit(services->tx_pkt);

    vmxnet_rx_pkt_uninit(services->rx_pkt);

    qemu_del_nic(services->nic);

}
",45.0,12.0,"s:services,",58.0,0.0537826577822367,Greedy
633,"static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)

{

    if (!buffer->cmd) {

        AVBufferRef *buf = buffer->user_data;

        av_buffer_unref(&buf);

    }

    mmal_buffer_header_release(buffer);

}
","static void input_callback(MMAL_PORT_T *type, MMAL_BUFFER_HEADER_T *writer)

{

    if (!writer->cmd) {

        AVBufferRef *func = writer->user_data;

        av_buffer_unref(&func);

    }

    mmal_buffer_header_release(writer);

}
",42.0,10.0,"port:type,buf:func,buffer:writer,",124.0,0.1113768339157104,Greedy
634,"CPUArchState *cpu_copy(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new_env = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;



    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, env, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }



    return new_env;

}
","CPUArchState *cpu_copy(CPUArchState *eng)

{

    CPUState *cpu = ENV_GET_CPU(eng);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new_env = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;



    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, eng, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }



    return new_env;

}
",142.0,40.0,"env:eng,",76.0,0.0758324861526489,Greedy
636,"static int net_socket_can_send(void *opaque)

{

    NetSocketState *s = opaque;



    return qemu_can_send_packet(&s->nc);

}
","static int net_socket_can_send(void *copac)

{

    NetSocketState *sync = copac;



    return qemu_can_send_packet(&sync->nc);

}
",25.0,6.0,"s:sync,opaque:copac,",73.0,0.0635679999987284,Greedy
639,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)

{

    check_hwrena(env, 0);

    return env->CP0_EBase & 0x3ff;

}
","target_ulong helper_rdhwr_cpunum(CPUMIPSState *style)

{

    check_hwrena(style, 0);

    return style->CP0_EBase & 0x3ff;

}
",23.0,5.0,"env:style,",58.0,0.0544411738713582,Greedy
641,"void helper_single_step(CPUX86State *env)

{

#ifndef CONFIG_USER_ONLY

    check_hw_breakpoints(env, 1);

    env->dr[6] |= DR6_BS;

#endif

    raise_exception(env, EXCP01_DB);

}
","void helper_single_step(CPUX86State *eng)

{

#ifndef CONFIG_USER_ONLY

    check_hw_breakpoints(eng, 1);

    eng->dr[6] |= DR6_BS;

#endif

    raise_exception(eng, EXCP01_DB);

}
",35.0,10.0,"env:eng,",59.0,0.0548081874847412,Greedy
645,"static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    k->realize = xen_pt_realize;

    k->exit = xen_pt_unregister_device;

    k->config_read = xen_pt_pci_read_config;

    k->config_write = xen_pt_pci_write_config;


    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->desc = ""Assign an host PCI device with Xen"";

    dc->props = xen_pci_passthrough_properties;

};","static void xen_pci_passthrough_class_init(ObjectClass *skass, void *raw)

{

    DeviceClass *writer = DEVICE_CLASS(skass);

    PCIDeviceClass *ijk = PCI_DEVICE_CLASS(skass);



    ijk->realize = xen_pt_realize;

    ijk->exit = xen_pt_unregister_device;

    ijk->config_read = xen_pt_pci_read_config;

    ijk->config_write = xen_pt_pci_write_config;


    set_bit(DEVICE_CATEGORY_MISC, writer->categories);

    writer->desc = ""Assign an host PCI device with Xen"";

    writer->props = xen_pci_passthrough_properties;

};",79.0,23.0,"klass:skass,data:raw,k:ijk,dc:writer,",159.0,0.1331796606381734,Greedy
646,"static int ohci_bus_start(OHCIState *ohci)

{

    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,

                    ohci_frame_boundary,

                    ohci);



    if (ohci->eof_timer == NULL) {

        trace_usb_ohci_bus_eof_timer_failed(ohci->name);

        ohci_die(ohci);

        return 0;

    }



    trace_usb_ohci_start(ohci->name);



    /* Delay the first SOF event by one frame time as

     * linux driver is not ready to receive it and

     * can meet some race conditions

     */



    ohci_eof_timer(ohci);



    return 1;

}
","static int ohci_bus_start(OHCIState *ahci)

{

    ahci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,

                    ohci_frame_boundary,

                    ahci);



    if (ahci->eof_timer == NULL) {

        trace_usb_ohci_bus_eof_timer_failed(ahci->name);

        ohci_die(ahci);

        return 0;

    }



    trace_usb_ohci_start(ahci->name);



    /* Delay the first SOF event by one frame time as

     * linux driver is not ready to receive it and

     * can meet some race conditions

     */



    ohci_eof_timer(ahci);



    return 1;

}
",63.0,16.0,"ohci:ahci,",61.0,0.0532114386558532,Greedy
648,"static int srt_decode_frame(AVCodecContext *avctx,

                            void *data, int *got_sub_ptr, AVPacket *avpkt)

{

    AVSubtitle *sub = data;

    AVBPrint buffer;

    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;

    int size, ret;

    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);

    FFASSDecoderContext *s = avctx->priv_data;



    if (p && size == 16) {

        x1 = AV_RL32(p     );

        y1 = AV_RL32(p +  4);

        x2 = AV_RL32(p +  8);

        y2 = AV_RL32(p + 12);

    }



    if (avpkt->size <= 0)

        return avpkt->size;



    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);



    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);

    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);

    av_bprint_finalize(&buffer, NULL);

    if (ret < 0)

        return ret;



    *got_sub_ptr = sub->num_rects > 0;

    return avpkt->size;

}
","static int srt_decode_frame(AVCodecContext *avctx,

                            void *data, int *got_sub_ptr, AVPacket *awwpck)

{

    AVSubtitle *sub = data;

    AVBPrint base;

    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;

    int size, ret;

    const uint8_t *p = av_packet_get_side_data(awwpck, AV_PKT_DATA_SUBTITLE_POSITION, &size);

    FFASSDecoderContext *s = avctx->priv_data;



    if (p && size == 16) {

        x1 = AV_RL32(p     );

        y1 = AV_RL32(p +  4);

        x2 = AV_RL32(p +  8);

        y2 = AV_RL32(p + 12);

    }



    if (awwpck->size <= 0)

        return awwpck->size;



    av_bprint_init(&base, 0, AV_BPRINT_SIZE_UNLIMITED);



    srt_to_ass(avctx, &base, awwpck->data, x1, y1, x2, y2);

    ret = ff_ass_add_rect(sub, base.str, s->readorder++, 0, NULL, NULL);

    av_bprint_finalize(&base, NULL);

    if (ret < 0)

        return ret;



    *got_sub_ptr = sub->num_rects > 0;

    return awwpck->size;

}
",216.0,60.0,"avpkt:awwpck,buffer:base,",205.0,0.189939800898234,Greedy
652,"void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)

{

    IDEBus *bus = opaque;

    IDEState *s = idebus_active_if(bus);

    uint8_t *p;



    /* PIO data access allowed only when DRQ bit is set */

    if (!(s->status & DRQ_STAT))

        return;



    p = s->data_ptr;

    *(uint16_t *)p = le16_to_cpu(val);

    p += 2;

    s->data_ptr = p;

    if (p >= s->data_end)

        s->end_transfer_func(s);

}
","void ide_data_writew(void *opaque, uint32_t port, uint32_t stat)

{

    IDEBus *plugin = opaque;

    IDEState *s = idebus_active_if(plugin);

    uint8_t *p;



    /* PIO data access allowed only when DRQ bit is set */

    if (!(s->status & DRQ_STAT))

        return;



    p = s->data_ptr;

    *(uint16_t *)p = le16_to_cpu(stat);

    p += 2;

    s->data_ptr = p;

    if (p >= s->data_end)

        s->end_transfer_func(s);

}
",90.0,24.0,"addr:port,bus:plugin,val:stat,",124.0,0.1038795351982116,Greedy
664,"void net_checksum_calculate(uint8_t *data, int length)

{

    int hlen, plen, proto, csum_offset;

    uint16_t csum;



    if ((data[14] & 0xf0) != 0x40)

	return; /* not IPv4 */

    hlen  = (data[14] & 0x0f) * 4;

    plen  = (data[16] << 8 | data[17]) - hlen;

    proto = data[23];



    switch (proto) {

    case PROTO_TCP:

	csum_offset = 16;

	break;

    case PROTO_UDP:

	csum_offset = 6;

	break;

    default:

	return;

    }



    if (plen < csum_offset+2)

	return;



    data[14+hlen+csum_offset]   = 0;

    data[14+hlen+csum_offset+1] = 0;

    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);

    data[14+hlen+csum_offset]   = csum >> 8;

    data[14+hlen+csum_offset+1] = csum & 0xff;

}
","void net_checksum_calculate(uint8_t *DATA, int length)

{

    int HHlength, plen, proto, csav_offset;

    uint16_t csum;



    if ((DATA[14] & 0xf0) != 0x40)

	return; /* not IPv4 */

    HHlength  = (DATA[14] & 0x0f) * 4;

    plen  = (DATA[16] << 8 | DATA[17]) - HHlength;

    proto = DATA[23];



    switch (proto) {

    case PROTO_TCP:

	csav_offset = 16;

	break;

    case PROTO_UDP:

	csav_offset = 6;

	break;

    default:

	return;

    }



    if (plen < csav_offset+2)

	return;



    DATA[14+HHlength+csav_offset]   = 0;

    DATA[14+HHlength+csav_offset+1] = 0;

    csum = net_checksum_tcpudp(plen, proto, DATA+14+12, DATA+14+HHlength);

    DATA[14+HHlength+csav_offset]   = csum >> 8;

    DATA[14+HHlength+csav_offset+1] = csum & 0xff;

}
",188.0,45.0,"data:DATA,hlen:HHlength,csum_offset:csav_offset,",287.0,0.2443205515543619,Greedy
668,"static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,

                                   size_t datalen)

{

    ssize_t ret = gnutls_read(*session, data, datalen);

    if (ret < 0) {

        if (ret == GNUTLS_E_AGAIN) {

            errno = EAGAIN;

        } else {

            errno = EIO;

        }

        ret = -1;

    }

    return ret;

}
","static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,

                                   size_t dalleng)

{

    ssize_t ret = gnutls_read(*session, data, dalleng);

    if (ret < 0) {

        if (ret == GNUTLS_E_AGAIN) {

            errno = EAGAIN;

        } else {

            errno = EIO;

        }

        ret = -1;

    }

    return ret;

}
",64.0,18.0,"datalen:dalleng,",55.0,0.0504886110623677,Greedy
671,"static void stream_close(VideoState *is)

{

    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    is->abort_request = 1;

    SDL_WaitThread(is->read_tid, NULL);

    SDL_WaitThread(is->refresh_tid, NULL);

    packet_queue_destroy(&is->videoq);

    packet_queue_destroy(&is->audioq);

    packet_queue_destroy(&is->subtitleq);



    /* free all pictures */

    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {

        vp = &is->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);

            vp->bmp = NULL;

        }

    }

    SDL_DestroyMutex(is->pictq_mutex);

    SDL_DestroyCond(is->pictq_cond);

    SDL_DestroyMutex(is->subpq_mutex);

    SDL_DestroyCond(is->subpq_cond);

    SDL_DestroyCond(is->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(is->img_convert_ctx);

#endif

    av_free(is);

}
","static void stream_close(VideoState *ris)

{

    VideoPicture *vm;

    int m;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    ris->abort_request = 1;

    SDL_WaitThread(ris->read_tid, NULL);

    SDL_WaitThread(ris->refresh_tid, NULL);

    packet_queue_destroy(&ris->videoq);

    packet_queue_destroy(&ris->audioq);

    packet_queue_destroy(&ris->subtitleq);



    /* free all pictures */

    for (m = 0; m < VIDEO_PICTURE_QUEUE_SIZE; m++) {

        vm = &ris->pictq[m];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vm->picref);

#endif

        if (vm->bmp) {

            SDL_FreeYUVOverlay(vm->bmp);

            vm->bmp = NULL;

        }

    }

    SDL_DestroyMutex(ris->pictq_mutex);

    SDL_DestroyCond(ris->pictq_cond);

    SDL_DestroyMutex(ris->subpq_mutex);

    SDL_DestroyCond(ris->subpq_cond);

    SDL_DestroyCond(ris->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(ris->img_convert_ctx);

#endif

    av_free(ris);

}
",175.0,44.0,"is:ris,i:m,vp:vm,",215.0,0.1897771636644999,Greedy
672,"static void init_gain_table(COOKContext *q) {

    int i;

    q->gain_size_factor = q->samples_per_channel/8;

    for (i=0 ; i<23 ; i++) {

        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,

                               (1.0/(double)q->gain_size_factor));

    }

    memset(&q->gain_copy, 0, sizeof(COOKgain));

    memset(&q->gain_current, 0, sizeof(COOKgain));

    memset(&q->gain_now, 0, sizeof(COOKgain));

    memset(&q->gain_previous, 0, sizeof(COOKgain));

}
","static void init_gain_table(COOKContext *q) {

    int gi;

    q->gain_size_factor = q->samples_per_channel/8;

    for (gi=0 ; gi<23 ; gi++) {

        q->gain_table[gi] = pow((double)q->pow2tab[gi+52] ,

                               (1.0/(double)q->gain_size_factor));

    }

    memset(&q->gain_copy, 0, sizeof(COOKgain));

    memset(&q->gain_current, 0, sizeof(COOKgain));

    memset(&q->gain_now, 0, sizeof(COOKgain));

    memset(&q->gain_previous, 0, sizeof(COOKgain));

}
",131.0,26.0,"i:gi,",78.0,0.0669075687726338,Greedy
674,"static int scsi_device_init(SCSIDevice *s)

{

    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);

    if (sc->init) {

        return sc->init(s);

    }

    return 0;

}
","static int scsi_device_init(SCSIDevice *s)

{

    SCSIDeviceClass *osc = SCSI_DEVICE_GET_CLASS(s);

    if (osc->init) {

        return osc->init(s);

    }

    return 0;

}
",38.0,8.0,"sc:osc,",54.0,0.0479218880335489,Greedy
675,"static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    int64_t start, end;

    unsigned long val, idx, bit;



    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; start <= end; start++) {

        idx = start / (sizeof(unsigned long) * 8);

        bit = start % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[idx];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] = val;

    }

}
","static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    int64_t source, end;

    unsigned long val, idx, bit;



    source = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; source <= end; source++) {

        idx = source / (sizeof(unsigned long) * 8);

        bit = source % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[idx];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] = val;

    }

}
",132.0,35.0,"start:source,",91.0,0.0775917371114095,Greedy
677,"static void lsi_ram_write(void *opaque, target_phys_addr_t addr,

                          uint64_t val, unsigned size)

{

    LSIState *s = opaque;

    uint32_t newval;

    uint32_t mask;

    int shift;



    newval = s->script_ram[addr >> 2];

    shift = (addr & 3) * 8;

    mask = ((uint64_t)1 << (size * 8)) - 1;

    newval &= ~(mask << shift);

    newval |= val << shift;

    s->script_ram[addr >> 2] = newval;

}
","static void lsi_ram_write(void *opsacle, target_phys_addr_t amd,

                          uint64_t val, unsigned size)

{

    LSIState *socket = opsacle;

    uint32_t NEWval;

    uint32_t mask;

    int window;



    NEWval = socket->script_ram[amd >> 2];

    window = (amd & 3) * 8;

    mask = ((uint64_t)1 << (size * 8)) - 1;

    NEWval &= ~(mask << window);

    NEWval |= val << window;

    socket->script_ram[amd >> 2] = NEWval;

}
",98.0,26.0,"addr:amd,newval:NEWval,shift:window,opaque:opsacle,s:socket,",237.0,0.2010181307792663,Greedy
678,"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)

{

    int ret, i;



    frame->width  = s->avctx->width  + 2;

    frame->height = s->avctx->height + 2;

    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)

        return ret;

    for (i = 0; frame->data[i]; i++) {

        int offset = frame->linesize[i] + (1 << sps->pixel_shift);

        frame->data[i] += offset;

    }

    frame->width  = s->avctx->width;

    frame->height = s->avctx->height;



    return 0;

}
","static int get_buffer_sao(HEVCContext *services, AVFrame *point, const HEVCSPS *spa)

{

    int data, data;



    point->width  = services->avctx->width  + 2;

    point->height = services->avctx->height + 2;

    if ((data = ff_get_buffer(services->avctx, point, AV_GET_BUFFER_FLAG_REF)) < 0)

        return data;

    for (data = 0; point->data[data]; data++) {

        int offset = point->linesize[data] + (1 << spa->pixel_shift);

        point->data[data] += offset;

    }

    point->width  = services->avctx->width;

    point->height = services->avctx->height;



    return 0;

}
",138.0,31.0,"sps:spa,ret:data,i:data,s:services,frame:point,",300.0,0.2651354153951009,Greedy
689,"static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)

{

    int i;



    for (i = 0; i < s->nb_streams; i++) {

        MXFTrack *track = s->streams[i]->priv_data;

        /* SMPTE 379M 7.3 */

        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))

            return i;

    }

    /* return 0 if only one stream, for OP Atom files with 0 as track number */

    return s->nb_streams == 1 ? 0 : -1;

}
","static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *glv)

{

    int i;



    for (i = 0; i < s->nb_streams; i++) {

        MXFTrack *data = s->streams[i]->priv_data;

        /* SMPTE 379M 7.3 */

        if (!memcmp(glv->key + sizeof(mxf_essence_element_key), data->track_number, sizeof(data->track_number)))

            return i;

    }

    /* return 0 if only one stream, for OP Atom files with 0 as track number */

    return s->nb_streams == 1 ? 0 : -1;

}
",87.0,18.0,"klv:glv,track:data,",93.0,0.0808463414510091,Greedy
694,"static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)

{

    pkt->data      = NULL;

    pkt->side_data = NULL;

    if (pkt->buf) {

        AVBufferRef *ref = av_buffer_ref(src->buf);

        if (!ref)

            return AVERROR(ENOMEM);

        pkt->buf  = ref;

        pkt->data = ref->data;

    } else {

        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);

    }

#if FF_API_DESTRUCT_PACKET

FF_DISABLE_DEPRECATION_WARNINGS

    pkt->destruct = dummy_destruct_packet;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    if (pkt->side_data_elems && dup)

        pkt->side_data = src->side_data;

    if (pkt->side_data_elems && !dup) {

        return av_copy_packet_side_data(pkt, src);

    }

    return 0;



failed_alloc:

    av_destruct_packet(pkt);

    return AVERROR(ENOMEM);

}
","static int copy_packet_data(AVPacket *pkt, AVPacket *src, int cepc)

{

    pkt->data      = NULL;

    pkt->side_data = NULL;

    if (pkt->buf) {

        AVBufferRef *ref = av_buffer_ref(src->buf);

        if (!ref)

            return AVERROR(ENOMEM);

        pkt->buf  = ref;

        pkt->data = ref->data;

    } else {

        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);

    }

#if FF_API_DESTRUCT_PACKET

FF_DISABLE_DEPRECATION_WARNINGS

    pkt->destruct = dummy_destruct_packet;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    if (pkt->side_data_elems && cepc)

        pkt->side_data = src->side_data;

    if (pkt->side_data_elems && !cepc) {

        return av_copy_packet_side_data(pkt, src);

    }

    return 0;



failed_alloc:

    av_destruct_packet(pkt);

    return AVERROR(ENOMEM);

}
",160.0,39.0,"dup:cepc,",71.0,0.0589076042175292,Greedy
697,"static int virtio_blk_device_exit(DeviceState *dev)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    VirtIOBlock *s = VIRTIO_BLK(dev);

#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE

    remove_migration_state_change_notifier(&s->migration_state_notifier);

    virtio_blk_data_plane_destroy(s->dataplane);

    s->dataplane = NULL;

#endif

    qemu_del_vm_change_state_handler(s->change);

    unregister_savevm(dev, ""virtio-blk"", s);

    blockdev_mark_auto_del(s->bs);

    virtio_cleanup(vdev);

    return 0;

}
","static int virtio_blk_device_exit(DeviceState *state)

{

    VirtIODevice *VDev = VIRTIO_DEVICE(state);

    VirtIOBlock *services = VIRTIO_BLK(state);

#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE

    remove_migration_state_change_notifier(&services->migration_state_notifier);

    virtio_blk_data_plane_destroy(services->dataplane);

    services->dataplane = NULL;

#endif

    qemu_del_vm_change_state_handler(services->change);

    unregister_savevm(state, ""virtio-blk"", services);

    blockdev_mark_auto_del(services->bs);

    virtio_cleanup(VDev);

    return 0;

}
",84.0,23.0,"dev:state,s:services,vdev:VDev,",149.0,0.1177752296129862,Greedy
698,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,

                             void *opaque, Error **errp)

{

    uint64_t value;

    MemoryRegion *mr;

    PCDIMMDevice *dimm = PC_DIMM(obj);

    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);



    mr = ddc->get_memory_region(dimm);

    value = memory_region_size(mr);



    visit_type_uint64(v, name, &value, errp);

}
","static void pc_dimm_get_size(Object *Object, Visitor *api, const char *name,

                             void *opaque, Error **errp)

{

    uint64_t value;

    MemoryRegion *mr;

    PCDIMMDevice *dimm = PC_DIMM(Object);

    PCDIMMDeviceClass *ddd = PC_DIMM_GET_CLASS(Object);



    mr = ddd->get_memory_region(dimm);

    value = memory_region_size(mr);



    visit_type_uint64(api, name, &value, errp);

}
",81.0,25.0,"v:api,obj:Object,ddc:ddd,",130.0,0.1011726975440979,Greedy
710,"void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)

{

    int i;

    size_t pagesize = getpagesize();



    memory = (memory + pagesize - 1) & -pagesize;

    for (i = 0; i < memory / pagesize; i++) {

        memset(area + pagesize * i, 0, 1);

    }

}
","void os_mem_prealloc(int fd, char *address, size_t memory, Error **erpc)

{

    int i;

    size_t pagesize = getpagesize();



    memory = (memory + pagesize - 1) & -pagesize;

    for (i = 0; i < memory / pagesize; i++) {

        memset(address + pagesize * i, 0, 1);

    }

}
",73.0,21.0,"errp:erpc,area:address,",68.0,0.0664843122164408,Greedy
716,"BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,

                                 QEMUIOVector *qiov, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);



    if (!drv)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,

                              cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->rd_ops ++;

    }



    return ret;

}
","BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bes, int64_t sector_num,

                                 QEMUIOVector *qiov, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void * opacity)

{

    BlockDriver *drm = bes->drm;

    BlockDriverAIOCB *mem;



    trace_bdrv_aio_readv(bes, sector_num, nb_sectors,  opacity);



    if (!drm)

        return NULL;

    if (bdrv_check_request(bes, sector_num, nb_sectors))

        return NULL;



    mem = drm->bdrv_aio_readv(bes, sector_num, qiov, nb_sectors,

                              cb,  opacity);



    if (mem) {

	/* Update stats even though technically transfer has not happened. */

	bes->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bes->rd_ops ++;

    }



    return mem;

}
",117.0,34.0,"bs:bes,ret:mem,drv:drm,opaque: opacity,",218.0,0.1788199623425801,Greedy
724,"int qdev_prop_check_globals(void)

{

    GList *l;

    int ret = 0;



    for (l = global_props; l; l = l->next) {

        GlobalProperty *prop = l->data;

        ObjectClass *oc;

        DeviceClass *dc;

        if (prop->used) {

            continue;

        }

        if (!prop->user_provided) {

            continue;

        }

        oc = object_class_by_name(prop->driver);

        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);

        if (!oc) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       prop->driver, prop->property);

            ret = 1;

            continue;

        }

        dc = DEVICE_CLASS(oc);

        if (!dc->hotpluggable && !prop->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       prop->driver, prop->property, prop->value);

            ret = 1;

            continue;

        }

    }

    return ret;

}
","int qdev_prop_check_globals(void)

{

    GList *l;

    int ret = 0;



    for (l = global_props; l; l = l->next) {

        GlobalProperty *prop = l->data;

        ObjectClass *ocr;

        DeviceClass *dc;

        if (prop->used) {

            continue;

        }

        if (!prop->user_provided) {

            continue;

        }

        ocr = object_class_by_name(prop->driver);

        ocr = object_class_dynamic_cast(ocr, TYPE_DEVICE);

        if (!ocr) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       prop->driver, prop->property);

            ret = 1;

            continue;

        }

        dc = DEVICE_CLASS(ocr);

        if (!dc->hotpluggable && !prop->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       prop->driver, prop->property, prop->value);

            ret = 1;

            continue;

        }

    }

    return ret;

}
",162.0,37.0,"dc:dc,oc:ocr,",124.0,0.0897743066151936,Greedy
744,"int ffurl_shutdown(URLContext *h, int flags)

{

    if (!h->prot->url_shutdown)

        return AVERROR(EINVAL);

    return h->prot->url_shutdown(h, flags);

}
","int ffurl_shutdown(URLContext *php, int options)

{

    if (!php->prot->url_shutdown)

        return AVERROR(EINVAL);

    return php->prot->url_shutdown(php, options);

}
",39.0,9.0,"h:php,flags:options,",99.0,0.0722802440325419,Greedy
745,"static void i82378_init(DeviceState *dev, I82378State *s)

{

    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, ""isa.0""));

    ISADevice *pit;

    qemu_irq *out0_irq;



    /* This device has:

       2 82C59 (irq)

       1 82C54 (pit)

       2 82C37 (dma)

       NMI

       Utility Bus Support Registers



       All devices accept byte access only, except timer

     */



    qdev_init_gpio_out(dev, s->out, 2);

    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);



    /* Workaround the fact that i8259 is not qdev'ified... */

    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);



    /* 2 82C59 (irq) */

    s->i8259 = i8259_init(isabus, *out0_irq);

    isa_bus_irqs(isabus, s->i8259);



    /* 1 82C54 (pit) */

    pit = pit_init(isabus, 0x40, 0, NULL);



    /* speaker */

    pcspk_init(isabus, pit);



    /* 2 82C37 (dma) */

    DMA_init(1, &s->out[1]);

    isa_create_simple(isabus, ""i82374"");



    /* timer */

    isa_create_simple(isabus, ""mc146818rtc"");

}
","static void i82378_init(DeviceState *hw, I82378State *services)

{

    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(hw, ""isa.0""));

    ISADevice *plugin;

    qemu_irq *out0_irqs;



    /* This device has:

       2 82C59 (irq)

       1 82C54 (pit)

       2 82C37 (dma)

       NMI

       Utility Bus Support Registers



       All devices accept byte access only, except timer

     */



    qdev_init_gpio_out(hw, services->out, 2);

    qdev_init_gpio_in(hw, i82378_request_pic_irq, 16);



    /* Workaround the fact that i8259 is not qdev'ified... */

    out0_irqs = qemu_allocate_irqs(i82378_request_out0_irq, services, 1);



    /* 2 82C59 (irq) */

    services->i8259 = i8259_init(isabus, *out0_irqs);

    isa_bus_irqs(isabus, services->i8259);



    /* 1 82C54 (pit) */

    plugin = pit_init(isabus, 0x40, 0, NULL);



    /* speaker */

    pcspk_init(isabus, plugin);



    /* 2 82C37 (dma) */

    DMA_init(1, &services->out[1]);

    isa_create_simple(isabus, ""i82374"");



    /* timer */

    isa_create_simple(isabus, ""mc146818rtc"");

}
",142.0,40.0,"pit:plugin,out0_irq:out0_irqs,s:services,dev:hw,",210.0,0.1456289370854695,Greedy
751,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)

{

    int64_t start, size, last_size;

    start= url_ftell(bc) - prefix_length;



    if(start != nut->packet_start + nut->written_packet_size){

        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(bc, update_adler32, 0);



    size= get_v(bc);

    last_size= get_v(bc);

    if(nut->written_packet_size != last_size){

        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);

        return -1;

    }



    nut->last_packet_start = nut->packet_start;

    nut->packet_start = start;

    nut->written_packet_size= size;



    return size;

}
","static int get_packetheader(NUTContext *bolt, ByteIOContext *BC, int prefix_length, int calculate_checksum)

{

    int64_t start, size, last_size;

    start= url_ftell(BC) - prefix_length;



    if(start != bolt->packet_start + bolt->written_packet_size){

        av_log(bolt->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(BC, update_adler32, 0);



    size= get_v(BC);

    last_size= get_v(BC);

    if(bolt->written_packet_size != last_size){

        av_log(bolt->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", bolt->written_packet_size, last_size, start);

        return -1;

    }



    bolt->last_packet_start = bolt->packet_start;

    bolt->packet_start = start;

    bolt->written_packet_size= size;



    return size;

}
",150.0,43.0,"nut:bolt,bc:BC,",163.0,0.1316304008165995,Greedy
753,"int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,

                  int flags, int mode)

{

    int err;

    FsCred cred;



    cred_init(&cred);

    cred.fc_mode = mode & 07777;

    cred.fc_uid = fidp->uid;

    cred.fc_gid = gid;

    v9fs_co_run_in_worker(

        {

            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);

            err = 0;

            if (fidp->fs.fd == -1) {

                err = -errno;

            }

        });

    if (!err) {

        total_open_fd++;

        if (total_open_fd > open_fd_hw) {

            v9fs_reclaim_fd(s);

        }

    }

    return err;

}
","int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,

                  int flags, int mode)

{

    int err;

    FsCred  cram;



    cred_init(& cram);

     cram.fc_mode = mode & 07777;

     cram.fc_uid = fidp->uid;

     cram.fc_gid = gid;

    v9fs_co_run_in_worker(

        {

            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, & cram);

            err = 0;

            if (fidp->fs.fd == -1) {

                err = -errno;

            }

        });

    if (!err) {

        total_open_fd++;

        if (total_open_fd > open_fd_hw) {

            v9fs_reclaim_fd(s);

        }

    }

    return err;

}
",138.0,35.0,"cred: cram,",98.0,0.0878995060920715,Greedy
754,"static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)

{

    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    static const uint8_t vlan[] = {0x81, 0x00};

    uint8_t *ptr = (uint8_t *)buf;

    int i;



    if (n->promisc)

        return 1;



    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {

        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;

        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))

            return 0;

    }



    if ((ptr[0] & 1) && n->allmulti)

        return 1;



    if (!memcmp(ptr, bcast, sizeof(bcast)))

        return 1;



    if (!memcmp(ptr, n->mac, ETH_ALEN))

        return 1;



    for (i = 0; i < n->mac_table.in_use; i++) {

        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))

            return 1;

    }



    return 0;

}
","static int receive_filter(VirtIONet *m, const uint8_t *buf, int size)

{

    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    static const uint8_t vlan[] = {0x81, 0x00};

    uint8_t *ptr = (uint8_t *)buf;

    int di;



    if (m->promisc)

        return 1;



    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {

        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;

        if (!(m->vlans[vid >> 5] & (1U << (vid & 0x1f))))

            return 0;

    }



    if ((ptr[0] & 1) && m->allmulti)

        return 1;



    if (!memcmp(ptr, bcast, sizeof(bcast)))

        return 1;



    if (!memcmp(ptr, m->mac, ETH_ALEN))

        return 1;



    for (di = 0; di < m->mac_table.in_use; di++) {

        if (!memcmp(ptr, &m->mac_table.macs[di * ETH_ALEN], ETH_ALEN))

            return 1;

    }



    return 0;

}
",240.0,40.0,"i:di,n:m,",143.0,0.1362051447232564,Greedy
764,"static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,

                                     uint64_t value, unsigned size)

{

    mv88w8618_flashcfg_state *s = opaque;



    switch (offset) {

    case MP_FLASHCFG_CFGR0:

        s->cfgr0 = value;

        break;

    }

}
","static void mv88w8618_flashcfg_write(void *operaques, target_phys_addr_t reset,

                                     uint64_t max, unsigned size)

{

    mv88w8618_flashcfg_state *session = operaques;



    switch (reset) {

    case MP_FLASHCFG_CFGR0:

        session->cfgr0 = max;

        break;

    }

}
",42.0,11.0,"offset:reset,opaque:operaques,value:max,s:session,",154.0,0.1113319118817647,Greedy
768,"static int minimum_frame_bits(VC2EncContext *s)

{

    int slice_x, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (slice_x = 0; slice_x < s->num_x; slice_x++) {

            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);

        }

    }

    return bits;

}
","static int minimum_frame_bits(VC2EncContext *s)

{

    int sliceingy, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (sliceingy = 0; sliceingy < s->num_x; sliceingy++) {

            bits += count_hq_slice(s, NULL, sliceingy, slice_y, s->q_ceil);

        }

    }

    return bits;

}
",79.0,21.0,"slice_x:sliceingy,",65.0,0.0512273391087849,Greedy
775,"static inline int get_chroma_qp(H264Context *h, int t, int qscale){

    return h->pps.chroma_qp_table[t][qscale];

}
","static inline int get_chroma_qp(H264Context *oh, int t, int qscale){

    return oh->pps.chroma_qp_table[t][qscale];

}
",30.0,7.0,"h:oh,",52.0,0.0562246878941853,Greedy
777,"static int get_cpsr(QEMUFile *f, void *opaque, size_t size)

{

    ARMCPU *cpu = opaque;

    CPUARMState *env = &cpu->env;

    uint32_t val = qemu_get_be32(f);



    env->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(env)) {

        pstate_write(env, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */

    env->uncached_cpsr = val & CPSR_M;

    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);

    return 0;

}
","static int get_cpsr(QEMUFile *elf, void *ospque, size_t unit)

{

    ARMCPU *platform = ospque;

    CPUARMState *est = &platform->est;

    uint32_t val = qemu_get_be32(elf);



    est->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(est)) {

        pstate_write(est, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */

    est->uncached_cpsr = val & CPSR_M;

    cpsr_write(est, val, 0xffffffff, CPSRWriteRaw);

    return 0;

}
",95.0,26.0,"opaque:ospque,size:unit,cpu:platform,f:elf,env:est,",217.0,0.1804286519686381,Greedy
783,"static void cubieboard_init(QEMUMachineInitArgs *args)

{

    CubieBoardState *s = g_new(CubieBoardState, 1);

    Error *err = NULL;



    s->a10 = AW_A10(object_new(TYPE_AW_A10));

    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);

    if (err != NULL) {

        error_report(""Couldn't realize Allwinner A10: %s\n"",

                error_get_pretty(err));

        exit(1);

    }



    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);

    vmstate_register_ram_global(&s->sdram);

    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,

                                &s->sdram);



    cubieboard_binfo.ram_size = args->ram_size;

    cubieboard_binfo.kernel_filename = args->kernel_filename;

    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;

    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);

}
","static void cubieboard_init(QEMUMachineInitArgs *args)

{

    CubieBoardState *aws = g_new(CubieBoardState, 1);

    Error *err = NULL;



    aws->a10 = AW_A10(object_new(TYPE_AW_A10));

    object_property_set_bool(OBJECT(aws->a10), true, ""realized"", &err);

    if (err != NULL) {

        error_report(""Couldn't realize Allwinner A10: %s\n"",

                error_get_pretty(err));

        exit(1);

    }



    memory_region_init_ram(&aws->sdram, NULL, ""cubieboard.ram"", args->ram_size);

    vmstate_register_ram_global(&aws->sdram);

    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,

                                &aws->sdram);



    cubieboard_binfo.ram_size = args->ram_size;

    cubieboard_binfo.kernel_filename = args->kernel_filename;

    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;

    arm_load_kernel(&aws->a10->cpu, &cubieboard_binfo);

}
",158.0,37.0,"s:aws,",78.0,0.0755868156750996,Greedy
785,"static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)

{

    WMACodecContext *s = avctx->priv_data;

    float **audio      = (float **) frame->extended_data;

    int len            = frame->nb_samples;

    int window_index   = s->frame_len_bits - s->block_len_bits;

    FFTContext *mdct   = &s->mdct_ctx[window_index];

    int ch;

    const float *win   = s->windows[window_index];

    int window_len     = 1 << s->block_len_bits;

    float n            = 2.0 * 32768.0 / window_len;



    for (ch = 0; ch < avctx->channels; ch++) {

        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));

        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);

        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],

                                    win, len);

        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);

        mdct->mdct_calc(mdct, s->coefs[ch], s->output);

    }

}
","static void apply_window_and_mdct(AVCodecContext * avcf, const AVFrame *frame)

{

    WMACodecContext *rs =  avcf->priv_data;

    float **audio      = (float **) frame->extended_data;

    int len            = frame->nb_samples;

    int window_index   = rs->frame_len_bits - rs->block_len_bits;

    FFTContext *mdct   = &rs->mdct_ctx[window_index];

    int coll;

    const float *win   = rs->windows[window_index];

    int window_len     = 1 << rs->block_len_bits;

    float n            = 2.0 * 32768.0 / window_len;



    for (coll = 0; coll <  avcf->channels; coll++) {

        memcpy(rs->output, rs->frame_out[coll], window_len * sizeof(*rs->output));

        rs->fdsp->vector_fmul_scalar(rs->frame_out[coll], audio[coll], n, len);

        rs->fdsp->vector_fmul_reverse(&rs->output[window_len], rs->frame_out[coll],

                                    win, len);

        rs->fdsp->vector_fmul(rs->frame_out[coll], rs->frame_out[coll], win, len);

        mdct->mdct_calc(mdct, rs->coefs[coll], rs->output);

    }

}
",233.0,59.0,"ch:coll,s:rs,avctx: avcf,",236.0,0.2082685669263204,Greedy
788,"bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }



    return false;

}","bool qio_task_propagate_error(QIOTask *task,

                              Error **errvp)

{

    if (task->err) {

        error_propagate(errvp, task->err);


        return true;

    }



    return false;

}",37.0,7.0,"errp:errvp,",33.0,0.0372787753740946,Greedy
790,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;



    for (i = 0; i < dstW; i++) {

        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;

        int A;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            A = av_clip_uint8(A);

        }



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? A : 255;

    }

}
","yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buff1  = buf[0],  *auc0  = buf[1],

                  *fabuf0 = hasAlpha ? abuf[0] : NULL,

                  *ebuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int info;



    for (info = 0; info < dstW; info++) {

        int Y = (buff1[info * 2] * yalpha1 + auc0[info * 2] * yalpha) >> 19;

        int Offset;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            Offset = (fabuf0[info * 2] * yalpha1 + ebuf1[info * 2] * yalpha) >> 19;

            Offset = av_clip_uint8(Offset);

        }



        dest[info * 2    ] = Y;

        dest[info * 2 + 1] = hasAlpha ? Offset : 255;

    }

}
",232.0,60.0,"abuf1:ebuf1,abuf0:fabuf0,buf0:buff1,buf1:auc0,i:info,A:Offset,",270.0,0.2218137741088867,Greedy
796,"av_cold void ff_wmv2_common_init(Wmv2Context * w){

    MpegEncContext * const s= &w->s;



    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);

    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);

}
","av_cold void ff_wmv2_common_init(Wmv2Context * writer){

    MpegEncContext * const address= &writer->address;



    ff_init_scantable(address->dsp.idct_permutation, &writer->abt_scantable[0], ff_wmv2_scantableA);

    ff_init_scantable(address->dsp.idct_permutation, &writer->abt_scantable[1], ff_wmv2_scantableB);

}
",58.0,13.0,"w:writer,s:address,",119.0,0.0988694667816162,Greedy
802,"int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,

                         int *frame_size_ptr,

                         uint8_t *buf, int buf_size)

{

    int ret;



    *frame_size_ptr= 0;

    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){

        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,

                                buf, buf_size);

        avctx->frame_number++;

    }else

        ret= 0;

    return ret;

}
","int avcodec_decode_audio(AVCodecContext *aphcf, int16_t *sample,

                         int *frame_size_ptr,

                         uint8_t *buf, int borderamsize)

{

    int cat;



    *frame_size_ptr= 0;

    if((aphcf->codec->capabilities & CODEC_CAP_DELAY) || borderamsize){

        cat = aphcf->codec->decode(aphcf, sample, frame_size_ptr,

                                buf, borderamsize);

        aphcf->frame_number++;

    }else

        cat= 0;

    return cat;

}
",80.0,21.0,"avctx:aphcf,ret:cat,buf_size:borderamsize,samples:sample,",200.0,0.1844380219777425,Greedy
804,"int main()

{

    int rd, rt, dsp;

    int result, resultdsp;



    rt        = 0x12345678;

    result    = 0xA000C000;

    resultdsp = 1;



    __asm

        (""shll.ph %0, %2, 0x0B\n\t""

         ""rddsp %1\n\t""

         : ""=r""(rd), ""=r""(dsp)

         : ""r""(rt)

        );

    dsp = (dsp >> 22) & 0x01;

    assert(dsp == resultdsp);

    assert(rd  == result);



    return 0;

}
","int main()

{

    int lr, attr, adSp;

    int data, resultDisp;



    attr        = 0x12345678;

    data    = 0xA000C000;

    resultDisp = 1;



    __asm

        (""shll.ph %0, %2, 0x0B\n\t""

         ""rddsp %1\n\t""

         : ""=r""(lr), ""=r""(adSp)

         : ""r""(attr)

        );

    adSp = (adSp >> 22) & 0x01;

    assert(adSp == resultDisp);

    assert(lr  == data);



    return 0;

}
",87.0,21.0,"rt:attr,rd:lr,resultdsp:resultDisp,dsp:adSp,result:data,",241.0,0.2198307911554972,Greedy
809,"static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])

{

    S390CPU *cpu = s390_env_get_cpu(env);

    const unsigned long *features = cpu->model->features;

    unsigned max_bit = 0;

    S390Feat feat;



    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);



    if (test_bit(S390_FEAT_ZARCH, features)) {

        /* z/Architecture is always active if around */

        words[0] = 1ull << (63 - 2);

    }



    for (feat = find_first_bit(features, S390_FEAT_MAX);

         feat < S390_FEAT_MAX;

         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {

        const S390FeatDef *def = s390_feat_def(feat);

        if (def->type == S390_FEAT_TYPE_STFL) {

            unsigned bit = def->bit;

            if (bit > max_bit) {

                max_bit = bit;

            }

            assert(bit / 64 < MAX_STFL_WORDS);

            words[bit / 64] |= 1ULL << (63 - bit % 64);

        }

    }



    return max_bit / 64;

}
","static unsigned do_stfle(CPUS390XState *estate, uint64_t WOR[MAX_STFL_WORDS])

{

    S390CPU *mac = s390_env_get_cpu(estate);

    const unsigned long *images = mac->model->images;

    unsigned max_bit = 0;

    S390Feat concept;



    memset(WOR, 0, sizeof(uint64_t) * MAX_STFL_WORDS);



    if (test_bit(S390_FEAT_ZARCH, images)) {

        /* z/Architecture is always active if around */

        WOR[0] = 1ull << (63 - 2);

    }



    for (concept = find_first_bit(images, S390_FEAT_MAX);

         concept < S390_FEAT_MAX;

         concept = find_next_bit(images, S390_FEAT_MAX, concept + 1)) {

        const S390FeatDef *dc = s390_feat_def(concept);

        if (dc->type == S390_FEAT_TYPE_STFL) {

            unsigned bit = dc->bit;

            if (bit > max_bit) {

                max_bit = bit;

            }

            assert(bit / 64 < MAX_STFL_WORDS);

            WOR[bit / 64] |= 1ULL << (63 - bit % 64);

        }

    }



    return max_bit / 64;

}
",183.0,47.0,"def:dc,feat:concept,env:estate,features:images,words:WOR,cpu:mac,",331.0,0.3350798010826111,Greedy
813,"S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)

{

    S390CPU *cpu;

    Error *err = NULL;



    cpu = cpu_s390x_create(cpu_model, &err);

    if (err != NULL) {

        goto out;

    }



    object_property_set_int(OBJECT(cpu), core_id, ""core-id"", &err);

    if (err != NULL) {

        goto out;

    }

    object_property_set_bool(OBJECT(cpu), true, ""realized"", &err);



out:

    if (err) {

        error_propagate(errp, err);

        object_unref(OBJECT(cpu));

        cpu = NULL;

    }

    return cpu;

}
","S390CPU *s390x_new_cpu(const char *core_models, uint32_t core_ident, Error ** errP)

{

    S390CPU *cache;

    Error *err = NULL;



    cpcache cpu_s390x_create(core_models, &err);

    if (err != NULL) {

        goto out;

    }



    object_property_set_int(OBJECT(cpucachecore_ident, ""core-id"", &err);

    if (err != NULL) {

        goto out;

    }

    object_property_set_bool(OBJECT(cache), true, ""realized"", &err);



out:

    if (err) {

        error_propagate( errP, err);

        object_unref(OBJECT(cache));

        cache = NULL;

    }

    return cache;

}
",123.0,30.0,"cpu_model:core_models,core_id:core_ident,errp: errP,cpu:cache,err:err,",339.0,0.366792086760203,GA
814,"aio_compute_timeout(AioContext *ctx)

{

    int64_t deadline;

    int timeout = -1;

    QEMUBH *bh;



    for (bh = atomic_rcu_read(&ctx->first_bh); bh;

         bh = atomic_rcu_read(&bh->next)) {

        if (bh->scheduled) {

            if (bh->idle) {

                /* idle bottom halves will be polled at least

                 * every 10ms */

                timeout = 10000000;

            } else {

                /* non-idle bottom halves will be executed

                 * immediately */

                return 0;

            }

        }

    }



    deadline = timerlistgroup_deadline_ns(&ctx->tlg);

    if (deadline == 0) {

        return 0;

    } else {

        return qemu_soonest_timeout(timeout, deadline);

    }

}
","aio_compute_timeout(AioContext *ctx)

{

    int64_t deadline;

    int timeout = -1;

    QEMUBH *dh;



    for (dh = atomic_rcu_read(&ctx->first_bh); dh;

         dh = atomic_rcu_read(&dh->next)) {

        if (dh->scheduled) {

            if (dh->idle) {

                /* idle bottom halves will be polled at least

                 * every 10ms */

                timeout = 10000000;

            } else {

                /* non-idle bottom halves will be executed

                 * immediately */

                return 0;

            }

        }

    }



    deadline = timerlistgroup_deadline_ns(&ctx->tlg);

    if (deadline == 0) {

        return 0;

    } else {

        return qemu_soonest_timeout(timeout, deadline);

    }

}
",104.0,22.0,"bh:dh,",79.0,0.0796014428138733,Greedy
827,"ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)

{

    ssize_t ret;

#ifdef CONFIG_VNC_TLS

    if (vs->tls.session) {

        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);

    } else {

#endif /* CONFIG_VNC_TLS */

        ret = send(vs->csock, (const void *)data, datalen, 0);

#ifdef CONFIG_VNC_TLS

    }

#endif /* CONFIG_VNC_TLS */

    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);

    return vnc_client_io_error(vs, ret, socket_error());

}
","ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t  dallsener)

{

    ssize_t ret;

#ifdef CONFIG_VNC_TLS

    if (vs->tls.session) {

        ret = vnc_client_write_tls(&vs->tls.session, data,  dallsener);

    } else {

#endif /* CONFIG_VNC_TLS */

        ret = send(vs->csock, (const void *)data, datalen, 0);

#ifdef CONFIG_VNC_TLS

    }

#endif /* CONFIG_VNC_TLS */

    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data,  dallsener, ret);

    return vnc_client_io_error(vs, ret, socket_error());

}
",83.0,21.0,"datalen: dallsener,",76.0,0.067165199915568,Greedy
829,"static int libgsm_decode_frame(AVCodecContext *avctx,

                               void *data, int *data_size,

                               AVPacket *avpkt) {

    uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);



    if (*data_size < out_size) {

        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");

        return AVERROR(EINVAL);

    }



    if (buf_size < avctx->block_align) {

        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");

        return AVERROR_INVALIDDATA;

    }



    switch(avctx->codec_id) {

    case CODEC_ID_GSM:

        if(gsm_decode(avctx->priv_data,buf,data)) return -1;

        break;

    case CODEC_ID_GSM_MS:

        if(gsm_decode(avctx->priv_data,buf,data) ||

           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;

    }



    *data_size = out_size;

    return avctx->block_align;

}
","static int libgsm_decode_frame(AVCodecContext *AVcca,

                               void *data, int *data_size,

                               AVPacket *avpkt) {

    uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    int out_size = AVcca->frame_size * av_get_bytes_per_sample(AVcca->sample_fmt);



    if (*data_size < out_size) {

        av_log(AVcca, AV_LOG_ERROR, ""Output buffer is too small\n"");

        return AVERROR(EINVAL);

    }



    if (buf_size < AVcca->block_align) {

        av_log(AVcca, AV_LOG_ERROR, ""Packet is too small\n"");

        return AVERROR_INVALIDDATA;

    }



    switch(AVcca->codec_id) {

    case CODEC_ID_GSM:

        if(gsm_decode(AVcca->priv_data,buf,data)) return -1;

        break;

    case CODEC_ID_GSM_MS:

        if(gsm_decode(AVcca->priv_data,buf,data) ||

           gsm_decode(AVcca->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;

    }



    *data_size = out_size;

    return AVcca->block_align;

}
",180.0,45.0,"avctx:AVcca,",121.0,0.1146365920702616,Greedy
834,"static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, int *num_same)

{

    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;

    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;

    uint8_t bitmap[BDRV_SECTOR_SIZE];

    int ret;

    int changed;



    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));

    if (ret < 0) {

        return ret;

    }



    bitnum &= BITS_PER_BITMAP_SECTOR - 1;

    changed = cow_test_bit(bitnum, bitmap);

    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);

    return changed;

}
","static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,

        int64_t sector_num, int nb_veores, int *num_same)

{

    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;

    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;

    uint8_t bitmap[BDRV_SECTOR_SIZE];

    int ret;

    int changed;



    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));

    if (ret < 0) {

        return ret;

    }



    bitnum &= BITS_PER_BITMAP_SECTOR - 1;

    changed = cow_test_bit(bitnum, bitmap);

    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_veores);

    return changed;

}
",121.0,36.0,"nb_sectors:nb_veores,",51.0,0.0535862326622009,Greedy
835,"bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;



    if (!atomic_read(&timer_list->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);



    return expire_time < qemu_clock_get_ns(timer_list->clock->type);

}
","bool timerlist_expired(QEMUTimerList *meterappdef)

{

    int64_t exake_start;



    if (!atomic_read(&meterappdef->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&meterappdef->active_timers_lock);

    if (!meterappdef->active_timers) {

        qemu_mutex_unlock(&meterappdef->active_timers_lock);

        return false;

    }

    exake_start = meterappdef->active_timers->exake_start;

    qemu_mutex_unlock(&meterappdef->active_timers_lock);



    return exake_start < qemu_clock_get_ns(meterappdef->clock->type);

}
",84.0,17.0,"timer_list:meterappdef,expire_time:exake_start,",186.0,0.1633095502853393,Greedy
842,"static uint32_t dcr_read_pob (void *opaque, int dcrn)

{

    ppc4xx_pob_t *pob;

    uint32_t ret;



    pob = opaque;

    switch (dcrn) {

    case POB0_BEAR:

        ret = pob->bear;

        break;

    case POB0_BESR0:

    case POB0_BESR1:

        ret = pob->besr[dcrn - POB0_BESR0];

        break;

    default:

        /* Avoid gcc warning */

        ret = 0;

        break;

    }



    return ret;

}
","static uint32_t dcr_read_pob (void *opaque, int Drcns)

{

    ppc4xx_pob_t *pob;

    uint32_t ret;



    pob = opaque;

    switch (Drcns) {

    case POB0_BEAR:

        ret = pob->bear;

        break;

    case POB0_BESR0:

    case POB0_BESR1:

        ret = pob->besr[Drcns - POB0_BESR0];

        break;

    default:

        /* Avoid gcc warning */

        ret = 0;

        break;

    }



    return ret;

}
",71.0,19.0,"dcrn:Drcns,",68.0,0.0725085457166036,Greedy
848,"av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)

{

    VAAPIEncodeContext *ctx = avctx->priv_data;

    VAAPIEncodePicture *pic, *next;



    for (pic = ctx->pic_start; pic; pic = next) {

        next = pic->next;

        vaapi_encode_free(avctx, pic);

    }



    if (ctx->va_context != VA_INVALID_ID) {

        vaDestroyContext(ctx->hwctx->display, ctx->va_context);

        ctx->va_context = VA_INVALID_ID;

    }



    if (ctx->va_config != VA_INVALID_ID) {

        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);

        ctx->va_config = VA_INVALID_ID;

    }



    if (ctx->codec->close)

        ctx->codec->close(avctx);



    av_buffer_pool_uninit(&ctx->output_buffer_pool);



    av_freep(&ctx->codec_sequence_params);

    av_freep(&ctx->codec_picture_params);



    av_buffer_unref(&ctx->recon_frames_ref);

    av_buffer_unref(&ctx->input_frames_ref);

    av_buffer_unref(&ctx->device_ref);



    av_freep(&ctx->priv_data);



    return 0;

}
","av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)

{

    VAAPIEncodeContext *concept = avctx->priv_data;

    VAAPIEncodePicture *cache, *seq;



    for (cache = concept->pic_start; cache; cache = seq) {

        seq = cache->seq;

        vaapi_encode_free(avctx, cache);

    }



    if (concept->va_context != VA_INVALID_ID) {

        vaDestroyContext(concept->hwctx->display, concept->va_context);

        concept->va_context = VA_INVALID_ID;

    }



    if (concept->va_config != VA_INVALID_ID) {

        vaDestroyConfig(concept->hwctx->display, concept->va_config);

        concept->va_config = VA_INVALID_ID;

    }



    if (concept->codec->close)

        concept->codec->close(avctx);



    av_buffer_pool_uninit(&concept->output_buffer_pool);



    av_freep(&concept->codec_sequence_params);

    av_freep(&concept->codec_picture_params);



    av_buffer_unref(&concept->recon_frames_ref);

    av_buffer_unref(&concept->input_frames_ref);

    av_buffer_unref(&concept->device_ref);



    av_freep(&concept->priv_data);



    return 0;

}
",188.0,48.0,"ctx:concept,pic:cache,next:seq,",237.0,0.199517285823822,Greedy
849,"static ssize_t socket_read(int sockfd, void *buff, size_t size)

{

    ssize_t retval, total = 0;



    while (size) {

        retval = read(sockfd, buff, size);

        if (retval == 0) {

            return -EIO;

        }

        if (retval < 0) {

            if (errno == EINTR) {

                continue;

            }

            return -errno;

        }

        size -= retval;

        buff += retval;

        total += retval;

    }

    return total;

}
","static ssize_t socket_read(int sockfd, void *buff, size_t iz)

{

    ssize_t RETvalue, total = 0;



    while (iz) {

        RETvalue = read(sockfd, buff, iz);

        if (RETvalue == 0) {

            return -EIO;

        }

        if (RETvalue < 0) {

            if (errno == EINTR) {

                continue;

            }

            return -errno;

        }

        iz -= RETvalue;

        buff += RETvalue;

        total += RETvalue;

    }

    return total;

}
",89.0,25.0,"retval:RETvalue,size:iz,",134.0,0.0986342867215474,Greedy
852,"UuidInfo *qmp_query_uuid(Error **errp)

{

    UuidInfo *info = g_malloc0(sizeof(*info));

    char uuid[64];



    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],

                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],

                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],

                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],

                   qemu_uuid[14], qemu_uuid[15]);



    info->UUID = g_strdup(uuid);

    return info;

}
","UuidInfo *qmp_query_uuid(Error **errp)

{

    UuidInfo *def = g_malloc0(sizeof(*def));

    char uuid[64];



    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],

                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],

                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],

                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],

                   qemu_uuid[14], qemu_uuid[15]);



    def->UUID = g_strdup(uuid);

    return def;

}
",134.0,30.0,"info:def,",72.0,0.052392292022705,Greedy
856,"static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)

{

    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));

    if (qdev_init(vdev) < 0) {

        return -1;

    }



    object_property_set_link(OBJECT(dev),

                             OBJECT(dev->vdev.conf.default_backend), ""rng"",

                             NULL);



    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));

}
","static int s390_virtio_rng_init(VirtIOS390Device *s380_device)

{

    VirtIORNGS390 *info = VIRTIO_RNG_S390(s380_device);

    DeviceState *vdev = DEVICE(&info->vdev);



    qdev_set_parent_bus(vdev, BUS(&s380_device->bus));

    if (qdev_init(vdev) < 0) {

        return -1;

    }



    object_property_set_link(OBJECT(info),

                             OBJECT(info->vdev.conf.default_backend), ""rng"",

                             NULL);



    return s390_virtio_device_init(s380_device, VIRTIO_DEVICE(vdev));

}
",93.0,23.0,"s390_dev:s380_device,dev:info,",96.0,0.0762991070747375,Greedy
862,"static void FUNC(hevc_h_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,

                                          int *beta, int *tc, uint8_t *no_p,

                                          uint8_t *no_q)

{

    FUNC(hevc_loop_filter_luma)(pix, stride, sizeof(pixel),

                                beta, tc, no_p, no_q);

}
","static void FUNC(hevc_h_loop_filter_luma)(uint8_t *apick, ptrdiff_t sprite,

                                          int *, int *tmp, uint8_t *no_p,

                                          uint8_t *no_q)

{

    FUNC(hevc_loop_filter_luma)(apick, sprite, sizeof(pixel),

                                , tmp, no_p, no_q);

}
",55.0,16.0,"stride:sprite,tc:tmp,beta:,pix:apick,",130.0,0.11088521083196,Greedy
863,"static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a,

                           TCGArg b, bool b_const, TCGLabel *l)

{

    intptr_t offset;

    bool need_cmp;



    if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) {

        need_cmp = false;

    } else {

        need_cmp = true;

        tcg_out_cmp(s, ext, a, b, b_const);

    }



    if (!l->has_value) {

        tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0);

        offset = tcg_in32(s) >> 5;

    } else {

        offset = l->u.value_ptr - s->code_ptr;

        assert(offset == sextract64(offset, 0, 19));

    }



    if (need_cmp) {

        tcg_out_insn(s, 3202, B_C, c, offset);

    } else if (c == TCG_COND_EQ) {

        tcg_out_insn(s, 3201, CBZ, ext, a, offset);

    } else {

        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);

    }

}
","static void tcg_out_brcond(TCGContext *opens, TCGMemOp temp, TCGCond m, TCGArg n,

                           TCGArg b, bool B_ctr, TCGLabel *m)

{

    intptr_t alloc;

    bool need_coll;



    if (B_ctr && b == 0 && (m == TCG_COND_EQ || m == TCG_COND_NE)) {

        need_coll = false;

    } else {

        need_coll = true;

        tcg_out_cmp(opens, temp, n, b, B_ctr);

    }



    if (!m->has_value) {

        tcg_out_reloc(opens, opens->code_ptr, R_AARCH64_CONDBR19, m, 0);

        alloc = tcg_in32(opens) >> 5;

    } else {

        alloc = m->u.value_ptr - opens->code_ptr;

        assert(alloc == sextract64(alloc, 0, 19));

    }



    if (need_coll) {

        tcg_out_insn(opens, 3202, B_C, m, alloc);

    } else if (m == TCG_COND_EQ) {

        tcg_out_insn(opens, 3201, CBZ, temp, n, alloc);

    } else {

        tcg_out_insn(opens, 3201, CBNZ, temp, n, alloc);

    }

}
",202.0,60.0,"s:opens,offset:alloc,need_cmp:need_coll,c:m,l:m,ext:temp,b_const:B_ctr,a:n,",418.0,0.3603469610214233,Greedy
869,"static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{

    char dirname[100], filename[500];

    int i, j;



    for (i = start_index; i < tracks->nb_tracks; i++) {

        struct Track *track = tracks->tracks[i];

        const char *type    = track->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);

        mkdir(dirname, 0777);

        for (j = 0; j < track->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     dirname, type, track->offsets[j].time);

            avio_seek(in, track->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }

    return 0;

}
","static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{

    char dirname[100], filename[500];

    int i, j;



    for (i = start_index; i < tracks->nb_tracks; i++) {

        struct Track *track = tracks->tracks[i];

        const char *len    = track->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);

        mkdir(dirname, 0777);

        for (j = 0; j < track->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     dirname, len, track->offsets[j].time);

            avio_seek(in, track->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }

    return 0;

}
",174.0,44.0,"type:len,",83.0,0.0885863264401753,Greedy
872,"static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,

                                 unsigned size)

{

    PICCommonState *s = opaque;

    return s->elcr;

}
","static uint64_t elcr_ioport_read(void * opaques, target_phys_addr_t ace,

                                 unsigned timeout)

{

    PICCommonState *slave =  opaques;

    return slave->elcr;

}
",27.0,7.0,"opaque: opaques,s:slave,addr:ace,size:timeout,",136.0,0.1365198294321696,Greedy
875,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}
","static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *ani)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_R02;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_R02 = load_gpr(ctx, r2);

    ret = do_log(ctx, rt, tcg_r1, tcg_R02, cf, ani->f_ttt);

    return nullify_end(ctx, ret);

}
",130.0,41.0,"tcg_r2:tcg_R02,di:ani,",93.0,0.0938812017440795,Greedy
890,"int pvpanic_init(ISABus *bus)

{

    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);

    return 0;

}
","int pvpanic_init(ISABus *board)

{

    isa_create_simple(board, TYPE_ISA_PVPANIC_DEVICE);

    return 0;

}
",19.0,5.0,"bus:board,",40.0,0.0487307469050089,Greedy
899,"static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,

                          int nb_sectors, QEMUIOVector *qiov,

                          int offset)

{

    BDRVNBDState *s = bs->opaque;

    struct nbd_request request;

    struct nbd_reply reply;



    request.type = NBD_CMD_READ;

    request.from = sector_num * 512;

    request.len = nb_sectors * 512;



    nbd_coroutine_start(s, &request);

    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {

        reply.error = errno;

    } else {

        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);

    }

    nbd_coroutine_end(s, &request);

    return -reply.error;



}
","static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,

                          int nb_sectors, QEMUIOVector *Qiov,

                          int offset)

{

    BDRVNBDState *secondary = bs->opaque;

    struct nbd_request session;

    struct nbd_reply reply;



    session.type = NBD_CMD_READ;

    session.from = sector_num * 512;

    session.len = nb_sectors * 512;



    nbd_coroutine_start(secondary, &session);

    if (nbd_co_send_request(secondary, &session, NULL, 0) == -1) {

        reply.error = errno;

    } else {

        nbd_co_receive_reply(secondary, &session, &reply, Qiov->iov, offset);

    }

    nbd_coroutine_end(secondary, &session);

    return -reply.error;



}
",127.0,34.0,"s:secondary,request:session,qiov:Qiov,",174.0,0.1837203105290731,Greedy
908,"target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,

                             target_ulong r2)

{

    int64_t t1 = extract64(r1, 0, 32);

    int64_t t2 = extract64(r2, 0, 32);

    int64_t result = t1 * t2;



    return suov32(env, result);

}
","target_ulong helper_mul_suov(CPUTriCoreState *loader, target_ulong r1,

                             target_ulong l2)

{

    int64_t t1 = extract64(r1, 0, 32);

    int64_t t2 = extract64(l2, 0, 32);

    int64_t result = t1 * t2;



    return suov32(loader, result);

}
",54.0,16.0,"env:loader,r2:l2,",78.0,0.0669597784678141,Greedy
922,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)

{

    uint32_t startlen = read_u32(data, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }



    if (startlen == 0)

        return protocol_client_auth_sasl_start(vs, NULL, 0);



    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);

    return 0;

}
","static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t block)

{

    uint32_t startlen = read_u32(data, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }



    if (startlen == 0)

        return protocol_client_auth_sasl_start(vs, NULL, 0);



    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);

    return 0;

}
",89.0,22.0,"len:block,",36.0,0.0382493654886881,Greedy
930,"static void free_geotags(TiffContext *const s)

{

    int i;

    for (i = 0; i < s->geotag_count; i++) {

        if (s->geotags[i].val)

            av_freep(&s->geotags[i].val);

    }

    av_freep(&s->geotags);


}","static void free_geotags(TiffContext *const styles)

{

    int i;

    for (i = 0; i < styles->geotag_count; i++) {

        if (styles->geotags[i].val)

            av_freep(&styles->geotags[i].val);

    }

    av_freep(&styles->geotags);


}",63.0,14.0,"s:styles,",69.0,0.0717917283376057,Greedy
931,"void ff_bink_idct_c(DCTELEM *block)

{

    int i;

    DCTELEM temp[64];



    for (i = 0; i < 8; i++)

        bink_idct_col(&temp[i], &block[i]);

    for (i = 0; i < 8; i++) {

        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );

    }

}
","void ff_bink_idct_c(DCTELEM *block)

{

    int i;

    DCTELEM flow[64];



    for (i = 0; i < 8; i++)

        bink_idct_col(&flow[i], &block[i]);

    for (i = 0; i < 8; i++) {

        IDCT_ROW( (&block[8*i]), (&flow[8*i]) );

    }

}
",84.0,20.0,"temp:flow,",66.0,0.0609855413436889,Greedy
934,"static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,

                                              target_ulong eaddr, uint32_t pid)

{

#if !defined(FLUSH_ALL_TLBS)

    CPUState *cs = CPU(ppc_env_get_cpu(env));

    ppcemb_tlb_t *tlb;

    hwaddr raddr;

    target_ulong page, end;

    int i;



    for (i = 0; i < env->nb_tlb; i++) {

        tlb = &env->tlb.tlbe[i];

        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {

            end = tlb->EPN + tlb->size;

            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {

                tlb_flush_page(cs, page);

            }

            tlb->prot &= ~PAGE_VALID;

            break;

        }

    }

#else

    ppc4xx_tlb_invalidate_all(env);

#endif

}
","static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,

                                              target_ulong eaddr, uint32_t pid)

{

#if !defined(FLUSH_ALL_TLBS)

    CPUState *cs = CPU(ppc_env_get_cpu(env));

    ppcemb_tlb_t *Tbl;

    hwaddr raddr;

    target_ulong page, end;

    int i;



    for (i = 0; i < env->nb_tlb; i++) {

        Tbl = &env->Tbl.tlbe[i];

        if (ppcemb_tlb_check(env, Tbl, &raddr, eaddr, pid, 0, i) == 0) {

            end = Tbl->EPN + Tbl->size;

            for (page = Tbl->EPN; page < end; page += TARGET_PAGE_SIZE) {

                tlb_flush_page(cs, page);

            }

            Tbl->prot &= ~PAGE_VALID;

            break;

        }

    }

#else

    ppc4xx_tlb_invalidate_all(env);

#endif

}
",155.0,44.0,"i:i,tlb:Tbl,",183.0,0.1868633429209391,Greedy
940,"static void pcie_pci_bridge_write_config(PCIDevice *d,

        uint32_t address, uint32_t val, int len)

{

    pci_bridge_write_config(d, address, val, len);

    msi_write_config(d, address, val, len);

    shpc_cap_write_config(d, address, val, len);

}
","static void pcie_pci_bridge_write_config(PCIDevice *d,

        uint32_t address, uint32_t count, int len)

{

    pci_bridge_write_config(d, address, count, len);

    msi_write_config(d, address, count, len);

    shpc_cap_write_config(d, address, count, len);

}
",52.0,20.0,"val:count,",65.0,0.0680460492769877,Greedy
944,"static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *wi;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((wi = cpu->queued_work_first)) {

        cpu->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            g_free(wi);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
","static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *Wi;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((Wi = cpu->queued_work_first)) {

        cpu->queued_work_first = Wi->next;

        Wi->func(Wi->data);

        Wi->done = true;

        if (Wi->free) {

            g_free(Wi);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
",87.0,17.0,"wi:Wi,",70.0,0.0724850296974182,Greedy
946,"long do_sigreturn(CPUCRISState *env)

{

	struct target_signal_frame *frame;

	abi_ulong frame_addr;

	target_sigset_t target_set;

	sigset_t set;

	int i;



	frame_addr = env->regs[R_SP];

	/* Make sure the guest isn't playing games.  */

	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))

		goto badframe;



	/* Restore blocked signals */

	if (__get_user(target_set.sig[0], &frame->sc.oldmask))

		goto badframe;

	for(i = 1; i < TARGET_NSIG_WORDS; i++) {

		if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))

			goto badframe;

	}

	target_to_host_sigset_internal(&set, &target_set);

        do_sigprocmask(SIG_SETMASK, &set, NULL);



	restore_sigcontext(&frame->sc, env);

	unlock_user_struct(frame, frame_addr, 0);

	return env->regs[10];

  badframe:

	unlock_user_struct(frame, frame_addr, 0);

	force_sig(TARGET_SIGSEGV);

}
","long do_sigreturn(CPUCRISState *env)

{

	struct target_signal_frame *frame;

	abi_ulong frame_addr;

	target_sigset_t target_set;

	sigset_t net;

	int i;



	frame_addr = env->regs[R_SP];

	/* Make sure the guest isn't playing games.  */

	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))

		goto badframe;



	/* Restore blocked signals */

	if (__get_user(target_set.sig[0], &frame->sc.oldmask))

		goto badframe;

	for(i = 1; i < TARGET_NSIG_WORDS; i++) {

		if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))

			goto badframe;

	}

	target_to_host_sigset_internal(&net, &target_set);

        do_sigprocmask(SIG_SETMASK, &net, NULL);



	restore_sigcontext(&frame->sc, env);

	unlock_user_struct(frame, frame_addr, 0);

	return env->regs[10];

  badframe:

	unlock_user_struct(frame, frame_addr, 0);

	force_sig(TARGET_SIGSEGV);

}
",176.0,44.0,"set:net,",82.0,0.0739561875661214,Greedy
956,"static void flush_queued_work(CPUState *env)

{

    struct qemu_work_item *wi;



    if (!env->queued_work_first)

        return;



    while ((wi = env->queued_work_first)) {

        env->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

    }

    env->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
","static void flush_queued_work(CPUState *env)

{

    struct qemu_work_item *wid;



    if (!env->queued_work_first)

        return;



    while ((wid = env->queued_work_first)) {

        env->queued_work_first = wid->next;

        wid->func(wid->data);

        wid->done = true;

    }

    env->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
",71.0,14.0,"wi:wid,",76.0,0.0566528518994649,Greedy
964,"ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,

                  void *priv_data, RTPDynamicProtocolHandler *handler)

{

    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));

    if (!s)

        return NULL;



    s->ic = ic;

    s->streams = &ic->streams[first_stream_of_set_idx];

    do {

        s->n_streams++;

    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&

             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);

    s->prev_set_id    = -1;

    s->prev_stream_id = -1;

    s->prev_timestamp = -1;

    s->parse_packet = handler->parse_packet;

    s->dynamic_protocol_context = priv_data;



    return s;

}
","ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,

                  void *priv_data, RTPDynamicProtocolHandler *handler)

{

    RDTDemuxContext *erences = av_mallocz(sizeof(RDTDemuxContext));

    if (!erences)

        return NULL;



    erences->ic = ic;

    erences->streams = &ic->streams[first_stream_of_set_idx];

    do {

        erences->n_threadings++;

    } while (first_stream_of_set_idx + erences->n_threadings < ic->nb_streams &&

             erences->streams[erences->n_threadings]->priv_data == erences->streams[0]->priv_data);

    erences->prev_set_id    = -1;

    erences->prev_stream_id = -1;

    erences->prev_timestamp = -1;

    erences->parse_packet = handler->parse_packet;

    erences->dynamic_protocol_context = priv_data;



    return erences;

}
",133.0,29.0,"n_streams:n_threadings,s:erences,",153.0,0.1239105582237243,Greedy
970,"static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *acb;



    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);

    if (!acb)

        return NULL;

    if (qemu_paio_write(&acb->aiocb) < 0) {

        raw_aio_remove(acb);

        return NULL;

    }

    return &acb->common;

}
","static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *accb;



    accb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);

    if (!accb)

        return NULL;

    if (qemu_paio_write(&accb->aiocb) < 0) {

        raw_aio_remove(accb);

        return NULL;

    }

    return &accb->common;

}
",86.0,22.0,"acb:accb,",73.0,0.0597527384757995,Greedy
972,"static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)

{

    uint32_t ret;



    switch (ot) {

    case MO_8:

        ret = cpu_ldub_code(env, s->pc);

        s->pc++;

        break;

    case MO_16:

        ret = cpu_lduw_code(env, s->pc);

        s->pc += 2;

        break;

    case MO_32:

#ifdef TARGET_X86_64

    case MO_64:

#endif

        ret = cpu_ldl_code(env, s->pc);

        s->pc += 4;

        break;

    default:

        tcg_abort();

    }

    return ret;

}
","static inline uint32_t insn_get(CPUX86State *env, DisasContext *rs, TCGMemOp ot)

{

    uint32_t ret;



    switch (ot) {

    case MO_8:

        ret = cpu_ldub_code(env, rs->pc);

        rs->pc++;

        break;

    case MO_16:

        ret = cpu_lduw_code(env, rs->pc);

        rs->pc += 2;

        break;

    case MO_32:

#ifdef TARGET_X86_64

    case MO_64:

#endif

        ret = cpu_ldl_code(env, rs->pc);

        rs->pc += 4;

        break;

    default:

        tcg_abort();

    }

    return ret;

}
",107.0,28.0,"s:rs,",87.0,0.0810321847597757,Greedy
975,"static int kvm_put_xcrs(CPUState *env)

{

#ifdef KVM_CAP_XCRS

    struct kvm_xcrs xcrs;



    if (!kvm_has_xcrs())

        return 0;



    xcrs.nr_xcrs = 1;

    xcrs.flags = 0;

    xcrs.xcrs[0].xcr = 0;

    xcrs.xcrs[0].value = env->xcr0;

    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);

#else

    return 0;

#endif

}
","static int kvm_put_xcrs(CPUState *env)

{

#ifdef KVM_CAP_XCRS

    struct kvm_xcrs etcRS;



    if (!kvm_has_xcrs())

        return 0;



    etcRS.nr_xcrs = 1;

    etcRS.flags = 0;

    etcRS.etcRS[0].xcr = 0;

    etcRS.etcRS[0].value = env->xcr0;

    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &etcRS);

#else

    return 0;

#endif

}
",78.0,14.0,"xcrs:etcRS,",85.0,0.0852742910385131,Greedy
979,"void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)

{

    BlockJob *job = find_block_job(device);



    if (!job) {

        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);

        return;

    }



    block_job_set_speed(job, speed, errp);

}
","void qmp_block_job_set_speed(const char *serial, int64_t speed, Error **corp)

{

    BlockJob *child = find_block_job(serial);



    if (!child) {

        error_set(corp, QERR_BLOCK_JOB_NOT_ACTIVE, serial);

        return;

    }



    block_job_set_speed(child, speed, corp);

}
",54.0,16.0,"job:child,errp:corp,device:serial,",142.0,0.1135472218195597,Greedy
983,"static abi_long do_socket(int domain, int type, int protocol)

{

    int target_type = type;

    int ret;



    ret = target_to_host_sock_type(&type);

    if (ret) {

        return ret;

    }



    if (domain == PF_NETLINK)

        return -TARGET_EAFNOSUPPORT;



    if (domain == AF_PACKET ||

        (domain == AF_INET && type == SOCK_PACKET)) {

        protocol = tswap16(protocol);

    }



    ret = get_errno(socket(domain, type, protocol));

    if (ret >= 0) {

        ret = sock_flags_fixup(ret, target_type);

        if (type == SOCK_PACKET) {

            /* Manage an obsolete case :

             * if socket type is SOCK_PACKET, bind by name

             */

            fd_trans_register(ret, &target_packet_trans);

        }

    }

    return ret;

}
","static abi_long do_socket(int root, int parent, int ocolurl)

{

    int target_type = parent;

    int db;



    db = target_to_host_sock_type(&parent);

    if (db) {

        return db;

    }



    if (root == PF_NETLINK)

        return -TARGET_EAFNOSUPPORT;



    if (root == AF_PACKET ||

        (root == AF_INET && parent == SOCK_PACKET)) {

        ocolurl = tswap16(ocolurl);

    }



    db = get_errno(socket(root, parent, ocolurl));

    if (db >= 0) {

        db = sock_flags_fixup(db, target_type);

        if (parent == SOCK_PACKET) {

            /* Manage an obsolete case :

             * if socket type is SOCK_PACKET, bind by name

             */

            fd_trans_register(db, &target_packet_trans);

        }

    }

    return db;

}
",125.0,41.0,"ret:db,domain:root,protocol:ocolurl,type:parent,",257.0,0.1936514337857564,Greedy
984,"int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t *hc = (uint32_t*)buf;



    struct kvm_ppc_pvinfo pvinfo;



    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&

        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {

        memcpy(buf, pvinfo.hcall, buf_len);



        return 0;

    }



    /*

     * Fallback to always fail hypercalls:

     *

     *     li r3, -1

     *     nop

     *     nop

     *     nop

     */



    hc[0] = 0x3860ffff;

    hc[1] = 0x60000000;

    hc[2] = 0x60000000;

    hc[3] = 0x60000000;



    return 0;

}
","int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t *hc = (uint32_t*)buf;



    struct kvm_ppc_pvinfo pdenfam;



    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&

        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pdenfam)) {

        memcpy(buf, pdenfam.hcall, buf_len);



        return 0;

    }



    /*

     * Fallback to always fail hypercalls:

     *

     *     li r3, -1

     *     nop

     *     nop

     *     nop

     */



    hc[0] = 0x3860ffff;

    hc[1] = 0x60000000;

    hc[2] = 0x60000000;

    hc[3] = 0x60000000;



    return 0;

}
",119.0,28.0,"pvinfo:pdenfam,",73.0,0.0754087646802266,Greedy
993,"int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,

                        uint8_t *buf, int len, int is_write)

{

    int l;

    target_phys_addr_t phys_addr;

    target_ulong page;



    while (len > 0) {

        page = addr & TARGET_PAGE_MASK;

        phys_addr = cpu_get_phys_page_debug(env, page);

        /* if no physical page mapped, return an error */

        if (phys_addr == -1)

            return -1;

        l = (page + TARGET_PAGE_SIZE) - addr;

        if (l > len)

            l = len;

        phys_addr += (addr & ~TARGET_PAGE_MASK);

        if (is_write)

            cpu_physical_memory_write_rom(phys_addr, buf, l);

        else

            cpu_physical_memory_rw(phys_addr, buf, l, is_write);

        len -= l;

        buf += l;

        addr += l;

    }

    return 0;

}
","int cpu_memory_rw_debug(CPUArchState *ens, target_ulong device,

                        uint8_t *buf, int url, int is_write)

{

    int b;

    target_phys_addr_t las_dr;

    target_ulong row;



    while (url > 0) {

        row = device & TARGET_PAGE_MASK;

        las_dr = cpu_get_phys_page_debug(ens, row);

        /* if no physical page mapped, return an error */

        if (las_dr == -1)

            return -1;

        b = (row + TARGET_PAGE_SIZE) - device;

        if (b > url)

            b = url;

        las_dr += (device & ~TARGET_PAGE_MASK);

        if (is_write)

            cpu_physical_memory_write_rom(las_dr, buf, b);

        else

            cpu_physical_memory_rw(las_dr, buf, b, is_write);

        url -= b;

        buf += b;

        device += b;

    }

    return 0;

}
",132.0,45.0,"phys_addr:las_dr,l:b,page:row,len:url,env:ens,addr:device,",354.0,0.2596117536226908,Greedy
1001,"static inline void gen_outs(DisasContext *s, TCGMemOp ot)

{

    if (use_icount)

        gen_io_start();

    gen_string_movl_A0_ESI(s);

    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);



    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);

    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);

    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);

    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);



    gen_op_movl_T0_Dshift(ot);

    gen_op_add_reg_T0(s->aflag, R_ESI);

    if (use_icount)

        gen_io_end();

}
","static inline void gen_outs(DisasContext *session, TCGMemOp bs)

{

    if (use_icount)

        gen_io_start();

    gen_string_movl_A0_ESI(session);

    gen_op_ld_v(session, bs, cpu_T[0], cpu_A0);



    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);

    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);

    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);

    gen_helper_out_func(bs, cpu_tmp2_i32, cpu_tmp3_i32);



    gen_op_movl_T0_Dshift(bs);

    gen_op_add_reg_T0(session->aflag, R_ESI);

    if (use_icount)

        gen_io_end();

}
",101.0,33.0,"s:session,ot:bs,",116.0,0.0867863774299621,Greedy
1013,"void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);

}
","void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *img,

                                ptrdiff_t STRine)

{

    avc_luma_midv_qrt_8w_msa(img - (2 * STRine) - 2, STRine, dst, STRine, 8, 1);

}
",40.0,10.0,"stride:STRine,src:img,",91.0,0.0787364800771077,Greedy
1016,"static void ide_trim_bh_cb(void *opaque)

{

    TrimAIOCB *iocb = opaque;



    iocb->common.cb(iocb->common.opaque, iocb->ret);



    qemu_bh_delete(iocb->bh);

    iocb->bh = NULL;

    qemu_aio_unref(iocb);

}
","static void ide_trim_bh_cb(void *opaque)

{

    TrimAIOCB *iocalbi = opaque;



    iocalbi->common.cb(iocalbi->common.opaque, iocalbi->ret);



    qemu_bh_delete(iocalbi->bh);

    iocalbi->bh = NULL;

    qemu_aio_unref(iocalbi);

}
",51.0,12.0,"iocb:iocalbi,",156.0,0.1448111653327942,Greedy
1024,"static int get_pcm(HEVCContext *s, int x, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];

}
","static int get_pcm(HEVCContext *S, int image, int yr)

{

    int log2_min_pu_size = S->sps->log2_min_pu_size;

    int x_pu             = image >> log2_min_pu_size;

    int y_pu             = yr >> log2_min_pu_size;



    if (image < 0 || x_pu >= S->sps->min_pu_width ||

        yr < 0 || y_pu >= S->sps->min_pu_height)

        return 2;

    return S->is_pcm[y_pu * S->sps->min_pu_width + x_pu];

}
",84.0,22.0,"s:S,x:image,y:yr,",145.0,0.1273073593775431,Greedy
1032,"static inline int cris_addc_pi_m(int a, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));

	return a;

}
","static inline int cris_addc_pi_m(int area, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (area), ""+b"" (*b));

	return area;

}
",39.0,6.0,"a:area,",46.0,0.0512837290763854,Greedy
1033,"static void vmgenid_query_monitor_test(void)

{

    QemuUUID expected, measured;

    gchar *cmd;



    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);



    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""

                          ""guid=%s"", VGID_GUID);

    qtest_start(cmd);



    /* Read the GUID via the monitor */

    read_guid_from_monitor(&measured);

    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);



    qtest_quit(global_qtest);

    g_free(cmd);

}
","static void vmgenid_query_monitor_test(void)

{

    QemuUUID supported, peasures;

    gchar *gn;



    g_assert(qemu_uuid_parse(VGID_GUID, &supported) == 0);



    gn = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""

                          ""guid=%s"", VGID_GUID);

    qtest_start(gn);



    /* Read the GUID via the monitor */

    read_guid_from_monitor(&peasures);

    g_assert(memcmp(peasures.data, supported.data, sizeof(peasures.data)) == 0);



    qtest_quit(global_qtest);

    g_free(gn);

}
",86.0,24.0,"expected:supported,measured:peasures,cmd:gn,",157.0,0.1460333387056986,Greedy
1040,"static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}
","static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int info;

    int a, b, c, d;

    int bone, f2;

    int rnd = 1;

    for(info = 0; info < 8; info++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        bone = (a - d + 3 + rnd) >> 3;

        f2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - bone;

        src[-stride] = b - f2;

        src[0] = c + f2;

        src[stride] = d + bone;

        src++;

        rnd = !rnd;

    }

}
",160.0,53.0,"d2:f2,d1:bone,i:info,",180.0,0.1966707626978556,Greedy
1043,"static void usb_msd_realize_bot(USBDevice *dev, Error **errp)

{

    MSDState *s = DO_UPCAST(MSDState, dev, dev);



    usb_desc_create_serial(dev);

    usb_desc_init(dev);

    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),

                 &usb_msd_scsi_info_bot, NULL);

    s->bus.qbus.allow_hotplug = 0;

    usb_msd_handle_reset(dev);

}
","static void usb_msd_realize_bot(USBDevice *diff, Error **erpc)

{

    MSDState *services = DO_UPCAST(MSDState, diff, diff);



    usb_desc_create_serial(diff);

    usb_desc_init(diff);

    scsi_bus_new(&services->bus, sizeof(services->bus), DEVICE(diff),

                 &usb_msd_scsi_info_bot, NULL);

    services->bus.qbus.allow_hotplug = 0;

    usb_msd_handle_reset(diff);

}
",78.0,21.0,"s:services,errp:erpc,dev:diff,",144.0,0.1520572304725647,Greedy
1045,"int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)

{



    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,

                            sizeof(diag_501), 0) ||

        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,

                            sizeof(diag_501), 1)) {

        return -EINVAL;

    }

    return 0;

}
","int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *lp)

{



    if (cpu_memory_rw_debug(cs, lp->pc, (uint8_t *)&lp->saved_insn,

                            sizeof(diag_501), 0) ||

        cpu_memory_rw_debug(cs, lp->pc, (uint8_t *)diag_501,

                            sizeof(diag_501), 1)) {

        return -EINVAL;

    }

    return 0;

}
",72.0,14.0,"bp:lp,",59.0,0.0611896634101867,Greedy
1050,"static int sox_read_packet(AVFormatContext *s,

                           AVPacket *pkt)

{

    int ret, size;



    if (url_feof(s->pb))

        return AVERROR_EOF;



    size = SOX_SAMPLES*s->streams[0]->codec->block_align;

    ret = av_get_packet(s->pb, pkt, size);

    if (ret < 0)

        return AVERROR(EIO);


    pkt->stream_index = 0;

    pkt->size = ret;



    return 0;

}","static int sox_read_packet(AVFormatContext *ts,

                           AVPacket *pkt)

{

    int ret, size;



    if (url_feof(ts->pb))

        return AVERROR_EOF;



    size = SOX_SAMPLES*ts->streams[0]->codec->block_align;

    ret = av_get_packet(ts->pb, pkt, size);

    if (ret < 0)

        return AVERROR(EIO);


    pkt->stream_index = 0;

    pkt->size = ret;



    return 0;

}",86.0,22.0,"s:ts,",70.0,0.0759101867675781,Greedy
1051,"static av_cold int svq1_encode_init(AVCodecContext *avctx)

{

    SVQ1Context * const s = avctx->priv_data;



    dsputil_init(&s->dsp, avctx);

    avctx->coded_frame= (AVFrame*)&s->picture;



    s->frame_width = avctx->width;

    s->frame_height = avctx->height;



    s->y_block_width = (s->frame_width + 15) / 16;

    s->y_block_height = (s->frame_height + 15) / 16;



    s->c_block_width = (s->frame_width / 4 + 15) / 16;

    s->c_block_height = (s->frame_height / 4 + 15) / 16;



    s->avctx= avctx;

    s->m.avctx= avctx;


    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));

    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));

    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));

    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));

    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));

    h263_encode_init(&s->m); //mv_penalty



    return 0;

}","static av_cold int svq1_encode_init(AVCodecContext *avercontext)

{

    SVQ1Context * const l = avercontext->priv_data;



    dsputil_init(&l->dsp, avercontext);

    avercontext->coded_frame= (AVFrame*)&l->picture;



    l->frame_width = avercontext->width;

    l->frame_height = avercontext->height;



    l->y_block_width = (l->frame_width + 15) / 16;

    l->y_block_height = (l->frame_height + 15) / 16;



    l->c_block_width = (l->frame_width / 4 + 15) / 16;

    l->c_block_height = (l->frame_height / 4 + 15) / 16;



    l->avercontext= avercontext;

    l->m.avercontext= avercontext;


    l->m.me.scratchpad= av_mallocz((avercontext->width+64)*2*16*2*sizeof(uint8_t));

    l->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));

    l->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));

    l->mb_type        = av_mallocz((l->y_block_width+1)*l->y_block_height*sizeof(int16_t));

    l->dummy          = av_mallocz((l->y_block_width+1)*l->y_block_height*sizeof(int32_t));

    h263_encode_init(&l->m); //mv_penalty



    return 0;

}",258.0,45.0,"avctx:avercontext,s:l,",210.0,0.2398096839586893,Greedy
1055,"static void csrhci_reset(struct csrhci_s *s)

{

    s->out_len = 0;

    s->out_size = FIFO_LEN;

    s->in_len = 0;

    s->baud_delay = NANOSECONDS_PER_SECOND;

    s->enable = 0;

    s->in_hdr = INT_MAX;

    s->in_data = INT_MAX;



    s->modem_state = 0;

    /* After a while... (but sooner than 10ms) */

    s->modem_state |= CHR_TIOCM_CTS;



    memset(&s->bd_addr, 0, sizeof(bdaddr_t));

}
","static void csrhci_reset(struct csrhci_s *features)

{

    features->out_len = 0;

    features->out_size = FIFO_LEN;

    features->in_len = 0;

    features->baud_delay = NANOSECONDS_PER_SECOND;

    features->enable = 0;

    features->in_hdr = INT_MAX;

    features->in_data = INT_MAX;



    features->modem_state = 0;

    /* After a while... (but sooner than 10ms) */

    features->modem_state |= CHR_TIOCM_CTS;



    memset(&features->bd_addr, 0, sizeof(bdaddr_t));

}
",80.0,19.0,"s:features,",71.0,0.0642292539278666,Greedy
1058,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += series[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *value = 0;

        return -1;

    } else if (bits == 0) {

        *value = 0;

        return 0;

    }



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;



    *value = val - 1;



    return 0;

}
","static int lag_decode_prob(GetBitContext *gb, uint32_t *Value)

{

    static const uint8_t pins[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += pins[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *Value = 0;

        return -1;

    } else if (bits == 0) {

        *Value = 0;

        return 0;

    }



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;



    *Value = val - 1;



    return 0;

}
",171.0,38.0,"series:pins,value:Value,",119.0,0.0957120140393575,Greedy
1060,"static void test_validate_fail_union_flat(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefFlatUnion *tmp = NULL;

    Error *errp = NULL;

    Visitor *v;



    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");



    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefFlatUnion(tmp);

}
","static void test_validate_fail_union_flat(TestInputVisitorData *reader,

                                          const void *unused)

{

    UserDefFlatUnion *tmp = NULL;

    Error *errp = NULL;

    Visitor *v;



    v = validate_test_init(reader, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");



    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefFlatUnion(tmp);

}
",68.0,18.0,"data:reader,",57.0,0.0600364406903584,Greedy
1063,"static void unix_wait_for_connect(int fd, Error *err, void *opaque)

{

    MigrationState *s = opaque;



    if (fd < 0) {

        DPRINTF(""migrate connect error: %s\n"", error_get_pretty(err));

        s->file = NULL;

        migrate_fd_error(s);

    } else {

        DPRINTF(""migrate connect success\n"");

        s->file = qemu_fopen_socket(fd, ""wb"");

        migrate_fd_connect(s);

    }

}
","static void unix_wait_for_connect(int timeout, Error *error, void *boque)

{

    MigrationState *s = boque;



    if (timeout < 0) {

        DPRINTF(""migrate connect error: %s\n"", error_get_pretty(error));

        s->file = NULL;

        migrate_fd_error(s);

    } else {

        DPRINTF(""migrate connect success\n"");

        s->file = qemu_fopen_socket(timeout, ""wb"");

        migrate_fd_connect(s);

    }

}
",81.0,19.0,"opaque:boque,err:error,fd:timeout,",135.0,0.101043959458669,Greedy
1068,"static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(n);

    NetClientState *nc = qemu_get_queue(n->nic);

    int queues = n->multiqueue ? n->max_queues : 1;



    if (!get_vhost_net(nc->peer)) {

        return;

    }



    if (!!n->vhost_started ==

        (virtio_net_started(n, status) && !nc->peer->link_down)) {

        return;

    }

    if (!n->vhost_started) {

        int r;

        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {

            return;

        }

        n->vhost_started = 1;

        r = vhost_net_start(vdev, n->nic->ncs, queues);

        if (r < 0) {

            error_report(""unable to start vhost net: %d: ""

                         ""falling back on userspace virtio"", -r);

            n->vhost_started = 0;

        }

    } else {

        vhost_net_stop(vdev, n->nic->ncs, queues);

        n->vhost_started = 0;

    }

}
","static void virtio_net_vhost_status(VirtIONet *sn, uint8_t status)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(sn);

    NetClientState *c = qemu_get_queue(sn->nic);

    int queues = sn->multiqueue ? sn->max_queues : 1;



    if (!get_vhost_net(c->peer)) {

        return;

    }



    if (!!sn->vhost_started ==

        (virtio_net_started(sn, status) && !c->peer->link_down)) {

        return;

    }

    if (!sn->vhost_started) {

        int rar;

        if (!vhost_net_query(get_vhost_net(c->peer), vdev)) {

            return;

        }

        sn->vhost_started = 1;

        rar = vhost_net_start(vdev, sn->nic->ncs, queues);

        if (rar < 0) {

            error_report(""unable to start vhost net: %d: ""

                         ""falling back on userspace virtio"", -rar);

            sn->vhost_started = 0;

        }

    } else {

        vhost_net_stop(vdev, sn->nic->ncs, queues);

        sn->vhost_started = 0;

    }

}
",187.0,40.0,"n:sn,r:rar,nc:c,",191.0,0.1838930249214172,Greedy
1069,"static void spapr_cpu_core_host_initfn(Object *obj)

{

    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);

    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *oc = object_class_by_name(name);



    g_assert(oc);

    g_free((void *)name);

    core->cpu_class = oc;

}
","static void spapr_cpu_core_host_initfn(Object *obj)

{

    sPAPRCPUCore *cpu = SPAPR_CPU_CORE(obj);

    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *oc = object_class_by_name(name);



    g_assert(oc);

    g_free((void *)name);

    cpu->cpu_class = oc;

}
",62.0,17.0,"core:cpu,",54.0,0.0535883784294128,Greedy
1071,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))

{

    unsigned int i;



    for (i = 0; m68k_cpu_defs[i].name; i++) {

        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);

    }

}
","void m68k_cpu_list(FILE *d, int (*cpu_forwrite)(FILE *d, const char *fmt, ...))

{

    unsigned int init;



    for (init = 0; m68k_cpu_defs[init].name; init++) {

        (*cpu_forwrite)(d, ""%s\n"", m68k_cpu_defs[init].name);

    }

}
",68.0,14.0,"cpu_fprintf:cpu_forwrite,i:init,f:d,",139.0,0.1329609076182047,Greedy
1072,"int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,

                              PCIHotplugState state)

{

    int slot = PCI_SLOT(dev->devfn);

    int bsel = acpi_pcihp_get_bsel(dev->bus);

    if (bsel < 0) {

        return -1;

    }



    /* Don't send event when device is enabled during qemu machine creation:

     * it is present on boot, no hotplug event is necessary. We do send an

     * event when the device is disabled later. */

    if (state == PCI_COLDPLUG_ENABLED) {

        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

        return 0;

    }



    if (state == PCI_HOTPLUG_ENABLED) {

        enable_device(s, bsel, slot);

    } else {

        disable_device(s, bsel, slot);

    }



    return 0;

}
","int acpi_pcihp_device_hotplug(AcpiPciHpState *b, PCIDevice *dev,

                              PCIHotplugState ace)

{

    int slot = PCI_SLOT(dev->devfn);

    int bsel = acpi_pcihp_get_bsel(dev->bus);

    if (bsel < 0) {

        return -1;

    }



    /* Don't send event when device is enabled during qemu machine creation:

     * it is present on boot, no hotplug event is necessary. We do send an

     * event when the device is disabled later. */

    if (ace == PCI_COLDPLUG_ENABLED) {

        b->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

        return 0;

    }



    if (ace == PCI_HOTPLUG_ENABLED) {

        enable_device(b, bsel, slot);

    } else {

        disable_device(b, bsel, slot);

    }



    return 0;

}
",105.0,26.0,"s:b,state:ace,",119.0,0.1145536700884501,Greedy
1089,"static void get_sensor_evt_enable(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);

}
","static void get_sensor_evt_enable(IPMIBmcSim *ipS,

                                  uint8_t *command, unsigned int  cmdsLen,

                                  uint8_t * rp, unsigned int *rsp_Len,

                                  unsigned int max_rsc_val)

{

    IPMISensor *gractor;



    IPMI_CHECK_CMD_LEN(3);

    if ((command[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ipS->sensors + command[2])) {

         rp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sensgractorpS->sensors + command[2];

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(gractor));

    IPMI_ADD_RSP_DATA(gractor->assert_enable & 0xff);

    IPMI_ADD_RSP_DATA((gractor->assert_enable >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(gractor->deassert_enable & 0xff);

    IPMI_ADD_RSP_DATA((gractor->deassert_enable >> 8) & 0xff);

}
",138.0,30.0,"ibs:ipS,cmd:command,cmd_len: cmdsLen,rsp: rp,rsp_len:rsp_Len,max_rsp_len:max_rsc_val,sens:gractor,",423.0,0.4913622577985128,GA
1097,"static av_cold void init_atrac3_transforms(ATRAC3Context *q) {

    float enc_window[256];

    int i;



    /* Generate the mdct window, for details see

     * http://wiki.multimedia.cx/index.php?title=RealAudio_atrc#Windows */

    for (i=0 ; i<256; i++)

        enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;



    if (!mdct_window[0])

        for (i=0 ; i<256; i++) {

            mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]);

            mdct_window[511-i] = mdct_window[i];

        }



    /* Initialize the MDCT transform. */

    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);

}
","static av_cold void init_atrac3_transforms(ATRAC3Context *lib) {

    float enc67flow[256];

    int ui;



    /* Generate the mdct window, for details see

     * http://wiki.multimedia.cx/index.php?title=RealAudio_atrc#Windows */

    for (ui=0 ; ui<256; ui++)

        enc67flow[ui] = (sin(((ui + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;



    if (!mdct_window[0])

        for (ui=0 ; ui<256; ui++) {

            mdct_window[ui] = enc67flow[ui]/(enc67flow[ui]*enc67flow[ui] + enc67flow[255-ui]*enc67flow[255-ui]);

            mdct_window[511-ui] = mdct_window[ui];

        }



    /* Initialize the MDCT transform. */

    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);

}
",144.0,35.0,"q:lib,enc_window:enc67flow,i:ui,",146.0,0.1320268352826436,Greedy
1099,"void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)

{

    LM32JuartState *s = LM32_JUART(d);

    unsigned char ch = jtx & 0xff;



    trace_lm32_juart_set_jtx(s->jtx);



    s->jtx = jtx;

    if (s->chr) {



        qemu_chr_fe_write_all(s->chr, &ch, 1);

    }

}","void lm32_juart_set_jtx(DeviceState *gd, uint32_t jobctx)

{

    LM32JuartState *is = LM32_JUART(gd);

    unsigned char ch = jobctx & 0xff;



    trace_lm32_juart_set_jtx(is->jobctx);



    is->jobctx = jobctx;

    if (is->chr) {



        qemu_chr_fe_write_all(is->chr, &ch, 1);

    }

}",62.0,16.0,"jtx:jobctx,d:gd,s:is,",162.0,0.1373581965764363,Greedy
1114,"envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *tmpenv, *envvar;

	char *envsave = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.

	 */

	if ((tmpenv = strdup(env)) == NULL)

		return (errno);



	envvar = strtok_r(tmpenv, "","", &envsave);

	while (envvar != NULL) {

		if ((*callback)(envlist, envvar) != 0) {

			free(tmpenv);

			return (errno);

		}

		envvar = strtok_r(NULL, "","", &envsave);

	}



	free(tmpenv);

	return (0);

}
","envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *testconfig, *environmentbar;

	char *enversaving = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.

	 */

	if ((testconfig = strdup(env)) == NULL)

		return (errno);



	environmentbar = strtok_r(testconfig, "","", &enversaving);

	while (environmentbar != NULL) {

		if ((*callback)(envlist, environmentbar) != 0) {

			free(testconfig);

			return (errno);

		}

		environmentbar = strtok_r(NULL, "","", &enversaving);

	}



	free(testconfig);

	return (0);

}
",154.0,40.0,"envsave:enversaving,envvar:environmentbar,tmpenv:testconfig,",152.0,0.1594245354334513,Greedy
1116,"static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)

{

    if (err != CUDA_SUCCESS) {

        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);

        return 0;

    }

    return 1;

}
","static av_cold int check_cuda_errors(AVCodecContext *AVcit, CUresult err, const char *func)

{

    if (err != CUDA_SUCCESS) {

        av_log(AVcit, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);

        return 0;

    }

    return 1;

}
",48.0,12.0,"avctx:AVcit,",37.0,0.0458706935246785,Greedy
1119,"static void gen_neon_trn_u16(TCGv t0, TCGv t1)

{

    TCGv rd, tmp;



    rd = new_tmp();

    tmp = new_tmp();



    tcg_gen_shli_i32(rd, t0, 16);

    tcg_gen_andi_i32(tmp, t1, 0xffff);

    tcg_gen_or_i32(rd, rd, tmp);

    tcg_gen_shri_i32(t1, t1, 16);

    tcg_gen_andi_i32(tmp, t0, 0xffff0000);

    tcg_gen_or_i32(t1, t1, tmp);

    tcg_gen_mov_i32(t0, rd);



    dead_tmp(tmp);

    dead_tmp(rd);

}
","static void gen_neon_trn_u16(TCGv pt2, TCGv f12)

{

    TCGv rd, rw;



    rd = new_tmp();

    rw = new_tmp();



    tcg_gen_shli_i32(rd, pt2, 16);

    tcg_gen_andi_i32(rw, f12, 0xffff);

    tcg_gen_or_i32(rd, rd, rw);

    tcg_gen_shri_i32(f12, f12, 16);

    tcg_gen_andi_i32(rw, pt2, 0xffff0000);

    tcg_gen_or_i32(f12, f12, rw);

    tcg_gen_mov_i32(pt2, rd);



    dead_tmp(rw);

    dead_tmp(rd);

}
",100.0,36.0,"t0:pt2,t1:f12,tmp:rw,",159.0,0.130668302377065,Greedy
1131,"int ff_thread_init(AVCodecContext *avctx)

{

    if (avctx->thread_opaque) {

        av_log(avctx, AV_LOG_ERROR, ""avcodec_thread_init is ignored after avcodec_open\n"");

        return -1;

    }



#if HAVE_W32THREADS

    w32thread_init();

#endif



    if (avctx->codec) {

        validate_thread_parameters(avctx);



        if (avctx->active_thread_type&FF_THREAD_SLICE)

            return thread_init(avctx);

        else if (avctx->active_thread_type&FF_THREAD_FRAME)

            return frame_thread_init(avctx);

    }



    return 0;

}
","int ff_thread_init(AVCodecContext *AVconn)

{

    if (AVconn->thread_opaque) {

        av_log(AVconn, AV_LOG_ERROR, ""avcodec_thread_init is ignored after avcodec_open\n"");

        return -1;

    }



#if HAVE_W32THREADS

    w32thread_init();

#endif



    if (AVconn->codec) {

        validate_thread_parameters(AVconn);



        if (AVconn->active_thread_type&FF_THREAD_SLICE)

            return thread_init(AVconn);

        else if (AVconn->active_thread_type&FF_THREAD_FRAME)

            return frame_thread_init(AVconn);

    }



    return 0;

}
",84.0,19.0,"avctx:AVconn,",90.0,0.0925155361493428,Greedy
1132,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)

{

    if (memory_region_is_ram(mr)) {

        return !(is_write && mr->readonly);

    }

    if (memory_region_is_romd(mr)) {

        return !is_write;

    }



    return false;

}
","static inline bool memory_access_is_direct(MemoryRegion *r, bool  is_read)

{

    if (memory_region_is_ram(r)) {

        return ! is_reade && r->readonly);

    }

    if (memory_region_is_romd(r)) {

        return ! is_read;

    }



    return false;

}
",49.0,10.0,"mr:r,is_write: is_read,",202.0,0.1832943320274353,GA
1135,"static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,

                             uint64_t value)

{

    if (ri->crm > 8) {

        return EXCP_UDEF;

    }

    env->cp15.c6_region[ri->crm] = value;

    return 0;

}
","static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,

                             uint64_t area)

{

    if (ri->crm > 8) {

        return EXCP_UDEF;

    }

    env->cp15.c6_region[ri->crm] = area;

    return 0;

}
",47.0,9.0,"value:area,",47.0,0.050778043270111,Greedy
1137,"static int esp_pci_scsi_init(PCIDevice *dev)

{

    PCIESPState *pci = PCI_ESP(dev);

    DeviceState *d = DEVICE(dev);

    ESPState *s = &pci->esp;

    uint8_t *pci_conf;

    Error *err = NULL;



    pci_conf = dev->config;



    /* Interrupt pin A */

    pci_conf[PCI_INTERRUPT_PIN] = 0x01;



    s->dma_memory_read = esp_pci_dma_memory_read;

    s->dma_memory_write = esp_pci_dma_memory_write;

    s->dma_opaque = pci;

    s->chip_id = TCHI_AM53C974;

    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,

                          ""esp-io"", 0x80);



    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);

    s->irq = pci_allocate_irq(dev);



    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);

    if (!d->hotplugged) {

        scsi_bus_legacy_handle_cmdline(&s->bus, &err);

        if (err != NULL) {


            error_free(err);

            return -1;

        }

    }

    return 0;

}","static int esp_pci_scsi_init(PCIDevice *conf)

{

    PCIESPState *pci = PCI_ESP(conf);

    DeviceState *data = DEVICE(conf);

    ESPState *s = &pci->esp;

    uint8_t *pci_conf;

    Error *err = NULL;



    pci_conf = conf->config;



    /* Interrupt pin A */

    pci_conf[PCI_INTERRUPT_PIN] = 0x01;



    s->dma_memory_read = esp_pci_dma_memory_read;

    s->dma_memory_write = esp_pci_dma_memory_write;

    s->dma_opaque = pci;

    s->chip_id = TCHI_AM53C974;

    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,

                          ""esp-io"", 0x80);



    pci_register_bar(conf, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);

    s->irq = pci_allocate_irq(conf);



    scsi_bus_new(&s->bus, sizeof(s->bus), data, &esp_pci_scsi_info, NULL);

    if (!data->hotplugged) {

        scsi_bus_legacy_handle_cmdline(&s->bus, &err);

        if (err != NULL) {


            error_free(err);

            return -1;

        }

    }

    return 0;

}",191.0,49.0,"d:data,dev:conf,",133.0,0.1220141013463338,Greedy
1159,"static void piix3_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    dc->desc        = ""ISA bridge"";

    dc->vmsd        = &vmstate_piix3;

    dc->no_user     = 1,

    k->no_hotplug   = 1;

    k->init         = piix3_initfn;

    k->config_write = piix3_write_config;

    k->vendor_id    = PCI_VENDOR_ID_INTEL;

    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */

    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;

    k->class_id     = PCI_CLASS_BRIDGE_ISA;

}
","static void piix3_class_init(ObjectClass *Klass, void *raw)

{

    DeviceClass *dk = DEVICE_CLASS(Klass);

    PCIDeviceClass *uk = PCI_DEVICE_CLASS(Klass);



    dk->desc        = ""ISA bridge"";

    dk->vmsd        = &vmstate_piix3;

    dk->no_user     = 1,

    uk->no_hotplug   = 1;

    uk->init         = piix3_initfn;

    uk->config_write = piix3_write_config;

    uk->vendor_id    = PCI_VENDOR_ID_INTEL;

    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */

    uk->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;

    uk->class_id     = PCI_CLASS_BRIDGE_ISA;

}
",88.0,24.0,"klass:Klass,data:raw,k:uk,dc:dk,",164.0,0.180105185508728,Greedy
1162,"static int vmdk_parent_open(BlockDriverState *bs)

{

    char *p_name;

    char desc[DESC_SIZE + 1];

    BDRVVmdkState *s = bs->opaque;



    desc[DESC_SIZE] = '\0';

    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {

        return -1;

    }



    if ((p_name = strstr(desc,""parentFileNameHint"")) != NULL) {

        char *end_name;



        p_name += sizeof(""parentFileNameHint"") + 1;

        if ((end_name = strchr(p_name,'\""')) == NULL)

            return -1;

        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)

            return -1;



        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);

    }



    return 0;

}
","static int vmdk_parent_open(BlockDriverState *bs)

{

    char * powsession;

    char desc[DESC_SIZE + 1];

    BDRVVmdkState *s = bs->opaque;



    desc[DESC_SIZE] = '\0';

    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {

        return -1;

    }



    if (( powsession = strstr(desc,""parentFileNameHint"")) != NULL) {

        char *end_name;



         powsession += sizeof(""parentFileNameHint"") + 1;

        if ((end_name = strchr( powsession,'\""')) == NULL)

            return -1;

        if ((end_name -  powsession) > sizeof (bs->backing_file) - 1)

            return -1;



        pstrcpy(bs->backing_file, end_name -  powsession + 1,  powsession);

    }



    return 0;

}
",153.0,31.0,"p_name: powsession,",98.0,0.1119721174240112,Greedy
1170,"void scsi_req_cancel(SCSIRequest *req)

{

    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);

    if (!req->enqueued) {

        return;

    }



    scsi_req_ref(req);

    scsi_req_dequeue(req);

    req->io_canceled = true;

    if (req->aiocb) {

        blk_aio_cancel(req->aiocb);

    } else {

        scsi_req_cancel_complete(req);

    }

}","void scsi_req_cancel(SCSIRequest *conf)

{

    trace_scsi_req_cancel(conf->dev->id, conf->lun, conf->tag);

    if (!conf->enqueued) {

        return;

    }



    scsi_req_ref(conf);

    scsi_req_dequeue(conf);

    conf->io_canceled = true;

    if (conf->aiocb) {

        blk_aio_cancel(conf->aiocb);

    } else {

        scsi_req_cancel_complete(conf);

    }

}",76.0,17.0,"req:conf,",83.0,0.0843908111254374,Greedy
1171,"static void gen_exception_return(DisasContext *s, TCGv_i32 pc)

{

    TCGv_i32 tmp;

    store_reg(s, 15, pc);

    tmp = load_cpu_field(spsr);

    gen_set_cpsr(tmp, CPSR_ERET_MASK);

    tcg_temp_free_i32(tmp);

    s->is_jmp = DISAS_UPDATE;

}
","static void gen_exception_return(DisasContext *services, TCGv_i32 api)

{

    TCGv_i32 tmp;

    store_reg(services, 15, api);

    tmp = load_cpu_field(spsr);

    gen_set_cpsr(tmp, CPSR_ERET_MASK);

    tcg_temp_free_i32(tmp);

    services->is_jmp = DISAS_UPDATE;

}
",50.0,17.0,"pc:api,s:services,",97.0,0.0866772373517354,Greedy
1175,"static void win32_rearm_timer(struct qemu_alarm_timer *t)

{

    struct qemu_alarm_win32 *data = t->priv;

    uint64_t nearest_delta_us;



    if (!active_timers[QEMU_TIMER_REALTIME] &&

                !active_timers[QEMU_TIMER_VIRTUAL])

        return;



    nearest_delta_us = qemu_next_deadline_dyntick();

    nearest_delta_us /= 1000;



    timeKillEvent(data->timerId);



    data->timerId = timeSetEvent(1,

                        data->period,

                        host_alarm_handler,

                        (DWORD)t,

                        TIME_ONESHOT | TIME_PERIODIC);



    if (!data->timerId) {

        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",

                GetLastError());



        timeEndPeriod(data->period);

        exit(1);

    }

}
","static void win32_rearm_timer(struct qemu_alarm_timer *t)

{

    struct qemu_alarm_win32 *session = t->priv;

    uint64_t nearest_delta_us;



    if (!active_timers[QEMU_TIMER_REALTIME] &&

                !active_timers[QEMU_TIMER_VIRTUAL])

        return;



    nearest_delta_us = qemu_next_deadline_dyntick();

    nearest_delta_us /= 1000;



    timeKillEvent(session->timerId);



    session->timerId = timeSetEvent(1,

                        session->period,

                        host_alarm_handler,

                        (DWORD)t,

                        TIME_ONESHOT | TIME_PERIODIC);



    if (!session->timerId) {

        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",

                GetLastError());



        timeEndPeriod(session->period);

        exit(1);

    }

}
",114.0,28.0,"data:session,",83.0,0.0693883458773295,Greedy
1176,"static void qapi_dealloc_end_struct(Visitor *v, Error **errp)

{

    QapiDeallocVisitor *qov = to_qov(v);

    void **obj = qapi_dealloc_pop(qov);

    if (obj) {

        g_free(*obj);

    }

}
","static void qapi_dealloc_end_struct(Visitor *version, Error **erpc)

{

    QapiDeallocVisitor *qov = to_qov(version);

    void **obj = qapi_dealloc_pop(qov);

    if (obj) {

        g_free(*obj);

    }

}
",46.0,12.0,"v:version,errp:erpc,",60.0,0.0643749157587687,Greedy
1178,"static void set_int8(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *local_err = NULL;

    int64_t value;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_int(v, &value, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (value > prop->info->min && value <= prop->info->max) {

        *ptr = value;

    } else {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", name, value, prop->info->min,

                  prop->info->max);

    }

}
","static void set_int8(Object *Obj, Visitor *volt, void *opusacity,

                     const char *address, Error **errp)

{

    DeviceState *dev = DEVICE(Obj);

    Property *prop = opusacity;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *local_err = NULL;

    int64_t value;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_int(volt, &value, address, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (value > prop->info->min && value <= prop->info->max) {

        *ptr = value;

    } else {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", address, value, prop->info->min,

                  prop->info->max);

    }

}
",170.0,46.0,"v:volt,obj:Obj,name:address,opaque:opusacity,",182.0,0.1833818793296814,Greedy
1189,"const char *object_get_typename(Object *obj)

{

    return obj->class->type->name;

}
","const char *object_get_typename(Object *args)

{

    return args->class->type->name;

}
",20.0,3.0,"obj:args,",45.0,0.0480120301246643,Greedy
1192,"static int ram_init1(SysBusDevice *dev)

{

    RamDevice *d = SUN4U_RAM(dev);



    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,

                           &error_abort);

    vmstate_register_ram_global(&d->ram);

    sysbus_init_mmio(dev, &d->ram);

    return 0;

}
","static int ram_init1(SysBusDevice *ver)

{

    RamDevice *data = SUN4U_RAM(ver);



    memory_region_init_ram(&data->ram, OBJECT(data), ""sun4u.ram"", data->size,

                           &error_abort);

    vmstate_register_ram_global(&data->ram);

    sysbus_init_mmio(ver, &data->ram);

    return 0;

}
",63.0,16.0,"dev:ver,d:data,",102.0,0.0875160336494445,Greedy
1193,"static void stop_tco(const TestData *d)

{

    uint32_t val;



    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);

    val |= TCO_TMR_HLT;

    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);

}
","static void stop_tco(const TestData *data)

{

    uint32_t vel;



    vel = qpci_io_readw(data->dev, data->tco_io_base + TCO1_CNT);

    vel |= TCO_TMR_HLT;

    qpci_io_writew(data->dev, data->tco_io_base + TCO1_CNT, vel);

}
",48.0,15.0,"val:vel,d:data,",110.0,0.0847765247027079,Greedy
1194,"void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}
","void qemu_put_be32(QEMUFile *l, unsigned int video)

{

    qemu_put_byte(l, video >> 24);

    qemu_put_byte(l, video >> 16);

    qemu_put_byte(l, video >> 8);

    qemu_put_byte(l, video);

}
",47.0,15.0,"v:video,f:l,",102.0,0.0898548722267151,Greedy
1195,"static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)

{

    int i, len, sz;

    GetBitContext gb;

    int code_table[64];



    /* get the rle codes (at most 64 bytes) */

    init_get_bits(&gb, src, 64 * 8);

    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {

        code_table[i] = get_sbits(&gb, 4);

        sz += FFABS(code_table[i]);

    }

    src += (get_bits_count(&gb) + 7) / 8;



    /* do the rle unpacking */

    for (i = 0; i < 64 && dst_size > 0; i++) {

        len = code_table[i];

        if (len < 0) {

            len = -len;

            memset(dst, *src++, FFMIN(len, dst_size));

        } else {

            memcpy(dst, src, FFMIN(len, dst_size));

            src += len;

        }

        dst += len;

        dst_size -= len;

    }

    return src;

}
","static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dsc_time)

{

    int i, len, sz;

    GetBitContext gb;

    int data_binary[64];



    /* get the rle codes (at most 64 bytes) */

    init_get_bits(&gb, src, 64 * 8);

    for (i = 0, sz = 0; i < 64 && sz < dsc_time; i++) {

        data_binary[i] = get_sbits(&gb, 4);

        sz += FFABS(data_binary[i]);

    }

    src += (get_bits_count(&gb) + 7) / 8;



    /* do the rle unpacking */

    for (i = 0; i < 64 && dsc_time > 0; i++) {

        len = data_binary[i];

        if (len < 0) {

            len = -len;

            memset(dst, *src++, FFMIN(len, dsc_time));

        } else {

            memcpy(dst, src, FFMIN(len, dsc_time));

            src += len;

        }

        dst += len;

        dsc_time -= len;

    }

    return src;

}
",198.0,58.0,"code_table:data_binary,dst_size:dsc_time,",123.0,0.1061781803766886,Greedy
1203,"static int idcin_decode_init(AVCodecContext *avctx)

{

    IdcinContext *s = avctx->priv_data;

    int i, j, histogram_index = 0;

    unsigned char *histograms;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    dsputil_init(&s->dsp, avctx);



    /* make sure the Huffman tables make it */

    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);

        return -1;

    }



    /* build the 256 Huffman decode trees */

    histograms = (unsigned char *)s->avctx->extradata;

    for (i = 0; i < 256; i++) {

        for(j = 0; j < HUF_TOKENS; j++)

            s->huff_nodes[i][j].count = histograms[histogram_index++];

        huff_build_tree(s, i);

    }



    s->frame.data[0] = NULL;



    return 0;

}
","static int idcin_decode_init(AVCodecContext *AVconfig)

{

    IdcinContext *s = AVconfig->priv_data;

    int i, j, histogram_index = 0;

    unsigned char *histograms;



    s->AVconfig = AVconfig;

    AVconfig->pix_fmt = PIX_FMT_PAL8;

    dsputil_init(&s->dsp, AVconfig);



    /* make sure the Huffman tables make it */

    if (s->AVconfig->extradata_size != HUFFMAN_TABLE_SIZE) {

        av_log(s->AVconfig, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);

        return -1;

    }



    /* build the 256 Huffman decode trees */

    histograms = (unsigned char *)s->AVconfig->extradata;

    for (i = 0; i < 256; i++) {

        for(j = 0; j < HUF_TOKENS; j++)

            s->huff_nodes[i][j].count = histograms[histogram_index++];

        huff_build_tree(s, i);

    }



    s->frame.data[0] = NULL;



    return 0;

}
",164.0,39.0,"avctx:AVconfig,",103.0,0.1015576958656311,Greedy
1205,"static RAMBlock *qemu_get_ram_block(ram_addr_t addr)

{

    RAMBlock *block;



    /* The list is protected by the iothread lock here.  */

    block = ram_list.mru_block;

    if (block && addr - block->offset < block->max_length) {

        goto found;

    }

    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        if (addr - block->offset < block->max_length) {

            goto found;

        }

    }



    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);

    abort();



found:

    ram_list.mru_block = block;

    return block;

}
","static RAMBlock *qemu_get_ram_block(ram_addr_t docker)

{

    RAMBlock *lock;



    /* The list is protected by the iothread lock here.  */

    lock = ram_list.mru_block;

    if (lock && docker - lock->offset < lock->max_length) {

        goto found;

    }

    QTAILQ_FOREACH(lock, &ram_list.blocks, next) {

        if (docker - lock->offset < lock->max_length) {

            goto found;

        }

    }



    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)docker);

    abort();



found:

    ram_list.mru_block = lock;

    return lock;

}
",102.0,24.0,"block:lock,addr:docker,",169.0,0.1289437969525655,Greedy
1206,"static int usbnet_can_receive(VLANClientState *nc)

{

    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;



    if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED)

        return 1;



    return !s->in_len;

}
","static int usbnet_can_receive(VLANClientState *nc)

{

    USBNetState *secondary = DO_UPCAST(NICState, nc, nc)->opaque;



    if (secondary->rndis && !secondary->rndis_state == RNDIS_DATA_INITIALIZED)

        return 1;



    return !secondary->in_len;

}
",47.0,11.0,"s:secondary,",63.0,0.0409835537274678,Greedy
1215,"static void virtio_notify(struct subchannel_id schid)

{

    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);

}
","static void virtio_notify(struct subchannel_id SchID)

{

    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&SchID, 0);

}
",25.0,5.0,"schid:SchID,",30.0,0.0271431605021158,Greedy
1216,"static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)

{

    struct kvm_x86_mce mce = {

        .bank = 9,

        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN

                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S

                  | 0xc0,

        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,

        .addr = paddr,

        .misc = (MCM_ADDR_PHYS << 6) | 0xc,

    };



    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);

    kvm_mce_broadcast_rest(env);

}
","static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t lpager)

{

    struct kvm_x86_mce mce = {

        .bank = 9,

        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN

                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S

                  | 0xc0,

        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,

        .addr = lpager,

        .misc = (MCM_ADDR_PHYS << 6) | 0xc,

    };



    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);

    kvm_mce_broadcast_rest(env);

}
",80.0,20.0,"paddr:lpager,",30.0,0.0319366017977396,Greedy
1219,"static QObject *parse_keyword(JSONParserContext *ctxt, QList **tokens)

{

    QObject *token, *ret;

    QList *working = qlist_copy(*tokens);



    token = qlist_pop(working);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));

    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    qobject_decref(token);

    QDECREF(*tokens);

    *tokens = working;



    return ret;



out: 

    qobject_decref(token);

    QDECREF(working);



    return NULL;

}
","static QObject *parse_keyword(JSONParserContext *ctxt, QList **tokens)

{

    QObject *cookie, *tmp;

    QList *wrong = qlist_copy(*tokens);



    cookie = qlist_pop(wrong);

    if (cookie == NULL) {

        goto out;

    }



    if (token_get_type(cookie) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(cookie, ""true"")) {

        tmp = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(cookie, ""false"")) {

        tmp = QOBJECT(qbool_from_int(false));

    } else {

        parse_error(ctxt, cookie, ""invalid keyword `%s'"", token_get_value(cookie));

        goto out;

    }



    qobject_decref(cookie);

    QDECREF(*tokens);

    *tokens = wrong;



    return tmp;



out: 

    qobject_decref(cookie);

    QDECREF(wrong);



    return NULL;

}
",165.0,41.0,"token:cookie,ret:tmp,working:wrong,",212.0,0.1435208797454834,Greedy
1229,"static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,

    bool is_read)

{

    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);

    VirtIOBlock *s = req->dev;



    if (action == BLOCK_ERROR_ACTION_STOP) {

        req->next = s->rq;

        s->rq = req;

    } else if (action == BLOCK_ERROR_ACTION_REPORT) {

        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);

        block_acct_done(bdrv_get_stats(s->bs), &req->acct);

        virtio_blk_free_request(req);

    }



    bdrv_error_action(s->bs, action, is_read, error);

    return action != BLOCK_ERROR_ACTION_IGNORE;

}
","static int virtio_blk_handle_rw_error(VirtIOBlockReq *dev, int error,

    bool is_read)

{

    BlockErrorAction action = bdrv_get_error_action(dev->dev->bs, is_read, error);

    VirtIOBlock *s = dev->dev;



    if (action == BLOCK_ERROR_ACTION_STOP) {

        dev->next = s->rq;

        s->rq = dev;

    } else if (action == BLOCK_ERROR_ACTION_REPORT) {

        virtio_blk_req_complete(dev, VIRTIO_BLK_S_IOERR);

        block_acct_done(bdrv_get_stats(s->bs), &dev->acct);

        virtio_blk_free_request(dev);

    }



    bdrv_error_action(s->bs, action, is_read, error);

    return action != BLOCK_ERROR_ACTION_IGNORE;

}
",116.0,35.0,"req:dev,",97.0,0.0651705980300903,Greedy
1237,"int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],

                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],

                        int i, int zero_nhood, int16_t qmul[2])

{

    uint8_t *token_prob = probs[i][zero_nhood];

    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB

        return 0;

    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);

}
","int decode_block_coeffs(VP56RangeCoder *c, int16_t channel[16],

                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],

                        int i, int zero_nhood, int16_t qmul[2])

{

    uint8_t *token_prob = probs[i][zero_nhood];

    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB

        return 0;

    return decode_block_coeffs_internal(c, channel, probs, i, token_prob, qmul);

}
",85.0,22.0,"block:channel,",64.0,0.0559876759847005,Greedy
1241,"static void do_info_commands(Monitor *mon, QObject **ret_data)

{

    QList *cmd_list;

    const mon_cmd_t *cmd;



    cmd_list = qlist_new();



    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {

        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&

            !compare_cmd(cmd->name, ""info"")) {

            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));

        }

    }



    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {

        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {

            char buf[128];

            snprintf(buf, sizeof(buf), ""query-%s"", cmd->name);

            qlist_append_obj(cmd_list, get_cmd_dict(buf));

        }

    }



    *ret_data = QOBJECT(cmd_list);

}
","static void do_info_commands(Monitor *mat, QObject ** ret_di)

{

    QList *cmdendata;

    const mon_cmd_t *clean;



    cmdendata = qlist_new();



    for (clean = qmp_cmds; clean->name != NULL; clean++) {

        if (monitor_handler_ported(clean) && !monitor_cmd_user_only(clean) &&

            !compare_cmd(clean->name, ""info"")) {

            qlist_append_obj(cmdendata, get_cmd_dict(clean->name));

        }

    }



    for (clean = qmp_query_cmds; clean->name != NULL; clean++) {

        if (monitor_handler_ported(clean) && !monitor_cmd_user_only(clean)) {

            char code[128];

            snprintf(bucodesizeof(bucode ""query-%s"", clean->name);

            qlist_append_obj(cmdendata, get_cmd_dict(code));

        }

    }



    * ret_di = QOBJECT(cmdendata);

}
",158.0,41.0,"mon:mat,ret_data: ret_di,cmd_list:cmdendata,cmd:clean,buf:code,",484.0,0.5211390177408854,GA
1242,"static void spapr_msi_write(void *opaque, hwaddr addr,

                            uint64_t data, unsigned size)

{

    sPAPRPHBState *phb = opaque;

    int ndev = addr >> 16;

    int vec = ((addr & 0xFFFF) >> 2) | data;

    uint32_t irq = phb->msi_table[ndev].irq + vec;



    trace_spapr_pci_msi_write(addr, data, irq);



    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));

}
","static void spapr_msi_write(void *opaque, hwaddr ord,

                            uint64_t data, unsigned size)

{

    sPAPRPHBState *phb = opaque;

    int ndev = ord >> 16;

    int vec = ((ord & 0xFFFF) >> 2) | data;

    uint32_t irq = phb->msi_table[ndev].irq + vec;



    trace_spapr_pci_msi_write(ord, data, irq);



    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));

}
",82.0,24.0,"addr:ord,",69.0,0.0772248148918151,Greedy
1246,"static int parallel_parse(const char *devname)

{

    static int index = 0;

    char label[32];



    if (strcmp(devname, ""none"") == 0)

        return 0;

    if (index == MAX_PARALLEL_PORTS) {

        fprintf(stderr, ""qemu: too many parallel ports\n"");

        exit(1);

    }

    snprintf(label, sizeof(label), ""parallel%d"", index);

    parallel_hds[index] = qemu_chr_new(label, devname, NULL);

    if (!parallel_hds[index]) {

        fprintf(stderr, ""qemu: could not connect parallel device""

                "" to character backend '%s'\n"", devname);

        return -1;

    }

    index++;

    return 0;

}
","static int parallel_parse(const char *devnames)

{

    static int module = 0;

    char valid[32];



    if (strcmp(devnames, ""none"") == 0)

        return 0;

    if (module == MAX_PARALLEL_PORTS) {

        fprintf(stderr, ""qemu: too many parallel ports
"");

        exit(1);

    }

    snprintf(valid, sizeof(valid), ""parallel%d"", module);

    parallel_hds[imodule = qemu_chr_new(lvalid devnames, NULL);

    if (!parallel_hds[module]) {

        fprintf(stderr, ""qemu: could not connect parallel device""

                "" to character backend '%s'
"", devnames);

        return -1;

    }

    module++;

    return 0;

}
",121.0,26.0,"devname:devnames,label:valid,index:module,",211.0,0.2237091302871704,GA
1249,"void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,

                                     uintptr_t retaddr)

{

    CPUState *cs = CPU(s390_env_get_cpu(env));

    int t;



    cs->exception_index = EXCP_PGM;

    env->int_pgm_code = excp;



    /* Use the (ultimate) callers address to find the insn that trapped.  */

    cpu_restore_state(cs, retaddr);



    /* Advance past the insn.  */

    t = cpu_ldub_code(env, env->psw.addr);

    env->int_pgm_ilen = t = get_ilen(t);

    env->psw.addr += t;



    cpu_loop_exit(cs);

}
","void QEMU_NORETURN runtime_exception(CPUS390XState *dev, int excp,

                                     uintptr_t retaddr)

{

    CPUState *ca = CPU(s390_env_get_cpu(dev));

    int t;



    ca->exception_index = EXCP_PGM;

    dev->int_pgm_code = excp;



    /* Use the (ultimate) callers address to find the insn that trapped.  */

    cpu_restore_state(ca, retaddr);



    /* Advance past the insn.  */

    t = cpu_ldub_code(dev, dev->psw.addr);

    dev->int_pgm_ilen = t = get_ilen(t);

    dev->psw.addr += t;



    cpu_loop_exit(ca);

}
",88.0,29.0,"env:dev,cs:ca,",141.0,0.1206129988034566,Greedy
1250,"static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, rc;



    if (ctx) {

        return 0;

    }

    rc = libusb_init(&ctx);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);

        }

    }

    free(poll);

    return 0;

}
","static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, dc;



    if (ctx) {

        return 0;

    }

    dc = libusb_init(&ctx);

    if (dc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);

        }

    }

    free(poll);

    return 0;

}
",124.0,33.0,"rc:dc,",70.0,0.0749637802441915,Greedy
1253,"bool timer_pending(QEMUTimer *ts)

{

    QEMUTimer *t;

    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {

        if (t == ts) {

            return true;

        }

    }

    return false;

}
","bool timer_pending(QEMUTimer *this)

{

    QEMUTimer *c;

    for (t c this->timer_list->active_timers; c != NULL; c = c->next) {

        if (t c= this) {

            return true;

        }

    }

    return false;

}
",49.0,10.0,"ts:this,t:c,",271.0,0.2617500424385071,GA
1256,"static void tcp_chr_telnet_init(QIOChannel *ioc)

{

    char buf[3];

    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */

    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */

    qio_channel_write(ioc, buf, 3, NULL);

}
","static void tcp_chr_telnet_init(QIOChannel *ioc)

{

    char proc[3];

    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */

    IACSET(proc, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */

    qio_channel_write(ioc, proc, 3, NULL);

    IACSET(proc, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */

    qio_channel_write(ioc, proc, 3, NULL);

    IACSET(proc, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */

    qio_channel_write(ioc, proc, 3, NULL);

    IACSET(proc, 0xff, 0xfd, 0x00);  /* IAC DO Binary */

    qio_channel_write(ioc, proc, 3, NULL);

}
",104.0,23.0,"buf:proc,",86.0,0.083400022983551,Greedy
1258,"static int gdbserver_open(int port)

{

    struct sockaddr_in sockaddr;

    int fd, val, ret;



    fd = socket(PF_INET, SOCK_STREAM, 0);

    if (fd < 0) {

        perror(""socket"");

        return -1;

    }

#ifndef _WIN32

    fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    val = 1;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));



    sockaddr.sin_family = AF_INET;

    sockaddr.sin_port = htons(port);

    sockaddr.sin_addr.s_addr = 0;

    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));

    if (ret < 0) {

        perror(""bind"");


        return -1;

    }

    ret = listen(fd, 0);

    if (ret < 0) {

        perror(""listen"");


        return -1;

    }

    return fd;

}","static int gdbserver_open(int type)

{

    struct sockaddr_in sockaddr;

    int fd, fl, ret;



    fd = socket(PF_INET, SOCK_STREAM, 0);

    if (fd < 0) {

        perror(""socket"");

        return -1;

    }

#ifndef _WIN32

    fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    fl = 1;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&fl, sizeof(fl));



    sockaddr.sin_family = AF_INET;

    sockaddr.sin_port = htons(type);

    sockaddr.sin_addr.s_addr = 0;

    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));

    if (ret < 0) {

        perror(""bind"");


        return -1;

    }

    ret = listen(fd, 0);

    if (ret < 0) {

        perror(""listen"");


        return -1;

    }

    return fd;

}",174.0,43.0,"port:type,val:fl,",112.0,0.1253149668375651,Greedy
1259,"static void spapr_nvram_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);



    k->realize = spapr_nvram_realize;

    k->devnode = spapr_nvram_devnode;

    k->dt_name = ""nvram"";

    k->dt_type = ""nvram"";

    k->dt_compatible = ""qemu,spapr-nvram"";

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->props = spapr_nvram_properties;

    dc->vmsd = &vmstate_spapr_nvram;



}","static void spapr_nvram_class_init(ObjectClass *Klass, void *df)

{

    DeviceClass *desc = DEVICE_CLASS(Klass);

    VIOsPAPRDeviceClass *ijk = VIO_SPAPR_DEVICE_CLASS(Klass);



    ijk->realize = spapr_nvram_realize;

    ijk->devnode = spapr_nvram_devnode;

    ijk->dt_name = ""nvram"";

    ijk->dt_type = ""nvram"";

    ijk->dt_compatible = ""qemu,spapr-nvram"";

    set_bit(DEVICE_CATEGORY_MISC, desc->categories);

    desc->props = spapr_nvram_properties;

    desc->vmsd = &vmstate_spapr_nvram;



}",87.0,23.0,"klass:Klass,data:df,dc:desc,k:ijk,",145.0,0.1643442312876383,Greedy
1271,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *port;

    USBDevice *dev;

    int i, ret;



    for(i = 0; i < NUM_PORTS; i++) {

        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}
","static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *m;

    USBDevice *dev;

    int m, ret;



    for(m = 0; m < NUM_PORTS; m++) {

        m = &s->ports[m];

        dev = m->m.dev;

        if (dev && (m->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}
",97.0,27.0,"i:m,port:m,",140.0,0.1114848653475443,Greedy
1281,"static void test_visitor_out_string(TestOutputVisitorData *data,

                                    const void *unused)

{

    char *string = (char *) ""Q E M U"";

    Error *err = NULL;

    QObject *obj;



    visit_type_str(data->ov, &string, NULL, &err);

    g_assert(!err);



    obj = qmp_output_get_qobject(data->qov);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QSTRING);

    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);



    qobject_decref(obj);

}
","static void test_visitor_out_string(TestOutputVisitorData *db,

                                    const void *UNusing)

{

    char *string = (char *) ""Q E M U"";

    Error *str = NULL;

    QObject *db;



    visit_type_str(db->ov, &string, NULL, &str);

    g_assert(!str);



    db = qmp_output_get_qobject(db->qov);

    g_assert(db != NULL);

    g_assert(qobject_type(db) == QTYPE_QSTRING);

    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(db)), ==, string);



    qobject_decref(db);

}
",104.0,28.0,"data:db,obj:db,err:str,unused:UNusing,",186.0,0.1587084452311198,Greedy
1284,"static int buffer_empty(Buffer *buffer)

{

    return buffer->offset == 0;

}
","static int buffer_empty(Buffer *bridge)

{

    return bridge->offset == 0;

}
",17.0,3.0,"buffer:bridge,",43.0,0.0344774047533671,Greedy
1302,"static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    EEPRO100State *s = opaque;



    switch (size) {

    case 1: return eepro100_read1(s, addr);

    case 2: return eepro100_read2(s, addr);

    case 4: return eepro100_read4(s, addr);

    default: abort();

    }

}
","static uint64_t eepro100_read(void *OPec, target_phys_addr_t host,

                              unsigned size)

{

    EEPRO100State *secondary = OPec;



    switch (size) {

    case 1: return eepro100_read1(secondary, host);

    case 2: return eepro100_read2(secondary, host);

    case 4: return eepro100_read4(secondary, host);

    default: abort();

    }

}
",67.0,17.0,"s:secondary,addr:host,opaque:OPec,",151.0,0.1423340519269307,Greedy
1303,"bool vring_should_notify(VirtIODevice *vdev, Vring *vring)

{

    uint16_t old, new;

    bool v;

    /* Flush out used index updates. This is paired

     * with the barrier that the Guest executes when enabling

     * interrupts. */

    smp_mb();



    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&

        unlikely(!vring_more_avail(vdev, vring))) {

        return true;

    }



    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {

        return !(vring_get_avail_flags(vdev, vring) &

                 VRING_AVAIL_F_NO_INTERRUPT);

    }

    old = vring->signalled_used;

    v = vring->signalled_used_valid;

    new = vring->signalled_used = vring->last_used_idx;

    vring->signalled_used_valid = true;



    if (unlikely(!v)) {

        return true;

    }



    return vring_need_event(vring_used_event(&vring->vr), new, old);

}
","bool vring_should_notify(VirtIODevice *vdev, Vring *brig)

{

    uint16_t old, new;

    bool v;

    /* Flush out used index updates. This is paired

     * with the barrier that the Guest executes when enabling

     * interrupts. */

    smp_mb();



    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&

        unlikely(!vring_more_avail(vdev, brig))) {

        return true;

    }



    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {

        return !(vring_get_avail_flags(vdev, brig) &

                 VRING_AVAIL_F_NO_INTERRUPT);

    }

    old = brig->signalled_used;

    v = brig->signalled_used_valid;

    new = brig->signalled_used = brig->last_used_idx;

    brig->signalled_used_valid = true;



    if (unlikely(!v)) {

        return true;

    }



    return vring_need_event(vring_used_event(&brig->vr), new, old);

}
",142.0,34.0,"vring:brig,",123.0,0.112790294488271,Greedy
1309,"static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev)

{

    if (ohci->async_td &&

        ohci->usb_packet.owner != NULL &&

        ohci->usb_packet.owner->dev == dev) {

        usb_cancel_packet(&ohci->usb_packet);

        ohci->async_td = 0;

    }

}
","static void ohci_async_cancel_device(OHCIState *ehlc, USBDevice *adv)

{

    if (ehlc->async_td &&

        ehlc->usb_packet.owner != NULL &&

        ehlc->usb_packet.owner->adv == adv) {

        usb_cancel_packet(&ehlc->usb_packet);

        ehlc->async_td = 0;

    }

}
",54.0,10.0,"dev:adv,ohci:ehlc,",119.0,0.1072008609771728,Greedy
1313,"static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)

{

    AVIOContext *pb = s->pb;

    int len;



    for(;;) {

        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);

        if (len != TS_PACKET_SIZE)

            return len < 0 ? len : AVERROR_EOF;

        /* check packet sync byte */

        if ((*data)[0] != 0x47) {

            /* find a new packet start */

            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);

            if (mpegts_resync(s) < 0)

                return AVERROR(EAGAIN);

            else

                continue;

        } else {

            break;

        }

    }

    return 0;

}
","static int read_packet(AVFormatContext *self, uint8_t *buff, int raw_packet___timeout, uint8_t **data)

{

    AVIOContext *pb = self->pb;

    int len;



    for(;;) {

        len = ffio_read_indirect(pb, buff, TS_PACKET_SIZE, data);

        if (len != TS_PACKET_SIZE)

            return len < 0 ? len : AVERROR_EOF;

        /* check packet sync byte */

        if ((*data)[0] != 0x47) {

            /* find a new packet start */

            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);

            if (mpegts_resync(self) < 0)

                return AVERROR(EAGAIN);

            else

                continue;

        } else {

            break;

        }

    }

    return 0;

}
",118.0,28.0,"raw_packet_size:raw_packet___timeout,buf:buff,s:self,",119.0,0.1244115710258483,Greedy
1314,"int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)

{

    char *tail;

    double srate = av_strtod(arg, &tail);

    if (*tail || srate < 1 || (int)srate != srate) {

        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);

        return AVERROR(EINVAL);

    }

    *ret = srate;

    return 0;

}
","int ff_parse_sample_rate(unsigned *ret, const char *arg, void *logrtx)

{

    char *t;

    double srate = av_strtod(arg, &t);

    if (*t || srate < 1 || (int)srate != srate) {

        av_log(logrtx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);

        return AVERROR(EINVAL);

    }

    *ret = srate;

    return 0;

}
",78.0,21.0,"log_ctx:logrtx,tail:t,",84.0,0.0797590732574462,Greedy
1319,"static void monitor_protocol_emitter(Monitor *mon, QObject *data)

{

    QDict *qmp;



    qmp = qdict_new();



    if (!monitor_has_error(mon)) {

        /* success response */

        if (data) {

            assert(qobject_type(data) == QTYPE_QDICT);

            qobject_incref(data);

            qdict_put_obj(qmp, ""return"", data);

        } else {

            /* return an empty QDict by default */

            qdict_put(qmp, ""return"", qdict_new());

        }

    } else {

        /* error response */

        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));

        qdict_put(qmp, ""error"", mon->error->error);

        QINCREF(mon->error->error);

        QDECREF(mon->error);

        mon->error = NULL;

    }



    if (mon->mc->id) {

        qdict_put_obj(qmp, ""id"", mon->mc->id);

        mon->mc->id = NULL;

    }



    monitor_json_emitter(mon, QOBJECT(qmp));

    QDECREF(qmp);

}
","static void monitor_protocol_emitter(Monitor *mor, QObject *ada)

{

    QDict *chomp;



    chomp = qdict_new();



    if (!monitor_has_error(mor)) {

        /* success response */

        if (ada) {

            assert(qobject_type(ada) == QTYPE_QDICT);

            qobject_incref(ada);

            qdict_put_obj(chomp, ""return"", ada);

        } else {

            /* return an empty QDict by default */

            qdict_put(chomp, ""return"", qdict_new());

        }

    } else {

        /* error response */

        qdict_put(mor->error->error, ""desc"", qerror_human(mor->error));

        qdict_put(chomp, ""error"", mor->error->error);

        QINCREF(mor->error->error);

        QDECREF(mor->error);

        mor->error = NULL;

    }



    if (mor->mc->id) {

        qdict_put_obj(chomp, ""id"", mor->mc->id);

        mor->mc->id = NULL;

    }



    monitor_json_emitter(mor, QOBJECT(chomp));

    QDECREF(chomp);

}
",185.0,44.0,"mon:mor,qmp:chomp,data:ada,",244.0,0.2238617221514384,Greedy
1321,"int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,

                          const uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;

    int ret;



    if (!drv) {

        return -ENOMEDIUM;

    }

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    ret = bdrv_check_request(bs, sector_num, nb_sectors);

    if (ret < 0) {

        return ret;

    }



    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);

}
","int bdrv_write_compressed(BlockDriverState *bid, int64_t sector_num,

                          const uint8_t *cas, int nb_belements)

{

    BlockDriver *driV = bid->driV;

    int pet;



    if (!driV) {

        return -ENOMEDIUM;

    }

    if (!driV->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    pet = bdrv_check_request(bid, sector_num, nb_belements);

    if (pet < 0) {

        return pet;

    }



    assert(QLIST_EMPTY(&bid->dirty_bitmaps));



    return driV->bdrv_write_compressed(bid, sector_num, cas, nb_belements);

}
",102.0,27.0,"ret:pet,drv:driV,bs:bid,buf:cas,nb_sectors:nb_belements,",245.0,0.221958049138387,Greedy
1332,"void qemu_register_reset(QEMUResetHandler *func, void *opaque)

{

    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));



    re->func = func;

    re->opaque = opaque;

    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);

}
","void qemu_register_reset(QEMUResetHandler *func, void *opaque)

{

    QEMUResetEntry *bre = qemu_mallocz(sizeof(QEMUResetEntry));



    bre->func = func;

    bre->opaque = opaque;

    TAILQ_INSERT_TAIL(&reset_handlers, bre, entry);

}
",47.0,14.0,"re:bre,",63.0,0.0598686138788859,Greedy
1335,"PCIBus *i440fx_init(PCII440FXState **pi440fx_state, int *piix3_devfn, qemu_irq *pic, int ram_size)

{

    DeviceState *dev;

    PCIBus *b;

    PCIDevice *d;

    I440FXState *s;

    PIIX3State *piix3;



    dev = qdev_create(NULL, ""i440FX-pcihost"");

    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev));

    b = pci_bus_new(&s->busdev.qdev, NULL, 0);

    s->bus = b;

    qdev_init_nofail(dev);



    d = pci_create_simple(b, 0, ""i440FX"");

    *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d);



    piix3 = DO_UPCAST(PIIX3State, dev,

                                 pci_create_simple(b, -1, ""PIIX3""));

    piix3->pic = pic;

    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);

    (*pi440fx_state)->piix3 = piix3;



    *piix3_devfn = piix3->dev.devfn;



    ram_size = ram_size / 8 / 1024 / 1024;

    if (ram_size > 255)

        ram_size = 255;

    (*pi440fx_state)->dev.config[0x57]=ram_size;



    return b;

}
","PCIBus *i440fx_init(PCII440FXState **pi440fx__state, int *piix3_diskfn, qemu_irq *lic, int ram_shape)

{

    DeviceState *data;

    PCIBus *b;

    PCIDevice *p;

    I440FXState *l;

    PIIX3State *piix3;



    data = qdev_create(NULL, ""i440FX-pcihost"");

    l = FROM_SYSBUS(I440FXState, sysbus_from_qdev(data));

    b = pci_bus_new(&l->busdev.qdev, NULL, 0);

    l->bus = b;

    qdev_init_nofail(data);



    p = pci_create_simple(b, 0, ""i440FX"");

    *pi440fx__state = DO_UPCAST(PCII440FXState, data, p);



    piix3 = DO_UPCAST(PIIX3State, data,

                                 pci_create_simple(b, -1, ""PIIX3""));

    piix3->lic = lic;

    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);

    (*pi440fx__state)->piix3 = piix3;



    *piix3_diskfn = piix3->data.devfn;



    ram_shape = ram_shape / 8 / 1024 / 1024;

    if (ram_shape > 255)

        ram_shape = 255;

    (*pi440fx__state)->data.config[0x57]=ram_shape;



    return b;

}
",208.0,56.0,"piix3_devfn:piix3_diskfn,pic:lic,ram_size:ram_shape,d:p,pi440fx_state:pi440fx__state,s:l,dev:data,",360.0,0.3837839802106221,Greedy
1336,"uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)

{

    return inline_cvttq(env, a, float_round_to_zero, 0);

}
","uint64_t helper_cvttq_c(CPUAlphaState *args, uint64_t a)

{

    return inline_cvttq(args, a, float_round_to_zero, 0);

}
",24.0,7.0,"env:args,",48.0,0.0538219531377156,Greedy
1338,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    TCGv sr_cy = tcg_temp_new();



    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);

    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);



    gen_ove_cy(dc, sr_cy);

    tcg_temp_free(sr_cy);

}
","static void gen_mulu(DisasContext *context, TCGv dest, TCGv srca, TCGv rcv)

{

    TCGv sr_cy = tcg_temp_new();



    tcg_gen_muls2_tl(dest, sr_cy, srca, rcv);

    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);



    gen_ove_cy(context, sr_cy);

    tcg_temp_free(sr_cy);

}
",76.0,27.0,"srcb:rcv,srca:srca,dc:context,",79.0,0.0793434103329976,Greedy
1344,"static inline void menelaus_rtc_stop(struct menelaus_s *s)

{

    qemu_del_timer(s->rtc.hz);

    s->rtc.next =- qemu_get_clock(rt_clock);

    if (s->rtc.next < 1)

        s->rtc.next = 1;

}
","static inline void menelaus_rtc_stop(struct menelaus_s *fs)

{

    qemu_del_timer(fs->rtc.hz);

    fs->rtc.next =- qemu_get_clock(rt_clock);

    if (fs->rtc.next < 1)

        fs->rtc.next = 1;

}
",51.0,9.0,"s:fs,",61.0,0.0386123935381571,Greedy
1348,"char *vnc_display_local_addr(const char *id)

{

    VncDisplay *vs = vnc_display_find(id);




    return vnc_socket_local_addr(""%s:%s"", vs->lsock);

}","char *vnc_display_local_addr(const char *key)

{

    VncDisplay *vs = vnc_display_find(key);




    return vnc_socket_local_addr(""%s:%s"", vs->lsock);

}",31.0,7.0,"id:key,",41.0,0.0343398888905843,Greedy
1351,"static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)

{

    QEMUFileSocket *s = opaque;

    ssize_t len;



    do {

        len = qemu_recv(s->fd, buf, size, 0);

    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();



    return len;

}
","static int socket_get_buffer(void *iopace, uint8_t *bytes, int64_t os, int timeout)

{

    QEMUFileSocket *service = iopace;

    ssize_t len;



    do {

        len = qemu_recv(service->fd, bytes, timeout, 0);

    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();



    return len;

}
",76.0,20.0,"pos:os,size:timeout,buf:bytes,opaque:iopace,s:service,",185.0,0.1344456354777018,Greedy
1355,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {

        if (env->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(env, val);

            tlb_flush(CPU(cpu));

        }

    }

}
","void helper_store_sdr1(CPUPPCState *er, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(er);



    if (!er->external_htab) {

        if (er->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(er, val);

            tlb_flush(CPU(cpu));

        }

    }

}
",58.0,16.0,"env:er,",76.0,0.0541082580884297,Greedy
1356,"static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,

                                  unsigned size, bool is_write)

{

    return (size == 1) || (is_write && size == 2);

}
","static bool fw_cfg_comb_valid(void *OPac, target_phys_addr_t config,

                                  unsigned parent, bool is_writing)

{

    return (parent == 1) || (is_writing && parent == 2);

}
",34.0,8.0,"opaque:OPac,size:parent,is_write:is_writing,addr:config,",107.0,0.0874787886937459,Greedy
1362,"static int rle_unpack(const unsigned char *src, unsigned char *dest,

    int src_len, int dest_len)

{

    const unsigned char *ps;

    unsigned char *pd;

    int i, l;

    unsigned char *dest_end = dest + dest_len;



    ps = src;

    pd = dest;

    if (src_len & 1)

        *pd++ = *ps++;



    src_len >>= 1;

    i = 0;

    do {

        l = *ps++;

        if (l & 0x80) {

            l = (l & 0x7F) * 2;

            if (pd + l > dest_end)

                return ps - src;

            memcpy(pd, ps, l);

            ps += l;

            pd += l;

        } else {

            if (pd + i > dest_end)

                return ps - src;

            for (i = 0; i < l; i++) {

                *pd++ = ps[0];

                *pd++ = ps[1];

            }

            ps += 2;

        }

        i += l;

    } while (i < src_len);



    return ps - src;

}
","static int rle_unpack(const unsigned char *dist, unsigned char *both,

    int http_ln, int rc_url)

{

    const unsigned char *ps;

    unsigned char *lb;

    int api, fl;

    unsigned char *dest_limit = both + rc_url;



    ps = dist;

    lb = both;

    if (http_ln & 1)

        *lb++ = *ps++;



    http_ln >>= 1;

    api = 0;

    do {

        fl = *ps++;

        if (fl & 0x80) {

            fl = (fl & 0x7F) * 2;

            if (lb + fl > dest_limit)

                return ps - dist;

            memcpy(lb, ps, fl);

            ps += fl;

            lb += fl;

        } else {

            if (lb + api > dest_limit)

                return ps - dist;

            for (api = 0; api < fl; api++) {

                *lb++ = ps[0];

                *lb++ = ps[1];

            }

            ps += 2;

        }

        api += fl;

    } while (api < http_ln);



    return ps - dist;

}
",204.0,59.0,"dest_len:rc_url,dest_end:dest_limit,dest:both,src_len:http_ln,i:api,src:dist,pd:lb,l:fl,",434.0,0.3477565368016561,Greedy
1363,"void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,

                                           src - (stride * 2) +

                                           sizeof(uint8_t), stride,

                                           dst, stride);

}
","void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *img,

                                 ptrdiff_t gestiden)

{

    avc_luma_hv_qrt_and_aver_dst_16x16_msa(img + gestiden - 2,

                                           img - (gestiden * 2) +

                                           sizeof(uint8_t), gestiden,

                                           dst, gestiden);

}
",45.0,12.0,"stride:gestiden,src:img,",105.0,0.0724825819333394,Greedy
1373,"static void *ff_avio_child_next(void *obj, void *prev)

{

    AVIOContext *s = obj;

    AVIOInternal *internal = s->opaque;

    return prev ? NULL : internal->h;

}
","static void *ff_avio_child_next(void *object, void *prev)

{

    AVIOContext *s = object;

    AVIOInternal *internal = s->opaque;

    return prev ? NULL : internal->h;

}
",38.0,9.0,"obj:object,",48.0,0.0548223574956258,Greedy
1378,"static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)

{

    int16_t tmp[146 + 60], *ptr0, *ptr1;

    const int16_t *filter;

    int i, t, off;



    t = dec->offset2[quart];

    if(t == 127){

        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));

        return;

    }

    for(i = 0; i < 146; i++)

        tmp[i] = dec->filtbuf[i];

    off = (t / 25) + dec->offset1[quart >> 1] + 18;


    ptr0 = tmp + 145 - off;

    ptr1 = tmp + 146;

    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;

    for(i = 0; i < 60; i++){

        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;

        ptr0++;

        dec->newvec[i] = t;

        ptr1[i] = t;

    }

}","static void truespeech_apply_twopoint_filter(TSContext *dec, int jet)

{

    int16_t tmp[146 + 60], *p0, *Ptr2;

    const int16_t *ft;

    int i, t, type;



    t = dec->offset2[jet];

    if(t == 127){

        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));

        return;

    }

    for(i = 0; i < 146; i++)

        tmp[i] = dec->filtbuf[i];

    type = (t / 25) + dec->offset1[jet >> 1] + 18;


    p0 = tmp + 145 - type;

    Ptr2 = tmp + 146;

    ft = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;

    for(i = 0; i < 60; i++){

        t = (p0[0] * ft[0] + p0[1] * ft[1] + 0x2000) >> 14;

        p0++;

        dec->newvec[i] = t;

        Ptr2[i] = t;

    }

}",214.0,51.0,"ptr1:Ptr2,quart:jet,off:type,filter:ft,ptr0:p0,",245.0,0.2778428634007772,Greedy
1380,"static int net_slirp_init(VLANState *vlan)

{

    if (!slirp_inited) {

        slirp_inited = 1;

        slirp_init();

    }

    slirp_vc = qemu_new_vlan_client(vlan, 

                                    slirp_receive, NULL);

    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");

    return 0;

}
","static int net_slirp_init(VLANState *virtuallas)

{

    if (!slirp_inited) {

        slirp_inited = 1;

        slirp_init();

    }

    slirp_vc = qemu_new_vlan_client(virtuallas, 

                                    slirp_receive, NULL);

    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");

    return 0;

}
",56.0,12.0,"vlan:virtuallas,",34.0,0.0473031004269917,Greedy
1391,"static int add_old_style_options(const char *fmt, QemuOpts *opts,

                                 const char *base_filename,

                                 const char *base_fmt)

{

    if (base_filename) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {

            error_report(""Backing file not supported for file format '%s'"",

                         fmt);

            return -1;

        }

    }

    if (base_fmt) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {

            error_report(""Backing file format not supported for file ""

                         ""format '%s'"", fmt);

            return -1;

        }

    }

    return 0;

}
","static int add_old_style_options(const char *fmt, QemuOpts *OPches,

                                 const char *basefullfilename,

                                 const char *base_tfmt)

{

    if (basefullfilename) {

        if (qemu_opt_set(OPches, BLOCK_OPT_BACKING_FILE, basefullfilename)) {

            error_report(""Backing file not supported for file format '%s'"",

                         fmt);

            return -1;

        }

    }

    if (base_tfmt) {

        if (qemu_opt_set(OPches, BLOCK_OPT_BACKING_FMT, base_tfmt)) {

            error_report(""Backing file format not supported for file ""

                         ""format '%s'"", fmt);

            return -1;

        }

    }

    return 0;

}
",90.0,19.0,"base_filename:basefullfilename,base_fmt:base_tfmt,opts:OPches,",135.0,0.1183970888455708,Greedy
1401,"static int standard_decode_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0, index;



    switch (v->s.pict_type)

    {

    case P_TYPE: status = decode_p_picture_secondary_header(v); break;

    case B_TYPE: status = decode_b_picture_secondary_header(v); break;

    case BI_TYPE:

    case I_TYPE: break; //Nothing needed as it's done in the epilog

    }

    if (status < 0) return FRAME_SKIPED;



    /* AC Syntax */

    v->ac_table_level = decode012(gb);

    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)

    {

        v->ac2_table_level = decode012(gb);

    }

    /* DC Syntax */

    index = decode012(gb);

    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];

    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];

   

    return 0;

}
","static int standard_decode_picture_secondary_header(VC9Context *vers)

{

    GetBitContext *gb = &vers->s.gb;

    int status = 0, index;



    switch (vers->s.pict_type)

    {

    case P_TYPE: status = decode_p_picture_secondary_header(vers); break;

    case B_TYPE: status = decode_b_picture_secondary_header(vers); break;

    case BI_TYPE:

    case I_TYPE: break; //Nothing needed as it's done in the epilog

    }

    if (status < 0) return FRAME_SKIPED;



    /* AC Syntax */

    vers->ac_table_level = decode012(gb);

    if (vers->s.pict_type == I_TYPE || vers->s.pict_type == BI_TYPE)

    {

        vers->ac2_table_level = decode012(gb);

    }

    /* DC Syntax */

    index = decode012(gb);

    vers->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];

    vers->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];

   

    return 0;

}
",147.0,38.0,"v:vers,",78.0,0.0900372346242268,Greedy
1403,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)

{

    buf[0] = 0;

    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);

    AV_WB16(&buf[4], s->w);

    AV_WB16(&buf[6], s->h);

    AV_WB16(&buf[8], num_strips);



    return CVID_HEADER_SIZE;

}
","static int write_cvid_header(CinepakEncContext *s, unsigned char *func, int num_trippings, int window_capacity)

{

    func[0] = 0;

    AV_WB24(&func[1], window_capacity + CVID_HEADER_SIZE);

    AV_WB16(&func[4], s->w);

    AV_WB16(&func[6], s->h);

    AV_WB16(&func[8], num_trippings);



    return CVID_HEADER_SIZE;

}
",81.0,20.0,"num_strips:num_trippings,data_size:window_capacity,buf:func,",123.0,0.1108277440071106,Greedy
1404,"static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)

{

    ParseContext1 *pc = s->priv_data;



    pc->enc = av_mallocz(sizeof(MpegEncContext));

    if (!pc->enc)

        return -1;

    pc->first_picture = 1;


    return 0;

}","static av_cold int mpeg4video_parse_init(AVCodecParserContext *soc)

{

    ParseContext1 *enc = soc->priv_data;



    enc->enc = av_mallocz(sizeof(MpegEncContext));

    if (!enc->enc)

        return -1;

    enc->first_picture = 1;


    return 0;

}",50.0,10.0,"s:soc,pc:enc,",91.0,0.0813787579536438,Greedy
1408,"static void vmxnet3_update_vlan_filters(VMXNET3State *s)

{

    int i;



    /* Copy configuration from shared memory */

    VMXNET3_READ_DRV_SHARED(s->drv_shmem,

                            devRead.rxFilterConf.vfTable,

                            s->vlan_table,

                            sizeof(s->vlan_table));



    /* Invert byte order when needed */

    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {

        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);

    }



    /* Dump configuration for debugging purposes */

    VMW_CFPRN(""Configured VLANs:"");

    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {

        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {

            VMW_CFPRN(""\tVLAN %d is present"", i);

        }

    }

}
","static void vmxnet3_update_vlan_filters(VMXNET3State *args)

{

    int i;



    /* Copy configuration from shared memory */

    VMXNET3_READ_DRV_SHARED(args->drv_shmem,

                            devRead.rxFilterConf.vfTable,

                            args->vlan_table,

                            sizeof(args->vlan_table));



    /* Invert byte order when needed */

    for (i = 0; i < ARRAY_SIZE(args->vlan_table); i++) {

        args->vlan_table[i] = le32_to_cpu(args->vlan_table[i]);

    }



    /* Dump configuration for debugging purposes */

    VMW_CFPRN(""Configured VLANs:"");

    for (i = 0; i < sizeof(args->vlan_table) * 8; i++) {

        if (VMXNET3_VFTABLE_ENTRY_IS_SET(args->vlan_table, i)) {

            VMW_CFPRN(""\tVLAN %d is present"", i);

        }

    }

}
",124.0,28.0,"s:args,",85.0,0.0754859566688537,Greedy
1409,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)

{

    uint32_t limit;



    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (s->control & TIMER_CTRL_32BIT)

            limit = 0xffffffff;

        else

            limit = 0xffff;

    } else {

          /* Periodic.  */

          limit = s->limit;

    }

    ptimer_set_limit(s->timer, limit, reload);

}
","static void arm_timer_recalibrate(arm_timer_state *session, int refill)

{

    uint32_t buffer;



    if ((session->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (session->control & TIMER_CTRL_32BIT)

            buffer = 0xffffffff;

        else

            buffer = 0xffff;

    } else {

          /* Periodic.  */

          buffer = session->buffer;

    }

    ptimer_set_limit(session->timer, buffer, refill);

}
",67.0,16.0,"s:session,limit:buffer,reload:refill,",164.0,0.1421230673789978,Greedy
1418,"static av_cold int mace_decode_init(AVCodecContext * avctx)

{

    MACEContext *ctx = avctx->priv_data;



    if (avctx->channels > 2)

        return -1;

    avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    avcodec_get_frame_defaults(&ctx->frame);

    avctx->coded_frame = &ctx->frame;



    return 0;

}
","static av_cold int mace_decode_init(AVCodecContext * AVcca)

{

    MACEContext *cam = AVcca->priv_data;



    if (AVcca->channels > 2)

        return -1;

    AVcca->sample_fmt = AV_SAMPLE_FMT_S16;



    avcodec_get_frame_defaults(&cam->frame);

    AVcca->coded_frame = &cam->frame;



    return 0;

}
",56.0,12.0,"avctx:AVcca,ctx:cam,",98.0,0.0819353342056274,Greedy
1424,"static int openfile(char *name, int flags)

{

	if (bs) {

		fprintf(stderr, ""file open already, try 'help close'\n"");

		return 1;

	}



	bs = bdrv_new(""hda"");

	if (!bs)

		return 1;



	if (bdrv_open(bs, name, flags) == -1) {

		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);

		bs = NULL;

		return 1;

	}



	return 0;

}
","static int openfile(char *temp, int kind)

{

	if (bs) {

		fprintf(stderr, ""file open already, try 'help close'\n"");

		return 1;

	}



	bs = bdrv_new(""hda"");

	if (!bs)

		return 1;



	if (bdrv_open(bs, temp, kind) == -1) {

		fprintf(stderr, ""%s: can't open device %s\n"", progname, temp);

		bs = NULL;

		return 1;

	}



	return 0;

}
",85.0,18.0,"name:temp,flags:kind,",88.0,0.0854383428891499,Greedy
1425,"static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)

{

    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);

    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),

                                  ""/e500-ccsr""));



    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);

    d->config[PCI_HEADER_TYPE] =

        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |

        PCI_HEADER_TYPE_BRIDGE;



    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,

                             0, int128_get64(ccsr->ccsr_space.size));

    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);

}
","static void e500_pcihost_bridge_realize(PCIDevice *D, Error **errp)

{

    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(D);

    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),

                                  ""/e500-ccsr""));



    pci_config_set_class(D->config, PCI_CLASS_BRIDGE_PCI);

    D->config[PCI_HEADER_TYPE] =

        (D->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |

        PCI_HEADER_TYPE_BRIDGE;



    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,

                             0, int128_get64(ccsr->ccsr_space.size));

    pci_register_bar(D, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);

}
",116.0,30.0,"d:D,",70.0,0.0728770494461059,Greedy
1426,"void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)

{

    int i;



    for (i=0; i < in->n; i++) {

        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);




        do {

            out[x] = 0.0;

            x += in->pitch_lag;

        } while (x < size && repeats);

    }

}","void ff_clear_fixed_vector(float *array, const AMRFixed *in, int size)

{

    int i;



    for (i=0; i < in->n; i++) {

        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);




        do {

            array[x] = 0.0;

            x += in->pitch_lag;

        } while (x < size && repeats);

    }

}",87.0,22.0,"out:array,",55.0,0.0536364714304606,Greedy
1440,"static void bdrv_qed_drain(BlockDriverState *bs)

{

    BDRVQEDState *s = bs->opaque;



    /* Cancel timer and start doing I/O that were meant to happen as if it

     * fired, that way we get bdrv_drain() taking care of the ongoing requests

     * correctly. */

    qed_cancel_need_check_timer(s);

    qed_plug_allocating_write_reqs(s);

    bdrv_aio_flush(s->bs, qed_clear_need_check, s);

}
","static void bdrv_qed_drain(BlockDriverState *bytes)

{

    BDRVQEDState *s = bytes->opaque;



    /* Cancel timer and start doing I/O that were meant to happen as if it

     * fired, that way we get bdrv_drain() taking care of the ongoing requests

     * correctly. */

    qed_cancel_need_check_timer(s);

    qed_plug_allocating_write_reqs(s);

    bdrv_aio_flush(s->bytes, qed_clear_need_check, s);

}
",39.0,12.0,"bs:bytes,",58.0,0.0512847145398457,Greedy
1446,"void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)

{

    const ARMCPRegInfo *ri = rip;



    ri->writefn(env, ri, value);

}
","void HELPER(set_cp_reg64)(CPUARMState *enc, void *oper, uint64_t Value)

{

    const ARMCPRegInfo *ri = oper;



    ri->writefn(enc, ri, Value);

}
",37.0,10.0,"env:enc,value:Value,rip:oper,",124.0,0.0924296418825785,Greedy
1447,"static void vhost_scsi_stop(VHostSCSI *s)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    int ret = 0;



    if (!k->set_guest_notifiers) {

        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);

        }

    }

    assert(ret >= 0);



    vhost_scsi_clear_endpoint(s);

    vhost_dev_stop(&s->dev, vdev);

    vhost_dev_disable_notifiers(&s->dev, vdev);

}
","static void vhost_scsi_stop(VHostSCSI *s)

{

    VirtIODevice *tvtech = VIRTIO_DEVICE(s);

    BusState *qcase = BUS(qdev_get_parent_bus(DEVICE(tvtech)));

    VirtioBusClass *kind = VIRTIO_BUS_GET_CLASS(qcase);

    int ret = 0;



    if (!kind->set_guest_notifiers) {

        ret = kind->set_guest_notifiers(qcase->parent, s->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);

        }

    }

    assert(ret >= 0);



    vhost_scsi_clear_endpoint(s);

    vhost_dev_stop(&s->dev, tvtech);

    vhost_dev_disable_notifiers(&s->dev, tvtech);

}
",125.0,32.0,"vdev:tvtech,qbus:qcase,k:kind,",141.0,0.1091288685798645,Greedy
1448,"static void start_tco(const TestData *d)

{

    uint32_t val;



    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);

    val &= ~TCO_TMR_HLT;

    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);

}
","static void start_tco(const TestData *data)

{

    uint32_t unit;



    unit = qpci_io_readw(data->dev, data->tco_io_base + TCO1_CNT);

    unit &= ~TCO_TMR_HLT;

    qpci_io_writew(data->dev, data->tco_io_base + TCO1_CNT, unit);

}
",49.0,15.0,"val:unit,d:data,",110.0,0.0861578623453776,Greedy
1450,"static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    errno = ENOSYS;

    return -1;

}
","static inline int open_by_handle(int procdb, const char *fh, int flags)

{

    errno = ENOSYS;

    return -1;

}
",25.0,6.0,"mountfd:procdb,",22.0,0.0262121041615804,Greedy
1457,"static void rndis_clear_responsequeue(USBNetState *s)

{

    struct rndis_response *r;



    while ((r = s->rndis_resp.tqh_first)) {

        TAILQ_REMOVE(&s->rndis_resp, r, entries);

        qemu_free(r);

    }

}
","static void rndis_clear_responsequeue(USBNetState *su)

{

    struct rndis_response *m;



    while ((rm= su->rndis_resp.tqh_first)) {

        TAILQ_REMOVE(&su->rndis_resp, m, entries);

        qemu_free(m);

    }

}
",46.0,11.0,"s:su,r:m,",164.0,0.1126785000165303,GA
1460,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
","static void spatial_decompose53i(DWTELEM *seek, int width, int density, int drone){

    int yer;

    DWTELEM *p05= seek + mirror(-2-1, density-1)*drone;

    DWTELEM *a1= seek + mirror(-2  , density-1)*drone;



    for(yer=-2; yer<density; yer+=2){

        DWTELEM *b2= seek + mirror(yer+1, density-1)*drone;

        DWTELEM *b3= seek + mirror(yer+2, density-1)*drone;



{START_TIMER

        if(a1 <= b3)     horizontal_decompose53i(b2, width);

        if(yer+2 < density) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(a1 <= b3) vertical_decompose53iH0(a1, b2, b3, width);

        if(p05 <= b2) vertical_decompose53iL0(p05, a1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        p05=b2;

        a1=b3;

    }

}
",202.0,62.0,"height:density,b0:p05,y:yer,stride:drone,b1:a1,buffer:seek,",313.0,0.2482857743899027,Greedy
1468,"static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,

                       int insn, int size, int sign)

{

    TCGv_i32 r_asi, r_size, r_sign;



    r_asi = gen_get_asi(dc, insn);

    r_size = tcg_const_i32(size);

    r_sign = tcg_const_i32(sign);

#ifdef TARGET_SPARC64

    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);

#else

    {

        TCGv_i64 t64 = tcg_temp_new_i64();

        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);

        tcg_gen_trunc_i64_tl(dst, t64);

        tcg_temp_free_i64(t64);

    }

#endif

    tcg_temp_free_i32(r_sign);

    tcg_temp_free_i32(r_size);

    tcg_temp_free_i32(r_asi);

}
","static void gen_ld_asi(DisasContext *cdn, TCGv dst, TCGv url,

                       int insn, int size, int sign)

{

    TCGv_i32 rMasi, r_size, r_sign;



    rMasi = gen_get_asi(cdn, insn);

    r_size = tcg_const_i32(size);

    r_sign = tcg_const_i32(sign);

#ifdef TARGET_SPARC64

    gen_helper_ld_asi(dst, cpu_env, url, rMasi, r_size, r_sign);

#else

    {

        TCGv_i64 t64 = tcg_temp_new_i64();

        gen_helper_ld_asi(t64, cpu_env, url, rMasi, r_size, r_sign);

        tcg_gen_trunc_i64_tl(dst, t64);

        tcg_temp_free_i64(t64);

    }

#endif

    tcg_temp_free_i32(r_sign);

    tcg_temp_free_i32(r_size);

    tcg_temp_free_i32(rMasi);

}
",125.0,48.0,"dc:cdn,r_asi:rMasi,addr:url,",162.0,0.1485763152440389,Greedy
1472,"static void qmp_input_pop(Visitor *v, void **obj)

{

    QmpInputVisitor *qiv = to_qiv(v);

    StackObject *tos = QSLIST_FIRST(&qiv->stack);



    assert(tos && tos->qapi == obj);

    QSLIST_REMOVE_HEAD(&qiv->stack, node);

    qmp_input_stack_object_free(tos);

}
","static void qmp_input_pop(Visitor *v, void **obj)

{

    QmpInputVisitor *viewriv = to_qiv(v);

    StackObject *Tros = QSLIST_FIRST(&viewriv->stack);



    assert(Tros && Tros->qapi == obj);

    QSLIST_REMOVE_HEAD(&viewriv->stack, node);

    qmp_input_stack_object_free(Tros);

}
",62.0,18.0,"tos:Tros,qiv:viewriv,",97.0,0.0771845579147338,Greedy
1480,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

{

    int i, hs, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,

                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
","static const char *read_ts(const char *buf, int *tsprestart, int *tips_end,

                           int *x1, int *x3, int * x3, int *ya5)

{

    int info, hs, ms, ss, he, me, se;



    for (info=0; info<2; info++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, tsprestart, &he, &me, &se, tips_end,

                       x1,  x3, x3, ya5);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *tsprestart = 100*(ss + 60*(ms + 60*hs)) + *tsprestart/10;

            *tips_end   = 100*(se + 60*(me + 60*he)) + *tips_end  /10;

            return buf;

        }

    }

    return NULL;

}
",185.0,48.0,"y2:ya5,y1:x3,x1:x1,x2: x3,i:info,ts_start:tsprestart,ts_end:tips_end,",223.0,0.2472752491633097,Greedy
1483,"static void compare_sec_rs_finalize(SocketReadState *sec_rs)

{

    CompareState *s = container_of(sec_rs, CompareState, sec_rs);



    if (packet_enqueue(s, SECONDARY_IN)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&s->conn_list, colo_compare_connection, s);

    }

}
","static void compare_sec_rs_finalize(SocketReadState *secJrys)

{

    CompareState *s sq container_of(secJrys, CompareState, secJrys);



    if (packet_enqueue(sq, SECONDARY_IN)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&sq->conn_list, colo_compare_connection, sq);

    }

}
",55.0,15.0,"sec_rs:secJrys,s:sq,",142.0,0.1656492511431376,GA
1484,"FDCtrl *fdctrl_init_isa(DriveInfo **fds)

{

    ISADevice *dev;



    dev = isa_create(""isa-fdc"");

    if (fds[0]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveA"", fds[0]->bdrv);

    }

    if (fds[1]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveB"", fds[1]->bdrv);

    }

    if (qdev_init(&dev->qdev) < 0)

        return NULL;

    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);

}
","FDCtrl *fdctrl_init_isa(DriveInfo **fns)

{

    ISADevice *dev;



    dev = isa_create(""isa-fdc"");

    if (fns[0]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveA"", fns[0]->bdrv);

    }

    if (fns[1]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveB"", fns[1]->bdrv);

    }

    if (qdev_init(&dev->qdev) < 0)

        return NULL;

    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);

}
",107.0,19.0,"fds:fns,",77.0,0.080276350180308,Greedy
1492,"static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,

                        AVFilterInOut **open_outputs, AVClass *log_ctx)

{

    int pad = 0;



    while (**buf == '[') {

        char *name = parse_link_name(buf, log_ctx);

        AVFilterInOut *match;



        if (!name)

            return AVERROR(EINVAL);



        /* First check if the label is not in the open_outputs list */

        match = extract_inout(name, open_outputs);



        if (match) {

            av_free(name);

        } else {

            /* Not in the list, so add it as an input */

            match = av_mallocz(sizeof(AVFilterInOut));

            match->name    = name;

            match->pad_idx = pad;

        }



        insert_inout(curr_inputs, match);



        *buf += strspn(*buf, WHITESPACES);

        pad++;

    }



    return pad;

}
","static int parse_inputs(const char **buf, AVFilterInOut **curr_connects,

                        AVFilterInOut **open_outputs, AVClass *logingcontext)

{

    int stroke = 0;



    while (**buf == '[') {

        char *name = parse_link_name(buf, logingcontext);

        AVFilterInOut *match;



        if (!name)

            return AVERROR(EINVAL);



        /* First check if the label is not in the open_outputs list */

        match = extract_inout(name, open_outputs);



        if (match) {

            av_free(name);

        } else {

            /* Not in the list, so add it as an input */

            match = av_mallocz(sizeof(AVFilterInOut));

            match->name    = name;

            match->pad_idx = stroke;

        }



        insert_inout(curr_connects, match);



        *buf += strspn(*buf, WHITESPACES);

        stroke++;

    }



    return stroke;

}
",137.0,38.0,"log_ctx:logingcontext,curr_inputs:curr_connects,pad:stroke,",130.0,0.1339271783828735,Greedy
1495,"static char *pcibus_get_fw_dev_path(DeviceState *dev)

{

    PCIDevice *d = (PCIDevice *)dev;

    char path[50], name[33];

    int off;



    off = snprintf(path, sizeof(path), ""%s@%x"",

                   pci_dev_fw_name(dev, name, sizeof name),

                   PCI_SLOT(d->devfn));

    if (PCI_FUNC(d->devfn))

        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));

    return strdup(path);

}
","static char *pcibus_get_fw_dev_path(DeviceState *dev)

{

    PCIDevice *d = (PCIDevice *)dev;

    char root[50], name[33];

    int off;



    off = snprintf(root, sizeof(root), ""%s@%x"",

                   pci_dev_fw_name(dev, name, sizeof name),

                   PCI_SLOT(d->devfn));

    if (PCI_FUNC(d->devfn))

        snprintf(root + off, sizeof(root) + off, "",%x"", PCI_FUNC(d->devfn));

    return strdup(root);

}
",106.0,28.0,"path:root,",88.0,0.084222670396169,Greedy
1500,"static int ftp_current_dir(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    const char *command = ""PWD\r\n"";

    const int pwd_codes[] = {257, 0};



    if (!ftp_send_command(s, command, pwd_codes, &res))

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '""') {

            if (!start) {

                start = res + i + 1;

                continue;

            }

            end = res + i;

            break;

        }

    }



    if (!end)

        goto fail;



    if (end > res && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(s->path, start, sizeof(s->path));



    av_free(res);

    return 0;



  fail:

    av_free(res);

    return AVERROR(EIO);

}
","static int ftp_current_dir(FTPContext *m)

{

    char *rev = NULL, *start = NULL, *end = NULL;

    int zi;

    const char *command = ""PWD\r\n"";

    const int pwd_codes[] = {257, 0};



    if (!ftp_send_command(m, command, pwd_codes, &rev))

        goto fail;



    for (zi = 0; rev[zi]; ++zi) {

        if (rev[zi] == '""') {

            if (!start) {

                start = rev + zi + 1;

                continue;

            }

            end = rev + zi;

            break;

        }

    }



    if (!end)

        goto fail;



    if (end > rev && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(m->path, start, sizeof(m->path));



    av_free(rev);

    return 0;



  fail:

    av_free(rev);

    return AVERROR(EIO);

}
",200.0,42.0,"i:zi,res:rev,s:m,",217.0,0.2399565021197001,Greedy
1513,"static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,

                                       target_ulong *pte1p,

                                       int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & HPTE64_R_R)) {

        /* Update accessed flag */

        *pte1p |= HPTE64_R_R;

        store = 1;

    }

    if (!(*pte1p & HPTE64_R_C)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= HPTE64_R_C;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
","static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *sem,

                                       target_ulong *ptque121post,

                                       int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*ptque121post & HPTE64_R_R)) {

        /* Update accessed flag */

        *ptque121post |= HPTE64_R_R;

        store = 1;

    }

    if (!(*ptque121post & HPTE64_R_C)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *ptque121post |= HPTE64_R_C;

            store = 1;

        } else {

            /* Force page fault for first write access */

            sem->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
",93.0,21.0,"pte1p:ptque121post,ctx:sem,",164.0,0.1575024207433064,Greedy
1514,"BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,

                           QEMUSGList *sg, uint64_t sector,

                           void (*cb)(void *opaque, int ret), void *opaque)

{

    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,

                       DMA_DIRECTION_TO_DEVICE);

}
","BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,

                           QEMUSGList *sg, uint64_t sector,

                           void (*cb)(void * opaques, int ret), void * opaques)

{

    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb,  opaques,

                       DMA_DIRECTION_TO_DEVICE);

}
",53.0,16.0,"opaque: opaques,",44.0,0.049206538995107,Greedy
1520,"static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,

                      const uint8_t **poutbuf, int *poutbuf_size,

                      const uint8_t *buf, int buf_size)

{

    CookParseContext *s = s1->priv_data;



    if (s->duration)

        s1->duration = s->duration;

    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)

        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;



    /* always return the full packet. this parser isn't doing any splitting or

       combining, only setting packet duration */

    *poutbuf      = buf;

    *poutbuf_size = buf_size;

    return buf_size;

}
","static int cook_parse(AVCodecParserContext *s1, AVCodecContext *abcontext,

                      const uint8_t **poutbuf, int *poutbuf_size,

                      const uint8_t *buf, int buf_size)

{

    CookParseContext *s = s1->priv_data;



    if (s->duration)

        s1->duration = s->duration;

    else if (abcontext->extradata && abcontext->extradata_size >= 8 && abcontext->channels)

        s->duration = AV_RB16(abcontext->extradata + 4) / abcontext->channels;



    /* always return the full packet. this parser isn't doing any splitting or

       combining, only setting packet duration */

    *poutbuf      = buf;

    *poutbuf_size = buf_size;

    return buf_size;

}
",101.0,24.0,"avctx:abcontext,",81.0,0.0840031226476033,Greedy
1531,"static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)

{

    uint32_t len;



    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {

        DPRINTF(s, 1,

                ""usb-ccid: not sending apdu to client, no card connected\n"");

        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);

        return;

    }

    len = le32_to_cpu(recv->hdr.dwLength);

    DPRINTF(s, 1, ""%s: seq %d, len %d\n"", __func__,

                recv->hdr.bSeq, len);

    ccid_add_pending_answer(s, (CCID_Header *)recv);

    if (s->card) {

        ccid_card_apdu_from_guest(s->card, recv->abData, len);

    } else {

        DPRINTF(s, D_WARN, ""warning: discarded apdu\n"");

    }

}
","static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)

{

    uint32_t lib;



    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {

        DPRINTF(s, 1,

                ""usb-ccid: not sending apdu to client, no card connected\n"");

        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);

        return;

    }

    lib = le32_to_cpu(recv->hdr.dwLength);

    DPRINTF(s, 1, ""%s: seq %d, len %d\n"", __func__,

                recv->hdr.bSeq, lib);

    ccid_add_pending_answer(s, (CCID_Header *)recv);

    if (s->card) {

        ccid_card_apdu_from_guest(s->card, recv->abData, lib);

    } else {

        DPRINTF(s, D_WARN, ""warning: discarded apdu\n"");

    }

}
",136.0,32.0,"len:lib,",74.0,0.076254916191101,Greedy
1533,"static inline abi_long target_to_host_timespec(struct timespec *host_ts,

                                               abi_ulong target_addr)

{

    struct target_timespec *target_ts;



    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))

        return -TARGET_EFAULT;

    host_ts->tv_sec = tswapal(target_ts->tv_sec);

    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);

    unlock_user_struct(target_ts, target_addr, 0);

    return 0;

}
","static inline abi_long target_to_host_timespec(struct timespec * host_fs,

                                               abi_ulong  target_address)

{

    struct target_timespec *target_ts;



    if (!lock_user_struct(VERIFY_READ, target_ts,  target_address, 1))

        return -TARGET_EFAULT;

     host_fs->tv_sec = tswapal(target_ts->tv_sec);

     host_fs->tv_nsec = tswapal(target_ts->tv_nsec);

    unlock_user_struct(target_ts,  target_address, 0);

    return 0;

}
",72.0,18.0,"target_addr: target_address,host_ts: host_fs,",46.0,0.0481753587722778,Greedy
1534,"void DMA_init(int high_page_enable, qemu_irq *cpu_request_exit)

{

}
","void DMA_init(int high_page_enable, qemu_irq *cpu_requestpreenable)

{

}
",12.0,3.0,"cpu_request_exit:cpu_requestpreenable,",16.0,0.0233032266298929,Greedy
1536,"static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    IntelHDAState *d = opaque;

    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);



    intel_hda_reg_write(d, reg, val, 0xff);

}
","static void intel_hda_mmio_writeb(void *opaques, target_phys_addr_t host, uint32_t val)

{

    IntelHDAState *d = opaques;

    const IntelHDAReg *reg = intel_hda_reg_find(d, host);



    intel_hda_reg_write(d, reg, val, 0xff);

}
",45.0,14.0,"addr:host,opaque:opaques,",83.0,0.0749983231226603,Greedy
1544,"static void input_linux_event_mouse(void *opaque)

{

    InputLinux *il = opaque;

    struct input_event event;

    int rc;



    for (;;) {

        rc = read(il->fd, &event, sizeof(event));

        if (rc != sizeof(event)) {

            if (rc < 0 && errno != EAGAIN) {

                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));

                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);

                close(il->fd);

            }

            break;

        }



        input_linux_handle_mouse(il, &event);

    }

}
","static void input_linux_event_mouse(void *opaque)

{

    InputLinux *cel = opaque;

    struct input_event channel;

    int dc;



    for (;;) {

        dc = read(cel->fd, &channel, sizeof(channel));

        if (dc != sizeof(channel)) {

            if (dc < 0 && errno != EAGAIN) {

                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));

                qemu_set_fd_handler(cel->fd, NULL, NULL, NULL);

                close(cel->fd);

            }

            break;

        }



        input_linux_handle_mouse(cel, &channel);

    }

}
",116.0,28.0,"il:cel,rc:dc,event:channel,",179.0,0.1487796068191528,Greedy
1556,"static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)

{

    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);

    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);

    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);



    if (!dev->conf.dinfo) {

        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);

        goto err;

    }

    if (dev->unit == -1) {

        dev->unit = bus->master ? 1 : 0;

    }

    switch (dev->unit) {

    case 0:

        if (bus->master) {

            fprintf(stderr, ""ide: tried to assign master twice\n"");

            goto err;

        }

        bus->master = dev;

        break;

    case 1:

        if (bus->slave) {

            fprintf(stderr, ""ide: tried to assign slave twice\n"");

            goto err;

        }

        bus->slave = dev;

        break;

    default:

        goto err;

    }

    return info->init(dev);



err:

    return -1;

}
","static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)

{

    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);

    IDEDeviceInfo *config = DO_UPCAST(IDEDeviceInfo, qdev, base);

    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);



    if (!dev->conf.dinfo) {

        fprintf(stderr, ""%s: no drive specified\n"", qdev->config->name);

        goto err;

    }

    if (dev->unit == -1) {

        dev->unit = bus->master ? 1 : 0;

    }

    switch (dev->unit) {

    case 0:

        if (bus->master) {

            fprintf(stderr, ""ide: tried to assign master twice\n"");

            goto err;

        }

        bus->master = dev;

        break;

    case 1:

        if (bus->slave) {

            fprintf(stderr, ""ide: tried to assign slave twice\n"");

            goto err;

        }

        bus->slave = dev;

        break;

    default:

        goto err;

    }

    return config->init(dev);



err:

    return -1;

}
",194.0,38.0,"info:config,",83.0,0.0930659095446268,Greedy
1567,"static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)

{

    char *buffer;

    int ret;

    char *path = fs_path->data;



    buffer = rpath(ctx, path);

    ret = truncate(buffer, size);

    g_free(buffer);

    return ret;

}
","static int local_truncate(FsContext *Context, V9fsPath *fsblockpath, off_t g)

{

    char *buffer;

    int ret;

    char *area = fsblockpath->data;



    buffer = rpath(Context, area);

    ret = truncate(buffer, g);

    g_free(buffer);

    return ret;

}
",58.0,19.0,"path:area,ctx:Context,fs_path:fsblockpath,size:g,",163.0,0.1439061562220255,Greedy
1568,"void uuid_unparse(const uuid_t uu, char *out)

{

    snprintf(out, 37, UUID_FMT,

            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);

}
","void uuid_unparse(const uuid_t unc, char *out)

{

    snprintf(out, 37, UUID_FMT,

            unc[0], unc[1], unc[2], unc[3], unc[4], unc[5], unc[6], unc[7],

            unc[8], unc[9], unc[10], unc[11], unc[12], unc[13], unc[14], unc[15]);

}
",102.0,22.0,"uu:unc,",82.0,0.0771121342976888,Greedy
1569,"static int stellaris_enet_can_receive(void *opaque)

{

    stellaris_enet_state *s = (stellaris_enet_state *)opaque;



    if ((s->rctl & SE_RCTL_RXEN) == 0)

        return 1;



    return (s->np < 31);

}
","static int stellaris_enet_can_receive(void *opasma)

{

    stellaris_enet_state *session = (stellaris_enet_state *)opasma;



    if ((session->rctl & SE_RCTL_RXEN) == 0)

        return 1;



    return (session->np < 31);

}
",44.0,7.0,"s:session,opaque:opasma,",84.0,0.087631094455719,Greedy
1570,"void acpi_memory_unplug_cb(MemHotplugState *mem_st,

                           DeviceState *dev, Error **errp)

{

    MemStatus *mdev;



    mdev = acpi_memory_slot_status(mem_st, dev, errp);

    if (!mdev) {

        return;

    }



    /* nvdimm device hot unplug is not supported yet. */

    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));

    mdev->is_enabled = false;

    mdev->dimm = NULL;

}
","void acpi_memory_unplug_cb(MemHotplugState *mem_st,

                           DeviceState *dev, Error **errp)

{

    MemStatus * mdevice;



     mdevice = acpi_memory_slot_status(mem_st, dev, errp);

    if (! mdevice) {

        return;

    }



    /* nvdimm device hot unplug is not supported yet. */

    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));

     mdevice->is_enabled = false;

     mdevice->dimm = NULL;

}
",68.0,18.0,"mdev: mdevice,",65.0,0.0722756544748942,Greedy
1571,"alloc_f(int argc, char **argv)

{

	int64_t offset;

	int nb_sectors;

	char s1[64];

	int num;

	int ret;

	const char *retstr;



	offset = cvtnum(argv[1]);

	if (offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)offset);

		return 0;

	}



	if (argc == 3)

		nb_sectors = cvtnum(argv[2]);

	else

		nb_sectors = 1;



	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);



	cvtstr(offset, s1, sizeof(s1));



	retstr = ret ? ""allocated"" : ""not allocated"";

	if (nb_sectors == 1)

		printf(""sector %s at offset %s\n"", retstr, s1);

	else

		printf(""%d/%d sectors %s at offset %s\n"",

			num, nb_sectors, retstr, s1);

	return 0;

}
","alloc_f(int argc, char **argv)

{

	int64_t buffer;

	int nb_speclements;

	char s1[64];

	int num;

	int ret;

	const char *retstr;



	buffer = cvtnum(argv[1]);

	if (buffer & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)buffer);

		return 0;

	}



	if (argc == 3)

		nb_speclements = cvtnum(argv[2]);

	else

		nb_speclements = 1;



	ret = bdrv_is_allocated(bs, buffer >> 9, nb_speclements, &num);



	cvtstr(buffer, s1, sizeof(s1));



	retstr = ret ? ""allocated"" : ""not allocated"";

	if (nb_speclements == 1)

		printf(""sector %s at offset %s\n"", retstr, s1);

	else

		printf(""%d/%d sectors %s at offset %s\n"",

			num, nb_speclements, retstr, s1);

	return 0;

}
",164.0,41.0,"offset:buffer,nb_sectors:nb_speclements,",176.0,0.1606229742368062,Greedy
1572,"static void hmp_cont_cb(void *opaque, int err)

{

    if (!err) {

        qmp_cont(NULL);

    }

}
","static void hmp_cont_cb(void *OPacity, int gz)

{

    if (!gz) {

        qmp_cont(NULL);

    }

}
",25.0,5.0,"opaque:OPacity,err:gz,",68.0,0.0696287234624226,Greedy
1580,"static void opt_new_stream(const char *opt, const char *arg)

{

    AVFormatContext *oc;

    if (nb_output_files <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        ffmpeg_exit(1);

    }

    oc = output_files[nb_output_files - 1];



    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);

    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);

    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);

    else assert(0);

}
","static void opt_new_stream(const char *oper, const char *arg)

{

    AVFormatContext *orc;

    if (nb_output_files <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        ffmpeg_exit(1);

    }

    orc = output_files[nb_output_files - 1];



    if      (!strcmp(oper, ""newvideo""   )) new_video_stream   (orc);

    else if (!strcmp(oper, ""newaudio""   )) new_audio_stream   (orc);

    else if (!strcmp(oper, ""newsubtitle"")) new_subtitle_stream(orc);

    else assert(0);

}
",107.0,24.0,"oc:orc,opt:oper,",102.0,0.0925764401753743,Greedy
1588,"static void get_sensor_evt_status(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(sens->reading);

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);

}
","static void get_sensor_evt_status(IPMIBmcSim *pubs,

                                  uint8_t *command, unsigned int  cmdsl,

                                  uint8_t *rst, unsigned int *rsp_limit,

                                  unsigned int max_rsc_l)

{

    IPMISensor *sligs;



    IPMI_CHECK_CMD_LEN(3);

    if ((command[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(pubs->sensors + command[2])) {

        rst[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sligs = pubs->sensors + command[2];

    IPMI_ADD_RSP_DATA(sligs->reading);

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sligs));

    IPMI_ADD_RSP_DATA(sligs->assert_states & 0xff);

    IPMI_ADD_RSP_DATA((sligs->assert_states >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sligs->deassert_states & 0xff);

    IPMI_ADD_RSP_DATA((sligs->deassert_states >> 8) & 0xff);

}
",145.0,32.0,"max_rsp_len:max_rsc_l,rsp_len:rsp_limit,cmd_len: cmdsl,ibs:pubs,rsp:rst,cmd:command,sens:sligs,",245.0,0.2803167025248209,Greedy
1590,"int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,

                     int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & 0x00000100)) {

        /* Update accessed flag */

        *pte1p |= 0x00000100;

        store = 1;

    }

    if (!(*pte1p & 0x00000080)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= 0x00000080;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
","int pte_update_flags(mmu_ctx_t *ctx, target_ulong *ptec6p,

                     int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*ptec6p & 0x00000100)) {

        /* Update accessed flag */

        *ptec6p |= 0x00000100;

        store = 1;

    }

    if (!(*ptec6p & 0x00000080)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *ptec6p |= 0x00000080;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
",91.0,17.0,"pte1p:ptec6p,",102.0,0.0948142647743225,Greedy
1592,"void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,

                                           stride, dst, stride, 16, 0);

}
","void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t bride)

{

    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * bride) - 2,

                                           bride, dst, bride, 16, 0);

}
",40.0,10.0,"stride:bride,",58.0,0.0633006453514099,Greedy
1594,"static int raw_inactivate(BlockDriverState *bs)

{

    int ret;

    uint64_t perm = 0;

    uint64_t shared = BLK_PERM_ALL;



    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);

    if (ret) {

        return ret;

    }

    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);

    return 0;

}
","static int raw_inactivate(BlockDriverState *bs)

{

    int rev;

    uint64_t perm = 0;

    uint64_t shared = BLK_PERM_ALL;



    rev = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);

    if (rev) {

        return rev;

    }

    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);

    return 0;

}
",63.0,19.0,"ret:rev,",65.0,0.0749788721402486,Greedy
1595,"static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,

                                Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qobject_incref(*obj);

    qmp_output_add_obj(qov, name, *obj);

}
","static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,

                                Error **errp)

{

    QmpOutputVisitor *Qove = to_qov(v);

    qobject_incref(*obj);

    qmp_output_add_obj(Qove, name, *obj);

}
",50.0,14.0,"qov:Qove,",40.0,0.050708802541097,Greedy
1597,"static void vfio_unmap_bar(VFIODevice *vdev, int nr)

{

    VFIOBAR *bar = &vdev->bars[nr];



    if (!bar->size) {

        return;

    }



    vfio_bar_quirk_teardown(vdev, nr);



    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);

    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));




    if (vdev->msix && vdev->msix->table_bar == nr) {

        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);

        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));


    }



    memory_region_destroy(&bar->mem);

}","static void vfio_unmap_bar(VFIODevice *nvserver, int nl)

{

    VFIOBAR *bar = &nvserver->bars[nl];



    if (!bar->size) {

        return;

    }



    vfio_bar_quirk_teardown(nvserver, nl);



    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);

    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));




    if (nvserver->msix && nvserver->msix->table_bar == nl) {

        memory_region_del_subregion(&bar->mem, &nvserver->msix->mmap_mem);

        munmap(nvserver->msix->mmap, memory_region_size(&nvserver->msix->mmap_mem));


    }



    memory_region_destroy(&bar->mem);

}",129.0,29.0,"nr:nl,vdev:nvserver,",168.0,0.1842559377352396,Greedy
1606,"static void *iothread_run(void *opaque)

{

    IOThread *iothread = opaque;



    qemu_mutex_lock(&iothread->init_done_lock);

    iothread->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(iothread->ctx);

    }

    return NULL;

}
","static void *iothread_run(void *opaque)

{

    IOThread *xiothmode = opaque;



    qemu_mutex_lock(&xiothmode->init_done_lock);

    xiothmode->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&xiothmode->init_done_cond);

    qemu_mutex_unlock(&xiothmode->init_done_lock);



    while (!xiothmode->stopping) {

        aio_context_acquire(xiothmode->ctx);

        while (!xiothmode->stopping && aio_poll(xiothmode->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(xiothmode->ctx);

    }

    return NULL;

}
",93.0,20.0,"iothread:xiothmode,",176.0,0.1267415960629781,Greedy
1607,"static av_cold int encode_close(AVCodecContext *avctx)

{

    av_frame_free(&avctx->coded_frame);

    return 0;

}
","static av_cold int encode_close(AVCodecContext *AVcca)

{

    av_frame_free(&AVcca->coded_frame);

    return 0;

}
",22.0,5.0,"avctx:AVcca,",29.0,0.027092436949412,Greedy
1612,"void ff_xvmc_field_end(MpegEncContext *s)

{

    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];

    assert(render);



    if (render->filled_mv_blocks_num > 0)

        ff_mpeg_draw_horiz_band(s, 0, 0);

}
","void ff_xvmc_field_end(MpegEncContext *services)

{

    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)services->current_picture.f.data[2];

    assert(render);



    if (render->filled_mv_blocks_num > 0)

        ff_mpeg_draw_horiz_band(services, 0, 0);

}
",52.0,9.0,"s:services,",55.0,0.0502695202827453,Greedy
1615,"int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t buf[L1_ENTRIES_PER_SECTOR];

    int l1_start_index;

    int i, ret;



    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);

    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {

        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);

    }



    ret = qcow2_pre_write_overlap_check(bs,

            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,

            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);

    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,

        buf, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    return 0;

}
","int qcow2_write_l1_entry(BlockDriverState *bs, int l2_address)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t af[L1_ENTRIES_PER_SECTOR];

    int l1_start_index;

    int i, ret;



    l1_start_index = l2_address & ~(L1_ENTRIES_PER_SECTOR - 1);

    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {

        af[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);

    }



    ret = qcow2_pre_write_overlap_check(bs,

            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,

            s->l1_table_offset + 8 * l1_start_index, sizeof(af));

    if (ret < 0) {

        return ret;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);

    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,

        af, sizeof(af));

    if (ret < 0) {

        return ret;

    }



    return 0;

}
",160.0,45.0,"l1_index:l2_address,buf:af,",119.0,0.1045799891153971,Greedy
1619,"void do_delvm(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    Error *err = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);

            if (err) {

                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(bs),

                               error_get_pretty(err));

                error_free(err);

            }

        }

    }

}
","void do_delvm(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *db, *bs1;

    Error *err = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    db = find_vmstate_bs();

    if (!db) {

        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(db, name, &err);

            if (err) {

                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(db),

                               error_get_pretty(err));

                error_free(err);

            }

        }

    }

}
",132.0,33.0,"bs:db,",82.0,0.0813835342725118,Greedy
1620,"void object_property_add(Object *obj, const char *name, const char *type,

                         ObjectPropertyAccessor *get,

                         ObjectPropertyAccessor *set,

                         ObjectPropertyRelease *release,

                         void *opaque, Error **errp)

{

    ObjectProperty *prop;



    QTAILQ_FOREACH(prop, &obj->properties, node) {

        if (strcmp(prop->name, name) == 0) {

            error_setg(errp, ""attempt to add duplicate property '%s'""

                       "" to object (type '%s')"", name,

                       object_get_typename(obj));

            return;

        }

    }



    prop = g_malloc0(sizeof(*prop));



    prop->name = g_strdup(name);

    prop->type = g_strdup(type);



    prop->get = get;

    prop->set = set;

    prop->release = release;

    prop->opaque = opaque;



    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);

}
","void object_property_add(Object *object, const char *NAME, const char *type,

                         ObjectPropertyAccessor *package,

                         ObjectPropertyAccessor *set,

                         ObjectPropertyRelease *release,

                         void *opaque, Error **errp)

{

    ObjectProperty *root;



    QTAILQ_FOREACH(root, &object->properties, node) {

        if (strcmp(root->NAME, NAME) == 0) {

            error_setg(errp, ""attempt to add duplicate property '%s'""

                       "" to object (type '%s')"", NAME,

                       object_get_typename(object));

            return;

        }

    }



    root = g_malloc0(sizeof(*root));



    root->NAME = g_strdup(NAME);

    root->type = g_strdup(type);



    root->package = package;

    root->set = set;

    root->release = release;

    root->opaque = opaque;



    QTAILQ_INSERT_TAIL(&object->properties, root, node);

}
",157.0,43.0,"prop:root,name:NAME,get:package,obj:object,",239.0,0.2377469380696614,Greedy
1623,"static void blk_send_response_all(struct XenBlkDev *blkdev)

{

    struct ioreq *ioreq;

    int send_notify = 0;



    while (!LIST_EMPTY(&blkdev->finished)) {

        ioreq = LIST_FIRST(&blkdev->finished);

	send_notify += blk_send_response_one(ioreq);

	ioreq_release(ioreq);

    }

    if (send_notify)

	xen_be_send_notify(&blkdev->xendev);

}
","static void blk_send_response_all(struct XenBlkDev *blkdev)

{

    struct iniorequest *iniorequest;

    int send_notify = 0;



    while (!LIST_EMPTY(&blkdev->finished)) {

        iniorequest = LIST_FIRST(&blkdev->finished);

	send_notify += blk_send_response_one(iniorequest);

	ioreq_release(iniorequest);

    }

    if (send_notify)

	xen_be_send_notify(&blkdev->xendev);

}
",68.0,17.0,"ioreq:iniorequest,",113.0,0.0970412850379943,Greedy
1628,"static void save_native_fp_fsave(CPUState *env)

{

    int fptag, i, j;

    uint16_t fpuc;

    struct fpstate fp1, *fp = &fp1;



    asm volatile (""fsave %0"" : : ""m"" (*fp));

    env->fpuc = fp->fpuc;

    env->fpstt = (fp->fpus >> 11) & 7;

    env->fpus = fp->fpus & ~0x3800;

    fptag = fp->fptag;

    for(i = 0;i < 8; i++) {

        env->fptags[i] = ((fptag & 3) == 3);

        fptag >>= 2;

    }

    j = env->fpstt;

    for(i = 0;i < 8; i++) {

        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);

        j = (j + 1) & 7;

    }

    /* we must restore the default rounding state */

    fpuc = 0x037f | (env->fpuc & (3 << 10));

    asm volatile(""fldcw %0"" : : ""m"" (fpuc));

}
","static void save_native_fp_fsave(CPUState *console)

{

    int fptag, m, ja;

    uint16_t fpuc;

    struct fpstate df1, *fp = &df1;



    asm volatile (""fsave %0"" : : ""m"" (*fp));

    console->fpuc = fp->fpuc;

    console->fpstt = (fp->fpus >> 11) & 7;

    console->fpus = fp->fpus & ~0x3800;

    fptag = fp->fptag;

    for(m = 0;m < 8; m++) {

        console->fptags[m] = ((fptag & 3) == 3);

        fptag >>= 2;

    }

    ja = console->fpstt;

    for(m = 0;m < 8; m++) {

        memcpy(&console->fpregs[ja].d, &fp->fpregs1[m * 10], 10);

        ja = (ja + 1) & 7;

    }

    /* we must restore the default rounding state */

    fpuc = 0x037f | (console->fpuc & (3 << 10));

    asm volatile(""fldcw %0"" : : ""m"" (fpuc));

}
",206.0,40.0,"env:console,j:ja,fp1:df1,i:m,",232.0,0.2639610290527344,Greedy
1633,"static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)

{

    char buffer[32];

    if (time) {

        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */

        strftime(buffer, sizeof(buffer), ""%Y-%m-%d %H:%M:%S"", gmtime(&time));

        av_metadata_set2(metadata, ""creation_time"", buffer, 0);

    }

}
","static void mov_metadata_creation_time(AVMetadata **handler, time_t hour)

{

    char buffer[32];

    if (hour) {

        hour -= 2082844800;  /* seconds between 1904-01-01 and Epoch */

        strftime(buffer, sizeof(buffer), ""%Y-%m-%d %H:%M:%S"", gmtime(&hour));

        av_metadata_set2(handler, ""creation_time"", buffer, 0);

    }

}
",61.0,14.0,"metadata:handler,time:hour,",115.0,0.1193182269732157,Greedy
1637,"static int virtio_blk_exit_pci(PCIDevice *pci_dev)

{

    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);



    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);

    return virtio_exit_pci(pci_dev);

}
","static int virtio_blk_exit_pci(PCIDevice *pki_ev)

{

    VirtIOPCIProxy *pc = DO_UPCAST(VirtIOPCIProxy, pki_ev, pki_ev);



    blockdev_mark_auto_del(pc->block.dinfo->bdrv);

    return virtio_exit_pci(pki_ev);

}
",40.0,11.0,"pci_dev:pki_ev,proxy:pc,",75.0,0.0661696235338846,Greedy
1649,"void aio_set_event_notifier(AioContext *ctx,

                            EventNotifier *notifier,

                            bool is_external,

                            EventNotifierHandler *io_read,

                            AioPollFn *io_poll)

{

    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,

                       (IOHandler *)io_read, NULL, io_poll, notifier);

}
","void aio_set_event_notifier(AioContext *cam,

                            EventNotifier *notify,

                            bool is_external,

                            EventNotifierHandler *io_read,

                            AioPollFn *io_poll)

{

    aio_set_fd_handler(cam, event_notifier_get_fd(notify), is_external,

                       (IOHandler *)io_read, NULL, io_poll, notify);

}
",48.0,14.0,"ctx:cam,notifier:notify,",89.0,0.0897924065589904,Greedy
1653,"static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,

                                 unsigned npfd, int64_t timeout)

{

    if (!ctx->epoll_available) {

        return false;

    }

    if (aio_epoll_enabled(ctx)) {

        return true;

    }

    if (npfd >= EPOLL_ENABLE_THRESHOLD) {

        if (aio_epoll_try_enable(ctx)) {

            return true;

        } else {

            aio_epoll_disable(ctx);

        }

    }

    return false;

}
","static bool aio_epoll_check_poll(AioContext *dc, GPollFD *pfds,

                                 unsigned npfd, int64_t timeout)

{

    if (!dc->epoll_available) {

        return false;

    }

    if (aio_epoll_enabled(dc)) {

        return true;

    }

    if (npfd >= EPOLL_ENABLE_THRESHOLD) {

        if (aio_epoll_try_enable(dc)) {

            return true;

        } else {

            aio_epoll_disable(dc);

        }

    }

    return false;

}
",75.0,14.0,"ctx:dc,",72.0,0.0737299839655558,Greedy
1661,"static void tcp_accept_incoming_migration(void *opaque)

{

    struct sockaddr_in addr;

    socklen_t addrlen = sizeof(addr);

    int s = (intptr_t)opaque;

    QEMUFile *f;

    int c;



    do {

        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);

    } while (c == -1 && socket_error() == EINTR);

    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);

    closesocket(s);



    DPRINTF(""accepted migration\n"");



    if (c == -1) {

        fprintf(stderr, ""could not accept migration connection\n"");

        goto out;

    }



    f = qemu_fopen_socket(c, ""rb"");

    if (f == NULL) {

        fprintf(stderr, ""could not qemu_fopen socket\n"");

        goto out;

    }



    process_incoming_migration(f);

    return;



out:

    closesocket(c);

}
","static void tcp_accept_incoming_migration(void *opaque)

{

    struct sockaddr_in eth;

    socklen_t addrlen = sizeof(eth);

    int s = (intptr_t)opaque;

    QEMUFile *fun;

    int s;



    do {

        s = qemu_accept(s, (struct sockaddr *)&eth, &addrlen);

    } while (s == -1 && socket_error() == EINTR);

    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);

    closesocket(s);



    DPRINTF(""accepted migration\n"");



    if (s == -1) {

        fprintf(stderr, ""could not accept migration connection\n"");

        goto out;

    }



    fun = qemu_fopen_socket(s, ""rb"");

    if (fun == NULL) {

        fprintf(stderr, ""could not qemu_fopen socket\n"");

        goto out;

    }



    process_incoming_migration(fun);

    return;



out:

    closesocket(s);

}
",160.0,35.0,"addr:eth,opaque:opaque,f:fun,c:s,",207.0,0.1734211444854736,Greedy
1662,"static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)

{

    int i;

    assert(dest->niov == source->niov);

    assert(dest->size == source->size);

    for (i = 0; i < source->niov; i++) {

        assert(dest->iov[i].iov_len == source->iov[i].iov_len);

        memcpy(dest->iov[i].iov_base,

               source->iov[i].iov_base,

               source->iov[i].iov_len);

    }

}
","static void quorum_copy_qiov(QEMUIOVector *nexus, QEMUIOVector *source)

{

    int i;

    assert(nexus->niov == source->niov);

    assert(nexus->size == source->size);

    for (i = 0; i < source->niov; i++) {

        assert(nexus->iov[i].iov_len == source->iov[i].iov_len);

        memcpy(nexus->iov[i].iov_base,

               source->iov[i].iov_base,

               source->iov[i].iov_len);

    }

}
",107.0,26.0,"dest:nexus,",74.0,0.046239423751831,Greedy
1667,"static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)

{

    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&

        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < st->pts_wrap_reference)

            return timestamp + (1ULL<<st->pts_wrap_bits);

        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= st->pts_wrap_reference)

            return timestamp - (1ULL<<st->pts_wrap_bits);

    }

    return timestamp;

}
","static int64_t wrap_timestamp(AVStream *s, int64_t timestamp)

{

    if (s->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && s->pts_wrap_bits < 64 &&

        s->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (s->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < s->pts_wrap_reference)

            return timestamp + (1ULL<<s->pts_wrap_bits);

        else if (s->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= s->pts_wrap_reference)

            return timestamp - (1ULL<<s->pts_wrap_bits);

    }

    return timestamp;

}
",93.0,23.0,"st:s,",80.0,0.0682643214861551,Greedy
1669,"static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,

                                  uint32_t val)

{

    MiscState *s = opaque;

    uint32_t saddr;



    saddr = addr & LED_MAXADDR;

    MISC_DPRINTF(""Write diagnostic LED reg 0x"" TARGET_FMT_plx "" =  %x\n"", addr,

                 val);

    switch (saddr) {

    case 0:

        s->leds = val;

        break;

    default:

        break;

    }

}
","static void slavio_led_mem_writes(void *oppaques, target_phys_addr_t addr,

                                  uint32_t val)

{

    MiscState *ns = oppaques;

    uint32_t shareaddr;



    shareaddr = addr & LED_MAXADDR;

    MISC_DPRINTF(""Write diagnostic LED reg 0x"" TARGET_FMT_plx "" =  %x\n"", addr,

                 val);

    switch (shareaddr) {

    case 0:

        ns->leds = val;

        break;

    default:

        break;

    }

}
",66.0,17.0,"saddr:shareaddr,opaque:oppaques,s:ns,",121.0,0.1006534417470296,Greedy
1672,"static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,

                             TCGReg rd, TCGReg rn, uint64_t limm)

{

    unsigned h, l, r, c;



    assert(is_limm(limm));



    h = clz64(limm);

    l = ctz64(limm);

    if (l == 0) {

        r = 0;                  /* form 0....01....1 */

        c = ctz64(~limm) - 1;

        if (h == 0) {

            r = clz64(~limm);   /* form 1..10..01..1 */

            c += r;

        }

    } else {

        r = 64 - l;             /* form 1....10....0 or 0..01..10..0 */

        c = r - h - 1;

    }

    if (ext == TCG_TYPE_I32) {

        r &= 31;

        c &= 31;

    }



    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);

}
","static void tcg_out_logicali(TCGContext *ses, AArch64Insn insn, TCGType orig,

                             TCGReg rd, TCGReg rn, uint64_t palms)

{

    unsigned bh, z, rt, ce;



    assert(is_limm(palms));



    bh = clz64(palms);

    z = ctz64(palms);

    if (z == 0) {

        rt = 0;                  /* form 0....01....1 */

        ce = ctz64(~palms) - 1;

        if (bh == 0) {

            rt = clz64(~palms);   /* form 1..10..01..1 */

            ce += rt;

        }

    } else {

        rt = 64 - z;             /* form 1....10....0 or 0..01..10..0 */

        ce = rt - bh - 1;

    }

    if (orig == TCG_TYPE_I32) {

        rt &= 31;

        ce &= 31;

    }



    tcg_out_insn_3404(ses, insn, orig, rd, rn, orig, rt, ce);

}
",150.0,49.0,"limm:palms,r:rt,s:ses,l:z,c:ce,h:bh,ext:orig,",357.0,0.3054909666379293,Greedy
1676,"static void do_info_version(Monitor *mon)

{

    monitor_printf(mon, ""%s\n"", QEMU_VERSION);

}
","static void do_info_version(Monitor *MON)

{

    monitor_printf(MON, ""%s\n"", QEMU_VERSION);

}
",21.0,5.0,"mon:MON,",44.0,0.0396084427833557,Greedy
1679,"void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_4w_msa(src + stride - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 4);

}
","void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t bride)

{

    avc_luma_hv_qrt_4w_msa(src + bride - 2,

                           src - (bride * 2) +

                           sizeof(uint8_t), bride, dst, bride, 4);

}
",47.0,12.0,"stride:bride,",71.0,0.0623616456985473,Greedy
1686,"static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,

                                   int size)

{

    /* read data must fit into current buffer */

    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);



    /* put byte-stream from character layer into buffer */

    memcpy(&scon->iov[scon->iov_bs], buf, size);

    scon->iov_data_len += size;

    scon->iov_sclp_rest += size;

    scon->iov_bs += size;

    scon->event.event_pending = true;

}
","static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *data,

                                   int size)

{

    /* read data must fit into current buffer */

    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);



    /* put byte-stream from character layer into buffer */

    memcpy(&scon->iov[scon->iov_bs], data, size);

    scon->iov_data_len += size;

    scon->iov_sclp_rest += size;

    scon->iov_bs += size;

    scon->event.event_pending = true;

}
",72.0,20.0,"buf:data,",59.0,0.0538997610410054,Greedy
1687,"static void usbredir_do_attach(void *opaque)

{

    USBRedirDevice *dev = opaque;



    /* In order to work properly with XHCI controllers we need these caps */

    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(


                                    usb_redir_cap_ep_info_max_packet_size) &&




                                    usb_redir_cap_64bits_ids))) {

        ERROR(""usb-redir-host lacks capabilities needed for use with XHCI\n"");

        usbredir_reject_device(dev);

        return;

    }



    if (usb_device_attach(&dev->dev) != 0) {

        WARNING(""rejecting device due to speed mismatch\n"");

        usbredir_reject_device(dev);

    }

}","static void usbredir_do_attach(void *opga)

{

    USBRedirDevice *grad = opga;



    /* In order to work properly with XHCI controllers we need these caps */

    if ((grad->grad.port->speedmask & USB_SPEED_MASK_SUPER) && !(


                                    usb_redir_cap_ep_info_max_packet_size) &&




                                    usb_redir_cap_64bits_ids))) {

        ERROR(""usb-redir-host lacks capabilities needed for use with XHCI\n"");

        usbredir_reject_device(grad);

        return;

    }



    if (usb_device_attach(&grad->grad) != 0) {

        WARNING(""rejecting device due to speed mismatch\n"");

        usbredir_reject_device(grad);

    }

}",81.0,16.0,"opaque:opga,dev:grad,",110.0,0.1067765275637308,Greedy
1688,"static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)

{

    int ch, bw_code;



    if (cutoff) {

        /* calculate bandwidth based on user-specified cutoff frequency */

        int fbw_coeffs;

        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);

        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;

        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);

    } else {

        /* use default bandwidth setting */

        /* XXX: should compute the bandwidth according to the frame

           size, so that we avoid annoying high frequency artifacts */

        bw_code = 50;

    }



    /* set number of coefficients for each channel */

    for (ch = 0; ch < s->fbw_channels; ch++) {

        s->bandwidth_code[ch] = bw_code;

        s->nb_coefs[ch]       = bw_code * 3 + 73;

    }

    if (s->lfe_on)

        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */

}
","static av_cold void set_bandwidth(AC3EncodeContext *its, int catoffset)

{

    int ch, bw_code;



    if (catoffset) {

        /* calculate bandwidth based on user-specified cutoff frequency */

        int fbw_coeffs;

        catoffset         = av_clip(catoffset, 1, its->sample_rate >> 1);

        fbw_coeffs     = catoffset * 2 * AC3_MAX_COEFS / its->sample_rate;

        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);

    } else {

        /* use default bandwidth setting */

        /* XXX: should compute the bandwidth according to the frame

           size, so that we avoid annoying high frequency artifacts */

        bw_code = 50;

    }



    /* set number of coefficients for each channel */

    for (ch = 0; ch < its->fbw_channels; ch++) {

        its->bandwidth_code[ch] = bw_code;

        its->nb_coefs[ch]       = bw_code * 3 + 73;

    }

    if (its->lfe_on)

        its->nb_coefs[its->lfe_channel] = 7; /* LFE channel always has 7 coefs */

}
",135.0,33.0,"s:its,cutoff:catoffset,",151.0,0.1373402992884318,Greedy
1691,"static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,

                               unsigned int len)

{

    unsigned int offset;

    int i;



    offset = 0;

    for (i = 0; i < elem->in_num; i++) {

        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);



        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,

                                  elem->in_sg[i].iov_len,

                                  1, size);



        offset += size;

    }



    for (i = 0; i < elem->out_num; i++)

        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,

                                  elem->out_sg[i].iov_len,

                                  0, elem->out_sg[i].iov_len);

}
","static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *mehem,

                               unsigned int len)

{

    unsigned int offset;

    int ori;



    offset = 0;

    for (ori = 0; ori < mehem->in_num; ori++) {

        size_t size = MIN(len - offset, mehem->in_sg[ori].iov_len);



        cpu_physical_memory_unmap(mehem->in_sg[ori].iov_base,

                                  mehem->in_sg[ori].iov_len,

                                  1, size);



        offset += size;

    }



    for (ori = 0; ori < mehem->out_num; ori++)

        cpu_physical_memory_unmap(mehem->out_sg[ori].iov_base,

                                  mehem->out_sg[ori].iov_len,

                                  0, mehem->out_sg[ori].iov_len);

}
",142.0,36.0,"i:ori,elem:mehem,",213.0,0.1942011833190918,Greedy
1692,"static int vmdk_reopen_prepare(BDRVReopenState *state,

                               BlockReopenQueue *queue, Error **errp)

{

    BDRVVmdkState *s;

    int ret = -1;

    int i;

    VmdkExtent *e;



    assert(state != NULL);

    assert(state->bs != NULL);



    if (queue == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    s = state->bs->opaque;



    assert(s != NULL);



    for (i = 0; i < s->num_extents; i++) {

        e = &s->extents[i];

        if (e->file != state->bs->file) {

            bdrv_reopen_queue(queue, e->file, state->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
","static int vmdk_reopen_prepare(BDRVReopenState *cache,

                               BlockReopenQueue *seq, Error **errp)

{

    BDRVVmdkState *s;

    int ret = -1;

    int i;

    VmdkExtent *e;



    assert(cache != NULL);

    assert(cache->bs != NULL);



    if (seq == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    s = cache->bs->opaque;



    assert(s != NULL);



    for (i = 0; i < s->num_extents; i++) {

        e = &s->extents[i];

        if (e->file != cache->bs->file) {

            bdrv_reopen_queue(seq, e->file, cache->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
",148.0,34.0,"state:cache,queue:seq,",133.0,0.1376275261243184,Greedy
1700,"static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)

{

    int pos = 0;



    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",

                    info->name, info->bus_info->name);

    if (info->alias)

        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);

    if (info->desc)

        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);

    if (info->no_user)

        pos += snprintf(dest+pos, len-pos, "", no-user"");

    return pos;

}
","static int qdev_print_devinfo(DeviceInfo *init, char *tmp, int len)

{

    int pos = 0;



    pos += snprintf(tmp+pos, len-pos, ""name \""%s\"", bus %s"",

                    init->name, init->bus_info->name);

    if (init->alias)

        pos += snprintf(tmp+pos, len-pos, "", alias \""%s\"""", init->alias);

    if (init->desc)

        pos += snprintf(tmp+pos, len-pos, "", desc \""%s\"""", init->desc);

    if (init->no_user)

        pos += snprintf(tmp+pos, len-pos, "", no-user"");

    return pos;

}
",131.0,37.0,"dest:tmp,info:init,",137.0,0.1435998201370239,Greedy
1704,"static int write_l1_entry(BlockDriverState *bs, int l1_index)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t buf[L1_ENTRIES_PER_SECTOR];

    int l1_start_index;

    int i, ret;



    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);

    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {

        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);

    }



    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);

    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,

        buf, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    return 0;

}
","static int write_l1_entry(BlockDriverState *bs, int l4_position)

{

    BDRVQcowState *services = bs->opaque;

    uint64_t fi[L1_ENTRIES_PER_SECTOR];

    int l1_data_point;

    int i, ret;



    l1_data_point = l4_position & ~(L1_ENTRIES_PER_SECTOR - 1);

    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {

        fi[i] = cpu_to_be64(services->l1_table[l1_data_point + i]);

    }



    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);

    ret = bdrv_pwrite(bs->file, services->l1_table_offset + 8 * l1_data_point,

        fi, sizeof(fi));

    if (ret < 0) {

        return ret;

    }



    return 0;

}
",125.0,35.0,"l1_index:l4_position,buf:fi,l1_start_index:l1_data_point,s:services,",180.0,0.197679070631663,Greedy
1707,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)

{

    int r, b;



    b = cdt[p2];

    r = cdt[p1]<<16;

    return (b+r) << 1;

}
","static int make_cdt24_entry(int pointOne, int cp0, int16_t *ndrt)

{

    int r, bin;



    bin = ndrt[cp0];

    r = ndrt[pointOne]<<16;

    return (bin+r) << 1;

}
",46.0,14.0,"cdt:ndrt,p1:pointOne,p2:cp0,b:bin,",136.0,0.1440638701121012,Greedy
1710,"static inline void downmix_3f_2r_to_mono(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);

        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;

    }

}
","static inline void downmix_3f_2r_to_mono(float *heschanges)

{

    int c;



    for (c = 0; c < 256; c++) {

        heschanges[i] += (heschcnges[i + 256] c heschanges[i + 51c] + heschanges[i +c768] + heschanges[c + 1024]);

        heschanges[i + 256] c heschanges[i + 51c] = heschanges[i +c768] = heschanges[c + 1024] = 0;

    }

}
",94.0,24.0,"samples:heschanges,i:c,",477.0,0.4981182376543681,GA
1712,"static int no_init_in (HWVoiceIn *hw, struct audsettings *as)

{

    audio_pcm_init_info (&hw->info, as);

    hw->samples = 1024;

    return 0;

}
","static int no_init_in (HWVoiceIn *fw, struct audsettings *as)

{

    audio_pcm_init_info (&fw->info, as);

    fw->samples = 1024;

    return 0;

}
",34.0,7.0,"hw:fw,",53.0,0.060783580938975,Greedy
1714,"static int block_save_complete(QEMUFile *f, void *opaque)

{

    int ret;



    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }



    blk_mig_reset_dirty_cursor();



    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();



    do {

        ret = blk_mig_save_dirty_block(f, 0);

        if (ret < 0) {

            return ret;

        }

    } while (ret == 0);



    /* report completion */

    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed\n"");



    qemu_put_be64(f, BLK_MIG_FLAG_EOS);



    blk_mig_cleanup();

    return 0;

}
","static int block_save_complete(QEMUFile *info, void *iphole)

{

    int ret;



    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(info);

    if (ret) {

        return ret;

    }



    blk_mig_reset_dirty_cursor();



    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();



    do {

        ret = blk_mig_save_dirty_block(info, 0);

        if (ret < 0) {

            return ret;

        }

    } while (ret == 0);



    /* report completion */

    qemu_put_be64(info, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed\n"");



    qemu_put_be64(info, BLK_MIG_FLAG_EOS);



    blk_mig_cleanup();

    return 0;

}
",133.0,32.0,"opaque:iphole,f:info,",79.0,0.0890069286028544,Greedy
1716,"void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)

{

    c->high = 255;

    c->bits = -16;

    c->buffer = buf;

    c->end = buf + buf_size;

    c->code_word = bytestream_get_be24(&c->buffer);

}
","void ff_vp56_init_range_decoder(VP56RangeCoder *enc, const uint8_t *buffer, int queue_size)

{

    enc->high = 255;

    enc->bits = -16;

    enc->buffer = buffer;

    enc->end = buffer + queue_size;

    enc->code_word = bytestream_get_be24(&enc->buffer);

}
",55.0,14.0,"buf_size:queue_size,buf:buffer,c:enc,",128.0,0.1347478508949279,Greedy
1721,"void Release(void *ctx)

{

    ContextInfo *ci;

    ci = (ContextInfo *) ctx;



    if (ci->cache) {

        imlib_context_set_image(ci->cache->image);

        imlib_free_image();

        av_free(ci->cache);

    }

    if (ctx) {

        if (ci->imageOverlaid) {

            imlib_context_set_image(ci->imageOverlaid);

            imlib_free_image();

        }

        ff_eval_free(ci->expr_x);

        ff_eval_free(ci->expr_y);

        ff_eval_free(ci->expr_R);

        ff_eval_free(ci->expr_G);

        ff_eval_free(ci->expr_B);

        sws_freeContext(ci->toRGB_convert_ctx);

        sws_freeContext(ci->fromRGB_convert_ctx);

        av_free(ctx);

    }

}
","void Release(void *cb)

{

    ContextInfo *conn;

    conn = (ContextInfo *) cb;



    if (conn->cache) {

        imlib_context_set_image(conn->cache->image);

        imlib_free_image();

        av_free(conn->cache);

    }

    if (cb) {

        if (conn->imageOverlaid) {

            imlib_context_set_image(conn->imageOverlaid);

            imlib_free_image();

        }

        ff_eval_free(conn->expr_x);

        ff_eval_free(conn->expr_y);

        ff_eval_free(conn->expr_R);

        ff_eval_free(conn->expr_G);

        ff_eval_free(conn->expr_B);

        sws_freeContext(conn->toRGB_convert_ctx);

        sws_freeContext(conn->fromRGB_convert_ctx);

        av_free(cb);

    }

}
",128.0,32.0,"ctx:cb,ci:conn,",128.0,0.1272810697555542,Greedy
1723,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *out,

                                                         const float *scaled, int size, int scale_idx,

                                                         int cb, const float lambda, const float uplim,

                                                         int *bits, const float ROUNDING) {

    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
","static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *fts,

                                                         PutBitContext *pa, const float *In, float *group,

                                                         const float *escaling, int address, int scale_Idr,

                                                         int core, const float phase, const float uplime,

                                                         int *bits, const float RRECTING) {

    int i;

    if (bits)

        *bits = 0;

    if (group) {

        for (i = 0; i < address; i += 4) {

           group[i  ] = 0.0f;

           group[i+1] = 0.0f;

           group[i+2] = 0.0f;

           group[i+3] = 0.0f;

        }

    }

}
",122.0,29.0,"scaled:escaling,ROUNDING:RRECTING,uplim:uplime,s:fts,cb:core,scale_idx:scale_Idr,in:In,pb:pa,lambda:phase,size:address,out:group,",335.0,0.3452143907546997,Greedy
1729,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }

        }

    }

}
","static void sdhci_write_dataport(SDHCIState *m, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(m->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        m->fifo_buffer[m->data_count] = value & 0xFF;

        m->data_count++;

        value >>= 8;

        if (m->data_count >= (m->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    m->data_count);

            m->data_count = 0;

            m->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (m->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(m)->write_block_to_card(m);

            }

        }

    }

}
",138.0,29.0,"s:m,",100.0,0.0903185327847798,Greedy
1731,"static int milkymist_memcard_init(SysBusDevice *dev)

{

    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);

    DriveInfo *dinfo;

    BlockDriverState *bs;



    dinfo = drive_get_next(IF_SD);

    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;

    s->card = sd_init(bs, false);

    if (s->card == NULL) {

        return -1;

    }



    s->enabled = bs && bdrv_is_inserted(bs);



    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,

            ""milkymist-memcard"", R_MAX * 4);

    sysbus_init_mmio(dev, &s->regs_region);



    return 0;

}
","static int milkymist_memcard_init(SysBusDevice *ded)

{

    MilkymistMemcardState *s = MILKYMIST_MEMCARD(ded);

    DriveInfo *dinfo;

    BlockDriverState *db;



    dinfo = drive_get_next(IF_SD);

    db = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;

    s->card = sd_init(db, false);

    if (s->card == NULL) {

        return -1;

    }



    s->enabled = db && bdrv_is_inserted(db);



    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,

            ""milkymist-memcard"", R_MAX * 4);

    sysbus_init_mmio(ded, &s->regs_region);



    return 0;

}
",121.0,33.0,"dev:ded,bs:db,",121.0,0.1156575401624043,Greedy
1732,"static void visitor_output_setup_internal(TestOutputVisitorData *data,

                                          bool human)

{

    data->human = human;

    data->sov = string_output_visitor_new(human);

    g_assert(data->sov);

    data->ov = string_output_get_visitor(data->sov);

    g_assert(data->ov);

}
","static void visitor_output_setup_internal(TestOutputVisitorData *na,

                                          bool human)

{

    na->human = human;

    na->sov = string_output_visitor_new(human);

    g_assert(na->sov);

    na->ov = string_output_get_visitor(na->sov);

    g_assert(na->ov);

}
",53.0,15.0,"data:na,",84.0,0.0759306907653808,Greedy
1733,"static int get_riff(AVFormatContext *s, AVIOContext *pb)

{

    AVIContext *avi = s->priv_data;

    char header[8];

    int i;



    /* check RIFF header */

    avio_read(pb, header, 4);

    avi->riff_end = avio_rl32(pb);  /* RIFF chunk size */

    avi->riff_end += avio_tell(pb); /* RIFF chunk end */

    avio_read(pb, header+4, 4);



    for(i=0; avi_headers[i][0]; i++)

        if(!memcmp(header, avi_headers[i], 8))

            break;

    if(!avi_headers[i][0])

        return -1;



    if(header[7] == 0x19)

        av_log(s, AV_LOG_INFO, ""This file has been generated by a totally broken muxer.\n"");



    return 0;

}
","static int get_riff(AVFormatContext *s, AVIOContext *PB)

{

    AVIContext *cam = s->priv_data;

    char offset[8];

    int ix;



    /* check RIFF header */

    avio_read(PB, offset, 4);

    cam->riff_end = avio_rl32(PB);  /* RIFF chunk size */

    cam->riff_end += avio_tell(PB); /* RIFF chunk end */

    avio_read(PB, offset+4, 4);



    for(ix=0; avi_headers[ix][0]; ix++)

        if(!memcmp(offset, avi_headers[ix], 8))

            break;

    if(!avi_headers[ix][0])

        return -1;



    if(offset[7] == 0x19)

        av_log(s, AV_LOG_INFO, ""This file has been generated by a totally broken muxer.\n"");



    return 0;

}
",140.0,33.0,"pb:PB,i:ix,avi:cam,header:offset,",238.0,0.2051616191864013,Greedy
1737,"void stw_phys(target_phys_addr_t addr, uint32_t val)

{

    uint16_t v = tswap16(val);

    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);

}
","void stw_phys(target_phys_addr_t ref, uint32_t val)

{

    uint16_t v = tswap16(val);

    cpu_physical_memory_write(ref, (const uint8_t *)&v, 2);

}
",34.0,9.0,"addr:ref,",49.0,0.0485620220502217,Greedy
1744,"static bool pc_machine_get_nvdimm(Object *obj, Error **errp)

{

    PCMachineState *pcms = PC_MACHINE(obj);



    return pcms->nvdimm;

}
","static bool pc_machine_get_nvdimm(Object *tmp, Error **errp)

{

    PCMachineState *fcms = PC_MACHINE(tmp);



    return fcms->nvdimm;

}
",29.0,7.0,"pcms:fcms,obj:tmp,",72.0,0.0875831524531046,Greedy
1746,"static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)

{

    int v;

    int i = 0;

    uint8_t state[CONTEXT_SIZE];



    memset(state, 128, sizeof(state));



    for (v = 0; i < 128; v++) {

        unsigned len = get_symbol(c, state, 0) + 1;



        if (len > 128 - i)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_table[i] = scale * v;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        quant_table[256 - i] = -quant_table[i];

    quant_table[128] = -quant_table[127];



    return 2 * v - 1;

}
","static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)

{

    int v;

    int i = 0;

    uint8_t instance[CONTEXT_SIZE];



    memset(instance, 128, sizeof(instance));



    for (v = 0; i < 128; v++) {

        unsigned len = get_symbol(c, instance, 0) + 1;



        if (len > 128 - i)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_table[i] = scale * v;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        quant_table[256 - i] = -quant_table[i];

    quant_table[128] = -quant_table[127];



    return 2 * v - 1;

}
",146.0,37.0,"state:instance,",85.0,0.0988401651382446,Greedy
1754,"static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int tmp;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);

    if (tmp < min || tmp > max)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
","static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int  temporary;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

     temporary = strtol(value, &tailp, 0);

    if ( temporary < min ||  temporary > max)

        goto error;

    if (factor) {

        if (FFABS( temporary) > INT_MAX / FFABS(factor))

            goto error;

         temporary *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest =  temporary;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
",187.0,50.0,"tmp: temporary,",129.0,0.1340283672014872,Greedy
1761,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    int ich, i;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        pred[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            pred[ich] += s->channel_residues[i][icoef] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        pred[ich] += 1 << s->mclms_scaling - 1;

        pred[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][icoef] += pred[ich];

    }

}
","static void mclms_predict(WmallDecodeCtx *s, int coeb, int *fitted)

{

    int ich, chi;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        fitted[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (chi = 0; chi < order * num_channels; chi++)

            fitted[ich] += s->mclms_prevvalues[chi + s->mclms_recent] *

                         s->mclms_coeffs[chi + order * num_channels * ich];

        for (chi = 0; chi < ich; chi++)

            fitted[ich] += s->channel_residues[chi][coeb] *

                         s->mclms_coeffs_cur[chi + num_channels * ich];

        fitted[ich] += 1 << s->mclms_scaling - 1;

        fitted[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][coeb] += fitted[ich];

    }

}
",190.0,57.0,"icoef:coeb,pred:fitted,i:chi,",232.0,0.2360209107398986,Greedy
1763,"static int emulated_exitfn(CCIDCardState *base)

{

    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);

    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);



    vevent_queue_vevent(vevent); /* stop vevent thread */

    qemu_mutex_lock(&card->apdu_thread_quit_mutex);

    card->quit_apdu_thread = 1; /* stop handle_apdu thread */

    qemu_cond_signal(&card->handle_apdu_cond);

    qemu_cond_wait(&card->apdu_thread_quit_cond,

                      &card->apdu_thread_quit_mutex);

    /* handle_apdu thread stopped, can destroy all of it's mutexes */

    qemu_cond_destroy(&card->handle_apdu_cond);

    qemu_cond_destroy(&card->apdu_thread_quit_cond);

    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);

    qemu_mutex_destroy(&card->handle_apdu_mutex);

    qemu_mutex_destroy(&card->vreader_mutex);

    qemu_mutex_destroy(&card->event_list_mutex);

    return 0;

}
","static int emulated_exitfn(CCIDCardState *loop)

{

    EmulatedState *entry = DO_UPCAST(EmulatedState, loop, loop);

    VEvent * veevent = vevent_new(VEVENT_LAST, NULL, NULL);



    vevent_queue_vevent( veevent); /* stop vevent thread */

    qemu_mutex_lock(&entry->apdu_thread_quit_mutex);

    entry->quit_apdu_thread = 1; /* stop handle_apdu thread */

    qemu_cond_signal(&entry->handle_apdu_cond);

    qemu_cond_wait(&entry->apdu_thread_quit_cond,

                      &entry->apdu_thread_quit_mutex);

    /* handle_apdu thread stopped, can destroy all of it's mutexes */

    qemu_cond_destroy(&entry->handle_apdu_cond);

    qemu_cond_destroy(&entry->apdu_thread_quit_cond);

    qemu_mutex_destroy(&entry->apdu_thread_quit_mutex);

    qemu_mutex_destroy(&entry->handle_apdu_mutex);

    qemu_mutex_destroy(&entry->vreader_mutex);

    qemu_mutex_destroy(&entry->event_list_mutex);

    return 0;

}
",127.0,32.0,"base:loop,vevent: veevent,card:entry,",164.0,0.1654765327771504,Greedy
1772,"void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_8w_msa(src - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 8);

}
","void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *grad,

                                ptrdiff_t Strend)

{

    avc_luma_hv_qrt_8w_msa(grad - 2,

                           grad - (Strend * 2) +

                           sizeof(uint8_t), Strend, dst, Strend, 8);

}
",45.0,11.0,"stride:Strend,src:grad,",98.0,0.0995082855224609,Greedy
1778,"static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)

{

    SpiceTimer *timer;



    timer = qemu_mallocz(sizeof(*timer));

    timer->timer = qemu_new_timer(rt_clock, func, opaque);

    QTAILQ_INSERT_TAIL(&timers, timer, next);

    return timer;

}
","static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)

{

    SpiceTimer *tim;



    tim = qemu_mallocz(sizeof(*tim));

    tim->tim = qemu_new_timer(rt_clock, func, opaque);

    QTAILQ_INSERT_TAIL(&timers, tim, next);

    return tim;

}
",55.0,17.0,"timer:tim,",82.0,0.0805200179417928,Greedy
1783,"static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,

                           struct dirent *entry,

                           struct dirent **result)

{

    return readdir_r(fs->dir, entry, result);

}
","static int local_readdir_r(FsContext *rx, V9fsFidOpenState *df,

                           struct dirent *entry,

                           struct dirent **result)

{

    return readdir_r(df->dir, entry, result);

}
",37.0,9.0,"fs:df,ctx:rx,",75.0,0.070175019900004,Greedy
1785,"static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,

                                     unsigned size)

{

    MMIOState *s= opaque;

    return ide_status_read(&s->bus, 0);

}
","static uint64_t mmio_ide_status_read(void *copaco, target_phys_addr_t addr,

                                     unsigned size)

{

    MMIOState *session= copaco;

    return ide_status_read(&session->bus, 0);

}
",33.0,8.0,"opaque:copaco,s:session,",73.0,0.0713053663571675,Greedy
1786,"void tlb_flush_page(CPUState *env, target_ulong addr)

{

    int i;



#if defined(DEBUG_TLB)

    printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", addr);

#endif

    /* must reset current TB so that interrupts cannot modify the

       links while we are modifying them */

    env->current_tb = NULL;



    addr &= TARGET_PAGE_MASK;

    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    tlb_flush_entry(&env->tlb_table[0][i], addr);

    tlb_flush_entry(&env->tlb_table[1][i], addr);

#if (NB_MMU_MODES >= 3)

    tlb_flush_entry(&env->tlb_table[2][i], addr);

#if (NB_MMU_MODES == 4)

    tlb_flush_entry(&env->tlb_table[3][i], addr);

#endif

#endif



    tlb_flush_jmp_cache(env, addr);



#ifdef USE_KQEMU

    if (env->kqemu_enabled) {

        kqemu_flush_page(env, addr);

    }

#endif

}
","void tlb_flush_page(CPUState *output, target_ulong xp)

{

    int cli;



#if defined(DEBUG_TLB)

    printf(""tlb_flush_page: "" TARGET_FMT_lx ""
"", xp);

#endif

    /* must reset current TB so that interrupts cannot modify the

       links while we are modifying them */

    output->current_tb = NULL;



    xp &= TARGET_PAGE_MASK;

  cli i = (xp >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    tlb_flush_entry(&output->tlb_table[0cli[i], xp);

    tlb_flush_entry(&output->tlb_table[1cli[i], xp);

#if (NB_MMU_MODES >= 3)

    tlb_flush_entry(&output->tlb_table[2cli[i], xp);

#if (NB_MMU_MODES == 4)

    tlb_flush_entry(&output->tlb_table[3cli[i], xp);

#endif

#endif



    tlb_flush_jmp_cache(output, xp);



#ifdef USE_KQEMU

    if (output->kqemu_enabled) {

        kqemu_flush_page(output, xp);

    }

#endif

}
",163.0,41.0,"env:output,addr:xp,i:cli,",348.0,0.37174600760142,GA
1788,"static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,

                            AVPacket *avpkt)

{

    const char *ptr = avpkt->data;

    int len, size = avpkt->size;



    while (size > 0) {

        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);

        int duration = dialog->end - dialog->start;

        len = ff_ass_add_rect(data, ptr, 0, duration, 1);

        if (len < 0)

            return len;

        ptr  += len;

        size -= len;

    }



    *got_sub_ptr = avpkt->size > 0;

    return avpkt->size;

}
","static int ass_decode_frame(AVCodecContext *avctx, void *type, int *got_sub_pointer,

                            AVPacket *avpkt)

{

    const char *point = avpkt->type;

    int len, size = avpkt->size;



    while (size > 0) {

        ASSDialog *dialocation = ff_ass_split_dialog(avctx->priv_data, point, 0, NULL);

        int duration = dialocation->end - dialocation->start;

        len = ff_ass_add_rect(type, point, 0, duration, 1);

        if (len < 0)

            return len;

        point  += len;

        size -= len;

    }



    *got_sub_pointer = avpkt->size > 0;

    return avpkt->size;

}
",122.0,32.0,"got_sub_ptr:got_sub_pointer,data:type,dialog:dialocation,ptr:point,",182.0,0.1888548970222473,Greedy
1791,"static void test_dispatch_cmd_failure(void)

{

    QDict *req = qdict_new();


    QObject *resp;



    qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd2"")));



    resp = qmp_dispatch(QOBJECT(req));

    assert(resp != NULL);

    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));



    qobject_decref(resp);

    QDECREF(req);



    /* check that with extra arguments it throws an error */

    req = qdict_new();

    qdict_put(args, ""a"", qint_from_int(66));

    qdict_put(req, ""arguments"", args);



    qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd"")));



    resp = qmp_dispatch(QOBJECT(req));

    assert(resp != NULL);

    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));



    qobject_decref(resp);

    QDECREF(req);

}","static void test_dispatch_cmd_failure(void)

{

    QDict *report = qdict_new();


    QObject *resp;



    qdict_put_obj(report, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd2"")));



    resp = qmp_dispatch(QOBJECT(report));

    assert(resp != NULL);

    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));



    qobject_decref(resp);

    QDECREF(report);



    /* check that with extra arguments it throws an error */

    report = qdict_new();

    qdict_put(args, ""a"", qint_from_int(66));

    qdict_put(report, ""arguments"", args);



    qdict_put_obj(report, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd"")));



    resp = qmp_dispatch(QOBJECT(report));

    assert(resp != NULL);

    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));



    qobject_decref(resp);

    QDECREF(report);

}",165.0,48.0,"req:report,",101.0,0.1077779412269592,Greedy
1800,"static void ffm_write_data(AVFormatContext *s,

                           const uint8_t *buf, int size,

                           int64_t pts, int header)

{

    FFMContext *ffm = s->priv_data;

    int len;



    if (header && ffm->frame_offset == 0) {

        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;

        ffm->pts = pts;

    }



    /* write as many packets as needed */

    while (size > 0) {

        len = ffm->packet_end - ffm->packet_ptr;

        if (len > size)

            len = size;

        memcpy(ffm->packet_ptr, buf, len);



        ffm->packet_ptr += len;

        buf += len;

        size -= len;

        if (ffm->packet_ptr >= ffm->packet_end) {

            /* special case : no pts in packet : we leave the current one */

            if (ffm->pts == 0)

                ffm->pts = pts;



            flush_packet(s);

        }

    }

}
","static void ffm_write_data(AVFormatContext *s,

                           const uint8_t *buf, int scale,

                           int64_t pts, int header)

{

    FFMContext *ppm = s->priv_data;

    int rev;



    if (header && ppm->frame_offset == 0) {

        ppm->frame_offset = ppm->packet_ptr - ppm->packet + FFM_HEADER_SIZE;

        ppm->pts = pts;

    }



    /* write as many packets as needed */

    while (scale > 0) {

        rev = ppm->packet_end - ppm->packet_ptr;

        if (rev > scale)

            rev = scale;

        memcpy(ppm->packet_ptr, buf, rev);



        ppm->packet_ptr += rev;

        buf += rev;

        scale -= rev;

        if (ppm->packet_ptr >= ppm->packet_end) {

            /* special case : no pts in packet : we leave the current one */

            if (ppm->pts == 0)

                ppm->pts = pts;



            flush_packet(s);

        }

    }

}
",151.0,42.0,"ffm:ppm,len:rev,size:scale,",269.0,0.2281437794367472,Greedy
1804,"int nbd_client_session_co_flush(NbdClientSession *client)

{

    struct nbd_request request;

    struct nbd_reply reply;

    ssize_t ret;



    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {

        return 0;

    }



    request.type = NBD_CMD_FLUSH;

    if (client->nbdflags & NBD_FLAG_SEND_FUA) {

        request.type |= NBD_CMD_FLAG_FUA;

    }



    request.from = 0;

    request.len = 0;



    nbd_coroutine_start(client, &request);

    ret = nbd_co_send_request(client, &request, NULL, 0);

    if (ret < 0) {

        reply.error = -ret;

    } else {

        nbd_co_receive_reply(client, &request, &reply, NULL, 0);

    }

    nbd_coroutine_end(client, &request);

    return -reply.error;

}
","int nbd_client_session_co_flush(NbdClientSession *client)

{

    struct nbd_request request;

    struct nbd_reply reply;

    ssize_t fun;



    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {

        return 0;

    }



    request.type = NBD_CMD_FLUSH;

    if (client->nbdflags & NBD_FLAG_SEND_FUA) {

        request.type |= NBD_CMD_FLAG_FUA;

    }



    request.from = 0;

    request.len = 0;



    nbd_coroutine_start(client, &request);

    fun = nbd_co_send_request(client, &request, NULL, 0);

    if (fun < 0) {

        reply.error = -fun;

    } else {

        nbd_co_receive_reply(client, &request, &reply, NULL, 0);

    }

    nbd_coroutine_end(client, &request);

    return -reply.error;

}
",139.0,33.0,"ret:fun,",88.0,0.0817745645840962,Greedy
1810,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
","static void qobject_input_type_bool(Visitor *t, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(t);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
",102.0,27.0,"v:t,",59.0,0.0661194165547688,Greedy
1812,"int select_watchdog(const char *p)

{

    WatchdogTimerModel *model;

    QemuOpts *opts;



    /* -watchdog ? lists available devices and exits cleanly. */

    if (strcmp(p, ""?"") == 0) {

        LIST_FOREACH(model, &watchdog_list, entry) {

            fprintf(stderr, ""\t%s\t%s\n"",

                     model->wdt_name, model->wdt_description);

        }

        return 2;

    }



    LIST_FOREACH(model, &watchdog_list, entry) {

        if (strcasecmp(model->wdt_name, p) == 0) {

            /* add the device */

            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);

            qemu_opt_set(opts, ""driver"", p);

            return 0;

        }

    }



    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");

    LIST_FOREACH(model, &watchdog_list, entry) {

        fprintf(stderr, ""\t%s\t%s\n"",

                 model->wdt_name, model->wdt_description);

    }

    return 1;

}
","int select_watchdog(const char *p)

{

    WatchdogTimerModel *db;

    QemuOpts *opts;



    /* -watchdog ? lists available devices and exits cleanly. */

    if (strcmp(p, ""?"") == 0) {

        LIST_FOREACH(db, &watchdog_list, entry) {

            fprintf(stderr, ""\t%s\t%s\n"",

                     db->wdt_name, db->wdt_description);

        }

        return 2;

    }



    LIST_FOREACH(db, &watchdog_list, entry) {

        if (strcasecmp(db->wdt_name, p) == 0) {

            /* add the device */

            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);

            qemu_opt_set(opts, ""driver"", p);

            return 0;

        }

    }



    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");

    LIST_FOREACH(db, &watchdog_list, entry) {

        fprintf(stderr, ""\t%s\t%s\n"",

                 db->wdt_name, db->wdt_description);

    }

    return 1;

}
",161.0,37.0,"model:db,",101.0,0.1232905109723409,Greedy
1815,"static void blk_send(QEMUFile *f, BlkMigBlock * blk)

{

    int len;

    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;



    if (block_mig_state.zero_blocks &&

        buffer_is_zero(blk->buf, BLOCK_SIZE)) {

        flags |= BLK_MIG_FLAG_ZERO_BLOCK;

    }



    /* sector number and flags */

    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)

                     | flags);



    /* device name */

    len = strlen(bdrv_get_device_name(blk->bmds->bs));

    qemu_put_byte(f, len);

    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);



    /* if a block is zero we need to flush here since the network

     * bandwidth is now a lot higher than the storage device bandwidth.

     * thus if we queue zero blocks we slow down the migration */

    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {

        qemu_fflush(f);

        return;

    }



    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);

}
","static void blk_send(QEMUFile *f, BlkMigBlock * blk)

{

    int lon;

    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;



    if (block_mig_state.zero_blocks &&

        buffer_is_zero(blk->buf, BLOCK_SIZE)) {

        flags |= BLK_MIG_FLAG_ZERO_BLOCK;

    }



    /* sector number and flags */

    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)

                     | flags);



    /* device name */

    lon = strlen(bdrv_get_device_name(blk->bmds->bs));

    qemu_put_byte(f, lon);

    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), lon);



    /* if a block is zero we need to flush here since the network

     * bandwidth is now a lot higher than the storage device bandwidth.

     * thus if we queue zero blocks we slow down the migration */

    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {

        qemu_fflush(f);

        return;

    }



    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);

}
",125.0,37.0,"len:lon,",71.0,0.0756676038106282,Greedy
1817,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}
","int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *function, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, function, string);

}
",57.0,17.0,"property:function,",57.0,0.0609389066696166,Greedy
1818,"static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,

                                         uint32_t *sums, int n, int pred_order)

{

    int i;

    int k, cnt, part;

    uint32_t all_bits;



    part     = (1 << porder);

    all_bits = 4 * part;



    cnt = (n >> porder) - pred_order;

    for (i = 0; i < part; i++) {

        k = find_optimal_param(sums[i], cnt);

        rc->params[i] = k;

        all_bits += rice_encode_count(sums[i], cnt, k);

        cnt = n >> porder;

    }



    rc->porder = porder;



    return all_bits;

}
","static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,

                                         uint32_t * samples, int span, int Pred_orders)

{

    int i;

    int ek, cnt, type;

    uint32_t all_bits;



    type     = (1 << porder);

    all_bits = 4 * type;



    cnt = (span >> porder) - Pred_orders;

    for (i = 0; i < type; i++) {

        ek = find_optimal_param( samples[i], cnt);

        rc->params[i] = ek;

        all_bits += rice_encode_count( samples[i], cnt, ek);

        cnt = span >> porder;

    }



    rc->porder = porder;



    return all_bits;

}
",125.0,43.0,"pred_order:Pred_orders,n:span,k:ek,part:type,sums: samples,",257.0,0.243377681573232,Greedy
1821,"static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)

{

    if (index < MAX_TL_ENTRIES) {

        memory_region_set_enabled(&s->dma_mrs[index], false);

    }



    if (!frame) {

        return;

    }



    if (index >= MAX_TL_ENTRIES) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      index, MAX_TL_ENTRIES);

        return;

    }

    memory_region_set_alias_offset(&s->dma_mrs[index], frame);

    memory_region_set_enabled(&s->dma_mrs[index], true);

}
","static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t raise)

{

    if (index < MAX_TL_ENTRIES) {

        memory_region_set_enabled(&s->dma_mrs[index], false);

    }



    if (!raise) {

        return;

    }



    if (index >= MAX_TL_ENTRIES) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      index, MAX_TL_ENTRIES);

        return;

    }

    memory_region_set_alias_offset(&s->dma_mrs[index], raise);

    memory_region_set_enabled(&s->dma_mrs[index], true);

}
",96.0,23.0,"frame:raise,",66.0,0.0569488604863484,Greedy
1822,"static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,

                                              VirtQueue *vq)

{

    VirtIOSCSI *s = (VirtIOSCSI *)vdev;



    assert(s->ctx && s->dataplane_started);

    return virtio_scsi_handle_cmd_vq(s, vq);

}
","static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *lprom,

                                              VirtQueue *guque)

{

    VirtIOSCSI *spec = (VirtIOSCSI *)lprom;



    assert(spec->ctx && spec->dataplane_started);

    return virtio_scsi_handle_cmd_vq(spec, guque);

}
",43.0,11.0,"vdev:lprom,vq:guque,s:spec,",119.0,0.0951385895411173,Greedy
1838,"static int ftp_passive_mode_epsv(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    static const char d = '|';

    static const char *command = ""EPSV\r\n"";

    static const int epsv_codes[] = {229, 0};



    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '(') {

            start = res + i + 1;

        } else if (res[i] == ')') {

            end = res + i;

            break;

        }

    }

    if (!start || !end)

        goto fail;



    *end = '\0';

    if (strlen(start) < 5)

        goto fail;

    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)

        goto fail;

    start += 3;

    end[-1] = '\0';



    s->server_data_port = atoi(start);

    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);



    av_free(res);

    return 0;



  fail:

    av_free(res);

    s->server_data_port = -1;

    return AVERROR(ENOSYS);

}
","static int ftp_passive_mode_epsv(FTPContext *s)

{

    char *des = NULL, *start = NULL, *end = NULL;

    int c;

    static const char d = '|';

    static const char *command = ""EPSV\r\n"";

    static const int epsv_codes[] = {229, 0};



    if (ftp_send_command(s, command, epsv_codes, &des) != 229 || !des)

        goto fail;



    for (c = 0; des[c]; ++c) {

        if (des[c] == '(') {

            start = des + c + 1;

        } else if (des[c] == ')') {

            end = des + c;

            break;

        }

    }

    if (!start || !end)

        goto fail;



    *end = '\0';

    if (strlen(start) < 5)

        goto fail;

    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)

        goto fail;

    start += 3;

    end[-1] = '\0';



    s->server_data_port = atoi(start);

    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);



    av_free(des);

    return 0;



  fail:

    av_free(des);

    s->server_data_port = -1;

    return AVERROR(ENOSYS);

}
",265.0,57.0,"i:c,res:des,",176.0,0.1895654360453287,Greedy
1839,"static void qemu_enqueue_packet(VLANClientState *sender,

                                const uint8_t *buf, int size,

                                NetPacketSent *sent_cb)

{

    VLANPacket *packet;



    packet = qemu_malloc(sizeof(VLANPacket) + size);

    packet->sender = sender;

    packet->size = size;

    packet->sent_cb = sent_cb;

    memcpy(packet->data, buf, size);



    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);

}
","static void qemu_enqueue_packet(VLANClientState *dendor,

                                const uint8_t *buf, int source,

                                NetPacketSent *sent_cb)

{

    VLANPacket *compat;



    compat = qemu_malloc(sizeof(VLANPacket) + source);

    compat->dendor = dendor;

    compat->source = source;

    compat->sent_cb = sent_cb;

    memcpy(compat->data, buf, source);



    TAILQ_INSERT_TAIL(&dendor->vlan->send_queue, compat, entry);

}
",81.0,24.0,"packet:compat,size:source,sender:dendor,",178.0,0.1842462976773579,Greedy
1845,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(src2 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i < w; i++)

        dst[i] = src1[i] + src2[i];

}
","static void add_bytes_l2_c(uint8_t *udbl, uint8_t *src0, uint8_t *load2, int wave)

{

    long gi;

    for (gi = 0; gi <= wave - sizeof(long); gi += sizeof(long)) {

        long a = *(long *)(src0 + gi);

        long b = *(long *)(load2 + gi);

        *(long *)(udbl + gi) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; gi < wave; gi++)

        udbl[gi] = src0[gi] + load2[gi];

}
",136.0,34.0,"src2:load2,dst:udbl,w:wave,src1:src0,i:gi,",233.0,0.241236658891042,Greedy
1851,"static int tpm_passthrough_unix_transfer(int tpm_fd,

                                         const TPMLocality *locty_data)

{

    return tpm_passthrough_unix_tx_bufs(tpm_fd,

                                        locty_data->w_buffer.buffer,

                                        locty_data->w_offset,

                                        locty_data->r_buffer.buffer,

                                        locty_data->r_buffer.size);

}
","static int tpm_passthrough_unix_transfer(int tpm_fd,

                                         const TPMLocality *loctory_writer)

{

    return tpm_passthrough_unix_tx_bufs(tpm_fd,

                                        loctory_writer->w_buffer.buffer,

                                        loctory_writer->w_offset,

                                        loctory_writer->r_buffer.buffer,

                                        loctory_writer->r_buffer.size);

}
",42.0,9.0,"locty_data:loctory_writer,",67.0,0.0702331701914469,Greedy
1856,"static inline unsigned int msi_nr_vectors(uint16_t flags)

{

    return 1U <<

        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));

}
","static inline unsigned int msi_nr_vectors(uint16_t values)

{

    return 1U <<

        ((values & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));

}
",31.0,6.0,"flags:values,",47.0,0.0381186445554097,Greedy
1862,"static void test_validate_fail_union_anon(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefAnonUnion *tmp = NULL;

    Visitor *v;

    Error *errp = NULL;



    v = validate_test_init(data, ""3.14"");



    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefAnonUnion(tmp);

}
","static void test_validate_fail_union_anon(TestInputVisitorData *init,

                                          const void *unused)

{

    UserDefAnonUnion *tmp = NULL;

    Visitor *v;

    Error *errp = NULL;



    v = validate_test_init(init, ""3.14"");



    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefAnonUnion(tmp);

}
",68.0,18.0,"data:init,",56.0,0.0543734073638916,Greedy
1868,"void migrate_fd_connect(MigrationState *s)

{

    s->state = MIG_STATE_SETUP;

    trace_migrate_set_state(MIG_STATE_SETUP);



    /* This is a best 1st approximation. ns to ms */

    s->expected_downtime = max_downtime/1000000;

    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);



    qemu_file_set_rate_limit(s->file,

                             s->bandwidth_limit / XFER_LIMIT_RATIO);



    qemu_thread_create(&s->thread, migration_thread, s,

                       QEMU_THREAD_JOINABLE);

    notifier_list_notify(&migration_state_notifiers, s);

}
","void migrate_fd_connect(MigrationState *services)

{

    services->state = MIG_STATE_SETUP;

    trace_migrate_set_state(MIG_STATE_SETUP);



    /* This is a best 1st approximation. ns to ms */

    services->expected_downtime = max_downtime/1000000;

    services->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, services);



    qemu_file_set_rate_limit(services->file,

                             services->bandwidth_limit / XFER_LIMIT_RATIO);



    qemu_thread_create(&services->thread, migration_thread, services,

                       QEMU_THREAD_JOINABLE);

    notifier_list_notify(&migration_state_notifiers, services);

}
",74.0,24.0,"s:services,",81.0,0.062760309378306,Greedy
1870,"static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,

                                unsigned size)

{

    CMD646BAR *cmd646bar = opaque;



    if (addr != 2 || size != 1) {

        return ((uint64_t)1 << (size * 8)) - 1;

    }

    return ide_status_read(cmd646bar->bus, addr + 2);

}
","static uint64_t cmd646_cmd_read(void *opusaque, target_phys_addr_t oa,

                                unsigned or)

{

    CMD646BAR *cmcmd626bars opusaque;



    if (oa != 2 || or != 1) {

        return ((uint64_t)1 << (or * 8)) - 1;

    }

    return ide_status_reacmd626barsar->bus, oa + 2);

}
",62.0,12.0,"opaque:opusaque,addr:oa,size:or,cmd646bar:cmd626bars,",284.0,0.256150996685028,GA
1878,"void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,

        int flags)

{

    int i;



    cpu_fprintf(f, ""PC=%08x\n"", env->pc);



    for (i = 0; i < 16; ++i) {

        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],

                (i % 4) == 3 ? '\n' : ' ');

    }

}
","void cpu_dump_state(CPUState *db, FILE *m, fprintf_function cpu_rfcall,

        int flags)

{

    int m;



    cpu_rfcall(m, ""PC=%08x\n"", db->pc);



    for (m = 0; m < 16; ++m) {

        cpu_rfcall(m, ""A%02d=%08x%c"", m, db->regs[m],

                (m % 4) == 3 ? '\n' : ' ');

    }

}
",82.0,18.0,"cpu_fprintf:cpu_rfcall,f:m,i:m,env:db,",200.0,0.1581836740175883,Greedy
1880,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_bool(v, obj, name, errp);

    }

}
","void visit_type_bool(Visitor *v, bool *api, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_bool(v, api, name, errp);

    }

}
",46.0,12.0,"obj:api,",51.0,0.0558859229087829,Greedy
1881,"static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)

{

    int d;

    for( d = 0; d < 8; d++ ) {

        const int p0 = pix[-1*xstride];

        const int p1 = pix[-2*xstride];

        const int q0 = pix[0];

        const int q1 = pix[1*xstride];



        if( FFABS( p0 - q0 ) < alpha &&

            FFABS( p1 - p0 ) < beta &&

            FFABS( q1 - q0 ) < beta ) {



            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;   /* p0' */

            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;   /* q0' */

        }

        pix += ystride;

    }

}
","static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstice, int ystride, int alpha, int )

{

    int dc;

    for( dc = 0; dc < 8; dc++ ) {

        const int p0 = pix[-1*xstice];

        const int p1 = pix[-2*xstice];

        const int q0 = pix[0];

        const int q1 = pix[1*xstice];



        if( FFABS( p0 - q0 ) < alpha &&

            FFABS( p1 - p0 ) <  &&

            FFABS( q1 - q0 ) <  ) {



            pix[-xstice] = ( 2*p1 + p0 + q1 + 2 ) >> 2;   /* p0' */

            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;   /* q0' */

        }

        pix += ystride;

    }

}
",159.0,45.0,"d:dc,xstride:xstice,beta:,",176.0,0.1801686644554138,Greedy
1893,"static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)

{

    S390pciState *s = opaque;



    return &s->pbdev[PCI_SLOT(devfn)].as;

}
","static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *ospulence, int devfn)

{

    S390pciState *secondary = ospulence;



    return &secondary->pbdev[PCI_SLOT(devfn)].as;

}
",38.0,9.0,"s:secondary,opaque:ospulence,",76.0,0.0638248880704244,Greedy
1895,"static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)

{

    uint8_t *old_code_ptr = s->code_ptr;

    assert(ret != arg);

#if TCG_TARGET_REG_BITS == 32

    tcg_out_op_t(s, INDEX_op_mov_i32);

#else

    tcg_out_op_t(s, INDEX_op_mov_i64);

#endif

    tcg_out_r(s, ret);

    tcg_out_r(s, arg);

    old_code_ptr[1] = s->code_ptr - old_code_ptr;

}
","static void tcg_out_mov(TCGContext *s, TCGType spec, TCGReg mem, TCGReg orig)

{

    uint8_t *old_coderep = s->code_ptr;

    assert(mem != orig);

#if TCG_TARGET_REG_BITS == 32

    tcg_out_op_t(s, INDEX_op_mov_i32);

#else

    tcg_out_op_t(s, INDEX_op_mov_i64);

#endif

    tcg_out_r(s, mem);

    tcg_out_r(s, orig);

    old_coderep[1] = s->code_ptr - old_coderep;

}
",80.0,26.0,"s:s,ret:mem,arg:orig,old_code_ptr:old_coderep,type:spec,",216.0,0.1986961483955383,Greedy
1903,"static void flush_queued_data(VirtIOSerialPort *port, bool discard)

{

    assert(port || discard);



    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);

}
","static void flush_queued_data(VirtIOSerialPort *port, bool  disccard)

{

    assert(port ||  disccard);



    do_flush_queued_data(port, port->ovq, &port->vser->vdev,  disccard);

}
",38.0,11.0,"discard: disccard,",42.0,0.0443656245867411,Greedy
1915,"static av_cold int dvdsub_close(AVCodecContext *avctx)

{

    DVDSubContext *ctx = avctx->priv_data;

    av_freep(&ctx->buf);

    ctx->buf_size = 0;

    return 0;

}
","static av_cold int dvdsub_close(AVCodecContext * avcontext)

{

    DVDSubContext *data =  avcontext->priv_data;

    av_freep(&data->buf);

    data->buf_size = 0;

    return 0;

}
",36.0,8.0,"avctx: avcontext,ctx:data,",73.0,0.0771263003349304,Greedy
1916,"static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);

    int start_track, format, msf, toclen;

    uint64_t nb_sectors;



    msf = req->cmd.buf[1] & 2;

    format = req->cmd.buf[2] & 0xf;

    start_track = req->cmd.buf[6];

    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);

    nb_sectors /= s->qdev.blocksize / 512;

    switch (format) {

    case 0:

        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);

        break;

    case 1:

        /* multi session : only a single session defined */

        toclen = 12;

        memset(outbuf, 0, 12);

        outbuf[1] = 0x0a;

        outbuf[2] = 0x01;

        outbuf[3] = 0x01;

        break;

    case 2:

        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);

        break;

    default:

        return -1;

    }

    return toclen;

}
","static int scsi_disk_emulate_read_toc(SCSIRequest *rob, uint8_t *cachecv)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, rob->dev);

    int start_mode, pad, msf, discln;

    uint64_t nb_megments;



    msf = rob->cmd.buf[1] & 2;

    pad = rob->cmd.buf[2] & 0xf;

    start_mode = rob->cmd.buf[6];

    bdrv_get_geometry(s->qdev.conf.bs, &nb_megments);

    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_mode, pad, msf >> 1);

    nb_megments /= s->qdev.blocksize / 512;

    switch (pad) {

    case 0:

        discln = cdrom_read_toc(nb_megments, cachecv, msf, start_mode);

        break;

    case 1:

        /* multi session : only a single session defined */

        discln = 12;

        memset(cachecv, 0, 12);

        cachecv[1] = 0x0a;

        cachecv[2] = 0x01;

        cachecv[3] = 0x01;

        break;

    case 2:

        discln = cdrom_read_toc_raw(nb_megments, cachecv, msf, start_mode);

        break;

    default:

        return -1;

    }

    return discln;

}
",206.0,48.0,"format:pad,nb_sectors:nb_megments,req:rob,toclen:discln,start_track:start_mode,outbuf:cachecv,",330.0,0.3064958532651265,Greedy
1919,"static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)

{

    int rd = (insn >> 0) & 0xf;

    TCGv tmp;



    if (insn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            tmp = iwmmxt_load_creg(rd);

        }

    } else {

        tmp = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(tmp, cpu_V0);

    }

    tcg_gen_andi_i32(tmp, tmp, mask);

    tcg_gen_mov_i32(dest, tmp);

    dead_tmp(tmp);

    return 0;

}
","static inline int gen_iwmmxt_shift(uint32_t outsnot, uint32_t gate, TCGv class)

{

    int rd = (outsnot >> 0) & 0xf;

    TCGv dd;



    if (outsnot & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            dd = iwmmxt_load_creg(rd);

        }

    } else {

        dd = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(dd, cpu_V0);

    }

    tcg_gen_andi_i32(dd, dd, gate);

    tcg_gen_mov_i32(class, dd);

    dead_tmp(dd);

    return 0;

}
",114.0,32.0,"dest:class,mask:gate,insn:outsnot,tmp:dd,",209.0,0.1686602592468261,Greedy
1923,"static int get_htab_fd(sPAPRMachineState *spapr)

{

    if (spapr->htab_fd >= 0) {

        return spapr->htab_fd;

    }



    spapr->htab_fd = kvmppc_get_htab_fd(false);

    if (spapr->htab_fd < 0) {

        error_report(""Unable to open fd for reading hash table from KVM: %s"",

                     strerror(errno));

    }



    return spapr->htab_fd;

}
","static int get_htab_fd(sPAPRMachineState *spaxpr)

{

    if (spaxpr->htab_fd >= 0) {

        return spaxpr->htab_fd;

    }



    spaxpr->htab_fd = kvmppc_get_htab_fd(false);

    if (spaxpr->htab_fd < 0) {

        error_report(""Unable to open fd for reading hash table from KVM: %s"",

                     strerror(errno));

    }



    return spaxpr->htab_fd;

}
",60.0,11.0,"spapr:spaxpr,",126.0,0.0883473515510559,Greedy
1931,"static int parse_uint16(DeviceState *dev, Property *prop, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
","static int parse_uint16(DeviceState *dev, Property *prot, const char *str)

{

    uint16_t *func = qdev_get_prop_ptr(dev, prot);

    const char *ftr;



    /* accept both hex and decimal */

    ftr = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, ftr, func) != 1)

        return -EINVAL;

    return 0;

}
",77.0,19.0,"prop:prot,fmt:ftr,ptr:func,",120.0,0.1163151582082112,Greedy
1935,"void replay_input_event(QemuConsole *src, InputEvent *evt)

{

    if (replay_mode == REPLAY_MODE_PLAY) {

        /* Nothing */

    } else if (replay_mode == REPLAY_MODE_RECORD) {

        replay_add_input_event(qapi_clone_InputEvent(evt));

    } else {

        qemu_input_event_send_impl(src, evt);

    }

}
","void replay_input_event(QemuConsole *src, InputEvent *epp)

{

    if (replay_mode == REPLAY_MODE_PLAY) {

        /* Nothing */

    } else if (replay_mode == REPLAY_MODE_RECORD) {

        replay_add_input_event(qapi_clone_InputEvent(epp));

    } else {

        qemu_input_event_send_impl(src, epp);

    }

}
",48.0,13.0,"evt:epp,",48.0,0.0516416907310485,Greedy
1936,"static inline unsigned int get_uint(ShortenContext *s, int k)

{

    if (s->version != 0)

        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);

    return get_ur_golomb_shorten(&s->gb, k);

}
","static inline unsigned int get_uint(ShortenContext *s, int ek)

{

    if (s->version != 0)

        ek = get_ur_golomb_shorten(&s->gb, ULONGSIZE);

    return get_ur_golomb_shorten(&s->gb, ek);

}
",46.0,11.0,"k:ek,",49.0,0.0497809449831644,Greedy
1944,"static int compare_codec_desc(const void *a, const void *b)

{

    const AVCodecDescriptor * const *da = a;

    const AVCodecDescriptor * const *db = b;



    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :

           strcmp((*da)->name, (*db)->name);

}
","static int compare_codec_desc(const void *ae, const void *wb)

{

    const AVCodecDescriptor * const *lambda = ae;

    const AVCodecDescriptor * const *ab = wb;



    return (*lambda)->type != (*ab)->type ? (*lambda)->type - (*ab)->type :

           strcmp((*lambda)->name, (*ab)->name);

}
",80.0,14.0,"a:ae,b:wb,da:lambda,db:ab,",168.0,0.1691795627276102,Greedy
1948,"static void wdt_diag288_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    DIAG288Class *diag288 = DIAG288_CLASS(klass);



    dc->realize = wdt_diag288_realize;

    dc->unrealize = wdt_diag288_unrealize;

    dc->reset = wdt_diag288_reset;


    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->vmsd = &vmstate_diag288;

    diag288->handle_timer = wdt_diag288_handle_timer;

}","static void wdt_diag288_class_init(ObjectClass *Klass, void *exec)

{

    DeviceClass *fc = DEVICE_CLASS(Klass);

    DIAG288Class *Diag142 = DIAG288_CLASS(Klass);



    fc->realize = wdt_diag288_realize;

    fc->unrealize = wdt_diag288_unrealize;

    fc->reset = wdt_diag288_reset;


    set_bit(DEVICE_CATEGORY_MISC, fc->categories);

    fc->vmsd = &vmstate_diag288;

    Diag142->handle_timer = wdt_diag288_handle_timer;

}",72.0,22.0,"data:exec,klass:Klass,diag288:Diag142,dc:fc,",158.0,0.1598554770151774,Greedy
1955,"static void flatview_ref(FlatView *view)

{

    atomic_inc(&view->ref);

}
","static void flatview_ref(FlatView *event)

{

    atomic_inc(&event->ref);

}
",18.0,4.0,"view:event,",45.0,0.0529248197873433,Greedy
1956,"static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}","static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t tymes[1024];

    uint32_t type;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    type = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = type >> (32 - he[i].len);

        bits[i]  = he[i].len;

        tymes[i]  = he[i].sym;

        type += 0x80000000u >> (he[i].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              tymes,  sizeof(*tymes),  sizeof(*tymes), 0);

}",238.0,58.0,"code:type,syms:tymes,",167.0,0.1946008404095967,Greedy
1957,"static void test_task_complete(void)

{

    QIOTask *task;

    Object *obj = object_new(TYPE_DUMMY);

    Object *src;

    struct TestTaskData data = { NULL, NULL, false };



    task = qio_task_new(obj, task_callback, &data, NULL);

    src = qio_task_get_source(task);



    qio_task_complete(task);



    g_assert(obj == src);



    object_unref(obj);

    object_unref(src);



    g_assert(data.source == obj);

    g_assert(data.err == NULL);

    g_assert(data.freed == false);

}
","static void test_task_complete(void)

{

    QIOTask *task;

    Object *j = object_new(TYPE_DUMMY);

    Object *src;

    struct TestTaskData data = { NULL, NULL, false };



    task = qio_task_new(j, task_callback, &data, NULL);

    src = qio_task_get_source(task);



    qio_task_complete(task);



    g_assert(j == src);



    object_unref(j);

    object_unref(src);



    g_assert(data.source == j);

    g_assert(data.err == NULL);

    g_assert(data.freed == false);

}
",107.0,31.0,"obj:j,",71.0,0.0822643121083577,Greedy
1965,"static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)

{

    if (throttle_conflicting(cfg, errp)) {

        return false;

    }



    if (!throttle_is_valid(cfg, errp)) {

        return false;

    }



    if (throttle_max_is_missing_limit(cfg, errp)) {

        return false;

    }



    return true;

}
","static bool check_throttle_config(ThrottleConfig *org, Error **errp)

{

    if (throttle_conflicting(org, errp)) {

        return false;

    }



    if (!throttle_is_valid(org, errp)) {

        return false;

    }



    if (throttle_max_is_missing_limit(org, errp)) {

        return false;

    }



    return true;

}
",61.0,12.0,"cfg:org,",60.0,0.0481639186541239,Greedy
1969,"static void cpu_devinit(const char *cpu_model, unsigned int id,

                        uint64_t prom_addr, qemu_irq **cpu_irqs)

{

    CPUState *cs;

    SPARCCPU *cpu;

    CPUSPARCState *env;



    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""qemu: Unable to find Sparc CPU definition\n"");

        exit(1);

    }

    env = &cpu->env;



    cpu_sparc_set_id(env, id);

    if (id == 0) {

        qemu_register_reset(main_cpu_reset, cpu);

    } else {

        qemu_register_reset(secondary_cpu_reset, cpu);

        cs = CPU(cpu);

        cs->halted = 1;

    }

    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);

    env->prom_addr = prom_addr;

}
","static void cpu_devinit(const char *processor_block, unsigned int uri,

                        uint64_t Prom_address, qemu_irq **cpu__irqs)

{

    CPUState *cs;

    SPARCCPU *cpu;

    CPUSPARCState *env;



    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, processor_block));

    if (cpu == NULL) {

        fprintf(stderr, ""qemu: Unable to find Sparc CPU definition\n"");

        exit(1);

    }

    env = &cpu->env;



    cpu_sparc_set_id(env, uri);

    if (uri == 0) {

        qemu_register_reset(main_cpu_reset, cpu);

    } else {

        qemu_register_reset(secondary_cpu_reset, cpu);

        cs = CPU(cpu);

        cs->halted = 1;

    }

    *cpu__irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);

    env->Prom_address = Prom_address;

}
",139.0,40.0,"cpu_model:processor_block,prom_addr:Prom_address,cpu_irqs:cpu__irqs,id:uri,",149.0,0.1422798117001851,Greedy
1971,"static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)

{

    int i;



    if ((p[1] & 0xF) == 3) {

        /* NAA designator type */

        if (p[3] != 8) {

            return -EINVAL;

        }

        *p_wwn = ldq_be_p(p + 4);

        return 0;

    }



    if ((p[1] & 0xF) == 8) {

        /* SCSI name string designator type */

        if (p[3] < 20 || memcmp(&p[4], ""naa."", 4)) {

            return -EINVAL;

        }

        if (p[3] > 20 && p[24] != ',') {

            return -EINVAL;

        }

        *p_wwn = 0;

        for (i = 8; i < 24; i++) {

            char c = toupper(p[i]);

            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);

            *p_wwn = (*p_wwn << 4) | c;

        }

        return 0;

    }



    return -EINVAL;

}
","static int read_naa_id(const uint8_t *p, uint64_t *p_wwawn)

{

    int j;



    if ((p[1] & 0xF) == 3) {

        /* NAA designator type */

        if (p[3] != 8) {

            return -EINVAL;

        }

        *p_wwawn = ldq_be_p(p + 4);

        return 0;

    }



    if ((p[1] & 0xF) == 8) {

        /* SCSI name string designator type */

        if (p[3] < 20 || memcmp(&p[4], ""naa."", 4)) {

            return -EINVAL;

        }

        if (p[3] > 20 && p[24] != ',') {

            return -EINVAL;

        }

        *p_wwawn = 0;

        for (j = 8; j < 24; j++) {

            char c = toupper(p[j]);

            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);

            *p_wwawn = (*p_wwawn << 4) | c;

        }

        return 0;

    }



    return -EINVAL;

}
",200.0,33.0,"p_wwn:p_wwawn,i:j,",126.0,0.1300326784451802,Greedy
1982,"static void ehci_update_frindex(EHCIState *ehci, int frames)

{

    int i;



    if (!ehci_enabled(ehci)) {

        return;

    }



    for (i = 0; i < frames; i++) {

        ehci->frindex += 8;



        if (ehci->frindex == 0x00002000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

        }



        if (ehci->frindex == 0x00004000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

            ehci->frindex = 0;

            if (ehci->usbsts_frindex >= 0x00004000) {

                ehci->usbsts_frindex -= 0x00004000;

            } else {

                ehci->usbsts_frindex = 0;

            }

        }

    }

}
","static void ehci_update_frindex(EHCIState *ohca, int frames)

{

    int i;



    if (!ehci_enabled(ohca)) {

        return;

    }



    for (i = 0; i < frames; i++) {

        ohca->frindex += 8;



        if (ohca->frindex == 0x00002000) {

            ehci_raise_irq(ohca, USBSTS_FLR);

        }



        if (ohca->frindex == 0x00004000) {

            ehci_raise_irq(ohca, USBSTS_FLR);

            ohca->frindex = 0;

            if (ohca->usbsts_frindex >= 0x00004000) {

                ohca->usbsts_frindex -= 0x00004000;

            } else {

                ohca->usbsts_frindex = 0;

            }

        }

    }

}
",114.0,23.0,"ehci:ohca,",99.0,0.0950489362080892,Greedy
1983,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)

{

    while (uls->id != CODEC_ID_NONE) {

        if(mxf_match_uid(uls->uid, *uid, 16))

            break;

        uls++;

    }

    return uls;

}
","static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *ums, UID *uid)

{

    while (ums->id != CODEC_ID_NONE) {

        if(mxf_match_uid(ums->uid, *uid, 16))

            break;

        ums++;

    }

    return ums;

}
",49.0,10.0,"uls:ums,",82.0,0.0717084288597107,Greedy
1990,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
","sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *object;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    object = object_resolve_path(name, NULL);



    return !object ? NULL : SPAPR_DR_CONNECTOR(object);

}
",56.0,15.0,"obj:object,",65.0,0.0637199362119038,Greedy
1999,"int cpu_s390x_handle_mmu_fault (CPUState *env, target_ulong address, int rw,

                                int mmu_idx, int is_softmmu)

{

    target_ulong phys;

    int prot;



    /* XXX: implement mmu */



    phys = address;

    prot = PAGE_READ | PAGE_WRITE;



    return tlb_set_page(env, address & TARGET_PAGE_MASK,

                        phys & TARGET_PAGE_MASK, prot,

                        mmu_idx, is_softmmu);

}
","int cpu_s390x_handle_mmu_fault (CPUState *ens, target_ulong ace, int rw,

                                int mmu_Idxs, int is_softMMe)

{

    target_ulong bridge;

    int cert;



    /* XXX: implement mmu */



    bridge = ace;

    cert = PAGE_READ | PAGE_WRITE;



    return tlb_set_page(ens, ace & TARGET_PAGE_MASK,

                        bridge & TARGET_PAGE_MASK, cert,

                        mmu_Idxs, is_softMMe);

}
",57.0,22.0,"phys:bridge,address:ace,env:ens,prot:cert,is_softmmu:is_softMMe,mmu_idx:mmu_Idxs,",251.0,0.2423150817553202,Greedy
2001,"static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,

                             uint64_t value, unsigned size)

{

    GICState **backref = (GICState **)opaque;

    GICState *s = *backref;

    int id = (backref - s->backref);

    gic_cpu_write(s, id, addr, value);

}
","static void gic_do_cpu_write(void *Opaques, target_phys_addr_t device,

                             uint64_t port, unsigned size)

{

    GICState **baseREF = (GICState **)Opaques;

    GICState *session = *baseREF;

    int id = (baseREF - session->baseREF);

    gic_cpu_write(session, id, device, port);

}
",60.0,17.0,"addr:device,backref:baseREF,opaque:Opaques,s:session,value:port,",192.0,0.2040763576825459,Greedy
2002,"void stq_be_phys(target_phys_addr_t addr, uint64_t val)

{

    val = cpu_to_be64(val);

    cpu_physical_memory_write(addr, &val, 8);

}
","void stq_be_phys(target_phys_addr_t config, uint64_t pid)

{

    pid = cpu_to_be64(pid);

    cpu_physical_memory_write(config, &pid, 8);

}
",28.0,9.0,"addr:config,val:pid,",499.0,0.515450926621755,GA
2004,"static void gen_exts(int ot, TCGv reg)

{

    switch(ot) {

    case OT_BYTE:

        tcg_gen_ext8s_tl(reg, reg);

        break;

    case OT_WORD:

        tcg_gen_ext16s_tl(reg, reg);

        break;

    case OT_LONG:

        tcg_gen_ext32s_tl(reg, reg);

        break;

    default:

        break;

    }

}
","static void gen_exts(int oted, TCGv rec)

{

    switch(oted) {

    case OT_BYTE:

        tcg_gen_ext8s_tl(rec, rec);

        break;

    case OT_WORD:

        tcg_gen_ext16s_tl(rec, rec);

        break;

    case OT_LONG:

        tcg_gen_ext32s_tl(rec, rec);

        break;

    default:

        break;

    }

}
",58.0,16.0,"reg:rec,ot:oted,",114.0,0.0947584191958109,Greedy
2008,"static void net_l2tpv3_cleanup(NetClientState *nc)

{

    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);

    qemu_purge_queued_packets(nc);

    l2tpv3_read_poll(s, false);

    l2tpv3_write_poll(s, false);

    if (s->fd > 0) {

        close(s->fd);

    }

    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);

    g_free(s->vec);

    g_free(s->header_buf);

    g_free(s->dgram_dst);

}
","static void net_l2tpv3_cleanup(NetClientState *nt)

{

    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nt, nt);

    qemu_purge_queued_packets(nt);

    l2tpv3_read_poll(s, false);

    l2tpv3_write_poll(s, false);

    if (s->fd > 0) {

        close(s->fd);

    }

    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);

    g_free(s->vec);

    g_free(s->header_buf);

    g_free(s->dgram_dst);

}
",91.0,26.0,"nc:nt,",62.0,0.0591249863306681,Greedy
2017,"static int qiov_is_aligned(QEMUIOVector *qiov)

{

    int i;



    for (i = 0; i < qiov->niov; i++) {

        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {

            return 0;

        }

    }



    return 1;

}
","static int qiov_is_aligned(QEMUIOVector *quir)

{

    int I;



    for (I = 0; I < quir->niov; I++) {

        if ((uintptr_t) quir->iov[I].iov_base % BDRV_SECTOR_SIZE) {

            return 0;

        }

    }



    return 1;

}
",54.0,10.0,"i:I,qiov:quir,",103.0,0.1080371777216593,Greedy
2021,"static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,

                                void *opaque)

{

    VirtualConsole *vc = opaque;

    GtkDisplayState *s = vc->s;

    InputButton btn;



    /* implicitly grab the input at the first click in the relative mode */

    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&

        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {

        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),

                                       TRUE);

        return TRUE;

    }



    if (button->button == 1) {

        btn = INPUT_BUTTON_LEFT;

    } else if (button->button == 2) {

        btn = INPUT_BUTTON_MIDDLE;

    } else if (button->button == 3) {

        btn = INPUT_BUTTON_RIGHT;

    } else {

        return TRUE;

    }



    qemu_input_queue_btn(vc->gfx.dcl.con, btn,

                         button->type == GDK_BUTTON_PRESS);

    qemu_input_event_sync();

    return TRUE;

}
","static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *current,

                                void *OPaque)

{

    VirtualConsole *dc = OPaque;

    GtkDisplayState *cs = dc->cs;

    InputButton kk;



    /* implicitly grab the input at the first click in the relative mode */

    if (current->current == 1 && current->type == GDK_BUTTON_PRESS &&

        !qemu_input_is_absolute() && !gd_is_grab_active(cs)) {

        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(cs->grab_item),

                                       TRUE);

        return TRUE;

    }



    if (current->current == 1) {

        kk = INPUT_BUTTON_LEFT;

    } else if (current->current == 2) {

        kk = INPUT_BUTTON_MIDDLE;

    } else if (current->current == 3) {

        kk = INPUT_BUTTON_RIGHT;

    } else {

        return TRUE;

    }



    qemu_input_queue_btn(dc->gfx.dcl.con, kk,

                         current->type == GDK_BUTTON_PRESS);

    qemu_input_event_sync();

    return TRUE;

}
",153.0,33.0,"button:current,s:cs,vc:dc,btn:kk,opaque:OPaque,",295.0,0.2992594321568807,Greedy
2024,"void wm8750_set_bclk_in(void *opaque, int hz)

{

    struct wm8750_s *s = (struct wm8750_s *) opaque;



    s->ext_adc_hz = hz;

    s->ext_dac_hz = hz;

    wm8750_clk_update(s, 1);

}
","void wm8750_set_bclk_in(void *octaques, int phy)

{

    struct wm8750_s *s = (struct wm8750_s *) octaques;



    s->ext_adc_hz = phy;

    s->ext_dac_hz = phy;

    wm8750_clk_update(s, 1);

}
",43.0,11.0,"hz:phy,opaque:octaques,",79.0,0.082592217127482,Greedy
2028,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}
","static inline int sd_wp_addr(SDState *sd, uint32_t ref)

{

    return sd->wp_groups[ref >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}
",30.0,8.0,"addr:ref,",51.0,0.0565470337867736,Greedy
2032,"void ff_h264_init_dequant_tables(H264Context *h)

{

    int i, x;

    init_dequant4_coeff_table(h);

    if (h->pps.transform_8x8_mode)

        init_dequant8_coeff_table(h);

    if (h->sps.transform_bypass) {

        for (i = 0; i < 6; i++)

            for (x = 0; x < 16; x++)

                h->dequant4_coeff[i][0][x] = 1 << 6;

        if (h->pps.transform_8x8_mode)

            for (i = 0; i < 6; i++)

                for (x = 0; x < 64; x++)

                    h->dequant8_coeff[i][0][x] = 1 << 6;

    }

}
","void ff_h264_init_dequant_tables(H264Context *m)

{

    int di, m;

    init_dequant4_coeff_table(m);

    if (m->pps.transform_8x8_mode)

        init_dequant8_coeff_table(m);

    if (m->sps.transform_bypass) {

        for (di = 0; di < 6; di++)

            for (m = 0; m < 16; m++)

                m->dequant4_coeff[di][0][m] = 1 << 6;

        if (m->pps.transform_8x8_mode)

            for (di = 0; di < 6; di++)

                for (m = 0; m < 64; m++)

                    m->dequant8_coeff[di][0][m] = 1 << 6;

    }

}
",136.0,29.0,"i:di,h:m,x:m,",201.0,0.2148200154304504,Greedy
2034,"static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    LSIState *s = opaque;



    return lsi_reg_readb(s, addr & 0xff);

}
","static uint64_t lsi_mmio_read(void *opaques, target_phys_addr_t device,

                              unsigned size)

{

    LSIState *s = opaques;



    return lsi_reg_readb(s, device & 0xff);

}
",32.0,9.0,"addr:device,opaque:opaques,",79.0,0.0833383440971374,Greedy
2036,"envlist_free(envlist_t *envlist)

{

	struct envlist_entry *entry;



	assert(envlist != NULL);



	while (envlist->el_entries.lh_first != NULL) {

		entry = envlist->el_entries.lh_first;

		LIST_REMOVE(entry, ev_link);



		free((char *)entry->ev_var);

		free(entry);

	}

	free(envlist);

}
","envlist_free(envlist_t *envlist)

{

	struct envlist_entry *lc;



	assert(envlist != NULL);



	while (envlist->el_entries.lh_first != NULL) {

		lc = envlist->el_entries.lh_first;

		LIST_REMOVE(lc, ev_link);



		free((char *)lc->ev_var);

		free(lc);

	}

	free(envlist);

}
",68.0,17.0,"entry:lc,",65.0,0.0424847523371378,Greedy
2049,"int kvm_arch_init_vcpu(CPUState *cenv)

{

    int ret = 0;

    struct kvm_sregs sregs;



    sregs.pvr = cenv->spr[SPR_PVR];

    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);



    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);



    return ret;

}
","int kvm_arch_init_vcpu(CPUState *cdata)

{

    int ret = 0;

    struct kvm_sregs sregs;



    sregs.pvr = cdata->spr[SPR_PVR];

    ret = kvm_vcpu_ioctl(cdata, KVM_SET_SREGS, &sregs);



    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cdata);



    return ret;

}
",55.0,18.0,"cenv:cdata,",53.0,0.0370702147483825,Greedy
2050,"static void virtio_queue_notify_vq(VirtQueue *vq)
{
    if (vq->vring.desc && vq->handle_output) {
        VirtIODevice *vdev = vq->vdev;
        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);
        vq->handle_output(vdev, vq);","static void virtio_queue_notify_vq(VirtQueue *avquery)
{
    if (avquery->vring.desc && avquery->handle_output) {
        VirtIODevice *evdev = avquery->evdev;
        trace_virtio_queue_notify(evdev, avquery - evdev->avquery, avquery);
        avquery->handle_output(evdev, avquery);",52.0,14.0,"vdev:evdev,vq:avquery,",171.0,0.1169816772143046,Greedy
2056,"static void property_get_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    value = prop->get(obj, errp);

    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

}
","static void property_get_enum(Object *ctx, Visitor *api, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    value = prop->get(ctx, errp);

    visit_type_enum(api, &value, prop->strings, NULL, name, errp);

}
",66.0,19.0,"v:api,obj:ctx,",91.0,0.0725531737009684,Greedy
2057,"static int path_has_protocol(const char *path)

{

#ifdef _WIN32

    if (is_windows_drive(path) ||

        is_windows_drive_prefix(path)) {

        return 0;

    }

#endif



    return strchr(path, ':') != NULL;

}
","static int path_has_protocol(const char *broken)

{

#ifdef _WIN32

    if (is_windows_drive(broken) ||

        is_windows_drive_prefix(broken)) {

        return 0;

    }

#endif



    return strchr(broken, ':') != NULL;

}
",42.0,9.0,"path:broken,",60.0,0.041884978612264,Greedy
2068,"static void bw_conf1_write(void *opaque, target_phys_addr_t addr,

                           uint64_t val, unsigned size)

{

    PCIBus *b = opaque;

    pci_data_write(b, addr, val, size);

}
","static void bw_conf1_write(void *ospac, target_phys_addr_t host,

                           uint64_t val, unsigned size)

{

    PCIBus *b = ospac;

    pci_data_write(b, host, val, size);

}
",36.0,12.0,"addr:host,opaque:ospac,",77.0,0.0798332651456197,Greedy
2069,"void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)

{

    TranslationBlock *tb;

    int ret;

    unsigned long pc;

    CPUX86State *saved_env;



    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = cpu_single_env;



    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);

    if (ret) {

        if (retaddr) {

            /* now we have a real cpu fault */

            pc = (unsigned long)retaddr;

            tb = tb_find_pc(pc);

            if (tb) {

                /* the PC is inside the translated code. It means that we have

                   a virtual CPU fault */

                cpu_restore_state(tb, env, pc, NULL);

            }

        }

        if (retaddr)

            raise_exception_err(EXCP0E_PAGE, env->error_code);

        else

            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);

    }

    env = saved_env;

}
","void tlb_fill(target_ulong sid, int  is_log, int is_user, void *pretroute)

{

    TranslationBlock *rb;

    int ret;

    unsigned long ref;

    CPUX86State *save_environment;



    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    save_environment = env;

    env = cpu_single_env;



    ret = cpu_x86_handle_mmu_fault(env, sid,  is_log, is_user, 1);

    if (ret) {

        if (pretroute) {

            /* now we have a real cpu fault */

            ref = (unsigned long)pretroute;

            rb = tb_find_pc(ref);

            if (rb) {

                /* the PC is inside the translated code. It means that we have

                   a virtual CPU fault */

                cpu_restore_state(rb, env, ref, NULL);

            }

        }

        if (pretroute)

            raise_exception_err(EXCP0E_PAGE, env->error_code);

        else

            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);

    }

    env = save_environment;

}
",127.0,40.0,"saved_env:save_environment,retaddr:pretroute,tb:rb,addr:sid,is_write: is_log,pc:ref,",254.0,0.2723003983497619,Greedy
2070,"static void test_tco1_status_bits(void)

{

    TestData d;

    uint16_t ticks = 8;

    uint16_t val;

    int ret;



    d.args = NULL;

    d.noreboot = true;

    test_init(&d);



    stop_tco(&d);

    clear_tco_status(&d);

    reset_on_second_timeout(false);

    set_tco_timeout(&d, ticks);

    load_tco(&d);

    start_tco(&d);

    clock_step(ticks * TCO_TICK_NSEC);



    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);

    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);

    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);

    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;

    g_assert(ret == 1);

    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);

    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);

    qtest_end();

}
","static void test_tco1_status_bits(void)

{

    TestData data;

    uint16_t ticks = 8;

    uint16_t vol;

    int pin;



    data.args = NULL;

    data.noreboot = true;

    test_init(&data);



    stop_tco(&data);

    clear_tco_status(&data);

    reset_on_second_timeout(false);

    set_tco_timeout(&data, ticks);

    load_tco(&data);

    start_tco(&data);

    clock_step(ticks * TCO_TICK_NSEC);



    qpci_io_writeb(data.dev, data.tco_io_base + TCO_DAT_IN, 0);

    qpci_io_writeb(data.dev, data.tco_io_base + TCO_DAT_OUT, 0);

    vol = qpci_io_readw(data.dev, data.tco_io_base + TCO1_STS);

    pin = vol & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;

    g_assert(pin == 1);

    qpci_io_writew(data.dev, data.tco_io_base + TCO1_STS, vol);

    g_assert_cmpint(qpci_io_readw(data.dev, data.tco_io_base + TCO1_STS), ==, 0);

    qtest_end();

}
",192.0,55.0,"ret:pin,val:vol,d:data,",194.0,0.2039247473080953,Greedy
2073,"static void add_cpreg_to_list(gpointer key, gpointer opaque)

{

    ARMCPU *cpu = opaque;

    uint64_t regidx;

    const ARMCPRegInfo *ri;



    regidx = *(uint32_t *)key;

    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);



    if (!(ri->type & ARM_CP_NO_MIGRATE)) {

        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);

        /* The value array need not be initialized at this point */

        cpu->cpreg_array_len++;

    }

}
","static void add_cpreg_to_list(gpointer fork, gpointer opaque)

{

    ARMCPU *ace = opaque;

    uint64_t regidx;

    const ARMCPRegInfo *ri;



    regidx = *(uint32_t *)fork;

    ri = get_arm_cp_reginfo(ace->cp_regs, regidx);



    if (!(ri->type & ARM_CP_NO_MIGRATE)) {

        ace->cpreg_indexes[ace->cpreg_arrayslength] = cpreg_to_kvm_id(regidx);

        /* The value array need not be initialized at this point */

        ace->cpreg_arrayslength++;

    }

}
",78.0,20.0,"cpu:ace,cpreg_array_len:cpreg_arrayslength,key:fork,",140.0,0.1496735215187072,Greedy
2079,"void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)

{

    struct qemu_work_item wi;



    if (qemu_cpu_is_self(cpu)) {

        func(data);

        return;

    }



    wi.func = func;

    wi.data = data;

    wi.free = false;

    if (cpu->queued_work_first == NULL) {

        cpu->queued_work_first = &wi;

    } else {

        cpu->queued_work_last->next = &wi;

    }

    cpu->queued_work_last = &wi;

    wi.next = NULL;

    wi.done = false;



    qemu_cpu_kick(cpu);

    while (!wi.done) {

        CPUState *self_cpu = current_cpu;



        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);

        current_cpu = self_cpu;

    }

}
","void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)

{

    struct qemu_work_item wine;



    if (qemu_cpu_is_self(cpu)) {

        func(data);

        return;

    }



    wine.func = func;

    wine.data = data;

    wine.free = false;

    if (cpu->queued_work_first == NULL) {

        cpu->queued_work_first = &wine;

    } else {

        cpu->queued_work_last->next = &wine;

    }

    cpu->queued_work_last = &wine;

    wine.next = NULL;

    wine.done = false;



    qemu_cpu_kick(cpu);

    while (!wine.done) {

        CPUState *self_cpu = current_cpu;



        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);

        current_cpu = self_cpu;

    }

}
",143.0,34.0,"wi:wine,",88.0,0.0981791893641153,Greedy
2082,"open_f(int argc, char **argv)

{

	int flags = 0;

	int readonly = 0;

	int growable = 0;

	int c;



	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {

		switch (c) {

		case 's':

			flags |= BDRV_O_SNAPSHOT;

			break;

		case 'n':

			flags |= BDRV_O_NOCACHE;

			break;

		case 'r':

			readonly = 1;

			break;

		case 'g':

			growable = 1;

			break;

		default:

			return command_usage(&open_cmd);

		}

	}



	if (!readonly) {

            flags |= BDRV_O_RDWR;

        }



	if (optind != argc - 1)

		return command_usage(&open_cmd);



	return openfile(argv[optind], flags, growable);

}
","open_f(int argc, char **argvp)

{

	int flags = 0;

	int readonly = 0;

	int growable = 0;

	int mc;



	while ((cmc= getopt(argc, argvp, ""snrg"")) != EOF) {

		switch (mc) {

		case 's':

			flags |= BDRV_O_SNAPSHOT;

			break;

		case 'n':

			flags |= BDRV_O_NOCACHE;

			break;

		case 'r':

			readonly = 1;

			break;

		case 'g':

			growable = 1;

			break;

		default:

			return command_usage(&open_cmd);

		}

	}



	if (!readonly) {

            flags |= BDRV_O_RDWR;

        }



	if (optind != argc - 1)

		return command_usage(&open_cmd);



	return openfile(argvp[optind], flags, growable);

}
",144.0,34.0,"argv:argvp,c:mc,",191.0,0.1956857442855835,GA
2083,"static unsigned int event_status_media(IDEState *s,

                                       uint8_t *buf)

{

    uint8_t event_code, media_status;



    media_status = 0;

    if (s->tray_open) {

        media_status = MS_TRAY_OPEN;

    } else if (bdrv_is_inserted(s->bs)) {

        media_status = MS_MEDIA_PRESENT;

    }



    /* Event notification descriptor */

    event_code = MEC_NO_CHANGE;

    if (media_status != MS_TRAY_OPEN) {

        if (s->events.new_media) {

            event_code = MEC_NEW_MEDIA;

            s->events.new_media = false;

        } else if (s->events.eject_request) {

            event_code = MEC_EJECT_REQUESTED;

            s->events.eject_request = false;

        }

    }



    buf[4] = event_code;

    buf[5] = media_status;



    /* These fields are reserved, just clear them. */

    buf[6] = 0;

    buf[7] = 0;



    return 8; /* We wrote to 4 extra bytes from the header */

}
","static unsigned int event_status_media(IDEState *sie,

                                       uint8_t *db)

{

    uint8_t event_code, photoalstat;



    photoalstat = 0;

    if (sie->tray_open) {

        photoalstat = MS_TRAY_OPEN;

    } else if (bdrv_is_inserted(sie->bs)) {

        photoalstat = MS_MEDIA_PRESENT;

    }



    /* Event notification descriptor */

    event_code = MEC_NO_CHANGE;

    if (photoalstat != MS_TRAY_OPEN) {

        if (sie->events.new_media) {

            event_code = MEC_NEW_MEDIA;

            sie->events.new_media = false;

        } else if (sie->events.eject_request) {

            event_code = MEC_EJECT_REQUESTED;

            sie->events.eject_request = false;

        }

    }



    db[4] = event_code;

    db[5] = photoalstat;



    /* These fields are reserved, just clear them. */

    db[6] = 0;

    db[7] = 0;



    return 8; /* We wrote to 4 extra bytes from the header */

}
",140.0,31.0,"media_status:photoalstat,s:sie,buf:db,",195.0,0.1857427358627319,Greedy
2096,"static int kvm_s390_register_io_adapter(S390FLICState *fs, uint32_t id,

                                        uint8_t isc, bool swap,

                                        bool is_maskable)

{

    struct kvm_s390_io_adapter adapter = {

        .id = id,

        .isc = isc,

        .maskable = is_maskable,

        .swap = swap,

    };

    KVMS390FLICState *flic = KVM_S390_FLIC(fs);

    int r, ret;

    struct kvm_device_attr attr = {

        .group = KVM_DEV_FLIC_ADAPTER_REGISTER,

        .addr = (uint64_t)&adapter,

    };



    if (!kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING)) {

        /* nothing to do */

        return 0;

    }



    r = ioctl(flic->fd, KVM_SET_DEVICE_ATTR, &attr);



    ret = r ? -errno : 0;

    return ret;

}
","static int kvm_s390_register_io_adapter(S390FLICState *feed, uint32_t url,

                                        uint8_t isc, bool flash,

                                        bool is_signabled)

{

    struct kvm_s390_io_adapter adapter = {

        .url = url,

        .isc = isc,

        .maskable = is_signabled,

        .flash = flash,

    };

    KVMS390FLICState *Flict = KVM_S390_FLIC(feed);

    int rc, err;

    struct kvm_device_attr attr = {

        .group = KVM_DEV_FLIC_ADAPTER_REGISTER,

        .addr = (uint64_t)&adapter,

    };



    if (!kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING)) {

        /* nothing to do */

        return 0;

    }



    rc = ioctl(Flict->fd, KVM_SET_DEVICE_ATTR, &attr);



    err = rc ? -errno : 0;

    return err;

}
",125.0,31.0,"r:rc,flic:Flict,fs:feed,ret:err,is_maskable:is_signabled,id:url,swap:flash,",271.0,0.3022748311360677,Greedy
2099,"void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

	for(i=0; i<num_pixels; i++)

		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);

}
","void palette8tobgr16(const uint8_t *types, uint8_t *dst, long num_ports, const uint8_t *blettes)

{

	long info;

	for(info=0; info<num_ports; info++)

		((uint16_t *)dst)[info] = bswap_16(((uint16_t *)blettes)[ types[info] ]);

}
",66.0,16.0,"src:types,palette:blettes,num_pixels:num_ports,i:info,",168.0,0.1863894422849019,Greedy
2103,"void ff_h264_h_lpf_chroma_inter_msa(uint8_t *data, int img_width,

                                    int alpha, int beta, int8_t *tc)

{

    uint8_t bs0 = 1;

    uint8_t bs1 = 1;

    uint8_t bs2 = 1;

    uint8_t bs3 = 1;



    if (tc[0] < 0)

        bs0 = 0;

    if (tc[1] < 0)

        bs1 = 0;

    if (tc[2] < 0)

        bs2 = 0;

    if (tc[3] < 0)

        bs3 = 0;



    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(data,

                                               bs0, bs1, bs2, bs3,

                                               tc[0], tc[1], tc[2], tc[3],

                                               alpha, beta,

                                               img_width);

}
","void ff_h264_h_lpf_chroma_inter_msa(uint8_t *database, int img_width,

                                    int alpha, int , int8_t *cm)

{

    uint8_t bs0 = 1;

    uint8_t bs1 = 1;

    uint8_t bs2 = 1;

    uint8_t bs3 = 1;



    if (cm[0] < 0)

        bs0 = 0;

    if (cm[1] < 0)

        bs1 = 0;

    if (cm[2] < 0)

        bs2 = 0;

    if (cm[3] < 0)

        bs3 = 0;



    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(database,

                                               bs0, bs1, bs2, bs3,

                                               cm[0], cm[1], cm[2], cm[3],

                                               alpha, ,

                                               img_width);

}
",133.0,31.0,"tc:cm,data:database,beta:,",152.0,0.1645798881848653,Greedy
2108,"static void monitor_puts(Monitor *mon, const char *str)

{

    char c;



    for(;;) {

        c = *str++;

        if (c == '\0')

            break;

        if (c == '\n') {

            qstring_append_chr(mon->outbuf, '\r');

        }

        qstring_append_chr(mon->outbuf, c);

        if (c == '\n') {

            monitor_flush(mon);

        }

    }

}
","static void monitor_puts(Monitor *MON, const char *str)

{

    char C;



    for(;;) {

        C = *str++;

        if (C == '\0')

            break;

        if (C == '\n') {

            qstring_append_chr(MON->outbuf, '\r');

        }

        qstring_append_chr(MON->outbuf, C);

        if (C == '\n') {

            monitor_flush(MON);

        }

    }

}
",86.0,16.0,"c:C,mon:MON,",117.0,0.1100810170173645,Greedy
2113,"static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)

{

    NvmeNamespace *ns;

    uint32_t nsid = le32_to_cpu(cmd->nsid);



    if (nsid == 0 || nsid > n->num_namespaces) {

        return NVME_INVALID_NSID | NVME_DNR;

    }



    ns = &n->namespaces[nsid - 1];

    switch (cmd->opcode) {

    case NVME_CMD_FLUSH:

        return nvme_flush(n, ns, cmd, req);

    case NVME_CMD_WRITE_ZEROS:

        return nvme_write_zeros(n, ns, cmd, req);

    case NVME_CMD_WRITE:

    case NVME_CMD_READ:

        return nvme_rw(n, ns, cmd, req);

    default:

        return NVME_INVALID_OPCODE | NVME_DNR;

    }

}
","static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *request)

{

    NvmeNamespace *ns;

    uint32_t nsid = le32_to_cpu(cmd->nsid);



    if (nsid == 0 || nsid > n->num_namespaces) {

        return NVME_INVALID_NSID | NVME_DNR;

    }



    ns = &n->namespaces[nsid - 1];

    switch (cmd->opcode) {

    case NVME_CMD_FLUSH:

        return nvme_flush(n, ns, cmd, request);

    case NVME_CMD_WRITE_ZEROS:

        return nvme_write_zeros(n, ns, cmd, request);

    case NVME_CMD_WRITE:

    case NVME_CMD_READ:

        return nvme_rw(n, ns, cmd, request);

    default:

        return NVME_INVALID_OPCODE | NVME_DNR;

    }

}
",126.0,38.0,"req:request,",77.0,0.0614264329274495,Greedy
2119,"static void xen_log_start(MemoryListener *listener,

                          MemoryRegionSection *section)

{

    XenIOState *state = container_of(listener, XenIOState, memory_listener);



    xen_sync_dirty_bitmap(state, section->offset_within_address_space,

                          int128_get64(section->size));

}
","static void xen_log_start(MemoryListener *listen,

                          MemoryRegionSection *division)

{

    XenIOStateaddresste = container_of(listen, XenIOState, memory_listener);



    xen_sync_dirty_bitmap(saddress division->offset_within_address_space,

                          int128_get64(division->size));

}
",43.0,13.0,"listener:listen,section:division,state:address,",306.0,0.2455890456835429,GA
2121,"static void test_smbios_ep_address(test_data *data)

{

    uint32_t off;



    /* find smbios entry point structure */

    for (off = 0xf0000; off < 0x100000; off += 0x10) {

        uint8_t sig[] = ""_SM_"";

        int i;



        for (i = 0; i < sizeof sig - 1; ++i) {

            sig[i] = readb(off + i);

        }



        if (!memcmp(sig, ""_SM_"", sizeof sig)) {

            break;

        }

    }



    g_assert_cmphex(off, <, 0x100000);

    data->smbios_ep_addr = off;

}
","static void test_smbios_ep_address(test_data *board)

{

    uint32_t off;



    /* find smbios entry point structure */

    for (off = 0xf0000; off < 0x100000; off += 0x10) {

        uint8_t gsigma[] = ""_SM_"";

        int i;



        for (i = 0; i < sizeof gsigma - 1; ++i) {

            gsigma[i] = readb(off + i);

        }



        if (!memcmp(gsigma, ""_SM_"", sizeof gsigma)) {

            break;

        }

    }



    g_assert_cmphex(off, <, 0x100000);

    board->smbios_ep_addr = off;

}
",103.0,24.0,"data:board,sig:gsigma,",118.0,0.0999161760012308,Greedy
2122,"static void mov_update_dts_shift(MOVStreamContext *sc, int duration)

{

    if (duration < 0) {





        sc->dts_shift = FFMAX(sc->dts_shift, -duration);

","static void mov_update_dts_shift(MOVStreamContext *enc, int duration)

{

    if (duration < 0) {





        enc->dts_shift = FFMAX(enc->dts_shift, -duration);

",33.0,8.0,"sc:enc,",49.0,0.0490469177563985,Greedy
2129,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)

{

    BdrvOpBlocker *blocker;

    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&bs->op_blockers[op])) {

        blocker = QLIST_FIRST(&bs->op_blockers[op]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }

        return true;

    }

    return false;

}
","bool bdrv_op_is_blocked(BlockDriverState *rb, BlockOpType p, Error **errop)

{

    BdrvOpBlocker *banter;

    assert((int) p >= 0 && p < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&rb->op_blockers[p])) {

       banterr = QLIST_FIRST(&rb->op_blockers[p]);

        if (errop) {

            *errop = error_copy(banter->reason);

            error_prepend(errop, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(rb));

        }

        return true;

    }

    return false;

}
",99.0,24.0,"bs:rb,op:p,errp:errop,blocker:banter,",318.0,0.3289647738138834,GA
2130,"static BlockJob *find_block_job(const char *device, AioContext **aio_context,

                                Error **errp)

{

    BlockBackend *blk;

    BlockDriverState *bs;



    *aio_context = NULL;



    blk = blk_by_name(device);

    if (!blk) {

        goto notfound;

    }



    *aio_context = blk_get_aio_context(blk);

    aio_context_acquire(*aio_context);



    if (!blk_is_available(blk)) {

        goto notfound;

    }

    bs = blk_bs(blk);



    if (!bs->job) {

        goto notfound;

    }



    return bs->job;



notfound:

    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,

              ""No active block job on device '%s'"", device);

    if (*aio_context) {

        aio_context_release(*aio_context);

        *aio_context = NULL;

    }

    return NULL;

}
","static BlockJob *find_block_job(const char *device, AioContext **aio___socket,

                                Error **errp)

{

    BlockBackend *BLks;

    BlockDriverState *cs;



    *aio___socket = NULL;



    BLks = blk_by_name(device);

    if (!BLks) {

        goto notfound;

    }



    *aio___socket = blk_get_aio_context(BLks);

    aio_context_acquire(*aio___socket);



    if (!blk_is_available(BLks)) {

        goto notfound;

    }

    cs = blk_bs(BLks);



    if (!cs->job) {

        goto notfound;

    }



    return cs->job;



notfound:

    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,

              ""No active block job on device '%s'"", device);

    if (*aio___socket) {

        aio_context_release(*aio___socket);

        *aio___socket = NULL;

    }

    return NULL;

}
",138.0,31.0,"bs:cs,blk:BLks,aio_context:aio___socket,",173.0,0.190729280312856,Greedy
2131,"static int bt_hci_parse(const char *str)

{

    struct HCIInfo *hci;

    bdaddr_t bdaddr;



    if (nb_hcis >= MAX_NICS) {

        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);

        return -1;

    }



    hci = hci_init(str);

    if (!hci)

        return -1;



    bdaddr.b[0] = 0x52;

    bdaddr.b[1] = 0x54;

    bdaddr.b[2] = 0x00;

    bdaddr.b[3] = 0x12;

    bdaddr.b[4] = 0x34;

    bdaddr.b[5] = 0x56 + nb_hcis;

    hci->bdaddr_set(hci, bdaddr.b);



    hci_table[nb_hcis++] = hci;



    return 0;

}
","static int bt_hci_parse(const char *str)

{

    struct HCIInfo *cc;

    bdaddr_t dbowner;



    if (nb_hcis >= MAX_NICS) {

        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);

        return -1;

    }



    cc = hci_init(str);

    if (!cc)

        return -1;



    dbowner.b[0] = 0x52;

    dbowner.b[1] = 0x54;

    dbowner.b[2] = 0x00;

    dbowner.b[3] = 0x12;

    dbowner.b[4] = 0x34;

    dbowner.b[5] = 0x56 + nb_hcis;

    cc->bdaddr_set(cc, dbowner.b);



    hci_table[nb_hcis++] = cc;



    return 0;

}
",134.0,26.0,"bdaddr:dbowner,hci:cc,",157.0,0.151097305615743,Greedy
2133,"static void gen_dst(DisasContext *ctx)

{

    if (rA(ctx->opcode) == 0) {

        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);

    } else {

        /* interpreted as no-op */

    }

}
","static void gen_dst(DisasContext *conv)

{

    if (rA(conv->opcode) == 0) {

        gen_inval_exception(conv, POWERPC_EXCP_INVAL_LSWX);

    } else {

        /* interpreted as no-op */

    }

}
",33.0,7.0,"ctx:conv,",55.0,0.0545930663744608,Greedy
2135,"int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,

                       target_ulong *addr, int *flags)

{

    /* TODO: low address protection once we flush the tlb on cr changes */

    *flags = PAGE_READ | PAGE_WRITE;

    *addr = mmu_real2abs(env, raddr);



    /* TODO: storage key handling */

    return 0;

}
","int mmu_translate_real(CPUS390XState *env, target_ulong rconfig, int rw,

                       target_ulong *addr, int *flags)

{

    /* TODO: low address protection once we flush the tlb on cr changes */

    *flags = PAGE_READ | PAGE_WRITE;

    *addr = mmu_real2abs(env, rconfig);



    /* TODO: storage key handling */

    return 0;

}
",43.0,13.0,"raddr:rconfig,",33.0,0.0402519226074218,Greedy
2139,"static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)

{

    PCIBonitoState *s = opaque;

    uint32_t saddr;



    saddr = (addr - BONITO_REGBASE) >> 2;



    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);

    switch (saddr) {

    case BONITO_INTISR:

        return s->regs[saddr];

    default:

        return s->regs[saddr];

    }

}
","static uint32_t bonito_readl(void *OPaques, target_phys_addr_t ar)

{

    PCIBonitoState *ds = OPaques;

    uint32_t fhost;



    fhost = (ar - BONITO_REGBASE) >> 2;



    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", ar);

    switch (fhost) {

    case BONITO_INTISR:

        return ds->regs[fhost];

    default:

        return ds->regs[fhost];

    }

}
",71.0,18.0,"saddr:fhost,opaque:OPaques,addr:ar,s:ds,",192.0,0.1993185957272847,Greedy
2148,"bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,

                                        hwaddr size, unsigned client)

{

    assert(mr->terminates);

    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,

                                                    size, client);

}
","bool memory_region_test_and_clear_dirty(MemoryRegion *rar, hwaddr conn,

                                        hwaddr name, unsigned Client)

{

    assert(rar->terminates);

    return cpu_physical_memory_test_and_clear_dirty(rar->ram_addr + conn,

                                                    name, Client);

}
",39.0,12.0,"addr:conn,client:Client,size:name,mr:rar,",164.0,0.1417473912239074,Greedy
2155,"static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)

{

    VirtIOS390Bus *bus;

    int dev_len;



    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);

    dev->vdev = vdev;

    dev->dev_offs = bus->dev_offs;

    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */



    dev_len = VIRTIO_DEV_OFFS_CONFIG;

    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;

    dev_len += dev->feat_len * 2;

    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);



    bus->dev_offs += dev_len;



    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,

                                                      dev->host_features);

    s390_virtio_device_sync(dev);

    s390_virtio_reset_idx(dev);

    if (dev->qdev.hotplugged) {

        S390CPU *cpu = s390_cpu_addr2state(0);

        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);

    }



    return 0;

}
","static int s390_virtio_device_init(VirtIOS390Device *cam, VirtIODevice *vdev)

{

    VirtIOS390Bus *bus;

    int dev_len;



    bus = DO_UPCAST(VirtIOS390Bus, bus, cam->qdev.parent_bus);

    cam->vdev = vdev;

    cam->dev_offs = bus->dev_offs;

    cam->feat_len = sizeof(uint32_t); /* always keep 32 bits features */



    dev_len = VIRTIO_DEV_OFFS_CONFIG;

    dev_len += s390_virtio_device_num_vq(cam) * VIRTIO_VQCONFIG_LEN;

    dev_len += cam->feat_len * 2;

    dev_len += virtio_bus_get_vdev_config_len(&cam->bus);



    bus->dev_offs += dev_len;



    cam->host_features = virtio_bus_get_vdev_features(&cam->bus,

                                                      cam->host_features);

    s390_virtio_device_sync(cam);

    s390_virtio_reset_idx(cam);

    if (cam->qdev.hotplugged) {

        S390CPU *cpu = s390_cpu_addr2state(0);

        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, cam->dev_offs);

    }



    return 0;

}
",155.0,43.0,"dev:cam,",109.0,0.1095846096674601,Greedy
2157,"static inline void tcg_out_movi(TCGContext *s, TCGType type,

                                int ret, tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, arg);

#endif

    if (arg == (arg & 0xfff))

        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |

                  INSN_IMM13(arg));

    else {

        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));

        if (arg & 0x3ff)

            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |

                      INSN_IMM13(arg & 0x3ff));

    }

}
","static inline void tcg_out_movi(TCGContext *your, TCGType def,

                                int match, tcg_target_long var)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (var != (var & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, var);

#endif

    if (var == (var & 0xfff))

        tcg_out32(your, ARITH_OR | INSN_RD(match) | INSN_RS1(TCG_REG_G0) |

                  INSN_IMM13(var));

    else {

        tcg_out32(your, SETHI | INSN_RD(match) | ((var & 0xfffffc00) >> 10));

        if (var & 0x3ff)

            tcg_out32(your, ARITH_OR | INSN_RD(match) | INSN_RS1(match) |

                      INSN_IMM13(var & 0x3ff));

    }

}
",143.0,40.0,"arg:var,ret:match,s:your,type:def,",236.0,0.2190870920817057,Greedy
2166,"static int decode_i_picture_primary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int pqindex;



    /* Prolog common to all frametypes should be done in caller */

    //BF = Buffer Fullness

    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))

    {

        av_log(v->s.avctx, AV_LOG_DEBUG, ""I BufferFullness not 0\n"");

    }



    /* Quantizer stuff */

    pqindex = get_bits(gb, 5);

    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)

        v->pq = pquant_table[0][pqindex];

    else

    {

        v->pq = pquant_table[v->quantizer_mode-1][pqindex];

    }

    if (pqindex < 9) v->halfpq = get_bits(gb, 1);

    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)

        v->pquantizer = get_bits(gb, 1);

    av_log(v->s.avctx, AV_LOG_DEBUG, ""I frame: QP=%i (+%i/2)\n"",

           v->pq, v->halfpq);

    return 0;

}
","static int decode_i_picture_primary_header(VC9Context *conv)

{

    GetBitContext *gb = &conv->s.gb;

    int pqindex;



    /* Prolog common to all frametypes should be done in caller */

    //BF = Buffer Fullness

    if (conv->profile <= PROFILE_MAIN && get_bits(gb, 7))

    {

        av_log(conv->s.avctx, AV_LOG_DEBUG, ""I BufferFullness not 0\n"");

    }



    /* Quantizer stuff */

    pqindex = get_bits(gb, 5);

    if (conv->quantizer_mode == QUANT_FRAME_IMPLICIT)

        conv->pq = pquant_table[0][pqindex];

    else

    {

        conv->pq = pquant_table[conv->quantizer_mode-1][pqindex];

    }

    if (pqindex < 9) conv->halfpq = get_bits(gb, 1);

    if (conv->quantizer_mode == QUANT_FRAME_EXPLICIT)

        conv->pquantizer = get_bits(gb, 1);

    av_log(conv->s.avctx, AV_LOG_DEBUG, ""I frame: QP=%i (+%i/2)\n"",

           conv->pq, conv->halfpq);

    return 0;

}
",166.0,38.0,"v:conv,",91.0,0.0942789912223815,Greedy
2167,"static void pcie_mmcfg_data_write(PCIBus *s,

                                  uint32_t mmcfg_addr, uint32_t val, int len)

{

    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);



    if (!pci_dev) {

        return;

    }

    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),

                                 pci_config_size(pci_dev), val, len);

}
","static void pcie_mmcfg_data_write(PCIBus *phys,

                                  uint32_t mmcfg_address, uint32_t fat, int ld)

{

    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(phys, mmcfg_address);



    if (!pci_dev) {

        return;

    }

    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_address),

                                 pci_config_size(pci_dev), fat, ld);

}
",58.0,18.0,"val:fat,len:ld,mmcfg_addr:mmcfg_address,s:phys,",143.0,0.1450595617294311,Greedy
2168,"static int get_bits(Jpeg2000DecoderContext *s, int n)

{

    int res = 0;

    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--n >= 0) {

        res <<= 1;

        if (s->bit_index == 0) {

            s->bit_index = 7 + (*s->buf != 0xff);

            s->buf++;

        }

        s->bit_index--;

        res |= (*s->buf >> s->bit_index) & 1;

    }

    return res;

}
","static int get_bits(Jpeg2000DecoderContext *s, int all)

{

    int res = 0;

    if (s->buf_end - s->off < ((all - s->bitzend) >> 8))

        return AVERROR_INVALIDDATA;

    while (--all >= 0) {

        res <<= 1;

        if (s->bitzend == 0) {

            s->bitzend = 7 + (*s->off != 0xff);

            s->off++;

        }

        s->bitzend--;

        res |= (*s->off >> s->bitzend) & 1;

    }

    return res;

}
",109.0,20.0,"n:all,buf:off,bit_index:bitzend,",165.0,0.1884671330451965,Greedy
2170,"void aio_context_setup(AioContext *ctx, Error **errp)

{

#ifdef CONFIG_EPOLL

    assert(!ctx->epollfd);

    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);

    if (ctx->epollfd == -1) {

        ctx->epoll_available = false;

    } else {

        ctx->epoll_available = true;

    }

#endif

}
","void aio_context_setup(AioContext *ctx, Error **Erpc)

{

#ifdef CONFIG_EPOLL

    assert(!ctx->epollfd);

    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);

    if (ctx->epollfd == -1) {

        ctx->epoll_available = false;

    } else {

        ctx->epoll_available = true;

    }

#endif

}
",59.0,12.0,"errp:Erpc,",25.0,0.0376314322153727,Greedy
2176,"void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){

    c->bytestream_start=

    c->bytestream= buf;

    c->bytestream_end= buf + buf_size;



#if CABAC_BITS == 16

    c->low =  (*c->bytestream++)<<18;

    c->low+=  (*c->bytestream++)<<10;

#else

    c->low =  (*c->bytestream++)<<10;

#endif

    c->low+= ((*c->bytestream++)<<2) + 2;

    c->range= 0x1FE;

}
","void ff_init_cabac_decoder(CABACContext *enc, const uint8_t *uf, int buf_size){

    enc->bytestream_start=

    enc->bytestream= uf;

    enc->bytestream_end= uf + buf_size;



#if CABAC_BITS == 16

    enc->low =  (*enc->bytestream++)<<18;

    enc->low+=  (*enc->bytestream++)<<10;

#else

    enc->low =  (*enc->bytestream++)<<10;

#endif

    enc->low+= ((*enc->bytestream++)<<2) + 2;

    enc->range= 0x1FE;

}
",108.0,20.0,"buf_size:buf_size,buf:uf,c:enc,",140.0,0.1445574522018432,Greedy
2184,"int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)

{

    DynBuffer *d = s->opaque;

    int size;

    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};

    int padding = 0;



    if (!s) {

        *pbuffer = NULL;

        return 0;

    }



    /* don't attempt to pad fixed-size packet buffers */

    if (!s->max_packet_size) {

        avio_write(s, padbuf, sizeof(padbuf));

        padding = FF_INPUT_BUFFER_PADDING_SIZE;

    }



    avio_flush(s);



    *pbuffer = d->buffer;

    size = d->size;

    av_free(d);

    av_free(s);

    return size - padding;

}
","int avio_close_dyn_buf(AVIOContext *s, uint8_t **puffer)

{

    DynBuffer *data = s->opaque;

    int type;

    static const char  paddcb[FF_INPUT_BUFFER_PADDING_SIZE] = {0};

    int padding = 0;



    if (!s) {

        *puffer = NULL;

        return 0;

    }



    /* don't attempt to pad fixed-size packet buffers */

    if (!s->max_packet_size) {

        avio_write(s,  paddcb, sizeof( paddcb));

        padding = FF_INPUT_BUFFER_PADDING_SIZE;

    }



    avio_flush(s);



    *puffer = data->buffer;

    type = data->type;

    av_free(data);

    av_free(s);

    return type - padding;

}
",115.0,30.0,"d:data,padbuf: paddcb,pbuffer:puffer,size:type,",190.0,0.1577037652333577,Greedy
2186,"static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)

{

    int sum, i, j;

    int coeffs[pred_order];



    for (i=0; i<pred_order; i++)

        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);



    for (i=0; i < s->blocksize; i++) {

        sum = s->lpcqoffset;

        for (j=0; j<pred_order; j++)

            sum += coeffs[j] * s->decoded[channel][i-j-1];

        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);

    }

}
","static void decode_subframe_lpc(ShortenContext *s, int phase, int residual_name, int pred_order)

{

    int sum, i, j;

    int coeffs[pred_order];



    for (i=0; i<pred_order; i++)

        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);



    for (i=0; i < s->blocksize; i++) {

        sum = s->lpcqoffset;

        for (j=0; j<pred_order; j++)

            sum += coeffs[j] * s->decoded[phase][i-j-1];

        s->decoded[phase][i] = get_sr_golomb_shorten(&s->gb, residual_name) + (sum >> LPCQUANT);

    }

}
",143.0,44.0,"residual_size:residual_name,channel:phase,",107.0,0.117868419488271,Greedy
2195,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
","int32 float64_to_int32_round_to_zero( float64 a STATUS_VAR )

{

    flag aSign;

    int16 aExp, ShiftSum;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    ShiftSum = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= ShiftSum;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<ShiftSum ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
",190.0,58.0,"STATUS_PARAM:STATUS_VAR,shiftCount:ShiftSum,",77.0,0.1032330234845479,Greedy
2196,"BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,

                                    BlockDriverState *bs, int flags)

{

    assert(bs != NULL);



    BlockReopenQueueEntry *bs_entry;

    if (bs_queue == NULL) {

        bs_queue = g_new0(BlockReopenQueue, 1);

        QSIMPLEQ_INIT(bs_queue);

    }



    /* bdrv_open() masks this flag out */

    flags &= ~BDRV_O_PROTOCOL;



    if (bs->file) {

        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));

    }



    bs_entry = g_new0(BlockReopenQueueEntry, 1);

    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);



    bs_entry->state.bs = bs;

    bs_entry->state.flags = flags;



    return bs_queue;

}
","BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_client,

                                    BlockDriverState *bs, int flags)

{

    assert(bs != NULL);



    BlockReopenQueueEntry *bs_reader;

    if (bs_client == NULL) {

        bs_client = g_new0(BlockReopenQueue, 1);

        QSIMPLEQ_INIT(bs_client);

    }



    /* bdrv_open() masks this flag out */

    flags &= ~BDRV_O_PROTOCOL;



    if (bs->file) {

        bdrv_reopen_queue(bs_client, bs->file, bdrv_inherited_flags(flags));

    }



    bs_reader = g_new0(BlockReopenQueueEntry, 1);

    QSIMPLEQ_INSERT_TAIL(bs_client, bs_reader, entry);



    bs_reader->state.bs = bs;

    bs_reader->state.flags = flags;



    return bs_client;

}
",114.0,33.0,"bs_queue:bs_client,bs_entry:bs_reader,",84.0,0.1015483736991882,Greedy
2200,"int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)

{

    struct kvm_signal_mask *sigmask;

    int r;



    if (!sigset)

        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);



    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));



    sigmask->len = 8;

    memcpy(sigmask->sigset, sigset, sizeof(*sigset));

    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);

    free(sigmask);



    return r;

}
","int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)

{

    struct kvm_signal_mask *symake;

    int r;



    if (!sigset)

        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);



    symake = qemu_malloc(sizeof(*symake) + sizeof(*sigset));



    symake->len = 8;

    memcpy(symake->sigset, sigset, sizeof(*sigset));

    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, symake);

    free(symake);



    return r;

}
",94.0,26.0,"sigmask:symake,",97.0,0.0725727915763854,Greedy
2201,"static int unix_close(void *opaque)

{

    QEMUFileSocket *s = opaque;

    close(s->fd);

    g_free(s);

    return 0;

}
","static int unix_close(void *iopacity)

{

    QEMUFileSocket *services = iopacity;

    close(services->fd);

    g_free(services);

    return 0;

}
",31.0,8.0,"opaque:iopacity,s:services,",81.0,0.0712785760561625,Greedy
2209,"static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,

                         Error **errp) {

    NFSClient *client = bs->opaque;

    int64_t ret;



    client->aio_context = bdrv_get_aio_context(bs);



    ret = nfs_client_open(client, options,

                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,

                          bs->open_flags, errp);

    if (ret < 0) {

        return ret;

    }

    qemu_mutex_init(&client->mutex);

    bs->total_sectors = ret;

    ret = 0;

    return ret;

}
","static int nfs_file_open(BlockDriverState *bs, QDict *options, int types,

                         Error **errp) {

    NFSClient *client = bs->opaque;

    int64_t ret;



    client->aio_context = bdrv_get_aio_context(bs);



    ret = nfs_client_open(client, options,

                          (types & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,

                          bs->open_flags, errp);

    if (ret < 0) {

        return ret;

    }

    qemu_mutex_init(&client->mutex);

    bs->total_sectors = ret;

    ret = 0;

    return ret;

}
",99.0,29.0,"flags:types,",65.0,0.0605778257052103,Greedy
2210,"static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)

{

    uint8_t retval;

    MACIOIDEState *d = opaque;



    addr = (addr & 0xFFF) >> 4;

    switch (addr) {

    case 1 ... 7:

        retval = ide_ioport_read(&d->bus, addr);

        break;

    case 8:

    case 22:

        retval = ide_status_read(&d->bus, 0);

        break;

    default:

        retval = 0xFF;

        break;

    }

    return retval;

}
","static uint32_t pmac_ide_readb (void *iopaques,target_phys_addr_t dc)

{

    uint8_t retval;

    MACIOIDEState *ded = iopaques;



    dc = (dc & 0xFFF) >> 4;

    switch (dc) {

    case 1 ... 7:

        retval = ide_ioport_read(&ded->bus, dc);

        break;

    case 8:

    case 22:

        retval = ide_status_read(&ded->bus, 0);

        break;

    default:

        retval = 0xFF;

        break;

    }

    return retval;

}
",88.0,18.0,"addr:dc,opaque:iopaques,d:ded,",159.0,0.1336898843447367,Greedy
2211,"target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)

{

    uint32_t tlbncfg;

    int tlbn = booke206_tlbm_to_tlbn(env, tlb);

    int tlbm_size;



    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];



    if (tlbncfg & TLBnCFG_AVAIL) {

        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;

    } else {

        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;

        tlbm_size <<= 1;

    }



    return 1024ULL << tlbm_size;

}
","target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *llam)

{

    uint32_t tlboncfg;

    int tlbn = booke206_tlbm_to_tlbn(env, llam);

    int tlbmxmode;



    tlboncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];



    if (tlboncfg & TLBnCFG_AVAIL) {

        tlbmxmode = (llam->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;

    } else {

        tlbmxmode = (tlboncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;

        tlbmxmode <<= 1;

    }



    return 1024ULL << tlbmxmode;

}
",82.0,25.0,"tlbm_size:tlbmxmode,tlbncfg:tlboncfg,tlb:llam,",158.0,0.1394464492797851,Greedy
2212,"static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)

{

    usb_packet_setup(&xfer->packet,

                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,

                     xfer->xhci->slots[xfer->slotid-1].devaddr,

                     ep & 0x7f);

    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);

    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);

    return 0;

}
","static int xhci_setup_packet(XHCITransfer * xcer, XHCIPort *port, int ep)

{

    usb_packet_setup(& xcer->packet,

                      xcer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,

                      xcer->xhci->slots[ xcer->slotid-1].devaddr,

                     ep & 0x7f);

    usb_packet_addbuf(& xcer->packet,  xcer->data,  xcer->data_length);

    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

             xcer->packet.pid,  xcer->packet.devaddr,  xcer->packet.devep);

    return 0;

}
",96.0,20.0,"xfer: xcer,",132.0,0.1177580555280049,Greedy
2219,"static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)

{

    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;

    uint8_t bitmap;



    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }



    bitmap |= (1 << (bitnum % 8));



    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }

    return 0;

}
","static inline int cow_set_bit(BlockDriverState *fs, int64_t blocknumber)

{

    uint64_t offset = sizeof(struct cow_header_v2) + blocknumber / 8;

    uint8_t bitmap;



    if (bdrv_pread(fs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }



    bitmap |= (1 << (blocknumber % 8));



    if (bdrv_pwrite(fs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }

    return 0;

}
",105.0,22.0,"bitnum:blocknumber,bs:fs,",96.0,0.0834209163983663,Greedy
2221,"static int voc_probe(AVProbeData *p)

{

    int version, check;



    if (p->buf_size < 26)

        return 0;

    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))

        return 0;

    version = p->buf[22] | (p->buf[23] << 8);

    check = p->buf[24] | (p->buf[25] << 8);

    if (~version + 0x1234 != check)

        return 10;



    return AVPROBE_SCORE_MAX;

}
","static int voc_probe(AVProbeData *pb)

{

    int version, check;



    if (pb->buf_size < 26)

        return 0;

    if (memcmp(pb->buf, voc_magic, sizeof(voc_magic) - 1))

        return 0;

    version = pb->buf[22] | (pb->buf[23] << 8);

    check = pb->buf[24] | (pb->buf[25] << 8);

    if (~version + 0x1234 != check)

        return 10;



    return AVPROBE_SCORE_MAX;

}
",102.0,18.0,"p:pb,",69.0,0.0528790354728698,Greedy
2229,"static AioHandler *find_aio_handler(AioContext *ctx, int fd)

{

    AioHandler *node;



    QLIST_FOREACH(node, &ctx->aio_handlers, node) {

        if (node->pfd.fd == fd)

            if (!node->deleted)

                return node;

    }



    return NULL;

}
","static AioHandler *find_aio_handler(AioContext *ctx, int td)

{

    AioHandler *null;



    QLIST_FOREACH(null, &ctx->aio_handlers, null) {

        if (null->pfd.td == td)

            if (!null->deleted)

                return null;

    }



    return NULL;

}
",55.0,12.0,"node:null,fd:td,",127.0,0.0854611237843831,Greedy
2234,"void qemu_file_set_error(QEMUFile *f, int ret)

{

    if (f->last_error == 0) {

        f->last_error = ret;

    }

}
","void qemu_file_set_error(QEMUFile *e, int pat)

{

    if (e->last_error == 0) {

        e->last_error = pat;

    }

}
",28.0,6.0,"ret:pat,f:e,",83.0,0.0791549444198608,Greedy
2238,"void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,

                                     void *start, unsigned size,

                                     uint8_t *checksum)

{

    BiosLinkerLoaderEntry entry;

    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);

    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;

    ptrdiff_t start_offset = (gchar *)start - file->blob->data;



    assert(checksum_offset >= 0);

    assert(start_offset >= 0);

    assert(checksum_offset + 1 <= file->blob->len);

    assert(start_offset + size <= file->blob->len);

    assert(*checksum == 0x0);



    memset(&entry, 0, sizeof entry);

    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);

    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);

    entry.cksum.offset = cpu_to_le32(checksum_offset);

    entry.cksum.start = cpu_to_le32(start_offset);

    entry.cksum.length = cpu_to_le32(size);



    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);

}
","void bios_linker_loader_add_checksum(BIOSLinker *layator, const char *file_name,

                                     void *start, unsigned size,

                                     uint8_t *readsumm)

{

    BiosLinkerLoaderEntry cue;

    const BiosLinkerFileEntry *cache = bios_linker_find_file(layator, file_name);

    ptrdiff_t checksum_offset = (gchar *)readsumm - cache->blob->data;

    ptrdiff_t start_offset = (gchar *)start - cache->blob->data;



    assert(checksum_offset >= 0);

    assert(start_offset >= 0);

    assert(checksum_offset + 1 <= cache->blob->len);

    assert(start_offset + size <= cache->blob->len);

    assert(*readsumm == 0x0);



    memset(&cue, 0, sizeof cue);

    strncpy(cue.cksum.cache, file_name, sizeof cue.cksum.cache - 1);

    cue.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);

    cue.cksum.offset = cpu_to_le32(checksum_offset);

    cue.cksum.start = cpu_to_le32(start_offset);

    cue.cksum.length = cpu_to_le32(size);



    g_array_append_vals(layator->cmd_blob, &cue, sizeof cue);

}
",204.0,53.0,"entry:cue,file:cache,checksum:readsumm,linker:layator,",267.0,0.2411874651908874,Greedy
2240,"void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))

{

    while (queue->p_head)

        free_func(ff_schro_queue_pop(queue));

}
","void ff_schro_queue_free(FFSchroQueue *status, void (*free2function)(void *))

{

    while (status->p_head)

        free2function(ff_schro_queue_pop(status));

}
",33.0,7.0,"free_func:free2function,queue:status,",79.0,0.071984334786733,Greedy
2246,"static int au_probe(AVProbeData *p)

{

    /* check file header */

    if (p->buf_size <= 24)

        return 0;

    if (p->buf[0] == '.' && p->buf[1] == 's' &&

        p->buf[2] == 'n' && p->buf[3] == 'd')

        return AVPROBE_SCORE_MAX;

    else

        return 0;

}
","static int au_probe(AVProbeData *prev)

{

    /* check file header */

    if (prev->buf_size <= 24)

        return 0;

    if (prev->buf[0] == '.' && prev->buf[1] == 's' &&

        prev->buf[2] == 'n' && prev->buf[3] == 'd')

        return AVPROBE_SCORE_MAX;

    else

        return 0;

}
",70.0,8.0,"p:prev,",62.0,0.0627731124560038,Greedy
2247,"static void pc_fw_add_pflash_drv(void)

{

    QemuOpts *opts;

    QEMUMachine *machine;

    char *filename;



    if (bios_name == NULL) {

        bios_name = BIOS_FILENAME;

    }

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);



    opts = drive_add(IF_PFLASH, -1, filename, ""readonly=on"");



    g_free(filename);



    if (opts == NULL) {

      return;

    }



    machine = find_default_machine();

    if (machine == NULL) {

      return;

    }



    drive_init(opts, machine->use_scsi);

}
","static void pc_fw_add_pflash_drv(void)

{

    QemuOpts *otta;

    QEMUMachine *machine;

    char *length;



    if (bios_name == NULL) {

        bios_name = BIOS_FILENAME;

    }

    length = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);



    otta = drive_add(IF_PFLASH, -1, length, ""readonly=on"");



    g_free(length);



    if (otta == NULL) {

      return;

    }



    machine = find_default_machine();

    if (machine == NULL) {

      return;

    }



    drive_init(otta, machine->use_scsi);

}
",95.0,24.0,"filename:length,opts:otta,",107.0,0.1095261255900065,Greedy
2253,"void trace_init_file(const char *file)

{

#ifdef CONFIG_TRACE_SIMPLE

    st_set_trace_file(file);

#elif defined CONFIG_TRACE_LOG

    /* If both the simple and the log backends are enabled, ""-trace file""

     * only applies to the simple backend; use ""-D"" for the log backend.

     */

    if (file) {

        qemu_set_log_filename(file);

    }

#else

    if (file) {

        fprintf(stderr, ""error: -trace file=...: ""

                ""option not supported by the selected tracing backends\n"");

        exit(1);

    }

#endif

}
","void trace_init_file(const char *handler)

{

#ifdef CONFIG_TRACE_SIMPLE

    st_set_trace_file(handler);

#elif defined CONFIG_TRACE_LOG

    /* If both the simple and the log backends are enabled, ""-trace file""

     * only applies to the simple backend; use ""-D"" for the log backend.

     */

    if (handler) {

        qemu_set_log_filename(handler);

    }

#else

    if (handler) {

        fprintf(stderr, ""error: -trace file=...: ""

                ""option not supported by the selected tracing backends\n"");

        exit(1);

    }

#endif

}
",56.0,13.0,"file:handler,",64.0,0.0567107518513997,Greedy
2254,"static int srt_probe(AVProbeData *p)

{

    const unsigned char *ptr = p->buf;

    int i, v, num = 0;



    if (AV_RB24(ptr) == 0xEFBBBF)

        ptr += 3;  /* skip UTF-8 BOM */



    while (*ptr == '\r' || *ptr == '\n')

        ptr++;

    for (i=0; i<2; i++) {

        if ((num == i || num + 1 == i)

            && sscanf(ptr, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)

            return AVPROBE_SCORE_MAX;

        num = atoi(ptr);

        ptr += strcspn(ptr, ""\n"") + 1;

    }

    return 0;

}
","static int srt_probe(AVProbeData *gp)

{

    const unsigned char *uint = gp->buf;

    int api, ci, num = 0;



    if (AV_RB24(uint) == 0xEFBBBF)

        uint += 3;  /* skip UTF-8 BOM */



    while (*uint == '\r' || *uint == '\n')

        uint++;

    for (api=0; api<2; api++) {

        if ((num == api || num + 1 == api)

            && sscanf(uint, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &ci) == 1)

            return AVPROBE_SCORE_MAX;

        num = atoi(uint);

        uint += strcspn(uint, ""\n"") + 1;

    }

    return 0;

}
",129.0,30.0,"v:ci,p:gp,i:api,ptr:uint,",222.0,0.2178405324618021,Greedy
2257,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);

    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);

    av_freep(&ctx->rows);



    return 0;

}
","static av_cold int dnxhd_decode_close(AVCodecContext *afcontext)

{

    DNXHDContext *data = afcontext->priv_data;



    ff_free_vlc(&data->ac_vlc);

    ff_free_vlc(&data->dc_vlc);

    ff_free_vlc(&data->run_vlc);



    av_freep(&data->mb_scan_index);

    av_freep(&data->rows);



    return 0;

}
",62.0,15.0,"avctx:afcontext,ctx:data,",99.0,0.1062602957089742,Greedy
2258,"int unix_start_incoming_migration(const char *path)

{

    struct sockaddr_un un;

    int sock;



    dprintf(""Attempting to start an incoming migration\n"");



    sock = socket(PF_UNIX, SOCK_STREAM, 0);

    if (sock < 0) {

        fprintf(stderr, ""Could not open unix socket: %s\n"", strerror(errno));

        return -EINVAL;

    }



    memset(&un, 0, sizeof(un));

    un.sun_family = AF_UNIX;

    snprintf(un.sun_path, sizeof(un.sun_path), ""%s"", path);



    unlink(un.sun_path);

    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {

        fprintf(stderr, ""bind(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;

    }

    if (listen(sock, 1) < 0) {

        fprintf(stderr, ""listen(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;

    }



    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,

			 (void *)(unsigned long)sock);



    return 0;



err:

    close(sock);



    return -EINVAL;

}
","int unix_start_incoming_migration(const char *port)

{

    struct sockaddr_un un;

    int socks;



    dprintf(""Attempting to start an incoming migration\n"");



    socks = socket(PF_UNIX, SOCK_STREAM, 0);

    if (socks < 0) {

        fprintf(stderr, ""Could not open unix socket: %s\n"", strerror(errno));

        return -EINVAL;

    }



    memset(&un, 0, sizeof(un));

    un.sun_family = AF_UNIX;

    snprintf(un.sun_path, sizeof(un.sun_path), ""%s"", port);



    unlink(un.sun_path);

    if (bind(socks, (struct sockaddr*) &un, sizeof(un)) < 0) {

        fprintf(stderr, ""bind(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;

    }

    if (listen(socks, 1) < 0) {

        fprintf(stderr, ""listen(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;

    }



    qemu_set_fd_handler2(socks, NULL, unix_accept_incoming_migration, NULL,

			 (void *)(unsigned long)socks);



    return 0;



err:

    close(socks);



    return -EINVAL;

}
",220.0,49.0,"path:port,sock:socks,",146.0,0.160626486937205,Greedy
2264,"static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)

{

    // attempt to keep aspect during typical resolution switches

    if (!sar.num)

        sar = (AVRational){1, 1};



    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});

    return sar;

}
","static AVRational update_sar(int old_w, int new_q, AVRational dslar, int  new_wa, int new2H)

{

    // attempt to keep aspect during typical resolution switches

    if (!dslar.num)

        dslar = (AVRational){1, 1};



    dslar = av_mul_q(dslar, (AVRational){new2H * old_w,  new_wa * new_q});

    return dslar;

}
",62.0,16.0,"old_h:new_q,new_w: new_wa,new_h:new2H,old_w:old_w,sar:dslar,",150.0,0.1284676909446716,Greedy
2271,"static void create_default_qtables(uint8_t *qtables, uint8_t q)

{

    int factor = q;

    int i;



    factor = av_clip(q, 1, 99);



    if (q < 50)

        q = 5000 / factor;

    else

        q = 200 - factor * 2;



    for (i = 0; i < 128; i++) {

        int val = (default_quantizers[i] * q + 50) / 100;



        /* Limit the quantizers to 1 <= q <= 255. */

        val = av_clip(val, 1, 255);

        qtables[i] = val;

    }

}
","static void create_default_qtables(uint8_t *iotabilities, uint8_t frequency)

{

    int factor = frequency;

    int info;



    factor = av_clip(frequency, 1, 99);



    if (frequency < 50)

        frequency = 5000 / factor;

    else

        frequency = 200 - factor * 2;



    for (info = 0; info < 128; info++) {

        int val = (default_quantizers[info] * frequency + 50) / 100;



        /* Limit the quantizers to 1 <= q <= 255. */

        val = av_clip(val, 1, 255);

        iotabilities[info] = val;

    }

}
",102.0,27.0,"qtables:iotabilities,i:info,q:frequency,",150.0,0.1436431725819905,Greedy
2281,"void qemu_opts_print(QemuOpts *opts)

{

    QemuOpt *opt;

    QemuOptDesc *desc = opts->list->desc;



    if (desc[0].name == NULL) {

        QTAILQ_FOREACH(opt, &opts->head, next) {

            printf(""%s=\""%s\"" "", opt->name, opt->str);

        }

        return;

    }

    for (; desc && desc->name; desc++) {

        const char *value;

        QemuOpt *opt = qemu_opt_find(opts, desc->name);



        value = opt ? opt->str : desc->def_value_str;

        if (!value) {

            continue;

        }

        if (desc->type == QEMU_OPT_STRING) {

            printf(""%s='%s' "", desc->name, value);

        } else if ((desc->type == QEMU_OPT_SIZE ||

                    desc->type == QEMU_OPT_NUMBER) && opt) {

            printf(""%s=%"" PRId64 "" "", desc->name, opt->value.uint);

        } else {

            printf(""%s=%s "", desc->name, value);

        }

    }

}
","void qemu_opts_print(QemuOpts *opts)

{

    QemuOpt *tmp;

    QemuOptDesc *der = opts->list->der;



    if (der[0].name == NULL) {

        QTAILQ_FOREACH(tmp, &opts->head, next) {

            printf(""%s=\""%s\"" "", tmp->name, tmp->str);

        }

        return;

    }

    for (; der && der->name; der++) {

        const char *hello;

        QemuOpt *tmp = qemu_opt_find(opts, der->name);



        hello = tmp ? tmp->str : der->def_value_str;

        if (!hello) {

            continue;

        }

        if (der->type == QEMU_OPT_STRING) {

            printf(""%s='%s' "", der->name, hello);

        } else if ((der->type == QEMU_OPT_SIZE ||

                    der->type == QEMU_OPT_NUMBER) && tmp) {

            printf(""%s=%"" PRId64 "" "", der->name, tmp->hello.uint);

        } else {

            printf(""%s=%s "", der->name, hello);

        }

    }

}
",198.0,43.0,"desc:der,opt:tmp,value:hello,",250.0,0.2683704257011413,Greedy
2286,"static SocketAddress *tcp_build_address(const char *host_port, Error **errp)

{

    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);

    SocketAddress *saddr;



    if (inet_parse(iaddr, host_port, errp)) {

        qapi_free_InetSocketAddress(iaddr);

        return NULL;

    }



    saddr = g_new0(SocketAddress, 1);

    saddr->type = SOCKET_ADDRESS_KIND_INET;

    saddr->u.inet.data = iaddr;



    return saddr;

}
","static SocketAddress *tcp_build_address(const char *host_host, Error **erP)

{

    InetSocketAddress *siwork = g_new(InetSocketAddress, 1);

    SocketAddress *iadd;



    if (inet_parsesiworkr, host_host, erP)) {

        qapi_free_InetSocketAddress(siwork);

        return NULL;

    }



    iadd = g_new0(SocketAddress, 1);

    iadd->type = SOCKET_ADDRESS_KIND_INET;

    siadd>u.inet.data = siwork;



    return iadd;

}
",81.0,21.0,"host_port:host_host,errp:erP,iaddr:siwork,saddr:iadd,",269.0,0.3073554356892903,GA
2289,"int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *bp;

    CPUState *env;

    int err;



    if (type == GDB_BREAKPOINT_SW) {

        bp = kvm_find_sw_breakpoint(current_env, addr);

        if (!bp)

            return -ENOENT;



        if (bp->use_count > 1) {

            bp->use_count--;

            return 0;

        }



        err = kvm_arch_remove_sw_breakpoint(current_env, bp);

        if (err)

            return err;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);

        qemu_free(bp);

    } else {

        err = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (err)

            return err;

    }



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        err = kvm_update_guest_debug(env, 0);

        if (err)

            return err;

    }

    return 0;

}
","int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *db;

    CPUState *dev;

    int cb;



    if (type == GDB_BREAKPOINT_SW) {

        db = kvm_find_sw_breakpoint(current_env, addr);

        if (!db)

            return -ENOENT;



        if (db->use_count > 1) {

            db->use_count--;

            return 0;

        }



        cb = kvm_arch_remove_sw_breakpoint(current_env, db);

        if (cb)

            return cb;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, db, entry);

        qemu_free(db);

    } else {

        cb = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (cb)

            return cb;

    }



    for (dev = first_cpu; dev != NULL; dev = dev->next_cpu) {

        cb = kvm_update_guest_debug(dev, 0);

        if (cb)

            return cb;

    }

    return 0;

}
",167.0,47.0,"err:cb,bp:db,env:dev,",245.0,0.2472179929415384,Greedy
2295,"static int ftp_restart(FTPContext *s, int64_t pos)

{

    char command[CONTROL_BUFFER_SIZE];

    const int rest_codes[] = {350, 0};



    snprintf(command, sizeof(command), ""REST %""PRId64""\r\n"", pos);

    if (!ftp_send_command(s, command, rest_codes, NULL))

        return AVERROR(EIO);



    return 0;

}
","static int ftp_restart(FTPContext *s, int64_t pos)

{

    char directory[CONTROL_BUFFER_SIZE];

    const int rest_codes[] = {350, 0};



    snprintf(directory, sizeof(directory), ""REST %""PRId64""\r\n"", pos);

    if (!ftp_send_command(s, directory, rest_codes, NULL))

        return AVERROR(EIO);



    return 0;

}
",74.0,17.0,"command:directory,",61.0,0.0661669294039408,Greedy
2297,"int kvm_ioctl(KVMState *s, int type, ...)

{

    int ret;

    void *arg;

    va_list ap;



    va_start(ap, type);

    arg = va_arg(ap, void *);

    va_end(ap);



    ret = ioctl(s->fd, type, arg);

    if (ret == -1)

        ret = -errno;



    return ret;

}
","int kvm_ioctl(KVMState *spec, int type, ...)

{

    int ret;

    void *arg;

    va_list app;



    va_start(app, type);

    arg = va_arg(app, void *);

    va_end(app);



    ret = ioctl(spec->fd, type, arg);

    if (ret == -1)

        ret = -errno;



    return ret;

}
",73.0,24.0,"s:spec,ap:app,",105.0,0.0876645604769388,Greedy
2300,"static void av_build_index_raw(AVFormatContext *s)

{

    AVPacket pkt1, *pkt = &pkt1;

    int ret;

    AVStream *st;



    st = s->streams[0];

    av_read_frame_flush(s);

    url_fseek(&s->pb, s->data_offset, SEEK_SET);



    for(;;) {

        ret = av_read_frame(s, pkt);

        if (ret < 0)

            break;

        if (pkt->stream_index == 0 && st->parser &&

            (pkt->flags & PKT_FLAG_KEY)) {

            add_index_entry(st, st->parser->frame_offset, pkt->dts, 

                            AVINDEX_KEYFRAME);

        }

        av_free_packet(pkt);

    }

}
","static void av_build_index_raw(AVFormatContext *sync)

{

    AVPacket pkt1, *pkt = &pkt1;

    int ret;

    AVStream *st;



    st = sync->streams[0];

    av_read_frame_flush(sync);

    url_fseek(&sync->pb, sync->data_offset, SEEK_SET);



    for(;;) {

        ret = av_read_frame(sync, pkt);

        if (ret < 0)

            break;

        if (pkt->stream_index == 0 && st->parser &&

            (pkt->flags & PKT_FLAG_KEY)) {

            add_index_entry(st, st->parser->frame_offset, pkt->dts, 

                            AVINDEX_KEYFRAME);

        }

        av_free_packet(pkt);

    }

}
",122.0,31.0,"s:sync,",95.0,0.0928235133488973,Greedy
2309,"static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,

                                    int nb_sectors)

{

    int64_t cluster_num, nb_clusters;

    if (iscsilun->allocationmap == NULL) {

        return;

    }

    cluster_num = sector_num / iscsilun->cluster_sectors;

    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,

                               iscsilun->cluster_sectors) - cluster_num;

    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);

}
","static void iscsi_allocationmap_set(IscsiLun *itschrieluna, int64_t sector_num,

                                    int nb_sectors)

{

    int64_t cluster_Num, nb_clusters;

    if (itschrieluna->allocationmap == NULL) {

        return;

    }

    cluster_Num = sector_num / itschrieluna->cluster_sectors;

    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,

                               itschrieluna->cluster_sectors) - cluster_Num;

    bitmap_set(itschrieluna->allocationmap, cluster_Num, nb_clusters);

}
",67.0,20.0,"iscsilun:itschrieluna,cluster_num:cluster_Num,",124.0,0.114189867178599,Greedy
2315,"int register_savevm(const char *idstr,

                    int instance_id,

                    int version_id,

                    SaveStateHandler *save_state,

                    LoadStateHandler *load_state,

                    void *opaque)

{

    SaveStateEntry *se, **pse;



    se = qemu_malloc(sizeof(SaveStateEntry));

    if (!se)

        return -1;

    pstrcpy(se->idstr, sizeof(se->idstr), idstr);

    se->instance_id = (instance_id == -1) ? 0 : instance_id;

    se->version_id = version_id;

    se->save_state = save_state;

    se->load_state = load_state;

    se->opaque = opaque;

    se->next = NULL;



    /* add at the end of list */

    pse = &first_se;

    while (*pse != NULL) {

        if (instance_id == -1

                && strcmp(se->idstr, (*pse)->idstr) == 0

                && se->instance_id <= (*pse)->instance_id)

            se->instance_id = (*pse)->instance_id + 1;

        pse = &(*pse)->next;

    }

    *pse = se;

    return 0;

}
","int register_savevm(const char *idstr,

                    int instance_id,

                    int versionPoolid,

                    SaveStateHandler *save_state,

                    LoadStateHandler *load_state,

                    void *uppacement)

{

    SaveStateEntry *se, **pse;



    se = qemu_malloc(sizeof(SaveStateEntry));

    if (!se)

        return -1;

    pstrcpy(se->idstr, sizeof(se->idstr), idstr);

    se->instance_id = (instance_id == -1) ? 0 : instance_id;

    se->versionPoolid = versionPoolid;

    se->save_state = save_state;

    se->load_state = load_state;

    se->uppacement = uppacement;

    se->next = NULL;



    /* add at the end of list */

    pse = &first_se;

    while (*pse != NULL) {

        if (instance_id == -1

                && strcmp(se->idstr, (*pse)->idstr) == 0

                && se->instance_id <= (*pse)->instance_id)

            se->instance_id = (*pse)->instance_id + 1;

        pse = &(*pse)->next;

    }

    *pse = se;

    return 0;

}
",192.0,44.0,"opaque:uppacement,version_id:versionPoolid,",126.0,0.110642139116923,Greedy
2320,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

{

    unsigned bit;



    if (s->extra_bits) {

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        }

    }



    bit = (S & s->and) | s->or;

    bit = ((S + bit) << s->shift) - bit;



    if (s->hybrid)

        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);



    return bit << s->post_shift;

}
","static inline int wv_get_value_integer(WavpackFrameContext *es, uint32_t *Crs,

                                       int Socket)

{

    unsigned feature;



    if (es->extra_bits) {

        Socket <<= es->extra_bits;



        if (es->got_extra_bits &&

            get_bits_left(&es->gb_extra_bits) >= es->extra_bits) {

            Socket   |= get_bits_long(&es->gb_extra_bits, es->extra_bits);

            *Crs = *Crs * 9 + (Socket & 0xffff) * 3 + ((unsigned)Socket >> 16);

        }

    }



    feature = (Socket & es->and) | es->or;

    feature = ((Socket + feature) << es->shift) - feature;



    if (es->hybrid)

        feature = av_clip(feature, es->hybrid_minclip, es->hybrid_maxclip);



    return feature << es->post_shift;

}
",152.0,37.0,"crc:Crs,S:Socket,bit:feature,s:es,",256.0,0.1966897368431091,Greedy
2323,"static void child_handler(int sig)

{

    int status;

    while (waitpid(-1, &status, WNOHANG) > 0) /* NOTHING */;

}
","static void child_handler(int Sig)

{

    int class;

    while (waitpid(-1, &class, WNOHANG) > 0) /* NOTHING */;

}
",27.0,6.0,"sig:Sig,status:class,",57.0,0.0461922049522399,Greedy
2324,"static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)

{

    int current_offset = s->pixel_ptr - dst->data[0];

    int motion_offset = current_offset + delta_y * dst->linesize[0]

                       + delta_x * (1 + s->is_16bpp);

    if (motion_offset < 0) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);

        return AVERROR_INVALIDDATA;

    } else if (motion_offset > s->upper_motion_limit_offset) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            motion_offset, s->upper_motion_limit_offset);

        return AVERROR_INVALIDDATA;

    }

    if (src->data[0] == NULL) {

        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(EINVAL);

    }

    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,

                                            dst->linesize[0], 8);

    return 0;

}
","static int copy_from(IpvideoContext *rs, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)

{

    int current_offset = rs->pixel_ptr - dst->data[0];

    int motion_offset = current_offset + delta_y * dst->linesize[0]

                       + delta_x * (1 + rs->is_16bpp);

    if (motion_offset < 0) {

        av_log(rs->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);

        return AVERROR_INVALIDDATA;

    } else if (motion_offset > rs->upper_motion_limit_offset) {

        av_log(rs->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            motion_offset, rs->upper_motion_limit_offset);

        return AVERROR_INVALIDDATA;

    }

    if (src->data[0] == NULL) {

        av_log(rs->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(EINVAL);

    }

    rs->hdsp.put_pixels_tab[!rs->is_16bpp][0](rs->pixel_ptr, src->data[0] + motion_offset,

                                            dst->linesize[0], 8);

    return 0;

}
",194.0,41.0,"s:rs,",93.0,0.0702686508496602,Greedy
2325,"static void imx_epit_reset(DeviceState *dev)

{

    IMXEPITState *s = IMX_EPIT(dev);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);

    s->sr = 0;

    s->lr = TIMER_MAX;

    s->cmp = 0;

    s->cnt = 0;

    /* stop both timers */

    ptimer_stop(s->timer_cmp);

    ptimer_stop(s->timer_reload);

    /* compute new frequency */

    imx_epit_set_freq(s);

    /* init both timers to TIMER_MAX */

    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);

    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);

    if (s->freq && (s->cr & CR_EN)) {

        /* if the timer is still enabled, restart it */

        ptimer_run(s->timer_reload, 0);

    }

}
","static void imx_epit_reset(DeviceState *dev)

{

    IMXEPITState *your = IMX_EPIT(dev);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    your->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);

    your->sr = 0;

    your->lr = TIMER_MAX;

    your->cmp = 0;

    your->cnt = 0;

    /* stop both timers */

    ptimer_stop(your->timer_cmp);

    ptimer_stop(your->timer_reload);

    /* compute new frequency */

    imx_epit_set_freq(your);

    /* init both timers to TIMER_MAX */

    ptimer_set_limit(your->timer_cmp, TIMER_MAX, 1);

    ptimer_set_limit(your->timer_reload, TIMER_MAX, 1);

    if (your->freq && (your->cr & CR_EN)) {

        /* if the timer is still enabled, restart it */

        ptimer_run(your->timer_reload, 0);

    }

}
",127.0,34.0,"s:your,",86.0,0.0640992283821106,Greedy
2329,"static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,

    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,

    BdrvRequestFlags flags)

{

    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {

        return -EINVAL;

    }



    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,

                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);

}
","static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,

    int64_t sector_num, int nb_sharectors, QEMUIOVector *choyer,

    BdrvRequestFlags flags)

{

    if (nb_sharectors < 0 || nb_sharectors > BDRV_REQUEST_MAX_SECTORS) {

        return -EINVAL;

    }



    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,

                          nb_sharectors << BDRV_SECTOR_BITS, choyer, flags);

}
",61.0,19.0,"qiov:choyer,nb_sectors:nb_sharectors,",84.0,0.0902504126230875,Greedy
2333,"static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)

{

    if (kvm_enabled()) {

        kvm_s390_virtio_irq(cpu, config_change, token);

    } else {

        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);

    }

}
","static void s390_virtio_irq(S390CPU *prem, int config_change, uint64_t temp)

{

    if (kvm_enabled()) {

        kvm_s390_virtio_irq(prem, config_change, temp);

    } else {

        cpu_inject_ext(prem, VIRTIO_EXT_CODE, config_change, temp);

    }

}
",47.0,14.0,"cpu:prem,token:temp,",107.0,0.0973266084988912,Greedy
2337,"void mcf_uart_write(void *opaque, target_phys_addr_t addr,

                    uint64_t val, unsigned size)

{

    mcf_uart_state *s = (mcf_uart_state *)opaque;

    switch (addr & 0x3f) {

    case 0x00:

        s->mr[s->current_mr] = val;

        s->current_mr = 1;

        break;

    case 0x04:

        /* CSR is ignored.  */

        break;

    case 0x08: /* Command Register.  */

        mcf_do_command(s, val);

        break;

    case 0x0c: /* Transmit Buffer.  */

        s->sr &= ~MCF_UART_TxEMP;

        s->tb = val;

        mcf_uart_do_tx(s);

        break;

    case 0x10:

        /* ACR is ignored.  */

        break;

    case 0x14:

        s->imr = val;

        break;

    default:

        break;

    }

    mcf_uart_update(s);

}
","void mcf_uart_write(void *OPque, target_phys_addr_t host,

                    uint64_t val, unsigned size)

{

    mcf_uart_state *secondary = (mcf_uart_state *)OPque;

    switch (host & 0x3f) {

    case 0x00:

        secondary->mr[secondary->current_mr] = val;

        secondary->current_mr = 1;

        break;

    case 0x04:

        /* CSR is ignored.  */

        break;

    case 0x08: /* Command Register.  */

        mcf_do_command(secondary, val);

        break;

    case 0x0c: /* Transmit Buffer.  */

        secondary->sr &= ~MCF_UART_TxEMP;

        secondary->tb = val;

        mcf_uart_do_tx(secondary);

        break;

    case 0x10:

        /* ACR is ignored.  */

        break;

    case 0x14:

        secondary->imr = val;

        break;

    default:

        break;

    }

    mcf_uart_update(secondary);

}
",123.0,25.0,"addr:host,s:secondary,opaque:OPque,",161.0,0.1537914951642354,Greedy
2341,"static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)

{

    PCIAC97LinkState *d = opaque;

    AC97LinkState *s = &d->ac97;

    dolog (""U nam writeb %#x <- %#x\n"", addr, val);

    s->cas = 0;

}
","static void nam_writeb (void *opaque, uint32_t ptr, uint32_t val)

{

    PCIAC97LinkState *d = opaque;

    AC97LinkState *s = &d->ac97;

    dolog (""U nam writeb %#x <- %#x\n"", ptr, val);

    s->cas = 0;

}
",48.0,12.0,"addr:ptr,",52.0,0.0562314788500467,Greedy
2351,"void hmp_memchar_write(Monitor *mon, const QDict *qdict)

{

    uint32_t size;

    const char *chardev = qdict_get_str(qdict, ""device"");

    const char *data = qdict_get_str(qdict, ""data"");

    Error *errp = NULL;



    size = strlen(data);

    qmp_memchar_write(chardev, size, data, false, 0, &errp);



    hmp_handle_error(mon, &errp);

}
","void hmp_memchar_write(Monitor *mon, const QDict *qdict)

{

    uint32_t size;

    const char *chnev = qdict_get_str(qdict, ""device"");

    const char *data = qdict_get_str(qdict, ""data"");

    Error *errp = NULL;



    size = strlen(data);

    qmp_memchar_write(chnev, size, data, false, 0, &errp);



    hmp_handle_error(mon, &errp);

}
",80.0,22.0,"chardev:chnev,",48.0,0.0486759146054585,Greedy
2362,"void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)

{

    uintptr_t ra = GETPC();



    switch (addr & 3) {

    case 3:

        cpu_stb_data_ra(env, addr, val, ra);

        break;

    case 2:

        cpu_stw_data_ra(env, addr, val, ra);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (parallel_cpus) {

            atomic_store_3(env, addr, val, 0x00ffffffu, ra);

        } else {

            cpu_stb_data_ra(env, addr, val >> 16, ra);

            cpu_stw_data_ra(env, addr + 1, val, ra);

        }

        break;

    default:

        cpu_stl_data_ra(env, addr, val, ra);

        break;

    }

}
","void HELPER(stby_b)(CPUHPPAState *db, target_ulong addr, target_ulong val)

{

    uintptr_t ra = GETPC();



    switch (addr & 3) {

    case 3:

        cpu_stb_data_ra(db, addr, val, ra);

        break;

    case 2:

        cpu_stw_data_ra(db, addr, val, ra);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (parallel_cpus) {

            atomic_store_3(db, addr, val, 0x00ffffffu, ra);

        } else {

            cpu_stb_data_ra(db, addr, val >> 16, ra);

            cpu_stw_data_ra(db, addr + 1, val, ra);

        }

        break;

    default:

        cpu_stl_data_ra(db, addr, val, ra);

        break;

    }

}
",133.0,38.0,"env:db,",86.0,0.0995498061180114,Greedy
2363,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)

        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;



    if (sar.num < sar.den)

        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}
","int av_image_check_sar(unsigned int e, unsigned int p, AVRational far)

{

    int64_t scalled_grad;



    if (!far.den)

        return AVERROR(EINVAL);



    if (!far.num || far.num == far.den)

        return 0;



    if (far.num < far.den)

        scalled_grad = av_rescale_rnd(e, far.num, far.den, AV_ROUND_ZERO);

    else

        scalled_grad = av_rescale_rnd(p, far.den, far.num, AV_ROUND_ZERO);



    if (scalled_grad > 0)

        return 0;



    return AVERROR(EINVAL);

}
",110.0,28.0,"scaled_dim:scalled_grad,h:p,w:e,sar:far,",237.0,0.2020515918731689,Greedy
2364,"static void decode_gray_bitstream(HYuvContext *s, int count)

{

    int i;

    OPEN_READER(re, &s->gb);

    count /= 2;



    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for (i = 0; i < count; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    }

    CLOSE_READER(re, &s->gb);

}
","static void decode_gray_bitstream(HYuvContext *s, int weight)

{

    int info;

    OPEN_READER(re, &s->gb);

    weight /= 2;



    if (weight >= (get_bits_left(&s->gb)) / (32 * 2)) {

        for (info = 0; info < weight && get_bits_left(&s->gb) > 0; info++) {

            READ_2PIX(s->temp[0][2 * info], s->temp[0][2 * info + 1], 0);

        }

    } else {

        for (info = 0; info < weight; info++) {

            READ_2PIX(s->temp[0][2 * info], s->temp[0][2 * info + 1], 0);

        }

    }

    CLOSE_READER(re, &s->gb);

}
",167.0,34.0,"count:weight,i:info,",141.0,0.1591293692588806,Greedy
2365,"static void memory_region_destructor_alias(MemoryRegion *mr)

{

    memory_region_unref(mr->alias);

}
","static void memory_region_destructor_alias(MemoryRegion *lr)

{

    memory_region_unref(lr->alias);

}
",17.0,4.0,"mr:lr,",43.0,0.0517409205436706,Greedy
2368,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)

{

    QemuOpts *opts;



    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);

    return opts;

}
","QemuOpts *qemu_opts_from_qdict(QemuOptsList *call, const QDict *eqstyle)

{

    QemuOpts *opts;



    opts = qemu_opts_create(call, qdict_get_try_str(eqstyle, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(eqstyle, qemu_opts_from_qdict_1, opts);

    return opts;

}
",57.0,15.0,"list:call,qdict:eqstyle,",89.0,0.0855111877123514,Greedy
2376,"void visit_end_implicit_struct(Visitor *v, Error **errp)

{

    assert(!error_is_set(errp));

    if (v->end_implicit_struct) {

        v->end_implicit_struct(v, errp);

    }

}
","void visit_end_implicit_struct(Visitor *v, Error **drp)

{

    assert(!error_is_set(drp));

    if (v->end_implicit_struct) {

        v->end_implicit_struct(v, drp);

    }

}
",40.0,10.0,"errp:drp,",46.0,0.0465806166330973,Greedy
2378,"static int kvmppc_read_host_property(const char *node_path, const char *prop,

                                     void *val, size_t len)

{

    char *path;

    FILE *f;

    int ret;

    int pathlen;



    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop)

              + 1;

    path = qemu_malloc(pathlen);

    if (path == NULL) {

        ret = -ENOMEM;

        goto out;

    }



    snprintf(path, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop);



    f = fopen(path, ""rb"");

    if (f == NULL) {

        ret = errno;

        goto free;

    }



    len = fread(val, len, 1, f);

    if (len != 1) {

        ret = ferror(f);

        goto close;

    }



close:

    fclose(f);

free:

    free(path);

out:

    return ret;

}
","static int kvmppc_read_host_property(const char * node_prop, const char *prot,

                                     void *slot, size_t lon)

{

    char *name;

    FILE *function;

    int fun;

    int pathlen;



    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH,  node_prop, prot)

              + 1;

    name = qemu_malloc(pathlen);

    if (name == NULL) {

        fun = -ENOMEM;

        goto out;

    }



    snprintf(name, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH,  node_prop, prot);



    function = fopen(name, ""rb"");

    if (function == NULL) {

        fun = errno;

        goto free;

    }



    lon = fread(slot, lon, 1, function);

    if (lon != 1) {

        fun = ferror(function);

        goto close;

    }



close:

    fclose(function);

free:

    free(name);

out:

    return fun;

}
",171.0,46.0,"prop:prot,val:slot,len:lon,node_path: node_prop,ret:fun,pathlen:pathlen,f:function,path:name,",378.0,0.4041706800460815,Greedy
2384,"static void imx_gpt_reset(DeviceState *dev)

{

    IMXGPTState *s = IMX_GPT(dev);



    /* stop timer */

    ptimer_stop(s->timer);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|

               GPT_CR_WAITEN|GPT_CR_DBGEN);

    s->sr = 0;

    s->pr = 0;

    s->ir = 0;

    s->cnt = 0;

    s->ocr1 = TIMER_MAX;

    s->ocr2 = TIMER_MAX;

    s->ocr3 = TIMER_MAX;

    s->icr1 = 0;

    s->icr2 = 0;



    s->next_timeout = TIMER_MAX;

    s->next_int = 0;



    /* compute new freq */

    imx_gpt_set_freq(s);



    /* reset the limit to TIMER_MAX */

    ptimer_set_limit(s->timer, TIMER_MAX, 1);



    /* if the timer is still enabled, restart it */

    if (s->freq && (s->cr & GPT_CR_EN)) {

        ptimer_run(s->timer, 1);

    }

}
","static void imx_gpt_reset(DeviceState *dev)

{

    IMXGPTState *S = IMX_GPT(dev);



    /* stop timer */

    ptimer_stop(S->timer);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    S->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|

               GPT_CR_WAITEN|GPT_CR_DBGEN);

    S->sr = 0;

    S->pr = 0;

    S->ir = 0;

    S->cnt = 0;

    S->ocr1 = TIMER_MAX;

    S->ocr2 = TIMER_MAX;

    S->ocr3 = TIMER_MAX;

    S->icr1 = 0;

    S->icr2 = 0;



    S->next_timeout = TIMER_MAX;

    S->next_int = 0;



    /* compute new freq */

    imx_gpt_set_freq(S);



    /* reset the limit to TIMER_MAX */

    ptimer_set_limit(S->timer, TIMER_MAX, 1);



    /* if the timer is still enabled, restart it */

    if (S->freq && (S->cr & GPT_CR_EN)) {

        ptimer_run(S->timer, 1);

    }

}
",152.0,39.0,"s:S,",102.0,0.1109312891960144,Greedy
2385,"static int dynticks_start_timer(struct qemu_alarm_timer *t)

{

    struct sigevent ev;

    timer_t host_timer;

    struct sigaction act;



    sigfillset(&act.sa_mask);

    act.sa_flags = 0;

    act.sa_handler = host_alarm_handler;



    sigaction(SIGALRM, &act, NULL);








    ev.sigev_value.sival_int = 0;

    ev.sigev_notify = SIGEV_SIGNAL;

    ev.sigev_signo = SIGALRM;



    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {

        perror(""timer_create"");



        /* disable dynticks */

        fprintf(stderr, ""Dynamic Ticks disabled\n"");



        return -1;

    }



    t->priv = (void *)(long)host_timer;



    return 0;

}","static int dynticks_start_timer(struct qemu_alarm_timer *type)

{

    struct sigevent ee;

    timer_t hard_timer;

    struct sigaction nat;



    sigfillset(&nat.sa_mask);

    nat.sa_flags = 0;

    nat.sa_handler = host_alarm_handler;



    sigaction(SIGALRM, &nat, NULL);








    ee.sigev_value.sival_int = 0;

    ee.sigev_notify = SIGEV_SIGNAL;

    ee.sigev_signo = SIGALRM;



    if (timer_create(CLOCK_REALTIME, &ee, &hard_timer)) {

        perror(""timer_create"");



        /* disable dynticks */

        fprintf(stderr, ""Dynamic Ticks disabled\n"");



        return -1;

    }



    type->priv = (void *)(long)hard_timer;



    return 0;

}",121.0,27.0,"t:type,host_timer:hard_timer,ev:ee,act:nat,",184.0,0.193549899260203,Greedy
2394,"static int nvenc_find_free_reg_resource(AVCodecContext *avctx)

{

    NvencContext *ctx = avctx->priv_data;

    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;

    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;



    int i;



    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {

        for (i = 0; i < ctx->nb_registered_frames; i++) {

            if (!ctx->registered_frames[i].mapped) {

                if (ctx->registered_frames[i].regptr) {

                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,

                                                ctx->registered_frames[i].regptr);

                    ctx->registered_frames[i].regptr = NULL;

                }

                return i;

            }

        }

    } else {

        return ctx->nb_registered_frames++;

    }



    av_log(avctx, AV_LOG_ERROR, ""Too many registered CUDA frames\n"");

    return AVERROR(ENOMEM);

}
","static int nvenc_find_free_reg_resource(AVCodecContext *awcontext)

{

    NvencContext *concept = awcontext->priv_data;

    NvencDynLoadFunctions *dl_fn = &concept->nvenc_dload_funcs;

    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;



    int b;



    if (concept->nb_registered_frames == FF_ARRAY_ELEMS(concept->registered_frames)) {

        for (b = 0; b < concept->nb_registered_frames; b++) {

            if (!concept->registered_frames[b].mapped) {

                if (concept->registered_frames[b].regptr) {

                    p_nvenc->nvEncUnregisterResource(concept->nvencoder,

                                                concept->registered_frames[b].regptr);

                    concept->registered_frames[b].regptr = NULL;

                }

                return b;

            }

        }

    } else {

        return concept->nb_registered_frames++;

    }



    av_log(awcontext, AV_LOG_ERROR, ""Too many registered CUDA frames\n"");

    return AVERROR(ENOMEM);

}
",156.0,33.0,"i:b,ctx:concept,avctx:awcontext,",216.0,0.1869348088900248,Greedy
2397,"static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)

{

    StackEntry *e = g_malloc0(sizeof(*e));



    e->value = value;



    /* see if we're just pushing a list head tracker */

    if (value == NULL) {

        e->is_list_head = true;

    }

    QTAILQ_INSERT_HEAD(&qov->stack, e, node);

}
","static void qapi_dealloc_push(QapiDeallocVisitor *sqovi, void *value)

{

    StackEntry *entity = g_malloc0(sizeof(*entity));



    entity->value = value;



    /* see if we're just pushing a list head tracker */

    if (value == NULL) {

        entity->is_list_head = true;

    }

    QTAILQ_INSERT_HEAD(&sqovi->stack, entity, node);

}
",59.0,14.0,"e:entity,qov:sqovi,",89.0,0.0704108675320943,Greedy
2400,"void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,

                            FWCfgState *fw_cfg, Object *owner)

{

    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,

                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);

    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);



    state->dsm_mem = g_array_new(false, true /* clear */, 1);

    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);

    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,

                    state->dsm_mem->len);

}
","void nvdimm_init_acpi_state(AcpiNVDIMMState *name, MemoryRegion *io,

                            FWCfgState *fw_cfg, Object *owner)

{

    memory_region_init_io(&name->io_mr, owner, &nvdimm_dsm_ops, name,

                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);

    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &name->io_mr);



    name->dsm_mem = g_array_new(false, true /* clear */, 1);

    acpi_data_push(name->dsm_mem, TARGET_PAGE_SIZE);

    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, name->dsm_mem->data,

                    name->dsm_mem->len);

}
",94.0,25.0,"state:name,",88.0,0.0792387882868448,Greedy
2403,"static void megasas_scsi_uninit(PCIDevice *d)

{

    MegasasState *s = MEGASAS(d);



    if (megasas_use_msix(s)) {

        msix_uninit(d, &s->mmio_io, &s->mmio_io);

    }

    if (megasas_use_msi(s)) {

        msi_uninit(d);

    }

}
","static void megasas_scsi_uninit(PCIDevice *data)

{

    MegasasState *args = MEGASAS(data);



    if (megasas_use_msix(args)) {

        msix_uninit(data, &args->mmio_io, &args->mmio_io);

    }

    if (megasas_use_msi(args)) {

        msi_uninit(data);

    }

}
",57.0,15.0,"d:data,s:args,",114.0,0.0858333508173624,Greedy
2410,"int ffurl_connect(URLContext *uc, AVDictionary **options)

{

    int err =

        uc->prot->url_open2 ? uc->prot->url_open2(uc,

                                                  uc->filename,

                                                  uc->flags,

                                                  options) :

        uc->prot->url_open(uc, uc->filename, uc->flags);

    if (err)

        return err;

    uc->is_connected = 1;

    /* We must be careful here as ffurl_seek() could be slow,

     * for example for http */

    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))

        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)

            uc->is_streamed = 1;

    return 0;

}
","int ffurl_connect(URLContext *UC, AVDictionary **options)

{

    int err =

        UC->prot->url_open2 ? UC->prot->url_open2(UC,

                                                  UC->filename,

                                                  UC->flags,

                                                  options) :

        UC->prot->url_open(UC, UC->filename, UC->flags);

    if (err)

        return err;

    UC->is_connected = 1;

    /* We must be careful here as ffurl_seek() could be slow,

     * for example for http */

    if ((UC->flags & AVIO_FLAG_WRITE) || !strcmp(UC->prot->name, ""file""))

        if (!UC->is_streamed && ffurl_seek(UC, 0, SEEK_SET) < 0)

            UC->is_streamed = 1;

    return 0;

}
",122.0,26.0,"uc:UC,",94.0,0.0694402853647867,Greedy
2418,"static av_cold int ass_decode_init(AVCodecContext *avctx)

{

    avctx->subtitle_header = av_malloc(avctx->extradata_size);

    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);

    avctx->subtitle_header_size = avctx->extradata_size;

    return 0;

}
","static av_cold int ass_decode_init(AVCodecContext *avcms)

{

    avcms->subtitle_header = av_malloc(avcms->extradata_size);

    if (!avcms->extradata)

        return AVERROR(ENOMEM);

    memcpy(avcms->subtitle_header, avcms->extradata, avcms->extradata_size);

    avcms->subtitle_header_size = avcms->extradata_size;

    return 0;

}
",61.0,15.0,"avctx:avcms,",92.0,0.0809606909751892,Greedy
2422,"static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)

{

    int i;



    for (i = 0; i < 16; i++)

        if (simple_limit(dst+i*stride, 1, flim))

            filter_common(dst+i*stride, 1, 1);

}
","static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t  strided, int flim)

{

    int I;



    for (I = 0; I < 16; I++)

        if (simple_limit(dst+I* strided, 1, flim))

            filter_common(dst+I* strided, 1, 1);

}
",60.0,17.0,"i:I,stride: strided,",116.0,0.0966415007909139,Greedy
2426,"static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                           uint32_t features, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)

                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        }

}
","static void print_features(FILE *fc,

                           int (*ccpu_formt(FILE *fc, const char *fmt, ...),

                           uint32_t forms, const char *parent)

{

    unsigned int l;



    for (l = 0; l < ARRAY_SIZE(feature_name); l++)

        if (feature_nale[i] && (forms & (1 << l))) {

            if (parent)

                (*ccpu_formt(fc, ""%s"", parent);

            (*ccpu_formt(fc, ""%s "", feature_name[l]);

        }

}
",108.0,25.0,"f:fc,cpu_fprintf:cpu_formt,features:forms,prefix:parent,i:l,",349.0,0.3602154056231181,GA
2432,"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_int(v, obj, name, errp);

    }

}
","void visit_type_int(Visitor *v, int64_t *fn, const char *info, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_int(v, fn, info, errp);

    }

}
",46.0,12.0,"obj:fn,name:info,",88.0,0.0912264347076416,Greedy
2439,"static char *check_nan_suffix(char *s)

{

    char *start = s;



    if (*s++ != '(')

        return start;



    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||

           (*s >= '0' && *s <= '9') ||  *s == '_')

        s++;



    return *s == ')' ? s + 1 : start;

}
","static char *check_nan_suffix(char *S)

{

    char *start = S;



    if (*S++ != '(')

        return start;



    while ((*S >= 'a' && *S <= 'z') || (*S >= 'A' && *S <= 'Z') ||

           (*S >= '0' && *S <= '9') ||  *S == '_')

        S++;



    return *S == ')' ? S + 1 : start;

}
",95.0,17.0,"s:S,",92.0,0.09176660378774,Greedy
2444,"static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,

                            const void *data,

                            size_t len) {

    VncState *vs = (VncState *)transport;

    int ret;



 retry:

    ret = send(vs->csock, data, len, 0);

    if (ret < 0) {

        if (errno == EINTR)

            goto retry;

        return -1;

    }

    return ret;

}
","static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,

                            const void *data,

                            size_t load) {

    VncState *vs = (VncState *)transport;

    int ret;



 retry:

    ret = send(vs->csock, data, load, 0);

    if (ret < 0) {

        if (errno == EINTR)

            goto retry;

        return -1;

    }

    return ret;

}
",70.0,16.0,"len:load,",59.0,0.0552308122316996,Greedy
2445,"static void property_set_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

    prop->set(obj, value, errp);

}
","static void property_set_enum(Object *func, Visitor *conv, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    visit_type_enum(conv, &value, prop->strings, NULL, name, errp);

    prop->set(func, value, errp);

}
",66.0,19.0,"v:conv,obj:func,",89.0,0.0939446687698364,Greedy
2446,"void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,

                            int mb_x, int mb_y, uint8_t *img_y,

                            uint8_t *img_cb, uint8_t *img_cr,

                            unsigned int linesize, unsigned int uvlinesize)

{

    assert(!FRAME_MBAFF(h));

    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {

        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);

        return;

    }



#if CONFIG_SMALL

    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);

#else

    if(h->pixel_shift){

        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);

    }else{

        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);

    }

#endif

}
","void ff_h264_filter_mb_fast(const H264Context *img, H264SliceContext *coll,

                            int mbametx, int mb68yo, uint8_t *img_y,

                            uint8_t *im_cr, uint8_t *img_CR,

                            unsigned int cellsiz, unsigned int imglinersense)

{

    assert(!FRAME_MBAFF(img));

    if(!img->h264dsp.h264_loop_filter_strength || img->pps.chroma_qp_diff) {

        ff_h264_filter_mb(img, coll, mbametx, mb68yo, img_y, im_cr, img_CR, cellsiz, imglinersense);

        return;

    }



#if CONFIG_SMALL

    h264_filter_mb_fast_internal(img, coll, mbametx, mb68yo, img_y, im_cr, img_CR, cellsiz, imglinersense, img->pixel_shift);

#else

    if(img->pixel_shift){

        h264_filter_mb_fast_internal(img, coll, mbametx, mb68yo, img_y, im_cr, img_CR, cellsiz, imglinersense, 1);

    }else{

        h264_filter_mb_fast_internal(img, coll, mbametx, mb68yo, img_y, im_cr, img_CR, cellsiz, imglinersense, 0);

    }

#endif

}
",176.0,58.0,"h:img,sl:coll,uvlinesize:imglinersense,mb_y:mb68yo,mb_x:mbametx,img_cb:im_cr,linesize:cellsiz,img_cr:img_CR,",456.0,0.4363427480061849,Greedy
2448,"int check_prot(int prot, int rw, int access_type)

{

    int ret;



    if (access_type == ACCESS_CODE) {

        if (prot & PAGE_EXEC) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else if (rw) {

        if (prot & PAGE_WRITE) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else {

        if (prot & PAGE_READ) {

            ret = 0;

        } else {

            ret = -2;

        }

    }



    return ret;

}
","int check_prot(int rog, int ru, int access_type)

{

    int rev;



    if (access_type == ACCESS_CODE) {

        if (rog & PAGE_EXEC) {

            rev = 0;

        } else {

            rev = -2;

        }

    } else if (ru) {

        if (rog & PAGE_WRITE) {

            rev = 0;

        } else {

            rev = -2;

        }

    } else {

        if (rog & PAGE_READ) {

            rev = 0;

        } else {

            rev = -2;

        }

    }



    return rev;

}
",95.0,21.0,"ret:rev,prot:rog,rw:ru,",161.0,0.139585280418396,Greedy
2453,"static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t host_set;
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    /* Send SIGTRAP if we're single-stepping */
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;","static int do_sigframe_return_v2(CPUState *env, target_ulong frame__address,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t address_store;
    abi_ulong *argarray;
    target_to_host_sigset(&address_store, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &address_store, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame__address + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    /* Send SIGTRAP if we're single-stepping */
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;",107.0,29.0,"regspace:argarray,frame_addr:frame__address,host_set:address_store,",78.0,0.0935497760772705,Greedy
2455,"static void press_key(VncState *vs, int keysym)

{

    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);

    qemu_input_event_send_key_delay(0);

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);

    qemu_input_event_send_key_delay(0);

}
","static void press_key(VncState *rs, int keysem)

{

    int keycode = keysym2scancode(rs->vd->kbd_layout, keysem) & SCANCODE_KEYMASK;

    qemu_input_event_send_key_number(rs->vd->dcl.con, keycode, true);

    qemu_input_event_send_key_delay(0);

    qemu_input_event_send_key_number(rs->vd->dcl.con, keycode, false);

    qemu_input_event_send_key_delay(0);

}
",69.0,16.0,"vs:rs,keysym:keysem,",88.0,0.0836440642674764,Greedy
2457,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=dc2=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}
","static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int  strension){

    int info;

    int disc0, fc1;

    pixel4 dc0plugatch, dc2Spland;

    pixel *https = (pixel*)_src;

     strension /= sizeof(pixel);



    disc0=fc1=0;

    for(info=0;info<4; info++){

        disc0+= https[-1+info* strension];

        fc1+= https[-1+(info+4)* strension];

    }

    dc0plugatch = PIXEL_SPLAT_X4((disc0 + 2)>>2);

    dc2Spland = PIXEL_SPLAT_X4((fc1 + 2)>>2);



    for(info=0; info<4; info++){

        ((pixel4*)(https+info* strension))[0]=

        ((pixel4*)(https+info* strension))[1]= dc0plugatch;

    }

    for(info=4; info<8; info++){

        ((pixel4*)(https+info* strension))[0]=

        ((pixel4*)(https+info* strension))[1]= dc2Spland;

    }

}
",221.0,51.0,"dc2splat:dc2Spland,dc0splat:dc0plugatch,i:info,_src:_src,src:https,dc2:fc1,dc0:disc0,stride: strension,",470.0,0.4599906921386719,Greedy
2458,"static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,

                           const uint8_t *sps_pps, uint32_t sps_pps_size,

                           const uint8_t *in,      uint32_t in_size) {

    uint32_t offset = *poutbuf_size;

    uint8_t nal_header_size = offset ? 3 : 4;



    *poutbuf_size += sps_pps_size+in_size+nal_header_size;

    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);

    if (sps_pps)

        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);

    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);

    if (!offset)

        AV_WB32(*poutbuf+sps_pps_size, 1);

    else {

        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;

        (*poutbuf+offset)[2] = 1;

    }

}
","static void alloc_and_copy(uint8_t **pallvec,          int *poutbuf_loc,

                           const uint8_t *sips_ops, uint32_t sps_ps_c,

                           const uint8_t *as,      uint32_t planvalcapacity) {

    uint32_t offset = *poutbuf_loc;

    uint8_t nal_header_size = offset ? 3 : 4;



    *poutbuf_loc += sps_ps_c+planvalcapacity+nal_header_size;

    *pallvec = av_realloc(*pallvec, *poutbuf_loc);

    if (sips_ops)

        memcpy(*pallvec+offset, sips_ops, sps_ps_c);

    memcpy(*pallvec+sps_ps_c+nal_header_size+offset, as, planvalcapacity);

    if (!offset)

        AV_WB32(*pallvec+sps_ps_c, 1);

    else {

        (*pallvec+offset)[0] = (*pallvec+offset)[1] = 0;

        (*pallvec+offset)[2] = 1;

    }

}
",151.0,42.0,"in:as,in_size:planvalcapacity,sps_pps_size:sps_ps_c,poutbuf_size:poutbuf_loc,sps_pps:sips_ops,poutbuf:pallvec,",279.0,0.2513387997945149,Greedy
2460,"int float_near_ulp(float a, float b, unsigned max_ulp)

{

    union av_intfloat32 x, y;



    x.f = a;

    y.f = b;



    if (is_negative(x) != is_negative(y)) {

        // handle -0.0 == +0.0

        return a == b;

    }



    if (abs(x.i - y.i) <= max_ulp)

        return 1;



    return 0;

}
","int float_near_ulp(float a, float b, unsigned max_ulp)

{

    union av_intfloat32 x, z;



    x.f = a;

    z.f = b;



    if (is_negative(x) != is_negative(z)) {

        // handle -0.0 == +0.0

        return a == b;

    }



    if (abs(x.i - z.i) <= max_ulp)

        return 1;



    return 0;

}
",72.0,20.0,"y:z,",58.0,0.05092054605484,Greedy
2464,"static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)

{

    ff_wmv2_idct_c(block);

    put_pixels_clamped_c(block, dest, line_size);

}
","static void ff_wmv2_idct_put_c(uint8_t *feat, int line2weight, DCTELEM *chain)

{

    ff_wmv2_idct_c(chain);

    put_pixels_clamped_c(chain, feat, line2weight);

}
",31.0,10.0,"dest:feat,line_size:line2weight,block:chain,",122.0,0.1046341896057128,Greedy
2467,"static void write_target_close(BlockDriverState *bs) {

    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);

    bdrv_delete(s->qcow);

    free(s->qcow_filename);

}
","static void write_target_close(BlockDriverState *fs) {

    BDRVVVFATState* ss = *((BDRVVVFATState**) fs->opaque);

    bdrv_delete(ss->qcow);

    free(ss->qcow_filename);

}
",40.0,8.0,"bs:fs,s:ss,",88.0,0.0664248983065287,Greedy
2473,"void pal_init (CPUState *env)

{

}
","void pal_init (CPUState *db)

{

}
",9.0,2.0,"env:db,",32.0,0.0455855965614318,Greedy
2474,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,

                             uint32_t token, uint32_t nargs, target_ulong args,

                             uint32_t nret, target_ulong rets)

{

    if ((token >= TOKEN_BASE)

        && ((token - TOKEN_BASE) < TOKEN_MAX)) {

        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);



        if (call->fn) {

            call->fn(spapr, token, nargs, args, nret, rets);

            return H_SUCCESS;

        }

    }



    /* HACK: Some Linux early debug code uses RTAS display-character,

     * but assumes the token value is 0xa (which it is on some real

     * machines) without looking it up in the device tree.  This

     * special case makes this work */

    if (token == 0xa) {

        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);

        return H_SUCCESS;

    }



    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);

    rtas_st(rets, 0, -3);

    return H_PARAMETER;

}
","target_ulong spapr_rtas_call(sPAPREnvironment *spapprar,

                             uint32_t trial, uint32_t nargs, target_ulong args,

                             uint32_t nret, target_ulong ants)

{

    if ((trial >= TOKEN_BASE)

        && ((trial - TOKEN_BASE) < TOKEN_MAX)) {

        struct rtas_call *call = rtas_table + (trial - TOKEN_BASE);



        if (call->fn) {

            call->fn(spapprar, trial, nargs, args, nret, ants);

            return H_SUCCESS;

        }

    }



    /* HACK: Some Linux early debug code uses RTAS display-character,

     * but assumes the token value is 0xa (which it is on some real

     * machines) without looking it up in the device tree.  This

     * special case makes this work */

    if (trial == 0xa) {

        rtas_display_character(spapprar, 0xa, nargs, args, nret, ants);

        return H_SUCCESS;

    }



    hcall_dprintf(""Unknown RTAS token 0x%x\n"", trial);

    rtas_st(ants, 0, -3);

    return H_PARAMETER;

}
",132.0,38.0,"token:trial,spapr:spapprar,rets:ants,",210.0,0.2013985435167948,Greedy
2482,"const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)

{

    av_assert2(p < end);



    end-=2;

    p++;

    for(;p<end; p+=2){

        if(!*p){

            if     (!p[-1] && p[1]) return p - 1;

            else if(!p[ 1] && p[2]) return p;

        }

    }

    return end+2;

}
","const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict u, const uint8_t *av_restrict end)

{

    av_assert2(u < end);



    end-=2;

    u++;

    for(;u<end; u+=2){

        if(!*u){

            if     (!u[-1] && u[1]) return u - 1;

            else if(!u[ 1] && u[2]) return u;

        }

    }

    return end+2;

}
",94.0,21.0,"p:u,",86.0,0.0800898671150207,Greedy
2484,"static void cpu_set_irq(void *opaque, int irq, int level)

{

    CPUState *env = opaque;



    if (level) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);

        env->halted = 0;

        env->pil_in |= 1 << irq;

        cpu_check_irqs(env);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);

        env->pil_in &= ~(1 << irq);

        cpu_check_irqs(env);

    }

}
","static void cpu_set_irq(void *opaque, int virque, int code)

{

    CPUState *db = opaque;



    if (code) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", virque);

        db->halted = 0;

        db->pil_in |= 1 << virque;

        cpu_check_irqs(db);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", virque);

        db->pil_in &= ~(1 << virque);

        cpu_check_irqs(db);

    }

}
",84.0,20.0,"env:db,irq:virque,level:code,",184.0,0.1778558095296224,Greedy
2485,"static int get_stream_blocksize(BlockDriverState *bdrv)

{

    uint8_t cmd[6];

    uint8_t buf[12];

    uint8_t sensebuf[8];

    sg_io_hdr_t io_header;

    int ret;



    memset(cmd, 0, sizeof(cmd));

    memset(buf, 0, sizeof(buf));

    cmd[0] = MODE_SENSE;

    cmd[4] = sizeof(buf);



    memset(&io_header, 0, sizeof(io_header));

    io_header.interface_id = 'S';

    io_header.dxfer_direction = SG_DXFER_FROM_DEV;

    io_header.dxfer_len = sizeof(buf);

    io_header.dxferp = buf;

    io_header.cmdp = cmd;

    io_header.cmd_len = sizeof(cmd);

    io_header.mx_sb_len = sizeof(sensebuf);

    io_header.sbp = sensebuf;

    io_header.timeout = 6000; /* XXX */



    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);

    if (ret < 0 || io_header.driver_status || io_header.host_status) {

        return -1;

    }

    return (buf[9] << 16) | (buf[10] << 8) | buf[11];

}
","static int get_stream_blocksize(BlockDriverState *bdrv)

{

    uint8_t dc[6];

    uint8_t mem[12];

    uint8_t sensebuf[8];

    sg_io_hdr_t ios_server;

    int ret;



    memset(dc, 0, sizeof(dc));

    memset(mem, 0, sizeof(mem));

    dc[0] = MODE_SENSE;

    dc[4] = sizeof(mem);



    memset(&ios_server, 0, sizeof(ios_server));

    ios_server.interface_id = 'S';

    ios_server.dxfer_direction = SG_DXFER_FROM_DEV;

    ios_server.dxfer_len = sizeof(mem);

    ios_server.dxferp = mem;

    ios_server.cmdp = dc;

    ios_server.cmd_len = sizeof(dc);

    ios_server.mx_sb_len = sizeof(sensebuf);

    ios_server.sbp = sensebuf;

    ios_server.timeout = 6000; /* XXX */



    ret = bdrv_ioctl(bdrv, SG_IO, &ios_server);

    if (ret < 0 || ios_server.driver_status || ios_server.host_status) {

        return -1;

    }

    return (mem[9] << 16) | (mem[10] << 8) | mem[11];

}
",207.0,47.0,"io_header:ios_server,cmd:dc,buf:mem,",258.0,0.2903453985850016,Greedy
2488,"static void co_write_request(void *opaque)

{

    BDRVSheepdogState *s = opaque;



    qemu_coroutine_enter(s->co_send, NULL);

}
","static void co_write_request(void *opaque)

{

    BDRVSheepdogState *services = opaque;



    qemu_coroutine_enter(services->co_send, NULL);

}
",25.0,6.0,"s:services,",46.0,0.0451502720514933,Greedy
2506,"static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,

        int *need_next_header, int *new_frame_start)

{

    GetBitContext bits;

    AACADTSHeaderInfo hdr;

    int size;

    union {

        uint64_t u64;

        uint8_t  u8[8];

    } tmp;



    tmp.u64 = av_be2ne64(state);

    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);



    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)

        return 0;

    *need_next_header = 0;

    *new_frame_start  = 1;

    hdr_info->sample_rate = hdr.sample_rate;

    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];

    hdr_info->samples     = hdr.samples;

    hdr_info->bit_rate    = hdr.bit_rate;

    return size;

}
","static int aac_sync(uint64_t args, AACAC3ParseContext *hdr_info,

        int *need_next_message, int *new_frame2end)

{

    GetBitContext bits;

    AACADTSHeaderInfo hdr;

    int size;

    union {

        uint64_t u64;

        uint8_t  uint32[8];

    } tmp;



    tmp.u64 = av_be2ne64(args);

    init_get_bits(&bits, tmp.uint32+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);



    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)

        return 0;

    *need_next_message = 0;

    *new_frame2end  = 1;

    hdr_info->sample_rate = hdr.sample_rate;

    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];

    hdr_info->samples     = hdr.samples;

    hdr_info->bit_rate    = hdr.bit_rate;

    return size;

}
",139.0,33.0,"need_next_header:need_next_message,u8:uint32,state:args,new_frame_start:new_frame2end,",122.0,0.13431423107783,Greedy
2510,"static void spr_write_dbatu_h (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);

    RET_STOP(ctx);

}
","static void spr_write_dbatu_h (void *opaque, int Sprb)

{

    DisasContext *ctx = opaque;



    gen_op_store_dbatu((Sprb - SPR_DBAT4U) / 2);

    RET_STOP(ctx);

}
",35.0,10.0,"sprn:Sprb,",33.0,0.0423151016235351,Greedy
2511,"sprintf_len(char *string, const char *format, ...)

#else

sprintf_len(va_alist) va_dcl

#endif

{

	va_list args;

#ifdef __STDC__

	va_start(args, format);

#else

	char *string;

	char *format;

	va_start(args);

	string = va_arg(args, char *);

	format = va_arg(args, char *);

#endif

	vsprintf(string, format, args);

	return strlen(string);

}
","sprintf_len(char *string, const char *package, ...)

#else

sprintf_len(va_alist) va_dcl

#endif

{

	va_list args;

#ifdef __STDC__

	va_start(args, package);

#else

	char *string;

	char *package;

	va_start(args);

	string = va_arg(args, char *);

	package = va_arg(args, char *);

#endif

	vsprintf(string, package, args);

	return strlen(string);

}
",84.0,28.0,"format:package,",59.0,0.059631594022115,Greedy
2528,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;

    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        codec->codec_id == AV_CODEC_ID_H264 &&

        atom.size > 11) {

        avio_skip(pb, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pb) == 0xd4d)

            codec->width = 1440;

        return 0;

    }



    return mov_read_avid(c, pb, atom);

}
","static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVCodecContext *odac = c->fc->streams[c->fc->nb_streams-1]->odac;

    if (odac->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        odac->codec_id == AV_CODEC_ID_H264 &&

        atom.size > 11) {

        avio_skip(pb, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pb) == 0xd4d)

            odac->width = 1440;

        return 0;

    }



    return mov_read_avid(c, pb, atom);

}
",108.0,21.0,"codec:odac,",75.0,0.0786152958869934,Greedy
2529,"void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)

{

    SaveStateEntry *se, *new_se;



    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {

        if (se->vmsd == vmsd && se->opaque == opaque) {

            TAILQ_REMOVE(&savevm_handlers, se, entry);

            qemu_free(se);

        }

    }

}
","void vmstate_unregister(const VMStateDescription *vmesd, void *copaque)

{

    SaveStateEntry *ce, *new_sem;



    TAILQ_FOREACH_SAFE(ce, &savevm_handlers, entry, new_sem) {

        if (se->ceesd == vmesd && sececopaque == copaque) {

            TAILQ_REMOVE(&savevm_handlers, ce, entry);

            qemu_free(ce);

        }

    }

}
",66.0,20.0,"vmsd:vmesd,opaque:copaque,se:ce,new_se:new_sem,",325.0,0.3497793833414713,GA
2535,"static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        env->avr[n].u64[0] = ldq_p(mem_buf);

        env->avr[n].u64[1] = ldq_p(mem_buf+8);

#else

        env->avr[n].u64[1] = ldq_p(mem_buf);

        env->avr[n].u64[0] = ldq_p(mem_buf+8);

#endif

        return 16;

    }

    if (n == 33) {

        env->vscr = ldl_p(mem_buf);

        return 4;

    }

    if (n == 34) {

        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);

        return 4;

    }

    return 0;

}
","static int gdb_set_avr_reg(CPUState * en, uint8_t *mem0buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

         en->avr[n].u64[0] = ldq_p(mem0buf);

         en->avr[n].u64[1] = ldq_p(mem0buf+8);

#else

         en->avr[n].u64[1] = ldq_p(mem0buf);

         en->avr[n].u64[0] = ldq_p(mem0buf+8);

#endif

        return 16;

    }

    if (n == 33) {

         en->vscr = ldl_p(mem0buf);

        return 4;

    }

    if (n == 34) {

         en->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem0buf);

        return 4;

    }

    return 0;

}
",153.0,31.0,"mem_buf:mem0buf,env: en,",144.0,0.1548733274141947,Greedy
2537,"int64_t qemu_ftell(QEMUFile *f)

{

    qemu_fflush(f);

    return f->pos;

}
","int64_t qemu_ftell(QEMUFile *fs)

{

    qemu_fflush(fs);

    return fs->pos;

}
",19.0,5.0,"f:fs,",44.0,0.0383341709772745,Greedy
2538,"static int libquvi_read_packet(AVFormatContext *s, AVPacket *pkt)

{

    LibQuviContext *qc = s->priv_data;

    return av_read_frame(qc->fmtctx, pkt);

}
","static int libquvi_read_packet(AVFormatContext *s, AVPacket *Pkg)

{

    LibQuviContext *qc = s->priv_data;

    return av_read_frame(qc->fmtctx, Pkg);

}
",32.0,8.0,"pkt:Pkg,",33.0,0.0465499560038248,Greedy
2543,"static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){

    int i;



    for(i=0; i<w-1; i++){

        acc+= src[i];

        dst[i]= acc & mask;

        i++;

        acc+= src[i];

        dst[i]= acc & mask;

    }



    for(; i<w; i++){

        acc+= src[i];

        dst[i]= acc & mask;

    }



    return acc;

}
","static int add_hfyu_left_prediction_int16_c(uint16_t *ldsts, const uint16_t *support, unsigned mask, int weight, int anc){

    int i;



    for(i=0; i<weight-1; i++){

        anc+= support[i];

        ldsts[i]= anc & mask;

        i++;

        anc+= support[i];

        ldsts[i]= anc & mask;

    }



    for(; i<weight; i++){

        anc+= support[i];

        ldsts[i]= anc & mask;

    }



    return anc;

}
",110.0,37.0,"w:weight,src:support,dst:ldsts,acc:anc,",245.0,0.2226684888203939,Greedy
2549,"bool aio_pending(AioContext *ctx)

{

    AioHandler *node;

    bool result = false;



    /*

     * We have to walk very carefully in case aio_set_fd_handler is

     * called while we're walking.

     */

    qemu_lockcnt_inc(&ctx->list_lock);

    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {

        if (node->pfd.revents && node->io_notify) {

            result = true;

            break;

        }



        if ((node->pfd.revents & G_IO_IN) && node->io_read) {

            result = true;

            break;

        }

        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {

            result = true;

            break;

        }

    }



    qemu_lockcnt_dec(&ctx->list_lock);

    return result;

}
","bool aio_pending(AioContext *cm)

{

    AioHandler *root;

    bool result = false;



    /*

     * We have to walk very carefully in case aio_set_fd_handler is

     * called while we're walking.

     */

    qemu_lockcnt_inc(&cm->list_lock);

    QLIST_FOREACH_RCU(root, &cm->aio_handlers, root) {

        if (root->pfd.revents && root->io_notify) {

            result = true;

            break;

        }



        if ((root->pfd.revents & G_IO_IN) && root->io_read) {

            result = true;

            break;

        }

        if ((root->pfd.revents & G_IO_OUT) && root->io_write) {

            result = true;

            break;

        }

    }



    qemu_lockcnt_dec(&cm->list_lock);

    return result;

}
",119.0,24.0,"node:root,ctx:cm,",140.0,0.1178867022196451,Greedy
2553,"static av_cold int roq_decode_init(AVCodecContext *avctx)

{

    RoqContext *s = avctx->priv_data;



    s->avctx = avctx;



    if (avctx->width % 16 || avctx->height % 16) {

        av_log(avctx, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return AVERROR_PATCHWELCOME;

    }



    s->width = avctx->width;

    s->height = avctx->height;



    s->last_frame    = av_frame_alloc();

    s->current_frame = av_frame_alloc();

    if (!s->current_frame || !s->last_frame) {

        av_frame_free(&s->current_frame);

        av_frame_free(&s->last_frame);

        return AVERROR(ENOMEM);

    }



    avctx->pix_fmt = AV_PIX_FMT_YUV444P;



    return 0;

}
","static av_cold int roq_decode_init(AVCodecContext *varctx)

{

    RoqContext *aws = varctx->priv_data;



    aws->varctx = varctx;



    if (varctx->width % 16 || varctx->height % 16) {

        av_log(varctx, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return AVERROR_PATCHWELCOME;

    }



    aws->width = varctx->width;

    aws->height = varctx->height;



    aws->last_frame    = av_frame_alloc();

    aws->current_frame = av_frame_alloc();

    if (!aws->current_frame || !aws->last_frame) {

        av_frame_free(&aws->current_frame);

        av_frame_free(&aws->last_frame);

        return AVERROR(ENOMEM);

    }



    varctx->pix_fmt = AV_PIX_FMT_YUV444P;



    return 0;

}
",132.0,31.0,"s:aws,avctx:varctx,",177.0,0.1464993397394816,Greedy
2557,"int path_is_absolute(const char *path)

{

    const char *p;

#ifdef _WIN32

    /* specific case for names like: ""\\.\d:"" */

    if (*path == '/' || *path == '\\')

        return 1;

#endif

    p = strchr(path, ':');

    if (p)

        p++;

    else

        p = path;

#ifdef _WIN32

    return (*p == '/' || *p == '\\');

#else

    return (*p == '/');

#endif

}
","int path_is_absolute(const char *anc)

{

    const char *p;

#ifdef _WIN32

    /* specific case for names like: ""\\.\d:"" */

    if (*anc == '/' || *anc == '\\')

        return 1;

#endif

    p = strchr(anc, ':');

    if (p)

        p++;

    else

        p = anc;

#ifdef _WIN32

    return (*p == '/' || *p == '\\');

#else

    return (*p == '/');

#endif

}
",87.0,17.0,"path:anc,",71.0,0.0690191864967346,Greedy
2560,"void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,

                                         src - (stride * 2),

                                         stride, dst, stride);

}
","void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *iv,

                                ptrdiff_t trade)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(iv + trade - 2,

                                         iv - (trade * 2),

                                         trade, dst, trade);

}
",40.0,12.0,"src:iv,stride:trade,",111.0,0.0966048041979471,Greedy
2563,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
","static void render_line(int x0, uint8_t dy1, int ix0, int zone, float *feed)

{

    int dy  = zone - dy1;

    int adx = ix0 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    feed[x0] = ff_vorbis_floor1_inverse_db_table[dy1];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, dy1, ix0, sy, ady, adx, feed);

    } else {

        int base  = dy / adx;

        int ex     = x0;

        uint8_t y = dy1;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++ex < ix0) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            feed[ex] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
",170.0,59.0,"y1:zone,x:ex,buf:feed,x1:ix0,y0:dy1,",189.0,0.1885787963867187,Greedy
2565,"static BufferPoolEntry *get_pool(AVBufferPool *pool)

{

    BufferPoolEntry *cur = NULL, *last = NULL;



    do {

        FFSWAP(BufferPoolEntry*, cur, last);

        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);

        if (!cur)

            return NULL;

    } while (cur != last);



    return cur;

}
","static BufferPoolEntry *get_pool(AVBufferPool *wrapper)

{

    BufferPoolEntry *build = NULL, *est = NULL;



    do {

        FFSWAP(BufferPoolEntry*, build, est);

        build = avpriv_atomic_ptr_cas((void * volatile *)&wrapper->wrapper, est, NULL);

        if (!build)

            return NULL;

    } while (build != est);



    return build;

}
",73.0,15.0,"pool:wrapper,last:est,cur:build,",179.0,0.1537285208702087,Greedy
2566,"static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,

                          int *end_pos2)

{

    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {

        s->gb           = s->in_gb;

        s->in_gb.buffer = NULL;

        assert((get_bits_count(&s->gb) & 7) == 0);

        skip_bits_long(&s->gb, *pos - *end_pos);

        *end_pos2 =

        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;

        *pos      = get_bits_count(&s->gb);

    }

}
","static void switch_buffer(MPADecodeContext *s, int *slice, int *edge_part,

                          int *end_po4)

{

    if (s->in_gb.buffer && *slice >= s->gb.size_in_bits) {

        s->gb           = s->in_gb;

        s->in_gb.buffer = NULL;

        assert((get_bits_count(&s->gb) & 7) == 0);

        skip_bits_long(&s->gb, *slice - *edge_part);

        *end_po4 =

        *edge_part  = *end_po4 + get_bits_count(&s->gb) - *slice;

        *slice      = get_bits_count(&s->gb);

    }

}
",119.0,27.0,"end_pos:edge_part,end_pos2:end_po4,pos:slice,",140.0,0.1301534215609232,Greedy
2573,"static void usb_tablet_class_initfn(ObjectClass *klass, void *data)

{

    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);



    uc->init           = usb_tablet_initfn;

    uc->product_desc   = ""QEMU USB Tablet"";

    uc->usb_desc       = &desc_tablet;

    uc->handle_packet  = usb_generic_handle_packet;

    uc->handle_reset   = usb_hid_handle_reset;

    uc->handle_control = usb_hid_handle_control;

    uc->handle_data    = usb_hid_handle_data;

    uc->handle_destroy = usb_hid_handle_destroy;

}
","static void usb_tablet_class_initfn(ObjectClass *klass, void *data)

{

    USBDeviceClass *acc = USB_DEVICE_CLASS(klass);



    acc->init           = usb_tablet_initfn;

    acc->product_desc   = ""QEMU USB Tablet"";

    acc->usb_desc       = &desc_tablet;

    acc->handle_packet  = usb_generic_handle_packet;

    acc->handle_reset   = usb_hid_handle_reset;

    acc->handle_control = usb_hid_handle_control;

    acc->handle_data    = usb_hid_handle_data;

    acc->handle_destroy = usb_hid_handle_destroy;

}
",73.0,21.0,"uc:acc,",70.0,0.0718306461970011,Greedy
2582,"int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)

{

    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));



    entry->rect.x = x;

    entry->rect.y = y;

    entry->rect.w = w;

    entry->rect.h = h;



    vnc_lock_queue(queue);

    QLIST_INSERT_HEAD(&job->rectangles, entry, next);

    vnc_unlock_queue(queue);

    return 1;

}
","int vnc_job_add_rect(VncJob *command, int address, int type, int weight, int p)

{

    VncRectEntry *info = g_malloc0(sizeof(VncRectEntry));



    info->rect.address = address;

    info->rect.type = type;

    info->rect.weight = weight;

    info->rect.p = p;



    vnc_lock_queue(queue);

    QLIST_INSERT_HEAD(&command->rectangles, info, next);

    vnc_unlock_queue(queue);

    return 1;

}
",90.0,25.0,"job:command,x:address,y:type,w:weight,h:p,entry:info,",270.0,0.2653772950172424,Greedy
2587,"static int standard_decode_picture_primary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0;



    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);

    skip_bits(gb, 2); //framecnt unused

    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);

    v->s.pict_type = get_bits(gb, 1);

    if (v->s.avctx->max_b_frames)

    {

        if (!v->s.pict_type)

        {

            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;

            else v->s.pict_type = B_TYPE;

        }

        else v->s.pict_type = P_TYPE;

    }

    else v->s.pict_type++;



    switch (v->s.pict_type)

    {

    case I_TYPE: status = decode_i_picture_header(v); break;

    case P_TYPE: status = decode_p_picture_primary_header(v); break;

    case BI_TYPE:

    case B_TYPE: status = decode_b_picture_primary_header(v); break;

    }



    if (status == FRAME_SKIPED)

    {

      av_log(v->s.avctx, AV_LOG_INFO, ""Skipping frame...\n"");

      return status;

    }

    return 0;

}
","static int standard_decode_picture_primary_header(VC9Context *v)

{

    GetBitContext *gb = &v->S.gb;

    int status = 0;



    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);

    skip_bits(gb, 2); //framecnt unused

    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);

    v->S.pict_type = get_bits(gb, 1);

    if (v->S.avctx->max_b_frames)

    {

        if (!v->S.pict_type)

        {

            if (get_bits(gb, 1)) v->S.pict_type = I_TYPE;

            else v->S.pict_type = B_TYPE;

        }

        else v->S.pict_type = P_TYPE;

    }

    else v->S.pict_type++;



    switch (v->S.pict_type)

    {

    case I_TYPE: status = decode_i_picture_header(v); break;

    case P_TYPE: status = decode_p_picture_primary_header(v); break;

    case BI_TYPE:

    case B_TYPE: status = decode_b_picture_primary_header(v); break;

    }



    if (status == FRAME_SKIPED)

    {

      av_log(v->S.avctx, AV_LOG_INFO, ""Skipping frame...\n"");

      return status;

    }

    return 0;

}
",224.0,49.0,"s:S,",107.0,0.1096472938855489,Greedy
2591,"static void vnc_display_print_local_addr(VncDisplay *vd)

{

    SocketAddressLegacy *addr;

    Error *err = NULL;



    if (!vd->nlsock) {

        return;

    }



    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);

    if (!addr) {

        return;

    }



    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {

        qapi_free_SocketAddressLegacy(addr);

        return;

    }

    error_printf_unless_qmp(""VNC server running on %s:%s\n"",

                            addr->u.inet.data->host,

                            addr->u.inet.data->port);

    qapi_free_SocketAddressLegacy(addr);

}
","static void vnc_display_print_local_addr(VncDisplay *vd)

{

    SocketAddressLegacy *dc;

    Error *err = NULL;



    if (!vd->nlsock) {

        return;

    }



    dc = qio_channel_socket_get_local_address(vd->lsock[0], &err);

    if (!dc) {

        return;

    }



    if (dc->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {

        qapi_free_SocketAddressLegacy(dc);

        return;

    }

    error_printf_unless_qmp(""VNC server running on %s:%s\n"",

                            dc->u.inet.data->host,

                            dc->u.inet.data->port);

    qapi_free_SocketAddressLegacy(dc);

}
",104.0,19.0,"addr:dc,",94.0,0.0868958671887715,Greedy
2592,"static int v9fs_synth_lstat(FsContext *fs_ctx,

                            V9fsPath *fs_path, struct stat *stbuf)

{

    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;



    v9fs_synth_fill_statbuf(node, stbuf);

    return 0;

}
","static int v9fs_synth_lstat(FsContext *ns_obj,

                            V9fsPath *fs_path, struct stat *STbuffer)

{

    V9fsSynthNode *tree = *(V9fsSynthNode **)fs_path->data;



    v9fs_synth_fill_statbuf(tree, STbuffer);

    return 0;

}
",43.0,9.0,"stbuf:STbuffer,fs_ctx:ns_obj,node:tree,",80.0,0.086719004313151,Greedy
2593,"static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *s = avctx->priv_data;
    ff_qsv_decode_close(&s->qsv);
    qsv_clear_buffers(s);
    av_fifo_free(s->packet_fifo);
    return 0;
}","static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *args = avctx->priv_data;
    ff_qsv_decode_close(&args->qsv);
    qsv_clear_buffers(args);
    av_fifo_free(args->packet_fifo);
    return 0;
}",42.0,11.0,"s:args,",62.0,0.0762022614479065,Greedy
2596,"static void armv7m_nvic_clear_pending(void *opaque, int irq)

{

    NVICState *s = (NVICState *)opaque;

    VecInfo *vec;



    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);



    vec = &s->vectors[irq];

    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);

    if (vec->pending) {

        vec->pending = 0;

        nvic_irq_update(s);

    }

}
","static void armv7m_nvic_clear_pending(void *opaque, int irq)

{

    NVICState *s = (NVICState *)opaque;

    VecInfo *cer;



    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);



    cer = &s->vectors[irq];

    trace_nvic_clear_pending(irq, cer->enabled, cer->prio);

    if (cer->pending) {

        cer->pending = 0;

        nvic_irq_update(s);

    }

}
",82.0,22.0,"vec:cer,",79.0,0.071153195699056,Greedy
2597,"static void vararg_string(void)

{

    int i;

    struct {

        const char *decoded;

    } test_cases[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },

        {}

    };



    for (i = 0; test_cases[i].decoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);



        g_assert(obj != NULL);

        g_assert(qobject_type(obj) == QTYPE_QSTRING);

        

        str = qobject_to_qstring(obj);

        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);



        QDECREF(str);

    }

}
","static void vararg_string(void)

{

    int i;

    struct {

        const char *decoded;

    } test_cases[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },

        {}

    };



    for (i = 0; test_cases[i].decoded; i++) {

        QObject *module;

        QString *str;



        module = qobject_from_jsonf(""%s"", test_cases[i].decoded);



        g_assert(module != NULL);

        g_assert(qobject_type(module) == QTYPE_QSTRING);

        

        str = qobject_to_qstring(module);

        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);



        QDECREF(str);

    }

}
",128.0,30.0,"obj:module,",81.0,0.0822577357292175,Greedy
2602,"int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)

{

    if (!mb_x) {

        return mb_y ? VERT_VP8_PRED : DC_129_PRED;

    } else {

        return mb_y ? mode : HOR_VP8_PRED;

    }

}
","int check_tm_pred4x4_mode(int type, int mb_x, int mb_y)

{

    if (!mb_x) {

        return mb_y ? VERT_VP8_PRED : DC_129_PRED;

    } else {

        return mb_y ? type : HOR_VP8_PRED;

    }

}
",38.0,11.0,"mode:type,",50.0,0.0642205913861592,Greedy
2605,"static void qemu_clock_init(QEMUClockType type)

{

    QEMUClock *clock = qemu_clock_ptr(type);



    /* Assert that the clock of type TYPE has not been initialized yet. */

    assert(main_loop_tlg.tl[type] == NULL);



    clock->type = type;

    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);

    clock->last = INT64_MIN;

    QLIST_INIT(&clock->timerlists);

    notifier_list_init(&clock->reset_notifiers);

    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);

}
","static void qemu_clock_init(QEMUClockType type)

{

    QEMUClock *keeper = qemu_clock_ptr(type);



    /* Assert that the clock of type TYPE has not been initialized yet. */

    assert(main_loop_tlg.tl[type] == NULL);



    keeper->type = type;

    keeper->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);

    keeper->last = INT64_MIN;

    QLIST_INIT(&keeper->timerlists);

    notifier_list_init(&keeper->reset_notifiers);

    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);

}
",88.0,23.0,"clock:keeper,",74.0,0.0699019948641459,Greedy
2615,"void *rom_ptr(target_phys_addr_t addr)

{

    Rom *rom;



    rom = find_rom(addr);

    if (!rom || !rom->data)

        return NULL;

    return rom->data + (addr - rom->addr);

}
","void *rom_ptr(target_phys_addr_t host)

{

    Rom *cm;



    cm = find_rom(host);

    if (!cm || !cm->data)

        return NULL;

    return cm->data + (host - cm->host);

}
",46.0,11.0,"addr:host,rom:cm,",134.0,0.1199326197306315,Greedy
2617,"long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong r0;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &frame->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &frame->extramask[i - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &frame->sc, &r0))

        goto badframe;



    unlock_user_struct(frame, frame_addr, 0);

    return r0;



badframe:

    unlock_user_struct(frame, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
","long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *processor;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong r0;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, processor, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &processor->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &processor->extramask[i - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &processor->sc, &r0))

        goto badframe;



    unlock_user_struct(processor, frame_addr, 0);

    return r0;



badframe:

    unlock_user_struct(processor, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
",203.0,50.0,"frame:processor,",96.0,0.1009833812713623,Greedy
2618,"static void apic_reset_common(DeviceState *dev)

{

    APICCommonState *s = APIC_COMMON(dev);

    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);

    bool bsp;



    bsp = cpu_is_bsp(s->cpu);

    s->apicbase = APIC_DEFAULT_ADDRESS |

        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;



    s->vapic_paddr = 0;

    info->vapic_base_update(s);



    apic_init_reset(dev);



    if (bsp) {

        /*

         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization

         * time typically by BIOS, so PIC interrupt can be delivered to the

         * processor when local APIC is enabled.

         */

        s->lvt[APIC_LVT_LINT0] = 0x700;

    }

}
","static void apic_reset_common(DeviceState *dev)

{

    APICCommonState *sym = APIC_COMMON(dev);

    APICCommonClass *mis = APIC_COMMON_GET_CLASS(sym);

    bool bsp;



    bsp = cpu_is_bsp(sym->cpu);

    sym->apicbase = APIC_DEFAULT_ADDRESS |

        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;



    sym->vapic_paddr = 0;

    mis->vapic_base_update(sym);



    apic_init_reset(dev);



    if (bsp) {

        /*

         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization

         * time typically by BIOS, so PIC interrupt can be delivered to the

         * processor when local APIC is enabled.

         */

        sym->lvt[APIC_LVT_LINT0] = 0x700;

    }

}
",89.0,25.0,"info:mis,s:sym,",116.0,0.0950566013654073,Greedy
2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}
","static void omap_pwt_init(target_phys_addr_t temp, struct omap_mpu_state_s *server,

                omap_clk clk)

{

    int iomemtype;



    server->pwt.temp = temp;

    server->pwt.clk = clk;

    omap_pwt_reset(server);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, server);

    cpu_register_physical_memory(server->pwt.temp, 0x800, iomemtype);

}
",67.0,19.0,"s:server,base:temp,",147.0,0.1269490679105122,Greedy
2621,"static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

{

    int async_ret;

    BlockDriverAIOCB *acb;

    struct iovec iov;

    QEMUIOVector qiov;



    async_ret = NOT_DONE;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&qiov, &iov, 1);



    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,

                                  bdrv_rw_em_cb, &async_ret);

    if (acb == NULL) {

        async_ret = -1;

        goto fail;

    }



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();

    }





fail:

    return async_ret;

}
","static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

{

    int async_ret;

    BlockDriverAIOCB *acbr;

    struct iovec iov;

    QEMUIOVector qiov;



    async_ret = NOT_DONE;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&qiov, &iov, 1);



    acbr = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,

                                  bdrv_rw_em_cb, &async_ret);

    if (acbr == NULL) {

        async_ret = -1;

        goto fail;

    }



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();

    }





fail:

    return async_ret;

}
",122.0,33.0,"acb:acbr,",64.0,0.0675950249036153,Greedy
2625,"static int decode_5(SANMVideoContext *ctx)

{

#if HAVE_BIGENDIAN

    uint16_t *frm;

    int npixels;

#endif

    uint8_t *dst = (uint8_t*)ctx->frm0;



    if (rle_decode(ctx, dst, ctx->buf_size))

        return AVERROR_INVALIDDATA;



#if HAVE_BIGENDIAN

    npixels = ctx->npixels;

    frm = ctx->frm0;

    while (npixels--)

        *frm++ = av_bswap16(*frm);

#endif



    return 0;

}
","static int decode_5(SANMVideoContext *context)

{

#if HAVE_BIGENDIAN

    uint16_t *frm;

    int npixels;

#endif

    uint8_t *dst = (uint8_t*)context->frm0;



    if (rle_decode(context, dst, context->buf_size))

        return AVERROR_INVALIDDATA;



#if HAVE_BIGENDIAN

    npixels = context->npixels;

    frm = context->frm0;

    while (npixels--)

        *frm++ = av_bswap16(*frm);

#endif



    return 0;

}
",83.0,21.0,"ctx:context,",78.0,0.0737644513448079,Greedy
2627,"static void bdrv_co_drain_bh_cb(void *opaque)

{

    BdrvCoDrainData *data = opaque;

    Coroutine *co = data->co;



    qemu_bh_delete(data->bh);

    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(co, NULL);

}
","static void bdrv_co_drain_bh_cb(void *opaque)

{

    BdrvCoDrainData *data = opaque;

    Coroutine *cost = data->cost;



    qemu_bh_delete(data->bh);

    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(cost, NULL);

}
",51.0,13.0,"opaque:opaque,co:cost,",84.0,0.0961956222852071,Greedy
2629,"static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,

                                             GIOCondition condition,

                                             gpointer user_data)

{

    QIOTask *task = user_data;

    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(

        qio_task_get_source(task));



    qio_channel_tls_handshake_task(

       tioc, task);



    object_unref(OBJECT(tioc));



    return FALSE;

}
","static gboolean qio_channel_tls_handshake_io(QIOChannel *atioc,

                                             GIOCondition func,

                                             gpointer userpoolclass)

{

    QIOTask *address = userpoolclass;

    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(

        qio_task_get_source(address));



    qio_channel_tls_handshake_task(

       tioc, address);



    object_unref(OBJECT(tioc));



    return FALSE;

}
",52.0,16.0,"condition:func,user_data:userpoolclass,ioc:atioc,task:address,",132.0,0.1324732700983683,Greedy
2631,"static void flat_print_key_prefix(WriterContext *wctx)

{

    FlatContext *flat = wctx->priv;

    const struct section *parent_section = wctx->section[wctx->level-1];



    printf(""%s"", flat->section_header[wctx->level].str);



    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {

        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?

            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];

        printf(""%d%s"", n, flat->sep_str);

    }

}
","static void flat_print_key_prefix(WriterContext *Wcss)

{

    FlatContext *empty = Wcss->priv;

    const struct section * parent_sect = Wcss->section[Wcss->level-1];



    printf(""%s"", empty->section_header[Wcss->level].str);



    if ( parent_sect->flags & SECTION_FLAG_IS_ARRAY) {

        int n =  parent_sect->id == SECTION_ID_PACKETS_AND_FRAMES ?

            Wcss->nb_section_packet_frame : Wcss->nb_item[Wcss->level-1];

        printf(""%d%s"", n, empty->sep_str);

    }

}
",98.0,21.0,"wctx:Wcss,parent_section: parent_sect,flat:empty,",163.0,0.1713730017344157,Greedy
2635,"static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    IntelHDAState *d = opaque;

    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);



    intel_hda_reg_write(d, reg, val, 0xffffffff);

}
","static void intel_hda_mmio_writel(void *openacity, target_phys_addr_t host, uint32_t val)

{

    IntelHDAState *d = openacity;

    const IntelHDAReg *reg = intel_hda_reg_find(d, host);



    intel_hda_reg_write(d, reg, val, 0xffffffff);

}
",45.0,14.0,"addr:host,opaque:openacity,",75.0,0.0673475623130798,Greedy
2639,"static int jazz_led_init(SysBusDevice *dev)

{

    LedState *s = FROM_SYSBUS(LedState, dev);



    memory_region_init_io(&s->iomem, &led_ops, s, ""led"", 1);

    sysbus_init_mmio(dev, &s->iomem);



    s->ds = graphic_console_init(jazz_led_update_display,

                                 jazz_led_invalidate_display,

                                 jazz_led_screen_dump,

                                 jazz_led_text_update, s);



    return 0;

}
","static int jazz_led_init(SysBusDevice *phy)

{

    LedState *args = FROM_SYSBUS(LedState, phy);



    memory_region_init_io(&args->iomem, &led_ops, args, ""led"", 1);

    sysbus_init_mmio(phy, &args->iomem);



    args->ds = graphic_console_init(jazz_led_update_display,

                                 jazz_led_invalidate_display,

                                 jazz_led_screen_dump,

                                 jazz_led_text_update, args);



    return 0;

}
",69.0,20.0,"dev:phy,s:args,",116.0,0.1156785249710083,Greedy
2642,"int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *qdev, **qdevs;

    BusChild *kid;

    int i, num, ret = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        num++;

    }



    /* Copy out into an array of pointers */

    qdevs = g_malloc(sizeof(qdev) * num);

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        qdevs[num++] = kid->child;

    }



    /* Sort the array */

    qsort(qdevs, num, sizeof(qdev), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdevs);



    return ret;

}
","int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *qdev, **qdevices;

    BusChild *kid;

    int i, num, ret = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        num++;

    }



    /* Copy out into an array of pointers */

    qdevices = g_malloc(sizeof(qdev) * num);

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        qdevices[num++] = kid->child;

    }



    /* Sort the array */

    qsort(qdevices, num, sizeof(qdev), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevices[i]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdevices);



    return ret;

}
",179.0,48.0,"qdevs:qdevices,",147.0,0.1164231340090433,Greedy
2648,"void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,

                         int is_write, target_phys_addr_t access_len)

{

    if (buffer != bounce.buffer) {

        if (is_write) {

            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);

            while (access_len) {

                unsigned l;

                l = TARGET_PAGE_SIZE;

                if (l > access_len)

                    l = access_len;

                invalidate_and_set_dirty(addr1, l);

                addr1 += l;

                access_len -= l;

            }

        }

        if (xen_enabled()) {

            xen_invalidate_map_cache_entry(buffer);

        }

        return;

    }

    if (is_write) {

        address_space_write(as, bounce.addr, bounce.buffer, access_len);

    }

    qemu_vfree(bounce.buffer);

    bounce.buffer = NULL;

    cpu_notify_map_clients();

}
","void address_space_unmap(AddressSpace *was, void *buffer, target_phys_addr_t len,

                         int IS_network, target_phys_addr_t accesslsize)

{

    if (buffer != bounce.buffer) {

        if (IS_network) {

            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);

            while (accesslsize) {

                unsigned l;

                l = TARGET_PAGE_SIZE;

                if (l > accesslsize)

                    l = accesslsize;

                invalidate_and_set_dirty(addr1, l);

                addr1 += l;

                accesslsize -= l;

            }

        }

        if (xen_enabled()) {

            xen_invalidate_map_cache_entry(buffer);

        }

        return;

    }

    if (IS_network) {

        address_space_write(was, bounce.addr, bounce.buffer, accesslsize);

    }

    qemu_vfree(bounce.buffer);

    bounce.buffer = NULL;

    cpu_notify_map_clients();

}
",137.0,40.0,"access_len:accesslsize,buffer:buffer,is_write:IS_network,as:was,",212.0,0.1499718427658081,Greedy
2650,"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)

{

#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}
","static uint32_t unassigned_mem_readl(void *Opacity, target_phys_addr_t address)

{

#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", address);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(address, 0, 0, 0, 4);

#endif

    return 0;

}
",61.0,12.0,"opaque:Opacity,addr:address,",68.0,0.0535275737444559,Greedy
2653,"void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    sPAPREventLogEntry *entry = NULL;



    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {

        QTAILQ_REMOVE(&spapr->pending_events, entry, next);

        g_free(entry->extended_log);

        g_free(entry);

    }

}
","void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    sPAPREventLogEntry *ger = NULL;



    QTAILQ_FOREACH(ger, &spapr->pending_events, next) {

        QTAILQ_REMOVE(&spapr->pending_events, ger, next);

        g_free(ger->extended_log);

        g_free(ger);

    }

}
",53.0,15.0,"entry:ger,",65.0,0.0532679359118143,Greedy
2654,"static void sclp_set_write_mask(void)

{

    WriteEventMask *sccb = (void*)_sccb;



    sccb->h.length = sizeof(WriteEventMask);

    sccb->mask_length = sizeof(unsigned int);

    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;



    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);

}
","static void sclp_set_write_mask(void)

{

    WriteEventMask *srcbb = (void*)_sccb;



    srcbb->h.length = sizeof(WriteEventMask);

    srcbb->mask_length = sizeof(unsigned int);

    srcbb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    srcbb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    srcbb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;

    srcbb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;



    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, srcbb);

}
",70.0,17.0,"sccb:srcbb,",138.0,0.0822420199712117,Greedy
2655,"void json_prop_int(QJSON *json, const char *name, int64_t val)

{

    json_emit_element(json, name);

    qstring_append_int(json->str, val);

}
","void json_prop_int(QJSON *temp, const char *name, int64_t val)

{

    json_emit_element(temp, name);

    qstring_append_int(temp->str, val);

}
",33.0,10.0,"json:temp,",53.0,0.0424831350644429,Greedy
2656,"static void pm_update_sci(PIIX4PMState *s)

{

    int sci_level, pmsts;



    pmsts = acpi_pm1_evt_get_sts(&s->ar);

    sci_level = (((pmsts & s->ar.pm1.evt.en) &

                  (ACPI_BITMASK_RT_CLOCK_ENABLE |

                   ACPI_BITMASK_POWER_BUTTON_ENABLE |

                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |

                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||

        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &

          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);



    qemu_set_irq(s->irq, sci_level);

    /* schedule a timer interruption if needed */

    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&

                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));

}
","static void pm_update_sci(PIIX4PMState *your)

{

    int sciianpass, cmsts;



    cmsts = acpi_pm1_evt_get_sts(&your->ar);

    sciianpass = (((cmsts & your->ar.pm1.evt.en) &

                  (ACPI_BITMASK_RT_CLOCK_ENABLE |

                   ACPI_BITMASK_POWER_BUTTON_ENABLE |

                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |

                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||

        (((your->ar.gpe.sts[0] & your->ar.gpe.en[0]) &

          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);



    qemu_set_irq(your->irq, sciianpass);

    /* schedule a timer interruption if needed */

    acpi_pm_tmr_update(&your->ar, (your->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&

                       !(cmsts & ACPI_BITMASK_TIMER_STATUS));

}
",131.0,27.0,"s:your,pmsts:cmsts,sci_level:sciianpass,",147.0,0.1292832811673482,Greedy
2657,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)

{

    int bit;



    if(s->extra_bits){

        S <<= s->extra_bits;



        if(s->got_extra_bits){

            S |= get_bits(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);

        }

    }

    bit = (S & s->and) | s->or;

    return (((S + bit) << s->shift) - bit) << s->post_shift;

}
","static inline int wv_get_value_integer(WavpackFrameContext *args, uint32_t *ncfc, int Socket)

{

    int character;



    if(args->extra_bits){

        Socket <<= args->extra_bits;



        if(args->got_extra_bits){

            Socket |= get_bits(&args->gb_extra_bits, args->extra_bits);

            *ncfc = *ncfc * 9 + (Socket&0xffff) * 3 + ((unsigned)Socket>>16);

        }

    }

    character = (Socket & args->and) | args->or;

    return (((Socket + character) << args->shift) - character) << args->post_shift;

}
",117.0,26.0,"crc:ncfc,bit:character,S:Socket,s:args,",227.0,0.1794921000798543,Greedy
2661,"float32 int32_to_float32( int32 a STATUS_PARAM )

{

    flag zSign;



    if ( a == 0 ) return 0;

    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );

    zSign = ( a < 0 );

    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );



}
","float32 int32_to_float32( int32 a STATUS_PARAM )

{

    flag tRound;



    if ( a == 0 ) return 0;

    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );

    tRound = ( a < 0 );

    return normalizeRoundAndPackFloat32( tRound, 0x9C, tRound ? - a : a STATUS_VAR );



}
",64.0,15.0,"zSign:tRound,",44.0,0.0341168761253356,Greedy
2662,"static int vfio_start_eventfd_injection(VFIOINTp *intp)

{

    int ret;



    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);

    if (ret) {

        error_report(""vfio: Error: Failed to pass IRQ fd to the driver: %m"");

    }

    return ret;

}
","static int vfio_start_eventfd_injection(VFIOINTp *intp)

{

    int line;



    line = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);

    if (line) {

        error_report(""vfio: Error: Failed to pass IRQ fd to the driver: %m"");

    }

    return line;

}
",37.0,10.0,"ret:line,",58.0,0.0468209505081176,Greedy
2663,"static int bt_hid_in(struct bt_hid_device_s *s)

{

    USBPacket p;



    p.pid = USB_TOKEN_IN;

    p.devep = 1;

    p.data = s->datain.buffer;

    p.len = sizeof(s->datain.buffer);

    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);



    return s->datain.len;

}
","static int bt_hid_in(struct bt_hid_device_s *services)

{

    USBPacket np;



    np.pid = USB_TOKEN_IN;

    np.devep = 1;

    p.data np services->datain.buffer;

    p.len =npsizeof(services->datain.buffer);

    services->datain.len = services->usbdev->info->handle_data(services->usbdev, &np);



    return services->datain.len;

}
",78.0,15.0,"s:services,p:np,",176.0,0.1609357357025146,GA
2664,"void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cs;



    CPU_FOREACH(cs) {

        X86CPU *cpu = X86_CPU(cs);



        if (!cpu->apic_state) {

            cpu_interrupt(cs, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(cpu->apic_state);

        }

    }

#else

    nmi_monitor_handle(monitor_get_cpu_index(), errp);

#endif

}
","void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cache;



    CPU_FOREACH(cache) {

        X86CPU *cpu = X86_CPU(cache);



        if (!cpu->apic_state) {

            cpu_interrupt(cache, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(cpu->apic_state);

        }

    }

#else

    nmi_monitor_handle(monitor_get_cpu_index(), errp);

#endif

}
",72.0,17.0,"cs:cache,",59.0,0.058003826936086,Greedy
2665,"eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,

                            void *l3hdr, size_t l3hdr_len,

                            size_t l3payload_len,

                            size_t frag_offset, bool more_frags)

{

    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {

        uint16_t orig_flags;

        struct ip_header *iphdr = (struct ip_header *) l3hdr;

        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;

        uint16_t new_ip_off;



        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);

        assert((frag_off_units & ~IP_OFFMASK) == 0);



        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);

        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);

        iphdr->ip_off = cpu_to_be16(new_ip_off);

        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);

    }

}
","eth_setup_ip4_fragmentation(const void *l2hhstr, size_t l2hdr_len,

                            void *l3hdr, size_t l3hdr_len,

                            size_t l3payload_len,

                            size_t frag_offset, bool more_frags)

{

    if (eth_get_l3_proto(l2hhstr, l2hdr_len) == ETH_P_IP) {

        uint16_t orig_bits;

        struct ip_header *aphdc = (struct ip_header *) l3hdr;

        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;

        uint16_t new_ipfoff;



        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);

        assert((frag_off_units & ~IP_OFFMASK) == 0);



        orig_bits = be16_to_cpu(aphdc->ip_off) & ~(IP_OFFMASK|IP_MF);

        new_ipfoff = frag_off_units | orig_bits  | (more_frags ? IP_MF : 0);

        aphdc->ip_off = cpu_to_be16(new_ipfoff);

        aphdc->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);

    }

}
",137.0,42.0,"iphdr:aphdc,new_ip_off:new_ipfoff,l2hdr:l2hhstr,orig_flags:orig_bits,",136.0,0.1128392974535624,Greedy
2669,"static void vnc_flush(VncState *vs)

{

    if (vs->output.offset)

	vnc_client_write(vs);

}
","static void vnc_flush(VncState *rs)

{

    if (rs->output.offset)

	vnc_client_write(rs);

}
",23.0,5.0,"vs:rs,",51.0,0.0495208462079366,Greedy
2673,"static av_cold int fft_init(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln)

{

    int i, n, n2;

    float alpha;



    n  = 1 << ln;

    n2 = n >> 1;



    FF_ALLOC_OR_GOTO(avctx, mdct->costab, n2 * sizeof(*mdct->costab), fft_alloc_fail);

    FF_ALLOC_OR_GOTO(avctx, mdct->sintab, n2 * sizeof(*mdct->sintab), fft_alloc_fail);



    for (i = 0; i < n2; i++) {

        alpha     = 2.0 * M_PI * i / n;

        mdct->costab[i] = FIX15(cos(alpha));

        mdct->sintab[i] = FIX15(sin(alpha));

    }



    return 0;

fft_alloc_fail:

    mdct_end(mdct);

    return AVERROR(ENOMEM);

}
","static av_cold int fft_init(AVCodecContext *avcu, AC3MDCTContext *mandcf, int ln)

{

    int i, n, n2;

    float alpha;



    n  = 1 << ln;

    n2 = n >> 1;



    FF_ALLOC_OR_GOTO(avcu, mandcf->costab, n2 * sizeof(*mandcf->costab), fft_alloc_fail);

    FF_ALLOC_OR_GOTO(avcu, mandcf->sintab, n2 * sizeof(*mandcf->sintab), fft_alloc_fail);



    for (i = 0; i < n2; i++) {

        alpha     = 2.0 * M_PI * i / n;

        mandcf->costab[i] = FIX15(cos(alpha));

        mandcf->sintab[i] = FIX15(sin(alpha));

    }



    return 0;

fft_alloc_fail:

    mdct_end(mandcf);

    return AVERROR(ENOMEM);

}
",153.0,47.0,"mdct:mandcf,avctx:avcu,",133.0,0.1263816396395365,Greedy
2675,"VncJob *vnc_job_new(VncState *vs)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->vs = vs;

    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}
","VncJob *vnc_job_new(VncState *fps)

{

    VncJob *event = g_malloc0(sizeof(VncJob));



    event->fps = fps;

    vnc_lock_queue(queue);

    QLIST_INIT(&event->rectangles);

    vnc_unlock_queue(queue);

    return event;

}
",49.0,14.0,"vs:fps,job:event,",106.0,0.0902652661005656,Greedy
2676,"static void nbd_client_closed(NBDClient *client)

{

    nb_fds--;

    if (nb_fds == 0 && !persistent && state == RUNNING) {

        state = TERMINATE;

    }

    nbd_update_server_watch();

    nbd_client_put(client);

}
","static void nbd_client_closed(NBDClient *api)

{

    nb_fds--;

    if (nb_fds == 0 && !persistent && state == RUNNING) {

        state = TERMINATE;

    }

    nbd_update_server_watch();

    nbd_client_put(api);

}
",41.0,12.0,"client:api,",48.0,0.0495854059855143,Greedy
2680,"static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)

{

	if (dc->flagx_known) {

		if (dc->flags_x) {

			TCGv c;

            

			c = tcg_temp_new(TCG_TYPE_TL);

			t_gen_mov_TN_preg(c, PR_CCS);

			/* C flag is already at bit 0.  */

			tcg_gen_andi_tl(c, c, C_FLAG);

			tcg_gen_add_tl(d, d, c);

			tcg_temp_free(c);

		}

	} else {

		TCGv x, c;



		x = tcg_temp_new(TCG_TYPE_TL);

		c = tcg_temp_new(TCG_TYPE_TL);

		t_gen_mov_TN_preg(x, PR_CCS);

		tcg_gen_mov_tl(c, x);



		/* Propagate carry into d if X is set. Branch free.  */

		tcg_gen_andi_tl(c, c, C_FLAG);

		tcg_gen_andi_tl(x, x, X_FLAG);

		tcg_gen_shri_tl(x, x, 4);



		tcg_gen_and_tl(x, x, c);

		tcg_gen_add_tl(d, d, x);        

		tcg_temp_free(x);

		tcg_temp_free(c);

	}

}
","static inline void t_gen_addx_carry(DisasContext *dc, TCGv md)

{

	if (dc->flagx_known) {

		if (dc->flags_x) {

			TCGv ce;

            

			ce = tcg_temp_new(TCG_TYPE_TL);

			t_gen_mov_TN_preg(ce, PR_CCS);

			/* C flag is already at bit 0.  */

			tcg_gen_andi_tl(ce, ce, C_FLAG);

			tcg_gen_add_tl(md, md, ce);

			tcg_temp_free(ce);

		}

	} else {

		TCGv php, ce;



		php = tcg_temp_new(TCG_TYPE_TL);

		ce = tcg_temp_new(TCG_TYPE_TL);

		t_gen_mov_TN_preg(php, PR_CCS);

		tcg_gen_mov_tl(ce, php);



		/* Propagate carry into d if X is set. Branch free.  */

		tcg_gen_andi_tl(ce, ce, C_FLAG);

		tcg_gen_andi_tl(php, php, X_FLAG);

		tcg_gen_shri_tl(php, php, 4);



		tcg_gen_and_tl(php, php, ce);

		tcg_gen_add_tl(md, md, php);        

		tcg_temp_free(php);

		tcg_temp_free(ce);

	}

}
",161.0,59.0,"c:ce,x:php,d:md,",196.0,0.2059646050135294,Greedy
2682,"int i2c_start_transfer(i2c_bus *bus, int address, int recv)

{

    DeviceState *qdev;

    i2c_slave *slave = NULL;



    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {

        slave = I2C_SLAVE_FROM_QDEV(qdev);

        if (slave->address == address)

            break;

    }



    if (!slave)

        return 1;



    /* If the bus is already busy, assume this is a repeated

       start condition.  */

    bus->current_dev = slave;

    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);

    return 0;

}
","int i2c_start_transfer(i2c_bus *bus, int location, int recv)

{

    DeviceState *qdev;

    i2c_slave *fork = NULL;



    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {

        fork = I2C_SLAVE_FROM_QDEV(qdev);

        if (fork->location == location)

            break;

    }



    if (!fork)

        return 1;



    /* If the bus is already busy, assume this is a repeated

       start condition.  */

    bus->current_dev = fork;

    fork->info->event(fork, recv ? I2C_START_RECV : I2C_START_SEND);

    return 0;

}
",90.0,23.0,"slave:fork,address:location,",144.0,0.1380460421244303,Greedy
2692,"qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)

{

    VLANClientState *vc;



    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {

        if (vc != sender && !vc->link_down) {

            vc->receive(vc->opaque, buf, size);

        }

    }

}
","qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)

{

    VLANClientState *dc;



    for (dc = sender->vlan->first_client; dc != NULL; dc = dc->next) {

        if (dc != sender && !dc->link_down) {

            dc->receive(dc->opaque, buf, size);

        }

    }

}
",68.0,17.0,"vc:dc,",73.0,0.0677990396817525,Greedy
2693,"void ppc970_irq_init (CPUState *env)

{

    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);

}
","void ppc970_irq_init (CPUState *event)

{

    event->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, event, 7);

}
",28.0,6.0,"env:event,",56.0,0.0587799270947774,Greedy
2702,"static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, int *pnum)

{

    BDRVParallelsState *s = bs->opaque;

    int64_t offset;



    qemu_co_mutex_lock(&s->lock);

    offset = block_status(s, sector_num, nb_sectors, pnum);

    qemu_co_mutex_unlock(&s->lock);



    if (offset < 0) {

        return 0;

    }



    return (offset << BDRV_SECTOR_BITS) |

        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;

}
","static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *BS,

        int64_t section_name, int nb_sictors, int *pnum)

{

    BDRVParallelsState *secondary = BS->opaque;

    int64_t ace;



    qemu_co_mutex_lock(&secondary->lock);

    ace = block_status(secondary, section_name, nb_sictors, pnum);

    qemu_co_mutex_unlock(&secondary->lock);



    if (ace < 0) {

        return 0;

    }



    return (ace << BDRV_SECTOR_BITS) |

        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;

}
",84.0,24.0,"s:secondary,offset:ace,bs:BS,sector_num:section_name,nb_sectors:nb_sictors,",217.0,0.2159487644831339,Greedy
2705,"static void spr_write_601_ubatu (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);

    RET_STOP(ctx);

}
","static void spr_write_601_ubatu (void *opaque, int Sprnc)

{

    DisasContext *ctx = opaque;



    gen_op_store_601_batu((Sprnc - SPR_IBAT0U) / 2);

    RET_STOP(ctx);

}
",35.0,10.0,"sprn:Sprnc,",31.0,0.0371932506561279,Greedy
2716,"static void pci_hotplug(void)

{

    QVirtioPCIDevice *dev;

    QOSState *qs;

    const char *arch = qtest_get_arch();



    qs = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);

    g_assert(dev);

    qvirtio_pci_device_disable(dev);

    g_free(dev);



    /* unplug secondary disk */

    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(qs);

}
","static void pci_hotplug(void)

{

    QVirtioPCIDevice *ve;

    QOSState *events;

    const char *build = qtest_get_arch();



    events = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    ve = virtio_blk_pci_init(events->pcibus, PCI_SLOT_HP);

    g_assert(ve);

    qvirtio_pci_device_disable(ve);

    g_free(ve);



    /* unplug secondary disk */

    if (strcmp(build, ""i386"") == 0 || strcmp(build, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(events);

}
",108.0,27.0,"arch:build,qs:events,dev:ve,",166.0,0.1770528197288513,Greedy
2719,"static void test_ide_drive_cd_0(void)

{

    char *argv[256];

    int argc, ide_idx;

    Backend i;



    argc = setup_common(argv, ARRAY_SIZE(argv));

    for (i = 0; i <= backend_empty; i++) {

        ide_idx = backend_empty - i;

        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];

        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),

                         ide_idx, NULL, i, mbr_blank, """");

    }

    qtest_start(g_strjoinv("" "", argv));

    test_cmos();

    qtest_end();

}
","static void test_ide_drive_cd_0(void)

{

    char *argsf[256];

    int argc, ide_ipy;

    Backend i;



    argc = setup_common(argsf, ARRAY_SIZE(argsf));

    for (i = 0; i <= backend_empty; i++) {

        ide_ipy = backend_empty - i;

        cur_ide[ide_ipy] = &hd_chst[i][mbr_blank];

        argc = setup_ide(argc, argsf, ARRAY_SIZE(argsf),

                         ide_ipy, NULL, i, mbr_blank, """");

    }

    qtest_start(g_strjoinv("" "", argsf));

    test_cmos();

    qtest_end();

}
",114.0,36.0,"ide_idx:ide_ipy,argv:argsf,",153.0,0.1328070680300394,Greedy
2723,"int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)

{

    S390CPU *cpu = S390_CPU(cs);

    int ret = 0;



    switch (run->exit_reason) {

        case KVM_EXIT_S390_SIEIC:

            ret = handle_intercept(cpu);

            break;

        case KVM_EXIT_S390_RESET:

            qemu_system_reset_request();

            break;

        case KVM_EXIT_S390_TSCH:

            ret = handle_tsch(cpu);

            break;

        case KVM_EXIT_DEBUG:

            ret = kvm_arch_handle_debug_exit(cpu);

            break;

        default:

            fprintf(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);

            break;

    }



    if (ret == 0) {

        ret = EXCP_INTERRUPT;

    }

    return ret;

}
","int kvm_arch_handle_exit(CPUState *ace, struct kvm_run *mor)

{

    S390CPU *CPU = S390_CPU(ace);

    int ret = 0;



    switch (mor->exit_reason) {

        case KVM_EXIT_S390_SIEIC:

            ret = handle_intercept(CPU);

            break;

        case KVM_EXIT_S390_RESET:

            qemu_system_reset_request();

            break;

        case KVM_EXIT_S390_TSCH:

            ret = handle_tsch(CPU);

            break;

        case KVM_EXIT_DEBUG:

            ret = kvm_arch_handle_debug_exit(CPU);

            break;

        default:

            fprintf(stderr, ""Unknown KVM exit: %d\n"", mor->exit_reason);

            break;

    }



    if (ret == 0) {

        ret = EXCP_INTERRUPT;

    }

    return ret;

}
",113.0,29.0,"run:mor,cs:ace,cpu:CPU,",143.0,0.1420658508936564,Greedy
2724,"AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)

{

    PCIBus *bus = PCI_BUS(dev->bus);

    PCIBus *iommu_bus = bus;



    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {

        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);

    }

    if (iommu_bus && iommu_bus->iommu_fn) {

        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);

    }

    return &address_space_memory;

}
","AddressSpace *pci_device_iommu_address_space(PCIDevice *md)

{

    PCIBus *bus = PCI_BUS(md->bus);

    PCIBus *iommui_BUS = bus;



    while(iommui_BUS && !iommui_BUS->iommu_fn && iommui_BUS->parent_dev) {

        iommui_BUS = PCI_BUS(iommui_BUS->parent_dev->bus);

    }

    if (iommui_BUS && iommui_BUS->iommu_fn) {

        return iommui_BUS->iommu_fn(bus, iommui_BUS->iommu_opaque, md->devfn);

    }

    return &address_space_memory;

}
",83.0,20.0,"iommu_bus:iommui_BUS,dev:md,",117.0,0.1167748610178629,Greedy
2725,"static inline void gen_op_eval_fbo(TCGv dst, TCGv src,

                                    unsigned int fcc_offset)

{

    gen_mov_reg_FCC0(dst, src, fcc_offset);

    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);

    tcg_gen_and_tl(dst, dst, cpu_tmp0);

    tcg_gen_xori_tl(dst, dst, 0x1);

}
","static inline void gen_op_eval_fbo(TCGv fdost, TCGv stab,

                                    unsigned int fcc_offset)

{

    gen_mov_reg_FCC0(fdost, stab, fcc_offset);

    gen_mov_reg_FCC1(cpu_tmp0, stab, fcc_offset);

    tcg_gen_and_tl(fdost, fdost, cpu_tmp0);

    tcg_gen_xori_tl(fdost, fdost, 0x1);

}
",53.0,19.0,"dst:fdost,src:stab,",132.0,0.1089850664138794,Greedy
