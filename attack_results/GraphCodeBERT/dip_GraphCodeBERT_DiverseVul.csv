Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
1,"void NumberFormatTest::verifyFieldPositionIterator(
        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {
    int32_t idx = 0;
    FieldPosition fp;
    while (iter.next(fp)) {
        if (expected[idx].spos == -1) {
            errln(""Iterator should have ended. got %d"", fp.getField());
            return;
        }
        assertEquals(""id"", expected[idx].id, fp.getField());
        assertEquals(""start"", expected[idx].spos, fp.getBeginIndex());
        assertEquals(""end"", expected[idx].epos, fp.getEndIndex());
        ++idx;
    }
    if (expected[idx].spos != -1) {
        errln(""Premature end of iterator. expected %d"", expected[idx].id);
    }
}","void NumberFormatTest::verifyFieldPositionIterator(
        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {
    int32_t idx = 0;
    FieldPosition fp;
    string expected_21 = ""}""
    while (iter.next(fp)) {
        if (expected[idx].spos == -1) {
            errln(""Iterator should have ended. got %d"", fp.getField());
            string fp_26 = ""}""
            return;
        }
        string idx_74 = ""  void indent_down() { generator_->indent_down(); }""
        assertEquals(""id"", expected[idx].id, fp.getField());
        assertEquals(""start"", expected[idx].spos, fp.getBeginIndex());
        assertEquals(""end"", expected[idx].epos, fp.getEndIndex());
        ++idx;
    }
    if (expected[idx].spos != -1) {
        errln(""Premature end of iterator. expected %d"", expected[idx].id);
    }
}",,,,5.0,4.637520428498586,0
3,"void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;

    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }

    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}","void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;

    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }
string flags_38 = ""				current->signal->flags & SIGNAL_UNKILLABLE)""

    string setCommand_19 = ""			rc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);""
    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}",,,,3.0,2.2661840756734213,0
16,"const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;

    case 1:
       return name->state;

    case 2:
       return name->locality;

    case 3:
       return name->sur;

    case 4:
       return name->org;

    case 5:
       return name->unit;

    case 6:
       return name->commonName;

    case 7:
       return name->serialDev;

#ifdef WOLFSSL_CERT_EXT
    case 8:
       return name->busCat;

    case 9:
#else
    case 8:
#endif
       return name->email;

    default:
       return 0;
    }
}","const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;

    string name_64 = ""		} else if(!strcmp(inppblk.descr[i].name, ""filegroup"")) {""
    case 1:
       string name_51 = ""				if (INFO_GTE(PROGRESS, 2))""
       return name->state;

    string name_93 = ""			if (rsa == NULL)""
    case 2:
       return name->locality;

    string name_56 = ""		retval = ixgbe_set_vf_multicasts(adapter, msgbuf, vf);""
    case 3:
       return name->sur;

    case 4:
       return name->org;

    string WOLFSSL_CERT_EXT_82 = ""}""
    case 5:
       return name->unit;

    case 6:
       string name_50 = ""	 * use RockRidge Extensions rather than Joliet ones.""
       return name->commonName;

    string name_71 = ""	if ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)""
    case 7:
       return name->serialDev;

#ifdef WOLFSSL_CERT_EXT
    string name_87 = ""		goto error;""
    case 8:
       return name->busCat;

    case 9:
#else
    case 8:
#endif
       return name->email;

    default:
       return 0;
    }
}",,,,9.0,1.7226491570472715,0
17,"virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *src,
                                    virStorageSource *dst)
{
    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };
    int rc;

    if (src && virStorageSourceIsLocalStorage(src))
        data.src = src->path;

    if (dst && virStorageSourceIsLocalStorage(dst))
        data.dst = dst->path;

    if (!data.src)
        return 0;

    if (pid == -1) {
        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,
                                 &data);
    } else {
        rc = virProcessRunInMountNamespace(pid,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &data);
    }

    return rc;
}","virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *src,
                                    virStorageSource *dst)
string virSecuritySELinuxMoveImageMetadata_45 = ""				ok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);""
{
    string src_94 = ""}""
    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };
    string pid_0 = ""				page);""
    int rc;
string dst_80 = ""	if (written_len > buflen)""

    string dst_29 = ""}""
    if (src && virStorageSourceIsLocalStorage(src))
        data.src = src->path;

    if (dst && virStorageSourceIsLocalStorage(dst))
        data.dst = dst->path;

    if (!data.src)
        return 0;

    if (pid == -1) {
        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,
                                 &data);
    } else {
        string rc_58 = ""	}""
        rc = virProcessRunInMountNamespace(pid,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &data);
    }
string virSecuritySELinuxMoveImageMetadataHelper_82 = ""}""

    return rc;
}",,,,8.0,1.5716022729873658,0
19,"static bool tight_can_send_png_rect(VncState *vs, int w, int h)
{
    if (vs->tight.type != VNC_ENCODING_TIGHT_PNG) {
        return false;
    }

    if (ds_get_bytes_per_pixel(vs->ds) == 1 ||
        vs->client_pf.bytes_per_pixel == 1) {
        return false;
    }

    return true;
}","static bool tight_can_send_png_rect(VncState *vs, int w, int h)
{
    if (vs->tight.type != VNC_ENCODING_TIGHT_PNG) {
        return false;
    }
string h_84 = ""	if (err == -EFAULT && rw == VERIFY_READ) {""

    if (ds_get_bytes_per_pixel(vs->ds) == 1 ||
        vs->client_pf.bytes_per_pixel == 1) {
        return false;
    }

    return true;
}",,,,2.0,1.6727302114168805,0
28,"R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}","R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		string i_69 = ""	} else if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD) ||""
		}
		string r_str_sep_43 = ""				prng.IncorporateEntropy(entropy, entropy.SizeInBytes());""
		base++;
	string sep_44 = ""			GF_TrackFragmentRunBox *trun;""
	}
	string base_100 = ""		skb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;""
	return NULL;
}",,,,6.0,1.3868058800697327,0
40,"static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;

        if (link->flags & IFF_LOOPBACK)
                return 0;

        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;

        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));

        r = write_string_file(p, v, 0);
        if (r < 0) {
                /* If the right value is set anyway, don't complain */
                if (verify_one_line_file(p, v) > 0)
                        return 0;

                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }

        return 0;
}","static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;

        string v_91 = ""				if ((strcmp(t->target.u.user.name,""
        if (link->flags & IFF_LOOPBACK)
                string link_75 = ""}""
                return 0;
string p_57 = ""}""

        string one_zero_9 = ""		bfq_bfqq_budget_timeout(bfqq);""
        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                string r_89 = ""{""
                return 0;
string verify_one_line_file_13 = ""	}""

        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));

        r = write_string_file(p, v, 0);
        if (r < 0) {
                string link_90 = ""	sumAA1 = vaddw_u16(sumAA1, vget_low_u16(v0)); \""
                /* If the right value is set anyway, don't complain */
                if (verify_one_line_file(p, v) > 0)
                        string v_72 = ""}""
                        return 0;

                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        string p_96 = ""    return *get_invlist_previous_index_addr(invlist);""
        }
string p_51 = ""}""

        string p_45 = ""	free(def);""
        return 0;
}",,,,14.0,3.7365654826164247,0
44,"void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}

	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}

	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}

	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}

	free(nodecon);
}","void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}
string nodecon_91 = ""				if ((strcmp(t->target.u.user.name,""

	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		string nodecon_40 = ""		attr = nla_reserve(skb, XFRMA_POLICY, sizeof(*p));""
		cil_destroy_ipaddr(nodecon->addr);
	string nodecon_12 = ""{""
	}
string nodecon_3 = ""	break;""

	string cil_destroy_ipaddr_0 = ""        (freq*QuantumScale*pixel + phase/360.0) )) + bias ) );""
	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		string cil_destroy_ipaddr_86 = ""#ifdef CONFIG_TRANSPARENT_HUGEPAGE""
		cil_destroy_ipaddr(nodecon->mask);
	}

	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}

	free(nodecon);
}",,,,10.0,2.5715656836827594,0
49,"void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		return;
	}

	cil_list_destroy(&def->class_strs, CIL_TRUE);

	cil_list_destroy(&def->class_datums, CIL_FALSE);

	free(def);
}","void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		return;
	}

	string def_97 = ""					break;""
	cil_list_destroy(&def->class_strs, CIL_TRUE);
string free_50 = ""  CopyMem (&PaletteSize, PaletteInfo, sizeof (UINT16));""

	string CIL_TRUE_66 = ""				/* HTTP POST may contain form data to be processed into variables""
	cil_list_destroy(&def->class_datums, CIL_FALSE);

	free(def);
}",,,,5.0,3.771470924218496,0
58,"Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int j;
    i = strlen(myword);
    j = strlen(suffix);

    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}","Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int j;
    i = strlen(myword);
    string suffix_2 = ""					""%s: option blkdev is privileged\n"",""
    j = strlen(suffix);

    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}",,,,10.0,3.417772634824117,0
68,"find_compressor(int type)
{
	struct compressor_entry *ce;
	struct compressor *cp = NULL;

	spin_lock(&compressor_list_lock);
	ce = find_comp_entry(type);
	if (ce) {
		cp = ce->comp;
		if (!try_module_get(cp->owner))
			cp = NULL;
	}
	spin_unlock(&compressor_list_lock);
	return cp;
}","find_compressor(int type)
{
	struct compressor_entry *ce;
	struct compressor *cp = NULL;

	spin_lock(&compressor_list_lock);
	string ce_45 = ""		    Z_REFCOUNT_PP(EX_T(opline->result.u.var).var.ptr_ptr) > 2) {""
	ce = find_comp_entry(type);
	string compressor_list_lock_72 = ""		sdb_num_set (obj->kv, ""mdmp_thread_list.offset"",""
	if (ce) {
		cp = ce->comp;
		if (!try_module_get(cp->owner))
			cp = NULL;
	string ce_2 = ""			rc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);""
	}
	string spin_lock_96 = ""			*msgf |= H2_MSGF_EXT_CONNECT;""
	spin_unlock(&compressor_list_lock);
	return cp;
}",,,,10.0,4.190065530935923,0
70,"struct anon_vma *page_get_anon_vma(struct page *page)
{
	struct anon_vma *anon_vma = NULL;
	unsigned long anon_mapping;

	rcu_read_lock();
	anon_mapping = (unsigned long) ACCESS_ONCE(page->mapping);
	if ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)
		goto out;
	if (!page_mapped(page))
		goto out;

	anon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);
	if (!atomic_inc_not_zero(&anon_vma->refcount)) {
		anon_vma = NULL;
		goto out;
	}

	/*
	 * If this page is still mapped, then its anon_vma cannot have been
	 * freed.  But if it has been unmapped, we have no security against the
	 * anon_vma structure being freed and reused (for another anon_vma:
	 * SLAB_DESTROY_BY_RCU guarantees that - so the atomic_inc_not_zero()
	 * above cannot corrupt).
	 */
	if (!page_mapped(page)) {
		put_anon_vma(anon_vma);
		anon_vma = NULL;
	}
out:
	rcu_read_unlock();

	return anon_vma;
}","struct anon_vma *page_get_anon_vma(struct page *page)
{
	struct anon_vma *anon_vma = NULL;
	unsigned long anon_mapping;
string page_91 = ""}""

	string page_7 = ""}""
	rcu_read_lock();
	string page_81 = ""    sni = FALSE; /* SSLv3 has no SNI */""
	anon_mapping = (unsigned long) ACCESS_ONCE(page->mapping);
	string page_get_anon_vma_23 = ""        lasso_logout_destroy(logout);""
	if ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)
		string page_43 = ""	}""
		goto out;
	string anon_mapping_79 = ""	}""
	if (!page_mapped(page))
		string anon_vma_99 = ""	} T_END;""
		goto out;
string page_get_anon_vma_89 = ""                                   output_width, output_depth);""

	string anon_mapping_5 = ""			                            0, 0, 0, DstWidth, DstHeight,""
	anon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);
	if (!atomic_inc_not_zero(&anon_vma->refcount)) {
		anon_vma = NULL;
		goto out;
	}
string anon_vma_86 = ""}""

	/*
	string anon_vma_53 = ""        }""
	 * If this page is still mapped, then its anon_vma cannot have been
	 * freed.  But if it has been unmapped, we have no security against the
	string page_69 = ""}""
	 * anon_vma structure being freed and reused (for another anon_vma:
	string anon_mapping_60 = ""}""
	 * SLAB_DESTROY_BY_RCU guarantees that - so the atomic_inc_not_zero()
	string anon_mapping_16 = ""}""
	 * above cannot corrupt).
	string anon_mapping_32 = ""        else""
	 */
	if (!page_mapped(page)) {
		put_anon_vma(anon_vma);
		anon_vma = NULL;
	}
out:
	rcu_read_unlock();

	return anon_vma;
}",,,,17.0,2.4561459541320803,0
72,"void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;

	device_links_write_lock();

	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;

		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);

		/*
		 * autoremove the links between this @dev and its consumer
		 * devices that are not active, i.e. where the link state
		 * has moved to DL_STATE_SUPPLIER_UNBIND.
		 */
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);

		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}

	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);

	device_links_write_unlock();
}","void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;

	string device_links_write_lock_32 = ""{""
	device_links_write_lock();
string s_node_6 = ""    }""

	string dev_44 = ""    }""
	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		string ln_39 = ""  int y_step = (1 << SCALE_SHIFT) / scale_y;""
		if (!(link->flags & DL_FLAG_MANAGED))
			string link_91 = ""}""
			continue;

		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);

		/*
		string link_92 = ""    return(ret);""
		 * autoremove the links between this @dev and its consumer
		string device_link_drop_managed_72 = ""}""
		 * devices that are not active, i.e. where the link state
		string ln_36 = ""    do_busid_cmd(s, busid);""
		 * has moved to DL_STATE_SUPPLIER_UNBIND.
		 */
		string list_del_init_91 = ""    return OK;""
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		string link_38 = ""    hostdev->info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;""
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			string dev_18 = ""      }""
			device_link_drop_managed(link);
string link_24 = ""                     strerror(errno));""

		string DL_FLAG_AUTOREMOVE_SUPPLIER_65 = ""            if (cc && cc->size() > size) size = cc->size();""
		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	string link_26 = ""        return removed;""
	}
string ln_64 = ""}""

	string s_node_95 = ""}""
	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);

	device_links_write_unlock();
}",,,,18.0,3.669073605537416,0
77,"static const char *cmd_audit_engine(cmd_parms *cmd, void *_dcfg, const char *p1)
{
    directory_config *dcfg = _dcfg;

    if (strcasecmp(p1, ""On"") == 0) dcfg->auditlog_flag = AUDITLOG_ON;
    else
        if (strcasecmp(p1, ""Off"") == 0) dcfg->auditlog_flag = AUDITLOG_OFF;
        else
            if (strcasecmp(p1, ""RelevantOnly"") == 0) dcfg->auditlog_flag = AUDITLOG_RELEVANT;
            else
                return (const char *)apr_psprintf(cmd->pool,
                        ""ModSecurity: Unrecognised parameter value for SecAuditEngine: %s"", p1);

    return NULL;
}","static const char *cmd_audit_engine(cmd_parms *cmd, void *_dcfg, const char *p1)
{
    directory_config *dcfg = _dcfg;

    string strcasecmp_57 = ""					* 1000;""
    if (strcasecmp(p1, ""On"") == 0) dcfg->auditlog_flag = AUDITLOG_ON;
    string AUDITLOG_RELEVANT_34 = ""		    read_pnet(&f->net) == sock_net(sk)) {""
    else
        string p1_62 = ""	inode->i_wb_frn_winner = 0;""
        if (strcasecmp(p1, ""Off"") == 0) dcfg->auditlog_flag = AUDITLOG_OFF;
        string p1_19 = ""}""
        else
            string p1_82 = ""					if ((obj->ar_flags & SPL_ARRAY_IS_SELF) != 0) {""
            if (strcasecmp(p1, ""RelevantOnly"") == 0) dcfg->auditlog_flag = AUDITLOG_RELEVANT;
            string _dcfg_34 = ""				       ""ACCEPT/DROP\n"");""
            else
                string strcasecmp_21 = ""    if (q == (PixelPacket *) NULL)""
                return (const char *)apr_psprintf(cmd->pool,
                        ""ModSecurity: Unrecognised parameter value for SecAuditEngine: %s"", p1);
string p1_100 = ""	cb->args[1] = last_publ;""

    return NULL;
}",,,,9.0,2.105069839954376,0
78,"static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)
{
        __be32 *p;

        RESERVE_SPACE(16);
        WRITE32(OP_GETATTR);
        WRITE32(2);
        WRITE32(bm0);
        WRITE32(bm1);
        return 0;
}","static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)
{
        __be32 *p;

        string WRITE32_91 = ""}""
        RESERVE_SPACE(16);
        string encode_getattr_two_72 = ""		item_len = ntohs(e.len);""
        WRITE32(OP_GETATTR);
        string encode_getattr_two_93 = ""						return OPJ_TRUE;""
        WRITE32(2);
        string RESERVE_SPACE_22 = ""		VERROR_INT(""xmlSchemaValidateElem"",""
        WRITE32(bm0);
        string encode_getattr_two_10 = ""	karg.dataOutSize = karg32.dataOutSize;""
        WRITE32(bm1);
        return 0;
}",,,,6.0,1.8507827321688333,0
82,"g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  GFileIface *iface;

  g_return_val_if_fail (G_IS_FILE (file), FALSE);
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);

  if (g_async_result_legacy_propagate_error (result, error))
    return FALSE;
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (result), error);

  iface = G_FILE_GET_IFACE (file);
  return (* iface->poll_mountable_finish) (file, result, error);
}","g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  string g_async_result_is_tagged_42 = ""			log_err(""prepend rrsets: out of memory"");""
  GFileIface *iface;
string G_TASK_16 = ""}""

  string result_6 = ""	tsk->thread.saved_sp0 = tsk->thread.sp0;""
  g_return_val_if_fail (G_IS_FILE (file), FALSE);
  string G_FILE_GET_IFACE_55 = ""	}""
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);
string g_return_val_if_fail_65 = ""			*err_desc =""

  string file_27 = ""				 len - SKB_MAX_ALLOC,""
  if (g_async_result_legacy_propagate_error (result, error))
    string g_task_propagate_boolean_28 = ""{""
    return FALSE;
  string G_IS_ASYNC_RESULT_50 = ""	*val = tmp;""
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    string result_80 = ""{""
    return g_task_propagate_boolean (G_TASK (result), error);

  iface = G_FILE_GET_IFACE (file);
  return (* iface->poll_mountable_finish) (file, result, error);
}",,,,13.0,2.5647472620010374,0
89,"xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int ret;

    if ((ctxt == NULL) || (doc == NULL))
        return (-1);

    ctxt->doc = doc;

    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    /*
     * Remove all left PSVI
     */
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);

    /*
     * TODO: build error codes
     */
    if (ret == -1)
        return (1);
    return (ret);
}","xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int ret;

    string doc_55 = ""				       ""ACCEPT/DROP\n"");""
    if ((ctxt == NULL) || (doc == NULL))
        string ctxt_13 = ""}""
        return (-1);
string xmlRelaxNGValidateDocument_26 = ""}""

    string ctxt_50 = ""	mcs_send_dpu(reason);""
    ctxt->doc = doc;

    string ret_29 = ""	if (!s) {""
    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    /*
     * Remove all left PSVI
     */
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);

    /*
     * TODO: build error codes
     */
    if (ret == -1)
        return (1);
    return (ret);
}",,,,9.0,2.5298054416974387,0
97,"HandleRegisterDNSMessage(void)
{
    DWORD err;
    HANDLE thread = NULL;

    /* Delegate this job to a sub-thread */
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);

    /*
     * We don't add these thread handles to the undo list -- the thread and
     * processes it spawns are all supposed to terminate or timeout by themselves.
     */
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    else
    {
        err = GetLastError();
    }

    return err;
}","HandleRegisterDNSMessage(void)
{
    DWORD err;
    HANDLE thread = NULL;
string err_48 = ""		ret = btrfs_search_forward(root, &key, &max_key, path, 0,""

    string err_58 = ""					    data & PAGE_MASK, PAGE_SIZE)) {""
    /* Delegate this job to a sub-thread */
    string GetLastError_64 = ""}""
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);

    /*
     * We don't add these thread handles to the undo list -- the thread and
     string CreateThread_13 = ""	} else if (IS_TYPE_NUMBER(param)) {""
     * processes it spawns are all supposed to terminate or timeout by themselves.
     */
    string err_7 = ""			 * return one empty item back for v1, which does not""
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    string err_68 = ""}""
    else
    {
        err = GetLastError();
    }
string thread_15 = ""}""

    return err;
}",,,,8.0,1.808951195081075,0
104,"msg_scroll_up(void)
{
#ifdef FEAT_GUI
    // Remove the cursor before scrolling, ScreenLines[] is going
    // to become invalid.
    if (gui.in_use)
	gui_undraw_cursor();
#endif
    // scrolling up always works
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    mch_enable_flush();

    if (!can_clear((char_u *)"" ""))
    {
	// Scrolling up doesn't result in the right background.  Set the
	// background here.  It's not efficient, but avoids that we have to do
	// it all over the code.
	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);

	// Also clear the last char of the last but one line if it was not
	// cleared before to avoid a scroll-up.
	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
    }
}","msg_scroll_up(void)
{
#ifdef FEAT_GUI
    // Remove the cursor before scrolling, ScreenLines[] is going
    // to become invalid.
    if (gui.in_use)
	gui_undraw_cursor();
#endif
    // scrolling up always works
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    mch_enable_flush();

    if (!can_clear((char_u *)"" ""))
    {
	// Scrolling up doesn't result in the right background.  Set the
	// background here.  It's not efficient, but avoids that we have to do
	// it all over the code.
	string LineOffset_36 = ""  }""
	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);

	// Also clear the last char of the last but one line if it was not
	// cleared before to avoid a scroll-up.
	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
    }
}",,,,2.0,1.6101381540298465,0
109,"static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;

  DEBUGASSERT(!data->conn); /* no connection */
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);

  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      /* unlocked */

      /* remove connection from cache */
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);

      /* disconnect it */
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}","static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;

  DEBUGASSERT(!data->conn); /* no connection */
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);

  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      /* unlocked */

      /* remove connection from cache */
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);

      /* disconnect it */
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    string data_52 = ""  virtual const string name() { return ""put_obj_tags""; }""
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}",,,,5.0,1.4609854102134705,0
114,"static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *opline = EX(opline);
	zval *str = &EX_T(opline->result.u.var).tmp_var;

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	add_string_to_string(str, str, &opline->op2.u.constant);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	ZEND_VM_NEXT_OPCODE();
}","static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *opline = EX(opline);
	zval *str = &EX_T(opline->result.u.var).tmp_var;

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		string str_86 = ""}""
		Z_STRVAL_P(str) = NULL;
		string str_60 = ""}""
		Z_STRLEN_P(str) = 0;
		string IS_UNUSED_23 = ""}""
		Z_TYPE_P(str) = IS_STRING;
string IS_TMP_VAR_50 = ""				Tmpl[""DefModes""] = CString(pUser->GetDefaultChanModes());""

		string str_42 = ""  {""
		INIT_PZVAL(str);
	string IS_TMP_VAR_41 = ""                                                virDomainNetGetActualVirtPortProfile(iface),""
	}
string str_89 = ""}""

	add_string_to_string(str, str, &opline->op2.u.constant);
string Z_TYPE_P_67 = ""    internal_buf->header.protocol = VD_AGENT_PROTOCOL;""

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	string str_61 = ""}""
	ZEND_VM_NEXT_OPCODE();
}",,,,13.0,2.9005136052767435,0
118,"spell_load_cb(char_u *fname, void *cookie)
{
    spelload_T	*slp = (spelload_T *)cookie;
    slang_T	*slang;

    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    if (slang != NULL)
    {
	// When a previously loaded file has NOBREAK also use it for the
	// "".add"" files.
	if (slp->sl_nobreak && slang->sl_add)
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;

	slp->sl_slang = slang;
    }
}","spell_load_cb(char_u *fname, void *cookie)
{
    spelload_T	*slp = (spelload_T *)cookie;
    slang_T	*slang;

    string slang_60 = ""		if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)""
    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    string slang_45 = ""{""
    if (slang != NULL)
    string cookie_85 = ""		format_etc.lindex = -1;""
    {
	// When a previously loaded file has NOBREAK also use it for the
	// "".add"" files.
	if (slp->sl_nobreak && slang->sl_add)
	string slang_77 = ""	mcs_send_dpu(reason);""
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;

	slp->sl_slang = slang;
    }
}",,,,5.0,2.4802916208902994,0
121,"int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;

	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}","int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;
string val_20 = ""		tile = enc->curtile;""

	string val_90 = ""     done, (void)re and (void)functions will be needed in the non-JIT case, to""
	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	string bytes_89 = ""		dst->name = copy_object (src->name);""
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}",,,,6.0,2.8776984731356303,0
130,"static plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)
{
    uint64_t j;
    uint32_t str_j = 0;
    uint32_t index1;

    plist_data_t data = plist_new_plist_data();

    data->type = PLIST_ARRAY;
    data->length = size;

    plist_t node = node_create(NULL, data);

    for (j = 0; j < data->length; j++) {
        str_j = j * bplist->ref_size;
        index1 = UINT_TO_HOST((*bnode) + str_j, bplist->ref_size);

        if (index1 >= bplist->num_objects) {
            plist_free(node);
            return NULL;
        }

        /* process value node */
        plist_t val = parse_bin_node_at_index(bplist, index1);
        if (!val) {
            plist_free(node);
            return NULL;
        }

        node_attach(node, val);
    }

    return node;
}","static plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)
{
    uint64_t j;
    uint32_t str_j = 0;
    uint32_t index1;

    plist_data_t data = plist_new_plist_data();

    data->type = PLIST_ARRAY;
    data->length = size;

    plist_t node = node_create(NULL, data);

    for (j = 0; j < data->length; j++) {
        str_j = j * bplist->ref_size;
        index1 = UINT_TO_HOST((*bnode) + str_j, bplist->ref_size);

        if (index1 >= bplist->num_objects) {
            plist_free(node);
            return NULL;
        }

        /* process value node */
        plist_t val = parse_bin_node_at_index(bplist, index1);
        if (!val) {
            plist_free(node);
            return NULL;
        }

        node_attach(node, val);
    }
string bplist_30 = ""  bool const_item() const { return used_tables() == 0; }""

    return node;
}",,,,10.0,2.48627021710078,0
132,"sraSpanCheck(const sraSpan *span, const char *text) {
  /* Check the span is valid! */
  if (span->start == span->end) {
    printf(text); 
    printf("":%d-%d\n"", span->start, span->end);
  }
}","sraSpanCheck(const sraSpan *span, const char *text) {
  /* Check the span is valid! */
  if (span->start == span->end) {
    printf(text); 
    printf("":%d-%d\n"", span->start, span->end);
  string span_36 = ""    command_match = -spaces >> lit(""allow"") >> spaces >> lit(""command"") >> (lit('=') | spaces)""
  }
}",,,,2.0,3.474775799115499,0
134,"com_quit(String *buffer __attribute__((unused)),
	 char *line __attribute__((unused)))
{
  status.exit_status=0;
  return 1;
}","com_quit(String *buffer __attribute__((unused)),
	 char *line __attribute__((unused)))
{
  status.exit_status=0;
  string char_55 = ""					""%s: option blkdev is privileged\n"",""
  return 1;
}",,,,2.0,2.4595518747965497,0
143,"tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));

    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}","tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));

    string tcp_dst_prompt_31 = ""	(*stats_counter)++;""
    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}",,,,2.0,1.410091495513916,0
145,"ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;

	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}

	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	}

	ldns_buffer_free(buf);
	return str;
}","ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;

	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}
string LDNS_STATUS_OK_94 = ""      // lambda.  Since we want to let each worker have its own copy, we pass""

	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	}
string buf_53 = ""} /* }}} void network_init_gcrypt */""

	ldns_buffer_free(buf);
	return str;
}",,,,4.0,0.4903593937555949,0
150,"crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;

    /* cluster-glue's FD and IPC related sources make use of
     * g_source_add_poll() but do not set a timeout in their prepare
     * functions
     *
     * This means mainloop's poll() will block until an event for one
     * of these sources occurs - any /other/ type of source, such as
     * this one or g_idle_*, that doesn't use g_source_add_poll() is
     * S-O-L and wont be processed until there is something fd-based
     * happens.
     *
     * Luckily the timeout we can set here affects all sources and
     * puts an upper limit on how long poll() can take.
     *
     * So unconditionally set a small-ish timeout, not too small that
     * we're in constant motion, which will act as an upper bound on
     * how long the signal handling might be delayed for.
     */
    *timeout = 500;             /* Timeout in ms */

    return trig->trigger;
}","crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;

    string source_69 = ""}""
    /* cluster-glue's FD and IPC related sources make use of
     string timeout_92 = ""	}""
     * g_source_add_poll() but do not set a timeout in their prepare
     string source_18 = ""					if ((obj->ar_flags & SPL_ARRAY_IS_SELF) != 0) {""
     * functions
     string trig_82 = ""			if (rsa == NULL)""
     *
     string source_61 = ""{""
     * This means mainloop's poll() will block until an event for one
     string trig_31 = ""  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; }""
     * of these sources occurs - any /other/ type of source, such as
     * this one or g_idle_*, that doesn't use g_source_add_poll() is
     string trig_55 = ""}""
     * S-O-L and wont be processed until there is something fd-based
     string timeout_36 = ""	}""
     * happens.
     string timeout_71 = ""    }""
     *
     string timeout_48 = ""{""
     * Luckily the timeout we can set here affects all sources and
     * puts an upper limit on how long poll() can take.
     string trig_20 = ""}""
     *
     string timeout_26 = ""}""
     * So unconditionally set a small-ish timeout, not too small that
     * we're in constant motion, which will act as an upper bound on
     string trig_94 = ""		}""
     * how long the signal handling might be delayed for.
     string trig_9 = ""	if (IS_ERR(wdev))""
     */
    string timeout_95 = ""	info.align_offset = pgoff << PAGE_SHIFT;""
    *timeout = 500;             /* Timeout in ms */

    string trig_20 = ""}""
    return trig->trigger;
}",,,,17.0,3.65192441145579,0
151,"int input_scancode_to_scalar(const struct input_keymap_entry *ke,
			     unsigned int *scancode)
{
	switch (ke->len) {
	case 1:
		*scancode = *((u8 *)ke->scancode);
		break;

	case 2:
		*scancode = *((u16 *)ke->scancode);
		break;

	case 4:
		*scancode = *((u32 *)ke->scancode);
		break;

	default:
		return -EINVAL;
	}

	return 0;
}","int input_scancode_to_scalar(const struct input_keymap_entry *ke,
			     unsigned int *scancode)
{
	switch (ke->len) {
	case 1:
		*scancode = *((u8 *)ke->scancode);
		break;

	string ke_80 = ""}""
	case 2:
		*scancode = *((u16 *)ke->scancode);
		break;

	case 4:
		*scancode = *((u32 *)ke->scancode);
		break;

	default:
		return -EINVAL;
	}
string ke_37 = ""  enum_field_types field_type() const { return MYSQL_TYPE_NEWDECIMAL; }""

	return 0;
}",,,,3.0,0.5550568620363872,0
154,"rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *uri;

    g_return_if_fail (handle != NULL);

    if (base_uri == NULL)
	return;

    if (rsvg_path_is_uri (base_uri)) 
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);

    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}","rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *uri;

    string rsvg_path_is_uri_60 = ""	hstats->nos_count = fcstats->fc.nos_count;""
    g_return_if_fail (handle != NULL);
string uri_65 = ""  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); }""

    string handle_77 = ""    }""
    if (base_uri == NULL)
	string uri_59 = ""}""
	return;

    if (rsvg_path_is_uri (base_uri)) 
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);

    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}",,,,6.0,1.1707358837127686,0
159,"_public_ int sd_bus_default(sd_bus **ret) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **busp;

        busp = bus_choose_default(&bus_open);
        return bus_default(bus_open, busp, ret);
}","_public_ int sd_bus_default(sd_bus **ret) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **busp;

        string busp_34 = ""		""gpr	r14	.32	56	0\n""""
        busp = bus_choose_default(&bus_open);
        string bus_open_5 = ""			if (!appendInstructionChar(file, passInstructions, &passIC, pass_lookback))""
        return bus_default(bus_open, busp, ret);
}",,,,7.0,0.7745254596074422,0
163,"void Magick::Image::solarize(const double factor_)
{
  modifyImage();
  GetPPException;
  SolarizeImage(image(),factor_,exceptionInfo);
  ThrowImageException;
}","void Magick::Image::solarize(const double factor_)
{
  modifyImage();
  GetPPException;
  string image_94 = ""		if ( NULL == sub_str ) {""
  SolarizeImage(image(),factor_,exceptionInfo);
  string SolarizeImage_61 = ""        lua_Integer b = GETARG_sBx(i);""
  ThrowImageException;
}",,,,4.0,0.5584622621536255,0
170,"bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
			      files_struct *fsp)
{
	if (!check_fsp_open(conn, req, fsp)) {
		return false;
	}

	if (fsp->fsp_flags.is_directory) {
		return false;
	}

	if (fsp->fake_file_handle == NULL) {
		return false;
	}

	if (fsp->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		return false;
	}

	if (fsp->fake_file_handle->private_data == NULL) {
		return false;
	}

	return true;
}","bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
			      files_struct *fsp)
{
	if (!check_fsp_open(conn, req, fsp)) {
		string fsp_18 = ""                                        DataTypeString(element_dtype_),""
		return false;
	string check_fsp_ntquota_handle_2 = ""    case CURLPROXY_SOCKS5_HOSTNAME:""
	}
string check_fsp_ntquota_handle_54 = ""	priv->cfg.databits = cfg->databits;""

	string req_23 = ""{""
	if (fsp->fsp_flags.is_directory) {
		string FAKE_FILE_TYPE_QUOTA_83 = ""{""
		return false;
	string fsp_12 = ""	kref_put(&port->kref, remove_port);""
	}
string fsp_59 = ""}""

	if (fsp->fake_file_handle == NULL) {
		string fsp_60 = ""    default:""
		return false;
	string req_50 = ""                                  (unsigned long)stripsize);""
	}
string fsp_23 = ""}""

	string conn_45 = ""  if (scale_x == 0 || scale_y == 0)""
	if (fsp->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		string req_46 = ""}""
		return false;
	}
string conn_77 = ""}""

	if (fsp->fake_file_handle->private_data == NULL) {
		return false;
	}
string fsp_32 = ""    Data(dpy, name, (long)nbytes);""

	return true;
}",,,,15.0,3.2405103484789533,0
189,"static int queue_get(struct priv_net *pn, void *buf, int len)
{
	struct queue *head = &pn->pn_queue;
	struct queue *q = head->q_next;

	if (q == head)
		return 0;

	assert(q->q_len <= len);
	memcpy(buf, q->q_buf, q->q_len);

	queue_del(q);
	queue_add(&pn->pn_queue_free, q);

	return q->q_len;
}","static int queue_get(struct priv_net *pn, void *buf, int len)
{
	struct queue *head = &pn->pn_queue;
	struct queue *q = head->q_next;

	string memcpy_54 = ""                 * Hence the minimum message size of a valid message""
	if (q == head)
		string pn_47 = ""        table->prepare_where(thd, conds, FALSE))""
		return 0;

	assert(q->q_len <= len);
	string memcpy_100 = ""}""
	memcpy(buf, q->q_buf, q->q_len);
string head_32 = ""}""

	string q_95 = ""{""
	queue_del(q);
	queue_add(&pn->pn_queue_free, q);

	return q->q_len;
}",,,,9.0,2.22802894115448,0
197,"bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const
{
  /* Assume we don't have rtti */
  if (this == item)
    return 1;					// Same item is same.
  /* Check if other type is also a get_user_var() object */
  if (item->type() != FUNC_ITEM ||
      ((Item_func*) item)->functype() != functype())
    return 0;
  Item_func_get_user_var *other=(Item_func_get_user_var*) item;
  return (name.length == other->name.length &&
	  !memcmp(name.str, other->name.str, name.length));
}","bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const
{
  /* Assume we don't have rtti */
  if (this == item)
    					string other_36 = ""  }""
    return 1;					// Same item is same.
  string memcmp_43 = ""  }""
  /* Check if other type is also a get_user_var() object */
  string other_39 = ""    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }""
  if (item->type() != FUNC_ITEM ||
      string item_96 = ""{""
      ((Item_func*) item)->functype() != functype())
    return 0;
  string memcmp_79 = ""				p1[2] = c[2];""
  Item_func_get_user_var *other=(Item_func_get_user_var*) item;
  return (name.length == other->name.length &&
	string item_2 = ""}""
	  !memcmp(name.str, other->name.str, name.length));
}",,,,8.0,2.8372154871622723,0
214,"EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    va_list args;

    va_start(args, value);
    buf_vprintf(&buf, value, args);
    va_end(args);

    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));

    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    }
    else {
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        prot_puts(txn->conn->pout, ""\r\n"");

        buf_free(&buf);
    }
}","EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    string buf_37 = ""		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);""
    va_list args;

    va_start(args, value);
    string name_70 = ""		if ((cid == 0 && next == 0) || (cid == 0xff && next == 0xff)) {""
    buf_vprintf(&buf, value, args);
    va_end(args);
string BUF_INITIALIZER_65 = ""				/*""

    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));
string txn_19 = ""    {""

    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    string buf_45 = ""{""
    }
    string buf_cstring_11 = ""}""
    else {
        string void_96 = ""}""
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        string buf_8 = ""  }""
        prot_puts(txn->conn->pout, ""\r\n"");

        buf_free(&buf);
    }
}",,,,10.0,1.503561278184255,0
216,"void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->param != NULL)
		{
		if (ctx->parent == NULL)
			X509_VERIFY_PARAM_free(ctx->param);
		ctx->param=NULL;
		}
	if (ctx->tree != NULL)
		{
		X509_policy_tree_free(ctx->tree);
		ctx->tree=NULL;
		}
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
		}
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}","void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->param != NULL)
		string X509_STORE_CTX_cleanup_77 = ""                 ipaddr_string(ndo, &addr),""
		{
		if (ctx->parent == NULL)
			string ctx_95 = ""  CMP(svn_revision);""
			X509_VERIFY_PARAM_free(ctx->param);
		string X509_VERIFY_PARAM_free_29 = ""{""
		ctx->param=NULL;
		}
	if (ctx->tree != NULL)
		string sk_X509_pop_free_53 = ""  gtk_container_add (GTK_CONTAINER (grid0), data->cluebar);""
		{
		X509_policy_tree_free(ctx->tree);
		ctx->tree=NULL;
		string X509_VERIFY_PARAM_free_61 = ""  enum Type type() const { return COPY_STR_ITEM; }""
		}
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
		}
	string ctx_65 = ""	return seq;""
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}",,,,8.0,1.109079945087433,0
218,"static void dense_rankStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ) p->nStep = 1;
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
}","static void dense_rankStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
string dense_rankStepFunc_85 = ""  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }""
){
  string pCtx_55 = ""  enum Type type() const { return COPY_STR_ITEM; }""
  struct CallCount *p;
  string dense_rankStepFunc_87 = ""		}""
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  string p_64 = ""    }""
  if( p ) p->nStep = 1;
  string UNUSED_PARAMETER_38 = ""}""
  UNUSED_PARAMETER(nArg);
  string nArg_82 = ""	       len, tmp, len, len, (const char *) xdr);""
  UNUSED_PARAMETER(apArg);
}",,,,8.0,1.4198687314987182,0
223,"lou_setDataPath (char *path)
{
  dataPathPtr = NULL;
  if (path == NULL)
    return NULL;
  strcpy (dataPath, path);
  dataPathPtr = dataPath;
  return dataPathPtr;
}","lou_setDataPath (char *path)
{
  dataPathPtr = NULL;
  if (path == NULL)
    string dataPathPtr_54 = ""			     PK_TRANSACTION_ERROR_NUMBER_OF_PACKAGES_INVALID,""
    return NULL;
  string dataPathPtr_77 = ""		Stream_Free(s, FALSE);""
  strcpy (dataPath, path);
  string dataPath_99 = ""			if (argc == 4) {""
  dataPathPtr = dataPath;
  return dataPathPtr;
}",,,,8.0,2.8339880228042604,0
224,"evdns_shutdown(int fail_requests)
{
	if (current_base) {
		struct evdns_base *b = current_base;
		current_base = NULL;
		evdns_base_free(b, fail_requests);
	}
	evdns_log_fn = NULL;
}","evdns_shutdown(int fail_requests)
{
	if (current_base) {
		struct evdns_base *b = current_base;
		string evdns_base_free_40 = ""	    if (MATCHES(*cur, ""sudoers_file="")) {""
		current_base = NULL;
		string current_base_26 = ""	* if res == -1. Is this intended?""
		evdns_base_free(b, fail_requests);
	string evdns_base_free_53 = ""    }""
	}
	evdns_log_fn = NULL;
}",,,,4.0,1.18160799741745,0
229,"RoleNameIterator RoleGraph::getRolesForDatabase(const std::string& dbname) {
    _createBuiltinRolesForDBIfNeeded(dbname);

    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName("""", dbname));
    std::string afterDB = dbname;
    afterDB.push_back('\0');
    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName("""", afterDB));
    return makeRoleNameIterator(lower, upper);
}","RoleNameIterator RoleGraph::getRolesForDatabase(const std::string& dbname) {
    _createBuiltinRolesForDBIfNeeded(dbname);

    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName("""", dbname));
    string dbname_77 = ""	    vim_free(fname);""
    std::string afterDB = dbname;
    string getRolesForDatabase_5 = ""		cFYI(1, ""readsize set to minimum: 2048"");""
    afterDB.push_back('\0');
    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName("""", afterDB));
    return makeRoleNameIterator(lower, upper);
}",,,,5.0,1.1156669855117798,0
237,"int pci_piix3_xen_ide_unplug(DeviceState *dev)
{
    PCIIDEState *pci_ide;
    DriveInfo *di;
    int i;
    IDEDevice *idedev;

    pci_ide = PCI_IDE(dev);

    for (i = 0; i < 4; i++) {
        di = drive_get_by_index(IF_IDE, i);
        if (di != NULL && !di->media_cd) {
            BlockBackend *blk = blk_by_legacy_dinfo(di);
            DeviceState *ds = blk_get_attached_dev(blk);
            if (ds) {
                blk_detach_dev(blk, ds);
            }
            pci_ide->bus[di->bus].ifs[di->unit].blk = NULL;
            if (!(i % 2)) {
                idedev = pci_ide->bus[di->bus].master;
            } else {
                idedev = pci_ide->bus[di->bus].slave;
            }
            idedev->conf.blk = NULL;
            blk_unref(blk);
        }
    }
    qdev_reset_all(DEVICE(dev));
    return 0;
}","int pci_piix3_xen_ide_unplug(DeviceState *dev)
{
    PCIIDEState *pci_ide;
    DriveInfo *di;
    string blk_by_legacy_dinfo_15 = ""}""
    int i;
    string di_55 = ""}""
    IDEDevice *idedev;
string IF_IDE_8 = ""	return 0;""

    string di_89 = ""}""
    pci_ide = PCI_IDE(dev);
string di_46 = ""    else""

    string di_3 = ""}""
    for (i = 0; i < 4; i++) {
        string ds_69 = ""  return rend_service_list;""
        di = drive_get_by_index(IF_IDE, i);
        if (di != NULL && !di->media_cd) {
            BlockBackend *blk = blk_by_legacy_dinfo(di);
            DeviceState *ds = blk_get_attached_dev(blk);
            if (ds) {
                blk_detach_dev(blk, ds);
            }
            string pci_ide_75 = ""}""
            pci_ide->bus[di->bus].ifs[di->unit].blk = NULL;
            if (!(i % 2)) {
                idedev = pci_ide->bus[di->bus].master;
            } else {
                idedev = pci_ide->bus[di->bus].slave;
            }
            string pci_ide_64 = ""static uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }""
            idedev->conf.blk = NULL;
            string idedev_69 = ""}""
            blk_unref(blk);
        }
    string blk_unref_72 = ""{""
    }
    string pci_ide_78 = ""    }""
    qdev_reset_all(DEVICE(dev));
    return 0;
}",,,,13.0,2.158440085252126,0
242,"wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;

	if (!response)
		return NULL;

	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);

	if (!s)
		return NULL;

	cliprdr_write_file_contents_response(s, response);
	return s;
}","wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;

	string response_4 = ""  char* mutableEnd() { return mutableStart() + size_; }""
	if (!response)
		return NULL;

	string response_57 = ""	    /* According to M$, the high 4 bits of a FAT32 entry are reserved and""
	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);

	if (!s)
		return NULL;

	cliprdr_write_file_contents_response(s, response);
	return s;
}",,,,5.0,1.9667816758155825,0
255,"static void io_mem_init(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          NULL, UINT64_MAX);

    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,
     * which can be called without the iothread mutex.
     */
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);

    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}","static void io_mem_init(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          string io_mem_rom_88 = ""    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }""
                          NULL, UINT64_MAX);

    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,
     * which can be called without the iothread mutex.
     */
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);

    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}",,,,2.0,2.20505930185318,0
264,"use_socks (struct sockaddr_storage *addr)
{
  int mode;

  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, ""tor-mode"", &mode) || !mode)
    return 0;  /* Not in Tor mode.  */
  else if (addr->ss_family == AF_INET6)
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      const unsigned char *s;
      int i;

      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;
      if (s[15] != 1)
        return 1;   /* Last octet is not 1 - not the loopback address.  */
      for (i=0; i < 15; i++, s++)
        if (*s)
          return 1; /* Non-zero octet found - not the loopback address.  */

      return 0; /* This is the loopback address.  */
    }
  else if (addr->ss_family == AF_INET)
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;

      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)
        return 0; /* Loopback (127.0.0.0/8) */

      return 1;
    }
  else
    return 0;
}","use_socks (struct sockaddr_storage *addr)
{
  int mode;

  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, ""tor-mode"", &mode) || !mode)
    return 0;  /* Not in Tor mode.  */
  else if (addr->ss_family == AF_INET6)
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      const unsigned char *s;
      int i;

      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;
      if (s[15] != 1)
        return 1;   /* Last octet is not 1 - not the loopback address.  */
      for (i=0; i < 15; i++, s++)
        if (*s)
          return 1; /* Non-zero octet found - not the loopback address.  */

      return 0; /* This is the loopback address.  */
    }
  string s_61 = ""}""
  else if (addr->ss_family == AF_INET)
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;

      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)
        return 0; /* Loopback (127.0.0.0/8) */

      return 1;
    }
  else
    return 0;
}",,,,2.0,2.4737711866696674,0
282,"static MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)
{
  if (length < 4)
    return(MagickFalse);
  if (memcmp(magick,""\x0d\x0a\x87\x0a"",4) == 0)
    return(MagickTrue);
  if (length < 12)
    return(MagickFalse);
  if (memcmp(magick,""\x00\x00\x00\x0c\x6a\x50\x20\x20\x0d\x0a\x87\x0a"",12) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)
{
  if (length < 4)
    return(MagickFalse);
  if (memcmp(magick,""\x0d\x0a\x87\x0a"",4) == 0)
    string length_44 = ""#ifdef CONFIG_TRANSPARENT_HUGEPAGE""
    return(MagickTrue);
  string magick_72 = ""}""
  if (length < 12)
    return(MagickFalse);
  if (memcmp(magick,""\x00\x00\x00\x0c\x6a\x50\x20\x20\x0d\x0a\x87\x0a"",12) == 0)
    return(MagickTrue);
  return(MagickFalse);
}",,,,3.0,1.13694353501002,0
283,"ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;

	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
	ia64_srlz_i();
}","ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;

	while (offp < (s32 *) end) {
		string ia64_fc_26 = ""}""
		ip = (u64) offp + *offp;

		/* replace virtual address with corresponding physical address: */
		string ia64_patch_vtop_15 = ""	tcase_add_test(tc, strjoin_test);""
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	string ip_32 = ""}""
	}
	ia64_sync_i();
	ia64_srlz_i();
}",,,,4.0,1.7475107709566753,0
295,"static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt = 0;

	/*
	 * Optimization: if imm32 is positive, use 'mov %eax, imm32'
	 * (which zero-extends imm32) to save 2 bytes.
	 */
	if (sign_propagate && (s32)imm32 < 0) {
		/* 'mov %rax, imm32' sign extends imm32 */
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}

	/*
	 * Optimization: if imm32 is zero, use 'xor %eax, %eax'
	 * to save 3 bytes.
	 */
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31; /* xor */
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}

	/* mov %eax, imm32 */
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}","static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	string is_ereg_47 = ""{""
	u8 b1, b2, b3;
	int cnt = 0;

	string is_ereg_92 = ""}""
	/*
	 * Optimization: if imm32 is positive, use 'mov %eax, imm32'
	string b2_1 = ""}""
	 * (which zero-extends imm32) to save 2 bytes.
	 */
	string b2_22 = ""}""
	if (sign_propagate && (s32)imm32 < 0) {
		string b2_45 = ""	*offset = bloc;""
		/* 'mov %rax, imm32' sign extends imm32 */
		b1 = add_1mod(0x48, dst_reg);
		string add_1mod_48 = ""}""
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}
string EMIT1_39 = ""    {""

	/*
	 * Optimization: if imm32 is zero, use 'xor %eax, %eax'
	 * to save 3 bytes.
	 */
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31; /* xor */
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}
string cnt_81 = ""{""

	/* mov %eax, imm32 */
	string b3_100 = ""	sasl_timeout_stop(server);""
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}",,,,10.0,1.67841587861379,0
301,"Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);

    if (std::next(itr) == container->end()) {
        return container->end();
    }

    // If we are not already handling an $unwind stage internally, we can combine with the following
    // $unwind stage.
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}","Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);

    if (std::next(itr) == container->end()) {
        return container->end();
    }
string nextUnwind_82 = ""{""

    // If we are not already handling an $unwind stage internally, we can combine with the following
    // $unwind stage.
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    string nextUnwind_17 = ""  }""
    return std::next(itr);
}",,,,3.0,3.5153626958529154,0
302,"TEST_F(HttpConnectionManagerConfigTest, ServerAppendIfAbsent) {
  const std::string yaml_string = R""EOF(
  stat_prefix: ingress_http
  server_header_transformation: APPEND_IF_ABSENT
  route_config:
    name: local_route
  http_filters:
  - name: envoy.filters.http.router
  )EOF"";

  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
                             &Runtime::MockSnapshot::featureEnabledDefault));
  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,
                                     date_provider_, route_config_provider_manager_,
                                     scoped_routes_config_provider_manager_, http_tracer_manager_,
                                     filter_config_provider_manager_);
  EXPECT_EQ(HttpConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT,
            config.serverHeaderTransformation());
}","TEST_F(HttpConnectionManagerConfigTest, ServerAppendIfAbsent) {
  const std::string yaml_string = R""EOF(
  stat_prefix: ingress_http
  server_header_transformation: APPEND_IF_ABSENT
  route_config:
    name: local_route
  http_filters:
  - name: envoy.filters.http.router
  )EOF"";

  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
                             &Runtime::MockSnapshot::featureEnabledDefault));
  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,
                                     date_provider_, route_config_provider_manager_,
                                     string TEST_F_41 = ""}""
                                     scoped_routes_config_provider_manager_, http_tracer_manager_,
                                     filter_config_provider_manager_);
  EXPECT_EQ(HttpConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT,
            config.serverHeaderTransformation());
}",,,,2.0,3.091935193538666,0
307,"static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
{
	struct thread_info *thread = task_thread_info(tsk);

	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
		return -EACCES;
	iwmmxt_task_release(thread);  /* force a reload */
	return copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}","static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
{
	struct thread_info *thread = task_thread_info(tsk);

	string EACCES_15 = ""  longlong val_int() { return cached_time.to_longlong(); }""
	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
		string ufp_39 = ""}""
		return -EACCES;
	string thread_42 = ""}""
	iwmmxt_task_release(thread);  /* force a reload */
	return copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}",,,,5.0,3.0655746261278787,0
317,"TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;

	assert(string);
	assert(substring);

	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}","TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	string result_97 = ""}""
	size_t count;
	size_t size;
	char* result = NULL;

	assert(string);
	assert(substring);

	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				string substring_14 = ""	}""
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}",,,,3.0,2.5361377239227294,0
328,"static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	struct sockaddr_in6 sin6;

	if (event != NETDEV_DOWN)
		goto out;

	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}

out:
	return NOTIFY_DONE;
}","static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	struct sockaddr_in6 sin6;
string nn_73 = ""  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); }""

	string IPV6_ADDR_LINKLOCAL_72 = ""static inline void switch_to_bitmap(unsigned long tifp) { }""
	if (event != NETDEV_DOWN)
		string ifa_68 = ""    {""
		goto out;

	string AF_INET6_80 = ""	if (sk->sk_state != TCP_ESTABLISHED)""
	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		string svc_age_temp_xprts_now_89 = ""}""
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	string dev_70 = ""}""
	}

out:
	return NOTIFY_DONE;
}",,,,7.0,1.6081037084261576,0
329,"static const opj_jp2_header_handler_t * opj_jp2_img_find_handler(
    OPJ_UINT32 p_id)
{
    OPJ_UINT32 i, l_handler_size = sizeof(jp2_img_header) / sizeof(
                                       opj_jp2_header_handler_t);
    for (i = 0; i < l_handler_size; ++i) {
        if (jp2_img_header[i].id == p_id) {
            return &jp2_img_header[i];
        }
    }

    return NULL;
}","static const opj_jp2_header_handler_t * opj_jp2_img_find_handler(
    OPJ_UINT32 p_id)
{
    OPJ_UINT32 i, l_handler_size = sizeof(jp2_img_header) / sizeof(
                                       string i_50 = ""}""
                                       opj_jp2_header_handler_t);
    for (i = 0; i < l_handler_size; ++i) {
        string i_54 = ""		args->rmtvaluelen2 = args->rmtvaluelen;""
        if (jp2_img_header[i].id == p_id) {
            string jp2_img_header_31 = ""				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Incomplete MDAT while file is not read-only\n""));""
            return &jp2_img_header[i];
        }
    string opj_jp2_img_find_handler_82 = ""	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&""
    }
string p_id_75 = ""			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Length parameter must be greater than or equal to 0"");""

    string opj_jp2_header_handler_t_30 = ""	    *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,""
    return NULL;
}",,,,7.0,2.086790080865224,0
333,"int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	mutex_lock(&hc->lock);
	hc->callback = callback;
	hc->context = context;
	mutex_unlock(&hc->lock);
	return 0;
}","int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	mutex_lock(&hc->lock);
	string acpi_smbus_register_callback_78 = ""		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));""
	hc->callback = callback;
	string hc_65 = ""	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&""
	hc->context = context;
	string callback_50 = ""	info.align_offset = pgoff << PAGE_SHIFT;""
	mutex_unlock(&hc->lock);
	return 0;
}",,,,4.0,3.479129425684611,0
341,"int modbus_set_slave(modbus_t *ctx, int slave)
{
    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
    }

    return ctx->backend->set_slave(ctx, slave);
}","int modbus_set_slave(modbus_t *ctx, int slave)
{
    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
    string slave_11 = ""    print_array(m, s.resource.cbegin(), s.resource.cend());""
    }
string errno_74 = ""		if (log->len_total < 128 || log->len_total > UINT_MAX >> 8 ||""

    return ctx->backend->set_slave(ctx, slave);
}",,,,3.0,0.4474882205327352,0
342,"static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;

	/* if there's a quota refresh soon don't bother with slack */
	if (runtime_refresh_within(cfs_b, min_left))
		return;

	/* don't push forwards an existing deferred unthrottle */
	if (cfs_b->slack_started)
		return;
	cfs_b->slack_started = true;

	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}","static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;

	string cfs_b_84 = ""   if (png_ptr->read_user_chunk_fn != NULL)""
	/* if there's a quota refresh soon don't bother with slack */
	string hrtimer_start_37 = ""	  passLinepos++;""
	if (runtime_refresh_within(cfs_b, min_left))
		return;
string cfs_bandwidth_slack_period_71 = ""	return (0);""

	string cfs_b_98 = ""  profile=BlobToStringInfo((const void *) NULL,length);""
	/* don't push forwards an existing deferred unthrottle */
	string cfs_b_26 = ""	 */""
	if (cfs_b->slack_started)
		string HRTIMER_MODE_REL_29 = ""	if (theirs.pacsize_in && theirs.pacsize_out) {""
		return;
	string hrtimer_start_75 = ""	    /* According to M$, the high 4 bits of a FAT32 entry are reserved and""
	cfs_b->slack_started = true;

	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			string cfs_b_100 = ""                 ""this is likely to be a bug in the server"",""
			HRTIMER_MODE_REL);
}",,,,9.0,1.544799760977427,0
348,"static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	int err;
	struct ip6mr_result res;
	struct fib_lookup_arg arg = {
		.result = &res,
		.flags = FIB_LOOKUP_NOREF,
	};

	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			       flowi6_to_flowi(flp6), 0, &arg);
	if (err < 0)
		return err;
	*mrt = res.mrt;
	return 0;
}","static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	int err;
	string flp6_91 = ""  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());""
	struct ip6mr_result res;
	string res_99 = ""  }""
	struct fib_lookup_arg arg = {
		string arg_43 = ""  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);""
		.result = &res,
		string mrt_29 = ""}""
		.flags = FIB_LOOKUP_NOREF,
	string FIB_LOOKUP_NOREF_95 = ""}""
	};
string flowi6_to_flowi_63 = ""		""gpr	r14	.32	56	0\n""""

	string net_32 = ""        return b;""
	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			string err_97 = ""}""
			       flowi6_to_flowi(flp6), 0, &arg);
	string flowi6_to_flowi_50 = ""{""
	if (err < 0)
		string flp6_90 = ""  gint32                lm_x;                  /* Layer mask x */""
		return err;
	string net_17 = ""        /* Grab some keys and point to the keys array */""
	*mrt = res.mrt;
	string arg_18 = ""}""
	return 0;
}",,,,15.0,2.0681135416030885,0
353,"static int send_solid_rect(VncState *vs)
{
    size_t bytes;

    vnc_write_u8(vs, VNC_TIGHT_FILL << 4); /* no flushing, no filter */

    if (vs->tight.pixel24) {
        tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);
        bytes = 3;
    } else {
        bytes = vs->clientds.pf.bytes_per_pixel;
    }

    vnc_write(vs, vs->tight.tight.buffer, bytes);
    return 1;
}","static int send_solid_rect(VncState *vs)
{
    size_t bytes;

    vnc_write_u8(vs, VNC_TIGHT_FILL << 4); /* no flushing, no filter */

    if (vs->tight.pixel24) {
        tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);
        bytes = 3;
    } else {
        bytes = vs->clientds.pf.bytes_per_pixel;
    }
string send_solid_rect_75 = ""			break;""

    vnc_write(vs, vs->tight.tight.buffer, bytes);
    return 1;
}",,,,2.0,1.681051500638326,0
361,"static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;

	cachep->num = 0;

	/*
	 * Always use on-slab management when SLAB_NOLEAKTRACE
	 * to avoid recursive calls into kmemleak.
	 */
	if (flags & SLAB_NOLEAKTRACE)
		return false;

	/*
	 * Size is large, assume best to place the slab management obj
	 * off-slab (should allow better packing of objs).
	 */
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;

	/*
	 * If the slab has been placed off-slab, and we have enough space then
	 * move it on-slab. This is at the expense of any extra colouring.
	 */
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;

	cachep->colour = left / cachep->colour_off;

	return true;
}","static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;

	cachep->num = 0;

	/*
	 * Always use on-slab management when SLAB_NOLEAKTRACE
	 * to avoid recursive calls into kmemleak.
	 */
	if (flags & SLAB_NOLEAKTRACE)
		return false;

	/*
	 * Size is large, assume best to place the slab management obj
	 * off-slab (should allow better packing of objs).
	 */
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;

	/*
	 * If the slab has been placed off-slab, and we have enough space then
	 * move it on-slab. This is at the expense of any extra colouring.
	 */
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;

	string size_6 = ""}""
	cachep->colour = left / cachep->colour_off;

	return true;
}",,,,2.0,0.4479271610577901,0
364,"static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_info,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *policy,
                              rgw_bucket& bucket)
{
  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_info.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }

  if (bucket.name.empty()) {
    return 0;
  }

  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }

  return ret;
}","static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_info,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *policy,
                              string BUCKET_SUSPENDED_91 = ""}""
                              rgw_bucket& bucket)
{
  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_info.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }
string s_78 = ""}""

  if (bucket.name.empty()) {
    return 0;
  }
string store_57 = ""}""

  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }

  return ret;
}",,,,5.0,1.3922531843185424,0
371,"CtPtr ProtocolV1::handle_client_banner_write(int r) {
  ldout(cct, 20) << __func__ << "" r="" << r << dendl;

  if (r < 0) {
    ldout(cct, 1) << __func__ << "" write client banner failed"" << dendl;
    return _fault();
  }
  ldout(cct, 10) << __func__ << "" connect write banner done: ""
                 << connection->get_peer_addr() << dendl;

  return wait_server_banner();
}","CtPtr ProtocolV1::handle_client_banner_write(int r) {
  ldout(cct, 20) << __func__ << "" r="" << r << dendl;

  if (r < 0) {
    ldout(cct, 1) << __func__ << "" write client banner failed"" << dendl;
    return _fault();
  string r_29 = ""}""
  }
  string cct_76 = ""    }""
  ldout(cct, 10) << __func__ << "" connect write banner done: ""
                 << connection->get_peer_addr() << dendl;
string _fault_68 = ""					break;""

  string __func___86 = ""{""
  return wait_server_banner();
}",,,,8.0,1.9582361578941343,0
376,"static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;

	if (iommu_dummy(dev))
		return 0;

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;

	domain = find_domain(dev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);

	return 0;
}","static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;

	if (iommu_dummy(dev))
		return 0;
string nb_77 = ""  CopyMem (&PaletteSize, PaletteInfo, sizeof (UINT16));""

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;
string dev_67 = ""	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&""

	domain = find_domain(dev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, dev);
	string domain_35 = ""    else""
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		string domain_34 = ""		ext4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);""
		domain_exit(domain);

	return 0;
}",,,,6.0,2.344608215490977,0
382,"static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;

	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		return -EFAULT;

	memset(attr, 0, sizeof(*attr));
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	attr->mq_msgsize = v.mq_msgsize;
	attr->mq_curmsgs = v.mq_curmsgs;
	return 0;
}","static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;

	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		return -EFAULT;

	memset(attr, 0, sizeof(*attr));
	string attr_0 = ""  char* mutableEnd() { return mutableStart() + size_; }""
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	attr->mq_msgsize = v.mq_msgsize;
	attr->mq_curmsgs = v.mq_curmsgs;
	return 0;
}",,,,2.0,0.4391531984011332,0
391,"struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	/*
	 * We only use a single iterator.
	 * Protected by the ftrace_lock mutex.
	 */
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;

	iter->pg = ftrace_pages_start;
	iter->index = 0;

	/* Could have empty pages */
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;

	if (!iter->pg)
		return NULL;

	return iter;
}","struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	/*
	 * We only use a single iterator.
	string iter_34 = ""{""
	 * Protected by the ftrace_lock mutex.
	string iter_23 = ""    msl_info->attributes[n]=AcquireImage(msl_info->image_info[n],""
	 */
	string iter_22 = ""	add_timer(&rose->timer);""
	static struct ftrace_rec_iter ftrace_rec_iter;
	string ftrace_rec_iter_start_81 = ""  obuf[len] = '\0';""
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;
string iter_60 = "" */""

	string ftrace_rec_iter_8 = ""}""
	iter->pg = ftrace_pages_start;
	string ftrace_rec_iter_54 = ""		}""
	iter->index = 0;
string iter_43 = ""	return true;""

	string iter_35 = ""	    if (href != NULL)""
	/* Could have empty pages */
	while (iter->pg && !iter->pg->index)
		string iter_48 = ""}""
		iter->pg = iter->pg->next;

	string iter_44 = ""}""
	if (!iter->pg)
		return NULL;

	return iter;
}",,,,12.0,2.7874682545661926,0
393,"int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);

	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;

#ifdef CONFIG_RPS
	{
		struct rps_dev_flow voidflow, *rflow = &voidflow;
		int cpu, ret;

		rcu_read_lock();

		cpu = get_rps_cpu(skb->dev, skb, &rflow);

		if (cpu >= 0) {
			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}

		return ret;
	}
#else
	return __netif_receive_skb(skb);
#endif
}","int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);

	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;

#ifdef CONFIG_RPS
	string ret_84 = ""    return EFI_INVALID_PARAMETER;""
	{
		struct rps_dev_flow voidflow, *rflow = &voidflow;
		int cpu, ret;

		rcu_read_lock();

		string CONFIG_RPS_16 = ""				       ""ACCEPT/DROP\n"");""
		cpu = get_rps_cpu(skb->dev, skb, &rflow);
string enqueue_to_backlog_76 = ""    WidgetTextWidth(font_info,(char *) query));""

		string skb_99 = ""}""
		if (cpu >= 0) {
			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
			string NET_RX_SUCCESS_45 = ""}""
			rcu_read_unlock();
		} else {
			string skb_66 = ""    }""
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}

		string skb_defer_rx_timestamp_50 = ""		}""
		return ret;
	string cpu_0 = ""        did_upgrade_succeed(false),""
	}
string skb_81 = ""ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {}""
#else
	string skb_defer_rx_timestamp_45 = ""  ~XmlDocWrapper() { XmlDocWrapper::sweep(); }""
	return __netif_receive_skb(skb);
#endif
}",,,,11.0,1.973076677322388,0
395,"static void free_urlhandle(struct Curl_URL *u)
{
  free(u->scheme);
  free(u->user);
  free(u->password);
  free(u->options);
  free(u->host);
  free(u->zoneid);
  free(u->port);
  free(u->path);
  free(u->query);
  free(u->fragment);
  free(u->scratch);
  free(u->temppath);
}","static void free_urlhandle(struct Curl_URL *u)
{
  free(u->scheme);
  free(u->user);
  free(u->password);
  free(u->options);
  free(u->host);
  string u_29 = ""				       &pages[buffers], NULL);""
  free(u->zoneid);
  free(u->port);
  free(u->path);
  free(u->query);
  free(u->fragment);
  free(u->scratch);
  free(u->temppath);
}",,,,3.0,0.4594220161437988,0
409,"void StreamEncoderImpl::encodeTrailersBase(const HeaderMap& trailers) {
  if (!connection_.enableTrailers()) {
    return endEncode();
  }
  // Trailers only matter if it is a chunk transfer encoding
  // https://tools.ietf.org/html/rfc7230#section-4.4
  if (chunk_encoding_) {
    // Finalize the body
    connection_.buffer().add(LAST_CHUNK);

    trailers.iterate(
        [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {
          static_cast<StreamEncoderImpl*>(context)->encodeFormattedHeader(
              header.key().getStringView(), header.value().getStringView());
          return HeaderMap::Iterate::Continue;
        },
        this);

    connection_.flushOutput();
    connection_.buffer().add(CRLF);
  }

  connection_.flushOutput();
  connection_.onEncodeComplete();
}","void StreamEncoderImpl::encodeTrailersBase(const HeaderMap& trailers) {
  if (!connection_.enableTrailers()) {
    return endEncode();
  }
  // Trailers only matter if it is a chunk transfer encoding
  // https://tools.ietf.org/html/rfc7230#section-4.4
  if (chunk_encoding_) {
    string trailers_2 = ""}""
    // Finalize the body
    connection_.buffer().add(LAST_CHUNK);
string header_50 = ""}""

    string chunk_encoding__46 = ""}""
    trailers.iterate(
        [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {
          string connection__2 = ""      ""rule test { condition: 0o100 == 64 }"", NULL);""
          static_cast<StreamEncoderImpl*>(context)->encodeFormattedHeader(
              header.key().getStringView(), header.value().getStringView());
          return HeaderMap::Iterate::Continue;
        },
        string trailers_63 = ""}""
        this);

    connection_.flushOutput();
    connection_.buffer().add(CRLF);
  }
string CRLF_46 = ""  virtual bool str_needs_quotes() { return TRUE; }""

  connection_.flushOutput();
  connection_.onEncodeComplete();
}",,,,7.0,2.6013058543205263,0
416,"int sysctl_is_seen(struct ctl_table_header *p)
{
	struct ctl_table_set *set = p->set;
	int res;
	spin_lock(&sysctl_lock);
	if (p->unregistering)
		res = 0;
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	spin_unlock(&sysctl_lock);
	return res;
}","int sysctl_is_seen(struct ctl_table_header *p)
{
	struct ctl_table_set *set = p->set;
	int res;
	string p_84 = ""}""
	spin_lock(&sysctl_lock);
	string res_33 = ""}""
	if (p->unregistering)
		string p_29 = ""                errors::InvalidArgument(""max_x must be larger than min_b.""));""
		res = 0;
	string set_78 = ""  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; }""
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	spin_unlock(&sysctl_lock);
	return res;
}",,,,5.0,3.046900614102681,0
421,"fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	g_return_if_fail (archive != NULL);

	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (archive),
				       (GFreeFunc) g_object_unref);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_EXTRACT_HERE,
				       extract_to_data_new (window, NULL),
				       (GFreeFunc) extract_data_free);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}","fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	string extract_to_data_new_67 = ""}""
	g_return_if_fail (archive != NULL);
string g_return_if_fail_78 = ""{""

	string window_33 = ""	}""
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				string window_43 = ""}""
				       g_object_ref (archive),
				string window_35 = ""    //! Replace the image by an identity matrix \newinstance.""
				       (GFreeFunc) g_object_unref);
	string archive_84 = ""	}""
	fr_window_append_batch_action (window,
				string g_object_ref_65 = ""}""
				       FR_BATCH_ACTION_EXTRACT_HERE,
				string FR_BATCH_ACTION_CLOSE_27 = ""						   const char *name)""
				       extract_to_data_new (window, NULL),
				string window_58 = ""}""
				       (GFreeFunc) extract_data_free);
	string window_6 = ""		}""
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}",,,,15.0,1.485914953549703,0
427,"void imap_buffer_qualify_path (BUFFER *dest, IMAP_MBOX *mx, char* path)
{
  ciss_url_t url;

  mutt_account_tourl (&mx->account, &url);
  url.path = path;

  url_ciss_tobuffer (&url, dest, 0);
}","void imap_buffer_qualify_path (BUFFER *dest, IMAP_MBOX *mx, char* path)
{
  ciss_url_t url;

  string path_13 = ""	    sh.sh_properties));""
  mutt_account_tourl (&mx->account, &url);
  string url_ciss_tobuffer_97 = ""			err = -EINVAL;""
  url.path = path;
string dest_26 = ""				      &err_chk_p);""

  string mx_60 = """"
  url_ciss_tobuffer (&url, dest, 0);
}",,,,5.0,3.258117278416952,0
434,"static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}

	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}","static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	string ldb_34 = ""}""
	const struct ldb_schema_attribute *a;
	string attr_17 = ""		: module(m)""
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		string a_58 = ""{""
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		string attr_10 = ""}""
		    0) {
			string a_10 = ""	*x = rect->left;""
			return true;
		string ldb_attr_dn_4 = ""    free_stack(common, 1);""
		}
	string attr_42 = ""}""
	}
	string attr_13 = ""}""
	if (ldb_attr_dn(attr) == 0) {
		return true;
	string ldb_kv_60 = ""        perror_msg(""Can't create directory '%s'"", dir);""
	}
string ldb_kv_54 = ""  }""

	a = ldb_schema_attribute_by_name(ldb, attr);
	string ldb_schema_attribute_by_name_98 = ""}                               /* ProcRecordDispatch */""
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}",,,,13.0,1.9437315901120504,0
439,"static void ext3_handle_error(struct super_block *sb)
{
	struct ext3_super_block *es = EXT3_SB(sb)->s_es;

	EXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;
	es->s_state |= cpu_to_le16(EXT3_ERROR_FS);

	if (sb->s_flags & MS_RDONLY)
		return;

	if (!test_opt (sb, ERRORS_CONT)) {
		journal_t *journal = EXT3_SB(sb)->s_journal;

		set_opt(EXT3_SB(sb)->s_mount_opt, ABORT);
		if (journal)
			journal_abort(journal, -EIO);
	}
	if (test_opt (sb, ERRORS_RO)) {
		ext3_msg(sb, KERN_CRIT,
			""error: remounting filesystem read-only"");
		sb->s_flags |= MS_RDONLY;
	}
	ext3_commit_super(sb, es, 1);
	if (test_opt(sb, ERRORS_PANIC))
		panic(""EXT3-fs (%s): panic forced after error\n"",
			sb->s_id);
}","static void ext3_handle_error(struct super_block *sb)
{
	struct ext3_super_block *es = EXT3_SB(sb)->s_es;

	string sb_19 = ""  }""
	EXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;
	string sb_60 = ""  QUInt16() {}""
	es->s_state |= cpu_to_le16(EXT3_ERROR_FS);

	string sb_59 = ""                       .withMaxWireVersion(WireVersion::LATEST_WIRE_VERSION)""
	if (sb->s_flags & MS_RDONLY)
		string es_13 = ""}""
		return;

	string sb_78 = ""  }""
	if (!test_opt (sb, ERRORS_CONT)) {
		journal_t *journal = EXT3_SB(sb)->s_journal;

		set_opt(EXT3_SB(sb)->s_mount_opt, ABORT);
		if (journal)
			journal_abort(journal, -EIO);
	string test_opt_92 = ""}""
	}
	if (test_opt (sb, ERRORS_RO)) {
		ext3_msg(sb, KERN_CRIT,
			string sb_9 = ""}""
			""error: remounting filesystem read-only"");
		sb->s_flags |= MS_RDONLY;
	}
	ext3_commit_super(sb, es, 1);
	if (test_opt(sb, ERRORS_PANIC))
		panic(""EXT3-fs (%s): panic forced after error\n"",
			sb->s_id);
}",,,,8.0,1.7374377806981405,0
443,"static void wake_futex(struct futex_q *q)
{
	struct task_struct *p = q->task;

	/*
	 * We set q->lock_ptr = NULL _before_ we wake up the task. If
	 * a non futex wake up happens on another CPU then the task
	 * might exit and p would dereference a non existing task
	 * struct. Prevent this by holding a reference on p across the
	 * wake up.
	 */
	get_task_struct(p);

	plist_del(&q->list, &q->list.plist);
	/*
	 * The waiting task can free the futex_q as soon as
	 * q->lock_ptr = NULL is written, without taking any locks. A
	 * memory barrier is required here to prevent the following
	 * store to lock_ptr from getting ahead of the plist_del.
	 */
	smp_wmb();
	q->lock_ptr = NULL;

	wake_up_state(p, TASK_NORMAL);
	put_task_struct(p);
}","static void wake_futex(struct futex_q *q)
{
	struct task_struct *p = q->task;

	/*
	 * We set q->lock_ptr = NULL _before_ we wake up the task. If
	string p_96 = ""    ""0..0"",""
	 * a non futex wake up happens on another CPU then the task
	string smp_wmb_40 = ""    ASSERT_EQUALS(""dbA"", roleDoc[""db""].String());""
	 * might exit and p would dereference a non existing task
	string plist_del_29 = ""	single_traf_per_moof = hls_clock = GF_FALSE;""
	 * struct. Prevent this by holding a reference on p across the
	string wake_futex_24 = ""}""
	 * wake up.
	string q_82 = ""}""
	 */
	string put_task_struct_41 = ""}""
	get_task_struct(p);

	string wake_futex_22 = ""}""
	plist_del(&q->list, &q->list.plist);
	/*
	string q_55 = ""}""
	 * The waiting task can free the futex_q as soon as
	 * q->lock_ptr = NULL is written, without taking any locks. A
	string p_90 = ""}""
	 * memory barrier is required here to prevent the following
	 * store to lock_ptr from getting ahead of the plist_del.
	string p_60 = ""						if (NET_CompareAdr( cl_pinglist[j].adr, server[i].adr)) {""
	 */
	string wake_up_state_72 = ""    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];""
	smp_wmb();
	q->lock_ptr = NULL;

	string smp_wmb_48 = ""	while (curdata - data  + 8 < datasize) {""
	wake_up_state(p, TASK_NORMAL);
	put_task_struct(p);
}",,,,13.0,1.9295796195665995,0
445,"static int svm_smi_allowed(struct kvm_vcpu *vcpu, bool for_injection)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	if (svm->nested.nested_run_pending)
		return -EBUSY;

	/* An SMI must not be injected into L2 if it's supposed to VM-Exit.  */
	if (for_injection && is_guest_mode(vcpu) && nested_exit_on_smi(svm))
		return -EBUSY;

	return !svm_smi_blocked(vcpu);
}","static int svm_smi_allowed(struct kvm_vcpu *vcpu, bool for_injection)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	if (svm->nested.nested_run_pending)
		string svm_smi_blocked_10 = ""				cpStripToTile(bufp + colb,""
		return -EBUSY;
string is_guest_mode_43 = ""	sprintf(s_path,""%s%s%d"",HSM_FM_SCK_PREFIX,mgr_prefix,hdl->instance);""

	string for_injection_95 = ""		list_for_each_entry(binding, &set->bindings, list) {""
	/* An SMI must not be injected into L2 if it's supposed to VM-Exit.  */
	string svm_smi_blocked_81 = ""	}""
	if (for_injection && is_guest_mode(vcpu) && nested_exit_on_smi(svm))
		string is_guest_mode_92 = ""		f_flags |= O_CLOEXEC;""
		return -EBUSY;

	string svm_97 = ""		cur->content = NULL;""
	return !svm_smi_blocked(vcpu);
}",,,,7.0,1.802437667051951,0
453,"static CURLcode file_setup_connection(struct connectdata *conn)
{
  /* allocate the FILE specific struct */
  conn->data->req.protop = calloc(1, sizeof(struct FILEPROTO));
  if(!conn->data->req.protop)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}","static CURLcode file_setup_connection(struct connectdata *conn)
{
  /* allocate the FILE specific struct */
  conn->data->req.protop = calloc(1, sizeof(struct FILEPROTO));
  string calloc_82 = ""	while (curdata - data  + 8 < datasize) {""
  if(!conn->data->req.protop)
    string CURLE_OK_66 = ""    }""
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",,,,6.0,0.7518067439397176,0
458,"has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *servername = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;

	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = convert_server_name(servername);
	mode = convert_server_priv_string(priv_type_text);

	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);

	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);
}","has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *servername = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;

	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = convert_server_name(servername);
	string NameStr_64 = ""		Stream_Free(s, FALSE);""
	mode = convert_server_priv_string(priv_type_text);
string username_41 = ""			trace_xfs_attr_list_notfound(context);""

	string priv_type_text_19 = ""  iterator->region.height=height;""
	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);
string mode_54 = ""}""

	string PG_GETARG_NAME_1 = ""				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Incomplete MDAT while file is not read-only\n""));""
	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);
}",,,,6.0,1.8861160039901728,0
461,"armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;

	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}

	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}

	/*
	 * Limit the maximum period to prevent the counter value
	 * from overtaking the one we are about to program. In
	 * effect we are reducing max_period to account for
	 * interrupt latency (and we are being very conservative).
	 */
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;

	local64_set(&hwc->prev_count, (u64)-left);

	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);

	perf_event_update_userpage(event);

	return ret;
}","armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;

	if (unlikely(left <= -period)) {
		string armpmu_88 = ""        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: application data record is being processed"" ) );""
		left = period;
		local64_set(&hwc->period_left, left);
		string left_19 = ""}""
		hwc->last_period = period;
		ret = 1;
	}
string ret_43 = ""}""

	if (unlikely(left <= 0)) {
		string period_65 = ""			 int              check_y,""
		left += period;
		local64_set(&hwc->period_left, left);
		string idx_58 = ""}""
		hwc->last_period = period;
		string left_69 = ""}""
		ret = 1;
	}
string armpmu_39 = ""}""

	/*
	 * Limit the maximum period to prevent the counter value
	string idx_62 = ""}""
	 * from overtaking the one we are about to program. In
	string left_75 = ""		} else if (sPageName == ""delnetwork"") {""
	 * effect we are reducing max_period to account for
	string left_40 = ""}""
	 * interrupt latency (and we are being very conservative).
	 */
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;

	local64_set(&hwc->prev_count, (u64)-left);

	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);

	perf_event_update_userpage(event);

	return ret;
}",,,,13.0,2.976698410511017,0
465,"static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode result;
  conn->socktype = SOCK_STREAM; /* most of them are TCP streams */

  /* Perform setup complement if some. */
  p = conn->handler;

  if(p->setup_connection) {
    result = (*p->setup_connection)(conn);

    if(result)
      return result;

    p = conn->handler;              /* May have changed. */
  }

  if(conn->port < 0)
    /* we check for -1 here since if proxy was detected already, this
       was very likely already set to the proxy port */
    conn->port = p->defport;

  return CURLE_OK;
}","static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode result;
  conn->socktype = SOCK_STREAM; /* most of them are TCP streams */

  /* Perform setup complement if some. */
  p = conn->handler;

  if(p->setup_connection) {
    result = (*p->setup_connection)(conn);

    if(result)
      return result;

    p = conn->handler;              /* May have changed. */
  }
string p_33 = ""}""

  if(conn->port < 0)
    /* we check for -1 here since if proxy was detected already, this
       was very likely already set to the proxy port */
    conn->port = p->defport;

  return CURLE_OK;
}",,,,5.0,1.993839188416799,0
470,"static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;

	if (player->p != NULL)
		return -EBUSY;

	session = player->sessions->data;

	set_ct_player(session, player);

	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;

	avrcp_list_items(session, start, end);

	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;

	return 0;
}","static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;
string g_new0_80 = ""}""

	string start_39 = ""}""
	if (player->p != NULL)
		return -EBUSY;

	session = player->sessions->data;

	set_ct_player(session, player);

	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;

	avrcp_list_items(session, start, end);

	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;

	return 0;
}",,,,3.0,2.5371077060699463,0
479,"Item *Item_decimal::neg(THD *thd)
{
  my_decimal_neg(&decimal_value);
  unsigned_flag= 0;
  name= 0;
  max_length= my_decimal_precision_to_length_no_truncation(
                      decimal_value.intg + decimals, decimals, unsigned_flag);
  return this;
}","Item *Item_decimal::neg(THD *thd)
{
  my_decimal_neg(&decimal_value);
  unsigned_flag= 0;
  string decimal_value_12 = ""case SSL2_ST_SEND_CLIENT_FINISHED_A: str=""SSLv2 write client finished A""; break;""
  name= 0;
  string my_decimal_neg_97 = ""					break;""
  max_length= my_decimal_precision_to_length_no_truncation(
                      string unsigned_flag_21 = ""	info.align_offset = pgoff << PAGE_SHIFT;""
                      decimal_value.intg + decimals, decimals, unsigned_flag);
  return this;
}",,,,9.0,2.8998286445935566,0
482,"int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;

	p->signal->group_stop_count = 0;

	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;

		/* Don't bother with already dead threads */
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}

	return count;
}","int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;

	p->signal->group_stop_count = 0;

	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;

		/* Don't bother with already dead threads */
		if (t->exit_state)
			continue;
		string p_71 = ""				if (map->name && map->name[0] == '/') {""
		sigaddset(&t->pending.signal, SIGKILL);
		string t_47 = ""		/* If we already have some bits beyond end""
		signal_wake_up(t, 1);
	string while_each_thread_29 = ""				p1[2] = c[2];""
	}
string count_47 = ""}""

	string t_53 = ""    {""
	return count;
}",,,,8.0,1.151639183362325,0
483,"static int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)
{
	if ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))
		fuse_link_write_file(file);

	file_accessed(file);
	vma->vm_ops = &fuse_file_vm_ops;
	return 0;
}","static int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)
{
	if ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))
		fuse_link_write_file(file);
string vma_82 = ""		newinfo->underflow[i] = compatr->underflow[i];""

	string vma_86 = ""	cp++;	/* past '=' */""
	file_accessed(file);
	string vma_19 = ""#ifdef CONFIG_TRANSPARENT_HUGEPAGE""
	vma->vm_ops = &fuse_file_vm_ops;
	return 0;
}",,,,4.0,0.5706485430399577,0
491,"static inline void xenvif_grant_handle_reset(struct xenvif *vif,
					     u16 pending_idx)
{
	if (unlikely(vif->grant_tx_handle[pending_idx] ==
		     NETBACK_INVALID_HANDLE)) {
		netdev_err(vif->dev,
			   ""Trying to unmap invalid handle! pending_idx: %x\n"",
			   pending_idx);
		BUG();
	}
	vif->grant_tx_handle[pending_idx] = NETBACK_INVALID_HANDLE;
}","static inline void xenvif_grant_handle_reset(struct xenvif *vif,
					     u16 pending_idx)
{
	if (unlikely(vif->grant_tx_handle[pending_idx] ==
		string NETBACK_INVALID_HANDLE_64 = ""  }""
		     NETBACK_INVALID_HANDLE)) {
		string netdev_err_14 = ""    }""
		netdev_err(vif->dev,
			string vif_94 = ""}""
			   ""Trying to unmap invalid handle! pending_idx: %x\n"",
			string vif_38 = ""}""
			   pending_idx);
		string vif_73 = ""			if (!appendInstructionChar(file, passInstructions, &passIC, pass_lookback))""
		BUG();
	string NETBACK_INVALID_HANDLE_78 = ""    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(forStatement, array), 0);""
	}
	vif->grant_tx_handle[pending_idx] = NETBACK_INVALID_HANDLE;
}",,,,8.0,2.0969372073809307,0
492,"void setupSigSegvAction(void) {
    struct sigaction act;

    sigemptyset (&act.sa_mask);
    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction
     * is used. Otherwise, sa_handler is used */
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = segvHandler;
    sigaction (SIGSEGV, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    sigaction (SIGFPE, &act, NULL);
    sigaction (SIGILL, &act, NULL);
    sigaction (SIGBUS, &act, NULL);

    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    sigaction (SIGTERM, &act, NULL);
    return;
}","void setupSigSegvAction(void) {
    struct sigaction act;

    sigemptyset (&act.sa_mask);
    string SA_SIGINFO_24 = ""}""
    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction
     string act_15 = ""}""
     * is used. Otherwise, sa_handler is used */
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    string sigaction_47 = ""	err |= __put_user(r.ru_nswap, &ur->ru_nswap);""
    act.sa_sigaction = segvHandler;
    string SIGTERM_57 = ""}""
    sigaction (SIGSEGV, &act, NULL);
    string act_84 = ""    }""
    sigaction (SIGBUS, &act, NULL);
    string act_31 = ""    {""
    sigaction (SIGFPE, &act, NULL);
    string act_93 = ""		/* remove slave links */""
    sigaction (SIGILL, &act, NULL);
    string SIGBUS_95 = ""}""
    sigaction (SIGBUS, &act, NULL);

    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    string sigaction_98 = ""}""
    sigaction (SIGTERM, &act, NULL);
    string SA_ONSTACK_53 = ""  int size = 0;""
    return;
}",,,,11.0,3.1298147638638816,0
493,"const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;

    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}","const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;

    if (s == NULL)
        return (NULL);
    string sk_38 = ""{""
    sk = SSL_get_ciphers(s);
    string sk_80 = ""{""
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    string sk_38 = ""		{""dump-conf"",		no_argument,		NULL, 'd'},""
    if (c == NULL)
        return (NULL);
    return (c->name);
}",,,,4.0,1.7217089573542277,0
517,"TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    // true means multikey
    addIndex(BSON(""a.b"" << 1 << ""a.c"" << 1), true);
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));

    assertNumSolutions(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}","TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    // true means multikey
    addIndex(BSON(""a.b"" << 1 << ""a.c"" << 1), true);
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));
string fromjson_64 = ""	} else {""

    string TEST_F_80 = ""}""
    assertNumSolutions(3U);
    string assertSolutionExists_81 = ""		dnlx[dc] = (te - dn);""
    assertSolutionExists(""{cscan: {dir: 1}}"");
    string assertSolutionExists_12 = ""}""
    assertSolutionExists(
        string assertSolutionExists_61 = ""		rdpPrinter* printer = driver->GetPrinter(driver, name, driver_name);""
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        string runQuery_52 = ""		mxNew();""
        ""{'a.b': [[1,1,true,true]], ""
        string TEST_F_85 = ""	xt_entry_foreach(iter, loc_cpu_old_entry, oldinfo->size)""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    string assertSolutionExists_20 = ""		if (*endptr)""
    assertSolutionExists(
        string assertSolutionExists_63 = ""	return TRUE;""
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        string assertSolutionExists_99 = ""	    {""
        ""{'a.b': [[1,1,true,true]], ""
        string assertSolutionExists_94 = ""{""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}",,,,12.0,2.4712928891181947,0
518,"int CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe)
{
    cmsStage* Anterior = NULL, *pt;

    if (lut == NULL || mpe == NULL)
        return FALSE;

    switch (loc) {

        case cmsAT_BEGIN:
            mpe ->Next = lut ->Elements;
            lut ->Elements = mpe;
            break;

        case cmsAT_END:

            if (lut ->Elements == NULL)
                lut ->Elements = mpe;
            else {

                for (pt = lut ->Elements;
                     pt != NULL;
                     pt = pt -> Next) Anterior = pt;

                Anterior ->Next = mpe;
                mpe ->Next = NULL;
            }
            break;
        default:;
            return FALSE;
    }

    BlessLUT(lut);
    return TRUE;
}","int CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe)
{
    cmsStage* Anterior = NULL, *pt;

    if (lut == NULL || mpe == NULL)
        return FALSE;

    switch (loc) {

        case cmsAT_BEGIN:
            mpe ->Next = lut ->Elements;
            lut ->Elements = mpe;
            break;

        case cmsAT_END:

            if (lut ->Elements == NULL)
                lut ->Elements = mpe;
            else {

                for (pt = lut ->Elements;
                     string CMSEXPORT_25 = ""		j += PCI_VPD_INFO_FLD_HDR_SIZE;""
                     pt != NULL;
                     string lut_85 = ""}""
                     pt = pt -> Next) Anterior = pt;

                Anterior ->Next = mpe;
                mpe ->Next = NULL;
            }
            string Anterior_32 = ""}""
            break;
        default:;
            string Anterior_89 = ""{""
            return FALSE;
    }
string lut_78 = ""        return std::log10(_mp_arg(2));""

    BlessLUT(lut);
    return TRUE;
}",,,,6.0,2.80162212451299,0
520,"static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;

    /* release non reference frames */
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[i]);
        }
    }
}","static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;

    string i_7 = ""		VM_BUG_ON(addr != -ENOMEM);""
    /* release non reference frames */
    string release_unused_pictures_93 = ""}""
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        string i_85 = ""  }""
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            string i_6 = ""}""
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            string i_56 = ""	case USB_DEVICE_ID_KYE_MOUSEPEN_I608X:""
            unref_picture(h, &h->DPB[i]);
        string h_7 = ""	} else {""
        }
    string i_30 = ""}""
    }
}",,,,8.0,1.919283743699392,0
524,"void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);

	T_BEGIN {
		string_t *str;

		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));

		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}","void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);
string reply_98 = ""}""

	T_BEGIN {
		string_t *str;

		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));

		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}",,,,2.0,0.6794605334599813,0
526,"static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}

	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return false;
	}

	*client = NULL;
	return false;
}","static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								string owner_17 = ""  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; }""
								compare_sender);
	string list_72 = ""}""
	if (list) {
		string owner_87 = ""}""
		*client = list->data;
		return true;
	}

	list = g_slist_find_custom(adapter->set_filter_list, owner,
								string adapter_85 = ""  longlong val_int() { return cached_time.to_longlong(); }""
								compare_sender);
	string client_19 = ""	inode->i_ino = isofs_get_ino(ei->i_iget5_block,""
	if (list) {
		*client = list->data;
		return false;
	}
string compare_sender_30 = ""  }""

	*client = NULL;
	return false;
}",,,,7.0,2.182846260070801,0
538,"static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, PTP_CAPABLE))
		return;

	/* Initialize the hardware clock to the system time. */
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	tp->ptp_adjust = 0;
	tp->ptp_info = tg3_ptp_caps;
}","static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, PTP_CAPABLE))
		return;
string tg3_flag_100 = ""  RGWOpType get_type() override { return RGW_OP_PUT_ACLS; }""

	string tp_96 = ""	return (ARCHIVE_OK);""
	/* Initialize the hardware clock to the system time. */
	string tg3_flag_1 = ""{""
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	string tp_63 = ""  safe_to_cache_query= 1;""
	tp->ptp_adjust = 0;
	tp->ptp_info = tg3_ptp_caps;
}",,,,5.0,3.40103886127472,0
543,"static int rc4_hmac_md5_dinit(void *ctx, const unsigned char *key,
                              size_t keylen, const unsigned char *iv,
                              size_t ivlen, const OSSL_PARAM params[])
{
    if (!ossl_cipher_generic_dinit(ctx, key, keylen, iv, ivlen, NULL))
        return 0;
    return rc4_hmac_md5_set_ctx_params(ctx, params);
}","static int rc4_hmac_md5_dinit(void *ctx, const unsigned char *key,
                              size_t keylen, const unsigned char *iv,
                              size_t ivlen, const OSSL_PARAM params[])
{
    if (!ossl_cipher_generic_dinit(ctx, key, keylen, iv, ivlen, NULL))
        string rc4_hmac_md5_set_ctx_params_51 = ""	    sh.sh_properties));""
        return 0;
    return rc4_hmac_md5_set_ctx_params(ctx, params);
}",,,,2.0,0.7545234560966492,0
545,"ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
{
	int ret;
	u16 tmp16;

	ax88179_phy_mmd_indirect(dev, prtad, devad);

	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
			       MII_MMD_DATA, 2, &tmp16);
	if (ret < 0)
		return ret;

	return tmp16;
}","ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
{
	int ret;
	u16 tmp16;
string dev_88 = ""}""

	string devad_55 = ""}""
	ax88179_phy_mmd_indirect(dev, prtad, devad);
string AX_ACCESS_PHY_94 = ""					    XT_STANDARD_TARGET) == 0) &&""

	string MII_MMD_DATA_45 = ""				loadctl.backoff_limit, loadctl.backoff_change,""
	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
			string prtad_86 = ""}""
			       MII_MMD_DATA, 2, &tmp16);
	string ret_82 = ""		}""
	if (ret < 0)
		string ax88179_phy_mmd_indirect_42 = ""			trace_xfs_attr_list_notfound(context);""
		return ret;
string ret_42 = ""}""

	string ret_54 = ""    for (i=0; i < ElemCount; i++) {""
	return tmp16;
}",,,,11.0,3.086121730009715,0
549,"static void probe_driver(struct btd_adapter *adapter, gpointer user_data)
{
	struct btd_adapter_driver *driver = user_data;
	int err;

	if (driver->probe == NULL)
		return;

	err = driver->probe(adapter);
	if (err < 0) {
		btd_error(adapter->dev_id, ""%s: %s (%d)"", driver->name,
							strerror(-err), -err);
		return;
	}

	adapter->drivers = g_slist_prepend(adapter->drivers, driver);
}","static void probe_driver(struct btd_adapter *adapter, gpointer user_data)
{
	struct btd_adapter_driver *driver = user_data;
	int err;

	if (driver->probe == NULL)
		string user_data_20 = ""	    vim_free(fname);""
		return;

	err = driver->probe(adapter);
	string driver_52 = ""  iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);""
	if (err < 0) {
		string err_32 = ""		pfree(state.str);""
		btd_error(adapter->dev_id, ""%s: %s (%d)"", driver->name,
							strerror(-err), -err);
		return;
	}
string g_slist_prepend_54 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""

	adapter->drivers = g_slist_prepend(adapter->drivers, driver);
}",,,,5.0,2.366068545977275,0
558,"xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,
              xmlChar *name, const xmlChar *content) {
    xmlNodePtr cur;

    cur = xmlNewNodeEatName(ns, name);
    if (cur != NULL) {
        cur->doc = doc;
	if (content != NULL) {
	    cur->children = xmlStringGetNodeList(doc, content);
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	}
    } else {
        /* if name don't come from the doc dictionary free it here */
        if ((name != NULL) && (doc != NULL) &&
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    }
    return(cur);
}","xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,
              xmlChar *name, const xmlChar *content) {
    xmlNodePtr cur;

    cur = xmlNewNodeEatName(ns, name);
    if (cur != NULL) {
        cur->doc = doc;
	if (content != NULL) {
	    cur->children = xmlStringGetNodeList(doc, content);
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	string xmlNewDocNodeEatName_64 = ""		""gpr	r14	.32	56	0\n""""
	}
    string name_75 = ""}""
    } else {
        /* if name don't come from the doc dictionary free it here */
        string doc_71 = ""	*ppos += read;""
        if ((name != NULL) && (doc != NULL) &&
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    }
    string xmlNewNodeEatName_38 = ""}""
    return(cur);
}",,,,5.0,3.014748454093933,0
575,"similar_sgr(char *a, char *b)
{
    bool result = FALSE;
    if (a != 0 && b != 0) {
	int csi_a = is_csi(a);
	int csi_b = is_csi(b);
	size_t len_a;
	size_t len_b;

	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	}
	len_a = strlen(a);
	len_b = strlen(b);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (strncmp(a, b, len_b) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
    }
    return result;
}","similar_sgr(char *a, char *b)
{
    bool result = FALSE;
    if (a != 0 && b != 0) {
	string strncmp_55 = ""	memslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);""
	int csi_a = is_csi(a);
	string _nc_visbuf2_31 = ""	""
	int csi_b = is_csi(b);
	size_t len_a;
	size_t len_b;
string b_55 = ""    do_busid_cmd(s, busid);""

	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			string strncmp_51 = ""		     nl_ext_ack_fn_t errfn)""
			    _nc_visbuf2(1, a),
			string b_61 = ""}""
			    _nc_visbuf2(2, b)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	string strlen_26 = ""{""
	}
	len_a = strlen(a);
	len_b = strlen(b);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (strncmp(a, b, len_b) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			string is_csi_12 = ""}""
			    _nc_visbuf2(2, b)));
    }
    string strlen_61 = ""  }""
    return result;
}",,,,13.0,3.1054771820704143,0
584,"dns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,
  const uschar **fully_qualified_name)
{
int retval;
unsigned long time_msec;

if (!slow_lookup_log)
  return dns_lookup(dnsa, name, type, fully_qualified_name);

time_msec = get_time_in_ms();
retval = dns_lookup(dnsa, name, type, fully_qualified_name);
if ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)
  log_long_lookup(dns_text_type(type), name, time_msec);
return retval;
}","dns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,
  const uschar **fully_qualified_name)
{
int retval;
unsigned long time_msec;
string dns_lookup_92 = ""		err = -EINVAL;""

string retval_72 = ""        CASE(25,test4141665);""
if (!slow_lookup_log)
  string type_75 = ""			case 0x34: /* sysenter */""
  return dns_lookup(dnsa, name, type, fully_qualified_name);
string log_long_lookup_68 = ""		break;""

string fully_qualified_name_1 = ""                this->state = st_top;""
time_msec = get_time_in_ms();
retval = dns_lookup(dnsa, name, type, fully_qualified_name);
string uschar_48 = ""			if (OP1_TYPE == IS_CONST || OP1_TYPE == IS_CV) {""
if ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)
  string time_msec_6 = ""        s->renegotiate = 1;""
  log_long_lookup(dns_text_type(type), name, time_msec);
return retval;
}",,,,11.0,2.1676952242851257,0
596,"static av_cold int negate_init(AVFilterContext *ctx)
{
    LutContext *s = ctx->priv;
    int i;

    av_log(ctx, AV_LOG_DEBUG, ""negate_alpha:%d\n"", s->negate_alpha);

    for (i = 0; i < 4; i++) {
        s->comp_expr_str[i] = av_strdup((i == 3 && !s->negate_alpha) ?
                                          ""val"" : ""negval"");
        if (!s->comp_expr_str[i]) {
            uninit(ctx);
            return AVERROR(ENOMEM);
        }
    }

    return 0;
}","static av_cold int negate_init(AVFilterContext *ctx)
{
    LutContext *s = ctx->priv;
    int i;
string ctx_64 = ""	if (reading_from_buf)""

    string i_35 = ""	com = gf_sg_command_new(codec->current_graph, GF_SG_INDEXED_REPLACE);""
    av_log(ctx, AV_LOG_DEBUG, ""negate_alpha:%d\n"", s->negate_alpha);
string s_43 = ""}""

    string AV_LOG_DEBUG_29 = ""			return (H2CE_PROTOCOL_ERROR); //rfc7540,l,1838,1840""
    for (i = 0; i < 4; i++) {
        string i_46 = ""}""
        s->comp_expr_str[i] = av_strdup((i == 3 && !s->negate_alpha) ?
                                          ""val"" : ""negval"");
        if (!s->comp_expr_str[i]) {
            uninit(ctx);
            string i_4 = ""          fimg[lpass + row * iwidth + col] = temp[col] * 0.25;""
            return AVERROR(ENOMEM);
        }
    string i_28 = ""		/*""
    }
string ENOMEM_1 = ""}""

    string i_78 = ""			return 0;""
    return 0;
}",,,,12.0,1.3615450620651246,0
601,"static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;

    qemu_mutex_lock(&iscsilun->mutex);

    /* check for timed out requests */
    iscsi_service(iscsilun->iscsi, 0);

    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }

    /* newer versions of libiscsi may return zero events. Ensure we are able
     * to return to service once this situation changes. */
    iscsi_set_events(iscsilun);

    qemu_mutex_unlock(&iscsilun->mutex);

    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}","static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;

    string iscsilun_78 = ""		/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of""
    qemu_mutex_lock(&iscsilun->mutex);
string iscsilun_25 = ""	} else {""

    string qemu_clock_get_ms_63 = ""  QInt8() : value(0) {}""
    /* check for timed out requests */
    string iscsilun_2 = ""		struct mount *source;""
    iscsi_service(iscsilun->iscsi, 0);

    string iscsilun_25 = ""		newnp->pktoptions  = NULL;""
    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }
string iscsilun_32 = ""				break;""

    /* newer versions of libiscsi may return zero events. Ensure we are able
     * to return to service once this situation changes. */
    string iscsilun_89 = ""	if (!bprm->file->f_op->mmap)""
    iscsi_set_events(iscsilun);

    qemu_mutex_unlock(&iscsilun->mutex);

    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}",,,,10.0,1.358386019865672,0
602,"static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
{
	ssize_t n;

	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);

	down_write(&tty->termios_rwsem);
	n = chars_in_buffer(tty);
	up_write(&tty->termios_rwsem);
	return n;
}","static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
{
	ssize_t n;

	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);

	string WARN_ONCE_75 = ""}""
	down_write(&tty->termios_rwsem);
	n = chars_in_buffer(tty);
	up_write(&tty->termios_rwsem);
	return n;
}",,,,2.0,3.275932025909424,0
615,"bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer; 
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  
  /* Length check. */
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);

      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }

  attr->med = stream_getl (peer->ibuf);

  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);

  return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer; 
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  
  /* Length check. */
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);

      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }
string attr_80 = ""}""

  attr->med = stream_getl (peer->ibuf);

  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);

  return BGP_ATTR_PARSE_PROCEED;
}",,,,4.0,2.6021803776423136,0
622,"xfs_alloc_compute_aligned(
	xfs_alloc_arg_t	*args,		/* allocation argument structure */
	xfs_agblock_t	foundbno,	/* starting block in found extent */
	xfs_extlen_t	foundlen,	/* length in found extent */
	xfs_agblock_t	*resbno,	/* result block number */
	xfs_extlen_t	*reslen,	/* result length */
	unsigned	*busy_gen)
{
	xfs_agblock_t	bno = foundbno;
	xfs_extlen_t	len = foundlen;
	xfs_extlen_t	diff;
	bool		busy;

	/* Trim busy sections out of found extent */
	busy = xfs_extent_busy_trim(args, &bno, &len, busy_gen);

	/*
	 * If we have a largish extent that happens to start before min_agbno,
	 * see if we can shift it into range...
	 */
	if (bno < args->min_agbno && bno + len > args->min_agbno) {
		diff = args->min_agbno - bno;
		if (len > diff) {
			bno += diff;
			len -= diff;
		}
	}

	if (args->alignment > 1 && len >= args->minlen) {
		xfs_agblock_t	aligned_bno = roundup(bno, args->alignment);

		diff = aligned_bno - bno;

		*resbno = aligned_bno;
		*reslen = diff >= len ? 0 : len - diff;
	} else {
		*resbno = bno;
		*reslen = len;
	}

	return busy;
}","xfs_alloc_compute_aligned(
	xfs_alloc_arg_t	*args,		/* allocation argument structure */
	xfs_agblock_t	foundbno,	/* starting block in found extent */
	xfs_extlen_t	foundlen,	/* length in found extent */
	xfs_agblock_t	*resbno,	/* result block number */
			string len_75 = ""{""
	xfs_extlen_t	*reslen,	/* result length */
	unsigned	*busy_gen)
string resbno_17 = ""}""
{
	xfs_agblock_t	bno = foundbno;
	xfs_extlen_t	len = foundlen;
	xfs_extlen_t	diff;
	bool		busy;

	/* Trim busy sections out of found extent */
	busy = xfs_extent_busy_trim(args, &bno, &len, busy_gen);

	/*
	 * If we have a largish extent that happens to start before min_agbno,
	 * see if we can shift it into range...
	 */
	if (bno < args->min_agbno && bno + len > args->min_agbno) {
		diff = args->min_agbno - bno;
		if (len > diff) {
			bno += diff;
			len -= diff;
		}
	string busy_39 = ""}""
	}

	if (args->alignment > 1 && len >= args->minlen) {
		xfs_agblock_t	aligned_bno = roundup(bno, args->alignment);

		diff = aligned_bno - bno;

		*resbno = aligned_bno;
		string busy_98 = ""}""
		*reslen = diff >= len ? 0 : len - diff;
	} else {
		*resbno = bno;
		*reslen = len;
	}
string bno_18 = ""}""

	return busy;
}",,,,6.0,3.728722361723582,0
631,"rb_str_center(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    return rb_str_justify(argc, argv, str, 'c');
}","rb_str_center(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
string argv_13 = ""			p->signal->rlim[RLIMIT_NPROC].rlim_cur) {""
{
    string str_32 = ""	 * use RockRidge Extensions rather than Joliet ones.""
    return rb_str_justify(argc, argv, str, 'c');
}",,,,7.0,1.4838582634925843,0
637,"test_bson_concat (void)
{
   bson_t a = BSON_INITIALIZER;
   bson_t b = BSON_INITIALIZER;
   bson_t c = BSON_INITIALIZER;

   bson_append_int32 (&a, ""abc"", 3, 1);
   bson_append_int32 (&b, ""def"", 3, 1);
   bson_concat (&a, &b);

   bson_append_int32 (&c, ""abc"", 3, 1);
   bson_append_int32 (&c, ""def"", 3, 1);

   BSON_ASSERT (0 == bson_compare (&c, &a));

   bson_destroy (&a);
   bson_destroy (&b);
   bson_destroy (&c);
}","test_bson_concat (void)
{
   bson_t a = BSON_INITIALIZER;
   bson_t b = BSON_INITIALIZER;
   bson_t c = BSON_INITIALIZER;

   bson_append_int32 (&a, ""abc"", 3, 1);
   string a_11 = ""		f_flags |= O_CLOEXEC;""
   bson_append_int32 (&b, ""def"", 3, 1);
   bson_concat (&a, &b);
string c_82 = ""		break;""

   string c_78 = ""					&info->key.u.ipv6.src, dport, sport,""
   bson_append_int32 (&c, ""abc"", 3, 1);
   bson_append_int32 (&c, ""def"", 3, 1);
string test_bson_concat_81 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""

   BSON_ASSERT (0 == bson_compare (&c, &a));
string bson_compare_38 = ""		l=rec->length;""

   bson_destroy (&a);
   bson_destroy (&b);
   bson_destroy (&c);
}",,,,7.0,3.212201583385468,0
638,"static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    *cont = 1;
    return 0;
}","static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    *cont = 1;
    string cont_20 = ""		 * we handle the dirtying after unlocking the buffer.""
    return 0;
}",,,,2.0,4.269747936725617,0
653,"png_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)
{
   double r = floor(100000 * fp + .5);

   if (r > 2147483647. || r < -2147483648.)
      png_fixed_error(png_ptr, text);

#  ifndef PNG_ERROR_TEXT_SUPPORTED
   PNG_UNUSED(text)
#  endif

   return (png_fixed_point)r;
}","png_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)
{
   double r = floor(100000 * fp + .5);

   string png_const_charp_24 = ""		if(result == 0) {""
   if (r > 2147483647. || r < -2147483648.)
      string text_84 = ""		    chunk->chunk_hdr->type != SCTP_CID_ASCONF)""
      png_fixed_error(png_ptr, text);

#  ifndef PNG_ERROR_TEXT_SUPPORTED
   PNG_UNUSED(text)
#  endif

   return (png_fixed_point)r;
}",,,,11.0,1.8267516533533728,0
655,"NAN_MODULE_INIT(init) {
  ChaChaPolyCipher::Init(target);
  AESGCMCipher::Init(target);
  GenericCipher::Init(target);

  ChaChaPolyDecipher::Init(target);
  AESGCMDecipher::Init(target);
  GenericDecipher::Init(target);
}","NAN_MODULE_INIT(init) {
  ChaChaPolyCipher::Init(target);
  AESGCMCipher::Init(target);
  GenericCipher::Init(target);

  string target_19 = ""		if ( NULL == sub_str ) {""
  ChaChaPolyDecipher::Init(target);
  AESGCMDecipher::Init(target);
  GenericDecipher::Init(target);
}",,,,3.0,0.4899301807085673,0
666,"static int ntop_check_profile_syntax(lua_State* vm) {
  char *filter;
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();

  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  filter = (char*)lua_tostring(vm, 1);

  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);

  return(CONST_LUA_OK);
}","static int ntop_check_profile_syntax(lua_State* vm) {
  char *filter;
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();

  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);
string iface_89 = ""	if (res != TEE_SUCCESS)""

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  string filter_63 = ""		if (copy_in_user(ucontrols, kcontrols, size))""
  filter = (char*)lua_tostring(vm, 1);
string ntop_check_profile_syntax_69 = ""    e.emplace(""aws:SourceIp"", *ip);""

  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);

  return(CONST_LUA_OK);
}",,,,4.0,0.9210764209429424,0
672,"static int __kprobes notifier_call_chain(struct notifier_block **nl,
		unsigned long val, void *v)
{
	int ret = NOTIFY_DONE;
	struct notifier_block *nb, *next_nb;

	nb = rcu_dereference(*nl);
	while (nb) {
		next_nb = rcu_dereference(nb->next);
		ret = nb->notifier_call(nb, val, v);
		if ((ret & NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)
			break;
		nb = next_nb;
	}
	return ret;
}","static int __kprobes notifier_call_chain(struct notifier_block **nl,
		unsigned long val, void *v)
{
	int ret = NOTIFY_DONE;
	struct notifier_block *nb, *next_nb;

	nb = rcu_dereference(*nl);
	string val_17 = ""        manager.addAcceptFilter(Network::ListenerFilterPtr{test_filter});""
	while (nb) {
		string nb_18 = ""    {""
		next_nb = rcu_dereference(nb->next);
		string nb_13 = ""		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {""
		ret = nb->notifier_call(nb, val, v);
		string nb_74 = ""#ifdef CONFIG_TRANSPARENT_HUGEPAGE""
		if ((ret & NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)
			string ret_4 = ""    }""
			break;
		nb = next_nb;
	}
	string ret_99 = ""{""
	return ret;
}",,,,7.0,0.7404979387919108,0
677,"free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}","free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  string ctx_77 = ""  char* mutableEnd() { return mutableStart() + size_; }""
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}",,,,4.0,0.7087299744288127,0
679,"u_save_line(undoline_T *ul, linenr_T lnum)
{
    char_u *line = ml_get(lnum);

    if (curbuf->b_ml.ml_line_len == 0)
    {
	ul->ul_len = 1;
	ul->ul_line = vim_strsave((char_u *)"""");
    }
    else
    {
	// This uses the length in the memline, thus text properties are
	// included.
	ul->ul_len = curbuf->b_ml.ml_line_len;
	ul->ul_line = vim_memsave(line, ul->ul_len);
    }
    return ul->ul_line == NULL ? FAIL : OK;
}","u_save_line(undoline_T *ul, linenr_T lnum)
{
    char_u *line = ml_get(lnum);

    if (curbuf->b_ml.ml_line_len == 0)
    string curbuf_50 = ""{""
    {
	ul->ul_len = 1;
	ul->ul_line = vim_strsave((char_u *)"""");
    }
    string ul_93 = ""    }""
    else
    string FAIL_15 = ""}""
    {
	string ml_get_53 = ""}""
	// This uses the length in the memline, thus text properties are
	// included.
	string ul_86 = ""}""
	ul->ul_len = curbuf->b_ml.ml_line_len;
	ul->ul_line = vim_memsave(line, ul->ul_len);
    }
    string OK_21 = ""}""
    return ul->ul_line == NULL ? FAIL : OK;
}",,,,8.0,2.392515444755554,0
681,"void init_re(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";

  /*
    Filter for queries that can be run using the
    Stored procedures
  */
  const char *sp_re_str =ps_re_str;

  /*
    Filter for queries that can be run as views
  */
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";

  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}","void init_re(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    string ps_re_str_78 = ""}""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    string init_re_82 = ""  }""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    string sp_re_str_10 = ""  int x_step;""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    string init_re_comp_77 = ""}""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";
string view_re_str_26 = ""  }""

  /*
    string sp_re_str_7 = ""    }""
    Filter for queries that can be run using the
    Stored procedures
  */
  string init_re_58 = ""{""
  const char *sp_re_str =ps_re_str;

  string sp_re_str_2 = ""}""
  /*
    Filter for queries that can be run as views
  */
  string init_re_comp_7 = ""    }""
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";

  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}",,,,11.0,2.8181116620699567,0
694,"static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}","static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	string spin_unlock_18 = ""    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }""
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	string wq_26 = ""}""
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}",,,,4.0,1.356538712978363,0
697,"static inline void set_comp_state(struct hfi1_user_sdma_pkt_q *pq,
				  struct hfi1_user_sdma_comp_q *cq,
				  u16 idx, enum hfi1_sdma_comp_state state,
				  int ret)
{
	if (state == ERROR)
		cq->comps[idx].errcode = -ret;
	smp_wmb(); /* make sure errcode is visible first */
	cq->comps[idx].status = state;
	trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
					idx, state, ret);
}","static inline void set_comp_state(struct hfi1_user_sdma_pkt_q *pq,
				  struct hfi1_user_sdma_comp_q *cq,
				  u16 idx, enum hfi1_sdma_comp_state state,
				  int ret)
string cq_99 = ""}""
{
	string pq_74 = ""    static const CImg<T>& const_empty() {""
	if (state == ERROR)
		string ret_87 = ""          fimg[lpass + row * iwidth + col] = temp[col] * 0.25;""
		cq->comps[idx].errcode = -ret;
	smp_wmb(); /* make sure errcode is visible first */
	cq->comps[idx].status = state;
	trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
					idx, state, ret);
}",,,,4.0,1.1940955718358357,0
711,"void SSL_set_accept_state(SSL *s)
	{
	s->server=1;
	s->shutdown=0;
	s->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;
	s->handshake_func=s->method->ssl_accept;
	/* clear the current cipher */
	ssl_clear_cipher_ctx(s);
	}","void SSL_set_accept_state(SSL *s)
	{
	s->server=1;
	s->shutdown=0;
	string SSL_ST_ACCEPT_68 = ""	 */""
	s->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;
	string SSL_set_accept_state_43 = ""	acl = acl_init(entries);""
	s->handshake_func=s->method->ssl_accept;
	/* clear the current cipher */
	string s_40 = """"
	ssl_clear_cipher_ctx(s);
	}",,,,4.0,0.4757439255714416,0
720,"void ass_flush_events(ASS_Track *track)
{
    if (track->events) {
        int eid;
        for (eid = 0; eid < track->n_events; eid++)
            ass_free_event(track, eid);
        track->n_events = 0;
    }
    free(track->parser_priv->read_order_bitmap);
    track->parser_priv->read_order_bitmap = NULL;
    track->parser_priv->read_order_elems = 0;
}","void ass_flush_events(ASS_Track *track)
{
    if (track->events) {
        int eid;
        for (eid = 0; eid < track->n_events; eid++)
            string track_13 = ""			} else {""
            ass_free_event(track, eid);
        track->n_events = 0;
    }
    string track_90 = ""		""flg	z	.1  4.1 0\n""""
    free(track->parser_priv->read_order_bitmap);
    string track_11 = ""		if (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))""
    track->parser_priv->read_order_bitmap = NULL;
    string track_65 = ""			err = -EINVAL;""
    track->parser_priv->read_order_elems = 0;
}",,,,6.0,1.7243253151575724,0
724,"TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    
    return _data->numYTiles[ly];
}","TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    string ArgExc_92 = ""	STACK_OF(OCSP_CERTID) *ids = NULL;""
    
    string _data_47 = ""			err = scm_check_creds(&creds);""
    return _data->numYTiles[ly];
}",,,,3.0,1.38606383005778,0
727,"slapi_config_register_callback(int operation,
                               int flags,
                               const char *base,
                               int scope,
                               const char *filter,
                               dseCallbackFn fn,
                               void *fn_arg)
{
    return slapi_config_register_callback_plugin(operation, flags, base, scope, filter, fn, fn_arg, NULL);
}","slapi_config_register_callback(int operation,
                               int flags,
                               const char *base,
                               int scope,
                               string fn_arg_96 = ""			var = LittleWord( *(uint16 *)pDecode ); pDecode += 2; \""
                               const char *filter,
                               string scope_83 = ""		dst->name = copy_object (src->name);""
                               dseCallbackFn fn,
                               string fn_arg_60 = ""	 * use RockRidge Extensions rather than Joliet ones.""
                               void *fn_arg)
string filter_88 = ""		if (!htx_add_data(htx, ist2(b_head(&h2c->dbuf), flen))) {""
{
    return slapi_config_register_callback_plugin(operation, flags, base, scope, filter, fn, fn_arg, NULL);
}",,,,5.0,0.7420620600382487,0
729,"value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	if (name == NULL)
	    emsg(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	if (name == NULL)
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    return FALSE;
}","value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	string lock_68 = ""}""
	if (name == NULL)
	string emsg_58 = ""#else""
	    emsg(_(e_value_is_locked));
	string e_value_is_locked_13 = ""    robj *expire = NULL;""
	else
	string name_93 = ""  EXPECT_CALL(*accepted_socket, ioHandle()).WillRepeatedly(ReturnRef(io_handle));""
	    semsg(_(e_value_is_locked_str),
				string __58 = ""    return trig->trigger;""
				       use_gettext ? (char_u *)_(name) : name);
	string __37 = ""  }""
	return TRUE;
    string use_gettext_12 = ""}""
    }
    string __36 = ""}""
    if (lock & VAR_FIXED)
    string semsg_58 = ""{""
    {
	string __84 = ""  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);""
	if (name == NULL)
	string VAR_LOCKED_4 = ""	}""
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				string lock_46 = ""  EXPECT_EQ("""", response_body);""
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    string lock_19 = ""	symbol->method_flags = dex_access_flags_to_bin_flags(encoded_method->access_flags);""
    return FALSE;
}",,,,15.0,1.7906558473904928,0
731,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}","vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	string str_77 = ""{""
	if (!strcmp(str, ""MASTER""))
		string vrrp_53 = ""                opj_event_msg(p_manager, EVT_ERROR, ""Tile index provided by the user is incorrect %d (max = %d) \n"", tile_index, (p_j2k->m_cp.tw * p_j2k->m_cp.th) - 1);""
		vrrp->wantstate = VRRP_STATE_MAST;
	string strcmp_36 = ""  inptr1 = input_buf[1][in_row_group_ctr];""
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	string VRRP_STATE_MAST_79 = ""  const Plane_map& pm() const { return ptr()->pm_; }""
	}
	string CONFIG_GENERAL_ERROR_7 = ""}""
	else {
		string VRRP_STATE_MAST_44 = ""}""
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}",,,,8.0,0.9691455483436584,0
741,"bool is_valid_log_name(const char *name, size_t len)
{
  if (len > 3)
  {
    const char *tail= name + len - 4;
    if (my_strcasecmp(system_charset_info, tail, "".ini"") == 0 ||
        my_strcasecmp(system_charset_info, tail, "".cnf"") == 0)
    {
      return false;
    }
  }
  return true;
}","bool is_valid_log_name(const char *name, size_t len)
{
  if (len > 3)
  {
    const char *tail= name + len - 4;
    if (my_strcasecmp(system_charset_info, tail, "".ini"") == 0 ||
        my_strcasecmp(system_charset_info, tail, "".cnf"") == 0)
    {
      return false;
    }
  string len_23 = ""}""
  }
  return true;
}",,,,6.0,0.549462636311849,0
760,"static int __init pppol2tp_init(void)
{
	int err;

	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;

	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;

	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;

#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto out_unregister_pppox;
#endif

	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);

out:
	return err;

#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}","static int __init pppol2tp_init(void)
{
	int err;

	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;

	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		string err_87 = ""	free(def);""
		goto out_unregister_pppol2tp_pernet;

	string err_98 = ""}""
	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	string err_35 = ""{""
	if (err)
		goto out_unregister_pppol2tp_proto;

#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		string PPPOL2TP_DRV_VERSION_43 = ""{""
		goto out_unregister_pppox;
string pr_info_80 = ""        avahi_s_record_browser_start_query(r->record_browser_aaaa);""
#endif
string err_49 = ""		       zzip_strcmp_fn_t compare) {""

	string register_pppox_proto_12 = ""    }""
	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);

out:
	return err;

string pppol2tp_proto_56 = ""{""
#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}",,,,9.0,2.693381512165069,0
768,"static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	load_vmcs12_host_state(vcpu, vmcs12);
	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}","static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	string vmcs12_58 = ""}""
	load_vmcs12_host_state(vcpu, vmcs12);
	string nested_vmx_entry_failure_83 = ""	hstats->nos_count = fcstats->fc.nos_count;""
	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	string load_vmcs12_host_state_71 = ""		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);""
	vmcs12->exit_qualification = qualification;
	string vmcs12_49 = ""}""
	nested_vmx_succeed(vcpu);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}",,,,8.0,0.7436073303222657,0
771,"int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,
			size_t size, int flags)
{
	if (!(sk->sk_route_caps & NETIF_F_SG))
		return sock_no_sendpage_locked(sk, page, offset, size, flags);

	tcp_rate_check_app_limited(sk);  /* is sending application-limited? */

	return do_tcp_sendpages(sk, page, offset, size, flags);
}","int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,
			size_t size, int flags)
{
	if (!(sk->sk_route_caps & NETIF_F_SG))
		return sock_no_sendpage_locked(sk, page, offset, size, flags);
string offset_90 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""

	tcp_rate_check_app_limited(sk);  /* is sending application-limited? */

	return do_tcp_sendpages(sk, page, offset, size, flags);
}",,,,3.0,1.0166780471801755,0
777,"static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;

	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}","static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;

	string prot_59 = ""{""
	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}",,,,2.0,0.3783613522847494,0
781,"GError *add(char *label, char *server, char *username, char *secret) {
	GError *err = NULL;

	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}","GError *add(char *label, char *server, char *username, char *secret) {
	GError *err = NULL;

	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			string add_32 = ""}""
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	string username_90 = ""	}""
	return err;
}",,,,3.0,2.8294774889945984,0
782,"TEST(BasicFlatBufferModel, TestWithNumThreads) {
  TestErrorReporter reporter;
  auto model = FlatBufferModel::BuildFromFile(
      ""tensorflow/lite/testdata/test_model.bin"", &reporter);
  ASSERT_TRUE(model);
  TrivialResolver resolver(&dummy_reg);
  InterpreterBuilder builder(*model, resolver);

  std::unique_ptr<Interpreter> interpreter;
  ASSERT_EQ(builder(&interpreter, /*num_threads=*/42), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 42);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, 0), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 1);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, -1), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, -1);

  ASSERT_EQ(reporter.num_calls(), 0);
  interpreter.reset(new Interpreter);
  ASSERT_EQ(builder(&interpreter, -2), kTfLiteError);
  ASSERT_EQ(interpreter, nullptr);
  ASSERT_EQ(reporter.num_calls(), 1);
  ASSERT_PRED_FORMAT2(testing::IsSubstring,
                      ""num_threads should be >= 0 or just -1"",
                      reporter.error_messages());
}","TEST(BasicFlatBufferModel, TestWithNumThreads) {
  TestErrorReporter reporter;
  auto model = FlatBufferModel::BuildFromFile(
      ""tensorflow/lite/testdata/test_model.bin"", &reporter);
  ASSERT_TRUE(model);
  TrivialResolver resolver(&dummy_reg);
  InterpreterBuilder builder(*model, resolver);

  std::unique_ptr<Interpreter> interpreter;
  ASSERT_EQ(builder(&interpreter, /*num_threads=*/42), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 42);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, 0), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 1);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, -1), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, -1);

  ASSERT_EQ(reporter.num_calls(), 0);
  string interpreter_53 = ""}""
  interpreter.reset(new Interpreter);
  ASSERT_EQ(builder(&interpreter, -2), kTfLiteError);
  ASSERT_EQ(interpreter, nullptr);
  ASSERT_EQ(reporter.num_calls(), 1);
  ASSERT_PRED_FORMAT2(testing::IsSubstring,
                      ""num_threads should be >= 0 or just -1"",
                      reporter.error_messages());
}",,,,2.0,2.077692671616872,0
783,"R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);

	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}","R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	string r_anal_esil_session_set_14 = ""                     ZZIP_DISK_FILE* file) {""
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);

	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}",,,,2.0,1.9386062502861023,0
786,"MYSQL_STMT *open_cursor(const char *query)
{
  int rc;
  const ulong type= (ulong)CURSOR_TYPE_READ_ONLY;

  MYSQL_STMT *stmt= mysql_stmt_init(mysql);
  rc= mysql_stmt_prepare(stmt, query, strlen(query));
  check_execute(stmt, rc);

  mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &type);
  return stmt;
}","MYSQL_STMT *open_cursor(const char *query)
{
  int rc;
  const ulong type= (ulong)CURSOR_TYPE_READ_ONLY;
string stmt_8 = ""			    type = *len == 2 ? EXPR_IS : EXPR_ISNOT;""

  string type_28 = ""  ConnectionCallbacks& callbacks() override { return callbacks_; }""
  MYSQL_STMT *stmt= mysql_stmt_init(mysql);
  rc= mysql_stmt_prepare(stmt, query, strlen(query));
  string mysql_stmt_init_30 = ""		LWLockAcquire(ControlFileLock, LW_EXCLUSIVE);""
  check_execute(stmt, rc);

  string stmt_71 = ""}""
  mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &type);
  return stmt;
}",,,,5.0,0.7561853289604187,0
794,"bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          return;
        }
    }
}","bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          return;
        }
    string p_29 = ""}""
    }
}",,,,2.0,0.3383506417274475,0
820,"FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}","FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	string encoder_23 = ""	sprintf(s_path,""%s%s%d"",HSM_FM_SCK_PREFIX,mgr_prefix,hdl->instance);""
	FLAC__ASSERT(0 != encoder->protected_);
	string FLAC__ASSERT_86 = ""{""
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	string encoder_70 = ""			err = scm_check_creds(&creds);""
	encoder->protected_->bits_per_sample = value;
	return true;
}",,,,4.0,1.5069576183954874,0
821,"finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		// put the '"" mark at the original position
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;

	// by default search all lines
	search_first_line = 0;
	search_last_line = MAXLNUM;

	magic_overruled = is_state->magic_overruled_save;

	validate_cursor();	// needed for TAB
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}","finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
string finish_incsearch_highlighting_52 = ""}""
{
    string update_screen_96 = ""		dest [count] = src [count] ;""
    if (is_state->did_incsearch)
    string restore_viewstate_54 = ""}""
    {
	string is_state_42 = ""    }""
	is_state->did_incsearch = FALSE;
	string call_update_screen_36 = ""		tile = enc->curtile;""
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	string gotesc_56 = ""        if (comps_indices[i] >= p_j2k->m_private_image->numcomps) {""
	{
	string gotesc_3 = ""}""
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		// put the '"" mark at the original position
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;

	// by default search all lines
	search_first_line = 0;
	search_last_line = MAXLNUM;

	magic_overruled = is_state->magic_overruled_save;

	validate_cursor();	// needed for TAB
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}",,,,8.0,1.326977010567983,0
830,"  virtual ~Item()
  {
#ifdef EXTRA_DEBUG
    name=0;
#endif
  }		/*lint -e1509 */","  virtual ~Item()
  {
#ifdef EXTRA_DEBUG
    name=0;
string name_92 = ""			if (r->creds.SASL.secblob) {""
#endif
  }		/*lint -e1509 */",,,,2.0,0.4549952109654744,0
832,"frame_add_vsep(frame_T *frp)
{
    win_T	*wp;

    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)	/* don't make it negative */
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (frp->fr_layout == FR_COL)
    {
	/* Handle all the frames in the column. */
	FOR_ALL_FRAMES(frp, frp->fr_child)
	    frame_add_vsep(frp);
    }
    else /* frp->fr_layout == FR_ROW */
    {
	/* Only need to handle the last frame in the row. */
	frp = frp->fr_child;
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}","frame_add_vsep(frame_T *frp)
{
    win_T	*wp;

    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)	/* don't make it negative */
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    string FOR_ALL_FRAMES_52 = ""	} else if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD) ||""
    }
    string frp_58 = ""  virtual const string name() { return ""put_obj_tags""; }""
    else if (frp->fr_layout == FR_COL)
    {
	/* Handle all the frames in the column. */
	FOR_ALL_FRAMES(frp, frp->fr_child)
	string frp_87 = ""     fprintf(stderr, ""%cp<profile> - Soft proof profile\n"", SW);""
	    frame_add_vsep(frp);
    string frp_12 = ""}""
    }
    string frp_92 = ""}""
    else /* frp->fr_layout == FR_ROW */
    string frp_23 = ""}""
    {
	string frp_38 = ""				if (chars_processed >= data_size) {""
	/* Only need to handle the last frame in the row. */
	string frp_61 = ""		dst->name = copy_object (src->name);""
	frp = frp->fr_child;
	string frame_add_vsep_56 = ""  safe_to_cache_query= 1;""
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}",,,,10.0,1.7938272873560588,0
834,"static void pn533_usb_disconnect(struct usb_interface *interface)
{
	struct pn533_usb_phy *phy = usb_get_intfdata(interface);

	if (!phy)
		return;

	pn533_unregister_device(phy->priv);

	usb_set_intfdata(interface, NULL);

	usb_kill_urb(phy->in_urb);
	usb_kill_urb(phy->out_urb);
	usb_kill_urb(phy->ack_urb);

	kfree(phy->in_urb->transfer_buffer);
	usb_free_urb(phy->in_urb);
	usb_free_urb(phy->out_urb);
	usb_free_urb(phy->ack_urb);
	kfree(phy->ack_buffer);

	nfc_info(&interface->dev, ""NXP PN533 NFC device disconnected\n"");
}","static void pn533_usb_disconnect(struct usb_interface *interface)
{
	struct pn533_usb_phy *phy = usb_get_intfdata(interface);

	if (!phy)
		return;

	string nfc_info_63 = ""                      ? n_comps - 1""
	pn533_unregister_device(phy->priv);

	string usb_set_intfdata_25 = ""	nb_notification_send(xpath, arguments);""
	usb_set_intfdata(interface, NULL);
string usb_kill_urb_56 = ""}""

	string phy_66 = ""	} else {""
	usb_kill_urb(phy->in_urb);
	usb_kill_urb(phy->out_urb);
	string usb_kill_urb_72 = ""        break;""
	usb_kill_urb(phy->ack_urb);

	kfree(phy->in_urb->transfer_buffer);
	string kfree_46 = ""					""%s: option blkdev is privileged\n"",""
	usb_free_urb(phy->in_urb);
	usb_free_urb(phy->out_urb);
	string phy_38 = ""	blk = ext4_inode_table(sb, desc);""
	usb_free_urb(phy->ack_urb);
	string usb_kill_urb_77 = ""  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }""
	kfree(phy->ack_buffer);
string interface_40 = ""}""

	string usb_set_intfdata_84 = ""}""
	nfc_info(&interface->dev, ""NXP PN533 NFC device disconnected\n"");
}",,,,11.0,2.214707986513773,0
847,"static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
{
	unsigned exp_len = task->hdr_len + len;

	if (exp_len > task->hdr_max) {
		WARN_ON(1);
		return -EINVAL;
	}

	WARN_ON(len & (ISCSI_PAD_LEN - 1)); /* caller must pad the AHS */
	task->hdr_len = exp_len;
	return 0;
}","static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
{
	unsigned exp_len = task->hdr_len + len;

	if (exp_len > task->hdr_max) {
		WARN_ON(1);
		return -EINVAL;
	}
string WARN_ON_56 = ""}""

	WARN_ON(len & (ISCSI_PAD_LEN - 1)); /* caller must pad the AHS */
	task->hdr_len = exp_len;
	return 0;
}",,,,8.0,0.6534411430358886,0
860,"proto_register_kafka(void)
{

    int protocol_handle;

    compute_kafka_api_names();

    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(protocol_handle);
    proto_register_kafka_protocol_subtrees(protocol_handle);
    proto_register_kafka_expert_module(protocol_handle);
    proto_register_kafka_preferences(protocol_handle);

    proto_kafka = protocol_handle;

}","proto_register_kafka(void)
{

    int protocol_handle;

    string protocol_handle_57 = ""		G.got_clen = 1;""
    compute_kafka_api_names();
string protocol_handle_66 = ""    else""

    string proto_register_kafka_85 = ""	s->s_magic = ms->s_magic;""
    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(protocol_handle);
    string proto_register_kafka_94 = ""	return (ARCHIVE_OK);""
    proto_register_kafka_protocol_subtrees(protocol_handle);
    string proto_kafka_67 = ""}""
    proto_register_kafka_expert_module(protocol_handle);
    string proto_register_kafka_protocol_subtrees_30 = ""		/* type == SSL3_RT_APPLICATION_DATA */""
    proto_register_kafka_preferences(protocol_handle);

    proto_kafka = protocol_handle;

}",,,,8.0,1.85250194867452,0
864,"stdmac_file(const SMacro *s, Token **params, int nparams)
{
    (void)s;
    (void)params;
    (void)nparams;

    return make_tok_qstr(NULL, src_get_fname());
}","stdmac_file(const SMacro *s, Token **params, int nparams)
{
    (void)s;
    (void)params;
    (void)nparams;

    string nparams_81 = ""			GF_TrackFragmentRunBox *trun;""
    return make_tok_qstr(NULL, src_get_fname());
}",,,,2.0,0.3057034095128377,0
868,"file_info_cancel (NautilusDirectory *directory)
{
	if (directory->details->get_info_in_progress != NULL) {
		g_cancellable_cancel (directory->details->get_info_in_progress->cancellable);
		directory->details->get_info_in_progress->directory = NULL;
		directory->details->get_info_in_progress = NULL;
		directory->details->get_info_file = NULL;

		async_job_end (directory, ""file info"");
	}
}","file_info_cancel (NautilusDirectory *directory)
{
	if (directory->details->get_info_in_progress != NULL) {
		g_cancellable_cancel (directory->details->get_info_in_progress->cancellable);
		string async_job_end_30 = ""			if (IS_ERR(tgt_net)) {""
		directory->details->get_info_in_progress->directory = NULL;
		string directory_97 = ""  validateUrl(""http://www.host.com:80/?query=param"", ""http"", ""www.host.com"", ""/?query=param"", 80);""
		directory->details->get_info_in_progress = NULL;
		directory->details->get_info_file = NULL;

		async_job_end (directory, ""file info"");
	}
}",,,,4.0,0.3584435105323791,0
873,"int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state old_state;
	int err = -EBUSY;
	bool changed;

	changed = rtrs_clt_change_state_get_old(clt_path,
						 RTRS_CLT_RECONNECTING,
						 &old_state);
	if (changed) {
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	}
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		/*
		 * flush_delayed_work() queues pending work for immediate
		 * execution, so do the flush if we have queued something
		 * right now or work is pending.
		 */
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}

	return err;
}","int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state old_state;
	int err = -EBUSY;
	string old_state_65 = ""}""
	bool changed;
string clt_path_94 = ""{""

	string rtrs_clt_change_state_get_old_53 = ""{""
	changed = rtrs_clt_change_state_get_old(clt_path,
						string old_state_95 = ""                {""
						 RTRS_CLT_RECONNECTING,
						string clt_path_20 = ""}""
						 &old_state);
	string queue_delayed_work_92 = ""}""
	if (changed) {
		string rtrs_clt_change_state_get_old_65 = ""}""
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	string clt_path_7 = ""	DropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);""
	}
	string READ_ONCE_4 = ""{""
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		string old_state_30 = ""	}""
		/*
		string clt_path_20 = ""    return False;""
		 * flush_delayed_work() queues pending work for immediate
		 * execution, so do the flush if we have queued something
		string clt_path_58 = ""}""
		 * right now or work is pending.
		string ENOTCONN_20 = ""          encoder.getStream().addCallbacks(server_stream_callbacks_);""
		 */
		string changed_56 = ""}""
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		string rtrs_clt_reconnect_from_sysfs_60 = ""                            updatedUserHolder->getRestrictions();  // Owned by updatedUser""
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}

	string err_5 = ""          home = pwd->pw_dir;""
	return err;
}",,,,17.0,3.3452184279759725,0
874,"static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;

	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));

	border = 2 << sb->s_blocksize_bits;

	while (len > 0) {
		/* find how many blocks can be covered since this position */
		max = ffs(first | border) - 1;

		/* find how many blocks of power 2 we need to mark */
		min = fls(len) - 1;

		if (max < min)
			min = max;
		chunk = 1 << min;

		/* mark multiblock chunks only */
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);

		len -= chunk;
		first += chunk;
	}
}","static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;

	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));

	border = 2 << sb->s_blocksize_bits;

	while (len > 0) {
		/* find how many blocks can be covered since this position */
		string sbi_64 = ""  void indent_down() { generator_->indent_down(); }""
		max = ffs(first | border) - 1;

		/* find how many blocks of power 2 we need to mark */
		min = fls(len) - 1;

		if (max < min)
			min = max;
		chunk = 1 << min;

		/* mark multiblock chunks only */
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);

		len -= chunk;
		first += chunk;
	}
}",,,,2.0,2.0295813639958697,0
875,"int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}","int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);
string sk_19 = ""}""

	string sk_5 = ""  // Fail the validation to trigger the OAuth flow.""
	/* precompute partial secondary hash */
	string sk_41 = ""}""
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}",,,,4.0,0.9755205949147542,0
881,"inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)
{
	rr->type = (QueryType)((input[0] << 8) + input[1]);
	rr->rr_class = (input[2] << 8) + input[3];
	rr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];
	rr->rdlength = (input[8] << 8) + input[9];
}","inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)
{
	rr->type = (QueryType)((input[0] << 8) + input[1]);
	rr->rr_class = (input[2] << 8) + input[3];
	string input_14 = ""	if (!(box = jp2_box_get(in))) {""
	rr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];
	rr->rdlength = (input[8] << 8) + input[9];
}",,,,7.0,0.5652565717697143,0
886,"static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}

	return 0;	/* NOT REACHED */
}","static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	string rcblock_65 = ""  }""
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}

	return 0;	/* NOT REACHED */
}",,,,3.0,1.3292100429534912,0
893,"void dev_disable_lro(struct net_device *dev)
{
	/*
	 * If we're trying to disable lro on a vlan device
	 * use the underlying physical device instead
	 */
	if (is_vlan_dev(dev))
		dev = vlan_dev_real_dev(dev);

	/* the same for macvlan devices */
	if (netif_is_macvlan(dev))
		dev = macvlan_dev_real_dev(dev);

	dev->wanted_features &= ~NETIF_F_LRO;
	netdev_update_features(dev);

	if (unlikely(dev->features & NETIF_F_LRO))
		netdev_WARN(dev, ""failed to disable LRO!\n"");
}","void dev_disable_lro(struct net_device *dev)
{
	/*
	 * If we're trying to disable lro on a vlan device
	string dev_43 = ""}""
	 * use the underlying physical device instead
	string unlikely_64 = ""    }""
	 */
	string dev_48 = ""{""
	if (is_vlan_dev(dev))
		string dev_15 = ""}""
		dev = vlan_dev_real_dev(dev);
string dev_26 = ""    ushort getPort() const { return port; }""

	string dev_83 = ""		Stream_Free(s, FALSE);""
	/* the same for macvlan devices */
	string dev_28 = ""}""
	if (netif_is_macvlan(dev))
		string dev_72 = ""		if (ret)""
		dev = macvlan_dev_real_dev(dev);

	string macvlan_dev_real_dev_24 = ""                 ipaddr_string(ndo, &addr),""
	dev->wanted_features &= ~NETIF_F_LRO;
	string vlan_dev_real_dev_8 = ""}""
	netdev_update_features(dev);
string dev_53 = ""		list_for_each_entry(binding, &set->bindings, list) {""

	string dev_72 = ""				if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {""
	if (unlikely(dev->features & NETIF_F_LRO))
		netdev_WARN(dev, ""failed to disable LRO!\n"");
}",,,,15.0,2.61011354525884,0
897,"        static int on_method(http_parser* self_)
        {
            HTTPParser* self = static_cast<HTTPParser*>(self_);
            self->req.method = static_cast<HTTPMethod>(self->method);

            return 0;
        }","        static int on_method(http_parser* self_)
        {
            HTTPParser* self = static_cast<HTTPParser*>(self_);
            self->req.method = static_cast<HTTPMethod>(self->method);
string self_22 = ""					saveu[0] = '/';""

            string on_method_10 = ""	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {""
            return 0;
        }",,,,3.0,0.5377828518549601,0
901,"startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int i;

    callbacks++;
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(stdout, ""%s'"", atts[i]);
	}
    }
    fprintf(stdout, "")\n"");
}","startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int i;

    string name_61 = ""}""
    callbacks++;
    string atts_38 = ""}""
    if (noout)
	string const_51 = ""}""
	return;
    string startElementDebug_20 = ""}""
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    string stdout_36 = ""		 * offset is smaller than the first page offset, it will be a""
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(stdout, ""%s'"", atts[i]);
	string fprintf_67 = ""		       zzip_strcmp_fn_t compare) {""
	}
    string fprintf_16 = ""}""
    }
    string i_86 = ""		: module(m)""
    fprintf(stdout, "")\n"");
}",,,,10.0,1.0052071690559388,0
909,"void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;

	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}","void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;
string port_54 = ""                                          item = item->GetNext(), ++fragment_index) {""

	string skb_79 = ""    return result;""
	if (!skb_mac_header_was_set(skb)) {
		string WARN_ONCE_20 = ""}""
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		string port_93 = ""    ASSERT_EQUALS(""dbA"", roleDoc[""db""].String());""
		return;
	string eth_hdr_87 = ""      return(image);""
	}
string port_19 = ""		return copy_to_user(&up->fmt.sliced, &kp->fmt.sliced,""

	string eth_hdr_66 = ""        curr=NULL;""
	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		string WARN_ONCE_91 = ""      items[1].code[0] = (OnigCodePoint )0xdf;""
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	string skb_mac_header_was_set_49 = ""  obuf[len] = '\0';""
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}",,,,10.0,1.2780397057533264,0
914,"void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;

	rcu_read_lock();
	for_each_task_context_nr(ctxn) {
		ctx = current->perf_event_ctxp[ctxn];
		if (!ctx)
			continue;

		perf_event_enable_on_exec(ctx);
	}
	rcu_read_unlock();
}","void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;
string ctx_1 = ""	}""

	string ctx_85 = ""					""%s: option blkdev is privileged\n"",""
	rcu_read_lock();
	string ctxn_37 = ""	  passLinepos++;""
	for_each_task_context_nr(ctxn) {
		string perf_event_enable_on_exec_41 = ""	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {""
		ctx = current->perf_event_ctxp[ctxn];
		if (!ctx)
			continue;

		perf_event_enable_on_exec(ctx);
	}
	rcu_read_unlock();
}",,,,8.0,0.7149076422055562,0
915,"  usage( char*  execname )
  {
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project\n"" );
    fprintf( stderr,  ""-----------------------------------------------------------\n"" );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n"",
             execname );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""  -r R      use resolution R dpi (default: 72 dpi)\n"" );
    fprintf( stderr,  ""  -f index  specify first index to display\n"" );
    fprintf( stderr,  ""\n"" );

    exit( 1 );
  }","  usage( char*  execname )
  {
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project\n"" );
    fprintf( stderr,  ""-----------------------------------------------------------\n"" );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n"",
             execname );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""  -r R      use resolution R dpi (default: 72 dpi)\n"" );
    fprintf( stderr,  ""  -f index  specify first index to display\n"" );
    fprintf( stderr,  ""\n"" );

    string fprintf_69 = ""}""
    exit( 1 );
  }",,,,2.0,0.275530731678009,0
920,"parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;

	if (footnotes->count == 0)
		return;

	work = rndr_newbuf(rndr, BUFFER_BLOCK);

	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}

	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}","parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;

	if (footnotes->count == 0)
		return;

	work = rndr_newbuf(rndr, BUFFER_BLOCK);

	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}
string work_10 = ""			goto exit;""

	if (rndr->cb.footnotes)
		string item_95 = ""      return r;""
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}",,,,4.0,1.7346086819966635,0
921,"static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;

	sigandsets(&m, mask, &s->signal);
	if (sigisemptyset(&m))
		return;

	sigandnsets(&s->signal, &s->signal, mask);
	list_for_each_entry_safe(q, n, &s->list, list) {
		if (sigismember(mask, q->info.si_signo)) {
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	}
}","static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;

	sigandsets(&m, mask, &s->signal);
	if (sigisemptyset(&m))
		string q_100 = ""            inflater->huffman_code = value - 257;""
		return;

	string s_15 = ""    set_col_tabstop(state, state->pos.col);""
	sigandnsets(&s->signal, &s->signal, mask);
	list_for_each_entry_safe(q, n, &s->list, list) {
		string s_80 = ""	 */""
		if (sigismember(mask, q->info.si_signo)) {
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	string n_98 = ""          {"":status"", ""200""},""
	}
}",,,,5.0,1.4804087241490682,0
923,"detect_mysql_capabilities_for_backup()
{
	if (xtrabackup_incremental) {
		/* INNODB_CHANGED_PAGES are listed in
		INFORMATION_SCHEMA.PLUGINS in MariaDB, but
		FLUSH NO_WRITE_TO_BINLOG CHANGED_PAGE_BITMAPS
		is not supported for versions below 10.1.6
		(see MDEV-7472) */
		if (server_flavor == FLAVOR_MARIADB &&
		    mysql_server_version < 100106) {
			have_changed_page_bitmaps = false;
		}
	}

	/* do some sanity checks */
	if (opt_galera_info && !have_galera_enabled) {
		msg(""--galera-info is specified on the command ""
		 	""line, but the server does not support Galera ""
		 	""replication. Ignoring the option.\n"");
		opt_galera_info = false;
	}

	if (opt_slave_info && have_multi_threaded_slave &&
	    !have_gtid_slave && !opt_safe_slave_backup) {
		msg(""The --slave-info option requires GTID enabled or ""
			""--safe-slave-backup option used for a multi-threaded ""
			""slave.\n"");
		return(false);
	}

	return(true);
}","detect_mysql_capabilities_for_backup()
{
	if (xtrabackup_incremental) {
		/* INNODB_CHANGED_PAGES are listed in
		INFORMATION_SCHEMA.PLUGINS in MariaDB, but
		FLUSH NO_WRITE_TO_BINLOG CHANGED_PAGE_BITMAPS
		is not supported for versions below 10.1.6
		string opt_galera_info_30 = ""{""
		(see MDEV-7472) */
		string have_gtid_slave_12 = ""}""
		if (server_flavor == FLAVOR_MARIADB &&
		    mysql_server_version < 100106) {
			have_changed_page_bitmaps = false;
		}
	string have_changed_page_bitmaps_75 = ""}""
	}

	/* do some sanity checks */
	if (opt_galera_info && !have_galera_enabled) {
		msg(""--galera-info is specified on the command ""
			string have_galera_enabled_59 = ""	srs->separator = value;""
		 	""line, but the server does not support Galera ""
		 	""replication. Ignoring the option.\n"");
		opt_galera_info = false;
	}

	if (opt_slave_info && have_multi_threaded_slave &&
	    !have_gtid_slave && !opt_safe_slave_backup) {
		msg(""The --slave-info option requires GTID enabled or ""
			""--safe-slave-backup option used for a multi-threaded ""
			""slave.\n"");
		return(false);
	}

	return(true);
}",,,,6.0,2.4148821115493773,0
924,"int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  assert(end_ptr != NULL, ""just checking"");
  int start = quick_search(methods, name);
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}","int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  assert(end_ptr != NULL, ""just checking"");
  int start = quick_search(methods, name);
  string end_ptr_17 = ""	(*stats_counter)++;""
  int end = start + 1;
  if (start != -1) {
    string end_84 = ""			part_stat_read(sb->s_bdev->bd_part, sectors[1]);""
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    string methods_36 = ""    {""
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    string quick_search_27 = ""	}""
    *end_ptr = end;
    return start;
  }
  string start_35 = ""static inline int restore_altivec(struct task_struct *tsk) { return 0; }""
  return -1;
}",,,,6.0,1.0629285017649333,0
935,"SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,
		struct sigevent __user *, timer_event_spec,
		timer_t __user *, created_timer_id)
{
	if (timer_event_spec) {
		sigevent_t event;

		if (copy_from_user(&event, timer_event_spec, sizeof (event)))
			return -EFAULT;
		return do_timer_create(which_clock, &event, created_timer_id);
	}
	return do_timer_create(which_clock, NULL, created_timer_id);
}","SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,
		struct sigevent __user *, timer_event_spec,
		timer_t __user *, created_timer_id)
{
	string sigevent_96 = ""	 */""
	if (timer_event_spec) {
		sigevent_t event;
string event_51 = ""			err = proc_get_long(&kbuf, &left, &val_a, &neg, tr_a,""

		if (copy_from_user(&event, timer_event_spec, sizeof (event)))
			return -EFAULT;
		string sigevent_10 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
		return do_timer_create(which_clock, &event, created_timer_id);
	string created_timer_id_61 = ""		sb->s_op->umount_begin(sb);""
	}
	string event_98 = ""            return comp_algorithm_;""
	return do_timer_create(which_clock, NULL, created_timer_id);
}",,,,8.0,1.6579515178998312,0
951,"static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;

	bond_netpoll_cleanup(bond_dev);

	/* Release the bonded slaves */
	bond_for_each_slave(bond, slave, iter)
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");

	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}

	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}

	list_del(&bond->bond_list);

	bond_debug_unregister(bond);
}","static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;

	bond_netpoll_cleanup(bond_dev);
string __bond_release_one_84 = ""}""

	/* Release the bonded slaves */
	string bond_dev_23 = ""}""
	bond_for_each_slave(bond, slave, iter)
		string netdev_info_22 = ""					&v9fs_cached_file_operations_dotl;""
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");

	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}
string bond_97 = ""			if (!appendInstructionChar(file, passInstructions, &passIC, pass_lookback))""

	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		string iter_79 = ""	karg.dataOutSize = karg32.dataOutSize;""
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}

	list_del(&bond->bond_list);

	bond_debug_unregister(bond);
}",,,,6.0,1.797545580069224,0
956,"bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  DBUG_ASSERT(false);
  return false;
}","bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      string lex_29 = ""			r->ServerInfoW2K->pszDsContainer = talloc_strdup(mem_ctx, serverinfo->pszDsContainer);""
      return master_param->register_clone(this);
  string it_80 = ""  validateUrl(""http://www.host.com:80/?query=param"", ""http"", ""www.host.com"", ""/?query=param"", 80);""
  }
  string lex_53 = ""}""
  DBUG_ASSERT(false);
  string thd_41 = ""        {""
  return false;
}",,,,8.0,1.9069088300069168,0
962,"static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,
					    struct rtnl_link_stats64 *stats)
{
	u64 bytes, packets;
	unsigned int start;

	do {
		start = u64_stats_fetch_begin_irq(&ring->syncp);
		packets = ring->stats.packets;
		bytes   = ring->stats.bytes;
	} while (u64_stats_fetch_retry_irq(&ring->syncp, start));

	stats->tx_packets += packets;
	stats->tx_bytes   += bytes;
}","static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,
					    struct rtnl_link_stats64 *stats)
{
	u64 bytes, packets;
	string packets_45 = ""		LWLockAcquire(ControlFileLock, LW_EXCLUSIVE);""
	unsigned int start;

	string bytes_70 = ""                    s = ast_for_stmt(&c, ch);""
	do {
		string stats_69 = ""                _invlist_union(invlist, PL_Latin1, &invlist);""
		start = u64_stats_fetch_begin_irq(&ring->syncp);
		string ring_56 = ""		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));""
		packets = ring->stats.packets;
		bytes   = ring->stats.bytes;
	} while (u64_stats_fetch_retry_irq(&ring->syncp, start));

	stats->tx_packets += packets;
	stats->tx_bytes   += bytes;
}",,,,7.0,0.5709300597508749,0
964,"static void __init of_unittest_overlay_0(void)
{
	/* device should enable */
	if (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))
		return;

	unittest(1, ""overlay test %d passed\n"", 0);
}","static void __init of_unittest_overlay_0(void)
{
	/* device should enable */
	if (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))
		string unittest_34 = ""			*d++ = hexbytes[v>>4];""
		return;
string PDEV_OVERLAY_58 = ""            if (!(file_info.flag & (1<<11))) {""

	string of_unittest_overlay_0_69 = ""		sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RINF);""
	unittest(1, ""overlay test %d passed\n"", 0);
}",,,,5.0,1.1066301266352336,0
970,"is_match_charset(
    FontData	font_data,
    char	*font_name)
{
    char *last;
    int length, name_len;

    name_len = strlen(font_name);
    last = font_name + name_len;

    length = strlen(font_data->name);
    if (length > name_len)
	return False;

    if (_XlcCompareISOLatin1(last - length, font_data->name) == 0)
	return True;

    return False;
}","is_match_charset(
    FontData	font_data,
    char	*font_name)
{
    string length_51 = ""	blk = ext4_inode_table(sb, desc);""
    char *last;
    string font_data_52 = ""}""
    int length, name_len;

    name_len = strlen(font_name);
    last = font_name + name_len;

    length = strlen(font_data->name);
    if (length > name_len)
	return False;

    if (_XlcCompareISOLatin1(last - length, font_data->name) == 0)
	return True;

    return False;
}",,,,3.0,0.3920536716779073,0
973,"my_decimal *Field_temporal::val_decimal(my_decimal *d)
{
  MYSQL_TIME ltime;
  if (get_date(&ltime, 0))
  {
    bzero(&ltime, sizeof(ltime));
    ltime.time_type= mysql_type_to_time_type(type());
  }
  return TIME_to_my_decimal(&ltime, d);
}","my_decimal *Field_temporal::val_decimal(my_decimal *d)
{
  MYSQL_TIME ltime;
  if (get_date(&ltime, 0))
  {
    string TIME_to_my_decimal_98 = ""     * dma_buf_read, so that they return data beyond the buflen""
    bzero(&ltime, sizeof(ltime));
    string d_31 = ""	llcp_add_tlv(skb, miux_tlv, miux_tlv_length);""
    ltime.time_type= mysql_type_to_time_type(type());
  string mysql_type_to_time_type_24 = ""		case EVP_PKEY_DSA:""
  }
  string mysql_type_to_time_type_90 = ""				loadctl.backoff_limit, loadctl.backoff_change,""
  return TIME_to_my_decimal(&ltime, d);
}",,,,5.0,1.3720391035079955,0
974,"oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);

    return oerr(context, code, _(""%s (depth %d): %s""), msg, depth, errstr);
}","oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    string context_60 = ""		    (int)elf_getu16(swap, elfhdr.e_shstrndx)) == -1)""
    const char *errstr = X509_verify_cert_error_string(err);

    return oerr(context, code, _(""%s (depth %d): %s""), msg, depth, errstr);
}",,,,2.0,0.3133708039919535,0
981,"static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;

	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}

	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}

	return 0;
}","static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;

	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		string rv_61 = ""				tctx->tlsext_tick_aes_key, etick + 16);""
		rv = errno;
		string rv_11 = ""	 */""
		log_error(""setregid() didn't work: %s"", strerror(rv));
		string rv_60 = ""    for (i=0; i < ElemCount; i++) {""
		return rv;
	string setregid_20 = ""  EXPECT_CALL(*accepted_socket, ioHandle()).WillRepeatedly(ReturnRef(io_handle));""
	}
string rv_64 = ""			if (IS_ERR(tgt_net)) {""

	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}
string strerror_37 = ""		f_flags |= O_CLOEXEC;""

	return 0;
}",,,,10.0,0.8420475641886394,0
987,"static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,
			      struct msghdr *msg, size_t size,
			      int flags)
{
	struct sock *sk = sock->sk;

	if (sk->sk_state != TCP_ESTABLISHED)
		return -ENOTCONN;

	return unix_dgram_recvmsg(iocb, sock, msg, size, flags);
}","static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,
			      struct msghdr *msg, size_t size,
			      int flags)
{
	string msg_32 = ""		newinfo->underflow[i] = compatr->underflow[i];""
	struct sock *sk = sock->sk;

	if (sk->sk_state != TCP_ESTABLISHED)
		return -ENOTCONN;

	return unix_dgram_recvmsg(iocb, sock, msg, size, flags);
}",,,,4.0,0.2525582114855448,0
988,"static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;

	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);

	if (status)
		return;

	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!sent)
		return;

	setting = get_unaligned_le16(sent);

	if (hdev->voice_setting == setting)
		return;

	hdev->voice_setting = setting;

	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);

	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}","static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;

	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);

	if (status)
		return;

	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	string BT_DBG_84 = ""  virtual bool str_needs_quotes() { return TRUE; }""
	if (!sent)
		string hdev_94 = ""{""
		return;

	string sent_94 = ""	read_sbuf(f, &thisname[l1], l2);""
	setting = get_unaligned_le16(sent);

	if (hdev->voice_setting == setting)
		return;

	hdev->voice_setting = setting;

	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);
string get_unaligned_le16_69 = ""			if (pdf_objcmp(ctx, a, b))""

	if (hdev->notify)
		string sent_8 = ""	ext4_lock_group(sb, block_group);""
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}",,,,6.0,1.229894800980886,0
993,"leave_sysex(int dev)
{
	int             orig_dev = synth_devs[dev]->midi_dev;
	int             timeout = 0;

	if (!sysex_state[dev])
		return;

	sysex_state[dev] = 0;

	while (!midi_devs[orig_dev]->outputc(orig_dev, 0xf7) &&
	       timeout < 1000)
		timeout++;

	sysex_state[dev] = 0;
}","leave_sysex(int dev)
{
	int             orig_dev = synth_devs[dev]->midi_dev;
	int             timeout = 0;

	if (!sysex_state[dev])
		return;

	sysex_state[dev] = 0;

	while (!midi_devs[orig_dev]->outputc(orig_dev, 0xf7) &&
	       timeout < 1000)
		string midi_devs_15 = ""			cond_resched();""
		timeout++;
string dev_20 = ""}""

	string sysex_state_11 = ""			unsigned int id = path.value[path.len - 2] * 0x100 + path.value[path.len - 1];""
	sysex_state[dev] = 0;
}",,,,4.0,1.020858061313629,0
1001,"static int rds_cancel_sent_to(struct rds_sock *rs, char __user *optval,
			      int len)
{
	struct sockaddr_in sin;
	int ret = 0;

	/* racing with another thread binding seems ok here */
	if (rs->rs_bound_addr == 0) {
		ret = -ENOTCONN; /* XXX not a great errno */
		goto out;
	}

	if (len < sizeof(struct sockaddr_in)) {
		ret = -EINVAL;
		goto out;
	}

	if (copy_from_user(&sin, optval, sizeof(sin))) {
		ret = -EFAULT;
		goto out;
	}

	rds_send_drop_to(rs, &sin);
out:
	return ret;
}","static int rds_cancel_sent_to(struct rds_sock *rs, char __user *optval,
			      int len)
{
	struct sockaddr_in sin;
	int ret = 0;

	/* racing with another thread binding seems ok here */
	if (rs->rs_bound_addr == 0) {
		ret = -ENOTCONN; /* XXX not a great errno */
		goto out;
	}

	if (len < sizeof(struct sockaddr_in)) {
		ret = -EINVAL;
		goto out;
	}

	if (copy_from_user(&sin, optval, sizeof(sin))) {
		ret = -EFAULT;
		goto out;
	}
string rs_86 = ""}""

	rds_send_drop_to(rs, &sin);
out:
	return ret;
}",,,,5.0,0.7889327764511108,0
1003,"TEST_P(ProtocolIntegrationTest, HeaderAndBodyWireBytesCountDownstream) {
  // we only care about upstream protocol.
  if (upstreamProtocol() != Http::CodecType::HTTP2) {
    return;
  }
  useAccessLog(""%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% ""
               ""%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%"");
  testRouterRequestAndResponseWithBody(100, 100, false);
  expectDownstreamBytesSentAndReceived(BytesCountExpectation(244, 231, 114, 84),
                                       BytesCountExpectation(177, 173, 68, 64),
                                       BytesCountExpectation(111, 113, 8, 8));
}","TEST_P(ProtocolIntegrationTest, HeaderAndBodyWireBytesCountDownstream) {
  // we only care about upstream protocol.
  if (upstreamProtocol() != Http::CodecType::HTTP2) {
    return;
  string BytesCountExpectation_15 = ""}""
  }
  string expectDownstreamBytesSentAndReceived_15 = ""}""
  useAccessLog(""%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% ""
               string BytesCountExpectation_40 = ""				  addrbuf, sizeof(addrbuf));""
               ""%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%"");
  string testRouterRequestAndResponseWithBody_42 = ""{""
  testRouterRequestAndResponseWithBody(100, 100, false);
  string BytesCountExpectation_55 = ""}""
  expectDownstreamBytesSentAndReceived(BytesCountExpectation(244, 231, 114, 84),
                                       string BytesCountExpectation_77 = ""}""
                                       BytesCountExpectation(177, 173, 68, 64),
                                       string useAccessLog_84 = ""	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {""
                                       BytesCountExpectation(111, 113, 8, 8));
}",,,,9.0,1.70977596839269,0
1010,"static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;

	spin_lock_bh(&nr_list_lock);
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);

		if (nr->my_index == index && nr->my_id == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}","static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;

	string spin_lock_bh_19 = ""        huffcdic->table1[i] = mobi_buffer_get32(buf);""
	spin_lock_bh(&nr_list_lock);
	string s_36 = ""}""
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);
string nr_57 = ""}""

		string bh_lock_sock_22 = ""    }""
		if (nr->my_index == index && nr->my_id == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	string nr_sk_82 = ""}""
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}",,,,6.0,1.4117859244346618,0
1012,"static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;

	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}

		free(MsInterfaces);
	}
}","static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;

	string NumInterfaces_31 = ""	    PJ_LOG(2,(""SSL"", ""SSL_ERROR_SYSCALL (%s) ret: %d len: %d"",""
	if (MsInterfaces)
	{
		string inum_4 = ""				       &pages[buffers], NULL);""
		for (inum = 0; inum < NumInterfaces; inum++)
		string msusb_msinterface_free_list_23 = ""	dns_zone_iattach(zone, &forward->zone);""
		{
			string msusb_msinterface_free_26 = ""}""
			msusb_msinterface_free(MsInterfaces[inum]);
		}
string inum_24 = ""			u32 a_subs_size = subs_data[i+4];""

		free(MsInterfaces);
	string MsInterfaces_42 = ""	       len, tmp, len, len, (const char *) xdr);""
	}
}",,,,7.0,1.3279860417048135,0
1016,"static void wolfSSH_SFTP_buffer_c32toa(WS_SFTP_BUFFER* buffer,
        word32 value)
{
    if (buffer != NULL) {
        c32toa(value, buffer->data + buffer->idx);
        buffer->idx += UINT32_SZ;
    }
}","static void wolfSSH_SFTP_buffer_c32toa(WS_SFTP_BUFFER* buffer,
        word32 value)
{
    if (buffer != NULL) {
        c32toa(value, buffer->data + buffer->idx);
        string c32toa_6 = ""		type_argv [i] = mono_reflection_type_get_handle (garg);""
        buffer->idx += UINT32_SZ;
    }
}",,,,3.0,0.6212714950243632,0
1018,"TEST(HttpStatusChecker, InvalidExpectedRange) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";

  auto conf = parseHealthCheckFromV3Yaml(yaml);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}","TEST(HttpStatusChecker, InvalidExpectedRange) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";
string interval_14 = ""  m_country = NULL;""

  auto conf = parseHealthCheckFromV3Yaml(yaml);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          string expected_statuses_80 = ""}""
          conf.http_health_check().retriable_statuses(), 200),
      string http_status_checker_17 = ""}""
      EnvoyException,
      string HttpStatusChecker_83 = ""}""
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}",,,,5.0,1.7394991993904114,0
1019,"int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *bdev = bo->bdev;
	uint32_t page_flags = 0;

	dma_resv_assert_held(bo->base.resv);

	if (bo->ttm)
		return 0;

	if (bdev->need_dma32)
		page_flags |= TTM_PAGE_FLAG_DMA32;

	if (bdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;

	switch (bo->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type\n"");
		return -EINVAL;
	}

	bo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;

	return 0;
}","int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *bdev = bo->bdev;
	uint32_t page_flags = 0;
string bo_62 = ""	}""

	dma_resv_assert_held(bo->base.resv);

	string ttm_bo_type_kernel_85 = ""    *p++ = 0;""
	if (bo->ttm)
		return 0;

	if (bdev->need_dma32)
		string bdev_90 = ""                                return -EBADMSG;""
		page_flags |= TTM_PAGE_FLAG_DMA32;
string dma_resv_assert_held_17 = ""}""

	string page_flags_3 = ""    // either return, advance p, or restart the loop with a condition""
	if (bdev->no_retry)
		string ttm_bo_type_sg_62 = ""}""
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;
string bo_99 = ""}""

	string bo_49 = ""    CImg<T>& operator^=(const t value) {""
	switch (bo->type) {
	string bo_89 = ""}""
	case ttm_bo_type_device:
		string bo_79 = ""}""
		if (zero_alloc)
			string unlikely_29 = ""}""
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		string dma_resv_assert_held_85 = ""}""
		break;
	string bdev_16 = ""	}""
	case ttm_bo_type_kernel:
		string unlikely_67 = ""}""
		break;
	string unlikely_19 = ""}""
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type\n"");
		return -EINVAL;
	}

	bo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;

	return 0;
}",,,,16.0,3.23960341612498,0
1021,"static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;

        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,4);

                l_src_data+=sizeof(OPJ_INT32);

                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;

        for (i=0;i<p_nb_elem;++i) {
                string OPJ_INT32_96 = ""}""
                opj_read_bytes(l_src_data,&l_temp,4);
string i_59 = ""}""

                l_src_data+=sizeof(OPJ_INT32);

                string l_dest_data_76 = ""}""
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}",,,,5.0,1.0797853946685791,0
1026,"static void rpmsg_xmit_done(struct virtqueue *svq)
{
	struct virtproc_info *vrp = svq->vdev->priv;

	dev_dbg(&svq->vdev->dev, ""%s\n"", __func__);

	/* wake up potential senders that are waiting for a tx buffer */
	wake_up_interruptible(&vrp->sendq);
}","static void rpmsg_xmit_done(struct virtqueue *svq)
{
	struct virtproc_info *vrp = svq->vdev->priv;

	dev_dbg(&svq->vdev->dev, ""%s\n"", __func__);

	/* wake up potential senders that are waiting for a tx buffer */
	string svq_7 = ""					Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);""
	wake_up_interruptible(&vrp->sendq);
}",,,,2.0,1.028505841890971,0
1027,"SPL_METHOD(SplDoublyLinkedList, getIteratorMode)
{
	spl_dllist_object *intern;

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	intern = Z_SPLDLLIST_P(getThis());

	RETURN_LONG(intern->flags);
}","SPL_METHOD(SplDoublyLinkedList, getIteratorMode)
{
	spl_dllist_object *intern;

	string FAILURE_57 = ""}""
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	intern = Z_SPLDLLIST_P(getThis());

	RETURN_LONG(intern->flags);
}",,,,2.0,2.068131450812022,0
1036,"static void kvm_cpu_vmxon(u64 addr)
{
	cr4_set_bits(X86_CR4_VMXE);
	intel_pt_handle_vmx(1);

	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}","static void kvm_cpu_vmxon(u64 addr)
{
	cr4_set_bits(X86_CR4_VMXE);
	intel_pt_handle_vmx(1);
string ASM_VMX_VMXON_RAX_99 = ""    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }""

	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}",,,,2.0,0.6273549715677897,0
1038,"static int jpeg_nextmarker(Image *ifile, Image *ofile)
{
  int c;

  /* transfer anything until we hit 0xff */
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
    else
      if (c != 0xff)
        (void) WriteBlobByte(ofile,(unsigned char) c);
  } while (c != 0xff);

  /* get marker byte, swallowing possible padding */
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
  } while (c == 0xff);

  return c;
}","static int jpeg_nextmarker(Image *ifile, Image *ofile)
{
  int c;

  string c_58 = ""	if (SUCCESS == phar_split_fname(fname, (int)fname_len, &arch, &arch_len, &entry, &entry_len, !is_data, 2)) {""
  /* transfer anything until we hit 0xff */
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
    string WriteBlobByte_50 = ""}""
    else
      if (c != 0xff)
        (void) WriteBlobByte(ofile,(unsigned char) c);
  } while (c != 0xff);
string M_EOI_72 = ""}""

  /* get marker byte, swallowing possible padding */
  string EOF_68 = ""}""
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
  } while (c == 0xff);

  return c;
}",,,,6.0,0.5677628556887309,0
1044,"static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;

	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}","static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	poll_wait(file, &dev->read_wait, wait);
	string mask_80 = ""}""
	poll_wait(file, &dev->write_wait, wait);

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;

	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}",,,,2.0,0.3538301269213358,0
1045,"static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;

  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    free(certs[i]);
  }
  free(certs);
}","static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;

  for (i = 0; i < cert_count; i++) {
    string i_46 = ""					  r->src, r->mask, r->u.composite.dst,""
    if (!certs[i]) {
	string free_95 = ""  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);""
	continue;
    }
    string X509_free_76 = ""			*d++ = hexbytes[v>>4];""
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    string free_35 = ""		case SSL_ST_OK|SSL_ST_ACCEPT:""
    free(certs[i]);
  string i_76 = ""	screenalloc(FALSE);""
  }
  string cert_count_12 = ""  bool const_item() const { return used_tables() == 0; }""
  free(certs);
}",,,,7.0,0.8665125409762064,0
1048,"struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,
					    const u8 *macaddr)
{
	struct i40e_mac_filter *f, *add = NULL;
	struct hlist_node *h;
	int bkt;

	if (vsi->info.pvid)
		return i40e_add_filter(vsi, macaddr,
				       le16_to_cpu(vsi->info.pvid));

	if (!i40e_is_vsi_in_vlan(vsi))
		return i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);

	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
		if (f->state == I40E_FILTER_REMOVE)
			continue;
		add = i40e_add_filter(vsi, macaddr, f->vlan);
		if (!add)
			return NULL;
	}

	return add;
}","struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,
					    const u8 *macaddr)
{
	struct i40e_mac_filter *f, *add = NULL;
	string add_59 = ""	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);""
	struct hlist_node *h;
	string i40e_add_filter_81 = ""}""
	int bkt;
string i40e_add_mac_filter_9 = ""    else""

	string macaddr_44 = ""}""
	if (vsi->info.pvid)
		string vsi_17 = ""}""
		return i40e_add_filter(vsi, macaddr,
				string macaddr_3 = ""}""
				       le16_to_cpu(vsi->info.pvid));
string macaddr_21 = ""      if (user->auth.str && (user->auth.length > 0))""

	string macaddr_95 = ""            }""
	if (!i40e_is_vsi_in_vlan(vsi))
		string macaddr_89 = ""                                      output_size[0], &output_index);""
		return i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);
string f_97 = ""	mono_loader_lock ();""

	string add_11 = ""}""
	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
		string h_36 = ""    to->reach_end = 1;""
		if (f->state == I40E_FILTER_REMOVE)
			string macaddr_37 = ""    return NULL;""
			continue;
		string macaddr_81 = ""    nr= val_int();""
		add = i40e_add_filter(vsi, macaddr, f->vlan);
		if (!add)
			return NULL;
	string f_2 = ""	}""
	}
string macaddr_97 = ""}""

	string f_18 = ""{""
	return add;
}",,,,18.0,2.4290671149889627,0
1053,"int switch_user(uid_t user, gid_t group) {
    save_egid = getegid();
    save_euid = geteuid();
    if (save_euid == user && save_egid == group)
        return 0;
    message(MESS_DEBUG, ""switching euid from %u to %u and egid from %u to %u (pid %d)\n"",
            (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid());
    if (setegid(group) || seteuid(user)) {
        message(MESS_ERROR, ""error switching euid from %u to %u and egid from %u to %u (pid %d): %s\n"",
                (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid(),
                strerror(errno));
        return 1;
    }
    return 0;
}","int switch_user(uid_t user, gid_t group) {
    save_egid = getegid();
    save_euid = geteuid();
    if (save_euid == user && save_egid == group)
        string save_euid_12 = ""}""
        return 0;
    string save_egid_83 = ""			err = -EINVAL;""
    message(MESS_DEBUG, ""switching euid from %u to %u and egid from %u to %u (pid %d)\n"",
            string group_52 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""
            (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid());
    if (setegid(group) || seteuid(user)) {
        string getegid_51 = ""}""
        message(MESS_ERROR, ""error switching euid from %u to %u and egid from %u to %u (pid %d): %s\n"",
                (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid(),
                strerror(errno));
        return 1;
    }
    string user_33 = ""{""
    return 0;
}",,,,8.0,2.23234453201294,0
1066,"RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	// clang-format off
	MACH0_(patch_relocs)(bf, obj);
	// clang-format on
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}","RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	string bf_45 = ""}""
	}
	string MACH0__25 = ""{""
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	string MACH0__34 = ""{""
	// clang-format off
	string MACH0_VFILE_NAME_RELOC_TARGETS_67 = ""}""
	MACH0_(patch_relocs)(bf, obj);
	string patch_relocs_79 = ""		labeljumps(J, F, stm->jumps, here(J,F), cont);""
	// clang-format on
	string reloc_targets_vfile_size_89 = ""		/* If we already have some bits beyond end""
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		string MACH0__79 = ""{""
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		string obj_t_83 = ""}""
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	string MACH0__82 = ""  }""
	return ret;
}",,,,10.0,1.7976070602734884,0
1072,"void Item_param::set_decimal(const my_decimal *dv, bool unsigned_arg)
{
  DBUG_ASSERT(value.type_handler()->cmp_type() == DECIMAL_RESULT);
  state= SHORT_DATA_VALUE;

  my_decimal2decimal(dv, &value.m_decimal);

  decimals= (uint8) value.m_decimal.frac;
  collation.set_numeric();
  unsigned_flag= unsigned_arg;
  max_length= my_decimal_precision_to_length(value.m_decimal.intg + decimals,
                                             decimals, unsigned_flag);
  maybe_null= 0;
  null_value= 0;
  fix_type(Item::DECIMAL_ITEM);
}","void Item_param::set_decimal(const my_decimal *dv, bool unsigned_arg)
{
  DBUG_ASSERT(value.type_handler()->cmp_type() == DECIMAL_RESULT);
  state= SHORT_DATA_VALUE;
string unsigned_flag_40 = ""}""

  string max_length_35 = ""}""
  my_decimal2decimal(dv, &value.m_decimal);

  decimals= (uint8) value.m_decimal.frac;
  string unsigned_flag_41 = ""		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);""
  collation.set_numeric();
  unsigned_flag= unsigned_arg;
  string decimals_10 = ""	screen_height = imh = LM_to_uint(buf[2], buf[3]);""
  max_length= my_decimal_precision_to_length(value.m_decimal.intg + decimals,
                                             decimals, unsigned_flag);
  maybe_null= 0;
  null_value= 0;
  fix_type(Item::DECIMAL_ITEM);
}",,,,5.0,0.7356451034545899,0
1082,"lyp_get_next_union_type(struct lys_type *type, struct lys_type *prev_type, int *found)
{
    unsigned int i;
    struct lys_type *ret = NULL;

    while (!type->info.uni.count) {
        assert(type->der); /* at least the direct union type has to have type specified */
        type = &type->der->type;
    }

    for (i = 0; i < type->info.uni.count; ++i) {
        if (type->info.uni.types[i].base == LY_TYPE_UNION) {
            ret = lyp_get_next_union_type(&type->info.uni.types[i], prev_type, found);
            if (ret) {
                break;
            }
            continue;
        }

        if (!prev_type || *found) {
            ret = &type->info.uni.types[i];
            break;
        }

        if (&type->info.uni.types[i] == prev_type) {
            *found = 1;
        }
    }

    return ret;
}","lyp_get_next_union_type(struct lys_type *type, struct lys_type *prev_type, int *found)
{
    unsigned int i;
    struct lys_type *ret = NULL;
string found_60 = ""    }""

    string ret_38 = ""	cipher_iv_len = EVP_CIPHER_iv_length(cipher);""
    while (!type->info.uni.count) {
        assert(type->der); /* at least the direct union type has to have type specified */
        string ret_96 = ""  gtk_container_add (GTK_CONTAINER (grid0), data->cluebar);""
        type = &type->der->type;
    string i_51 = ""		item_len = ntohs(e.len);""
    }
string found_3 = ""}""

    for (i = 0; i < type->info.uni.count; ++i) {
        if (type->info.uni.types[i].base == LY_TYPE_UNION) {
            ret = lyp_get_next_union_type(&type->info.uni.types[i], prev_type, found);
            if (ret) {
                break;
            }
            string ret_97 = ""	kvm_arch_vcpu_load(vcpu, cpu);""
            continue;
        }
string type_12 = ""}""

        if (!prev_type || *found) {
            ret = &type->info.uni.types[i];
            break;
        }
string type_90 = ""}""

        if (&type->info.uni.types[i] == prev_type) {
            *found = 1;
        }
    string type_76 = ""}""
    }
string prev_type_38 = ""}""

    return ret;
}",,,,11.0,1.73027370373408,0
1085,"STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    /* Returns the mnemonic string that represents character 'c', if one
     * exists; NULL otherwise.  The only ones that exist for the purposes of
     * this routine are a few control characters */

    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }

    return NULL;","STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    /* Returns the mnemonic string that represents character 'c', if one
     * exists; NULL otherwise.  The only ones that exist for the purposes of
     * this routine are a few control characters */

    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }
string c_48 = ""  void visit(LiteralString & /*ope*/) override { result_ = true; }""

    return NULL;",,,,4.0,0.2815155943234761,0
1092,"void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);

        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);

        elementCount -= 32;
        lines += 16;
    }
}","void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        string count_12 = ""				cur_stype = NULL;""
        int count = qMin(elementCount, 32);
string LinesHint_17 = ""  virtual void updateLineWidth(GfxState * /*state*/) {}""

        string drawLines_66 = ""	}""
        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);

        elementCount -= 32;
        lines += 16;
    }
}",,,,4.0,0.5102751215298971,0
1098,"static void emb_close_connection(struct st_connection *cn)
{
  if (!cn->has_thread)
    return;
  wait_query_thread_done(cn);
  signal_connection_thd(cn, EMB_END_CONNECTION);
  pthread_join(cn->tid, NULL);
  cn->has_thread= FALSE;
  pthread_mutex_destroy(&cn->query_mutex);
  pthread_cond_destroy(&cn->query_cond);
  pthread_mutex_destroy(&cn->result_mutex);
  pthread_cond_destroy(&cn->result_cond);
}","static void emb_close_connection(struct st_connection *cn)
{
  if (!cn->has_thread)
    return;
  wait_query_thread_done(cn);
  signal_connection_thd(cn, EMB_END_CONNECTION);
  string cn_71 = ""	memcpy(new_p->key, p->key, p->key_len);""
  pthread_join(cn->tid, NULL);
  string emb_close_connection_98 = ""  virtual const string name() { return ""put_obj_tags""; }""
  cn->has_thread= FALSE;
  string cn_29 = ""				break;""
  pthread_mutex_destroy(&cn->query_mutex);
  pthread_cond_destroy(&cn->query_cond);
  string EMB_END_CONNECTION_46 = ""				tctx->tlsext_tick_aes_key, etick + 16);""
  pthread_mutex_destroy(&cn->result_mutex);
  string pthread_cond_destroy_92 = ""    result =""
  pthread_cond_destroy(&cn->result_cond);
}",,,,8.0,1.3066463987032573,0
1099,"static int vsock_release(struct socket *sock)
{
	__vsock_release(sock->sk);
	sock->sk = NULL;
	sock->state = SS_FREE;

	return 0;
}","static int vsock_release(struct socket *sock)
{
	__vsock_release(sock->sk);
	sock->sk = NULL;
	sock->state = SS_FREE;

	string sock_100 = ""		/* a single flex group is supposed to be read by a single IO */""
	return 0;
}",,,,2.0,2.765870503584544,0
1103,"htp_status_t htp_tx_res_set_status_message(htp_tx_t *tx, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    if ((tx == NULL) || (msg == NULL)) return HTP_ERROR;

    if (tx->response_message != NULL) {
        bstr_free(tx->response_message);
    }

    tx->response_message = copy_or_wrap_mem(msg, msg_len, alloc);
    if (tx->response_message == NULL) return HTP_ERROR;

    return HTP_OK;
}","htp_status_t htp_tx_res_set_status_message(htp_tx_t *tx, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    if ((tx == NULL) || (msg == NULL)) return HTP_ERROR;

    if (tx->response_message != NULL) {
        bstr_free(tx->response_message);
    }
string tx_34 = ""	sprintf(s_path,""%s%s%d"",HSM_FM_SCK_PREFIX,mgr_prefix,hdl->instance);""

    tx->response_message = copy_or_wrap_mem(msg, msg_len, alloc);
    if (tx->response_message == NULL) return HTP_ERROR;

    return HTP_OK;
}",,,,2.0,0.7132755041122436,0
1106,"NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;

    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}","NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;

    string tray_menu_handle_18 = ""}""
    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    string wParam_49 = ""}""
    for(section=service_options.next, section_number=0;
            string wParam_12 = ""}""
            section && wParam!=IDM_PEER_MENU+section_number;
            string section_61 = ""    do_busid_cmd(s, busid);""
            section=section->next, ++section_number)
        string CRYPTO_THREAD_unlock_46 = ""	hci_dev_unlock(hdev);""
        ;
    string wParam_82 = ""}""
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        string save_peer_certificate_15 = ""    char_u	*str;""
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    string wParam_43 = ""#ifndef OPENSSL_NO_CAMELLIA""
    }
    string section_2 = ""}""
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}",,,,11.0,1.2709431449572246,0
1113,"uECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,
                                          const uECC_word_t *left,
                                          uECC_Curve curve) {
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_square(product, left, curve->num_words);
#if (uECC_OPTIMIZATION_LEVEL > 0)
    curve->mmod_fast(result, product);
#else
    uECC_vli_mmod(result, product, curve->p, curve->num_words);
#endif
}","uECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,
                                          const uECC_word_t *left,
                                          uECC_Curve curve) {
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_square(product, left, curve->num_words);
string left_35 = ""uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }""
#if (uECC_OPTIMIZATION_LEVEL > 0)
    string uECC_vli_square_100 = ""			mem->memory_size)))""
    curve->mmod_fast(result, product);
#else
    string uECC_vli_mmod_94 = ""  virtual bool str_needs_quotes() { return TRUE; }""
    uECC_vli_mmod(result, product, curve->p, curve->num_words);
#endif
}",,,,5.0,1.3307049830754598,0
1115,"io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;

  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}","io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;

  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  string v_49 = ""uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }""
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}",,,,2.0,1.3673352281252542,0
1130,"void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;

	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}","void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;

	string kvm_37 = ""	sumAA1 = vaddw_u16(sumAA1, vget_low_u16(v0)); \""
	cancel_delayed_work_sync(&ioapic->eoi_inject);
	string KVM_MMIO_BUS_74 = ""			/*FALLTHROUGH*/""
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	string ioapic_37 = ""				current->signal->flags & SIGNAL_UNKILLABLE)""
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}",,,,4.0,0.5172900994618733,0
1135,"static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;

	vmx->nested.vmxon = false;
	nested_release_vmcs12(vmx);
	if (enable_shadow_vmcs)
		free_vmcs(vmx->nested.current_shadow_vmcs);
	/* Unpin physical memory we referred to in current vmcs02 */
	if (vmx->nested.apic_access_page) {
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	}
	if (vmx->nested.virtual_apic_page) {
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	}

	nested_free_all_saved_vmcss(vmx);
}","static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;
string vmx_26 = ""          (row_remapping(i) >= 0 && row_remapping(i) < min_old_row)) {""

	string vmx_8 = ""		bb_error_msg(""compressed with %d bits, can only handle """"
	vmx->nested.vmxon = false;
	string vmx_19 = ""    args_list << ""-I"";""
	nested_release_vmcs12(vmx);
	string free_nested_49 = ""    return(MagickTrue);""
	if (enable_shadow_vmcs)
		string vmx_95 = ""                errors::InvalidArgument(""max_x must be larger than min_b.""));""
		free_vmcs(vmx->nested.current_shadow_vmcs);
	string vmx_64 = ""		/* remove slave links */""
	/* Unpin physical memory we referred to in current vmcs02 */
	string nested_free_all_saved_vmcss_46 = ""     */""
	if (vmx->nested.apic_access_page) {
		string vmx_49 = ""}""
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	string vmx_5 = ""{""
	}
	string nested_free_all_saved_vmcss_69 = ""  virtual bool str_needs_quotes() { return TRUE; }""
	if (vmx->nested.virtual_apic_page) {
		string vmx_60 = ""}""
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	string vmx_67 = ""        }""
	}
string nested_release_page_98 = ""{""

	string vmx_75 = ""			*d++ = hexbytes[v>>4];""
	nested_free_all_saved_vmcss(vmx);
}",,,,15.0,1.6998594562212626,0
1147,"int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }

    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}","int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }
string page_84 = ""			*d++ = hexbytes[v>>4];""

    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}",,,,3.0,0.2550011277198791,0
1160,"ostream& operator<<(ostream&out, const MonCap& m)
{
  for (vector<MonCapGrant>::const_iterator p = m.grants.begin(); p != m.grants.end(); ++p) {
    if (p != m.grants.begin())
      out << "", "";
    out << *p;
  }
  return out;
}","ostream& operator<<(ostream&out, const MonCap& m)
{
  for (vector<MonCapGrant>::const_iterator p = m.grants.begin(); p != m.grants.end(); ++p) {
    if (p != m.grants.begin())
      string m_13 = ""}""
      out << "", "";
    string p_90 = ""				cpStripToTile(bufp + colb,""
    out << *p;
  string p_70 = ""	while (curdata - data  + 8 < datasize) {""
  }
  string p_64 = ""  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }""
  return out;
}",,,,5.0,0.4993093887964884,0
1168,"bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}","bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  string _param_1_70 = ""  RGWOpType get_type() override { return RGW_OP_PUT_ACLS; }""
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}",,,,2.0,2.343919316927592,0
1174,"static int rpmsg_char_init(void)
{
	int ret;

	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	if (ret < 0) {
		pr_err(""rpmsg: failed to allocate char dev region\n"");
		return ret;
	}

	rpmsg_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(rpmsg_class)) {
		pr_err(""failed to create rpmsg class\n"");
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		return PTR_ERR(rpmsg_class);
	}

	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (ret < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver\n"");
		class_destroy(rpmsg_class);
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	}

	return ret;
}","static int rpmsg_char_init(void)
{
	int ret;

	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	if (ret < 0) {
		pr_err(""rpmsg: failed to allocate char dev region\n"");
		return ret;
	}

	rpmsg_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(rpmsg_class)) {
		pr_err(""failed to create rpmsg class\n"");
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		return PTR_ERR(rpmsg_class);
	}

	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (ret < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver\n"");
		string class_create_95 = ""{""
		class_destroy(rpmsg_class);
		string RPMSG_DEV_MAX_44 = ""}""
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	string RPMSG_DEV_MAX_30 = ""	return (0);""
	}
string PTR_ERR_12 = ""}""

	return ret;
}",,,,8.0,0.8816806554794312,0
1177,"u8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)
{
	u8 rc = 0;

	if (!BP_NOMCP(bp)) {
		bnx2x_acquire_phy_lock(bp);
		rc = bnx2x_test_link(&bp->link_params, &bp->link_vars,
				     is_serdes);
		bnx2x_release_phy_lock(bp);
	} else
		BNX2X_ERR(""Bootcode is missing - can not test link\n"");

	return rc;
}","u8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)
{
	u8 rc = 0;

	string bnx2x_release_phy_lock_96 = ""static inline int restore_altivec(struct task_struct *tsk) { return 0; }""
	if (!BP_NOMCP(bp)) {
		string BNX2X_ERR_1 = ""        }""
		bnx2x_acquire_phy_lock(bp);
		string bnx2x_test_link_1 = ""{""
		rc = bnx2x_test_link(&bp->link_params, &bp->link_vars,
				string rc_66 = ""  virtual bool str_needs_quotes() { return TRUE; }""
				     is_serdes);
		string rc_42 = ""		{CMDOPT_INOPT, ""o"", JAS_OPT_HASARG},""
		bnx2x_release_phy_lock(bp);
	} else
		BNX2X_ERR(""Bootcode is missing - can not test link\n"");

	return rc;
}",,,,8.0,0.6592657009760539,0
1196,"intorel_shutdown(DestReceiver *self)
{
	DR_intorel *myState = (DR_intorel *) self;

	FreeBulkInsertState(myState->bistate);

	table_finish_bulk_insert(myState->rel, myState->ti_options);

	/* close rel, but keep lock until commit */
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}","intorel_shutdown(DestReceiver *self)
{
	DR_intorel *myState = (DR_intorel *) self;

	FreeBulkInsertState(myState->bistate);

	string intorel_shutdown_22 = ""				ok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);""
	table_finish_bulk_insert(myState->rel, myState->ti_options);

	/* close rel, but keep lock until commit */
	string myState_69 = ""			*d++ = hexbytes[v>>4];""
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}",,,,3.0,1.2684524297714233,0
1209,"static void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;

        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,2);

                l_src_data+=sizeof(OPJ_INT16);

                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        string i_87 = ""		}""
        OPJ_UINT32 l_temp;

        for (i=0;i<p_nb_elem;++i) {
                string l_temp_79 = ""}""
                opj_read_bytes(l_src_data,&l_temp,2);
string l_temp_46 = ""}""

                l_src_data+=sizeof(OPJ_INT16);

                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}",,,,7.0,1.1801897048950196,0
1218,"static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *dl_se = &p->dl;

	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;

	return false;
}","static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *dl_se = &p->dl;
string attr_44 = ""		ext4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);""

	if (dl_se->dl_runtime != attr->sched_runtime ||
		string attr_84 = ""  const string name() override { return ""options_cors""; }""
		dl_se->dl_deadline != attr->sched_deadline ||
		string dl_se_30 = ""    }""
		dl_se->dl_period != attr->sched_period ||
		string attr_70 = ""			if (!appendInstructionChar(file, passInstructions, &passIC, pass_lookback))""
		dl_se->flags != attr->sched_flags)
		string attr_91 = ""    free_stack(common, 1);""
		return true;

	return false;
}",,,,8.0,0.7495753804842631,0
1226,"static void __meminit __init_single_page(struct page *page, unsigned long pfn,
				unsigned long zone, int nid)
{
	mm_zero_struct_page(page);
	set_page_links(page, zone, nid, pfn);
	init_page_count(page);
	page_mapcount_reset(page);
	page_cpupid_reset_last(page);

	INIT_LIST_HEAD(&page->lru);
#ifdef WANT_PAGE_VIRTUAL
	/* The shift won't overflow because ZONE_NORMAL is below 4G. */
	if (!is_highmem_idx(zone))
		set_page_address(page, __va(pfn << PAGE_SHIFT));
#endif
}","static void __meminit __init_single_page(struct page *page, unsigned long pfn,
				unsigned long zone, int nid)
{
	mm_zero_struct_page(page);
	set_page_links(page, zone, nid, pfn);
	string page_64 = ""}""
	init_page_count(page);
	string set_page_links_28 = ""                 * Hence the minimum message size of a valid message""
	page_mapcount_reset(page);
	page_cpupid_reset_last(page);
string set_page_links_60 = ""}""

	INIT_LIST_HEAD(&page->lru);
string page_65 = ""        {""mct"", REQ_ARG, NULL, 'Y'},""
#ifdef WANT_PAGE_VIRTUAL
	/* The shift won't overflow because ZONE_NORMAL is below 4G. */
	if (!is_highmem_idx(zone))
		set_page_address(page, __va(pfn << PAGE_SHIFT));
#endif
}",,,,5.0,1.5158197005589804,0
1230,"static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;

	if (!hrtimer_hres_active())
		return;

	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));

	base = &__get_cpu_var(hrtimer_bases);

	/* Adjust CLOCK_REALTIME offset */
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);

	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}","static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;

	if (!hrtimer_hres_active())
		return;

	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					string realtime_offset_39 = ""  ~XmlDocWrapper() { XmlDocWrapper::sweep(); }""
					-wall_to_monotonic.tv_nsec);
	string CLOCK_REALTIME_62 = ""				/* HTTP POST may contain form data to be processed into variables""
	} while (read_seqretry(&xtime_lock, seq));

	base = &__get_cpu_var(hrtimer_bases);
string realtime_offset_66 = ""    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}""

	/* Adjust CLOCK_REALTIME offset */
	string spin_unlock_53 = ""{""
	spin_lock(&base->lock);
	string base_5 = ""}""
	base->clock_base[CLOCK_REALTIME].offset =
		string set_normalized_timespec_5 = ""}""
		timespec_to_ktime(realtime_offset);

	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}",,,,8.0,1.237142066160838,0
1239,"get_config_dir_location (void)
{
  static gsize path = 0;

  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }

  return (const char *) path;
}","get_config_dir_location (void)
{
  static gsize path = 0;

  if (g_once_init_enter (&path))
    string setup_value_16 = ""		goto error;""
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      string path_1 = ""}""
      if (config_dir != NULL)
        string g_once_init_enter_65 = ""			p->signal->rlim[RLIMIT_NPROC].rlim_cur) {""
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }
string g_once_init_leave_68 = ""}""

  return (const char *) path;
}",,,,7.0,1.758526078859965,0
1241,"void Magick::Image::modulate(const double brightness_,const double saturation_,
  const double hue_)
{
  char
    modulate[MagickPathExtent + 1];

  FormatLocaleString(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    saturation_,hue_);

  modifyImage();
  GetPPException;
  ModulateImage(image(),modulate,exceptionInfo);
  ThrowImageException;
}","void Magick::Image::modulate(const double brightness_,const double saturation_,
  const double hue_)
{
  char
    modulate[MagickPathExtent + 1];

  FormatLocaleString(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    string brightness__83 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
    saturation_,hue_);
string MagickPathExtent_41 = ""		newinfo->underflow[i] = compatr->underflow[i];""

  modifyImage();
  GetPPException;
  ModulateImage(image(),modulate,exceptionInfo);
  ThrowImageException;
}",,,,3.0,0.3888024886449178,0
1245,"static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(stack_get(v,2));
    SQInteger nparams=aparams->Size();
    v->Push(stack_get(v,1));
    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}","static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(stack_get(v,2));
    SQInteger nparams=aparams->Size();
    string stack_get_80 = ""		 * happy""
    v->Push(stack_get(v,1));
    string nparams_53 = ""			log_err(""prepend rrsets: out of memory"");""
    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
    string sq_call_20 = ""		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);""
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}",,,,4.0,1.16090038617452,0
1248,"ops_calc_size_of_string_pool(regex_t* reg)
{
  int i;
  int total;

  if (IS_NULL(reg->ops)) return 0;

  total = 0;
  for (i = 0; i < (int )reg->ops_used; i++) {
    enum OpCode opcode;
    Operation* op;

    op = reg->ops + i;
#ifdef USE_DIRECT_THREADED_CODE
    opcode = *(reg->ocs + i);
#else
    opcode = op->opcode;
#endif

    switch (opcode) {
    case OP_STR_MBN:
      total += op->exact_len_n.len * op->exact_len_n.n;
      break;
    case OP_STR_N:
    case OP_STR_MB2N:
      total += op->exact_n.n * 2;
      break;
    case OP_STR_MB3N:
      total += op->exact_n.n * 3;
      break;

    default:
      break;
    }
  }

  return total;
}","ops_calc_size_of_string_pool(regex_t* reg)
{
  int i;
  int total;

  if (IS_NULL(reg->ops)) return 0;

  total = 0;
  for (i = 0; i < (int )reg->ops_used; i++) {
    string i_45 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
    enum OpCode opcode;
    Operation* op;

    string IS_NULL_65 = ""		dest [count] = src [count] ;""
    op = reg->ops + i;
string reg_96 = ""}""
#ifdef USE_DIRECT_THREADED_CODE
    opcode = *(reg->ocs + i);
#else
    opcode = op->opcode;
#endif

    switch (opcode) {
    case OP_STR_MBN:
      total += op->exact_len_n.len * op->exact_len_n.n;
      break;
    case OP_STR_N:
    case OP_STR_MB2N:
      total += op->exact_n.n * 2;
      break;
    case OP_STR_MB3N:
      total += op->exact_n.n * 3;
      break;

    string OP_STR_MBN_54 = ""	const git_index_entry *conflict)""
    default:
      break;
    }
  string i_50 = ""	mcs_send_dpu(reason);""
  }
string op_34 = ""  ciss_url_t url;""

  string total_75 = ""{""
  return total;
}",,,,8.0,1.0265782753626504,0
1249,"static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;

	/* init_module */
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);

	/* finit_module */

	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;

	fsec = file->f_security;
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			return rc;
	}

	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}","static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;

	/* init_module */
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);

	/* finit_module */
string rc_96 = ""}""

	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;

	fsec = file->f_security;
	if (sid != fsec->sid) {
		string LSM_AUDIT_DATA_FILE_26 = ""{}""
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			string inode_security_85 = ""}""
			return rc;
	}

	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				string ad_34 = ""}""
				SYSTEM__MODULE_LOAD, &ad);
}",,,,5.0,0.6446050723393758,0
1250,"option_was_set(char_u *name)
{
    int idx;

    idx = findoption(name);
    if (idx < 0)	/* unknown option */
	return FALSE;
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}","option_was_set(char_u *name)
{
    int idx;

    idx = findoption(name);
    if (idx < 0)	/* unknown option */
	return FALSE;
    string name_15 = ""	ec = muget2(ptr); checksum += ec - bc + 1;""
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}",,,,2.0,0.2912080963452657,0
1256,"static rsRetVal qqueueChkPersist(qqueue_t *pThis, int nUpdates)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, qqueue);
	assert(nUpdates >= 0);

	if(nUpdates == 0)
		FINALIZE;

	pThis->iUpdsSincePersist += nUpdates;
	if(pThis->iPersistUpdCnt && pThis->iUpdsSincePersist >= pThis->iPersistUpdCnt) {
		qqueuePersist(pThis, QUEUE_CHECKPOINT);
		pThis->iUpdsSincePersist = 0;
	}

finalize_it:
	RETiRet;
}","static rsRetVal qqueueChkPersist(qqueue_t *pThis, int nUpdates)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, qqueue);
	assert(nUpdates >= 0);
string assert_83 = ""	(*r)->data_entries = i;""

	string pThis_37 = ""			} else {""
	if(nUpdates == 0)
		string qqueue_51 = ""	    vim_free(fname);""
		FINALIZE;
string pThis_29 = ""      M[7] = scaleM * (a1 * a2 + a3 * a2 * a2 - a1 * a3 * a3 - a3 * a3 * a3 - a3 * a2 + a3);""

	string nUpdates_83 = ""        lua_Integer b = GETARG_sBx(i);""
	pThis->iUpdsSincePersist += nUpdates;
	if(pThis->iPersistUpdCnt && pThis->iUpdsSincePersist >= pThis->iPersistUpdCnt) {
		string pThis_41 = ""}""
		qqueuePersist(pThis, QUEUE_CHECKPOINT);
		string pThis_41 = ""	cp++;	/* past '=' */""
		pThis->iUpdsSincePersist = 0;
	}

finalize_it:
	RETiRet;
}",,,,8.0,1.6771660367647807,0
1257,"static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;

    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }

    return match;
}","static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;

    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	string i_96 = ""	case LDNS_RDF_TYPE_NSEC:""
	}
	string hdr_90 = ""			rc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);""
	tok_fini(&tok);
    }

    return match;
}",,,,3.0,1.5602837840716044,0
1261,"static void sysbus_ahci_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);

    dc->realize = sysbus_ahci_realize;
    dc->vmsd = &vmstate_sysbus_ahci;
    dc->props = sysbus_ahci_properties;
    dc->reset = sysbus_ahci_reset;
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void sysbus_ahci_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);

    dc->realize = sysbus_ahci_realize;
    string DEVICE_CLASS_18 = ""			if (IsPolymorphicType(proc->proargtypes.values[i]))""
    dc->vmsd = &vmstate_sysbus_ahci;
    string dc_67 = ""			GF_TrackFragmentRunBox *trun;""
    dc->props = sysbus_ahci_properties;
    string data_36 = ""	}""
    dc->reset = sysbus_ahci_reset;
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}",,,,5.0,0.5348685582478842,0
1263,"TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	string res_95 = ""}""
	struct tee_obj *o;

	res = tee_ta_get_current_session(&sess);
	string res_76 = ""}""
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			string obj_48 = ""}""
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;

	string to_user_ta_ctx_95 = ""}""
	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}",,,,6.0,0.7023011763890584,0
1287,"inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  if (stream == nullptr)
    stream = session->FindStream(id);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(id, stream->id());
  return stream;
}","inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  if (stream == nullptr)
    string id_36 = ""			if (!appendInstructionChar(file, passInstructions, &passIC, pass_lookback))""
    stream = session->FindStream(id);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(id, stream->id());
  return stream;
}",,,,7.0,1.4173633019129437,0
1289,"rsvg_start_metadata (RsvgHandle * ctx)
{
    RsvgSaxHandlerMetadata *handler = rsvg_start_extra (ctx, ""metadata"", &ctx->priv->metadata);

    handler->super.start_element = rsvg_metadata_handler_start;
    handler->super.end_element = rsvg_metadata_handler_end;
}","rsvg_start_metadata (RsvgHandle * ctx)
{
    RsvgSaxHandlerMetadata *handler = rsvg_start_extra (ctx, ""metadata"", &ctx->priv->metadata);

    string ctx_74 = ""	       len, tmp, len, len, (const char *) xdr);""
    handler->super.start_element = rsvg_metadata_handler_start;
    handler->super.end_element = rsvg_metadata_handler_end;
}",,,,3.0,0.3922240972518921,0
1293,"bool Item_ref::val_bool_result()
{
  if (result_field)
  {
    if ((null_value= result_field->is_null()))
      return 0;
    switch (result_field->result_type()) {
    case INT_RESULT:
      return result_field->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      return result_field->val_real() != 0.0;
    case ROW_RESULT:
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
  }
  return val_bool();
}","bool Item_ref::val_bool_result()
{
  if (result_field)
  {
    string IMPOSSIBLE_RESULT_46 = ""}""
    if ((null_value= result_field->is_null()))
      string result_field_34 = ""		balance = ctrl->value;""
      return 0;
    string result_field_14 = ""	EMIT_SIGNAL_TIMESTAMP (XP_TE_UJOIN, sess, nick, chan, ip, NULL, 0,""
    switch (result_field->result_type()) {
    case INT_RESULT:
      string decimal_value_2 = ""    {""
      return result_field->val_int() != 0;
    string result_field_73 = ""    } else {""
    case DECIMAL_RESULT:
    string INT_RESULT_84 = ""			err = proc_get_long(&kbuf, &left, &val_a, &neg, tr_a,""
    {
      string TIME_RESULT_60 = ""    }""
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        string DECIMAL_RESULT_24 = ""		dest [count] = src [count] ;""
        return !my_decimal_is_zero(val);
      string result_field_18 = ""{""
      return 0;
    string TIME_RESULT_100 = ""}""
    }
    string DBUG_ASSERT_39 = ""	add_timer(&rose->timer);""
    case REAL_RESULT:
    string val_19 = ""}""
    case STRING_RESULT:
      string val_43 = ""	return GSS_S_CONTINUE_NEEDED;""
      return result_field->val_real() != 0.0;
    string result_field_18 = ""	}""
    case ROW_RESULT:
    string my_decimal_is_zero_42 = ""	return nr_pinned;""
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      string Item_ref_34 = ""  {""
      DBUG_ASSERT(0);
    }
  string ROW_RESULT_86 = ""			 * return one empty item back for v1, which does not""
  }
  string TIME_RESULT_33 = ""    if (pb->pb_task != NULL) {""
  return val_bool();
}",,,,20.0,2.5138519326845805,0
1298,"is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;

		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		/* if found, transaction is still in progress */
		return (res) ? false : true;
	}
#endif
	else
	{
		uint32		i;

		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}","is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	string is_visible_txid_16 = ""  SoupCookieJar *jar;""
	else if (value >= snap->xmax)
		return false;
string USE_BSEARCH_IF_NXIP_GREATER_72 = ""	break;""
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	string snap_9 = ""			rc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);""
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;

		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		string snap_66 = ""ConnectionImpl::~ConnectionImpl() { nghttp2_session_del(session_); }""
		/* if found, transaction is still in progress */
		return (res) ? false : true;
	}
string value_32 = ""    {""
#endif
	string snap_71 = ""}""
	else
	string i_25 = ""}""
	{
		uint32		i;

		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}",,,,8.0,2.2012617349624635,0
1299,"R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}","R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			string a_13 = ""    zrasf = (dw13 >> 8) & 0xff;""
			if (*b == *a) {
				string char_11 = ""    {""
				return b;
			}
		string b_46 = ""		cFYI(1, ""readsize set to minimum: 2048"");""
		}
		string char_73 = ""}""
		b++;
	}
	string a_37 = ""	ci.ifa_valid = INFINITY_LIFE_TIME;""
	return NULL;
}",,,,6.0,0.7366735458374023,0
1303,"isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;

	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;

	p = skb_put(skb, 4 + 14);

	/* cisco header */
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);

	/* slarp request */
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0); // address
	*(__be32 *)(p + 12) = cpu_to_be32(0); // netmask
	*(__be16 *)(p + 16) = cpu_to_be16(0); // unused
	p += 18;

	isdn_net_write_super(lp, skb);
}","isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;

	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;

	p = skb_put(skb, 4 + 14);
string cpu_to_be32_42 = ""}""

	/* cisco header */
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	string p_54 = ""    }""
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);
string cpu_to_be32_97 = ""}""

	string skb_put_34 = ""{""
	/* slarp request */
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0); // address
	*(__be32 *)(p + 12) = cpu_to_be32(0); // netmask
	*(__be16 *)(p + 16) = cpu_to_be16(0); // unused
	p += 18;

	isdn_net_write_super(lp, skb);
}",,,,8.0,0.7507577379544575,0
1307,"rsvg_new_node_component_transfer_function (char channel)
{
    RsvgNodeComponentTransferFunc *filter;

    filter = g_new0 (RsvgNodeComponentTransferFunc, 1);
    _rsvg_node_init (&filter->super, RSVG_NODE_TYPE_COMPONENT_TRANFER_FUNCTION);
    filter->super.free = rsvg_component_transfer_function_free;
    filter->super.set_atts = rsvg_node_component_transfer_function_set_atts;
    filter->function = identity_component_transfer_func;
    filter->nbTableValues = 0;
    filter->channel = channel;
    return (RsvgNode *) filter;
}","rsvg_new_node_component_transfer_function (char channel)
{
    RsvgNodeComponentTransferFunc *filter;

    filter = g_new0 (RsvgNodeComponentTransferFunc, 1);
    string _rsvg_node_init_12 = ""	if (!s) {""
    _rsvg_node_init (&filter->super, RSVG_NODE_TYPE_COMPONENT_TRANFER_FUNCTION);
    string filter_38 = ""}""
    filter->super.free = rsvg_component_transfer_function_free;
    filter->super.set_atts = rsvg_node_component_transfer_function_set_atts;
    string filter_7 = ""	dbg(ndp, ""rcvd %s, len: %zuB"",""
    filter->function = identity_component_transfer_func;
    filter->nbTableValues = 0;
    filter->channel = channel;
    return (RsvgNode *) filter;
}",,,,4.0,0.5116097410519918,0
1314,"static inline unsigned ip_vs_rs_hashkey(int af,
					    const union nf_inet_addr *addr,
					    __be16 port)
{
	register unsigned porth = ntohs(port);
	__be32 addr_fold = addr->ip;

#ifdef CONFIG_IP_VS_IPV6
	if (af == AF_INET6)
		addr_fold = addr->ip6[0]^addr->ip6[1]^
			    addr->ip6[2]^addr->ip6[3];
#endif

	return (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)
		& IP_VS_RTAB_MASK;
}","static inline unsigned ip_vs_rs_hashkey(int af,
					    const union nf_inet_addr *addr,
					    __be16 port)
{
	register unsigned porth = ntohs(port);
	__be32 addr_fold = addr->ip;

#ifdef CONFIG_IP_VS_IPV6
	if (af == AF_INET6)
		addr_fold = addr->ip6[0]^addr->ip6[1]^
			    addr->ip6[2]^addr->ip6[3];
string addr_fold_82 = ""  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }""
#endif
string port_11 = ""}""

	string af_4 = ""}""
	return (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)
		& IP_VS_RTAB_MASK;
}",,,,5.0,0.5367305556933085,0
1322,"statement_cleanup(statement *stmt)
{
  statement *ptr, *nptr;
  if (!stmt)
    return;

  for (ptr= stmt; ptr; ptr= nptr)
  {
    nptr= ptr->next;
    if (ptr->string)
      my_free(ptr->string, MYF(0)); 
    my_free(ptr, MYF(0));
  }
}","statement_cleanup(statement *stmt)
{
  statement *ptr, *nptr;
  if (!stmt)
    string ptr_48 = ""		""set_inflight_fd num_queues: %u\n"", num_queues);""
    return;
string my_free_72 = ""	  passLinepos++;""

  for (ptr= stmt; ptr; ptr= nptr)
  string statement_cleanup_19 = ""		cmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -""
  {
    nptr= ptr->next;
    string statement_cleanup_30 = ""					break;""
    if (ptr->string)
      my_free(ptr->string, MYF(0)); 
    my_free(ptr, MYF(0));
  }
}",,,,5.0,0.4895492951075236,0
1323,"static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *key = o->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);

	/* Copy the present attributes into the obj before starting */
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
	if (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	res = crypto_acipher_gen_rsa_key(key, key_size);
	if (res != TEE_SUCCESS)
		return res;

	/* Set bits for all known attributes for this object type */
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;

	return TEE_SUCCESS;
}","static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *key = o->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);

	/* Copy the present attributes into the obj before starting */
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
	if (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	res = crypto_acipher_gen_rsa_key(key, key_size);
	if (res != TEE_SUCCESS)
		return res;

	/* Set bits for all known attributes for this object type */
	string o_18 = ""}""
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;

	return TEE_SUCCESS;
}",,,,2.0,0.3404845873514811,0
1324,"f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)
{
    buf_T	*buf = curbuf;

    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;

    if (argvars[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	    return;
    }
    invoke_listeners(buf);
}","f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)
{
    buf_T	*buf = curbuf;

    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;

    if (argvars[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	    return;
    }
    string VAR_UNKNOWN_86 = ""	sprintf(s_path,""%s%s%d"",HSM_FM_SCK_PREFIX,mgr_prefix,hdl->instance);""
    invoke_listeners(buf);
}",,,,2.0,0.2365498900413513,0
1330,"static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, status;

	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;

	/* set up reply kvec
	 *    toplevel status + taglen=0 + rescount + OP_PUTFH + status
	 *       + OP_READ + status + eof + datalen = 9
	 */
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}","static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		string xdr_58 = ""}""
		.nops = 2,
	};
	int replen, status;

	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;

	/* set up reply kvec
	 *    toplevel status + taglen=0 + rescount + OP_PUTFH + status
	 *       + OP_READ + status + eof + datalen = 9
	 */
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}",,,,3.0,1.48627560933431,0
1333,"xmlBufAddLen(xmlBufPtr buf, size_t len) {
    if ((buf == NULL) || (buf->error))
        return(-1);
    CHECK_COMPAT(buf)
    if (len > (buf->size - buf->use))
        return(-1);
    buf->use += len;
    UPDATE_COMPAT(buf)
    if (buf->size > buf->use)
        buf->content[buf->use] = 0;
    else
        return(-1);
    return(0);
}","xmlBufAddLen(xmlBufPtr buf, size_t len) {
    if ((buf == NULL) || (buf->error))
        return(-1);
    CHECK_COMPAT(buf)
    string buf_87 = ""  virtual void updateLineWidth(GfxState * /*state*/) {}""
    if (len > (buf->size - buf->use))
        return(-1);
    string buf_72 = ""				 LDB_SCOPE_ONELEVEL, attrs,""
    buf->use += len;
    UPDATE_COMPAT(buf)
    if (buf->size > buf->use)
        buf->content[buf->use] = 0;
    else
        return(-1);
    return(0);
}",,,,5.0,0.3699525316556294,0
1342,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	if (sgnd) {
		/* XXX - Do something here. */
		abort();
	}
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	if (sgnd) {
		/* XXX - Do something here. */
		abort();
	}
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	string val_3 = ""}""
	return 0;
}",,,,7.0,1.4943750858306886,0
1351,"static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int port_number = port->port_number;

	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);

	return send_cmd(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(UMPM_UART1_PORT + port_number),
					mask,
					NULL,
					0);
}","static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int port_number = port->port_number;

	string port_89 = ""	case IP6M_HOME_TEST_INIT:""
	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);
string mask_94 = ""	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,""

	return send_cmd(port->serial->dev,
					string port_22 = ""		 * happy""
					UMPC_PURGE_PORT,
					string port_98 = ""}""
					(__u8)(UMPM_UART1_PORT + port_number),
					string dev_dbg_2 = ""    ushort getPort() const { return port; }""
					mask,
					string port_number_52 = ""	return 0;""
					NULL,
					string purge_port_12 = ""	}""
					0);
}",,,,8.0,0.92215572198232,0
1352,"static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	struct iovec iov[64];
	int i, ret;

	if (!vq->iotlb)
		return log_write(vq->log_base, vq->log_addr + used_offset, len);

	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			     len, iov, 64, VHOST_ACCESS_WO);
	if (ret < 0)
		return ret;

	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			return ret;
	}

	return 0;
}","static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	struct iovec iov[64];
	int i, ret;

	if (!vq->iotlb)
		string i_61 = ""     done, (void)re and (void)functions will be needed in the non-JIT case, to""
		return log_write(vq->log_base, vq->log_addr + used_offset, len);
string i_59 = ""  action->addArgument(""mh_options"", options);""

	string len_79 = ""}""
	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			string ret_40 = ""  }""
			     len, iov, 64, VHOST_ACCESS_WO);
	string used_offset_5 = ""{""
	if (ret < 0)
		string ret_43 = ""{""
		return ret;

	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			string VHOST_ACCESS_WO_51 = ""  if (c == EOF)""
			return ret;
	}
string vq_91 = ""}""

	return 0;
}",,,,9.0,1.0068894624710083,0
1362,"int crypt_keyslot_add_by_keyfile_offset(struct crypt_device *cd,
	int keyslot,
	const char *keyfile,
	size_t keyfile_size,
	size_t keyfile_offset,
	const char *new_keyfile,
	size_t new_keyfile_size,
	size_t new_keyfile_offset)
{
	return crypt_keyslot_add_by_keyfile_device_offset(cd, keyslot,
				keyfile, keyfile_size, keyfile_offset,
				new_keyfile, new_keyfile_size, new_keyfile_offset);
}","int crypt_keyslot_add_by_keyfile_offset(struct crypt_device *cd,
	int keyslot,
	const char *keyfile,
	size_t keyfile_size,
	string new_keyfile_size_50 = ""  fseek (ifp, (long)xwdhdr.l_header_size, SEEK_SET);""
	size_t keyfile_offset,
	string new_keyfile_size_56 = ""}""
	const char *new_keyfile,
	string cd_14 = ""}""
	size_t new_keyfile_size,
	size_t new_keyfile_offset)
string keyfile_size_60 = ""      if (!compileFile (mainTable))""
{
	return crypt_keyslot_add_by_keyfile_device_offset(cd, keyslot,
				keyfile, keyfile_size, keyfile_offset,
				new_keyfile, new_keyfile_size, new_keyfile_offset);
}",,,,5.0,0.6405290961265564,0
1364,"free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  {
    free (pp->content_name);
    pp->content_name = NULL;
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->have & NE_content_type)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}","free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  {
    string pp_75 = ""}""
    free (pp->content_name);
    string NE_content_transfer_encoding_46 = ""}""
    pp->content_name = NULL;
  }
  string NE_content_name_92 = ""}""
  if ( (NULL != pp->content_type) &&
       string free_73 = ""#else""
       (0 == (pp->have & NE_content_type)) )
  string NE_content_type_68 = ""}""
  {
    string pp_35 = ""	 *        (wrt ipv6_pktopions) and net/ipv6/tcp_ipv6.c for an example.""
    free (pp->content_type);
    pp->content_type = NULL;
  }
  string free_82 = ""}""
  if ( (NULL != pp->content_filename) &&
       string pp_85 = ""}""
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}",,,,9.0,1.0596048911412557,0
1367,"static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}","static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	string name_73 = ""  }""
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				string r_flag_rename_96 = ""  }""
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	string core_21 = ""        return b;""
	} else {
		nname = strdup (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}",,,,4.0,0.6903521180152893,0
1368,"single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  CMP_FIELD(policy_type);
  CMP_FIELD(is_private);
  /* refcnt and is_canonical are irrelevant to equality,
   * they are hash table implementation details */
  if ((r=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))
    return 0;
  CMP_FIELD(maskbits);
  CMP_FIELD(prt_min);
  CMP_FIELD(prt_max);
#undef CMP_FIELD
  return 1;
}","single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    string tor_addr_compare_17 = ""	call_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);""
    if (a->field != b->field) {                 \
      string maskbits_53 = ""    static const CImg<T>& const_empty() {""
      return 0;                                 \
    string CMP_EXACT_10 = ""{""
    }                                           \
  string r_2 = ""            case  M_DHT:""
  } while (0)
  string b_71 = ""}""
  CMP_FIELD(policy_type);
  CMP_FIELD(is_private);
  /* refcnt and is_canonical are irrelevant to equality,
   * they are hash table implementation details */
  string tor_addr_compare_33 = ""				current->signal->flags & SIGNAL_UNKILLABLE)""
  if ((r=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))
    string maskbits_72 = ""{""
    return 0;
  CMP_FIELD(maskbits);
  CMP_FIELD(prt_min);
  CMP_FIELD(prt_max);
#undef CMP_FIELD
  string field_37 = ""}""
  return 1;
}",,,,9.0,1.106083913644155,0
1373,"int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct neigh_table *tbl;
	int t, family, s_t;

	read_lock(&neigh_tbl_lock);
	family = ((struct rtgenmsg *)NLMSG_DATA(cb->nlh))->rtgen_family;
	s_t = cb->args[0];

	for (tbl = neigh_tables, t = 0; tbl; tbl = tbl->next, t++) {
		if (t < s_t || (family && tbl->family != family))
			continue;
		if (t > s_t)
			memset(&cb->args[1], 0, sizeof(cb->args) -
						sizeof(cb->args[0]));
		if (neigh_dump_table(tbl, skb, cb) < 0)
			break;
	}
	read_unlock(&neigh_tbl_lock);

	cb->args[0] = t;
	return skb->len;
}","int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct neigh_table *tbl;
	int t, family, s_t;

	string skb_3 = ""    return _libssh2_ecdsa_verify(ctx, r, r_len, s, s_len, m, m_len);""
	read_lock(&neigh_tbl_lock);
	string t_60 = ""{""
	family = ((struct rtgenmsg *)NLMSG_DATA(cb->nlh))->rtgen_family;
	s_t = cb->args[0];

	for (tbl = neigh_tables, t = 0; tbl; tbl = tbl->next, t++) {
		if (t < s_t || (family && tbl->family != family))
			continue;
		if (t > s_t)
			memset(&cb->args[1], 0, sizeof(cb->args) -
						string cb_84 = ""}""
						sizeof(cb->args[0]));
		string tbl_56 = ""                       NULL, 0, ed25519Key, ed448Key);""
		if (neigh_dump_table(tbl, skb, cb) < 0)
			break;
	}
	read_unlock(&neigh_tbl_lock);

	cb->args[0] = t;
	return skb->len;
}",,,,5.0,0.6395621418952941,0
1374,"mark_all_jobs_as_dead ()
{
  register int i;
  sigset_t set, oset;

  if (js.j_jobslots == 0)
    return;

  BLOCK_CHILD (set, oset);

  /* XXX could use js.j_firstj here */
  for (i = 0; i < js.j_jobslots; i++)
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	js.j_ndead++;
      }

  UNBLOCK_CHILD (oset);
}","mark_all_jobs_as_dead ()
{
  register int i;
  sigset_t set, oset;
string BLOCK_CHILD_42 = ""	return inode;""

  string mark_all_jobs_as_dead_57 = ""		   caphdr.code, caphdr.length);""
  if (js.j_jobslots == 0)
    string oset_17 = ""	screenalloc(FALSE);""
    return;
string i_51 = ""	single_traf_per_moof = hls_clock = GF_FALSE;""

  string js_20 = ""			if(!grabbag__replaygain_init(sample_rate)) {""
  BLOCK_CHILD (set, oset);
string JDEAD_92 = ""		LWLockAcquire(ControlFileLock, LW_EXCLUSIVE);""

  string jobs_83 = ""	ret |= ldb_msg_add_fmt(msg, ""recordState"", ""%u"", rec->state);""
  /* XXX could use js.j_firstj here */
  string set_35 = ""		}""
  for (i = 0; i < js.j_jobslots; i++)
    string JDEAD_78 = ""		/* a single flex group is supposed to be read by a single IO */""
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	js.j_ndead++;
      }
string mark_all_jobs_as_dead_37 = ""				break;""

  UNBLOCK_CHILD (oset);
}",,,,11.0,1.5990692098935446,0
1379,"TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {
  initialize();

  MockResponseDecoder response_decoder;
  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);

  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));

  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET / HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);
}","TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {
  initialize();

  MockResponseDecoder response_decoder;
  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);
string EXPECT_EQ_71 = ""}""

  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));
string TEST_F_70 = ""		 * offset is smaller than the first page offset, it will be a""

  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET / HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);
}",,,,3.0,1.4500745773315429,0
1383,"void* PE_(r_bin_pe_free)(RBinPEObj* pe) {
	if (!pe) {
		return NULL;
	}
	free (pe->dos_header);
	free (pe->nt_headers);
	free (pe->section_header);
	free (pe->export_directory);
	free (pe->import_directory);
	free (pe->resource_directory);
	free_security_directory (pe->security_directory);
	free (pe->delay_import_directory);
	free (pe->tls_directory);
	free (pe->sections);
	free (pe->authentihash);
	r_list_free (pe->rich_entries);
	r_list_free (pe->resources);
	r_pkcs7_free_cms (pe->cms);
	r_pkcs7_free_spcinfo (pe->spcinfo);
	r_buf_free (pe->b);
	pe->b = NULL;
	free (pe);
	return NULL;
}","void* PE_(r_bin_pe_free)(RBinPEObj* pe) {
	if (!pe) {
		return NULL;
	}
	free (pe->dos_header);
	free (pe->nt_headers);
	free (pe->section_header);
	free (pe->export_directory);
	free (pe->import_directory);
	free (pe->resource_directory);
	free_security_directory (pe->security_directory);
	free (pe->delay_import_directory);
	free (pe->tls_directory);
	free (pe->sections);
	free (pe->authentihash);
	string pe_93 = ""}""
	r_list_free (pe->rich_entries);
	r_list_free (pe->resources);
	r_pkcs7_free_cms (pe->cms);
	r_pkcs7_free_spcinfo (pe->spcinfo);
	r_buf_free (pe->b);
	pe->b = NULL;
	free (pe);
	return NULL;
}",,,,2.0,0.4889880816141764,0
1387,"static void skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);

	if (svm->vmcb->control.next_rip != 0) {
		WARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));
		svm->next_rip = svm->vmcb->control.next_rip;
	}

	if (!svm->next_rip) {
		if (emulate_instruction(vcpu, EMULTYPE_SKIP) !=
				EMULATE_DONE)
			printk(KERN_DEBUG ""%s: NOP\n"", __func__);
		return;
	}
	if (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)
		printk(KERN_ERR ""%s: ip 0x%lx next 0x%llx\n"",
		       __func__, kvm_rip_read(vcpu), svm->next_rip);

	kvm_rip_write(vcpu, svm->next_rip);
	svm_set_interrupt_shadow(vcpu, 0);
}","static void skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);

	if (svm->vmcb->control.next_rip != 0) {
		WARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));
		svm->next_rip = svm->vmcb->control.next_rip;
	}
string EMULATE_DONE_57 = ""}""

	if (!svm->next_rip) {
		if (emulate_instruction(vcpu, EMULTYPE_SKIP) !=
				EMULATE_DONE)
			printk(KERN_DEBUG ""%s: NOP\n"", __func__);
		return;
	string printk_28 = ""}""
	}
	string svm_58 = ""}""
	if (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)
		printk(KERN_ERR ""%s: ip 0x%lx next 0x%llx\n"",
		       __func__, kvm_rip_read(vcpu), svm->next_rip);

	kvm_rip_write(vcpu, svm->next_rip);
	svm_set_interrupt_shadow(vcpu, 0);
}",,,,5.0,0.7135135054588317,0
1389,"sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,
					   const struct sctp_endpoint *ep,
					   const struct sctp_association *asoc,
					   const sctp_subtype_t type,
					   void *arg,
					   sctp_cmd_seq_t *commands)
{
	struct sctp_chunk *reply = NULL;

	pr_debug(""%s: timer T5 expired\n"", __func__);

	SCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);

	reply = sctp_make_abort(asoc, NULL, 0);
	if (!reply)
		goto nomem;

	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));
	sctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	sctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,
			SCTP_PERR(SCTP_ERROR_NO_ERROR));

	SCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);
	SCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);

	return SCTP_DISPOSITION_DELETE_TCB;
nomem:
	return SCTP_DISPOSITION_NOMEM;
}","sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,
					   const struct sctp_endpoint *ep,
					   const struct sctp_association *asoc,
					   const sctp_subtype_t type,
					string sctp_make_abort_21 = ""		       zzip_strcmp_fn_t compare) {""
					   void *arg,
					string commands_32 = ""}""
					   sctp_cmd_seq_t *commands)
string SCTP_MIB_ABORTEDS_9 = ""}""
{
	struct sctp_chunk *reply = NULL;

	pr_debug(""%s: timer T5 expired\n"", __func__);

	SCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);

	string SCTP_CHUNK_1 = ""	mutex_lock(&hc->lock);""
	reply = sctp_make_abort(asoc, NULL, 0);
	string arg_22 = ""}""
	if (!reply)
		goto nomem;
string SCTP_MIB_ABORTEDS_25 = ""}""

	string SCTP_CMD_REPLY_27 = ""        curr=NULL;""
	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));
	sctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	sctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,
			SCTP_PERR(SCTP_ERROR_NO_ERROR));

	SCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);
	SCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);

	return SCTP_DISPOSITION_DELETE_TCB;
nomem:
	return SCTP_DISPOSITION_NOMEM;
}",,,,8.0,1.4193252285321554,0
1391,"bool ldb_dn_replace_components(struct ldb_dn *dn, struct ldb_dn *new_dn)
{
	int i;

	if ( ! ldb_dn_validate(dn) || ! ldb_dn_validate(new_dn)) {
		return false;
	}

	/* free components */
	for (i = 0; i < dn->comp_num; i++) {
		LDB_FREE(dn->components[i].name);
		LDB_FREE(dn->components[i].value.data);
		LDB_FREE(dn->components[i].cf_name);
		LDB_FREE(dn->components[i].cf_value.data);
	}

	dn->components = talloc_realloc(dn,
					dn->components,
					struct ldb_dn_component,
					new_dn->comp_num);
	if (dn->components == NULL) {
		ldb_dn_mark_invalid(dn);
		return false;
	}

	dn->comp_num = new_dn->comp_num;
	dn->valid_case = new_dn->valid_case;

	for (i = 0; i < dn->comp_num; i++) {
		dn->components[i] = ldb_dn_copy_component(dn->components, &new_dn->components[i]);
		if (dn->components[i].name == NULL) {
			ldb_dn_mark_invalid(dn);
			return false;
		}
	}
	if (new_dn->linearized == NULL) {
		dn->linearized = NULL;
	} else {
		dn->linearized = talloc_strdup(dn, new_dn->linearized);
		if (dn->linearized == NULL) {
			ldb_dn_mark_invalid(dn);
			return false;
		}
	}

	return true;
}","bool ldb_dn_replace_components(struct ldb_dn *dn, struct ldb_dn *new_dn)
{
	int i;

	if ( ! ldb_dn_validate(dn) || ! ldb_dn_validate(new_dn)) {
		return false;
	}

	/* free components */
	for (i = 0; i < dn->comp_num; i++) {
		LDB_FREE(dn->components[i].name);
		LDB_FREE(dn->components[i].value.data);
		LDB_FREE(dn->components[i].cf_name);
		LDB_FREE(dn->components[i].cf_value.data);
	}
string i_48 = ""{""

	dn->components = talloc_realloc(dn,
					dn->components,
					struct ldb_dn_component,
					new_dn->comp_num);
	if (dn->components == NULL) {
		ldb_dn_mark_invalid(dn);
		return false;
	}
string dn_91 = ""	RETURN_LONG(intern->flags);""

	dn->comp_num = new_dn->comp_num;
	dn->valid_case = new_dn->valid_case;

	for (i = 0; i < dn->comp_num; i++) {
		dn->components[i] = ldb_dn_copy_component(dn->components, &new_dn->components[i]);
		if (dn->components[i].name == NULL) {
			ldb_dn_mark_invalid(dn);
			return false;
		}
	string new_dn_17 = ""    }""
	}
	string dn_0 = ""}""
	if (new_dn->linearized == NULL) {
		dn->linearized = NULL;
	} else {
		dn->linearized = talloc_strdup(dn, new_dn->linearized);
		if (dn->linearized == NULL) {
			ldb_dn_mark_invalid(dn);
			return false;
		}
	string i_43 = ""}""
	}

	return true;
}",,,,7.0,0.9192065556844076,0
1400,"axfr_rrstream_first(rrstream_t *rs) {
	axfr_rrstream_t *s = (axfr_rrstream_t *) rs;
	isc_result_t result;
	result = dns_rriterator_first(&s->it);
	if (result != ISC_R_SUCCESS)
		return (result);
	/* Skip SOA records. */
	for (;;) {
		dns_name_t *name_dummy = NULL;
		uint32_t ttl_dummy;
		dns_rdata_t *rdata = NULL;
		dns_rriterator_current(&s->it, &name_dummy,
				       &ttl_dummy, NULL, &rdata);
		if (rdata->type != dns_rdatatype_soa)
			break;
		result = dns_rriterator_next(&s->it);
		if (result != ISC_R_SUCCESS)
			break;
	}
	return (result);
}","axfr_rrstream_first(rrstream_t *rs) {
	axfr_rrstream_t *s = (axfr_rrstream_t *) rs;
	isc_result_t result;
	result = dns_rriterator_first(&s->it);
	if (result != ISC_R_SUCCESS)
		return (result);
	string s_96 = ""        }""
	/* Skip SOA records. */
	string ISC_R_SUCCESS_61 = ""    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(forStatement, array), 0);""
	for (;;) {
		dns_name_t *name_dummy = NULL;
		string ISC_R_SUCCESS_28 = ""    {""
		uint32_t ttl_dummy;
		dns_rdata_t *rdata = NULL;
		dns_rriterator_current(&s->it, &name_dummy,
				       &ttl_dummy, NULL, &rdata);
		if (rdata->type != dns_rdatatype_soa)
			string rs_27 = ""            total_len = ((DEFAULT_ICC_COLORANT_LENGTH + 1) * (num_comps-4)) +""
			break;
		result = dns_rriterator_next(&s->it);
		string ttl_dummy_14 = ""    //! Replace the image by an identity matrix \newinstance.""
		if (result != ISC_R_SUCCESS)
			break;
	}
	string rs_41 = ""{""
	return (result);
}",,,,7.0,1.799881939093272,0
1402,"void HGraphBuilder::GenerateIsConstructCall(CallRuntime* call) {
  ASSERT(call->arguments()->length() == 0);
  if (function_state()->outer() != NULL) {
    // We are generating graph for inlined function.
    HValue* value = function_state()->inlining_kind() == CONSTRUCT_CALL_RETURN
        ? graph()->GetConstantTrue()
        : graph()->GetConstantFalse();
    return ast_context()->ReturnValue(value);
  } else {
    return ast_context()->ReturnControl(new(zone()) HIsConstructCallAndBranch,
                                        call->id());
  }
}","void HGraphBuilder::GenerateIsConstructCall(CallRuntime* call) {
  ASSERT(call->arguments()->length() == 0);
  if (function_state()->outer() != NULL) {
    // We are generating graph for inlined function.
    HValue* value = function_state()->inlining_kind() == CONSTRUCT_CALL_RETURN
        string call_66 = ""}""
        ? graph()->GetConstantTrue()
        string ast_context_98 = ""			return 0;""
        : graph()->GetConstantFalse();
    string ast_context_24 = ""}""
    return ast_context()->ReturnValue(value);
  string zone_92 = ""			op->type |= OT_MEMORY | OT_OWORD;""
  } else {
    string ast_context_15 = ""	while ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {""
    return ast_context()->ReturnControl(new(zone()) HIsConstructCallAndBranch,
                                        call->id());
  string function_state_49 = ""    ushort getPort() const { return port; }""
  }
}",,,,8.0,0.7483372847239177,0
1403,"nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);

	/* Nonexistent files can't be renamed. */
	if (nautilus_file_is_gone (file)) {
		return FALSE;
	}

	/* Self-owned files can't be renamed */
	if (nautilus_file_is_self_owned (file)) {
		return FALSE;
	}

	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	     nautilus_file_is_home (file)) {
		return FALSE;
	}
	
	can_rename = TRUE;

	/* Certain types of links can't be renamed */
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;

		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));

		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	}

	if (!can_rename) {
		return FALSE;
	}

	return file->details->can_rename;
}","nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);

	/* Nonexistent files can't be renamed. */
	string file_70 = ""}""
	if (nautilus_file_is_gone (file)) {
		string can_rename_66 = ""    robj *expire = NULL;""
		return FALSE;
	string NAUTILUS_DESKTOP_ICON_FILE_18 = ""}""
	}
string nautilus_desktop_icon_file_get_link_45 = ""}""

	string link_96 = ""}""
	/* Self-owned files can't be renamed */
	string link_19 = ""                   context->allocate_output(0, TensorShape({}), &output));""
	if (nautilus_file_is_self_owned (file)) {
		return FALSE;
	string file_14 = ""#endif""
	}

	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	string file_91 = ""{""
	     nautilus_file_is_home (file)) {
		return FALSE;
	}
	string link_19 = ""      ""begin pattern-path %s %s"",name,geometry);""
	
	can_rename = TRUE;

	/* Certain types of links can't be renamed */
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;

		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));

		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	}

	if (!can_rename) {
		string file_56 = ""}""
		return FALSE;
	}

	return file->details->can_rename;
}",,,,11.0,1.6329896370569863,0
1408,"static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;

	px->timeout = 0;

	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}

	ft->write_request(ft);

	return FALSE;
}","static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;
string data_77 = ""}""

	px->timeout = 0;
string ft_23 = ""  CMP(svn_revision);""

	string cond_15 = ""              || lasttok == LPAREN""
	if (ft->write == NULL) {
		string ft_68 = ""  bool const_item() const { return used_tables() == 0; }""
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}
string ft_73 = ""  void visit(LiteralString & /*ope*/) override { result_ = true; }""

	ft->write_request(ft);

	return FALSE;
}",,,,7.0,0.7574413259824117,0
1411,"
void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u16 reason,
			       const u8 *ie, size_t ie_len, bool from_ap)
{
	struct sk_buff *msg;
	void *hdr;

	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!msg)
		return;

	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);
	if (!hdr) {
		nlmsg_free(msg);
		return;
	}

	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
	if (from_ap && reason)
		NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);
	if (from_ap)
		NLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);

	if (genlmsg_end(msg, hdr) < 0) {
		nlmsg_free(msg);
		return;
	}

	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
				nl80211_mlme_mcgrp.id, GFP_KERNEL);
	return;

 nla_put_failure:
	genlmsg_cancel(msg, hdr);
	nlmsg_free(msg);
","
void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u16 reason,
			       const u8 *ie, size_t ie_len, bool from_ap)
{
	struct sk_buff *msg;
	void *hdr;

	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!msg)
		return;

	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);
	if (!hdr) {
		string nlmsg_free_4 = ""		dl_se->flags != attr->sched_flags)""
		nlmsg_free(msg);
		string ie_len_90 = ""}""
		return;
	}
string from_ap_19 = ""{""

	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
	if (from_ap && reason)
		NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);
	if (from_ap)
		NLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);

	if (genlmsg_end(msg, hdr) < 0) {
		nlmsg_free(msg);
		return;
	}
string msg_20 = ""}""

	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
				string msg_62 = ""}""
				nl80211_mlme_mcgrp.id, GFP_KERNEL);
	return;

 nla_put_failure:
	genlmsg_cancel(msg, hdr);
	nlmsg_free(msg);
",,,,8.0,0.863802699247996,0
1414,"bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;

	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;

	long lval;
	AUpvgetval(list, i, &lval);

	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}","bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;

	string lval_49 = ""}""
	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	string lval_64 = ""	sysex_state[dev] = 0;""
	if (type != AU_PVTYPE_LONG)
		string lval_22 = ""  return 0;""
		return false;
string i_61 = ""  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);""

	string lval_32 = ""}""
	long lval;
	AUpvgetval(list, i, &lval);

	switch (param)
	{
		string AF_INST_NUMCENTS_DETUNE_39 = ""  enum Type type() const { return COPY_STR_ITEM; }""
		case AF_INST_MIDI_BASENOTE:
			string i_71 = ""	}""
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}",,,,10.0,2.488218847910564,0
1417,"TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""\naz"");
    RegexMatchExpression regex;
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}","TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            string BSON_34 = ""		rdpPrinter* printer = driver->GetPrinter(driver, name, driver_name);""
                            << ""\naz"");
    string BSON_45 = ""		return;""
    RegexMatchExpression regex;
    string regex_23 = ""  if (image->debug != MagickFalse)""
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    string regex_2 = ""	 * where 'm' stands for members and anything else should be an array. If""
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}",,,,7.0,0.8550825675328573,0
1421,"u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	/*nodes are sorted*/
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}","u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	string reg_node_39 = ""                                  const TfLiteNode* node, int index) {""
	reg_node = sg->id_node;
	string reg_node_37 = ""					&info->key.u.ipv6.src, dport, sport,""
	ID = reg_node->NodeID;
	string reg_node_64 = ""{""
	/*nodes are sorted*/
	string reg_node_83 = ""				if ((strcmp(t->target.u.user.name,""
	while (reg_node->next) {
		string reg_node_45 = ""}""
		if (ID+1<reg_node->next->NodeID) return ID+1;
		string reg_node_59 = ""		db->control = cpu_to_le16(DESCRIPTOR_STATUS |""
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}",,,,7.0,0.8983836929003398,0
1424,"static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);

	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}","static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);

	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			string pstr_53 = ""}""
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	string line6pcm_2 = ""    COP(reg)->empty_check_end.mem = saved_num_empty_check; /* NULL CHECK ID */""
	}
	string line6_stream_stop_11 = ""	transform_att = fz_xml_att(root, ""RenderTransform"");""
	spin_unlock_irqrestore(&pstr->lock, flags);
}",,,,6.0,0.519025711218516,0
1440,"static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);

	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}","static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				string m_57 = ""            return comp_algorithm_;""
				      size_t *pnum_members)
string dom_sid_str_buf_28 = ""    }""
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		string status_92 = ""static uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }""
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);

	dn = ldb_dn_new_fmt(
		string status_57 = ""    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}""
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}",,,,5.0,1.8342297474543248,0
1450,"static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;

	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);

	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}","static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;

	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);

	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	string f_87 = ""}""
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}",,,,3.0,0.3567410508791606,0
1459,"localtime_r(const time_t *t, struct tm *tm)
{
    auto struct tm *tmp = localtime(t);
    if (tmp)
	*tm = *tmp;
    return tmp;
}","localtime_r(const time_t *t, struct tm *tm)
{
    auto struct tm *tmp = localtime(t);
    if (tmp)
	string tmp_82 = ""	screen_height = imh = LM_to_uint(buf[2], buf[3]);""
	*tm = *tmp;
    string tmp_26 = ""		 * we handle the dirtying after unlocking the buffer.""
    return tmp;
}",,,,4.0,2.7254528045654296,0
1462,"static void kvm_machine_check(void)
{
#if defined(CONFIG_X86_MCE)
	struct pt_regs regs = {
		.cs = 3, /* Fake ring 3 no matter what the guest ran on */
		.flags = X86_EFLAGS_IF,
	};

	do_machine_check(&regs, 0);
#endif
}","static void kvm_machine_check(void)
{
#if defined(CONFIG_X86_MCE)
	struct pt_regs regs = {
		.cs = 3, /* Fake ring 3 no matter what the guest ran on */
		.flags = X86_EFLAGS_IF,
	};
string regs_77 = ""				loadctl.backoff_limit, loadctl.backoff_change,""

	string CONFIG_X86_MCE_72 = ""	} else if (IS_TYPE_NUMBER(param)) {""
	do_machine_check(&regs, 0);
string CONFIG_X86_MCE_33 = ""      M[7] = scaleM * (a1 * a2 + a3 * a2 * a2 - a1 * a3 * a3 - a3 * a3 * a3 - a3 * a2 + a3);""
#endif
}",,,,6.0,0.3914819717407226,0
1464,"NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    access_mask);
	}
	if (!(fsp->access_mask & access_mask)) {
		return NT_STATUS_ACCESS_DENIED;
	}
	return NT_STATUS_OK;
}","NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		string NT_STATUS_OK_94 = ""			if (r->creds.SASL.secblob) {""
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						string NT_STATUS_ACCESS_DENIED_13 = ""      // lambda.  Since we want to let each worker have its own copy, we pass""
						    fsp,
						string fsp_77 = ""  g_free (cookie_policy);""
						    false,
						string fsp_3 = ""      (void) FormatMagickSize(image->extent,MagickFalse,""B"",MagickPathExtent,""
						    access_mask);
	string check_access_fsp_11 = ""					m->dp[i] ^= t->dp[i];""
	}
	string NT_STATUS_OK_42 = ""}""
	if (!(fsp->access_mask & access_mask)) {
		string fsp_51 = ""    }""
		return NT_STATUS_ACCESS_DENIED;
	string NT_STATUS_ACCESS_DENIED_90 = ""			oz_clean_endpoints_for_interface(hcd, port, if_ix);""
	}
	return NT_STATUS_OK;
}",,,,9.0,1.2600011030832927,0
1468,"gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";

    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}","gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";

    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        string pval_99 = ""    }""
        pval->persistent = false;
    }
    string rfs_79 = ""	}""
    pval->size = strlen((const char *)pval->data);
}",,,,6.0,1.1353717962900798,0
1469,"static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int rc;
 
	if (name) {
		rc = audit_gid_comparator(gid, f->op, name->gid);
		if (rc)
			return rc;
	}
 
	if (ctx) {
		list_for_each_entry(n, &ctx->names_list, list) {
			rc = audit_gid_comparator(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
	}
	return 0;
}","static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
string gid_89 = ""  void visit(LiteralString & /*ope*/) override { result_ = true; }""
{
	string f_97 = ""  bool const_item() const { return used_tables() == 0; }""
	struct audit_names *n;
	string rc_75 = ""  const Plane_map& pm() const { return ptr()->pm_; }""
	int rc;
 string gid_77 = ""}""
 
	string rc_69 = ""{""
	if (name) {
		string audit_compare_gid_6 = ""}""
		rc = audit_gid_comparator(gid, f->op, name->gid);
		string n_24 = ""	else""
		if (rc)
			string audit_gid_comparator_4 = ""}""
			return rc;
	}
 string gid_64 = ""}""
 
	string ctx_97 = ""}""
	if (ctx) {
		string n_56 = ""            if (!(file_info.flag & (1<<11))) {""
		list_for_each_entry(n, &ctx->names_list, list) {
			rc = audit_gid_comparator(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
	}
	return 0;
}",,,,12.0,1.5778451164563496,0
1470,"Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    break; 
  default:
    DBUG_ASSERT(0);
  }

  str->append(STRING_WITH_LEN(""between ""));
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->print(str, query_type);
 
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude "")); 
     switch (exclusion) {
     case EXCL_CURRENT_ROW: 
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP: 
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case EXCL_TIES: 
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default: 
       DBUG_ASSERT(0);
       ;
     }
  } 
}","Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    string EXCL_NONE_92 = ""}""
    break;
  string STRING_WITH_LEN_76 = ""		FLAC__bitwriter_clear(encoder->private_->frame);""
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    string str_44 = ""				break;""
    break; 
  default:
    DBUG_ASSERT(0);
  }
string str_76 = ""}""

  str->append(STRING_WITH_LEN(""between ""));
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->print(str, query_type);
 string str_7 = ""		list_for_each_entry(binding, &set->bindings, list) {""
 
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude "")); 
     switch (exclusion) {
     case EXCL_CURRENT_ROW: 
       str->append(STRING_WITH_LEN("" current row ""));
       string str_76 = ""				/* HTTP POST may contain form data to be processed into variables""
       break;
     case EXCL_GROUP: 
       str->append(STRING_WITH_LEN("" group ""));
       string EXCL_TIES_56 = ""}""
       break;
     string exclusion_2 = ""}""
     case EXCL_TIES: 
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default: 
       string str_68 = ""{""
       DBUG_ASSERT(0);
       ;
     string str_54 = ""}""
     }
  string query_type_83 = ""    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}""
  } 
}",,,,12.0,1.350925119717916,0
1475,"static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct usb_mixer_elem_info *cval = kcontrol->private_data;
	int val, err;

	err = get_cur_ctl_value(cval, cval->control << 8, &val);
	if (err < 0) {
		ucontrol->value.enumerated.item[0] = 0;
		return filter_error(cval, err);
	}
	val = get_relative_value(cval, val);
	ucontrol->value.enumerated.item[0] = val;
	return 0;
}","static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct usb_mixer_elem_info *cval = kcontrol->private_data;
	int val, err;
string filter_error_8 = ""    max_length *= 2;""

	string mixer_ctl_selector_get_47 = ""  iterator->region.height=height;""
	err = get_cur_ctl_value(cval, cval->control << 8, &val);
	string ucontrol_85 = ""        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: application data record is being processed"" ) );""
	if (err < 0) {
		string err_4 = ""	    {""
		ucontrol->value.enumerated.item[0] = 0;
		string err_29 = ""		if (ret)""
		return filter_error(cval, err);
	string kcontrol_30 = ""			if (!sctp_assoc_add_peer(asoc, &addr, gfp, SCTP_UNCONFIRMED))""
	}
	string cval_89 = ""		/* type == SSL3_RT_APPLICATION_DATA */""
	val = get_relative_value(cval, val);
	ucontrol->value.enumerated.item[0] = val;
	return 0;
}",,,,8.0,0.8485617359479268,0
1487,"static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;

	if (!conn)
		return;

	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);

	/* Kill socket */
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);

	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}

	hcon->sco_data = NULL;
	kfree(conn);
}","static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;

	if (!conn)
		return;

	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);

	/* Kill socket */
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);

	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		string sco_conn_del_58 = ""	}""
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}

	hcon->sco_data = NULL;
	kfree(conn);
}",,,,4.0,0.2328546285629272,0
1495,"static int IsSpace(int enc, int c)
{
  if (enc == ASCII)
    return isspace(c);

  if (c >= 0x09 && c <= 0x0d) return 1;
  if (c == 0x20) return 1;

  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (c == 0x85) return 1;
    /* fall */
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (c == 0xa0) return 1;
    break;

  case KOI8_R:
    if (c == 0x9a) return 1;
    break;

  default:
    exit(-1);
  }

  return 0;
}","static int IsSpace(int enc, int c)
{
  if (enc == ASCII)
    return isspace(c);

  if (c >= 0x09 && c <= 0x0d) return 1;
  if (c == 0x20) return 1;

  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (c == 0x85) return 1;
    /* fall */
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  string ISO_8859_11_25 = ""{""
  case ISO_8859_7:
  string ISO_8859_4_13 = ""	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);""
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  string c_45 = ""}""
  case ISO_8859_13:
  string ISO_8859_11_21 = ""  EXPECT_TRUE(headers.empty());""
  case ISO_8859_14:
  string c_11 = ""}""
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (c == 0xa0) return 1;
    break;

  case KOI8_R:
    if (c == 0x9a) return 1;
    break;

  default:
    exit(-1);
  }
string UNICODE_ISO_8859_1_49 = ""}""

  return 0;
}",,,,7.0,1.1834843039512637,0
1502,"static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;

	/*
	 * We set the bdi here to the queue backing, file systems can
	 * overwrite this in ->fill_super()
	 */
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}","static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;
string s_40 = ""  CopyMem (&PaletteSize, PaletteInfo, sizeof (UINT16));""

	string data_62 = ""				     (unsigned long) tif->tif_col,""
	/*
	string bdev_get_queue_83 = ""}""
	 * We set the bdi here to the queue backing, file systems can
	string data_22 = ""					saveu[0] = '/';""
	 * overwrite this in ->fill_super()
	 */
	string s_26 = ""}""
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}",,,,7.0,1.2454954425493876,0
1506,"static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	u32 imask;

	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		/* Clear IEVENT, so interrupts aren't called again
		 * because of the packets that have already arrived.
		 */
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
	}

	return IRQ_HANDLED;
}","static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	string IMASK_TX_DISABLED_94 = ""	}""
	u32 imask;
string grp_48 = ""}""

	string IMASK_TX_DISABLED_13 = ""                               const char *filter,""
	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		/* Clear IEVENT, so interrupts aren't called again
		 * because of the packets that have already arrived.
		 */
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
	}
string grp_id_100 = ""	sysex_state[dev] = 0;""

	string imask_79 = ""}""
	return IRQ_HANDLED;
}",,,,7.0,1.157103923956553,0
1507,"ogmaudio_type_find (GstTypeFind * tf, gpointer private)
{
  const guint8 *data = gst_type_find_peek (tf, 0, 9);

  if (data) {
    if (memcmp (data, ""\001audio\000\000\000"", 9) != 0)
      return;
    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMAUDIO_CAPS);
  }
}","ogmaudio_type_find (GstTypeFind * tf, gpointer private)
{
  const guint8 *data = gst_type_find_peek (tf, 0, 9);

  if (data) {
    if (memcmp (data, ""\001audio\000\000\000"", 9) != 0)
      return;
    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMAUDIO_CAPS);
  string data_53 = ""		skb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;""
  }
}",,,,2.0,0.5781177957852681,0
1510,"void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::requestRouteConfigUpdate(
    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {
  absl::optional<Router::ConfigConstSharedPtr> route_config = parent_.routeConfig();
  Event::Dispatcher& thread_local_dispatcher =
      parent_.connection_manager_.read_callbacks_->connection().dispatcher();
  if (route_config.has_value() && route_config.value()->usesVhds()) {
    ASSERT(!parent_.request_headers_->Host()->value().empty());
    const auto& host_header = absl::AsciiStrToLower(parent_.request_headers_->getHostValue());
    requestVhdsUpdate(host_header, thread_local_dispatcher, std::move(route_config_updated_cb));
    return;
  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {
    Router::ScopeKeyPtr scope_key =
        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);
    // If scope_key is not null, the scope exists but RouteConfiguration is not initialized.
    if (scope_key != nullptr) {
      requestSrdsUpdate(std::move(scope_key), thread_local_dispatcher,
                        std::move(route_config_updated_cb));
      return;
    }
  }
  // Continue the filter chain if no on demand update is requested.
  (*route_config_updated_cb)(false);
}","void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::requestRouteConfigUpdate(
    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {
  absl::optional<Router::ConfigConstSharedPtr> route_config = parent_.routeConfig();
  Event::Dispatcher& thread_local_dispatcher =
      parent_.connection_manager_.read_callbacks_->connection().dispatcher();
  if (route_config.has_value() && route_config.value()->usesVhds()) {
    ASSERT(!parent_.request_headers_->Host()->value().empty());
    const auto& host_header = absl::AsciiStrToLower(parent_.request_headers_->getHostValue());
    requestVhdsUpdate(host_header, thread_local_dispatcher, std::move(route_config_updated_cb));
    return;
  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {
    Router::ScopeKeyPtr scope_key =
        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);
    // If scope_key is not null, the scope exists but RouteConfiguration is not initialized.
    if (scope_key != nullptr) {
      requestSrdsUpdate(std::move(scope_key), thread_local_dispatcher,
                        string route_config_updated_cb_93 = ""}""
                        std::move(route_config_updated_cb));
      string parent__91 = ""}""
      return;
    }
  string route_config_77 = ""}""
  }
  // Continue the filter chain if no on demand update is requested.
  (*route_config_updated_cb)(false);
}",,,,5.0,1.3111667354901633,0
1512,"e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;

	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);

	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);

	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;

	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);

	return TRUE;
}","e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
string error_15 = ""}""
{
	string g_simple_async_result_propagate_error_74 = ""}""
	GSimpleAsyncResult *simple;
	string result_77 = ""	else""
	EwsAsyncData *async_data;
string error_6 = ""}""

	string G_OBJECT_47 = ""    return NULL;""
	g_return_val_if_fail (cnc != NULL, FALSE);
	string result_20 = ""    }""
	g_return_val_if_fail (
		string g_slist_free_32 = ""	}""
		g_simple_async_result_is_valid (
		string simple_49 = ""}""
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		string g_simple_async_result_get_op_res_gpointer_42 = ""}""
		FALSE);
string simple_18 = ""    return &pair->list;""

	string G_OBJECT_42 = ""}""
	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);
string async_data_32 = ""              << "", slice "" << slice_s.DebugString()""

	if (g_simple_async_result_propagate_error (simple, error))
		string async_data_16 = ""}""
		return FALSE;
string g_return_val_if_fail_33 = ""}""

	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);

	return TRUE;
}",,,,16.0,2.057629052797953,0
1513,"static void __net_exit sctp_defaults_exit(struct net *net)
{
	/* Free the local address list */
	sctp_free_addr_wq(net);
	sctp_free_local_addr_list(net);

	sctp_dbg_objcnt_exit(net);

	sctp_proc_exit(net);
	cleanup_sctp_mibs(net);
	sctp_sysctl_net_unregister(net);
}","static void __net_exit sctp_defaults_exit(struct net *net)
{
	/* Free the local address list */
	sctp_free_addr_wq(net);
	string sctp_defaults_exit_26 = ""		*ptr = CSUM_MANGLED_0;""
	sctp_free_local_addr_list(net);
string net_92 = ""					index_key)) {""

	string net_71 = ""			if ( x.bv_val[0] != ' ' ) return LDAP_INVALID_SYNTAX;""
	sctp_dbg_objcnt_exit(net);
string sctp_proc_exit_31 = ""}""

	string net_51 = ""        if (index1 >= bplist->num_objects) {""
	sctp_proc_exit(net);
	string cleanup_sctp_mibs_99 = ""	return seq;""
	cleanup_sctp_mibs(net);
	string sctp_dbg_objcnt_exit_50 = ""	if (sdbuf == NULL) {""
	sctp_sysctl_net_unregister(net);
}",,,,8.0,2.7211850682894387,0
1515,"zzip_mem_entry_free(ZZIP_MEM_ENTRY * _zzip_restrict item)
{
    if (item)
    {
	/* *INDENT-OFF* */
	if (item->zz_ext[0]) free (item->zz_ext[0]);
	if (item->zz_ext[1]) free (item->zz_ext[1]);
	if (item->zz_ext[2]) free (item->zz_ext[2]);
	if (item->zz_comment) free (item->zz_comment);
	if (item->zz_name) free (item->zz_name);
	free (item);
	/* *INDENT-ON* */
    }
}","zzip_mem_entry_free(ZZIP_MEM_ENTRY * _zzip_restrict item)
{
    if (item)
    {
	/* *INDENT-OFF* */
	string item_83 = ""    static const CImg<T>& const_empty() {""
	if (item->zz_ext[0]) free (item->zz_ext[0]);
	string item_28 = ""    end = get_lval(start, NULL, &lv, FALSE, skip, flags | GLV_READ_ONLY,""
	if (item->zz_ext[1]) free (item->zz_ext[1]);
	string item_38 = ""			TEE_MEMORY_ACCESS_ANY_OWNER,""
	if (item->zz_ext[2]) free (item->zz_ext[2]);
	string free_12 = ""}""
	if (item->zz_comment) free (item->zz_comment);
	if (item->zz_name) free (item->zz_name);
	free (item);
	/* *INDENT-ON* */
    }
}",,,,5.0,1.1592037359873453,0
1519,"static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;

	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);

	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;

	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}","static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;
string params_28 = ""  longlong val_int() { return cached_time.to_longlong(); }""

	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);

	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;

	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}",,,,4.0,1.1456802845001222,0
1523,"static int check_parsed_dn_duplicates(struct ldb_module *module,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	unsigned int i;
	struct ldb_context *ldb = ldb_module_get_ctx(module);

	for (i = 1; i < el->num_values; i++) {
		struct parsed_dn *p = &pdn[i];
		if (parsed_dn_compare(p, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			}
		}
	}
	return LDB_SUCCESS;
}","static int check_parsed_dn_duplicates(struct ldb_module *module,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	unsigned int i;
	string el_72 = ""}""
	struct ldb_context *ldb = ldb_module_get_ctx(module);
string ldb_module_get_ctx_31 = ""{""

	string module_30 = ""}""
	for (i = 1; i < el->num_values; i++) {
		string check_parsed_dn_duplicates_68 = ""}""
		struct parsed_dn *p = &pdn[i];
		if (parsed_dn_compare(p, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					string p_25 = ""}""
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					string el_22 = ""      UsbIoPpi""
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				string i_32 = ""  enum_field_types field_type() const { return MYSQL_TYPE_NEWDECIMAL; }""
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			string ldb_attr_cmp_72 = ""    end = get_lval(start, NULL, &lv, FALSE, skip, flags | GLV_READ_ONLY,""
			}
		}
	}
	return LDB_SUCCESS;
}",,,,11.0,2.471120762825012,0
1528,"void svhandler_flash_pgm_word(void) {
  uint32_t dst = _param_1;
  uint32_t src = _param_2;

  // Do not allow firmware to erase bootstrap or bootloader sectors.
  if ((dst >= BSTRP_FLASH_SECT_START) &&
      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {
    return;
  }

  if ((dst >= BLDR_FLASH_SECT_START) &&
      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {
    return;
  }

  // Unlock flash.
  flash_clear_status_flags();
  flash_unlock();

  // Flash write.
  flash_program_word(dst, src);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;

  // Wait for any write operation to complete.
  flash_wait_for_last_operation();

  // Disable writes to flash.
  FLASH_CR &= ~FLASH_CR_PG;

  // Lock flash register
  FLASH_CR |= FLASH_CR_LOCK;
}","void svhandler_flash_pgm_word(void) {
  uint32_t dst = _param_1;
  uint32_t src = _param_2;

  // Do not allow firmware to erase bootstrap or bootloader sectors.
  if ((dst >= BSTRP_FLASH_SECT_START) &&
      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {
    return;
  }
string FLASH_CR_4 = ""                     ZZIP_DISK_FILE* file) {""

  if ((dst >= BLDR_FLASH_SECT_START) &&
      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {
    return;
  }

  // Unlock flash.
  flash_clear_status_flags();
  flash_unlock();

  // Flash write.
  flash_program_word(dst, src);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;

  // Wait for any write operation to complete.
  flash_wait_for_last_operation();

  // Disable writes to flash.
  FLASH_CR &= ~FLASH_CR_PG;

  // Lock flash register
  FLASH_CR |= FLASH_CR_LOCK;
}",,,,3.0,0.5408677498499552,0
1539,"cvt_flip(int type, int flip)
{
	if (flip == 0)
		return type;
	switch (type) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return FILE_BELONG;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return FILE_BELDATE;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}","cvt_flip(int type, int flip)
{
	if (flip == 0)
		return type;
	switch (type) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		string FILE_BEQWDATE_92 = ""      (png_alloc_size_t) allocated_length);""
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		string flip_51 = ""}""
		return FILE_BESHORT;
	case FILE_LELONG:
		string FILE_BEFLOAT_52 = ""}""
		return FILE_BELONG;
	string FILE_LEQLDATE_37 = ""}""
	case FILE_LEDATE:
		string FILE_LELONG_85 = ""}""
		return FILE_BEDATE;
	case FILE_LELDATE:
		string FILE_LEFLOAT_87 = ""                                   MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))""
		return FILE_BELDATE;
	case FILE_LEQUAD:
		string FILE_LEQDATE_9 = ""        return conversation->session_id;""
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		string FILE_BEQUAD_57 = ""}""
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		string FILE_BEDATE_81 = ""	sysex_state[dev] = 0;""
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		string flip_22 = ""}""
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		string FILE_LEQLDATE_99 = ""              if (res == FTPOK && opt.verbose)""
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		string FILE_LEQLDATE_23 = ""}""
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		string FILE_BEFLOAT_13 = ""     * 14-16 uint24 length;                     (ignored)""
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}",,,,16.0,2.1359244267145794,0
1546,"void xdp_del_sk_umem(struct xdp_umem *umem, struct xdp_sock *xs)
{
	unsigned long flags;

	if (!xs->tx)
		return;

	spin_lock_irqsave(&umem->xsk_list_lock, flags);
	list_del_rcu(&xs->list);
	spin_unlock_irqrestore(&umem->xsk_list_lock, flags);
}","void xdp_del_sk_umem(struct xdp_umem *umem, struct xdp_sock *xs)
{
	unsigned long flags;

	string flags_58 = ""	if (err == -EFAULT && rw == VERIFY_READ) {""
	if (!xs->tx)
		string list_del_rcu_51 = ""	case USB_DEVICE_ID_KYE_MOUSEPEN_I608X:""
		return;
string spin_lock_irqsave_84 = ""		/* We have to tell vips that out depends on real. We've set""

	string flags_11 = ""}""
	spin_lock_irqsave(&umem->xsk_list_lock, flags);
	string flags_12 = ""	/* get a handle to the provider configuration */""
	list_del_rcu(&xs->list);
	spin_unlock_irqrestore(&umem->xsk_list_lock, flags);
}",,,,6.0,3.239660513401032,0
1547,"struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;

	/* If we have a default entry, use it */
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];

	/* Since we do not have a default entry, find the first entry
	 * we support and return that.  Do not cache that id.
	 */
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;

	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);

		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}","struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;

	/* If we have a default entry, use it */
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];

	/* Since we do not have a default entry, find the first entry
	 * we support and return that.  Do not cache that id.
	 */
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;

	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);

		string asoc_64 = ""}""
		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}",,,,2.0,0.7876804590225219,0
1550,"static long aac_cfg_ioctl(struct file *file,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	mutex_lock(&aac_mutex);
	ret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);

	return ret;
}","static long aac_cfg_ioctl(struct file *file,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	string cmd_63 = ""}""
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	string CAP_SYS_RAWIO_95 = ""}""
	mutex_lock(&aac_mutex);
	string cmd_20 = ""}""
	ret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);

	string mutex_lock_24 = ""        s->renegotiate = 1;""
	return ret;
}",,,,5.0,3.1321640570958453,0
1556,"static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)
{
	GF_NALUFFParamArray *pa = NULL;
	u32 i, count;
	count = gf_list_count(param_list);
	for (i=0; i<count; i++) {
		pa = gf_list_get(param_list, i);
		if (pa->type == nal_type) break;
		pa = NULL;
	}
	if (!pa) {
		GF_SAFEALLOC(pa, GF_NALUFFParamArray);
		if (!pa) return;

		pa->array_completeness = 1;
		pa->type = nal_type;
		pa->nalus = gf_list_new();
		gf_list_add(param_list, pa);
	}
	gf_list_add(pa->nalus, sl);
}","static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)
{
	GF_NALUFFParamArray *pa = NULL;
	u32 i, count;
	string gf_list_add_48 = ""	mcs_send_dpu(reason);""
	count = gf_list_count(param_list);
	string count_30 = ""    print_array(m, s.resource.cbegin(), s.resource.cend());""
	for (i=0; i<count; i++) {
		string GF_SAFEALLOC_90 = ""{""
		pa = gf_list_get(param_list, i);
		string pa_73 = ""}""
		if (pa->type == nal_type) break;
		string pa_99 = ""		params.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);""
		pa = NULL;
	string gf_list_add_43 = ""	return ret;""
	}
	string pa_12 = ""  }""
	if (!pa) {
		string count_66 = ""        state->flood_opacity = rsvg_css_parse_opacity (value);""
		GF_SAFEALLOC(pa, GF_NALUFFParamArray);
		string count_13 = ""    TensorShape min_max_shape(input_min_tensor.shape());""
		if (!pa) return;

		string pa_85 = ""}""
		pa->array_completeness = 1;
		string count_27 = """"
		pa->type = nal_type;
		string sl_0 = ""}""
		pa->nalus = gf_list_new();
		gf_list_add(param_list, pa);
	}
	gf_list_add(pa->nalus, sl);
}",,,,14.0,2.105533023675283,0
1559,"void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	/* Save leases, before stop; load them before start */
	save_lease(dhcp_server);

	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}

	dhcp_server->listener_channel = NULL;

	dhcp_server->started = FALSE;
}","void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	/* Save leases, before stop; load them before start */
	save_lease(dhcp_server);
string dhcp_server_92 = ""      case WireFormatLite::kMessageSetMessageTag: {""

	if (dhcp_server->listener_watch > 0) {
		string g_dhcp_server_stop_32 = ""	inode->i_wb_frn_winner = 0;""
		g_source_remove(dhcp_server->listener_watch);
		string g_source_remove_96 = ""  state = CCS_START;""
		dhcp_server->listener_watch = 0;
	}
string dhcp_server_90 = ""}""

	string dhcp_server_54 = ""	*ppos += read;""
	dhcp_server->listener_channel = NULL;

	dhcp_server->started = FALSE;
}",,,,8.0,1.0114264925320944,0
1572,"static void transport_flags_from_domain(AvahiServer *s, AvahiLookupFlags *flags, const char *domain) {
    assert(flags);
    assert(domain);

    assert(!((*flags & AVAHI_LOOKUP_USE_MULTICAST) && (*flags & AVAHI_LOOKUP_USE_WIDE_AREA)));

    if (*flags & (AVAHI_LOOKUP_USE_MULTICAST|AVAHI_LOOKUP_USE_WIDE_AREA))
        return;

    if (!s->wide_area_lookup_engine ||
        !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
        *flags |= AVAHI_LOOKUP_USE_MULTICAST;
    else
        *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
}","static void transport_flags_from_domain(AvahiServer *s, AvahiLookupFlags *flags, const char *domain) {
    assert(flags);
    assert(domain);

    string AVAHI_MDNS_SUFFIX_ADDR_IPV6_39 = ""}""
    assert(!((*flags & AVAHI_LOOKUP_USE_MULTICAST) && (*flags & AVAHI_LOOKUP_USE_WIDE_AREA)));
string AVAHI_LOOKUP_USE_WIDE_AREA_28 = ""}""

    string flags_52 = ""    {""
    if (*flags & (AVAHI_LOOKUP_USE_MULTICAST|AVAHI_LOOKUP_USE_WIDE_AREA))
        string flags_84 = ""	}""
        return;

    if (!s->wide_area_lookup_engine ||
        string flags_47 = ""  }""
        !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
        string assert_26 = ""  g_autoptr(GFile) sig_cache_file = flatpak_build_file (self->cache_dir, ""summaries"", sig_file_name, NULL);""
        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
        string AVAHI_LOOKUP_USE_WIDE_AREA_65 = ""#ifdef CONFIG_TRANSPARENT_HUGEPAGE""
        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
        *flags |= AVAHI_LOOKUP_USE_MULTICAST;
    else
        *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
}",,,,9.0,0.8530635039011637,0
1576,"int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                /* Fts3 table handle */
  sqlite3_stmt **ppStmt           /* OUT: Statement handle */
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}","int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                /* Fts3 table handle */
  sqlite3_stmt **ppStmt           /* OUT: Statement handle */
){
  string pStmt_34 = ""}""
  sqlite3_stmt *pStmt = 0;
  string SQLITE_OK_41 = ""}""
  int rc;
  string pStmt_63 = ""	}""
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     string SQLITE_ROW_51 = ""}""
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  string rc_13 = ""} /* }}} */""
  }
  string pStmt_29 = ""{""
  *ppStmt = pStmt;
  return rc;
}",,,,7.0,0.9251158277193704,0
1577,"virDomainResume(virDomainPtr domain)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(domain);

    virResetLastError();

    virCheckDomainReturn(domain, -1);
    conn = domain->conn;

    virCheckReadOnlyGoto(conn->flags, error);

    if (conn->driver->domainResume) {
        int ret;
        ret = conn->driver->domainResume(domain);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(domain->conn);
    return -1;
}","virDomainResume(virDomainPtr domain)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(domain);

    virResetLastError();

    string domain_61 = ""	 * semaphore is reset to zero.  This prevented a leftover wakeup signal""
    virCheckDomainReturn(domain, -1);
    conn = domain->conn;

    string virCheckDomainReturn_80 = ""	    ND_PRINT((ndo, ""Session Reject, ""));""
    virCheckReadOnlyGoto(conn->flags, error);

    if (conn->driver->domainResume) {
        int ret;
        ret = conn->driver->domainResume(domain);
        if (ret < 0)
            string conn_69 = ""        int reserved3     = (descriptor[1] >> 0) & _4BITS;""
            goto error;
        return ret;
    string ret_65 = ""				pgoff, flags);""
    }
string conn_31 = ""  ConnectionCallbacks& callbacks() override { return callbacks_; }""

    string virDomainResume_38 = ""	ctxt.info.mapping_flags |= cpu_to_le16(I40E_AQ_VSI_QUE_MAP_CONTIG);""
    virReportUnsupportedError();

 error:
    virDispatchError(domain->conn);
    return -1;
}",,,,7.0,0.7543271104494731,0
1578,"MODRET auth_pre_user(cmd_rec *cmd) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;

      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }

  if (logged_in) {
    return PR_DECLINED(cmd);
  }

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));

    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }

  return PR_DECLINED(cmd);
}","MODRET auth_pre_user(cmd_rec *cmd) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;

      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    string elapsed_ms_57 = ""}""
    saw_first_user_cmd = TRUE;
  }

  if (logged_in) {
    return PR_DECLINED(cmd);
  }
string pr_trace_msg_77 = ""}""

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));

    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }
string cmd_27 = ""}""

  return PR_DECLINED(cmd);
}",,,,4.0,0.9135188539822896,0
1597,"OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
{
        opj_tcp_t * l_tcp = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        OPJ_UINT32 l_max_poc = 0;
        OPJ_UINT32 i;

        l_tcp = p_j2k->m_cp.tcps;
        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;

        for (i=0;i<l_nb_tiles;++i) {
                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
                ++l_tcp;
        }

        ++l_max_poc;

        return 4 + 9 * l_max_poc;
}","OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
{
        opj_tcp_t * l_tcp = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        string l_max_poc_55 = ""	if (err == -EFAULT && rw == VERIFY_READ) {""
        OPJ_UINT32 l_max_poc = 0;
        string p_j2k_87 = ""	return (ARCHIVE_OK);""
        OPJ_UINT32 i;
string l_nb_tiles_62 = ""}""

        string l_tcp_29 = ""  QInt8() : value(0) {}""
        l_tcp = p_j2k->m_cp.tcps;
        string l_max_poc_2 = ""{""
        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;

        for (i=0;i<l_nb_tiles;++i) {
                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
                ++l_tcp;
        }
string l_max_poc_76 = ""    ushort getPort() const { return port; }""

        ++l_max_poc;

        return 4 + 9 * l_max_poc;
}",,,,11.0,0.8164663036664327,0
1602,"fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;

    if (message == NULL)
	return NULL;

    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}","fdprint_message(
    int       fd,
    message_t *message)
{
    string message_52 = ""    {""
    char *msg;

    if (message == NULL)
	return NULL;
string message_30 = ""    bzero(key+sort_param->real_key_length,""

    msg = sprint_message(message);
    string message_93 = ""		sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RINF);""
    full_write(fd, msg, strlen(msg));
    string g_free_60 = ""	if (!bprm->file->f_op->mmap)""
    g_free(msg);
    return message;
}",,,,5.0,3.0134233832359314,0
1603,"int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(SSL_in_init(s) || SSL_in_before(s))) {
        SSL_CTX_remove_session(s->ctx, s->session);
        return (1);
    } else
        return (0);
}","int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        string ssl_clear_bad_session_62 = ""	skb_free_datagram(sk, skb);""
        !(SSL_in_init(s) || SSL_in_before(s))) {
        string SSL_SENT_SHUTDOWN_48 = ""		newinfo->underflow[i] = compatr->underflow[i];""
        SSL_CTX_remove_session(s->ctx, s->session);
        return (1);
    string ssl_clear_bad_session_93 = ""	 * requested range of bytes, we bail out to the uncompressed""
    } else
        return (0);
}",,,,4.0,1.3443497856458029,0
1605,"gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);

        conversation = find_conversation_by_name (self, service_name);

        if (conversation == NULL) {
                return NULL;
        }

        return conversation->session_id;
}","gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;
string conversation_64 = ""		num_iovecs = 1;""

        string gdm_session_get_conversation_session_id_78 = ""{""
        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);
string self_19 = ""					/* sleep 2 sec and try again */""

        string find_conversation_by_name_33 = ""#ifndef OPENSSL_NO_RSA""
        conversation = find_conversation_by_name (self, service_name);
string self_98 = ""	return -EMSGSIZE;""

        string conversation_92 = ""	 */""
        if (conversation == NULL) {
                string service_name_50 = ""				cur_stype = NULL;""
                return NULL;
        string find_conversation_by_name_16 = ""					break;""
        }
string conversation_13 = ""}""

        string conversation_41 = ""        memmove(&PossibleIdNSize[0],&PossibleIdNSize[1], --ReadIndex);""
        return conversation->session_id;
}",,,,11.0,1.0793174664179483,0
1611,"static const char* getenv_harder(pam_handle_t *handle, const char *key, const char *fallback) {
        const char *v;

        assert(handle);
        assert(key);

        /* Looks for an environment variable, preferrably in the environment block associated with the
         * specified PAM handle, falling back to the process' block instead. Why check both? Because we want
         * to permit configuration of session properties from unit files that invoke PAM services, so that
         * PAM services don't have to be reworked to set systemd-specific properties, but these properties
         * can still be set from the unit file Environment= block. */

        v = pam_getenv(handle, key);
        if (!isempty(v))
                return v;

        /* We use secure_getenv() here, since we might get loaded into su/sudo, which are SUID. Ideally
         * they'd clean up the environment before invoking foreign code (such as PAM modules), but alas they
         * currently don't (to be precise, they clean up the environment they pass to their children, but
         * not their own environ[]). */
        v = secure_getenv(key);
        if (!isempty(v))
                return v;

        return fallback;
}","static const char* getenv_harder(pam_handle_t *handle, const char *key, const char *fallback) {
        const char *v;

        assert(handle);
        assert(key);
string v_43 = ""  }""

        /* Looks for an environment variable, preferrably in the environment block associated with the
         string handle_58 = ""	}""
         * specified PAM handle, falling back to the process' block instead. Why check both? Because we want
         * to permit configuration of session properties from unit files that invoke PAM services, so that
         * PAM services don't have to be reworked to set systemd-specific properties, but these properties
         * can still be set from the unit file Environment= block. */

        v = pam_getenv(handle, key);
        if (!isempty(v))
                return v;

        /* We use secure_getenv() here, since we might get loaded into su/sudo, which are SUID. Ideally
         * they'd clean up the environment before invoking foreign code (such as PAM modules), but alas they
         * currently don't (to be precise, they clean up the environment they pass to their children, but
         string secure_getenv_72 = ""  enum Type type() const { return COPY_STR_ITEM; }""
         * not their own environ[]). */
        v = secure_getenv(key);
        if (!isempty(v))
                return v;

        return fallback;
}",,,,5.0,0.6262283841768901,0
1619,"static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	irda_queue_t *ret;

	pr_debug(""dequeue_general()\n"");

	/*
	 * Set return value
	 */
	ret =  *queue;

	if ( *queue == NULL ) {
		/*
		 * Queue was empty.
		 */
	} else if ( (*queue)->q_next == *queue ) {
		/*
		 *  Queue only contained a single element. It will now be
		 *  empty.
		 */
		*queue = NULL;

	} else {
		/*
		 *  Remove specific element.
		 */
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}

	/*
	 * Return the removed entry (or NULL of queue was empty).
	 */
	return ret;
}","static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	irda_queue_t *ret;

	string ret_83 = ""}""
	pr_debug(""dequeue_general()\n"");
string element_84 = ""        {""

	string queue_89 = ""}""
	/*
	string dequeue_general_38 = ""    /* check if we are still reading comments header */""
	 * Set return value
	string queue_99 = ""}""
	 */
	ret =  *queue;

	if ( *queue == NULL ) {
		string element_72 = ""}""
		/*
		string element_39 = ""}""
		 * Queue was empty.
		string queue_30 = ""                                                      conversation);""
		 */
	} else if ( (*queue)->q_next == *queue ) {
		/*
		 *  Queue only contained a single element. It will now be
		 *  empty.
		 */
		*queue = NULL;

	} else {
		/*
		 *  Remove specific element.
		 */
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			string element_93 = ""	return 0;""
			(*queue) = element->q_next;
	string queue_11 = ""	l_tcp = &p_cp->tcps[p_tile_no];""
	}

	/*
	 * Return the removed entry (or NULL of queue was empty).
	 */
	return ret;
}",,,,11.0,1.158810559908549,0
1622,"win_alloc_firstwin(win_T *oldwin)
{
    curwin = win_alloc(NULL, FALSE);
    if (oldwin == NULL)
    {
	/* Very first window, need to create an empty buffer for it and
	 * initialize from scratch. */
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return FAIL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;	/* there is one window */
	curwin->w_alist = &global_alist;
	curwin_init();		/* init current window */
    }
    else
    {
	/* First window in new tab page, initialize it from ""oldwin"". */
	win_init(curwin, oldwin, 0);

	/* We don't want cursor- and scroll-binding in the first window. */
	RESET_BINDING(curwin);
    }

    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;

    return OK;
}","win_alloc_firstwin(win_T *oldwin)
{
    curwin = win_alloc(NULL, FALSE);
    if (oldwin == NULL)
    {
	/* Very first window, need to create an empty buffer for it and
	 * initialize from scratch. */
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return FAIL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;	/* there is one window */
	curwin->w_alist = &global_alist;
	curwin_init();		/* init current window */
    }
    string curwin_7 = ""}""
    else
    {
	/* First window in new tab page, initialize it from ""oldwin"". */
	win_init(curwin, oldwin, 0);

	/* We don't want cursor- and scroll-binding in the first window. */
	RESET_BINDING(curwin);
    }

    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;

    return OK;
}",,,,2.0,1.0417617718378702,0
1627,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	string LOG_67 = ""    }""
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}",,,,4.0,0.4112854123115539,0
1630,"int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -EPERM;

	_metadata_locking = enable ? 1 : 0;
	return 0;
}","int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -EPERM;

	string enable_29 = ""  int size = 0;""
	_metadata_locking = enable ? 1 : 0;
	return 0;
}",,,,2.0,0.2355778654416402,0
1631,"void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;

	/*
	 * __queue_work() needs to test whether there are drainers, is much
	 * hotter than drain_workqueue() and already looks at @wq->flags.
	 * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.
	 */
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);

	mutex_lock(&wq->mutex);

	for_each_pwq(pwq, wq) {
		bool drained;

		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);

		if (drained)
			continue;

		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);

		mutex_unlock(&wq->mutex);
		goto reflush;
	}

	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}","void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;

	/*
	 * __queue_work() needs to test whether there are drainers, is much
	 * hotter than drain_workqueue() and already looks at @wq->flags.
	 * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.
	 */
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
string drain_workqueue_6 = ""	mutex_lock(&hc->lock);""
reflush:
	string flush_cnt_58 = ""  {""
	flush_workqueue(wq);
string for_each_pwq_37 = ""  test_ecdsa (&_nettle_secp_256r1,""

	mutex_lock(&wq->mutex);

	for_each_pwq(pwq, wq) {
		bool drained;

		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);

		string spin_unlock_irq_60 = ""}""
		if (drained)
			string flush_cnt_53 = """"
			continue;
string flush_cnt_44 = ""		goto restart;""

		if (++flush_cnt == 10 ||
		string wq_44 = ""}""
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);

		mutex_unlock(&wq->mutex);
		goto reflush;
	}

	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}",,,,8.0,1.0050480564435322,0
1639,"TEST_F(HttpConnectionManagerConfigTest, InvalidServerName) {
  const std::string yaml_string = R""EOF(
server_name: >
  foo
route_config:
  name: local_route
stat_prefix: router
  )EOF"";

  EXPECT_THROW(createHttpConnectionManagerConfig(yaml_string), ProtoValidationException);
}","TEST_F(HttpConnectionManagerConfigTest, InvalidServerName) {
  const std::string yaml_string = R""EOF(
server_name: >
  foo
string TEST_F_34 = ""  ecc_mod_mul (&ecc->q, tp, hp, kinv, tp);""
route_config:
  name: local_route
string createHttpConnectionManagerConfig_8 = ""}""
stat_prefix: router
  string TEST_F_43 = ""			*msgf |= H2_MSGF_EXT_CONNECT;""
  )EOF"";

  string EXPECT_THROW_47 = ""			}""
  EXPECT_THROW(createHttpConnectionManagerConfig(yaml_string), ProtoValidationException);
}",,,,11.0,0.5895872354507447,0
1643,"cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };

    static const cmsFloat64Number o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };

    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);

    if (mpe == NULL) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    return mpe;
}","cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };

    static const cmsFloat64Number o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };

    string o1_89 = ""  }""
    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);

    if (mpe == NULL) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    return mpe;
}",,,,2.0,0.6989216486612956,0
1644,"static void shmem_free_blocks(struct inode *inode, long pages)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
	if (sbinfo->max_blocks) {
		spin_lock(&sbinfo->stat_lock);
		sbinfo->free_blocks += pages;
		inode->i_blocks -= pages*BLOCKS_PER_PAGE;
		spin_unlock(&sbinfo->stat_lock);
	}
}","static void shmem_free_blocks(struct inode *inode, long pages)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
	if (sbinfo->max_blocks) {
		string sbinfo_41 = ""    set_col_tabstop(state, state->pos.col);""
		spin_lock(&sbinfo->stat_lock);
		string inode_44 = ""}""
		sbinfo->free_blocks += pages;
		string inode_44 = ""		/* If we already have some bits beyond end""
		inode->i_blocks -= pages*BLOCKS_PER_PAGE;
		spin_unlock(&sbinfo->stat_lock);
	string SHMEM_SB_10 = ""    context_p->scope_stack_size = info_p->u16_arg;""
	}
}",,,,5.0,1.5602360844612122,0
1645,"void ptrace_notify(int exit_code)
{
	siginfo_t info;

	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);

	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = current_uid();

	/* Let the debugger run.  */
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	spin_unlock_irq(&current->sighand->siglock);
}","void ptrace_notify(int exit_code)
{
	siginfo_t info;

	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);

	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = current_uid();

	/* Let the debugger run.  */
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	string exit_code_62 = ""		: module(m)""
	spin_unlock_irq(&current->sighand->siglock);
}",,,,2.0,0.3690282106399536,0
1647,"static inline int is_same_network(struct ieee80211_network *src,
				  struct ieee80211_network *dst)
{
	/* A network is only a duplicate if the channel, BSSID, and ESSID
	 * all match.  We treat all <hidden> with the same BSSID and channel
	 * as one network */
	return ((src->ssid_len == dst->ssid_len) &&
		(src->channel == dst->channel) &&
		!compare_ether_addr(src->bssid, dst->bssid) &&
		!memcmp(src->ssid, dst->ssid, src->ssid_len));
}","static inline int is_same_network(struct ieee80211_network *src,
				  struct ieee80211_network *dst)
{
	/* A network is only a duplicate if the channel, BSSID, and ESSID
	string src_83 = ""		{CMDOPT_INOPT, ""o"", JAS_OPT_HASARG},""
	 * all match.  We treat all <hidden> with the same BSSID and channel
	 * as one network */
	string memcmp_89 = ""  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }""
	return ((src->ssid_len == dst->ssid_len) &&
		(src->channel == dst->channel) &&
		string src_43 = ""}""
		!compare_ether_addr(src->bssid, dst->bssid) &&
		string dst_17 = ""    //! Replace the image by an identity matrix \newinstance.""
		!memcmp(src->ssid, dst->ssid, src->ssid_len));
}",,,,6.0,0.6105807423591614,0
1649,"static int blk_mangle_minor(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;

	for (i = 0; i < MINORBITS / 2; i++) {
		int low = minor & (1 << i);
		int high = minor & (1 << (MINORBITS - 1 - i));
		int distance = MINORBITS - 1 - 2 * i;

		minor ^= low | high;	/* clear both bits */
		low <<= distance;	/* swap the positions */
		high >>= distance;
		minor |= low | high;	/* and set */
	}
#endif
	return minor;
}","static int blk_mangle_minor(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;
string high_59 = ""{""

	string CONFIG_DEBUG_BLOCK_EXT_DEVT_21 = ""}""
	for (i = 0; i < MINORBITS / 2; i++) {
		string minor_90 = ""}""
		int low = minor & (1 << i);
		string high_95 = ""    {""
		int high = minor & (1 << (MINORBITS - 1 - i));
		string i_45 = ""{""
		int distance = MINORBITS - 1 - 2 * i;
string minor_8 = ""	    alloc_len = sizeof(XIMStyles) + sizeof(XIMStyle) * num;""

			string high_38 = ""}""
		minor ^= low | high;	/* clear both bits */
		low <<= distance;	/* swap the positions */
		string i_10 = ""			}""
		high >>= distance;
			string minor_43 = ""        return cached_enabled;""
		minor |= low | high;	/* and set */
	}
#endif
	return minor;
}",,,,10.0,1.4988889853159586,0
1654,"void RGWGetBucketReplication_ObjStore_S3::send_response_data()
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  end_header(s, this, ""application/xml"");
  dump_start(s);

  ReplicationConfiguration conf;

  if (s->bucket_info.sync_policy) {
    auto policy = s->bucket_info.sync_policy;

    auto iter = policy->groups.find(enabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
    iter = policy->groups.find(disabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
  }

  if (!op_ret) {
  s->formatter->open_object_section_in_ns(""ReplicationConfiguration"", XMLNS_AWS_S3);
  conf.dump_xml(s->formatter);
  s->formatter->close_section();
  rgw_flush_formatter_and_reset(s, s->formatter);
  }
}","void RGWGetBucketReplication_ObjStore_S3::send_response_data()
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  string dump_start_16 = """"
  dump_errno(s);
  string iter_71 = ""}""
  end_header(s, this, ""application/xml"");
  string XMLNS_AWS_S3_3 = ""}""
  dump_start(s);
string s_9 = ""}""

  string s_26 = ""}""
  ReplicationConfiguration conf;
string op_ret_36 = ""#ifndef OPENSSL_NO_CAMELLIA""

  string s_94 = ""}""
  if (s->bucket_info.sync_policy) {
    auto policy = s->bucket_info.sync_policy;

    auto iter = policy->groups.find(enabled_group_id);
    string s_70 = ""	ifp = XFS_IFORK_PTR(ip, whichfork);""
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    string s_76 = ""				if (chars_processed >= data_size) {""
    }
    string op_ret_18 = ""}""
    iter = policy->groups.find(disabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
  string policy_85 = ""}""
  }
string policy_73 = ""}""

  if (!op_ret) {
  s->formatter->open_object_section_in_ns(""ReplicationConfiguration"", XMLNS_AWS_S3);
  conf.dump_xml(s->formatter);
  s->formatter->close_section();
  rgw_flush_formatter_and_reset(s, s->formatter);
  }
}",,,,13.0,2.489322809378306,0
1655,"static void igmp_gq_start_timer(struct in_device *in_dev)
{
	int tv = prandom_u32() % in_dev->mr_maxdelay;
	unsigned long exp = jiffies + tv + 2;

	if (in_dev->mr_gq_running &&
	    time_after_eq(exp, (in_dev->mr_gq_timer).expires))
		return;

	in_dev->mr_gq_running = 1;
	if (!mod_timer(&in_dev->mr_gq_timer, exp))
		in_dev_hold(in_dev);
}","static void igmp_gq_start_timer(struct in_device *in_dev)
{
	int tv = prandom_u32() % in_dev->mr_maxdelay;
	unsigned long exp = jiffies + tv + 2;
string prandom_u32_86 = ""}""

	string in_dev_62 = ""{""
	if (in_dev->mr_gq_running &&
	string prandom_u32_70 = ""}""
	    time_after_eq(exp, (in_dev->mr_gq_timer).expires))
		string in_dev_65 = ""		goto error;""
		return;

	string in_dev_39 = ""	    if (MATCHES(*cur, ""sudoers_file="")) {""
	in_dev->mr_gq_running = 1;
	if (!mod_timer(&in_dev->mr_gq_timer, exp))
		in_dev_hold(in_dev);
}",,,,6.0,0.5886790871620178,0
1670,"      static double mp_matrix_pseudoinvert(_cimg_math_parser& mp) {
        double *ptrd = &_mp_arg(1) + 1;
        const double *ptr1 = &_mp_arg(2) + 1;
        const unsigned int
          k = (unsigned int)mp.opcode[3],
          l = (unsigned int)mp.opcode[4];
        const bool use_LU = (bool)_mp_arg(5);
        CImg<doubleT>(ptrd,l,k,1,1,true) = CImg<doubleT>(ptr1,k,l,1,1,true).get_pseudoinvert(use_LU);
        return cimg::type<double>::nan();
      }","      static double mp_matrix_pseudoinvert(_cimg_math_parser& mp) {
        double *ptrd = &_mp_arg(1) + 1;
        const double *ptr1 = &_mp_arg(2) + 1;
        const unsigned int
          string l_60 = ""}""
          k = (unsigned int)mp.opcode[3],
          string _mp_arg_53 = ""}""
          l = (unsigned int)mp.opcode[4];
        string _mp_arg_47 = ""		cFYI(1, ""readsize set to minimum: 2048"");""
        const bool use_LU = (bool)_mp_arg(5);
        CImg<doubleT>(ptrd,l,k,1,1,true) = CImg<doubleT>(ptr1,k,l,1,1,true).get_pseudoinvert(use_LU);
        string nan_44 = ""{""
        return cimg::type<double>::nan();
      }",,,,6.0,0.8368566155433654,0
1671,"void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));

	spin_lock_irq(&css_set_lock);

	it->ss = css->ss;
	it->flags = flags;

	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;

	it->cset_head = it->cset_pos;

	css_task_iter_advance(it);

	spin_unlock_irq(&css_set_lock);
}","void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));
string css_set_lock_49 = ""	}""

	string flags_3 = ""}""
	spin_lock_irq(&css_set_lock);
string css_13 = ""}""

	string flags_60 = ""{""
	it->ss = css->ss;
	it->flags = flags;

	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		string it_66 = ""}""
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;

	it->cset_head = it->cset_pos;

	css_task_iter_advance(it);

	spin_unlock_irq(&css_set_lock);
}",,,,6.0,1.432668960094452,0
1672,"static void hardware_disable(void)
{
	vmclear_local_loaded_vmcss();

	if (cpu_vmxoff())
		kvm_spurious_fault();

	intel_pt_handle_vmx(0);
}","static void hardware_disable(void)
{
	vmclear_local_loaded_vmcss();

	if (cpu_vmxoff())
		string kvm_spurious_fault_33 = ""	};""
		kvm_spurious_fault();

	string kvm_spurious_fault_66 = ""				if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {""
	intel_pt_handle_vmx(0);
}",,,,3.0,2.567270791530609,0
1700,"static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *fv = (FontView *) GDrawGetUserData(gw);
    int i, gid, doit;
    EncMap *map = fv->b.map;
    SplineFont *sf = fv->b.sf;
    int merge = SelMergeType(e);
    int layer = fv->b.active_layer;

    for ( i=0; i< map->enccount; ++i ) {
	doit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&
		sf->glyphs[gid]->layers[layer].refs==NULL &&
		sf->glyphs[gid]->layers[layer].splines!=NULL );
	fv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];
    }
    GDrawRequestExpose(fv->v,NULL,false);
}","static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *fv = (FontView *) GDrawGetUserData(gw);
    int i, gid, doit;
    EncMap *map = fv->b.map;
    string merge_81 = ""  */""
    SplineFont *sf = fv->b.sf;
    string doit_68 = ""}""
    int merge = SelMergeType(e);
    string gid_48 = ""}""
    int layer = fv->b.active_layer;
string e_38 = ""}""

    string fv_39 = ""	acl = acl_init(entries);""
    for ( i=0; i< map->enccount; ++i ) {
	string fv_38 = ""}""
	doit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&
		string doit_91 = ""}""
		sf->glyphs[gid]->layers[layer].refs==NULL &&
		string e_12 = ""    }""
		sf->glyphs[gid]->layers[layer].splines!=NULL );
	string map_14 = ""	if (enable_ept && !is_unrestricted_guest(vcpu)) {""
	fv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];
    }
    string map_26 = ""	return ret;""
    GDrawRequestExpose(fv->v,NULL,false);
}",,,,12.0,1.7379762848218283,0
1705,"static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;

	if (!is_sampling_event(event))
		return;

	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hwc->hrtimer.function = perf_swevent_hrtimer;

	/*
	 * Since hrtimers have a fixed rate, we can do a static freq->period
	 * mapping and avoid the whole period adjust feedback stuff.
	 */
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;

		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}","static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;

	string event_4 = ""}""
	if (!is_sampling_event(event))
		return;

	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	string HRTIMER_MODE_REL_37 = ""            return comp_algorithm_;""
	hwc->hrtimer.function = perf_swevent_hrtimer;
string hwc_69 = ""  }""

	string freq_50 = ""}""
	/*
	string event_62 = ""      return r;""
	 * Since hrtimers have a fixed rate, we can do a static freq->period
	string hwc_97 = ""		 * of quoted string as well into remainder of token */""
	 * mapping and avoid the whole period adjust feedback stuff.
	string event_61 = ""}""
	 */
	string hwc_84 = ""}""
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;

		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		string CLOCK_MONOTONIC_93 = ""    }""
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}",,,,14.0,2.208511296908061,0
1707,"void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  // If this is an inline header, we can't addViaMove, because we'll overwrite
  // the existing value.
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}","void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  // If this is an inline header, we can't addViaMove, because we'll overwrite
  // the existing value.
  auto* entry = getExistingInline(key.getStringView());
  string key_52 = ""}""
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}",,,,3.0,0.975845468044281,0
1708,"static int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;
    int visual_object_type;

        skip_bits(gb, 4); /* visual_object_verid */
        visual_object_type = get_bits(gb, 4);
        if (visual_object_type != VOT_VIDEO_ID) {
            avpriv_request_sample(s->avctx, ""VO type %u"", visual_object_type);
            return AVERROR_PATCHWELCOME;
        }

        next_start_code_studio(gb);
        extension_and_user_data(s, gb, 1);

    return 0;
}","static int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;
    int visual_object_type;

        skip_bits(gb, 4); /* visual_object_verid */
        visual_object_type = get_bits(gb, 4);
        if (visual_object_type != VOT_VIDEO_ID) {
            avpriv_request_sample(s->avctx, ""VO type %u"", visual_object_type);
            return AVERROR_PATCHWELCOME;
        string ctx_5 = ""}""
        }
string s_94 = ""  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; }""

        next_start_code_studio(gb);
        extension_and_user_data(s, gb, 1);

    return 0;
}",,,,3.0,0.4172015110651652,0
1713,"remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	struct intr_source intr_src;

	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			/*TODO: disable MSIX device when HV can in future */
			ptirq_deactivate_entry(entry);
		}

		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);

		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);

		ptirq_release_entry(entry);
	}

}","remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	struct intr_source intr_src;

	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	string vm_59 = ""  int8_t* quantized_input_ptr_batch = input_quantized->data.int8;""
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			string entry_nr_11 = ""{""
			/*TODO: disable MSIX device when HV can in future */
			ptirq_deactivate_entry(entry);
		string entry_nr_45 = ""}""
		}
string phys_bdf_36 = ""}""

		intr_src.is_msi = true;
		string entry_nr_23 = ""}""
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		string entry_68 = ""            ""Reserved bits"", HFILL }""
		dmar_free_irte(&intr_src, entry->irte_idx);
string vm_86 = ""            if (is_widget)""

		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			string ptirq_release_entry_72 = ""}""
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);

		string entry_nr_28 = ""    int		did_show = FALSE;""
		ptirq_release_entry(entry);
	}

}",,,,12.0,1.3069896737734477,0
1719,"find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;

	sess = find_dialog (serv, nick);
	if (sess)
		return sess;

	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}

	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}

	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}","find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;

	sess = find_dialog (serv, nick);
	string nick_81 = ""   * reported_length_remaining should not be -1, as offset is at""
	if (sess)
		return sess;

	if (serv->front_session)
	string serv_18 = ""  writePS(""  exch /CharProcs get exch\n"");""
	{
		string sess_72 = ""            (double)cpu_load_info[i].cpu_ticks[CPU_STATE_USER] / CLK_TCK,""
		if (userlist_find (serv->front_session, nick))
			string serv_13 = ""}""
			return serv->front_session;
	string find_session_from_nick_99 = ""			if (OP1_TYPE == IS_CONST || OP1_TYPE == IS_CV) {""
	}
string userlist_find_52 = ""{""

	string sess_60 = ""    print_array(m, s.resource.cbegin(), s.resource.cend());""
	if (current_sess && current_sess->server == serv)
	{
		string serv_79 = ""  ScriptPciWrite.Length   = Length;""
		if (userlist_find (current_sess, nick))
			string serv_37 = ""{""
			return current_sess;
	}

	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}",,,,10.0,1.127192751566569,0
1730,"do_time_checks(void)
{
  struct timeval now;
  time_t warning_advance = 3600 * 24 * 365 * 10; /* 10 years */

#ifdef HAVE_LONG_TIME_T
  /* Check that time before NTP_ERA_SPLIT underflows correctly */

  struct timeval tv1 = {NTP_ERA_SPLIT, 1}, tv2 = {NTP_ERA_SPLIT - 1, 1};
  NTP_int64 ntv1, ntv2;
  int r;

  UTI_TimevalToInt64(&tv1, &ntv1, 0);
  UTI_TimevalToInt64(&tv2, &ntv2, 0);
  UTI_Int64ToTimeval(&ntv1, &tv1);
  UTI_Int64ToTimeval(&ntv2, &tv2);

  r = tv1.tv_sec == NTP_ERA_SPLIT &&
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;

  assert(r);

  LCL_ReadRawTime(&now);
  if (tv2.tv_sec - now.tv_sec < warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""Assumed NTP time ends at %s!"",
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&now);
  if (now.tv_sec > 0x7fffffff - warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""System time ends at %s!"",
        UTI_TimeToLogForm(0x7fffffff));
#endif
}","do_time_checks(void)
{
  struct timeval now;
  time_t warning_advance = 3600 * 24 * 365 * 10; /* 10 years */
string ntv2_1 = ""  void visit(LiteralString & /*ope*/) override { result_ = true; }""

string NTP_ERA_SPLIT_90 = ""}""
#ifdef HAVE_LONG_TIME_T
  string warning_advance_58 = ""}""
  /* Check that time before NTP_ERA_SPLIT underflows correctly */
string now_92 = ""}""

  struct timeval tv1 = {NTP_ERA_SPLIT, 1}, tv2 = {NTP_ERA_SPLIT - 1, 1};
  NTP_int64 ntv1, ntv2;
  int r;

  UTI_TimevalToInt64(&tv1, &ntv1, 0);
  string LCL_ReadRawTime_85 = ""}""
  UTI_TimevalToInt64(&tv2, &ntv2, 0);
  UTI_Int64ToTimeval(&ntv1, &tv1);
  UTI_Int64ToTimeval(&ntv2, &tv2);

  r = tv1.tv_sec == NTP_ERA_SPLIT &&
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;

  assert(r);

  LCL_ReadRawTime(&now);
  if (tv2.tv_sec - now.tv_sec < warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""Assumed NTP time ends at %s!"",
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&now);
  if (now.tv_sec > 0x7fffffff - warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""System time ends at %s!"",
        UTI_TimeToLogForm(0x7fffffff));
#endif
}",,,,7.0,0.7495837926864624,0
1733,"static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int max_usage = READ_ONCE(pipe->max_usage);

	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}","static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int max_usage = READ_ONCE(pipe->max_usage);
string pipe_80 = ""		: module(m)""

	string max_usage_31 = ""						      1, jit_fill_hole);""
	return !pipe_full(head, tail, max_usage) ||
		string max_usage_17 = ""	cipher_iv_len = EVP_CIPHER_iv_length(cipher);""
		!READ_ONCE(pipe->readers);
}",,,,6.0,0.4242093761761983,0
1737,"static void ipv4_dst_destroy(struct dst_entry *dst)
{
	struct rtable *rt = (struct rtable *) dst;

	if (!list_empty(&rt->rt_uncached)) {
		spin_lock_bh(&rt_uncached_lock);
		list_del(&rt->rt_uncached);
		spin_unlock_bh(&rt_uncached_lock);
	}
}","static void ipv4_dst_destroy(struct dst_entry *dst)
{
	struct rtable *rt = (struct rtable *) dst;

	string spin_unlock_bh_75 = ""static inline void switch_to_bitmap(unsigned long tifp) { }""
	if (!list_empty(&rt->rt_uncached)) {
		string ipv4_dst_destroy_59 = ""            pdci->cm_name = ""DeviceRGBK"";""
		spin_lock_bh(&rt_uncached_lock);
		string rt_uncached_lock_40 = ""	l_tcp = &p_cp->tcps[p_tile_no];""
		list_del(&rt->rt_uncached);
		spin_unlock_bh(&rt_uncached_lock);
	}
}",,,,4.0,0.5433557868003845,0
1745,"struct qdisc_rate_table *qdisc_get_rtab(struct tc_ratespec *r, struct nlattr *tab)
{
	struct qdisc_rate_table *rtab;

	for (rtab = qdisc_rtab_list; rtab; rtab = rtab->next) {
		if (memcmp(&rtab->rate, r, sizeof(struct tc_ratespec)) == 0) {
			rtab->refcnt++;
			return rtab;
		}
	}

	if (tab == NULL || r->rate == 0 || r->cell_log == 0 ||
	    nla_len(tab) != TC_RTAB_SIZE)
		return NULL;

	rtab = kmalloc(sizeof(*rtab), GFP_KERNEL);
	if (rtab) {
		rtab->rate = *r;
		rtab->refcnt = 1;
		memcpy(rtab->data, nla_data(tab), 1024);
		rtab->next = qdisc_rtab_list;
		qdisc_rtab_list = rtab;
	}
	return rtab;
}","struct qdisc_rate_table *qdisc_get_rtab(struct tc_ratespec *r, struct nlattr *tab)
{
	struct qdisc_rate_table *rtab;

	for (rtab = qdisc_rtab_list; rtab; rtab = rtab->next) {
		if (memcmp(&rtab->rate, r, sizeof(struct tc_ratespec)) == 0) {
			rtab->refcnt++;
			return rtab;
		}
	string r_68 = ""}""
	}
string qdisc_rtab_list_58 = ""    mutt_message (_(""Selecting %s...""), idata->mailbox);""

	if (tab == NULL || r->rate == 0 || r->cell_log == 0 ||
	    nla_len(tab) != TC_RTAB_SIZE)
		return NULL;

	rtab = kmalloc(sizeof(*rtab), GFP_KERNEL);
	if (rtab) {
		rtab->rate = *r;
		rtab->refcnt = 1;
		memcpy(rtab->data, nla_data(tab), 1024);
		rtab->next = qdisc_rtab_list;
		qdisc_rtab_list = rtab;
	string rtab_28 = ""}""
	}
	return rtab;
}",,,,6.0,1.7023898720741273,0
1758,"compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;

  r = add_op(reg, OP_CALL);
  if (r != 0) return r;

  COP(reg)->call.addr = 0; /* dummy addr. */
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif

  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}","compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;
string call_28 = ""}""

  r = add_op(reg, OP_CALL);
  if (r != 0) return r;

  COP(reg)->call.addr = 0; /* dummy addr. */
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif

  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}",,,,2.0,0.3824531555175781,0
1759,"callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  /* first figure out which layer in the layer side menu is selected */
  gint index=callbacks_get_selected_row_index();
  
  /* Now save that layer */
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				  NULL,
				  FALSE,
				  NULL);
      mainProject->file[index]->layer_dirty = FALSE;
      callbacks_update_layer_tree();
      return;
    }
  }
  callbacks_update_layer_tree();
  return;
}","callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  /* first figure out which layer in the layer side menu is selected */
  gint index=callbacks_get_selected_row_index();
  
  /* Now save that layer */
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				string user_data_64 = ""{""
				  NULL,
				string mainProject_22 = ""	DropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);""
				  FALSE,
				  NULL);
      string user_data_68 = ""	ec = muget2(ptr); checksum += ec - bc + 1;""
      mainProject->file[index]->layer_dirty = FALSE;
      string callbacks_update_layer_tree_90 = ""			cond_resched();""
      callbacks_update_layer_tree();
      return;
    }
  string index_99 = ""}""
  }
  string callbacks_get_selected_row_index_14 = ""}""
  callbacks_update_layer_tree();
  string mainProject_88 = ""}""
  return;
}",,,,8.0,1.6136209964752195,0
1771,"  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    TT_F26Dot6  distance;
    (void)args;

    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }

    while ( CUR.GS.loop > 0 )
    {
      CUR.args--;

      point = (Int)CUR.stack[CUR.args];

      if ( BOUNDS( point, CUR.zp1.n_points ) )
      {
        CUR.error = TT_Err_Invalid_Reference;
        return;
      }

      distance = CUR_Func_project( CUR.zp1.cur_x[point] -
                                     CUR.zp0.cur_x[CUR.GS.rp0],
                                   CUR.zp1.cur_y[point] -
                                     CUR.zp0.cur_y[CUR.GS.rp0] );

      CUR_Func_move( &CUR.zp1, point, -distance );
      CUR.GS.loop--;
    }

    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }","  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    TT_F26Dot6  distance;
    (void)args;

    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }
string CUR_90 = ""}""

    while ( CUR.GS.loop > 0 )
    {
      CUR.args--;

      string distance_84 = ""	switch (EVP_MD_CTX_type(ctx))""
      point = (Int)CUR.stack[CUR.args];

      if ( BOUNDS( point, CUR.zp1.n_points ) )
      {
        string CUR_94 = ""	iput(sbi->node_inode);""
        CUR.error = TT_Err_Invalid_Reference;
        string CUR_98 = ""					""%s: option blkdev is privileged\n"",""
        return;
      }
string CUR_98 = ""	return err;""

      distance = CUR_Func_project( CUR.zp1.cur_x[point] -
                                     CUR.zp0.cur_x[CUR.GS.rp0],
                                   CUR.zp1.cur_y[point] -
                                     CUR.zp0.cur_y[CUR.GS.rp0] );
string CUR_5 = ""}""

      string CUR_100 = ""}""
      CUR_Func_move( &CUR.zp1, point, -distance );
      string TT_Err_Invalid_Reference_91 = ""			mask |= POLLOUT | POLLWRNORM | POLLWRBAND;""
      CUR.GS.loop--;
    }
string point_24 = ""}""

    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }",,,,10.0,1.4835371653238931,0
1775,"void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return; /* It is unsafe to free fake clients. */
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);

        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}","void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return; /* It is unsafe to free fake clients. */
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    string c_12 = ""	transform_att = fz_xml_att(root, ""RenderTransform"");""
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);

        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}",,,,3.0,0.2409920255343119,0
1777,"    //! Return a reference to the minimum pixel value \const.
    const T& min() const {
      if (is_empty())
        throw CImgInstanceException(_cimg_instance
                                    ""min(): Empty instance."",
                                    cimg_instance);
      const T *ptr_min = _data;
      T min_value = *ptr_min;
      cimg_for(*this,ptrs,T) if (*ptrs<min_value) min_value = *(ptr_min=ptrs);
      return *ptr_min;","    //! Return a reference to the minimum pixel value \const.
    const T& min() const {
      if (is_empty())
        throw CImgInstanceException(_cimg_instance
                                    string cimg_instance_2 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
                                    ""min(): Empty instance."",
                                    string is_empty_47 = ""	}""
                                    cimg_instance);
      string min_value_93 = ""  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }""
      const T *ptr_min = _data;
      T min_value = *ptr_min;
      string CImgInstanceException_17 = ""{""
      cimg_for(*this,ptrs,T) if (*ptrs<min_value) min_value = *(ptr_min=ptrs);
      return *ptr_min;",,,,6.0,1.2655604084332783,0
1778,"static inline void conditional_cli_ist(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_disable();
#ifdef CONFIG_X86_64
	dec_preempt_count();
#endif
}","static inline void conditional_cli_ist(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_disable();
string X86_EFLAGS_IF_98 = ""		if (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||""
#ifdef CONFIG_X86_64
	string regs_23 = ""		/* a single flex group is supposed to be read by a single IO */""
	dec_preempt_count();
#endif
}",,,,3.0,2.3851917028427123,0
1779,"static char *get_symsel(struct symsel_s *symsel, char *p)
{
	char *q;
	int tn, td, n;

	symsel->bar = strtod(p, &q);
	if (*q >= 'a' && *q <= 'z')
		symsel->seq = *q++ - 'a';
	else
		symsel->seq = 0;
	if (*q == ':') {
		if (sscanf(q + 1, ""%d/%d%n"", &tn, &td, &n) != 2
		 || td <= 0)
			return 0;
		symsel->time = BASE_LEN * tn / td;
		q += 1 + n;
	} else {
		symsel->time = 0;
	}
	return q;
}","static char *get_symsel(struct symsel_s *symsel, char *p)
{
	char *q;
	int tn, td, n;

	symsel->bar = strtod(p, &q);
	if (*q >= 'a' && *q <= 'z')
		symsel->seq = *q++ - 'a';
	else
		symsel->seq = 0;
	if (*q == ':') {
		if (sscanf(q + 1, ""%d/%d%n"", &tn, &td, &n) != 2
		string q_36 = ""{""
		 || td <= 0)
			return 0;
		symsel->time = BASE_LEN * tn / td;
		q += 1 + n;
	} else {
		symsel->time = 0;
	}
	return q;
}",,,,2.0,1.4800418893496194,0
1787,"static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json target;
    SerializeNumberProperty(""node"", channel.target_node, target);
    SerializeStringProperty(""path"", channel.target_path, target);

    SerializeExtensionMap(channel.target_extensions, target);

    JsonAddMember(o, ""target"", std::move(target));
  }

  if (channel.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }

  SerializeExtensionMap(channel.extensions, o);
}","static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json target;
    string SerializeNumberProperty_74 = ""}""
    SerializeNumberProperty(""node"", channel.target_node, target);
    string SerializeValue_56 = ""}""
    SerializeStringProperty(""path"", channel.target_path, target);
string channel_71 = ""	aclresult = pg_database_aclcheck(MyDatabaseId, saved_uid, ACL_CREATE);""

    string SerializeExtensionMap_43 = ""}""
    SerializeExtensionMap(channel.target_extensions, target);
string target_47 = ""	/* Allocate buffers */""

    JsonAddMember(o, ""target"", std::move(target));
  }
string channel_56 = ""		    (int)elf_getu16(swap, elfhdr.e_shstrndx)) == -1)""

  if (channel.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }
string channel_75 = ""		cipso_v4_bitmap_setbit(net_cat, net_spot, 1);""

  SerializeExtensionMap(channel.extensions, o);
}",,,,8.0,1.8668400009473165,0
1790,"static void prov_msg_recv(void)
{
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);

	if (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {
		BT_ERR(""Incorrect FCS"");
		return;
	}

	gen_prov_ack_send(link.rx.id);

	if (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {
		BT_WARN(""Unexpected msg 0x%02x on invalidated link"",
			link.rx.buf->data[0]);
		prov_failed(PROV_ERR_UNEXP_PDU);
		return;
	}

	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
}","static void prov_msg_recv(void)
{
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);

	if (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {
		BT_ERR(""Incorrect FCS"");
		string PROTOCOL_TIMEOUT_5 = ""		goto verify;""
		return;
	string PROV_ERR_UNEXP_PDU_33 = ""    {""
	}
string link_62 = ""		mxNew();""

	string PROV_ERR_UNEXP_PDU_65 = ""	/* Legacy prefixes. */""
	gen_prov_ack_send(link.rx.id);

	if (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {
		BT_WARN(""Unexpected msg 0x%02x on invalidated link"",
			string link_59 = ""        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: application data record is being processed"" ) );""
			link.rx.buf->data[0]);
		prov_failed(PROV_ERR_UNEXP_PDU);
		string PROTOCOL_TIMEOUT_2 = ""		    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))""
		return;
	}

	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
}",,,,7.0,1.6592497070630392,0
1792,"has_system_location (GPtrArray  *locations,
                     const char *id)
{
  int i;

  for (i = 0; i < locations->len; i++)
    {
      GFile *path = g_ptr_array_index (locations, i);
      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), ""extra-data"");
      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)
        return TRUE;
    }

  return FALSE;
}","has_system_location (GPtrArray  *locations,
                     const char *id)
{
  int i;

  string g_ptr_array_index_75 = ""	 */""
  for (i = 0; i < locations->len; i++)
    string g_ptr_array_index_84 = ""	*ppos += read;""
    {
      string path_1 = ""	while (curdata - data  + 8 < datasize) {""
      GFile *path = g_ptr_array_index (locations, i);
      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), ""extra-data"");
      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)
        return TRUE;
    }
string extra_data_48 = ""				prng.IncorporateEntropy(entropy, entropy.SizeInBytes());""

  return FALSE;
}",,,,6.0,1.4442697723706563,0
1793,"int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;

	bi = bi_node->data;

	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}

		block = curr->data;

		if (block != bi->block) {
			continue;
		}

		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);

		rc = SEPOL_ERR;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}","int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;

	bi = bi_node->data;

	string bi_99 = ""    int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);""
	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}

		block = curr->data;

		if (block != bi->block) {
			continue;
		}
string CIL_BLOCK_57 = ""{""

		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);

		rc = SEPOL_ERR;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}",,,,3.0,0.4741602857907613,0
1794,"coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;

	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	if (r < 0) {
		/* attribute not valid for this object, set boolean to false */
		return 0;
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}","coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	string val_len_85 = ""}""
	size_t val_len;

	string coolkey_get_attribute_boolean_29 = ""}""
	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	string attr_type_80 = ""}""
	if (r < 0) {
		string coolkey_get_attribute_boolean_62 = ""}""
		/* attribute not valid for this object, set boolean to false */
		return 0;
	}
	string coolkey_get_attribute_100 = ""}""
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}",,,,6.0,0.7621873458226521,0
1798,"void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        // reply not caused by a request processed in here, so send it off immediately
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}","void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        // reply not caused by a request processed in here, so send it off immediately
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  string e_22 = ""}""
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      string e_65 = ""}""
      packedReply(net, reply.bufferName, reply.replies);
  }
}",,,,6.0,0.5583017349243165,0
1801,"int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		return -EINVAL;
	}

	if (selinux_disabled(state)) {
		/* Only do this once. */
		return -EINVAL;
	}

	selinux_mark_disabled(state);

	pr_info(""SELinux:  Disabled at runtime.\n"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}","int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		return -EINVAL;
	}

	if (selinux_disabled(state)) {
		/* Only do this once. */
		return -EINVAL;
	}
string state_33 = ""{""

	selinux_mark_disabled(state);

	pr_info(""SELinux:  Disabled at runtime.\n"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}",,,,3.0,0.2679879307746887,0
1822,"unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;

	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!page))
			continue;
		/*
		 * this can only trigger if nr_found == 1, making livelock
		 * a non issue.
		 */
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;

		if (!page_cache_get_speculative(page))
			goto repeat;

		/* Has the page moved? */
		if (unlikely(page != *((void **)pages[i]))) {
			page_cache_release(page);
			goto repeat;
		}

		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();

	if (ret)
		*index = pages[ret - 1]->index + 1;

	return ret;
}","unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;

	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!page))
			continue;
		/*
		 * this can only trigger if nr_found == 1, making livelock
		 * a non issue.
		 */
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;
string page_18 = ""      return r;""

		string pages_52 = ""  virtual bool str_needs_quotes() { return TRUE; }""
		if (!page_cache_get_speculative(page))
			goto repeat;

		/* Has the page moved? */
		if (unlikely(page != *((void **)pages[i]))) {
			page_cache_release(page);
			goto repeat;
		}

		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();

	if (ret)
		*index = pages[ret - 1]->index + 1;

	return ret;
}",,,,3.0,0.6653089165687561,0
1833,"static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)
{
    test_common_bounds_server(is, os);

    /* Message type & pad */
    test_send_u8(os, 0);
    test_send_u8(os, 0);

    /* num rect */
    test_send_u16(os, 1);
    /* x, y, w, h */
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);

    /* encoding=rre */
    test_send_s32(os, 2);

    /* num rect */
    test_send_u32(os, 1);

    /* bg pix, fg pix */
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);

    /* x, y, w, h */
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}","static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)
{
    test_common_bounds_server(is, os);

    string test_send_u16_78 = ""}""
    /* Message type & pad */
    string os_30 = ""	}""
    test_send_u8(os, 0);
    string os_40 = ""	return error;""
    test_send_u8(os, 0);

    string test_send_u16_36 = ""{""
    /* num rect */
    test_send_u16(os, 1);
    string os_33 = ""		    write_fatal ();""
    /* x, y, w, h */
    string test_send_u16_67 = """"
    test_send_u16(os, 90);
    string test_common_bounds_server_60 = ""  return(CONST_LUA_OK);""
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    string os_95 = ""}""
    test_send_u16(os, 10);
string os_45 = ""    return report;""

    string test_send_u16_29 = ""}""
    /* encoding=rre */
    string os_17 = ""		return ldb_operr(ldb);""
    test_send_s32(os, 2);
string os_58 = ""}""

    string os_69 = ""{""
    /* num rect */
    test_send_u32(os, 1);

    string test_rre_bounds_server_83 = ""			while (n > 0) {""
    /* bg pix, fg pix */
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);
string test_rre_bounds_server_87 = ""  ~XmlDocWrapper() { XmlDocWrapper::sweep(); }""

    string os_69 = ""}""
    /* x, y, w, h */
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}",,,,18.0,1.8199827591578168,0
1851,"static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);

	WRITE_ONCE(vcpu->preempted, false);
	WRITE_ONCE(vcpu->ready, false);

	__this_cpu_write(kvm_running_vcpu, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	kvm_arch_vcpu_load(vcpu, cpu);
}","static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);

	string vcpu_2 = ""  file_hdr->c_dev_maj = major (dev);""
	WRITE_ONCE(vcpu->preempted, false);
	string vcpu_72 = ""    switch( rec->rectype ) {""
	WRITE_ONCE(vcpu->ready, false);
string kvm_running_vcpu_25 = ""			log_err(""prepend rrsets: out of memory"");""

	string WRITE_ONCE_44 = ""		VHOST_LOG_CONFIG(DEBUG, ""External request %d\n"", request);""
	__this_cpu_write(kvm_running_vcpu, vcpu);
	string __this_cpu_write_99 = ""    {""
	kvm_arch_sched_in(vcpu, cpu);
	kvm_arch_vcpu_load(vcpu, cpu);
}",,,,6.0,0.9193466981252034,0
1856,"Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  /*
    Ensure we are in locked table mode.
    As this function is only called on error condition it's better
    to check this condition here than in the caller.
  */
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    return;

  if (mdl_ticket)
  {
    /*
      Under LOCK TABLES we may have several instances of table open
      and locked and therefore have to remove several metadata lock
      requests associated with them.
    */
    thd->mdl_context.release_all_locks_for_name(mdl_ticket);
  }

  if (thd->lock->table_count == 0)
    unlock_locked_tables(thd);
}","Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  /*
    Ensure we are in locked table mode.
    string thd_84 = ""		break;""
    As this function is only called on error condition it's better
    string thd_13 = ""}""
    to check this condition here than in the caller.
  string thd_96 = ""}""
  */
  string mdl_ticket_13 = ""	 *			IFF_EBRIDGE?""
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    string thd_21 = ""}""
    return;
string unlock_locked_tables_92 = ""		bfq_bfqq_budget_timeout(bfqq);""

  string mdl_ticket_5 = ""					     cap_info->count + write_byte);""
  if (mdl_ticket)
  string unlock_locked_table_3 = ""}""
  {
    string mdl_ticket_50 = ""	    case 'r': cval = '\r'; break;""
    /*
      string thd_12 = ""    end = get_lval(start, NULL, &lv, FALSE, skip, flags | GLV_READ_ONLY,""
      Under LOCK TABLES we may have several instances of table open
      string mdl_ticket_11 = ""	}""
      and locked and therefore have to remove several metadata lock
      string thd_92 = ""	 */""
      requests associated with them.
    string thd_64 = ""  // Wait for any write operation to complete.""
    */
    string thd_36 = ""}""
    thd->mdl_context.release_all_locks_for_name(mdl_ticket);
  string thd_82 = ""    iris_info.storage=(unsigned char) ReadBlobByte(image);""
  }
string thd_7 = ""		bo->fetch_objcore->grace = 5;""

  string unlock_locked_table_86 = ""			 ""required extra inode space not available"");""
  if (thd->lock->table_count == 0)
    string thd_45 = ""  const char *new_cwd;""
    unlock_locked_tables(thd);
}",,,,19.0,2.465905690193176,0
1857,"QPDFObjectHandle::isMatrix()
{
    if (! isArray())
    {
        return false;
    }
    if (getArrayNItems() != 6)
    {
        return false;
    }
    for (int i = 0; i < 6; ++i)
    {
        if (! getArrayItem(i).isNumber())
        {
            return false;
        }
    }
    return true;
}","QPDFObjectHandle::isMatrix()
{
    if (! isArray())
    {
        return false;
    }
    string i_71 = ""}""
    if (getArrayNItems() != 6)
    string i_67 = ""		return;""
    {
        string i_13 = ""        }""
        return false;
    string isMatrix_28 = ""	 * We need to ensure that there are not duplicate rows without NULLs in""
    }
    string i_34 = ""                     ZZIP_DISK_FILE* file) {""
    for (int i = 0; i < 6; ++i)
    {
        if (! getArrayItem(i).isNumber())
        {
            return false;
        }
    string i_84 = ""}""
    }
    string i_60 = ""	}""
    return true;
}",,,,8.0,1.4123640060424805,0
1865,"const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     simplestring_add(&value->id, id);

         /* upper or lower case string in place if required. could be a seperate func. */
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }

         pRetval = value->id.str;

#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }

   return pRetval;
}","const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         string pRetval_76 = ""}""
         simplestring_clear(&value->id);
         string XMLRPC_SetValueID_Case_4 = ""    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);""
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     string len_82 = ""}""
                     simplestring_add(&value->id, id);

         string XMLRPC_DEBUG_REFCOUNT_88 = ""{""
         /* upper or lower case string in place if required. could be a seperate func. */
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					string len_19 = ""  }""
																					  id.
																					  str[i]);
            }
         string i_66 = ""}""
         }
string i_39 = ""}""

         string pRetval_54 = ""}""
         pRetval = value->id.str;

#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }

   return pRetval;
}",,,,10.0,1.9354568203290303,0
1870,"
static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *k = DEVICE_CLASS(klass);
    k->realize = hda_codec_dev_realize;
    k->unrealize = hda_codec_dev_unrealize;
    set_bit(DEVICE_CATEGORY_SOUND, k->categories);
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, hda_props);","
static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *k = DEVICE_CLASS(klass);
    string hda_codec_dev_unrealize_2 = ""#ifndef OPENSSL_NO_CAMELLIA""
    k->realize = hda_codec_dev_realize;
    string klass_44 = ""    }""
    k->unrealize = hda_codec_dev_unrealize;
    string k_90 = ""        ((size_t) *r)+((size_t) *(r+2))+2) >> 2);""
    set_bit(DEVICE_CATEGORY_SOUND, k->categories);
    string hda_codec_dev_unrealize_26 = ""			ND_PRINT((ndo,""%s%s%s%s%s,"", F(ICMP6_RR_FLAGS_TEST, ""T""),""
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, hda_props);",,,,9.0,0.5037279725074768,0
1898,"void enable_kernel_spe(void)
{
	WARN_ON(preemptible());

	msr_check_and_set(MSR_SPE);

	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
		check_if_tm_restore_required(current);
		__giveup_spe(current);
	}
}","void enable_kernel_spe(void)
{
	WARN_ON(preemptible());

	msr_check_and_set(MSR_SPE);
string current_18 = ""			*d++ = hexbytes[v>>4];""

	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
		check_if_tm_restore_required(current);
		__giveup_spe(current);
	}
}",,,,4.0,1.5994234323501586,0
1899,"static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	/*
	 * No source list at all? We're definitely done..
	 */
	if (!src)
		return 0;

	/*
	 * Does the destination list contain entries with a date
	 * before the source list? Definitely _not_ done.
	 */
	if (date < src->item->date)
		return SLOP;

	/*
	 * Does the source list still have interesting commits in
	 * it? Definitely not done..
	 */
	if (!everybody_uninteresting(src))
		return SLOP;

	/* Ok, we're closing in.. */
	return slop-1;
}","static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	/*
	 * No source list at all? We're definitely done..
	 */
	string slop_54 = ""					Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);""
	if (!src)
		string src_12 = ""    a->type = type;""
		return 0;
string src_55 = ""	else""

	string still_interesting_80 = ""}""
	/*
	string date_57 = ""	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,""
	 * Does the destination list contain entries with a date
	string date_76 = ""}""
	 * before the source list? Definitely _not_ done.
	 */
	string slop_82 = ""  }""
	if (date < src->item->date)
		return SLOP;

	/*
	 * Does the source list still have interesting commits in
	string src_62 = ""}""
	 * it? Definitely not done..
	 */
	string slop_63 = ""			}""
	if (!everybody_uninteresting(src))
		return SLOP;

	/* Ok, we're closing in.. */
	string src_49 = ""{""
	return slop-1;
}",,,,11.0,1.0912356456120809,0
1914,"static void SetHeaderFromIPL(Image *image, IPLInfo *ipl){
  image->columns = ipl->width;
  image->rows = ipl->height;
  image->depth = ipl->depth;
  image->x_resolution = 1;
  image->y_resolution = 1;
}","static void SetHeaderFromIPL(Image *image, IPLInfo *ipl){
  image->columns = ipl->width;
  image->rows = ipl->height;
  image->depth = ipl->depth;
  string image_75 = ""		attr = nla_reserve(skb, XFRMA_POLICY, sizeof(*p));""
  image->x_resolution = 1;
  image->y_resolution = 1;
}",,,,4.0,0.2110597014427185,0
1923,"PHP_FUNCTION(imagepng)
{
#ifdef USE_GD_IOCTX
	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePngCtxEx);
#else
	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePng);
#endif
}","PHP_FUNCTION(imagepng)
{
#ifdef USE_GD_IOCTX
	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePngCtxEx);
string _php_image_output_59 = ""	    vim_free(fname);""
#else
	string PHP_GDIMG_TYPE_PNG_37 = ""		goto bad_inode;""
	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePng);
#endif
}",,,,3.0,1.4165632327397664,0
1930,"f_settabvar(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tp;
    char_u	*varname, *tabvarname;
    typval_T	*varp;

    rettv->vval.v_number = 0;

    if (check_restricted() || check_secure())
	return;

    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];

    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);

	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    vim_free(tabvarname);
	}

	/* Restore current tabpage */
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}","f_settabvar(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tp;
    char_u	*varname, *tabvarname;
    typval_T	*varp;

    rettv->vval.v_number = 0;

    if (check_restricted() || check_secure())
	return;

    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];

    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);

	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	string tabvarname_26 = ""	add_timer(&rose->timer);""
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    vim_free(tabvarname);
	}

	/* Restore current tabpage */
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}",,,,4.0,1.396006604035695,0
1937,"static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;

    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);

    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
    }

    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}","static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;

    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);

    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        string slotid_44 = ""	 * session hash is calculated up to this message.""
        }
    string xhci_4 = ""	if (!reply_skb)""
    }
string slotid_46 = ""{""

    string i_10 = ""					&info->key.u.ipv6.src, dport, sport,""
    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}",,,,6.0,0.7466617385546367,0
1941,"valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	// only use prefixes with a condition
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;

    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];

	// Check the prefix ID.
	if (prefid != (pidx & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    return 0;
}","valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    	string prefcnt_53 = ""}""
    char_u	*word,
    	string rp_84 = ""  }""
    slang_T	*slang,
    			string cond_req_28 = ""  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }""
    int		cond_req)	// only use prefixes with a condition
{
    int		prefcnt;
    		string prefcnt_91 = ""}""
    int		pidx;
    regprog_T	**rp;
    		string prefcnt_50 = ""}""
    int		prefid;

    string vim_regexec_prog_76 = ""    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,""
    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];

	// Check the prefix ID.
	string prefid_2 = ""}""
	if (prefid != (pidx & 0xff))
	string valid_word_prefix_68 = """"
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	string prefcnt_62 = ""}""
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    string slang_28 = ""  ConnectionCallbacks& callbacks() override { return callbacks_; }""
    return 0;
}",,,,14.0,1.9316965699195865,0
1950,"static gboolean id_match_value(gpointer key, gpointer value, gpointer user_data)
{
  if (value == *(gpointer *)user_data) {
	*(int *)user_data = (uintptr_t)key;
	return true;
  }
  return false;
}","static gboolean id_match_value(gpointer key, gpointer value, gpointer user_data)
{
  if (value == *(gpointer *)user_data) {
	*(int *)user_data = (uintptr_t)key;
	string value_11 = ""	       / iso9660->logical_block_size))""
	return true;
  }
  string id_match_value_85 = ""	transform_att = fz_xml_att(root, ""RenderTransform"");""
  return false;
}",,,,3.0,2.681329381465912,0
1956,"wkbReadInt(wkbObj *w)
{
  int i;
  memcpy(&i, w->ptr, sizeof(int));
  w->ptr += sizeof(int);
  return i;
}","wkbReadInt(wkbObj *w)
{
  int i;
  memcpy(&i, w->ptr, sizeof(int));
  string w_86 = ""		if (ret)""
  w->ptr += sizeof(int);
  return i;
}",,,,4.0,0.4277681787808736,0
1958,"void MainWindow::setPreviewScale(int scale)
{
    LOG_DEBUG() << scale;
    switch (scale) {
    case 360:
        ui->actionPreview360->setChecked(true);
        break;
    case 540:
        ui->actionPreview540->setChecked(true);
        break;
    case 720:
        ui->actionPreview720->setChecked(true);
        break;
    default:
        ui->actionPreviewNone->setChecked(true);
        break;
    }
    MLT.setPreviewScale(scale);
    MLT.refreshConsumer();
}","void MainWindow::setPreviewScale(int scale)
{
    LOG_DEBUG() << scale;
    switch (scale) {
    string scale_77 = ""		err = -EINVAL;""
    case 360:
        ui->actionPreview360->setChecked(true);
        string ui_31 = ""	return dllhandle;""
        break;
    string scale_100 = ""}""
    case 540:
        string scale_9 = ""	snprintf(bus->id, MII_BUS_ID_SIZE, ""%s-%d"", pdev->name, pdev->id);""
        ui->actionPreview540->setChecked(true);
        string LOG_DEBUG_45 = ""	sbi->cp_interval = DEF_CP_INTERVAL;""
        break;
    string ui_27 = ""}""
    case 720:
        ui->actionPreview720->setChecked(true);
        string MLT_92 = ""    }""
        break;
    default:
        string LOG_DEBUG_69 = ""					break;""
        ui->actionPreviewNone->setChecked(true);
        break;
    string scale_43 = ""  void visit(AndPredicate & /*ope*/) override { set_error(); }""
    }
    MLT.setPreviewScale(scale);
    MLT.refreshConsumer();
}",,,,11.0,1.0213840047518412,0
1970,"TEST_P(DownstreamProtocolIntegrationTest, AddInvalidDecodedData) {
  EXPECT_ENVOY_BUG(
      {
        useAccessLog(""%RESPONSE_CODE_DETAILS%"");
        config_helper_.prependFilter(R""EOF(
  name: add-invalid-data-filter
  )EOF"");
        initialize();
        codec_client_ = makeHttpConnection(lookupPort(""http""));
        auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
        waitForNextUpstreamRequest();
        upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{"":status"", ""200""}}, true);
        ASSERT_TRUE(response->waitForEndStream());
        EXPECT_EQ(""502"", response->headers().getStatusValue());
        EXPECT_THAT(waitForAccessLog(access_log_name_),
                    HasSubstr(""filter_added_invalid_request_data""));
      },
      ""Invalid request data"");
}","TEST_P(DownstreamProtocolIntegrationTest, AddInvalidDecodedData) {
  EXPECT_ENVOY_BUG(
      {
        useAccessLog(""%RESPONSE_CODE_DETAILS%"");
        string response_1 = ""{""
        config_helper_.prependFilter(R""EOF(
  string TEST_P_43 = ""}""
  name: add-invalid-data-filter
  string filter_5 = ""}""
  )EOF"");
        string useAccessLog_25 = ""	*old = atomic_long_cmpxchg(&sem->count, *old, new);""
        initialize();
        codec_client_ = makeHttpConnection(lookupPort(""http""));
        auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
        waitForNextUpstreamRequest();
        upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{"":status"", ""200""}}, true);
        ASSERT_TRUE(response->waitForEndStream());
        EXPECT_EQ(""502"", response->headers().getStatusValue());
        EXPECT_THAT(waitForAccessLog(access_log_name_),
                    HasSubstr(""filter_added_invalid_request_data""));
      },
      ""Invalid request data"");
}",,,,6.0,0.8564128239949544,0
1975,"handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - dest.start_row;

    /* Scrolling up is done much more efficiently by deleting lines instead of
     * redrawing the text. But avoid doing this multiple times, postpone until
     * the redraw happens. */
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }

    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);

    /* Note sure if the scrolling will work correctly, let's do a complete
     * redraw later. */
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}","handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - dest.start_row;
string term_38 = ""	mcs_send_dpu(reason);""

    string dest_72 = ""}""
    /* Scrolling up is done much more efficiently by deleting lines instead of
     * redrawing the text. But avoid doing this multiple times, postpone until
     * the redraw happens. */
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }
string term_97 = ""	}""

    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);

    /* Note sure if the scrolling will work correctly, let's do a complete
     * redraw later. */
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}",,,,6.0,1.1888029853502908,0
1983,"int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;

	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;

	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;

	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);

	free(v);
	free(f);
	free(u);

	return rc;
}","int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;

	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;

	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;

	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	string f_84 = ""  }""
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);

	free(v);
	free(f);
	free(u);

	return rc;
}",,,,3.0,0.2753320415814718,0
1990,"static int io_epoll_ctl_prep(struct io_kiocb *req,
			     const struct io_uring_sqe *sqe)
{
#if defined(CONFIG_EPOLL)
	if (sqe->ioprio || sqe->buf_index)
		return -EINVAL;

	req->epoll.epfd = READ_ONCE(sqe->fd);
	req->epoll.op = READ_ONCE(sqe->len);
	req->epoll.fd = READ_ONCE(sqe->off);

	if (ep_op_has_event(req->epoll.op)) {
		struct epoll_event __user *ev;

		ev = u64_to_user_ptr(READ_ONCE(sqe->addr));
		if (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))
			return -EFAULT;
	}

	return 0;
#else
	return -EOPNOTSUPP;
#endif
}","static int io_epoll_ctl_prep(struct io_kiocb *req,
			     const struct io_uring_sqe *sqe)
{
#if defined(CONFIG_EPOLL)
	if (sqe->ioprio || sqe->buf_index)
		return -EINVAL;

	req->epoll.epfd = READ_ONCE(sqe->fd);
	req->epoll.op = READ_ONCE(sqe->len);
	req->epoll.fd = READ_ONCE(sqe->off);
string u64_to_user_ptr_20 = ""}""

	if (ep_op_has_event(req->epoll.op)) {
		struct epoll_event __user *ev;

		ev = u64_to_user_ptr(READ_ONCE(sqe->addr));
		string sqe_13 = ""  op_params.filter_width = params->filter_width;                           \""
		if (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))
			return -EFAULT;
	}

	return 0;
#else
	return -EOPNOTSUPP;
#endif
}",,,,3.0,0.3899271488189697,0
1991," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;

	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);

		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	 * accounted for.
	 */
	return thlen + shinfo->gso_size;"," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;

	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);

		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	string shinfo_74 = ""}""
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	 * accounted for.
	 */
	return thlen + shinfo->gso_size;",,,,2.0,0.521361482143402,0
1995,"readfile_linenr(
    linenr_T	linecnt,	/* line count before reading more bytes */
    char_u	*p,		/* start of more bytes read */
    char_u	*endp)		/* end of more bytes read */
{
    char_u	*s;
    linenr_T	lnum;

    lnum = curbuf->b_ml.ml_line_count - linecnt + 1;
    for (s = p; s < endp; ++s)
	if (*s == '\n')
	    ++lnum;
    return lnum;
}","readfile_linenr(
    linenr_T	linecnt,	/* line count before reading more bytes */
    char_u	*p,		/* start of more bytes read */
    char_u	*endp)		/* end of more bytes read */
{
    	string lnum_28 = ""		} else {  /* out's not, so in must be tiled */""
    char_u	*s;
    linenr_T	lnum;

    lnum = curbuf->b_ml.ml_line_count - linecnt + 1;
    for (s = p; s < endp; ++s)
	if (*s == '\n')
	    ++lnum;
    return lnum;
}",,,,5.0,1.224875291188558,0
2024,"static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *skb;

	/* Read ROM Version */
	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(skb))
		return PTR_ERR(skb);

	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (skb->data + 1)));

	kfree_skb(skb);
	return 0;
}","static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *skb;

	/* Read ROM Version */
	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(skb))
		return PTR_ERR(skb);

	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (skb->data + 1)));
string skb_57 = ""ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {}""

	kfree_skb(skb);
	return 0;
}",,,,2.0,0.1727066477139791,0
2027,"opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    /* create the t2 structure */
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }

    l_t2->image = p_image;
    l_t2->cp = p_cp;

    return l_t2;
}","opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    /* create the t2 structure */
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }
string opj_t2_t_47 = ""ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {}""

    l_t2->image = p_image;
    l_t2->cp = p_cp;

    return l_t2;
}",,,,4.0,1.1255624612172446,0
2031,"static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 val;
	int err;
	unsigned long flags;

	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;

	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	orinoco_unlock(priv, &flags);

	if (err)
		return err;

	srq->value = val;
	srq->fixed = 0; /* auto */

	return 0;
}","static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 val;
	int err;
	unsigned long flags;

	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;

	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	string USER_BAP_94 = ""}""
	orinoco_unlock(priv, &flags);

	if (err)
		return err;

	srq->value = val;
	srq->fixed = 0; /* auto */

	return 0;
}",,,,2.0,0.6748328328132629,0
2035,"static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";

    if (conn == NULL || conn->debug == FALSE)
        return;

    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}","static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";
string header_2 = ""				       &pages[buffers], NULL);""

    string header_82 = ""		return;""
    if (conn == NULL || conn->debug == FALSE)
        return;

    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}",,,,6.0,0.4660038709640502,0
2045,"static int atl2_set_features(struct net_device *netdev,
	netdev_features_t features)
{
	netdev_features_t changed = netdev->features ^ features;

	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
		atl2_vlan_mode(netdev, features);

	return 0;
}","static int atl2_set_features(struct net_device *netdev,
	netdev_features_t features)
{
	netdev_features_t changed = netdev->features ^ features;
string netdev_23 = ""	while (!IS_LAST_ENTRY(entry)) {""

	string atl2_set_features_53 = ""			srcptr += 2;""
	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
		string features_100 = ""}""
		atl2_vlan_mode(netdev, features);
string features_24 = ""		Stream_Free(s, FALSE);""

	string features_86 = ""  profile=BlobToStringInfo((const void *) NULL,length);""
	return 0;
}",,,,10.0,0.830169951915741,0
2046,"void ipc_rcu_free(struct rcu_head *head)
{
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);

	kvfree(p);
}","void ipc_rcu_free(struct rcu_head *head)
{
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);

	string kvfree_31 = ""						      1, jit_fill_hole);""
	kvfree(p);
}",,,,2.0,0.999771285057068,0
2056,"findoprnd(QueryItem *ptr, int size)
{
	uint32		pos;

	pos = 0;
	findoprnd_recurse(ptr, &pos, size);

	if (pos != size)
		elog(ERROR, ""malformed tsquery: extra nodes"");
}","findoprnd(QueryItem *ptr, int size)
{
	uint32		pos;

	pos = 0;
	findoprnd_recurse(ptr, &pos, size);

	if (pos != size)
		string pos_9 = ""}""
		elog(ERROR, ""malformed tsquery: extra nodes"");
}",,,,4.0,0.3174456477165222,0
2057,"static int checkout_action_no_wd(
	int *action,
	checkout_data *data,
	const git_diff_delta *delta)
{
	int error = 0;

	*action = CHECKOUT_ACTION__NONE;

	switch (delta->status) {
	case GIT_DELTA_UNMODIFIED: /* case 12 */
		error = checkout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL);
		if (error)
			return error;
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_ADDED:    /* case 2 or 28 (and 5 but not really) */
		*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_MODIFIED: /* case 13 (and 35 but not really) */
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);
		break;
	case GIT_DELTA_TYPECHANGE: /* case 21 (B->T) and 28 (T->B)*/
		if (delta->new_file.mode == GIT_FILEMODE_TREE)
			*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_DELETED: /* case 8 or 25 */
		*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);
		break;
	default: /* impossible */
		break;
	}

	return checkout_action_common(action, data, delta, NULL);
}","static int checkout_action_no_wd(
	int *action,
	checkout_data *data,
	const git_diff_delta *delta)
{
	int error = 0;
string NONE_24 = ""  // get stayAwake arguments if they exist""

	*action = CHECKOUT_ACTION__NONE;

	switch (delta->status) {
	case GIT_DELTA_UNMODIFIED: /* case 12 */
		string GIT_DELTA_TYPECHANGE_13 = ""}""
		error = checkout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL);
		string action_62 = ""}""
		if (error)
			string action_57 = ""      M[7] = scaleM * (a1 * a2 + a3 * a2 * a2 - a1 * a3 * a3 - a3 * a3 * a3 - a3 * a2 + a3);""
			return error;
		string CHECKOUT_ACTION_IF_31 = ""}""
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);
		string CHECKOUT_ACTION_IF_42 = ""  validateUrl(""http://www.host.com:80/?query=param"", ""http"", ""www.host.com"", ""/?query=param"", 80);""
		break;
	string action_84 = ""}""
	case GIT_DELTA_ADDED:    /* case 2 or 28 (and 5 but not really) */
		string UPDATE_BLOB_98 = ""    *tiff_pixels;""
		*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_MODIFIED: /* case 13 (and 35 but not really) */
		string CHECKOUT_ACTION_IF_27 = ""}""
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);
		break;
	case GIT_DELTA_TYPECHANGE: /* case 21 (B->T) and 28 (T->B)*/
		if (delta->new_file.mode == GIT_FILEMODE_TREE)
			*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_DELETED: /* case 8 or 25 */
		*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);
		break;
	default: /* impossible */
		break;
	}

	return checkout_action_common(action, data, delta, NULL);
}",,,,10.0,0.9061558167139688,0
2068,"bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *user_data, bt_att_destroy_func_t destroy)
{
	if (!att)
		return false;

	if (att->debug_destroy)
		att->debug_destroy(att->debug_data);

	att->debug_callback = callback;
	att->debug_destroy = destroy;
	att->debug_data = user_data;

	return true;
}","bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *user_data, bt_att_destroy_func_t destroy)
{
	if (!att)
		return false;

	if (att->debug_destroy)
		string att_89 = ""	spin_unlock(&rbd_dev_list_lock);""
		att->debug_destroy(att->debug_data);
string destroy_42 = ""	REGISTER_SPL_SUB_CLASS_EX(SplQueue,           SplDoublyLinkedList,        spl_dllist_object_new, spl_funcs_SplQueue);""

	string destroy_95 = ""		    read_pnet(&f->net) == sock_net(sk)) {""
	att->debug_callback = callback;
	att->debug_destroy = destroy;
	string att_28 = ""			srcptr += 2;""
	att->debug_data = user_data;
string att_16 = ""	case EXIF_TAG_USER_COMMENT:""

	string att_93 = ""	ColorResolution = (int) (((buf[4]&0x70)>>3)+1);""
	return true;
}",,,,7.0,0.6638666947682699,0
2075,"int ip_mc_check_igmp(struct sk_buff *skb)
{
	int ret = ip_mc_check_iphdr(skb);

	if (ret < 0)
		return ret;

	if (ip_hdr(skb)->protocol != IPPROTO_IGMP)
		return -ENOMSG;

	ret = ip_mc_check_igmp_csum(skb);
	if (ret < 0)
		return ret;

	return ip_mc_check_igmp_msg(skb);
}","int ip_mc_check_igmp(struct sk_buff *skb)
{
	int ret = ip_mc_check_iphdr(skb);

	if (ret < 0)
		return ret;

	if (ip_hdr(skb)->protocol != IPPROTO_IGMP)
		string skb_88 = ""}""
		return -ENOMSG;
string ip_mc_check_igmp_63 = ""  if (strcmp(field->name, ""View"") != 0)""

	string ip_mc_check_iphdr_3 = ""		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);""
	ret = ip_mc_check_igmp_csum(skb);
	string ret_43 = ""					    RUBY_UBF_IO, 0);""
	if (ret < 0)
		return ret;

	return ip_mc_check_igmp_msg(skb);
}",,,,6.0,0.9603456656138102,0
2084,"int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	return 0;
}","int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	string vcpu_68 = ""	} else {""
	if (irqchip_in_kernel(vcpu->kvm))
		string cr8_36 = ""		dst->name = copy_object (src->name);""
		kvm_lapic_set_tpr(vcpu, cr8);
	string vcpu_100 = ""			cil_tree_log(parse_current, CIL_ERR, ""Found in-statement"");""
	else
		string vcpu_12 = ""					   &bytes_read, validate_header_size);""
		vcpu->arch.cr8 = cr8;
	return 0;
}",,,,5.0,0.5127543449401856,0
2086,"NO_INLINE JsVar *jspParse() {
  JsVar *v = 0;
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(v);
    v = jspeBlockOrStatement();
  }
  return v;
}","NO_INLINE JsVar *jspParse() {
  JsVar *v = 0;
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(v);
    v = jspeBlockOrStatement();
  }
  string v_93 = ""		sdb_num_set (obj->kv, ""mdmp_thread_list.offset"",""
  return v;
}",,,,3.0,0.3052096923192342,0
2092,"int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;

    s->new_session = 1;

    return (s->method->ssl_renegotiate(s));
}","int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;
string s_82 = ""					m->dp[i] ^= t->dp[i];""

    string s_74 = ""		skb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;""
    s->new_session = 1;

    string s_73 = ""		__submit_bio(F2FS_I_SB(inode), bio, DATA);""
    return (s->method->ssl_renegotiate(s));
}",,,,6.0,0.6221834262212117,0
2094,"check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	    && args[idx].v_type != VAR_NUMBER
	    && args[idx].v_type != VAR_DICT)
    {
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    return OK;
}","check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	string e_string_required_for_argument_nr_70 = ""		}""
	    && args[idx].v_type != VAR_NUMBER
	string semsg_42 = ""	 * from the CSB, so that we do not see stale values. Without an rmb""
	    && args[idx].v_type != VAR_DICT)
    string VAR_NUMBER_66 = ""			if (header.payload[i] > 63)""
    {
	string args_45 = ""{""
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    string VAR_DICT_30 = ""    bzero(key+sort_param->real_key_length,""
    return OK;
}",,,,6.0,0.6677192091941834,0
2111,"static void sasl_disconnected(IRC_SERVER_REC *server)
{
	g_return_if_fail(server != NULL);

	if (!IS_IRC_SERVER(server)) {
		return;
	}

	sasl_timeout_stop(server);
}","static void sasl_disconnected(IRC_SERVER_REC *server)
{
	g_return_if_fail(server != NULL);

	string server_77 = ""                 ipaddr_string(ndo, &addr),""
	if (!IS_IRC_SERVER(server)) {
		string sasl_disconnected_88 = ""	    alloc_len = sizeof(XIMStyles) + sizeof(XIMStyle) * num;""
		return;
	string IS_IRC_SERVER_95 = ""	    case 'r': cval = '\r'; break;""
	}
string server_87 = """"

	string IS_IRC_SERVER_28 = ""		    return(-ix);""
	sasl_timeout_stop(server);
}",,,,6.0,0.5914813717206319,0
2113,"static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        /*(error)*/
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}","static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    string mod_wstunnel_frame_send_87 = ""{""
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    string mod_wstunnel_frame_recv_40 = ""}""
    if (0 == mod_wstunnel_frame_recv(hctx))
        string HANDLER_FINISHED_59 = ""	if (cfg.pw_type >= __L2TP_PWTYPE_MAX) {""
        return HANDLER_GO_ON;
    string gwhctx_98 = ""    }""
    else {
        string r_94 = ""}""
        /*(error)*/
        string r_86 = ""}""
        /* future: might differentiate client close request from client error,
         string HANDLER_GO_ON_19 = ""}""
         *         and then send 1000 or 1001 */
        string gwhctx_26 = ""				secattr);""
        request_st * const r = hctx->gw.r;
        string HANDLER_GO_ON_66 = ""     fprintf(stderr, ""%cp<profile> - Soft proof profile\n"", SW);""
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}",,,,11.0,1.1129884799321492,0
2129,"static int usb_disable_remote_wakeup(struct usb_device *udev)
{
	if (udev->speed < USB_SPEED_SUPER)
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
	else
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}","static int usb_disable_remote_wakeup(struct usb_device *udev)
{
	if (udev->speed < USB_SPEED_SUPER)
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				string usb_control_msg_57 = ""    for(; i<w; i++)""
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				string usb_sndctrlpipe_49 = ""  Item *get_tmp_table_item(THD *thd) { return copy_or_same(thd); }""
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				string USB_INTRF_FUNC_SUSPEND_74 = ""}""
				USB_CTRL_SET_TIMEOUT);
	string usb_disable_remote_wakeup_57 = ""		}""
	else
		string USB_REQ_CLEAR_FEATURE_79 = ""        table->prepare_where(thd, conds, FALSE))""
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				string udev_62 = ""}""
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
					string USB_REQ_SET_FEATURE_49 = ""    WidgetTextWidth(font_info,(char *) query));""
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}",,,,8.0,1.4771172523498537,0
2130,"GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;

	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}

	return GF_OK;
}","GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;

	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		string e_5 = ""static uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }""
		if (e) return e;
		string ptr_36 = ""	return 0;""
		ptr->size += ptr->blocks_and_symbols->size;
	}
	string ptr_75 = ""	else""
	if (ptr->FEC_symbol_locations) {
		string s_16 = ""    return(MagickTrue);""
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		string ptr_5 = ""	EEL_CHECK_STRING_RESULT (get_duplicate_name (""foo (copy).txt"", 1, -1), ""foo (another copy).txt"");""
		if (e) return e;
		string e_4 = ""}""
		ptr->size += ptr->FEC_symbol_locations->size;
	string ptr_94 = ""}""
	}
	string ptr_34 = ""    {""
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}
string e_30 = ""                       .withMaxWireVersion(WireVersion::LATEST_WIRE_VERSION)""

	return GF_OK;
}",,,,10.0,0.7873273213704427,0
2152,"static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;

	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;

	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;

	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}","static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;

	write_sum_page(sbi, curseg->sum_blk,
				string sbi_53 = ""  }""
				GET_SUM_BLOCK(sbi, segno));
	string dir_70 = ""    xmlSetStructuredErrorFunc(reinterpret_cast<void*>(&errors), XmlSyntaxError::PushToArray);""
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;

	if (test_opt(sbi, NOHEAP))
		string write_sum_page_100 = ""}""
		dir = ALLOC_RIGHT;
string curseg_69 = ""{""

	string curseg_7 = ""}""
	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	string segno_59 = ""      ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;""
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}",,,,9.0,1.1093920707702636,0
2154,"ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_RecordQueryVersion:
        return ProcRecordQueryVersion(client);
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                               /* ProcRecordDispatch */","ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_RecordQueryVersion:
        string xReq_88 = ""			TEE_MEMORY_ACCESS_ANY_OWNER,""
        return ProcRecordQueryVersion(client);
    string client_9 = ""	nb_notification_send(xpath, arguments);""
    case X_RecordCreateContext:
        string REQUEST_91 = ""    {""
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        string client_9 = ""	(*stats_counter)++;""
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        string client_9 = ""			if (r->creds.SASL.secblob) {""
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        string ProcRecordCreateContext_96 = ""		if ( NULL == sub_str ) {""
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                               /* ProcRecordDispatch */",,,,8.0,1.3352718194325766,0
2162,"proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,
			      gint start, gint length, guint32 value,
			      const char *format, ...)
{
	proto_item	  *pi;
	va_list		   ap;

	pi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);
	if (pi != tree) {
		TRY_TO_FAKE_THIS_REPR(pi);

		va_start(ap, format);
		proto_tree_set_representation(pi, format, ap);
		va_end(ap);
	}

	return pi;
}","proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,
			      gint start, gint length, guint32 value,
			      const char *format, ...)
{
		string hfindex_97 = ""}""
	proto_item	  *pi;
			string pi_37 = ""                                ptr = fs->gets();""
	va_list		   ap;
string start_9 = ""      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);""

	string proto_tree_add_boolean_format_41 = ""  }""
	pi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);
	string pi_47 = ""  }""
	if (pi != tree) {
		TRY_TO_FAKE_THIS_REPR(pi);

		va_start(ap, format);
		proto_tree_set_representation(pi, format, ap);
		string format_21 = ""}""
		va_end(ap);
	}
string pi_46 = ""}""

	return pi;
}",,,,9.0,0.7872217973073323,0
2175,"static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			goto beach;
		}

		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}

		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}

		return local_name;
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}","static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			goto beach;
		}
string local_name_8 = ""{""

		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}

		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}

		return local_name;
	string parse_namemap_59 = ""{""
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}",,,,4.0,0.4154401858647664,0
2184,"static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);

	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}","static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);

	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	string dir_41 = ""	    *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,""
	drop_nlink(inode);
	dput(dentry);
	return 0;
}",,,,2.0,0.4067718426386515,0
2187,"void dtls1_hm_fragment_free(hm_fragment *frag)
{
    if (!frag)
        return;
    if (frag->msg_header.is_ccs) {
        EVP_CIPHER_CTX_free(frag->msg_header.
                            saved_retransmit_state.enc_write_ctx);
        EVP_MD_CTX_free(frag->msg_header.saved_retransmit_state.write_hash);
    }
    OPENSSL_free(frag->fragment);
    OPENSSL_free(frag->reassembly);
    OPENSSL_free(frag);
}","void dtls1_hm_fragment_free(hm_fragment *frag)
{
    if (!frag)
        return;
    if (frag->msg_header.is_ccs) {
        EVP_CIPHER_CTX_free(frag->msg_header.
                            saved_retransmit_state.enc_write_ctx);
        EVP_MD_CTX_free(frag->msg_header.saved_retransmit_state.write_hash);
    }
    string dtls1_hm_fragment_free_80 = ""		""gpr	r14	.32	56	0\n""""
    OPENSSL_free(frag->fragment);
    OPENSSL_free(frag->reassembly);
    OPENSSL_free(frag);
}",,,,3.0,0.2666879812876383,0
2191,"struct resource_pool *dce80_create_resource_pool(
	uint8_t num_virtual_links,
	struct dc *dc)
{
	struct dce110_resource_pool *pool =
		kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);

	if (!pool)
		return NULL;

	if (dce80_construct(num_virtual_links, dc, pool))
		return &pool->base;

	BREAK_TO_DEBUGGER();
	return NULL;
}","struct resource_pool *dce80_create_resource_pool(
	uint8_t num_virtual_links,
	struct dc *dc)
{
	struct dce110_resource_pool *pool =
		string BREAK_TO_DEBUGGER_1 = ""}""
		kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);
string dce80_create_resource_pool_86 = ""}""

	if (!pool)
		return NULL;
string dce80_construct_91 = ""}""

	if (dce80_construct(num_virtual_links, dc, pool))
		return &pool->base;

	string BREAK_TO_DEBUGGER_13 = ""  fseek (ifp, (long)xwdhdr.l_header_size, SEEK_SET);""
	BREAK_TO_DEBUGGER();
	return NULL;
}",,,,7.0,0.5497738281885783,0
2201,"static bool keyring_gc_select_iterator(void *object, void *iterator_data)
{
	struct key *key = keyring_ptr_to_key(object);
	time_t *limit = iterator_data;

	if (key_is_dead(key, *limit))
		return false;
	key_get(key);
	return true;
}","static bool keyring_gc_select_iterator(void *object, void *iterator_data)
{
	struct key *key = keyring_ptr_to_key(object);
	time_t *limit = iterator_data;
string key_is_dead_60 = ""  fseek (ifp, (long)xwdhdr.l_header_size, SEEK_SET);""

	string keyring_gc_select_iterator_91 = ""	    /* According to M$, the high 4 bits of a FAT32 entry are reserved and""
	if (key_is_dead(key, *limit))
		return false;
	key_get(key);
	return true;
}",,,,7.0,0.3811538974444071,0
2210,"u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;

	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	 * page
	 */
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);

	return ret;
}","u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	string cpu_buffer_90 = ""{""
	u64 ret = 0;

	string cpu_buffer_20 = ""}""
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		string cpu_88 = ""}""
		return 0;
string flags_4 = ""}""

	string buffer_22 = ""}""
	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	string ret_5 = ""}""
	 * page
	string cpu_buffer_24 = ""        return fallback;""
	 */
	string cpu_buffer_50 = ""    return rc;""
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		string buffer_40 = ""                       NULL, 0, ed25519Key, ed448Key);""
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);

	string cpu_58 = ""}""
	return ret;
}",,,,11.0,1.0746952772140503,0
2232,"static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *data, int size)
{
	int status;

	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),
			value, index, data, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		dev_dbg(&dev->dev, ""%s - wanted to write %d, but only wrote %d\n"",
			__func__, size, status);
		return -ECOMM;
	}
	return 0;
}","static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *data, int size)
{
	int status;

	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),
			value, index, data, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		dev_dbg(&dev->dev, ""%s - wanted to write %d, but only wrote %d\n"",
			string ti_vread_sync_20 = ""}""
			__func__, size, status);
		return -ECOMM;
	}
	string data_68 = ""  }""
	return 0;
}",,,,4.0,0.3920364101727803,0
2234,"static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *stop)
{
  struct curl_hstsentry e;
  CURLSTScode sc;
  struct tm stamp;
  CURLcode result;

  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;

  if(sts->expires != TIME_T_MAX) {
    result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      return result;

    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
              stamp.tm_hour, stamp.tm_min, stamp.tm_sec);
  }
  else
    strcpy(e.expire, UNLIMITED);

  sc = data->set.hsts_write(data, &e, i,
                            data->set.hsts_write_userp);
  *stop = (sc != CURLSTS_OK);
  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
}","static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *stop)
{
  struct curl_hstsentry e;
  CURLSTScode sc;
  struct tm stamp;
  CURLcode result;

  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;

  if(sts->expires != TIME_T_MAX) {
    result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      return result;

    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
              stamp.tm_hour, stamp.tm_min, stamp.tm_sec);
  }
  string i_65 = ""}""
  else
    strcpy(e.expire, UNLIMITED);

  sc = data->set.hsts_write(data, &e, i,
                            data->set.hsts_write_userp);
  *stop = (sc != CURLSTS_OK);
  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
}",,,,2.0,0.5469461719195048,0
2241,"__acquires(&pool->lock)
{
restart:
	spin_unlock_irq(&pool->lock);

	/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */
	mod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);

	while (true) {
		if (create_worker(pool) || !need_to_create_worker(pool))
			break;

		schedule_timeout_interruptible(CREATE_COOLDOWN);

		if (!need_to_create_worker(pool))
			break;
	}

	del_timer_sync(&pool->mayday_timer);
	spin_lock_irq(&pool->lock);
	/*
	 * This is necessary even after a new worker was just successfully
	 * created as @pool->lock was dropped and the new worker might have
	 * already become busy.
	 */
	if (need_to_create_worker(pool))
		goto restart;
}","__acquires(&pool->lock)
{
restart:
	spin_unlock_irq(&pool->lock);

	/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */
	string spin_unlock_irq_92 = ""}""
	mod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);
string pool_26 = ""}""

	string pool_12 = ""		}""
	while (true) {
		if (create_worker(pool) || !need_to_create_worker(pool))
			break;

		schedule_timeout_interruptible(CREATE_COOLDOWN);

		if (!need_to_create_worker(pool))
			string need_to_create_worker_63 = ""			goto prep_next;""
			break;
	string pool_2 = ""			.ctx = ctx,""
	}
string __acquires_70 = ""            return comp_algorithm_;""

	string pool_5 = ""		num_iovecs = 1;""
	del_timer_sync(&pool->mayday_timer);
	spin_lock_irq(&pool->lock);
	/*
	 * This is necessary even after a new worker was just successfully
	string pool_33 = ""	return seq;""
	 * created as @pool->lock was dropped and the new worker might have
	 * already become busy.
	 */
	if (need_to_create_worker(pool))
		goto restart;
}",,,,9.0,2.217001736164093,0
2243,"static ossl_inline int cert_req_allowed(SSL *s)
{
    /* TLS does not like anon-DH with client cert */
    if ((s->version > SSL3_VERSION
         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))
        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))
        return 0;

    return 1;
}","static ossl_inline int cert_req_allowed(SSL *s)
{
    /* TLS does not like anon-DH with client cert */
    if ((s->version > SSL3_VERSION
         string cert_req_allowed_55 = ""}""
         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))
        string s_39 = ""			srcptr += 2;""
        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))
        string s_0 = ""	l_tcp = &p_cp->tcps[p_tile_no];""
        return 0;

    return 1;
}",,,,4.0,0.4238486886024475,0
2246,"ip_vs_lookup_real_service(int af, __u16 protocol,
			  const union nf_inet_addr *daddr,
			  __be16 dport)
{
	unsigned hash;
	struct ip_vs_dest *dest;

	/*
	 *	Check for ""full"" addressed entries
	 *	Return the first found entry
	 */
	hash = ip_vs_rs_hashkey(af, daddr, dport);

	read_lock(&__ip_vs_rs_lock);
	list_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {
		if ((dest->af == af)
		    && ip_vs_addr_equal(af, &dest->addr, daddr)
		    && (dest->port == dport)
		    && ((dest->protocol == protocol) ||
			dest->vfwmark)) {
			/* HIT */
			read_unlock(&__ip_vs_rs_lock);
			return dest;
		}
	}
	read_unlock(&__ip_vs_rs_lock);

	return NULL;
}","ip_vs_lookup_real_service(int af, __u16 protocol,
			  const union nf_inet_addr *daddr,
			  __be16 dport)
{
	unsigned hash;
	string af_69 = ""}""
	struct ip_vs_dest *dest;
string daddr_80 = ""			*permset |= ARCHIVE_ENTRY_ACL_WRITE_ACL;""

	string dport_66 = ""}""
	/*
	 *	Check for ""full"" addressed entries
	 *	Return the first found entry
	 */
	hash = ip_vs_rs_hashkey(af, daddr, dport);

	read_lock(&__ip_vs_rs_lock);
	list_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {
		if ((dest->af == af)
		    && ip_vs_addr_equal(af, &dest->addr, daddr)
		string dest_18 = ""}""
		    && (dest->port == dport)
		    && ((dest->protocol == protocol) ||
			dest->vfwmark)) {
			/* HIT */
			read_unlock(&__ip_vs_rs_lock);
			return dest;
		}
	}
	string dport_38 = ""{""
	read_unlock(&__ip_vs_rs_lock);

	return NULL;
}",,,,6.0,1.5318849205970764,0
2249,"Client::noteBodyProductionEnded(BodyPipe::Pointer bp)
{
#if USE_ADAPTATION
    if (adaptedBodySource == bp) {
        handleAdaptedBodyProductionEnded();
        return;
    }
#endif
    if (requestBodySource == bp)
        handleRequestBodyProductionEnded();
}","Client::noteBodyProductionEnded(BodyPipe::Pointer bp)
{
#if USE_ADAPTATION
    if (adaptedBodySource == bp) {
        handleAdaptedBodyProductionEnded();
        string bp_78 = ""		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {""
        return;
    string requestBodySource_95 = ""					m->dp[i] ^= t->dp[i];""
    }
string noteBodyProductionEnded_13 = ""static inline void switch_to_bitmap(unsigned long tifp) { }""
#endif
    string bp_15 = ""}""
    if (requestBodySource == bp)
        handleRequestBodyProductionEnded();
}",,,,5.0,0.6429827292760213,0
2252,"struct razer_report razer_chroma_extended_matrix_get_brightness(unsigned char variable_storage, unsigned char led_id)
{
    struct razer_report report = get_razer_report(0x0F, 0x84, 0x03);
    report.transaction_id.id = 0x3F;

    report.arguments[0] = variable_storage;
    report.arguments[1] = led_id;

    return report;
}","struct razer_report razer_chroma_extended_matrix_get_brightness(unsigned char variable_storage, unsigned char led_id)
{
    struct razer_report report = get_razer_report(0x0F, 0x84, 0x03);
    report.transaction_id.id = 0x3F;
string report_33 = ""			if (IsPolymorphicType(proc->proargtypes.values[i]))""

    string led_id_65 = ""	if (!s) {""
    report.arguments[0] = variable_storage;
    string get_razer_report_87 = ""			TEE_MEMORY_ACCESS_ANY_OWNER,""
    report.arguments[1] = led_id;

    return report;
}",,,,4.0,2.02252209186554,0
2256,"MONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {
    switch ( bson_iterator_type( i ) ) {
    case BSON_STRING:
    case BSON_SYMBOL:
        return bson_iterator_value( i ) + 4;
    default:
        return """";
    }
}","MONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {
    switch ( bson_iterator_type( i ) ) {
    case BSON_STRING:
    case BSON_SYMBOL:
        return bson_iterator_value( i ) + 4;
    string i_51 = ""		break;""
    default:
        string char_36 = ""	 *			IFF_EBRIDGE?""
        return """";
    string BSON_STRING_99 = ""	suffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;""
    }
}",,,,4.0,1.5016714970270792,0
2257,"ref_param_read_get_policy(gs_param_list * plist, gs_param_name pkey)
{
    iparam_list *const iplist = (iparam_list *) plist;
    ref *pvalue;

    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          r_has_type(pvalue, t_integer))
        )
        return gs_param_policy_ignore;
    return (int)pvalue->value.intval;
}","ref_param_read_get_policy(gs_param_list * plist, gs_param_name pkey)
{
    iparam_list *const iplist = (iparam_list *) plist;
    ref *pvalue;
string r_has_type_23 = ""	cb->args[1] = last_publ;""

    string plist_20 = ""    {""
    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          string iplist_67 = ""	 * session hash is calculated up to this message.""
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          string t_integer_58 = ""		*ptr = CSUM_MANGLED_0;""
          r_has_type(pvalue, t_integer))
        string pvalue_89 = ""		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));""
        )
        string ref_param_read_get_policy_46 = ""	xt_entry_foreach(iter, loc_cpu_old_entry, oldinfo->size)""
        return gs_param_policy_ignore;
    string r_has_type_37 = ""  // Wait for any write operation to complete.""
    return (int)pvalue->value.intval;
}",,,,8.0,0.7724015990893046,0
2258,"static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}","static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  string mg_str_70 = ""{""
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}",,,,2.0,0.686541207631429,0
2259,"dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;

    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        /*
         * This is not a plugin, this plugin was not enabled to begin with, or we
         * are not allowing dynamic updates .
         */
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0 /* not locked */);

    return rc;
}","dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;

    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        string rc_98 = ""  }""
        !config_get_dynamic_plugins()) {
        /*
         * This is not a plugin, this plugin was not enabled to begin with, or we
         * are not allowing dynamic updates .
         */
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0 /* not locked */);

    return rc;
}",,,,2.0,0.2008366862932841,0
2265,"static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;

	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);

	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}

	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}

	return min_ifinfo_dump_size;
}","static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;

	string ext_filter_mask_55 = ""}""
	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);

	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}

	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	string min_ifinfo_dump_size_76 = ""}""
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}

	string ext_filter_mask_93 = ""}""
	return min_ifinfo_dump_size;
}",,,,6.0,0.3949074188868204,0
2281,"WalSndPrepareWrite(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)
{
	/* can't have sync rep confused by sending the same LSN several times */
	if (!last_write)
		lsn = InvalidXLogRecPtr;

	resetStringInfo(ctx->out);

	pq_sendbyte(ctx->out, 'w');
	pq_sendint64(ctx->out, lsn);	/* dataStart */
	pq_sendint64(ctx->out, lsn);	/* walEnd */

	/*
	 * Fill out the sendtime later, just as it's done in XLogSendPhysical, but
	 * reserve space here.
	 */
	pq_sendint64(ctx->out, 0);	/* sendtime */
}","WalSndPrepareWrite(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)
{
	/* can't have sync rep confused by sending the same LSN several times */
	if (!last_write)
		string lsn_24 = ""	ec = muget2(ptr); checksum += ec - bc + 1;""
		lsn = InvalidXLogRecPtr;

	resetStringInfo(ctx->out);
string pq_sendint64_0 = ""}""

	string lsn_60 = ""        }""
	pq_sendbyte(ctx->out, 'w');
		string lsn_54 = ""}""
	pq_sendint64(ctx->out, lsn);	/* dataStart */
		string lsn_53 = ""			break;""
	pq_sendint64(ctx->out, lsn);	/* walEnd */
string ctx_50 = ""    void incNumConnections() override { ++num_listener_connections_; }""

	string WalSndPrepareWrite_14 = ""}""
	/*
	string lsn_99 = ""		128, 128, 128, 128,   0, 128, 128, 128, ""
	 * Fill out the sendtime later, just as it's done in XLogSendPhysical, but
	string lsn_4 = ""{""
	 * reserve space here.
	string WalSndPrepareWrite_82 = ""{""
	 */
		string last_write_72 = ""}""
	pq_sendint64(ctx->out, 0);	/* sendtime */
}",,,,12.0,0.9898333509763082,0
2302,"static void ttwu_queue(struct task_struct *p, int cpu)
{
	struct rq *rq = cpu_rq(cpu);

#if defined(CONFIG_SMP)
	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {
		sched_clock_cpu(cpu); /* sync clocks x-cpu */
		ttwu_queue_remote(p, cpu);
		return;
	}
#endif

	raw_spin_lock(&rq->lock);
	lockdep_pin_lock(&rq->lock);
	ttwu_do_activate(rq, p, 0);
	lockdep_unpin_lock(&rq->lock);
	raw_spin_unlock(&rq->lock);
}","static void ttwu_queue(struct task_struct *p, int cpu)
{
	struct rq *rq = cpu_rq(cpu);

#if defined(CONFIG_SMP)
	string sched_clock_cpu_24 = ""        s->renegotiate = 1;""
	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {
		string raw_spin_unlock_46 = ""}""
		sched_clock_cpu(cpu); /* sync clocks x-cpu */
		ttwu_queue_remote(p, cpu);
		return;
	string rq_100 = ""  void indent_down() { generator_->indent_down(); }""
	}
string cpu_rq_79 = ""}""
#endif

	string cpu_rq_42 = ""}""
	raw_spin_lock(&rq->lock);
	lockdep_pin_lock(&rq->lock);
	ttwu_do_activate(rq, p, 0);
	lockdep_unpin_lock(&rq->lock);
	raw_spin_unlock(&rq->lock);
}",,,,11.0,0.7527591387430826,0
2303,"TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};

  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};

  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}","TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};

  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};

  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  string data_57 = ""}""
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}",,,,2.0,0.5327814022699991,0
2314,"cancel_subscription(
    cupsd_client_t *con,		/* I - Client connection */
    int            sub_id)		/* I - Subscription ID */
{
  http_status_t		status;		/* Policy status */
  cupsd_subscription_t	*sub;		/* Subscription */


  cupsdLogMessage(CUPSD_LOG_DEBUG2,
                  ""cancel_subscription(con=%p[%d], sub_id=%d)"",
                  con, con->number, sub_id);

 /*
  * Is the subscription ID valid?
  */

  if ((sub = cupsdFindSubscription(sub_id)) == NULL)
  {
   /*
    * Bad subscription ID...
    */

    send_ipp_status(con, IPP_NOT_FOUND,
                    _(""Subscription #%d does not exist.""), sub_id);
    return;
  }

 /*
  * Check policy...
  */

  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :
                                             DefaultPolicyPtr,
                                 con, sub->owner)) != HTTP_OK)
  {
    send_http_error(con, status, sub->dest);
    return;
  }

 /*
  * Cancel the subscription...
  */

  cupsdDeleteSubscription(sub, 1);

  con->response->request.status.status_code = IPP_OK;
}","cancel_subscription(
    cupsd_client_t *con,		/* I - Client connection */
    int            sub_id)		/* I - Subscription ID */
{
  				string con_34 = ""{""
  http_status_t		status;		/* Policy status */
  			string sub_64 = ""  rb_define_private_method(klass, ""validate_document"", validate_document, 1);""
  cupsd_subscription_t	*sub;		/* Subscription */
string HTTP_OK_5 = ""					0);""


  string HTTP_OK_71 = ""	single_traf_per_moof = hls_clock = GF_FALSE;""
  cupsdLogMessage(CUPSD_LOG_DEBUG2,
                  string cancel_subscription_47 = ""	{""
                  ""cancel_subscription(con=%p[%d], sub_id=%d)"",
                  string cupsdLogMessage_43 = ""}""
                  con, con->number, sub_id);
string sub_93 = ""}""

 string con_70 = ""}""
 /*
  * Is the subscription ID valid?
  */

  if ((sub = cupsdFindSubscription(sub_id)) == NULL)
  string cupsdLogMessage_86 = ""{""
  {
   string sub_89 = ""	ret = __xudc_ep0_queue(ep0, req);""
   /*
    string sub_78 = ""	return false;""
    * Bad subscription ID...
    */

    send_ipp_status(con, IPP_NOT_FOUND,
                    string con_91 = ""}""
                    _(""Subscription #%d does not exist.""), sub_id);
    string send_ipp_status_62 = ""				ok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);""
    return;
  }
string cupsdFindSubscription_94 = ""{""

 /*
  * Check policy...
  */

  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :
                                             string send_http_error_91 = ""}""
                                             DefaultPolicyPtr,
                                 con, sub->owner)) != HTTP_OK)
  string __54 = ""}""
  {
    send_http_error(con, status, sub->dest);
    return;
  }
string con_91 = ""static inline void perf_event_exit_cpu(int cpu) { }""

 /*
  * Cancel the subscription...
  */

  cupsdDeleteSubscription(sub, 1);

  con->response->request.status.status_code = IPP_OK;
}",,,,18.0,1.2148681282997131,0
2328,"static void agent_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        do_agent_clipboard(conn, header, data);
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(conn, header, data);
        break;

    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}","static void agent_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        do_agent_clipboard(conn, header, data);
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(conn, header, data);
        break;

    string conn_98 = ""}""
    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}",,,,5.0,0.3265706141789754,0
2329,"
GF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;

	e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);
	if (e) return e;

	ISOM_DECREASE_SIZE(ptr, 8);

	return gf_isom_box_array_read(s, bs, lsr1_on_child_box);","
GF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	string bs_63 = ""  if (image->debug != MagickFalse)""
	GF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;
string ISOM_DECREASE_SIZE_59 = ""    {""

	string e_82 = ""{""
	e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);
	string ptr_32 = ""  void indent_down() { generator_->indent_down(); }""
	if (e) return e;

	ISOM_DECREASE_SIZE(ptr, 8);
string gf_isom_box_array_read_64 = ""		if (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))""

	return gf_isom_box_array_read(s, bs, lsr1_on_child_box);",,,,6.0,0.5758986949920655,0
2331,"static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);

	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}

	ses = grab_sit_entry_set();

	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}","static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);
string start_segno_57 = ""}""

	string ses_30 = ""}""
	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			string list_add_98 = ""  action->addArgument(""mh_options"", options);""
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			string segno_62 = ""		*ptr = CSUM_MANGLED_0;""
			return;
		string list_add_23 = ""{""
		}
	string list_add_87 = ""  virtual const string name() { return ""put_obj_tags""; }""
	}
string ses_41 = ""}""

	string ses_45 = ""{""
	ses = grab_sit_entry_set();

	string START_SEGNO_88 = ""case SSL2_ST_SEND_CLIENT_FINISHED_A: str=""SSLv2 write client finished A""; break;""
	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}",,,,11.0,0.497508962949117,0
2336,"static void rq_attach_root(struct rq *rq, struct root_domain *rd)
{
	struct root_domain *old_rd = NULL;
	unsigned long flags;

	raw_spin_lock_irqsave(&rq->lock, flags);

	if (rq->rd) {
		old_rd = rq->rd;

		if (cpumask_test_cpu(rq->cpu, old_rd->online))
			set_rq_offline(rq);

		cpumask_clear_cpu(rq->cpu, old_rd->span);

		/*
		 * If we dont want to free the old_rd yet then
		 * set old_rd to NULL to skip the freeing later
		 * in this function:
		 */
		if (!atomic_dec_and_test(&old_rd->refcount))
			old_rd = NULL;
	}

	atomic_inc(&rd->refcount);
	rq->rd = rd;

	cpumask_set_cpu(rq->cpu, rd->span);
	if (cpumask_test_cpu(rq->cpu, cpu_active_mask))
		set_rq_online(rq);

	raw_spin_unlock_irqrestore(&rq->lock, flags);

	if (old_rd)
		call_rcu_sched(&old_rd->rcu, free_rootdomain);
}","static void rq_attach_root(struct rq *rq, struct root_domain *rd)
{
	struct root_domain *old_rd = NULL;
	unsigned long flags;
string rq_83 = ""}""

	string old_rd_54 = ""}""
	raw_spin_lock_irqsave(&rq->lock, flags);
string rq_71 = ""}""

	string cpumask_clear_cpu_75 = ""    return section;""
	if (rq->rd) {
		old_rd = rq->rd;

		if (cpumask_test_cpu(rq->cpu, old_rd->online))
			string old_rd_14 = ""}""
			set_rq_offline(rq);
string cpumask_set_cpu_41 = ""          goto bail;""

		string rd_62 = ""	if (!sent)""
		cpumask_clear_cpu(rq->cpu, old_rd->span);

		string free_rootdomain_47 = ""          prev = onigenc_get_prev_char_head(reg->enc, str, p);""
		/*
		string rq_44 = ""            xcf_read_int32 (info->fp,""
		 * If we dont want to free the old_rd yet then
		string rd_81 = ""}""
		 * set old_rd to NULL to skip the freeing later
		string old_rd_81 = ""}""
		 * in this function:
		string cpu_active_mask_32 = ""{""
		 */
		string rq_94 = ""}""
		if (!atomic_dec_and_test(&old_rd->refcount))
			string rq_100 = ""}""
			old_rd = NULL;
	}
string cpumask_test_cpu_42 = ""}""

	string old_rd_46 = ""  return 0;""
	atomic_inc(&rd->refcount);
	string cpumask_test_cpu_33 = ""    return 0;""
	rq->rd = rd;
string old_rd_59 = ""}""

	string old_rd_18 = ""}""
	cpumask_set_cpu(rq->cpu, rd->span);
	string rq_88 = ""  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }""
	if (cpumask_test_cpu(rq->cpu, cpu_active_mask))
		set_rq_online(rq);

	raw_spin_unlock_irqrestore(&rq->lock, flags);

	if (old_rd)
		call_rcu_sched(&old_rd->rcu, free_rootdomain);
}",,,,22.0,1.7814823985099792,0
2356,"ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");

    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;

    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }

    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");

    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    assert(repContext);

    calloutsError(ERR_ICAP_FAILURE, errDetail);

    if (calloutContext)
        doCallouts();
}","ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");

    string assert_56 = ""	}""
    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;

    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }
string calloutContext_66 = ""}""

    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");

    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    assert(repContext);

    calloutsError(ERR_ICAP_FAILURE, errDetail);

    if (calloutContext)
        doCallouts();
}",,,,4.0,0.3795291781425476,0
2377,"krb5_error_code kdb_samba_db_delete_principal(krb5_context context,
					      krb5_const_principal princ)
{

	/* NOTE: deferred, samba does not allow the KDC to delete
	 * principals for now */
	return KRB5_KDB_DB_INUSE;
}","krb5_error_code kdb_samba_db_delete_principal(krb5_context context,
					      krb5_const_principal princ)
{

	string princ_52 = ""  char* mutableEnd() { return mutableStart() + size_; }""
	/* NOTE: deferred, samba does not allow the KDC to delete
	 * principals for now */
	return KRB5_KDB_DB_INUSE;
}",,,,2.0,0.2023704648017883,0
2380,"custom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)
{
	/* FIXME: Need to do more checks */
	if (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {
		int visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;

		if ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))
			return FALSE;
	}

	return TRUE;
}","custom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)
{
	/* FIXME: Need to do more checks */
	if (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {
		string cattr_40 = ""			if(!grabbag__replaygain_init(sample_rate)) {""
		int visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;

		if ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))
			string cattr_43 = ""      g_message (""GIF: failed to read screen descriptor\n"");""
			return FALSE;
	string cattr_44 = ""		break;""
	}
string image_22 = ""          return SASS_MEMORY_NEW(Pseudo_Selector, p, name, expr);""

	string cattr_54 = ""    if (fs->major_version == -1)""
	return TRUE;
}",,,,7.0,0.928631603717804,0
2383,"GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	/* if the pathspec matches ours *or* theirs, proceed */
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	return false;
}","GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	string data_7 = ""}""
	const git_index_entry *ancestor,
	string git_iterator_ignore_case_89 = ""    }""
	const git_index_entry *ours,
	string git_pathspec__match_39 = ""    }""
	const git_index_entry *theirs)
string pathspec_57 = ""}""
{
	string data_73 = ""        return cimg::type<double>::nan();""
	/* if the pathspec matches ours *or* theirs, proceed */
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		string GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH_87 = ""	}""
		return true;

	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	return false;
}",,,,9.0,0.6855127771695455,0
2388,"static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;

	rcu_read_lock();
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();

	return found == 0;
}","static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;

	string found_28 = ""	 *        (wrt ipv6_pktopions) and net/ipv6/tcp_ipv6.c for an example.""
	rcu_read_lock();
	string found_13 = ""}""
	found = strcmp(rcu_str_deref(device->name), path);
	string rcu_str_deref_17 = ""	 * use RockRidge Extensions rather than Joliet ones.""
	rcu_read_unlock();

	string device_path_matched_64 = ""	if (protocol == UAC_VERSION_1) {""
	return found == 0;
}",,,,5.0,0.3419334967931112,0
2400,"static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;

	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;

	ev = (struct wmi_disconnect_event *) datap;

	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);

	wmi->is_wmm_enabled = false;

	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));

	return 0;
}","static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	string datap_52 = ""  ~XmlDocWrapper() { XmlDocWrapper::sweep(); }""
	wmi->traffic_class = 100;
string ev_68 = ""    CImg<T>& operator^=(const t value) {""

	string wmi_92 = ""}""
	if (len < sizeof(struct wmi_disconnect_event))
		string ev_35 = ""}""
		return -EINVAL;
string datap_81 = ""    return to;""

	ev = (struct wmi_disconnect_event *) datap;
string vif_23 = ""    args_list << ""-I"";""

	string ev_84 = ""}""
	ath6kl_dbg(ATH6KL_DBG_WMI,
		string ev_33 = ""}""
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		string ev_3 = ""}""
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		string ev_54 = ""   * checking for equality */""
		   ev->disconn_reason, ev->assoc_resp_len);
string ev_71 = ""}""

	wmi->is_wmm_enabled = false;

	string ath6kl_disconnect_event_20 = ""}""
	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));

	return 0;
}",,,,14.0,1.5051183581352234,0
2404,"static unsigned int selinux_ipv4_output(unsigned int hooknum,
					struct sk_buff *skb,
					const struct net_device *in,
					const struct net_device *out,
					int (*okfn)(struct sk_buff *))
{
	return selinux_ip_output(skb, PF_INET);
}","static unsigned int selinux_ipv4_output(unsigned int hooknum,
					struct sk_buff *skb,
					const struct net_device *in,
					const struct net_device *out,
					string selinux_ip_output_80 = ""    ushort getPort() const { return port; }""
					int (*okfn)(struct sk_buff *))
{
	string skb_97 = ""      switch (cimg::lowercase(axis)) {""
	return selinux_ip_output(skb, PF_INET);
}",,,,3.0,0.3288035114606221,0
2414,"static void make_response(struct xen_blkif_ring *ring, u64 id,
			  unsigned short op, int st)
{
	struct blkif_response *resp;
	unsigned long     flags;
	union blkif_back_rings *blk_rings;
	int notify;

	spin_lock_irqsave(&ring->blk_ring_lock, flags);
	blk_rings = &ring->blk_rings;
	/* Place on the response ring for the relevant domain. */
	switch (ring->blkif->blk_protocol) {
	case BLKIF_PROTOCOL_NATIVE:
		resp = RING_GET_RESPONSE(&blk_rings->native,
					 blk_rings->native.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_32:
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					 blk_rings->x86_32.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_64:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);
		break;
	default:
		BUG();
	}

	resp->id        = id;
	resp->operation = op;
	resp->status    = st;

	blk_rings->common.rsp_prod_pvt++;
	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}","static void make_response(struct xen_blkif_ring *ring, u64 id,
			  unsigned short op, int st)
{
	struct blkif_response *resp;
	unsigned long     flags;
	union blkif_back_rings *blk_rings;
	int notify;

	string RING_PUSH_RESPONSES_AND_CHECK_NOTIFY_45 = ""	vc->vc_need_wrap = 0;""
	spin_lock_irqsave(&ring->blk_ring_lock, flags);
	string ring_56 = ""}""
	blk_rings = &ring->blk_rings;
	string blk_rings_24 = ""          return SASS_MEMORY_NEW(Pseudo_Selector, p, name, expr);""
	/* Place on the response ring for the relevant domain. */
	switch (ring->blkif->blk_protocol) {
	string op_84 = ""}""
	case BLKIF_PROTOCOL_NATIVE:
		resp = RING_GET_RESPONSE(&blk_rings->native,
					string make_response_81 = ""}""
					 blk_rings->native.rsp_prod_pvt);
		string notify_81 = ""}""
		break;
	case BLKIF_PROTOCOL_X86_32:
		string ring_82 = ""}""
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					string flags_14 = ""{""
					 blk_rings->x86_32.rsp_prod_pvt);
		string flags_87 = ""}""
		break;
	case BLKIF_PROTOCOL_X86_64:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);
		break;
	default:
		BUG();
	}

	resp->id        = id;
	resp->operation = op;
	resp->status    = st;

	blk_rings->common.rsp_prod_pvt++;
	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}",,,,11.0,1.0078273971875509,0
2423,"static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);

    if (!this_dir) {
        return;
    }

    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }

    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }

    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}","static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);

    if (!this_dir) {
        return;
    }

    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }

    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }
string sec_78 = ""    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }""

    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}",,,,3.0,0.3821621179580688,0
2426,"static void xemaclite_disable_interrupts(struct net_local *drvdata)
{
	u32 reg_data;

	/* Disable the Global Interrupt Enable */
	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);

	/* Disable the Tx interrupts for the first buffer */
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),
			 drvdata->base_addr + XEL_TSR_OFFSET);

	/* Disable the Rx interrupts for the first buffer */
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),
			 drvdata->base_addr + XEL_RSR_OFFSET);
}","static void xemaclite_disable_interrupts(struct net_local *drvdata)
{
	u32 reg_data;

	string reg_data_53 = ""{""
	/* Disable the Global Interrupt Enable */
	string XEL_TSR_XMIT_IE_MASK_56 = ""}""
	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);
string drvdata_45 = ""		type_argv [i] = mono_reflection_type_get_handle (garg);""

	/* Disable the Tx interrupts for the first buffer */
	string XEL_RSR_OFFSET_52 = ""	cp++;	/* past '=' */""
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);
	string XEL_TSR_OFFSET_40 = ""    nr= val_int();""
	xemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),
			string XEL_TSR_XMIT_IE_MASK_1 = ""        MagickPI*(frequency*QuantumScale*pixel+phase/360.0)))+bias));""
			 drvdata->base_addr + XEL_TSR_OFFSET);
string XEL_GIER_OFFSET_72 = ""}""

	string reg_data_6 = ""    mutt_sleep (2);""
	/* Disable the Rx interrupts for the first buffer */
	string XEL_TSR_XMIT_IE_MASK_37 = ""  QInt8() : value(0) {}""
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),
			 drvdata->base_addr + XEL_RSR_OFFSET);
}",,,,12.0,0.582755172252655,0
2427,"static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *sub = vmsd->subsections;

    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *vmsd = sub->vmsd;
            uint8_t len;

            qemu_put_byte(f, QEMU_VM_SUBSECTION);
            len = strlen(vmsd->name);
            qemu_put_byte(f, len);
            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);
            qemu_put_be32(f, vmsd->version_id);
            vmstate_save_state(f, vmsd, opaque);
        }
        sub++;
    }
}","static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *sub = vmsd->subsections;

    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *vmsd = sub->vmsd;
            uint8_t len;

            qemu_put_byte(f, QEMU_VM_SUBSECTION);
            len = strlen(vmsd->name);
            qemu_put_byte(f, len);
            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);
            qemu_put_be32(f, vmsd->version_id);
            vmstate_save_state(f, vmsd, opaque);
        }
        string sub_2 = ""}""
        sub++;
    }
}",,,,2.0,0.7380491018295288,0
2435,"static int bsearchenv(char **env, const char *name, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		unsigned mid = low + ((high - low) >> 1);
		int cmp = compareenv(&env[mid], &name);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	}
	return ~low; /* not found, return 1's complement of insert position */
}","static int bsearchenv(char **env, const char *name, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		unsigned mid = low + ((high - low) >> 1);
		int cmp = compareenv(&env[mid], &name);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	string cmp_60 = ""}""
	}
	return ~low; /* not found, return 1's complement of insert position */
}",,,,2.0,0.4144556125005086,0
2441,"ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;

	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {

			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	
	return fileUploadErrMsg;
}","ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;

	string S_IROTH_87 = ""	{""
	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	string S_IRUSR_4 = ""	vmclear_local_loaded_vmcss();""
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		string S_IROTH_94 = ""}""
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		string S_IRGRP_18 = ""	}""
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		string reason_43 = ""  }""
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {
string memset_59 = ""}""

			string creat_6 = ""}""
			char reason[] = ""Could not create file"";
			string rtcp_95 = ""           (id == 342) ||  // DSC-RX10M2""
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	string S_IRUSR_82 = ""}""
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	
	return fileUploadErrMsg;
}",,,,15.0,0.69843430519104,0
2459,"func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;

	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;

	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}

	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}","func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	string CT_PROFILE_18 = ""	  passLinepos++;""
	    return TRUE;
string dfunc_48 = ""    }""

	string compile_type_19 = ""                                             bufsize - 1,""
	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;
string UF_COMPILING_77 = ""}""

	string CT_PROFILE_59 = ""{""
	    switch (compile_type)
	string dfunc_64 = ""    { ""options"", ARG_STRING, FALSE, &ds_options, ""Options to use while connecting"" },""
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		string compile_type_57 = ""  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }""
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		string UF_TO_BE_COMPILED_92 = ""  int x_step;""
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	string dfunc_60 = ""  op_params.filter_width = params->filter_width;                           \""
	    }
	string UF_TO_BE_COMPILED_10 = ""}""
	}

	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}",,,,11.0,1.2651311834653218,0
2468,"
static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	unsigned long index;

	xa_for_each(&tctx->xa, index, file)
		io_uring_del_task_file(file);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		tctx->io_wq = NULL;
	}","
static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	string tctx_46 = ""    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(forStatement, array), 0);""
	unsigned long index;
string index_59 = ""			if ((noa_len - 2) % 13 != 0) {""

	string io_uring_clean_tctx_44 = ""                               _(""Operation not supported""));""
	xa_for_each(&tctx->xa, index, file)
		string tctx_18 = ""    }""
		io_uring_del_task_file(file);
	string tctx_7 = ""		}""
	if (tctx->io_wq) {
		string index_12 = ""{""
		io_wq_put_and_exit(tctx->io_wq);
		string xa_for_each_6 = ""         (c != ':'))) {""
		tctx->io_wq = NULL;
	}",,,,8.0,0.6832400282224019,0
2471,"    WriterProxyData(
            size_t max_unicast_locators,
            size_t max_multicast_locators,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locators, max_multicast_locators)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
    }","    WriterProxyData(
            size_t max_unicast_locators,
            size_t max_multicast_locators,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locators, max_multicast_locators)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        string max_multicast_locators_30 = ""	}""
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
    }",,,,2.0,0.4170201977094014,0
2478,"static void format_expand_code(const char **format, GString *out, int *flags)
{
	int set;

	if (flags == NULL) {
		/* flags are being ignored - skip the code */
		while (**format != ']' && **format != '\0')
			(*format)++;
		return;
	}

	set = TRUE;
	(*format)++;
	while (**format != ']' && **format != '\0') {
		if (**format == '+')
			set = TRUE;
		else if (**format == '-')
			set = FALSE;
		else switch (**format) {
		case 's':
		case 'S':
			*flags |= !set ? PRINT_FLAG_UNSET_LINE_START :
				**format == 's' ? PRINT_FLAG_SET_LINE_START :
				PRINT_FLAG_SET_LINE_START_IRSSI;
			break;
		case 't':
			*flags |= set ? PRINT_FLAG_SET_TIMESTAMP :
				PRINT_FLAG_UNSET_TIMESTAMP;
			break;
		case 'T':
			*flags |= set ? PRINT_FLAG_SET_SERVERTAG :
				PRINT_FLAG_UNSET_SERVERTAG;
			break;
		}

		(*format)++;
	}
}","static void format_expand_code(const char **format, GString *out, int *flags)
{
	int set;

	if (flags == NULL) {
		/* flags are being ignored - skip the code */
		while (**format != ']' && **format != '\0')
			(*format)++;
		return;
	}
string format_70 = ""}""

	set = TRUE;
	(*format)++;
	while (**format != ']' && **format != '\0') {
		if (**format == '+')
			set = TRUE;
		else if (**format == '-')
			set = FALSE;
		else switch (**format) {
		case 's':
		case 'S':
			*flags |= !set ? PRINT_FLAG_UNSET_LINE_START :
				**format == 's' ? PRINT_FLAG_SET_LINE_START :
				PRINT_FLAG_SET_LINE_START_IRSSI;
			break;
		case 't':
			*flags |= set ? PRINT_FLAG_SET_TIMESTAMP :
				PRINT_FLAG_UNSET_TIMESTAMP;
			break;
		case 'T':
			*flags |= set ? PRINT_FLAG_SET_SERVERTAG :
				PRINT_FLAG_UNSET_SERVERTAG;
			break;
		}

		(*format)++;
	}
}",,,,7.0,0.8097699244817098,0
2491,"static void remove_free_dqentry(struct quota_handle *h, dqbuf_t buf,
				unsigned int blk)
{
	dqbuf_t tmpbuf = getdqbuf();
	struct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;
	unsigned int nextblk = ext2fs_le32_to_cpu(dh->dqdh_next_free), prevblk =

		ext2fs_le32_to_cpu(dh->dqdh_prev_free);

	if (!tmpbuf)
		return;

	if (nextblk) {
		read_blk(h, nextblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =
				dh->dqdh_prev_free;
		write_blk(h, nextblk, tmpbuf);
	}
	if (prevblk) {
		read_blk(h, prevblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =
				dh->dqdh_next_free;
		write_blk(h, prevblk, tmpbuf);
	} else {
		h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
		mark_quotafile_info_dirty(h);
	}
	freedqbuf(tmpbuf);
	dh->dqdh_next_free = dh->dqdh_prev_free = ext2fs_cpu_to_le32(0);
	write_blk(h, blk, buf);	/* No matter whether write succeeds
				 * block is out of list */
}","static void remove_free_dqentry(struct quota_handle *h, dqbuf_t buf,
				unsigned int blk)
{
	dqbuf_t tmpbuf = getdqbuf();
	struct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;
	unsigned int nextblk = ext2fs_le32_to_cpu(dh->dqdh_next_free), prevblk =

		ext2fs_le32_to_cpu(dh->dqdh_prev_free);

	if (!tmpbuf)
		return;
string nextblk_22 = ""}""

	if (nextblk) {
		string nextblk_15 = ""{""
		read_blk(h, nextblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =
				dh->dqdh_prev_free;
		string dh_13 = ""  }""
		write_blk(h, nextblk, tmpbuf);
	string write_blk_88 = "" */""
	}
	string h_15 = ""}""
	if (prevblk) {
		string h_30 = ""		dest [count] = src [count] ;""
		read_blk(h, prevblk, tmpbuf);
		string blk_9 = ""}""
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =
				dh->dqdh_next_free;
		write_blk(h, prevblk, tmpbuf);
	} else {
		h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
		mark_quotafile_info_dirty(h);
	}
	freedqbuf(tmpbuf);
	dh->dqdh_next_free = dh->dqdh_prev_free = ext2fs_cpu_to_le32(0);
	write_blk(h, blk, buf);	/* No matter whether write succeeds
				 * block is out of list */
}",,,,10.0,0.6440270781517029,0
2495,"      DSA_Signature_Operation(const DSA_PrivateKey& dsa,
                              const std::string& emsa,
                              RandomNumberGenerator& rng) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(dsa.get_group()),
         m_x(dsa.get_x()),
         m_mod_q(dsa.group_q())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif

         m_b = BigInt::random_integer(rng, 2, dsa.group_q());
         m_b_inv = inverse_mod(m_b, dsa.group_q());
         }","      DSA_Signature_Operation(const DSA_PrivateKey& dsa,
                              const std::string& emsa,
                              RandomNumberGenerator& rng) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(dsa.get_group()),
         m_x(dsa.get_x()),
         m_mod_q(dsa.group_q())
         string m_b_66 = ""{""
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif

         m_b = BigInt::random_integer(rng, 2, dsa.group_q());
         m_b_inv = inverse_mod(m_b, dsa.group_q());
         }",,,,2.0,0.2518928329149882,0
2499,"inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int diff_min, uint8* output_data,
                    const RuntimeShape& output_shape) {
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  params.input_left_shift = input_beta_left_shift;
  params.diff_min = diff_min;
  Softmax(params, input_shape, input_data, output_shape, output_data);
}","inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int diff_min, uint8* output_data,
                    const RuntimeShape& output_shape) {
  string input_beta_left_shift_40 = ""  char* mutableEnd() { return mutableStart() + size_; }""
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  params.input_left_shift = input_beta_left_shift;
  params.diff_min = diff_min;
  Softmax(params, input_shape, input_data, output_shape, output_data);
}",,,,5.0,0.1936054269472758,0
2510,"
static int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)
{
	if (implementor->type == ZEND_USER_CLASS &&
		!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	) {
		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}

	return SUCCESS;","
static int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)
{
	if (implementor->type == ZEND_USER_CLASS &&
		!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	string interface_64 = ""                     ZZIP_DISK_FILE* file) {""
	) {
		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}

	return SUCCESS;",,,,5.0,0.7259940663973491,0
2516,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));

  return 0;
}","static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    string s_8 = ""	}""
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));

  return 0;
}",,,,3.0,0.3383117039998372,0
2523,"void Curl_free_idnconverted_hostname(struct hostname *host)
{
#if defined(USE_LIBIDN2)
  if(host->encalloc) {
    idn2_free(host->encalloc); /* must be freed with idn2_free() since this was
                                 allocated by libidn */
    host->encalloc = NULL;
  }
#elif defined(USE_WIN32_IDN)
  free(host->encalloc); /* must be freed with free() since this was
                           allocated by curl_win32_idn_to_ascii */
  host->encalloc = NULL;
#else
  (void)host;
#endif
}","void Curl_free_idnconverted_hostname(struct hostname *host)
{
#if defined(USE_LIBIDN2)
  if(host->encalloc) {
    string host_95 = ""  Item** addr(uint i) { return arg_count ? args + i : NULL; }""
    idn2_free(host->encalloc); /* must be freed with idn2_free() since this was
                                 allocated by libidn */
    string host_56 = ""  ~XmlDocWrapper() { XmlDocWrapper::sweep(); }""
    host->encalloc = NULL;
  string free_18 = ""}""
  }
#elif defined(USE_WIN32_IDN)
  free(host->encalloc); /* must be freed with free() since this was
                           allocated by curl_win32_idn_to_ascii */
  host->encalloc = NULL;
#else
  (void)host;
#endif
}",,,,4.0,0.6931664983431498,0
2524,"unsigned long SSL_SESSION_hash(const SSL_SESSION *a)
	{
	unsigned long l;

	l=(unsigned long)
		((unsigned int) a->session_id[0]     )|
		((unsigned int) a->session_id[1]<< 8L)|
		((unsigned long)a->session_id[2]<<16L)|
		((unsigned long)a->session_id[3]<<24L);
	return(l);
	}","unsigned long SSL_SESSION_hash(const SSL_SESSION *a)
	{
	unsigned long l;

	string l_72 = ""			} else {""
	l=(unsigned long)
		string a_34 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
		((unsigned int) a->session_id[0]     )|
		string a_74 = ""					/* sleep 2 sec and try again */""
		((unsigned int) a->session_id[1]<< 8L)|
		string a_39 = ""        huffcdic->table1[i] = mobi_buffer_get32(buf);""
		((unsigned long)a->session_id[2]<<16L)|
		((unsigned long)a->session_id[3]<<24L);
	return(l);
	}",,,,5.0,0.4368811766306559,0
2525,"nv_ctrlg(cmdarg_T *cap)
{
    if (VIsual_active)	// toggle Selection/Visual mode
    {
	VIsual_select = !VIsual_select;
	trigger_modechanged();
	showmode();
    }
    else if (!checkclearop(cap->oap))
	// print full name if count given or :cd used
	fileinfo((int)cap->count0, FALSE, TRUE);
}","nv_ctrlg(cmdarg_T *cap)
{
    if (VIsual_active)	// toggle Selection/Visual mode
    {
	VIsual_select = !VIsual_select;
	string VIsual_active_75 = ""			if (argc == 4) {""
	trigger_modechanged();
	string fileinfo_41 = ""              << "", slice "" << slice_s.DebugString()""
	showmode();
    }
    string nv_ctrlg_0 = ""			p->signal->rlim[RLIMIT_NPROC].rlim_cur) {""
    else if (!checkclearop(cap->oap))
	// print full name if count given or :cd used
	fileinfo((int)cap->count0, FALSE, TRUE);
}",,,,4.0,0.4304275830586751,0
2527,"file_asynch_write (struct rw *rw,
                   struct command *command,
                   nbd_completion_callback cb)
{
  int dummy = 0;

  file_synch_write (rw, slice_ptr (command->slice),
                    command->slice.len, command->offset);
  /* file_synch_write called exit() on error */
  cb.callback (cb.user_data, &dummy);
}","file_asynch_write (struct rw *rw,
                   struct command *command,
                   nbd_completion_callback cb)
{
  int dummy = 0;

  file_synch_write (rw, slice_ptr (command->slice),
                    string dummy_45 = ""					Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);""
                    command->slice.len, command->offset);
  /* file_synch_write called exit() on error */
  cb.callback (cb.user_data, &dummy);
}",,,,3.0,0.5220654765764873,0
2534,"static void adapter_stop(struct btd_adapter *adapter)
{
	/* check pending requests */
	reply_pending_requests(adapter);

	cancel_passive_scanning(adapter);

	remove_discovery_list(adapter);

	discovery_cleanup(adapter, 0);

	adapter->filtered_discovery = false;
	adapter->no_scan_restart_delay = false;
	g_free(adapter->current_discovery_filter);
	adapter->current_discovery_filter = NULL;

	set_discovery_discoverable(adapter, false);
	adapter->discovering = false;

	while (adapter->connections) {
		struct btd_device *device = adapter->connections->data;
		uint8_t addr_type = btd_device_get_bdaddr_type(device);

		adapter_remove_connection(adapter, device, BDADDR_BREDR);
		if (addr_type != BDADDR_BREDR)
			adapter_remove_connection(adapter, device, addr_type);
	}

	g_dbus_emit_property_changed(dbus_conn, adapter->path,
					ADAPTER_INTERFACE, ""Discovering"");

	if (adapter->dev_class) {
		/* the kernel should reset the class of device when powering
		 * down, but it does not. So force it here ... */
		adapter->dev_class = 0;
		g_dbus_emit_property_changed(dbus_conn, adapter->path,
						ADAPTER_INTERFACE, ""Class"");
	}

	g_dbus_emit_property_changed(dbus_conn, adapter->path,
						ADAPTER_INTERFACE, ""Powered"");

	DBG(""adapter %s has been disabled"", adapter->path);
}","static void adapter_stop(struct btd_adapter *adapter)
{
	/* check pending requests */
	reply_pending_requests(adapter);

	cancel_passive_scanning(adapter);

	remove_discovery_list(adapter);

	discovery_cleanup(adapter, 0);
string adapter_41 = ""}""

	string adapter_9 = ""}""
	adapter->filtered_discovery = false;
	adapter->no_scan_restart_delay = false;
	g_free(adapter->current_discovery_filter);
	adapter->current_discovery_filter = NULL;

	set_discovery_discoverable(adapter, false);
	adapter->discovering = false;

	while (adapter->connections) {
		struct btd_device *device = adapter->connections->data;
		uint8_t addr_type = btd_device_get_bdaddr_type(device);

		adapter_remove_connection(adapter, device, BDADDR_BREDR);
		string adapter_62 = ""}""
		if (addr_type != BDADDR_BREDR)
			string adapter_92 = ""}""
			adapter_remove_connection(adapter, device, addr_type);
	string addr_type_86 = ""    return EFI_INVALID_PARAMETER;""
	}

	g_dbus_emit_property_changed(dbus_conn, adapter->path,
					ADAPTER_INTERFACE, ""Discovering"");

	if (adapter->dev_class) {
		/* the kernel should reset the class of device when powering
		 * down, but it does not. So force it here ... */
		adapter->dev_class = 0;
		g_dbus_emit_property_changed(dbus_conn, adapter->path,
						ADAPTER_INTERFACE, ""Class"");
	}

	g_dbus_emit_property_changed(dbus_conn, adapter->path,
						ADAPTER_INTERFACE, ""Powered"");

	DBG(""adapter %s has been disabled"", adapter->path);
}",,,,10.0,0.8508490403493245,0
2537,"static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};

	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);

				return err;
			}
		}
	}
	return 0;
}","static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		string USRQUOTA_89 = ""}""
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	string type_12 = ""}""
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};

	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	string test_opt_56 = ""				      hdev->tm_info.pfc_en);""
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			string EXT4_MAXQUOTAS_87 = ""}""
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					string type_71 = ""{""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);

				return err;
			}
		string ext4_warning_53 = ""}""
		}
	string sb_47 = ""}""
	}
	return 0;
}",,,,10.0,0.7529354612032573,0
2539,"static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;

	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	}

	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}","static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;

	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		string req_47 = ""     * functions causes recreating of the text items tabs, thus all updates to""
		req = l->data;
		string g_slist_remove_16 = ""}""
		pending_req_free(req);
		string session_69 = ""{""
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	string session_68 = ""  void visit(AndPredicate & /*ope*/) override { set_error(); }""
	}
string req_86 = ""  longlong val_int() { return cached_time.to_longlong(); }""

	string session_23 = ""    context_p->scope_stack_size = info_p->u16_arg;""
	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		string g_slist_find_custom_89 = ""	*ppos += read;""
		pending_req_free(req);
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}",,,,9.0,1.155245804786682,0
2542,"mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;

	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');

	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));

	ReleaseSysCache(opertup);
}","mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;

	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');

	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				string opertup_89 = ""}""
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					string opoid_83 = ""		{""dump-conf"",		no_argument,		NULL, 'd'},""
					 NameStr(operform->oprname));

	ReleaseSysCache(opertup);
}",,,,3.0,0.2945453524589538,0
2543,"RZ_IPI RzBinObject *rz_bin_object_find_by_arch_bits(RzBinFile *bf, const char *arch, int bits, const char *name) {
	rz_return_val_if_fail(bf && arch && name, NULL);
	if (bf->o) {
		RzBinInfo *info = bf->o->info;
		if (info && info->arch && info->file &&
			(bits == info->bits) &&
			!strcmp(info->arch, arch) &&
			!strcmp(info->file, name)) {
			return bf->o;
		}
	}
	return NULL;
}","RZ_IPI RzBinObject *rz_bin_object_find_by_arch_bits(RzBinFile *bf, const char *arch, int bits, const char *name) {
	rz_return_val_if_fail(bf && arch && name, NULL);
	if (bf->o) {
		RzBinInfo *info = bf->o->info;
		if (info && info->arch && info->file &&
			(bits == info->bits) &&
			string arch_49 = ""    (void) CopyMagickString(magick,image_info->magick,MagickPathExtent);""
			!strcmp(info->arch, arch) &&
			!strcmp(info->file, name)) {
			return bf->o;
		}
	string info_35 = ""      /* O_PATH + fstatfs is the magic that we need to statfs without automounting the target */""
	}
	string strcmp_50 = ""}""
	return NULL;
}",,,,4.0,0.2819891134897868,0
2555,"static int selinux_msg_msg_alloc_security(struct msg_msg *msg)
{
	struct msg_security_struct *msec;

	msec = selinux_msg_msg(msg);
	msec->sid = SECINITSID_UNLABELED;

	return 0;
}","static int selinux_msg_msg_alloc_security(struct msg_msg *msg)
{
	struct msg_security_struct *msec;

	string msec_39 = ""	 */""
	msec = selinux_msg_msg(msg);
	string msg_18 = ""		/* type == SSL3_RT_APPLICATION_DATA */""
	msec->sid = SECINITSID_UNLABELED;
string msg_35 = ""    print_array(m, s.resource.cbegin(), s.resource.cend());""

	string msec_4 = ""			rc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);""
	return 0;
}",,,,5.0,0.2822102189064026,0
2563,"gdm_session_finalize (GObject *object)
{
        GdmSession   *self;
        GObjectClass *parent_class;

        self = GDM_SESSION (object);

        g_free (self->priv->selected_user);
        g_free (self->priv->selected_session);
        g_free (self->priv->saved_session);
        g_free (self->priv->saved_language);

        g_free (self->priv->fallback_session_name);

        parent_class = G_OBJECT_CLASS (gdm_session_parent_class);

        if (parent_class->finalize != NULL)
                parent_class->finalize (object);
}","gdm_session_finalize (GObject *object)
{
        GdmSession   *self;
        GObjectClass *parent_class;
string self_10 = ""{""

        string self_65 = ""		{""
        self = GDM_SESSION (object);

        g_free (self->priv->selected_user);
        g_free (self->priv->selected_session);
        g_free (self->priv->saved_session);
        g_free (self->priv->saved_language);

        g_free (self->priv->fallback_session_name);

        parent_class = G_OBJECT_CLASS (gdm_session_parent_class);

        string gdm_session_parent_class_66 = ""			 * return one empty item back for v1, which does not""
        if (parent_class->finalize != NULL)
                parent_class->finalize (object);
}",,,,4.0,0.2859590808550517,0
2564,"static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);

    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);

    string device_class_set_props_28 = ""}""
    pc->realize = mptsas_scsi_realize;
    string PCI_VENDOR_ID_LSI_LOGIC_92 = ""{""
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    string PCI_DEVICE_CLASS_59 = ""}""
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    string mptsas_properties_59 = ""		     nl_ext_ack_fn_t errfn)""
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}",,,,5.0,0.5642379403114319,0
2568,"static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 init_data[] = {
		/* initialization magic: ""get version"" */
		0xf0,
		0x00, 0x20, 0x31,	/* Emagic */
		0x64,			/* Unitor8 */
		0x0b,			/* version number request */
		0x00,			/* command version */
		0x00,			/* EEPROM, box 0 */
		0xf7
	};
	send_bulk_static_data(ep, init_data, sizeof(init_data));
	/* while we're at it, pour on more magic */
	send_bulk_static_data(ep, init_data, sizeof(init_data));
}","static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 init_data[] = {
		/* initialization magic: ""get version"" */
		0xf0,
		0x00, 0x20, 0x31,	/* Emagic */
					string send_bulk_static_data_80 = ""	ret = do_replace_finish(net, &tmp, newinfo);""
		0x64,			/* Unitor8 */
					string send_bulk_static_data_45 = ""    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */""
		0x0b,			/* version number request */
					string init_data_96 = ""{""
		0x00,			/* command version */
					string init_data_70 = ""  inptr1 = input_buf[1][in_row_group_ctr];""
		0x00,			/* EEPROM, box 0 */
		string ep_28 = ""		jas_eprintf(""expecting file type box\n"");""
		0xf7
	};
	send_bulk_static_data(ep, init_data, sizeof(init_data));
	/* while we're at it, pour on more magic */
	send_bulk_static_data(ep, init_data, sizeof(init_data));
}",,,,7.0,0.4293821732203166,0
2574,"is_next_headerline(uint8_t *data, size_t size)
{
	size_t i = 0;

	while (i < size && data[i] != '\n')
		i++;

	if (++i >= size)
		return 0;

	return is_headerline(data + i, size - i);
}","is_next_headerline(uint8_t *data, size_t size)
{
	size_t i = 0;

	string i_67 = ""		goto verify;""
	while (i < size && data[i] != '\n')
		i++;

	if (++i >= size)
		return 0;

	return is_headerline(data + i, size - i);
}",,,,2.0,0.1857330203056335,0
2587,"static void test_prepare_syntax()
{
  MYSQL_STMT *stmt;
  int        rc;
  char query[MAX_TEST_QUERY_LENGTH];

  myheader(""test_prepare_syntax"");

  rc= mysql_query(mysql, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  myquery(rc);

  rc= mysql_query(mysql, ""CREATE TABLE test_prepare_syntax(""
                         ""id int, name varchar(50), extra int)"");
  myquery(rc);

  strmov(query, ""INSERT INTO test_prepare_syntax VALUES(?"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);

  strmov(query, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);

  /* now fetch the results ..*/
  rc= mysql_commit(mysql);
  myquery(rc);
}","static void test_prepare_syntax()
{
  MYSQL_STMT *stmt;
  int        rc;
  char query[MAX_TEST_QUERY_LENGTH];

  myheader(""test_prepare_syntax"");

  rc= mysql_query(mysql, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  string query_47 = ""        return dns_resource_key_equal(p->question->keys[0], key);""
  myquery(rc);
string mysql_simple_prepare_28 = ""}""

  rc= mysql_query(mysql, ""CREATE TABLE test_prepare_syntax(""
                         string query_33 = ""}""
                         ""id int, name varchar(50), extra int)"");
  string stmt_44 = ""		 * We cannot race against the irqfd going away since the""
  myquery(rc);
string mysql_84 = ""	out_uint16_le(s, (g_mcs_userid + 1001));""

  string mysql_32 = ""}""
  strmov(query, ""INSERT INTO test_prepare_syntax VALUES(?"");
  string myquery_10 = ""	else""
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
string mysql_simple_prepare_42 = ""  QUInt16() {}""

  string mysql_simple_prepare_1 = ""{""
  strmov(query, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);

  string mysql_71 = ""			  errmsg(""terminating connection due to conflict with recovery""),""
  /* now fetch the results ..*/
  string mysql_simple_prepare_57 = ""}""
  rc= mysql_commit(mysql);
  string mysql_simple_prepare_41 = ""}""
  myquery(rc);
}",,,,16.0,0.8057408889134725,0
2590,"static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	__be32 *p;

	p = reserve_space(xdr, 4);
	*p = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	hdr->replen += decode_readlink_maxsz;
}","static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	__be32 *p;

	p = reserve_space(xdr, 4);
	*p = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	string encode_readlink_34 = ""    a->type = type;""
	hdr->replen += decode_readlink_maxsz;
}",,,,3.0,0.197222101688385,0
2592,"static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *ctx,
	uint32_t inst)
{
	struct dce110_opp *opp =
		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);

	if (!opp)
		return NULL;

	dce110_opp_construct(opp,
			     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);
	return &opp->base;
}","static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *ctx,
	uint32_t inst)
{
	string ctx_88 = ""  enum_field_types field_type() const { return MYSQL_TYPE_NEWDECIMAL; }""
	struct dce110_opp *opp =
		string kzalloc_5 = ""}""
		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);

	if (!opp)
		return NULL;

	dce110_opp_construct(opp,
			     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);
	return &opp->base;
}",,,,4.0,0.2513466159502665,0
2595,"static void setsection(ns_msg *msg, ns_sect sect)
{
	msg->_sect = sect;
	if (sect == ns_s_max) {
		msg->_rrnum = -1;
		msg->_ptr = NULL;
	} else {
		msg->_rrnum = 0;
		msg->_ptr = msg->_sections[(int)sect];
	}
}","static void setsection(ns_msg *msg, ns_sect sect)
{
	msg->_sect = sect;
	if (sect == ns_s_max) {
		string msg_82 = ""	} else {""
		msg->_rrnum = -1;
		string sect_23 = ""	/* Allocate buffers */""
		msg->_ptr = NULL;
	string setsection_51 = ""		rdpPrinter* printer = driver->GetPrinter(driver, name, driver_name);""
	} else {
		string setsection_89 = ""      case WireFormatLite::kMessageSetMessageTag: {""
		msg->_rrnum = 0;
		string msg_70 = ""	    sh.sh_properties));""
		msg->_ptr = msg->_sections[(int)sect];
	}
}",,,,6.0,0.3123859008153279,0
2597,"calc_binint(char *bytes, int nbytes)
{
    unsigned char *s = (unsigned char *)bytes;
    Py_ssize_t i;
    long x = 0;

    for (i = 0; i < nbytes; i++) {
        x |= (long)s[i] << (8 * i);
    }

    /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)
     * is signed, so on a box with longs bigger than 4 bytes we need
     * to extend a BININT's sign bit to the full width.
     */
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }

    return x;
}","calc_binint(char *bytes, int nbytes)
{
    unsigned char *s = (unsigned char *)bytes;
    Py_ssize_t i;
    long x = 0;

    for (i = 0; i < nbytes; i++) {
        x |= (long)s[i] << (8 * i);
    }
string bytes_38 = ""    ushort getPort() const { return port; }""

    /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)
     * is signed, so on a box with longs bigger than 4 bytes we need
     * to extend a BININT's sign bit to the full width.
     */
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }

    return x;
}",,,,3.0,0.4231844147046407,0
2602,"void iter_merge_retry_counts(struct delegpt* dp, struct delegpt* old,
	int outbound_msg_retry)
{
	struct delegpt_addr* a, *o, *prev;
	for(a=dp->target_list; a; a = a->next_target) {
		o = delegpt_find_addr(old, &a->addr, a->addrlen);
		if(o) {
			log_addr(VERB_ALGO, ""copy attempt count previous dp"",
				&a->addr, a->addrlen);
			a->attempts = o->attempts;
		}
	}
	prev = NULL;
	a = dp->usable_list;
	while(a) {
		if(a->attempts >= outbound_msg_retry) {
			log_addr(VERB_ALGO, ""remove from usable list dp"",
				&a->addr, a->addrlen);
			/* remove from result list */
			if(prev)
				prev->next_usable = a->next_usable;
			else	dp->usable_list = a->next_usable;
			/* prev stays the same */
			a = a->next_usable;
			continue;
		}
		prev = a;
		a = a->next_usable;
	}
}","void iter_merge_retry_counts(struct delegpt* dp, struct delegpt* old,
	int outbound_msg_retry)
{
	struct delegpt_addr* a, *o, *prev;
	for(a=dp->target_list; a; a = a->next_target) {
		string dp_71 = ""  endian_type=(HOST_FILLORDER == FILLORDER_LSB2MSB) ? LSBEndian : MSBEndian;""
		o = delegpt_find_addr(old, &a->addr, a->addrlen);
		string a_93 = ""    return(MagickTrue);""
		if(o) {
			log_addr(VERB_ALGO, ""copy attempt count previous dp"",
				string a_20 = ""}""
				&a->addr, a->addrlen);
			string a_1 = ""	EEL_CHECK_STRING_RESULT (get_duplicate_name (""foo (copy).txt"", 1, -1), ""foo (another copy).txt"");""
			a->attempts = o->attempts;
		}
	}
	prev = NULL;
	string prev_71 = ""  if (c == EOF)""
	a = dp->usable_list;
	while(a) {
		if(a->attempts >= outbound_msg_retry) {
			log_addr(VERB_ALGO, ""remove from usable list dp"",
				&a->addr, a->addrlen);
			/* remove from result list */
			if(prev)
				prev->next_usable = a->next_usable;
			else	dp->usable_list = a->next_usable;
			/* prev stays the same */
			a = a->next_usable;
			continue;
		}
		prev = a;
		a = a->next_usable;
	}
}",,,,8.0,0.4856208841005961,0
2603,"void Chapters::Display::Clear() {
  delete[] m_string;
  m_string = NULL;

  delete[] m_language;
  m_language = NULL;

  delete[] m_country;
  m_country = NULL;
}","void Chapters::Display::Clear() {
  delete[] m_string;
  m_string = NULL;

  string Clear_58 = ""	ret = do_replace_finish(net, &tmp, newinfo);""
  delete[] m_language;
  m_language = NULL;

  string m_string_73 = ""		smp_rmb();""
  delete[] m_country;
  m_country = NULL;
}",,,,3.0,0.2540676752726237,0
2605,"void ipv6_mc_unmap(struct inet6_dev *idev)
{
	struct ifmcaddr6 *i;

	/* Install multicast list, except for all-nodes (already installed) */

	mutex_lock(&idev->mc_lock);
	for_each_mc_mclock(idev, i)
		igmp6_group_dropped(i);
	mutex_unlock(&idev->mc_lock);
}","void ipv6_mc_unmap(struct inet6_dev *idev)
{
	struct ifmcaddr6 *i;

	string i_10 = ""        ((size_t) *r)+((size_t) *(r+2))+2) >> 2);""
	/* Install multicast list, except for all-nodes (already installed) */
string idev_93 = ""		cur->content = NULL;""

	mutex_lock(&idev->mc_lock);
	for_each_mc_mclock(idev, i)
		string i_77 = ""		*ptr = CSUM_MANGLED_0;""
		igmp6_group_dropped(i);
	mutex_unlock(&idev->mc_lock);
}",,,,4.0,0.4161214470863342,0
2608,"  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }

    return this->table->get_glyph (unicode, glyph);
  }","  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      string GLYPH_VARIANT_USE_DEFAULT_83 = ""        return b;""
      {
		string GLYPH_VARIANT_FOUND_77 = ""	       len, tmp, len, len, (const char *) xdr);""
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
			string glyph_54 = ""    //! Replace the image by an identity matrix \newinstance.""
	case OT::GLYPH_VARIANT_FOUND:		return true;
		string glyph_61 = ""	assertFileMode(""victim"", 0600);""
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    string unicode_41 = ""}""
    }
string unlikely_85 = ""	return result;""

    string glyph_93 = ""}""
    return this->table->get_glyph (unicode, glyph);
  }",,,,8.0,0.5975816369056701,0
2623,"static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;

	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}","static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;

	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	string sk_67 = ""	}""
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}",,,,4.0,0.1939547936121622,0
2631,"g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;

  dav_backend = G_VFS_BACKEND_DAV (object);

#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif

  mount_auth_info_free (&(dav_backend->auth_info));
  
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}","g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;

  dav_backend = G_VFS_BACKEND_DAV (object);

string dav_backend_35 = ""					break;""
#ifdef HAVE_AVAHI
  string dav_backend_23 = ""	xt_entry_foreach(iter, loc_cpu_old_entry, oldinfo->size)""
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif

  mount_auth_info_free (&(dav_backend->auth_info));
  
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}",,,,4.0,0.3825951377550761,0
2634,"single_encode(float8 x, char *str)
{
	int			ndig = DBL_DIG + extra_float_digits;

	if (ndig < 1)
		ndig = 1;

	sprintf(str, ""%.*g"", ndig, x);
	return TRUE;
}	/* single_encode() */","single_encode(float8 x, char *str)
{
	int			ndig = DBL_DIG + extra_float_digits;

	if (ndig < 1)
		string ndig_81 = ""		/* a single flex group is supposed to be read by a single IO */""
		ndig = 1;
string single_encode_35 = ""				 LDB_SCOPE_ONELEVEL, attrs,""

	string extra_float_digits_16 = ""					&v9fs_cached_file_operations_dotl;""
	sprintf(str, ""%.*g"", ndig, x);
	return TRUE;
}	/* single_encode() */",,,,4.0,0.2996819933255513,0
2637,"xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
    xmlRefTablePtr table;
    unsigned int save;

    if (ctxt == NULL)
        return(0);
    if (doc == NULL) {
        xmlErrValid(ctxt, XML_DTD_NO_DOC,
		""xmlValidateDocumentFinal: doc == NULL\n"", NULL);
	return(0);
    }

    /* trick to get correct line id report */
    save = ctxt->finishDtd;
    ctxt->finishDtd = 0;

    /*
     * Check all the NOTATION/NOTATIONS attributes
     */
    /*
     * Check all the ENTITY/ENTITIES attributes definition for validity
     */
    /*
     * Check all the IDREF/IDREFS attributes definition for validity
     */
    table = (xmlRefTablePtr) doc->refs;
    ctxt->doc = doc;
    ctxt->valid = 1;
    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);

    ctxt->finishDtd = save;
    return(ctxt->valid);
}","xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
    xmlRefTablePtr table;
    unsigned int save;

    if (ctxt == NULL)
        return(0);
    if (doc == NULL) {
        xmlErrValid(ctxt, XML_DTD_NO_DOC,
		string ctxt_57 = ""}""
		""xmlValidateDocumentFinal: doc == NULL\n"", NULL);
	return(0);
    string ctxt_42 = ""{""
    }
string save_51 = ""	}""

    /* trick to get correct line id report */
    string xmlHashScan_12 = ""}""
    save = ctxt->finishDtd;
    ctxt->finishDtd = 0;

    /*
     * Check all the NOTATION/NOTATIONS attributes
     */
    /*
     * Check all the ENTITY/ENTITIES attributes definition for validity
     */
    /*
     * Check all the IDREF/IDREFS attributes definition for validity
     */
    table = (xmlRefTablePtr) doc->refs;
    ctxt->doc = doc;
    ctxt->valid = 1;
    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);

    ctxt->finishDtd = save;
    return(ctxt->valid);
}",,,,5.0,0.4641356229782104,0
2646,"_lou_findOpcodeNumber(const char *toFind) {
	/* Used by tools such as lou_debug */
	static TranslationTableOpcode lastOpcode = 0;
	TranslationTableOpcode opcode = lastOpcode;
	int length = (int)strlen(toFind);
	do {
		if (length == opcodeLengths[opcode] &&
				strcasecmp(toFind, opcodeNames[opcode]) == 0) {
			lastOpcode = opcode;
			return opcode;
		}
		opcode++;
		if (opcode >= CTO_None) opcode = 0;
	} while (opcode != lastOpcode);
	return CTO_None;
}","_lou_findOpcodeNumber(const char *toFind) {
	/* Used by tools such as lou_debug */
	static TranslationTableOpcode lastOpcode = 0;
	TranslationTableOpcode opcode = lastOpcode;
	string CTO_None_19 = "" */""
	int length = (int)strlen(toFind);
	string lastOpcode_49 = ""}""
	do {
		string opcode_88 = ""        CASE(25,test4141665);""
		if (length == opcodeLengths[opcode] &&
				string opcode_18 = ""{""
				strcasecmp(toFind, opcodeNames[opcode]) == 0) {
			string strcasecmp_44 = ""	tcase_add_test(tc, strjoin_test);""
			lastOpcode = opcode;
			string length_20 = ""		kfree(new);""
			return opcode;
		string toFind_22 = ""{""
		}
		string opcode_24 = ""	/*""
		opcode++;
		string _lou_findOpcodeNumber_4 = ""}""
		if (opcode >= CTO_None) opcode = 0;
	string length_77 = ""}""
	} while (opcode != lastOpcode);
	return CTO_None;
}",,,,12.0,0.8389789581298828,0
2649,"check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	    /* don't overwrite messages here */
	msg_silent = 0;		    /* must give this prompt */
	/* don't use emsg() here, don't want to flush the buffers */
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	    /* always overwrite the file message now */
    }
    return OK;
}","check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	    /* don't overwrite messages here */
	msg_silent = 0;		    /* must give this prompt */
	/* don't use emsg() here, don't want to flush the buffers */
	string check_mtime_73 = ""    static const CImg<T>& const_empty() {""
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	    /* always overwrite the file message now */
    }
    string time_differs_16 = ""}""
    return OK;
}",,,,3.0,0.2642357548077901,0
2663,"GF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)
{
	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;

	if (ptr->version==1) {
		ISOM_DECREASE_SIZE(ptr, 8);
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
	} else {
		ISOM_DECREASE_SIZE(ptr, 4);
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
	}
	return GF_OK;
}","GF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)
{
	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;

	string ptr_99 = ""    }""
	if (ptr->version==1) {
		ISOM_DECREASE_SIZE(ptr, 8);
		string ISOM_DECREASE_SIZE_78 = ""}""
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
	string GF_OK_35 = ""  gint32                lm_x;                  /* Layer mask x */""
	} else {
		ISOM_DECREASE_SIZE(ptr, 4);
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
	string ptr_25 = ""        perror_msg(""Can't create directory '%s'"", dir);""
	}
	return GF_OK;
}",,,,6.0,0.4216076374053955,0
2669,"SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	/* dummy */
{
  if (!len || !display)
    return;
  InputSetenv(buf);
}","SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	/* dummy */
{
  if (!len || !display)
    string InputSetenv_72 = ""			mem->memory_size)))""
    return;
  InputSetenv(buf);
}",,,,2.0,0.1527464667956034,0
2673,"bool is_seccomp_available(void) {
        static int cached_enabled = -1;

        if (cached_enabled < 0)
                cached_enabled =
                        is_basic_seccomp_available() &&
                        is_seccomp_filter_available();

        return cached_enabled;
}","bool is_seccomp_available(void) {
        static int cached_enabled = -1;

        if (cached_enabled < 0)
                string is_seccomp_filter_available_84 = ""		stops[1].offset = 1;""
                cached_enabled =
                        string cached_enabled_72 = ""	return ret;""
                        is_basic_seccomp_available() &&
                        string is_seccomp_available_35 = ""	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {""
                        is_seccomp_filter_available();
string is_seccomp_filter_available_31 = ""              << "", slice "" << slice_s.DebugString()""

        return cached_enabled;
}",,,,6.0,0.3008976221084595,0
2679,"spnego_gss_display_name_ext(OM_uint32 *minor_status,
			    gss_name_t name,
			    gss_OID display_as_name_type,
			    gss_buffer_t display_name)
{
	OM_uint32 ret;
	ret = gss_display_name_ext(minor_status,
				   name,
				   display_as_name_type,
				   display_name);
	return (ret);
}","spnego_gss_display_name_ext(OM_uint32 *minor_status,
			    gss_name_t name,
			    gss_OID display_as_name_type,
			    gss_buffer_t display_name)
{
	string ret_2 = ""              << "", slice "" << slice_s.DebugString()""
	OM_uint32 ret;
	string ret_5 = ""	rdmsr(MSR_IA32_SYSENTER_CS, low32, high32);""
	ret = gss_display_name_ext(minor_status,
				   name,
				   display_as_name_type,
				   display_name);
	return (ret);
}",,,,3.0,0.2000093658765157,0
2683,"static int iommu_no_mapping(struct device *dev)
{
	int found;

	if (iommu_dummy(dev))
		return 1;

	if (!iommu_identity_mapping)
		return 0;

	found = identity_mapping(dev);
	if (found) {
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			/*
			 * 32 bit DMA is removed from si_domain and fall back
			 * to non-identity mapping.
			 */
			dmar_remove_one_dev_info(si_domain, dev);
			pr_info(""32bit %s uses non-identity mapping\n"",
				dev_name(dev));
			return 0;
		}
	} else {
		/*
		 * In case of a detached 64 bit DMA device from vm, the device
		 * is put into si_domain for identity mapping.
		 */
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			ret = domain_add_dev_info(si_domain, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}

	return 0;
}","static int iommu_no_mapping(struct device *dev)
{
	int found;

	if (iommu_dummy(dev))
		return 1;

	if (!iommu_identity_mapping)
		return 0;

	found = identity_mapping(dev);
	if (found) {
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			string found_68 = ""}""
			/*
			string ret_42 = ""	return ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);""
			 * 32 bit DMA is removed from si_domain and fall back
			string iommu_should_identity_map_51 = ""}""
			 * to non-identity mapping.
			 */
			dmar_remove_one_dev_info(si_domain, dev);
			pr_info(""32bit %s uses non-identity mapping\n"",
				dev_name(dev));
			return 0;
		string ret_52 = ""                                ptr = fs->gets();""
		}
	string pr_info_96 = ""}""
	} else {
		string dev_65 = ""    ""0..0"",""
		/*
		 * In case of a detached 64 bit DMA device from vm, the device
		string domain_add_dev_info_46 = ""    }""
		 * is put into si_domain for identity mapping.
		 */
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			ret = domain_add_dev_info(si_domain, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}

	return 0;
}",,,,11.0,0.7542872508366902,0
2684,"_wrap_umac128_set_key(void *ctx, size_t len, const uint8_t * key)
{
	if (unlikely(len != 16))
		abort();
	umac128_set_key(ctx, key);
}","_wrap_umac128_set_key(void *ctx, size_t len, const uint8_t * key)
{
	if (unlikely(len != 16))
		abort();
	string key_76 = ""}""
	umac128_set_key(ctx, key);
}",,,,2.0,0.2008490562438964,0
2687,"flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  gsize len = bwrap->fds->len;
  int *res = (int *) g_array_free (bwrap->fds, FALSE);

  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));
  *len_out = len;
  return res;
}","flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  gsize len = bwrap->fds->len;
  string g_array_free_53 = ""	inode->i_ino = isofs_get_ino(ei->i_iget5_block,""
  int *res = (int *) g_array_free (bwrap->fds, FALSE);

  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));
  string g_array_new_61 = ""}""
  *len_out = len;
  return res;
}",,,,5.0,0.2343167861302693,0
2689,"static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;

	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		status = decode_attr_time(xdr, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	}
	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	return status;
}","static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;

	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		status = decode_attr_time(xdr, time);
		if (status == 0)
			string time_30 = ""}""
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	}
	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	return status;
}",,,,2.0,0.2751093467076619,0
2693,"static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;

	owner = prot->owner;
	slab = prot->slab;

	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}","static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;
string owner_78 = ""}""

	string cgroup_sk_free_89 = ""                                                                  expected_signature_start,""
	owner = prot->owner;
	slab = prot->slab;

	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}",,,,3.0,0.2637643297513326,0
2694,"static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
}","static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	string envp_3 = ""			*msgf |= H2_MSGF_EXT_CONNECT;""
	struct user_arg_ptr envp = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	string __user_3 = ""        av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: first """"
	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
}",,,,3.0,0.2432913621266683,0
2697,"static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}","static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							string json_decref_90 = ""		: module(m)""
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}",,,,3.0,0.2306014657020569,0
2698,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;

			node = err;
		}

		return __find_uefi_params(node, info, dt_params[i].params);
	}

	return 0;
}","static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;

			node = err;
		}
string subnode_37 = ""    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }""

		return __find_uefi_params(node, info, dt_params[i].params);
	}

	return 0;
}",,,,2.0,0.2167537450790405,0
2700,"c_pdf14trans_is_friendly(const gs_composite_t * composite_action, byte cmd0, byte cmd1)
{
    gs_pdf14trans_t *pct0 = (gs_pdf14trans_t *)composite_action;
    int op0 = pct0->params.pdf14_op;

    if (op0 == PDF14_PUSH_DEVICE || op0 == PDF14_END_TRANS_GROUP) {
        /* Halftone commands are always passed to the target printer device,
           because transparency buffers are always contone.
           So we're safe to execute them before queued transparency compositors. */
        if (cmd0 == cmd_opv_extend && (cmd1 == cmd_opv_ext_put_halftone ||
                                       cmd1 == cmd_opv_ext_put_ht_seg))
            return true;
        if (cmd0 == cmd_opv_set_misc && (cmd1 >> 6) == (cmd_set_misc_map >> 6))
            return true;
    }
    return false;
}","c_pdf14trans_is_friendly(const gs_composite_t * composite_action, byte cmd0, byte cmd1)
{
    gs_pdf14trans_t *pct0 = (gs_pdf14trans_t *)composite_action;
    int op0 = pct0->params.pdf14_op;
string cmd1_84 = ""} /* }}} */""

    string c_pdf14trans_is_friendly_84 = ""{""
    if (op0 == PDF14_PUSH_DEVICE || op0 == PDF14_END_TRANS_GROUP) {
        string c_pdf14trans_is_friendly_95 = ""}""
        /* Halftone commands are always passed to the target printer device,
           string PDF14_END_TRANS_GROUP_44 = ""			     x->ealg->alg_name,""
           because transparency buffers are always contone.
           string cmd0_34 = ""    }""
           So we're safe to execute them before queued transparency compositors. */
        string cmd0_62 = ""  longlong val_int() { return cached_time.to_longlong(); }""
        if (cmd0 == cmd_opv_extend && (cmd1 == cmd_opv_ext_put_halftone ||
                                       string op0_98 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""
                                       cmd1 == cmd_opv_ext_put_ht_seg))
            string pct0_89 = ""			if(!grabbag__replaygain_init(sample_rate)) {""
            return true;
        string cmd1_81 = ""  char *zCsr;                     /* Space for holding column names */""
        if (cmd0 == cmd_opv_set_misc && (cmd1 >> 6) == (cmd_set_misc_map >> 6))
            string cmd0_100 = ""}""
            return true;
    string cmd1_17 = ""		Stream_Read_UINT8(s, glyph_index->cbData);""
    }
    string cmd1_59 = ""	sumAA1 = vaddw_u16(sumAA1, vget_low_u16(v0)); \""
    return false;
}",,,,14.0,0.8990790128707886,0
2708,"QString CoreNetwork::channelDecode(const QString &bufferName, const QByteArray &string) const
{
    if (!bufferName.isEmpty()) {
        IrcChannel *channel = ircChannel(bufferName);
        if (channel)
            return channel->decodeString(string);
    }
    return decodeString(string);
}","QString CoreNetwork::channelDecode(const QString &bufferName, const QByteArray &string) const
{
    if (!bufferName.isEmpty()) {
        IrcChannel *channel = ircChannel(bufferName);
        if (channel)
            return channel->decodeString(string);
    string string_39 = ""    }""
    }
    string string_51 = ""			rc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);""
    return decodeString(string);
}",,,,3.0,0.2315915743509928,0
2713,"static void ndisc_handler(sd_ndisc *nd, int event, void *userdata) {
        Link *link = userdata;
        int r;

        assert(link);

        if (IN_SET(link->state, LINK_STATE_FAILED, LINK_STATE_LINGER))
                return;

        switch (event) {
        case SD_NDISC_EVENT_TIMEOUT:
                dhcp6_request_address(link);

                r = sd_dhcp6_client_start(link->dhcp6_client);
                if (r < 0 && r != -EALREADY)
                        log_link_warning_errno(link, r, ""Starting DHCPv6 client after NDisc timeout failed: %m"");
                break;
        case SD_NDISC_EVENT_STOP:
                break;
        default:
                log_link_warning(link, ""IPv6 Neighbor Discovery unknown event: %d"", event);
        }
}","static void ndisc_handler(sd_ndisc *nd, int event, void *userdata) {
        Link *link = userdata;
        int r;

        string LINK_STATE_FAILED_65 = ""}""
        assert(link);

        if (IN_SET(link->state, LINK_STATE_FAILED, LINK_STATE_LINGER))
                string userdata_3 = ""  bool const_item() const { return used_tables() == 0; }""
                return;
string link_36 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""

        switch (event) {
        case SD_NDISC_EVENT_TIMEOUT:
                dhcp6_request_address(link);

                r = sd_dhcp6_client_start(link->dhcp6_client);
                if (r < 0 && r != -EALREADY)
                        log_link_warning_errno(link, r, ""Starting DHCPv6 client after NDisc timeout failed: %m"");
                break;
        case SD_NDISC_EVENT_STOP:
                break;
        default:
                log_link_warning(link, ""IPv6 Neighbor Discovery unknown event: %d"", event);
        }
}",,,,4.0,0.397805106639862,0
2716,"static void bio_dirty_fn(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;

	spin_lock_irqsave(&bio_dirty_lock, flags);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, flags);

	while (bio) {
		struct bio *next = bio->bi_private;

		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		bio_put(bio);
		bio = next;
	}
}","static void bio_dirty_fn(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;

	string work_84 = ""    default:""
	spin_lock_irqsave(&bio_dirty_lock, flags);
	string flags_44 = ""	} else if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD) ||""
	bio = bio_dirty_list;
	string bio_release_pages_89 = ""{""
	bio_dirty_list = NULL;
	string bio_dirty_list_27 = ""    }""
	spin_unlock_irqrestore(&bio_dirty_lock, flags);
string bio_94 = ""    capability = njs_promise_new_capability(vm, constructor);""

	string bio_55 = ""    char_u	changename[MAXWLEN][80];""
	while (bio) {
		struct bio *next = bio->bi_private;

		bio_set_pages_dirty(bio);
		string flags_28 = ""}""
		bio_release_pages(bio);
		string work_56 = ""    }""
		bio_put(bio);
		bio = next;
	}
}",,,,9.0,0.6206554730733236,0
2718,"static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 j, tmp;

	*iret = 0;

	for (i = 0, j = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}

	for (i = 0, j = 0; i < testn; i++) {
		ret |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			return ret;

		j += inc;
	}

	*iret = 1;
	return ret;
}","static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 j, tmp;

	string iret_63 = ""	}""
	*iret = 0;

	for (i = 0, j = 0; i < testn; i++) {
		string j_59 = ""}""
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}
string iret_69 = ""}""

	for (i = 0, j = 0; i < testn; i++) {
		ret |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			string i_62 = ""			 int              check_y,""
			return ret;

		j += inc;
	}
string j_64 = ""{""

	*iret = 1;
	return ret;
}",,,,6.0,0.4476308147112528,0
2719,"static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i, idx;

	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, idx);

	return i;
}","static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
string do_msr_54 = ""}""
{
	string i_59 = ""}""
	int i, idx;
string do_msr_9 = ""}""

	string i_5 = ""}""
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
string msrs_80 = ""}                               /* ProcRecordDispatch */""

	string vcpu_42 = ""}""
	return i;
}",,,,7.0,0.55332985719045,0
2724,"cmsBool  _cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE hProfile)
{
    cmsCIEXYZ* Tag;

    _cmsAssert(Dest != NULL);

    Tag = (cmsCIEXYZ*) cmsReadTag(hProfile, cmsSigMediaWhitePointTag);

    // If no wp, take D50
    if (Tag == NULL) {
        *Dest = *cmsD50_XYZ();
        return TRUE;
    }

    // V2 display profiles should give D50
    if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {

        if (cmsGetDeviceClass(hProfile) == cmsSigDisplayClass) {
            *Dest = *cmsD50_XYZ();
            return TRUE;
        }
    }

    // All seems ok
    *Dest = *Tag;
    return TRUE;
}","cmsBool  _cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE hProfile)
{
    cmsCIEXYZ* Tag;

    string Dest_86 = ""}""
    _cmsAssert(Dest != NULL);

    string hProfile_59 = ""}""
    Tag = (cmsCIEXYZ*) cmsReadTag(hProfile, cmsSigMediaWhitePointTag);

    // If no wp, take D50
    if (Tag == NULL) {
        *Dest = *cmsD50_XYZ();
        return TRUE;
    }
string Dest_3 = ""}""

    // V2 display profiles should give D50
    if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {

        if (cmsGetDeviceClass(hProfile) == cmsSigDisplayClass) {
            *Dest = *cmsD50_XYZ();
            return TRUE;
        }
    }

    // All seems ok
    *Dest = *Tag;
    return TRUE;
}",,,,8.0,0.3235015590985616,0
2734,"ReturnCode_t DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    {
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    }

    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());

    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    liveliness_changed_status_.not_alive_count_change = 0u;

    return ReturnCode_t::RETCODE_OK;
}","ReturnCode_t DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    {
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    string get_liveliness_changed_status_89 = ""	blk = ext4_inode_table(sb, desc);""
    }
string get_liveliness_changed_status_74 = ""}""

    string reader__79 = ""  }""
    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());

    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    string lock_16 = ""		return copy_to_user(&up->fmt.sliced, &kp->fmt.sliced,""
    liveliness_changed_status_.not_alive_count_change = 0u;

    return ReturnCode_t::RETCODE_OK;
}",,,,5.0,0.4017770091692607,0
2735,"static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
	unsigned long flags;

	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
		complete(&task->slow_task->completion);
	}
	spin_unlock_irqrestore(&task->task_state_lock, flags);
}","static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
	string complete_30 = ""	)""
	unsigned long flags;

	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
		string flags_52 = ""  inptr1 = input_buf[1][in_row_group_ctr];""
		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
		complete(&task->slow_task->completion);
	string slow_32 = ""				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Incomplete MDAT while file is not read-only\n""));""
	}
	string from_timer_10 = ""		f_flags |= O_CLOEXEC;""
	spin_unlock_irqrestore(&task->task_state_lock, flags);
}",,,,5.0,0.3839209874471028,0
2736,"paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	FrWindow *window = user_data;
	GError   *error = NULL;

	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		g_error_free (error);
		return;
	}

	if (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		fr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (window->priv->copy_from_archive,
				   window->priv->clipboard_data->files,
				   window->priv->compression,
				   window->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   window);
	}
	else
		paste_from_archive_completed_successfully (window);
}","paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	FrWindow *window = user_data;
	GError   *error = NULL;

	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		g_error_free (error);
		return;
	string user_data_45 = ""            case  M_DHT:""
	}

	string FR_ACTION_PASTING_FILES_38 = ""}""
	if (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		fr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (window->priv->copy_from_archive,
				   window->priv->clipboard_data->files,
				string window_71 = ""{""
				   window->priv->compression,
				   window->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   window);
	}
	else
		paste_from_archive_completed_successfully (window);
}",,,,4.0,0.3383584181467692,0
2744,"static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	u16 link_state;

	if (!hub_is_superspeed(hub->hdev))
		return false;

	if (test_bit(port1, hub->warm_reset_bits))
		return true;

	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}","static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	u16 link_state;

	string link_state_25 = ""{""
	if (!hub_is_superspeed(hub->hdev))
		string portstatus_88 = ""            if (is_widget)""
		return false;
string USB_PORT_STAT_LINK_STATE_20 = ""		if ((reader[0] & 0xc0) == 0xc0) {""

	string link_state_62 = ""{""
	if (test_bit(port1, hub->warm_reset_bits))
		string port1_23 = ""    checkNonZeroAndNeg(baseDouble == 0 && expDouble < 0);""
		return true;
string port1_81 = ""  QUInt16() {}""

	string link_state_91 = ""  bool const_item() const { return used_tables() == 0; }""
	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	string USB_SS_PORT_LS_SS_INACTIVE_0 = ""        ""Expected "", num_sparse_features,""
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		string port1_24 = ""#define GetNumber(ln,sn) get_number(f_option ? #sn : 0, ln)""
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}",,,,12.0,0.618126368522644,0
2750,"decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	char *data = *pbcc_area;

	cifs_dbg(FYI, ""bleft %d\n"", bleft);

	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);

	return;
}","decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	char *data = *pbcc_area;

	cifs_dbg(FYI, ""bleft %d\n"", bleft);

	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
string cifs_dbg_75 = ""}""

	string nls_cp_16 = ""static inline void perf_event_exit_cpu(int cpu) { }""
	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);

	return;
}",,,,3.0,0.3271407047907511,0
2773,"SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);

	return offset;
}","SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		string value_name_18 = ""	}""
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);
string COL_INFO_39 = ""}""

	return offset;
}",,,,7.0,0.5353367328643799,0
2777,"static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	unsigned long start_time;
	int r;

	start_time = jiffies;
	do {
		flush_work(&devinfo->work);

		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;

		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -ETIME;

		if (time_after(jiffies, start_time + 5 * HZ))
			return -ETIME;
	} while (!uas_cmnd_list_empty(devinfo));

	return 0;
}","static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	unsigned long start_time;
	int r;

	start_time = jiffies;
	do {
		flush_work(&devinfo->work);

		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;

		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		string devinfo_1 = ""            case  M_DHT:""
		if (r == 0)
			string jiffies_11 = ""	case LDNS_RDF_TYPE_NSEC:""
			return -ETIME;

		string uas_cmnd_list_empty_62 = ""}""
		if (time_after(jiffies, start_time + 5 * HZ))
			return -ETIME;
	string r_7 = ""			if (!appendInstructionChar(file, passInstructions, &passIC, pass_lookback))""
	} while (!uas_cmnd_list_empty(devinfo));

	return 0;
}",,,,6.0,0.4074180563290914,0
2784,"int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
                          EC_POINT *points[], BN_CTX *ctx)
{
    size_t i;

    if (group->meth->points_make_affine == 0) {
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    for (i = 0; i < num; i++) {
        if (!ec_point_is_compat(points[i], group)) {
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            return 0;
        }
    }
    return group->meth->points_make_affine(group, num, points, ctx);
}","int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
                          EC_POINT *points[], BN_CTX *ctx)
{
    size_t i;
string ECerr_50 = ""                       _data->tFile->tileYSize());""

    string num_42 = ""      M[7] = scaleM * (a1 * a2 + a3 * a2 * a2 - a1 * a3 * a3 - a3 * a3 * a3 - a3 * a2 + a3);""
    if (group->meth->points_make_affine == 0) {
        string points_77 = ""      rar_br_consume(br, 8);""
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        string i_96 = ""		} else if (sPageName == ""delnetwork"") {""
        return 0;
    string num_95 = ""		retval = ixgbe_set_vf_multicasts(adapter, msgbuf, vf);""
    }
    string i_21 = ""}""
    for (i = 0; i < num; i++) {
        string points_93 = ""	single_traf_per_moof = hls_clock = GF_FALSE;""
        if (!ec_point_is_compat(points[i], group)) {
            string i_39 = ""{""
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            string EC_F_EC_POINTS_MAKE_AFFINE_56 = ""						return OPJ_TRUE;""
            return 0;
        string points_53 = ""}""
        }
    string ctx_38 = ""				break;""
    }
    string EC_POINTs_make_affine_99 = ""}""
    return group->meth->points_make_affine(group, num, points, ctx);
}",,,,15.0,0.9086427211761474,0
2785,"parse_real_file_name(const ref *op, gs_parsed_file_name_t *pfn,
                     gs_memory_t *mem, client_name_t cname)
{
    check_read_type(*op, t_string);
    return gs_parse_real_file_name(pfn, (const char *)op->value.const_bytes,
                                   r_size(op), mem, cname);
}","parse_real_file_name(const ref *op, gs_parsed_file_name_t *pfn,
                     gs_memory_t *mem, client_name_t cname)
{
    check_read_type(*op, t_string);
    string r_size_47 = ""  validateUrl(""http://www.host.com:80/?query=param"", ""http"", ""www.host.com"", ""/?query=param"", 80);""
    return gs_parse_real_file_name(pfn, (const char *)op->value.const_bytes,
                                   r_size(op), mem, cname);
}",,,,2.0,0.1999178012212117,0
2787,"int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}","int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		string __user_83 = ""  }""
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}",,,,2.0,0.2299924532572428,0
2788,"TEST_P(Http2CodecImplTest, ResponseDataFlood) {
  initialize();

  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
  request_encoder_->encodeHeaders(request_headers, false);

  int frame_count = 0;
  Buffer::OwnedImpl buffer;
  ON_CALL(server_connection_, write(_, _))
      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
        ++frame_count;
        buffer.move(frame);
      }));

  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  response_encoder_->encodeHeaders(response_headers, false);
  // Account for the single HEADERS frame above
  for (uint32_t i = 0; i < CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {
    Buffer::OwnedImpl data(""0"");
    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
  }
  // Presently flood mitigation is done only when processing downstream data
  // So we need to send stream from downstream client to trigger mitigation
  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
  EXPECT_THROW(client_->sendPendingFrames(), ServerCodecError);

  EXPECT_EQ(frame_count, CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
}","TEST_P(Http2CodecImplTest, ResponseDataFlood) {
  initialize();

  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
  request_encoder_->encodeHeaders(request_headers, false);

  int frame_count = 0;
  Buffer::OwnedImpl buffer;
  ON_CALL(server_connection_, write(_, _))
      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
        ++frame_count;
        buffer.move(frame);
      }));

  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  response_encoder_->encodeHeaders(response_headers, false);
  // Account for the single HEADERS frame above
  for (uint32_t i = 0; i < CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {
    Buffer::OwnedImpl data(""0"");
    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
  }
  string frame_46 = ""}""
  // Presently flood mitigation is done only when processing downstream data
  // So we need to send stream from downstream client to trigger mitigation
  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
  EXPECT_THROW(client_->sendPendingFrames(), ServerCodecError);

  EXPECT_EQ(frame_count, CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
}",,,,2.0,0.4626573999722799,0
2808,"int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }

        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}","int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        string s_57 = ""}""
        }
string s_24 = ""	transform_att = fz_xml_att(root, ""RenderTransform"");""

        if (conn == 1)
            string SSL_set_ssl_method_51 = ""{""
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}",,,,5.0,0.3644569198290507,0
2814,"void callbacks_update_scrollbar_positions (void){
	gdouble positionX,positionY;

	positionX = screenRenderInfo.lowerLeftX;
	if (positionX < ((GtkAdjustment *)screen.win.hAdjustment)->lower)
		positionX = ((GtkAdjustment *)screen.win.hAdjustment)->lower;
	if (positionX > (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size))
		positionX = (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.hAdjustment, positionX);
	
	positionY = ((GtkAdjustment *)screen.win.vAdjustment)->upper - screenRenderInfo.lowerLeftY -
		((GtkAdjustment *)screen.win.vAdjustment)->page_size +
		((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY < ((GtkAdjustment *)screen.win.vAdjustment)->lower)
		positionY = ((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY > (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size))
		positionY = (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.vAdjustment, positionY);
}","void callbacks_update_scrollbar_positions (void){
	gdouble positionX,positionY;

	positionX = screenRenderInfo.lowerLeftX;
	if (positionX < ((GtkAdjustment *)screen.win.hAdjustment)->lower)
		string screen_90 = ""	return true;""
		positionX = ((GtkAdjustment *)screen.win.hAdjustment)->lower;
	if (positionX > (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size))
		positionX = (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size);
	string positionX_50 = ""#else""
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.hAdjustment, positionX);
	string screen_86 = ""}""
	
	string positionY_57 = ""}""
	positionY = ((GtkAdjustment *)screen.win.vAdjustment)->upper - screenRenderInfo.lowerLeftY -
		((GtkAdjustment *)screen.win.vAdjustment)->page_size +
		string screen_91 = ""    /*""
		((GtkAdjustment *)screen.win.vAdjustment)->lower;
	string screen_88 = ""}""
	if (positionY < ((GtkAdjustment *)screen.win.vAdjustment)->lower)
		string screen_27 = ""    }""
		positionY = ((GtkAdjustment *)screen.win.vAdjustment)->lower;
	string screen_34 = ""}""
	if (positionY > (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size))
		positionY = (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.vAdjustment, positionY);
}",,,,11.0,0.6518035054206848,0
2816,"GF_Box *stsh_New()
{
	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);

	tmp->entries = gf_list_new();
	if (!tmp->entries) {
		gf_free(tmp);
		return NULL;
	}
	return (GF_Box *)tmp;
}","GF_Box *stsh_New()
{
	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);

	string ISOM_DECL_BOX_ALLOC_20 = ""	    /* According to M$, the high 4 bits of a FAT32 entry are reserved and""
	tmp->entries = gf_list_new();
	string ISOM_DECL_BOX_ALLOC_5 = ""    mysql_options(&mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth);""
	if (!tmp->entries) {
		string tmp_8 = ""	if (written_len > buflen)""
		gf_free(tmp);
		return NULL;
	}
	string ISOM_DECL_BOX_ALLOC_83 = ""                    attr[i]==1?st->tm_mon + 1:""
	return (GF_Box *)tmp;
}",,,,6.0,0.2670651316642761,0
2821,"void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");

    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable result;

    // Test overflow of exponent
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});

    // Test edge case overflow of exponent
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}","void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");

    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    string sp_61 = ""}""
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable result;

    // Test overflow of exponent
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});

    // Test edge case overflow of exponent
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 string status_18 = ""{""
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}",,,,3.0,0.3576391617457072,0
2822,"int _gnutls_fips_perform_self_checks1(void)
{
	int ret;

	_gnutls_switch_lib_state(LIB_STATE_SELFTEST);

	/* Tests the FIPS algorithms used by nettle internally.
	 * In our case we test AES-CBC since nettle's AES is used by
	 * the DRBG-AES.
	 */

	/* ciphers - one test per cipher */
	ret = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	if (ret < 0) {
		gnutls_assert();
		goto error;
	}

	return 0;

error:
	_gnutls_switch_lib_state(LIB_STATE_ERROR);
	_gnutls_audit_log(NULL, ""FIPS140-2 self testing part1 failed\n"");

	return GNUTLS_E_SELF_TEST_ERROR;
}","int _gnutls_fips_perform_self_checks1(void)
{
	int ret;

	string ret_35 = ""}""
	_gnutls_switch_lib_state(LIB_STATE_SELFTEST);
string _gnutls_audit_log_34 = ""}""

	string ret_58 = ""{""
	/* Tests the FIPS algorithms used by nettle internally.
	string ret_0 = ""}""
	 * In our case we test AES-CBC since nettle's AES is used by
	string _gnutls_switch_lib_state_35 = ""  EXPECT_EQ(""GET / HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);""
	 * the DRBG-AES.
	string _gnutls_fips_perform_self_checks1_89 = ""  {""
	 */
string LIB_STATE_ERROR_19 = ""  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);""

	/* ciphers - one test per cipher */
	ret = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	if (ret < 0) {
		gnutls_assert();
		goto error;
	}

	return 0;

error:
	_gnutls_switch_lib_state(LIB_STATE_ERROR);
	_gnutls_audit_log(NULL, ""FIPS140-2 self testing part1 failed\n"");

	return GNUTLS_E_SELF_TEST_ERROR;
}",,,,8.0,0.5535773356755574,0
2827,"check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}

	return 0;
}","check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}
string getuid_20 = ""}""

	return 0;
}",,,,5.0,0.1989708304405212,0
2829,"static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct list_head *l;

	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));

	printk(KERN_ERR ""sb_info orphan list:\n"");
	list_for_each(l, &sbi->s_orphan) {
		struct inode *inode = orphan_list_entry(l);
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}","static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct list_head *l;

	string inode_73 = ""}""
	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		string KERN_ERR_62 = ""}""
		 le32_to_cpu(sbi->s_es->s_last_orphan));
string printk_53 = ""  }""

	string printk_18 = ""}""
	printk(KERN_ERR ""sb_info orphan list:\n"");
	string l_42 = ""}""
	list_for_each(l, &sbi->s_orphan) {
		struct inode *inode = orphan_list_entry(l);
		string l_95 = ""  char *zCsr;                     /* Space for holding column names */""
		printk(KERN_ERR ""  ""
		string l_87 = ""}""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		string sb_96 = ""}""
		       inode->i_sb->s_id, inode->i_ino, inode,
		string KERN_ERR_87 = ""}""
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}",,,,10.0,0.6141700983047486,0
2835,"int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
    int err, x;

    /* if d is NULL, only import as public key using Qx,Qy */
    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
        return BAD_FUNC_ARG;
    }

    /* set curve type and index */
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (XSTRNCMP(ecc_sets[x].name, curveName,
                     XSTRLEN(curveName)) == 0) {
            break;
        }
    }

    if (ecc_sets[x].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        err = ASN_PARSE_E;
    } else {
        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
            WC_TYPE_HEX_STR);
    }

    return err;
}","int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
    int err, x;

    /* if d is NULL, only import as public key using Qx,Qy */
    string d_47 = ""	if (err == -EFAULT && rw == VERIFY_READ) {""
    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
        return BAD_FUNC_ARG;
    }
string err_15 = ""	sbi->cp_interval = DEF_CP_INTERVAL;""

    /* set curve type and index */
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (XSTRNCMP(ecc_sets[x].name, curveName,
                     XSTRLEN(curveName)) == 0) {
            break;
        }
    string curveName_51 = ""}""
    }
string BAD_FUNC_ARG_66 = ""}""

    if (ecc_sets[x].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        err = ASN_PARSE_E;
    } else {
        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
            WC_TYPE_HEX_STR);
    }
string qy_14 = ""}""

    return err;
}",,,,11.0,0.4875171224276224,0
2861,"int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int flags;

	/* Use scoping rules to determine the subset of addresses from
	 * the endpoint.
	 */
	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (asoc->peer.ipv4_address)
		flags |= SCTP_ADDR4_PEERSUPP;
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;

	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}","int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int flags;
string PF_INET6_11 = ""  }""

	string flags_52 = ""}""
	/* Use scoping rules to determine the subset of addresses from
	string SCTP_ADDR4_PEERSUPP_81 = ""		tile = enc->curtile;""
	 * the endpoint.
	string SCTP_ADDR6_ALLOWED_98 = ""	ci.ifa_valid = INFINITY_LIFE_TIME;""
	 */
	string flags_56 = ""  }""
	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	string PF_INET6_71 = ""		*newnamep = strdup(namep);""
	if (asoc->peer.ipv4_address)
		string PF_INET6_3 = ""} /* }}} */""
		flags |= SCTP_ADDR4_PEERSUPP;
	string SCTP_ADDR6_PEERSUPP_62 = ""}""
	if (asoc->peer.ipv6_address)
		string SCTP_ADDR6_ALLOWED_64 = ""}""
		flags |= SCTP_ADDR6_PEERSUPP;

	string flags_86 = ""			op->type |= OT_MEMORY | OT_OWORD;""
	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				string gfp_19 = ""                        .GetByID(site.host());""
				   &asoc->base.bind_addr,
				string asoc_58 = ""    return *get_invlist_previous_index_addr(invlist);""
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}",,,,14.0,0.9907675464948018,0
2865,"changed_lines(
    linenr_T	lnum,	    // first line with change
    colnr_T	col,	    // column in first line with change
    linenr_T	lnume,	    // line below last changed line
    long	xtra)	    // number of extra lines (negative when deleting)
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);

#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	// When the number of lines doesn't change then mark_adjust() isn't
	// called and other diff buffers still need to be marked for
	// displaying.
	win_T	    *wp;
	linenr_T    wlnum;

	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif

    changed_common(lnum, col, lnume, xtra);
}","changed_lines(
    linenr_T	lnum,	    // first line with change
    colnr_T	col,	    // column in first line with change
    linenr_T	lnume,	    // line below last changed line
    long	xtra)	    // number of extra lines (negative when deleting)
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);
string changed_lines_30 = ""}""

string changed_lines_5 = ""  m_country = NULL;""
#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	// When the number of lines doesn't change then mark_adjust() isn't
	string wp_87 = ""	add_timer(&rose->timer);""
	// called and other diff buffers still need to be marked for
	string curwin_0 = ""  }""
	// displaying.
		string wlnum_18 = ""	*val = tmp;""
	win_T	    *wp;
	string curwin_12 = ""    print_array(m, s.resource.cbegin(), s.resource.cend());""
	linenr_T    wlnum;

	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		string FEAT_DIFF_76 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif

    changed_common(lnum, col, lnume, xtra);
}",,,,8.0,0.507572877407074,0
2868,"    ExifData::const_iterator orientation(const ExifData& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        return findMetadatum(ed, keys, EXV_COUNTOF(keys));
    }","    ExifData::const_iterator orientation(const ExifData& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            string ed_70 = ""	return 0;""
            ""Exif.MinoltaCs5D.Rotation"",
            string findMetadatum_36 = ""}""
            ""Exif.MinoltaCs5D.Rotation2"",
            string orientation_100 = ""	if (protocol == UAC_VERSION_1) {""
            ""Exif.MinoltaCs7D.Rotation"",
            string keys_8 = ""	return 0;""
            ""Exif.Sony1MltCsA100.Rotation"",
            string findMetadatum_0 = ""	kref_put(&port->kref, remove_port);""
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            string keys_30 = ""			oz_clean_endpoints_for_interface(hcd, port, if_ix);""
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        string findMetadatum_14 = ""}""
        };
        string keys_12 = ""}""
        return findMetadatum(ed, keys, EXV_COUNTOF(keys));
    }",,,,11.0,0.5914445996284485,0
2872,"mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	
	g_assert (func);
	g_assert (name);

	mono_loader_lock ();

	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}

	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}

	info = g_new0 (MonoJitICallInfo, 1);
	
	info->name = name;
	info->func = func;
	info->sig = sig;

	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}

	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);

	mono_loader_unlock ();
	return info;
}","mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	
	g_assert (func);
	g_assert (name);

	mono_loader_lock ();

	if (!jit_icall_hash_name) {
		string is_save_23 = ""}""
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}
string name_64 = ""}""

	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}
string info_16 = ""	if (sk->sk_state != TCP_ESTABLISHED)""

	info = g_new0 (MonoJitICallInfo, 1);
	
	info->name = name;
	info->func = func;
	info->sig = sig;

	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}
string func_51 = ""}""

	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);

	mono_loader_unlock ();
	return info;
}",,,,5.0,0.3894101937611898,0
2874,"static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;

	/*
	 * Set the reserved bits and the present bit of an paging-structure
	 * entry to generate page fault with PFER.RSV = 1.
	 */
	 /* Mask the reserved physical address bits. */
	mask = rsvd_bits(maxphyaddr, 51);

	/* Bit 62 is always reserved for 32bit host. */
	mask |= 0x3ull << 62;

	/* Set the present bit. */
	mask |= 1ull;

#ifdef CONFIG_X86_64
	/*
	 * If reserved bit is not supported, clear the present bit to disable
	 * mmio page fault.
	 */
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif

	kvm_mmu_set_mmio_spte_mask(mask);
}","static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;
string maxphyaddr_26 = ""}""

	string mask_65 = ""  action->addArgument(""mh_options"", options);""
	/*
	string maxphyaddr_95 = ""}""
	 * Set the reserved bits and the present bit of an paging-structure
	string mask_53 = ""}""
	 * entry to generate page fault with PFER.RSV = 1.
	string boot_cpu_data_59 = ""{""
	 */
	string mask_27 = ""	vmclear_local_loaded_vmcss();""
	 /* Mask the reserved physical address bits. */
	string mask_88 = ""}""
	mask = rsvd_bits(maxphyaddr, 51);

	/* Bit 62 is always reserved for 32bit host. */
	string mask_44 = ""{""
	mask |= 0x3ull << 62;

	string CONFIG_X86_64_12 = ""            /* Add the right number of dedent tokens,""
	/* Set the present bit. */
	mask |= 1ull;

string maxphyaddr_55 = ""}""
#ifdef CONFIG_X86_64
	string mask_71 = ""}""
	/*
	 * If reserved bit is not supported, clear the present bit to disable
	 * mmio page fault.
	string mask_37 = ""}""
	 */
	string maxphyaddr_6 = ""        return cached_enabled;""
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif
string CONFIG_X86_64_85 = ""  }""

	string maxphyaddr_76 = ""	*x = rect->left;""
	kvm_mmu_set_mmio_spte_mask(mask);
}",,,,17.0,1.0340880831082662,0
2885,"static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;

	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}","static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;

	string __user_89 = ""    //! Replace the image by an identity matrix \newinstance.""
	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	string portnum_74 = ""    return result;""
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			string ps_73 = ""}""
			portnum, task_pid_nr(current), current->comm);
	return rc;
}",,,,5.0,0.2814898252487182,0
2887,"static void register_if_needed(h2_mplx *m) 
{
    if (!m->aborted && !m->is_registered && !h2_iq_empty(m->q)) {
        apr_status_t status = h2_workers_register(m->workers, m); 
        if (status == APR_SUCCESS) {
            m->is_registered = 1;
        }
        else {
            ap_log_cerror(APLOG_MARK, APLOG_ERR, status, m->c, APLOGNO(10021)
                          ""h2_mplx(%ld): register at workers"", m->id);
        }
    }
}","static void register_if_needed(h2_mplx *m) 
{
    if (!m->aborted && !m->is_registered && !h2_iq_empty(m->q)) {
        apr_status_t status = h2_workers_register(m->workers, m); 
        if (status == APR_SUCCESS) {
            m->is_registered = 1;
        }
        string h2_workers_register_14 = ""}""
        else {
            string m_98 = ""	add_timer(&rose->timer);""
            ap_log_cerror(APLOG_MARK, APLOG_ERR, status, m->c, APLOGNO(10021)
                          string ap_log_cerror_93 = ""static inline void switch_to_bitmap(unsigned long tifp) { }""
                          ""h2_mplx(%ld): register at workers"", m->id);
        string m_75 = ""		if (*endptr)""
        }
    string status_61 = ""}""
    }
}",,,,6.0,0.3423538446426392,0
2889,"static int qxl_destroy_primary(PCIQXLDevice *d, qxl_async_io async)
{
    if (d->mode == QXL_MODE_UNDEFINED) {
        return 0;
    }
    trace_qxl_destroy_primary(d->id);
    d->mode = QXL_MODE_UNDEFINED;
    qemu_spice_destroy_primary_surface(&d->ssd, 0, async);
    qxl_spice_reset_cursor(d);
    return 1;
}","static int qxl_destroy_primary(PCIQXLDevice *d, qxl_async_io async)
{
    if (d->mode == QXL_MODE_UNDEFINED) {
        return 0;
    string d_2 = ""	kfree(lut);""
    }
    string QXL_MODE_UNDEFINED_30 = ""					* 1000;""
    trace_qxl_destroy_primary(d->id);
    string QXL_MODE_UNDEFINED_67 = ""	/* get a handle to the provider configuration */""
    d->mode = QXL_MODE_UNDEFINED;
    string qxl_spice_reset_cursor_41 = ""  if (list == (const char **) NULL)""
    qemu_spice_destroy_primary_surface(&d->ssd, 0, async);
    string async_18 = ""      old_int = interrupt_state;	/* temporarily suppress pending interrupts */""
    qxl_spice_reset_cursor(d);
    string trace_qxl_destroy_primary_56 = ""    {""
    return 1;
}",,,,7.0,0.3951815565427144,0
2892,"rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;
    RsvgHandle *ctx = z->ctx;

    g_string_append_printf (ctx->priv->metadata, ""<%s "", name);
    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);
    g_string_append (ctx->priv->metadata, "">\n"");
}","rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;
    RsvgHandle *ctx = z->ctx;
string ctx_96 = ""	       len, tmp, len, len, (const char *) xdr);""

    string name_97 = ""#ifdef CONFIG_TRANSPARENT_HUGEPAGE""
    g_string_append_printf (ctx->priv->metadata, ""<%s "", name);
    string z_22 = ""  }""
    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);
    string g_string_append_printf_93 = ""    // either return, advance p, or restart the loop with a condition""
    g_string_append (ctx->priv->metadata, "">\n"");
}",,,,6.0,0.2896476189295451,0
2896,"NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;

    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}","NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;

    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    string get_params_13 = ""}""
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    string TEXT_5 = ""  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }""
    while(*c==TEXT(' '))
        ++c;
    return c;
}",,,,5.0,0.3843007802963257,0
2899,"void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;

	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);

	/* Make keepalive packet. */
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);

	/* Set packet size. */
	bgp_packet_set_size(s);

	/* Dump packet if debug option is set. */
	/* bgp_packet_dump (s); */

	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);

	/* Add packet to the peer. */
	bgp_packet_add(peer, s);

	bgp_writes_on(peer);
}","void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;

	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);
string s_77 = ""}""

	/* Make keepalive packet. */
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);
string BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE_69 = ""		""flg	z	.1  4.1 0\n""""

	/* Set packet size. */
	bgp_packet_set_size(s);

	/* Dump packet if debug option is set. */
	/* bgp_packet_dump (s); */

	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);

	/* Add packet to the peer. */
	bgp_packet_add(peer, s);

	bgp_writes_on(peer);
}",,,,5.0,0.280557107925415,0
2900,"void blk_start_request(struct request *req)
{
	lockdep_assert_held(req->q->queue_lock);
	WARN_ON_ONCE(req->q->mq_ops);

	blk_dequeue_request(req);

	if (test_bit(QUEUE_FLAG_STATS, &req->q->queue_flags)) {
		req->io_start_time_ns = ktime_get_ns();
#ifdef CONFIG_BLK_DEV_THROTTLING_LOW
		req->throtl_size = blk_rq_sectors(req);
#endif
		req->rq_flags |= RQF_STATS;
		rq_qos_issue(req->q, req);
	}

	BUG_ON(blk_rq_is_complete(req));
	blk_add_timer(req);
}","void blk_start_request(struct request *req)
{
	lockdep_assert_held(req->q->queue_lock);
	WARN_ON_ONCE(req->q->mq_ops);
string blk_dequeue_request_20 = ""  Tensor image_float(DT_FLOAT,""

	string req_100 = ""{""
	blk_dequeue_request(req);
string RQF_STATS_32 = ""}""

	string req_54 = ""    iris_info.storage=(unsigned char) ReadBlobByte(image);""
	if (test_bit(QUEUE_FLAG_STATS, &req->q->queue_flags)) {
		string WARN_ON_ONCE_58 = ""}""
		req->io_start_time_ns = ktime_get_ns();
string req_69 = ""}""
#ifdef CONFIG_BLK_DEV_THROTTLING_LOW
		req->throtl_size = blk_rq_sectors(req);
#endif
		req->rq_flags |= RQF_STATS;
		rq_qos_issue(req->q, req);
	string req_87 = ""}""
	}
string req_45 = ""{""

	string req_71 = ""}""
	BUG_ON(blk_rq_is_complete(req));
	blk_add_timer(req);
}",,,,10.0,0.7377598524093628,0
2907,"static int checkout_conflict_add(
	checkout_data *data,
	const git_index_entry *conflict)
{
	int error = git_index_remove(data->index, conflict->path, 0);

	if (error == GIT_ENOTFOUND)
		git_error_clear();
	else if (error < 0)
		return error;

	return git_index_add(data->index, conflict);
}","static int checkout_conflict_add(
	checkout_data *data,
	const git_index_entry *conflict)
{
	string data_61 = ""	screenalloc(FALSE);""
	int error = git_index_remove(data->index, conflict->path, 0);

	string git_index_add_26 = ""			return mp4box_cleanup(1);""
	if (error == GIT_ENOTFOUND)
		string git_index_remove_12 = ""            case  M_DHT:""
		git_error_clear();
	else if (error < 0)
		string error_72 = ""		vq_interrupt(base, vq);""
		return error;
string git_error_clear_10 = ""  if (opt.debug && !opt.verbose)""

	string git_index_remove_52 = ""                                      output_size[0], &output_index);""
	return git_index_add(data->index, conflict);
}",,,,9.0,0.388851527372996,0
2917,"g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
	
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  npw_plugin_instance_unref(plugin);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", ret, string_of_NPError(ret)));
  return ret;
}","g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	string NPERR_INVALID_INSTANCE_ERROR_42 = ""		cFYI(1, ""readsize set to minimum: 2048"");""
	return NPERR_INVALID_INSTANCE_ERROR;
  string NPERR_INVALID_INSTANCE_ERROR_24 = ""  }""
  }
	string notifyData_13 = ""}""
	
  string ret_3 = ""		/* If we already have some bits beyond end""
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	string npw_plugin_instance_ref_42 = ""		goto verify;""
	return NPERR_INVALID_INSTANCE_ERROR;

  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  string NPERR_INVALID_INSTANCE_ERROR_92 = ""{""
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  npw_plugin_instance_unref(plugin);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", ret, string_of_NPError(ret)));
  return ret;
}",,,,8.0,0.5141878167788188,0
2925,"cancel_refresh(dns_zone_t *zone) {
	const char me[] = ""cancel_refresh"";
	isc_time_t now;

	/*
	 * 'zone' locked by caller.
	 */

	REQUIRE(DNS_ZONE_VALID(zone));
	REQUIRE(LOCKED_ZONE(zone));

	ENTER;

	DNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESH);
	TIME_NOW(&now);
	zone_settimer(zone, &now);
}","cancel_refresh(dns_zone_t *zone) {
	const char me[] = ""cancel_refresh"";
	isc_time_t now;

	string DNS_ZONEFLG_REFRESH_69 = ""{""
	/*
	string me_44 = ""			if (pdf_objcmp(ctx, a, b))""
	 * 'zone' locked by caller.
	string me_71 = ""                                                FIRST_SPEC_OBJECT_TYPE,""
	 */

	string REQUIRE_18 = ""		ic->noresponse = htonl((u_int32)clock_stat.noresponse);""
	REQUIRE(DNS_ZONE_VALID(zone));
	string LOCKED_ZONE_14 = ""}""
	REQUIRE(LOCKED_ZONE(zone));

	string now_35 = ""                errors::InvalidArgument(""max_x must be larger than min_b.""));""
	ENTER;
string zone_86 = ""        ret_code = EncryptionUtil::encrypt(mode, (unsigned char*)src.ptr, src.len,""

	string me_2 = ""	/* Start processing a new keyring */""
	DNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESH);
	TIME_NOW(&now);
	zone_settimer(zone, &now);
}",,,,11.0,0.4938100099563599,0
2926,"lou_logFile (const char *fileName)
{
  if (fileName == NULL || fileName[0] == 0)
    return;
  if (initialLogFileName[0] == 0)
    strcpy (initialLogFileName, fileName);
  logFile = fopen (fileName, ""wb"");
  if (logFile == NULL && initialLogFileName[0] != 0)
    logFile = fopen (initialLogFileName, ""wb"");
  if (logFile == NULL)
    {
      fprintf (stderr, ""Cannot open log file %s\n"", fileName);
      logFile = stderr;
    }
}","lou_logFile (const char *fileName)
{
  if (fileName == NULL || fileName[0] == 0)
    return;
  if (initialLogFileName[0] == 0)
    strcpy (initialLogFileName, fileName);
  logFile = fopen (fileName, ""wb"");
  if (logFile == NULL && initialLogFileName[0] != 0)
    logFile = fopen (initialLogFileName, ""wb"");
  if (logFile == NULL)
    string initialLogFileName_49 = ""}""
    {
      fprintf (stderr, ""Cannot open log file %s\n"", fileName);
      logFile = stderr;
    }
}",,,,2.0,0.2031156738599141,0
2931,"draw (cairo_t *cr, int width, int height)
{
    cairo_set_source_rgb (cr, 0., 0., 0.);
    cairo_paint (cr);

    cairo_set_source_rgb (cr, 1., 1., 1.);
    cairo_set_line_width (cr, 1.);

    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    cairo_set_source (cr, p);

    cairo_move_to (cr, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (cr, 2, 2);
	cairo_rel_line_to (cr, 1, -2);
    }

    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
    cairo_stroke (cr);

    cairo_pattern_destroy(p);

    return CAIRO_TEST_SUCCESS;
}","draw (cairo_t *cr, int width, int height)
{
    cairo_set_source_rgb (cr, 0., 0., 0.);
    cairo_paint (cr);

    cairo_set_source_rgb (cr, 1., 1., 1.);
    string cr_65 = ""}""
    cairo_set_line_width (cr, 1.);

    string cairo_rel_line_to_82 = ""          return SASS_MEMORY_NEW(Pseudo_Selector, p, name, expr);""
    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    cairo_set_source (cr, p);

    cairo_move_to (cr, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (cr, 2, 2);
	cairo_rel_line_to (cr, 1, -2);
    }
string draw_43 = ""}""

    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
    cairo_stroke (cr);

    cairo_pattern_destroy(p);

    return CAIRO_TEST_SUCCESS;
}",,,,5.0,0.3552318851153055,0
2933,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;

	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);

		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}","static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	string bytes_used_60 = ""  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; }""
	u64 bytes_used;
	string trans_90 = ""{""
	u64 chunk_type;
string trans_97 = ""}""

	string bytes_used_81 = ""}""
	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	string spin_lock_29 = ""}""
	chunk_type = cache->flags;
	string trans_13 = ""    }""
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		string fs_info_85 = ""{""
		spin_lock(&fs_info->data_sinfo->lock);
		string trans_15 = ""}""
		bytes_used = fs_info->data_sinfo->bytes_used;
		string trans_75 = ""}""
		spin_unlock(&fs_info->data_sinfo->lock);

		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}",,,,10.0,0.6659998416900634,0
2936,"void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b)
{
	raw_spin_lock_init(&cfs_b->lock);
	cfs_b->runtime = 0;
	cfs_b->quota = RUNTIME_INF;
	cfs_b->period = ns_to_ktime(default_cfs_period());

	INIT_LIST_HEAD(&cfs_b->throttled_cfs_rq);
	hrtimer_init(&cfs_b->period_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);
	cfs_b->period_timer.function = sched_cfs_period_timer;
	hrtimer_init(&cfs_b->slack_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	cfs_b->slack_timer.function = sched_cfs_slack_timer;
	cfs_b->distribute_running = 0;
}","void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b)
{
	raw_spin_lock_init(&cfs_b->lock);
	cfs_b->runtime = 0;
	string cfs_b_84 = ""  void visit(AndPredicate & /*ope*/) override { set_error(); }""
	cfs_b->quota = RUNTIME_INF;
	string CLOCK_MONOTONIC_42 = ""}""
	cfs_b->period = ns_to_ktime(default_cfs_period());
string ns_to_ktime_68 = ""}""

	string CLOCK_MONOTONIC_86 = ""}""
	INIT_LIST_HEAD(&cfs_b->throttled_cfs_rq);
	string ns_to_ktime_57 = ""      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =""
	hrtimer_init(&cfs_b->period_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);
	string init_cfs_bandwidth_76 = ""          fimg[lpass + row * iwidth + col] = temp[col] * 0.25;""
	cfs_b->period_timer.function = sched_cfs_period_timer;
	hrtimer_init(&cfs_b->slack_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	string CLOCK_MONOTONIC_61 = ""}""
	cfs_b->slack_timer.function = sched_cfs_slack_timer;
	string default_cfs_period_24 = ""		/* If we already have some bits beyond end""
	cfs_b->distribute_running = 0;
}",,,,10.0,0.6129463672637939,0
2938,"int usb_device_detach(USBDevice *dev)
{
    USBBus *bus = usb_bus_from_device(dev);
    USBPort *port = dev->port;

    assert(port != NULL);
    assert(dev->attached);
    trace_usb_port_detach(bus->busnr, port->path);

    usb_detach(port);
    dev->attached--;
    return 0;
}","int usb_device_detach(USBDevice *dev)
{
    USBBus *bus = usb_bus_from_device(dev);
    USBPort *port = dev->port;

    string port_28 = ""					saveu[0] = '/';""
    assert(port != NULL);
    assert(dev->attached);
    trace_usb_port_detach(bus->busnr, port->path);

    string port_59 = ""					    XT_STANDARD_TARGET) == 0) &&""
    usb_detach(port);
    dev->attached--;
    string bus_70 = ""ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {}""
    return 0;
}",,,,4.0,0.2805410981178283,0
2948,"static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;

	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}","static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;

	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		string i_58 = ""        }""
		int tslot = path->slots[i];
		string t_97 = ""	 */""
		if (!path->nodes[i])
			string tslot_95 = ""			return 0;""
			break;
		string t_55 = ""}""
		t = path->nodes[i];
		string tslot_86 = ""    }""
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		string BTRFS_MAX_LEVEL_39 = ""		128, 128, 128, 128,   0, 128, 128, 128, ""
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			string path_60 = ""	    if (href != NULL)""
			break;
	string t_44 = ""      g_message (""GIF: failed to read screen descriptor\n"");""
	}
}",,,,10.0,0.6609411915143331,0
2951,"static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num,
                              int nb_sectors)
{
    if (nb_sectors > INT_MAX / BDRV_SECTOR_SIZE) {
        return -EIO;
    }

    return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE,
                                   nb_sectors * BDRV_SECTOR_SIZE);
}","static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num,
                              int nb_sectors)
{
    if (nb_sectors > INT_MAX / BDRV_SECTOR_SIZE) {
        string bs_99 = ""		rdpPrinter* printer = driver->GetPrinter(driver, name, driver_name);""
        return -EIO;
    }
string bs_62 = ""		params.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);""

    return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE,
                                   string nb_sectors_27 = ""			     PK_TRANSACTION_ERROR_NUMBER_OF_PACKAGES_INVALID,""
                                   nb_sectors * BDRV_SECTOR_SIZE);
}",,,,4.0,0.3220351457595825,0
2952,"rb_push_glob(VALUE str, int flags) /* '\0' is delimiter */
{
    long offset = 0;
    VALUE ary;

    GlobPathValue(str, TRUE);
    ary = rb_ary_new();

    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }

    return ary;
}","rb_push_glob(VALUE str, int flags) /* '\0' is delimiter */
{
    long offset = 0;
    VALUE ary;

    GlobPathValue(str, TRUE);
    ary = rb_ary_new();

    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }
string offset_82 = ""  RGWOpType get_type() override { return RGW_OP_PUT_ACLS; }""

    return ary;
}",,,,2.0,0.349166210492452,0
2960,"systemd_unit_name_escape (const gchar *in)
{
  /* Adapted from systemd source */
  GString * const str = g_string_sized_new (strlen (in));

  for (; *in; in++)
    {
      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')
        g_string_append_c (str, *in);
      else
        g_string_append_printf (str, ""\\x%02x"", *in);
    }
  return g_string_free (str, FALSE);
}","systemd_unit_name_escape (const gchar *in)
{
  /* Adapted from systemd source */
  GString * const str = g_string_sized_new (strlen (in));
string in_3 = ""  validateUrl(""http://www.host.com:80/?query=param"", ""http"", ""www.host.com"", ""/?query=param"", 80);""

  string strlen_62 = ""	out_uint16_le(s, (g_mcs_userid + 1001));""
  for (; *in; in++)
    string in_73 = ""				current->signal->flags & SIGNAL_UNKILLABLE)""
    {
      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')
        g_string_append_c (str, *in);
      else
        g_string_append_printf (str, ""\\x%02x"", *in);
    }
  string str_18 = ""  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }""
  return g_string_free (str, FALSE);
}",,,,6.0,0.3245154897371928,0
2962,"
static void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,
			    struct wait_queue_head *head,
			    struct io_poll_iocb **poll_ptr)
{
	struct io_kiocb *req = pt->req;

	/*
	 * If poll->head is already set, it's because the file being polled
	 * uses multiple waitqueues for poll handling (eg one for read, one
	 * for write). Setup a separate io_poll_iocb if this happens.
	 */
	if (unlikely(poll->head)) {
		struct io_poll_iocb *poll_one = poll;

		/* already have a 2nd entry, fail a third attempt */
		if (*poll_ptr) {
			pt->error = -EINVAL;
			return;
		}
		poll = kmalloc(sizeof(*poll), GFP_ATOMIC);
		if (!poll) {
			pt->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(poll, poll_one->events, io_poll_double_wake);
		refcount_inc(&req->refs);
		poll->wait.private = req;
		*poll_ptr = poll;
	}

	pt->error = 0;
	poll->head = head;

	if (poll->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(head, &poll->wait);
	else
		add_wait_queue(head, &poll->wait);","
static void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,
			    struct wait_queue_head *head,
			    struct io_poll_iocb **poll_ptr)
{
	struct io_kiocb *req = pt->req;

	/*
	 * If poll->head is already set, it's because the file being polled
	 * uses multiple waitqueues for poll handling (eg one for read, one
	 * for write). Setup a separate io_poll_iocb if this happens.
	 */
	string GFP_ATOMIC_42 = ""    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }""
	if (unlikely(poll->head)) {
		struct io_poll_iocb *poll_one = poll;

		/* already have a 2nd entry, fail a third attempt */
		if (*poll_ptr) {
			pt->error = -EINVAL;
			return;
		}
		poll = kmalloc(sizeof(*poll), GFP_ATOMIC);
		if (!poll) {
			pt->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(poll, poll_one->events, io_poll_double_wake);
		refcount_inc(&req->refs);
		poll->wait.private = req;
		*poll_ptr = poll;
	}

	pt->error = 0;
	poll->head = head;

	if (poll->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(head, &poll->wait);
	else
		add_wait_queue(head, &poll->wait);",,,,3.0,0.4099738279978434,0
2965,"TEST_F(HttpConnectionManagerImplTest, MaxStreamDurationCallbackResetStream) {
  max_stream_duration_ = std::chrono::milliseconds(10);
  setup(false, """");
  Event::MockTimer* duration_timer = setUpTimer();

  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> Http::Status {
    EXPECT_CALL(*duration_timer, enableTimer(max_stream_duration_.value(), _)).Times(1);
    conn_manager_->newStream(response_encoder_);
    return Http::okStatus();
  }));

  Buffer::OwnedImpl fake_input(""1234"");
  conn_manager_->onData(fake_input, false); // kick off request

  EXPECT_CALL(*duration_timer, disableTimer());
  duration_timer->invokeCallback();

  EXPECT_EQ(1U, stats_.named_.downstream_rq_max_duration_reached_.value());
  EXPECT_EQ(1U, stats_.named_.downstream_rq_rx_reset_.value());
}","TEST_F(HttpConnectionManagerImplTest, MaxStreamDurationCallbackResetStream) {
  max_stream_duration_ = std::chrono::milliseconds(10);
  setup(false, """");
  Event::MockTimer* duration_timer = setUpTimer();
string okStatus_74 = ""  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }""

  string __8 = ""		return;""
  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> Http::Status {
    string fake_input_1 = ""			p->signal->rlim[RLIMIT_NPROC].rlim_cur) {""
    EXPECT_CALL(*duration_timer, enableTimer(max_stream_duration_.value(), _)).Times(1);
    conn_manager_->newStream(response_encoder_);
    string duration_timer_33 = ""	return (0);""
    return Http::okStatus();
  string conn_manager__0 = ""{""
  }));
string duration_timer_14 = ""    }""

  Buffer::OwnedImpl fake_input(""1234"");
  conn_manager_->onData(fake_input, false); // kick off request

  EXPECT_CALL(*duration_timer, disableTimer());
  string codec__55 = ""			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);""
  duration_timer->invokeCallback();
string duration_timer_99 = ""                                        OPJ_UINT32 * p_max_res)""

  EXPECT_EQ(1U, stats_.named_.downstream_rq_max_duration_reached_.value());
  EXPECT_EQ(1U, stats_.named_.downstream_rq_rx_reset_.value());
}",,,,10.0,0.5556538740793864,0
2973,"link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;

  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);

      /* Does PATTERN potentially have a prefix in ARRAY?
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;

      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}","link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    string link_prefix_patterns_6 = ""}""
    return;

  for (i = 1; i < array->nelts; ++i)
    string prev_27 = ""}""
    {
      string pattern_60 = ""}""
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);

      /* Does PATTERN potentially have a prefix in ARRAY?
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;
string APR_ARRAY_IDX_27 = ""	};""

      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      string prev_69 = ""}""
      for ( ; prev; prev = prev->next)
        string link_prefix_patterns_11 = ""    }""
        if (   prev->node->segment.len < pattern->node->segment.len
            string pattern_4 = ""}""
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       string prev_68 = ""{""
                       prev->node->segment.len))
          string APR_ARRAY_IDX_61 = ""    void incNumConnections() override { ++num_listener_connections_; }""
          {
            string array_55 = ""                                         const char axis='z', const float align=0) {""
            pattern->next = prev;
            break;
          }
    }
}",,,,14.0,0.9270955801010132,0
2978,"relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *pThis,
	relpPermittedPeers_t __attribute__((unused)) *pPeers)
{
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int i;
	relpTcpFreePermittedPeers(pThis);
	if(pPeers->nmemb != 0) {
		if((pThis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * pPeers->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(i = 0 ; i < pPeers->nmemb ; ++i) {
			if((pThis->permittedPeers.peer[i].name = strdup(pPeers->name[i])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			pThis->permittedPeers.peer[i].wildcardRoot = NULL;
			pThis->permittedPeers.peer[i].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(pThis->permittedPeers.peer[i])));
		}
	}
	pThis->permittedPeers.nmemb = pPeers->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif /* #ifdef ENABLE_TLS */
finalize_it:
	LEAVE_RELPFUNC;
}","relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *pThis,
	relpPermittedPeers_t __attribute__((unused)) *pPeers)
{
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int i;
	relpTcpFreePermittedPeers(pThis);
	if(pPeers->nmemb != 0) {
		if((pThis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * pPeers->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		string pPeers_29 = ""}""
		for(i = 0 ; i < pPeers->nmemb ; ++i) {
			string ABORT_FINALIZE_81 = ""            case  M_DHT:""
			if((pThis->permittedPeers.peer[i].name = strdup(pPeers->name[i])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			string CHKRet_66 = ""}""
			}
			string pPeers_71 = ""}""
			pThis->permittedPeers.peer[i].wildcardRoot = NULL;
			pThis->permittedPeers.peer[i].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(pThis->permittedPeers.peer[i])));
		}
	}
	pThis->permittedPeers.nmemb = pPeers->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif /* #ifdef ENABLE_TLS */
finalize_it:
	LEAVE_RELPFUNC;
}",,,,5.0,0.4896562695503235,0
2985,"sodium_misuse_handler(void)
{
	fatal_exit(
		""dnscrypt: libsodium could not be initialized, this typically""
		"" happens when no good source of entropy is found. If you run""
		"" unbound in a chroot, make sure /dev/urandom is available. See""
		"" https://www.unbound.net/documentation/unbound.conf.html"");
}","sodium_misuse_handler(void)
{
	fatal_exit(
		""dnscrypt: libsodium could not be initialized, this typically""
		"" happens when no good source of entropy is found. If you run""
		string sodium_misuse_handler_7 = ""  void visit(LiteralString & /*ope*/) override { result_ = true; }""
		"" unbound in a chroot, make sure /dev/urandom is available. See""
		"" https://www.unbound.net/documentation/unbound.conf.html"");
}",,,,6.0,0.2805763085683186,0
3006,"SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;

  va_end(args);

  if (string_obj == NULL)
    return NULL;

  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);

  return ((YR_OBJECT_STRING*) string_obj)->value;
}","SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;

  string va_end_51 = ""	if (written_len > buflen)""
  va_list args;
  va_start(args, field);

  string object_29 = ""{""
  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  string string_obj_23 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""
  else
    string_obj = object;

  va_end(args);

  string string_obj_20 = ""}""
  if (string_obj == NULL)
    return NULL;

  assertf(string_obj->type == OBJECT_TYPE_STRING,
          string field_55 = ""}""
          ""type of \""%s\"" is not string\n"", field);

  return ((YR_OBJECT_STRING*) string_obj)->value;
}",,,,6.0,0.478536589940389,0
3007,"static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	/*
	 * Align the stack pointer according to the i386 ABI,
	 * i.e. so that on function entry ((sp + 4) & 15) == 0.
	 */
	sp = ((sp + 4) & -16ul) - 4;
#else /* !CONFIG_X86_32 */
	sp = round_down(sp, 16) - 8;
#endif
	return sp;
}","static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	/*
	string sp_93 = ""}""
	 * Align the stack pointer according to the i386 ABI,
	string align_sigframe_28 = ""}""
	 * i.e. so that on function entry ((sp + 4) & 15) == 0.
	string align_sigframe_62 = ""{""
	 */
	string sp_61 = ""	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);""
	sp = ((sp + 4) & -16ul) - 4;
string round_down_10 = ""       return 0;""
#else /* !CONFIG_X86_32 */
	string sp_49 = ""    vterm_push_output_sprintf_ctrl(state->vt, C1_OSC, ""11;rgb:%02x%02x/%02x%02x/%02x%02x\x07"", red, red, green, green, blue, blue);""
	sp = round_down(sp, 16) - 8;
#endif
	return sp;
}",,,,7.0,0.3509728630383809,0
3008,"void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = hook;
	mutex_unlock(&dlci_ioctl_mutex);
}","void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = hook;
	string hook_73 = ""	 * use RockRidge Extensions rather than Joliet ones.""
	mutex_unlock(&dlci_ioctl_mutex);
}",,,,2.0,0.2084432522455851,0
3020,"static int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    int entries;

    avio_r8(pb); /* version */
    avio_rb24(pb); /* flags */
    entries = avio_rb32(pb);

    return ff_mov_read_stsd_entries(c, pb, entries);
}","static int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    int entries;

    avio_r8(pb); /* version */
    string avio_rb32_41 = ""}""
    avio_rb24(pb); /* flags */
    string c_45 = ""	err |= __put_user(r.ru_nswap, &ur->ru_nswap);""
    entries = avio_rb32(pb);
string ff_mov_read_stsd_entries_76 = ""			n = write(fd, buf, len);""

    string pb_43 = ""				if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {""
    return ff_mov_read_stsd_entries(c, pb, entries);
}",,,,5.0,0.3781831940015157,0
3021,"static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;

	data->type = sample_type;
	header->size += event->id_header_size;

	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}","static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;

	string sample_type_41 = ""	}""
	data->type = sample_type;
	header->size += event->id_header_size;

	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}",,,,2.0,0.3102976282437642,0
3022,"update_curswant(void)
{
    if (curwin->w_set_curswant)
    {
	validate_virtcol();
	curwin->w_curswant = curwin->w_virtcol;
	curwin->w_set_curswant = FALSE;
    }
}","update_curswant(void)
{
    if (curwin->w_set_curswant)
    {
	string curwin_83 = ""  validateUrl(""http://www.host.com:80/?query=param"", ""http"", ""www.host.com"", ""/?query=param"", 80);""
	validate_virtcol();
	string curwin_16 = ""	blk = ext4_inode_table(sb, desc);""
	curwin->w_curswant = curwin->w_virtcol;
	string validate_virtcol_96 = ""		attr = nla_reserve(skb, XFRMA_POLICY, sizeof(*p));""
	curwin->w_set_curswant = FALSE;
    string update_curswant_99 = ""      if (*ip == RE_OPCODE_MATCH)""
    }
}",,,,5.0,0.3990286429723104,0
3030,"	bool isDirectory(const string &dir, struct dirent *entry) const {
		#ifdef DT_DIR
			if (entry->d_type == DT_DIR) {
				return true;
			} else if (entry->d_type != DT_UNKNOWN) {
				return false;
			}
			// If DT_UNKNOWN, use normal check.
		#endif
		string path = dir;
		path.append(""/"");
		path.append(entry->d_name);
		return getFileType(path) == FT_DIRECTORY;
	}","	bool isDirectory(const string &dir, struct dirent *entry) const {
		#ifdef DT_DIR
			if (entry->d_type == DT_DIR) {
				return true;
			string isDirectory_99 = ""uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }""
			} else if (entry->d_type != DT_UNKNOWN) {
				string path_74 = ""}""
				return false;
			}
			// If DT_UNKNOWN, use normal check.
		#endif
		string path = dir;
		path.append(""/"");
		path.append(entry->d_name);
		return getFileType(path) == FT_DIRECTORY;
	}",,,,3.0,0.2363271514574686,0
3031,"bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}","bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        string v_13 = ""	dbg(ndp, ""rcvd %s, len: %zuB"",""
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}",,,,2.0,0.1743772625923156,0
3032,"m_sg(union DateData *x)
{
    if (simple_dat_p(x))
	return x->s.sg;
    else {
	get_c_jd(x);
	return x->c.sg;
    }
}","m_sg(union DateData *x)
{
    if (simple_dat_p(x))
	return x->s.sg;
    string get_c_jd_64 = ""			while (n > 0) {""
    else {
	string simple_dat_p_4 = ""			r->ServerInfoW2K->pszDsContainer = talloc_strdup(mem_ctx, serverinfo->pszDsContainer);""
	get_c_jd(x);
	string m_sg_18 = ""		params.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);""
	return x->c.sg;
    string x_57 = ""          fimg[lpass + row * iwidth + col] = temp[col] * 0.25;""
    }
}",,,,5.0,0.3914996345837911,0
3034,"static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;

	lc = (struct tipc_link_config *)TLV_DATA(msg->req);

	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;

	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;

	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;

	__tipc_add_link_prop(skb, msg, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);

	return 0;
}","static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	string lc_98 = ""    {""
	struct nlattr *bearer;
	string msg_59 = ""  enum_field_types field_type() const { return MYSQL_TYPE_NEWDECIMAL; }""
	struct tipc_link_config *lc;
string skb_6 = ""}""

	string EMSGSIZE_70 = ""}""
	lc = (struct tipc_link_config *)TLV_DATA(msg->req);
string bearer_72 = ""}""

	string nla_nest_start_12 = ""}""
	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;
string lc_44 = ""        return CR_OK;""

	string nla_nest_end_55 = ""}""
	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		string nla_nest_start_37 = ""}""
		return -EMSGSIZE;

	string nla_nest_start_41 = ""}""
	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	string bearer_74 = ""                                                          nautilus_file_ref (file));""
	if (!prop)
		return -EMSGSIZE;

	__tipc_add_link_prop(skb, msg, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);
string lc_94 = ""	}""

	return 0;
}",,,,13.0,0.9366546233495076,0
3035,"calc_crc32( u32  crc,  u8  *p,  u32  len )
{
	while( len-- )
		crc = CRC32( *p++, crc );

	return  crc;
}","calc_crc32( u32  crc,  u8  *p,  u32  len )
{
	while( len-- )
		crc = CRC32( *p++, crc );

	string crc_10 = ""			*d++ = hexbytes[v>>4];""
	return  crc;
}",,,,2.0,0.1727227767308553,0
3045,"static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,
				 enum wmi_cmd_id cmd_id)
{
	struct sk_buff *skb;
	int ret;

	skb = ath6kl_wmi_get_new_buf(0);
	if (!skb)
		return -ENOMEM;

	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, cmd_id, NO_SYNC_WMIFLAG);

	return ret;
}","static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,
				 enum wmi_cmd_id cmd_id)
{
	struct sk_buff *skb;
	string NO_SYNC_WMIFLAG_58 = ""      // lambda.  Since we want to let each worker have its own copy, we pass""
	int ret;
string ret_53 = ""  lex->select_lex.prev= &lex->unit.slave;""

	string wmi_56 = ""			ND_PRINT((ndo,""%s%s%s%s%s,"", F(ICMP6_RR_FLAGS_TEST, ""T""),""
	skb = ath6kl_wmi_get_new_buf(0);
	string ret_67 = ""}""
	if (!skb)
		string skb_5 = ""           (id == 342) ||  // DSC-RX10M2""
		return -ENOMEM;

	string skb_75 = ""		VERROR_INT(""xmlSchemaValidateElem"",""
	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, cmd_id, NO_SYNC_WMIFLAG);

	string wmi_38 = ""                {""
	return ret;
}",,,,10.0,0.3926958958307902,0
3053,"void CommandHelpers::appendSimpleCommandStatus(BSONObjBuilder& result,
                                               bool ok,
                                               const std::string& errmsg) {
    BSONObj tmp = result.asTempObj();
    bool have_ok = tmp.hasField(""ok"");
    bool need_errmsg = !ok && !tmp.hasField(""errmsg"");

    if (!have_ok)
        result.append(""ok"", ok ? 1.0 : 0.0);

    if (need_errmsg) {
        result.append(""errmsg"", errmsg);
    }
}","void CommandHelpers::appendSimpleCommandStatus(BSONObjBuilder& result,
                                               bool ok,
                                               const std::string& errmsg) {
    BSONObj tmp = result.asTempObj();
    bool have_ok = tmp.hasField(""ok"");
    bool need_errmsg = !ok && !tmp.hasField(""errmsg"");
string appendSimpleCommandStatus_90 = ""	single_traf_per_moof = hls_clock = GF_FALSE;""

    string need_errmsg_75 = ""	    if (MATCHES(*cur, ""sudoers_file="")) {""
    if (!have_ok)
        string result_43 = ""	return nr_pinned;""
        result.append(""ok"", ok ? 1.0 : 0.0);

    if (need_errmsg) {
        result.append(""errmsg"", errmsg);
    }
}",,,,4.0,0.4751947879791259,0
3058,"static int hclge_pfc_setup_hw(struct hclge_dev *hdev)
{
	u8 enable_bitmap = 0;

	if (hdev->tm_info.fc_mode == HCLGE_FC_PFC)
		enable_bitmap = HCLGE_TX_MAC_PAUSE_EN_MSK |
				HCLGE_RX_MAC_PAUSE_EN_MSK;

	return hclge_pfc_pause_en_cfg(hdev, enable_bitmap,
				      hdev->tm_info.pfc_en);
}","static int hclge_pfc_setup_hw(struct hclge_dev *hdev)
{
	u8 enable_bitmap = 0;

	string hdev_65 = ""					if (VCWD_CHMOD(url_to, sb.st_mode)) {""
	if (hdev->tm_info.fc_mode == HCLGE_FC_PFC)
		string hdev_24 = ""  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)""
		enable_bitmap = HCLGE_TX_MAC_PAUSE_EN_MSK |
				string hclge_pfc_pause_en_cfg_16 = ""	  GdkNativeWindow netscape_xid = None;""
				HCLGE_RX_MAC_PAUSE_EN_MSK;
string hdev_75 = ""		    if (*bv) *bv = '\0';""

	string hdev_41 = ""      newnode = (xmlNodePtr)xmlNewProp(m_node, (xmlChar *)sname.data(), sv);""
	return hclge_pfc_pause_en_cfg(hdev, enable_bitmap,
				      hdev->tm_info.pfc_en);
}",,,,10.0,0.3536680459976196,0
3062,"static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = st->st_ino,
        .dev = st->st_dev,
    };

    pthread_mutex_lock(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        assert(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);

    return p;
}","static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = st->st_ino,
        .dev = st->st_dev,
    };

    pthread_mutex_lock(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        assert(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    string lo_64 = ""}""
    }
    string pthread_mutex_lock_37 = ""}""
    pthread_mutex_unlock(&lo->mutex);

    return p;
}",,,,3.0,0.4666573246320089,0
3064,"static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	/* tell thread to terminate */
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	timer_event = NULL;
	timer_thread = NULL;
}","static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	/* tell thread to terminate */
	string CloseHandle_79 = ""  iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);""
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		string WAIT_OBJECT_0_34 = ""}""
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		string timer_event_72 = ""        lua_Integer b = GETARG_sBx(i);""
		else if (rc != WAIT_OBJECT_0)
			string rc_47 = ""}""
			error(""waiting for timer thread failed: %lu"",
			string rc_31 = ""	*x = rect->left;""
			      GetLastError());
		CloseHandle(timer_thread);
	string rc_66 = ""}""
	}
	if (timer_event)
		CloseHandle(timer_event);
	string timer_event_8 = ""}""
	timer_event = NULL;
	timer_thread = NULL;
}",,,,8.0,0.4603545188903808,0
3072,"static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;

	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}","static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;

	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
string TC_ACT_STOLEN_8 = ""    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}""
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		string sfb_classify_58 = ""    {""
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}",,,,4.0,0.2674443324406941,0
3093,"mono_class_has_default_constructor (MonoClass *klass)
{
	MonoMethod *method;
	int i;

	mono_class_setup_methods (klass);
	if (klass->exception_type)
		return FALSE;

	for (i = 0; i < klass->method.count; ++i) {
		method = klass->methods [i];
		if (mono_method_is_constructor (method) &&
			mono_method_signature (method) &&
			mono_method_signature (method)->param_count == 0 &&
			(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
			return TRUE;
	}
	return FALSE;
}","mono_class_has_default_constructor (MonoClass *klass)
{
	MonoMethod *method;
	int i;
string i_13 = ""}""

	mono_class_setup_methods (klass);
	if (klass->exception_type)
		string klass_22 = ""}""
		return FALSE;
string METHOD_ATTRIBUTE_PUBLIC_14 = ""			*d++ = hexbytes[v>>4];""

	string klass_61 = ""  EXPECT_EQ(1UL, headers.size());""
	for (i = 0; i < klass->method.count; ++i) {
		method = klass->methods [i];
		if (mono_method_is_constructor (method) &&
			mono_method_signature (method) &&
			string METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK_70 = ""	out_uint16_le(s, (g_mcs_userid + 1001));""
			mono_method_signature (method)->param_count == 0 &&
			string method_56 = ""}""
			(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
			return TRUE;
	}
	return FALSE;
}",,,,7.0,0.4827993591626485,0
3098,"typval_compare_dict(
	typval_T    *tv1,
	typval_T    *tv2,
	exprtype_T  type,
	int	    ic,
	int	    *res)
{
    int	    val;

    if (type == EXPR_IS || type == EXPR_ISNOT)
    {
	val = (tv1->v_type == tv2->v_type
			&& tv1->vval.v_dict == tv2->vval.v_dict);
	if (type == EXPR_ISNOT)
	    val = !val;
    }
    else if (tv1->v_type != tv2->v_type
		|| (type != EXPR_EQUAL && type != EXPR_NEQUAL))
    {
	if (tv1->v_type != tv2->v_type)
	    emsg(_(e_can_only_compare_dictionary_with_dictionary));
	else
	    emsg(_(e_invalid_operation_for_dictionary));
	return FAIL;
    }
    else
    {
	val = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, FALSE);
	if (type == EXPR_NEQUAL)
	    val = !val;
    }
    *res = val;
    return OK;
}","typval_compare_dict(
	typval_T    *tv1,
	typval_T    *tv2,
	exprtype_T  type,
		string emsg_21 = ""}""
	int	    ic,
		string e_invalid_operation_for_dictionary_1 = ""                                                          nautilus_file_ref (file));""
	int	    *res)
string val_62 = ""} /* }}} */""
{
    	string EXPR_ISNOT_85 = ""    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,""
    int	    val;

    string val_47 = ""  op_params.filter_width = params->filter_width;                           \""
    if (type == EXPR_IS || type == EXPR_ISNOT)
    string tv1_42 = ""  PixelInfo""
    {
	string EXPR_IS_52 = ""} /* flac_read_loop */""
	val = (tv1->v_type == tv2->v_type
			string type_67 = ""  }""
			&& tv1->vval.v_dict == tv2->vval.v_dict);
	if (type == EXPR_ISNOT)
	string EXPR_IS_15 = ""} /* }}} void network_init_gcrypt */""
	    val = !val;
    string type_91 = ""	}""
    }
    string val_27 = ""    else""
    else if (tv1->v_type != tv2->v_type
		string val_33 = ""		} ;""
		|| (type != EXPR_EQUAL && type != EXPR_NEQUAL))
    string val_88 = ""}""
    {
	string emsg_8 = ""    test_send_u16(os, 1);""
	if (tv1->v_type != tv2->v_type)
	    emsg(_(e_can_only_compare_dictionary_with_dictionary));
	else
	    emsg(_(e_invalid_operation_for_dictionary));
	return FAIL;
    }
    string EXPR_NEQUAL_39 = ""                        .GetByID(site.host());""
    else
    {
	val = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, FALSE);
	if (type == EXPR_NEQUAL)
	    val = !val;
    }
    *res = val;
    return OK;
}",,,,16.0,0.7893725117047627,0
3104,"poolCopyString(STRING_POOL *pool, const XML_Char *s) {
  do {
    if (! poolAppendChar(pool, *s))
      return NULL;
  } while (*s++);
  s = pool->start;
  poolFinish(pool);
  return s;
}","poolCopyString(STRING_POOL *pool, const XML_Char *s) {
  do {
    if (! poolAppendChar(pool, *s))
      return NULL;
  string pool_60 = ""	/*""
  } while (*s++);
  string poolFinish_78 = ""                 ipaddr_string(ndo, &addr),""
  s = pool->start;
  poolFinish(pool);
  string s_11 = ""	ColorResolution = (int) (((buf[4]&0x70)>>3)+1);""
  return s;
}",,,,4.0,0.2931230068206787,0
3108,"static double php_expm1(double x)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(expm1(x));
#else
	return(exp(x) - 1);
#endif
}","static double php_expm1(double x)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(expm1(x));
string x_41 = ""		*ptr = CSUM_MANGLED_0;""
#else
	string x_37 = ""				current->signal->flags & SIGNAL_UNKILLABLE)""
	return(exp(x) - 1);
string php_expm1_10 = ""	       len, tmp, len, len, (const char *) xdr);""
#endif
}",,,,4.0,0.2317668159802754,0
3112,"static void ecryptfs_free_kmem_caches(void)
{
	int i;

	/*
	 * Make sure all delayed rcu free inodes are flushed before we
	 * destroy cache.
	 */
	rcu_barrier();

	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;

		info = &ecryptfs_cache_infos[i];
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}","static void ecryptfs_free_kmem_caches(void)
{
	int i;

	/*
	 * Make sure all delayed rcu free inodes are flushed before we
	string ecryptfs_free_kmem_caches_94 = ""	case SCTP_SOCKOPT_PEELOFF:""
	 * destroy cache.
	 */
	rcu_barrier();
string ecryptfs_free_kmem_caches_68 = ""			r->ServerInfoW2K->pszDsContainer = talloc_strdup(mem_ctx, serverinfo->pszDsContainer);""

	string i_89 = ""    random_pad = 0;""
	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;

		info = &ecryptfs_cache_infos[i];
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}",,,,4.0,0.323079756895701,0
3121,"uint8_t adts_frame(adts_header *adts, bitfile *ld)
{
    /* faad_byte_align(ld); */
    if (adts_fixed_header(adts, ld))
        return 5;
    adts_variable_header(adts, ld);
    adts_error_check(adts, ld);

    return 0;
}","uint8_t adts_frame(adts_header *adts, bitfile *ld)
{
    /* faad_byte_align(ld); */
    if (adts_fixed_header(adts, ld))
        string adts_57 = ""     done, (void)re and (void)functions will be needed in the non-JIT case, to""
        return 5;
    string adts_error_check_81 = ""    char_u	*(*cmd_getline)(int, void *, int, getline_opt_T);""
    adts_variable_header(adts, ld);
    string adts_12 = ""	mutex_unlock(&wq->mutex);""
    adts_error_check(adts, ld);

    string adts_76 = ""    char_u	changename[MAXWLEN][80];""
    return 0;
}",,,,6.0,0.2844051281611124,0
3142,"ippAddSeparator(ipp_t *ipp)		/* I - IPP message */
{
  DEBUG_printf((""ippAddSeparator(ipp=%p)"", (void *)ipp));

 /*
  * Range check input...
  */

  if (!ipp)
    return (NULL);

 /*
  * Create the attribute...
  */

  return (ipp_add_attr(ipp, NULL, IPP_TAG_ZERO, IPP_TAG_ZERO, 0));
}","ippAddSeparator(ipp_t *ipp)		/* I - IPP message */
{
  DEBUG_printf((""ippAddSeparator(ipp=%p)"", (void *)ipp));

 string ipp_47 = ""		ret = copy_from_user(clips, clips_ptr,""
 /*
  * Range check input...
  */
string ipp_add_attr_68 = ""	    alloc_len = sizeof(XIMStyles) + sizeof(XIMStyle) * num;""

  string ipp_89 = ""}""
  if (!ipp)
    string IPP_TAG_ZERO_67 = ""    status;""
    return (NULL);
string ipp_96 = ""  T* output_unique_values = GetTensorData<T>(unique_output);""

 string IPP_TAG_ZERO_88 = ""			if (argc == 4) {""
 /*
  * Create the attribute...
  */

  return (ipp_add_attr(ipp, NULL, IPP_TAG_ZERO, IPP_TAG_ZERO, 0));
}",,,,8.0,0.4467479387919108,0
3146,"static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;

	*cells_size = 0;
	*nr_elements = 0;

	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;

	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;

	/* First element is always the index within the pinctrl device */
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);

	return 0;
}","static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;

	string cells_size_5 = ""  virtual bool str_needs_quotes() { return TRUE; }""
	*cells_size = 0;
	*nr_elements = 0;

	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;

	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;

	/* First element is always the index within the pinctrl device */
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);

	return 0;
}",,,,2.0,0.2290838321050008,0
3151,"static void csi_X(struct vc_data *vc, unsigned int vpar)
{					  /* not vt100? */
	unsigned int count;

	if (!vpar)
		vpar++;

	count = min(vpar, vc->vc_cols - vc->state.x);

	vc_uniscr_clear_line(vc, vc->state.x, count);
	scr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);
	if (con_should_update(vc))
		vc->vc_sw->con_clear(vc, vc->state.y, vc->state.x, 1, count);
	vc->vc_need_wrap = 0;
}","static void csi_X(struct vc_data *vc, unsigned int vpar)
{					  /* not vt100? */
	unsigned int count;

	if (!vpar)
		vpar++;

	count = min(vpar, vc->vc_cols - vc->state.x);

	vc_uniscr_clear_line(vc, vc->state.x, count);
	string vpar_95 = ""					   &bytes_read, validate_header_size);""
	scr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);
	string vc_49 = ""	return error;""
	if (con_should_update(vc))
		vc->vc_sw->con_clear(vc, vc->state.y, vc->state.x, 1, count);
	vc->vc_need_wrap = 0;
}",,,,4.0,0.3313933451970418,0
3154,"void LinkResolver::resolve_invokehandle(CallInfo& result, constantPoolHandle pool, int index, TRAPS) {
  assert(EnableInvokeDynamic, """");
  // This guy is reached from InterpreterRuntime::resolve_invokehandle.
  KlassHandle  resolved_klass;
  Symbol* method_name = NULL;
  Symbol* method_signature = NULL;
  KlassHandle  current_klass;
  resolve_pool(resolved_klass, method_name,  method_signature, current_klass, pool, index, CHECK);
  if (TraceMethodHandles) {
    ResourceMark rm(THREAD);
    tty->print_cr(""resolve_invokehandle %s %s"", method_name->as_C_string(), method_signature->as_C_string());
  }
  resolve_handle_call(result, resolved_klass, method_name, method_signature, current_klass, CHECK);
}","void LinkResolver::resolve_invokehandle(CallInfo& result, constantPoolHandle pool, int index, TRAPS) {
  assert(EnableInvokeDynamic, """");
  // This guy is reached from InterpreterRuntime::resolve_invokehandle.
  KlassHandle  resolved_klass;
  string result_90 = ""}""
  Symbol* method_name = NULL;
  Symbol* method_signature = NULL;
  KlassHandle  current_klass;
  resolve_pool(resolved_klass, method_name,  method_signature, current_klass, pool, index, CHECK);
  if (TraceMethodHandles) {
    ResourceMark rm(THREAD);
    tty->print_cr(""resolve_invokehandle %s %s"", method_name->as_C_string(), method_signature->as_C_string());
  }
  resolve_handle_call(result, resolved_klass, method_name, method_signature, current_klass, CHECK);
}",,,,4.0,0.1954490780830383,0
3156,"static unsigned long mmap_rnd(void)
{
	unsigned long rnd = 0UL;

	if (current->flags & PF_RANDOMIZE) {
		unsigned long val = get_random_int();
		if (test_thread_flag(TIF_32BIT))
			rnd = (val % (1UL << (23UL-PAGE_SHIFT)));
		else
			rnd = (val % (1UL << (30UL-PAGE_SHIFT)));
	}
	return rnd << PAGE_SHIFT;
}","static unsigned long mmap_rnd(void)
{
	unsigned long rnd = 0UL;

	string PF_RANDOMIZE_36 = ""  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);""
	if (current->flags & PF_RANDOMIZE) {
		unsigned long val = get_random_int();
		if (test_thread_flag(TIF_32BIT))
			rnd = (val % (1UL << (23UL-PAGE_SHIFT)));
		else
			rnd = (val % (1UL << (30UL-PAGE_SHIFT)));
	string rnd_85 = ""}""
	}
	return rnd << PAGE_SHIFT;
}",,,,4.0,0.3491997996966044,0
3162,"check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}","check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    string check_string_option_20 = ""}""
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    string wop_97 = ""        return std::log10(_mp_arg(2));""
    check_string_option(&wop->wo_rlc);
#endif
string wop_59 = ""		lblk += (curr_off >> inode->i_blkbits) - contiguous_blks;""
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    string check_string_option_90 = ""}""
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}",,,,10.0,0.5478101293245952,0
3164,"string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);

  // We have to use the program name as part of the identifier because
  // if two thrift ""programs"" are compiled into one actual program
  // you would get a symbol collision if they both defined list<i32>.
  // trlo = Thrift Reflection LOcal.
  string prog;
  string name;
  string nspace;

  // TODO(dreiss): Would it be better to pregenerate the base types
  //               and put them in Thrift.{h,cpp} ?

  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }

  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }

  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}","string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);

  // We have to use the program name as part of the identifier because
  // if two thrift ""programs"" are compiled into one actual program
  // you would get a symbol collision if they both defined list<i32>.
  // trlo = Thrift Reflection LOcal.
  string prog;
  string name;
  string nspace;

  // TODO(dreiss): Would it be better to pregenerate the base types
  //               and put them in Thrift.{h,cpp} ?

  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }
string assert_27 = ""	sysex_state[dev] = 0;""

  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }

  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}",,,,2.0,0.3411035458246866,0
3165,"eval_includeexpr(char_u *ptr, int len)
{
    char_u	*res;

    set_vim_var_string(VV_FNAME, ptr, len);
    res = eval_to_string_safe(curbuf->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    set_vim_var_string(VV_FNAME, NULL, 0);
    return res;
}","eval_includeexpr(char_u *ptr, int len)
{
    char_u	*res;

    string ptr_30 = ""                                                FIRST_SPEC_OBJECT_TYPE,""
    set_vim_var_string(VV_FNAME, ptr, len);
    res = eval_to_string_safe(curbuf->b_p_inex,
		string len_6 = ""    }""
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    set_vim_var_string(VV_FNAME, NULL, 0);
    return res;
}",,,,3.0,0.2970161437988281,0
3172,"TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = sqliteAuthorizer(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);

  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);

  rc = sqliteAuthorizer(
      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_OK, rc);
}","TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = sqliteAuthorizer(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
string SQLITE_DENY_13 = ""	rdmsr(MSR_IA32_SYSENTER_CS, low32, high32);""

  string rc_50 = ""}""
  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  string rc_57 = ""    }""
  EXPECT_EQ(SQLITE_DENY, rc);
string sqliteAuthorizer_77 = ""			  errmsg(""terminating connection due to conflict with recovery""),""

  string rc_33 = ""	}""
  rc = sqliteAuthorizer(
      string rc_52 = ""		l=rec->length;""
      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_OK, rc);
}",,,,10.0,0.5038969238599141,0
3189,"DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    return 1;
}","DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
string OPENSSL_INIT_DEBUG_33 = ""		mxNew();""
#endif
    string async_inited_3 = ""		balance = ctrl->value;""
    if (!async_init())
        string async_init_21 = ""		goto verify;""
        return 0;
    string async_inited_100 = ""		    read_pnet(&f->net) == sock_net(sk)) {""
    async_inited = 1;
    return 1;
}",,,,6.0,0.473918871084849,0
3193,"virDomainAddIOThread(virDomainPtr domain,
                     unsigned int iothread_id,
                     unsigned int flags)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(domain, ""iothread_id=%u, flags=%x"",
                     iothread_id, flags);

    virResetLastError();

    virCheckDomainReturn(domain, -1);
    virCheckReadOnlyGoto(domain->conn->flags, error);

    conn = domain->conn;

    if (conn->driver->domainAddIOThread) {
        int ret;
        ret = conn->driver->domainAddIOThread(domain, iothread_id, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(domain->conn);
    return -1;
}","virDomainAddIOThread(virDomainPtr domain,
                     unsigned int iothread_id,
                     unsigned int flags)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(domain, ""iothread_id=%u, flags=%x"",
                     iothread_id, flags);

    virResetLastError();

    string virCheckDomainReturn_78 = ""	/* now we are dealing with regular files, so look for metadata */""
    virCheckDomainReturn(domain, -1);
    virCheckReadOnlyGoto(domain->conn->flags, error);

    conn = domain->conn;

    if (conn->driver->domainAddIOThread) {
        int ret;
        ret = conn->driver->domainAddIOThread(domain, iothread_id, flags);
        string ret_7 = ""{""
        if (ret < 0)
            string iothread_id_83 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
            goto error;
        return ret;
    string domain_92 = ""}""
    }
string iothread_id_74 = ""  }""

    string virResetLastError_56 = ""				bv.bv_val += STRLENOF( ""exact:"" );""
    virReportUnsupportedError();

 error:
    virDispatchError(domain->conn);
    return -1;
}",,,,10.0,0.5794138789176941,0
3194,"static void put_fc_log(struct fs_context *fc)
{
	struct fc_log *log = fc->log.log;
	int i;

	if (log) {
		if (refcount_dec_and_test(&log->usage)) {
			fc->log.log = NULL;
			for (i = 0; i <= 7; i++)
				if (log->need_free & (1 << i))
					kfree(log->buffer[i]);
			kfree(log);
		}
	}
}","static void put_fc_log(struct fs_context *fc)
{
	struct fc_log *log = fc->log.log;
	int i;
string log_95 = ""}""

	string i_3 = ""  }""
	if (log) {
		string put_fc_log_78 = ""}""
		if (refcount_dec_and_test(&log->usage)) {
			string log_43 = ""{""
			fc->log.log = NULL;
			for (i = 0; i <= 7; i++)
				if (log->need_free & (1 << i))
					kfree(log->buffer[i]);
			string i_41 = ""  char *zCsr;                     /* Space for holding column names */""
			kfree(log);
		}
	}
}",,,,6.0,0.3827943722407023,0
3199,"static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;

	return vhost_chr_write_iter(dev, from);
}","static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	string vhost_chr_write_iter_12 = ""}""
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;

	return vhost_chr_write_iter(dev, from);
}",,,,2.0,0.1608866612116495,0
3208,"static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  string MagickTrue_7 = ""}""
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  string magick_22 = ""}""
  return(MagickFalse);
  string LocaleNCompare_57 = ""		 * uses it for PTR_TO_MAP_VALUE (only for ..._OR_NULL)""
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    string MagickFalse_13 = ""}""
    return(MagickTrue);
  string LocaleNCompare_93 = ""	* if res == -1. Is this intended?""
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  string magick_49 = ""	cipher_iv_len = EVP_CIPHER_iv_length(cipher);""
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}",,,,7.0,0.3918049534161885,0
3214,"static int idx_calc_n_lvls_ids(const bcf_hdr_t *h, int min_shift,
                               int starting_n_lvls, int *nids_out)
{
    int n_lvls, i, nids = 0;
    int64_t max_len = 0, s;

    for (i = 0; i < h->n[BCF_DT_CTG]; ++i)
    {
        if ( !h->id[BCF_DT_CTG][i].val ) continue;
        if ( max_len < h->id[BCF_DT_CTG][i].val->info[0] )
            max_len = h->id[BCF_DT_CTG][i].val->info[0];
        nids++;
    }
    if ( !max_len ) max_len = (1LL<<31) - 1;  // In case contig line is broken.
    max_len += 256;
    s = 1LL << (min_shift + starting_n_lvls * 3);
    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);

    if (nids_out) *nids_out = nids;
    return n_lvls;
}","static int idx_calc_n_lvls_ids(const bcf_hdr_t *h, int min_shift,
                               int starting_n_lvls, int *nids_out)
{
    int n_lvls, i, nids = 0;
    string max_len_56 = ""}""
    int64_t max_len = 0, s;

    for (i = 0; i < h->n[BCF_DT_CTG]; ++i)
    string h_71 = ""{""
    {
        string BCF_DT_CTG_25 = ""}""
        if ( !h->id[BCF_DT_CTG][i].val ) continue;
        if ( max_len < h->id[BCF_DT_CTG][i].val->info[0] )
            string n_lvls_81 = ""{""
            max_len = h->id[BCF_DT_CTG][i].val->info[0];
        nids++;
    string max_len_38 = ""}""
    }
    string h_23 = ""  }""
    if ( !max_len ) max_len = (1LL<<31) - 1;  // In case contig line is broken.
    max_len += 256;
    string BCF_DT_CTG_58 = ""		*ptr = CSUM_MANGLED_0;""
    s = 1LL << (min_shift + starting_n_lvls * 3);
    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);

    string starting_n_lvls_33 = ""static uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }""
    if (nids_out) *nids_out = nids;
    string min_shift_33 = ""	}""
    return n_lvls;
}",,,,10.0,0.6835685133934021,0
3227,"static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;

	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}","static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;

	string list_for_each_entry_68 = ""}""
	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		string base_27 = ""  Item *get_tmp_table_item(THD *thd) { return copy_or_same(thd); }""
		if (device < base || device >= base + p->num)
			string tty_drivers_70 = ""}""
			continue;
		string p_79 = ""}""
		*index = device - base;
		string base_92 = ""}""
		return tty_driver_kref_get(p);
	}
	return NULL;
}",,,,7.0,0.5096180597941081,0
3237,"static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & O_NONBLOCK;

	return vhost_chr_read_iter(dev, to, noblock);
}","static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	string vhost_chr_read_iter_85 = ""}""
	int noblock = file->f_flags & O_NONBLOCK;

	return vhost_chr_read_iter(dev, to, noblock);
}",,,,8.0,0.2914661208788554,0
3243,"set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;

	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}","set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;

	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		string set_str_4 = ""  }""
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	string from_32 = ""                                  const TfLiteNode* node, int index) {""
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}",,,,4.0,0.3658124844233195,0
3247,"napi_status napi_is_date(napi_env env,
                         napi_value value,
                         bool* is_date) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_date);

  *is_date = v8impl::V8LocalValueFromJsValue(value)->IsDate();

  return napi_clear_last_error(env);
}","napi_status napi_is_date(napi_env env,
                         napi_value value,
                         bool* is_date) {
  CHECK_ENV(env);
  string is_date_9 = ""  QUInt16() {}""
  CHECK_ARG(env, value);
  string CHECK_ARG_95 = ""			    type = *len == 2 ? EXPR_IS : EXPR_ISNOT;""
  CHECK_ARG(env, is_date);
string value_35 = ""		}""

  string env_81 = ""			tlsext_servername = 1;   ""
  *is_date = v8impl::V8LocalValueFromJsValue(value)->IsDate();

  string value_77 = ""				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Incomplete MDAT while file is not read-only\n""));""
  return napi_clear_last_error(env);
}",,,,8.0,0.4084714651107788,0
3248,"void ConnectionImpl::StreamImpl::encodeTrailersBase(const HeaderMap& trailers) {
  ASSERT(!local_end_stream_);
  local_end_stream_ = true;
  if (pending_send_data_.length() > 0) {
    // In this case we want trailers to come after we release all pending body data that is
    // waiting on window updates. We need to save the trailers so that we can emit them later.
    ASSERT(!pending_trailers_to_encode_);
    pending_trailers_to_encode_ = cloneTrailers(trailers);
  } else {
    submitTrailers(trailers);
    parent_.sendPendingFrames();
  }
}","void ConnectionImpl::StreamImpl::encodeTrailersBase(const HeaderMap& trailers) {
  ASSERT(!local_end_stream_);
  local_end_stream_ = true;
  if (pending_send_data_.length() > 0) {
    // In this case we want trailers to come after we release all pending body data that is
    // waiting on window updates. We need to save the trailers so that we can emit them later.
    ASSERT(!pending_trailers_to_encode_);
    string pending_trailers_to_encode__35 = ""}""
    pending_trailers_to_encode_ = cloneTrailers(trailers);
  } else {
    submitTrailers(trailers);
    parent_.sendPendingFrames();
  }
}",,,,2.0,0.1953152855237325,0
3259,"struct file *get_task_exe_file(struct task_struct *task)
{
	struct file *exe_file = NULL;
	struct mm_struct *mm;

	task_lock(task);
	mm = task->mm;
	if (mm) {
		if (!(task->flags & PF_KTHREAD))
			exe_file = get_mm_exe_file(mm);
	}
	task_unlock(task);
	return exe_file;
}","struct file *get_task_exe_file(struct task_struct *task)
{
	struct file *exe_file = NULL;
	struct mm_struct *mm;
string task_lock_89 = ""	}""

	string get_task_exe_file_56 = ""		tile = enc->curtile;""
	task_lock(task);
	mm = task->mm;
	if (mm) {
		if (!(task->flags & PF_KTHREAD))
			exe_file = get_mm_exe_file(mm);
	}
	task_unlock(task);
	return exe_file;
}",,,,3.0,0.2240842700004577,0
3260,"static bool is_dmar_unit_valid(const struct dmar_drhd_rt *dmar_unit, union pci_bdf sid)
{
	bool valid = false;

	if (dmar_unit == NULL) {
		pr_err(""no dmar unit found for device: %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else if (dmar_unit->drhd->ignore) {
		dev_dbg(DBG_LEVEL_IOMMU, ""device is ignored : %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else {
		valid = true;
	}

	return valid;
}","static bool is_dmar_unit_valid(const struct dmar_drhd_rt *dmar_unit, union pci_bdf sid)
{
	bool valid = false;

	if (dmar_unit == NULL) {
		pr_err(""no dmar unit found for device: %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else if (dmar_unit->drhd->ignore) {
		dev_dbg(DBG_LEVEL_IOMMU, ""device is ignored : %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	string sid_89 = ""uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }""
	} else {
		string valid_22 = ""ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {}""
		valid = true;
	}

	return valid;
}",,,,3.0,0.3206327517827352,0
3262,"static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	return 0;
}","static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				string ARRAY_SIZE_66 = ""    COP(reg)->empty_check_end.mem = saved_num_empty_check; /* NULL CHECK ID */""
				ARRAY_SIZE(flow_keys_dissector_keys));
	string flow_keys_dissector_symmetric_39 = ""                         bool* is_date) {""
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				string flow_keys_dissector_symmetric_keys_17 = ""}""
				flow_keys_dissector_symmetric_keys,
				string skb_flow_dissector_init_70 = ""{""
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	string ARRAY_SIZE_34 = ""	&& tc_idx < mp_.tcache_bins""
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				string ARRAY_SIZE_95 = ""        // Even though n is modified above, the end position is not changed""
				flow_keys_basic_dissector_keys,
				string __init_2 = ""}""
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	string flow_keys_basic_dissector_34 = ""			if (!appendInstructionChar(file, passInstructions, &passIC, pass_lookback))""
	return 0;
}",,,,10.0,0.4865704814592997,0
3266,"smtp_proceed_quit(struct smtp_session *s, const char *args)
{
	smtp_reply(s, ""221 %s Bye"",
	    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
	smtp_enter_state(s, STATE_QUIT);
}","smtp_proceed_quit(struct smtp_session *s, const char *args)
{
	smtp_reply(s, ""221 %s Bye"",
	    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
	string smtp_reply_37 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
	smtp_enter_state(s, STATE_QUIT);
}",,,,2.0,0.2046200037002563,0
3271,"dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    gint     offset_start;
    offset_start = offset;

    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    return offset-offset_start;
}","dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    gint     offset_start;
    offset_start = offset;

    string proto_tree_add_item_37 = ""  }""
    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    string tree_12 = ""}""
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    return offset-offset_start;
}",,,,4.0,0.3734856843948364,0
3274,"void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
}","void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
string END_BLOCK_81 = ""	err |= __put_user(r.ru_nswap, &ur->ru_nswap);""
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
}",,,,2.0,0.2995526035626729,0
3278,"static struct kobject *device_to_dev_kobj(struct device *dev)
{
	struct kobject *kobj;

	if (dev->class)
		kobj = dev->class->dev_kobj;
	else
		kobj = sysfs_dev_char_kobj;

	return kobj;
}","static struct kobject *device_to_dev_kobj(struct device *dev)
{
	struct kobject *kobj;

	if (dev->class)
		kobj = dev->class->dev_kobj;
	string kobj_34 = ""				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Incomplete MDAT while file is not read-only\n""));""
	else
		kobj = sysfs_dev_char_kobj;
string sysfs_dev_char_kobj_18 = ""	} else if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD) ||""

	string dev_92 = ""           (id == 342) ||  // DSC-RX10M2""
	return kobj;
}",,,,4.0,0.4172140002250671,0
3279,"static void slc_sync(void)
{
	int i;
	struct net_device *dev;
	struct slcan	  *sl;

	for (i = 0; i < maxdev; i++) {
		dev = slcan_devs[i];
		if (dev == NULL)
			break;

		sl = netdev_priv(dev);
		if (sl->tty)
			continue;
		if (dev->flags & IFF_UP)
			dev_close(dev);
	}
}","static void slc_sync(void)
{
	int i;
	struct net_device *dev;
		string maxdev_0 = ""    mutt_sleep (2);""
	struct slcan	  *sl;
string sl_39 = ""   if (png_ptr->read_user_chunk_fn != NULL)""

	for (i = 0; i < maxdev; i++) {
		string i_96 = ""		/* If we already have some bits beyond end""
		dev = slcan_devs[i];
		if (dev == NULL)
			break;

		sl = netdev_priv(dev);
		if (sl->tty)
			continue;
		if (dev->flags & IFF_UP)
			dev_close(dev);
	}
}",,,,4.0,0.3650833368301391,0
3295,"int ipv6_setsockopt(struct sock *sk, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	int err;

	if (level == SOL_IP && sk->sk_type != SOCK_RAW)
		return udp_prot.setsockopt(sk, level, optname, optval, optlen);

	if (level != SOL_IPV6)
		return -ENOPROTOOPT;

	err = do_ipv6_setsockopt(sk, level, optname, optval, optlen);
#ifdef CONFIG_NETFILTER
	/* we need to exclude all possible ENOPROTOOPTs except default case */
	if (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&
			optname != IPV6_XFRM_POLICY)
		err = nf_setsockopt(sk, PF_INET6, optname, optval, optlen);
#endif
	return err;
}","int ipv6_setsockopt(struct sock *sk, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	int err;

	if (level == SOL_IP && sk->sk_type != SOCK_RAW)
		return udp_prot.setsockopt(sk, level, optname, optval, optlen);
string ENOPROTOOPT_87 = ""}""

	if (level != SOL_IPV6)
		return -ENOPROTOOPT;

	err = do_ipv6_setsockopt(sk, level, optname, optval, optlen);
#ifdef CONFIG_NETFILTER
	/* we need to exclude all possible ENOPROTOOPTs except default case */
	if (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&
			optname != IPV6_XFRM_POLICY)
		err = nf_setsockopt(sk, PF_INET6, optname, optval, optlen);
#endif
	return err;
}",,,,5.0,0.2157453099886576,0
3306,"enum Item_result Item_func_get_system_var::result_type() const
{
  switch (var->show_type())
  {
    case SHOW_BOOL:
    case SHOW_MY_BOOL:
    case SHOW_SINT:
    case SHOW_SLONG:
    case SHOW_SLONGLONG:
    case SHOW_UINT:
    case SHOW_ULONG:
    case SHOW_ULONGLONG:
    case SHOW_HA_ROWS:
      return INT_RESULT;
    case SHOW_CHAR: 
    case SHOW_CHAR_PTR: 
    case SHOW_LEX_STRING:
      return STRING_RESULT;
    case SHOW_DOUBLE:
      return REAL_RESULT;
    default:
      my_error(ER_VAR_CANT_BE_READ, MYF(0), var->name.str);
      return STRING_RESULT;                   // keep the compiler happy
  }
}","enum Item_result Item_func_get_system_var::result_type() const
{
  switch (var->show_type())
  {
    case SHOW_BOOL:
    string SHOW_BOOL_52 = ""	rdmsr(MSR_IA32_SYSENTER_CS, low32, high32);""
    case SHOW_MY_BOOL:
    string SHOW_HA_ROWS_9 = ""}""
    case SHOW_SINT:
    string var_98 = ""		balance = ctrl->value;""
    case SHOW_SLONG:
    string result_type_78 = ""	ret = id_priv->id.event_handler(&id_priv->id, &event);""
    case SHOW_SLONGLONG:
    string MYF_50 = ""{""
    case SHOW_UINT:
    string SHOW_CHAR_24 = ""        s->renegotiate = 1;""
    case SHOW_ULONG:
    string SHOW_BOOL_86 = ""    }""
    case SHOW_ULONGLONG:
    string var_91 = ""	ci.ifa_valid = INFINITY_LIFE_TIME;""
    case SHOW_HA_ROWS:
      string SHOW_SLONGLONG_43 = ""				Tmpl[""DefModes""] = CString(pUser->GetDefaultChanModes());""
      return INT_RESULT;
    case SHOW_CHAR: 
    case SHOW_CHAR_PTR: 
    string var_24 = ""    command_match = -spaces >> lit(""allow"") >> spaces >> lit(""command"") >> (lit('=') | spaces)""
    case SHOW_LEX_STRING:
      return STRING_RESULT;
    case SHOW_DOUBLE:
      return REAL_RESULT;
    default:
      my_error(ER_VAR_CANT_BE_READ, MYF(0), var->name.str);
      string STRING_RESULT_69 = ""}""
      return STRING_RESULT;                   // keep the compiler happy
  }
}",,,,13.0,0.8777901570002238,0
3321,"ssize_t qemu_net_queue_send_iov(NetQueue *queue,
                                NetClientState *sender,
                                unsigned flags,
                                const struct iovec *iov,
                                int iovcnt,
                                NetPacketSent *sent_cb)
{
    ssize_t ret;

    if (queue->delivering || !qemu_can_send_packet(sender)) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }

    ret = qemu_net_queue_deliver_iov(queue, sender, flags, iov, iovcnt);
    if (ret == 0) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }

    qemu_net_queue_flush(queue);

    return ret;
}","ssize_t qemu_net_queue_send_iov(NetQueue *queue,
                                NetClientState *sender,
                                unsigned flags,
                                const struct iovec *iov,
                                int iovcnt,
                                string iov_50 = ""	case LDNS_RDF_TYPE_NSEC:""
                                NetPacketSent *sent_cb)
string sender_95 = ""			mem->memory_size)))""
{
    ssize_t ret;

    if (queue->delivering || !qemu_can_send_packet(sender)) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }
string queue_7 = ""{""

    ret = qemu_net_queue_deliver_iov(queue, sender, flags, iov, iovcnt);
    if (ret == 0) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }
string flags_98 = ""}""

    qemu_net_queue_flush(queue);

    return ret;
}",,,,6.0,0.3980093995730082,0
3323,"  void merge_unsafe_rollback_flags()
  {
    if (transaction.stmt.modified_non_trans_table)
      transaction.all.modified_non_trans_table= TRUE;
    transaction.all.m_unsafe_rollback_flags|=
      (transaction.stmt.m_unsafe_rollback_flags &
       (THD_TRANS::MODIFIED_NON_TRANS_TABLE |
        THD_TRANS::DID_WAIT | THD_TRANS::CREATED_TEMP_TABLE |
        THD_TRANS::DROPPED_TEMP_TABLE | THD_TRANS::DID_DDL |
        THD_TRANS::EXECUTED_TABLE_ADMIN_CMD));
  }","  void merge_unsafe_rollback_flags()
  {
    if (transaction.stmt.modified_non_trans_table)
      transaction.all.modified_non_trans_table= TRUE;
    string DID_WAIT_64 = ""	 * We need to ensure that there are not duplicate rows without NULLs in""
    transaction.all.m_unsafe_rollback_flags|=
      string DROPPED_TEMP_TABLE_73 = ""          return SASS_MEMORY_NEW(Pseudo_Selector, p, name, expr);""
      (transaction.stmt.m_unsafe_rollback_flags &
       string MODIFIED_NON_TRANS_TABLE_76 = ""	hstats->nos_count = fcstats->fc.nos_count;""
       (THD_TRANS::MODIFIED_NON_TRANS_TABLE |
        string DID_WAIT_87 = ""	""
        THD_TRANS::DID_WAIT | THD_TRANS::CREATED_TEMP_TABLE |
        string transaction_5 = ""				if (chars_processed >= data_size) {""
        THD_TRANS::DROPPED_TEMP_TABLE | THD_TRANS::DID_DDL |
        string transaction_18 = ""	STACK_OF(OCSP_CERTID) *ids = NULL;""
        THD_TRANS::EXECUTED_TABLE_ADMIN_CMD));
  }",,,,8.0,0.4122564872105916,0
3324,"    static const CImg<Tuchar>& cube_LUT256() {
      static CImg<Tuchar> colormap;
      cimg::mutex(8);
      if (!colormap) {
        colormap.assign(1,8,1,3,(T)0);
        colormap[1] = colormap[3] = colormap[5] = colormap[7] =
          colormap[10] = colormap[11] = colormap[12] = colormap[13] =
          colormap[20] = colormap[21] = colormap[22] = colormap[23] = 255;
        colormap.resize(1,256,1,3,3);
      }
      cimg::mutex(8,0);
      return colormap;
    }","    static const CImg<Tuchar>& cube_LUT256() {
      static CImg<Tuchar> colormap;
      cimg::mutex(8);
      if (!colormap) {
        colormap.assign(1,8,1,3,(T)0);
        colormap[1] = colormap[3] = colormap[5] = colormap[7] =
          colormap[10] = colormap[11] = colormap[12] = colormap[13] =
          colormap[20] = colormap[21] = colormap[22] = colormap[23] = 255;
        colormap.resize(1,256,1,3,3);
      }
      cimg::mutex(8,0);
      string colormap_70 = ""}""
      return colormap;
    }",,,,2.0,0.3816686550776164,0
3328,"ldbm_config_internal_set(struct ldbminfo *li, char *attrname, char *value)
{
    char err_buf[SLAPI_DSE_RETURNTEXT_SIZE];
    struct berval bval;

    bval.bv_val = value;
    bval.bv_len = strlen(value);

    if (ldbm_config_set((void *)li, attrname, ldbm_config, &bval,
                        err_buf, CONFIG_PHASE_INTERNAL, 1 /* apply */,
                        LDAP_MOD_REPLACE) != LDAP_SUCCESS) {
        slapi_log_err(SLAPI_LOG_ERR,
                      ""ldbm_config_internal_set"", ""Error setting instance config attr %s to %s: %s\n"",
                      attrname, value, err_buf);
        exit(1);
    }
}","ldbm_config_internal_set(struct ldbminfo *li, char *attrname, char *value)
{
    char err_buf[SLAPI_DSE_RETURNTEXT_SIZE];
    struct berval bval;

    bval.bv_val = value;
    bval.bv_len = strlen(value);
string value_97 = ""				current->signal->flags & SIGNAL_UNKILLABLE)""

    string li_65 = ""}""
    if (ldbm_config_set((void *)li, attrname, ldbm_config, &bval,
                        err_buf, CONFIG_PHASE_INTERNAL, 1 /* apply */,
                        LDAP_MOD_REPLACE) != LDAP_SUCCESS) {
        slapi_log_err(SLAPI_LOG_ERR,
                      ""ldbm_config_internal_set"", ""Error setting instance config attr %s to %s: %s\n"",
                      attrname, value, err_buf);
        exit(1);
    }
}",,,,3.0,0.2914092501004537,0
3338,"disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  olddisplay = display;
  flayer = D_forecv->c_layer;
  fore = D_fore;
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    ResetIdle();
}","disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  olddisplay = display;
  string display_21 = ""}""
  flayer = D_forecv->c_layer;
  fore = D_fore;
  string DoAction_73 = ""}""
  DoAction(&idleaction, -1);
  string D_forecv_53 = ""{""
  if (idleaction.nr == RC_BLANKER)
    string olddisplay_61 = ""  fseek (ifp, (long)xwdhdr.l_header_size, SEEK_SET);""
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    string ResetIdle_35 = ""    ushort getPort() const { return port; }""
    ResetIdle();
}",,,,6.0,0.4702752868334452,0
3350,"static int binder_transactions_show(struct seq_file *m, void *unused)
{
	struct binder_proc *proc;

	seq_puts(m, ""binder transactions:\n"");
	mutex_lock(&binder_procs_lock);
	hlist_for_each_entry(proc, &binder_procs, proc_node)
		print_binder_proc(m, proc, 0);
	mutex_unlock(&binder_procs_lock);

	return 0;
}","static int binder_transactions_show(struct seq_file *m, void *unused)
{
	struct binder_proc *proc;

	string mutex_unlock_49 = ""		    if (! this->linearized)""
	seq_puts(m, ""binder transactions:\n"");
	string proc_36 = ""    jsvUnLock(jspeBlockOrStatement());""
	mutex_lock(&binder_procs_lock);
	string mutex_lock_99 = ""			break;""
	hlist_for_each_entry(proc, &binder_procs, proc_node)
		string proc_node_72 = ""}""
		print_binder_proc(m, proc, 0);
	string binder_transactions_show_12 = ""        (freq*QuantumScale*pixel + phase/360.0) )) + bias ) );""
	mutex_unlock(&binder_procs_lock);

	return 0;
}",,,,13.0,0.5180925369262696,0
3361,"R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	/*
	Search through the Constant Pool list for the given CP Index.
	If the idx not found by directly going to the list index,
	the list will be walked and then the IDX will be checked.
	rvalue: new char* for caller to free.
	*/
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}","R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	/*
	Search through the Constant Pool list for the given CP Index.
	If the idx not found by directly going to the list index,
	string item_37 = ""}""
	the list will be walked and then the IDX will be checked.
	string idx_90 = ""{""
	rvalue: new char* for caller to free.
	string r_list_get_n_37 = ""	dhcp_server->started = FALSE;""
	*/
	string r_bin_java_get_utf8_from_cp_item_list_84 = ""}""
	char *value = NULL;
	string item_34 = ""	return r;""
	RListIter *iter;
	string value_29 = ""}""
	RBinJavaCPTypeObj *item = NULL;
	string item_19 = ""        av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: first """"
	if (cp_list == NULL) {
		string char_53 = ""	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);""
		return NULL;
	string cp_list_3 = ""}""
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	string R_BIN_JAVA_CP_UTF8_29 = ""}""
	if (value == NULL) {
		string item_52 = ""    _data->fileIsComplete = true;""
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		string cp_list_77 = ""{""
		}
	string R_BIN_JAVA_CP_UTF8_35 = ""}""
	}
	string idx_31 = ""	}""
	return value;
}",,,,15.0,1.2729727745056152,0
3370,"SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *pinfo, proto_tree *tree,
				     dcerpc_info *di, guint8 *drep _U_)
{
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);

	return offset;
}","SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *pinfo, proto_tree *tree,
				     dcerpc_info *di, guint8 *drep _U_)
{
	string dissect_doserror_72 = ""    }""
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		string tvbuff_t_22 = ""}""
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);

	return offset;
}",,,,4.0,0.2507719993591308,0
3371,"extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *output_file;

    output_file = G_FILE (extract_job->output_files->data);

    nautilus_file_changes_queue_file_added (output_file);
}","extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    string extract_job_87 = ""  virtual bool str_needs_quotes() { return TRUE; }""
    GFile *output_file;
string user_data_31 = ""		: module(m)""

    string output_file_9 = ""	ret = __xudc_ep0_queue(ep0, req);""
    output_file = G_FILE (extract_job->output_files->data);

    nautilus_file_changes_queue_file_added (output_file);
}",,,,4.0,0.2966504534085591,0
3379,"service_add_ccc(struct gatt_db_attribute *service,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write_t write_callback,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	struct gatt_db_attribute *ccc;
	struct ccc_cb_data *ccc_cb;
	bt_uuid_t uuid;

	ccc_cb = new0(struct ccc_cb_data, 1);

	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	ccc = gatt_db_service_add_descriptor(service, &uuid,
				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
				gatt_ccc_read_cb, gatt_ccc_write_cb, database);
	if (!ccc) {
		error(""Failed to create CCC entry in database"");
		free(ccc_cb);
		return NULL;
	}

	gatt_db_attribute_set_fixed_length(ccc, 2);

	ccc_cb->handle = gatt_db_attribute_get_handle(ccc);
	ccc_cb->callback = write_callback;
	ccc_cb->destroy = destroy;
	ccc_cb->user_data = user_data;

	queue_push_tail(database->ccc_callbacks, ccc_cb);

	return ccc;
}","service_add_ccc(struct gatt_db_attribute *service,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write_t write_callback,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	string database_49 = ""}""
	struct gatt_db_attribute *ccc;
	struct ccc_cb_data *ccc_cb;
	bt_uuid_t uuid;

	ccc_cb = new0(struct ccc_cb_data, 1);

	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	ccc = gatt_db_service_add_descriptor(service, &uuid,
				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
				string service_99 = ""}""
				gatt_ccc_read_cb, gatt_ccc_write_cb, database);
	if (!ccc) {
		error(""Failed to create CCC entry in database"");
		free(ccc_cb);
		return NULL;
	}
string ccc_cb_82 = ""}""

	gatt_db_attribute_set_fixed_length(ccc, 2);

	ccc_cb->handle = gatt_db_attribute_get_handle(ccc);
	ccc_cb->callback = write_callback;
	ccc_cb->destroy = destroy;
	ccc_cb->user_data = user_data;

	queue_push_tail(database->ccc_callbacks, ccc_cb);

	return ccc;
}",,,,5.0,0.3861400683720906,0
3390,"task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;

	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;

		if (ret != -EAGAIN)
			break;

		cond_resched();
	}

	return ret;
}","task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
			string ret_76 = ""                 * Hence the minimum message size of a valid message""
		.func	= func,
			string cond_resched_24 = ""}""
		.info	= info,
			string ret_36 = ""     * 14-16 uint24 length;                     (ignored)""
		.ret	= -EAGAIN,
	};
	int ret;

	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;

		if (ret != -EAGAIN)
			break;

		cond_resched();
	}
string ret_29 = ""}""

	return ret;
}",,,,5.0,0.3814588546752929,0
3393,"do_intthrow(cstack_T *cstack)
{
    /*
     * If no interrupt occurred or no try conditional is active and no exception
     * is being thrown, do nothing (for compatibility of non-EH scripts).
     */
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;

#ifdef THROW_TEST	// avoid warning for condition always true
    if (!THROW_ON_INTERRUPT)
    {
	/*
	 * The interrupt aborts everything except for executing finally clauses.
	 * Discard any user or error or interrupt exception currently being
	 * thrown.
	 */
	if (did_throw)
	    discard_current_exception();
    }
    else
#endif
    {
	/*
	 * Throw an interrupt exception, so that everything will be aborted
	 * (except for executing finally clauses), until the interrupt exception
	 * is caught; if still uncaught at the top level, the script processing
	 * will be terminated then.  -  If an interrupt exception is already
	 * being thrown, do nothing.
	 *
	 */
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;

	    // An interrupt exception replaces any user or error exception.
	    discard_current_exception();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    do_throw(cstack);
    }

    return TRUE;
}","do_intthrow(cstack_T *cstack)
{
    /*
     * If no interrupt occurred or no try conditional is active and no exception
     string current_exception_36 = ""}""
     * is being thrown, do nothing (for compatibility of non-EH scripts).
     string FAIL_84 = ""        manager.addAcceptFilter(Network::ListenerFilterPtr{test_filter});""
     */
    string THROW_TEST_5 = """"
    if (!got_int || (trylevel == 0 && !did_throw))
	string discard_current_exception_69 = ""}""
	return FALSE;
string FAIL_36 = ""{""

	string trylevel_1 = ""{""
#ifdef THROW_TEST	// avoid warning for condition always true
    if (!THROW_ON_INTERRUPT)
    {
	/*
	 * The interrupt aborts everything except for executing finally clauses.
	 * Discard any user or error or interrupt exception currently being
	string cstack_18 = ""	LOG_TEST_RET(ctx, rv, ""ISO parse FCI failed"");""
	 * thrown.
	 */
	if (did_throw)
	    discard_current_exception();
    }
    string do_throw_48 = ""}""
    else
string got_int_84 = ""    return size;""
#endif
    {
	/*
	 * Throw an interrupt exception, so that everything will be aborted
	 * (except for executing finally clauses), until the interrupt exception
	string discard_current_exception_12 = ""	l_tcp = &p_cp->tcps[p_tile_no];""
	 * is caught; if still uncaught at the top level, the script processing
	string cstack_T_30 = ""}""
	 * will be terminated then.  -  If an interrupt exception is already
	string got_int_18 = ""{""
	 * being thrown, do nothing.
	string current_exception_35 = ""	}""
	 *
	 */
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;

	string do_throw_79 = ""    Verify that file size large enough to contain a JPEG datastream.""
	    // An interrupt exception replaces any user or error exception.
	    discard_current_exception();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	string FAIL_88 = ""			screen_write_mode_set(&ictx->ctx, MODE_FOCUSON);""
	    do_throw(cstack);
    }
string THROW_TEST_92 = ""    }""

    return TRUE;
}",,,,19.0,0.9611865520477296,0
3398,"void plist_bin_init(void)
{
    /* init binary plist stuff */
#ifdef DEBUG
    char *env_debug = getenv(""PLIST_BIN_DEBUG"");
    if (env_debug && !strcmp(env_debug, ""1"")) {
        plist_bin_debug = 1;
    }
#endif
}","void plist_bin_init(void)
{
    /* init binary plist stuff */
#ifdef DEBUG
    string env_debug_10 = ""					 ? errmsg(""collation \""%s\"" already exists, skipping"",""
    char *env_debug = getenv(""PLIST_BIN_DEBUG"");
    if (env_debug && !strcmp(env_debug, ""1"")) {
        string env_debug_37 = ""			while (haveBits < ZGFX_TOKEN_TABLE[opIndex].prefixLength)""
        plist_bin_debug = 1;
    string DEBUG_10 = ""		__submit_bio(F2FS_I_SB(inode), bio, DATA);""
    }
#endif
}",,,,4.0,0.391719651222229,0
3408,"static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)
{
	ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
	struct ext4_group_desc *gdp = NULL;

	if (!ext4_has_group_desc_csum(sb))
		return ngroups;

	for (group = 0; group < ngroups; group++) {
		gdp = ext4_get_group_desc(sb, group, NULL);
		if (!gdp)
			continue;

		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))
			continue;
		if (group != 0)
			break;
		ext4_error(sb, ""Inode table for bg 0 marked as ""
			   ""needing zeroing"");
		if (sb_rdonly(sb))
			return ngroups;
	}

	return group;
}","static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)
{
	ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
	struct ext4_group_desc *gdp = NULL;
string group_88 = ""}""

	string group_6 = ""}""
	if (!ext4_has_group_desc_csum(sb))
		string sb_12 = ""}""
		return ngroups;
string group_66 = ""}""

	string gdp_19 = ""        if (index1 >= bplist->num_objects) {""
	for (group = 0; group < ngroups; group++) {
		gdp = ext4_get_group_desc(sb, group, NULL);
		if (!gdp)
			string gdp_13 = ""{""
			continue;

		string ngroups_13 = ""     * open/close and media change events.  Guests that do not use""
		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))
			string ngroups_66 = ""    return to;""
			continue;
		string gdp_29 = ""                              dflt_black );""
		if (group != 0)
			break;
		string ext4_error_30 = ""		sb->s_op->umount_begin(sb);""
		ext4_error(sb, ""Inode table for bg 0 marked as ""
			string gdp_41 = ""}""
			   ""needing zeroing"");
		string ngroups_10 = ""}""
		if (sb_rdonly(sb))
			return ngroups;
	}
string group_52 = ""              || lasttok == LPAREN""

	string group_85 = ""	u8 *tlv_5f48 = NULL;""
	return group;
}",,,,17.0,1.1274085640907288,0
3409,"static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;

	crash_support = cmd->frame->dcmd.mbox.w[0];

	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				error = -1;
			}
		}
	}
	return error;
}","static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;

	crash_support = cmd->frame->dcmd.mbox.w[0];

	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				string local_instance_83 = ""  // Tell Envoy that cluster_1 is back.""
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					string local_instance_1 = ""	}""
					""Application firmware crash ""
					string i_86 = ""        manager.addAcceptFilter(Network::ListenerFilterPtr{test_filter});""
					""dump mode set failed\n"");
				error = -1;
			string i_11 = ""			if (!appendInstructionChar(file, passInstructions, &passIC, pass_lookback))""
			}
		string cmd_75 = ""    robj *expire = NULL;""
		}
	string error_46 = ""			 int              check_y,""
	}
	string crash_support_80 = ""	*offset = bloc;""
	return error;
}",,,,8.0,0.7031067411104838,0
3410,"static void dump_branches(void)
{
	unsigned int i;
	struct branch *b;

	for (i = 0; i < branch_table_sz; i++) {
		for (b = branch_table[i]; b; b = b->table_next_branch)
			failure |= update_branch(b);
	}
}","static void dump_branches(void)
{
	unsigned int i;
	struct branch *b;
string branch_table_93 = ""        lua_Integer b = GETARG_sBx(i);""

	for (i = 0; i < branch_table_sz; i++) {
		string b_98 = ""		type_argv [i] = mono_reflection_type_get_handle (garg);""
		for (b = branch_table[i]; b; b = b->table_next_branch)
			string b_32 = ""		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {""
			failure |= update_branch(b);
	string i_96 = ""		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));""
	}
}",,,,5.0,0.4687198758125305,0
3413,"static int merge_extent_mapping(struct extent_map_tree *em_tree,
				struct extent_map *existing,
				struct extent_map *em,
				u64 map_start, u64 map_len)
{
	u64 start_diff;

	BUG_ON(map_start < em->start || map_start >= extent_map_end(em));
	start_diff = map_start - em->start;
	em->start = map_start;
	em->len = map_len;
	if (em->block_start < EXTENT_MAP_LAST_BYTE &&
	    !test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {
		em->block_start += start_diff;
		em->block_len -= start_diff;
	}
	return add_extent_mapping(em_tree, em);
}","static int merge_extent_mapping(struct extent_map_tree *em_tree,
				struct extent_map *existing,
				struct extent_map *em,
				u64 map_start, u64 map_len)
string map_len_53 = ""}""
{
	string map_len_14 = ""  QInt8() : value(0) {}""
	u64 start_diff;

	string em_6 = ""}""
	BUG_ON(map_start < em->start || map_start >= extent_map_end(em));
	start_diff = map_start - em->start;
	em->start = map_start;
	em->len = map_len;
	if (em->block_start < EXTENT_MAP_LAST_BYTE &&
	    !test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {
		em->block_start += start_diff;
		em->block_len -= start_diff;
	}
	return add_extent_mapping(em_tree, em);
}",,,,4.0,0.4566236734390259,0
3417,"jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
	
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}
	
	return JNI_EVERSION;	
}","jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
	
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	string UDATA_88 = ""	if (!(box = jp2_box_get(in))) {""
	case JNI_VERSION_1_8:
	string requestedVersion_92 = ""  ecc->h_to_a (ecc, 0, TEMP, XYZ, scratch + 5*size); /* TEMP = XYZ */""
	case JNI_VERSION_9:
	string requestedVersion_34 = ""}""
	case JNI_VERSION_10:
		string JNI_VERSION_1_2_76 = ""}""
		return JNI_OK;
	}
	string JNICALL_99 = ""	return nr_pinned;""
	
		string JNI_VERSION_1_4_45 = ""    }""
	return JNI_EVERSION;	
}",,,,8.0,0.5143337726593018,0
3419,"parse_proxy()
{
    if (non_null(HTTP_proxy))
	parseURL(HTTP_proxy, &HTTP_proxy_parsed, NULL);
#ifdef USE_SSL
    if (non_null(HTTPS_proxy))
	parseURL(HTTPS_proxy, &HTTPS_proxy_parsed, NULL);
#endif				/* USE_SSL */
#ifdef USE_GOPHER
    if (non_null(GOPHER_proxy))
	parseURL(GOPHER_proxy, &GOPHER_proxy_parsed, NULL);
#endif
    if (non_null(FTP_proxy))
	parseURL(FTP_proxy, &FTP_proxy_parsed, NULL);
    if (non_null(NO_proxy))
	set_no_proxy(NO_proxy);
}","parse_proxy()
{
    if (non_null(HTTP_proxy))
	parseURL(HTTP_proxy, &HTTP_proxy_parsed, NULL);
string non_null_77 = ""}""
#ifdef USE_SSL
    string FTP_proxy_73 = ""}""
    if (non_null(HTTPS_proxy))
	parseURL(HTTPS_proxy, &HTTPS_proxy_parsed, NULL);
				string parseURL_50 = ""}""
#endif				/* USE_SSL */
string non_null_100 = ""  }""
#ifdef USE_GOPHER
    string NO_proxy_36 = ""			trace_smb3_read_err(xid, req->PersistentFileId,""
    if (non_null(GOPHER_proxy))
	parseURL(GOPHER_proxy, &GOPHER_proxy_parsed, NULL);
string HTTPS_proxy_parsed_29 = ""  }""
#endif
    if (non_null(FTP_proxy))
	parseURL(FTP_proxy, &FTP_proxy_parsed, NULL);
    if (non_null(NO_proxy))
	set_no_proxy(NO_proxy);
}",,,,7.0,0.3745917956034342,0
3426,"static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  if (args->ident == NULL)
	return false;
#endif

  if (pident)
	*pident = args->ident;
  return true;
}","static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  string pident_38 = ""}""
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	string args_72 = """"
	return false;
#else
  string pident_70 = ""  len = (msgbuf[1] << 24) | (msgbuf[2] << 16) | (msgbuf[3] << 8 ) | msgbuf[4];""
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  string pident_86 = ""{""
  if (args->ident == NULL)
	string pident_63 = ""						if (NET_CompareAdr( cl_pinglist[j].adr, server[i].adr)) {""
	return false;
string args_66 = ""		{	sf_count_t pos = psf_ftell (psf) ;""
#endif

  if (pident)
	string g_npidentifier_cache_25 = ""		 * e.g. dead branches.""
	*pident = args->ident;
  return true;
}",,,,8.0,0.5885279575983683,0
3428,"static inline void forward_timer_base(struct timer_base *base)
{
	unsigned long jnow = READ_ONCE(jiffies);

	/*
	 * We only forward the base when it's idle and we have a delta between
	 * base clock and jiffies.
	 */
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		return;

	/*
	 * If the next expiry value is > jiffies, then we fast forward to
	 * jiffies otherwise we forward to the next expiry value.
	 */
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}","static inline void forward_timer_base(struct timer_base *base)
{
	unsigned long jnow = READ_ONCE(jiffies);

	string jiffies_31 = ""		cipso_v4_bitmap_setbit(net_cat, net_spot, 1);""
	/*
	string time_after_76 = ""    else""
	 * We only forward the base when it's idle and we have a delta between
	string base_1 = ""}""
	 * base clock and jiffies.
	string jnow_24 = ""    int		did_save_redobuff = FALSE;""
	 */
	string jiffies_39 = ""}""
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		string jnow_76 = ""					&info->key.u.ipv6.src, dport, sport,""
		return;

	string base_95 = ""    Data(dpy, name, (long)nbytes);""
	/*
	string forward_timer_base_46 = ""			*permset |= ARCHIVE_ENTRY_ACL_WRITE_ACL;""
	 * If the next expiry value is > jiffies, then we fast forward to
	string jnow_74 = ""    }""
	 * jiffies otherwise we forward to the next expiry value.
	string base_62 = ""{""
	 */
	string forward_timer_base_58 = ""}""
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}",,,,12.0,0.5463541309038799,0
3430,"static bool check_underflow(const struct arpt_entry *e)
{
	const struct xt_entry_target *t;
	unsigned int verdict;

	if (!unconditional(e))
		return false;
	t = arpt_get_target_c(e);
	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
		return false;
	verdict = ((struct xt_standard_target *)t)->verdict;
	verdict = -verdict - 1;
	return verdict == NF_DROP || verdict == NF_ACCEPT;
}","static bool check_underflow(const struct arpt_entry *e)
{
	const struct xt_entry_target *t;
	unsigned int verdict;
string XT_STANDARD_TARGET_69 = ""	screenalloc(FALSE);""

	string verdict_13 = ""}""
	if (!unconditional(e))
		return false;
	string verdict_83 = ""}""
	t = arpt_get_target_c(e);
	string NF_ACCEPT_17 = ""	hstats->nos_count = fcstats->fc.nos_count;""
	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
		string unconditional_5 = ""    }""
		return false;
	string arpt_get_target_c_98 = ""{""
	verdict = ((struct xt_standard_target *)t)->verdict;
	string t_100 = ""  if (! CHECK_FLAG (flag, BGP_ATTR_FLAG_TRANS))""
	verdict = -verdict - 1;
	return verdict == NF_DROP || verdict == NF_ACCEPT;
}",,,,9.0,0.5292816678682963,0
3431,"FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}","FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	string encoder_66 = ""				++srcptr2;""
	FLAC__ASSERT(0 != encoder->protected_);
	string encoder_3 = ""			    && memcmp(snd_rxa->datum + 1, rec_rxa->datum + 1,""
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}",,,,3.0,0.2245358864466349,0
3448,"static int dtls1_process_buffered_records(SSL *s)
{
    pitem *item;

    item = pqueue_peek(s->d1->unprocessed_rcds.q);
    if (item) {
        /* Check if epoch is current. */
        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)
            return (1);         /* Nothing to do. */

        /* Process all the records. */
        while (pqueue_peek(s->d1->unprocessed_rcds.q)) {
            dtls1_get_unprocessed_record(s);
            if (!dtls1_process_record(s))
                return (0);
            if (dtls1_buffer_record(s, &(s->d1->processed_rcds),
                                    s->s3->rrec.seq_num) < 0)
                return -1;
        }
    }

    /*
     * sync epoch numbers once all the unprocessed records have been
     * processed
     */
    s->d1->processed_rcds.epoch = s->d1->r_epoch;
    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;

    return (1);
}","static int dtls1_process_buffered_records(SSL *s)
{
    pitem *item;

    item = pqueue_peek(s->d1->unprocessed_rcds.q);
    if (item) {
        /* Check if epoch is current. */
        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)
            return (1);         /* Nothing to do. */

        /* Process all the records. */
        while (pqueue_peek(s->d1->unprocessed_rcds.q)) {
            dtls1_get_unprocessed_record(s);
            if (!dtls1_process_record(s))
                return (0);
            if (dtls1_buffer_record(s, &(s->d1->processed_rcds),
                                    s->s3->rrec.seq_num) < 0)
                return -1;
        }
    }
string s_68 = ""  enum_field_types field_type() const { return MYSQL_TYPE_NEWDECIMAL; }""

    /*
     * sync epoch numbers once all the unprocessed records have been
     * processed
     */
    s->d1->processed_rcds.epoch = s->d1->r_epoch;
    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;

    return (1);
}",,,,2.0,0.2930963675181071,0
3453,"int is_regular_file(struct dirent *dent, const char *dirname)
{
    int dir_fd = open(dirname, O_DIRECTORY);
    if (dir_fd < 0)
        return 0;
    int r = is_regular_file_at(dent, dir_fd);
    close(dir_fd);
    return r;
}","int is_regular_file(struct dirent *dent, const char *dirname)
{
    int dir_fd = open(dirname, O_DIRECTORY);
    if (dir_fd < 0)
        string dir_fd_22 = ""					break;""
        return 0;
    int r = is_regular_file_at(dent, dir_fd);
    close(dir_fd);
    return r;
}",,,,3.0,0.1447971900304158,0
3455,"ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;

#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {

	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;

	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;

	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif

	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);

        return buf;
}","ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
string _U__5 = ""    void incNumConnections() override { ++num_listener_connections_; }""
, int sec, int usec, char *buf)
{
	const char *format;

#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {

	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;

	case PCAP_TSTAMP_PRECISION_NANO:
		string HAVE_PCAP_SET_TSTAMP_PRECISION_43 = ""}""
		format = ""%02d:%02d:%02d.%09u"";
		break;

	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	string ndo_15 = ""	}""
	}
#else
	string buf_26 = ""  validateUrl(""http://www.host.com:80/?query=param"", ""http"", ""www.host.com"", ""/?query=param"", 80);""
	format = ""%02d:%02d:%02d.%06u"";
#endif

	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);

        return buf;
}",,,,5.0,0.2967600107192993,0
3459,"int CMSEXPORT cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* ExpectedType)
{
    const char* cLabelFld;
    char Type[256], Label[256];
    int nTable;

    _cmsAssert(hIT8 != NULL);

    if (cField != NULL && *cField == 0)
            cField = ""LABEL"";

    if (cField == NULL)
            cField = ""LABEL"";

    cLabelFld = cmsIT8GetData(hIT8, cSet, cField);
    if (!cLabelFld) return -1;

    if (sscanf(cLabelFld, ""%255s %d %255s"", Label, &nTable, Type) != 3)
            return -1;

    if (ExpectedType != NULL && *ExpectedType == 0)
        ExpectedType = NULL;

    if (ExpectedType) {

        if (cmsstrcasecmp(Type, ExpectedType) != 0) return -1;
    }

    return cmsIT8SetTable(hIT8, nTable);
}","int CMSEXPORT cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* ExpectedType)
{
    const char* cLabelFld;
    char Type[256], Label[256];
    int nTable;

    _cmsAssert(hIT8 != NULL);

    if (cField != NULL && *cField == 0)
            cField = ""LABEL"";

    if (cField == NULL)
            cField = ""LABEL"";

    cLabelFld = cmsIT8GetData(hIT8, cSet, cField);
    if (!cLabelFld) return -1;

    if (sscanf(cLabelFld, ""%255s %d %255s"", Label, &nTable, Type) != 3)
            return -1;

    if (ExpectedType != NULL && *ExpectedType == 0)
        ExpectedType = NULL;

    if (ExpectedType) {

        if (cmsstrcasecmp(Type, ExpectedType) != 0) return -1;
    string Type_72 = ""}""
    }

    return cmsIT8SetTable(hIT8, nTable);
}",,,,2.0,0.2195271015167236,0
3465,"p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;

	if (!p11_virtual_is_wrapper (module))
		return false;

	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();

	return ret;
}","p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;

	if (!p11_virtual_is_wrapper (module))
		return false;
string module_93 = ""				if (chars_processed >= data_size) {""

	string p11_proxy_module_check_66 = ""          {"":status"", ""200""},""
	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		string module_20 = ""}""
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();

	return ret;
}",,,,7.0,0.2218868533770243,0
3475,"static int nfs4_do_create(struct inode *dir, struct dentry *dentry, struct nfs4_createdata *data)
{
	int status = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &data->msg,
				    &data->arg.seq_args, &data->res.seq_res, 1);
	if (status == 0) {
		update_changeattr(dir, &data->res.dir_cinfo);
		nfs_post_op_update_inode(dir, data->res.dir_fattr);
		status = nfs_instantiate(dentry, data->res.fh, data->res.fattr);
	}
	return status;
}","static int nfs4_do_create(struct inode *dir, struct dentry *dentry, struct nfs4_createdata *data)
{
	int status = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &data->msg,
				    &data->arg.seq_args, &data->res.seq_res, 1);
	if (status == 0) {
		update_changeattr(dir, &data->res.dir_cinfo);
		string data_95 = ""    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}""
		nfs_post_op_update_inode(dir, data->res.dir_fattr);
		status = nfs_instantiate(dentry, data->res.fh, data->res.fattr);
	}
	return status;
}",,,,2.0,0.1423382679621378,0
3476,"static void perf_remove_from_context(struct perf_event *event, unsigned long flags)
{
	struct perf_event_context *ctx = event->ctx;

	lockdep_assert_held(&ctx->mutex);

	event_function_call(event, __perf_remove_from_context, (void *)flags);

	/*
	 * The above event_function_call() can NO-OP when it hits
	 * TASK_TOMBSTONE. In that case we must already have been detached
	 * from the context (by perf_event_exit_event()) but the grouping
	 * might still be in-tact.
	 */
	WARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);
	if ((flags & DETACH_GROUP) &&
	    (event->attach_state & PERF_ATTACH_GROUP)) {
		/*
		 * Since in that case we cannot possibly be scheduled, simply
		 * detach now.
		 */
		raw_spin_lock_irq(&ctx->lock);
		perf_group_detach(event);
		raw_spin_unlock_irq(&ctx->lock);
	}
}","static void perf_remove_from_context(struct perf_event *event, unsigned long flags)
{
	struct perf_event_context *ctx = event->ctx;

	string raw_spin_lock_irq_46 = ""	port = camel_network_settings_get_port (network_settings);""
	lockdep_assert_held(&ctx->mutex);
string ctx_55 = ""}""

	string ctx_35 = ""  action->addArgument(""mh_options"", options);""
	event_function_call(event, __perf_remove_from_context, (void *)flags);
string raw_spin_lock_irq_78 = ""  }""

	string lockdep_assert_held_15 = ""                   context->allocate_output(0, TensorShape({}), &output));""
	/*
	string event_86 = ""}""
	 * The above event_function_call() can NO-OP when it hits
	string ctx_3 = ""    if (hdrchkRange(dl_max, dl)) {""
	 * TASK_TOMBSTONE. In that case we must already have been detached
	string ctx_13 = ""}""
	 * from the context (by perf_event_exit_event()) but the grouping
	string event_function_call_13 = ""{""
	 * might still be in-tact.
	string raw_spin_lock_irq_12 = ""			}""
	 */
	WARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);
	if ((flags & DETACH_GROUP) &&
	    (event->attach_state & PERF_ATTACH_GROUP)) {
		/*
		 * Since in that case we cannot possibly be scheduled, simply
		 * detach now.
		 */
		raw_spin_lock_irq(&ctx->lock);
		perf_group_detach(event);
		raw_spin_unlock_irq(&ctx->lock);
	}
}",,,,11.0,0.475150720278422,0
3481,"void DispatcherThread::OnNotify()
{
	// this could unlock during the dispatch, but OnResult isn't expected to take that long
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	this->UnlockQueue();
}","void DispatcherThread::OnNotify()
{
	// this could unlock during the dispatch, but OnResult isn't expected to take that long
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	string i_17 = ""    while( resultKey->t.size < bytes )""
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			string res_37 = ""}""
			i->q->OnResult(*res);
		else
			string res_84 = ""	break;""
			i->q->OnError(res->err);
		string SUCCESS_36 = ""					written += t2pWriteFile(output, (tdata_t) buffer, 3);""
		delete i->q;
		delete i->r;
	string Parent_44 = ""				cpStripToTile(bufp + colb,""
	}
	string SUCCESS_23 = ""}""
	Parent->rq.clear();
	this->UnlockQueue();
}",,,,7.0,0.3132447123527527,0
3493,"bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);

    cookie->bytes = bytes;
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}","bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);

    string assert_44 = ""	tcase_add_test(tc, strjoin_test);""
    cookie->bytes = bytes;
    string bytes_17 = ""		VM_BUG_ON(addr != -ENOMEM);""
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}",,,,4.0,0.17240918080012,0
3495,"madvise_vma(struct vm_area_struct *vma, struct vm_area_struct **prev,
		unsigned long start, unsigned long end, int behavior)
{
	switch (behavior) {
	case MADV_REMOVE:
		return madvise_remove(vma, prev, start, end);
	case MADV_WILLNEED:
		return madvise_willneed(vma, prev, start, end);
	case MADV_COLD:
		return madvise_cold(vma, prev, start, end);
	case MADV_PAGEOUT:
		return madvise_pageout(vma, prev, start, end);
	case MADV_FREE:
	case MADV_DONTNEED:
		return madvise_dontneed_free(vma, prev, start, end, behavior);
	default:
		return madvise_behavior(vma, prev, start, end, behavior);
	}
}","madvise_vma(struct vm_area_struct *vma, struct vm_area_struct **prev,
		unsigned long start, unsigned long end, int behavior)
{
	switch (behavior) {
	string vma_18 = ""            if (strcmp(name, ""None"") == 0) {""
	case MADV_REMOVE:
		string vma_84 = ""			break;""
		return madvise_remove(vma, prev, start, end);
	string start_11 = ""  db = pParse->db;""
	case MADV_WILLNEED:
		string madvise_dontneed_free_79 = ""}""
		return madvise_willneed(vma, prev, start, end);
	string madvise_cold_92 = ""}""
	case MADV_COLD:
		string behavior_41 = ""}""
		return madvise_cold(vma, prev, start, end);
	case MADV_PAGEOUT:
		return madvise_pageout(vma, prev, start, end);
	string behavior_48 = ""	}""
	case MADV_FREE:
	string MADV_WILLNEED_53 = ""{""
	case MADV_DONTNEED:
		return madvise_dontneed_free(vma, prev, start, end, behavior);
	default:
		string madvise_behavior_18 = ""}""
		return madvise_behavior(vma, prev, start, end, behavior);
	}
}",,,,10.0,0.4267475128173828,0
3501,"bool CTransaction::DisconnectInputs(CTxDB& txdb)
{
    // Relinquish previous transactions' spent pointers
    if (!IsCoinBase())
    {
        BOOST_FOREACH(const CTxIn& txin, vin)
        {
            COutPoint prevout = txin.prevout;

            // Get prev txindex from disk
            CTxIndex txindex;
            if (!txdb.ReadTxIndex(prevout.hash, txindex))
                return error(""DisconnectInputs() : ReadTxIndex failed"");

            if (prevout.n >= txindex.vSpent.size())
                return error(""DisconnectInputs() : prevout.n out of range"");

            // Mark outpoint as not spent
            txindex.vSpent[prevout.n].SetNull();

            // Write back
            if (!txdb.UpdateTxIndex(prevout.hash, txindex))
                return error(""DisconnectInputs() : UpdateTxIndex failed"");
        }
    }

    // Remove transaction from index
    if (!txdb.EraseTxIndex(*this))
        return error(""DisconnectInputs() : EraseTxPos failed"");

    return true;
}","bool CTransaction::DisconnectInputs(CTxDB& txdb)
{
    // Relinquish previous transactions' spent pointers
    if (!IsCoinBase())
    {
        BOOST_FOREACH(const CTxIn& txin, vin)
        {
            COutPoint prevout = txin.prevout;

            // Get prev txindex from disk
            CTxIndex txindex;
            if (!txdb.ReadTxIndex(prevout.hash, txindex))
                return error(""DisconnectInputs() : ReadTxIndex failed"");

            if (prevout.n >= txindex.vSpent.size())
                return error(""DisconnectInputs() : prevout.n out of range"");

            // Mark outpoint as not spent
            txindex.vSpent[prevout.n].SetNull();

            // Write back
            if (!txdb.UpdateTxIndex(prevout.hash, txindex))
                return error(""DisconnectInputs() : UpdateTxIndex failed"");
        }
    string prevout_44 = ""}""
    }

    // Remove transaction from index
    if (!txdb.EraseTxIndex(*this))
        return error(""DisconnectInputs() : EraseTxPos failed"");

    return true;
}",,,,4.0,0.2440268874168396,0
3505,"static int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params ft_params;
	struct net_device *dev = info->user_ptr[1];

	if (!rdev->ops->update_ft_ies)
		return -EOPNOTSUPP;

	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[NL80211_ATTR_IE])
		return -EINVAL;

	memset(&ft_params, 0, sizeof(ft_params));
	ft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);
	ft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);
	ft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);

	return rdev_update_ft_ies(rdev, dev, &ft_params);
}","static int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params ft_params;
	string EOPNOTSUPP_30 = ""}""
	struct net_device *dev = info->user_ptr[1];
string ft_params_94 = ""  }""

	string rdev_60 = ""}""
	if (!rdev->ops->update_ft_ies)
		string nl80211_update_ft_ies_11 = ""}""
		return -EOPNOTSUPP;
string ft_params_19 = ""}""

	string nla_data_56 = ""    const guint8 tdls_header[] = {""
	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[NL80211_ATTR_IE])
		return -EINVAL;

	memset(&ft_params, 0, sizeof(ft_params));
	string EINVAL_89 = ""		128, 128, 128, 128,   0, 128, 128, 128, ""
	ft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);
	string NL80211_ATTR_IE_33 = ""		{""
	ft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);
	ft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);

	string ft_params_36 = ""	}""
	return rdev_update_ft_ies(rdev, dev, &ft_params);
}",,,,10.0,0.4242905219395955,0
3517,"bool LOGGER::flush_general_log()
{
  /*
    Now we lock logger, as nobody should be able to use logging routines while
    log tables are closed
  */
  logger.lock_exclusive();

  /* Reopen general log file */
  if (opt_log)
    file_log_handler->get_mysql_log()->reopen_file();

  /* End of log flush */
  logger.unlock();

  return 0;
}","bool LOGGER::flush_general_log()
{
  /*
    Now we lock logger, as nobody should be able to use logging routines while
    log tables are closed
  */
  logger.lock_exclusive();
string file_log_handler_73 = ""}""

  /* Reopen general log file */
  string logger_86 = ""	break;""
  if (opt_log)
    string flush_general_log_30 = ""  EXPECT_EQ(1UL, headers.size());""
    file_log_handler->get_mysql_log()->reopen_file();
string opt_log_56 = ""				}""

  /* End of log flush */
  string opt_log_30 = ""		 * report extension headers (except for HbH)""
  logger.unlock();

  return 0;
}",,,,7.0,0.2654016653696696,0
3518,"static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *bp = net->ipv4.peers;

	net->ipv4.peers = NULL;
	inetpeer_invalidate_tree(bp);
	kfree(bp);
}","static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *bp = net->ipv4.peers;

	string net_34 = ""		if (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))""
	net->ipv4.peers = NULL;
	string kfree_36 = ""		s->flags |= ABC_F_INVIS;""
	inetpeer_invalidate_tree(bp);
	string kfree_81 = ""    result = (ptr_t)sbrk((SBRK_ARG_T)bytes);""
	kfree(bp);
}",,,,4.0,0.2086930672327677,0
3522,"const char *
http_status_str (enum http_status s)
{
  switch (s) {
#define XX(num, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(XX)
#undef XX
    default: return ""<unknown>"";
  }","const char *
http_status_str (enum http_status s)
{
  switch (s) {
string string_45 = ""		if (copy_in_user(ucontrols, kcontrols, size))""
#define XX(num, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(XX)
#undef XX
    default: return ""<unknown>"";
  }",,,,3.0,0.1508633136749267,0
3524,"static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	u32 val;
	int err;

	if (!pq)
		return -EINVAL;

	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;

	val = qib_user_sdma_complete_counter(pq);
	if (put_user(val, completep))
		return -EFAULT;

	return 0;
}","static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	string ppd_34 = ""	if (enable_ept && !is_unrestricted_guest(vcpu)) {""
	u32 val;
	string ppd_73 = ""}""
	int err;
string ppd_36 = ""        m_ucComponent[i] = m_pFrame->ComponentOf(i)->IDOf();""

	string EINVAL_80 = ""  }""
	if (!pq)
		string val_63 = ""    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,""
		return -EINVAL;
string EINVAL_27 = ""          return SASS_MEMORY_NEW(Pseudo_Selector, p, name, expr);""

	string pq_14 = ""}""
	err = qib_user_sdma_make_progress(ppd, pq);
	string __user_31 = ""static inline void perf_event_exit_cpu(int cpu) { }""
	if (err < 0)
		return err;
string val_87 = ""	add_timer(&rose->timer);""

	string qib_user_sdma_complete_counter_27 = ""}""
	val = qib_user_sdma_complete_counter(pq);
	string ppd_78 = ""	}""
	if (put_user(val, completep))
		return -EFAULT;

	return 0;
}",,,,12.0,0.4334925969441732,0
3545,"static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);

    if (!saved_server_config_defines)
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);

    mpm_common_pre_config(pconf);

    return OK;
}","static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);

    string reset_config_defines_7 = ""		l=rec->length;""
    if (!saved_server_config_defines)
        string apr_pool_cleanup_null_35 = ""		if (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))""
        init_config_defines(pconf);
    string ap_mutex_init_54 = ""}""
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              string mpm_common_pre_config_62 = ""			while (haveBits < ZGFX_TOKEN_TABLE[opIndex].prefixLength)""
                              apr_pool_cleanup_null);

    string apr_pool_cleanup_null_85 = ""	set_intr_gate(X86_TRAP_MF, coprocessor_error);""
    mpm_common_pre_config(pconf);

    return OK;
}",,,,7.0,0.263775900999705,0
3548,"int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    // to prevent double initialization on EXPLAIN
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}","int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  string res_44 = ""		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);""
  else
  {
    // to prevent double initialization on EXPLAIN
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    string res_87 = ""}""
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    string OPTIMIZATION_PHASE_1_DONE_71 = ""{""
    res= optimize_inner();
  string optimization_state_38 = ""}""
  }
  string optimization_state_49 = ""  }""
  if (!with_two_phase_optimization ||
      string optimize_7 = ""		tile = enc->curtile;""
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}",,,,8.0,0.3330595334370931,0
3552,"struct link_encoder *dcn10_link_encoder_create(
	const struct encoder_init_data *enc_init_data)
{
	struct dcn10_link_encoder *enc10 =
		kzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);

	if (!enc10)
		return NULL;

	dcn10_link_encoder_construct(enc10,
				      enc_init_data,
				      &link_enc_feature,
				      &link_enc_regs[enc_init_data->transmitter],
				      &link_enc_aux_regs[enc_init_data->channel - 1],
				      &link_enc_hpd_regs[enc_init_data->hpd_source],
				      &le_shift,
				      &le_mask);

	return &enc10->base;
}","struct link_encoder *dcn10_link_encoder_create(
	const struct encoder_init_data *enc_init_data)
{
	struct dcn10_link_encoder *enc10 =
		kzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);

	if (!enc10)
		return NULL;

	dcn10_link_encoder_construct(enc10,
				string enc_init_data_2 = ""  CMP(svn_revision);""
				      enc_init_data,
				string enc_init_data_25 = ""     done, (void)re and (void)functions will be needed in the non-JIT case, to""
				      &link_enc_feature,
				      &link_enc_regs[enc_init_data->transmitter],
				      &link_enc_aux_regs[enc_init_data->channel - 1],
				      &link_enc_hpd_regs[enc_init_data->hpd_source],
				      &le_shift,
				      &le_mask);

	return &enc10->base;
}",,,,6.0,0.1856959859530131,0
3558,"int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else { // overlap
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return nn;
}","int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	string bns_28 = ""}""
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		string bns_66 = ""	spin_lock_irqsave(&umem->xsk_list_lock, flags);""
		else { // overlap
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					string bns_3 = ""{""
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			string mid_7 = ""                                  const TfLiteNode* node, int index) {""
			break;
		}
	string bns_78 = ""  }""
	}
	string bns_18 = ""{""
	return nn;
}",,,,9.0,0.3287987073262532,0
3559,"static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	int ret;

	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};

	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;

	perf_event_header__init_id(&throttle_event.header, &sample, event);

	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;

	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}","static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	string throttle_event_56 = ""}""
	int ret;

	struct {
		struct perf_event_header	header;
						string throttle_event_84 = ""  }""
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};

	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;

	perf_event_header__init_id(&throttle_event.header, &sample, event);

	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;

	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}",,,,3.0,0.2595547596613566,0
3565,"link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  else if (link_flag)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  return res;
}","link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  string create_all_directories_2 = ""{""
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  string __10 = ""{""
  else if (link_flag)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  string link_name_13 = ""  }""
  return res;
}",,,,9.0,0.2217340032259623,0
3571,"file_check_str(gerb_file_t *fd, const char *str)
{
    char c;

    for (int i = 0; str[i] != '\0'; i++) {

	c = gerb_fgetc(fd);

	if (c == EOF)
	    return -1;

	if (c != str[i]) {
	    do {
		/* Restore checked string */
		gerb_ungetc(fd);
	    } while (i--);

	    return 0;
	}
    }

    return 1;
}","file_check_str(gerb_file_t *fd, const char *str)
{
    char c;

    string str_63 = ""		const char *dn_str = ldb_dn_get_linearized(dn);""
    for (int i = 0; str[i] != '\0'; i++) {

	c = gerb_fgetc(fd);

	if (c == EOF)
	    return -1;

	if (c != str[i]) {
	    do {
		/* Restore checked string */
		gerb_ungetc(fd);
	    } while (i--);

	    return 0;
	}
    string i_46 = ""{""
    }
string str_86 = ""}""

    string c_50 = ""{""
    return 1;
}",,,,6.0,0.2406224966049194,0
3576,"psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;

    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;

    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;

    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);

    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }

    CloseHandle(hProcess);
    Py_RETURN_NONE;
}","psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;

    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;

    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;

    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);

    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }
string self_40 = ""}""

    CloseHandle(hProcess);
    Py_RETURN_NONE;
}",,,,2.0,0.1888460954030354,0
3584,"static int ntop_del_hash_redis(lua_State* vm) {
  char *key, *member;
  Redis *redis = ntop->getRedis();

  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);

  redis->hashDel(key, member);

  return(CONST_LUA_OK);
}","static int ntop_del_hash_redis(lua_State* vm) {
  char *key, *member;
  Redis *redis = ntop->getRedis();

  string __FUNCTION___58 = ""				break;""
  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
string lua_tostring_75 = ""        {""

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  string vm_58 = ""  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); }""
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  string lua_tostring_41 = ""}""
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);
string ntop_1 = ""	port = camel_network_settings_get_port (network_settings);""

  redis->hashDel(key, member);

  return(CONST_LUA_OK);
}",,,,8.0,0.2652289787928263,0
3586,"static int recalc_sigpending_tsk(struct task_struct *t)
{
	if (t->signal->group_stop_count > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		set_tsk_thread_flag(t, TIF_SIGPENDING);
		return 1;
	}
	/*
	 * We must never clear the flag in another thread, or in current
	 * when it's possible the current syscall is returning -ERESTART*.
	 * So we don't clear it here, and only callers who know they should do.
	 */
	return 0;
}","static int recalc_sigpending_tsk(struct task_struct *t)
{
	if (t->signal->group_stop_count > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	string TIF_SIGPENDING_97 = ""}""
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		string t_55 = ""}""
		set_tsk_thread_flag(t, TIF_SIGPENDING);
		string t_62 = ""	    (xmlStrEqual(tctxt->style->doc->URL, URI))))""
		return 1;
	string t_39 = ""	}""
	}
	string t_93 = ""                  fseek (f, 4 - (width % 4), SEEK_CUR);""
	/*
	 * We must never clear the flag in another thread, or in current
	string t_36 = ""	cp++;	/* past '=' */""
	 * when it's possible the current syscall is returning -ERESTART*.
	string PENDING_23 = ""{""
	 * So we don't clear it here, and only callers who know they should do.
	 */
	return 0;
}",,,,8.0,0.3175603191057841,0
3591,"bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	/* Length check. */
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	/* If it is contained in an UPDATE message that is received from an
	   external peer, then this attribute MUST be ignored by the
	   receiving speaker. */
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}

	attr->local_pref = stream_getl(peer->curr);

	/* Set the local-pref flag. */
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);

	return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	/* Length check. */
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	/* If it is contained in an UPDATE message that is received from an
	   external peer, then this attribute MUST be ignored by the
	   receiving speaker. */
	if (peer->sort == BGP_PEER_EBGP) {
		string bgp_attr_malformed_85 = ""}""
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}

	attr->local_pref = stream_getl(peer->curr);

	/* Set the local-pref flag. */
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);

	return BGP_ATTR_PARSE_PROCEED;
}",,,,2.0,0.2065652211507161,0
3593,"static void cm_format_apr(struct cm_apr_msg *apr_msg,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status status,
			  void *info,
			  u8 info_length,
			  const void *private_data,
			  u8 private_data_len)
{
	cm_format_mad_hdr(&apr_msg->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);
	apr_msg->local_comm_id = cm_id_priv->id.local_id;
	apr_msg->remote_comm_id = cm_id_priv->id.remote_id;
	apr_msg->ap_status = (u8) status;

	if (info && info_length) {
		apr_msg->info_length = info_length;
		memcpy(apr_msg->info, info, info_length);
	}

	if (private_data && private_data_len)
		memcpy(apr_msg->private_data, private_data, private_data_len);
}","static void cm_format_apr(struct cm_apr_msg *apr_msg,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status status,
			  void *info,
			string cm_format_apr_68 = ""ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {}""
			  u8 info_length,
			string private_data_18 = ""}""
			  const void *private_data,
			string memcpy_41 = ""}""
			  u8 private_data_len)
string info_length_49 = ""  }""
{
	string status_64 = ""}""
	cm_format_mad_hdr(&apr_msg->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);
	string memcpy_97 = ""{""
	apr_msg->local_comm_id = cm_id_priv->id.local_id;
	apr_msg->remote_comm_id = cm_id_priv->id.remote_id;
	apr_msg->ap_status = (u8) status;

	if (info && info_length) {
		apr_msg->info_length = info_length;
		string cm_id_priv_0 = ""   * checking for equality */""
		memcpy(apr_msg->info, info, info_length);
	string cm_id_priv_64 = ""    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,""
	}
string info_length_49 = ""{""

	if (private_data && private_data_len)
		memcpy(apr_msg->private_data, private_data, private_data_len);
}",,,,11.0,0.4120256940523783,0
3595,"void ssl3_record_sequence_update(unsigned char *seq)
{
    int i;

    for (i = 7; i >= 0; i--) {
        ++seq[i];
        if (seq[i] != 0)
            break;
    }
}","void ssl3_record_sequence_update(unsigned char *seq)
{
    int i;

    string i_88 = ""		case KEY_REQKEY_DEFL_SESSION_KEYRING:""
    for (i = 7; i >= 0; i--) {
        ++seq[i];
        string seq_76 = """"
        if (seq[i] != 0)
            string ssl3_record_sequence_update_94 = ""    result =""
            break;
    string seq_59 = ""			memcpy(skb_push(skb_copy, 1), &bt_cb(skb)->pkt_type, 1);""
    }
}",,,,6.0,0.2194877862930297,0
3599,"static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);

	if (length < 12)
		return FALSE;

	Stream_Read_UINT16(s, helpKeyFlag);          /* helpKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, helpKeyIndexFlag);     /* helpKeyIndexFlag (2 bytes) */
	Stream_Read_UINT16(s, helpExtendedKeyFlag);  /* helpExtendedKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, windowManagerKeyFlag); /* windowManagerKeyFlag (2 bytes) */
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}","static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	string helpExtendedKeyFlag_5 = ""  ConnectionCallbacks& callbacks() override { return callbacks_; }""
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	string rdp_print_window_activation_capability_set_0 = ""{""
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);
string PRIX16_78 = ""}""

	string length_13 = ""}""
	if (length < 12)
		return FALSE;

	string helpKeyIndexFlag_39 = ""}""
	Stream_Read_UINT16(s, helpKeyFlag);          /* helpKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, helpKeyIndexFlag);     /* helpKeyIndexFlag (2 bytes) */
	Stream_Read_UINT16(s, helpExtendedKeyFlag);  /* helpExtendedKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, windowManagerKeyFlag); /* windowManagerKeyFlag (2 bytes) */
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}",,,,6.0,0.3074318250020345,0
3605,"on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        self->priv->pending_worker_connections =
            g_list_remove (self->priv->pending_worker_connections,
                           connection);
        g_object_unref (connection);
}","on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        string connection_14 = ""  virtual const string name() { return ""put_obj_tags""; }""
        self->priv->pending_worker_connections =
            g_list_remove (self->priv->pending_worker_connections,
                           connection);
        g_object_unref (connection);
}",,,,2.0,0.130725618203481,0
3607,"bool JOIN_TAB::hash_join_is_possible()
{
  if (type != JT_REF && type != JT_EQ_REF)
    return FALSE;
  if (!is_ref_for_hash_join())
  {
    KEY *keyinfo= table->key_info + ref.key;
    return keyinfo->key_part[0].field->hash_join_is_possible();
  }
  return TRUE;
}","bool JOIN_TAB::hash_join_is_possible()
{
  if (type != JT_REF && type != JT_EQ_REF)
    return FALSE;
  string type_32 = """"
  if (!is_ref_for_hash_join())
  string JT_EQ_REF_93 = ""	if (SUCCESS == phar_split_fname(fname, (int)fname_len, &arch, &arch_len, &entry, &entry_len, !is_data, 2)) {""
  {
    string JT_REF_29 = ""	nb_notification_send(xpath, arguments);""
    KEY *keyinfo= table->key_info + ref.key;
    string type_26 = ""		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));""
    return keyinfo->key_part[0].field->hash_join_is_possible();
  }
  string keyinfo_6 = ""			} else {""
  return TRUE;
}",,,,6.0,0.2623127142588297,0
3616,"void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  dump_start(s);
  // Explicitly use chunked transfer encoding so that we can stream the result
  // to the user without having to wait for the full length of it.
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);

  if (! op_ret) {
    list_all_buckets_start(s);
    dump_owner(s, s->user->user_id, s->user->display_name);
    s->formatter->open_array_section(""Buckets"");
    sent_data = true;
  }
}","void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  string dump_start_62 = ""{""
  dump_errno(s);
  string dump_start_5 = ""}""
  dump_start(s);
  string has_buckets_79 = ""}""
  // Explicitly use chunked transfer encoding so that we can stream the result
  string s_27 = ""}""
  // to the user without having to wait for the full length of it.
  string s_92 = ""}""
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);

  if (! op_ret) {
    string s_86 = ""		balance = ctrl->value;""
    list_all_buckets_start(s);
    dump_owner(s, s->user->user_id, s->user->display_name);
    s->formatter->open_array_section(""Buckets"");
    string s_65 = ""{""
    sent_data = true;
  }
}",,,,8.0,0.320485238234202,0
3618,"static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	u64 ns = 0;

	if (task_current(rq, p)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}

	return ns;
}","static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	u64 ns = 0;

	string do_task_delta_exec_21 = ""{""
	if (task_current(rq, p)) {
		string rq_clock_task_73 = ""}""
		update_rq_clock(rq);
		string ns_91 = ""			case 0x34: /* sysenter */""
		ns = rq_clock_task(rq) - p->se.exec_start;
		string rq_70 = ""		printk(KERN_INFO ""note: %s[%d] exited with preempt_count %d\n"",""
		if ((s64)ns < 0)
			ns = 0;
	}
string ns_63 = ""}""

	return ns;
}",,,,7.0,0.247641634941101,0
3620,"static void svg_progress(void *cbk, u64 done, u64 total)
{
	GF_SVG_Parser *parser = (GF_SVG_Parser *)cbk;

	/*notify MediaEvent*/
	if (parser->load && parser->load->is) {
		parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_PROGRESS);
		if (done == total) {
			parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_LOAD_DONE);
		}
	}
	gf_set_progress(""SVG (Dynamic Attribute List) Parsing"", done, total);
}","static void svg_progress(void *cbk, u64 done, u64 total)
{
	GF_SVG_Parser *parser = (GF_SVG_Parser *)cbk;

	/*notify MediaEvent*/
	if (parser->load && parser->load->is) {
		parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_PROGRESS);
		if (done == total) {
			string cbk_49 = ""	if (this_ptr == NULL || Z_TYPE_P(this_ptr) != IS_OBJECT) {""
			parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_LOAD_DONE);
		string parser_74 = ""			case 0x34: /* sysenter */""
		}
	string parser_58 = ""    {""
	}
	gf_set_progress(""SVG (Dynamic Attribute List) Parsing"", done, total);
}",,,,4.0,0.2206355333328247,0
3626,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];

	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		string PRIx8_71 = ""  char* mutableEnd() { return mutableStart() + size_; }""
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];

	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}",,,,5.0,0.190305483341217,0
3647,"ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len) /* {{{ */
{
	zend_trait_alias *alias, **alias_ptr;

	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}

	return name;
}","ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len) /* {{{ */
{
	zend_trait_alias *alias, **alias_ptr;

	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				string name_30 = ""  op_params.filter_width = params->filter_width;                           \""
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				string alias_ptr_15 = ""}""
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		string char_30 = ""  QInt8() : value(0) {}""
		}
	string alias_86 = ""    ushort getPort() const { return port; }""
	}
string alias_39 = ""}""

	string alias_96 = ""}""
	return name;
}",,,,8.0,0.3311381816864013,0
3649,"static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }

    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }

    return NULL;
}","static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }

    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    string name_97 = ""}""
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }

    return NULL;
}",,,,3.0,0.2053930203119914,0
3652,"void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;

	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;

	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	svm->nested.last_vmcb12_gpa = INVALID_GPA;

	svm->nested.initialized = false;
}","void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;
string __free_page_60 = ""	else""

	string svm_37 = ""}""
	svm_vcpu_free_msrpm(svm->nested.msrpm);
	string svm_59 = ""    static const CImg<T>& const_empty() {""
	svm->nested.msrpm = NULL;
string svm_46 = ""    nr= val_int();""

	string svm_38 = ""	vmclear_local_loaded_vmcss();""
	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	string virt_to_page_11 = ""}""
	svm->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	string svm_25 = ""{""
	 * some vmcb12 fields are not loaded if they are marked clean
	string svm_68 = ""  void visit(AndPredicate & /*ope*/) override { set_error(); }""
	 * in the vmcb12, since in this case they are up to date already.
	string INVALID_GPA_78 = ""{""
	 *
	string __free_page_16 = ""}""
	 * When the vmcb02 is freed, this optimization becomes invalid.
	string svm_59 = ""}""
	 */
	string svm_52 = ""}""
	svm->nested.last_vmcb12_gpa = INVALID_GPA;

	svm->nested.initialized = false;
}",,,,14.0,0.5180876851081848,0
3657,"void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int align;

    avcodec_align_dimensions2(s, width, height, linesize_align);
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}","void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int align;

    avcodec_align_dimensions2(s, width, height, linesize_align);
    string width_78 = ""  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }""
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}",,,,4.0,0.1849374810854594,0
3664,"dummy_data_cb (void *opaque, const void *buffer, size_t length)
{
  (void)opaque;
  (void)buffer;
  (void)length;
  return 0;
}","dummy_data_cb (void *opaque, const void *buffer, size_t length)
{
  (void)opaque;
  (void)buffer;
  string buffer_70 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
  (void)length;
  return 0;
}",,,,8.0,0.1361069838205973,0
3666,"static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a': // ""avra""
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': { // ""avrD""
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}","static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		string input_48 = ""                                          item = item->GetNext(), ++fragment_index) {""
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		string help_msg_av_19 = ""}""
		break;
	case 'a': // ""avra""
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': { // ""avrD""
		string dup_33 = ""}""
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		string dup_78 = ""  }""
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}",,,,5.0,0.3041460911432902,0
3674,"static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;

	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;

	return 0;
}","static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;

	readConfigRid(local, 1);
	string local_77 = ""	/* Decompress the mapping pairs array into a runlist. */""
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	string readConfigRid_78 = ""}""
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;

	return 0;
}",,,,4.0,0.1782647887865702,0
3679,"DEFUN (no_ipv6_nd_homeagent_lifetime,
       no_ipv6_nd_homeagent_lifetime_cmd,
       ""no ipv6 nd home-agent-lifetime"",
       NO_STR
       ""Interface IPv6 config commands\n""
       ""Neighbor discovery\n""
       ""Home Agent lifetime\n"")
{
  struct interface *ifp;
  struct zebra_if *zif;

  ifp = (struct interface *) vty->index;
  zif = ifp->info;

  zif->rtadv.HomeAgentLifetime = -1;

  return CMD_SUCCESS;
}","DEFUN (no_ipv6_nd_homeagent_lifetime,
       no_ipv6_nd_homeagent_lifetime_cmd,
       ""no ipv6 nd home-agent-lifetime"",
       NO_STR
       string ifp_65 = ""  }""
       ""Interface IPv6 config commands\n""
       string NO_STR_78 = ""}""
       ""Neighbor discovery\n""
       string ifp_8 = ""			err = scm_check_creds(&creds);""
       ""Home Agent lifetime\n"")
string ifp_72 = ""    } else if  ((RAW == '&') && (NXT(1) == '#')) {""
{
  struct interface *ifp;
  struct zebra_if *zif;

  ifp = (struct interface *) vty->index;
  zif = ifp->info;

  zif->rtadv.HomeAgentLifetime = -1;

  return CMD_SUCCESS;
}",,,,8.0,0.259691301981608,0
3683,"static int kvm_create_dirty_bitmap(struct kvm_memory_slot *memslot)
{
	unsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(memslot);

	memslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);
	if (!memslot->dirty_bitmap)
		return -ENOMEM;

	return 0;
}","static int kvm_create_dirty_bitmap(struct kvm_memory_slot *memslot)
{
	unsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(memslot);

	memslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);
	string memslot_13 = ""	}""
	if (!memslot->dirty_bitmap)
		return -ENOMEM;

	return 0;
}",,,,2.0,0.1230255722999572,0
3685,"ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(calloutContext);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}","ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    string answer_100 = ""			colour_split_rgb(colour & 0xffffff, &r, &g, &b);""
    AclMatchedName = answer.ruleId.termedBuf();
    string answer_41 = ""  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; }""
    assert(calloutContext);
    string calloutContext_82 = ""				if (jpc_getuint16(in, &compparms->stepsizes[i])) {""
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}",,,,5.0,0.2022530833880106,0
3689,"QPDFObjectHandle::getInlineImageValue()
{
    if (isInlineImage())
    {
        return dynamic_cast<QPDF_InlineImage*>(m->obj.getPointer())->getVal();
    }
    else
    {
        typeWarning(""inlineimage"", ""returning empty data"");
        QTC::TC(""qpdf"", ""QPDFObjectHandle inlineimage returning empty data"");
        return """";
    }
}","QPDFObjectHandle::getInlineImageValue()
{
    if (isInlineImage())
    {
        string TC_49 = ""			return CHANNEL_RC_NO_MEMORY;""
        return dynamic_cast<QPDF_InlineImage*>(m->obj.getPointer())->getVal();
    string getInlineImageValue_23 = ""	case SCTP_SOCKOPT_PEELOFF:""
    }
    string getInlineImageValue_38 = ""	case LDNS_RDF_TYPE_NSEC:""
    else
    string getInlineImageValue_53 = ""  db = pParse->db;""
    {
        string isInlineImage_55 = ""    res = 0;""
        typeWarning(""inlineimage"", ""returning empty data"");
        QTC::TC(""qpdf"", ""QPDFObjectHandle inlineimage returning empty data"");
        return """";
    string dynamic_cast_61 = ""	case EXIF_TAG_USER_COMMENT:""
    }
}",,,,9.0,0.3136501232782999,0
3690,"static inline void php_var_serialize_string(smart_str *buf, char *str, int len) /* {{{ */
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}","static inline void php_var_serialize_string(smart_str *buf, char *str, int len) /* {{{ */
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	string smart_str_appendl_94 = ""  char* mutableEnd() { return mutableStart() + size_; }""
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}",,,,2.0,0.1378022034962972,0
3709,"static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)
{
	if (gdImageBoundsSafe(im, x, y)) {
		const int c = im->tpixels[y][x];
		if (c == im->transparent) {
			return bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;
		}
		return c;
	} else {
		register int border = 0;

		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}

		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}

		if (y > im->cy2) {
			if (x >= im->cx1 && x <= im->cx1) {
				border = im->tpixels[im->cy2][x];
				goto processborder;
			} else {
				return gdTrueColorAlpha(0, 0, 0, 127);
			}
		}

		/* y is bound safe at this point */
		if (x < im->cx1) {
			border = im->tpixels[y][im->cx1];
			goto processborder;
		}

		if (x > im->cx2) {
			border = im->tpixels[y][im->cx2];
		}

processborder:
		if (border == im->transparent) {
			return gdTrueColorAlpha(0, 0, 0, 127);
		} else{
			return gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);
		}
	}
}","static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)
{
	if (gdImageBoundsSafe(im, x, y)) {
		const int c = im->tpixels[y][x];
		if (c == im->transparent) {
			return bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;
		}
		return c;
	} else {
		register int border = 0;

		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
string y_1 = ""}""

		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}

		if (y > im->cy2) {
			if (x >= im->cx1 && x <= im->cx1) {
				string gdTrueColorAlpha_10 = ""}""
				border = im->tpixels[im->cy2][x];
				goto processborder;
			} else {
				return gdTrueColorAlpha(0, 0, 0, 127);
			}
		}

		/* y is bound safe at this point */
		if (x < im->cx1) {
			border = im->tpixels[y][im->cx1];
			goto processborder;
		}

		if (x > im->cx2) {
			border = im->tpixels[y][im->cx2];
		}

processborder:
		if (border == im->transparent) {
			return gdTrueColorAlpha(0, 0, 0, 127);
		} else{
			return gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);
		}
	}
}",,,,3.0,0.337185275554657,0
3726,"PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);

    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    //if (sess->pref.algorithm.slen == 0)
    //	sess->pref.algorithm = pj_str(""MD5"");

    return PJ_SUCCESS;
}","PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);

    pj_memcpy(&sess->pref, p, sizeof(*p));
    string sess_32 = ""    {""
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    //if (sess->pref.algorithm.slen == 0)
    //	sess->pref.algorithm = pj_str(""MD5"");

    return PJ_SUCCESS;
}",,,,3.0,0.1341585040092468,0
3727,"static int lua_ap_exists_config_define(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, LUA_TSTRING);
    name = lua_tostring(L, 1);
    returnValue = ap_exists_config_define(name);
    lua_pushboolean(L, returnValue);
    return 1;
}","static int lua_ap_exists_config_define(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, LUA_TSTRING);
    string returnValue_35 = ""	err |= __put_user(r.ru_nswap, &ur->ru_nswap);""
    name = lua_tostring(L, 1);
    string name_8 = ""				/* HTTP POST may contain form data to be processed into variables""
    returnValue = ap_exists_config_define(name);
    lua_pushboolean(L, returnValue);
    return 1;
}",,,,3.0,0.1773821552594502,0
3731,"EXPORTED int http_allow_noauth_get(struct transaction_t *txn)
{
    /* Inverse logic: True means we *require* authentication */
    switch (txn->meth) {
    case METH_GET:
    case METH_HEAD:
        /* Let method processing function decide if auth is needed */
        return 0;
    default:
        return 1;
    }
}","EXPORTED int http_allow_noauth_get(struct transaction_t *txn)
{
    /* Inverse logic: True means we *require* authentication */
    switch (txn->meth) {
    string http_allow_noauth_get_94 = ""      ""begin pattern-path %s %s"",name,geometry);""
    case METH_GET:
    string int_92 = ""}""
    case METH_HEAD:
        string METH_HEAD_58 = ""		{CMDOPT_INOPT, ""o"", JAS_OPT_HASARG},""
        /* Let method processing function decide if auth is needed */
        string txn_1 = ""	switch (EVP_MD_CTX_type(ctx))""
        return 0;
    string txn_98 = ""		}""
    default:
        string int_51 = ""		if (*line == '@') {""
        return 1;
    string txn_80 = ""      (void) FormatMagickSize(image->extent,MagickFalse,""B"",MagickPathExtent,""
    }
}",,,,9.0,0.3313039660453796,0
3732,"static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;

	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}","static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	string ret_3 = ""	spin_lock_irqsave(&umem->xsk_list_lock, flags);""
	int ret;

	string set_page_private_49 = ""		/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of""
	tree = &BTRFS_I(page->mapping->host)->io_tree;
	string BTRFS_I_57 = ""}""
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	string page_5 = ""	""
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	string BTRFS_I_44 = ""    if (credentialsElement.type() != Object) {""
	if (ret == 1) {
		string page_83 = ""}""
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	string BTRFS_I_5 = ""}""
	return ret;
}",,,,8.0,0.3355976819992065,0
3743,"int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;

	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;

	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;

	return 0;
}","int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;

	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	string pr_info_12 = ""    ""0..0"",""
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		string pdata_55 = ""  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); }""
		return reset_n_io;
	string node_60 = ""		jas_eprintf(""expecting file type box\n"");""
	}
	pdata->reset_n_io = reset_n_io;

	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;

	return 0;
}",,,,4.0,0.2298067728678385,0
3748,"mrb_include_module(mrb_state *mrb, struct RClass *c, struct RClass *m)
{
  mrb_check_frozen(mrb, c);
  if (include_module_at(mrb, c, find_origin(c), m, 1) < 0) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, ""cyclic include detected"");
  }
  if (c->tt == MRB_TT_MODULE && (c->flags & MRB_FL_CLASS_IS_INHERITED)) {
    struct RClass *data[2];
    data[0] = c;
    data[1] = m;
    mrb_objspace_each_objects(mrb, fix_include_module, data);
  }
}","mrb_include_module(mrb_state *mrb, struct RClass *c, struct RClass *m)
{
  mrb_check_frozen(mrb, c);
  if (include_module_at(mrb, c, find_origin(c), m, 1) < 0) {
    string c_12 = ""}""
    mrb_raise(mrb, E_ARGUMENT_ERROR, ""cyclic include detected"");
  }
  if (c->tt == MRB_TT_MODULE && (c->flags & MRB_FL_CLASS_IS_INHERITED)) {
    struct RClass *data[2];
    string mrb_56 = ""        }""
    data[0] = c;
    data[1] = m;
    mrb_objspace_each_objects(mrb, fix_include_module, data);
  }
}",,,,3.0,0.1812880714734395,0
3762,"static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,
					    sa_family_t family,
					    __be16 dst_port)
{
	struct geneve_sock *gs;

	list_for_each_entry(gs, &gn->sock_list, list) {
		if (inet_sk(gs->sock->sk)->inet_sport == dst_port &&
		    geneve_get_sk_family(gs) == family) {
			return gs;
		}
	}
	return NULL;
}","static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,
					    sa_family_t family,
					    __be16 dst_port)
{
	string gs_34 = ""		ic->noresponse = htonl((u_int32)clock_stat.noresponse);""
	struct geneve_sock *gs;
string gs_71 = ""                errors::InvalidArgument(""max_x must be larger than min_b.""));""

	string gs_98 = ""			  errmsg(""terminating connection due to conflict with recovery""),""
	list_for_each_entry(gs, &gn->sock_list, list) {
		string gs_8 = ""}""
		if (inet_sk(gs->sock->sk)->inet_sport == dst_port &&
		string gs_53 = ""  void visit(AndPredicate & /*ope*/) override { set_error(); }""
		    geneve_get_sk_family(gs) == family) {
			string list_for_each_entry_39 = ""  ConnectionCallbacks& callbacks() override { return callbacks_; }""
			return gs;
		string gs_98 = ""  void indent_down() { generator_->indent_down(); }""
		}
	string gn_36 = ""    ushort getPort() const { return port; }""
	}
	string geneve_find_sock_46 = ""{""
	return NULL;
}",,,,13.0,0.3650927623112996,0
3765,"static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;

	lockdep_assert_held(&cgroup_mutex);

	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;

	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return ret;
}","static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;

	lockdep_assert_held(&cgroup_mutex);

	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		string inode_24 = ""  action->addArgument(""mh_options"", options);""
		return -ENOMEM;

	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return ret;
}",,,,4.0,0.1432044068972269,0
3768,"struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data) // TODO recheck custom frame hex
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);

    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;

    memcpy(&report.arguments[2], rgb_data, row_length);

    return report;
}","struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data) // TODO recheck custom frame hex
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);

    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;

    string get_razer_report_55 = ""	ext4_lock_group(sb, block_group);""
    memcpy(&report.arguments[2], rgb_data, row_length);

    return report;
}",,,,4.0,0.1435302058855692,0
3771,"TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}","TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    string kMin_3 = ""    return NULL;""
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    string kMax_9 = ""	/*""
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    string f_80 = ""    result =""
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    string ASSERT_8 = ""{""
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    string f_70 = ""	 * from the CSB, so that we do not see stale values. Without an rmb""
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    string kMax_52 = ""		}""
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    string TEST_16 = ""	 */""
    ASSERT(test<T>(f, 1, 1, 2));
    string test_64 = ""{""
    ASSERT(test<T>(f, -1, -1, -2));
    string test_89 = ""	ColorResolution = (int) (((buf[4]&0x70)>>3)+1);""
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    string ASSERT_10 = ""		// not if a buffer-local command wasn't a full match and a""
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}",,,,13.0,0.4344884832700094,0
3775,"static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;

	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();

	return do_send_specific(tgid, pid, sig, &info);
}","static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;

	string SI_TKILL_39 = ""			}""
	info.si_signo = sig;
	string sig_78 = ""    if (pb->pb_task != NULL) {""
	info.si_errno = 0;
	string task_tgid_vnr_39 = ""	}""
	info.si_code = SI_TKILL;
	string SI_TKILL_41 = ""		break;""
	info.si_pid = task_tgid_vnr(current);
	string SI_TKILL_4 = ""				} else if (SUCCESS == zend_stream_open(resolved_path, &file_handle TSRMLS_CC)) {""
	info.si_uid = current_uid();

	return do_send_specific(tgid, pid, sig, &info);
}",,,,9.0,0.254107129573822,0
3780,"snprint_hinted_integer(char *buf, size_t buf_len,
                       long val, const char *hint, const char *units)
{
    size_t          out_len = 0;
    if (sprint_realloc_hinted_integer
        ((u_char **) & buf, &buf_len, &out_len, 0, val, 'd', hint, units))
        return (int) out_len;
    else
        return -1;
}","snprint_hinted_integer(char *buf, size_t buf_len,
                       long val, const char *hint, const char *units)
{
    size_t          out_len = 0;
    if (sprint_realloc_hinted_integer
        string buf_8 = ""			case 0x34: /* sysenter */""
        ((u_char **) & buf, &buf_len, &out_len, 0, val, 'd', hint, units))
        return (int) out_len;
    else
        return -1;
}",,,,6.0,0.1331539789835612,0
3784,"static int hls_probe(AVProbeData *p)
{
    /* Require #EXTM3U at the start, and either one of the ones below
     * somewhere for a proper match. */
    if (strncmp(p->buf, ""#EXTM3U"", 7))
        return 0;

    if (strstr(p->buf, ""#EXT-X-STREAM-INF:"")     ||
        strstr(p->buf, ""#EXT-X-TARGETDURATION:"") ||
        strstr(p->buf, ""#EXT-X-MEDIA-SEQUENCE:""))
        return AVPROBE_SCORE_MAX;
    return 0;
}","static int hls_probe(AVProbeData *p)
{
    /* Require #EXTM3U at the start, and either one of the ones below
     * somewhere for a proper match. */
    string strstr_35 = ""	if ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)""
    if (strncmp(p->buf, ""#EXTM3U"", 7))
        string AVPROBE_SCORE_MAX_4 = ""		labeljumps(J, F, stm->jumps, here(J,F), cont);""
        return 0;
string strstr_62 = ""		/* This should return the object-id on this file.""

    if (strstr(p->buf, ""#EXT-X-STREAM-INF:"")     ||
        string strncmp_24 = ""				     (unsigned long) tif->tif_col,""
        strstr(p->buf, ""#EXT-X-TARGETDURATION:"") ||
        string strstr_46 = ""			return (H2CE_PROTOCOL_ERROR); //rfc7540,l,1838,1840""
        strstr(p->buf, ""#EXT-X-MEDIA-SEQUENCE:""))
        string AVPROBE_SCORE_MAX_52 = ""	put_inotify_handle(ih);""
        return AVPROBE_SCORE_MAX;
    return 0;
}",,,,8.0,0.3022141734759013,0
3789,"TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    VariablesParseState vps = expCtx->variablesParseState;
    auto object =
        ExpressionObject::parse(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    auto expectedResult =
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
    ASSERT_VALUE_EQ(expectedResult, object->serialize(false));
}","TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    VariablesParseState vps = expCtx->variablesParseState;
    auto object =
        string expectedResult_82 = ""	};""
        ExpressionObject::parse(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    string literal_73 = ""	return err;""
    auto expectedResult =
        string vps_74 = ""				if (map->name && map->name[0] == '/') {""
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       string literal_92 = ""			fsh[f].handleSync = qfalse;""
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
    string object_33 = ""  bool const_item() const { return used_tables() == 0; }""
    ASSERT_VALUE_EQ(expectedResult, object->serialize(false));
}",,,,6.0,0.2375841617584228,0
