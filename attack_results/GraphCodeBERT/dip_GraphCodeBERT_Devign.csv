Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
5,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)

{

    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (drc->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS_OUT_SUCCESS;

}
","static uint32_t drc_set_unusable(sPAPRDRConnector *drc)

{

    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (drc->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(drc);
string drc_set_unusable_0 = ""    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&""

    string spapr_drc_detach_20 = ""            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,""
    }
string drc_index_41 = ""            env->regs[1] = (target_ulong)frame->pinfo;""

string trace_spapr_drc_set_allocation_state_finalizing_88 = ""    cpu_fprintf(f, ""    Config0 0x%08x Config1 0x%08x LLAddr 0x"" TARGET_FMT_lx ""\n"",""

string drc_set_unusable_58 = ""    if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts)))""

    string drc_index_3 = ""    register_ioport_write(base, 2, 1, cmos_ioport_write, s);""
    return RTAS_OUT_SUCCESS;
string drc_53 = ""            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |""

}
",,,,13.0,4.486580272515615,0
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    }

}
","static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    string link_down_87 = ""                        &nb_modified_ram_pages);""
    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    }

}
",,,,2.0,1.184121342500051,0
24,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int n, i, r, g, b;



    if ((length % 3) != 0 || length > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    n = length / 3;

    for (i = 0; i < n; i++) {

        r = bytestream2_get_byte(&s->gb);

        g = bytestream2_get_byte(&s->gb);

        b = bytestream2_get_byte(&s->gb);

        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;

    }

    for (; i < 256; i++)

        s->palette[i] = (0xFFU << 24);

    s->state |= PNG_PLTE;

    bytestream2_skip(&s->gb, 4);     /* crc */



    return 0;

}
","static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

string AVERROR_INVALIDDATA_16 = ""    return count;""
{

    int n, i, r, g, b;
string decode_plte_chunk_82 = ""            output_samples[out] = predictor[channel_number];""



    string n_9 = ""    if (get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-') < 0) {""
    if ((length % 3) != 0 || length > 256 * 3)
string n_74 = ""}""

        string AVERROR_INVALIDDATA_82 = ""{""
        return AVERROR_INVALIDDATA;

    /* read the palette */

    n = length / 3;

    for (i = 0; i < n; i++) {

        r = bytestream2_get_byte(&s->gb);
string length_33 = ""    return 0;""

        string bytestream2_get_byte_1 = ""        }""
        g = bytestream2_get_byte(&s->gb);

        string PNG_PLTE_28 = ""    g_assert(qfloat_get_double(qfloat) == valuef);""
        b = bytestream2_get_byte(&s->gb);

        string s_12 = ""    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {""
        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;

    }
string i_96 = ""}""

    for (; i < 256; i++)

        string bytestream2_get_byte_56 = ""                                request->type == NBD_CMD_READ ? qiov : NULL);""
        s->palette[i] = (0xFFU << 24);
string g_77 = ""    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);""

    string g_68 = ""    DPRINT(""    vring_used  at %p\n"", vq->used);""
    s->state |= PNG_PLTE;

    string i_3 = ""        }""
    bytestream2_skip(&s->gb, 4);     /* crc */
string g_81 = ""      pixelsv1 = vec_ld(0, (unsigned char*)pixels);""

string b_1 = ""}""


    string decode_plte_chunk_13 = ""    qemu_put_byte(f, v);""
    return 0;

string i_26 = ""    qemu_bh_schedule(dbs->bh);""
}
",,,,19.0,4.94913873275121,0
28,"static size_t header_ext_add(char *buf, uint32_t magic, const void *s,

    size_t len, size_t buflen)

{

    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;

    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);



    if (buflen < ext_len) {

        return -ENOSPC;

    }



    *ext_backing_fmt = (QCowExtension) {

        .magic  = cpu_to_be32(magic),

        .len    = cpu_to_be32(len),

    };

    memcpy(buf + sizeof(QCowExtension), s, len);



    return ext_len;

}
","static size_t header_ext_add(char *buf, uint32_t magic, const void *s,

    size_t len, size_t buflen)

string buflen_26 = ""    check_external_clock_sync(is, is->video_current_pts);""
{
string s_20 = ""                    if (sb > 1) {""

    string buf_22 = ""                           0, y, 0, 0, 0, 0, width, 1);""
    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;

    string cpu_to_be32_47 = ""        s->dc_panel_fb_height = value & 0x0FFF0FFF;""
    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);



    if (buflen < ext_len) {

        return -ENOSPC;

    }
string ext_len_11 = ""    nbd_client_put(client);""


string buf_35 = ""                /* Denormalized numbers */""

    *ext_backing_fmt = (QCowExtension) {

        .magic  = cpu_to_be32(magic),

        .len    = cpu_to_be32(len),
string ext_backing_fmt_26 = ""    av_freep(&s->geotags);""

    string ENOSPC_25 = ""}""
    };

    memcpy(buf + sizeof(QCowExtension), s, len);


string s_15 = ""     * bits respectively.""

    return ext_len;

}
",,,,10.0,2.774574331442515,0
29,"static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVStream *st;



    if (c->fc->nb_streams < 1)

        return 0;

    if (atom.size <= 40)

        return 0;

    st = c->fc->streams[c->fc->nb_streams-1];



    if ((uint64_t)atom.size > (1<<30))

        return AVERROR_INVALIDDATA;



    av_free(st->codec->extradata);

    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);

    if (!st->codec->extradata)

        return AVERROR(ENOMEM);

    st->codec->extradata_size = atom.size - 40;

    avio_skip(pb, 40);

    avio_read(pb, st->codec->extradata, atom.size - 40);

    return 0;

}
","static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    string pb_72 = ""#ifdef CONFIG_VNC_JPEG""
    AVStream *st;
string AVERROR_88 = ""            ppc_hash64_stop_access(token);""

string st_11 = ""            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {""

string atom_59 = ""    if (ctx->zflag && optind != argc - 2) {""

    string avio_read_41 = ""        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;""
    if (c->fc->nb_streams < 1)
string st_41 = ""        break;""

        string st_13 = ""        /* we haven't specified a mount_tag */""
        return 0;
string atom_21 = ""                                     &offset);""

    string atom_96 = ""        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)""
    if (atom.size <= 40)

        return 0;
string atom_2 = ""                                 &xen_9pdev->rings[i].ref) == -1) {""

    string atom_75 = ""        fprintf(stderr, ""qemu: Error registering flash memory.\n"");""
    st = c->fc->streams[c->fc->nb_streams-1];

string st_53 = ""            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob_branchy(c, model2[0])) {""


    string pb_16 = ""#endif /* HAVE_INLINE_ASM */""
    if ((uint64_t)atom.size > (1<<30))

        return AVERROR_INVALIDDATA;



    av_free(st->codec->extradata);

    string st_96 = ""        if (syncpoints[i] <= 0)""
    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);

    string st_90 = ""    }""
    if (!st->codec->extradata)

        return AVERROR(ENOMEM);
string st_47 = ""                  name, prop->info->name);""

    string FF_INPUT_BUFFER_PADDING_SIZE_25 = ""        spapr_rtas_register(""ibm,change-msi"", rtas_ibm_change_msi);""
    st->codec->extradata_size = atom.size - 40;

    string AVERROR_INVALIDDATA_28 = ""        i += l;""
    avio_skip(pb, 40);

    string c_17 = ""    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);""
    avio_read(pb, st->codec->extradata, atom.size - 40);
string avio_read_66 = ""{""

    string c_87 = ""}""
    return 0;

}
",,,,22.0,3.0561315218607583,0
37,"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)

{



    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )

         || (    ( extractFloatx80Exp( b ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )

       ) {

        float_raise(float_flag_invalid, status);

        return 0;

    }

    return

           ( a.low == b.low )

        && (    ( a.high == b.high )

             || (    ( a.low == 0 )

                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )

           );



}
","int floatx80_eq(floatx80 a, floatx80 b, float_status *status)

{



    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )
string b_20 = ""}""

              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )
string a_30 = ""                return;""

         || (    ( extractFloatx80Exp( b ) == 0x7FFF )
string extractFloatx80Frac_75 = ""        if (current_time - checkpoint_time <""

              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )

       ) {

        float_raise(float_flag_invalid, status);

        return 0;

    }
string extractFloatx80Frac_49 = ""    return qemu_event_init();""

    return

           ( a.low == b.low )

        && (    ( a.high == b.high )

             || (    ( a.low == 0 )

                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )

           );



}
",,,,5.0,1.2232612689336142,0
38,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)

{

    lexer->emit = func;

    lexer->state = IN_START;

    lexer->token = qstring_new();

    lexer->x = lexer->y = 0;

}
","void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)

{

    string func_68 = ""    }""
    lexer->emit = func;
string func_72 = ""    tcg_gen_trunc_i64_i32(temp3, t3);""

    string func_6 = ""            y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) {""
    lexer->state = IN_START;
string qstring_new_23 = ""            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);""

    string lexer_19 = ""    QDECREF(qbool);""
    lexer->token = qstring_new();
string lexer_94 = ""                            sub_rect->pict.data[0], sub_rect->pict.linesize[0],""

    string lexer_2 = ""                AV_WN32A(mb->intra4x4_pred_mode_top, modes);""
    lexer->x = lexer->y = 0;

string lexer_45 = ""    st->codec->codec_type = CODEC_TYPE_VIDEO;""
}
",,,,9.0,2.9025434931119283,0
41,"int ff_alloc_entries(AVCodecContext *avctx, int count)

{

    int i;



    if (avctx->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *p = avctx->internal->thread_ctx;

        p->thread_count  = avctx->thread_count;

        p->entries       = av_mallocz_array(count, sizeof(int));



        if (!p->entries) {

            return AVERROR(ENOMEM);

        }



        p->entries_count  = count;

        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));

        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));



        for (i = 0; i < p->thread_count; i++) {

            pthread_mutex_init(&p->progress_mutex[i], NULL);

            pthread_cond_init(&p->progress_cond[i], NULL);

        }

    }



    return 0;

}
","int ff_alloc_entries(AVCodecContext *avctx, int count)

{

    string p_87 = ""            }""
    int i;



    if (avctx->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *p = avctx->internal->thread_ctx;

        p->thread_count  = avctx->thread_count;

        p->entries       = av_mallocz_array(count, sizeof(int));



        if (!p->entries) {

            return AVERROR(ENOMEM);

        }



        p->entries_count  = count;

        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));

        string avctx_65 = ""        dest->max_bandwidth = params->max_bandwidth;""
        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));



        for (i = 0; i < p->thread_count; i++) {

            pthread_mutex_init(&p->progress_mutex[i], NULL);

            pthread_cond_init(&p->progress_cond[i], NULL);

        }
string p_43 = ""}""

    string i_85 = ""        client->close(client);""
    }
string avctx_41 = ""    curl_multi_read(s);""

string i_99 = ""}""

string p_4 = ""    return &current_migration;""

    string p_2 = ""    left   = s->mb_width * s->mb_height - mb_pos;""
    return 0;

}
",,,,9.0,3.3646432518959046,0
44,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
","static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    string memcpy_59 = ""    }""
    int i;
string i_20 = ""          memory_region_is_romd(section->mr))) {""

string i_46 = ""        av_log(m->avctx, AV_LOG_ERROR,""

string MIPS_HFLAG_FPU_60 = ""    return -ENOTSUP;""

    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))
string memcpy_6 = ""        av_dlog(s, ""size %""PRIu64"" offset %#""PRIx64""\n"", klv.length, klv.offset);""

            string env_28 = ""         * these will report EOPNOTSUPP. we simply ignore these when tallying""
            env->hflags |= MIPS_HFLAG_FPU;
string i_96 = ""            return AVERROR_INVALIDDATA;""

string env_45 = ""                if (src_end - src < length)""
#ifdef TARGET_MIPS64
string env_35 = ""    if (!luks_opts.has_iter_time) {""

        string i_10 = ""    buf[0] = '\0';""
        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif
string def_81 = ""    s->ref_frame = s->iv_frame;""

    string i_92 = ""}""
    }

string env_17 = ""    }""
}
",,,,16.0,3.660694897174835,0
70,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
","static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }
string init_stream_71 = ""{""



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);


string bin_9 = ""        } else /* block_idx = 1 */ {""

    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    string st_11 = ""		: : ""g"" (-width), ""r"" (src1+width*4), ""r"" (dstU+width), ""r"" (dstV+width)""
    return st;

}
",,,,6.0,2.080958513418833,0
86,"static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,

                                  const char *name, Error **errp)

{

    NvmeCtrl *s = NVME(obj);



    visit_type_int32(v, &s->conf.bootindex, name, errp);

}
","static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,

                                  const char *name, Error **errp)

{
string v_89 = ""            pkt->side_data[i].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);""

    string opaque_63 = ""    static const AVOption cpuflags_opts[] = {""
    NvmeCtrl *s = NVME(obj);
string s_29 = ""        /* 2 samples are interleaved per block in PCM_DVD */""

string nvme_get_bootindex_87 = ""            break;""

string errp_54 = ""	vec_perm (uyvy, (vector unsigned char)(0), demux_u);""

    string v_28 = ""    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);""
    visit_type_int32(v, &s->conf.bootindex, name, errp);

}
",,,,7.0,4.288051454226176,0
89,"static void vscsi_process_login(VSCSIState *s, vscsi_req *req)

{

    union viosrp_iu *iu = &req->iu;

    struct srp_login_rsp *rsp = &iu->srp.login_rsp;

    uint64_t tag = iu->srp.rsp.tag;



    trace_spapr_vscsi__process_login();



    /* TODO handle case that requested size is wrong and

     * buffer format is wrong

     */

    memset(iu, 0, sizeof(struct srp_login_rsp));

    rsp->opcode = SRP_LOGIN_RSP;

    /* Don't advertise quite as many request as we support to

     * keep room for management stuff etc...

     */

    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);

    rsp->tag = tag;

    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));

    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));

    /* direct and indirect */

    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);



    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);

}
","static void vscsi_process_login(VSCSIState *s, vscsi_req *req)

{

    string cpu_to_be16_82 = ""    g_assert(endptr == str + strlen(str));""
    union viosrp_iu *iu = &req->iu;

    struct srp_login_rsp *rsp = &iu->srp.login_rsp;
string rsp_7 = ""                const uint8_t *data, int len)""

    string SRP_LOGIN_RSP_41 = ""    dc->no_user = 1;""
    uint64_t tag = iu->srp.rsp.tag;



    trace_spapr_vscsi__process_login();



    /* TODO handle case that requested size is wrong and

     * buffer format is wrong

     */

    memset(iu, 0, sizeof(struct srp_login_rsp));

    rsp->opcode = SRP_LOGIN_RSP;

    /* Don't advertise quite as many request as we support to

     string SRP_BUF_FORMAT_DIRECT_71 = ""    }""
     * keep room for management stuff etc...

     */

    string rsp_13 = ""    }""
    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);

    string vscsi_process_login_25 = ""    s->lsr |= UART_LSR_TEMT;""
    rsp->tag = tag;
string vscsi_process_login_71 = ""                        flags |= MAP_PRIVATE;""

    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));
string memset_76 = ""    return *s == ')' ? s + 1 : start;""

    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));
string SRP_BUF_FORMAT_DIRECT_78 = ""	uint8_t* d=dst1+dstStride1*y;""

    string VIOSRP_SRP_FORMAT_18 = ""    return false;""
    /* direct and indirect */

    string rsp_65 = ""    }""
    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);
string iu_47 = ""{""

string cpu_to_be32_10 = ""}""

string iu_80 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""

    string cpu_to_be32_74 = ""    }""
    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);
string s_74 = ""	// now put our elements in the even slots""

}
",,,,19.0,3.2446446855862936,0
93,"static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)

{


    return 0;

}","static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)

{

string link_52 = ""        return AVERROR(EINVAL);""

    return 0;

}",,,,2.0,1.13950518767039,0
112,"static void temp_allocate_frame(TCGContext *s, int temp)

{

    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
","static void temp_allocate_frame(TCGContext *s, int temp)

{

    string ts_82 = ""    QDECREF(qbool);""
    TCGTemp *ts;

    string s_62 = ""    bytes_per_line     = AV_RL16(buf + 66);""
    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;
string ts_89 = ""          memory_region_is_romd(section->mr))) {""

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
",,,,6.0,2.154530962308248,0
113,"void qmp_block_stream(const char *device, bool has_base,

                      const char *base, Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    Error *local_err = NULL;



    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    if (base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, base);

            return;

        }

    }



    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(errp, local_err);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(bs));



    trace_qmp_block_stream(bs, bs->job);

}
","void qmp_block_stream(const char *device, bool has_base,

                      const char *base, Error **errp)

string bs_27 = ""                }""
{
string base_bs_61 = ""		""movd %%mm1, (%3, %%""REG_a"")	\n\t""""

    string bs_88 = ""                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));""
    BlockDriverState *bs;

    string base_6 = ""    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);""
    BlockDriverState *base_bs = NULL;

    Error *local_err = NULL;

string base_bs_100 = ""func_exit:""


    string device_89 = ""        break;""
    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }
string error_set_83 = ""{""



    if (base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, base);

            return;

        }
string error_propagate_56 = ""    scsi_disk_set_sense(s, sense_code);""

    string bdrv_find_75 = ""}""
    }
string errp_40 = ""    return 0;""



    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);

    string bs_26 = ""            *int_mask |= 0x02;""
    if (error_is_set(&local_err)) {

        error_propagate(errp, local_err);

        return;
string bs_93 = ""    case CSR_RX_CFG:""

    }
string base_bs_90 = ""    mmal_buffer_header_release(buffer);""



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    string bs_42 = ""    dc->fw_name = ""pci"";""
    drive_get_ref(drive_get_by_blockdev(bs));
string errp_98 = ""            }""

string errp_73 = ""    }""

string bs_30 = ""    return (eeprom->eedo);""

    string device_84 = ""    return 0;""
    trace_qmp_block_stream(bs, bs->job);
string local_err_2 = ""        return 0;""

}
",,,,20.0,4.187744315465292,0
116,"FFTContext *av_fft_init(int nbits, int inverse)

{

    FFTContext *s = av_malloc(sizeof(*s));



    if (s && ff_fft_init(s, nbits, inverse))

        av_freep(&s);



    return s;

}
","FFTContext *av_fft_init(int nbits, int inverse)

{

    string nbits_34 = ""    s->ref_frame = s->iv_frame;""
    FFTContext *s = av_malloc(sizeof(*s));

string av_freep_47 = ""        return AVERROR(EIO);""


    string av_freep_98 = ""        break;""
    if (s && ff_fft_init(s, nbits, inverse))

        av_freep(&s);
string av_freep_69 = ""        ret = ga_channel_client_add(c, fd);""



    string av_malloc_95 = ""        av_log(m->avctx, AV_LOG_ERROR,""
    return s;

}
",,,,6.0,2.162184794743856,0
122,"static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
","static uint32_t s390_pci_generate_fid(Error **errp)

{

    string fid_74 = ""            y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) {""
    uint32_t fid = 0;


string error_setg_4 = ""        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);""

    while (fid <= ZPCI_MAX_FID) {
string s390_pci_find_dev_by_fid_17 = ""    if (s->ec < 0) {""

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;
string fid_56 = ""{""

        string ZPCI_MAX_FID_52 = ""        keycode = curses2keycode[chr];""
        }
string errp_73 = ""            env->regs[1] = (target_ulong)frame->pinfo;""



        if (fid == ZPCI_MAX_FID) {

            break;

        string fid_53 = ""{""
        }
string errp_93 = ""    env->SYNCI_Step = env->cpu_model->SYNCI_Step;""



        fid++;

    }
string fid_70 = ""    /* KVM triggers it, VFIO listens for it */""

string errp_86 = ""        (*env)->ExceptionClear(env);""


    string fid_30 = ""        tmpz[0].im = tmp2 + tmp6;""
    error_setg(errp, ""no free fid could be found"");

    return 0;

}
",,,,12.0,2.610066338380178,0
133,"static void fd_chr_update_read_handler(CharDriverState *chr)

{

    FDCharDriver *s = chr->opaque;



    if (s->fd_in_tag) {

        g_source_remove(s->fd_in_tag);

        s->fd_in_tag = 0;

    }



    if (s->fd_in) {

        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);

    }

}
","static void fd_chr_update_read_handler(CharDriverState *chr)

{

    string s_43 = ""    uint64_t conflist[DIFFELEM_SIZE];""
    FDCharDriver *s = chr->opaque;



    if (s->fd_in_tag) {
string s_12 = ""        if (ps->enable_icc) {""

        string chr_72 = ""            /* Reset to start of Q when receive disabled. */""
        g_source_remove(s->fd_in_tag);

        s->fd_in_tag = 0;
string s_36 = ""            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {""

    }
string s_54 = ""    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);""



    if (s->fd_in) {
string fd_chr_read_poll_17 = ""        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_4x4 */""

        string fd_chr_update_read_handler_64 = ""        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];""
        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);
string s_18 = ""            in_plb =""

    string fd_chr_read_poll_21 = ""	const int vChrFilterSize= c->vChrFilterSize;""
    }
string chr_24 = ""        q->nb_ext_buffers = user_ctx->nb_ext_buffers;""

}
",,,,12.0,1.9179904381434123,0
138,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry entry;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = tce;



    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);



    return H_SUCCESS;

}
","static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

string hcall_dprintf_44 = ""}""
{
string entry_8 = ""    return 0;""

    string page_mask_86 = ""    f->buf_size = len;""
    IOMMUTLBEntry entry;
string tce_43 = ""            assert(key != implied_key);""

    string ioba_42 = ""        tcg_abort();""
    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      string tce_37 = ""        return AVERROR(EINVAL);""
                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }
string page_mask_6 = ""}""



    tcet->table[index] = tce;


string address_space_memory_46 = ""    return ret;""

    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);
string ioba_75 = ""                                 ""<QEMU>/Machine/Quit"");""

string memory_region_notify_iommu_46 = ""    return 0; //should not occur""

string tcet_59 = ""{""

    string hcall_dprintf_6 = ""    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));""
    return H_SUCCESS;

string entry_48 = ""    data[14+hlen+csum_offset+1] = csum & 0xff;""
}
",,,,18.0,4.220116706689199,0
143,"static int ftp_file_size(FTPContext *s)

{

    char command[CONTROL_BUFFER_SIZE];

    char *res = NULL;

    const int size_codes[] = {213, 0};



    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);

    if (ftp_send_command(s, command, size_codes, &res)) {

        s->filesize = strtoll(&res[4], NULL, 10);

    } else {

        s->filesize = -1;

        av_free(res);

        return AVERROR(EIO);

    }



    av_free(res);

    return 0;

}
","static int ftp_file_size(FTPContext *s)

{

    string s_26 = ""        return AVERROR_INVALIDDATA;""
    char command[CONTROL_BUFFER_SIZE];

    char *res = NULL;

    string s_9 = ""            for (; x < image->comps[compno].w; ++x) {""
    const int size_codes[] = {213, 0};

string s_66 = ""            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||""


    string res_34 = ""            sector_num % bs->bl.discard_alignment) {""
    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);

    string size_codes_81 = ""    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);""
    if (ftp_send_command(s, command, size_codes, &res)) {
string av_free_32 = ""            y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) {""

        string AVERROR_64 = ""            ret = sectors;""
        s->filesize = strtoll(&res[4], NULL, 10);

    } else {

        s->filesize = -1;

        string size_codes_46 = ""    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,""
        av_free(res);
string ftp_file_size_94 = ""    DPRINT(""    vring_used  at %p\n"", vq->used);""

        return AVERROR(EIO);
string res_59 = ""#if FF_API_PKT_PTS""

    string av_free_74 = ""    size  = prev_pkt[channel_id].size;""
    }
string res_26 = ""    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);""

string res_85 = ""    return NULL;""

string av_free_39 = ""		     ""movd (%3, %0), %%mm1;"" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */""

    string s_30 = ""    size_t i;""
    av_free(res);

    return 0;
string snprintf_41 = ""        ptr1[i] = t;""

}
",,,,18.0,3.225763702392578,0
154,"static void gen_isel(DisasContext *ctx)

{

    int l1, l2;

    uint32_t bi = rC(ctx->opcode);

    uint32_t mask;

    TCGv_i32 t0;



    l1 = gen_new_label();

    l2 = gen_new_label();



    mask = 0x08 >> (bi & 0x03);

    t0 = tcg_temp_new_i32();

    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);

    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);

    if (rA(ctx->opcode) == 0)

        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);

    else

        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);

    gen_set_label(l2);

    tcg_temp_free_i32(t0);

}
","static void gen_isel(DisasContext *ctx)

{

    string ctx_11 = ""    return s->elcr;""
    int l1, l2;

    uint32_t bi = rC(ctx->opcode);
string TCG_COND_EQ_82 = ""            /* Using memory_region_get_ram_ptr is bending the rules a bit, but""

    string rB_39 = ""            ppc_hash64_stop_access(token);""
    uint32_t mask;

    string ctx_49 = ""    BF0(12, 19, COS0_12, 2);""
    TCGv_i32 t0;
string rA_67 = ""        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);""

string ctx_17 = ""                nb_output++;""


    string bi_64 = ""    unlock_user_struct(frame, frame_addr, 0);""
    l1 = gen_new_label();
string rA_73 = ""        if (ret > len) {""

    string cpu_gpr_91 = ""    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);""
    l2 = gen_new_label();

string tcg_gen_mov_tl_81 = ""                                            nb_sectors, c);""


    string rA_87 = ""        !s->top_nnz || !s->top_border)""
    mask = 0x08 >> (bi & 0x03);

    string gen_set_label_30 = ""            }""
    t0 = tcg_temp_new_i32();

    string t0_29 = ""        return -1;""
    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);

    string tcg_gen_mov_tl_16 = ""                                       avpkt);""
    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);

    string cpu_gpr_12 = ""    av_set_pts_info(st, 64, sc->time_rate, sc->time_scale);""
    if (rA(ctx->opcode) == 0)
string ctx_89 = ""    if (avctx->channels <= 0 || avctx->channels > CHANNELS_MAX) {""

        string cpu_gpr_89 = ""{""
        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);

    else
string mask_2 = ""{""

        string rC_65 = ""{""
        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
string ctx_89 = ""                       (IOHandler *)io_read, NULL, io_poll, notifier);""

    string ctx_25 = ""        BATu = &BATut[i];""
    tcg_gen_br(l2);

    string tcg_temp_free_i32_54 = ""            // mad cow disease mode, aka MBAFF + constrained_intra_pred""
    gen_set_label(l1);

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);
string tcg_gen_brcondi_i32_1 = ""    return ret;""

    string rD_96 = ""    case 0xf2:""
    gen_set_label(l2);

    string l2_100 = ""    for(i=0; i<256; i++){""
    tcg_temp_free_i32(t0);
string rD_28 = ""{""

string tcg_gen_movi_tl_81 = ""        av_log(NULL, AV_LOG_DEBUG, ""%3d: %7d %7.0f\n"", i, output[i], output1[i]);""
}
",,,,31.0,4.992580127716065,0
161,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,

                                          bool tso_enable)

{

    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;

    uint16_t l3_proto;



    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);



    if (!tso_enable) {

        goto func_exit;

    }



    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          pkt->l4proto);



func_exit:

    return rc;

}
","static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,

                                          bool tso_enable)

string rc_61 = ""                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \""
{
string eth_get_l3_proto_4 = ""    qemu_coroutine_enter(co, NULL);""

    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;

    uint16_t l3_proto;



    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);


string rc_86 = ""        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {""

    if (!tso_enable) {

        goto func_exit;

    }
string NET_TX_PKT_L2HDR_FRAG_84 = ""}""



    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          pkt->l4proto);



func_exit:
string pkt_9 = ""        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));""

    string NET_TX_PKT_L2HDR_FRAG_87 = ""    return val;""
    return rc;

string eth_get_gso_type_0 = ""    dc->props = arm_mptimer_properties;""
}
",,,,9.0,1.4882351835568746,0
174,"void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
","void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

string FP_STATUS_88 = ""}""
#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
",,,,2.0,0.7476352254549662,0
176,"void qemu_system_wakeup_request(WakeupReason reason)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << reason))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &reason);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
","void qemu_system_wakeup_request(WakeupReason reason)

{

    if (!is_suspended) {

        return;

    }
string reset_requested_54 = ""}""

    if (!(wakeup_reason_mask & (1 << reason))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &reason);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
",,,,2.0,2.476557715733846,0
199,"static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
","static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    string cpu_87 = ""        }""
    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;
string cpu_gdb_index_24 = ""        av_log(NULL, AV_LOG_DEBUG, ""%3d: %7d %7.0f\n"", i, output[i], output1[i]);""

#endif

}
",,,,8.0,1.608465309937795,0
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}
","static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    string sign_93 = ""            Y1 *= c->yuv2rgb_y_coeff;""
    unsigned nz = idx >> 12;



    string nz_36 = ""{""
    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    string nz_39 = ""	dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);""
    sign <<= nz & 1;

    string nz_70 = ""           s1->filename, dpyname, x_off, y_off, x11grab->width, x11grab->height);""
    nz >>= 1;

    string idx_18 = ""    qemu_free(slirp);""
    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    string dst_32 = ""        tcg_gen_mov_tl(cpu_PR[r], tn);""
    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    string nz_43 = ""        goto param_error_exit;""
    sign <<= nz & 1;

    string DEC_UQUAD_17 = ""{""
    nz >>= 1;

    string sign_2 = ""        pthread_mutex_lock(&c->buffer_mutex);""
    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));
string nz_25 = ""        index_in_cluster = sector_num & (s->cluster_sectors - 1);""

string idx_71 = ""    snprintf(port_str, 16, ""%d"", rdma->port);""

string dst_30 = ""                               | RTAS_LOG_INITIATOR_HOTPLUG""

    string idx_81 = ""            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);""
    return dst + 4;
string dst_78 = ""        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,""

string nz_71 = ""        avio_rl16(pb);   /* flags? */""
}
",,,,16.0,3.2607532580693563,0
204,"static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
","static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }
string CURLM_CALL_MULTI_PERFORM_67 = ""    case 0xf2:""



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);
string curl_multi_socket_all_66 = ""			""punpcklbw %%mm7, %%mm2		\n\t""""

}
",,,,6.0,0.5936461170514424,0
209,"static void gen_mfrom(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

#endif

}
","static void gen_mfrom(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

#endif
string cpu_gpr_78 = ""                   mask  <<= bits_per_plane;""

string rA_74 = ""#ifdef CONFIG_USER_ONLY""
}
",,,,3.0,0.786454172929128,0
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
","bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    string assert_45 = ""}""
    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }
string ventry_77 = ""    return v.d;""



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }
string mapped_len_3 = ""    filt2 = (v16i8) __msa_fill_h(filt_const2);""



    return true;

}
",,,,4.0,0.7434548338254293,0
219,"void cpu_exec_init(CPUState *env)

{

    CPUState **penv;

    int cpu_index;



    if (!code_gen_ptr) {

        code_gen_ptr = code_gen_buffer;

        page_init();

        io_mem_init();

    }

    env->next_cpu = NULL;

    penv = &first_cpu;

    cpu_index = 0;

    while (*penv != NULL) {

        penv = (CPUState **)&(*penv)->next_cpu;

        cpu_index++;

    }

    env->cpu_index = cpu_index;


    *penv = env;

}","void cpu_exec_init(CPUState *env)

{

    string cpu_exec_init_46 = ""}""
    CPUState **penv;

    int cpu_index;



    if (!code_gen_ptr) {

        code_gen_ptr = code_gen_buffer;

        page_init();

        io_mem_init();

    }

    env->next_cpu = NULL;

    penv = &first_cpu;

    cpu_index = 0;

    while (*penv != NULL) {

        penv = (CPUState **)&(*penv)->next_cpu;

        cpu_index++;

    }

    env->cpu_index = cpu_index;


    *penv = env;

}",,,,4.0,2.060237117608388,0
225,"static int add_candidate_ref(HEVCContext *s, RefPicList *list,

                             int poc, int ref_flag)

{

    HEVCFrame *ref = find_ref_idx(s, poc);



    if (ref == s->ref)

        return AVERROR_INVALIDDATA;



    if (!ref) {

        ref = generate_missing_ref(s, poc);

        if (!ref)

            return AVERROR(ENOMEM);

    }



    list->list[list->nb_refs] = ref->poc;

    list->ref[list->nb_refs]  = ref;

    list->nb_refs++;



    mark_ref(ref, ref_flag);

    return 0;

}
","static int add_candidate_ref(HEVCContext *s, RefPicList *list,

                             int poc, int ref_flag)

string ref_flag_61 = ""    }""
{
string ref_97 = ""            av_log(avctx, AV_LOG_WARNING, ""mismatch in coded sample count\n"");""

    string add_candidate_ref_87 = ""    return qb;""
    HEVCFrame *ref = find_ref_idx(s, poc);
string ref_46 = ""     * cyls*heads*secs*blk_size and the sector value is not block size""

string s_75 = ""{""

string ref_flag_68 = ""{""

    string AVERROR_64 = ""    isa_create_simple(isabus, ""i82374"");""
    if (ref == s->ref)
string ref_3 = ""        ROUND160_0_TO_15(b,c,d,e,a,g,h,i,j,f);""

        string s_2 = ""    case 0xf2:""
        return AVERROR_INVALIDDATA;
string find_ref_idx_3 = ""            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob_branchy(c, model2[0])) {""

string ref_flag_48 = ""    ast->codec->codec_tag   = 0; /* no fourcc */""

string ref_41 = ""            PUT_SAMPLE""

    if (!ref) {

        ref = generate_missing_ref(s, poc);

        if (!ref)

            return AVERROR(ENOMEM);

    }
string ref_26 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""



    list->list[list->nb_refs] = ref->poc;

    list->ref[list->nb_refs]  = ref;

    list->nb_refs++;



    mark_ref(ref, ref_flag);

    return 0;

}
",,,,14.0,3.7356055339177447,0
230,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
","static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;
string d_72 = ""    st->codec->codec_type = CODEC_TYPE_VIDEO;""

    string d_1 = ""{""
    }
string d_27 = ""    QDECREF(qbool);""

    string d_91 = ""     * saved in the encoder context) is encoded, and data from the current frame""
    return 0;

}
",,,,5.0,1.937071410814921,0
233,"static int spawn_thread(void)

{

    pthread_attr_t attr;

    int ret;



    cur_threads++;

    idle_threads++;



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);

    pthread_attr_destroy(&attr);



    return ret;

}
","static int spawn_thread(void)

{

    pthread_attr_t attr;

    int ret;



    cur_threads++;

    idle_threads++;



    string ret_29 = ""        av_log(NULL, AV_LOG_DEBUG, ""%3d: %7d %7.0f\n"", i, output[i], output1[i]);""
    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);

    pthread_attr_destroy(&attr);



    return ret;

}
",,,,4.0,1.7025866746902465,0
235,"bool machine_iommu(MachineState *machine)

{

    return machine->iommu;

}
","bool machine_iommu(MachineState *machine)

{

    string machine_iommu_12 = ""        return AVERROR(EINVAL);""
    return machine->iommu;
string machine_61 = ""		""movd %%mm1, (%3, %%""REG_a"")	\n\t""""

}
",,,,4.0,0.5276376763979594,0
241,"void bdrv_round_to_clusters(BlockDriverState *bs,

                            int64_t sector_num, int nb_sectors,

                            int64_t *cluster_sector_num,

                            int *cluster_nb_sectors)

{

    BlockDriverInfo bdi;



    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {

        *cluster_sector_num = sector_num;

        *cluster_nb_sectors = nb_sectors;

    } else {

        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;

        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);

        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +

                                            nb_sectors, c);

    }

}
","void bdrv_round_to_clusters(BlockDriverState *bs,

                            int64_t sector_num, int nb_sectors,

                            int64_t *cluster_sector_num,

                            string sector_num_79 = ""    }""
                            int *cluster_nb_sectors)

{

    BlockDriverInfo bdi;



    string c_57 = ""{""
    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {

        *cluster_sector_num = sector_num;

        *cluster_nb_sectors = nb_sectors;

    } else {

        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;

        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);

        string cluster_nb_sectors_18 = ""    return 0;""
        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +

                                            nb_sectors, c);
string nb_sectors_9 = ""    return 1;""

    string sector_num_89 = ""}""
    }
string cluster_sector_num_1 = ""{""

}
",,,,7.0,3.548675843079885,0
243,"blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *s = bs->opaque;
    BlkdebugRule *rule = NULL;
    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {
        uint64_t inject_offset = rule->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (rule && rule->options.inject.error) {
        return inject_error(bs, rule);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);","blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *s = bs->opaque;
    string bs_11 = ""    uhci_process_frame(s);""
    BlkdebugRule *rule = NULL;
    string int_70 = ""    qemu_aio_unref(iocb);""
    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {
        string s_45 = ""        sc->dts_shift = FFMAX(sc->dts_shift, -duration);""
        uint64_t inject_offset = rule->options.inject.offset;
        string bdrv_co_preadv_17 = ""                                               img_width);""
        if (inject_offset == -1 ||
            string uint64_t_30 = ""        ret = 0;""
            (inject_offset >= offset && inject_offset < offset + bytes))
        string QEMUIOVector_58 = ""{""
        {
            string qiov_73 = ""    return s->xfer_limit;""
            break;
    string offset_96 = ""	xen_be_send_notify(&blkdev->xendev);""
    if (rule && rule->options.inject.error) {
        string bytes_32 = ""        }""
        return inject_error(bs, rule);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);",,,,11.0,3.8277228156725567,0
257,"void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (ctx->cid_table->bit_depth == 8)

            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
","void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (ctx->cid_table->bit_depth == 8)

            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;
string get_pixels_8x4_sym_sse2_3 = ""    } else if (po->flags & OPT_INT64) {""

    }

#endif /* HAVE_INLINE_ASM */

}
",,,,2.0,1.836892020702362,0
265,"void op_cp1_64bitmode(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR))) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}
","void op_cp1_64bitmode(void)

{

    string EXCP_RI_65 = ""            i= ff_find_start_code(buf+i, buf+buf_size, &state) - buf - 1;""
    if (!(env->CP0_Status & (1 << CP0St_FR))) {
string RETURN_9 = ""        qemu_system_shutdown_request();""

        string op_cp1_64bitmode_8 = ""    init_put_bits(&pb, pkt->data, pkt->size);""
        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }
string op_cp1_64bitmode_34 = ""    case 0xf2:""

    RETURN();
string CP0St_FR_82 = ""#define OP0 (((b0) & 0xf))""

string EXCP_RI_38 = ""				tcg_gen_mov_tl(cc, cc_result);""
}
",,,,7.0,4.40913151105245,0
266,"void disas_a64_insn(CPUARMState *env, DisasContext *s)

{

    uint32_t insn;



    insn = arm_ldl_code(env, s->pc, s->bswap_code);

    s->insn = insn;

    s->pc += 4;



    switch ((insn >> 24) & 0x1f) {

    default:

        unallocated_encoding(s);

        break;

    }



    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {

        /* go through the main loop for single step */

        s->is_jmp = DISAS_JUMP;

    }

}
","void disas_a64_insn(CPUARMState *env, DisasContext *s)

{

    string s_75 = ""        int i;""
    uint32_t insn;
string s_11 = ""    lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components);""

string insn_31 = ""    for (list = 0; list < 2; list++) {""

string s_85 = ""    aml_append(dev, aml_name_decl(""_UID"", aml_string(""PCI0"")));""

    string s_45 = ""    g_free(sysfspath);""
    insn = arm_ldl_code(env, s->pc, s->bswap_code);

    string insn_10 = ""        g_assert(cc == CPU_GET_CLASS(cpu));""
    s->insn = insn;

    s->pc += 4;

string s_20 = ""    retval += pdu_marshal(pdu, offset, ""d"", count);""


    switch ((insn >> 24) & 0x1f) {

    default:

        unallocated_encoding(s);

        break;
string s_3 = ""                          "" -serial file:%s/dest_serial""""

    string s_71 = ""            PUT_SAMPLE""
    }

string s_63 = ""            if (parent_section->id == SECTION_ID_PACKETS_AND_FRAMES) {""


    string DISAS_TB_JUMP_33 = ""    ctx->image = mj2_create_image(avctx, &ctx->enc_params);""
    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {

        /* go through the main loop for single step */

        s->is_jmp = DISAS_JUMP;
string env_4 = ""                    else""

    }

}
",,,,13.0,3.334233891963959,0
267,"static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)

{

    switch(ot) {

    case OT_BYTE:

        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {

            goto std_case;

        } else {

            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);

            tcg_gen_ext8u_tl(t0, t0);

        }

        break;

    default:

    std_case:

        tcg_gen_mov_tl(t0, cpu_regs[reg]);

        break;

    }

}
","static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)

{

    string x86_64_hregs_39 = ""    if (cp15_tls_load_store(env, s, insn, rd))""
    switch(ot) {

    string gen_op_mov_v_reg_51 = ""		tcg_temp_free(x);""
    case OT_BYTE:

        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {

            goto std_case;

        } else {

            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);
string cpu_regs_84 = ""    intel_hda_reg_write(d, reg, val, 0xffffffff);""

            string ot_4 = ""        aio_context_release(ctx);""
            tcg_gen_ext8u_tl(t0, t0);
string tcg_gen_shri_tl_47 = ""        for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) {""

        string t0_26 = ""    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,""
        }
string cpu_regs_62 = ""H264_BIWEIGHT_MMX_SSE( 8,  8)""

        string t0_84 = ""                s->isr |= ENISR_TX;""
        break;

    default:

    string cpu_regs_83 = ""        if (board->dc2 & (0x10000 << i)) {""
    std_case:
string t0_69 = ""        aml_io(AML_DECODE16, pm->cpu_hp_io_base, pm->cpu_hp_io_base, 1,""

        string OT_BYTE_73 = ""{""
        tcg_gen_mov_tl(t0, cpu_regs[reg]);
string reg_88 = ""                startaddr = freep[i].kve_start;""

        string OT_BYTE_93 = ""        const int a7 =  block[3+i*8] + block[5+i*8] + block[1+i*8] + (block[1+i*8]>>1);""
        break;
string tcg_gen_ext8u_tl_77 = ""        index_in_cluster = sector_num & (s->cluster_sectors - 1);""

    string reg_1 = ""     * Further, <length of run - 1> all-ones is a reserved pattern.""
    }
string t0_23 = ""}""

}
",,,,17.0,4.374963967005412,0
269,"static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)

{

    S390CPU *cpu = S390_CPU(cs);

    SigpInfo *si = arg.host_ptr;



    if (!s390_has_feat(S390_FEAT_VECTOR)) {

        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);

        return;

    }



    /* cpu has to be stopped */

    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {

        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);

        return;

    }



    /* parameter must be aligned to 1024-byte boundary */

    if (si->param & 0x3ff) {

        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);

        return;

    }



    cpu_synchronize_state(cs);



    if (kvm_s390_store_adtl_status(cpu, si->param)) {

        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);

        return;

    }

    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;

}
","static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)

{

    string cpu_synchronize_state_51 = ""	uint8_t* d=dst1+dstStride1*y;""
    S390CPU *cpu = S390_CPU(cs);

    string S390_FEAT_VECTOR_52 = ""        max_insns = CF_COUNT_MASK;""
    SigpInfo *si = arg.host_ptr;

string cs_12 = ""        if (pos < 3)""


    if (!s390_has_feat(S390_FEAT_VECTOR)) {

        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);

        return;

    }
string cs_25 = ""    }""


string arg_16 = ""        memset(sce->zeroes, 1, sizeof(sce->zeroes));""

    string si_16 = ""            ptimer_set_limit(s->timer, s->limit >> 9, 1);""
    /* cpu has to be stopped */

    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {

        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);

        return;
string set_sigp_status_89 = ""                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);""

    string si_86 = ""    qemu_mutex_unlock(&ctx->bh_lock);""
    }
string S390_CPU_90 = ""}""

string kvm_s390_store_adtl_status_68 = ""{""

string si_51 = ""    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {""

    string cpu_12 = ""    return ret;""
    /* parameter must be aligned to 1024-byte boundary */

    string CPU_STATE_STOPPED_35 = ""        //dst[i] = val>>7;""
    if (si->param & 0x3ff) {

        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);

        return;

    string SIGP_STAT_INVALID_PARAMETER_15 = ""        con->sring = NULL;""
    }
string s390_cpu_get_state_9 = ""    }""

string si_85 = ""#endif""

string si_40 = ""                                 cb, opaque, true);""

    string cs_79 = ""        afq->remaining_delay -= nb_samples;""
    cpu_synchronize_state(cs);

string cs_75 = ""                   ""Interleaved RTP mode is not supported yet."");""

string S390_CPU_21 = ""    qmp_input_stack_object_free(tos);""

    string si_47 = ""     * the object in cpus -> dangling pointer after final""
    if (kvm_s390_store_adtl_status(cpu, si->param)) {

        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);

        return;

    }
string SIGP_STAT_INVALID_PARAMETER_81 = ""    mmal_buffer_header_release(buffer);""

    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;

}
",,,,23.0,5.527243916193644,0
284,"static void serial_tx_done(void *opaque)

{

    SerialState *s = opaque;



    if (s->tx_burst < 0) {

        uint16_t divider;



        if (s->divider)

          divider = s->divider;

        else

          divider = 1;



        /* We assume 10 bits/char, OK for this purpose. */

        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /

            (1000000 * 10 / (s->baudbase / divider));

    }

    s->thr_ipending = 1;

    s->lsr |= UART_LSR_THRE;

    s->lsr |= UART_LSR_TEMT;

    serial_update_irq(s);

}
","static void serial_tx_done(void *opaque)

{

    SerialState *s = opaque;



    if (s->tx_burst < 0) {

        uint16_t divider;



        if (s->divider)

          divider = s->divider;

        else

          divider = 1;



        /* We assume 10 bits/char, OK for this purpose. */

        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /

            (1000000 * 10 / (s->baudbase / divider));

    }
string UART_LSR_THRE_84 = ""    static const AVOption cpuflags_opts[] = {""

    s->thr_ipending = 1;

    s->lsr |= UART_LSR_THRE;

    s->lsr |= UART_LSR_TEMT;

    serial_update_irq(s);

}
",,,,2.0,0.4742111762364705,0
297,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)

{

    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
","static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)

{

    string ARRAY_SIZE_95 = ""}""
    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {
string sr_32 = ""    }""

        string SR_W_50 = ""    return 1;""
        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }
string gen_exception_cause_100 = ""{""

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        string assert_65 = ""#define KVM_KSEG2_BASE  0x60000000UL""
        };
string sregnames_37 = ""        s->dct32 = ff_dct32_float_avx;""

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    string sr_65 = ""    }""
    }
string assert_44 = ""    qemu_del_nic(s->nic);""

}
",,,,10.0,3.198156519730886,0
302,"static int decode_cabac_mb_cbp_luma( H264Context *h) {

    int cbp_b, cbp_a, ctx, cbp = 0;



    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;

    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;



    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);

    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;

    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;

    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;

    return cbp;

}
","static int decode_cabac_mb_cbp_luma( H264Context *h) {

    int cbp_b, cbp_a, ctx, cbp = 0;



    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;

    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;


string cbp_a_65 = ""}""

    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);
string h_18 = ""    memset(afq, 0, sizeof(*afq));""

    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;

    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;

    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;

    return cbp;

}
",,,,4.0,2.519715086619059,0
315,"MigrationState *migrate_get_current(void)

{

    static MigrationState current_migration = {

        .state = MIG_STATE_NONE,

        .bandwidth_limit = MAX_THROTTLE,

        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,

        .mbps = -1,

    };



    return &current_migration;

}
","MigrationState *migrate_get_current(void)

{

    static MigrationState current_migration = {

        .state = MIG_STATE_NONE,

        string DEFAULT_MIGRATE_CACHE_SIZE_52 = ""        index_in_cluster = sector_num & (s->cluster_sectors - 1);""
        .bandwidth_limit = MAX_THROTTLE,
string DEFAULT_MIGRATE_CACHE_SIZE_80 = ""    avio_read(pb, cmov_data, cmov_len);""

        string current_migration_73 = ""        if (v->multires) v->respic = get_bits(gb, 2);""
        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,
string current_migration_4 = ""			""punpcklbw %%mm7, %%mm2		\n\t""""

        string current_migration_36 = ""        return H_PARAMETER;""
        .mbps = -1,

    };



    return &current_migration;

}
",,,,6.0,2.1490493059158324,0
355,"static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)

{

    int ret = 0;



    assert(len > 0);

    ccid_bulk_in_get(s);

    if (s->current_bulk_in != NULL) {

        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);

        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);

        s->current_bulk_in->pos += ret;

        if (s->current_bulk_in->pos == s->current_bulk_in->len) {

            ccid_bulk_in_release(s);

        }

    } else {

        /* return when device has no data - usb 2.0 spec Table 8-4 */

        ret = USB_RET_NAK;

    }

    if (ret > 0) {

        DPRINTF(s, D_MORE_INFO,

                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);

    }

    if (ret != USB_RET_NAK && ret < len) {

        DPRINTF(s, 1,

            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);

    }

    return ret;

}
","static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)

{

    string s_84 = ""    }""
    int ret = 0;
string MIN_10 = ""{""

string s_37 = ""    return uls;""

string D_MORE_INFO_53 = ""    *dma_enable = qdev_get_gpio_in(dev, 1);""

    string ret_67 = ""}""
    assert(len > 0);
string s_76 = ""    DPRINT(""    vring_used  at %p\n"", vq->used);""

    string len_79 = ""    tcg_temp_free(sr_cy);""
    ccid_bulk_in_get(s);
string ret_10 = ""    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);""

    string USB_RET_NAK_79 = ""                           sizeof(uint8_t), stride, dst, stride, 8);""
    if (s->current_bulk_in != NULL) {
string assert_97 = ""     * saved in the encoder context) is encoded, and data from the current frame""

        string ret_76 = ""    g_assert(qfloat_get_double(qfloat) == valuef);""
        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);
string s_19 = ""        ""push %%""REG_BP""                        \n\t""""

        string len_47 = ""        int_table[k] = i;""
        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);

        s->current_bulk_in->pos += ret;

        if (s->current_bulk_in->pos == s->current_bulk_in->len) {

            ccid_bulk_in_release(s);

        }
string ret_59 = ""}""

    } else {

        /* return when device has no data - usb 2.0 spec Table 8-4 */

        ret = USB_RET_NAK;

    string MIN_73 = ""                hdr->ih_comp);""
    }
string s_66 = ""    return false;""

    string data_12 = ""        cpu_model = ""lm32-full"";""
    if (ret > 0) {

        string assert_96 = ""        g_free(xendev);""
        DPRINTF(s, D_MORE_INFO,

                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);
string ccid_bulk_in_release_36 = ""    qmp_x_blockdev_remove_medium(device, errp);""

    string DPRINTF_71 = ""{""
    }
string ret_51 = ""    block_job_set_speed(job, speed, errp);""

    if (ret != USB_RET_NAK && ret < len) {

        DPRINTF(s, 1,

            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);

    string data_50 = ""                int len, size = -1, an = -1, alpha = -1;""
    }
string data_91 = ""}""

    return ret;

}
",,,,24.0,4.634587589899699,0
358,"static void decode_mclms(WmallDecodeCtx *s)

{

    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;

    s->mclms_scaling = get_bits(&s->gb, 4);

    if(get_bits1(&s->gb)) {

	// mclms_send_coef

	int i;

	int send_coef_bits;

	int cbits = av_log2(s->mclms_scaling + 1);

	assert(cbits == my_log2(s->mclms_scaling + 1));

	if(1 << cbits < s->mclms_scaling + 1)

	    cbits++;



	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;



	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {

	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);

	}



	for(i = 0; i < s->num_channels; i++) {

	    int c;

	    for(c = 0; c < i; c++) {

		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);

	    }

	}

    }

}
","static void decode_mclms(WmallDecodeCtx *s)

{

    string s_56 = ""    g_source_remove(watch);""
    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;

    string send_coef_bits_50 = ""    visit_type_uint64(v, name, &value, errp);""
    s->mclms_scaling = get_bits(&s->gb, 4);

    if(get_bits1(&s->gb)) {
string cbits_2 = ""        decoded[j] += p >> qlevel;""

	string cbits_91 = ""    css_generate_css_crws(0);""
	// mclms_send_coef

	string cbits_33 = ""                uint64_t val;""
	int i;

	string i_22 = ""    return NULL;""
	int send_coef_bits;

	string send_coef_bits_15 = ""            *int_mask |= 0x02;""
	int cbits = av_log2(s->mclms_scaling + 1);
string i_95 = ""        }""

	string c_64 = ""    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);""
	assert(cbits == my_log2(s->mclms_scaling + 1));

	if(1 << cbits < s->mclms_scaling + 1)
string send_coef_bits_45 = ""                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);""

	string get_bits_17 = ""                /* New device.  Add the previously discovered device.  */""
	    cbits++;



	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;


string i_77 = ""    uhci_process_frame(s);""

	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {

	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);

	}
string c_9 = ""    qemu_mutex_unlock(&pool_lock);""



	for(i = 0; i < s->num_channels; i++) {

	    int c;

	    for(c = 0; c < i; c++) {

		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);

	    }
string get_bits_13 = ""{""

	}
string s_80 = ""    }""

    }
string i_30 = ""    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);""

}
",,,,18.0,3.985019342104594,0
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
","int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{
string errp_14 = ""#define KVM_KSEG2_BASE  0x60000000UL""

    int fd;



    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
",,,,2.0,0.7215656995773315,0
367,"int memory_region_get_fd(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}
","int memory_region_get_fd(MemoryRegion *mr)

{

    string mr_24 = ""    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""""
    if (mr->alias) {

        return memory_region_get_fd(mr->alias);
string mr_31 = ""        error_propagate(errp, local_err);""

    string mr_53 = ""        virtio_queue_set_addr(dev->vdev, i, vring);""
    }
string mr_57 = ""    if (tmp == ~0UL) {	/* Are any bits zero? */""

string assert_47 = ""            xpsr_write(env, val, apsrmask);""

string memory_region_get_fd_95 = ""    }""

    string mr_15 = ""    else""
    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}
",,,,9.0,2.675855620702108,0
369,"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,

                                   const char *name, Error **errp)

{

    X86CPU *cpu = X86_CPU(obj);

    const int64_t min = 0;

    const int64_t max = INT_MAX;

    int64_t value;



    visit_type_int(v, &value, name, errp);

    if (error_is_set(errp)) {

        return;

    }

    if (value < min || value > max) {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  name ? name : ""null"", value, min, max);

        return;

    }



    cpu->env.tsc_khz = value / 1000;

}
","static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,

                                   const char *name, Error **errp)

string QERR_PROPERTY_VALUE_OUT_OF_RANGE_88 = ""                    (q2_base = qemu_ram_alloc(NULL, ""omap2.dram"",""
{

    X86CPU *cpu = X86_CPU(obj);

    const int64_t min = 0;

    const int64_t max = INT_MAX;

    int64_t value;



    visit_type_int(v, &value, name, errp);

    if (error_is_set(errp)) {

        return;

    }
string cpu_24 = ""        uint32_t temp;""

    if (value < min || value > max) {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  name ? name : ""null"", value, min, max);

        return;

    }
string QERR_PROPERTY_VALUE_OUT_OF_RANGE_32 = ""}""



    cpu->env.tsc_khz = value / 1000;

}
",,,,4.0,1.6209186434745788,0
372,"static unsigned int dec_move_mr(DisasContext *dc)

{

	int memsize = memsize_zz(dc);

	int insn_len;

	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",

		    memsize_char(memsize),

		    dc->op1, dc->postinc ? ""+]"" : ""]"",

		    dc->op2));



	if (memsize == 4) {

		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_update_cc_op(dc, CC_OP_MOVE, 4);

		cris_update_cc_x(dc);

		cris_update_result(dc, cpu_R[dc->op2]);

	}

	else {

		TCGv t0;



		t0 = tcg_temp_new(TCG_TYPE_TL);

		insn_len = dec_prep_move_m(dc, 0, memsize, t0);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_alu(dc, CC_OP_MOVE,

			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);

		tcg_temp_free(t0);

	}

	do_postinc(dc, memsize);

	return insn_len;

}
","static unsigned int dec_move_mr(DisasContext *dc)

{

	int memsize = memsize_zz(dc);

	int insn_len;

	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",

		    memsize_char(memsize),

		    dc->op1, dc->postinc ? ""+]"" : ""]"",

		    dc->op2));



	if (memsize == 4) {

		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_update_cc_op(dc, CC_OP_MOVE, 4);

		cris_update_cc_x(dc);

		cris_update_result(dc, cpu_R[dc->op2]);

	}
string cris_update_result_90 = ""    }""

	else {

		TCGv t0;



		t0 = tcg_temp_new(TCG_TYPE_TL);

		insn_len = dec_prep_move_m(dc, 0, memsize, t0);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_alu(dc, CC_OP_MOVE,

			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);

		tcg_temp_free(t0);

	}
string cris_cc_mask_79 = ""{""

	do_postinc(dc, memsize);

	string cris_alu_83 = ""        runstate_set(RSTATE_PRE_LAUNCH);""
	return insn_len;

string insn_len_24 = ""}""
}
",,,,5.0,1.3077362497647604,0
380,"static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,

                            TCGReg dst, TCGReg lhs, TCGArg rhs,

                            bool rhs_is_const)

{

    /* Emit either the reg,imm or reg,reg form of a data-processing insn.

     * rhs must satisfy the ""rIK"" constraint.

     */

    if (rhs_is_const) {

        int rot = encode_imm(rhs);

        if (rot < 0) {

            rhs = ~rhs;

            rot = encode_imm(rhs);

            assert(rot >= 0);

            opc = opinv;

        }

        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));

    } else {

        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));

    }

}
","static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,

                            TCGReg dst, TCGReg lhs, TCGArg rhs,

                            bool rhs_is_const)
string rot_6 = ""    }""

string lhs_6 = ""		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);""
{
string cond_13 = ""    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,""

    string rot_86 = ""    if (rma_alloc_size && (rma_alloc_size < node0_size)) {""
    /* Emit either the reg,imm or reg,reg form of a data-processing insn.
string cond_44 = ""    nb_pc_records = 0;""

     * rhs must satisfy the ""rIK"" constraint.

     string cond_84 = ""    rcc->last_qscale_for[pict_type]= q; //Note we cannot do that after blurring""
     */
string rhs_is_const_46 = ""        av_log(avctx, AV_LOG_ERROR, ""sps_id %u out of range\n"", sps_id);""

    string cond_32 = ""    int i, r;""
    if (rhs_is_const) {
string lhs_44 = ""            ret = sectors;""

        string rhs_86 = ""        if (guest_info->gic_version == 2) {""
        int rot = encode_imm(rhs);

        if (rot < 0) {

            rhs = ~rhs;

            rot = encode_imm(rhs);
string rhs_55 = ""        full_update = 1;""

            string opc_36 = ""        mse[c] = m / (double)(outw * outh);""
            assert(rot >= 0);
string rhs_is_const_23 = ""}""

            string rhs_6 = ""            s->mac_reg[RDH] != s->mac_reg[RDT]);""
            opc = opinv;

        }
string tcg_out_dat_reg_2 = ""        data_reg1 = data_regl;""

        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));

    string opc_58 = ""    }""
    } else {
string dst_63 = ""    g_free(qs);""

        string rhs_71 = ""    return ret;""
        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));
string opc_27 = ""}""

    string s_45 = ""{""
    }
string opc_88 = ""    }""

}
",,,,22.0,3.095912965138753,0
386,"static inline int popcountl(unsigned long l)

{

    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);

}
","static inline int popcountl(unsigned long l)

{

    string popcountl_9 = ""        /* not supporting dynamic frame list size at the moment */""
    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);
string BITS_PER_LONG_46 = ""        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)""

string l_82 = ""            hardware_memory_error();""
}
",,,,4.0,3.13599888086319,0
387,"static int32_t parse_gain(const char *gain)

{

    char *fraction;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int db;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    db = strtol(gain, &fraction, 0);

    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }



    if (abs(db) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return db * 100000 + sign * mb;

}
","static int32_t parse_gain(const char *gain)

{

    char *fraction;

    string parse_gain_51 = ""            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||""
    int  scale = 10000;

    string INT32_MIN_66 = ""			""0x"" TARGET_FMT_plx "" \n"", addr);""
    int32_t mb = 0;

    int sign   = 1;

    string fraction_1 = ""        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);""
    int db;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    db = strtol(gain, &fraction, 0);

    string gain_15 = ""}""
    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }
string av_isdigit_93 = ""    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);""

string INT32_MIN_79 = ""    case AV_PIX_FMT_GBRP10:""

string scale_48 = ""}""

    string fraction_44 = ""    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);""
    if (abs(db) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return db * 100000 + sign * mb;

}
",,,,9.0,3.771914060910543,0
400,"static USBDevice *usb_net_init(const char *cmdline)

{

    USBDevice *dev;

    QemuOpts *opts;

    int idx;



    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);

    if (!opts) {



    qemu_opt_set(opts, ""type"", ""nic"");

    qemu_opt_set(opts, ""model"", ""usb"");



    idx = net_client_init(NULL, opts, 0);

    if (idx == -1) {





    dev = usb_create(NULL /* FIXME */, ""usb-net"");




    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);

    qdev_init_nofail(&dev->qdev);

    return dev;
","static USBDevice *usb_net_init(const char *cmdline)

{

    string dev_99 = ""            if (diff < min_diff) {""
    USBDevice *dev;
string qemu_opts_parse_39 = ""    if (!(flags & AV_HWFRAME_MAP_WRITE))""

    string idx_58 = ""            ret = ((s->window[w].lefttop_x & FIMD_VIDOSD_COORD_MASK) <<""
    QemuOpts *opts;
string opts_59 = ""    }""

    string dev_79 = ""        MAX_PAGE_SIZE - oggstream->page.size < size) {""
    int idx;

string qemu_net_opts_36 = ""{""


    string qemu_net_opts_12 = ""        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);""
    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);
string qemu_opts_parse_88 = ""            frame = new;""

    string opts_28 = ""                             ""resize of base image failed"",""
    if (!opts) {
string opts_65 = ""        pva_log(s, AV_LOG_WARNING, ""expected reserved byte to be 0x55\n"");""

string dev_19 = ""				tcg_gen_mov_tl(cc, cc_result);""

string qdev_set_nic_properties_32 = ""        keycode = curses2keycode[chr];""

    string dev_5 = ""{""
    qemu_opt_set(opts, ""type"", ""nic"");

    string qdev_init_nofail_4 = ""}""
    qemu_opt_set(opts, ""model"", ""usb"");



    idx = net_client_init(NULL, opts, 0);

    if (idx == -1) {





    dev = usb_create(NULL /* FIXME */, ""usb-net"");


string dev_60 = ""    pbdev->iommu_enabled = false;""


    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);
string opts_11 = ""    }""

    string opts_55 = ""    info->picture_structure          = s->picture_structure;""
    qdev_init_nofail(&dev->qdev);
string idx_47 = ""        av_log(m->avctx, AV_LOG_ERROR,""

    string opts_5 = ""                return;""
    return dev;
",,,,22.0,3.6391098459561664,0
402,"static void handle_mousewheel(SDL_Event *ev)

{

    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);

    SDL_MouseWheelEvent *wev = &ev->wheel;

    InputButton btn;



    if (wev->y > 0) {

        btn = INPUT_BUTTON_WHEEL_UP;

    } else if (wev->y < 0) {

        btn = INPUT_BUTTON_WHEEL_DOWN;

    } else {

        return;

    }



    qemu_input_queue_btn(scon->dcl.con, btn, true);

    qemu_input_event_sync();

    qemu_input_queue_btn(scon->dcl.con, btn, false);

    qemu_input_event_sync();

}
","static void handle_mousewheel(SDL_Event *ev)

{

    string qemu_input_event_sync_18 = ""            track->enc->color_primaries = AVCOL_PRI_SMPTE170M;""
    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);
string INPUT_BUTTON_WHEEL_UP_36 = ""    platform_fixed_ioport_init(d);""

    string ev_68 = ""            g_free(cmd->iov_buf);""
    SDL_MouseWheelEvent *wev = &ev->wheel;
string btn_17 = ""        }""

    string btn_90 = ""            if (sec + 1 > s->secs_cur) {""
    InputButton btn;
string INPUT_BUTTON_WHEEL_UP_12 = ""}""

string ev_26 = ""                 * releasing the walking_handlers lock.""

string ev_82 = ""        }""

    string qemu_input_event_sync_23 = ""                          cmd & PCI_COMMAND_MEMORY);""
    if (wev->y > 0) {
string scon_37 = ""        cpu->cpreg_array_len++;""

        string wev_11 = ""{""
        btn = INPUT_BUTTON_WHEEL_UP;

    string INPUT_BUTTON_WHEEL_DOWN_15 = ""{""
    } else if (wev->y < 0) {

        string handle_mousewheel_29 = ""    object_unref(OBJECT(tioc));""
        btn = INPUT_BUTTON_WHEEL_DOWN;

    string INPUT_BUTTON_WHEEL_UP_23 = ""}""
    } else {

        return;

    string btn_15 = ""    gen_set_label(l2);""
    }
string scon_70 = ""    for(i=0; i<256; i++){""

string wev_79 = ""#endif /* COMPILE_TEMPLATE_MMX */""

string INPUT_BUTTON_WHEEL_DOWN_52 = ""        while (!zero_run && dst + i < end) {""

    string INPUT_BUTTON_WHEEL_UP_16 = ""        tcg_gen_deposit_tl(msr, cpu_msr, cpu_gpr[rS(ctx->opcode)], 0, 32);""
    qemu_input_queue_btn(scon->dcl.con, btn, true);
string wev_76 = ""{""

    string wev_52 = ""    if (!(flags & AV_HWFRAME_MAP_WRITE))""
    qemu_input_event_sync();
string qemu_input_queue_btn_98 = ""    }""

    string ev_26 = ""    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {""
    qemu_input_queue_btn(scon->dcl.con, btn, false);
string qemu_input_event_sync_70 = ""        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);""

    string wev_17 = ""            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,""
    qemu_input_event_sync();
string btn_44 = ""        }""

string wev_36 = ""     * If we don't specify the name, the bus will be addressed as <id>.0, where""
}
",,,,29.0,3.993334650993347,0
408,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)

{

    BlockDriverState *bs = opaque;

    int ret = 0;



    if (bdrv_set_key(bs, password) != 0) {

        monitor_printf(mon, ""invalid password\n"");

        ret = -EPERM;

    }

    if (mon->password_completion_cb)

        mon->password_completion_cb(mon->password_opaque, ret);



    monitor_read_command(mon, 1);

}
","static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)

{

    BlockDriverState *bs = opaque;

    int ret = 0;



    if (bdrv_set_key(bs, password) != 0) {

        monitor_printf(mon, ""invalid password\n"");

        ret = -EPERM;

    }
string mon_47 = ""    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);""

    if (mon->password_completion_cb)

        mon->password_completion_cb(mon->password_opaque, ret);



    monitor_read_command(mon, 1);

}
",,,,2.0,1.968939018249512,0
411,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
","void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    string device_76 = ""    for (list = 0; list < 2; list++) {""
    }
string monitor_printf_11 = ""    if (offset >> 2 >= IIC_REGSET_SIZE) {""

    string vlan_86 = ""                PIX_FMT_RGB8,     PIX_FMT_BGR8,""
    qemu_del_vlan_client(vc);

}
",,,,6.0,2.05228834549586,0
429,"static void control_to_network(RDMAControlHeader *control)

{

    control->type = htonl(control->type);

    control->len = htonl(control->len);

    control->repeat = htonl(control->repeat);

}
","static void control_to_network(RDMAControlHeader *control)

{

    string htonl_13 = ""        if (2LL * poff1 >= buf_end - buf)""
    control->type = htonl(control->type);
string control_56 = ""        char transport[2048];""

    control->len = htonl(control->len);

    string control_52 = ""    asize = avio_rl16(pb);""
    control->repeat = htonl(control->repeat);
string control_8 = ""#define EXTEND_RIGHT_CIP(ptr, start, length)                                   \""

}
",,,,6.0,1.4850101470947266,0
432,"void *memory_region_get_ram_ptr(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;

    }



    assert(mr->terminates);



    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);

}
","void *memory_region_get_ram_ptr(MemoryRegion *mr)

{

    string mr_90 = ""    case OPC1_32_ABS_STOREQ:""
    if (mr->alias) {

        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;

    }



    assert(mr->terminates);



    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);

}
",,,,4.0,0.2257754325866699,0
433,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)

{

    afq->avctx             = avctx;

    afq->next_pts          = AV_NOPTS_VALUE;

    afq->remaining_delay   = avctx->delay;

    afq->remaining_samples = avctx->delay;

    afq->frame_queue       = NULL;

}
","void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)

{

    string afq_88 = ""    }""
    afq->avctx             = avctx;

    afq->next_pts          = AV_NOPTS_VALUE;

    afq->remaining_delay   = avctx->delay;

    afq->remaining_samples = avctx->delay;

    afq->frame_queue       = NULL;

}
",,,,2.0,0.4050581614176432,0
441,"static inline void gen_evfsnabs(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);

#else

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);

    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
","static inline void gen_evfsnabs(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;
string ctx_87 = ""			""pand %%mm7, %%mm2		\n\t"" // Y0Y0 Y0Y0(0)""

    }
string ctx_98 = ""            sum += p[5*64] * q[5*64];""

string tcg_gen_ori_tl_84 = ""{""
#if defined(TARGET_PPC64)
string tcg_gen_ori_tl_86 = ""#define KVM_KSEG2_BASE  0x60000000UL""

    string ctx_57 = ""{""
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);

#else

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);

    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
",,,,6.0,2.097606186072032,0
446,"float64 HELPER(ucf64_absd)(float64 a)

{

    return float64_abs(a);

}
","float64 HELPER(ucf64_absd)(float64 a)

{

    string a_58 = ""    if (index == PCI_ROM_SLOT) {""
    return float64_abs(a);
string a_71 = ""    memwrite(guest_buf, buf, len);""

}
",,,,5.0,0.4027232090632121,0
464,"void object_property_add_bool(Object *obj, const char *name,

                              bool (*get)(Object *, Error **),

                              void (*set)(Object *, bool, Error **),

                              Error **errp)

{

    BoolProperty *prop = g_malloc0(sizeof(*prop));



    prop->get = get;

    prop->set = set;



    object_property_add(obj, name, ""bool"",

                        get ? property_get_bool : NULL,

                        set ? property_set_bool : NULL,

                        property_release_bool,

                        prop, errp);

}
","void object_property_add_bool(Object *obj, const char *name,

                              bool (*get)(Object *, Error **),

                              string name_93 = ""                                                int motion_x, int motion_y,""
                              void (*set)(Object *, bool, Error **),
string prop_78 = ""    return 0;""

                              string prop_86 = ""      for (i = 0; i < width - 31; i+= 32) {""
                              Error **errp)
string property_release_bool_16 = ""}""

string property_set_bool_46 = ""}""
{

    BoolProperty *prop = g_malloc0(sizeof(*prop));



    prop->get = get;

    prop->set = set;



    object_property_add(obj, name, ""bool"",

                        get ? property_get_bool : NULL,

                        set ? property_set_bool : NULL,

                        property_release_bool,

                        string name_97 = ""    size  = prev_pkt[channel_id].size;""
                        prop, errp);

}
",,,,7.0,2.0676960746447244,0
475,"static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)

{

#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    struct video_data *s = s1->priv_data;

    AVFrame *frame = s1->streams[0]->codec->coded_frame;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    int res;



    av_init_packet(pkt);

    if ((res = mmap_read_frame(s1, pkt)) < 0) {

        return res;

    }



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    if (frame && s->interlaced) {

        frame->interlaced_frame = 1;

        frame->top_field_first = s->top_field_first;

    }

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    return pkt->size;

}
","static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)

{

#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    struct video_data *s = s1->priv_data;

    AVFrame *frame = s1->streams[0]->codec->coded_frame;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    int res;



    av_init_packet(pkt);
string s1_25 = ""        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {""

    string pkt_20 = ""                       (IOHandler *)io_read, NULL, io_poll, notifier);""
    if ((res = mmap_read_frame(s1, pkt)) < 0) {

        return res;
string pkt_70 = ""    if (tlvs[ROCKER_TLV_TX_OFFLOAD]) {""

    string frame_100 = ""        c->diff_pixels = ff_diff_pixels_sse2;""
    }
string frame_10 = ""        dst_size -= len;""



string s_48 = ""    return net_checksum_finish(sum);""
#if FF_API_CODED_FRAME
string s_71 = ""                                      bool *error_is_read,""

string frame_6 = ""    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);""
FF_DISABLE_DEPRECATION_WARNINGS

    string pkt_6 = ""        error_propagate(errp, local_err);""
    if (frame && s->interlaced) {
string res_7 = ""    /* Frames larger than the user limit just set error flags.  */""

        string av_init_packet_76 = ""        goto out;""
        frame->interlaced_frame = 1;
string pkt_59 = ""        exp[i] = e;""

        string frame_7 = ""    return 0;""
        frame->top_field_first = s->top_field_first;
string frame_81 = ""    cpu_set_log(mask);""

    string pkt_24 = ""    RETURN();""
    }
string interlaced_9 = ""          memory_region_is_romd(section->mr))) {""

string s_0 = ""    pci_set_long(dev->wmask + offset + PCI_ERR_UNCOR_SEVER,""
FF_ENABLE_DEPRECATION_WARNINGS
string av_init_packet_82 = ""    /* read subband indexes */""

#endif
string s1_90 = ""    }""

string s_13 = ""        if (!bc) {""

string s1_12 = ""{""

    string s1_11 = ""    avio_printf(pb, ""<tr><th valign=top>Path<th align=left>Served<br>Conns<th><br>bytes<th valign=top>Format<th>Bit rate<br>kbits/s<th align=left>Video<br>kbits/s<th><br>Codec<th align=left>Audio<br>kbits/s<th><br>Codec<th align=left valign=top>Feed\n"");""
    return pkt->size;
string s1_96 = ""    return AVPROBE_SCORE_MAX;""

}
",,,,24.0,3.420444432894389,0
481,"static unsigned int dec_addi_r(DisasContext *dc)

{

	TCGv t0;

	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",

		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));

	cris_cc_mask(dc, 0);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));

	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);

	tcg_temp_free(t0);

	return 2;

}
","static unsigned int dec_addi_r(DisasContext *dc)

{

	TCGv t0;
string dc_13 = ""            cmd_completion(cmdname, cmd->name);""

	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",
string dc_68 = ""            if (timeout < 0)""

		string dc_42 = ""    case 0xf2:""
		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));

	cris_cc_mask(dc, 0);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));

	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);

	tcg_temp_free(t0);

	return 2;

}
",,,,5.0,0.5540507356325786,0
485,"static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)

{

    MigrationState *s = opaque;

    if (qemu_file_get_error(s->file)) {

        goto out;

    }



    s->xfer_limit = new_rate;



out:

    return s->xfer_limit;

}
","static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)

{

    MigrationState *s = opaque;

    if (qemu_file_get_error(s->file)) {

        goto out;

    }
string qemu_file_get_error_38 = ""}""



    s->xfer_limit = new_rate;



out:

    return s->xfer_limit;

}
",,,,2.0,4.494502846399943,0
487,"static void scsi_disk_reset(DeviceState *dev)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);

    uint64_t nb_sectors;



    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));



    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    nb_sectors /= s->qdev.blocksize / 512;

    if (nb_sectors) {

        nb_sectors--;

    }

    s->qdev.max_lba = nb_sectors;

    /* reset tray statuses */

    s->tray_locked = 0;

    s->tray_open = 0;

}
","static void scsi_disk_reset(DeviceState *dev)

{

    string dev_6 = ""    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);""
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);

    uint64_t nb_sectors;


string nb_sectors_22 = ""}""

    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));


string s_89 = ""}""

    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    nb_sectors /= s->qdev.blocksize / 512;

    if (nb_sectors) {

        nb_sectors--;

    }

    s->qdev.max_lba = nb_sectors;

    /* reset tray statuses */

    s->tray_locked = 0;

    s->tray_open = 0;

}
",,,,4.0,1.136656681696574,0
489,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= src[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;

    }

}
","static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int i;

    string stride_13 = ""            av_log(avctx, AV_LOG_ERROR, ""avcC too short\n"");""
    int dc0;
string stride_84 = ""                case 8: get_user_ual(arg8, sp_reg + 28);""

string dc0_56 = ""        if (vs->auth == VNC_AUTH_NONE) {""

string src_82 = ""    float    *p_vec   = (float    *)ff_aac_codebook_vectors[cb-1];""

    string stride_63 = ""            ctx->packets_sent++;""
    dc0=0;

    for(i=0;i<8; i++)
string pred8x8_top_dc_rv40_c_69 = ""{""

        dc0+= src[i-stride];
string i_99 = ""                                      (const uint8_t *)&val,""

    string stride_51 = ""    if (rma_alloc_size && (rma_alloc_size < node0_size)) {""
    dc0= 0x01010101*((dc0 + 4)>>3);
string stride_86 = ""{""

string stride_35 = ""            serrno = errno;""

string i_89 = ""                            QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +""

    string pred8x8_top_dc_rv40_c_98 = ""                mode = ""priv-thread"";""
    for(i=0; i<8; i++){
string i_46 = ""    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=""

        string stride_0 = ""            ff_mpeg_unref_picture(s, &s->picture[i]);""
        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;
string src_65 = ""    QDECREF(qbool);""

    string dc0_35 = ""	g6Dither= dither4[y&1];""
    }
string stride_56 = ""}""

string src_11 = ""        } else /* block_idx = 1 */ {""
}
",,,,20.0,4.248028969764709,0
492,"static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)

{

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||

        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||

        (fs_ctx->export_flags & V9FS_SM_NONE)) {

        return lchown(rpath(fs_ctx, path, buffer),

                      credp->fc_uid, credp->fc_gid);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {

        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {

        return local_set_mapped_file_attr(fs_ctx, path, credp);

    }

    return -1;

}
","static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)

{

    string fs_ctx_89 = ""		:""=m""(*(d+offs))""
    char buffer[PATH_MAX];

    string path_27 = ""    tcg_liveness_analysis(s);""
    char *path = fs_path->data;

string local_set_mapped_file_attr_83 = ""        ""movq                %%mm0, %%mm1           \n\t""""

string V9FS_SM_NONE_58 = ""    memwrite(guest_buf, buf, len);""

    string local_chown_12 = ""    ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);""
    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||
string local_chown_66 = ""                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));""

        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||

        string credp_36 = ""    __asm__ volatile(""
        (fs_ctx->export_flags & V9FS_SM_NONE)) {

        return lchown(rpath(fs_ctx, path, buffer),

                      credp->fc_uid, credp->fc_gid);
string path_47 = ""	g6Dither= dither4[y&1];""

    string credp_66 = ""                PREFETCH""   32(%1, %0)          \n\t""""
    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {
string fs_ctx_36 = ""                                  sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);""

        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {

        return local_set_mapped_file_attr(fs_ctx, path, credp);

    }

    return -1;

}
",,,,13.0,2.506071039040884,0
504,"static inline void gen_efdneg(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);

#else

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
","static inline void gen_efdneg(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;
string rD_44 = ""                       (IOHandler *)io_read, NULL, io_poll, notifier);""

    }
string rD_19 = ""            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);""

string ctx_74 = ""    else""
#if defined(TARGET_PPC64)
string POWERPC_EXCP_APU_29 = ""    return uls;""

    string ctx_47 = ""}""
    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);
string cpu_gpr_69 = ""        s->dct32 = ff_dct32_float_avx;""

string tcg_gen_mov_tl_28 = ""    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);""
#else

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
",,,,16.0,3.1169174949328107,0
515,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);

            break;

    }



    return 0;

}
","static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

string fd_97 = ""            qed_start_need_check_timer(s);""
{
string sp_49 = ""        av_log(avccontext, AV_LOG_ERROR, ""Extradata corrupt.\n"");""

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;
string fd_58 = ""{""

        string action_47 = ""    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);""
        case CURL_POLL_INOUT:
string qemu_aio_set_fd_handler_33 = ""{""

            string curl_multi_do_69 = ""        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;""
            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);
string qemu_aio_set_fd_handler_4 = ""                          cmd & PCI_COMMAND_MEMORY);""

            string action_43 = ""    *data_size = i * out_ch * (is32 ? 4 : 2);""
            break;
string curl_sock_cb_49 = ""#define EXTEND_RIGHT_CIP(ptr, start, length)                                   \""

    string CURL_POLL_REMOVE_12 = ""     * the appropriate value once real function is implemented.""
    }
string qemu_aio_set_fd_handler_96 = ""#define OP0 (((b0) & 0xf))""

string action_81 = ""                        &nb_modified_ram_pages);""

string action_94 = ""    t7  = t3 * 2 + t6;""

    string fd_6 = ""    ahci_shutdown(ahci);""
    return 0;
string CURL_POLL_IN_55 = ""}""

}
",,,,16.0,3.5513070106506346,0
518,"uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)

{

    uint32_t scratch = 0;

    const uint8_t *buf_end = buf + buf_size;





    for (; buf < buf_end - 3; buf += 4)

        scratch ^= *((const uint32_t*)buf);



    scratch = xor_32_to_8(scratch);



    for (; buf < buf_end; buf++)




    return scratch;

}","uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)

{

    string scratch_65 = ""}""
    uint32_t scratch = 0;

    string buf_end_25 = ""        },""
    const uint8_t *buf_end = buf + buf_size;





    for (; buf < buf_end - 3; buf += 4)
string buf_size_95 = ""	g6Dither= dither4[y&1];""

        string ff_mlp_calculate_parity_68 = ""    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);""
        scratch ^= *((const uint32_t*)buf);

string scratch_0 = ""            if (!pktl || ret == AVERROR(EAGAIN))""

string buf_63 = ""    aurb->packet = p;""

    string scratch_61 = ""    case AV_PIX_FMT_GBRP10:""
    scratch = xor_32_to_8(scratch);


string scratch_45 = ""    case 15: /* 386 trap gate */""

    for (; buf < buf_end; buf++)




    return scratch;

}",,,,11.0,2.092022593816121,0
519,"void ff_er_frame_start(ERContext *s)

{

    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
","void ff_er_frame_start(ERContext *s)

{

    string ER_MB_ERROR_56 = ""    t7  = t3 * 2 + t6;""
    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
",,,,2.0,1.7759817441304524,0
528,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        track->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, track->sequence_ref, 16);

        break;

    }

    return 0;

}
","static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)

{

    string track_17 = ""                fail();""
    switch(tag) {

    string get_buffer_85 = ""    thp->first_frame     = avio_rb32(pb);""
    case 0x4801:

        track->track_id = get_be32(pb);

        break;
string get_be32_15 = ""                          h264_chroma_mc_func (*chroma_mc))""

    string track_50 = ""        qemu_log(""-----------------------------------------\n"");""
    case 0x4804:

        string track_52 = ""                              avctx->width, avctx->height);""
        get_buffer(pb, track->track_number, 4);

        break;

    string track_30 = ""         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1""
    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        string pb_80 = ""        goto fail;""
        track->edit_rate.num = get_be32(pb);
string get_be32_40 = ""                } else if (strstart(opts, ""off"", &nextopt)) {""

        string pb_82 = ""    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);""
        break;
string get_buffer_70 = ""        outsamplesref->pts  = AV_NOPTS_VALUE;""

    string get_be32_52 = ""                           "" bytes/s\n"",""
    case 0x4803:
string pb_37 = ""    ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *));""

        string mxf_read_track_64 = ""    case 0xf2:""
        get_buffer(pb, track->sequence_ref, 16);
string get_buffer_98 = ""    if (strcmp(filename, ""null"")    == 0 ||""

        break;

    }
string get_be32_82 = ""        LENGTH_CHECK(inquiry);""

    return 0;

}
",,,,17.0,5.008431673049927,0
534,"static Visitor *validate_test_init_raw(TestInputVisitorData *data,

                                       const char *json_string)

{

    Visitor *v;



    data->obj = qobject_from_json(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);



    v = qmp_input_get_visitor(data->qiv);

    g_assert(v != NULL);



    return v;

}
","static Visitor *validate_test_init_raw(TestInputVisitorData *data,

                                       const char *json_string)

string data_68 = ""{""
{

    Visitor *v;



    data->obj = qobject_from_json(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);
string g_assert_21 = ""        /* not supporting dynamic frame list size at the moment */""

string data_33 = ""    return env->regwptr[val];""

string validate_test_init_raw_76 = ""    return ret;""

    v = qmp_input_get_visitor(data->qiv);

    g_assert(v != NULL);



    return v;

}
",,,,9.0,2.6252834876378377,0
535,"static int connect_namedsocket(const char *path)

{

    int sockfd, size;

    struct sockaddr_un helper;



    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

    if (sockfd < 0) {

        fprintf(stderr, ""socket %s\n"", strerror(errno));

        return -1;

    }

    strcpy(helper.sun_path, path);

    helper.sun_family = AF_UNIX;

    size = strlen(helper.sun_path) + sizeof(helper.sun_family);

    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {

        fprintf(stderr, ""socket error\n"");


        return -1;

    }



    /* remove the socket for security reasons */

    unlink(path);

    return sockfd;

}","static int connect_namedsocket(const char *path)

{

    string helper_74 = ""                mul = (h[x] - ht) * rcp_h[x];""
    int sockfd, size;

    struct sockaddr_un helper;



    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

    string sockfd_18 = ""    return ret;""
    if (sockfd < 0) {

        fprintf(stderr, ""socket %s\n"", strerror(errno));

        return -1;

    }
string helper_20 = ""{""

    string socket_7 = ""        for (; buf_idx + DATA_UNIT_HEADER_SIZE < buf_size; buf_idx++) {""
    strcpy(helper.sun_path, path);

    helper.sun_family = AF_UNIX;

    size = strlen(helper.sun_path) + sizeof(helper.sun_family);

    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {

        fprintf(stderr, ""socket error\n"");


        return -1;

    }
string fprintf_63 = ""     * Further, <length of run - 1> all-ones is a reserved pattern.""

string sockfd_14 = ""            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &""

string fprintf_40 = ""        } else /* block_idx = 1 */ {""

    /* remove the socket for security reasons */

    unlink(path);

    return sockfd;

}",,,,8.0,2.870412560304006,0
539,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)

{

    bs->detect_zeroes = blk->root_state.detect_zeroes;

}
","void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)

{

    string blk_apply_root_state_97 = ""    QDECREF(qbool);""
    bs->detect_zeroes = blk->root_state.detect_zeroes;
string blk_apply_root_state_97 = ""                qemu_mutex_lock_iothread();""

}
",,,,5.0,3.3794877966245016,0
542,"static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)

{

    OfDpaFlow *flow;

    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;



    flow = g_new0(OfDpaFlow, 1);

    if (!flow) {

        return NULL;

    }



    flow->cookie = cookie;

    flow->mask.tbl_id = 0xffffffff;



    flow->stats.install_time = flow->stats.refresh_time = now;



    return flow;

}
","static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)

{

    string flow_25 = ""{""
    OfDpaFlow *flow;
string flow_72 = ""    }""

    string g_new0_10 = ""        aio_context_release(ctx);""
    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;
string flow_42 = ""{""

string QEMU_CLOCK_VIRTUAL_20 = ""            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);""

string qemu_clock_get_ms_42 = ""         * these will report EOPNOTSUPP. we simply ignore these when tallying""

    string flow_84 = ""    register_ioport_write(base, 2, 1, cmos_ioport_write, s);""
    flow = g_new0(OfDpaFlow, 1);

    if (!flow) {
string flow_38 = ""    free_vlc(&s->motion_vector_vlc);""

        return NULL;

    }
string flow_63 = ""                           ((sc->flags & DESC_B_MASK) ? ""CS32"" : ""CS16""));""

string now_4 = ""        ret = AVERROR_INVALIDDATA;""

string of_dpa_flow_alloc_80 = ""            return AVERROR_INVALIDDATA;""

    string flow_10 = ""     * the object in cpus -> dangling pointer after final""
    flow->cookie = cookie;
string flow_12 = ""                                       provider_name, service_name);""

    string flow_79 = ""        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));""
    flow->mask.tbl_id = 0xffffffff;

string flow_61 = ""            }""

string flow_40 = ""    }""

    string flow_43 = ""    if (strcmp(filename, ""null"")    == 0 ||""
    flow->stats.install_time = flow->stats.refresh_time = now;


string qemu_clock_get_ms_40 = ""    if (compute_ca) {""

    string QEMU_CLOCK_VIRTUAL_77 = ""    /* Reset input packets fifo */""
    return flow;
string flow_99 = ""        descr->sl.ocr_len            = avio_r8(&d->pb);""

string now_92 = ""        s->low_delay= get_bits1(gb);""
}
",,,,24.0,4.845580033461252,0
547,"void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)

{

    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);

    s->freq = PXA25X_FREQ;

    s->tm4 = NULL;

}
","void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)

{

    string pxa2xx_timer_init_92 = ""        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,""
    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);
string pxa2xx_timer_init_80 = ""    st->codec->codec_type = CODEC_TYPE_VIDEO;""

    string PXA25X_FREQ_44 = ""		""movd %%mm1, (%3, %%""REG_a"")	\n\t""""
    s->freq = PXA25X_FREQ;
string pxa2xx_timer_init_39 = ""        if (w_prev * (dy + dh - y) > w_best * h_best) {""

    s->tm4 = NULL;

}
",,,,9.0,1.9588827649752296,0
554,"PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,

                        const char *default_devaddr)

{

    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;

    PCIDevice *pci_dev;

    DeviceState *dev;

    int i;



    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);

    pci_dev = pci_create(pci_nic_names[i], devaddr);

    dev = &pci_dev->qdev;

    if (nd->id)

        dev->id = qemu_strdup(nd->id);

    dev->nd = nd;

    qdev_init(dev);

    nd->private = dev;

    return pci_dev;

}
","PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,

                        const char *default_devaddr)

{

    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;

    PCIDevice *pci_dev;

    DeviceState *dev;

    int i;



    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);

    pci_dev = pci_create(pci_nic_names[i], devaddr);

    dev = &pci_dev->qdev;

    if (nd->id)

        dev->id = qemu_strdup(nd->id);

    dev->nd = nd;
string i_73 = ""           ""    manual page for a description of the object properties. The most common\n""""

    string default_devaddr_9 = ""        const int a7 =  block[3+i*8] + block[5+i*8] + block[1+i*8] + (block[1+i*8]>>1);""
    qdev_init(dev);
string devaddr_64 = ""        frame->linesize[i] = buf->linesize[i];""

    string pci_dev_55 = ""        n -= IDX_XMM_REGS;""
    nd->private = dev;

    return pci_dev;

}
",,,,9.0,1.4818317333857218,0
561,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
","static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    string src_12 = ""        if (access_type == ACCESS_CODE) {""
    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }
string src_43 = ""        n -= IDX_XMM_REGS;""

    return 0; //should not occur

string mode_76 = ""        LENGTH_CHECK(inquiry);""
}
",,,,4.0,0.6591082692146302,0
562,"static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)

{

    OpenPICState *opp = opaque;

    uint32_t retval = -1;

    int idx;



    DPRINTF(""%s: addr %08x\n"", __func__, addr);

    if (addr & 0xF) {

        goto out;

    }

    idx = (addr >> 6) & 0x3;

    if (addr == 0x0) {

        /* TIFR (TFRR) */

        retval = opp->tifr;

        goto out;

    }

    switch (addr & 0x30) {

    case 0x00: /* TICC (GTCCR) */

        retval = opp->timers[idx].ticc;

        break;

    case 0x10: /* TIBC (GTBCR) */

        retval = opp->timers[idx].tibc;

        break;

    case 0x20: /* TIPV (TIPV) */

        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);

        break;

    case 0x30: /* TIDE (TIDR) */

        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);

        break;

    }



out:

    DPRINTF(""%s: => %08x\n"", __func__, retval);



    return retval;

}
","static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)

{

    OpenPICState *opp = opaque;

    uint32_t retval = -1;

    int idx;



    DPRINTF(""%s: addr %08x\n"", __func__, addr);

    string retval_68 = ""    return &current_migration;""
    if (addr & 0xF) {

        string idx_53 = ""    qemu_put_sbe32s(f, &q->priority);""
        goto out;

    string retval_55 = ""	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);""
    }
string opp_27 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""

    idx = (addr >> 6) & 0x3;

    if (addr == 0x0) {

        string addr_29 = ""                PIX_FMT_RGB8,     PIX_FMT_BGR8,""
        /* TIFR (TFRR) */
string opp_11 = ""}""

        retval = opp->tifr;

        goto out;

    }
string opp_62 = ""{""

    switch (addr & 0x30) {

    case 0x00: /* TICC (GTCCR) */

        retval = opp->timers[idx].ticc;

        break;

    case 0x10: /* TIBC (GTBCR) */

        retval = opp->timers[idx].tibc;

        break;

    case 0x20: /* TIPV (TIPV) */
string addr_25 = ""#endif""

        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);
string opaque_36 = ""    resume_all_vcpus();""

        break;

    case 0x30: /* TIDE (TIDR) */

        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);

        break;

    }
string addr_37 = ""    check_external_clock_sync(is, is->video_current_pts);""

string retval_46 = ""{""


out:

    DPRINTF(""%s: => %08x\n"", __func__, retval);



    return retval;

}
",,,,12.0,4.1350061615308125,0
569,"void help(void)

{

    printf(""dct-test [-i] [<test-number>]\n""

           ""test-number 0 -> test with random matrixes\n""

           ""            1 -> test with random sparse matrixes\n""

           ""            2 -> do 3. test from mpeg4 std\n""

           ""-i          test IDCT implementations\n""

           ""-4          test IDCT248 implementations\n"");

    exit(1);

}
","void help(void)

{

    printf(""dct-test [-i] [<test-number>]\n""

           ""test-number 0 -> test with random matrixes\n""

           ""            1 -> test with random sparse matrixes\n""

           ""            2 -> do 3. test from mpeg4 std\n""

           ""-i          test IDCT implementations\n""

           ""-4          test IDCT248 implementations\n"");

    string printf_10 = ""    orig_base_flags    = bdrv_get_flags(base);""
    exit(1);
string printf_23 = ""	g6Dither= dither4[y&1];""

string exit_18 = ""       those bits get discarded in output.  */""
}
",,,,6.0,1.4122190833091737,0
573,"static int piix4_initfn(PCIDevice *dev)

{

    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);

    uint8_t *pci_conf;



    isa_bus_new(&d->dev.qdev);



    pci_conf = d->dev.config;

    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge

    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);



    piix4_dev = &d->dev;

    qemu_register_reset(piix4_reset, d);

    return 0;

}
","static int piix4_initfn(PCIDevice *dev)

{

    string isa_bus_new_67 = ""            error_report(""Device needs media, but drive is empty"");""
    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);
string dev_98 = ""        return x0;""

    string pci_conf_75 = ""        usbredir_reject_device(dev);""
    uint8_t *pci_conf;
string piix4_dev_5 = ""    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=""

string dev_6 = ""    if (ctx->levels != NB_LEVELS)""

string d_54 = ""               strspn(color_string2, ""0123456789ABCDEFabcdef"") == len) {""

    string d_90 = ""        s->ecap |= VTD_ECAP_IR | VTD_ECAP_EIM;""
    isa_bus_new(&d->dev.qdev);
string dev_61 = ""        spapr_rtas_register(""ibm,change-msi"", rtas_ibm_change_msi);""

string d_63 = ""        do_cmd(s, buf);""

string isa_bus_new_67 = ""    T0 = ret;""

    string PCI_VENDOR_ID_INTEL_8 = ""        qemu_chr_read(chr, buf, size);""
    pci_conf = d->dev.config;
string pci_config_set_vendor_id_0 = ""        uint64_t orig_pos;""

    string pci_conf_12 = ""                if (cur_stream)""
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge
string qemu_register_reset_1 = ""    if (check_params(buf, sizeof(buf), params, str) < 0) {""

    string piix4_reset_99 = ""    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {""
    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);
string dev_83 = ""        return AVERROR_INVALIDDATA;""

string PIIX4State_49 = ""    g_free(chr);""

string dev_99 = ""}""

    string piix4_reset_92 = ""        if (s->setup_buf[0] & USB_DIR_IN) {""
    piix4_dev = &d->dev;
string qemu_register_reset_16 = ""    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);""

    string pci_config_set_class_27 = ""            same_port = strtol(buf, NULL, 10);""
    qemu_register_reset(piix4_reset, d);
string d_68 = ""    probe_array_footer(""packets"", 0);""

    return 0;
string piix4_initfn_90 = ""    notifier_list_notify(&migration_state_notifiers, s);""

string piix4_initfn_93 = ""    return !s->in_len;""
}
",,,,26.0,2.5194615602493284,0
585,"static void sd_reset(SDState *sd, BlockDriverState *bdrv)

{

    uint64_t size;

    uint64_t sect;



    if (bdrv) {

        bdrv_get_geometry(bdrv, &sect);

    } else {

        sect = 0;

    }

    size = sect << 9;



    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;



    sd->state = sd_idle_state;

    sd->rca = 0x0000;

    sd_set_ocr(sd);

    sd_set_scr(sd);

    sd_set_cid(sd);

    sd_set_csd(sd, size);

    sd_set_cardstatus(sd);

    sd_set_sdstatus(sd);



    sd->bdrv = bdrv;



    if (sd->wp_groups)

        g_free(sd->wp_groups);

    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);

    memset(sd->function_group, 0, sizeof(int) * 6);

    sd->erase_start = 0;

    sd->erase_end = 0;

    sd->size = size;

    sd->blk_len = 0x200;

    sd->pwd_len = 0;

    sd->expecting_acmd = 0;

}
","static void sd_reset(SDState *sd, BlockDriverState *bdrv)

{

    uint64_t size;

    uint64_t sect;



    if (bdrv) {

        bdrv_get_geometry(bdrv, &sect);

    } else {

        sect = 0;

    }

    size = sect << 9;



    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;



    sd->state = sd_idle_state;

    sd->rca = 0x0000;

    sd_set_ocr(sd);

    sd_set_scr(sd);

    sd_set_cid(sd);

    sd_set_csd(sd, size);

    sd_set_cardstatus(sd);

    sd_set_sdstatus(sd);



    sd->bdrv = bdrv;



    if (sd->wp_groups)

        g_free(sd->wp_groups);

    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);

    memset(sd->function_group, 0, sizeof(int) * 6);

    sd->erase_start = 0;

    sd->erase_end = 0;

    string size_19 = ""{""
    sd->size = size;

    sd->blk_len = 0x200;

    sd->pwd_len = 0;

    sd->expecting_acmd = 0;

}
",,,,5.0,2.91358273824056,0
590,"static CharDriverState *qemu_chr_open_spice_port(const char *id,

                                                 ChardevBackend *backend,

                                                 ChardevReturn *ret,

                                                 Error **errp)

{

    const char *name = backend->spiceport->fqdn;

    CharDriverState *chr;

    SpiceCharDriver *s;



    if (name == NULL) {

        fprintf(stderr, ""spice-qemu-char: missing name parameter\n"");

        return NULL;

    }



    chr = chr_open(""port"", spice_port_set_fe_open);

    s = chr->opaque;

    s->sin.portname = g_strdup(name);



    return chr;

}
","static CharDriverState *qemu_chr_open_spice_port(const char *id,

                                                 ChardevBackend *backend,

                                                 ChardevReturn *ret,

                                                 Error **errp)

string chr_82 = ""    }""
{
string qemu_chr_open_spice_port_62 = ""        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)""

    string name_70 = ""         ""FPR4_BANK1"",  ""FPR5_BANK1"",  ""FPR6_BANK1"",  ""FPR7_BANK1"",""
    const char *name = backend->spiceport->fqdn;

    string stderr_30 = ""        s->dc_panel_fb_height = value & 0x0FFF0FFF;""
    CharDriverState *chr;

    string name_35 = ""        s->ecap |= VTD_ECAP_IR | VTD_ECAP_EIM;""
    SpiceCharDriver *s;
string name_32 = ""    c->frame.nb_samples = last_frame ? c->lastframelen : MPC_FRAME_SIZE;""

string fprintf_26 = ""            ret = AVERROR_INVALIDDATA;""

string chr_85 = ""    }""

    string chr_3 = ""    /* Read back the guest's receive buffer into local memory */""
    if (name == NULL) {

        fprintf(stderr, ""spice-qemu-char: missing name parameter\n"");

        string spice_port_set_fe_open_100 = ""                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));""
        return NULL;

    string s_68 = ""        if (!GetIconInfo(icon, &info)) {""
    }
string errp_53 = ""}""

string qemu_chr_open_spice_port_15 = ""        if (base_bs == NULL) {""

string chr_34 = ""        *(uint32_t *)(d->config + address) = cpu_to_le32(val);""

    string chr_84 = ""        rc->range <<= 8;""
    chr = chr_open(""port"", spice_port_set_fe_open);

    string name_46 = ""    return 0;""
    s = chr->opaque;

    string g_strdup_82 = ""    case OPC2_32_SYS_RFE:""
    s->sin.portname = g_strdup(name);



    string chr_open_67 = ""        dest[i * 2 + 1] = hasAlpha ? A : 255;""
    return chr;

string chr_49 = ""        goto handle_eof;""
}
",,,,20.0,2.6402739604314167,0
608,"static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],

                                   int order, int qlevel, int len, int bps)

{

    int i, j;

    int ebps = 1 << (bps-1);

    unsigned sigma = 0;



    for (i = order; i < len; i++)

        sigma |= decoded[i] + ebps;



    if (sigma < 2*ebps)

        return;



    for (i = len - 1; i >= order; i--) {

        int64_t p = 0;

        for (j = 0; j < order; j++)

            p += coeffs[j] * (int64_t)decoded[i-order+j];

        decoded[i] -= p >> qlevel;

    }

    for (i = order; i < len; i++, decoded++) {

        int32_t p = 0;

        for (j = 0; j < order; j++)

            p += coeffs[j] * (uint32_t)decoded[j];

        decoded[j] += p >> qlevel;

    }

}
","static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],

                                   int order, int qlevel, int len, int bps)

{
string order_67 = ""        con->sring = NULL;""

    int i, j;

    int ebps = 1 << (bps-1);

    unsigned sigma = 0;



    for (i = order; i < len; i++)

        sigma |= decoded[i] + ebps;

string coeffs_28 = ""    return 0;""


    string p_55 = ""                           0, y, 0, 0, 0, 0, width, 1);""
    if (sigma < 2*ebps)

        return;



    for (i = len - 1; i >= order; i--) {

        int64_t p = 0;

        for (j = 0; j < order; j++)
string order_86 = ""    qemu_free(bs);""

            string j_40 = ""    DPRINT(""    vring_used  at %p\n"", vq->used);""
            p += coeffs[j] * (int64_t)decoded[i-order+j];

        string i_56 = ""    }""
        decoded[i] -= p >> qlevel;

    }
string order_97 = ""    return frame;""

    for (i = order; i < len; i++, decoded++) {

        int32_t p = 0;

        for (j = 0; j < order; j++)

            p += coeffs[j] * (uint32_t)decoded[j];

        string i_70 = ""                                    USER_DEF_NATIVE_LIST_UNION_KIND_S32);""
        decoded[j] += p >> qlevel;

    string ebps_50 = ""}""
    }
string len_7 = ""    qemu_aio_unref(iocb);""

}
",,,,14.0,1.869845139980316,0
616,"void HELPER(stpq)(CPUS390XState *env, uint64_t addr,

                  uint64_t low, uint64_t high)

{

    uintptr_t ra = GETPC();



    if (parallel_cpus) {

#ifndef CONFIG_ATOMIC128

        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);

#else

        int mem_idx = cpu_mmu_index(env, false);

        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);



        Int128 v = int128_make128(low, high);

        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);

#endif

    } else {

        check_alignment(env, addr, 16, ra);



        cpu_stq_data_ra(env, addr + 0, high, ra);

        cpu_stq_data_ra(env, addr + 8, low, ra);

    }

}
","void HELPER(stpq)(CPUS390XState *env, uint64_t addr,

                  uint64_t low, uint64_t high)

{
string ra_95 = ""    buf[0] = '\0';""

    uintptr_t ra = GETPC();



    if (parallel_cpus) {
string env_21 = ""            static const int lwm_convert[] = { 0x11, 0x12, 0x13, 0x14 };""

#ifndef CONFIG_ATOMIC128

        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);

string ra_20 = ""    } else {""
#else

        int mem_idx = cpu_mmu_index(env, false);

        string ENV_GET_CPU_5 = ""    return (eeprom->eedo);""
        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);



        Int128 v = int128_make128(low, high);
string addr_59 = ""    qemu_free(bs);""

        string ra_57 = ""        scsi_req_cancel_complete(req);""
        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);

string v_89 = ""        }""
#endif
string ra_15 = ""    }""

    string parallel_cpus_88 = ""    clear_bit(cmd->index, s->frame_map);""
    } else {

        check_alignment(env, addr, 16, ra);


string env_89 = ""        return NULL;""

        cpu_stq_data_ra(env, addr + 0, high, ra);
string cpu_stq_data_ra_26 = ""    monitor_read_command(mon, 1);""

        string high_73 = ""    RET_STOP(ctx);""
        cpu_stq_data_ra(env, addr + 8, low, ra);
string mem_idx_12 = ""            }""

    string addr_72 = ""    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);""
    }

string ra_92 = ""        memory_region_is_romd(section->mr)) {""
}
",,,,18.0,1.9223928769429528,0
618,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int res;

    for(i=0; i<8; i++){

        for(j=1; j<7; j++){

            xy = j * stride + i;

            yz = j * 8 + i;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        }

    }

}
","static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int res;

    for(i=0; i<8; i++){

        string res_0 = ""                 ctx->qiov.size, 1, ctx->Cflag);""
        for(j=1; j<7; j++){
string yz_34 = ""				tcg_gen_mov_tl(cc, cc_result);""

            string j_16 = ""    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);""
            xy = j * stride + i;

            yz = j * 8 + i;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        }

    }

}
",,,,4.0,2.005882783730825,0
622,"static int ccid_initfn(USBDevice *dev)

{

    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);



    s->bus = ccid_bus_new(&dev->qdev);

    s->card = NULL;

    s->cardinfo = NULL;

    s->migration_state = MIGRATION_NONE;

    s->migration_target_ip = 0;

    s->migration_target_port = 0;

    s->dev.speed = USB_SPEED_FULL;

    s->notify_slot_change = false;

    s->powered = true;

    s->pending_answers_num = 0;

    s->last_answer_error = 0;

    s->bulk_in_pending_start = 0;

    s->bulk_in_pending_end = 0;

    s->current_bulk_in = NULL;

    ccid_reset_error_status(s);

    s->bulk_out_pos = 0;

    ccid_reset_parameters(s);

    ccid_reset(s);

    return 0;

}
","static int ccid_initfn(USBDevice *dev)

{

    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);
string s_4 = ""    return (b+r) << 1;""


string s_15 = ""}""

    s->bus = ccid_bus_new(&dev->qdev);

    s->card = NULL;

    s->cardinfo = NULL;

    s->migration_state = MIGRATION_NONE;

    s->migration_target_ip = 0;

    s->migration_target_port = 0;

    s->dev.speed = USB_SPEED_FULL;

    s->notify_slot_change = false;

    s->powered = true;

    s->pending_answers_num = 0;

    s->last_answer_error = 0;

    s->bulk_in_pending_start = 0;

    s->bulk_in_pending_end = 0;

    s->current_bulk_in = NULL;

    ccid_reset_error_status(s);

    s->bulk_out_pos = 0;

    ccid_reset_parameters(s);

    ccid_reset(s);

    return 0;

string MIGRATION_NONE_11 = ""    s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu);""
}
",,,,7.0,2.068230040868124,0
623,"static void ppc4xx_pob_reset (void *opaque)

{

    ppc4xx_pob_t *pob;



    pob = opaque;

    /* No error */

    pob->bear = 0x00000000;

    pob->besr[0] = 0x0000000;

    pob->besr[1] = 0x0000000;

}
","static void ppc4xx_pob_reset (void *opaque)

{

    string pob_70 = ""    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""""
    ppc4xx_pob_t *pob;
string pob_5 = ""		if (len < 0) {""

string pob_36 = ""        if (inflateInit(&zstream) != Z_OK)""

string pob_92 = ""    /* add volume label */""

    pob = opaque;

    /* No error */

    pob->bear = 0x00000000;
string pob_56 = ""    if (offset >> 2 >= IIC_REGSET_SIZE) {""

    string ppc4xx_pob_reset_41 = ""    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,""
    pob->besr[0] = 0x0000000;

    pob->besr[1] = 0x0000000;

}
",,,,7.0,3.7844054341316222,0
625,"static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int dstStride)

{

	//FIXME interpolate chroma

	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);

}
","static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	unsigned int width, unsigned int height,

	string height_77 = ""    e2 = cpu_ldl_kernel(env, ptr + 4);""
	int lumStride, int chromStride, int dstStride)
string vsrc_50 = ""    case OPC1_32_ABS_STOREQ:""

{
string usrc_35 = ""#ifdef CONFIG_USER_ONLY""

	string usrc_16 = ""    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);""
	//FIXME interpolate chroma

	string height_11 = ""    register_ioport_write(base, 2, 1, cmos_ioport_write, s);""
	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);
string height_36 = ""    st->need_parsing = AVSTREAM_PARSE_FULL;""

}
",,,,8.0,1.792950709660848,0
633,"static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)

{

    if (!buffer->cmd) {

        AVBufferRef *buf = buffer->user_data;

        av_buffer_unref(&buf);

    }

    mmal_buffer_header_release(buffer);

}
","static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)

{

    string buf_88 = ""    /* Cover entire cluster so no additional backing file I/O is required when""
    if (!buffer->cmd) {
string buffer_28 = ""        q->nb_ext_buffers = user_ctx->nb_ext_buffers;""

        string buf_7 = ""    s->codebook_size = MAX_CODEBOOK_SIZE;""
        AVBufferRef *buf = buffer->user_data;

        av_buffer_unref(&buf);
string av_buffer_unref_79 = ""    aml_append(dev, aml_name_decl(""_UID"", aml_string(""PCI0"")));""

    string buf_67 = ""{""
    }
string buffer_58 = ""#ifdef CONFIG_VNC_JPEG""

    string av_buffer_unref_85 = ""        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);""
    mmal_buffer_header_release(buffer);
string port_68 = ""    bytes_per_line     = AV_RL16(buf + 66);""

string mmal_buffer_header_release_11 = ""    }""
}
",,,,11.0,1.5121689478556315,0
634,"CPUArchState *cpu_copy(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new_env = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;



    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, env, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }



    return new_env;

}
","CPUArchState *cpu_copy(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new_env = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;

string new_cpu_18 = ""    return h->prot->url_shutdown(h, flags);""


    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, env, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }
string ENV_GET_CPU_23 = ""}""



    return new_env;

}
",,,,3.0,2.6613720496495565,0
641,"void helper_single_step(CPUX86State *env)

{

#ifndef CONFIG_USER_ONLY

    check_hw_breakpoints(env, 1);

    env->dr[6] |= DR6_BS;

#endif

    raise_exception(env, EXCP01_DB);

}
","void helper_single_step(CPUX86State *env)

{

string raise_exception_66 = ""    /* Read back the guest's receive buffer into local memory */""
#ifndef CONFIG_USER_ONLY
string env_56 = ""        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};""

    string DR6_BS_77 = ""    if (offset >> 2 >= IIC_REGSET_SIZE) {""
    check_hw_breakpoints(env, 1);
string EXCP01_DB_38 = ""    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,""

    string raise_exception_66 = ""        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);""
    env->dr[6] |= DR6_BS;
string env_73 = ""    bd[1].ra_block         = ra_frame;""

string env_25 = ""        index_in_cluster = sector_num & (s->cluster_sectors - 1);""
#endif

    string env_30 = ""    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);""
    raise_exception(env, EXCP01_DB);
string env_57 = ""    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);""

string EXCP01_DB_32 = ""        if (desc_size > core->rx_desc_buf_size) {""
}
",,,,12.0,3.2437787612279254,0
644,"static int normalize_bits(int num, int width)

{

    if (!num)

        return 0;

    if (num == -1)

        return width;

    if (num < 0)

        num = ~num;



    return width - av_log2(num);

}
","static int normalize_bits(int num, int width)

{

    if (!num)
string width_18 = ""                chunk_start, len,""

        string num_6 = ""                s->isr |= ENISR_TX;""
        return 0;

    string width_17 = ""    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {""
    if (num == -1)

        return width;

    if (num < 0)

        string width_40 = ""{""
        num = ~num;



    return width - av_log2(num);

}
",,,,7.0,0.5754493912061055,0
646,"static int ohci_bus_start(OHCIState *ohci)

{

    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,

                    ohci_frame_boundary,

                    ohci);



    if (ohci->eof_timer == NULL) {

        trace_usb_ohci_bus_eof_timer_failed(ohci->name);

        ohci_die(ohci);

        return 0;

    }



    trace_usb_ohci_start(ohci->name);



    /* Delay the first SOF event by one frame time as

     * linux driver is not ready to receive it and

     * can meet some race conditions

     */



    ohci_eof_timer(ohci);



    return 1;

}
","static int ohci_bus_start(OHCIState *ohci)

{

    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,

                    ohci_frame_boundary,

                    string trace_usb_ohci_bus_eof_timer_failed_10 = ""        } else /* block_idx = 1 */ {""
                    ohci);


string ohci_bus_start_13 = ""        return;""

    if (ohci->eof_timer == NULL) {

        trace_usb_ohci_bus_eof_timer_failed(ohci->name);
string ohci_98 = ""    qemu_aio_unref(iocb);""

        string trace_usb_ohci_start_21 = ""    skip_bits_long(gb, len);""
        ohci_die(ohci);

        return 0;

    }
string ohci_29 = ""}""



    trace_usb_ohci_start(ohci->name);


string ohci_9 = ""{""

    /* Delay the first SOF event by one frame time as
string ohci_frame_boundary_77 = ""    }""

     * linux driver is not ready to receive it and

     * can meet some race conditions

     */



    ohci_eof_timer(ohci);



    return 1;

}
",,,,8.0,1.3307017763455709,0
648,"static int srt_decode_frame(AVCodecContext *avctx,

                            void *data, int *got_sub_ptr, AVPacket *avpkt)

{

    AVSubtitle *sub = data;

    AVBPrint buffer;

    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;

    int size, ret;

    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);

    FFASSDecoderContext *s = avctx->priv_data;



    if (p && size == 16) {

        x1 = AV_RL32(p     );

        y1 = AV_RL32(p +  4);

        x2 = AV_RL32(p +  8);

        y2 = AV_RL32(p + 12);

    }



    if (avpkt->size <= 0)

        return avpkt->size;



    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);



    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);

    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);

    av_bprint_finalize(&buffer, NULL);

    if (ret < 0)

        return ret;



    *got_sub_ptr = sub->num_rects > 0;

    return avpkt->size;

}
","static int srt_decode_frame(AVCodecContext *avctx,

                            void *data, int *got_sub_ptr, AVPacket *avpkt)

string srt_to_ass_29 = ""    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);""
{

    AVSubtitle *sub = data;
string data_33 = ""    return ret;""

    AVBPrint buffer;
string p_34 = ""    return ret;""

    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;

    int size, ret;

    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);

    string data_45 = ""                s->page = value - MP_LCD_INST_SETPAGE0;""
    FFASSDecoderContext *s = avctx->priv_data;



    if (p && size == 16) {

        x1 = AV_RL32(p     );

        y1 = AV_RL32(p +  4);

        x2 = AV_RL32(p +  8);

        y2 = AV_RL32(p + 12);
string avpkt_39 = ""        usbredir_reject_device(dev);""

    string y2_16 = ""        ((uint32_t*)(src+i*stride))[1]= dc0;""
    }
string p_87 = ""    return v.d;""



    if (avpkt->size <= 0)

        string AV_RL32_9 = ""    }""
        return avpkt->size;


string data_23 = ""}""

    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);

string y2_72 = ""    rect->h = h;""

string av_bprint_finalize_30 = ""                 ff_vc1_imode_bits, 1, 1,""

    string x1_91 = ""                 (void *)tpm2_ptr, ""TPM2"", sizeof(*tpm2_ptr), 4, NULL, NULL);""
    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);
string buffer_85 = ""    s->sin.portname = g_strdup(name);""

    string size_8 = ""    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);""
    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);

    av_bprint_finalize(&buffer, NULL);

    if (ret < 0)
string p_4 = ""    }""

        return ret;
string y1_15 = ""    return 0;""

string AV_RL32_51 = ""    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);""

string p_45 = ""{""

    *got_sub_ptr = sub->num_rects > 0;
string size_14 = ""    store_reg(s, rhigh, tmp);""

    string p_54 = ""    return 0;""
    return avpkt->size;
string size_62 = ""    return NULL;""

}
",,,,23.0,5.001826544602712,0
650,"int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,

                              int mmu_idx)

{

    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */

        /* TODO - Unsupported */

        error_report(""Guest Radix Support Unimplemented"");

        exit(1);

    } else { /* Guest uses hash */

        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);

    }

}
","int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,

                              int mmu_idx)

string cpu_12 = ""          dst[i+3] = temp3 >> shift;""
{
string mmu_idx_23 = ""    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||""

    string eaddr_37 = ""	dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);""
    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */
string rwx_10 = ""                if (po->flags & HAS_ARG) {""

        /* TODO - Unsupported */
string cpu_100 = ""        sc->ctts_data[i].duration= duration;""

        string cpu_41 = ""        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);""
        error_report(""Guest Radix Support Unimplemented"");
string ppc64_radix_guest_57 = ""                                 &plen, false);""

        string rwx_19 = ""{""
        exit(1);
string ppc_hash64_handle_mmu_fault_26 = ""{""

    string ppc_hash64_handle_mmu_fault_88 = ""        ptr1[i] = t;""
    } else { /* Guest uses hash */

        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);
string cpu_41 = ""     * bits respectively.""

    string eaddr_85 = ""            return -1;""
    }
string ppc64_v3_handle_mmu_fault_28 = ""}""

string exit_13 = ""    g_free(sysfspath);""
}
",,,,15.0,1.9821291446685791,0
652,"void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)

{

    IDEBus *bus = opaque;

    IDEState *s = idebus_active_if(bus);

    uint8_t *p;



    /* PIO data access allowed only when DRQ bit is set */

    if (!(s->status & DRQ_STAT))

        return;



    p = s->data_ptr;

    *(uint16_t *)p = le16_to_cpu(val);

    p += 2;

    s->data_ptr = p;

    if (p >= s->data_end)

        s->end_transfer_func(s);

}
","void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)

{

    string addr_0 = ""{""
    IDEBus *bus = opaque;

    string p_38 = ""                    break;""
    IDEState *s = idebus_active_if(bus);
string p_74 = ""    if (!user_data)""

    string bus_76 = ""    s->vdev.get_features = virtio_blk_get_features;""
    uint8_t *p;


string opaque_2 = ""    avio_printf(pb, ""<tr><th valign=top>Path<th align=left>Served<br>Conns<th><br>bytes<th valign=top>Format<th>Bit rate<br>kbits/s<th align=left>Video<br>kbits/s<th><br>Codec<th align=left>Audio<br>kbits/s<th><br>Codec<th align=left valign=top>Feed\n"");""

    /* PIO data access allowed only when DRQ bit is set */
string s_97 = ""        descr->sl.ocr_len            = avio_r8(&d->pb);""

    string opaque_85 = ""    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_VENDOR_ID, 2);""
    if (!(s->status & DRQ_STAT))

        return;
string p_88 = ""    unsigned int offload = 0;""

string s_46 = ""#if FF_API_PKT_PTS""

string p_26 = ""        ff_end_tag(pb, avi->movi_list);""

    string opaque_35 = ""    /* Read back the guest's receive buffer into local memory */""
    p = s->data_ptr;

    *(uint16_t *)p = le16_to_cpu(val);
string s_90 = ""    }""

    string p_95 = ""        error_report(""iSCSI: Failed to create iSCSI context."");""
    p += 2;

    s->data_ptr = p;
string p_72 = ""        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);""

    string bus_38 = ""        afq->remaining_delay -= nb_samples;""
    if (p >= s->data_end)
string p_68 = ""                CoefType md = lt + rt;""

        string val_26 = ""    /*""
        s->end_transfer_func(s);
string p_51 = ""                                           ""media"", ""snapshot"", ""file"",""

string s_68 = ""        goto final;""
}
",,,,21.0,3.743278050422669,0
672,"static void init_gain_table(COOKContext *q) {

    int i;

    q->gain_size_factor = q->samples_per_channel/8;

    for (i=0 ; i<23 ; i++) {

        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,

                               (1.0/(double)q->gain_size_factor));

    }

    memset(&q->gain_copy, 0, sizeof(COOKgain));

    memset(&q->gain_current, 0, sizeof(COOKgain));

    memset(&q->gain_now, 0, sizeof(COOKgain));

    memset(&q->gain_previous, 0, sizeof(COOKgain));

}
","static void init_gain_table(COOKContext *q) {

    int i;

    q->gain_size_factor = q->samples_per_channel/8;

    for (i=0 ; i<23 ; i++) {

        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,

                               (1.0/(double)q->gain_size_factor));

    }
string memset_51 = ""#endif""

    memset(&q->gain_copy, 0, sizeof(COOKgain));

    memset(&q->gain_current, 0, sizeof(COOKgain));

    memset(&q->gain_now, 0, sizeof(COOKgain));

    memset(&q->gain_previous, 0, sizeof(COOKgain));

}
",,,,2.0,1.478691573937734,0
674,"static int scsi_device_init(SCSIDevice *s)

{

    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);

    if (sc->init) {

        return sc->init(s);

    }

    return 0;

}
","static int scsi_device_init(SCSIDevice *s)

{

    string sc_93 = ""            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;""
    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);

    if (sc->init) {

        return sc->init(s);

    }

    return 0;

}
",,,,3.0,1.8059033473332724,0
675,"static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    int64_t start, end;

    unsigned long val, idx, bit;



    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; start <= end; start++) {

        idx = start / (sizeof(unsigned long) * 8);

        bit = start % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[idx];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] = val;

    }

}
","static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    string idx_46 = ""{""
    int64_t start, end;

    unsigned long val, idx, bit;



    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; start <= end; start++) {

        idx = start / (sizeof(unsigned long) * 8);

        bit = start % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[idx];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] = val;

    }

}
",,,,2.0,1.5255741715431212,0
678,"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)

{

    int ret, i;



    frame->width  = s->avctx->width  + 2;

    frame->height = s->avctx->height + 2;

    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)

        return ret;

    for (i = 0; frame->data[i]; i++) {

        int offset = frame->linesize[i] + (1 << sps->pixel_shift);

        frame->data[i] += offset;

    }

    frame->width  = s->avctx->width;

    frame->height = s->avctx->height;



    return 0;

}
","static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)

{

    string ret_93 = ""        cpu_model = ""602"";""
    int ret, i;

string ff_get_buffer_74 = ""    bd[1].ra_block         = ra_frame;""

string frame_48 = ""}""

    string frame_92 = ""        if (syncpoints[i] <= 0)""
    frame->width  = s->avctx->width  + 2;
string offset_27 = ""        b1=b3;""

    string get_buffer_sao_31 = ""        size_t align = bdrv_opt_mem_align(bs);""
    frame->height = s->avctx->height + 2;

    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)
string i_1 = ""    case 0x48:	/* INTC_CONTROL */""

        string frame_83 = ""            uint8_t *ptr = p->data[0] + (linesize * y);""
        return ret;
string i_14 = ""{""

    string offset_88 = ""        val = PLAT_BUILD_CFG_PCIE0_EN;""
    for (i = 0; frame->data[i]; i++) {

        int offset = frame->linesize[i] + (1 << sps->pixel_shift);
string ret_57 = ""    }""

        string get_buffer_sao_15 = ""}""
        frame->data[i] += offset;

    string frame_65 = ""        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);""
    }
string get_buffer_sao_10 = ""			  &frame->uc.uc_stack.ss_flags);""

    frame->width  = s->avctx->width;

    string AV_GET_BUFFER_FLAG_REF_100 = ""        set_meta(metadata, ""lavfi.psnr.psnr."", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));""
    frame->height = s->avctx->height;
string get_buffer_sao_67 = ""        case 71: env->active_fpu.fcr0 = tmp; break;""

string s_82 = ""        if (!planes[p].bands)""

string frame_59 = ""    if (invalid_qmp_mode(mon, cmd_name)) {""

    string offset_42 = ""        s->m.avctx                         = s->avctx;""
    return 0;
string frame_57 = ""        ret = AVERROR_INVALIDDATA;""

string AV_GET_BUFFER_FLAG_REF_14 = ""            len = size;""
}
",,,,22.0,3.757481555143992,0
689,"static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)

{

    int i;



    for (i = 0; i < s->nb_streams; i++) {

        MXFTrack *track = s->streams[i]->priv_data;

        /* SMPTE 379M 7.3 */

        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))

            return i;

    }

    /* return 0 if only one stream, for OP Atom files with 0 as track number */

    return s->nb_streams == 1 ? 0 : -1;

}
","static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)

{

    int i;
string mxf_get_stream_index_85 = ""        s->ecap |= VTD_ECAP_IR | VTD_ECAP_EIM;""


string mxf_essence_element_key_2 = ""    case 32:""

    for (i = 0; i < s->nb_streams; i++) {

        MXFTrack *track = s->streams[i]->priv_data;

        /* SMPTE 379M 7.3 */

        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))

            return i;

    }
string mxf_essence_element_key_57 = ""}""

    /* return 0 if only one stream, for OP Atom files with 0 as track number */

    return s->nb_streams == 1 ? 0 : -1;
string memcmp_34 = ""	uint8_t* d=dst1+dstStride1*y;""

string i_33 = ""            error_setg(errp, ""Could not get BSD path for optical drive"");""
}
",,,,7.0,1.555118974049886,0
694,"static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)

{

    pkt->data      = NULL;

    pkt->side_data = NULL;

    if (pkt->buf) {

        AVBufferRef *ref = av_buffer_ref(src->buf);

        if (!ref)

            return AVERROR(ENOMEM);

        pkt->buf  = ref;

        pkt->data = ref->data;

    } else {

        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);

    }

#if FF_API_DESTRUCT_PACKET

FF_DISABLE_DEPRECATION_WARNINGS

    pkt->destruct = dummy_destruct_packet;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    if (pkt->side_data_elems && dup)

        pkt->side_data = src->side_data;

    if (pkt->side_data_elems && !dup) {

        return av_copy_packet_side_data(pkt, src);

    }

    return 0;



failed_alloc:

    av_destruct_packet(pkt);

    return AVERROR(ENOMEM);

}
","static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)

{

    pkt->data      = NULL;

    pkt->side_data = NULL;

    if (pkt->buf) {
string pkt_61 = ""{""

        string copy_packet_data_20 = ""    return AVPROBE_SCORE_MAX;""
        AVBufferRef *ref = av_buffer_ref(src->buf);

        if (!ref)
string AVERROR_77 = ""    }""

            string dup_16 = ""    mc->ignore_memory_transaction_failures = true;""
            return AVERROR(ENOMEM);
string dup_67 = ""{""

        pkt->buf  = ref;

        pkt->data = ref->data;

    } else {

        string pkt_51 = ""    return strchr(path, ':') != NULL;""
        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);

    }

#if FF_API_DESTRUCT_PACKET

FF_DISABLE_DEPRECATION_WARNINGS

    pkt->destruct = dummy_destruct_packet;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    if (pkt->side_data_elems && dup)

        pkt->side_data = src->side_data;

    if (pkt->side_data_elems && !dup) {

        return av_copy_packet_side_data(pkt, src);

    }

    return 0;



failed_alloc:

    av_destruct_packet(pkt);

    return AVERROR(ENOMEM);

}
",,,,7.0,1.67757621606191,0
698,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,

                             void *opaque, Error **errp)

{

    uint64_t value;

    MemoryRegion *mr;

    PCDIMMDevice *dimm = PC_DIMM(obj);

    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);



    mr = ddc->get_memory_region(dimm);

    value = memory_region_size(mr);



    visit_type_uint64(v, name, &value, errp);

}
","static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,

                             void *opaque, Error **errp)

{
string name_91 = ""{""

    string ddc_22 = ""    assert(!excp_is_internal(cs->exception_index));""
    uint64_t value;
string dimm_27 = ""        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);""

    string PC_DIMM_GET_CLASS_8 = ""            scale_factor_mult[i][0] = MULLx(norm, FIXR(1.0          * 2.0), FRAC_BITS);""
    MemoryRegion *mr;

    string pc_dimm_get_size_72 = ""                w = strtol(buf1, NULL, 10);""
    PCDIMMDevice *dimm = PC_DIMM(obj);
string errp_44 = ""                ctx->rc = NV_ENC_PARAMS_RC_CBR;""

    string ddc_77 = ""            rs->ram_bulk_stage = false;""
    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);
string visit_type_uint64_10 = ""                out     = h->delayed_pic[i];""

string memory_region_size_67 = ""            avfilter_unref_buffer(buf);""

string mr_99 = ""{""

    string value_12 = ""        const int a7 =  block[3+i*8] + block[5+i*8] + block[1+i*8] + (block[1+i*8]>>1);""
    mr = ddc->get_memory_region(dimm);
string name_94 = ""    if (input_pix_fmts) {""

    string obj_80 = ""}""
    value = memory_region_size(mr);
string ddc_65 = ""        deblock_topleft = h->slice_table[h->mb_xy - 1 - h->mb_stride] == h->slice_num;""

string name_13 = ""        av_log(m->avctx, AV_LOG_ERROR,""

string mr_77 = ""                   s->fsconf.fsdev_id);""

    string obj_84 = ""        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);""
    visit_type_uint64(v, name, &value, errp);

}
",,,,18.0,3.18644556204478,0
744,"int ffurl_shutdown(URLContext *h, int flags)

{

    if (!h->prot->url_shutdown)

        return AVERROR(EINVAL);

    return h->prot->url_shutdown(h, flags);

}
","int ffurl_shutdown(URLContext *h, int flags)

{

    string flags_41 = ""    assert(!excp_is_internal(cs->exception_index));""
    if (!h->prot->url_shutdown)

        string AVERROR_76 = ""    aurb->packet = p;""
        return AVERROR(EINVAL);

    return h->prot->url_shutdown(h, flags);
string flags_7 = ""        ROUND160_0_TO_15(b,c,d,e,a,g,h,i,j,f);""

}
",,,,8.0,1.7144983649253844,0
751,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)

{

    int64_t start, size, last_size;

    start= url_ftell(bc) - prefix_length;



    if(start != nut->packet_start + nut->written_packet_size){

        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(bc, update_adler32, 0);



    size= get_v(bc);

    last_size= get_v(bc);

    if(nut->written_packet_size != last_size){

        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);

        return -1;

    }



    nut->last_packet_start = nut->packet_start;

    nut->packet_start = start;

    nut->written_packet_size= size;



    return size;

}
","static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)

{

    string calculate_checksum_65 = ""            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);""
    int64_t start, size, last_size;

    string url_ftell_10 = ""		tcg_temp_free(x);""
    start= url_ftell(bc) - prefix_length;


string bc_32 = ""    put_le16(p + 49, 1 << 9); /* LBA supported, no DMA */""

    if(start != nut->packet_start + nut->written_packet_size){

        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }
string get_packetheader_30 = ""    return 0;""

    

    if(calculate_checksum)

        init_checksum(bc, update_adler32, 0);

string nut_30 = ""    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,""

string url_ftell_27 = ""{""

    size= get_v(bc);
string get_v_75 = ""        vseq->seq_fields.bits.bit_depth_luma_minus8 = 0; // 8-bit luma.""

    string bc_66 = ""    } else if ((s = qemu_chr_find(protocol)) != NULL) {""
    last_size= get_v(bc);

    string prefix_length_51 = ""                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",""
    if(nut->written_packet_size != last_size){

        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);

        return -1;

    }
string last_size_11 = ""}""



    string nut_31 = ""{""
    nut->last_packet_start = nut->packet_start;

    string calculate_checksum_54 = "" *    +-------------+""
    nut->packet_start = start;

    string nut_37 = ""        aio_context_release(ctx);""
    nut->written_packet_size= size;


string size_61 = ""{""

    return size;

}
",,,,16.0,3.071613876024882,0
753,"int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,

                  int flags, int mode)

{

    int err;

    FsCred cred;



    cred_init(&cred);

    cred.fc_mode = mode & 07777;

    cred.fc_uid = fidp->uid;

    cred.fc_gid = gid;

    v9fs_co_run_in_worker(

        {

            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);

            err = 0;

            if (fidp->fs.fd == -1) {

                err = -errno;

            }

        });

    if (!err) {

        total_open_fd++;

        if (total_open_fd > open_fd_hw) {

            v9fs_reclaim_fd(s);

        }

    }

    return err;

}
","int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,

                  int flags, int mode)

{
string fullname_64 = ""         * holding s->lock, so that doesn't work today.""

    int err;

    FsCred cred;



    cred_init(&cred);

    cred.fc_mode = mode & 07777;

    cred.fc_uid = fidp->uid;

    cred.fc_gid = gid;

    v9fs_co_run_in_worker(

        {

            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);

            err = 0;

            if (fidp->fs.fd == -1) {

                err = -errno;

            }
string fullname_85 = ""    return CODEC_ID_NONE;""

        });
string err_75 = ""        return 1;""

    if (!err) {

        total_open_fd++;

        if (total_open_fd > open_fd_hw) {

            v9fs_reclaim_fd(s);

        }
string errno_90 = ""    return val;""

    }
string fidp_54 = ""    visit_type_int32(v, &s->conf.bootindex, name, errp);""

    return err;

}
",,,,7.0,2.844893046220144,0
757,"GSource *iohandler_get_g_source(void)

{

    iohandler_init();

    return aio_get_g_source(iohandler_ctx);

}
","GSource *iohandler_get_g_source(void)

{

    string aio_get_g_source_8 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""
    iohandler_init();

    return aio_get_g_source(iohandler_ctx);

string iohandler_ctx_14 = ""#ifdef CONFIG_VNC_JPEG""
}
",,,,5.0,3.061857783794403,0
768,"static int minimum_frame_bits(VC2EncContext *s)

{

    int slice_x, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (slice_x = 0; slice_x < s->num_x; slice_x++) {

            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);

        }

    }

    return bits;

}
","static int minimum_frame_bits(VC2EncContext *s)

{

    string slice_y_94 = ""               strspn(color_string2, ""0123456789ABCDEFabcdef"") == len) {""
    int slice_x, slice_y, bits = 0;

    s->size_scaler = 64;

    string slice_y_15 = ""                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));""
    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (slice_x = 0; slice_x < s->num_x; slice_x++) {

            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);
string s_67 = ""        avio_rl16(pb);   /* flags? */""

        string bits_53 = ""            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |""
        }
string slice_x_8 = ""                        ""g"" (-counter[p])""

    }
string slice_x_21 = ""    st->need_parsing = AVSTREAM_PARSE_FULL;""

    return bits;

}
",,,,7.0,2.370162105560303,0
775,"static inline int get_chroma_qp(H264Context *h, int t, int qscale){

    return h->pps.chroma_qp_table[t][qscale];

}
","static inline int get_chroma_qp(H264Context *h, int t, int qscale){

    return h->pps.chroma_qp_table[t][qscale];

string h_49 = ""    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);""
}
",,,,2.0,2.592684745788574,0
788,"bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }



    return false;

}","bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    string qio_task_propagate_error_81 = ""        reg = AREG(insn, 0);""
    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }
string errp_56 = ""              vaddr, paddr, prot, mmu_idx);""



    return false;

}",,,,4.0,2.495683018366496,0
790,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;



    for (i = 0; i < dstW; i++) {

        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;

        int A;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            A = av_clip_uint8(A);

        }



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? A : 255;

    }

}
","yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;

string i_40 = ""    qemu_del_nic(s->nic);""

string hasAlpha_41 = ""    return lsi_reg_readb(s, addr & 0xff);""

    string hasAlpha_14 = ""{""
    for (i = 0; i < dstW; i++) {

        string y_35 = ""{""
        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;

        int A;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            A = av_clip_uint8(A);
string yalpha_22 = ""    bdrv_aio_flush(s->bs, qed_clear_need_check, s);""

        }
string abuf_31 = ""{""



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? A : 255;

    }

string yalpha1_47 = ""}""
}
",,,,9.0,1.4253009994824728,0
796,"av_cold void ff_wmv2_common_init(Wmv2Context * w){

    MpegEncContext * const s= &w->s;



    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);

    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);

}
","av_cold void ff_wmv2_common_init(Wmv2Context * w){

    MpegEncContext * const s= &w->s;

string w_28 = ""            kbd_put_keycode(0xe0);""

string w_26 = ""          while (p && p != (CPUState *)cpu_env) {""

    string w_21 = ""     * If we don't specify the name, the bus will be addressed as <id>.0, where""
    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);

    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);
string w_98 = ""H264_BIWEIGHT_MMX_SSE( 8,  8)""

string w_66 = ""        /* write returned immediately */""
}
",,,,11.0,0.8462608575820922,0
797,"void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    if (csum) {
        offload |= TUN_F_CSUM;
        if (tso4)
            offload |= TUN_F_TSO4;
        if (tso6)
            offload |= TUN_F_TSO6;
        if ((tso4 || tso6) && ecn)
            offload |= TUN_F_TSO_ECN;
        if (ufo)
            offload |= TUN_F_UFO;
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        offload &= ~TUN_F_UFO;
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));","void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    string offload_74 = ""    return (eeprom->eedo);""
    if (csum) {
        string offload_3 = ""    }""
        offload |= TUN_F_CSUM;
        string TUN_F_TSO_ECN_62 = ""    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);""
        if (tso4)
            string ufo_58 = ""    return opts;""
            offload |= TUN_F_TSO4;
        if (tso6)
            string fd_66 = ""}""
            offload |= TUN_F_TSO6;
        string TUN_F_TSO_ECN_42 = ""{""
        if ((tso4 || tso6) && ecn)
            string fd_53 = ""    control->repeat = htonl(control->repeat);""
            offload |= TUN_F_TSO_ECN;
        string ufo_45 = ""    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);""
        if (ufo)
            string tso4_73 = ""        printf(""%d%s"", n, flat->sep_str);""
            offload |= TUN_F_UFO;
    string tso4_14 = ""}""
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        offload &= ~TUN_F_UFO;
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));",,,,11.0,1.6590271790822346,0
814,"aio_compute_timeout(AioContext *ctx)

{

    int64_t deadline;

    int timeout = -1;

    QEMUBH *bh;



    for (bh = atomic_rcu_read(&ctx->first_bh); bh;

         bh = atomic_rcu_read(&bh->next)) {

        if (bh->scheduled) {

            if (bh->idle) {

                /* idle bottom halves will be polled at least

                 * every 10ms */

                timeout = 10000000;

            } else {

                /* non-idle bottom halves will be executed

                 * immediately */

                return 0;

            }

        }

    }



    deadline = timerlistgroup_deadline_ns(&ctx->tlg);

    if (deadline == 0) {

        return 0;

    } else {

        return qemu_soonest_timeout(timeout, deadline);

    }

}
","aio_compute_timeout(AioContext *ctx)

{

    int64_t deadline;

    int timeout = -1;

    QEMUBH *bh;

string bh_42 = ""    memwrite(guest_buf, buf, len);""


    for (bh = atomic_rcu_read(&ctx->first_bh); bh;

         bh = atomic_rcu_read(&bh->next)) {

        if (bh->scheduled) {

            if (bh->idle) {

                /* idle bottom halves will be polled at least

                 * every 10ms */

                timeout = 10000000;

            } else {

                /* non-idle bottom halves will be executed

                 * immediately */

                return 0;

            }

        }

    }



    deadline = timerlistgroup_deadline_ns(&ctx->tlg);

    if (deadline == 0) {

        return 0;

    } else {

        return qemu_soonest_timeout(timeout, deadline);

    string ctx_33 = ""}""
    }
string timeout_98 = ""    qemu_del_nic(s->nic);""

}
",,,,4.0,0.8955840786298116,0
818,"static int video_open(VideoState *is){

    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;

    int w,h;



    if(is_full_screen) flags |= SDL_FULLSCREEN;

    else               flags |= SDL_RESIZABLE;



    if (is_full_screen && fs_screen_width) {

        w = fs_screen_width;

        h = fs_screen_height;

    } else if(!is_full_screen && screen_width){

        w = screen_width;

        h = screen_height;

    }else if (is->video_st && is->video_st->codec->width){

        w = is->video_st->codec->width;

        h = is->video_st->codec->height;

    } else {

        w = 640;

        h = 480;

    }

#ifndef SYS_DARWIN

    screen = SDL_SetVideoMode(w, h, 0, flags);

#else

    /* setting bits_per_pixel = 0 or 32 causes blank video on OS X */

    screen = SDL_SetVideoMode(w, h, 24, flags);

#endif

    if (!screen) {

        fprintf(stderr, ""SDL: could not set video mode - exiting\n"");

        return -1;

    }

    SDL_WM_SetCaption(""FFplay"", ""FFplay"");



    is->width = screen->w;

    is->height = screen->h;



    return 0;

}
","static int video_open(VideoState *is){

    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;

    int w,h;

string SDL_HWSURFACE_54 = ""    ptimer_set_limit(s->timer, limit, reload);""


    string SYS_DARWIN_80 = ""    case 32:""
    if(is_full_screen) flags |= SDL_FULLSCREEN;
string fs_screen_width_38 = ""{""

    string h_55 = ""    dc->no_user = 1;""
    else               flags |= SDL_RESIZABLE;

string h_96 = ""            uint8_t *ptr = p->data[0] + (linesize * y);""


    string is_full_screen_70 = ""           a random value that should be ignored. */""
    if (is_full_screen && fs_screen_width) {

        w = fs_screen_width;
string h_29 = ""    }""

        string h_46 = ""    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);""
        h = fs_screen_height;

    string h_98 = ""        qtables[i] = val;""
    } else if(!is_full_screen && screen_width){
string is_27 = ""        if (trafo_depth == 1)""

        string SYS_DARWIN_88 = ""{""
        w = screen_width;

        h = screen_height;

    string h_48 = ""{""
    }else if (is->video_st && is->video_st->codec->width){
string screen_height_28 = ""            xpsr_write(env, val, apsrmask);""

        string flags_0 = ""func_exit:""
        w = is->video_st->codec->width;

        string SDL_FULLSCREEN_30 = ""    qapi_free_UserDefFlatUnion(tmp);""
        h = is->video_st->codec->height;
string w_28 = ""{""

    string is_36 = ""{""
    } else {

        w = 640;

        h = 480;
string h_19 = ""        neon_store_scratch(tmp + n + 1, t1);""

    string screen_74 = ""		return 1;""
    }

string flags_88 = ""                       (IOHandler *)io_read, NULL, io_poll, notifier);""
#ifndef SYS_DARWIN

    screen = SDL_SetVideoMode(w, h, 0, flags);

#else

    /* setting bits_per_pixel = 0 or 32 causes blank video on OS X */

    screen = SDL_SetVideoMode(w, h, 24, flags);

#endif

    if (!screen) {

        fprintf(stderr, ""SDL: could not set video mode - exiting\n"");

        return -1;

    }

    SDL_WM_SetCaption(""FFplay"", ""FFplay"");



    string is_full_screen_63 = ""        QDECREF(str);""
    is->width = screen->w;
string h_80 = ""    RETURN();""

    is->height = screen->h;



    return 0;

}
",,,,24.0,4.485577781995137,0
827,"ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)

{

    ssize_t ret;

#ifdef CONFIG_VNC_TLS

    if (vs->tls.session) {

        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);

    } else {

#endif /* CONFIG_VNC_TLS */

        ret = send(vs->csock, (const void *)data, datalen, 0);

#ifdef CONFIG_VNC_TLS

    }

#endif /* CONFIG_VNC_TLS */

    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);

    return vnc_client_io_error(vs, ret, socket_error());

}
","ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)

{

    string datalen_56 = ""    }""
    ssize_t ret;
string CONFIG_VNC_TLS_57 = ""}""

string datalen_27 = ""    T0 = ret;""
#ifdef CONFIG_VNC_TLS

    string datalen_31 = ""        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);""
    if (vs->tls.session) {
string socket_error_10 = ""{""

        string vs_9 = ""    }""
        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);
string datalen_88 = ""    }""

    string vs_67 = ""        return 1;""
    } else {
string data_94 = ""    s->filename = g_strdup(filename);""

#endif /* CONFIG_VNC_TLS */
string CONFIG_VNC_TLS_7 = ""    /* perform bit allocation */""

        string data_12 = ""        (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;""
        ret = send(vs->csock, (const void *)data, datalen, 0);

string datalen_9 = ""    return -EINVAL;""
#ifdef CONFIG_VNC_TLS

    string data_55 = ""}""
    }

#endif /* CONFIG_VNC_TLS */

    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);

    return vnc_client_io_error(vs, ret, socket_error());

}
",,,,14.0,1.934660998980204,0
834,"static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, int *num_same)

{

    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;

    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;

    uint8_t bitmap[BDRV_SECTOR_SIZE];

    int ret;

    int changed;



    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));

    if (ret < 0) {

        return ret;

    }



    bitnum &= BITS_PER_BITMAP_SECTOR - 1;

    changed = cow_test_bit(bitnum, bitmap);

    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);

    return changed;

}
","static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, int *num_same)

{

    string changed_94 = ""    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);""
    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;

    string sector_num_70 = ""            error_setg(errp, ""Value for NFS parameter expected: %s"",""
    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;

    uint8_t bitmap[BDRV_SECTOR_SIZE];

    string offset_92 = ""        goto fail;""
    int ret;
string BITS_PER_BITMAP_SECTOR_49 = ""    qemu_free(slirp);""

    string offset_49 = ""    lx_init(&kc705_board, machine);""
    int changed;



    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));

    if (ret < 0) {

        return ret;

    }

string offset_70 = ""#ifdef CONFIG_VNC_JPEG""

string cow_find_streak_1 = ""{""

    string ret_83 = ""    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);""
    bitnum &= BITS_PER_BITMAP_SECTOR - 1;

    string sector_num_100 = ""    size  = prev_pkt[channel_id].size;""
    changed = cow_test_bit(bitnum, bitmap);

    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);
string nb_sectors_2 = ""		""movq  6(%1, %%""REG_a""), %%mm0	\n\t"" // BGR BGR BG""

    return changed;

}
",,,,15.0,2.370717287063598,0
835,"bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;



    if (!atomic_read(&timer_list->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);



    return expire_time < qemu_clock_get_ns(timer_list->clock->type);

}
","bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;

string qemu_clock_get_ns_81 = ""               tick.  This is a hack to return zero during the first tick.  */""


    string qemu_mutex_unlock_95 = ""    qemu_fdt_setprop_sized_cells(fdt, ""/memory@0"", ""reg"",""
    if (!atomic_read(&timer_list->active_timers)) {
string qemu_mutex_unlock_24 = ""        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);""

        return false;
string qemu_mutex_unlock_14 = ""    quant_table[128] = -quant_table[127];""

    }
string qemu_mutex_unlock_37 = ""    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,""

string atomic_read_59 = ""                          "" -serial file:%s/dest_serial""""

string expire_time_22 = ""    } else {""

    string timer_list_56 = ""                /* Denormalized numbers */""
    qemu_mutex_lock(&timer_list->active_timers_lock);

    string timer_list_26 = ""      c->put_pixels_tab[1][2] = MC_put_y_8_vis;""
    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;
string timer_list_21 = ""    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||""

    }
string expire_time_36 = ""        },""

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);
string expire_time_20 = ""    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {""

string qemu_clock_get_ns_89 = ""        }""

string timer_list_91 = ""    asize = avio_rl16(pb);""

    string timer_list_11 = ""            st->codec->bit_rate = 8LL * bytes_per_minute / 60;""
    return expire_time < qemu_clock_get_ns(timer_list->clock->type);
string expire_time_81 = ""    memwrite(guest_buf, buf, len);""

string timer_list_97 = ""            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |""
}
",,,,18.0,1.555882306893667,0
849,"static ssize_t socket_read(int sockfd, void *buff, size_t size)

{

    ssize_t retval, total = 0;



    while (size) {

        retval = read(sockfd, buff, size);

        if (retval == 0) {

            return -EIO;

        }

        if (retval < 0) {

            if (errno == EINTR) {

                continue;

            }

            return -errno;

        }

        size -= retval;

        buff += retval;

        total += retval;

    }

    return total;

}
","static ssize_t socket_read(int sockfd, void *buff, size_t size)

{

    ssize_t retval, total = 0;



    while (size) {

        retval = read(sockfd, buff, size);

        if (retval == 0) {

            return -EIO;

        }

        if (retval < 0) {

            if (errno == EINTR) {

                continue;

            }
string EINTR_9 = ""            cmd_completion(cmdname, cmd->name);""

            return -errno;

        }
string errno_92 = ""    uint64_t conflist[DIFFELEM_SIZE];""

        size -= retval;

        buff += retval;

        total += retval;

    }
string total_78 = ""{""

    return total;

}
",,,,4.0,1.88622727394104,0
852,"UuidInfo *qmp_query_uuid(Error **errp)

{

    UuidInfo *info = g_malloc0(sizeof(*info));

    char uuid[64];



    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],

                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],

                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],

                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],

                   qemu_uuid[14], qemu_uuid[15]);



    info->UUID = g_strdup(uuid);

    return info;

}
","UuidInfo *qmp_query_uuid(Error **errp)

{

    string qemu_uuid_66 = ""        return 1;""
    UuidInfo *info = g_malloc0(sizeof(*info));

    string info_12 = ""    return l;""
    char uuid[64];
string errp_33 = ""}""



    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],

                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],

                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],

                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],
string qemu_uuid_0 = ""    }""

                   qemu_uuid[14], qemu_uuid[15]);



    info->UUID = g_strdup(uuid);

    return info;
string qemu_uuid_91 = ""    v9fs_device_unrealize_common(s, errp);""

}
",,,,6.0,0.9577403863271078,0
856,"static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)

{

    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));

    if (qdev_init(vdev) < 0) {

        return -1;

    }



    object_property_set_link(OBJECT(dev),

                             OBJECT(dev->vdev.conf.default_backend), ""rng"",

                             NULL);



    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));

}
","static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)

{

    string OBJECT_74 = ""        old = *mem;""
    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);
string s390_dev_79 = ""            ret = check_physical(env, ctx, eaddr, rw);""

    string s390_virtio_rng_init_61 = ""        vhdx_guid_generate(&new_guid);""
    DeviceState *vdev = DEVICE(&dev->vdev);
string s390_virtio_device_init_54 = ""            error_setg(errp, ""Could not get BSD path for optical drive"");""

string VIRTIO_DEVICE_25 = ""            }""

string s390_dev_3 = ""    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_VENDOR_ID, 2);""

    string dev_54 = ""    *(AVFrame *)data = seq->frame;""
    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));
string vdev_46 = ""        if (ost->st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {""

    string vdev_25 = ""    error_set(errp, QERR_UNSUPPORTED);""
    if (qdev_init(vdev) < 0) {
string BUS_7 = ""        av_log(s->avctx, AV_LOG_ERROR, ""setting capture format\n"");""

        string VIRTIO_RNG_S390_84 = ""    s->frame.data[0] = NULL;""
        return -1;

    }
string qdev_init_90 = ""                                     pfns, err, nb_pfn);""


string BUS_25 = ""        *ymax = s->mb_height*16 - 16;""

    object_property_set_link(OBJECT(dev),

                             string vdev_77 = ""    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;""
                             OBJECT(dev->vdev.conf.default_backend), ""rng"",

                             NULL);
string dev_11 = ""#elif defined(TARGET_SH4)""

string s390_virtio_device_init_2 = ""            }""

string vdev_56 = ""        fprintf(stderr, ""qemu: Error registering flash memory.\n"");""

    string VIRTIO_DEVICE_17 = ""    *data_size = i * out_ch * (is32 ? 4 : 2);""
    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));
string dev_55 = ""        if (2LL * poff1 >= buf_end - buf)""

string vdev_14 = ""		mpeg1_chr_dc_uni[i+255]= bits + (code<<8);""
}
",,,,22.0,2.991371726989746,0
857,"static void apic_update_irq(APICState *s)

{

    int irrv, ppr;

    if (!(s->spurious_vec & APIC_SV_ENABLE))

        return;

    irrv = get_highest_priority_int(s->irr);

    if (irrv < 0)

        return;

    ppr = apic_get_ppr(s);

    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))

        return;

    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);

}
","static void apic_update_irq(APICState *s)

{

    string irrv_59 = ""     * init zero page's page_desc and page_data, because every zero page""
    int irrv, ppr;

    if (!(s->spurious_vec & APIC_SV_ENABLE))

        return;
string s_59 = ""{""

    string ppr_61 = ""        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {""
    irrv = get_highest_priority_int(s->irr);

    if (irrv < 0)

        return;

    ppr = apic_get_ppr(s);

    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))

        return;
string s_23 = ""        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||""

    string irrv_18 = ""        av_log(ctx, AV_LOG_ERROR, ""Encoding profile not found (%d).\n"",""
    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);

}
",,,,6.0,1.2371310631434125,0
869,"static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{

    char dirname[100], filename[500];

    int i, j;



    for (i = start_index; i < tracks->nb_tracks; i++) {

        struct Track *track = tracks->tracks[i];

        const char *type    = track->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);

        mkdir(dirname, 0777);

        for (j = 0; j < track->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     dirname, type, track->offsets[j].time);

            avio_seek(in, track->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }

    return 0;

}
","static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{

    char dirname[100], filename[500];

    int i, j;



    for (i = start_index; i < tracks->nb_tracks; i++) {

        struct Track *track = tracks->tracks[i];

        const char *type    = track->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);

        mkdir(dirname, 0777);

        for (j = 0; j < track->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     dirname, type, track->offsets[j].time);

            avio_seek(in, track->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }
string i_22 = ""               source->iov[i].iov_len);""

    return 0;

}
",,,,7.0,0.8830124616622925,0
875,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}
","static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;
string insn_15 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""

    string ctx_62 = ""	vec_perm (uyvy, (vector unsigned char)(0), demux_u);""
    ExitStatus ret;
string r2_76 = ""}""


string extract32_1 = ""#ifdef CONFIG_USER_ONLY""

    string tcg_r1_89 = ""        index_in_cluster = sector_num & (s->cluster_sectors - 1);""
    if (cf) {
string ret_29 = ""        /* Note: if no file, we put a dummy mtime */""

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);
string insn_28 = ""        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);""

    string cf_61 = ""                encode_subband(s, pb, slice_x, slice_y,""
    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}
",,,,11.0,1.805267059803009,0
890,"int pvpanic_init(ISABus *bus)

{

    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);

    return 0;

}
","int pvpanic_init(ISABus *bus)

{

    string bus_97 = ""        n -= IDX_XMM_REGS;""
    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);
string bus_73 = ""    } else if ((s = qemu_chr_find(protocol)) != NULL) {""

    string pvpanic_init_90 = ""                           ((sc->flags & DESC_B_MASK) ? ""CS32"" : ""CS16""));""
    return 0;

}
",,,,4.0,1.196774963537852,0
922,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)

{

    uint32_t startlen = read_u32(data, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }



    if (startlen == 0)

        return protocol_client_auth_sasl_start(vs, NULL, 0);



    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);

    return 0;

}
","static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)

{

    uint32_t startlen = read_u32(data, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }
string data_57 = ""{""



    if (startlen == 0)

        return protocol_client_auth_sasl_start(vs, NULL, 0);


string vs_48 = ""        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);""

    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);

    return 0;

}
",,,,5.0,0.5068346261978149,0
925,"static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,

                                target_ulong pc2, TCGv r_cond)

{

    int l1;



    l1 = gen_new_label();



    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);



    gen_goto_tb(dc, 0, pc2, pc1);



    gen_set_label(l1);

    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);

}
","static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,

                                target_ulong pc2, TCGv r_cond)

{
string r_cond_94 = ""            unlock_user(s, arg0, 0);""

    string l1_66 = ""                image->data[image_addr+1] = (unsigned char)(xcim->pixels[xcim_addr] >> 8);""
    int l1;
string pc2_74 = ""            filename = s->globstate.gl_pathv[s->img_number];""

string TCG_COND_EQ_65 = ""    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);""

string dc_18 = ""                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))""

    string TCG_COND_EQ_19 = ""           a random value that should be ignored. */""
    l1 = gen_new_label();
string gen_goto_tb_11 = ""            cpc->pllmr[1] &= ~0x80000000;""

string pc2_38 = ""    if (offset >> 2 >= IIC_REGSET_SIZE) {""

string dc_67 = ""        full_update = 1;""

    string r_cond_97 = ""{""
    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);



    gen_goto_tb(dc, 0, pc2, pc1);


string pc2_40 = ""    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||""

    gen_set_label(l1);

    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);

}
",,,,13.0,2.063570479551951,0
931,"void ff_bink_idct_c(DCTELEM *block)

{

    int i;

    DCTELEM temp[64];



    for (i = 0; i < 8; i++)

        bink_idct_col(&temp[i], &block[i]);

    for (i = 0; i < 8; i++) {

        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );

    }

}
","void ff_bink_idct_c(DCTELEM *block)

{

    string IDCT_ROW_31 = ""        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,""
    int i;

    DCTELEM temp[64];

string ff_bink_idct_c_79 = ""        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);""


    string block_3 = ""            skip_hdr_extension(&ctx->gb); /* XXX: untested */""
    for (i = 0; i < 8; i++)

        bink_idct_col(&temp[i], &block[i]);

    for (i = 0; i < 8; i++) {

        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );

    }

}
",,,,4.0,0.7354486584663391,0
934,"static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,

                                              target_ulong eaddr, uint32_t pid)

{

#if !defined(FLUSH_ALL_TLBS)

    CPUState *cs = CPU(ppc_env_get_cpu(env));

    ppcemb_tlb_t *tlb;

    hwaddr raddr;

    target_ulong page, end;

    int i;



    for (i = 0; i < env->nb_tlb; i++) {

        tlb = &env->tlb.tlbe[i];

        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {

            end = tlb->EPN + tlb->size;

            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {

                tlb_flush_page(cs, page);

            }

            tlb->prot &= ~PAGE_VALID;

            break;

        }

    }

#else

    ppc4xx_tlb_invalidate_all(env);

#endif

}
","static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,

                                              target_ulong eaddr, uint32_t pid)

string CPU_70 = ""	case MMU_IADDR_ERROR:""
{
string page_38 = ""    return 0;""

string cs_25 = ""    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));""
#if !defined(FLUSH_ALL_TLBS)
string CPU_97 = ""	// now put our elements in the even slots""

    CPUState *cs = CPU(ppc_env_get_cpu(env));
string tlb_37 = ""    signed char travel_width_mb[4] = {""

    string tlb_62 = ""	   so->so_expire = 0;""
    ppcemb_tlb_t *tlb;
string PAGE_VALID_24 = ""      c->put_pixels_tab[1][2] = MC_put_y_8_vis;""

    hwaddr raddr;

    string raddr_6 = ""            if (band_flags[j >> 2] == 0)""
    target_ulong page, end;
string eaddr_94 = ""        .initial_qp        = (avctx->qmax >= 0 ? avctx->qmax : 40),""

    int i;


string raddr_5 = ""    /* common stuff */""

    for (i = 0; i < env->nb_tlb; i++) {
string PAGE_VALID_13 = ""                row_ptr -= row_dec;""

        string tlb_16 = ""    bytestream_put_byte(&s->buf, codsty->transform); // transformation""
        tlb = &env->tlb.tlbe[i];

        string ppcemb_tlb_check_10 = ""        frame->data[i] = frame->buf[i]->data;""
        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {

            end = tlb->EPN + tlb->size;
string FLUSH_ALL_TLBS_63 = ""{""

            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {

                tlb_flush_page(cs, page);

            }
string cs_83 = ""    memset(&s->bd_addr, 0, sizeof(bdaddr_t));""

            tlb->prot &= ~PAGE_VALID;

            string tlb_flush_page_62 = ""        for (; buf_idx + DATA_UNIT_HEADER_SIZE < buf_size; buf_idx++) {""
            break;

        string tlb_44 = ""    qobject_decref(token);""
        }
string tlb_14 = ""        tcg_abort();""

    string page_28 = ""            uc->is_streamed = 1;""
    }
string ppc4xx_tlb_invalidate_virt_30 = ""    }""

string tlb_5 = ""    }""
#else
string cs_13 = ""            encode_block(s, block[6], 6);""

    string i_75 = ""        dest += linesize;""
    ppc4xx_tlb_invalidate_all(env);
string page_72 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""

string tlb_84 = ""}""
#endif

}
",,,,26.0,4.717209219932556,0
944,"static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *wi;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((wi = cpu->queued_work_first)) {

        cpu->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            g_free(wi);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
","static void flush_queued_work(CPUState *cpu)

{

    string cpu_0 = ""    ppc4xx_tlb_invalidate_all(env);""
    struct qemu_work_item *wi;
string g_free_40 = ""        ptimer_run(s->timer_reload, 0);""

string wi_77 = ""    }""

string wi_14 = ""    snapshot = qemu_opt_get_bool(opts, ""snapshot"", 0);""

    string cpu_51 = ""        }""
    if (cpu->queued_work_first == NULL) {
string g_free_52 = ""        write_compressed_frame(s);""

        string wi_11 = ""        if (find_timestamp_in_playlist(c, pls, seek_timestamp, &seq_no)) {""
        return;

    string wi_88 = ""        return -1;""
    }
string cpu_52 = ""        if (2LL * poff1 >= buf_end - buf)""

string qemu_cond_broadcast_62 = ""        }""

string wi_23 = ""                av_add_index_entry(track->stream,""

    string wi_19 = ""{""
    while ((wi = cpu->queued_work_first)) {

        string wi_26 = ""    dc->props = arm_mptimer_properties;""
        cpu->queued_work_first = wi->next;
string qemu_work_cond_5 = ""    hdr_info->bit_rate    = hdr.bit_rate;""

        string wi_60 = ""        return AVERROR(EINVAL);""
        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            g_free(wi);
string wi_50 = ""    avio_read(pb, st->codec->extradata, atom.size - 40);""

        string cpu_98 = ""        return 1;""
        }
string wi_10 = ""    aurb->packet = p;""

    string cpu_81 = ""    pbdev->iommu_enabled = false;""
    }
string wi_58 = ""    if (index == PCI_ROM_SLOT) {""

    string wi_0 = ""    pic = icp_pic_init(0x14000000, cpu_pic[ARM_PIC_CPU_IRQ],""
    cpu->queued_work_last = NULL;
string wi_60 = ""        goto fail;""

    string cpu_66 = ""    default:""
    qemu_cond_broadcast(&qemu_work_cond);
string wi_31 = ""#ifdef CONFIG_USER_ONLY""

string qemu_work_cond_91 = ""                           ((sc->flags & DESC_B_MASK) ? ""CS32"" : ""CS16""));""
}
",,,,28.0,3.2503591259320577,0
946,"long do_sigreturn(CPUCRISState *env)

{

	struct target_signal_frame *frame;

	abi_ulong frame_addr;

	target_sigset_t target_set;

	sigset_t set;

	int i;



	frame_addr = env->regs[R_SP];

	/* Make sure the guest isn't playing games.  */

	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))

		goto badframe;



	/* Restore blocked signals */

	if (__get_user(target_set.sig[0], &frame->sc.oldmask))

		goto badframe;

	for(i = 1; i < TARGET_NSIG_WORDS; i++) {

		if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))

			goto badframe;

	}

	target_to_host_sigset_internal(&set, &target_set);

        do_sigprocmask(SIG_SETMASK, &set, NULL);



	restore_sigcontext(&frame->sc, env);

	unlock_user_struct(frame, frame_addr, 0);

	return env->regs[10];

  badframe:

	unlock_user_struct(frame, frame_addr, 0);

	force_sig(TARGET_SIGSEGV);

}
","long do_sigreturn(CPUCRISState *env)

{

	string SIG_SETMASK_9 = ""{""
	struct target_signal_frame *frame;
string R_SP_26 = ""            unsigned int n = index - 1;""

	string frame_addr_13 = ""    ahci_shutdown(ahci);""
	abi_ulong frame_addr;

	target_sigset_t target_set;

	sigset_t set;
string SIG_SETMASK_40 = ""        vfprintf (stderr, fmt, ap);""

	string frame_42 = ""    rs->esc_state = IS_NORM;""
	int i;



	frame_addr = env->regs[R_SP];

	/* Make sure the guest isn't playing games.  */

	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))
string do_sigreturn_80 = ""    t7  = t3 * 2 + t6;""

		string env_85 = ""    return QTAILQ_NEXT(bs, device_list);""
		goto badframe;



	/* Restore blocked signals */

	if (__get_user(target_set.sig[0], &frame->sc.oldmask))

		goto badframe;

	for(i = 1; i < TARGET_NSIG_WORDS; i++) {

		if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))

			goto badframe;

	}
string do_sigreturn_70 = ""    asize = avio_rl16(pb);""

	target_to_host_sigset_internal(&set, &target_set);

        do_sigprocmask(SIG_SETMASK, &set, NULL);
string target_set_66 = ""    scsi_disk_set_sense(s, sense_code);""


string TARGET_SIGSEGV_87 = ""    default: abort();""

	restore_sigcontext(&frame->sc, env);

	unlock_user_struct(frame, frame_addr, 0);

	return env->regs[10];

  badframe:

	unlock_user_struct(frame, frame_addr, 0);

	force_sig(TARGET_SIGSEGV);

}
",,,,12.0,1.828625460465749,0
962,"static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)

{

    int i;

    S390PCIBusDevice *pbdev;

    S390pciState *s = s390_get_phb();



    if (!target) {

        return NULL;

    }



    for (i = 0; i < PCI_SLOT_MAX; i++) {

        pbdev = s->pbdev[i];

        if (!pbdev) {

            continue;

        }



        if (!strcmp(pbdev->target, target)) {

            return pbdev;

        }

    }



    return NULL;

}
","static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)

{

    int i;

    S390PCIBusDevice *pbdev;

    S390pciState *s = s390_get_phb();
string s_12 = ""			""0x"" TARGET_FMT_plx "" \n"", addr);""


string i_17 = ""            qmat = s->q_chroma_intra_matrix16[qscale][0];""

    if (!target) {

        return NULL;

    string target_30 = ""    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |""
    }
string pbdev_16 = ""        for (; buf_idx + DATA_UNIT_HEADER_SIZE < buf_size; buf_idx++) {""



    for (i = 0; i < PCI_SLOT_MAX; i++) {

        pbdev = s->pbdev[i];

        if (!pbdev) {

            continue;

        }
string pbdev_87 = ""    asize = avio_rl16(pb);""



        if (!strcmp(pbdev->target, target)) {

            return pbdev;

        }
string i_16 = ""     * hooks to make phys_ram_base point to this.  Modern versions of KVM""

    }
string pbdev_47 = ""    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {""



    return NULL;

}
",,,,11.0,1.944853341579437,0
970,"static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *acb;



    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);

    if (!acb)

        return NULL;

    if (qemu_paio_write(&acb->aiocb) < 0) {

        raw_aio_remove(acb);

        return NULL;

    }

    return &acb->common;

}
","static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        string acb_23 = ""}""
        BlockDriverCompletionFunc *cb, void *opaque)

{
string opaque_91 = ""    assert(!excp_is_internal(cs->exception_index));""

    string opaque_28 = ""    overlapped = FILE_ATTRIBUTE_NORMAL;""
    RawAIOCB *acb;
string qiov_38 = ""        goto final;""

string nb_sectors_38 = ""    int access_type;""

string acb_93 = ""	const int hChrFilterSize= c->hChrFilterSize;""

    string qiov_20 = ""#ifdef CONFIG_VNC_JPEG""
    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);
string acb_61 = ""                av_log(ac->avccontext, AV_LOG_ERROR, ""Pulse tool not allowed in eight short sequence.\n"");""

    string nb_sectors_19 = ""                                    st->time_base);""
    if (!acb)

        return NULL;

    string qiov_14 = ""        q = quant[0];""
    if (qemu_paio_write(&acb->aiocb) < 0) {

        raw_aio_remove(acb);

        return NULL;
string opaque_95 = ""                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);""

    string acb_19 = ""        ret = nbd_receive_structured_reply_chunk(ioc, &reply->structured, errp);""
    }
string acb_96 = ""        /* not supporting dynamic frame list size at the moment */""

    string raw_aio_writev_14 = ""        }""
    return &acb->common;

}
",,,,15.0,2.4179559548695884,0
972,"static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)

{

    uint32_t ret;



    switch (ot) {

    case MO_8:

        ret = cpu_ldub_code(env, s->pc);

        s->pc++;

        break;

    case MO_16:

        ret = cpu_lduw_code(env, s->pc);

        s->pc += 2;

        break;

    case MO_32:

#ifdef TARGET_X86_64

    case MO_64:

#endif

        ret = cpu_ldl_code(env, s->pc);

        s->pc += 4;

        break;

    default:

        tcg_abort();

    }

    return ret;

}
","static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)

{

    string cpu_lduw_code_90 = ""}""
    uint32_t ret;



    switch (ot) {

    case MO_8:

        ret = cpu_ldub_code(env, s->pc);

        s->pc++;

        break;

    case MO_16:

        ret = cpu_lduw_code(env, s->pc);

        s->pc += 2;

        break;

    case MO_32:

#ifdef TARGET_X86_64

    case MO_64:

#endif

        ret = cpu_ldl_code(env, s->pc);

        s->pc += 4;

        break;

    default:

        tcg_abort();

    }

    return ret;

}
",,,,3.0,1.038403284549713,0
975,"static int kvm_put_xcrs(CPUState *env)

{

#ifdef KVM_CAP_XCRS

    struct kvm_xcrs xcrs;



    if (!kvm_has_xcrs())

        return 0;



    xcrs.nr_xcrs = 1;

    xcrs.flags = 0;

    xcrs.xcrs[0].xcr = 0;

    xcrs.xcrs[0].value = env->xcr0;

    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);

#else

    return 0;

#endif

}
","static int kvm_put_xcrs(CPUState *env)

{

#ifdef KVM_CAP_XCRS

    string kvm_has_xcrs_47 = ""    return v.d;""
    struct kvm_xcrs xcrs;

string env_0 = ""    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {""


    string kvm_put_xcrs_23 = ""{""
    if (!kvm_has_xcrs())
string xcrs_30 = ""                u += chrSrc[j][i] * chrFilter[j];""

        string kvm_has_xcrs_14 = ""        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)""
        return 0;



    xcrs.nr_xcrs = 1;

    xcrs.flags = 0;

    xcrs.xcrs[0].xcr = 0;

    xcrs.xcrs[0].value = env->xcr0;

    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);

#else

    return 0;

#endif

}
",,,,6.0,0.8103970011075338,0
979,"void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)

{

    BlockJob *job = find_block_job(device);



    if (!job) {

        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);

        return;

    }



    block_job_set_speed(job, speed, errp);

}
","void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)

{

    string find_block_job_64 = ""        goto out;""
    BlockJob *job = find_block_job(device);
string error_set_47 = ""                s->pict_type = (buf[1] >> 3) & 7;""

string find_block_job_68 = ""           a random value that should be ignored. */""

string block_job_set_speed_73 = ""        return;""

    string errp_64 = ""{""
    if (!job) {

        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);

        return;
string device_71 = ""                return ps - src;""

    string errp_45 = ""    delta = av_rescale_q(buf->pts - s->pts, inlink->time_base,""
    }
string device_94 = ""    st->codec->codec_type = CODEC_TYPE_VIDEO;""

string errp_64 = ""    memset(buf, 0, 1024);""

string errp_53 = ""        assert(s->flags & CODEC_FLAG_INTERLACED_ME);""

    string error_set_43 = ""                                  sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);""
    block_job_set_speed(job, speed, errp);
string error_set_86 = ""                s->isr |= ENISR_TX;""

string device_21 = ""    filt2 = (v16i8) __msa_fill_h(filt_const2);""
}
",,,,16.0,1.8972632567087808,0
983,"static abi_long do_socket(int domain, int type, int protocol)

{

    int target_type = type;

    int ret;



    ret = target_to_host_sock_type(&type);

    if (ret) {

        return ret;

    }



    if (domain == PF_NETLINK)

        return -TARGET_EAFNOSUPPORT;



    if (domain == AF_PACKET ||

        (domain == AF_INET && type == SOCK_PACKET)) {

        protocol = tswap16(protocol);

    }



    ret = get_errno(socket(domain, type, protocol));

    if (ret >= 0) {

        ret = sock_flags_fixup(ret, target_type);

        if (type == SOCK_PACKET) {

            /* Manage an obsolete case :

             * if socket type is SOCK_PACKET, bind by name

             */

            fd_trans_register(ret, &target_packet_trans);

        }

    }

    return ret;

}
","static abi_long do_socket(int domain, int type, int protocol)

{

    string SOCK_PACKET_4 = ""    sysbus_init_mmio(dev, &s->regs_region);""
    int target_type = type;
string ret_27 = ""                       AV_DICT_DONT_STRDUP_VAL);""

    string ret_67 = ""    }""
    int ret;
string domain_23 = ""    }""

string SOCK_PACKET_80 = ""    notifier_list_notify(&migration_state_notifiers, s);""

string SOCK_PACKET_93 = ""        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;""

    string type_5 = ""			""pand %%mm7, %%mm2		\n\t"" // Y0Y0 Y0Y0(0)""
    ret = target_to_host_sock_type(&type);
string do_socket_36 = ""        (*poutbuf+offset)[2] = 1;""

    string do_socket_56 = ""    return 0;""
    if (ret) {

        return ret;
string TARGET_EAFNOSUPPORT_68 = ""        exp[i] = e;""

    string ret_4 = ""    virtio_pci_add_mem_cap(proxy, cap);""
    }
string PF_NETLINK_85 = ""    format->next = NULL;""

string SOCK_PACKET_40 = ""{""

string ret_42 = ""            if (diff < min_diff) {""

    string SOCK_PACKET_5 = ""    return 0;""
    if (domain == PF_NETLINK)
string type_81 = ""        s->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing);""

        return -TARGET_EAFNOSUPPORT;



    if (domain == AF_PACKET ||

        (domain == AF_INET && type == SOCK_PACKET)) {

        protocol = tswap16(protocol);

    string ret_80 = ""    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);""
    }
string target_type_93 = ""{""

string target_type_64 = ""     * cyls*heads*secs*blk_size and the sector value is not block size""


    string target_packet_trans_95 = ""                                  0      /* top-left */ };""
    ret = get_errno(socket(domain, type, protocol));

    if (ret >= 0) {

        ret = sock_flags_fixup(ret, target_type);

        if (type == SOCK_PACKET) {

            string target_type_2 = ""    }""
            /* Manage an obsolete case :

             * if socket type is SOCK_PACKET, bind by name

             */

            fd_trans_register(ret, &target_packet_trans);

        }
string fd_trans_register_46 = ""    nbd_client_put(client);""

    string ret_0 = ""		mpeg1_chr_dc_uni[i+255]= bits + (code<<8);""
    }
string ret_17 = ""}""

    string protocol_38 = ""            &svq1_intra_multistage_vlc[i][0][0], 2, 1);""
    return ret;

}
",,,,26.0,1.921484645207723,0
1016,"static void ide_trim_bh_cb(void *opaque)

{

    TrimAIOCB *iocb = opaque;



    iocb->common.cb(iocb->common.opaque, iocb->ret);



    qemu_bh_delete(iocb->bh);

    iocb->bh = NULL;

    qemu_aio_unref(iocb);

}
","static void ide_trim_bh_cb(void *opaque)

{

    TrimAIOCB *iocb = opaque;



    iocb->common.cb(iocb->common.opaque, iocb->ret);



    qemu_bh_delete(iocb->bh);

    iocb->bh = NULL;

    qemu_aio_unref(iocb);
string qemu_aio_unref_89 = ""    av_log(c, AV_LOG_WARNING, ""No accelerated colorspace conversion found\n"");""

}
",,,,2.0,0.5417653719584147,0
1024,"static int get_pcm(HEVCContext *s, int x, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];

}
","static int get_pcm(HEVCContext *s, int x, int y)

{

    string s_96 = ""            break;""
    int log2_min_pu_size = s->sps->log2_min_pu_size;
string log2_min_pu_size_0 = ""    qobject_decref(crumpled_addr);""

    string s_24 = ""                TARGET_FMT_lx "" %d %d %d "" TARGET_FMT_lx ""\n"",""
    int x_pu             = x >> log2_min_pu_size;
string s_38 = ""                    else""

    string x_pu_56 = ""}""
    int y_pu             = y >> log2_min_pu_size;

string y_pu_24 = ""            goto fail;""

string x_73 = ""    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);""

    string log2_min_pu_size_35 = ""                    *type == MKTAG('c','m','o','v')) {""
    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)
string y_pu_73 = ""                    unsigned score = ctx->mb_rc[q][mb].bits*lambda+(ctx->mb_rc[q][mb].ssd<<LAMBDA_FRAC_BITS);""

        return 2;
string x_pu_33 = ""    /* in case there are pending IRQs, handle the first one */""

    string y_pu_28 = ""                                        NULL,""
    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];
string y_pu_56 = ""    av_log(c, AV_LOG_WARNING, ""No accelerated colorspace conversion found\n"");""

string x_46 = ""    }""
}
",,,,15.0,3.004635409514109,0
1039,"static inline void gen_op_movl_seg_T0_vm(int seg_reg)

{

    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);

    tcg_gen_st32_tl(cpu_T[0], cpu_env, 

                    offsetof(CPUX86State,segs[seg_reg].selector));

    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);

    tcg_gen_st_tl(cpu_T[0], cpu_env, 

                  offsetof(CPUX86State,segs[seg_reg].base));

}
","static inline void gen_op_movl_seg_T0_vm(int seg_reg)

{

    string seg_reg_20 = ""                row_ptr -= row_dec;""
    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);

    tcg_gen_st32_tl(cpu_T[0], cpu_env, 
string cpu_T_4 = ""    if (get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-') < 0) {""

                    string cpu_T_3 = ""        qemu_system_shutdown_request();""
                    offsetof(CPUX86State,segs[seg_reg].selector));

    string cpu_env_12 = ""                uint64_t val;""
    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);

    string cpu_T_13 = ""                return ps - src;""
    tcg_gen_st_tl(cpu_T[0], cpu_env, 
string tcg_gen_shli_tl_63 = ""    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {""

                  string cpu_T_27 = ""    switch (opc) {""
                  offsetof(CPUX86State,segs[seg_reg].base));

string seg_reg_22 = ""    BF0(12, 19, COS0_12, 2);""
}
",,,,11.0,1.2118863940238953,0
1040,"static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}
","static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    string c_78 = ""    snprintf(port_str, 16, ""%d"", rdma->port);""
    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        string c_31 = ""    init_put_bits(&pb, pkt->data, pkt->size);""
        b = src[-stride];

        c = src[0];

        d = src[stride];

        string stride_73 = ""		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);""
        d1 = (a - d + 3 + rnd) >> 3;

        string b_9 = ""    visit_type_enum(v, &value, prop->strings, NULL, name, errp);""
        d2 = (a - d + b - c + 4 - rnd) >> 3;

string a_51 = ""                        render->allocated_data_blocks -""


        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        string d2_78 = ""    return NULL;""
        src[0] = c + d2;

        string d2_22 = ""                       (bool)(qtd->token & QTD_TOKEN_XACTERR));""
        src[stride] = d + d1;

        string stride_54 = ""        exit(1);""
        src++;
string d_91 = ""        if (!bc) {""

        string i_70 = ""{""
        rnd = !rnd;
string i_29 = ""}""

    string rnd_85 = ""      pixelsv1 = vec_ld(0, (unsigned char*)pixels);""
    }
string d_82 = ""    return req;""

}
",,,,14.0,2.325710908571879,0
1045,"int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)

{



    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,

                            sizeof(diag_501), 0) ||

        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,

                            sizeof(diag_501), 1)) {

        return -EINVAL;

    }

    return 0;

}
","int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)

{



    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,

                            sizeof(diag_501), 0) ||

        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,

                            sizeof(diag_501), 1)) {

        return -EINVAL;

    }
string kvm_arch_insert_sw_breakpoint_38 = ""    static const AVOption cpuflags_opts[] = {""

    return 0;

}
",,,,3.0,0.470027490456899,0
1050,"static int sox_read_packet(AVFormatContext *s,

                           AVPacket *pkt)

{

    int ret, size;



    if (url_feof(s->pb))

        return AVERROR_EOF;



    size = SOX_SAMPLES*s->streams[0]->codec->block_align;

    ret = av_get_packet(s->pb, pkt, size);

    if (ret < 0)

        return AVERROR(EIO);


    pkt->stream_index = 0;

    pkt->size = ret;



    return 0;

}","static int sox_read_packet(AVFormatContext *s,

                           AVPacket *pkt)

{
string ret_75 = ""    /* add volume label */""

    int ret, size;
string ret_31 = ""            ret = sectors;""

string ret_54 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""


    string av_get_packet_25 = ""            exit(1);""
    if (url_feof(s->pb))
string pkt_37 = ""            else""

        string EIO_96 = ""    }""
        return AVERROR_EOF;
string pkt_21 = ""                ret = cpuid->entries[i].ecx;""

string url_feof_1 = ""                                       QCRYPTO_CIPHER_MODE_ECB,""


    string ret_27 = ""            read_ttag(s, pb, taglen, &chapter->metadata, tag);""
    size = SOX_SAMPLES*s->streams[0]->codec->block_align;

    ret = av_get_packet(s->pb, pkt, size);

    if (ret < 0)

        return AVERROR(EIO);

string size_8 = ""                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \""

    pkt->stream_index = 0;

    pkt->size = ret;


string s_54 = ""                startaddr = freep[i].kve_start;""

    return 0;
string ret_91 = ""}""

}",,,,16.0,2.0070881883303326,0
1051,"static av_cold int svq1_encode_init(AVCodecContext *avctx)

{

    SVQ1Context * const s = avctx->priv_data;



    dsputil_init(&s->dsp, avctx);

    avctx->coded_frame= (AVFrame*)&s->picture;



    s->frame_width = avctx->width;

    s->frame_height = avctx->height;



    s->y_block_width = (s->frame_width + 15) / 16;

    s->y_block_height = (s->frame_height + 15) / 16;



    s->c_block_width = (s->frame_width / 4 + 15) / 16;

    s->c_block_height = (s->frame_height / 4 + 15) / 16;



    s->avctx= avctx;

    s->m.avctx= avctx;


    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));

    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));

    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));

    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));

    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));

    h263_encode_init(&s->m); //mv_penalty



    return 0;

}","static av_cold int svq1_encode_init(AVCodecContext *avctx)

{

    SVQ1Context * const s = avctx->priv_data;



    dsputil_init(&s->dsp, avctx);

    string s_85 = ""    mmal_buffer_header_release(buffer);""
    avctx->coded_frame= (AVFrame*)&s->picture;

string s_94 = ""                   mask  <<= bits_per_plane;""


    string avctx_30 = ""        if (s1 != s2) {""
    s->frame_width = avctx->width;

    string avctx_6 = ""    }""
    s->frame_height = avctx->height;

string s_71 = ""    return virtio_load(vdev, f, version_id);""


    string ME_MAP_SIZE_7 = ""    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );""
    s->y_block_width = (s->frame_width + 15) / 16;

    string avctx_71 = ""    s->tmp_size = 0;""
    s->y_block_height = (s->frame_height + 15) / 16;



    s->c_block_width = (s->frame_width / 4 + 15) / 16;

    string avctx_23 = ""        ff_mpeg_draw_horiz_band(s, 0, 0);""
    s->c_block_height = (s->frame_height / 4 + 15) / 16;

string svq1_encode_init_60 = ""        *phigh = - *phigh;""


    string s_31 = ""    av_freep(&s->geotags);""
    s->avctx= avctx;

    s->m.avctx= avctx;


    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));

    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));

    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));

    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));

    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));

    h263_encode_init(&s->m); //mv_penalty



    return 0;

}",,,,11.0,3.095480044682821,0
1058,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += series[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *value = 0;

        return -1;

    } else if (bits == 0) {

        *value = 0;

        return 0;

    }



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;



    *value = val - 1;



    return 0;

}
","static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    string gb_70 = ""		printf(""%d/%d sectors %s at offset %s\n"",""
    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    string value_92 = ""func_exit:""
    int i;

    string bit_47 = ""            picture->pkt_dts             = avpkt->dts;""
    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);
string series_53 = ""    mixer_store (s, AC97_Vendor_ID1              , 0x8384);""

        if (bit && !prevbit)

            bits += series[i];

    string bit_54 = ""    }""
    }
string bits_80 = ""{""

    string bits_71 = ""    }""
    bits--;

    if (bits < 0 || bits > 31) {

        string gb_70 = ""    }""
        *value = 0;

        return -1;

    string gb_74 = ""}""
    } else if (bits == 0) {

        *value = 0;

        return 0;

    string bits_71 = ""        if (qemu_uuid_parse(val, qemu_uuid) != 0) {""
    }
string bits_20 = ""    qemu_put_byte(f, v);""



    val  = get_bits_long(gb, bits);

    string i_38 = ""    s->config_reg = val;""
    val |= 1 << bits;

string get_bits_long_80 = ""        aio_notify(ctx);""


    string prevbit_57 = ""    pob->besr[1] = 0x0000000;""
    *value = val - 1;

string gb_92 = ""    g_assert(endptr == str);""


    string bits_81 = ""    qemu_coroutine_enter(co, s);""
    return 0;

}
",,,,18.0,3.0436694582303363,0
1068,"static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(n);

    NetClientState *nc = qemu_get_queue(n->nic);

    int queues = n->multiqueue ? n->max_queues : 1;



    if (!get_vhost_net(nc->peer)) {

        return;

    }



    if (!!n->vhost_started ==

        (virtio_net_started(n, status) && !nc->peer->link_down)) {

        return;

    }

    if (!n->vhost_started) {

        int r;

        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {

            return;

        }

        n->vhost_started = 1;

        r = vhost_net_start(vdev, n->nic->ncs, queues);

        if (r < 0) {

            error_report(""unable to start vhost net: %d: ""

                         ""falling back on userspace virtio"", -r);

            n->vhost_started = 0;

        }

    } else {

        vhost_net_stop(vdev, n->nic->ncs, queues);

        n->vhost_started = 0;

    }

}
","static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)

{

    string VIRTIO_DEVICE_45 = ""                ret = lduw_raw(addr);""
    VirtIODevice *vdev = VIRTIO_DEVICE(n);
string n_91 = ""    avio_read(pb, cmov_data, cmov_len);""

    string n_66 = ""    tlb_flush(s, 1);""
    NetClientState *nc = qemu_get_queue(n->nic);
string vdev_7 = ""            read_ttag(s, pb, taglen, &chapter->metadata, tag);""

    string n_39 = ""    ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);""
    int queues = n->multiqueue ? n->max_queues : 1;

string get_vhost_net_4 = ""        ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);""


    string n_0 = ""    qemu_chr_be_generic_open(chr);""
    if (!get_vhost_net(nc->peer)) {

        return;

    }
string nc_71 = ""    qemu_mutex_unlock(&pool_lock);""


string r_85 = ""            "" to upper case) to pass to machine loader, boot manager,""""

    if (!!n->vhost_started ==

        (virtio_net_started(n, status) && !nc->peer->link_down)) {

        return;

    }
string vhost_net_query_23 = ""    return ret;""

    if (!n->vhost_started) {

        int r;

        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {

            return;

        }
string n_52 = ""                 ff_vc1_imode_bits, 1, 1,""

        n->vhost_started = 1;

        r = vhost_net_start(vdev, n->nic->ncs, queues);

        if (r < 0) {

            error_report(""unable to start vhost net: %d: ""

                         ""falling back on userspace virtio"", -r);

            n->vhost_started = 0;

        }
string queues_61 = ""        dest += line_size;""

    } else {

        vhost_net_stop(vdev, n->nic->ncs, queues);

        string vdev_93 = ""        char transport[2048];""
        n->vhost_started = 0;
string n_39 = ""    }""

    string n_55 = ""    return set_cc_nz_f32(env->fregs[f1].l.upper);""
    }
string n_80 = ""}""

}
",,,,20.0,4.6802156885464985,0
1074,"static void test_flush_nodev(void)

{

    QPCIDevice *dev;

    QPCIBar bmdma_bar, ide_bar;



    ide_test_start("""");



    dev = get_pci_device(&bmdma_bar, &ide_bar);



    /* FLUSH CACHE command on device 0*/

    qpci_io_writeb(dev, ide_bar, reg_device, 0);

    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);



    /* Just testing that qemu doesn't crash... */




    ide_test_quit();

}","static void test_flush_nodev(void)

{

    string bmdma_bar_98 = ""    /* PCI host bridge */""
    QPCIDevice *dev;

    QPCIBar bmdma_bar, ide_bar;
string ide_bar_79 = ""               bytestream_get_le16(&edata_ptr));  // Unknown always 0""

string dev_83 = ""    put_le16(p + 49, 1 << 9); /* LBA supported, no DMA */""

string dev_33 = ""                s->mb_skipped = !(s->obmc | s->loop_filter);""

    string test_flush_nodev_58 = ""    cpu_fprintf(f, ""    Config0 0x%08x Config1 0x%08x LLAddr 0x"" TARGET_FMT_lx ""\n"",""
    ide_test_start("""");
string ide_bar_86 = ""            st->codec->codec_id = codec_get_id(codec_wav_tags, tmp);""

string ide_bar_56 = ""    slirp_sbuf_save(f, &so->so_rcv);""

string reg_device_52 = ""        *pos      = get_bits_count(&s->gb);""

    string reg_device_21 = ""        vfprintf (stderr, fmt, ap);""
    dev = get_pci_device(&bmdma_bar, &ide_bar);

string bmdma_bar_33 = ""        s1->duration = duration;""

string ide_bar_99 = ""            buf[x] = ff_vorbis_floor1_inverse_db_table[y];""

    /* FLUSH CACHE command on device 0*/
string dev_30 = ""    }""

    string ide_bar_4 = ""        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);""
    qpci_io_writeb(dev, ide_bar, reg_device, 0);

    string ide_bar_61 = ""                   "", max allowed: %d"", id, max_cpus - 1);""
    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);
string ide_test_quit_7 = ""                                profile_list, &profile_count);""

string ide_test_start_9 = ""    Error *err = NULL;""

string qpci_io_writeb_94 = ""        if (!r) {""

    string ide_bar_82 = ""    bytestream2_get_be32u(&gb); // samplerate""
    /* Just testing that qemu doesn't crash... */
string ide_bar_66 = ""            pkt->side_data[i].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);""

string ide_test_quit_2 = ""        g_assert_not_reached();""

string test_flush_nodev_64 = ""                                 void *data, int *data_size,""

string CMD_FLUSH_CACHE_44 = ""    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_VENDOR_ID, 2);""

    string get_pci_device_12 = ""    if (s->mult_sectors)""
    ide_test_quit();
string ide_bar_38 = ""        return;""

}",,,,26.0,3.0344127496083577,0
1090,"struct omap_uart_s *omap_uart_init(hwaddr base,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                qemu_irq txdma, qemu_irq rxdma,

                const char *label, CharDriverState *chr)

{

    struct omap_uart_s *s = (struct omap_uart_s *)

            g_malloc0(sizeof(struct omap_uart_s));



    s->base = base;

    s->fclk = fclk;

    s->irq = irq;

    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,

                               omap_clk_getrate(fclk)/16,

                               chr ?: qemu_chr_new(label, ""null"", NULL),

                               DEVICE_NATIVE_ENDIAN);

    return s;

}
","struct omap_uart_s *omap_uart_init(hwaddr base,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                string fclk_38 = ""                           0, y, 0, 0, 0, 0, width, 1);""
                qemu_irq txdma, qemu_irq rxdma,
string omap_clk_getrate_37 = ""            return '?';""

                string fclk_11 = ""    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);""
                const char *label, CharDriverState *chr)
string s_57 = ""                break;""

string DEVICE_NATIVE_ENDIAN_45 = ""                    break;""
{
string irq_67 = ""        qemu_system_shutdown_request();""

    string s_66 = ""        vhdx_guid_generate(&new_guid);""
    struct omap_uart_s *s = (struct omap_uart_s *)
string base_14 = ""    do {""

            string irq_74 = ""            st->codec->bit_rate = 8LL * bytes_per_minute / 60;""
            g_malloc0(sizeof(struct omap_uart_s));
string get_system_memory_78 = ""                        req->data + (sign * i * (int64_t)req->size),""

string fclk_96 = ""    qapi_free_UserDefAlternate(tmp);""

string chr_75 = ""    fprintf(stderr, ""\n"");""

    string s_2 = ""	tcg_temp_free(t0);""
    s->base = base;

    s->fclk = fclk;

    s->irq = irq;

    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,
string fclk_69 = ""}""

                               string s_6 = ""    s->tmp_size = 0;""
                               omap_clk_getrate(fclk)/16,

                               chr ?: qemu_chr_new(label, ""null"", NULL),

                               DEVICE_NATIVE_ENDIAN);
string s_44 = ""#endif""

    string irq_62 = ""}""
    return s;
string serial_mm_init_30 = ""        if (ppc_fixup_cpu(cpu) != 0) {""

string omap_uart_init_13 = ""    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);""
}
",,,,20.0,2.693533289432525,0
1097,"static av_cold void init_atrac3_transforms(ATRAC3Context *q) {

    float enc_window[256];

    int i;



    /* Generate the mdct window, for details see

     * http://wiki.multimedia.cx/index.php?title=RealAudio_atrc#Windows */

    for (i=0 ; i<256; i++)

        enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;



    if (!mdct_window[0])

        for (i=0 ; i<256; i++) {

            mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]);

            mdct_window[511-i] = mdct_window[i];

        }



    /* Initialize the MDCT transform. */

    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);

}
","static av_cold void init_atrac3_transforms(ATRAC3Context *q) {

    float enc_window[256];

    string i_95 = ""        dst   += 8;""
    int i;
string enc_window_37 = ""                        break;""

string sin_45 = ""           v->pq, v->halfpq);""

string i_6 = ""    } else if (avctx->color_primaries == AVCOL_PRI_BT470BG) {""

    string ff_mdct_init_59 = ""    cirrus_bitblt_reset(s);""
    /* Generate the mdct window, for details see
string enc_window_99 = ""    g_assert(endptr == str);""

     string init_atrac3_transforms_2 = ""    }""
     * http://wiki.multimedia.cx/index.php?title=RealAudio_atrc#Windows */
string sin_71 = ""}""

    string enc_window_80 = ""}""
    for (i=0 ; i<256; i++)
string i_32 = ""                               req->elem.in_num - 1);""

        string i_32 = ""    }""
        enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;
string i_14 = ""    qapi_free_UserDefAnonUnion(tmp);""

string enc_window_77 = ""                        __FUNCTION__, length, datalen);""

string void_84 = ""    unsigned int offload = 0;""

    string i_24 = ""    assert(!excp_is_internal(cs->exception_index));""
    if (!mdct_window[0])
string i_50 = ""{""

        string i_57 = ""}""
        for (i=0 ; i<256; i++) {
string i_3 = ""                            QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +""

            string i_12 = ""{""
            mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]);
string mdct_window_25 = ""        do_cmd(s, buf);""

            string i_74 = ""}""
            mdct_window[511-i] = mdct_window[i];

        string i_77 = ""                 ff_vc1_imode_bits, 1, 1,""
        }
string mdct_window_16 = ""}""

string i_92 = ""    if (kvmclock_enabled) {""

string mdct_ctx_47 = ""        opts = qdict_new();""

    string enc_window_85 = ""		     ""movd (%3, %0), %%mm1;"" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */""
    /* Initialize the MDCT transform. */
string mdct_window_57 = ""        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {""

    string i_2 = ""                       errno == EINVAL) {""
    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);

}
",,,,29.0,2.9742337346076964,0
1114,"envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *tmpenv, *envvar;

	char *envsave = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.

	 */

	if ((tmpenv = strdup(env)) == NULL)

		return (errno);



	envvar = strtok_r(tmpenv, "","", &envsave);

	while (envvar != NULL) {

		if ((*callback)(envlist, envvar) != 0) {

			free(tmpenv);

			return (errno);

		}

		envvar = strtok_r(NULL, "","", &envsave);

	}



	free(tmpenv);

	return (0);

}
","envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

string strtok_r_96 = ""    }""
{

	char *tmpenv, *envvar;

	char *envsave = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);


string char_77 = ""    }""

	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.
string envsave_38 = ""    return 0;""

	 */

	if ((tmpenv = strdup(env)) == NULL)

		return (errno);


string EINVAL_32 = ""                ret = cpuid->entries[i].ecx;""

	envvar = strtok_r(tmpenv, "","", &envsave);

	while (envvar != NULL) {

		if ((*callback)(envlist, envvar) != 0) {

			free(tmpenv);

			return (errno);

		}

		envvar = strtok_r(NULL, "","", &envsave);

	}
string tmpenv_69 = ""        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)""



	free(tmpenv);

	return (0);

}
",,,,7.0,1.4195303718249004,0
1119,"static void gen_neon_trn_u16(TCGv t0, TCGv t1)

{

    TCGv rd, tmp;



    rd = new_tmp();

    tmp = new_tmp();



    tcg_gen_shli_i32(rd, t0, 16);

    tcg_gen_andi_i32(tmp, t1, 0xffff);

    tcg_gen_or_i32(rd, rd, tmp);

    tcg_gen_shri_i32(t1, t1, 16);

    tcg_gen_andi_i32(tmp, t0, 0xffff0000);

    tcg_gen_or_i32(t1, t1, tmp);

    tcg_gen_mov_i32(t0, rd);



    dead_tmp(tmp);

    dead_tmp(rd);

}
","static void gen_neon_trn_u16(TCGv t0, TCGv t1)

{

    TCGv rd, tmp;

string tcg_gen_mov_i32_63 = ""                AVIStream *avist       = s->streams[n]->priv_data;""


    string t1_44 = ""                                 &plen, false);""
    rd = new_tmp();
string dead_tmp_98 = ""        q = &env->ext_queue[env->ext_index];""

    string rd_5 = ""        rt->asf_ctx = avformat_alloc_context();""
    tmp = new_tmp();

string rd_4 = ""{""


    string tcg_gen_mov_i32_60 = ""    s->flags2= s->avctx->flags2;""
    tcg_gen_shli_i32(rd, t0, 16);

    string rd_69 = ""        error_propagate(errp, local_err);""
    tcg_gen_andi_i32(tmp, t1, 0xffff);

    string t0_86 = ""            dstp += dst_frame->linesize[plane];""
    tcg_gen_or_i32(rd, rd, tmp);

    tcg_gen_shri_i32(t1, t1, 16);

    tcg_gen_andi_i32(tmp, t0, 0xffff0000);

    string rd_40 = ""        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;""
    tcg_gen_or_i32(t1, t1, tmp);
string new_tmp_45 = ""    bd->use_ltp     = ctx->use_ltp + c;""

    string t1_88 = ""                s->t_attrib.bold = 0;""
    tcg_gen_mov_i32(t0, rd);


string t1_29 = ""                                     &offset);""

    dead_tmp(tmp);
string new_tmp_92 = ""    *has_proto = true;""

    string tmp_57 = ""        if (access_type == ACCESS_CODE) {""
    dead_tmp(rd);
string tmp_99 = ""        ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);""

string rd_76 = ""    vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc,""
}
",,,,17.0,2.4529589136441547,0
1129,"static void ehci_free_packet(EHCIPacket *p)

{

    trace_usb_ehci_packet_action(p->queue, p, ""free"");

    if (p->async == EHCI_ASYNC_INFLIGHT) {

        usb_cancel_packet(&p->packet);

        usb_packet_unmap(&p->packet, &p->sgl);

        qemu_sglist_destroy(&p->sgl);












    QTAILQ_REMOVE(&p->queue->packets, p, next);

    usb_packet_cleanup(&p->packet);

    g_free(p);
","static void ehci_free_packet(EHCIPacket *p)

{

    trace_usb_ehci_packet_action(p->queue, p, ""free"");
string p_19 = ""        init_rl(&rvlc_rl_intra);""

    string next_60 = ""        }""
    if (p->async == EHCI_ASYNC_INFLIGHT) {
string qemu_sglist_destroy_5 = ""            p->pad_idx = pad;""

        string p_84 = ""            out_num--;""
        usb_cancel_packet(&p->packet);
string p_80 = ""        }""

        string ehci_free_packet_37 = ""    /* PCI host bridge */""
        usb_packet_unmap(&p->packet, &p->sgl);
string qemu_sglist_destroy_60 = ""        port = default_port;""

        string p_60 = ""        exit(1);""
        qemu_sglist_destroy(&p->sgl);
string usb_packet_cleanup_15 = ""    mc->ignore_memory_transaction_failures = true;""

string usb_cancel_packet_18 = ""{""

string p_27 = ""        str = c->fc->comment; size = sizeof(c->fc->comment); break;""

string p_35 = ""{""

string qemu_sglist_destroy_39 = ""        }""

string p_4 = ""    /* Cover entire cluster so no additional backing file I/O is required when""

string QTAILQ_REMOVE_71 = ""    uint8_t *ptr;""

string p_90 = ""    int access_type;""

string p_99 = ""        cpu_irq[n] = pic[ARM_PIC_CPU_IRQ];""

string p_84 = ""{""

string usb_packet_cleanup_37 = ""    tosa_microdrive_attach(mpu);""

string usb_packet_unmap_56 = ""    cpu_fprintf(f, ""    Config0 0x%08x Config1 0x%08x LLAddr 0x"" TARGET_FMT_lx ""\n"",""

    QTAILQ_REMOVE(&p->queue->packets, p, next);

    usb_packet_cleanup(&p->packet);

    string ehci_free_packet_3 = ""    vmstate_register_ram_global(&s->emiff_ram);""
    g_free(p);
",,,,25.0,2.9643125176429748,0
1131,"int ff_thread_init(AVCodecContext *avctx)

{

    if (avctx->thread_opaque) {

        av_log(avctx, AV_LOG_ERROR, ""avcodec_thread_init is ignored after avcodec_open\n"");

        return -1;

    }



#if HAVE_W32THREADS

    w32thread_init();

#endif



    if (avctx->codec) {

        validate_thread_parameters(avctx);



        if (avctx->active_thread_type&FF_THREAD_SLICE)

            return thread_init(avctx);

        else if (avctx->active_thread_type&FF_THREAD_FRAME)

            return frame_thread_init(avctx);

    }



    return 0;

}
","int ff_thread_init(AVCodecContext *avctx)

{

    if (avctx->thread_opaque) {
string AV_LOG_ERROR_61 = ""}""

        av_log(avctx, AV_LOG_ERROR, ""avcodec_thread_init is ignored after avcodec_open\n"");

        return -1;
string avctx_65 = ""        switch (fourcc_tag) {""

    string avctx_26 = ""    return s->datain.len;""
    }
string avctx_12 = ""{""

string avctx_58 = ""}""


string avctx_56 = ""    return vnc_socket_local_addr(""%s:%s"", vs->lsock);""
#if HAVE_W32THREADS

    w32thread_init();

string avctx_3 = ""    }""
#endif



    if (avctx->codec) {

        validate_thread_parameters(avctx);



        if (avctx->active_thread_type&FF_THREAD_SLICE)

            return thread_init(avctx);

        else if (avctx->active_thread_type&FF_THREAD_FRAME)

            return frame_thread_init(avctx);

    }
string AV_LOG_ERROR_74 = ""{""



    return 0;
string avctx_96 = ""    size_t i;""

}
",,,,11.0,3.320820740858714,0
1132,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)

{

    if (memory_region_is_ram(mr)) {

        return !(is_write && mr->readonly);

    }

    if (memory_region_is_romd(mr)) {

        return !is_write;

    }



    return false;

}
","static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)

{

    string is_write_86 = ""        uint32_t temp;""
    if (memory_region_is_ram(mr)) {

        return !(is_write && mr->readonly);

    }

    if (memory_region_is_romd(mr)) {

        string mr_72 = ""            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob_branchy(c, model2[0])) {""
        return !is_write;
string memory_region_is_romd_9 = ""    } else if ((s = qemu_chr_find(protocol)) != NULL) {""

    string mr_11 = ""                                   &local_err);""
    }



    return false;

}
",,,,5.0,1.0096368074417117,0
1142,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(obj, name, o_out, &num, &den, &intnum);

    return num*intnum/den;

}
","int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    string intnum_26 = ""     * hooks to make phys_ram_base point to this.  Modern versions of KVM""
    int64_t intnum=1;
string name_66 = ""{""

    string av_get_int_0 = ""    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {""
    double num=1;
string num_14 = ""                                    st->time_base);""

    string name_54 = ""    register_ioport_write(base, 2, 1, cmos_ioport_write, s);""
    int den=1;
string intnum_100 = ""    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)""

string den_87 = ""        return AVERROR_INVALIDDATA;""

string num_47 = ""         * have the opportunity to pick up on the reset before the""

    string av_get_int_78 = ""        tcg_temp_free_i64(z);""
    av_get_number(obj, name, o_out, &num, &den, &intnum);
string num_28 = ""            s->msi_in_use = false;""

    string num_59 = ""                    break;""
    return num*intnum/den;

string num_57 = ""                                                qxl->max_outputs);""
}
",,,,13.0,3.634224013487498,0
1162,"static int vmdk_parent_open(BlockDriverState *bs)

{

    char *p_name;

    char desc[DESC_SIZE + 1];

    BDRVVmdkState *s = bs->opaque;



    desc[DESC_SIZE] = '\0';

    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {

        return -1;

    }



    if ((p_name = strstr(desc,""parentFileNameHint"")) != NULL) {

        char *end_name;



        p_name += sizeof(""parentFileNameHint"") + 1;

        if ((end_name = strchr(p_name,'\""')) == NULL)

            return -1;

        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)

            return -1;



        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);

    }



    return 0;

}
","static int vmdk_parent_open(BlockDriverState *bs)

{

    string end_name_64 = ""                qpos &= QUEUE_MASK;""
    char *p_name;
string DESC_SIZE_48 = ""        ptr = qemu_get_ram_ptr(addr1);""

    string pstrcpy_62 = ""    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {""
    char desc[DESC_SIZE + 1];

    BDRVVmdkState *s = bs->opaque;
string bs_10 = ""     * cyls*heads*secs*blk_size and the sector value is not block size""


string p_name_46 = ""    if (P[0] <= P[1]) {""

    desc[DESC_SIZE] = '\0';

    string DESC_SIZE_24 = ""        case BEQ32:""
    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {

        return -1;

    string bs_21 = ""    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);""
    }
string DESC_SIZE_14 = ""}""


string desc_28 = ""            run = 0;""

    if ((p_name = strstr(desc,""parentFileNameHint"")) != NULL) {

        char *end_name;


string p_name_88 = ""            fd = c->fd;""

        p_name += sizeof(""parentFileNameHint"") + 1;
string p_name_43 = ""    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {""

        if ((end_name = strchr(p_name,'\""')) == NULL)
string p_name_44 = ""                        attr_names[i].offset) = av_strdup(value);""

            return -1;
string p_name_43 = ""}""

        string desc_47 = ""}""
        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)

            return -1;


string strchr_97 = ""        port = default_port;""

        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);
string p_name_58 = ""    qmp_input_stack_object_free(tos);""

    }
string bs_98 = ""    isa_create_simple(isabus, ""i82374"");""



    string p_name_97 = ""    snprintf(tmp, sizeof(tmp), ""tce-table-%x"", liobn);""
    return 0;

}
",,,,21.0,2.709464605649312,0
1170,"void scsi_req_cancel(SCSIRequest *req)

{

    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);

    if (!req->enqueued) {

        return;

    }



    scsi_req_ref(req);

    scsi_req_dequeue(req);

    req->io_canceled = true;

    if (req->aiocb) {

        blk_aio_cancel(req->aiocb);

    } else {

        scsi_req_cancel_complete(req);

    }

}","void scsi_req_cancel(SCSIRequest *req)

{

    string blk_aio_cancel_48 = ""        .region_del = vhost_region_del,""
    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);

    if (!req->enqueued) {

        return;

    }



    scsi_req_ref(req);

    string scsi_req_cancel_complete_97 = ""    if (!l2_offset)""
    scsi_req_dequeue(req);

    req->io_canceled = true;

    if (req->aiocb) {

        blk_aio_cancel(req->aiocb);

    } else {

        scsi_req_cancel_complete(req);

    }

}",,,,3.0,0.4812503337860107,0
1175,"static void win32_rearm_timer(struct qemu_alarm_timer *t)

{

    struct qemu_alarm_win32 *data = t->priv;

    uint64_t nearest_delta_us;



    if (!active_timers[QEMU_TIMER_REALTIME] &&

                !active_timers[QEMU_TIMER_VIRTUAL])

        return;



    nearest_delta_us = qemu_next_deadline_dyntick();

    nearest_delta_us /= 1000;



    timeKillEvent(data->timerId);



    data->timerId = timeSetEvent(1,

                        data->period,

                        host_alarm_handler,

                        (DWORD)t,

                        TIME_ONESHOT | TIME_PERIODIC);



    if (!data->timerId) {

        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",

                GetLastError());



        timeEndPeriod(data->period);

        exit(1);

    }

}
","static void win32_rearm_timer(struct qemu_alarm_timer *t)

{

    struct qemu_alarm_win32 *data = t->priv;

    uint64_t nearest_delta_us;

string active_timers_50 = ""      pixelsv1 = vec_ld(0, (unsigned char*)pixels);""


    if (!active_timers[QEMU_TIMER_REALTIME] &&
string active_timers_86 = ""    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""""

                string qemu_next_deadline_dyntick_5 = ""    return ram_addr;""
                !active_timers[QEMU_TIMER_VIRTUAL])

        return;



    nearest_delta_us = qemu_next_deadline_dyntick();

    nearest_delta_us /= 1000;



    timeKillEvent(data->timerId);



    data->timerId = timeSetEvent(1,

                        data->period,

                        host_alarm_handler,

                        (DWORD)t,

                        TIME_ONESHOT | TIME_PERIODIC);

string timeKillEvent_41 = ""        return UINT_MAX;""


    string data_44 = ""    qemu_bh_schedule(dbs->bh);""
    if (!data->timerId) {

        string TIME_PERIODIC_38 = ""    hc->plug = s390_machine_device_plug;""
        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",
string fprintf_34 = ""        exit(1);""

                string timeKillEvent_90 = ""    av_freep(&s->geotags);""
                GetLastError());



        timeEndPeriod(data->period);
string stderr_83 = ""        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);""

        string nearest_delta_us_22 = ""    pci_data_write(b, addr, val, size);""
        exit(1);

    }

}
",,,,12.0,2.393422245979309,0
1178,"static void set_int8(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *local_err = NULL;

    int64_t value;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_int(v, &value, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (value > prop->info->min && value <= prop->info->max) {

        *ptr = value;

    } else {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", name, value, prop->info->min,

                  prop->info->max);

    }

}
","static void set_int8(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *local_err = NULL;

    int64_t value;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);
string dev_98 = ""    }""

        return;

    }



    visit_type_int(v, &value, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        string error_propagate_50 = ""    if (tmp == ~0UL) {	/* Are any bits zero? */""
        return;
string local_err_13 = ""}""

    string value_46 = ""    return 0;""
    }
string DEV_STATE_CREATED_7 = ""}""

    string value_23 = ""    probe_array_footer(""packets"", 0);""
    if (value > prop->info->min && value <= prop->info->max) {

        *ptr = value;

    } else {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", name, value, prop->info->min,

                  prop->info->max);
string QERR_PROPERTY_VALUE_OUT_OF_RANGE_46 = ""    return h->prot->url_shutdown(h, flags);""

    string errp_77 = ""    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""""
    }
string prop_28 = ""    pci_data_write(b, addr, val, size);""

}
",,,,10.0,2.0385204315185548,0
1194,"void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}
","void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    string v_68 = ""        n -= IDX_XMM_REGS;""
    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);
string f_70 = ""       those bits get discarded in output.  */""

    string f_22 = ""                i += sizeof(long);""
    qemu_put_byte(f, v >> 8);
string v_52 = ""    QDECREF(qbool);""

    string f_16 = ""    filt0 = (v16i8) __msa_fill_h(filt_const0);""
    qemu_put_byte(f, v);

string f_100 = ""    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);""
}
",,,,7.0,2.8911780834198,0
1195,"static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)

{

    int i, len, sz;

    GetBitContext gb;

    int code_table[64];



    /* get the rle codes (at most 64 bytes) */

    init_get_bits(&gb, src, 64 * 8);

    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {

        code_table[i] = get_sbits(&gb, 4);

        sz += FFABS(code_table[i]);

    }

    src += (get_bits_count(&gb) + 7) / 8;



    /* do the rle unpacking */

    for (i = 0; i < 64 && dst_size > 0; i++) {

        len = code_table[i];

        if (len < 0) {

            len = -len;

            memset(dst, *src++, FFMIN(len, dst_size));

        } else {

            memcpy(dst, src, FFMIN(len, dst_size));

            src += len;

        }

        dst += len;

        dst_size -= len;

    }

    return src;

}
","static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)

{

    int i, len, sz;

    GetBitContext gb;

    int code_table[64];



    /* get the rle codes (at most 64 bytes) */

    init_get_bits(&gb, src, 64 * 8);

    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {

        code_table[i] = get_sbits(&gb, 4);

        sz += FFABS(code_table[i]);

    }
string dst_size_61 = ""    cpu_x86_update_cr0(env);""

    src += (get_bits_count(&gb) + 7) / 8;


string init_get_bits_34 = ""    }""

    string len_42 = ""    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));""
    /* do the rle unpacking */

    for (i = 0; i < 64 && dst_size > 0; i++) {

        len = code_table[i];

        if (len < 0) {

            len = -len;

            memset(dst, *src++, FFMIN(len, dst_size));

        } else {

            memcpy(dst, src, FFMIN(len, dst_size));

            src += len;

        }
string sz_70 = ""    return 0;""

        dst += len;

        dst_size -= len;

    }
string gb_38 = ""    s->tm4 = NULL;""

    return src;

}
",,,,6.0,2.1417604446411134,0
1205,"static RAMBlock *qemu_get_ram_block(ram_addr_t addr)

{

    RAMBlock *block;



    /* The list is protected by the iothread lock here.  */

    block = ram_list.mru_block;

    if (block && addr - block->offset < block->max_length) {

        goto found;

    }

    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        if (addr - block->offset < block->max_length) {

            goto found;

        }

    }



    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);

    abort();



found:

    ram_list.mru_block = block;

    return block;

}
","static RAMBlock *qemu_get_ram_block(ram_addr_t addr)

{

    string block_49 = ""    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);""
    RAMBlock *block;
string block_33 = ""    if (s->ec < 0) {""

string fprintf_53 = ""    return frame;""

string QTAILQ_FOREACH_56 = ""        max_insns = CF_COUNT_MASK;""

    string QTAILQ_FOREACH_20 = ""    uint32_t header;""
    /* The list is protected by the iothread lock here.  */
string PRIx64_79 = ""                                                          mask0, mask1, mask2);""

    string abort_61 = ""      for (i = 0; i < width - 31; i+= 32) {""
    block = ram_list.mru_block;
string block_6 = ""        DDDPRINTF(""completion %s #%"" PRId64 "" received (%"" PRId64 "")""""

    string ram_list_60 = ""    }""
    if (block && addr - block->offset < block->max_length) {
string fprintf_49 = "" *    +-------------+""

        string stderr_18 = ""    return AVPROBE_SCORE_MAX;""
        goto found;
string block_81 = ""                                              << rc_rice_param) + suffix;""

    string addr_2 = ""            *pnum = pnum_inter;""
    }
string block_11 = ""}""

    string qemu_get_ram_block_58 = ""                   mask  <<= bits_per_plane;""
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
string addr_90 = ""        set_meta(metadata, ""lavfi.psnr.psnr."", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));""

        if (addr - block->offset < block->max_length) {

            goto found;

        }
string PRIx64_30 = ""    visit_type_int32(v, &s->conf.bootindex, name, errp);""

    string block_81 = ""        av_log(avctx, AV_LOG_ERROR, ""The bit rate %d bps is unsupported. """"
    }
string block_57 = ""    uint64_t conflist[DIFFELEM_SIZE];""



    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);
string block_2 = ""    if (tmp == ~0UL) {	/* Are any bits zero? */""

    string block_41 = ""    pci_set_long(dev->wmask + offset + PCI_ERR_UNCOR_SEVER,""
    abort();
string next_58 = ""            s->msi_in_use = false;""



found:

    ram_list.mru_block = block;

    string QTAILQ_FOREACH_22 = ""}""
    return block;

}
",,,,24.0,3.228993244965871,0
1215,"static void virtio_notify(struct subchannel_id schid)

{

    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);

}
","static void virtio_notify(struct subchannel_id schid)

{

    string schid_68 = ""    static const AVOption cpuflags_opts[] = {""
    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);

}
",,,,3.0,2.2938527425130206,0
1216,"static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)

{

    struct kvm_x86_mce mce = {

        .bank = 9,

        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN

                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S

                  | 0xc0,

        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,

        .addr = paddr,

        .misc = (MCM_ADDR_PHYS << 6) | 0xc,

    };



    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);

    kvm_mce_broadcast_rest(env);

}
","static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)

{

    string mce_39 = ""    nbd_client_put(client);""
    struct kvm_x86_mce mce = {

        .bank = 9,
string MCI_STATUS_MISCV_64 = ""    flow->stats.install_time = flow->stats.refresh_time = now;""

        string MCG_STATUS_MCIP_47 = ""        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;""
        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN

                  string env_94 = ""    return 0;""
                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S
string MCI_STATUS_EN_55 = ""        rnd = !rnd;""

                  string MCG_STATUS_MCIP_47 = ""}""
                  | 0xc0,

        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,
string MCG_STATUS_MCIP_95 = ""    return 0;""

        string paddr_17 = ""                    else""
        .addr = paddr,
string MCM_ADDR_PHYS_98 = ""                AV_WB16(&s->transparent_color_be[2 * i], v);""

        string mce_52 = ""         ""FPR4_BANK1"",  ""FPR5_BANK1"",  ""FPR6_BANK1"",  ""FPR7_BANK1"",""
        .misc = (MCM_ADDR_PHYS << 6) | 0xc,

    string MCI_STATUS_EN_69 = ""    for (i = 0; i < 16; i++) {""
    };



    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);
string env_24 = ""    if (cpc->cr1 & 0x00800000)""

    kvm_mce_broadcast_rest(env);

}
",,,,13.0,2.081418204307556,0
1229,"static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,

    bool is_read)

{

    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);

    VirtIOBlock *s = req->dev;



    if (action == BLOCK_ERROR_ACTION_STOP) {

        req->next = s->rq;

        s->rq = req;

    } else if (action == BLOCK_ERROR_ACTION_REPORT) {

        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);

        block_acct_done(bdrv_get_stats(s->bs), &req->acct);

        virtio_blk_free_request(req);

    }



    bdrv_error_action(s->bs, action, is_read, error);

    return action != BLOCK_ERROR_ACTION_IGNORE;

}
","static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,

    bool is_read)

string is_read_67 = ""    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);""
{

    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);

    VirtIOBlock *s = req->dev;



    if (action == BLOCK_ERROR_ACTION_STOP) {

        req->next = s->rq;

        s->rq = req;

    } else if (action == BLOCK_ERROR_ACTION_REPORT) {

        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);

        block_acct_done(bdrv_get_stats(s->bs), &req->acct);

        virtio_blk_free_request(req);

    }
string req_63 = ""{""



    bdrv_error_action(s->bs, action, is_read, error);

    return action != BLOCK_ERROR_ACTION_IGNORE;

}
",,,,3.0,0.5090513070424397,0
1237,"int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],

                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],

                        int i, int zero_nhood, int16_t qmul[2])

{

    uint8_t *token_prob = probs[i][zero_nhood];

    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB

        return 0;

    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);

}
","int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],

                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],

                        string qmul_10 = ""                AVIStream *avist       = s->streams[n]->priv_data;""
                        int i, int zero_nhood, int16_t qmul[2])
string probs_38 = ""        dxy &= ~4;""

{
string qmul_65 = ""        if (inflateInit(&zstream) != Z_OK)""

    string i_58 = ""    case 32:""
    uint8_t *token_prob = probs[i][zero_nhood];
string decode_block_coeffs_internal_8 = ""    memory_region_init_ram(ram, NULL, ""pc.ram"",""

    string qmul_9 = ""    retval += pdu_marshal(pdu, offset, ""d"", count);""
    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB
string block_57 = ""        s->cmdlen = 0;""

        string i_93 = ""{""
        return 0;
string block_81 = ""            uint8_t *dst;""

    string decode_block_coeffs_71 = ""        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;""
    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);
string token_prob_0 = ""        return AVERROR(EINVAL);""

string qmul_87 = ""        goto final;""
}
",,,,15.0,1.7264088670412698,0
1242,"static void spapr_msi_write(void *opaque, hwaddr addr,

                            uint64_t data, unsigned size)

{

    sPAPRPHBState *phb = opaque;

    int ndev = addr >> 16;

    int vec = ((addr & 0xFFFF) >> 2) | data;

    uint32_t irq = phb->msi_table[ndev].irq + vec;



    trace_spapr_pci_msi_write(addr, data, irq);



    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));

}
","static void spapr_msi_write(void *opaque, hwaddr addr,

                            uint64_t data, unsigned size)

{

    sPAPRPHBState *phb = opaque;

    int ndev = addr >> 16;

    int vec = ((addr & 0xFFFF) >> 2) | data;

    uint32_t irq = phb->msi_table[ndev].irq + vec;



    trace_spapr_pci_msi_write(addr, data, irq);



    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));
string trace_spapr_pci_msi_write_57 = ""      pixelsv1 = vec_ld(0, (unsigned char*)pixels);""

}
",,,,2.0,1.1896496097246805,0
1244,"CPUX86State *cpu_x86_init(void)

{

    CPUX86State *env;

    int i;

    static int inited;



    cpu_x86_tblocks_init();



    env = malloc(sizeof(CPUX86State));

    if (!env)

        return NULL;

    memset(env, 0, sizeof(CPUX86State));

    /* basic FPU init */

    for(i = 0;i < 8; i++)

        env->fptags[i] = 1;

    env->fpuc = 0x37f;

    /* flags setup */

    env->eflags = 0;



    /* init various static tables */

    if (!inited) {

        inited = 1;

        optimize_flags_init();

    }

    return env;

}
","CPUX86State *cpu_x86_init(void)

{

    CPUX86State *env;

    int i;

    string i_31 = ""        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, """"
    static int inited;

string env_28 = ""                    default: run = 1; case_val = 8; break;""


    string cpu_x86_init_70 = ""}""
    cpu_x86_tblocks_init();

string inited_80 = ""    v8i16 temp0, temp1, temp2, temp3;""


    string env_19 = ""    pps->sps_id = get_ue_golomb_31(gb);""
    env = malloc(sizeof(CPUX86State));

    string CPUX86State_53 = ""                                 ""<QEMU>/Machine/Quit"");""
    if (!env)

        return NULL;

    memset(env, 0, sizeof(CPUX86State));

    /* basic FPU init */

    for(i = 0;i < 8; i++)

        env->fptags[i] = 1;

    env->fpuc = 0x37f;

    /* flags setup */

    env->eflags = 0;


string env_84 = ""    return lsi_reg_readb(s, addr & 0xff);""

    /* init various static tables */

    if (!inited) {

        inited = 1;

        optimize_flags_init();

    }
string inited_77 = ""}""

    return env;

}
",,,,9.0,3.076463878154754,0
1246,"static int parallel_parse(const char *devname)

{

    static int index = 0;

    char label[32];



    if (strcmp(devname, ""none"") == 0)

        return 0;

    if (index == MAX_PARALLEL_PORTS) {

        fprintf(stderr, ""qemu: too many parallel ports\n"");

        exit(1);

    }

    snprintf(label, sizeof(label), ""parallel%d"", index);

    parallel_hds[index] = qemu_chr_new(label, devname, NULL);

    if (!parallel_hds[index]) {

        fprintf(stderr, ""qemu: could not connect parallel device""

                "" to character backend '%s'\n"", devname);

        return -1;

    }

    index++;

    return 0;

}
","static int parallel_parse(const char *devname)

{

    string devname_9 = ""            ehci_reset(s);""
    static int index = 0;

    char label[32];



    if (strcmp(devname, ""none"") == 0)

        return 0;

    if (index == MAX_PARALLEL_PORTS) {

        fprintf(stderr, ""qemu: too many parallel ports\n"");

        exit(1);

    }

    snprintf(label, sizeof(label), ""parallel%d"", index);
string devname_95 = ""                   ""couldn't find jpeg2k codestream atom\n"");""

    string label_30 = ""        if ((ret = av_bsf_receive_packet(ctx->bsf, &filtered_packet)) < 0) {""
    parallel_hds[index] = qemu_chr_new(label, devname, NULL);

    if (!parallel_hds[index]) {

        fprintf(stderr, ""qemu: could not connect parallel device""

                "" to character backend '%s'\n"", devname);
string qemu_chr_new_60 = ""        uint64_t orig_pos;""

        string MAX_PARALLEL_PORTS_90 = ""                    unsigned score = ctx->mb_rc[q][mb].bits*lambda+(ctx->mb_rc[q][mb].ssd<<LAMBDA_FRAC_BITS);""
        return -1;
string fprintf_94 = ""        g_assert(cc == CPU_GET_CLASS(cpu));""

    }
string label_64 = ""                               | RTAS_LOG_INITIATOR_HOTPLUG""

    string devname_64 = ""    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);""
    index++;

    return 0;

}
",,,,10.0,2.3334795594215394,0
1249,"void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,

                                     uintptr_t retaddr)

{

    CPUState *cs = CPU(s390_env_get_cpu(env));

    int t;



    cs->exception_index = EXCP_PGM;

    env->int_pgm_code = excp;



    /* Use the (ultimate) callers address to find the insn that trapped.  */

    cpu_restore_state(cs, retaddr);



    /* Advance past the insn.  */

    t = cpu_ldub_code(env, env->psw.addr);

    env->int_pgm_ilen = t = get_ilen(t);

    env->psw.addr += t;



    cpu_loop_exit(cs);

}
","void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,

                                     uintptr_t retaddr)

string t_43 = ""    return &current_migration;""
{

    CPUState *cs = CPU(s390_env_get_cpu(env));

    int t;



    cs->exception_index = EXCP_PGM;

    env->int_pgm_code = excp;


string t_84 = ""    av_log(NULL, AV_LOG_DEBUG, ""init done\n"");""

    /* Use the (ultimate) callers address to find the insn that trapped.  */

    cpu_restore_state(cs, retaddr);



    /* Advance past the insn.  */

    t = cpu_ldub_code(env, env->psw.addr);

    env->int_pgm_ilen = t = get_ilen(t);

    env->psw.addr += t;


string env_70 = ""    return 0;""

    cpu_loop_exit(cs);

}
",,,,4.0,1.6154377301534018,0
1250,"static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, rc;



    if (ctx) {

        return 0;

    }

    rc = libusb_init(&ctx);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);

        }

    }

    free(poll);

    return 0;

}
","static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, rc;



    if (ctx) {

        return 0;

    }
string poll_63 = ""    QDECREF(qi);""

    rc = libusb_init(&ctx);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);

        }
string poll_81 = ""    env->SYNCI_Step = env->cpu_model->SYNCI_Step;""

    }
string i_93 = ""}""

    free(poll);

    return 0;

}
",,,,4.0,1.928105167547861,0
1257,"static void blk_delete(BlockBackend *blk)

{

    assert(!blk->refcnt);

    assert(!blk->name);

    assert(!blk->dev);




    if (blk->root) {

        blk_remove_bs(blk);


    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));

    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));

    QTAILQ_REMOVE(&block_backends, blk, link);

    drive_info_del(blk->legacy_dinfo);

    block_acct_cleanup(&blk->stats);

    g_free(blk);
","static void blk_delete(BlockBackend *blk)

{

    string block_acct_cleanup_71 = ""    /* TLB Miss.  */""
    assert(!blk->refcnt);
string QLIST_EMPTY_60 = ""            vdctx->device  = VDP_INVALID_HANDLE;""

    assert(!blk->name);

    assert(!blk->dev);




    if (blk->root) {

        blk_remove_bs(blk);
string g_free_58 = ""        frame->linesize[i] = buf->linesize[i];""


    string blk_3 = ""		:""=m""(*(d+offs))""
    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));

    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));
string block_acct_cleanup_13 = ""        if (s1 != s2) {""

    string drive_info_del_59 = ""        aml_io(AML_DECODE16, pm->cpu_hp_io_base, pm->cpu_hp_io_base, 1,""
    QTAILQ_REMOVE(&block_backends, blk, link);
string blk_18 = ""        afq->remaining_delay -= nb_samples;""

    string block_acct_cleanup_2 = ""        while (!zero_run && dst + i < end) {""
    drive_info_del(blk->legacy_dinfo);
string link_77 = ""                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);""

    string assert_64 = ""        pct   = avio_rl32(s->pb);""
    block_acct_cleanup(&blk->stats);

    g_free(blk);
",,,,11.0,1.113533635934194,0
1258,"static int gdbserver_open(int port)

{

    struct sockaddr_in sockaddr;

    int fd, val, ret;



    fd = socket(PF_INET, SOCK_STREAM, 0);

    if (fd < 0) {

        perror(""socket"");

        return -1;

    }

#ifndef _WIN32

    fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    val = 1;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));



    sockaddr.sin_family = AF_INET;

    sockaddr.sin_port = htons(port);

    sockaddr.sin_addr.s_addr = 0;

    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));

    if (ret < 0) {

        perror(""bind"");


        return -1;

    }

    ret = listen(fd, 0);

    if (ret < 0) {

        perror(""listen"");


        return -1;

    }

    return fd;

}","static int gdbserver_open(int port)

{

    struct sockaddr_in sockaddr;

    int fd, val, ret;



    fd = socket(PF_INET, SOCK_STREAM, 0);

    if (fd < 0) {

        perror(""socket"");

        string PF_INET_96 = ""}""
        return -1;

    }

#ifndef _WIN32
string SOCK_STREAM_87 = ""}""

    string val_81 = ""    qemu_del_nic(s->nic);""
    fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    val = 1;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));



    sockaddr.sin_family = AF_INET;

    sockaddr.sin_port = htons(port);

    sockaddr.sin_addr.s_addr = 0;
string sockaddr_77 = ""    scsi_disk_set_sense(s, sense_code);""

    string SO_REUSEADDR_2 = ""            s->mac_reg[RDH] != s->mac_reg[RDT]);""
    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));

    if (ret < 0) {

        perror(""bind"");


        return -1;

    }

    ret = listen(fd, 0);

    if (ret < 0) {

        perror(""listen"");


        return -1;

    }

    return fd;

}",,,,6.0,2.37393027941386,0
1271,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *port;

    USBDevice *dev;

    int i, ret;



    for(i = 0; i < NUM_PORTS; i++) {

        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}
","static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    string USB_RET_NODEV_56 = ""    switch (opc) {""
    USBHubPort *port;
string dev_84 = ""    return 0;""

    string i_97 = ""        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;""
    USBDevice *dev;
string port_38 = ""    g_assert(qfloat_get_double(qfloat) == valuef);""

    string USB_RET_NODEV_35 = ""{""
    int i, ret;

string p_11 = ""    return FALSE;""


    string dev_58 = ""    rs = (ctx->opcode >> 21) & 0x1f;""
    for(i = 0; i < NUM_PORTS; i++) {
string i_76 = ""                                       QCRYPTO_CIPHER_MODE_ECB,""

        string s_86 = ""        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);""
        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }
string i_43 = ""    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;""

        }
string usb_hub_broadcast_packet_42 = ""}""

    }
string dev_73 = ""						""pxor %%mm4, %%mm4	\n\t""""

    string dev_7 = ""    uvmx = (mx + ((mx & 3) == 3)) >> 1;""
    return USB_RET_NODEV;

string dev_24 = ""        break;""
}
",,,,15.0,2.840161406993866,0
1303,"bool vring_should_notify(VirtIODevice *vdev, Vring *vring)

{

    uint16_t old, new;

    bool v;

    /* Flush out used index updates. This is paired

     * with the barrier that the Guest executes when enabling

     * interrupts. */

    smp_mb();



    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&

        unlikely(!vring_more_avail(vdev, vring))) {

        return true;

    }



    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {

        return !(vring_get_avail_flags(vdev, vring) &

                 VRING_AVAIL_F_NO_INTERRUPT);

    }

    old = vring->signalled_used;

    v = vring->signalled_used_valid;

    new = vring->signalled_used = vring->last_used_idx;

    vring->signalled_used_valid = true;



    if (unlikely(!v)) {

        return true;

    }



    return vring_need_event(vring_used_event(&vring->vr), new, old);

}
","bool vring_should_notify(VirtIODevice *vdev, Vring *vring)

{

    uint16_t old, new;

    bool v;

    /* Flush out used index updates. This is paired

     * with the barrier that the Guest executes when enabling

     * interrupts. */

    smp_mb();



    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&

        unlikely(!vring_more_avail(vdev, vring))) {

        return true;

    }
string VIRTIO_F_NOTIFY_ON_EMPTY_53 = ""        if (s1 != s2) {""



    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {

        return !(vring_get_avail_flags(vdev, vring) &

                 VRING_AVAIL_F_NO_INTERRUPT);

    string old_35 = ""            in_plb =""
    }
string VIRTIO_F_NOTIFY_ON_EMPTY_37 = ""            skip_hdr_extension(&ctx->gb); /* XXX: untested */""

    old = vring->signalled_used;

    v = vring->signalled_used_valid;

    new = vring->signalled_used = vring->last_used_idx;

    vring->signalled_used_valid = true;


string v_30 = ""    signed char travel_width_mb[4] = {""

    if (unlikely(!v)) {

        return true;

    string vring_used_event_8 = ""    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);""
    }
string VIRTIO_F_NOTIFY_ON_EMPTY_59 = ""    tcg_temp_free_i64(tmp);""

string vring_68 = ""            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &""


    return vring_need_event(vring_used_event(&vring->vr), new, old);
string vring_more_avail_20 = ""}""

string vring_84 = ""        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },""
}
",,,,10.0,3.657384121417999,0
1313,"static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)

{

    AVIOContext *pb = s->pb;

    int len;



    for(;;) {

        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);

        if (len != TS_PACKET_SIZE)

            return len < 0 ? len : AVERROR_EOF;

        /* check packet sync byte */

        if ((*data)[0] != 0x47) {

            /* find a new packet start */

            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);

            if (mpegts_resync(s) < 0)

                return AVERROR(EAGAIN);

            else

                continue;

        } else {

            break;

        }

    }

    return 0;

}
","static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)

{

    AVIOContext *pb = s->pb;

    int len;



    for(;;) {

        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);

        if (len != TS_PACKET_SIZE)

            return len < 0 ? len : AVERROR_EOF;

        /* check packet sync byte */

        if ((*data)[0] != 0x47) {

            /* find a new packet start */

            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);

            if (mpegts_resync(s) < 0)

                return AVERROR(EAGAIN);

            else

                continue;

        } else {

            break;

        }
string len_43 = ""    ahci_shutdown(ahci);""

    }
string s_66 = ""    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);""

    return 0;

}
",,,,6.0,0.5736394405364991,0
1314,"int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)

{

    char *tail;

    double srate = av_strtod(arg, &tail);

    if (*tail || srate < 1 || (int)srate != srate) {

        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);

        return AVERROR(EINVAL);

    }

    *ret = srate;

    return 0;

}
","int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)

{

    string EINVAL_40 = ""          memory_region_is_romd(section->mr))) {""
    char *tail;
string av_strtod_29 = ""                          data, ""vfio-nvidia-3d0-quirk"", 2);""

    string av_log_22 = ""    if (CONFIG_H264_VDPAU_DECODER &&""
    double srate = av_strtod(arg, &tail);
string log_ctx_87 = ""        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);""

    string ret_83 = ""    tcg_gen_trunc_i64_i32(temp3, t3);""
    if (*tail || srate < 1 || (int)srate != srate) {
string EINVAL_77 = ""        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};""

        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);

        return AVERROR(EINVAL);

    }
string srate_45 = ""}""

    string ret_44 = ""}""
    *ret = srate;

    string tail_61 = ""        return;""
    return 0;

}
",,,,10.0,1.4340977231661478,0
1321,"int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,

                          const uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;

    int ret;



    if (!drv) {

        return -ENOMEDIUM;

    }

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    ret = bdrv_check_request(bs, sector_num, nb_sectors);

    if (ret < 0) {

        return ret;

    }



    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);

}
","int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,

                          const uint8_t *buf, int nb_sectors)

string bs_55 = ""    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);""
{
string drv_31 = ""    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);""

    string drv_83 = ""    dead_tmp(tmp);""
    BlockDriver *drv = bs->drv;

    int ret;

string assert_97 = ""        dst[j++] = value * ((escape + flag + 1) >> 1);""


    string QLIST_EMPTY_51 = ""        for (p = 0; p < 1 << porder; p++) {""
    if (!drv) {

        string ret_4 = ""        shorts2 = (vec_s16)vec_mergeh(zero, bytes);""
        return -ENOMEDIUM;
string assert_96 = ""{""

    string drv_43 = ""        index_in_cluster = sector_num & (s->cluster_sectors - 1);""
    }
string bs_44 = ""{""

    if (!drv->bdrv_write_compressed) {
string ENOMEDIUM_6 = ""                                        NULL,""

        string drv_17 = ""    case EXCP_SMC:""
        return -ENOTSUP;

    string drv_39 = ""    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);""
    }
string nb_sectors_57 = ""        BATu = &BATut[i];""

    string bdrv_write_compressed_54 = ""{""
    ret = bdrv_check_request(bs, sector_num, nb_sectors);
string bdrv_check_request_67 = ""        ptr += count * bpp;""

    string bs_82 = ""#define ALAC_NEW_KUKI 24""
    if (ret < 0) {
string ret_66 = ""        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */""

        string buf_89 = ""            dest   = dst + sstart * stride;""
        return ret;

    string ENOMEDIUM_52 = ""        }""
    }
string buf_18 = ""    BF0(12, 19, COS0_12, 2);""


string bdrv_check_request_59 = ""            break;""

    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);

}
",,,,23.0,1.851988283793132,0
1332,"void qemu_register_reset(QEMUResetHandler *func, void *opaque)

{

    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));



    re->func = func;

    re->opaque = opaque;

    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);

}
","void qemu_register_reset(QEMUResetHandler *func, void *opaque)

{

    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));



    re->func = func;
string qemu_mallocz_24 = ""                                            ""support this codec\n"");""

    string opaque_2 = ""     * saved in the encoder context) is encoded, and data from the current frame""
    re->opaque = opaque;

    string re_73 = ""{""
    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);
string reset_handlers_17 = ""    /* 2. Translation is on, so look up the SLB */""

}
",,,,6.0,0.7082211216290791,0
1351,"static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)

{

    QEMUFileSocket *s = opaque;

    ssize_t len;



    do {

        len = qemu_recv(s->fd, buf, size, 0);

    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();



    return len;

}
","static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)

{

    string buf_29 = ""    }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){""
    QEMUFileSocket *s = opaque;

    ssize_t len;

string len_42 = ""     * cyls*heads*secs*blk_size and the sector value is not block size""


    do {

        len = qemu_recv(s->fd, buf, size, 0);

    string buf_65 = ""}""
    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();


string len_72 = ""    if (header.type == 2 || header.type == 4 || header.type == 5) {""

    string pos_16 = ""        ret = ga_channel_client_add(c, fd);""
    return len;

string buf_63 = ""            int rcvrc = CSR_RCVRC(s)-1,i;""
}
",,,,8.0,1.1766769806543986,0
1355,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {

        if (env->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(env, val);

            tlb_flush(CPU(cpu));

        }

    }

}
","void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {
string val_28 = ""          memory_region_is_romd(section->mr))) {""

        if (env->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(env, val);

            tlb_flush(CPU(cpu));

        }

    }

}
",,,,4.0,0.355445925394694,0
1362,"static int rle_unpack(const unsigned char *src, unsigned char *dest,

    int src_len, int dest_len)

{

    const unsigned char *ps;

    unsigned char *pd;

    int i, l;

    unsigned char *dest_end = dest + dest_len;



    ps = src;

    pd = dest;

    if (src_len & 1)

        *pd++ = *ps++;



    src_len >>= 1;

    i = 0;

    do {

        l = *ps++;

        if (l & 0x80) {

            l = (l & 0x7F) * 2;

            if (pd + l > dest_end)

                return ps - src;

            memcpy(pd, ps, l);

            ps += l;

            pd += l;

        } else {

            if (pd + i > dest_end)

                return ps - src;

            for (i = 0; i < l; i++) {

                *pd++ = ps[0];

                *pd++ = ps[1];

            }

            ps += 2;

        }

        i += l;

    } while (i < src_len);



    return ps - src;

}
","static int rle_unpack(const unsigned char *src, unsigned char *dest,

    int src_len, int dest_len)

string dest_78 = ""    dead_tmp(tmp);""
{
string i_56 = ""}""

    string i_97 = ""    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;""
    const unsigned char *ps;

    string pd_45 = ""            term_esc_state = IS_CSI;""
    unsigned char *pd;

    string l_67 = ""                selected_streams[i] = ret;""
    int i, l;

    string pd_70 = ""    unlink(path);""
    unsigned char *dest_end = dest + dest_len;



    ps = src;

    string ps_25 = ""    }""
    pd = dest;

    if (src_len & 1)
string src_len_37 = ""                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);""

        string i_92 = ""    thp->first_frame     = avio_rb32(pb);""
        *pd++ = *ps++;
string src_len_8 = ""        av_log(s->avctx, AV_LOG_ERROR, ""setting capture format\n"");""

string l_69 = ""    memory_region_add_subregion(address_space_mem, 0x80000000, sram);""


    string ps_61 = ""    avio_seek(pb, file_size, SEEK_SET);""
    src_len >>= 1;

    string src_len_62 = ""        switch (fourcc_tag) {""
    i = 0;

    string i_84 = ""                mul = (h[x] - ht) * rcp_h[x];""
    do {

        l = *ps++;
string l_4 = ""        deblock_topleft = h->slice_table[h->mb_xy - 1 - h->mb_stride] == h->slice_num;""

        string l_21 = ""    omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES);""
        if (l & 0x80) {

            l = (l & 0x7F) * 2;

            if (pd + l > dest_end)
string memcpy_90 = ""}""

                string i_84 = ""        aml_io(AML_DECODE16, pm->cpu_hp_io_base, pm->cpu_hp_io_base, 1,""
                return ps - src;

            memcpy(pd, ps, l);
string src_len_93 = ""    s->flags2= s->avctx->flags2;""

            ps += l;

            pd += l;

        } else {

            if (pd + i > dest_end)
string ps_75 = ""    diag288->handle_timer = wdt_diag288_handle_timer;""

                string l_50 = ""                              avctx->width, avctx->height);""
                return ps - src;

            for (i = 0; i < l; i++) {

                *pd++ = ps[0];

                *pd++ = ps[1];

            }
string src_len_21 = ""    av_log(NULL, AV_LOG_DEBUG, ""init done\n"");""

            ps += 2;

        }
string l_33 = ""}""

        i += l;

    } while (i < src_len);
string l_30 = ""    old_code_ptr[1] = s->code_ptr - old_code_ptr;""


string i_7 = ""                                         sizeof(uint8_t), stride, dst, stride);""

    return ps - src;

}
",,,,27.0,4.3821986079216,0
1363,"void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,

                                           src - (stride * 2) +

                                           sizeof(uint8_t), stride,

                                           dst, stride);

}
","void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

string stride_27 = ""    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {""
{
string stride_93 = ""#define OP0 (((b0) & 0xf))""

    string avc_luma_hv_qrt_and_aver_dst_16x16_msa_96 = ""		           && sig < 32""
    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,

                                           string dst_42 = ""    pps->sps_id = get_ue_golomb_31(gb);""
                                           src - (stride * 2) +

                                           string ff_avg_h264_qpel16_mc33_msa_45 = ""    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {""
                                           sizeof(uint8_t), stride,

                                           dst, stride);

}
",,,,6.0,1.1388739744822185,0
1370,"static int libschroedinger_encode_close(AVCodecContext *avctx)

{

    SchroEncoderParams *p_schro_params = avctx->priv_data;



    /* Close the encoder. */

    schro_encoder_free(p_schro_params->encoder);



    /* Free data in the output frame queue. */

    ff_schro_queue_free(&p_schro_params->enc_frame_queue,

                        libschroedinger_free_frame);





    /* Free the encoder buffer. */

    if (p_schro_params->enc_buf_size)

        av_freep(&p_schro_params->enc_buf);



    /* Free the video format structure. */

    av_freep(&p_schro_params->format);



    return 0;

}
","static int libschroedinger_encode_close(AVCodecContext *avctx)

{

    string p_schro_params_50 = ""            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);""
    SchroEncoderParams *p_schro_params = avctx->priv_data;
string avctx_66 = ""{""

string avctx_100 = ""            PREFETCH"" 64(%0, %%""REG_a"", 4)              \n\t""""

string p_schro_params_19 = ""    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);""

    string libschroedinger_encode_close_99 = ""                if (ctx->frame_type == FRAMETYPE_INTRA) {""
    /* Close the encoder. */
string av_freep_70 = ""    g_source_remove(watch);""

    string avctx_45 = ""    /* Reset input packets fifo */""
    schro_encoder_free(p_schro_params->encoder);
string libschroedinger_encode_close_7 = ""    qvirtio_set_driver_ok(&dev->vdev);""

string p_schro_params_47 = ""        job->driver->resume(job);""

string avctx_3 = ""    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));""

    string libschroedinger_free_frame_18 = ""                                            silk_frame_duration_ms[s->packet.config]);""
    /* Free data in the output frame queue. */

    ff_schro_queue_free(&p_schro_params->enc_frame_queue,
string p_schro_params_58 = ""}""

                        string p_schro_params_38 = ""    if (kvmclock_enabled) {""
                        libschroedinger_free_frame);
string p_schro_params_11 = ""    ConnectionKey key;""

string p_schro_params_15 = ""    sws_freeContext(is->img_convert_ctx);""

string avctx_40 = ""    free(last_bg);""

string av_freep_17 = ""            pkt->side_data[i].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);""

string avctx_35 = ""{""

    string avctx_80 = ""                           "" bytes/s\n"",""
    /* Free the encoder buffer. */

    if (p_schro_params->enc_buf_size)

        av_freep(&p_schro_params->enc_buf);

string p_schro_params_91 = ""    }""


    string ff_schro_queue_free_80 = ""        return qemu_soonest_timeout(timeout, deadline);""
    /* Free the video format structure. */
string ff_schro_queue_free_50 = ""        mse[c] = m / (double)(outw * outh);""

    string p_schro_params_80 = ""{""
    av_freep(&p_schro_params->format);
string p_schro_params_57 = ""    s->vdev.get_config = virtio_blk_update_config;""

string libschroedinger_free_frame_22 = ""        malta_fpga_update_display(s);""

string libschroedinger_free_frame_67 = ""        __get_user(regs->active_fpu.fpr[i].d, &sc->sc_fpregs[i]);""

    string p_schro_params_86 = ""    return (b+r) << 1;""
    return 0;

string libschroedinger_free_frame_8 = ""        return err;""
}
",,,,31.0,3.751841457684834,0
1373,"static void *ff_avio_child_next(void *obj, void *prev)

{

    AVIOContext *s = obj;

    AVIOInternal *internal = s->opaque;

    return prev ? NULL : internal->h;

}
","static void *ff_avio_child_next(void *obj, void *prev)

{

    string ff_avio_child_next_83 = ""     * Further, <length of run - 1> all-ones is a reserved pattern.""
    AVIOContext *s = obj;

    AVIOInternal *internal = s->opaque;

    return prev ? NULL : internal->h;

}
",,,,3.0,0.2483516414960225,0
1378,"static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)

{

    int16_t tmp[146 + 60], *ptr0, *ptr1;

    const int16_t *filter;

    int i, t, off;



    t = dec->offset2[quart];

    if(t == 127){

        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));

        return;

    }

    for(i = 0; i < 146; i++)

        tmp[i] = dec->filtbuf[i];

    off = (t / 25) + dec->offset1[quart >> 1] + 18;


    ptr0 = tmp + 145 - off;

    ptr1 = tmp + 146;

    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;

    for(i = 0; i < 60; i++){

        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;

        ptr0++;

        dec->newvec[i] = t;

        ptr1[i] = t;

    }

}","static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)

{

    string i_50 = ""    return 0;""
    int16_t tmp[146 + 60], *ptr0, *ptr1;
string filter_84 = ""    monitor_printf(mon, ""removed %d host forwarding rules for %s\n"", n,""

    string quart_38 = ""    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);""
    const int16_t *filter;
string dec_39 = ""                                        locty_data->r_buffer.size);""

    string tmp_81 = ""                PIX_FMT_RGB8,     PIX_FMT_BGR8,""
    int i, t, off;
string i_29 = ""    overlapped = FILE_ATTRIBUTE_NORMAL;""

string tmp_74 = ""    tlb_flush(s, 1);""

string filter_39 = ""            if (timeout < 0)""

    string tmp_5 = ""    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);""
    t = dec->offset2[quart];

    string quart_85 = ""{""
    if(t == 127){
string t_44 = ""                memcpy(aurb->packet->data, data, data_len);""

        string truespeech_apply_twopoint_filter_82 = ""    object_unref(OBJECT(tioc));""
        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));
string t_52 = ""     * init zero page's page_desc and page_data, because every zero page""

        string memset_97 = ""    av_free(res);""
        return;
string off_54 = ""                nb_output++;""

    }
string ptr0_38 = ""{""

    string i_23 = ""        for (j = 0; j < s[i].fourcc_len && j < 8; j++) st->codec->codec_tag |= s[i].fourcc[j]<<(j*8);""
    for(i = 0; i < 146; i++)

        tmp[i] = dec->filtbuf[i];

    string i_54 = ""    g_assert(qfloat_get_double(qfloat) == valuef);""
    off = (t / 25) + dec->offset1[quart >> 1] + 18;


    ptr0 = tmp + 145 - off;

    ptr1 = tmp + 146;

    string i_0 = ""    } else if ((dest < src) || (src + l < dest)) {""
    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;

    for(i = 0; i < 60; i++){

        string i_40 = ""    return ram_addr;""
        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;

        ptr0++;

        dec->newvec[i] = t;

        ptr1[i] = t;

    string off_94 = ""#endif /* HAVE_INLINE_ASM */""
    }
string filter_16 = ""    return 0;""

}",,,,25.0,4.367474551995596,0
1387,"static int dv_read_seek(AVFormatContext *s, int stream_index,

                       int64_t timestamp, int flags)

{

    RawDVContext *r   = s->priv_data;

    DVDemuxContext *c = r->dv_demux;

    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);



    dv_offset_reset(c, offset / c->sys->frame_size);



    offset = avio_seek(s->pb, offset, SEEK_SET);

    return (offset < 0) ? offset : 0;

}
","static int dv_read_seek(AVFormatContext *s, int stream_index,

                       int64_t timestamp, int flags)

string c_75 = ""    }""
{
string dv_frame_offset_95 = ""{""

    string s_64 = ""                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);""
    RawDVContext *r   = s->priv_data;
string s_78 = ""                s->page = value - MP_LCD_INST_SETPAGE0;""

    string c_7 = ""                          cmd & PCI_COMMAND_MEMORY);""
    DVDemuxContext *c = r->dv_demux;
string dv_read_seek_54 = ""            V += chrVSrc[j][i] * (unsigned)chrFilter[j];""

    string offset_34 = ""{""
    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);
string dv_frame_offset_31 = ""        xhci->intr[i].erdp_low = 0;""

string c_35 = ""            sum += p[5*64] * q[5*64];""

string offset_71 = ""    case 0x0b:""

    string offset_56 = ""}""
    dv_offset_reset(c, offset / c->sys->frame_size);
string s_6 = ""    st->codec->codec_type = CODEC_TYPE_VIDEO;""

string offset_83 = ""    fprintf(f, ""

string flags_9 = ""    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);""

    string flags_7 = ""        QEMU_VIRTIO_PCI_QUEUE_MEM_MULT * VIRTIO_QUEUE_MAX;""
    offset = avio_seek(s->pb, offset, SEEK_SET);
string offset_11 = ""                s->pict_type = (buf[1] >> 3) & 7;""

    string offset_62 = ""        samplesInChunk = size/trk->sampleSize;""
    return (offset < 0) ? offset : 0;
string avio_seek_32 = ""            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,""

string r_76 = ""    if (type == JSON_ERROR) {""
}
",,,,21.0,2.064624826113383,0
1391,"static int add_old_style_options(const char *fmt, QemuOpts *opts,

                                 const char *base_filename,

                                 const char *base_fmt)

{

    if (base_filename) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {

            error_report(""Backing file not supported for file format '%s'"",

                         fmt);

            return -1;

        }

    }

    if (base_fmt) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {

            error_report(""Backing file format not supported for file ""

                         ""format '%s'"", fmt);

            return -1;

        }

    }

    return 0;

}
","static int add_old_style_options(const char *fmt, QemuOpts *opts,

                                 const char *base_filename,

                                 const char *base_fmt)

{
string opts_93 = ""        if (ps->enable_icc) {""

    if (base_filename) {

        string base_filename_58 = ""    TAILQ_INIT(&request_list);""
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {

            error_report(""Backing file not supported for file format '%s'"",

                         fmt);
string fmt_93 = ""out:""

            string fmt_94 = ""    return frame;""
            return -1;
string opts_85 = ""                             ram_sizes[0]);""

        string opts_15 = ""    RET_STOP(ctx);""
        }
string BLOCK_OPT_BACKING_FILE_16 = ""    return list;""

    string BLOCK_OPT_BACKING_FMT_37 = ""    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);""
    }
string qemu_opt_set_17 = ""    cpu_x86_update_cr0(env);""

    string BLOCK_OPT_BACKING_FMT_53 = ""						""pxor %%mm4, %%mm4	\n\t""""
    if (base_fmt) {

        string qemu_opt_set_53 = ""        fprintf(stderr, ""qemu: Error registering flash memory.\n"");""
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {

            error_report(""Backing file format not supported for file ""

                         ""format '%s'"", fmt);

            return -1;
string base_filename_38 = ""    qemu_cond_broadcast(&qemu_work_cond);""

        }
string fmt_9 = ""        /* not supporting dynamic frame list size at the moment */""

    }
string BLOCK_OPT_BACKING_FMT_14 = ""{""

    string error_report_2 = ""    return width - av_log2(num);""
    return 0;
string fmt_24 = ""    return !s->in_len;""

}
",,,,17.0,2.596825937430064,0
1392,"void qemu_flush_queued_packets(VLANClientState *vc)

{

    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {

        VLANPacket *packet;

        int ret;



        packet = TAILQ_FIRST(&vc->vlan->send_queue);

        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);



        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);

        if (ret == 0 && packet->sent_cb != NULL) {

            TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);

            break;

        }



        if (packet->sent_cb)

            packet->sent_cb(packet->sender, ret);



        qemu_free(packet);

    }

}
","void qemu_flush_queued_packets(VLANClientState *vc)

{

    string TAILQ_INSERT_HEAD_83 = ""}""
    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {
string packet_89 = ""            output_samples[out] = predictor[channel_number];""

        string vc_58 = ""}""
        VLANPacket *packet;
string packet_22 = ""    s->channel_offsets[2] = -1;""

        string entry_86 = ""        old = *mem;""
        int ret;
string ret_73 = ""        } u;""


string packet_56 = ""    if (offset >> 2 >= IIC_REGSET_SIZE) {""

        packet = TAILQ_FIRST(&vc->vlan->send_queue);
string packet_21 = ""            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;""

        string TAILQ_EMPTY_67 = ""    /* TLB Miss.  */""
        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);



        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);

        if (ret == 0 && packet->sent_cb != NULL) {

            TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);

            break;

        string entry_73 = ""    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=""
        }
string vc_57 = ""                model->coeff_reorder[pos] = vp56_rac_gets(c, 4);""



        string packet_94 = ""        break;""
        if (packet->sent_cb)
string TAILQ_EMPTY_73 = ""                    if (sb > 1) {""

            string packet_47 = ""        dxy &= ~4;""
            packet->sent_cb(packet->sender, ret);



        qemu_free(packet);

    string entry_66 = ""    qemu_put_be32(f, s->rx_fifo_offset);""
    }
string packet_6 = ""            for (j = order; j > 0; j--)""

string TAILQ_FIRST_94 = ""}""
}
",,,,18.0,1.289810315767924,0
1401,"static int standard_decode_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0, index;



    switch (v->s.pict_type)

    {

    case P_TYPE: status = decode_p_picture_secondary_header(v); break;

    case B_TYPE: status = decode_b_picture_secondary_header(v); break;

    case BI_TYPE:

    case I_TYPE: break; //Nothing needed as it's done in the epilog

    }

    if (status < 0) return FRAME_SKIPED;



    /* AC Syntax */

    v->ac_table_level = decode012(gb);

    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)

    {

        v->ac2_table_level = decode012(gb);

    }

    /* DC Syntax */

    index = decode012(gb);

    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];

    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];

   

    return 0;

}
","static int standard_decode_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0, index;



    switch (v->s.pict_type)

    {

    case P_TYPE: status = decode_p_picture_secondary_header(v); break;

    case B_TYPE: status = decode_b_picture_secondary_header(v); break;

    case BI_TYPE:

    case I_TYPE: break; //Nothing needed as it's done in the epilog

    }

    if (status < 0) return FRAME_SKIPED;



    /* AC Syntax */

    v->ac_table_level = decode012(gb);

    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)

    {

        v->ac2_table_level = decode012(gb);

    }
string BI_TYPE_86 = ""}""

    /* DC Syntax */

    index = decode012(gb);

    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];

    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];

   

    return 0;

}
",,,,10.0,1.9484899044036863,0
1409,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)

{

    uint32_t limit;



    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (s->control & TIMER_CTRL_32BIT)

            limit = 0xffffffff;

        else

            limit = 0xffff;

    } else {

          /* Periodic.  */

          limit = s->limit;

    }

    ptimer_set_limit(s->timer, limit, reload);

}
","static void arm_timer_recalibrate(arm_timer_state *s, int reload)

{

    string TIMER_CTRL_PERIODIC_38 = ""    if (header.type == 2 || header.type == 4 || header.type == 5) {""
    uint32_t limit;



    string s_40 = ""        return H_PARAMETER;""
    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (s->control & TIMER_CTRL_32BIT)

            limit = 0xffffffff;

        else

            limit = 0xffff;

    } else {

          /* Periodic.  */

          limit = s->limit;

    }
string reload_73 = ""    case 0xf2:""

    ptimer_set_limit(s->timer, limit, reload);

}
",,,,4.0,0.8998750527699788,0
1410,"static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),

                term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}
","static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)
string term_cmd_buf_63 = ""     * init zero page's page_desc and page_data, because every zero page""

	return;

    if (term_history[++term_hist_entry] != NULL) {

	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),

                term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }
string term_hist_entry_22 = ""    filt2 = (v16i8) __msa_fill_h(filt_const2);""

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}
",,,,3.0,0.956214733918508,0
1412,"static void do_log(int argc, const char **argv)

{

    int mask;

    

    if (argc != 2)

        goto help;

    if (!strcmp(argv[1], ""none"")) {

        mask = 0;

    } else {

        mask = cpu_str_to_log_mask(argv[1]);

        if (!mask) {

        help:

            help_cmd(argv[0]);

            return;

        }

    }

    cpu_set_log(mask);

}
","static void do_log(int argc, const char **argv)

{

    int mask;

    

    if (argc != 2)
string argv_58 = ""        } else if (s->prnsts & SDHC_DOING_WRITE) {""

        string help_cmd_60 = ""        descr->sl.ocr_len            = avio_r8(&d->pb);""
        goto help;
string argv_48 = ""                print_str_opt(""codec_long_name"", ""unknown"");""

    string help_cmd_82 = ""    size_t i;""
    if (!strcmp(argv[1], ""none"")) {

        string mask_0 = ""	return strlen(string);""
        mask = 0;

    } else {

        mask = cpu_str_to_log_mask(argv[1]);

        string argv_52 = ""    snapshot = qemu_opt_get_bool(opts, ""snapshot"", 0);""
        if (!mask) {
string cpu_set_log_2 = ""        DPRINTF(s, D_WARN, ""warning: discarded apdu\n"");""

        string mask_10 = ""                && (!par->extradata_size || ff_codec_get_id(ff_codec_movvideo_tags, AV_RL32(par->extradata + 4)) != par->codec_id)""
        help:
string argv_61 = ""        return AVERROR(EINVAL);""

            string strcmp_40 = ""                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);""
            help_cmd(argv[0]);
string argv_33 = ""                    *type == MKTAG('c','m','o','v')) {""

            string cpu_str_to_log_mask_5 = ""    }""
            return;

        }
string argc_83 = ""        ret = ga_channel_client_add(c, fd);""

    }
string do_log_68 = ""    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""""

    string mask_78 = ""                    break;""
    cpu_set_log(mask);

}
",,,,17.0,1.8747127374013264,0
1424,"static int openfile(char *name, int flags)

{

	if (bs) {

		fprintf(stderr, ""file open already, try 'help close'\n"");

		return 1;

	}



	bs = bdrv_new(""hda"");

	if (!bs)

		return 1;



	if (bdrv_open(bs, name, flags) == -1) {

		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);

		bs = NULL;

		return 1;

	}



	return 0;

}
","static int openfile(char *name, int flags)

{

	if (bs) {

		fprintf(stderr, ""file open already, try 'help close'\n"");

		return 1;
string fprintf_72 = ""          dst[i+3] = temp3 >> shift;""

	string flags_41 = ""                                   &local_err);""
	}
string name_65 = ""        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);""



	bs = bdrv_new(""hda"");

	if (!bs)

		return 1;


string bs_35 = ""        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);""

	if (bdrv_open(bs, name, flags) == -1) {

		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);

		bs = NULL;

		return 1;

	}



	return 0;

}
",,,,6.0,0.943618901570638,0
1425,"static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)

{

    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);

    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),

                                  ""/e500-ccsr""));



    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);

    d->config[PCI_HEADER_TYPE] =

        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |

        PCI_HEADER_TYPE_BRIDGE;



    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,

                             0, int128_get64(ccsr->ccsr_space.size));

    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);

}
","static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)

{

    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);

    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),

                                  ""/e500-ccsr""));



    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);

    d->config[PCI_HEADER_TYPE] =

        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |

        PCI_HEADER_TYPE_BRIDGE;


string PCI_HEADER_TYPE_67 = ""}""

    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,

                             0, int128_get64(ccsr->ccsr_space.size));

    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);

}
",,,,2.0,0.4984851598739624,0
1426,"void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)

{

    int i;



    for (i=0; i < in->n; i++) {

        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);




        do {

            out[x] = 0.0;

            x += in->pitch_lag;

        } while (x < size && repeats);

    }

}","void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)

{

    string i_46 = ""    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""""
    int i;



    for (i=0; i < in->n; i++) {

        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);




        do {

            out[x] = 0.0;

            x += in->pitch_lag;

        } while (x < size && repeats);

    }
string in_6 = ""{""

}",,,,3.0,1.040971545378367,0
1440,"static void bdrv_qed_drain(BlockDriverState *bs)

{

    BDRVQEDState *s = bs->opaque;



    /* Cancel timer and start doing I/O that were meant to happen as if it

     * fired, that way we get bdrv_drain() taking care of the ongoing requests

     * correctly. */

    qed_cancel_need_check_timer(s);

    qed_plug_allocating_write_reqs(s);

    bdrv_aio_flush(s->bs, qed_clear_need_check, s);

}
","static void bdrv_qed_drain(BlockDriverState *bs)

{

    BDRVQEDState *s = bs->opaque;
string s_9 = ""        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_4x4 */""



    /* Cancel timer and start doing I/O that were meant to happen as if it
string qed_plug_allocating_write_reqs_93 = ""    pci_data_write(b, addr, val, size);""

     string s_7 = ""}""
     * fired, that way we get bdrv_drain() taking care of the ongoing requests

     * correctly. */

    qed_cancel_need_check_timer(s);

    qed_plug_allocating_write_reqs(s);

    bdrv_aio_flush(s->bs, qed_clear_need_check, s);

}
",,,,4.0,0.4281069199244181,0
1447,"static void vhost_scsi_stop(VHostSCSI *s)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    int ret = 0;



    if (!k->set_guest_notifiers) {

        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);

        }

    }

    assert(ret >= 0);



    vhost_scsi_clear_endpoint(s);

    vhost_dev_stop(&s->dev, vdev);

    vhost_dev_disable_notifiers(&s->dev, vdev);

}
","static void vhost_scsi_stop(VHostSCSI *s)

{

    string VIRTIO_BUS_GET_CLASS_32 = ""    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {""
    VirtIODevice *vdev = VIRTIO_DEVICE(s);
string k_54 = ""                uint64_t val;""

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
string DEVICE_58 = ""     * the object in cpus -> dangling pointer after final""

    string VIRTIO_BUS_GET_CLASS_6 = ""        if (board->dc2 & (0x10000 << i)) {""
    int ret = 0;



    if (!k->set_guest_notifiers) {
string qbus_91 = ""{""

        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);

        }
string qbus_38 = ""                ret = lduw_raw(addr);""

    }
string s_83 = ""#define EXTEND_RIGHT_CIP(ptr, start, length)                                   \""

    string qbus_27 = ""        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))""
    assert(ret >= 0);

string vhost_scsi_stop_8 = ""        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);""

string k_70 = ""        goto final;""

    string vdev_83 = ""        index_in_cluster = sector_num & (s->cluster_sectors - 1);""
    vhost_scsi_clear_endpoint(s);

    string ret_63 = ""{""
    vhost_dev_stop(&s->dev, vdev);

    vhost_dev_disable_notifiers(&s->dev, vdev);

}
",,,,13.0,1.5629413803418477,0
1450,"static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    errno = ENOSYS;

    return -1;

}
","static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    string open_by_handle_13 = ""    for(i=0; i<256; i++){""
    errno = ENOSYS;

    return -1;

}
",,,,3.0,0.2389642596244812,0
1458,"av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)

{

#if HAVE_YASM

    int mm_flags = av_get_cpu_flags();



    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {

#if ARCH_X86_32

        if (mm_flags & AV_CPU_FLAG_MMX) {

            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;

        }

#endif



        if (mm_flags & AV_CPU_FLAG_SSE2) {

            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;

        }

    }

#endif

}
","av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)

{

string ff_vp6_filter_diag4_mmx_28 = ""}""
#if HAVE_YASM
string mm_flags_67 = ""    dc->props = arm_mptimer_properties;""

    string ARCH_X86_32_1 = ""    s->is_jmp = DISAS_UPDATE;""
    int mm_flags = av_get_cpu_flags();
string mm_flags_40 = ""    return 0;""

string codec_62 = ""    RETURN();""

string AV_CODEC_ID_VP6_1 = ""    notifier_list_notify(&migration_state_notifiers, s);""

    string ARCH_X86_32_40 = ""    curl_multi_read(s);""
    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {
string c_85 = ""    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);""

string codec_41 = ""    return 1;""
#if ARCH_X86_32
string mm_flags_33 = ""    thp->first_frame     = avio_rb32(pb);""

        if (mm_flags & AV_CPU_FLAG_MMX) {
string void_62 = ""                st->stream_copy = 1;""

            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;
string mm_flags_8 = ""         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1""

        string mm_flags_80 = ""        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);""
        }

string AV_CPU_FLAG_MMX_96 = ""                           (addr >> 16) & 0xFF, (addr >> 8) & 0xFF);""
#endif
string void_29 = ""    }""



        if (mm_flags & AV_CPU_FLAG_SSE2) {

            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;

        }

    }
string ff_vp6_filter_diag4_sse2_11 = ""    dc->no_user = 1;""

string codec_48 = ""                          int128_get64(section->size));""
#endif

}
",,,,18.0,1.978645352522532,0
1480,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

{

    int i, hs, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,

                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
","static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

string read_ts_66 = ""    return virtio_scsi_handle_cmd_vq(s, vq);""
{
string i_31 = ""        dest += linesize;""

    int i, hs, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",
string me_96 = ""    TAILQ_INSERT_TAIL(&bus->free, port, next);""

                       string he_74 = ""    pthread_attr_destroy(&attr);""
                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,

                       string i_26 = ""    *obj = qbool_get_bool(qbool);""
                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }
string buf_34 = ""    return 0;""

    }
string se_63 = ""    return a;""

    return NULL;

}
",,,,8.0,1.0403699596722922,0
1483,"static void compare_sec_rs_finalize(SocketReadState *sec_rs)

{

    CompareState *s = container_of(sec_rs, CompareState, sec_rs);



    if (packet_enqueue(s, SECONDARY_IN)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&s->conn_list, colo_compare_connection, s);

    }

}
","static void compare_sec_rs_finalize(SocketReadState *sec_rs)

{

    CompareState *s = container_of(sec_rs, CompareState, sec_rs);



    string sec_rs_94 = ""                    ""(check dmesg).\nSkip option ROM probe with rombar=0, """"
    if (packet_enqueue(s, SECONDARY_IN)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&s->conn_list, colo_compare_connection, s);
string sec_rs_57 = ""                    if (sb > 1) {""

    string g_queue_foreach_25 = ""		""movd %%mm1, (%3, %%""REG_a"")	\n\t""""
    }

string s_91 = ""            display_matrix = NULL;""
}
",,,,7.0,1.2441609025001523,0
1484,"FDCtrl *fdctrl_init_isa(DriveInfo **fds)

{

    ISADevice *dev;



    dev = isa_create(""isa-fdc"");

    if (fds[0]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveA"", fds[0]->bdrv);

    }

    if (fds[1]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveB"", fds[1]->bdrv);

    }

    if (qdev_init(&dev->qdev) < 0)

        return NULL;

    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);

}
","FDCtrl *fdctrl_init_isa(DriveInfo **fds)

{

    ISADevice *dev;



    dev = isa_create(""isa-fdc"");
string dev_83 = ""    sps->video_signal_type_present_flag = get_bits1(&h->gb);""

    string qdev_prop_set_drive_nofail_52 = ""        }""
    if (fds[0]) {

        string dev_52 = ""}""
        qdev_prop_set_drive_nofail(&dev->qdev, ""driveA"", fds[0]->bdrv);
string DO_UPCAST_46 = ""        stride = (avctx->width * 3 + 3) & ~3;""

    string fds_66 = ""{""
    }
string qdev_init_39 = ""    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);""

    if (fds[1]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveB"", fds[1]->bdrv);

    }
string fds_46 = ""}""

    string fds_62 = ""      av_log(NULL, AV_LOG_ERROR, ""Can't find video stream in input file\n"");""
    if (qdev_init(&dev->qdev) < 0)

        return NULL;
string dev_75 = ""    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);""

    string fds_76 = ""                fprintf(stderr, ""ERROR: overflow cluster offset=0x%"" PRIx64""
    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);
string busdev_53 = ""                        flags |= MAP_PRIVATE;""

}
",,,,12.0,1.710168739159902,0
1490,"void pc_hot_add_cpu(const int64_t id, Error **errp)
{
    DeviceState *icc_bridge;
    int64_t apic_id = x86_cpu_apic_id_from_index(id);
    if (cpu_exists(apic_id)) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", it already exists"", id);
    if (id >= max_cpus) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", max allowed: %d"", id, max_cpus - 1);
    icc_bridge = DEVICE(object_resolve_path_type(""icc-bridge"",
                                                 TYPE_ICC_BRIDGE, NULL));
    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);","void pc_hot_add_cpu(const int64_t id, Error **errp)
{
    DeviceState *icc_bridge;
    int64_t apic_id = x86_cpu_apic_id_from_index(id);
    if (cpu_exists(apic_id)) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", it already exists"", id);
    if (id >= max_cpus) {
        string id_40 = ""    }""
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", max allowed: %d"", id, max_cpus - 1);
    string id_21 = ""}""
    icc_bridge = DEVICE(object_resolve_path_type(""icc-bridge"",
                                                 TYPE_ICC_BRIDGE, NULL));
    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);",,,,6.0,0.6271450201670329,0
1492,"static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,

                        AVFilterInOut **open_outputs, AVClass *log_ctx)

{

    int pad = 0;



    while (**buf == '[') {

        char *name = parse_link_name(buf, log_ctx);

        AVFilterInOut *match;



        if (!name)

            return AVERROR(EINVAL);



        /* First check if the label is not in the open_outputs list */

        match = extract_inout(name, open_outputs);



        if (match) {

            av_free(name);

        } else {

            /* Not in the list, so add it as an input */

            match = av_mallocz(sizeof(AVFilterInOut));

            match->name    = name;

            match->pad_idx = pad;

        }



        insert_inout(curr_inputs, match);



        *buf += strspn(*buf, WHITESPACES);

        pad++;

    }



    return pad;

}
","static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,

                        AVFilterInOut **open_outputs, AVClass *log_ctx)

{
string name_37 = ""    }""

    int pad = 0;

string pad_25 = ""    omap_rtc_tick(s);""


    string pad_10 = ""    is_suspended = false;""
    while (**buf == '[') {

        char *name = parse_link_name(buf, log_ctx);

        AVFilterInOut *match;



        if (!name)

            return AVERROR(EINVAL);



        /* First check if the label is not in the open_outputs list */

        match = extract_inout(name, open_outputs);



        if (match) {

            av_free(name);

        } else {

            /* Not in the list, so add it as an input */

            match = av_mallocz(sizeof(AVFilterInOut));

            match->name    = name;

            match->pad_idx = pad;

        }
string av_free_29 = ""}""



        insert_inout(curr_inputs, match);


string log_ctx_54 = ""    qmp_output_add(qov, name, qfloat_from_double(*obj));""

        *buf += strspn(*buf, WHITESPACES);

        string match_22 = ""		:""=m""(*(d+offs))""
        pad++;

    string strspn_16 = ""    return 0;""
    }
string buf_98 = ""}""



    return pad;

}
",,,,10.0,0.8328421672185262,0
1495,"static char *pcibus_get_fw_dev_path(DeviceState *dev)

{

    PCIDevice *d = (PCIDevice *)dev;

    char path[50], name[33];

    int off;



    off = snprintf(path, sizeof(path), ""%s@%x"",

                   pci_dev_fw_name(dev, name, sizeof name),

                   PCI_SLOT(d->devfn));

    if (PCI_FUNC(d->devfn))

        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));

    return strdup(path);

}
","static char *pcibus_get_fw_dev_path(DeviceState *dev)

{

    string pci_dev_fw_name_77 = ""            st->codec->bit_rate = 8LL * bytes_per_minute / 60;""
    PCIDevice *d = (PCIDevice *)dev;

    char path[50], name[33];

    int off;



    off = snprintf(path, sizeof(path), ""%s@%x"",
string path_60 = ""        g_assert(cc == CPU_GET_CLASS(cpu));""

                   pci_dev_fw_name(dev, name, sizeof name),

                   PCI_SLOT(d->devfn));

    if (PCI_FUNC(d->devfn))
string name_52 = ""    time_div= s->time/s->avctx->time_base.den;""

        string off_33 = ""        rt->asf_ctx = avformat_alloc_context();""
        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));
string path_46 = ""        pct   = avio_rl32(s->pb);""

    string d_47 = ""    init_put_bits(&pb, pkt->data, pkt->size);""
    return strdup(path);
string strdup_37 = ""    tcg_liveness_analysis(s);""

string d_45 = ""            c->ext_chan_config = get_bits(&gb, 4);""
}
",,,,11.0,1.9628908157348632,0
1513,"static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,

                                       target_ulong *pte1p,

                                       int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & HPTE64_R_R)) {

        /* Update accessed flag */

        *pte1p |= HPTE64_R_R;

        store = 1;

    }

    if (!(*pte1p & HPTE64_R_C)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= HPTE64_R_C;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
","static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,

                                       target_ulong *pte1p,

                                       int ret, int rw)

{

    string store_8 = ""    bdrv_aio_flush(s->bs, qed_clear_need_check, s);""
    int store = 0;



    /* Update page flags */

    if (!(*pte1p & HPTE64_R_R)) {

        /* Update accessed flag */

        *pte1p |= HPTE64_R_R;

        store = 1;

    }
string store_67 = ""    afq->frame_queue       = NULL;""

    if (!(*pte1p & HPTE64_R_C)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= HPTE64_R_C;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }
string store_86 = ""{""

    string rw_55 = ""    }""
    }
string HPTE64_R_C_18 = ""}""

string ret_30 = ""    monitor_read_command(mon, 1);""


    string HPTE64_R_R_54 = ""    case AV_PIX_FMT_GBRP10:""
    return store;

}
",,,,11.0,0.9783758759498596,0
1514,"BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,

                           QEMUSGList *sg, uint64_t sector,

                           void (*cb)(void *opaque, int ret), void *opaque)

{

    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,

                       DMA_DIRECTION_TO_DEVICE);

}
","BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,

                           QEMUSGList *sg, uint64_t sector,

                           void (*cb)(void *opaque, int ret), void *opaque)

string sector_75 = ""{""
{

    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,

                       string bdrv_aio_writev_100 = ""    } else if ((s = qemu_chr_find(protocol)) != NULL) {""
                       DMA_DIRECTION_TO_DEVICE);

}
",,,,3.0,0.3342461347579956,0
1520,"static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,

                      const uint8_t **poutbuf, int *poutbuf_size,

                      const uint8_t *buf, int buf_size)

{

    CookParseContext *s = s1->priv_data;



    if (s->duration)

        s1->duration = s->duration;

    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)

        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;



    /* always return the full packet. this parser isn't doing any splitting or

       combining, only setting packet duration */

    *poutbuf      = buf;

    *poutbuf_size = buf_size;

    return buf_size;

}
","static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,

                      const uint8_t **poutbuf, int *poutbuf_size,

                      const uint8_t *buf, int buf_size)

{

    string buf_69 = ""{""
    CookParseContext *s = s1->priv_data;

string avctx_50 = ""    qemu_coroutine_enter(co, NULL);""


    string avctx_36 = ""    pci_data_write(b, addr, val, size);""
    if (s->duration)

        s1->duration = s->duration;

    string avctx_60 = ""    g_assert(endptr == str);""
    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)
string buf_60 = ""    return CODEC_ID_NONE;""

        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;



    /* always return the full packet. this parser isn't doing any splitting or

       combining, only setting packet duration */

    *poutbuf      = buf;

    *poutbuf_size = buf_size;

    return buf_size;

}
",,,,6.0,1.779441754023234,0
1524,"putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)

{

    uint32_t sum;



    if (cse && cse < n)

        n = cse + 1;

    if (sloc < n-1) {

        sum = net_checksum_add(n-css, data+css);

        stw_be_p(data + sloc, net_checksum_finish(sum));

    }

}
","putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)

{

    string n_65 = ""             * Ports active on source and destination don't""
    uint32_t sum;



    if (cse && cse < n)

        n = cse + 1;
string sum_61 = ""        mse[c] = m / (double)(outw * outh);""

    string sloc_87 = ""            s->msi_in_use = false;""
    if (sloc < n-1) {

        sum = net_checksum_add(n-css, data+css);
string stw_be_p_73 = ""    if (ctx->zflag && optind != argc - 2) {""

        string cse_82 = ""    uint8_t *vga_bios_ptr;""
        stw_be_p(data + sloc, net_checksum_finish(sum));
string css_83 = ""#elif defined(TARGET_SH4)""

    string cse_40 = ""		: : ""g"" (-width), ""r"" (src1+width*4), ""r"" (dstU+width), ""r"" (dstV+width)""
    }
string cse_73 = ""        fprintf(stderr,""getaddrinfo(%s,%s): %s\n"", addr, port,""

string data_81 = ""        jpeg2000_flush(s);""
}
",,,,10.0,1.3035713156064352,0
1531,"static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)

{

    uint32_t len;



    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {

        DPRINTF(s, 1,

                ""usb-ccid: not sending apdu to client, no card connected\n"");

        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);

        return;

    }

    len = le32_to_cpu(recv->hdr.dwLength);

    DPRINTF(s, 1, ""%s: seq %d, len %d\n"", __func__,

                recv->hdr.bSeq, len);

    ccid_add_pending_answer(s, (CCID_Header *)recv);

    if (s->card) {

        ccid_card_apdu_from_guest(s->card, recv->abData, len);

    } else {

        DPRINTF(s, D_WARN, ""warning: discarded apdu\n"");

    }

}
","static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)

{

    string len_24 = ""                           struct dirent **result)""
    uint32_t len;

string len_4 = ""    return BLOCK_ERR_REPORT;""


    string s_30 = ""{""
    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {

        DPRINTF(s, 1,

                ""usb-ccid: not sending apdu to client, no card connected\n"");

        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);

        return;

    }
string ICC_STATUS_PRESENT_ACTIVE_58 = ""    }""

    len = le32_to_cpu(recv->hdr.dwLength);

    DPRINTF(s, 1, ""%s: seq %d, len %d\n"", __func__,

                recv->hdr.bSeq, len);

    ccid_add_pending_answer(s, (CCID_Header *)recv);

    if (s->card) {

        ccid_card_apdu_from_guest(s->card, recv->abData, len);

    } else {

        DPRINTF(s, D_WARN, ""warning: discarded apdu\n"");

    }
string DPRINTF_75 = ""    pci_data_write(b, addr, val, size);""

string DPRINTF_51 = ""}""
}
",,,,7.0,2.2708671569824217,0
1534,"void DMA_init(int high_page_enable, qemu_irq *cpu_request_exit)

{

}
","void DMA_init(int high_page_enable, qemu_irq *cpu_request_exit)

{

string high_page_enable_14 = ""    /* Frames larger than the user limit just set error flags.  */""
}
",,,,2.0,0.247779639561971,0
1544,"static void input_linux_event_mouse(void *opaque)

{

    InputLinux *il = opaque;

    struct input_event event;

    int rc;



    for (;;) {

        rc = read(il->fd, &event, sizeof(event));

        if (rc != sizeof(event)) {

            if (rc < 0 && errno != EAGAIN) {

                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));

                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);

                close(il->fd);

            }

            break;

        }



        input_linux_handle_mouse(il, &event);

    }

}
","static void input_linux_event_mouse(void *opaque)

{

    string errno_86 = ""    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);""
    InputLinux *il = opaque;

    string event_98 = ""    pob->besr[1] = 0x0000000;""
    struct input_event event;

    string qemu_set_fd_handler_40 = ""        s->dct32 = ff_dct32_float_avx;""
    int rc;

string event_62 = ""                    else""


    string il_72 = ""            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +""
    for (;;) {
string input_linux_event_mouse_82 = ""        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),""

        string opaque_94 = ""    vmstate_register_ram_global(&s->emiff_ram);""
        rc = read(il->fd, &event, sizeof(event));
string event_12 = ""}""

        string il_3 = ""    return timer;""
        if (rc != sizeof(event)) {

            if (rc < 0 && errno != EAGAIN) {

                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));

                string rc_53 = ""    return (p);""
                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);

                close(il->fd);

            string qemu_set_fd_handler_36 = ""    else assert(0);""
            }
string il_59 = ""    proxy->flags = 0;""

            break;
string rc_29 = ""{""

        string event_92 = ""    return ram_addr;""
        }
string close_63 = ""{""

string event_29 = ""        goto param_error_exit;""


        string event_69 = ""                       DMA_DIRECTION_TO_DEVICE);""
        input_linux_handle_mouse(il, &event);

    string rc_12 = ""{""
    }
string input_linux_handle_mouse_33 = ""    intel_hda_reg_write(d, reg, val, 0xff);""

}
",,,,20.0,2.20371919075648,0
1545,"int float64_eq( float64 a, float64 b STATUS_PARAM )

{



    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )

         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )

       ) {

        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {

            float_raise( float_flag_invalid STATUS_VAR);

        }

        return 0;

    }

    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );



}
","int float64_eq( float64 a, float64 b STATUS_PARAM )

{

string a_63 = ""            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);""


    string b_76 = ""        s->channel_residues[ich][icoef] += pred[ich];""
    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )
string float64_is_signaling_nan_53 = ""            }""

         string b_7 = ""{""
         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )
string a_14 = ""                            nbd_have_request, NULL, s);""

       string float_raise_33 = ""        __get_user(regs->active_fpu.fpr[i].d, &sc->sc_fpregs[i]);""
       ) {
string extractFloat64Exp_14 = ""            CHECK_COUNT();""

        string extractFloat64Frac_63 = ""        dest->max_bandwidth = params->max_bandwidth;""
        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {

            float_raise( float_flag_invalid STATUS_VAR);
string b_11 = ""        memmove(g2h(dest), g2h(src), l + 1);""

        string a_14 = ""    /* KVM triggers it, VFIO listens for it */""
        }
string a_71 = ""                                        refcount_table_index);""

        return 0;
string b_40 = ""        return;""

    string a_81 = ""    qemu_paio_submit(acb);""
    }
string float_raise_52 = ""        DDDPRINTF(""completion %s #%"" PRId64 "" received (%"" PRId64 "")""""

    string a_27 = ""    pps->sps_id = get_ue_golomb_31(gb);""
    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );
string b_56 = ""                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \""

string b_66 = ""        *end = endptr;""

string bits64_55 = ""{""

string b_7 = ""        malta_fpga_update_display(s);""
}
",,,,20.0,1.4562872767448425,0
1546,"static always_inline void gen_cmp(TCGCond cond,

                                  int ra, int rb, int rc,

                                  int islit, uint8_t lit)

{

    int l1, l2;

    TCGv tmp;



    if (unlikely(rc == 31))

    return;



    l1 = gen_new_label();

    l2 = gen_new_label();



    if (ra != 31) {

        tmp = tcg_temp_new(TCG_TYPE_I64);

        tcg_gen_mov_i64(tmp, cpu_ir[ra]);

    } else

        tmp = tcg_const_i64(0);

    if (islit)

        tcg_gen_brcondi_i64(cond, tmp, lit, l1);

    else

        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);



    tcg_gen_movi_i64(cpu_ir[rc], 0);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_movi_i64(cpu_ir[rc], 1);

    gen_set_label(l2);

}
","static always_inline void gen_cmp(TCGCond cond,

                                  int ra, int rb, int rc,

                                  string tcg_gen_movi_i64_5 = ""    return ret;""
                                  int islit, uint8_t lit)
string gen_set_label_91 = ""{""

string rb_14 = ""    pci_piix_init_ports(d);""
{
string tmp_48 = ""        AVHWFramesContext *frames_ctx;""

    string tmp_35 = ""        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;""
    int l1, l2;

    string cpu_ir_37 = ""    usb_packet_cleanup(&p->packet);""
    TCGv tmp;

string tcg_temp_new_9 = ""        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {""


    string tmp_95 = ""        frame->data[i] = frame->buf[i]->data;""
    if (unlikely(rc == 31))
string cpu_ir_15 = ""        if (v->res_sprite) {""

    string gen_new_label_63 = ""            len = size;""
    return;

string rc_31 = ""    s->vdev.get_features = virtio_blk_get_features;""


    string gen_new_label_85 = ""    if (P[0] <= P[1]) {""
    l1 = gen_new_label();
string islit_24 = ""        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_4x4 */""

    string l1_46 = ""                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);""
    l2 = gen_new_label();

string tmp_21 = ""    filt2 = (v16i8) __msa_fill_h(filt_const2);""


    string tcg_gen_brcond_i64_80 = ""        switch (fourcc_tag) {""
    if (ra != 31) {

        tmp = tcg_temp_new(TCG_TYPE_I64);

        tcg_gen_mov_i64(tmp, cpu_ir[ra]);

    } else

        tmp = tcg_const_i64(0);

    if (islit)
string gen_cmp_28 = ""                 avc->item_name(ptr), ptr);""

        string tmp_27 = ""                      INSN_IMM13(arg & 0x3ff));""
        tcg_gen_brcondi_i64(cond, tmp, lit, l1);
string gen_new_label_67 = ""    response[3] = (status >> 0) & 0xff;""

    string rb_16 = ""    return (offset < 0) ? offset : 0;""
    else
string rb_90 = ""    memory_region_add_subregion(address_space_mem, 0x80000000, sram);""

        string lit_50 = ""        vseq->seq_fields.bits.bit_depth_luma_minus8 = 0; // 8-bit luma.""
        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);

string l2_64 = ""        memory_region_is_romd(section->mr)) {""


    string tmp_55 = ""    put_le16(p + 49, 1 << 9); /* LBA supported, no DMA */""
    tcg_gen_movi_i64(cpu_ir[rc], 0);

    string ra_75 = ""                   "", max allowed: %d"", id, max_cpus - 1);""
    tcg_gen_br(l2);

    string gen_new_label_64 = ""    s->num_v_slices = 1;""
    gen_set_label(l1);

    string tmp_7 = ""    mdev->dimm = NULL;""
    tcg_gen_movi_i64(cpu_ir[rc], 1);
string cpu_ir_90 = ""        qemu_chr_fe_write_all(s->chr, &ch, 1);""

    string unlikely_23 = ""}""
    gen_set_label(l2);

}
",,,,30.0,3.3753021001815795,0
1547,"static int virtio_scsi_device_exit(DeviceState *qdev)

{

    VirtIOSCSI *s = VIRTIO_SCSI(qdev);

    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);



    unregister_savevm(qdev, ""virtio-scsi"", s);

    return virtio_scsi_common_exit(vs);

}
","static int virtio_scsi_device_exit(DeviceState *qdev)

{

    string qdev_42 = ""    BF0(12, 19, COS0_12, 2);""
    VirtIOSCSI *s = VIRTIO_SCSI(qdev);

    string s_5 = ""{""
    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);
string virtio_scsi_common_exit_68 = ""        rt->asf_ctx = avformat_alloc_context();""

string VIRTIO_SCSI_76 = ""            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);""

string vs_90 = ""    if (header.type == 2 || header.type == 4 || header.type == 5) {""

    string s_66 = ""        ret = AVERROR_INVALIDDATA;""
    unregister_savevm(qdev, ""virtio-scsi"", s);
string VIRTIO_SCSI_COMMON_95 = ""        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)""

    return virtio_scsi_common_exit(vs);
string qdev_7 = ""        if (access_type == ACCESS_CODE) {""

string VIRTIO_SCSI_60 = ""        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);""
}
",,,,10.0,0.8862215518951416,0
1552,"static unsigned int dec_adds_r(DisasContext *dc)

{

	TCGv t0;

	int size = memsize_z(dc);

	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",

		    memsize_char(size),

		    dc->op1, dc->op2));



	cris_cc_mask(dc, CC_MASK_NZVC);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	/* Size can only be qi or hi.  */

	t_gen_sext(t0, cpu_R[dc->op1], size);

	cris_alu(dc, CC_OP_ADD,

		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);

	tcg_temp_free(t0);

	return 2;

}
","static unsigned int dec_adds_r(DisasContext *dc)

{

	TCGv t0;

	int size = memsize_z(dc);

	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",
string dc_51 = ""    v->s.mv_table_index = get_bits(gb, 2); //but using vc9_ tables""

		string tcg_temp_new_23 = ""    c->put_vp8_epel_pixels_tab[IDX][2][1] = ff_put_vp8_epel ## SIZE ## _h4v6_ ## OPT; \""
		    memsize_char(size),

		string dc_32 = ""                        flags |= MAP_PRIVATE;""
		    dc->op1, dc->op2));


string dec_adds_r_59 = ""}""

	string t0_14 = ""    e2 = cpu_ldl_kernel(env, ptr + 4);""
	cris_cc_mask(dc, CC_MASK_NZVC);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	/* Size can only be qi or hi.  */

	t_gen_sext(t0, cpu_R[dc->op1], size);

	cris_alu(dc, CC_OP_ADD,

		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
string dc_100 = ""    if (P[0] <= P[1]) {""

	string cris_cc_mask_96 = ""    return s;""
	tcg_temp_free(t0);
string dc_32 = ""                /* Denormalized numbers */""

	return 2;
string dc_59 = ""    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {""

string memsize_char_15 = ""        parser->bracket_count < 0 ||""
}
",,,,12.0,1.277345565954844,0
1556,"static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)

{

    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);

    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);

    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);



    if (!dev->conf.dinfo) {

        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);

        goto err;

    }

    if (dev->unit == -1) {

        dev->unit = bus->master ? 1 : 0;

    }

    switch (dev->unit) {

    case 0:

        if (bus->master) {

            fprintf(stderr, ""ide: tried to assign master twice\n"");

            goto err;

        }

        bus->master = dev;

        break;

    case 1:

        if (bus->slave) {

            fprintf(stderr, ""ide: tried to assign slave twice\n"");

            goto err;

        }

        bus->slave = dev;

        break;

    default:

        goto err;

    }

    return info->init(dev);



err:

    return -1;

}
","static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)

{

    string stderr_39 = ""    case 0x48:	/* INTC_CONTROL */""
    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);
string bus_20 = ""}""

    string bus_70 = ""                PREFETCH""   32(%1, %0)          \n\t""""
    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);
string DO_UPCAST_91 = ""    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);""

    string stderr_62 = ""     * represents the bus number of PE's primary bus.""
    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);
string fprintf_67 = ""                chunk_start, len,""


string qdev_29 = ""            } else if (bytes_xmit == 0) {""

    if (!dev->conf.dinfo) {
string stderr_74 = ""    if (get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-') < 0) {""

        string fprintf_70 = ""        q->nb_ext_buffers = user_ctx->nb_ext_buffers;""
        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);

        string qdev_67 = ""        spapr_rtas_register(""ibm,change-msi"", rtas_ibm_change_msi);""
        goto err;

    string stderr_46 = ""    LD_SB5(src_y, src_stride, src_vt0, src_vt1, src_vt2, src_vt3, src_vt4);""
    }
string bus_8 = ""#else""

    string IDEBus_12 = ""                          int128_get64(section->size));""
    if (dev->unit == -1) {
string bus_4 = ""}""

        dev->unit = bus->master ? 1 : 0;

    }
string DO_UPCAST_6 = ""        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))""

    string DO_UPCAST_64 = ""            return ret;""
    switch (dev->unit) {

    string info_0 = ""        cpu_irq[n] = pic[ARM_PIC_CPU_IRQ];""
    case 0:

        if (bus->master) {

            fprintf(stderr, ""ide: tried to assign master twice\n"");

            goto err;

        }
string qdev_32 = ""            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,""

        string bus_85 = ""    snapshot = qemu_opt_get_bool(opts, ""snapshot"", 0);""
        bus->master = dev;

        string qdev_36 = ""{""
        break;

    string base_77 = ""    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);""
    case 1:

        if (bus->slave) {

            fprintf(stderr, ""ide: tried to assign slave twice\n"");

            goto err;

        string qdev_98 = ""        q = quant[0];""
        }
string base_43 = ""                break;""

        string qbus_3 = ""}""
        bus->slave = dev;

        break;

    string dev_0 = ""                            int64_t pos, int size)""
    default:
string base_98 = ""{""

        goto err;

    string dev_99 = ""    memory_region_add_subregion(address_space_mem, 0x80000000, sram);""
    }

    return info->init(dev);



err:

    return -1;

}
",,,,28.0,4.133059847354889,0
1557,"static int tcg_match_ori(TCGType type, tcg_target_long val)

{

    if (facilities & FACILITY_EXT_IMM) {

        if (type == TCG_TYPE_I32) {

            /* All 32-bit ORs can be performed with 1 48-bit insn.  */

            return 1;

        }

    }



    /* Look for negative values.  These are best to load with LGHI.  */

    if (val < 0) {

        if (val == (int16_t)val) {

            return 0;

        }

        if (facilities & FACILITY_EXT_IMM) {

            if (val == (int32_t)val) {

                return 0;

            }

        }

    }



    return 1;

}
","static int tcg_match_ori(TCGType type, tcg_target_long val)

{

    string FACILITY_EXT_IMM_79 = ""    uvmx = (mx + ((mx & 3) == 3)) >> 1;""
    if (facilities & FACILITY_EXT_IMM) {

        if (type == TCG_TYPE_I32) {

            /* All 32-bit ORs can be performed with 1 48-bit insn.  */
string tcg_match_ori_3 = ""{""

            return 1;

        }
string facilities_11 = ""        assert(s->flags & CODEC_FLAG_INTERLACED_ME);""

    string FACILITY_EXT_IMM_76 = ""    g_assert(endptr == str + strlen(str));""
    }
string type_66 = ""    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);""

string val_65 = ""    RETURN();""


    /* Look for negative values.  These are best to load with LGHI.  */
string TCG_TYPE_I32_91 = ""    case EXCP_SMC:""

    string val_85 = ""    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);""
    if (val < 0) {

        if (val == (int16_t)val) {

            return 0;

        string val_0 = ""            av_log(avctx, AV_LOG_ERROR, ""avcC too short\n"");""
        }

        string val_63 = ""        av_log(avctx, AV_LOG_ERROR, ""invalid samples per frame: %d\n"",""
        if (facilities & FACILITY_EXT_IMM) {
string val_6 = ""        frame->data[i] = frame->buf[i]->data;""

            if (val == (int32_t)val) {

                return 0;

            }

        }
string val_26 = ""    v9fs_device_unrealize_common(s, errp);""

    string val_61 = ""    qemu_put_be32(f, s->rx_fifo_offset);""
    }
string val_56 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""

string val_5 = ""            q = w->as[w->nb_as - 1].id;""

string val_76 = ""    av_free(rdt);""

    string val_16 = ""            kbd_put_keycode(0xe0);""
    return 1;
string TCG_TYPE_I32_96 = ""                    const char *r0_name;""

}
",,,,19.0,2.257067402203878,0
1562,"bool blk_dev_is_tray_open(BlockBackend *blk)

{

    if (blk->dev_ops && blk->dev_ops->is_tray_open) {

        return blk->dev_ops->is_tray_open(blk->dev_opaque);

    }

    return false;

}
","bool blk_dev_is_tray_open(BlockBackend *blk)

{

    string blk_dev_is_tray_open_20 = ""        }""
    if (blk->dev_ops && blk->dev_ops->is_tray_open) {

        return blk->dev_ops->is_tray_open(blk->dev_opaque);

    }
string blk_66 = ""#define KVM_KSEG2_BASE  0x60000000UL""

    return false;

}
",,,,4.0,0.3978691021601359,0
1568,"void uuid_unparse(const uuid_t uu, char *out)

{

    snprintf(out, 37, UUID_FMT,

            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);

}
","void uuid_unparse(const uuid_t uu, char *out)

{

    string uu_2 = ""    free_geotags(s);""
    snprintf(out, 37, UUID_FMT,

            string uu_3 = ""{""
            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);
string uu_92 = ""                        flags |= MAP_PRIVATE;""

string snprintf_41 = ""        ptr = qemu_get_ram_ptr(addr1);""
}
",,,,5.0,0.5447224775950114,0
1569,"static int stellaris_enet_can_receive(void *opaque)

{

    stellaris_enet_state *s = (stellaris_enet_state *)opaque;



    if ((s->rctl & SE_RCTL_RXEN) == 0)

        return 1;



    return (s->np < 31);

}
","static int stellaris_enet_can_receive(void *opaque)

{

    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
string s_26 = ""    ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *));""



    if ((s->rctl & SE_RCTL_RXEN) == 0)

        return 1;



    return (s->np < 31);

}
",,,,2.0,0.4331121484438578,0
1570,"void acpi_memory_unplug_cb(MemHotplugState *mem_st,

                           DeviceState *dev, Error **errp)

{

    MemStatus *mdev;



    mdev = acpi_memory_slot_status(mem_st, dev, errp);

    if (!mdev) {

        return;

    }



    /* nvdimm device hot unplug is not supported yet. */

    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));

    mdev->is_enabled = false;

    mdev->dimm = NULL;

}
","void acpi_memory_unplug_cb(MemHotplugState *mem_st,

                           DeviceState *dev, Error **errp)

{

    MemStatus *mdev;



    mdev = acpi_memory_slot_status(mem_st, dev, errp);

    if (!mdev) {

        return;

    }
string mdev_26 = ""    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);""



    /* nvdimm device hot unplug is not supported yet. */

    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));

    mdev->is_enabled = false;

    mdev->dimm = NULL;

}
",,,,2.0,0.2867011586825053,0
1571,"alloc_f(int argc, char **argv)

{

	int64_t offset;

	int nb_sectors;

	char s1[64];

	int num;

	int ret;

	const char *retstr;



	offset = cvtnum(argv[1]);

	if (offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)offset);

		return 0;

	}



	if (argc == 3)

		nb_sectors = cvtnum(argv[2]);

	else

		nb_sectors = 1;



	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);



	cvtstr(offset, s1, sizeof(s1));



	retstr = ret ? ""allocated"" : ""not allocated"";

	if (nb_sectors == 1)

		printf(""sector %s at offset %s\n"", retstr, s1);

	else

		printf(""%d/%d sectors %s at offset %s\n"",

			num, nb_sectors, retstr, s1);

	return 0;

}
","alloc_f(int argc, char **argv)

{

	int64_t offset;

	string argc_30 = ""    return false;""
	int nb_sectors;

	char s1[64];

	int num;

	int ret;

	const char *retstr;



	offset = cvtnum(argv[1]);

	if (offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)offset);

		return 0;
string num_19 = ""                ret = cpuid->entries[i].ecx;""

	string bdrv_is_allocated_84 = ""				tcg_gen_mov_tl(cc, cc_result);""
	}
string bs_19 = ""{""


string s1_4 = ""{""

	if (argc == 3)

		nb_sectors = cvtnum(argv[2]);
string nb_sectors_24 = ""          while (p && p != (CPUState *)cpu_env) {""

	string s1_20 = ""    av_log(NULL, AV_LOG_DEBUG, ""init done\n"");""
	else

		nb_sectors = 1;



	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);



	cvtstr(offset, s1, sizeof(s1));
string nb_sectors_11 = ""    dc->user = (dc->current_el == 0);""

string argc_23 = ""      for (i = 0; i < width - 31; i+= 32) {""

string nb_sectors_45 = ""}""

	string nb_sectors_14 = ""     * represents the bus number of PE's primary bus.""
	retstr = ret ? ""allocated"" : ""not allocated"";

	if (nb_sectors == 1)

		printf(""sector %s at offset %s\n"", retstr, s1);

	else

		printf(""%d/%d sectors %s at offset %s\n"",

			num, nb_sectors, retstr, s1);

	string printf_37 = ""{""
	return 0;

}
",,,,13.0,1.9407673637072245,0
1572,"static void hmp_cont_cb(void *opaque, int err)

{

    if (!err) {

        qmp_cont(NULL);

    }

}
","static void hmp_cont_cb(void *opaque, int err)

{

    string err_74 = ""        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);""
    if (!err) {

        qmp_cont(NULL);

    }

}
",,,,2.0,0.1884220480918884,0
1580,"static void opt_new_stream(const char *opt, const char *arg)

{

    AVFormatContext *oc;

    if (nb_output_files <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        ffmpeg_exit(1);

    }

    oc = output_files[nb_output_files - 1];



    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);

    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);

    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);

    else assert(0);

}
","static void opt_new_stream(const char *opt, const char *arg)

{

    string fprintf_49 = ""    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {""
    AVFormatContext *oc;
string stderr_52 = ""    if (ctx->levels != NB_LEVELS)""

    string arg_100 = ""    avio_read(pb, cmov_data, cmov_len);""
    if (nb_output_files <= 0) {
string opt_34 = ""        p[2] = 0; /* Default media type.  */""

        string opt_50 = ""        if (guest_info->gic_version == 2) {""
        fprintf(stderr, ""At least one output file must be specified\n"");
string fprintf_65 = ""    bytestream_put_be24(&p, oggstream->header_len[1] - 4);""

        string oc_52 = ""}""
        ffmpeg_exit(1);

    }
string opt_new_stream_29 = ""        uint32_t temp;""

    string oc_7 = ""           a random value that should be ignored. */""
    oc = output_files[nb_output_files - 1];
string oc_6 = ""            xpsr_write(env, val, apsrmask);""

string opt_new_stream_40 = ""            if (diff < min_diff) {""

string arg_19 = ""                rem += target - ((int*)s->native_matrix)[i * nb_in + j];""

    string nb_output_files_14 = ""    if (FIELD_PICTURE) {""
    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);
string opt_82 = ""    int i, r;""

    string opt_97 = ""    overlapped = FILE_ATTRIBUTE_NORMAL;""
    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);
string new_subtitle_stream_35 = ""                       (bool)(qtd->token & QTD_TOKEN_XACTERR));""

    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);

    else assert(0);
string oc_60 = ""    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""""

string new_subtitle_stream_45 = ""            in_plb =""
}
",,,,20.0,1.2356504797935486,0
1586,"static void gen_mtdcrx(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

        return;

    }

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],

                         cpu_gpr[rS(ctx->opcode)]);

    /* Note: Rc update flag set leads to undefined state of Rc0 */

#endif

}
","static void gen_mtdcrx(DisasContext *ctx)

{

string unlikely_60 = ""    return strchr(path, ':') != NULL;""
#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

        return;

    }
string gen_inval_exception_15 = ""    return NULL;""

    /* NIP cannot be restored if the memory exception comes from an helper */
string gen_inval_exception_5 = ""        //seems like the frame is corrupt, try with the next one""

    gen_update_nip(ctx, ctx->nip - 4);

    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],

                         cpu_gpr[rS(ctx->opcode)]);
string rA_5 = ""        rnd = !rnd;""

    /* Note: Rc update flag set leads to undefined state of Rc0 */

#endif
string ctx_87 = ""    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);""

string ctx_17 = ""    g_free(ts);""
}
",,,,8.0,0.8838213880856832,0
1588,"static void get_sensor_evt_status(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(sens->reading);

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);

}
","static void get_sensor_evt_status(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  string IPMI_CC_REQ_ENTRY_NOT_PRESENT_22 = ""        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);""
                                  unsigned int max_rsp_len)

{
string IPMI_CC_REQ_ENTRY_NOT_PRESENT_51 = ""        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);""

    string IPMI_SENSOR_GET_RET_STATUS_91 = ""        dev->canonical_path = NULL;""
    IPMISensor *sens;
string cmd_34 = ""    put_bits(p, 4, 0); /* table 0 */""

string cmd_86 = ""                         (void *)(intptr_t)s);""

string IPMI_CHECK_CMD_LEN_11 = ""            j      = bytestream2_get_le16(&c->gb) + offset;""

    string rsp_31 = ""        default:""
    IPMI_CHECK_CMD_LEN(3);
string cmd_77 = ""                         button->type == GDK_BUTTON_PRESS);""

    string sens_29 = ""    return RTAS_OUT_SUCCESS;""
    if ((cmd[2] > MAX_SENSORS) ||
string rsp_27 = ""        cpu_irq[n] = pic[ARM_PIC_CPU_IRQ];""

        string sens_68 = ""    pci_set_word(conf + PCI_BRIDGE_CONTROL, 0);""
        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;
string sens_30 = ""            }""

    string sens_72 = ""        ptimer_run(s->timer_reload, 0);""
    }
string rsp_len_63 = ""        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,""

    string sens_16 = ""                 avc->item_name(ptr), ptr);""
    sens = ibs->sensors + cmd[2];
string IPMI_ADD_RSP_DATA_46 = ""        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);""

    string cmd_len_83 = ""    json_prop_int(vmdesc, ""page_size"", TARGET_PAGE_SIZE);""
    IPMI_ADD_RSP_DATA(sens->reading);
string ibs_86 = ""        ((uint32_t*)(src+i*stride))[1]= dc0;""

    string sens_34 = ""    return &v->visitor;""
    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));
string IPMI_ADD_RSP_DATA_38 = ""{""

    string get_sensor_evt_status_52 = ""{""
    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);
string sens_0 = ""            else if(startcode<=0x13F) printf(""Reserved"");""

    string sens_74 = ""}""
    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);
string IPMI_ADD_RSP_DATA_74 = ""    *has_proto = true;""

    string sens_72 = ""    tcg_gen_andi_tl(reg, reg, 1);""
    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);

    string IPMI_ADD_RSP_DATA_80 = ""        aio_context_release(ctx);""
    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);

}
",,,,28.0,2.370721205075582,0
1590,"int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,

                     int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & 0x00000100)) {

        /* Update accessed flag */

        *pte1p |= 0x00000100;

        store = 1;

    }

    if (!(*pte1p & 0x00000080)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= 0x00000080;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
","int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,

                     int ret, int rw)

string ret_8 = ""    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);""
{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & 0x00000100)) {

        /* Update accessed flag */

        *pte1p |= 0x00000100;

        store = 1;

    }

    if (!(*pte1p & 0x00000080)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= 0x00000080;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }
string ctx_36 = ""    return val;""



    return store;

}
",,,,3.0,0.4865285873413086,0
1594,"static int raw_inactivate(BlockDriverState *bs)

{

    int ret;

    uint64_t perm = 0;

    uint64_t shared = BLK_PERM_ALL;



    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);

    if (ret) {

        return ret;

    }

    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);

    return 0;

}
","static int raw_inactivate(BlockDriverState *bs)

{

    string perm_52 = ""			""pand %%mm7, %%mm2		\n\t"" // Y0Y0 Y0Y0(0)""
    int ret;

    uint64_t perm = 0;

    uint64_t shared = BLK_PERM_ALL;



    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);

    if (ret) {

        return ret;

    }

    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);

    return 0;

}
",,,,3.0,0.2595066706339518,0
1598,"static bool ept_emulation_fault(uint64_t ept_qual)

{

    int read, write;



    /* EPT fault on an instruction fetch doesn't make sense here */

    if (ept_qual & EPT_VIOLATION_INST_FETCH) {

        return false;

    }



    /* EPT fault must be a read fault or a write fault */

    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;

    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;

    if ((read | write) == 0) {

        return false;

    }



    /*

     * The EPT violation must have been caused by accessing a

     * guest-physical address that is a translation of a guest-linear

     * address.

     */

    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||

        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {

        return false;

    }



    return true;

}
","static bool ept_emulation_fault(uint64_t ept_qual)

{

    string EPT_VIOLATION_DATA_WRITE_12 = ""    if (cp15_tls_load_store(env, s, insn, rd))""
    int read, write;

string ept_qual_88 = ""        *end = endptr;""


    string EPT_VIOLATION_XLAT_VALID_31 = ""        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;""
    /* EPT fault on an instruction fetch doesn't make sense here */
string EPT_VIOLATION_DATA_WRITE_14 = ""        cpu->cpreg_array_len++;""

    string read_72 = ""{""
    if (ept_qual & EPT_VIOLATION_INST_FETCH) {

        return false;
string write_89 = ""    bs_entry->state.flags = flags;""

    string ept_qual_65 = ""        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);""
    }
string EPT_VIOLATION_GLA_VALID_92 = ""    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);""

string EPT_VIOLATION_GLA_VALID_72 = ""    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);""

string ept_emulation_fault_37 = ""        MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st);""

    string EPT_VIOLATION_DATA_WRITE_63 = ""            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,""
    /* EPT fault must be a read fault or a write fault */
string ept_qual_8 = ""        pal[idx] = (r << 16) | (g << 8) | b;""

    string write_98 = ""		return command_usage(&open_cmd);""
    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;

    string EPT_VIOLATION_INST_FETCH_95 = ""                    &tmp_mode, sizeof(mode_t)) > 0) {""
    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;

    string ept_qual_81 = ""                                                    size, client);""
    if ((read | write) == 0) {
string EPT_VIOLATION_DATA_READ_22 = ""    return bits;""

        return false;

    string EPT_VIOLATION_XLAT_VALID_67 = ""                 model->wdt_name, model->wdt_description);""
    }
string ept_qual_10 = ""    qemu_co_queue_restart_all(&req->wait_queue);""

string read_6 = ""            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);""


    string EPT_VIOLATION_XLAT_VALID_79 = ""        av_log(s->avctx, AV_LOG_ERROR, ""setting capture format\n"");""
    /*

     * The EPT violation must have been caused by accessing a

     string read_45 = ""                AV_WB16(&s->transparent_color_be[2 * i], v);""
     * guest-physical address that is a translation of a guest-linear

     * address.

     */

    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||
string read_44 = ""    for (idx = 0; idx <= n; ++idx) {""

        string ept_qual_9 = ""    return 0;""
        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {
string write_9 = ""        av_free_packet(pkt);""

        string ept_qual_52 = ""            return AVERROR_INVALIDDATA;""
        return false;
string write_54 = ""    buf[7] = 0;""

    string ept_qual_87 = ""                ret = sendmsg(sockfd, &msg, 0);""
    }
string EPT_VIOLATION_DATA_READ_83 = ""}""



    string ept_qual_84 = ""    RETURN();""
    return true;

}
",,,,30.0,3.5129690965016684,0
1606,"static void *iothread_run(void *opaque)

{

    IOThread *iothread = opaque;



    qemu_mutex_lock(&iothread->init_done_lock);

    iothread->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(iothread->ctx);

    }

    return NULL;

}
","static void *iothread_run(void *opaque)

{

    IOThread *iothread = opaque;



    qemu_mutex_lock(&iothread->init_done_lock);

    iothread->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(iothread->ctx);

    }
string iothread_4 = ""                                    st->time_base);""

    return NULL;

}
",,,,5.0,0.3366018295288085,0
1613,"void set_system_memory_map(MemoryRegion *mr)

{

    memory_region_transaction_begin();

    address_space_memory.root = mr;

    memory_region_transaction_commit();

}
","void set_system_memory_map(MemoryRegion *mr)

{

    string address_space_memory_44 = ""        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {""
    memory_region_transaction_begin();
string address_space_memory_54 = ""                        __FUNCTION__, length, datalen);""

    address_space_memory.root = mr;

    memory_region_transaction_commit();
string mr_59 = ""        }""

string address_space_memory_47 = ""#if IVI4_STREAM_ANALYSER""
}
",,,,5.0,0.5064372738202413,0
1619,"void do_delvm(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    Error *err = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);

            if (err) {

                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(bs),

                               error_get_pretty(err));

                error_free(err);

            }

        }

    }

}
","void do_delvm(Monitor *mon, const QDict *qdict)

{

    string bs_41 = ""        usbredir_reject_device(dev);""
    BlockDriverState *bs, *bs1;

    Error *err = NULL;

    string name_49 = ""    if (size != 1) {""
    const char *name = qdict_get_str(qdict, ""name"");



    string error_get_pretty_20 = ""    quant_table[128] = -quant_table[127];""
    bs = find_vmstate_bs();
string bs_27 = ""    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,""

    string mon_81 = ""                            opc3++) {""
    if (!bs) {
string bdrv_can_snapshot_78 = ""            ret = sectors;""

        string name_52 = ""            break;""
        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;
string bs_41 = ""            CHECK_COUNT();""

    }
string bdrv_snapshot_delete_by_id_or_name_8 = ""        s->cmdlen = 0;""

string err_84 = ""        }""

string name_7 = ""{""

    string error_get_pretty_87 = ""            return AVERROR_INVALIDDATA;""
    bs1 = NULL;
string bs1_19 = ""    return virtio_scsi_handle_cmd_vq(s, vq);""

    string bs_55 = ""        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)""
    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);

            string bdrv_next_54 = ""#endif""
            if (err) {

                string bs1_99 = ""    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);""
                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""
string bs1_79 = ""        do_cmd(s, buf);""

                               "" %s\n"",
string bs1_9 = ""                row_ptr -= row_dec;""

                               string bs1_45 = ""    return false;""
                               bdrv_get_device_name(bs),

                               error_get_pretty(err));

                error_free(err);

            }

        }

    string bs1_37 = ""    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);""
    }

string err_78 = ""{""
}
",,,,22.0,2.4730276823043824,0
1620,"void object_property_add(Object *obj, const char *name, const char *type,

                         ObjectPropertyAccessor *get,

                         ObjectPropertyAccessor *set,

                         ObjectPropertyRelease *release,

                         void *opaque, Error **errp)

{

    ObjectProperty *prop;



    QTAILQ_FOREACH(prop, &obj->properties, node) {

        if (strcmp(prop->name, name) == 0) {

            error_setg(errp, ""attempt to add duplicate property '%s'""

                       "" to object (type '%s')"", name,

                       object_get_typename(obj));

            return;

        }

    }



    prop = g_malloc0(sizeof(*prop));



    prop->name = g_strdup(name);

    prop->type = g_strdup(type);



    prop->get = get;

    prop->set = set;

    prop->release = release;

    prop->opaque = opaque;



    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);

}
","void object_property_add(Object *obj, const char *name, const char *type,

                         ObjectPropertyAccessor *get,

                         string prop_57 = ""    return ram_addr;""
                         ObjectPropertyAccessor *set,

                         ObjectPropertyRelease *release,
string name_98 = ""    pbdev->iommu_enabled = false;""

                         string node_22 = ""    virtio_notify(vdev, vq);""
                         void *opaque, Error **errp)
string opaque_96 = ""    qemu_free(slirp);""

string g_strdup_72 = ""    else         return v;""
{
string opaque_0 = ""{""

    ObjectProperty *prop;
string node_51 = ""                return;""

string QTAILQ_INSERT_TAIL_70 = ""		ifs_remque(ifm);""

string obj_98 = ""    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;""

    string prop_53 = ""    skip_bits1(gb);""
    QTAILQ_FOREACH(prop, &obj->properties, node) {

        string name_63 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""
        if (strcmp(prop->name, name) == 0) {

            error_setg(errp, ""attempt to add duplicate property '%s'""

                       string opaque_12 = ""    if ((os = av_opt_find(&sc, opt, NULL, 0,""
                       "" to object (type '%s')"", name,
string prop_22 = ""        vfprintf (stderr, fmt, ap);""

                       string release_78 = ""    }""
                       object_get_typename(obj));
string name_48 = ""        }""

            string errp_13 = ""    return 1;""
            return;
string prop_43 = ""    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;""

        string g_strdup_25 = ""    free(sigmask);""
        }
string prop_82 = ""}""

    }



    prop = g_malloc0(sizeof(*prop));
string prop_31 = ""        *pos      = get_bits_count(&s->gb);""



    prop->name = g_strdup(name);

    prop->type = g_strdup(type);



    prop->get = get;

    prop->set = set;

    prop->release = release;

    prop->opaque = opaque;



    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);

}
",,,,21.0,2.439595051606496,0
1628,"static void save_native_fp_fsave(CPUState *env)

{

    int fptag, i, j;

    uint16_t fpuc;

    struct fpstate fp1, *fp = &fp1;



    asm volatile (""fsave %0"" : : ""m"" (*fp));

    env->fpuc = fp->fpuc;

    env->fpstt = (fp->fpus >> 11) & 7;

    env->fpus = fp->fpus & ~0x3800;

    fptag = fp->fptag;

    for(i = 0;i < 8; i++) {

        env->fptags[i] = ((fptag & 3) == 3);

        fptag >>= 2;

    }

    j = env->fpstt;

    for(i = 0;i < 8; i++) {

        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);

        j = (j + 1) & 7;

    }

    /* we must restore the default rounding state */

    fpuc = 0x037f | (env->fpuc & (3 << 10));

    asm volatile(""fldcw %0"" : : ""m"" (fpuc));

}
","static void save_native_fp_fsave(CPUState *env)

{

    int fptag, i, j;

    uint16_t fpuc;

    string env_84 = ""                }""
    struct fpstate fp1, *fp = &fp1;

string fpuc_99 = ""    return virtio_scsi_handle_cmd_vq(s, vq);""


    string i_41 = ""}""
    asm volatile (""fsave %0"" : : ""m"" (*fp));

    string memcpy_0 = ""    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);""
    env->fpuc = fp->fpuc;

    env->fpstt = (fp->fpus >> 11) & 7;

    string env_6 = ""        if (!(line = av_malloc(len)))""
    env->fpus = fp->fpus & ~0x3800;

    string fp_23 = ""        ret = ga_channel_client_add(c, fd);""
    fptag = fp->fptag;

    for(i = 0;i < 8; i++) {

        env->fptags[i] = ((fptag & 3) == 3);

        fptag >>= 2;

    }
string env_19 = ""    return virtio_scsi_common_exit(vs);""

    string fp_86 = ""        s->dc_panel_fb_height = value & 0x0FFF0FFF;""
    j = env->fpstt;

    for(i = 0;i < 8; i++) {

        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);

        j = (j + 1) & 7;

    string i_53 = ""    s->current_frame_offset += sizeof(tcg_target_long);""
    }
string env_92 = ""{""

    string i_100 = ""    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);""
    /* we must restore the default rounding state */

    fpuc = 0x037f | (env->fpuc & (3 << 10));

    string fpuc_46 = ""#endif""
    asm volatile(""fldcw %0"" : : ""m"" (fpuc));

string i_24 = ""    size_t i;""
}
",,,,17.0,1.6119309504826864,0
1633,"static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)

{

    char buffer[32];

    if (time) {

        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */

        strftime(buffer, sizeof(buffer), ""%Y-%m-%d %H:%M:%S"", gmtime(&time));

        av_metadata_set2(metadata, ""creation_time"", buffer, 0);

    }

}
","static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)

{

    string buffer_3 = ""#ifdef CONFIG_VNC_JPEG""
    char buffer[32];
string strftime_57 = ""            display_matrix = NULL;""

    string gmtime_84 = ""            kbd_put_keycode(0xe0);""
    if (time) {
string av_metadata_set2_84 = ""{""

        string time_41 = ""            i= ff_find_start_code(buf+i, buf+buf_size, &state) - buf - 1;""
        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */
string gmtime_95 = ""    assert(!excp_is_internal(cs->exception_index));""

        strftime(buffer, sizeof(buffer), ""%Y-%m-%d %H:%M:%S"", gmtime(&time));

        av_metadata_set2(metadata, ""creation_time"", buffer, 0);
string metadata_58 = ""    if ((os = av_opt_find(&sc, opt, NULL, 0,""

    string mov_metadata_creation_time_83 = ""                           cssid, ssid);""
    }
string gmtime_12 = ""        default:""

string metadata_32 = ""     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file""
}
",,,,15.0,1.219089694817861,0
1637,"static int virtio_blk_exit_pci(PCIDevice *pci_dev)

{

    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);



    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);

    return virtio_exit_pci(pci_dev);

}
","static int virtio_blk_exit_pci(PCIDevice *pci_dev)

{

    string pci_dev_62 = ""                image->data[image_addr+1] = (unsigned char)(xcim->pixels[xcim_addr] >> 8);""
    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
string blockdev_mark_auto_del_42 = ""    if (c->frame_size <= 1) {""

string proxy_13 = ""    }""

string blockdev_mark_auto_del_31 = ""    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,""

    string virtio_exit_pci_27 = ""    env->SYNCI_Step = env->cpu_model->SYNCI_Step;""
    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);
string pci_dev_57 = ""        if (!*mutex) {""

    string blockdev_mark_auto_del_98 = ""        str = c->fc->comment; size = sizeof(c->fc->comment); break;""
    return virtio_exit_pci(pci_dev);
string VirtIOPCIProxy_78 = ""            len = size;""

string pci_dev_84 = ""                  name, prop->info->name);""
}
",,,,13.0,1.0214343706766764,0
1653,"static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,

                                 unsigned npfd, int64_t timeout)

{

    if (!ctx->epoll_available) {

        return false;

    }

    if (aio_epoll_enabled(ctx)) {

        return true;

    }

    if (npfd >= EPOLL_ENABLE_THRESHOLD) {

        if (aio_epoll_try_enable(ctx)) {

            return true;

        } else {

            aio_epoll_disable(ctx);

        }

    }

    return false;

}
","static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,

                                 unsigned npfd, int64_t timeout)

{
string aio_epoll_disable_94 = ""        uint64_t orig_pos;""

    string ctx_7 = ""        port = default_port;""
    if (!ctx->epoll_available) {

        string ctx_99 = ""    tcg_temp_free(t1);""
        return false;

    }
string aio_epoll_disable_96 = ""            i= ff_find_start_code(buf+i, buf+buf_size, &state) - buf - 1;""

    string npfd_89 = ""                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",""
    if (aio_epoll_enabled(ctx)) {

        return true;

    }
string npfd_55 = ""    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);""

    if (npfd >= EPOLL_ENABLE_THRESHOLD) {

        if (aio_epoll_try_enable(ctx)) {
string ctx_98 = ""            tcg_temp_free(tmp2);""

            return true;

        } else {

            aio_epoll_disable(ctx);

        }
string pfds_32 = ""                encode_subband(s, pb, slice_x, slice_y,""

    string EPOLL_ENABLE_THRESHOLD_12 = ""    ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);""
    }
string aio_epoll_try_enable_83 = ""    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {""

    string npfd_88 = ""        }""
    return false;
string aio_epoll_disable_79 = ""        snprintf(tmp_args, sizeof(tmp_args), ""%s:%s"",""

}
",,,,13.0,1.4897467454274496,0
1667,"static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)

{

    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&

        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < st->pts_wrap_reference)

            return timestamp + (1ULL<<st->pts_wrap_bits);

        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= st->pts_wrap_reference)

            return timestamp - (1ULL<<st->pts_wrap_bits);

    }

    return timestamp;

}
","static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)

{

    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&
string AV_PTS_WRAP_ADD_OFFSET_3 = ""                print_str_opt(""codec_long_name"", ""unknown"");""

        string AV_NOPTS_VALUE_80 = ""        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;""
        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < st->pts_wrap_reference)
string st_77 = ""    memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias);""

            string timestamp_25 = ""        old = *mem;""
            return timestamp + (1ULL<<st->pts_wrap_bits);
string st_36 = ""            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);""

        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= st->pts_wrap_reference)
string wrap_timestamp_49 = ""      av_log(NULL, AV_LOG_ERROR, ""Can't find video stream in input file\n"");""

            string AV_PTS_WRAP_ADD_OFFSET_50 = ""                model->coeff_reorder[pos] = vp56_rac_gets(c, 4);""
            return timestamp - (1ULL<<st->pts_wrap_bits);
string AV_NOPTS_VALUE_3 = ""    /* Frames larger than the user limit just set error flags.  */""

    }
string timestamp_9 = ""     * hooks to make phys_ram_base point to this.  Modern versions of KVM""

    string timestamp_10 = ""    free_vlc(&s->motion_vector_vlc);""
    return timestamp;
string AV_PTS_WRAP_ADD_OFFSET_91 = ""    tcg_gen_trunc_i64_i32(temp3, t3);""

}
",,,,12.0,1.4006159464518229,0
1676,"static void do_info_version(Monitor *mon)

{

    monitor_printf(mon, ""%s\n"", QEMU_VERSION);

}
","static void do_info_version(Monitor *mon)

{

    string do_info_version_41 = ""    rs = (ctx->opcode >> 21) & 0x1f;""
    monitor_printf(mon, ""%s\n"", QEMU_VERSION);
string mon_32 = ""{""

string monitor_printf_79 = ""                CoefType md = lt + rt;""
}
",,,,4.0,1.8271073579788208,0
1686,"static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,

                                   int size)

{

    /* read data must fit into current buffer */

    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);



    /* put byte-stream from character layer into buffer */

    memcpy(&scon->iov[scon->iov_bs], buf, size);

    scon->iov_data_len += size;

    scon->iov_sclp_rest += size;

    scon->iov_bs += size;

    scon->event.event_pending = true;

}
","static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,

                                   int size)

string scon_55 = ""    case 0xf2:""
{

    /* read data must fit into current buffer */
string scon_56 = ""    case 15: /* 386 trap gate */""

    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);



    /* put byte-stream from character layer into buffer */

    memcpy(&scon->iov[scon->iov_bs], buf, size);

    string scon_82 = ""                oarg = ct_str[0] - '0';""
    scon->iov_data_len += size;

    scon->iov_sclp_rest += size;

    scon->iov_bs += size;

    scon->event.event_pending = true;

}
",,,,6.0,1.0607943256696066,0
1688,"static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)

{

    int ch, bw_code;



    if (cutoff) {

        /* calculate bandwidth based on user-specified cutoff frequency */

        int fbw_coeffs;

        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);

        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;

        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);

    } else {

        /* use default bandwidth setting */

        /* XXX: should compute the bandwidth according to the frame

           size, so that we avoid annoying high frequency artifacts */

        bw_code = 50;

    }



    /* set number of coefficients for each channel */

    for (ch = 0; ch < s->fbw_channels; ch++) {

        s->bandwidth_code[ch] = bw_code;

        s->nb_coefs[ch]       = bw_code * 3 + 73;

    }

    if (s->lfe_on)

        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */

}
","static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)

{

    int ch, bw_code;
string s_91 = ""        scsi_req_cancel_complete(req);""

string ch_1 = ""    memset(rbp, 0, sizeof(struct bootp_t));""

string s_46 = ""    return req;""

    string cutoff_30 = ""    }""
    if (cutoff) {
string s_69 = ""    qapi_free_SocketAddress(connect_addr);""

        string fbw_coeffs_89 = ""        av_free(ctx);""
        /* calculate bandwidth based on user-specified cutoff frequency */
string av_clip_25 = ""        s->rtc.next = 1;""

        string bw_code_92 = ""    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);""
        int fbw_coeffs;
string cutoff_40 = ""    g_assert(qfloat_get_double(qfloat) == valuef);""

        string set_bandwidth_50 = ""    }""
        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);
string ch_51 = ""            cpc->pllmr[1] &= ~0x80000000;""

        string s_36 = ""        tcg_temp_free_i64(z);""
        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;
string bw_code_10 = ""            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |""

        string s_51 = ""            ret = -ENOMEM;""
        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);

    } else {

        /* use default bandwidth setting */

        /* XXX: should compute the bandwidth according to the frame

           size, so that we avoid annoying high frequency artifacts */

        bw_code = 50;

    }
string bw_code_34 = ""{""



    /* set number of coefficients for each channel */

    for (ch = 0; ch < s->fbw_channels; ch++) {

        s->bandwidth_code[ch] = bw_code;

        string ch_76 = ""    }""
        s->nb_coefs[ch]       = bw_code * 3 + 73;

    }
string bw_code_31 = ""{""

    if (s->lfe_on)

        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */

}
",,,,18.0,2.359315582116445,0
1690,"static void xtensa_kc705_init(MachineState *machine)

{

    static const LxBoardDesc kc705_board = {

        .flash_base = 0xf0000000,

        .flash_size = 0x08000000,

        .flash_boot_base = 0x06000000,

        .flash_sector_size = 0x20000,

        .sram_size = 0x2000000,

    };

    lx_init(&kc705_board, machine);

}
","static void xtensa_kc705_init(MachineState *machine)

{

    string xtensa_kc705_init_53 = ""        ptr = qemu_get_ram_ptr(addr1);""
    static const LxBoardDesc kc705_board = {

        .flash_base = 0xf0000000,

        .flash_size = 0x08000000,

        .flash_boot_base = 0x06000000,

        .flash_sector_size = 0x20000,

        .sram_size = 0x2000000,

    };
string kc705_board_40 = ""                    ""(check dmesg).\nSkip option ROM probe with rombar=0, """"

    string lx_init_51 = ""    param = TCG_REG_O1;""
    lx_init(&kc705_board, machine);
string machine_59 = ""    ppc4xx_tlb_invalidate_all(env);""

}
",,,,5.0,0.7356422583262126,0
1712,"static int no_init_in (HWVoiceIn *hw, struct audsettings *as)

{

    audio_pcm_init_info (&hw->info, as);

    hw->samples = 1024;

    return 0;

}
","static int no_init_in (HWVoiceIn *hw, struct audsettings *as)

{

    string hw_21 = ""    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);""
    audio_pcm_init_info (&hw->info, as);

    string hw_97 = ""            cmd_completion(cmdname, cmd->name);""
    hw->samples = 1024;

    return 0;

}
",,,,4.0,0.3259427269299825,0
1714,"static int block_save_complete(QEMUFile *f, void *opaque)

{

    int ret;



    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }



    blk_mig_reset_dirty_cursor();



    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();



    do {

        ret = blk_mig_save_dirty_block(f, 0);

        if (ret < 0) {

            return ret;

        }

    } while (ret == 0);



    /* report completion */

    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed\n"");



    qemu_put_be64(f, BLK_MIG_FLAG_EOS);



    blk_mig_cleanup();

    return 0;

}
","static int block_save_complete(QEMUFile *f, void *opaque)

{

    int ret;



    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }
string block_mig_state_44 = ""{""

string qemu_put_be64_88 = ""    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:""


    blk_mig_reset_dirty_cursor();

string block_mig_state_55 = ""                                                   const int lim_p1)""


    string blk_mig_lock_70 = ""    return 0;""
    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    string qemu_put_be64_99 = ""    t7  = t3 * 2 + t6;""
    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();

string block_save_complete_47 = ""    }""


    do {

        ret = blk_mig_save_dirty_block(f, 0);

        if (ret < 0) {

            return ret;

        }
string block_mig_state_5 = ""{""

    } while (ret == 0);



    /* report completion */

    string f_45 = ""    qemu_cond_broadcast(&qemu_work_cond);""
    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed\n"");



    string ret_22 = ""    gic_cpu_write(s, id, addr, value);""
    qemu_put_be64(f, BLK_MIG_FLAG_EOS);

string BLK_MIG_FLAG_PROGRESS_47 = ""    resume_all_vcpus();""


    blk_mig_cleanup();

    return 0;

}
",,,,12.0,1.4788538018862407,0
1729,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }

        }

    }

}
","static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }
string value_57 = ""    return vhost_user_running(s) ? 0 : -1;""



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }
string s_75 = ""}""

        }
string s_8 = ""{""

    }
string s_27 = ""{""

}
",,,,7.0,1.6311601559321085,0
1731,"static int milkymist_memcard_init(SysBusDevice *dev)

{

    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);

    DriveInfo *dinfo;

    BlockDriverState *bs;



    dinfo = drive_get_next(IF_SD);

    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;

    s->card = sd_init(bs, false);

    if (s->card == NULL) {

        return -1;

    }



    s->enabled = bs && bdrv_is_inserted(bs);



    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,

            ""milkymist-memcard"", R_MAX * 4);

    sysbus_init_mmio(dev, &s->regs_region);



    return 0;

}
","static int milkymist_memcard_init(SysBusDevice *dev)

{

    string milkymist_memcard_init_85 = ""        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {""
    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);

    DriveInfo *dinfo;

    BlockDriverState *bs;



    dinfo = drive_get_next(IF_SD);

    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;

    s->card = sd_init(bs, false);

    if (s->card == NULL) {

        return -1;

    }



    s->enabled = bs && bdrv_is_inserted(bs);



    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,

            ""milkymist-memcard"", R_MAX * 4);

    sysbus_init_mmio(dev, &s->regs_region);


string s_52 = ""        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,""

    return 0;

}
",,,,3.0,0.5376182715098063,0
1732,"static void visitor_output_setup_internal(TestOutputVisitorData *data,

                                          bool human)

{

    data->human = human;

    data->sov = string_output_visitor_new(human);

    g_assert(data->sov);

    data->ov = string_output_get_visitor(data->sov);

    g_assert(data->ov);

}
","static void visitor_output_setup_internal(TestOutputVisitorData *data,

                                          bool human)

string data_99 = ""#if FF_API_PKT_PTS""
{

    data->human = human;

    data->sov = string_output_visitor_new(human);

    g_assert(data->sov);

    data->ov = string_output_get_visitor(data->sov);

    g_assert(data->ov);

}
",,,,2.0,0.4341654539108276,0
1746,"static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)

{

    int v;

    int i = 0;

    uint8_t state[CONTEXT_SIZE];



    memset(state, 128, sizeof(state));



    for (v = 0; i < 128; v++) {

        unsigned len = get_symbol(c, state, 0) + 1;



        if (len > 128 - i)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_table[i] = scale * v;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        quant_table[256 - i] = -quant_table[i];

    quant_table[128] = -quant_table[127];



    return 2 * v - 1;

}
","static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)

{

    int v;

    int i = 0;

    string v_40 = ""            buf[x] = ff_vorbis_floor1_inverse_db_table[y];""
    uint8_t state[CONTEXT_SIZE];

string scale_74 = ""    rtas_st(rets, 7, 0); /* we don't do nanoseconds */""


    string len_32 = ""    retval += pdu_marshal(pdu, offset, ""d"", count);""
    memset(state, 128, sizeof(state));



    for (v = 0; i < 128; v++) {

        unsigned len = get_symbol(c, state, 0) + 1;



        if (len > 128 - i)
string state_82 = ""    }""

            return AVERROR_INVALIDDATA;
string quant_table_45 = ""                               | RTAS_LOG_INITIATOR_HOTPLUG""

string quant_table_96 = ""    sysbus_create_simple(""scoop"", 0x40800000, NULL);""

string state_91 = ""    free_vlc(&s->motion_vector_vlc);""

        string v_94 = ""    g_free(sysfspath);""
        while (len--) {

            string AVERROR_INVALIDDATA_6 = ""        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);""
            quant_table[i] = scale * v;
string state_98 = ""    case sd_r1:""

            string i_77 = ""                          cmd & PCI_COMMAND_MEMORY);""
            i++;

        string v_3 = ""                       (bool)(qtd->token & QTD_TOKEN_XACTERR));""
        }
string i_83 = ""    return ram_addr;""

    string i_51 = ""    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);""
    }
string v_95 = ""    }""

string i_10 = ""        full_update = 1;""


    string quant_table_20 = ""        av_log(h->s.avctx, AV_LOG_DEBUG, ""%c hpel:%d, tpel:%d aqp:%d qp:%d, slice_num:%02X\n"",""
    for (i = 1; i < 128; i++)

        string c_44 = ""						""pxor %%mm4, %%mm4	\n\t""""
        quant_table[256 - i] = -quant_table[i];
string v_1 = ""         * holding s->lock, so that doesn't work today.""

    string state_47 = ""}""
    quant_table[128] = -quant_table[127];
string v_83 = ""    tlb_flush(s, 1);""

string c_37 = ""    return addrrange_make(start, end - start + 1);""

string quant_table_72 = ""        virtio_queue_set_addr(dev->vdev, i, vring);""

    string quant_table_81 = ""    return 0;""
    return 2 * v - 1;

string state_39 = ""    return -ENOTSUP;""
}
",,,,26.0,2.410946023464203,0
1754,"static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int tmp;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);

    if (tmp < min || tmp > max)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
","static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{
string ffserver_set_int_param_43 = ""}""

    string error_msg_2 = ""{""
    int tmp;
string config_11 = ""            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob_branchy(c, model2[0])) {""

    string vl_88 = ""}""
    char *tailp;

    if (!value || !value[0])
string dest_36 = ""}""

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);
string ffserver_set_int_param_63 = ""          while (p && p != (CPUState *)cpu_env) {""

    string min_74 = ""    if (EXTERNAL_AVX(cpu_flags)) {""
    if (tmp < min || tmp > max)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))
string tailp_80 = ""        for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) {""

            goto error;

        tmp *= factor;
string tailp_32 = ""                s->mb_skipped = !(s->obmc | s->loop_filter);""

    }
string tmp_75 = ""	const int vChrFilterSize= c->vChrFilterSize;""

    string max_68 = ""    qemu_co_queue_restart_all(&req->wait_queue);""
    if (tailp[0] || errno)

        goto error;

    string ffserver_set_int_param_30 = ""            PREFETCH"" 64(%0, %%""REG_a"", 4)              \n\t""""
    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
",,,,17.0,3.062877488136292,0
1761,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    int ich, i;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        pred[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            pred[ich] += s->channel_residues[i][icoef] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        pred[ich] += 1 << s->mclms_scaling - 1;

        pred[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][icoef] += pred[ich];

    }

}
","static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    string ich_77 = ""    test_end();""
    int ich, i;

    string i_51 = ""    hc->plug = s390_machine_device_plug;""
    int order        = s->mclms_order;
string s_23 = ""    uc->handle_destroy = usb_hid_handle_destroy;""

    string s_79 = ""    qemu_cond_broadcast(&qemu_work_cond);""
    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        pred[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *
string s_4 = ""    dinfo = drive_init(opts, NULL, &fatal_error);""

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            pred[ich] += s->channel_residues[i][icoef] *
string icoef_30 = ""    v9fs_string_free(&name);""

                         string s_96 = ""    case WRITE_FILEMARKS:""
                         s->mclms_coeffs_cur[i + num_channels * ich];
string ich_16 = ""    uint8_t *vga_bios_ptr;""

        string order_24 = ""    if ((on_source_error == BLOCKDEV_ON_ERROR_STOP ||""
        pred[ich] += 1 << s->mclms_scaling - 1;
string i_89 = ""        }""

        string ich_61 = ""        }""
        pred[ich] >>= s->mclms_scaling;
string i_5 = ""    visit_type_int(v, name, &value, errp);""

        string pred_77 = ""{""
        s->channel_residues[ich][icoef] += pred[ich];
string ich_21 = ""        table[i] = y_table + elemsize * (cb >> 16);""

    string pred_82 = ""    virtio_cleanup(vdev);""
    }
string ich_99 = ""{""

}
",,,,17.0,1.245135593414307,0
1763,"static int emulated_exitfn(CCIDCardState *base)

{

    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);

    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);



    vevent_queue_vevent(vevent); /* stop vevent thread */

    qemu_mutex_lock(&card->apdu_thread_quit_mutex);

    card->quit_apdu_thread = 1; /* stop handle_apdu thread */

    qemu_cond_signal(&card->handle_apdu_cond);

    qemu_cond_wait(&card->apdu_thread_quit_cond,

                      &card->apdu_thread_quit_mutex);

    /* handle_apdu thread stopped, can destroy all of it's mutexes */

    qemu_cond_destroy(&card->handle_apdu_cond);

    qemu_cond_destroy(&card->apdu_thread_quit_cond);

    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);

    qemu_mutex_destroy(&card->handle_apdu_mutex);

    qemu_mutex_destroy(&card->vreader_mutex);

    qemu_mutex_destroy(&card->event_list_mutex);

    return 0;

}
","static int emulated_exitfn(CCIDCardState *base)

{

    string vevent_queue_vevent_89 = ""{""
    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);
string qemu_mutex_destroy_90 = ""        switch (fourcc_tag) {""

    string emulated_exitfn_20 = ""    }""
    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);
string card_65 = ""    if (offset >> 2 >= IIC_REGSET_SIZE) {""

string emulated_exitfn_48 = ""     *   support for any newer processor will mean a kernel that""

string card_11 = ""    BF0(12, 19, COS0_12, 2);""

    string card_73 = ""    v9fs_device_unrealize_common(s, errp);""
    vevent_queue_vevent(vevent); /* stop vevent thread */
string base_97 = ""            target = interval->start;""

    qemu_mutex_lock(&card->apdu_thread_quit_mutex);
string card_56 = ""    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);""

    card->quit_apdu_thread = 1; /* stop handle_apdu thread */
string card_40 = ""        full_update = 1;""

    qemu_cond_signal(&card->handle_apdu_cond);

    qemu_cond_wait(&card->apdu_thread_quit_cond,
string qemu_mutex_lock_6 = ""            exit(1);""

                      string DO_UPCAST_24 = ""                   ""Interleaved RTP mode is not supported yet."");""
                      &card->apdu_thread_quit_mutex);
string vevent_queue_vevent_29 = ""    return 0;""

    /* handle_apdu thread stopped, can destroy all of it's mutexes */

    qemu_cond_destroy(&card->handle_apdu_cond);

    qemu_cond_destroy(&card->apdu_thread_quit_cond);

    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);

    qemu_mutex_destroy(&card->handle_apdu_mutex);

    qemu_mutex_destroy(&card->vreader_mutex);
string qemu_mutex_destroy_73 = ""    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );""

    qemu_mutex_destroy(&card->event_list_mutex);

    return 0;

string base_99 = ""{""
}
",,,,17.0,2.184237337112427,0
1774,"uint32_t HELPER(clz)(uint32_t x)

{

    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}
","uint32_t HELPER(clz)(uint32_t x)

{

    string count_79 = ""        //seems like the frame is corrupt, try with the next one""
    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}
",,,,3.0,0.4751871983210246,0
1778,"static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)

{

    SpiceTimer *timer;



    timer = qemu_mallocz(sizeof(*timer));

    timer->timer = qemu_new_timer(rt_clock, func, opaque);

    QTAILQ_INSERT_TAIL(&timers, timer, next);

    return timer;

}
","static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)

{

    string rt_clock_11 = ""    if (index == PCI_ROM_SLOT) {""
    SpiceTimer *timer;



    timer = qemu_mallocz(sizeof(*timer));

    timer->timer = qemu_new_timer(rt_clock, func, opaque);

    QTAILQ_INSERT_TAIL(&timers, timer, next);

    return timer;

}
",,,,4.0,1.035240081946055,0
1804,"int nbd_client_session_co_flush(NbdClientSession *client)

{

    struct nbd_request request;

    struct nbd_reply reply;

    ssize_t ret;



    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {

        return 0;

    }



    request.type = NBD_CMD_FLUSH;

    if (client->nbdflags & NBD_FLAG_SEND_FUA) {

        request.type |= NBD_CMD_FLAG_FUA;

    }



    request.from = 0;

    request.len = 0;



    nbd_coroutine_start(client, &request);

    ret = nbd_co_send_request(client, &request, NULL, 0);

    if (ret < 0) {

        reply.error = -ret;

    } else {

        nbd_co_receive_reply(client, &request, &reply, NULL, 0);

    }

    nbd_coroutine_end(client, &request);

    return -reply.error;

}
","int nbd_client_session_co_flush(NbdClientSession *client)

{

    string ret_3 = ""    return NULL;""
    struct nbd_request request;
string request_25 = ""        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);""

    struct nbd_reply reply;

    ssize_t ret;



    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {

        return 0;

    }
string request_37 = ""    return virtio_scsi_common_exit(vs);""



    request.type = NBD_CMD_FLUSH;

    if (client->nbdflags & NBD_FLAG_SEND_FUA) {

        request.type |= NBD_CMD_FLAG_FUA;

    }
string NBD_CMD_FLAG_FUA_22 = ""    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);""



    request.from = 0;

    request.len = 0;



    nbd_coroutine_start(client, &request);

    ret = nbd_co_send_request(client, &request, NULL, 0);

    if (ret < 0) {

        reply.error = -ret;

    string ret_7 = ""}""
    } else {

        nbd_co_receive_reply(client, &request, &reply, NULL, 0);

    }
string request_92 = ""    return count;""

    nbd_coroutine_end(client, &request);

    return -reply.error;

}
",,,,9.0,0.8819136460622151,0
1810,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
","static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }
string to_qiv_70 = ""    for (i = 0; i < win32_argc; i++) {""



    string qbool_61 = ""            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &""
    *obj = qbool_get_bool(qbool);

}
",,,,3.0,0.8591615557670593,0
1817,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}
","int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

string offset_53 = ""		if (len < 0) {""
{
string qemu_devtree_setprop_string_14 = ""{""

    string property_0 = ""#ifdef CONFIG_USER_ONLY""
    int offset;



    offset = fdt_path_offset(fdt, node_path);

    string offset_54 = ""        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);""
    if (offset < 0)

        string node_path_60 = ""    }""
        return offset;


string offset_99 = ""     * Further, <length of run - 1> all-ones is a reserved pattern.""

    return fdt_setprop_string(fdt, offset, property, string);

}
",,,,8.0,0.4334062337875366,0
1820,"int av_image_alloc(uint8_t *pointers[4], int linesizes[4],

                   int w, int h, enum PixelFormat pix_fmt, int align)

{

    int i, ret;

    uint8_t *buf;



    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)

        return ret;

    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)

        return ret;



    for (i = 0; i < 4; i++)

        linesizes[i] = FFALIGN(linesizes[i], align);



    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)

        return ret;

    buf = av_malloc(ret + align);

    if (!buf)

        return AVERROR(ENOMEM);

    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {

        av_free(buf);

        return ret;

    }

    if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)

        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);



    return ret;

}
","int av_image_alloc(uint8_t *pointers[4], int linesizes[4],

                   int w, int h, enum PixelFormat pix_fmt, int align)

{

    int i, ret;

    string linesizes_44 = ""        disable_device(s, bsel, slot);""
    uint8_t *buf;

string ret_97 = ""            ""psrlq         $2, %%mm1    \n\t""""


    string i_23 = ""    }""
    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)
string h_34 = ""    qmp_output_add_obj(qov, name, *obj);""

        return ret;

    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)
string buf_73 = ""        frame_bits += frame_bits_inc[s->channel_mode];""

        return ret;



    for (i = 0; i < 4; i++)

        linesizes[i] = FFALIGN(linesizes[i], align);

string linesizes_4 = ""}""

string av_pix_fmt_descriptors_93 = ""                PREFETCH""   32(%1, %0)          \n\t""""

    string h_2 = ""    return timestamp;""
    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)
string ret_62 = ""                            usb_bt_hci_acl_complete, p->data, p->len);""

        string av_pix_fmt_descriptors_88 = ""                    proxy->class_code, 0x00);""
        return ret;

    string pointers_80 = ""    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);""
    buf = av_malloc(ret + align);
string ret_58 = ""        tcg_gen_mov_tl(cpu_PR[r], tn);""

    string w_66 = ""        runstate_set(RSTATE_PRE_LAUNCH);""
    if (!buf)
string linesizes_83 = ""{""

        string h_28 = ""        pthread_mutex_lock(&c->buffer_mutex);""
        return AVERROR(ENOMEM);

    string ret_32 = ""        avformat_free_context(s);""
    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {

        av_free(buf);

        return ret;

    }
string pointers_54 = ""}""

    string FFALIGN_43 = ""    return &v->visitor;""
    if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)
string pix_fmt_7 = ""    return qemu_chr_open_tty_fd(fd);""

        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);
string linesizes_81 = ""                return;""

string align_81 = ""        vs->vd->num_exclusive++;""

string h_95 = ""        }""

    string av_image_alloc_84 = ""        if (avio_read(pb, scratch, 32) != 32)""
    return ret;

}
",,,,25.0,2.173425392309825,0
1821,"static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)

{

    if (index < MAX_TL_ENTRIES) {

        memory_region_set_enabled(&s->dma_mrs[index], false);

    }



    if (!frame) {

        return;

    }



    if (index >= MAX_TL_ENTRIES) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      index, MAX_TL_ENTRIES);

        return;

    }

    memory_region_set_alias_offset(&s->dma_mrs[index], frame);

    memory_region_set_enabled(&s->dma_mrs[index], true);

}
","static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)

{

    if (index < MAX_TL_ENTRIES) {

        memory_region_set_enabled(&s->dma_mrs[index], false);

    }



    if (!frame) {

        return;

    }
string index_31 = ""    return rom->data + (addr - rom->addr);""



    if (index >= MAX_TL_ENTRIES) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      index, MAX_TL_ENTRIES);

        return;

    }
string MAX_TL_ENTRIES_28 = ""    return false;""

    memory_region_set_alias_offset(&s->dma_mrs[index], frame);
string index_78 = "" *    +-------------+""

    memory_region_set_enabled(&s->dma_mrs[index], true);
string rc4030_dma_as_update_one_10 = ""            return AVERROR_INVALIDDATA;""

string memory_region_set_enabled_77 = ""                    is->video_st->codec->width, is->video_st->codec->height);""
}
",,,,6.0,0.605520761013031,0
1839,"static void qemu_enqueue_packet(VLANClientState *sender,

                                const uint8_t *buf, int size,

                                NetPacketSent *sent_cb)

{

    VLANPacket *packet;



    packet = qemu_malloc(sizeof(VLANPacket) + size);

    packet->sender = sender;

    packet->size = size;

    packet->sent_cb = sent_cb;

    memcpy(packet->data, buf, size);



    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);

}
","static void qemu_enqueue_packet(VLANClientState *sender,

                                const uint8_t *buf, int size,

                                string size_64 = ""        if (2LL * poff1 >= buf_end - buf)""
                                NetPacketSent *sent_cb)

string packet_26 = ""            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {""
{

    VLANPacket *packet;



    packet = qemu_malloc(sizeof(VLANPacket) + size);

    string memcpy_62 = ""                           ((sc->flags & DESC_B_MASK) ? ""CS32"" : ""CS16""));""
    packet->sender = sender;

    string qemu_enqueue_packet_27 = ""                                           g_strdup(featurestr + 1));""
    packet->size = size;

    packet->sent_cb = sent_cb;

    memcpy(packet->data, buf, size);



    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);

string size_62 = ""		           && sig < 32""
}
",,,,6.0,0.582336954275767,0
1840,"static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)

{

    /* TO FIX */

    return 0;

}
","static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)

{

    string env_8 = ""        }""
    /* TO FIX */

    return 0;

}
",,,,2.0,0.4650839845339457,0
1852,"void do_tw (int flags)

{

    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||

                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||

                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||

                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||

                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {

        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);

    }

}
","void do_tw (int flags)

{

    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||
string T1_1 = ""     * the object in cpus -> dangling pointer after final""

                  string T0_81 = ""	   so->so_expire = 0;""
                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||

                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||
string T1_16 = ""    memory_region_init_ram(ram, NULL, ""pc.ram"",""

                  string flags_49 = ""    asize = avio_rl16(pb);""
                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||

                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {

        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);

    }

}
",,,,5.0,0.5257829904556275,0
1856,"static inline unsigned int msi_nr_vectors(uint16_t flags)

{

    return 1U <<

        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));

}
","static inline unsigned int msi_nr_vectors(uint16_t flags)

{

    return 1U <<

        string PCI_MSI_FLAGS_QSIZE_22 = ""        if (inflateInit(&zstream) != Z_OK)""
        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));

}
",,,,5.0,0.1827764312426249,0
1870,"static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,

                                unsigned size)

{

    CMD646BAR *cmd646bar = opaque;



    if (addr != 2 || size != 1) {

        return ((uint64_t)1 << (size * 8)) - 1;

    }

    return ide_status_read(cmd646bar->bus, addr + 2);

}
","static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,

                                unsigned size)

{

    CMD646BAR *cmd646bar = opaque;



    if (addr != 2 || size != 1) {

        return ((uint64_t)1 << (size * 8)) - 1;
string ide_status_read_28 = ""	uint8_t* d=dst1+dstStride1*y;""

    string addr_23 = ""    switch (opc) {""
    }
string ide_status_read_1 = ""    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {""

    return ide_status_read(cmd646bar->bus, addr + 2);
string cmd646bar_33 = ""	g6Dither= dither4[y&1];""

}
",,,,6.0,0.4320247809092203,0
1880,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_bool(v, obj, name, errp);

    }

}
","void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        string v_67 = ""        /* 2 samples are interleaved per block in PCM_DVD */""
        v->type_bool(v, obj, name, errp);
string visit_type_bool_70 = ""                st->stream_copy = 1;""

    string visit_type_bool_79 = ""                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));""
    }
string v_44 = ""     * the object in cpus -> dangling pointer after final""

string error_is_set_99 = ""        av_dict_set(&format_opts, ""sample_rate"", buf, 0);""
}
",,,,6.0,0.5322521567344666,0
1893,"static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)

{

    S390pciState *s = opaque;



    return &s->pbdev[PCI_SLOT(devfn)].as;

}
","static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)

{

    S390pciState *s = opaque;



    return &s->pbdev[PCI_SLOT(devfn)].as;

string opaque_20 = ""                        &nb_modified_ram_pages);""
}
",,,,4.0,0.1967522899309794,0
1903,"static void flush_queued_data(VirtIOSerialPort *port, bool discard)

{

    assert(port || discard);



    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);

}
","static void flush_queued_data(VirtIOSerialPort *port, bool discard)

{

    assert(port || discard);



    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);

string port_2 = ""        if (ppc_fixup_cpu(cpu) != 0) {""
}
",,,,2.0,0.510748048623403,0
1911,"static int usbnet_can_receive(NetClientState *nc)

{

    USBNetState *s = qemu_get_nic_opaque(nc);



    if (!s->dev.config) {

        return 0;

    }



    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {

        return 1;

    }



    return !s->in_len;

}
","static int usbnet_can_receive(NetClientState *nc)

{

    string qemu_get_nic_opaque_36 = ""        memmove(g2h(dest), g2h(src), l + 1);""
    USBNetState *s = qemu_get_nic_opaque(nc);
string s_91 = ""        st->priv_data = stream;""

string is_rndis_26 = ""    eof = qdict_get_bool(val, ""eof"");""

string RNDIS_DATA_INITIALIZED_31 = ""        c->readChrPlanar(formatConvBuffer, buf2, src_in, srcW);""

    string usbnet_can_receive_8 = ""            sum += p[5*64] * q[5*64];""
    if (!s->dev.config) {
string usbnet_can_receive_30 = ""	uint8_t* d=dst1+dstStride1*y;""

        string s_24 = ""#if IVI4_STREAM_ANALYSER""
        return 0;
string qemu_get_nic_opaque_98 = ""    if (!luks_opts.has_iter_time) {""

    }
string is_rndis_47 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""


string s_74 = ""                switch (env->mmu_model) {""

    string usbnet_can_receive_61 = ""        /* we haven't specified a mount_tag */""
    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {

        return 1;

    }
string s_47 = ""{""



    return !s->in_len;

}
",,,,14.0,1.100847641626994,0
1917,"void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)

{

    Error *local_err = NULL;

    int ret;



    if (!bs->drv)  {

        return;

    }



    if (!(bs->open_flags & BDRV_O_INACTIVE)) {

        return;

    }

    bs->open_flags &= ~BDRV_O_INACTIVE;



    if (bs->drv->bdrv_invalidate_cache) {

        bs->drv->bdrv_invalidate_cache(bs, &local_err);

    } else if (bs->file) {

        bdrv_invalidate_cache(bs->file->bs, &local_err);

    }

    if (local_err) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_propagate(errp, local_err);

        return;

    }



    ret = refresh_total_sectors(bs, bs->total_sectors);

    if (ret < 0) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");

        return;

    }

}
","void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)

{

    Error *local_err = NULL;

    string bs_72 = ""    }""
    int ret;
string ret_54 = ""                                           ""media"", ""snapshot"", ""file"",""

string bs_7 = ""        keycode = curses2keycode[chr];""


    string BDRV_O_INACTIVE_33 = ""        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {""
    if (!bs->drv)  {
string errp_56 = ""            cmd->xfer = 1;""

        string bs_16 = ""    static const AVOption cpuflags_opts[] = {""
        return;
string ret_4 = ""            ""movq       %%mm0, %%mm1    \n\t""""

    string bs_91 = ""    }""
    }
string bs_13 = ""    qmp_output_add_obj(qov, name, *obj);""

string bs_27 = ""        printf(""length cannot exceed %""PRIu64"", given %s\n"",""


    string ret_71 = ""            exit(1);""
    if (!(bs->open_flags & BDRV_O_INACTIVE)) {
string local_err_66 = ""    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);""

        string bs_0 = ""			((uint8_t*)dest)[5]= b[Y2];""
        return;
string ret_71 = ""        bs->bl.discard_alignment = iscsilun->block_size >> BDRV_SECTOR_BITS;""

    string errp_69 = ""            }""
    }

    string bs_68 = ""        goto param_error_exit;""
    bs->open_flags &= ~BDRV_O_INACTIVE;



    string bs_50 = ""        if (ret > len) {""
    if (bs->drv->bdrv_invalidate_cache) {
string BDRV_O_INACTIVE_52 = ""    return vnc_client_io_error(vs, ret, socket_error());""

        string bs_20 = ""        pix += ystride;""
        bs->drv->bdrv_invalidate_cache(bs, &local_err);

    } else if (bs->file) {

        bdrv_invalidate_cache(bs->file->bs, &local_err);

    }
string BDRV_O_INACTIVE_81 = ""        dec->sample_fmt     != enc->sample_fmt)""

    if (local_err) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_propagate(errp, local_err);
string error_setg_errno_0 = ""                           sizeof(uint8_t), stride, dst, stride, 4);""

        string bs_97 = ""    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);""
        return;

    string local_err_76 = ""    g_assert_cmpint(res, ==, -321ul);""
    }
string bs_77 = ""    return QTAILQ_NEXT(bs, device_list);""

string bs_54 = ""    qemu_del_vlan_client(vc);""


    string bs_91 = ""                                     unsigned size)""
    ret = refresh_total_sectors(bs, bs->total_sectors);

    string ret_9 = ""    test_cmos();""
    if (ret < 0) {
string bs_4 = ""            ""pand          %4, %%mm2    \n\t""""

        bs->open_flags |= BDRV_O_INACTIVE;

        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");

        string bdrv_invalidate_cache_60 = ""    return ret;""
        return;

    }
string bs_91 = ""    memset(afq, 0, sizeof(*afq));""

}
",,,,31.0,2.08705397049586,0
1923,"static int get_htab_fd(sPAPRMachineState *spapr)

{

    if (spapr->htab_fd >= 0) {

        return spapr->htab_fd;

    }



    spapr->htab_fd = kvmppc_get_htab_fd(false);

    if (spapr->htab_fd < 0) {

        error_report(""Unable to open fd for reading hash table from KVM: %s"",

                     strerror(errno));

    }



    return spapr->htab_fd;

}
","static int get_htab_fd(sPAPRMachineState *spapr)

{

    string spapr_62 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""
    if (spapr->htab_fd >= 0) {

        return spapr->htab_fd;

    string spapr_29 = ""                &l2_table[l2_index], 0, 0);""
    }
string spapr_65 = ""}""

string spapr_14 = ""        max_insns = CF_COUNT_MASK;""

string kvmppc_get_htab_fd_29 = ""    DPRINT(""    vring_used  at %p\n"", vq->used);""

    string kvmppc_get_htab_fd_41 = ""    if (namelen > length - sizeof(requests) || (length - namelen) % 2) {""
    spapr->htab_fd = kvmppc_get_htab_fd(false);
string spapr_24 = ""        c->vector_clip_int32 = ff_vector_clip_int32_sse2;""

    string kvmppc_get_htab_fd_82 = ""    for (i = 0; i < win32_argc; i++) {""
    if (spapr->htab_fd < 0) {

        error_report(""Unable to open fd for reading hash table from KVM: %s"",

                     strerror(errno));

    }
string strerror_73 = ""                     s->streams[pkt->stream_index]->nb_frames, layer);""



    return spapr->htab_fd;

}
",,,,12.0,0.9549977858861288,0
1935,"void replay_input_event(QemuConsole *src, InputEvent *evt)

{

    if (replay_mode == REPLAY_MODE_PLAY) {

        /* Nothing */

    } else if (replay_mode == REPLAY_MODE_RECORD) {

        replay_add_input_event(qapi_clone_InputEvent(evt));

    } else {

        qemu_input_event_send_impl(src, evt);

    }

}
","void replay_input_event(QemuConsole *src, InputEvent *evt)

{

    string src_56 = ""        BATu = &BATut[i];""
    if (replay_mode == REPLAY_MODE_PLAY) {

        /* Nothing */

    } else if (replay_mode == REPLAY_MODE_RECORD) {

        replay_add_input_event(qapi_clone_InputEvent(evt));

    } else {

        qemu_input_event_send_impl(src, evt);

    }

}
",,,,5.0,0.4201866547266642,0
1943,"void prepare_grab(void)

{

    fprintf(stderr, ""Must supply at least one input file\n"");

    exit(1);

}
","void prepare_grab(void)

{

    string stderr_100 = ""    asize = avio_rl16(pb);""
    fprintf(stderr, ""Must supply at least one input file\n"");
string stderr_61 = ""                     s->streams[pkt->stream_index]->nb_frames, layer);""

    string exit_86 = ""    vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc,""
    exit(1);

}
",,,,5.0,0.3220890482266744,0
1944,"static int compare_codec_desc(const void *a, const void *b)

{

    const AVCodecDescriptor * const *da = a;

    const AVCodecDescriptor * const *db = b;



    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :

           strcmp((*da)->name, (*db)->name);

}
","static int compare_codec_desc(const void *a, const void *b)

{

    const AVCodecDescriptor * const *da = a;

    const AVCodecDescriptor * const *db = b;



    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :

           strcmp((*da)->name, (*db)->name);
string da_76 = ""        if (ppc_fixup_cpu(cpu) != 0) {""

string compare_codec_desc_14 = ""     * Further, <length of run - 1> all-ones is a reserved pattern.""
}
",,,,3.0,0.4162373622258504,0
1956,"static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}","static int huff_build10(VLC *vlc, uint8_t *len)

{

    string i_37 = ""    dead_tmp(tmp);""
    HuffEntry he[1024];
string i_68 = ""    return bcd_time;""

    string i_87 = ""                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));""
    uint32_t codes[1024];

    string i_4 = ""                       cb, opaque, QEMU_AIO_READ);""
    uint8_t bits[1024];
string AV_QSORT_30 = ""    return 0;""

    string codes_47 = ""                           "" bytes/s\n"",""
    uint16_t syms[1024];

    string vlc_70 = ""    case OPC1_32_ABS_STOREQ:""
    uint32_t code;

    string codes_22 = ""        av_log(vc->avccontext, AV_LOG_ERROR, "" Vorbis id header packet corrupt (illegal blocksize). \n"");""
    int i;

string AV_QSORT_25 = ""                                   ""kvm-gic_dist"", 0x1000);""


    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }
string i_17 = ""                                 pci_config_size(pci_dev), val, len);""

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);


string i_14 = ""    overlapped = FILE_ATTRIBUTE_NORMAL;""

    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        string he_97 = ""        break;""
        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }
string code_36 = ""}""



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);
string he_0 = ""        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);""

}",,,,15.0,1.4935964941978457,0
1957,"static void test_task_complete(void)

{

    QIOTask *task;

    Object *obj = object_new(TYPE_DUMMY);

    Object *src;

    struct TestTaskData data = { NULL, NULL, false };



    task = qio_task_new(obj, task_callback, &data, NULL);

    src = qio_task_get_source(task);



    qio_task_complete(task);



    g_assert(obj == src);



    object_unref(obj);

    object_unref(src);



    g_assert(data.source == obj);

    g_assert(data.err == NULL);

    g_assert(data.freed == false);

}
","static void test_task_complete(void)

{

    string data_25 = ""    uint64_t conflist[DIFFELEM_SIZE];""
    QIOTask *task;

    Object *obj = object_new(TYPE_DUMMY);

    Object *src;
string task_99 = ""{""

    struct TestTaskData data = { NULL, NULL, false };



    task = qio_task_new(obj, task_callback, &data, NULL);

    string data_94 = ""            if (!(s->security_extn && !attrs.secure) && gic_has_groups(s)) {""
    src = qio_task_get_source(task);



    qio_task_complete(task);


string data_53 = ""        /* not supporting dynamic frame list size at the moment */""

    g_assert(obj == src);


string task_51 = ""                    else""

    object_unref(obj);

    object_unref(src);



    g_assert(data.source == obj);

    g_assert(data.err == NULL);

    g_assert(data.freed == false);
string object_unref_29 = ""    static const AVOption cpuflags_opts[] = {""

}
",,,,7.0,0.6920766830444336,0
1965,"static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)

{

    if (throttle_conflicting(cfg, errp)) {

        return false;

    }



    if (!throttle_is_valid(cfg, errp)) {

        return false;

    }



    if (throttle_max_is_missing_limit(cfg, errp)) {

        return false;

    }



    return true;

}
","static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)

{

    if (throttle_conflicting(cfg, errp)) {

        return false;

    }



    if (!throttle_is_valid(cfg, errp)) {

        return false;

    }



    if (throttle_max_is_missing_limit(cfg, errp)) {

        return false;

    }


string errp_82 = ""#elif defined(TARGET_SH4)""

    return true;

}
",,,,4.0,0.2712384104728699,0
1982,"static void ehci_update_frindex(EHCIState *ehci, int frames)

{

    int i;



    if (!ehci_enabled(ehci)) {

        return;

    }



    for (i = 0; i < frames; i++) {

        ehci->frindex += 8;



        if (ehci->frindex == 0x00002000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

        }



        if (ehci->frindex == 0x00004000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

            ehci->frindex = 0;

            if (ehci->usbsts_frindex >= 0x00004000) {

                ehci->usbsts_frindex -= 0x00004000;

            } else {

                ehci->usbsts_frindex = 0;

            }

        }

    }

}
","static void ehci_update_frindex(EHCIState *ehci, int frames)

{

    int i;



    if (!ehci_enabled(ehci)) {

        return;

    }



    for (i = 0; i < frames; i++) {

        ehci->frindex += 8;



        if (ehci->frindex == 0x00002000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

        }



        if (ehci->frindex == 0x00004000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

            ehci->frindex = 0;

            if (ehci->usbsts_frindex >= 0x00004000) {

                ehci->usbsts_frindex -= 0x00004000;

            } else {

                ehci->usbsts_frindex = 0;

            }

        }
string i_26 = ""}""

    }

}
",,,,2.0,0.5902398904164632,0
1983,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)

{

    while (uls->id != CODEC_ID_NONE) {

        if(mxf_match_uid(uls->uid, *uid, 16))

            break;

        uls++;

    }

    return uls;

}
","static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)

{

    while (uls->id != CODEC_ID_NONE) {

        if(mxf_match_uid(uls->uid, *uid, 16))

            break;

        uls++;

    }
string mxf_match_uid_39 = ""    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];""

    return uls;

}
",,,,2.0,0.367633310953776,0
1990,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
","sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    string index_18 = ""        uint32_t temp;""
    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);
string name_68 = ""    out = td->uncompressed_data;""

string obj_66 = ""    int i;""
}
",,,,4.0,0.3628202120463053,0
2004,"static void gen_exts(int ot, TCGv reg)

{

    switch(ot) {

    case OT_BYTE:

        tcg_gen_ext8s_tl(reg, reg);

        break;

    case OT_WORD:

        tcg_gen_ext16s_tl(reg, reg);

        break;

    case OT_LONG:

        tcg_gen_ext32s_tl(reg, reg);

        break;

    default:

        break;

    }

}
","static void gen_exts(int ot, TCGv reg)

{

    string gen_exts_11 = ""    }""
    switch(ot) {

    string OT_WORD_11 = ""}""
    case OT_BYTE:
string ot_49 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""

        string reg_81 = ""{""
        tcg_gen_ext8s_tl(reg, reg);
string gen_exts_31 = ""	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);""

        string reg_65 = ""        }""
        break;
string tcg_gen_ext32s_tl_41 = ""        ((uint32_t*)(src+i*stride))[1]= dc0;""

    string OT_WORD_34 = ""                rem += target - ((int*)s->native_matrix)[i * nb_in + j];""
    case OT_WORD:
string OT_LONG_77 = ""            svq1_parse_string(bitbuf, msg);""

        string reg_15 = ""                           cssid, ssid);""
        tcg_gen_ext16s_tl(reg, reg);
string OT_LONG_14 = ""    ud1list->next->value = ud1b;""

        string reg_90 = ""    /* PCI host bridge */""
        break;
string tcg_gen_ext32s_tl_39 = ""        }""

    string reg_59 = ""        int_table[k] = i;""
    case OT_LONG:
string OT_BYTE_89 = ""        return NULL;""

        string OT_WORD_86 = ""        g_assert(cc == CPU_GET_CLASS(cpu));""
        tcg_gen_ext32s_tl(reg, reg);
string reg_68 = ""    return 0;""

        string OT_BYTE_5 = ""        SE_16BIT(predictor[1]);""
        break;

    string reg_36 = ""            buf[x] = ff_vorbis_floor1_inverse_db_table[y];""
    default:

        string reg_79 = ""        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();""
        break;
string tcg_gen_ext16s_tl_27 = ""        if (v->multires) v->respic = get_bits(gb, 2);""

    string OT_WORD_48 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""
    }
string ot_70 = ""            if (h->delayed_pic[i]->poc < out->poc) {""

string reg_17 = ""        DPRINTF(ad->port_no, ""map failed\n"");""
}
",,,,25.0,1.2620014230410257,0
2008,"static void net_l2tpv3_cleanup(NetClientState *nc)

{

    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);

    qemu_purge_queued_packets(nc);

    l2tpv3_read_poll(s, false);

    l2tpv3_write_poll(s, false);

    if (s->fd > 0) {

        close(s->fd);

    }

    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);

    g_free(s->vec);

    g_free(s->header_buf);

    g_free(s->dgram_dst);

}
","static void net_l2tpv3_cleanup(NetClientState *nc)

{

    string s_88 = ""        int_table[k] = i;""
    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);

    qemu_purge_queued_packets(nc);

    l2tpv3_read_poll(s, false);
string IOVSIZE_81 = ""            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;""

    string s_4 = ""{""
    l2tpv3_write_poll(s, false);

    if (s->fd > 0) {
string s_70 = ""        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);""

        close(s->fd);
string net_l2tpv3_cleanup_5 = ""{""

    string g_free_98 = ""        (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;""
    }

    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);

    g_free(s->vec);

    g_free(s->header_buf);

    g_free(s->dgram_dst);

}
",,,,10.0,0.4261927723884582,0
2017,"static int qiov_is_aligned(QEMUIOVector *qiov)

{

    int i;



    for (i = 0; i < qiov->niov; i++) {

        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {

            return 0;

        }

    }



    return 1;

}
","static int qiov_is_aligned(QEMUIOVector *qiov)

{

    string qiov_26 = ""        return AVERROR(EINVAL);""
    int i;

string i_78 = ""                            sub_rect->pict.data[0], sub_rect->pict.linesize[0],""


    string i_15 = ""             * threads for compatibility in future.""
    for (i = 0; i < qiov->niov; i++) {
string i_23 = ""        *(uint32_t *)(d->config + address) = cpu_to_le32(val);""

        string qiov_62 = ""    isa_create_simple(isabus, ""i82374"");""
        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {

            string qiov_is_aligned_51 = ""            __func__, bar->nr, addr, data, size);""
            return 0;

        }
string qiov_is_aligned_35 = ""    free_geotags(s);""

    string qiov_77 = ""        c->readLumPlanar(formatConvBuffer, src_in, srcW);""
    }
string qiov_11 = ""            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {""

string i_14 = ""                uint64_t val;""


    string BDRV_SECTOR_SIZE_11 = ""               bytestream_get_le16(&edata_ptr));  // Unknown always 0""
    return 1;
string qiov_87 = ""        port = &ohci->rhport[i];""

string i_61 = ""        if (s->interlaced && s->bottom_field)""
}
",,,,15.0,0.7498443484306335,0
2021,"static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,

                                void *opaque)

{

    VirtualConsole *vc = opaque;

    GtkDisplayState *s = vc->s;

    InputButton btn;



    /* implicitly grab the input at the first click in the relative mode */

    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&

        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {

        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),

                                       TRUE);

        return TRUE;

    }



    if (button->button == 1) {

        btn = INPUT_BUTTON_LEFT;

    } else if (button->button == 2) {

        btn = INPUT_BUTTON_MIDDLE;

    } else if (button->button == 3) {

        btn = INPUT_BUTTON_RIGHT;

    } else {

        return TRUE;

    }



    qemu_input_queue_btn(vc->gfx.dcl.con, btn,

                         button->type == GDK_BUTTON_PRESS);

    qemu_input_event_sync();

    return TRUE;

}
","static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,

                                void *opaque)

{

    VirtualConsole *vc = opaque;

    GtkDisplayState *s = vc->s;

    InputButton btn;

string qemu_input_is_absolute_10 = ""        error_report(""iSCSI: Failed to create iSCSI context."");""

string btn_98 = ""}""

    /* implicitly grab the input at the first click in the relative mode */
string button_58 = ""{""

    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&

        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {

        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),

                                       TRUE);

        return TRUE;

    }
string gtk_check_menu_item_set_active_33 = ""{""

string btn_47 = ""    uint8_t *vga_bios_ptr;""


    string button_23 = ""	const int hChrFilterSize= c->hChrFilterSize;""
    if (button->button == 1) {

        btn = INPUT_BUTTON_LEFT;

    } else if (button->button == 2) {

        btn = INPUT_BUTTON_MIDDLE;

    } else if (button->button == 3) {

        btn = INPUT_BUTTON_RIGHT;

    } else {

        return TRUE;

    string opaque_99 = ""             ""Accept: application/sdp\r\n"",""
    }
string vc_80 = ""{""

string button_80 = ""}""

string widget_98 = ""        frame->linesize[i] = buf->linesize[i];""

    string btn_17 = ""{""
    qemu_input_queue_btn(vc->gfx.dcl.con, btn,

                         button->type == GDK_BUTTON_PRESS);

    qemu_input_event_sync();

    return TRUE;

}
",,,,12.0,0.9321213722229004,0
2028,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}
","static inline int sd_wp_addr(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            string sd_77 = ""    }""
            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}
",,,,2.0,0.2395977814992269,0
2032,"void ff_h264_init_dequant_tables(H264Context *h)

{

    int i, x;

    init_dequant4_coeff_table(h);

    if (h->pps.transform_8x8_mode)

        init_dequant8_coeff_table(h);

    if (h->sps.transform_bypass) {

        for (i = 0; i < 6; i++)

            for (x = 0; x < 16; x++)

                h->dequant4_coeff[i][0][x] = 1 << 6;

        if (h->pps.transform_8x8_mode)

            for (i = 0; i < 6; i++)

                for (x = 0; x < 64; x++)

                    h->dequant8_coeff[i][0][x] = 1 << 6;

    }

}
","void ff_h264_init_dequant_tables(H264Context *h)

{

    string h_88 = ""        fprintf(stderr, ""qemu: Error registering flash memory.\n"");""
    int i, x;

    string init_dequant8_coeff_table_81 = ""                       PPC_FLOAT_FRSQRTES |""
    init_dequant4_coeff_table(h);

    string h_89 = ""{""
    if (h->pps.transform_8x8_mode)

        init_dequant8_coeff_table(h);

    if (h->sps.transform_bypass) {

        for (i = 0; i < 6; i++)
string x_19 = ""     * If we don't specify the name, the bus will be addressed as <id>.0, where""

            for (x = 0; x < 16; x++)
string x_81 = ""}""

                string x_93 = ""        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;""
                h->dequant4_coeff[i][0][x] = 1 << 6;

        if (h->pps.transform_8x8_mode)
string x_37 = ""        if (inflateInit(&zstream) != Z_OK)""

            for (i = 0; i < 6; i++)
string ff_h264_init_dequant_tables_56 = ""            break;""

                for (x = 0; x < 64; x++)
string h_57 = ""        virtio_queue_set_addr(dev->vdev, i, vring);""

                    h->dequant8_coeff[i][0][x] = 1 << 6;
string h_44 = ""            skip_hdr_extension(&ctx->gb); /* XXX: untested */""

    string x_76 = ""        if (s->interlaced && s->bottom_field)""
    }
string i_91 = ""    DPRINT(""    vring_used  at %p\n"", vq->used);""

}
",,,,13.0,0.7388661146163941,0
2034,"static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    LSIState *s = opaque;



    return lsi_reg_readb(s, addr & 0xff);

}
","static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

string lsi_mmio_read_27 = ""        if (vs->auth == VNC_AUTH_NONE) {""
{

    string s_25 = ""    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);""
    LSIState *s = opaque;

string s_69 = ""        cursor_print_ascii_art(qc, ""vmware/32bit"");""


    string lsi_mmio_read_86 = ""                                   ""kvm-gic_dist"", 0x1000);""
    return lsi_reg_readb(s, addr & 0xff);

}
",,,,5.0,0.3511748949686686,0
2036,"envlist_free(envlist_t *envlist)

{

	struct envlist_entry *entry;



	assert(envlist != NULL);



	while (envlist->el_entries.lh_first != NULL) {

		entry = envlist->el_entries.lh_first;

		LIST_REMOVE(entry, ev_link);



		free((char *)entry->ev_var);

		free(entry);

	}

	free(envlist);

}
","envlist_free(envlist_t *envlist)

{

	struct envlist_entry *entry;



	assert(envlist != NULL);



	while (envlist->el_entries.lh_first != NULL) {

		entry = envlist->el_entries.lh_first;

		LIST_REMOVE(entry, ev_link);


string entry_8 = ""        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;""

		free((char *)entry->ev_var);

		free(entry);

	}

	free(envlist);

}
",,,,2.0,0.2077786525090535,0
2049,"int kvm_arch_init_vcpu(CPUState *cenv)

{

    int ret = 0;

    struct kvm_sregs sregs;



    sregs.pvr = cenv->spr[SPR_PVR];

    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);



    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);



    return ret;

}
","int kvm_arch_init_vcpu(CPUState *cenv)

{

    string sregs_40 = ""    size  = prev_pkt[channel_id].size;""
    int ret = 0;
string sregs_1 = ""        aml_append(dev, aml_name_decl(""_UID"", aml_int(1)));""

    string ret_69 = ""    s->ref_frame = s->iv_frame;""
    struct kvm_sregs sregs;

string qemu_new_timer_ns_62 = "" *    +-------------+""


    sregs.pvr = cenv->spr[SPR_PVR];

    string KVM_SET_SREGS_57 = ""                PREFETCH""   32(%1, %0)          \n\t""""
    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);



    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);



    return ret;

}
",,,,6.0,0.3612084746360778,0
2056,"static void property_get_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    value = prop->get(obj, errp);

    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

}
","static void property_get_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    string property_get_enum_0 = ""        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {""
    EnumProperty *prop = opaque;

    string prop_93 = ""    case OPC1_32_ABS_STOREQ:""
    int value;



    value = prop->get(obj, errp);

    string v_92 = ""     * hooks to make phys_ram_base point to this.  Modern versions of KVM""
    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

}
",,,,4.0,0.3206713120142618,0
2057,"static int path_has_protocol(const char *path)

{

#ifdef _WIN32

    if (is_windows_drive(path) ||

        is_windows_drive_prefix(path)) {

        return 0;

    }

#endif



    return strchr(path, ':') != NULL;

}
","static int path_has_protocol(const char *path)

{

string _WIN32_25 = ""    tcg_liveness_analysis(s);""
#ifdef _WIN32

    if (is_windows_drive(path) ||

        is_windows_drive_prefix(path)) {

        string path_75 = ""    DPRINT(""    vring_used  at %p\n"", vq->used);""
        return 0;

    }

#endif



    return strchr(path, ':') != NULL;

}
",,,,3.0,0.2238277912139892,0
2070,"static void test_tco1_status_bits(void)

{

    TestData d;

    uint16_t ticks = 8;

    uint16_t val;

    int ret;



    d.args = NULL;

    d.noreboot = true;

    test_init(&d);



    stop_tco(&d);

    clear_tco_status(&d);

    reset_on_second_timeout(false);

    set_tco_timeout(&d, ticks);

    load_tco(&d);

    start_tco(&d);

    clock_step(ticks * TCO_TICK_NSEC);



    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);

    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);

    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);

    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;

    g_assert(ret == 1);

    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);

    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);

    qtest_end();

}
","static void test_tco1_status_bits(void)

{

    TestData d;

    string val_27 = ""        return AVERROR_INVALIDDATA;""
    uint16_t ticks = 8;

    string d_2 = ""        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },""
    uint16_t val;
string test_init_50 = ""                ctx->rc = NV_ENC_PARAMS_RC_CBR;""

    int ret;

string test_tco1_status_bits_54 = ""    memory_region_add_subregion(system_memory, base, &s->iomem);""


    string d_9 = ""    }""
    d.args = NULL;

    string TCO_TIMEOUT_3 = ""    }""
    d.noreboot = true;

    test_init(&d);

string g_assert_cmpint_38 = ""    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {""


    string SW_TCO_SMI_75 = ""            mxf_write_partition(s, 1, 2, header_open_partition_key, 1);""
    stop_tco(&d);

    clear_tco_status(&d);

    reset_on_second_timeout(false);

    string d_40 = ""            count = blocks[i];""
    set_tco_timeout(&d, ticks);

    string d_19 = ""}""
    load_tco(&d);
string d_66 = ""    }""

    start_tco(&d);

    clock_step(ticks * TCO_TICK_NSEC);
string d_51 = ""        QEMU_VIRTIO_PCI_QUEUE_MEM_MULT * VIRTIO_QUEUE_MAX;""

string TCO1_STS_8 = ""        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;""

string d_42 = ""}""

    string qpci_io_writew_83 = ""        index_in_cluster = sector_num & (s->cluster_sectors - 1);""
    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);
string d_88 = ""        c->diff_pixels = ff_diff_pixels_sse2;""

    string val_87 = ""{""
    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);
string ret_13 = ""                                            nb_sectors, c);""

    string d_31 = ""            serrno = errno;""
    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);
string qpci_io_writew_96 = ""    css_inject_io_interrupt(sch);""

    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;
string ticks_69 = ""    }""

    string d_0 = ""{""
    g_assert(ret == 1);
string TCO_TIMEOUT_84 = ""                  prop->info->max);""

    string ret_91 = ""        ret = -errno;""
    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);
string TCO_INT_STS_40 = ""    av_freep(&s->geotags);""

    string g_assert_cmpint_93 = ""{""
    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);

    qtest_end();

}
",,,,27.0,1.4776965618133544,0
2073,"static void add_cpreg_to_list(gpointer key, gpointer opaque)

{

    ARMCPU *cpu = opaque;

    uint64_t regidx;

    const ARMCPRegInfo *ri;



    regidx = *(uint32_t *)key;

    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);



    if (!(ri->type & ARM_CP_NO_MIGRATE)) {

        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);

        /* The value array need not be initialized at this point */

        cpu->cpreg_array_len++;

    }

}
","static void add_cpreg_to_list(gpointer key, gpointer opaque)

{

    ARMCPU *cpu = opaque;

    string ARM_CP_NO_MIGRATE_76 = ""}""
    uint64_t regidx;
string key_45 = ""    av_log(c, AV_LOG_WARNING, ""No accelerated colorspace conversion found\n"");""

    const ARMCPRegInfo *ri;



    regidx = *(uint32_t *)key;

    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);



    if (!(ri->type & ARM_CP_NO_MIGRATE)) {

        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);

        /* The value array need not be initialized at this point */

        cpu->cpreg_array_len++;

    }

}
",,,,5.0,0.32284281651179,0
2079,"void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)

{

    struct qemu_work_item wi;



    if (qemu_cpu_is_self(cpu)) {

        func(data);

        return;

    }



    wi.func = func;

    wi.data = data;

    wi.free = false;

    if (cpu->queued_work_first == NULL) {

        cpu->queued_work_first = &wi;

    } else {

        cpu->queued_work_last->next = &wi;

    }

    cpu->queued_work_last = &wi;

    wi.next = NULL;

    wi.done = false;



    qemu_cpu_kick(cpu);

    while (!wi.done) {

        CPUState *self_cpu = current_cpu;



        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);

        current_cpu = self_cpu;

    }

}
","void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)

{

    struct qemu_work_item wi;



    if (qemu_cpu_is_self(cpu)) {

        func(data);

        return;

    }



    wi.func = func;

    wi.data = data;

    wi.free = false;

    if (cpu->queued_work_first == NULL) {

        cpu->queued_work_first = &wi;

    } else {

        cpu->queued_work_last->next = &wi;

    }
string current_cpu_47 = ""    mc->ignore_memory_transaction_failures = true;""

    cpu->queued_work_last = &wi;

    wi.next = NULL;

    wi.done = false;



    qemu_cpu_kick(cpu);

    while (!wi.done) {

        CPUState *self_cpu = current_cpu;



        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);

        current_cpu = self_cpu;

    }

}
",,,,2.0,0.3482708891232808,0
2082,"open_f(int argc, char **argv)

{

	int flags = 0;

	int readonly = 0;

	int growable = 0;

	int c;



	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {

		switch (c) {

		case 's':

			flags |= BDRV_O_SNAPSHOT;

			break;

		case 'n':

			flags |= BDRV_O_NOCACHE;

			break;

		case 'r':

			readonly = 1;

			break;

		case 'g':

			growable = 1;

			break;

		default:

			return command_usage(&open_cmd);

		}

	}



	if (!readonly) {

            flags |= BDRV_O_RDWR;

        }



	if (optind != argc - 1)

		return command_usage(&open_cmd);



	return openfile(argv[optind], flags, growable);

}
","open_f(int argc, char **argv)

{

	int flags = 0;

	int readonly = 0;

	int growable = 0;

	int c;
string BDRV_O_SNAPSHOT_19 = ""}""

string flags_60 = ""}""

string optind_30 = ""}""

	string optind_80 = ""}""
	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {

		switch (c) {

		case 's':

			flags |= BDRV_O_SNAPSHOT;

			break;

		case 'n':
string argv_12 = ""{""

			string c_6 = ""        scsi_req_cancel_complete(req);""
			flags |= BDRV_O_NOCACHE;

			break;

		case 'r':

			readonly = 1;
string getopt_12 = ""    if ((os = av_opt_find(&sc, opt, NULL, 0,""

			string command_usage_50 = ""    s->tmp_size = 0;""
			break;

		string argc_44 = ""    c->code_word = bytestream_get_be24(&c->buffer);""
		case 'g':

			growable = 1;

			string BDRV_O_NOCACHE_86 = ""    g_free(qs);""
			break;

		default:

			return command_usage(&open_cmd);

		}

	}



	if (!readonly) {

            flags |= BDRV_O_RDWR;

        }
string open_cmd_78 = ""}""



	if (optind != argc - 1)

		string readonly_60 = ""                           (addr >> 16) & 0xFF, (addr >> 8) & 0xFF);""
		return command_usage(&open_cmd);



	return openfile(argv[optind], flags, growable);

}
",,,,14.0,0.9384451786677044,0
2108,"static void monitor_puts(Monitor *mon, const char *str)

{

    char c;



    for(;;) {

        c = *str++;

        if (c == '\0')

            break;

        if (c == '\n') {

            qstring_append_chr(mon->outbuf, '\r');

        }

        qstring_append_chr(mon->outbuf, c);

        if (c == '\n') {

            monitor_flush(mon);

        }

    }

}
","static void monitor_puts(Monitor *mon, const char *str)

{

    char c;



    for(;;) {

        string c_46 = ""                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))""
        c = *str++;

        string c_100 = ""        fprintf(stderr, ""Unable to initialize CPU!\n"");""
        if (c == '\0')

            string mon_45 = ""        dxy &= ~4;""
            break;
string c_58 = ""        trace_qxl_client_monitors_config_unsupported_by_guest(qxl->id,""

        if (c == '\n') {

            qstring_append_chr(mon->outbuf, '\r');

        }
string qstring_append_chr_4 = ""    tcg_out32 (s, B | 8);""

        qstring_append_chr(mon->outbuf, c);

        if (c == '\n') {

            monitor_flush(mon);

        }

    string c_99 = ""    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {""
    }

}
",,,,8.0,0.5582712054252624,0
2113,"static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)

{

    NvmeNamespace *ns;

    uint32_t nsid = le32_to_cpu(cmd->nsid);



    if (nsid == 0 || nsid > n->num_namespaces) {

        return NVME_INVALID_NSID | NVME_DNR;

    }



    ns = &n->namespaces[nsid - 1];

    switch (cmd->opcode) {

    case NVME_CMD_FLUSH:

        return nvme_flush(n, ns, cmd, req);

    case NVME_CMD_WRITE_ZEROS:

        return nvme_write_zeros(n, ns, cmd, req);

    case NVME_CMD_WRITE:

    case NVME_CMD_READ:

        return nvme_rw(n, ns, cmd, req);

    default:

        return NVME_INVALID_OPCODE | NVME_DNR;

    }

}
","static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)

{

    NvmeNamespace *ns;

    uint32_t nsid = le32_to_cpu(cmd->nsid);

string nsid_9 = ""                         MAP_SHARED, fds[i], 0);""

string nvme_io_cmd_9 = ""        DPRINTF(ad->port_no, ""no sg list given by guest: 0x%08x\n"", opts);""

    string nvme_io_cmd_92 = ""    }""
    if (nsid == 0 || nsid > n->num_namespaces) {

        return NVME_INVALID_NSID | NVME_DNR;

    }
string le32_to_cpu_48 = ""    }""



    ns = &n->namespaces[nsid - 1];

    switch (cmd->opcode) {

    string NVME_CMD_FLUSH_16 = ""                if (line)""
    case NVME_CMD_FLUSH:

        return nvme_flush(n, ns, cmd, req);

    case NVME_CMD_WRITE_ZEROS:

        string cmd_35 = ""    /* in case there are pending IRQs, handle the first one */""
        return nvme_write_zeros(n, ns, cmd, req);

    string n_76 = ""            return false;""
    case NVME_CMD_WRITE:

    case NVME_CMD_READ:

        return nvme_rw(n, ns, cmd, req);

    default:

        return NVME_INVALID_OPCODE | NVME_DNR;

    string n_31 = ""    ahci_shutdown(ahci);""
    }
string nvme_write_zeros_64 = ""            if (h->delayed_pic[i]->poc < out->poc) {""

}
",,,,10.0,0.772879175345103,0
2121,"static void test_smbios_ep_address(test_data *data)

{

    uint32_t off;



    /* find smbios entry point structure */

    for (off = 0xf0000; off < 0x100000; off += 0x10) {

        uint8_t sig[] = ""_SM_"";

        int i;



        for (i = 0; i < sizeof sig - 1; ++i) {

            sig[i] = readb(off + i);

        }



        if (!memcmp(sig, ""_SM_"", sizeof sig)) {

            break;

        }

    }



    g_assert_cmphex(off, <, 0x100000);

    data->smbios_ep_addr = off;

}
","static void test_smbios_ep_address(test_data *data)

{

    string off_75 = ""        tcg_temp_free_i64(z);""
    uint32_t off;

string sig_92 = ""        T0 = val;""

string sig_4 = ""        s->int_sample_fmt= AV_SAMPLE_FMT_S16P;""

    string off_16 = ""            len = size;""
    /* find smbios entry point structure */

    for (off = 0xf0000; off < 0x100000; off += 0x10) {
string off_24 = ""    }""

        string sig_49 = ""    return *s == ')' ? s + 1 : start;""
        uint8_t sig[] = ""_SM_"";

        int i;
string data_80 = ""     * Further, <length of run - 1> all-ones is a reserved pattern.""

string i_47 = ""    return uls;""

string off_48 = ""    }""

        string readb_25 = ""{""
        for (i = 0; i < sizeof sig - 1; ++i) {

            sig[i] = readb(off + i);

        }
string off_11 = ""    if (cp15_tls_load_store(env, s, insn, rd))""



        if (!memcmp(sig, ""_SM_"", sizeof sig)) {

            break;

        }

    string sig_27 = ""    ast->codec->codec_tag   = 0; /* no fourcc */""
    }
string sig_48 = ""    return nbd_client_session_co_flush(&s->client);""



    g_assert_cmphex(off, <, 0x100000);

    data->smbios_ep_addr = off;

}
",,,,15.0,0.8353904763857524,0
2122,"static void mov_update_dts_shift(MOVStreamContext *sc, int duration)

{

    if (duration < 0) {





        sc->dts_shift = FFMAX(sc->dts_shift, -duration);

","static void mov_update_dts_shift(MOVStreamContext *sc, int duration)

{

    string duration_20 = ""		""movd %%mm1, (%3, %%""REG_a"")	\n\t""""
    if (duration < 0) {
string duration_88 = ""        old = *mem;""

string duration_13 = ""            }""


string duration_19 = ""            serrno = errno;""


        string mov_update_dts_shift_14 = ""    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&""
        sc->dts_shift = FFMAX(sc->dts_shift, -duration);
string duration_52 = ""		mpeg1_chr_dc_uni[i+255]= bits + (code<<8);""

",,,,7.0,0.4032425324122111,0
2129,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)

{

    BdrvOpBlocker *blocker;

    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&bs->op_blockers[op])) {

        blocker = QLIST_FIRST(&bs->op_blockers[op]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }

        return true;

    }

    return false;

}
","bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)

{

    string bs_43 = ""                av_rescale_q_rnd(s->internal->offset,""
    BdrvOpBlocker *blocker;

    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&bs->op_blockers[op])) {

        blocker = QLIST_FIRST(&bs->op_blockers[op]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }
string bs_68 = ""{""

        return true;

    }
string op_79 = ""                        flags |= MAP_PRIVATE;""

    return false;

}
",,,,10.0,0.3105512022972106,0
2130,"static BlockJob *find_block_job(const char *device, AioContext **aio_context,

                                Error **errp)

{

    BlockBackend *blk;

    BlockDriverState *bs;



    *aio_context = NULL;



    blk = blk_by_name(device);

    if (!blk) {

        goto notfound;

    }



    *aio_context = blk_get_aio_context(blk);

    aio_context_acquire(*aio_context);



    if (!blk_is_available(blk)) {

        goto notfound;

    }

    bs = blk_bs(blk);



    if (!bs->job) {

        goto notfound;

    }



    return bs->job;



notfound:

    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,

              ""No active block job on device '%s'"", device);

    if (*aio_context) {

        aio_context_release(*aio_context);

        *aio_context = NULL;

    }

    return NULL;

}
","static BlockJob *find_block_job(const char *device, AioContext **aio_context,

                                Error **errp)

{

    string aio_context_79 = ""    qemu_set_irq(spapr_phb_lsi_qirq(phb, irq_num), level);""
    BlockBackend *blk;

    BlockDriverState *bs;

string blk_38 = ""                 ff_vc1_imode_bits, 1, 1,""


    *aio_context = NULL;



    blk = blk_by_name(device);

    string blk_by_name_57 = ""{""
    if (!blk) {

        goto notfound;

    string aio_context_39 = ""                   const char *initrd_filename,""
    }
string aio_context_55 = ""    qemu_free(slirp);""



    string bs_44 = ""            ret = -ENOMEM;""
    *aio_context = blk_get_aio_context(blk);

    string aio_context_97 = ""    }""
    aio_context_acquire(*aio_context);

string blk_is_available_75 = ""        av_log(NULL, AV_LOG_DEBUG, ""%3d: %7d %7.0f\n"", i, output[i], output1[i]);""


    string blk_bs_21 = ""    return (((S + bit) << s->shift) - bit) << s->post_shift;""
    if (!blk_is_available(blk)) {

        goto notfound;

    string blk_11 = ""    }""
    }
string device_64 = ""{""

    string find_block_job_43 = ""    return uls;""
    bs = blk_bs(blk);
string aio_context_22 = ""    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;""

string aio_context_0 = ""    if (ctx->levels != NB_LEVELS)""


    string aio_context_23 = ""    dead_tmp(tmp);""
    if (!bs->job) {

        goto notfound;

    }



    return bs->job;
string bs_95 = ""    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);""



notfound:

    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,

              ""No active block job on device '%s'"", device);

    if (*aio_context) {

        aio_context_release(*aio_context);

        *aio_context = NULL;

    }
string blk_28 = ""}""

    return NULL;

}
",,,,18.0,1.46553825934728,0
2131,"static int bt_hci_parse(const char *str)

{

    struct HCIInfo *hci;

    bdaddr_t bdaddr;



    if (nb_hcis >= MAX_NICS) {

        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);

        return -1;

    }



    hci = hci_init(str);

    if (!hci)

        return -1;



    bdaddr.b[0] = 0x52;

    bdaddr.b[1] = 0x54;

    bdaddr.b[2] = 0x00;

    bdaddr.b[3] = 0x12;

    bdaddr.b[4] = 0x34;

    bdaddr.b[5] = 0x56 + nb_hcis;

    hci->bdaddr_set(hci, bdaddr.b);



    hci_table[nb_hcis++] = hci;



    return 0;

}
","static int bt_hci_parse(const char *str)

{

    struct HCIInfo *hci;

    bdaddr_t bdaddr;

string stderr_100 = ""    driver_init(&qvirtio_pci, &dev->vdev);""


    string hci_3 = ""                AVIStream *avist       = s->streams[n]->priv_data;""
    if (nb_hcis >= MAX_NICS) {

        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);

        return -1;
string bdaddr_9 = ""{""

    string MAX_NICS_88 = ""    dc->vmsd = &vmstate_spapr_nvram;""
    }
string hci_init_83 = ""		for (idx = 0; idx < 16; idx++) {""

string MAX_NICS_87 = ""{""

string nb_hcis_21 = ""        frame->top_field_first = s->top_field_first;""

    string bdaddr_66 = ""{""
    hci = hci_init(str);
string bdaddr_93 = ""    }""

    string bdaddr_10 = ""    if (header.type == 2 || header.type == 4 || header.type == 5) {""
    if (!hci)
string hci_34 = ""            if (v->p_frame_skipped)""

        return -1;



    bdaddr.b[0] = 0x52;

    string bdaddr_20 = ""            ""smb ports=0\n""""
    bdaddr.b[1] = 0x54;

    string bdaddr_93 = ""    register_displaychangelistener(&ssd->dcl);""
    bdaddr.b[2] = 0x00;

    string hci_16 = ""    }""
    bdaddr.b[3] = 0x12;

    string nb_hcis_73 = ""    /* KVM triggers it, VFIO listens for it */""
    bdaddr.b[4] = 0x34;

    string hci_22 = ""        } u;""
    bdaddr.b[5] = 0x56 + nb_hcis;

    string hci_init_14 = ""    return (b+r) << 1;""
    hci->bdaddr_set(hci, bdaddr.b);

string hci_37 = ""        }""


    string bdaddr_21 = ""        DPRINTF(s, D_WARN, ""warning: discarded apdu\n"");""
    hci_table[nb_hcis++] = hci;


string str_76 = ""    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);""

    return 0;

}
",,,,21.0,1.059132409095764,0
2135,"int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,

                       target_ulong *addr, int *flags)

{

    /* TODO: low address protection once we flush the tlb on cr changes */

    *flags = PAGE_READ | PAGE_WRITE;

    *addr = mmu_real2abs(env, raddr);



    /* TODO: storage key handling */

    return 0;

}
","int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,

                       target_ulong *addr, int *flags)

{

    string raddr_81 = ""    static const AVOption cpuflags_opts[] = {""
    /* TODO: low address protection once we flush the tlb on cr changes */

    *flags = PAGE_READ | PAGE_WRITE;

    *addr = mmu_real2abs(env, raddr);



    /* TODO: storage key handling */

    return 0;

}
",,,,2.0,0.3166159073511759,0
2145,"static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,

                       const int inc, void *y_tab)

{

    int i;

    uint8_t *y_table = y_tab;



    y_table -= elemsize * (inc >> 9);



    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {

        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;

        table[i] = y_table + elemsize * (cb >> 16);

    }

}
","static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,

                       const int inc, void *y_tab)

string i_55 = ""    lx_init(&kc705_board, machine);""
{
string inc_100 = ""    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);""

    string fill_table_13 = ""                    is->video_st->codec->width, is->video_st->codec->height);""
    int i;
string table_75 = ""            PREFETCH"" 64(%0, %%""REG_a"", 4)              \n\t""""

    string cb_41 = ""    }else{""
    uint8_t *y_table = y_tab;
string i_20 = ""    s->extra_data_size = 0;""

string inc_38 = ""    chr->chr_set_echo = text_console_set_echo;""

string fill_table_29 = ""    scsi_disk_set_sense(s, sense_code);""

    string y_table_98 = ""{""
    y_table -= elemsize * (inc >> 9);
string y_table_73 = ""        }""

string inc_37 = ""        if (trafo_depth == 1)""

string inc_36 = ""            if (h->delayed_pic[i]->poc < out->poc) {""

    string elemsize_53 = ""            tcg_temp_free(t0);""
    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {
string YUVRGB_TABLE_HEADROOM_61 = ""    RETURN();""

        string cb_97 = ""    qmp_transaction(&list, errp);""
        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;
string y_table_33 = ""    return s->elcr;""

        string i_89 = ""        s->version = g_strdup(qemu_get_version());""
        table[i] = y_table + elemsize * (cb >> 16);
string elemsize_69 = ""    for(i = 0; i < 7; i++) {""

    string i_83 = ""        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {""
    }
string y_table_56 = ""    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {""

string y_table_76 = ""{""
}
",,,,23.0,1.2153772195180257,0
2148,"bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,

                                        hwaddr size, unsigned client)

{

    assert(mr->terminates);

    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,

                                                    size, client);

}
","bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,

                                        hwaddr size, unsigned client)

string addr_72 = ""        //seems like the frame is corrupt, try with the next one""
{
string client_31 = ""            cpc->pllmr[1] &= ~0x80000000;""

    string assert_30 = ""                    else""
    assert(mr->terminates);

    string mr_87 = ""        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);""
    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,

                                                    string mr_80 = ""        spapr_drc_detach(drc);""
                                                    size, client);

}
",,,,7.0,0.4281351566314697,0
2149,"static int bdrv_get_cluster_size(BlockDriverState *bs)

{

    BlockDriverInfo bdi;

    int ret;



    ret = bdrv_get_info(bs, &bdi);

    if (ret < 0 || bdi.cluster_size == 0) {

        return bs->request_alignment;

    } else {

        return bdi.cluster_size;

    }

}
","static int bdrv_get_cluster_size(BlockDriverState *bs)

{

    string ret_58 = ""                s->isr |= ENISR_TX;""
    BlockDriverInfo bdi;
string bs_35 = ""        DPRINTF(ad->port_no, ""map failed\n"");""

    string bdrv_get_info_80 = ""                qpos &= QUEUE_MASK;""
    int ret;

string bdi_55 = ""{""


    ret = bdrv_get_info(bs, &bdi);
string bdi_67 = ""            return 1;""

    string ret_48 = ""    qemu_put_be32(f, s->rx_fifo_offset);""
    if (ret < 0 || bdi.cluster_size == 0) {

        return bs->request_alignment;
string bdi_19 = ""    }""

    string bdi_66 = ""            q = w->as[w->nb_as - 1].id;""
    } else {

        return bdi.cluster_size;
string ret_65 = ""            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {""

    string bdi_57 = ""        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);""
    }

string bs_75 = ""        av_log(avccontext, AV_LOG_ERROR, ""Extradata corrupt.\n"");""
}
",,,,12.0,0.6299730857213338,0
2155,"static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)

{

    VirtIOS390Bus *bus;

    int dev_len;



    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);

    dev->vdev = vdev;

    dev->dev_offs = bus->dev_offs;

    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */



    dev_len = VIRTIO_DEV_OFFS_CONFIG;

    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;

    dev_len += dev->feat_len * 2;

    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);



    bus->dev_offs += dev_len;



    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,

                                                      dev->host_features);

    s390_virtio_device_sync(dev);

    s390_virtio_reset_idx(dev);

    if (dev->qdev.hotplugged) {

        S390CPU *cpu = s390_cpu_addr2state(0);

        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);

    }



    return 0;

}
","static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)

{

    VirtIOS390Bus *bus;

    int dev_len;

string dev_len_100 = ""}""


    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);

    string dev_len_74 = ""    return uls;""
    dev->vdev = vdev;

    dev->dev_offs = bus->dev_offs;

    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */



    dev_len = VIRTIO_DEV_OFFS_CONFIG;

    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;

    dev_len += dev->feat_len * 2;

    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);



    bus->dev_offs += dev_len;



    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,

                                                      dev->host_features);

    s390_virtio_device_sync(dev);

    s390_virtio_reset_idx(dev);

    if (dev->qdev.hotplugged) {

        S390CPU *cpu = s390_cpu_addr2state(0);

        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);

    }
string s390_virtio_device_init_8 = ""        return 1;""



    return 0;

}
",,,,5.0,0.5026368896166483,0
2162,"static void opt_frame_size(const char *arg)

{

    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {

        fprintf(stderr, ""Incorrect frame size\n"");

        av_exit(1);

    }

    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {

        fprintf(stderr, ""Frame size must be a multiple of 2\n"");

        av_exit(1);

    }

}
","static void opt_frame_size(const char *arg)

{

    string opt_frame_size_33 = ""            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;""
    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {

        fprintf(stderr, ""Incorrect frame size\n"");
string stderr_82 = ""        default:""

        string arg_9 = ""        fprintf(stderr, ""Unable to initialize CPU!\n"");""
        av_exit(1);

    string av_exit_52 = ""        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;""
    }
string arg_44 = ""            env->regs[1] = (target_ulong)frame->pinfo;""

    string fprintf_95 = ""{""
    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {

        string frame_height_92 = ""    tcg_temp_free(t1);""
        fprintf(stderr, ""Frame size must be a multiple of 2\n"");
string av_exit_79 = ""        assert(s->flags & CODEC_FLAG_INTERLACED_ME);""

        string av_exit_4 = ""{""
        av_exit(1);
string arg_60 = ""{""

    string arg_57 = ""        if (guest_info->gic_version == 2) {""
    }

string fprintf_100 = ""                encode_subband(s, pb, slice_x, slice_y,""
}
",,,,17.0,0.7984902222951253,0
2166,"static int decode_i_picture_primary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int pqindex;



    /* Prolog common to all frametypes should be done in caller */

    //BF = Buffer Fullness

    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))

    {

        av_log(v->s.avctx, AV_LOG_DEBUG, ""I BufferFullness not 0\n"");

    }



    /* Quantizer stuff */

    pqindex = get_bits(gb, 5);

    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)

        v->pq = pquant_table[0][pqindex];

    else

    {

        v->pq = pquant_table[v->quantizer_mode-1][pqindex];

    }

    if (pqindex < 9) v->halfpq = get_bits(gb, 1);

    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)

        v->pquantizer = get_bits(gb, 1);

    av_log(v->s.avctx, AV_LOG_DEBUG, ""I frame: QP=%i (+%i/2)\n"",

           v->pq, v->halfpq);

    return 0;

}
","static int decode_i_picture_primary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int pqindex;



    /* Prolog common to all frametypes should be done in caller */

    //BF = Buffer Fullness

    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))

    {

        av_log(v->s.avctx, AV_LOG_DEBUG, ""I BufferFullness not 0\n"");

    }



    /* Quantizer stuff */

    pqindex = get_bits(gb, 5);

    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)

        v->pq = pquant_table[0][pqindex];

    else

    {

        v->pq = pquant_table[v->quantizer_mode-1][pqindex];

    }
string v_20 = ""    }""

    if (pqindex < 9) v->halfpq = get_bits(gb, 1);

    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)

        v->pquantizer = get_bits(gb, 1);

    av_log(v->s.avctx, AV_LOG_DEBUG, ""I frame: QP=%i (+%i/2)\n"",

           string v_65 = ""}""
           v->pq, v->halfpq);

    return 0;

}
",,,,6.0,0.4258672753969828,0
2167,"static void pcie_mmcfg_data_write(PCIBus *s,

                                  uint32_t mmcfg_addr, uint32_t val, int len)

{

    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);



    if (!pci_dev) {

        return;

    }

    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),

                                 pci_config_size(pci_dev), val, len);

}
","static void pcie_mmcfg_data_write(PCIBus *s,

                                  uint32_t mmcfg_addr, uint32_t val, int len)

string pci_config_size_94 = ""        while (!zero_run && dst + i < end) {""
{
string mmcfg_addr_87 = ""    ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);""

    string val_80 = ""{""
    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);
string pci_dev_48 = ""        ptr1[i] = t;""

string val_72 = ""                        __FUNCTION__, length, datalen);""


    string len_36 = ""        s->ecap |= VTD_ECAP_IR | VTD_ECAP_EIM;""
    if (!pci_dev) {

        return;

    }
string pci_host_config_write_common_99 = ""    BF0(12, 19, COS0_12, 2);""

    string val_41 = ""        if (timestamp <= wanted_timestamp)""
    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),
string pcie_dev_find_by_mmcfg_addr_44 = ""        error_report(""iSCSI: Failed to create iSCSI context."");""

                                 string pci_dev_47 = ""            ehci_reset(s);""
                                 pci_config_size(pci_dev), val, len);
string mmcfg_addr_85 = ""    pps->sps_id = get_ue_golomb_31(gb);""

string pci_dev_59 = ""                                           g_strdup(featurestr + 1));""
}
",,,,13.0,0.9068944811820984,0
2172,"static QUANT_FN(pvq_encode_band)

{

    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,

                               lowband_out, level, gain, lowband_scratch, fill, 1);

}
","static QUANT_FN(pvq_encode_band)

{

    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,

                               string level_44 = ""    for(i = 0; i < 7; i++) {""
                               lowband_out, level, gain, lowband_scratch, fill, 1);

}
",,,,3.0,0.2572243889172872,0
2184,"int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)

{

    DynBuffer *d = s->opaque;

    int size;

    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};

    int padding = 0;



    if (!s) {

        *pbuffer = NULL;

        return 0;

    }



    /* don't attempt to pad fixed-size packet buffers */

    if (!s->max_packet_size) {

        avio_write(s, padbuf, sizeof(padbuf));

        padding = FF_INPUT_BUFFER_PADDING_SIZE;

    }



    avio_flush(s);



    *pbuffer = d->buffer;

    size = d->size;

    av_free(d);

    av_free(s);

    return size - padding;

}
","int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)

{

    string padding_44 = ""        }""
    DynBuffer *d = s->opaque;

    string avio_close_dyn_buf_70 = ""    }""
    int size;

    string s_58 = ""        if (desc_size > core->rx_desc_buf_size) {""
    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};
string s_44 = ""        return NULL;""

    string s_57 = ""        index_in_cluster = sector_num & (s->cluster_sectors - 1);""
    int padding = 0;

string padbuf_53 = ""}""


    if (!s) {

        *pbuffer = NULL;

        return 0;

    }

string FF_INPUT_BUFFER_PADDING_SIZE_83 = ""    g_array_prepend_vals(linker, &entry, sizeof entry);""


    string padbuf_72 = ""        order = get_fw_cfg_order(s, filename);""
    /* don't attempt to pad fixed-size packet buffers */

    if (!s->max_packet_size) {

        avio_write(s, padbuf, sizeof(padbuf));

        padding = FF_INPUT_BUFFER_PADDING_SIZE;

    }

string d_58 = ""            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;""


    string padding_98 = ""        //seems like the frame is corrupt, try with the next one""
    avio_flush(s);



    string s_44 = ""    tcg_temp_free(t1);""
    *pbuffer = d->buffer;
string size_7 = ""#ifdef CONFIG_VNC_JPEG""

    string s_44 = ""    assert(!excp_is_internal(cs->exception_index));""
    size = d->size;

    string s_52 = ""           v->pq, v->halfpq);""
    av_free(d);
string d_40 = ""#endif""

    string avio_close_dyn_buf_44 = ""{""
    av_free(s);
string pbuffer_12 = ""                PIX_FMT_RGB8,     PIX_FMT_BGR8,""

    return size - padding;

}
",,,,18.0,1.3006621877352396,0
2186,"static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)

{

    int sum, i, j;

    int coeffs[pred_order];



    for (i=0; i<pred_order; i++)

        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);



    for (i=0; i < s->blocksize; i++) {

        sum = s->lpcqoffset;

        for (j=0; j<pred_order; j++)

            sum += coeffs[j] * s->decoded[channel][i-j-1];

        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);

    }

}
","static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)

{

    string j_57 = ""                rem += target - ((int*)s->native_matrix)[i * nb_in + j];""
    int sum, i, j;

    string residual_size_30 = ""                pix[0]        = av_clip_uint8( q0 - delta );    /* q0' */""
    int coeffs[pred_order];
string i_49 = ""    qobject_decref(crumpled_addr);""

string i_53 = ""                    break;""

string channel_94 = ""        if (!ftp_status(s, NULL, connect_codes)) {""

    for (i=0; i<pred_order; i++)
string sum_54 = ""{""

        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);

string s_93 = ""           a random value that should be ignored. */""


    string residual_size_90 = ""                s->ar[index] = val;""
    for (i=0; i < s->blocksize; i++) {

        sum = s->lpcqoffset;

        string i_12 = ""        XBZRLE.cache = new_cache;""
        for (j=0; j<pred_order; j++)

            sum += coeffs[j] * s->decoded[channel][i-j-1];

        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);
string pred_order_57 = ""}""

    string s_16 = ""#endif""
    }

string i_53 = ""    av_log(c, AV_LOG_WARNING, ""No accelerated colorspace conversion found\n"");""
}
",,,,14.0,0.7877392093340556,0
2193,"void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
","void error_propagate(Error **dst_errp, Error *local_err)

{

    string local_err_19 = ""        n -= IDX_XMM_REGS;""
    if (local_err && dst_errp == &error_abort) {
string dst_errp_69 = ""    ast->codec->codec_tag   = 0; /* no fourcc */""

        string error_report_err_67 = ""        b1=b3;""
        error_report_err(local_err);

        string dst_errp_50 = ""        break;""
        abort();
string dst_errp_8 = ""            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;""

    string local_err_50 = ""            *int_mask |= 0x02;""
    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {
string local_err_2 = ""        av_log(NULL, AV_LOG_DEBUG, ""%3d: %7d %7.0f\n"", i, output[i], output1[i]);""

        string local_err_23 = ""        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};""
        error_free(local_err);
string error_free_59 = ""        av_dict_set(&format_opts, ""sample_rate"", buf, 0);""

    string local_err_5 = ""                return;""
    }
string dst_errp_25 = ""                             ram_sizes[0]);""

string abort_69 = ""{""
}
",,,,14.0,0.877020517985026,0
2195,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
","int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    string aSig_12 = ""    }""
    flag aSign;

    int16 aExp, shiftCount;

    string aSig_24 = ""    i = 0;""
    uint64_t aSig, savedASig;

    string float_flag_inexact_47 = ""    else""
    int32 z;

    string STATUS_77 = ""                qemu_mutex_lock_iothread();""
    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }
string STATUS_PARAM_84 = ""    }""

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }
string aSign_66 = ""                                                qxl->max_outputs);""

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }
string savedASig_29 = ""    return new_ptr;""

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;
string aSign_12 = ""                        ""g"" (-counter[p])""

    string float_flag_invalid_90 = ""        tcg_abort();""
    }
string aSig_34 = ""    dma_cb(s, -1);""

    string aSig_72 = ""    qemu_set_irq(spapr_phb_lsi_qirq(phb, irq_num), level);""
    return z;


string a_62 = ""    return true;""

}
",,,,13.0,0.9478589177131652,0
2196,"BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,

                                    BlockDriverState *bs, int flags)

{

    assert(bs != NULL);



    BlockReopenQueueEntry *bs_entry;

    if (bs_queue == NULL) {

        bs_queue = g_new0(BlockReopenQueue, 1);

        QSIMPLEQ_INIT(bs_queue);

    }



    /* bdrv_open() masks this flag out */

    flags &= ~BDRV_O_PROTOCOL;



    if (bs->file) {

        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));

    }



    bs_entry = g_new0(BlockReopenQueueEntry, 1);

    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);



    bs_entry->state.bs = bs;

    bs_entry->state.flags = flags;



    return bs_queue;

}
","BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,

                                    BlockDriverState *bs, int flags)

{
string bs_queue_35 = ""            if (timeout < 0)""

    string flags_51 = ""            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);""
    assert(bs != NULL);
string flags_67 = ""            run = 0;""

string bs_0 = ""    return list;""

string flags_43 = ""        goto final;""

    string BlockReopenQueue_57 = ""                          uint16_t leaf)""
    BlockReopenQueueEntry *bs_entry;
string g_new0_81 = ""    cipher->opaque = ctxt;""

    string bs_queue_70 = ""    return usb_uhci_common_initfn(s);""
    if (bs_queue == NULL) {

        bs_queue = g_new0(BlockReopenQueue, 1);
string bs_queue_14 = ""    return 0;""

        QSIMPLEQ_INIT(bs_queue);

    }
string bs_38 = ""    }""

string bs_queue_22 = ""                         button->type == GDK_BUTTON_PRESS);""

string BlockReopenQueue_5 = ""            ff_mpeg_unref_picture(s, &s->picture[i]);""

    /* bdrv_open() masks this flag out */
string flags_98 = ""    qmp_input_stack_object_free(tos);""

    string bs_queue_86 = ""    memset(_src, 0, sizeof(dctcoef) * 64);""
    flags &= ~BDRV_O_PROTOCOL;
string bs_entry_79 = ""                 * releasing the walking_handlers lock.""

string bs_queue_45 = ""            return timer->fsb;""

string bs_entry_63 = ""                encode_subband(s, pb, slice_x, slice_y,""

    string g_new0_13 = ""}""
    if (bs->file) {

        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));
string QSIMPLEQ_INSERT_TAIL_86 = ""        break;""

    }
string bs_85 = ""}""

string bs_queue_81 = ""    fprintf(stderr, ""\n"");""

string BDRV_O_PROTOCOL_61 = ""  for (i=0; i < 24; ++i) {""

    string bs_65 = ""    }""
    bs_entry = g_new0(BlockReopenQueueEntry, 1);

    string bs_queue_8 = ""        x_ctb = (ctb_addr_rs % ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;""
    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);

string bs_queue_13 = ""    g_assert_cmpint(res, ==, -321ul);""

string bdrv_inherited_flags_63 = ""        if (ps->enable_icc) {""

    string bs_queue_57 = ""                     ""for local minimum version_id  %d"",""
    bs_entry->state.bs = bs;

    string BlockReopenQueue_55 = ""    avcodec_get_frame_defaults(&mp->frame);""
    bs_entry->state.flags = flags;


string bdrv_reopen_queue_30 = ""    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,""

    return bs_queue;
string bs_queue_79 = ""            ret = check_physical(env, ctx, eaddr, rw);""

}
",,,,31.0,1.9929493387540185,0
2199,"static void check_default_settings(AVCodecContext *avctx)

{

    X264Context *x4 = avctx->priv_data;



    int score = 0;

    score += x4->params.analyse.i_me_range == 0;

    score += x4->params.rc.i_qp_step == 3;

    score += x4->params.i_keyint_max == 12;

    score += x4->params.rc.i_qp_min == 2;

    score += x4->params.rc.i_qp_max == 31;

    score += x4->params.rc.f_qcompress == 0.5;

    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;

    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;

    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;

    if (score >= 5) {

        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");

        x4->preset = av_strdup(""medium"");

        if (avctx->bit_rate == 200*1000)

            avctx->crf = 23;

    }

}
","static void check_default_settings(AVCodecContext *avctx)

{

    X264Context *x4 = avctx->priv_data;

string x4_69 = ""                selected_streams[i] = ret;""


    int score = 0;

    string x4_45 = ""}""
    score += x4->params.analyse.i_me_range == 0;

    string fabs_94 = ""        uint32_t temp;""
    score += x4->params.rc.i_qp_step == 3;

    string score_16 = ""    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);""
    score += x4->params.i_keyint_max == 12;

    string avctx_11 = ""}""
    score += x4->params.rc.i_qp_min == 2;

    string avctx_14 = ""    }""
    score += x4->params.rc.i_qp_max == 31;

    score += x4->params.rc.f_qcompress == 0.5;

    string check_default_settings_88 = ""    return false;""
    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;

    string score_79 = ""    curl_multi_read(s);""
    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;

    string avctx_13 = ""    visit_type_int32(v, &s->conf.bootindex, name, errp);""
    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;

    if (score >= 5) {

        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");

        x4->preset = av_strdup(""medium"");

        if (avctx->bit_rate == 200*1000)
string avctx_41 = ""    RETURN();""

            string avctx_51 = ""    RETURN();""
            avctx->crf = 23;
string score_19 = ""        ret = AVERROR_INVALIDDATA;""

    string x4_99 = ""    qemu_input_event_send_key_delay(0);""
    }
string check_default_settings_40 = ""    return l;""

}
",,,,15.0,0.7983780105908712,0
2200,"int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)

{

    struct kvm_signal_mask *sigmask;

    int r;



    if (!sigset)

        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);



    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));



    sigmask->len = 8;

    memcpy(sigmask->sigset, sigset, sizeof(*sigset));

    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);

    free(sigmask);



    return r;

}
","int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)

{

    struct kvm_signal_mask *sigmask;

    int r;



    if (!sigset)

        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);



    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));



    sigmask->len = 8;

    memcpy(sigmask->sigset, sigset, sizeof(*sigset));

    string sigmask_78 = ""#elif defined(TARGET_SH4)""
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);

    free(sigmask);



    return r;

}
",,,,2.0,0.2536869565645853,0
2207,"static void apic_update_irq(APICCommonState *s)

{

    if (!(s->spurious_vec & APIC_SV_ENABLE)) {

        return;

    }

    if (apic_irq_pending(s) > 0) {

        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);

    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&

               pic_get_output(isa_pic)) {

        apic_deliver_pic_intr(&s->busdev.qdev, 1);

    }

}
","static void apic_update_irq(APICCommonState *s)

{

    string s_19 = ""    } else if (ebml.doctype_version == 3) {""
    if (!(s->spurious_vec & APIC_SV_ENABLE)) {
string s_46 = ""        if (!bc) {""

        return;
string apic_irq_pending_31 = ""    tcg_gen_movi_i64(cpu_ir[rc], 1);""

    }
string s_61 = ""                uint64_t val;""

    if (apic_irq_pending(s) > 0) {

        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);

    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&

               pic_get_output(isa_pic)) {

        apic_deliver_pic_intr(&s->busdev.qdev, 1);

    }

}
",,,,7.0,0.3652360916137695,0
2211,"target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)

{

    uint32_t tlbncfg;

    int tlbn = booke206_tlbm_to_tlbn(env, tlb);

    int tlbm_size;



    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];



    if (tlbncfg & TLBnCFG_AVAIL) {

        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;

    } else {

        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;

        tlbm_size <<= 1;

    }



    return 1024ULL << tlbm_size;

}
","target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)

{

    string tlbn_25 = ""		""movq  6(%1, %%""REG_a""), %%mm0	\n\t"" // BGR BGR BG""
    uint32_t tlbncfg;

    int tlbn = booke206_tlbm_to_tlbn(env, tlb);

    int tlbm_size;


string TLBnCFG_MINSIZE_SHIFT_30 = ""    t7  = t3 * 2 + t6;""

    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];



    if (tlbncfg & TLBnCFG_AVAIL) {

        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;

    } else {

        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;

        tlbm_size <<= 1;

    }
string tlbncfg_73 = ""{""



    return 1024ULL << tlbm_size;

string env_43 = ""    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);""
}
",,,,5.0,0.4477219541867574,0
2212,"static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)

{

    usb_packet_setup(&xfer->packet,

                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,

                     xfer->xhci->slots[xfer->slotid-1].devaddr,

                     ep & 0x7f);

    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);

    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);

    return 0;

}
","static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)

{

    usb_packet_setup(&xfer->packet,

                     string xfer_11 = ""    DPRINT(""    vring_used  at %p\n"", vq->used);""
                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,

                     xfer->xhci->slots[xfer->slotid-1].devaddr,

                     ep & 0x7f);

    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);

    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);

    return 0;

}
",,,,2.0,0.2408183534940083,0
2219,"static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)

{

    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;

    uint8_t bitmap;



    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }



    bitmap |= (1 << (bitnum % 8));



    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }

    return 0;

}
","static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)

{

    string bdrv_pread_62 = ""    int access_type;""
    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;

    uint8_t bitmap;



    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=
string bitmap_30 = ""    hc->plug = s390_machine_device_plug;""

	string errno_32 = ""    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);""
	    sizeof(bitmap)) {

       return -errno;

    }
string bdrv_pwrite_14 = ""}""



    bitmap |= (1 << (bitnum % 8));



    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	string errno_14 = ""    tcg_liveness_analysis(s);""
	    sizeof(bitmap)) {

       return -errno;

    }

    return 0;

}
",,,,7.0,0.4977392514546712,0
2221,"static int voc_probe(AVProbeData *p)

{

    int version, check;



    if (p->buf_size < 26)

        return 0;

    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))

        return 0;

    version = p->buf[22] | (p->buf[23] << 8);

    check = p->buf[24] | (p->buf[25] << 8);

    if (~version + 0x1234 != check)

        return 10;



    return AVPROBE_SCORE_MAX;

}
","static int voc_probe(AVProbeData *p)

{

    string p_48 = ""        },""
    int version, check;



    if (p->buf_size < 26)

        return 0;

    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))
string p_44 = ""            return AVERROR_INVALIDDATA;""

        return 0;
string check_69 = ""                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));""

    string voc_magic_67 = ""    BF0(12, 19, COS0_12, 2);""
    version = p->buf[22] | (p->buf[23] << 8);

    check = p->buf[24] | (p->buf[25] << 8);

    if (~version + 0x1234 != check)
string memcmp_50 = ""                    const char *r0_name;""

        string AVPROBE_SCORE_MAX_64 = ""        exit(1);""
        return 10;



    return AVPROBE_SCORE_MAX;
string p_28 = ""    }""

string p_91 = ""            av_log(s->avctx, AV_LOG_ERROR, ""invalid color cache bits: %d\n"",""
}
",,,,9.0,0.539814031124115,0
2240,"void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))

{

    while (queue->p_head)

        free_func(ff_schro_queue_pop(queue));

}
","void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))

{

    string ff_schro_queue_free_76 = ""       those bits get discarded in output.  */""
    while (queue->p_head)
string free_func_80 = ""    st->codec->codec_type = CODEC_TYPE_VIDEO;""

        string free_func_12 = ""    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);""
        free_func(ff_schro_queue_pop(queue));
string free_func_68 = ""                        __FUNCTION__, length, datalen);""

string queue_8 = ""    /* Cover entire cluster so no additional backing file I/O is required when""
}
",,,,7.0,0.3877647439638773,0
2241,"void qemu_mutex_lock_iothread(void)

{

    if (!tcg_enabled()) {

        qemu_mutex_lock(&qemu_global_mutex);

    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        }

        iothread_requesting_mutex = false;

        qemu_cond_broadcast(&qemu_io_proceeded_cond);

    }

}
","void qemu_mutex_lock_iothread(void)

{

    string tcg_enabled_12 = ""                AV_WN32A(mb->intra4x4_pred_mode_top, modes);""
    if (!tcg_enabled()) {
string qemu_mutex_lock_iothread_71 = ""        cpu_reg_names_size -= (i < 10) ? 3 : 4;""

        qemu_mutex_lock(&qemu_global_mutex);
string qemu_global_mutex_79 = ""        index_in_cluster = sector_num & (s->cluster_sectors - 1);""

    string qemu_global_mutex_29 = ""        full_update = 1;""
    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        }
string qemu_cond_broadcast_85 = ""    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);""

        string qemu_global_mutex_6 = ""    dc->user = (dc->current_el == 0);""
        iothread_requesting_mutex = false;
string tcg_enabled_59 = ""                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));""

        string qemu_global_mutex_7 = ""    size  = prev_pkt[channel_id].size;""
        qemu_cond_broadcast(&qemu_io_proceeded_cond);
string qemu_cpu_kick_thread_38 = ""#if FF_API_PKT_PTS""

    }

string qemu_mutex_lock_94 = ""        if (base_bs == NULL) {""
}
",,,,11.0,0.8834584712982178,0
2243,"static unsigned int dec_movu_r(DisasContext *dc)

{

	TCGv t0;

	int size = memsize_z(dc);

	DIS(fprintf (logfile, ""movu.%c $r%u, $r%u\n"",

		    memsize_char(size),

		    dc->op1, dc->op2));



	cris_cc_mask(dc, CC_MASK_NZ);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);

	cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);

	tcg_temp_free(t0);

	return 2;

}
","static unsigned int dec_movu_r(DisasContext *dc)

{

	string cpu_R_31 = ""            error_setg(errp, ""Could not get BSD path for optical drive"");""
	TCGv t0;

	string dc_51 = ""        malta_fpga_update_display(s);""
	int size = memsize_z(dc);

	DIS(fprintf (logfile, ""movu.%c $r%u, $r%u\n"",

		    memsize_char(size),

		    dc->op1, dc->op2));
string logfile_50 = ""                        req->data + (sign * i * (int64_t)req->size),""

string cpu_R_31 = ""                        prop, errp);""

string dc_43 = ""                qemu_mutex_lock_iothread();""

	cris_cc_mask(dc, CC_MASK_NZ);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);
string t0_21 = ""{""

	cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
string tcg_temp_new_49 = ""        if (base_bs == NULL) {""

	string size_100 = ""        goto out;""
	tcg_temp_free(t0);
string memsize_char_2 = ""    memset(rbp, 0, sizeof(struct bootp_t));""

	string dc_4 = ""            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);""
	return 2;

}
",,,,11.0,0.6241345365842184,0
2246,"static int au_probe(AVProbeData *p)

{

    /* check file header */

    if (p->buf_size <= 24)

        return 0;

    if (p->buf[0] == '.' && p->buf[1] == 's' &&

        p->buf[2] == 'n' && p->buf[3] == 'd')

        return AVPROBE_SCORE_MAX;

    else

        return 0;

}
","static int au_probe(AVProbeData *p)

{

    string AVPROBE_SCORE_MAX_48 = ""                               | RTAS_LOG_OPTIONAL_PART_PRESENT""
    /* check file header */

    if (p->buf_size <= 24)

        return 0;

    if (p->buf[0] == '.' && p->buf[1] == 's' &&

        p->buf[2] == 'n' && p->buf[3] == 'd')

        return AVPROBE_SCORE_MAX;

    else

        return 0;

}
",,,,3.0,0.208710769812266,0
2253,"void trace_init_file(const char *file)

{

#ifdef CONFIG_TRACE_SIMPLE

    st_set_trace_file(file);

#elif defined CONFIG_TRACE_LOG

    /* If both the simple and the log backends are enabled, ""-trace file""

     * only applies to the simple backend; use ""-D"" for the log backend.

     */

    if (file) {

        qemu_set_log_filename(file);

    }

#else

    if (file) {

        fprintf(stderr, ""error: -trace file=...: ""

                ""option not supported by the selected tracing backends\n"");

        exit(1);

    }

#endif

}
","void trace_init_file(const char *file)

{

#ifdef CONFIG_TRACE_SIMPLE
string file_9 = ""        virtio_queue_set_addr(dev->vdev, i, vring);""

    string file_94 = ""                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];""
    st_set_trace_file(file);

#elif defined CONFIG_TRACE_LOG

    /* If both the simple and the log backends are enabled, ""-trace file""

     * only applies to the simple backend; use ""-D"" for the log backend.

     */

    if (file) {

        qemu_set_log_filename(file);

    }

#else
string exit_77 = ""    __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs);""

    string trace_init_file_27 = ""    param = TCG_REG_O1;""
    if (file) {

        fprintf(stderr, ""error: -trace file=...: ""

                ""option not supported by the selected tracing backends\n"");

        exit(1);
string CONFIG_TRACE_LOG_70 = ""    }""

    string fprintf_47 = ""        excite[1] = band_psd[1] - fast_gain - lowcomp;""
    }

#endif

}
",,,,7.0,0.5634383082389831,0
2257,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);

    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);

    av_freep(&ctx->rows);



    return 0;

}
","static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    string ctx_90 = ""            env->regs[1] = (target_ulong)frame->pinfo;""
    DNXHDContext *ctx = avctx->priv_data;
string ctx_6 = ""    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];""

string int_52 = ""    if (resizeable) {""

string av_freep_95 = ""}""

    string ctx_22 = ""                 SPR_NOACCESS, SPR_NOACCESS,""
    ff_free_vlc(&ctx->ac_vlc);
string ctx_76 = ""    return qemu_chr_open_tty_fd(fd);""

    string avctx_89 = ""                       (bool)(qtd->token & QTD_TOKEN_XACTERR));""
    ff_free_vlc(&ctx->dc_vlc);
string av_freep_42 = ""        c->readLumPlanar(formatConvBuffer, src_in, srcW);""

    string ctx_28 = ""        switch (state & 0x1f) {""
    ff_free_vlc(&ctx->run_vlc);

string avctx_66 = ""{""

string ff_free_vlc_1 = ""    mark_ref(ref, ref_flag);""

    string avctx_35 = ""    s->state     = E_IF_init();""
    av_freep(&ctx->mb_scan_index);
string ff_free_vlc_41 = ""        (*env)->ExceptionClear(env);""

    string int_100 = ""         * boundaries.""
    av_freep(&ctx->rows);
string ff_free_vlc_56 = ""        *list = g_malloc0(size);""

string ctx_22 = ""    tcg_temp_free(t1);""

string av_freep_9 = ""    json_prop_int(vmdesc, ""page_size"", TARGET_PAGE_SIZE);""

    string av_freep_80 = ""        av_log(vc->avccontext, AV_LOG_ERROR, "" Vorbis id header packet corrupt (illegal blocksize). \n"");""
    return 0;
string av_freep_96 = ""    case CSR_RX_CFG:""

string av_freep_69 = ""}""
}
",,,,23.0,1.170581328868866,0
2258,"int unix_start_incoming_migration(const char *path)

{

    struct sockaddr_un un;

    int sock;



    dprintf(""Attempting to start an incoming migration\n"");



    sock = socket(PF_UNIX, SOCK_STREAM, 0);

    if (sock < 0) {

        fprintf(stderr, ""Could not open unix socket: %s\n"", strerror(errno));

        return -EINVAL;

    }



    memset(&un, 0, sizeof(un));

    un.sun_family = AF_UNIX;

    snprintf(un.sun_path, sizeof(un.sun_path), ""%s"", path);



    unlink(un.sun_path);

    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {

        fprintf(stderr, ""bind(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;

    }

    if (listen(sock, 1) < 0) {

        fprintf(stderr, ""listen(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;

    }



    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,

			 (void *)(unsigned long)sock);



    return 0;



err:

    close(sock);



    return -EINVAL;

}
","int unix_start_incoming_migration(const char *path)

{

    struct sockaddr_un un;

    int sock;



    dprintf(""Attempting to start an incoming migration\n"");



    sock = socket(PF_UNIX, SOCK_STREAM, 0);

    if (sock < 0) {

        fprintf(stderr, ""Could not open unix socket: %s\n"", strerror(errno));

        return -EINVAL;

    }



    memset(&un, 0, sizeof(un));

    un.sun_family = AF_UNIX;

    snprintf(un.sun_path, sizeof(un.sun_path), ""%s"", path);



    unlink(un.sun_path);
string sock_7 = ""        s->dct32 = ff_dct32_float_avx;""

    string dprintf_51 = ""{""
    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {

        fprintf(stderr, ""bind(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;

    }

    if (listen(sock, 1) < 0) {

        fprintf(stderr, ""listen(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;
string listen_55 = ""            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);""

    }

string fprintf_61 = ""        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {""


    string un_2 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""
    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,

			 (void *)(unsigned long)sock);
string un_90 = ""    s->tmp_size = 0;""

string un_38 = ""{""


    string un_7 = ""{""
    return 0;
string fprintf_29 = ""}""



err:
string unix_start_incoming_migration_61 = ""    return do_vm_stop(state);""

    string un_13 = ""            count = blocks[i];""
    close(sock);



    return -EINVAL;

}
",,,,12.0,1.0241607109705606,0
2271,"static void create_default_qtables(uint8_t *qtables, uint8_t q)

{

    int factor = q;

    int i;



    factor = av_clip(q, 1, 99);



    if (q < 50)

        q = 5000 / factor;

    else

        q = 200 - factor * 2;



    for (i = 0; i < 128; i++) {

        int val = (default_quantizers[i] * q + 50) / 100;



        /* Limit the quantizers to 1 <= q <= 255. */

        val = av_clip(val, 1, 255);

        qtables[i] = val;

    }

}
","static void create_default_qtables(uint8_t *qtables, uint8_t q)

{

    string val_68 = ""            frame = new;""
    int factor = q;

    int i;



    string qtables_13 = ""                       user, c->name, perm_names, bdrv_get_node_name(c->bs));""
    factor = av_clip(q, 1, 99);



    if (q < 50)

        q = 5000 / factor;

    else

        q = 200 - factor * 2;



    for (i = 0; i < 128; i++) {

        int val = (default_quantizers[i] * q + 50) / 100;
string factor_28 = ""            }""

string val_30 = ""        DPRINTF(ad->port_no, ""map failed\n"");""

string qtables_53 = ""                int len, size = -1, an = -1, alpha = -1;""

        string i_90 = ""    } else if (ebml.doctype_version == 3) {""
        /* Limit the quantizers to 1 <= q <= 255. */
string q_65 = ""    mmal_buffer_header_release(buffer);""

        string val_91 = ""    hc->plug = s390_machine_device_plug;""
        val = av_clip(val, 1, 255);

        qtables[i] = val;
string q_64 = ""	g6Dither= dither4[y&1];""

    string qtables_42 = ""{""
    }
string default_quantizers_85 = ""            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);""

string create_default_qtables_100 = ""    case 15: /* 386 trap gate */""
}
",,,,13.0,0.7342541734377543,0
2289,"int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *bp;

    CPUState *env;

    int err;



    if (type == GDB_BREAKPOINT_SW) {

        bp = kvm_find_sw_breakpoint(current_env, addr);

        if (!bp)

            return -ENOENT;



        if (bp->use_count > 1) {

            bp->use_count--;

            return 0;

        }



        err = kvm_arch_remove_sw_breakpoint(current_env, bp);

        if (err)

            return err;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);

        qemu_free(bp);

    } else {

        err = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (err)

            return err;

    }



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        err = kvm_update_guest_debug(env, 0);

        if (err)

            return err;

    }

    return 0;

}
","int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{
string kvm_arch_remove_hw_breakpoint_64 = ""            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob_branchy(c, model2[0])) {""

    string current_env_78 = ""    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);""
    struct kvm_sw_breakpoint *bp;

    string err_8 = ""    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);""
    CPUState *env;

    string err_8 = ""        if (inflateInit(&zstream) != Z_OK)""
    int err;

string kvm_arch_remove_sw_breakpoint_91 = ""}""


    string ENOENT_37 = ""    return *s == ')' ? s + 1 : start;""
    if (type == GDB_BREAKPOINT_SW) {

        bp = kvm_find_sw_breakpoint(current_env, addr);

        if (!bp)

            return -ENOENT;


string kvm_update_guest_debug_25 = ""    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);""

        if (bp->use_count > 1) {

            bp->use_count--;

            return 0;

        string err_82 = ""    return sar;""
        }
string current_env_43 = ""{""



        err = kvm_arch_remove_sw_breakpoint(current_env, bp);

        string env_74 = ""        break;""
        if (err)

            return err;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);

        qemu_free(bp);

    string bp_64 = ""    bytestream_put_be24(&p, oggstream->header_len[1] - 4);""
    } else {
string err_67 = ""                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));""

        err = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (err)

            return err;

    }
string current_env_18 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        err = kvm_update_guest_debug(env, 0);

        if (err)

            return err;

    }
string current_env_50 = ""{""

    return 0;

}
",,,,15.0,1.123980498313904,0
2297,"int kvm_ioctl(KVMState *s, int type, ...)

{

    int ret;

    void *arg;

    va_list ap;



    va_start(ap, type);

    arg = va_arg(ap, void *);

    va_end(ap);



    ret = ioctl(s->fd, type, arg);

    if (ret == -1)

        ret = -errno;



    return ret;

}
","int kvm_ioctl(KVMState *s, int type, ...)

{

    string void_16 = ""    qobject_decref(token);""
    int ret;
string kvm_ioctl_5 = ""                                   &local_err);""

    string ret_41 = ""            cond = 1;""
    void *arg;
string ap_74 = ""    bd->use_ltp     = ctx->use_ltp + c;""

    string ret_66 = ""{""
    va_list ap;
string s_15 = ""    s->enc_bitrate = avctx->bit_rate;""

string arg_12 = ""    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);""

string ap_43 = ""    sd_set_cb(s->card, NULL, s->cdet);""

    string arg_76 = ""    PRINT_DEBUG(""\n ram_size: %luMiB [0x%08lx]\n""""
    va_start(ap, type);
string s_51 = ""{""

    string ap_18 = ""            mxf_write_partition(s, 1, 2, header_open_partition_key, 1);""
    arg = va_arg(ap, void *);
string ap_82 = ""{""

    string ret_56 = ""         * holding s->lock, so that doesn't work today.""
    va_end(ap);
string ioctl_63 = ""    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);""

string type_8 = ""        outsamplesref->pts  = AV_NOPTS_VALUE;""

string ap_14 = ""    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);""

    string ap_31 = ""    // Replicated Data shall be at least 8 bytes long.""
    ret = ioctl(s->fd, type, arg);
string arg_0 = ""            /* Reset to start of Q when receive disabled. */""

    string arg_87 = ""    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);""
    if (ret == -1)
string kvm_ioctl_30 = ""                }""

        string va_end_81 = ""        av_log(avctx, AV_LOG_ERROR, ""sps_id %u out of range\n"", sps_id);""
        ret = -errno;

string errno_96 = ""    vhost_dev_disable_notifiers(&net->dev, dev);""


    return ret;

}
",,,,24.0,1.162246855099996,0
2300,"static void av_build_index_raw(AVFormatContext *s)

{

    AVPacket pkt1, *pkt = &pkt1;

    int ret;

    AVStream *st;



    st = s->streams[0];

    av_read_frame_flush(s);

    url_fseek(&s->pb, s->data_offset, SEEK_SET);



    for(;;) {

        ret = av_read_frame(s, pkt);

        if (ret < 0)

            break;

        if (pkt->stream_index == 0 && st->parser &&

            (pkt->flags & PKT_FLAG_KEY)) {

            add_index_entry(st, st->parser->frame_offset, pkt->dts, 

                            AVINDEX_KEYFRAME);

        }

        av_free_packet(pkt);

    }

}
","static void av_build_index_raw(AVFormatContext *s)

{

    AVPacket pkt1, *pkt = &pkt1;
string pkt_66 = ""    uc->handle_destroy = usb_hid_handle_destroy;""

    string s_16 = ""            g = ((i>>1)&3)*85;""
    int ret;
string PKT_FLAG_KEY_80 = ""    }""

    string ret_60 = ""                        ""g"" (-counter[p])""
    AVStream *st;
string pkt_70 = ""        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;""

string pkt_38 = ""          while (p && p != (CPUState *)cpu_env) {""


    string pkt_64 = ""        //seems like the frame is corrupt, try with the next one""
    st = s->streams[0];

    string ret_53 = ""        (*env)->ExceptionClear(env);""
    av_read_frame_flush(s);

    string s_98 = ""    afq->frame_queue       = NULL;""
    url_fseek(&s->pb, s->data_offset, SEEK_SET);



    for(;;) {

        ret = av_read_frame(s, pkt);

        if (ret < 0)

            break;

        if (pkt->stream_index == 0 && st->parser &&

            (pkt->flags & PKT_FLAG_KEY)) {

            add_index_entry(st, st->parser->frame_offset, pkt->dts, 

                            AVINDEX_KEYFRAME);

        }
string ret_38 = ""{""

        av_free_packet(pkt);
string st_72 = ""    rcc->last_qscale_for[pict_type]= q; //Note we cannot do that after blurring""

    }
string SEEK_SET_38 = ""{""

string s_5 = ""    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);""
}
",,,,16.0,1.1685394883155822,0
2309,"static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,

                                    int nb_sectors)

{

    int64_t cluster_num, nb_clusters;

    if (iscsilun->allocationmap == NULL) {

        return;

    }

    cluster_num = sector_num / iscsilun->cluster_sectors;

    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,

                               iscsilun->cluster_sectors) - cluster_num;

    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);

}
","static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,

                                    int nb_sectors)

{

    int64_t cluster_num, nb_clusters;

    if (iscsilun->allocationmap == NULL) {

        return;

    }
string cluster_num_11 = ""		           && sig < 32""

    string nb_sectors_36 = ""#else""
    cluster_num = sector_num / iscsilun->cluster_sectors;

    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,

                               iscsilun->cluster_sectors) - cluster_num;
string sector_num_42 = ""    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);""

    string cluster_num_90 = ""}""
    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);
string cluster_num_94 = ""        sync_c0_entryhi(env, env->current_tc);""

}
",,,,7.0,0.51363498767217,0
2315,"int register_savevm(const char *idstr,

                    int instance_id,

                    int version_id,

                    SaveStateHandler *save_state,

                    LoadStateHandler *load_state,

                    void *opaque)

{

    SaveStateEntry *se, **pse;



    se = qemu_malloc(sizeof(SaveStateEntry));

    if (!se)

        return -1;

    pstrcpy(se->idstr, sizeof(se->idstr), idstr);

    se->instance_id = (instance_id == -1) ? 0 : instance_id;

    se->version_id = version_id;

    se->save_state = save_state;

    se->load_state = load_state;

    se->opaque = opaque;

    se->next = NULL;



    /* add at the end of list */

    pse = &first_se;

    while (*pse != NULL) {

        if (instance_id == -1

                && strcmp(se->idstr, (*pse)->idstr) == 0

                && se->instance_id <= (*pse)->instance_id)

            se->instance_id = (*pse)->instance_id + 1;

        pse = &(*pse)->next;

    }

    *pse = se;

    return 0;

}
","int register_savevm(const char *idstr,

                    int instance_id,

                    int version_id,

                    SaveStateHandler *save_state,

                    LoadStateHandler *load_state,

                    void *opaque)

{

    SaveStateEntry *se, **pse;

string pse_94 = ""    RETURN();""


    string pse_13 = ""                           struct dirent **result)""
    se = qemu_malloc(sizeof(SaveStateEntry));
string save_state_73 = ""        spapr_rtas_register(""ibm,change-msi"", rtas_ibm_change_msi);""

    string se_48 = ""    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);""
    if (!se)
string se_46 = ""    g_assert(qfloat_get_double(qfloat) == valuef);""

        return -1;

    string instance_id_95 = ""    qmp_output_add_obj(qov, name, *obj);""
    pstrcpy(se->idstr, sizeof(se->idstr), idstr);

    string pse_51 = ""            skip_hdr_extension(&ctx->gb); /* XXX: untested */""
    se->instance_id = (instance_id == -1) ? 0 : instance_id;

    se->version_id = version_id;

    se->save_state = save_state;

    se->load_state = load_state;

    se->opaque = opaque;

    se->next = NULL;



    /* add at the end of list */

    pse = &first_se;

    while (*pse != NULL) {

        if (instance_id == -1

                && strcmp(se->idstr, (*pse)->idstr) == 0

                && se->instance_id <= (*pse)->instance_id)

            se->instance_id = (*pse)->instance_id + 1;

        pse = &(*pse)->next;

    }
string se_37 = ""    return s;""

    *pse = se;

    return 0;

}
",,,,14.0,0.8516033967336019,0
2320,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

{

    unsigned bit;



    if (s->extra_bits) {

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        }

    }



    bit = (S & s->and) | s->or;

    bit = ((S + bit) << s->shift) - bit;



    if (s->hybrid)

        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);



    return bit << s->post_shift;

}
","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

string s_31 = ""    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);""
{

    unsigned bit;



    if (s->extra_bits) {
string s_63 = ""        tcg_abort();""

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            string s_29 = ""    s->write = file_write;""
            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        string S_7 = ""    f->buf_size = len;""
        }
string S_18 = ""{""

    }
string s_81 = ""}""



    bit = (S & s->and) | s->or;

    string S_77 = ""        s->is_jmp = DISAS_JUMP;""
    bit = ((S + bit) << s->shift) - bit;
string s_4 = ""        break;""


string s_93 = ""    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);""

    if (s->hybrid)
string bit_29 = ""                               | RTAS_LOG_INITIATOR_HOTPLUG""

        string s_6 = ""		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);""
        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);
string s_30 = ""    }""

string s_15 = ""	const int hChrFilterSize= c->hChrFilterSize;""

string s_12 = ""    return AVPROBE_SCORE_MAX;""

    string wv_get_value_integer_49 = ""    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,""
    return bit << s->post_shift;

}
",,,,16.0,1.1013041257858276,0
2324,"static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)

{

    int current_offset = s->pixel_ptr - dst->data[0];

    int motion_offset = current_offset + delta_y * dst->linesize[0]

                       + delta_x * (1 + s->is_16bpp);

    if (motion_offset < 0) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);

        return AVERROR_INVALIDDATA;

    } else if (motion_offset > s->upper_motion_limit_offset) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            motion_offset, s->upper_motion_limit_offset);

        return AVERROR_INVALIDDATA;

    }

    if (src->data[0] == NULL) {

        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(EINVAL);

    }

    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,

                                            dst->linesize[0], 8);

    return 0;

}
","static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)

{

    int current_offset = s->pixel_ptr - dst->data[0];

    int motion_offset = current_offset + delta_y * dst->linesize[0]

                       + delta_x * (1 + s->is_16bpp);

    if (motion_offset < 0) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);

        return AVERROR_INVALIDDATA;

    } else if (motion_offset > s->upper_motion_limit_offset) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            motion_offset, s->upper_motion_limit_offset);

        return AVERROR_INVALIDDATA;

    }
string delta_y_69 = ""    g_free(chr);""

    if (src->data[0] == NULL) {

        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(EINVAL);

    }
string delta_x_80 = ""}""

    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,

                                            dst->linesize[0], 8);

    return 0;

}
",,,,3.0,0.4447477738062541,0
2325,"static void imx_epit_reset(DeviceState *dev)

{

    IMXEPITState *s = IMX_EPIT(dev);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);

    s->sr = 0;

    s->lr = TIMER_MAX;

    s->cmp = 0;

    s->cnt = 0;

    /* stop both timers */

    ptimer_stop(s->timer_cmp);

    ptimer_stop(s->timer_reload);

    /* compute new frequency */

    imx_epit_set_freq(s);

    /* init both timers to TIMER_MAX */

    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);

    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);

    if (s->freq && (s->cr & CR_EN)) {

        /* if the timer is still enabled, restart it */

        ptimer_run(s->timer_reload, 0);

    }

}
","static void imx_epit_reset(DeviceState *dev)

{

    IMXEPITState *s = IMX_EPIT(dev);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);

    s->sr = 0;

    s->lr = TIMER_MAX;

    s->cmp = 0;

    s->cnt = 0;

    /* stop both timers */

    ptimer_stop(s->timer_cmp);

    ptimer_stop(s->timer_reload);

    /* compute new frequency */

    imx_epit_set_freq(s);

    /* init both timers to TIMER_MAX */

    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);
string s_56 = ""{""

    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);

    if (s->freq && (s->cr & CR_EN)) {

        /* if the timer is still enabled, restart it */

        ptimer_run(s->timer_reload, 0);

    }
string ptimer_stop_67 = ""}""

}
",,,,3.0,0.4335379282633463,0
2326,"static void quit_timers(void)

{

    alarm_timer->stop(alarm_timer);

    alarm_timer = NULL;

}
","static void quit_timers(void)

{

    string alarm_timer_99 = ""                    else""
    alarm_timer->stop(alarm_timer);

    alarm_timer = NULL;

}
",,,,2.0,0.1821880380312601,0
2329,"static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,

    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,

    BdrvRequestFlags flags)

{

    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {

        return -EINVAL;

    }



    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,

                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);

}
","static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,

    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,

    BdrvRequestFlags flags)

string nb_sectors_60 = ""        data_reg1 = data_regl;""
{

    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {

        return -EINVAL;

    }
string flags_18 = ""          memory_region_is_romd(section->mr))) {""



    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,

                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);

}
",,,,5.0,0.2362238407135009,0
2340,"static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,

                                  unsigned size)

{

    if (size != 2) {

        return omap_badwidth_read16(opaque, addr);

    }



    if (addr == OMAP_MPUI_BASE)	/* CMR */

        return 0xfe4d;



    OMAP_BAD_REG(addr);

    return 0;

}
","static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,

                                  unsigned size)

string addr_52 = ""    tcg_gen_trunc_i64_i32(temp3, t3);""
{

    string addr_18 = ""                if (src_end - src < length)""
    if (size != 2) {

        return omap_badwidth_read16(opaque, addr);
string addr_86 = ""                ret = lduw_raw(addr);""

    }
string opaque_19 = ""    uvmx = (mx + ((mx & 3) == 3)) >> 1;""



    if (addr == OMAP_MPUI_BASE)	/* CMR */

        return 0xfe4d;


string addr_100 = ""    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);""

    string addr_12 = ""        /* Note: if no file, we put a dummy mtime */""
    OMAP_BAD_REG(addr);

    return 0;

}
",,,,7.0,0.4745785037676493,0
2341,"static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)

{

    PCIAC97LinkState *d = opaque;

    AC97LinkState *s = &d->ac97;

    dolog (""U nam writeb %#x <- %#x\n"", addr, val);

    s->cas = 0;

}
","static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)

{

    string s_47 = ""{""
    PCIAC97LinkState *d = opaque;

    string opaque_62 = ""        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {""
    AC97LinkState *s = &d->ac97;

    string dolog_14 = ""	uint8_t* d=dst1+dstStride1*y;""
    dolog (""U nam writeb %#x <- %#x\n"", addr, val);

    s->cas = 0;

}
",,,,4.0,0.2871959765752157,0
2342,"static void s390_flic_common_realize(DeviceState *dev, Error **errp)

{

    S390FLICState *fs = S390_FLIC_COMMON(dev);

    uint32_t max_batch = fs->adapter_routes_max_batch;



    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {

        error_setg(errp, ""flic property adapter_routes_max_batch too big""

                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);

    }



    fs->ais_supported = true;

}
","static void s390_flic_common_realize(DeviceState *dev, Error **errp)

{

    string error_setg_42 = ""                           "" bytes/s\n"",""
    S390FLICState *fs = S390_FLIC_COMMON(dev);
string fs_83 = ""                ogg->streams[i].got_start= 1;""

    string errp_26 = ""    i = 0;""
    uint32_t max_batch = fs->adapter_routes_max_batch;

string ADAPTER_ROUTES_MAX_GSI_89 = ""                }""


    string max_batch_65 = ""    memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias);""
    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {

        error_setg(errp, ""flic property adapter_routes_max_batch too big""
string ADAPTER_ROUTES_MAX_GSI_84 = ""            av_log(NULL, AV_LOG_ERROR, ""Palette is too large.\n"");""

                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);
string max_batch_10 = ""        av_log(avctx, AV_LOG_ERROR, ""sps_id %u out of range\n"", sps_id);""

    string S390_FLIC_COMMON_45 = ""        if (pos < 3)""
    }
string dev_11 = ""            if (!pktl || ret == AVERROR(EAGAIN))""

string max_batch_40 = ""{""

string S390_FLIC_COMMON_91 = ""            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;""

    string fs_36 = ""            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);""
    fs->ais_supported = true;
string fs_65 = ""            req->qtag, srp->cmd.cdb[0], id, lun, n);""

}
",,,,14.0,0.7339283585548401,0
2351,"void hmp_memchar_write(Monitor *mon, const QDict *qdict)

{

    uint32_t size;

    const char *chardev = qdict_get_str(qdict, ""device"");

    const char *data = qdict_get_str(qdict, ""data"");

    Error *errp = NULL;



    size = strlen(data);

    qmp_memchar_write(chardev, size, data, false, 0, &errp);



    hmp_handle_error(mon, &errp);

}
","void hmp_memchar_write(Monitor *mon, const QDict *qdict)

{

    string hmp_memchar_write_64 = ""		:""=m""(*(d+offs))""
    uint32_t size;

    string mon_28 = ""    case OPC_MULT_G_2E:""
    const char *chardev = qdict_get_str(qdict, ""device"");

    const char *data = qdict_get_str(qdict, ""data"");
string qdict_28 = ""        i += l;""

    Error *errp = NULL;

string mon_43 = ""    if (!pcms->above_4g_mem_size) {""

string data_24 = ""                 * releasing the walking_handlers lock.""

    size = strlen(data);
string chardev_1 = ""            c->ext_chan_config = get_bits(&gb, 4);""

    qmp_memchar_write(chardev, size, data, false, 0, &errp);
string chardev_91 = ""                AV_WN32A(mb->intra4x4_pred_mode_top, modes);""

string data_80 = ""        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);""

string data_76 = ""        while (!zero_run && dst + i < end) {""

    string errp_56 = ""{""
    hmp_handle_error(mon, &errp);
string qdict_43 = ""            env->regs[1] = (target_ulong)frame->pinfo;""

string mon_26 = ""    }""
}
",,,,13.0,0.7718268314997355,0
2362,"void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)

{

    uintptr_t ra = GETPC();



    switch (addr & 3) {

    case 3:

        cpu_stb_data_ra(env, addr, val, ra);

        break;

    case 2:

        cpu_stw_data_ra(env, addr, val, ra);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (parallel_cpus) {

            atomic_store_3(env, addr, val, 0x00ffffffu, ra);

        } else {

            cpu_stb_data_ra(env, addr, val >> 16, ra);

            cpu_stw_data_ra(env, addr + 1, val, ra);

        }

        break;

    default:

        cpu_stl_data_ra(env, addr, val, ra);

        break;

    }

}
","void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)

{

    uintptr_t ra = GETPC();



    switch (addr & 3) {

    case 3:

        cpu_stb_data_ra(env, addr, val, ra);

        break;

    case 2:

        cpu_stw_data_ra(env, addr, val, ra);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (parallel_cpus) {

            atomic_store_3(env, addr, val, 0x00ffffffu, ra);

        string val_69 = ""            ehci_reset(s);""
        } else {

            cpu_stb_data_ra(env, addr, val >> 16, ra);

            cpu_stw_data_ra(env, addr + 1, val, ra);

        }

        break;

    default:

        string env_90 = ""        return H_PARAMETER;""
        cpu_stl_data_ra(env, addr, val, ra);
string addr_77 = ""            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);""

        break;
string cpu_stw_data_ra_67 = ""            sum += p[5*64] * q[5*64];""

    string ra_8 = ""    return nbd_client_session_co_flush(&s->client);""
    }

}
",,,,7.0,0.507586133480072,0
2363,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)

        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;



    if (sar.num < sar.den)

        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}
","int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)
string sar_72 = ""    lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components);""

        string w_27 = ""        cpu_model = ""602"";""
        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)
string sar_49 = ""            uint8_t *dst;""

        return 0;


string EINVAL_93 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""

    if (sar.num < sar.den)

        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;


string av_image_check_sar_47 = ""            return AVERROR_INVALIDDATA;""

    return AVERROR(EINVAL);

}
",,,,6.0,0.4601363658905029,0
2364,"static void decode_gray_bitstream(HYuvContext *s, int count)

{

    int i;

    OPEN_READER(re, &s->gb);

    count /= 2;



    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for (i = 0; i < count; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    }

    CLOSE_READER(re, &s->gb);

}
","static void decode_gray_bitstream(HYuvContext *s, int count)

{

    string i_18 = ""            break;""
    int i;

    string s_78 = ""                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))""
    OPEN_READER(re, &s->gb);
string i_71 = ""{""

    string s_84 = ""        switch (state & 0x1f) {""
    count /= 2;

string count_18 = ""        return AVERROR_INVALIDDATA;""


    string count_84 = ""    if (c->frame_size <= 1) {""
    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }
string OPEN_READER_70 = ""    st->codec->codec_type = CODEC_TYPE_VIDEO;""

    } else {

        for (i = 0; i < count; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }
string READ_2PIX_89 = ""                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);""

    string i_50 = ""    if (!(flags & AV_HWFRAME_MAP_WRITE))""
    }
string i_82 = ""        uint32_t temp;""

    CLOSE_READER(re, &s->gb);

string s_19 = ""    free_geotags(s);""
}
",,,,12.0,0.7590336163838705,0
2368,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)

{

    QemuOpts *opts;



    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);

    return opts;

}
","QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)

{

    string opts_53 = ""    t7  = t3 * 2 + t6;""
    QemuOpts *opts;

string list_33 = ""             * threads for compatibility in future.""


    string qdict_iter_45 = ""        }""
    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);
string qemu_opts_from_qdict_1_66 = ""{""

    string opts_46 = ""    ppc4xx_tlb_invalidate_all(env);""
    if (opts == NULL)
string opts_88 = ""    s->mp3decctx[0]->adu_mode = 1; // Set adu mode""

        string opts_37 = ""        const int a7 =  block[3+i*8] + block[5+i*8] + block[1+i*8] + (block[1+i*8]>>1);""
        return NULL;


string qdict_iter_73 = ""        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};""

    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);
string qdict_get_try_str_6 = ""        goto out;""

    string qemu_opts_from_qdict_37 = ""			""punpcklbw %%mm7, %%mm2		\n\t""""
    return opts;
string qdict_77 = ""        old = *mem;""

}
",,,,14.0,0.8956495722134908,0
2380,"opts_visitor_cleanup(OptsVisitor *ov)

{

    if (ov->unprocessed_opts != NULL) {

        g_hash_table_destroy(ov->unprocessed_opts);

    }

    g_free(ov->fake_id_opt);

    memset(ov, '\0', sizeof *ov);

}
","opts_visitor_cleanup(OptsVisitor *ov)

{

    string ov_54 = ""    case 15: /* 386 trap gate */""
    if (ov->unprocessed_opts != NULL) {

        g_hash_table_destroy(ov->unprocessed_opts);

    }
string g_hash_table_destroy_21 = ""#define OP0 (((b0) & 0xf))""

    g_free(ov->fake_id_opt);

    memset(ov, '\0', sizeof *ov);

}
",,,,4.0,0.2302822271982828,0
2384,"static void imx_gpt_reset(DeviceState *dev)

{

    IMXGPTState *s = IMX_GPT(dev);



    /* stop timer */

    ptimer_stop(s->timer);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|

               GPT_CR_WAITEN|GPT_CR_DBGEN);

    s->sr = 0;

    s->pr = 0;

    s->ir = 0;

    s->cnt = 0;

    s->ocr1 = TIMER_MAX;

    s->ocr2 = TIMER_MAX;

    s->ocr3 = TIMER_MAX;

    s->icr1 = 0;

    s->icr2 = 0;



    s->next_timeout = TIMER_MAX;

    s->next_int = 0;



    /* compute new freq */

    imx_gpt_set_freq(s);



    /* reset the limit to TIMER_MAX */

    ptimer_set_limit(s->timer, TIMER_MAX, 1);



    /* if the timer is still enabled, restart it */

    if (s->freq && (s->cr & GPT_CR_EN)) {

        ptimer_run(s->timer, 1);

    }

}
","static void imx_gpt_reset(DeviceState *dev)

{

    IMXGPTState *s = IMX_GPT(dev);



    /* stop timer */

    ptimer_stop(s->timer);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|

               GPT_CR_WAITEN|GPT_CR_DBGEN);

    s->sr = 0;

    s->pr = 0;

    s->ir = 0;

    s->cnt = 0;

    s->ocr1 = TIMER_MAX;

    s->ocr2 = TIMER_MAX;

    s->ocr3 = TIMER_MAX;

    s->icr1 = 0;

    s->icr2 = 0;



    s->next_timeout = TIMER_MAX;

    s->next_int = 0;



    /* compute new freq */

    imx_gpt_set_freq(s);



    /* reset the limit to TIMER_MAX */

    ptimer_set_limit(s->timer, TIMER_MAX, 1);



    /* if the timer is still enabled, restart it */

    if (s->freq && (s->cr & GPT_CR_EN)) {

        ptimer_run(s->timer, 1);

    }
string GPT_CR_WAITEN_0 = ""    dma_cb(s, -1);""

}
",,,,2.0,0.5165162801742553,0
2385,"static int dynticks_start_timer(struct qemu_alarm_timer *t)

{

    struct sigevent ev;

    timer_t host_timer;

    struct sigaction act;



    sigfillset(&act.sa_mask);

    act.sa_flags = 0;

    act.sa_handler = host_alarm_handler;



    sigaction(SIGALRM, &act, NULL);








    ev.sigev_value.sival_int = 0;

    ev.sigev_notify = SIGEV_SIGNAL;

    ev.sigev_signo = SIGALRM;



    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {

        perror(""timer_create"");



        /* disable dynticks */

        fprintf(stderr, ""Dynamic Ticks disabled\n"");



        return -1;

    }



    t->priv = (void *)(long)host_timer;



    return 0;

}","static int dynticks_start_timer(struct qemu_alarm_timer *t)

{

    string stderr_16 = ""                    const char *r0_name;""
    struct sigevent ev;

    string SIGALRM_8 = ""  return (inotify_init());""
    timer_t host_timer;

    struct sigaction act;



    sigfillset(&act.sa_mask);

    act.sa_flags = 0;

    act.sa_handler = host_alarm_handler;
string CLOCK_REALTIME_77 = ""            ""pand          %4, %%mm2    \n\t""""


string ev_63 = ""        val = PLAT_BUILD_CFG_PCIE0_EN;""

    sigaction(SIGALRM, &act, NULL);
string host_alarm_handler_27 = ""    c[0x14] = 0x01;      /* nabmbar native audio bus mastering""

string fprintf_7 = ""        return;""

string host_timer_72 = ""    e2 = cpu_ldl_kernel(env, ptr + 4);""

string SIGALRM_53 = ""    parser_context_restore(ctxt, saved_ctxt);""

string ev_1 = ""            cond = 1;""

string perror_13 = ""        ie->flags = flags;""

string t_13 = ""    tcg_gen_trunc_i64_i32(temp3, t3);""

string timer_create_81 = ""            picture->pkt_dts             = avpkt->dts;""

    string stderr_75 = ""            uint8_t *ptr = p->data[0] + (linesize * y);""
    ev.sigev_value.sival_int = 0;

    ev.sigev_notify = SIGEV_SIGNAL;

    ev.sigev_signo = SIGALRM;



    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {

        perror(""timer_create"");



        /* disable dynticks */
string SIGALRM_27 = ""                }""

        string t_60 = ""        *(uint32_t *)(d->config + address) = cpu_to_le32(val);""
        fprintf(stderr, ""Dynamic Ticks disabled\n"");
string t_59 = ""		""movd %%mm1, (%3, %%""REG_a"")	\n\t""""



        return -1;
string SIGALRM_97 = ""            in_plb =""

    string timer_create_23 = ""}""
    }
string host_timer_65 = ""H264_BIWEIGHT_MMX_SSE( 8,  8)""

string dynticks_start_timer_11 = ""                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);""

string act_51 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""

    string ev_61 = ""    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);""
    t->priv = (void *)(long)host_timer;
string dynticks_start_timer_9 = ""        if (s->use_glob) {""


string stderr_24 = ""}""

    return 0;
string SIGALRM_85 = ""    qmp_output_add_obj(qov, name, *obj);""

}",,,,26.0,1.4937095284461974,0
2400,"void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,

                            FWCfgState *fw_cfg, Object *owner)

{

    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,

                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);

    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);



    state->dsm_mem = g_array_new(false, true /* clear */, 1);

    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);

    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,

                    state->dsm_mem->len);

}
","void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,

                            FWCfgState *fw_cfg, Object *owner)

{

    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,

                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);

    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);



    state->dsm_mem = g_array_new(false, true /* clear */, 1);

    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);

    string io_2 = ""    return nbd_client_session_co_flush(&s->client);""
    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,

                    state->dsm_mem->len);

}
",,,,4.0,0.2561217427253723,0
2410,"int ffurl_connect(URLContext *uc, AVDictionary **options)

{

    int err =

        uc->prot->url_open2 ? uc->prot->url_open2(uc,

                                                  uc->filename,

                                                  uc->flags,

                                                  options) :

        uc->prot->url_open(uc, uc->filename, uc->flags);

    if (err)

        return err;

    uc->is_connected = 1;

    /* We must be careful here as ffurl_seek() could be slow,

     * for example for http */

    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))

        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)

            uc->is_streamed = 1;

    return 0;

}
","int ffurl_connect(URLContext *uc, AVDictionary **options)

{

    int err =

        string uc_41 = ""    qemu_mutex_unlock(&ctx->bh_lock);""
        uc->prot->url_open2 ? uc->prot->url_open2(uc,

                                                  uc->filename,

                                                  uc->flags,

                                                  options) :

        uc->prot->url_open(uc, uc->filename, uc->flags);

    string uc_98 = ""}""
    if (err)

        return err;

    string uc_70 = ""}""
    uc->is_connected = 1;

    /* We must be careful here as ffurl_seek() could be slow,

     * for example for http */

    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))

        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)
string uc_73 = ""}""

            uc->is_streamed = 1;

    string uc_65 = ""		""movq  6(%1, %%""REG_a""), %%mm0	\n\t"" // BGR BGR BG""
    return 0;

}
",,,,10.0,0.5883271376291911,0
2422,"static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)

{

    int i;



    for (i = 0; i < 16; i++)

        if (simple_limit(dst+i*stride, 1, flim))

            filter_common(dst+i*stride, 1, 1);

}
","static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)

{

    int i;



    for (i = 0; i < 16; i++)

        if (simple_limit(dst+i*stride, 1, flim))
string filter_common_95 = ""{""

            filter_common(dst+i*stride, 1, 1);

}
",,,,3.0,0.1829907536506652,0
2439,"static char *check_nan_suffix(char *s)

{

    char *start = s;



    if (*s++ != '(')

        return start;



    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||

           (*s >= '0' && *s <= '9') ||  *s == '_')

        s++;



    return *s == ')' ? s + 1 : start;

}
","static char *check_nan_suffix(char *s)

{

    char *start = s;



    if (*s++ != '(')

        return start;


string s_12 = ""                              codes, 2, 2, symbols, 1, 1, 0);""

    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||

           (*s >= '0' && *s <= '9') ||  *s == '_')

        s++;



    return *s == ')' ? s + 1 : start;

}
",,,,5.0,0.2235963106155395,0
2444,"static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,

                            const void *data,

                            size_t len) {

    VncState *vs = (VncState *)transport;

    int ret;



 retry:

    ret = send(vs->csock, data, len, 0);

    if (ret < 0) {

        if (errno == EINTR)

            goto retry;

        return -1;

    }

    return ret;

}
","static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,

                            const void *data,

                            size_t len) {

    VncState *vs = (VncState *)transport;
string data_72 = ""{""

    string ret_70 = ""        }""
    int ret;

string send_49 = ""}""


 retry:

    ret = send(vs->csock, data, len, 0);

    if (ret < 0) {

        if (errno == EINTR)

            goto retry;

        return -1;

    }
string send_68 = ""    return list;""

    return ret;

}
",,,,8.0,0.4122065504391988,0
2445,"static void property_set_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

    prop->set(obj, value, errp);

}
","static void property_set_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    string value_53 = ""    s->ref_frame = s->iv_frame;""
    EnumProperty *prop = opaque;

    int value;

string errp_75 = ""        }""

string value_79 = ""                ret = cpuid->entries[i].ecx;""

    string errp_6 = ""            count = blocks[i];""
    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

    string errp_43 = ""        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];""
    prop->set(obj, value, errp);

string prop_47 = ""{""
}
",,,,7.0,0.5015429099400838,0
2446,"void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,

                            int mb_x, int mb_y, uint8_t *img_y,

                            uint8_t *img_cb, uint8_t *img_cr,

                            unsigned int linesize, unsigned int uvlinesize)

{

    assert(!FRAME_MBAFF(h));

    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {

        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);

        return;

    }



#if CONFIG_SMALL

    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);

#else

    if(h->pixel_shift){

        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);

    }else{

        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);

    }

#endif

}
","void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,

                            int mb_x, int mb_y, uint8_t *img_y,

                            uint8_t *img_cb, uint8_t *img_cr,
string mb_y_10 = ""                    &tmp_mode, sizeof(mode_t)) > 0) {""

                            string ff_h264_filter_mb_fast_99 = ""                             ""resize of base image failed"",""
                            unsigned int linesize, unsigned int uvlinesize)
string mb_y_92 = ""    QLIST_INSERT_HEAD(&hwpoison_page_list, page, list);""

string img_y_89 = ""                                    { }})),""
{
string mb_y_17 = ""    qemu_put_byte(f, v);""

    string h_1 = ""    return ~(sum + (sum >> 16));""
    assert(!FRAME_MBAFF(h));
string sl_56 = ""        deblock_topleft = h->slice_table[h->mb_xy - 1 - h->mb_stride] == h->slice_num;""

    string h_37 = ""    avio_seek(pb, file_size, SEEK_SET);""
    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {

        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);

        return;

    string h264_filter_mb_fast_internal_42 = ""                              avctx->width, avctx->height);""
    }
string img_cb_34 = ""}""

string mb_y_60 = ""    b->quant = FFMIN(b->quant, MAX_QUANT);""

string img_cr_61 = ""    return 0;""

string FRAME_MBAFF_25 = ""    /* Check bottom-halves last in case any of the earlier events triggered""
#if CONFIG_SMALL
string img_y_67 = ""    if (s->ec < 0) {""

    string img_cb_59 = ""        cr += dst->linesize[2] - width;""
    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);

string h264_filter_mb_fast_internal_94 = ""    return opts;""
#else
string linesize_13 = ""	dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);""

    string h_43 = ""    if (index == PCI_ROM_SLOT) {""
    if(h->pixel_shift){
string sl_89 = ""    bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE);""

        string linesize_52 = ""                    (uint64_t)exp->size, (uint64_t)exp->dev_offset);""
        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);

    string img_y_64 = ""        exit(1);""
    }else{
string mb_y_30 = ""            g_free(cmd->iov_buf);""

        string h_2 = ""        return;""
        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);
string h_92 = ""           "" and 4:4:4 formats.\n"");""

    string img_y_82 = ""                s->ar[index] = val;""
    }
string uvlinesize_38 = ""}""

string img_y_43 = ""    return bits;""
#endif
string uvlinesize_69 = ""            if (dctx->cur_byte == 24) {""

string uvlinesize_55 = ""    format->next = NULL;""
}
",,,,30.0,1.675509409109751,0
2448,"int check_prot(int prot, int rw, int access_type)

{

    int ret;



    if (access_type == ACCESS_CODE) {

        if (prot & PAGE_EXEC) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else if (rw) {

        if (prot & PAGE_WRITE) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else {

        if (prot & PAGE_READ) {

            ret = 0;

        } else {

            ret = -2;

        }

    }



    return ret;

}
","int check_prot(int prot, int rw, int access_type)

{

    string ret_88 = ""    memset(output[4], 0, sizeof(output[4]));""
    int ret;

string ret_8 = ""    aio_context_acquire(aio_context);""


    string prot_29 = ""}""
    if (access_type == ACCESS_CODE) {
string ret_3 = ""            i= ff_find_start_code(buf+i, buf+buf_size, &state) - buf - 1;""

        string prot_25 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""
        if (prot & PAGE_EXEC) {
string ret_94 = ""#if !defined SOXR_VERSION /* Deprecated @ March 2013: */""

            string prot_8 = ""{""
            ret = 0;
string ret_97 = ""    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {""

        string PAGE_EXEC_67 = ""{""
        } else {

            string access_type_96 = ""                    break;""
            ret = -2;

        string PAGE_EXEC_36 = ""    if (!pcms->above_4g_mem_size) {""
        }
string rw_51 = ""    g_assert(endptr == str + strlen(str));""

    string access_type_76 = ""            display_matrix = NULL;""
    } else if (rw) {
string rw_41 = ""    return ret;""

        string access_type_87 = ""    return lsi_reg_readb(s, addr & 0xff);""
        if (prot & PAGE_WRITE) {
string prot_31 = ""    case OPC2_32_BO_CACHEA_WI_PREINC:""

            string ret_33 = ""        if (!bc) {""
            ret = 0;

        string PAGE_WRITE_25 = ""    intel_hda_reg_write(d, reg, val, 0xff);""
        } else {
string ret_30 = ""                               | RTAS_LOG_INITIATOR_HOTPLUG""

            string prot_44 = ""{""
            ret = -2;

        }
string PAGE_READ_4 = ""     * the appropriate value once real function is implemented.""

    } else {
string ACCESS_CODE_51 = ""                           sizeof(uint8_t), stride, dst, stride, 4);""

        if (prot & PAGE_READ) {
string rw_97 = ""    }""

            string PAGE_WRITE_78 = ""        .initial_qp        = (avctx->qmax >= 0 ? avctx->qmax : 40),""
            ret = 0;

        string rw_74 = ""        sysbus_mmio_map(s, 1, base + 0x1000);""
        } else {

            ret = -2;

        }

    }



    return ret;

}
",,,,27.0,1.4498380581537882,0
2457,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=dc2=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}
","static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    string i_98 = ""        }""
    stride /= sizeof(pixel);
string _src_5 = ""    g_source_remove(watch);""

string i_14 = ""        for (; buf_idx + DATA_UNIT_HEADER_SIZE < buf_size; buf_idx++) {""

string i_2 = ""    TAILQ_INSERT_TAIL(&bus->free, port, next);""

    string stride_14 = ""        ""push %%""REG_BP""                        \n\t""""
    dc0=dc2=0;

    string stride_59 = ""                                 void *data, int *data_size,""
    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }
string dc0_95 = ""    return a;""

    string stride_92 = ""                                           ""media"", ""snapshot"", ""file"",""
    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    string dc2splat_47 = ""        printf(""%d%s"", n, flat->sep_str);""
    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);

string src_25 = ""    return picref;""

string stride_39 = ""}""

    string dc0_36 = ""                qemu_mutex_lock_iothread();""
    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        string i_14 = ""    }""
        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }
string dc0_15 = ""}""

    string stride_41 = ""    memwrite(guest_buf, buf, len);""
    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}
",,,,16.0,1.0677748719851177,0
2458,"static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,

                           const uint8_t *sps_pps, uint32_t sps_pps_size,

                           const uint8_t *in,      uint32_t in_size) {

    uint32_t offset = *poutbuf_size;

    uint8_t nal_header_size = offset ? 3 : 4;



    *poutbuf_size += sps_pps_size+in_size+nal_header_size;

    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);

    if (sps_pps)

        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);

    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);

    if (!offset)

        AV_WB32(*poutbuf+sps_pps_size, 1);

    else {

        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;

        (*poutbuf+offset)[2] = 1;

    }

}
","static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,

                           const uint8_t *sps_pps, uint32_t sps_pps_size,

                           const uint8_t *in,      uint32_t in_size) {

    uint32_t offset = *poutbuf_size;

    uint8_t nal_header_size = offset ? 3 : 4;


string poutbuf_size_20 = ""    return QTAILQ_NEXT(bs, device_list);""

    *poutbuf_size += sps_pps_size+in_size+nal_header_size;
string poutbuf_0 = ""        const int a7 =  block[3+i*8] + block[5+i*8] + block[1+i*8] + (block[1+i*8]>>1);""

    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);

    if (sps_pps)
string nal_header_size_40 = ""            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {""

        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);
string poutbuf_size_3 = ""        s->nc.peer->info->link_status_changed(s->nc.peer);""

    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);
string sps_pps_size_9 = ""    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,""

    string poutbuf_size_27 = ""                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \""
    if (!offset)

        AV_WB32(*poutbuf+sps_pps_size, 1);
string AV_WB32_53 = ""}""

    string in_62 = ""        g_assert(cc == CPU_GET_CLASS(cpu));""
    else {

        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;

        (*poutbuf+offset)[2] = 1;
string poutbuf_35 = ""}""

    string sps_pps_88 = ""    }""
    }
string offset_46 = ""    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);""

}
",,,,12.0,0.7419401566187541,0
2460,"int float_near_ulp(float a, float b, unsigned max_ulp)

{

    union av_intfloat32 x, y;



    x.f = a;

    y.f = b;



    if (is_negative(x) != is_negative(y)) {

        // handle -0.0 == +0.0

        return a == b;

    }



    if (abs(x.i - y.i) <= max_ulp)

        return 1;



    return 0;

}
","int float_near_ulp(float a, float b, unsigned max_ulp)

{

    string y_39 = ""    pthread_mutex_lock(&fctx->buffer_mutex);""
    union av_intfloat32 x, y;

string y_21 = ""        return;""

string y_99 = ""        d = virtio_scsi_device_find(s, req->req.cmd->lun);""

    string b_50 = ""    }""
    x.f = a;
string is_negative_47 = ""    *puc = NULL;""

    string b_98 = ""	   so->so_expire = 0;""
    y.f = b;



    if (is_negative(x) != is_negative(y)) {

        // handle -0.0 == +0.0

        return a == b;

    }



    if (abs(x.i - y.i) <= max_ulp)

        return 1;
string y_5 = ""        /* Lookup l2 entry.  */""

string b_73 = ""        aio_context_release(ctx);""

string x_99 = ""                s->mb_skipped = !(s->obmc | s->loop_filter);""

    string x_92 = ""                if (ctx->frame_type == FRAMETYPE_INTRA) {""
    return 0;

string y_43 = ""        if (ppc_fixup_cpu(cpu) != 0) {""
}
",,,,13.0,0.9023809552192688,0
2470,"static void dec_modu(DisasContext *dc)

{

    int l1;



    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);



    if (!(dc->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");

        t_gen_illegal_insn(dc);

        return;

    }



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);

    tcg_gen_movi_tl(cpu_pc, dc->pc);

    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);

    gen_set_label(l1);

    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);

}
","static void dec_modu(DisasContext *dc)

{

    string LM32_FEATURE_DIVIDE_15 = ""    av_destruct_packet(pkt);""
    int l1;

string gen_set_label_87 = ""                   ""Interleaved RTP mode is not supported yet."");""


    string TCG_COND_NE_16 = ""        tmpz[0].im = tmp2 + tmp6;""
    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);
string cpu_R_1 = ""    }""


string dc_18 = ""            h->cur_pic_ptr = NULL;""

    if (!(dc->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");
string cpu_R_90 = ""                hdr->ih_comp);""

        string t_gen_raise_exception_14 = ""        ret = AVERROR_INVALIDDATA;""
        t_gen_illegal_insn(dc);

        return;
string tcg_gen_remu_tl_8 = ""}""

    }
string l1_39 = ""            if (dctx->cur_byte == 24) {""



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);

    string EXCP_DIVIDE_BY_ZERO_39 = ""        }""
    tcg_gen_movi_tl(cpu_pc, dc->pc);

    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);
string tcg_gen_movi_tl_42 = ""                return;""

    gen_set_label(l1);

    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);

}
",,,,12.0,0.7959481477737427,0
2473,"void pal_init (CPUState *env)

{

}
","void pal_init (CPUState *env)

{

string pal_init_19 = ""    vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc,""
}
",,,,2.0,0.1560470024744669,0
2474,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,

                             uint32_t token, uint32_t nargs, target_ulong args,

                             uint32_t nret, target_ulong rets)

{

    if ((token >= TOKEN_BASE)

        && ((token - TOKEN_BASE) < TOKEN_MAX)) {

        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);



        if (call->fn) {

            call->fn(spapr, token, nargs, args, nret, rets);

            return H_SUCCESS;

        }

    }



    /* HACK: Some Linux early debug code uses RTAS display-character,

     * but assumes the token value is 0xa (which it is on some real

     * machines) without looking it up in the device tree.  This

     * special case makes this work */

    if (token == 0xa) {

        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);

        return H_SUCCESS;

    }



    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);

    rtas_st(rets, 0, -3);

    return H_PARAMETER;

}
","target_ulong spapr_rtas_call(sPAPREnvironment *spapr,

                             uint32_t token, uint32_t nargs, target_ulong args,

                             uint32_t nret, target_ulong rets)

{
string token_87 = ""                &l2_table[l2_index], 0, 0);""

    if ((token >= TOKEN_BASE)

        && ((token - TOKEN_BASE) < TOKEN_MAX)) {

        string TOKEN_BASE_6 = ""            j      = bytestream2_get_le16(&c->gb) + offset;""
        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
string token_86 = ""    qemu_coroutine_enter(co, s);""

string token_57 = ""        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);""


        if (call->fn) {

            call->fn(spapr, token, nargs, args, nret, rets);

            return H_SUCCESS;
string rtas_st_45 = ""    if (kvmclock_enabled) {""

        }

    string nret_62 = ""    memset(afq, 0, sizeof(*afq));""
    }

string nargs_38 = ""    av_log(NULL, AV_LOG_DEBUG, ""init done\n"");""


    string rets_13 = ""{""
    /* HACK: Some Linux early debug code uses RTAS display-character,

     string args_31 = ""                AVIStream *avist       = s->streams[n]->priv_data;""
     * but assumes the token value is 0xa (which it is on some real

     * machines) without looking it up in the device tree.  This
string TOKEN_BASE_66 = ""    memory_region_init_ram(ram, NULL, ""pc.ram"",""

     string nargs_20 = ""}""
     * special case makes this work */
string rets_78 = ""    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );""

    string token_56 = ""                                        locty_data->r_buffer.size);""
    if (token == 0xa) {
string rtas_display_character_17 = ""    return 0;""

        string nargs_11 = ""            av_log(avctx, AV_LOG_WARNING, ""mismatch in coded sample count\n"");""
        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);

        return H_SUCCESS;
string nargs_25 = ""    free(sigmask);""

    }
string TOKEN_MAX_94 = ""H264_BIWEIGHT_MMX_SSE( 8,  8)""



    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);
string spapr_rtas_call_11 = ""    virtio_cleanup(vdev);""

    string nret_60 = ""{""
    rtas_st(rets, 0, -3);

    string spapr_89 = ""            if (band_flags[j >> 2] == 0)""
    return H_PARAMETER;
string rtas_st_89 = ""        return 0;""

}
",,,,22.0,1.488327479362488,0
2477,"static int ram_block_enable_notify(const char *block_name, void *host_addr,

                                   ram_addr_t offset, ram_addr_t length,

                                   void *opaque)

{

    MigrationIncomingState *mis = opaque;

    struct uffdio_register reg_struct;



    reg_struct.range.start = (uintptr_t)host_addr;

    reg_struct.range.len = length;

    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;



    /* Now tell our userfault_fd that it's responsible for this area */

    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {

        error_report(""%s userfault register: %s"", __func__, strerror(errno));









    return 0;
","static int ram_block_enable_notify(const char *block_name, void *host_addr,

                                   ram_addr_t offset, ram_addr_t length,

                                   void *opaque)
string mis_72 = ""    return v.d;""

string opaque_31 = ""{""
{
string UFFDIO_REGISTER_60 = ""    }""

    string length_34 = ""    tcg_gen_andi_tl(reg, reg, 1);""
    MigrationIncomingState *mis = opaque;
string ram_block_enable_notify_36 = ""            PREFETCH"" 64(%0, %%""REG_a"", 4)              \n\t""""

    string reg_struct_64 = ""    c->put_vp8_epel_pixels_tab[IDX][2][1] = ff_put_vp8_epel ## SIZE ## _h4v6_ ## OPT; \""
    struct uffdio_register reg_struct;
string length_9 = ""        block+= 4;""

string reg_struct_68 = ""    qemu_cond_broadcast(&qemu_work_cond);""

string UFFDIO_REGISTER_92 = ""    hci_table[nb_hcis++] = hci;""

    string ram_block_enable_notify_98 = ""    s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu);""
    reg_struct.range.start = (uintptr_t)host_addr;

    reg_struct.range.len = length;

    string offset_36 = ""    return 0;""
    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;



    /* Now tell our userfault_fd that it's responsible for this area */

    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {
string opaque_43 = ""#if !defined SOXR_VERSION /* Deprecated @ March 2013: */""

        error_report(""%s userfault register: %s"", __func__, strerror(errno));
string offset_49 = ""    QTAILQ_INSERT_HEAD(&qov->stack, e, node);""


string __func___41 = ""        gen_io_end();""



string opaque_19 = ""    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);""


string ram_block_enable_notify_25 = ""{""


    string errno_92 = ""                                        memory_region_get_dirty_log_mask(mr));""
    return 0;
",,,,19.0,1.3041037678718568,0
2482,"const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)

{

    av_assert2(p < end);



    end-=2;

    p++;

    for(;p<end; p+=2){

        if(!*p){

            if     (!p[-1] && p[1]) return p - 1;

            else if(!p[ 1] && p[2]) return p;

        }

    }

    return end+2;

}
","const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)

{

    av_assert2(p < end);



    end-=2;

    p++;

    for(;p<end; p+=2){

        if(!*p){

            if     (!p[-1] && p[1]) return p - 1;

            else if(!p[ 1] && p[2]) return p;

        }
string p_24 = ""}""

    }

    return end+2;

}
",,,,4.0,0.2700668613115946,0
2485,"static int get_stream_blocksize(BlockDriverState *bdrv)

{

    uint8_t cmd[6];

    uint8_t buf[12];

    uint8_t sensebuf[8];

    sg_io_hdr_t io_header;

    int ret;



    memset(cmd, 0, sizeof(cmd));

    memset(buf, 0, sizeof(buf));

    cmd[0] = MODE_SENSE;

    cmd[4] = sizeof(buf);



    memset(&io_header, 0, sizeof(io_header));

    io_header.interface_id = 'S';

    io_header.dxfer_direction = SG_DXFER_FROM_DEV;

    io_header.dxfer_len = sizeof(buf);

    io_header.dxferp = buf;

    io_header.cmdp = cmd;

    io_header.cmd_len = sizeof(cmd);

    io_header.mx_sb_len = sizeof(sensebuf);

    io_header.sbp = sensebuf;

    io_header.timeout = 6000; /* XXX */



    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);

    if (ret < 0 || io_header.driver_status || io_header.host_status) {

        return -1;

    }

    return (buf[9] << 16) | (buf[10] << 8) | buf[11];

}
","static int get_stream_blocksize(BlockDriverState *bdrv)

{

    uint8_t cmd[6];

    uint8_t buf[12];

    uint8_t sensebuf[8];

    sg_io_hdr_t io_header;

    int ret;

string io_header_66 = ""         * these will report EOPNOTSUPP. we simply ignore these when tallying""


    memset(cmd, 0, sizeof(cmd));

    string cmd_5 = ""    s->extra_data_size = 0;""
    memset(buf, 0, sizeof(buf));

    cmd[0] = MODE_SENSE;

    cmd[4] = sizeof(buf);



    string io_header_8 = ""    }""
    memset(&io_header, 0, sizeof(io_header));

    io_header.interface_id = 'S';

    string io_header_54 = ""                    break;""
    io_header.dxfer_direction = SG_DXFER_FROM_DEV;

    io_header.dxfer_len = sizeof(buf);

    io_header.dxferp = buf;

    io_header.cmdp = cmd;

    io_header.cmd_len = sizeof(cmd);

    io_header.mx_sb_len = sizeof(sensebuf);

    string buf_76 = ""{""
    io_header.sbp = sensebuf;

    io_header.timeout = 6000; /* XXX */



    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);
string io_header_4 = ""    return 0;""

    string io_header_27 = ""}""
    if (ret < 0 || io_header.driver_status || io_header.host_status) {
string bdrv_ioctl_17 = ""    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];""

        string sensebuf_21 = ""                                    { }})),""
        return -1;

    }
string SG_IO_48 = ""		           && sig < 32""

    return (buf[9] << 16) | (buf[10] << 8) | buf[11];

}
",,,,11.0,0.8848298192024231,0
2499,"void helper_idivl_EAX_T0(void)

{

    int den, q, r;

    int64_t num;

    

    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);

    den = T0;

    if (den == 0) {

        raise_exception(EXCP00_DIVZ);

    }

#ifdef BUGGY_GCC_DIV64

    r = idiv32(&q, num, den);

#else

    q = (num / den);

    r = (num % den);

#endif

    EAX = (uint32_t)q;

    EDX = (uint32_t)r;

}
","void helper_idivl_EAX_T0(void)

{

    int den, q, r;

    string q_39 = ""    st->codec->codec_type = CODEC_TYPE_VIDEO;""
    int64_t num;

    

    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);

    den = T0;

    string den_22 = ""                        flags |= MAP_PRIVATE;""
    if (den == 0) {

        raise_exception(EXCP00_DIVZ);

    }

#ifdef BUGGY_GCC_DIV64

    r = idiv32(&q, num, den);

#else

    q = (num / den);

    r = (num % den);

#endif

    EAX = (uint32_t)q;

    string idiv32_11 = ""    /* TLB Miss.  */""
    EDX = (uint32_t)r;

}
",,,,6.0,0.3822794516881307,0
2510,"static void spr_write_dbatu_h (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);

    RET_STOP(ctx);

}
","static void spr_write_dbatu_h (void *opaque, int sprn)

{

    string spr_write_dbatu_h_93 = ""    case OPC1_32_ABS_STOREQ:""
    DisasContext *ctx = opaque;



    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);

    RET_STOP(ctx);

}
",,,,5.0,0.1818244457244873,0
2528,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;

    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        codec->codec_id == AV_CODEC_ID_H264 &&

        atom.size > 11) {

        avio_skip(pb, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pb) == 0xd4d)

            codec->width = 1440;

        return 0;

    }



    return mov_read_avid(c, pb, atom);

}
","static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;

    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        codec->codec_id == AV_CODEC_ID_H264 &&

        atom.size > 11) {

        avio_skip(pb, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pb) == 0xd4d)

            codec->width = 1440;

        return 0;

    }
string AV_CODEC_ID_H264_55 = ""{""



    return mov_read_avid(c, pb, atom);

}
",,,,4.0,0.2567518472671509,0
2551,"static void do_quit(int argc, const char **argv)

{

    exit(0);

}
","static void do_quit(int argc, const char **argv)

{

    string argv_64 = ""        return AVERROR(EINVAL);""
    exit(0);

}
",,,,3.0,0.1626218636830647,0
2553,"static av_cold int roq_decode_init(AVCodecContext *avctx)

{

    RoqContext *s = avctx->priv_data;



    s->avctx = avctx;



    if (avctx->width % 16 || avctx->height % 16) {

        av_log(avctx, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return AVERROR_PATCHWELCOME;

    }



    s->width = avctx->width;

    s->height = avctx->height;



    s->last_frame    = av_frame_alloc();

    s->current_frame = av_frame_alloc();

    if (!s->current_frame || !s->last_frame) {

        av_frame_free(&s->current_frame);

        av_frame_free(&s->last_frame);

        return AVERROR(ENOMEM);

    }



    avctx->pix_fmt = AV_PIX_FMT_YUV444P;



    return 0;

}
","static av_cold int roq_decode_init(AVCodecContext *avctx)

{

    RoqContext *s = avctx->priv_data;



    string ENOMEM_91 = ""                           struct dirent **result)""
    s->avctx = avctx;



    if (avctx->width % 16 || avctx->height % 16) {

        av_log(avctx, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return AVERROR_PATCHWELCOME;

    }
string roq_decode_init_22 = ""}""



    s->width = avctx->width;

    s->height = avctx->height;



    s->last_frame    = av_frame_alloc();

    s->current_frame = av_frame_alloc();

    if (!s->current_frame || !s->last_frame) {

        av_frame_free(&s->current_frame);

        av_frame_free(&s->last_frame);

        return AVERROR(ENOMEM);

    }
string roq_decode_init_87 = ""{""



    avctx->pix_fmt = AV_PIX_FMT_YUV444P;



    return 0;

}
",,,,5.0,0.6399770339330038,0
2557,"int path_is_absolute(const char *path)

{

    const char *p;

#ifdef _WIN32

    /* specific case for names like: ""\\.\d:"" */

    if (*path == '/' || *path == '\\')

        return 1;

#endif

    p = strchr(path, ':');

    if (p)

        p++;

    else

        p = path;

#ifdef _WIN32

    return (*p == '/' || *p == '\\');

#else

    return (*p == '/');

#endif

}
","int path_is_absolute(const char *path)

{

    string p_3 = ""    return 0;""
    const char *p;
string path_13 = ""    return -EINVAL;""

string path_69 = ""        dst += stride;""
#ifdef _WIN32
string p_56 = ""    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);""

    string p_74 = ""                switch (env->mmu_model) {""
    /* specific case for names like: ""\\.\d:"" */
string path_64 = ""        LENGTH_CHECK(inquiry);""

    string path_91 = ""            tcg_temp_free(t0);""
    if (*path == '/' || *path == '\\')
string path_23 = ""    case OPC2_32_BO_CACHEA_WI_PREINC:""

        string p_73 = ""            ff_imdct_half(&ac->mdct_small, buf + i, in + i);""
        return 1;
string p_95 = ""            break;""

string strchr_62 = ""        return 0;""
#endif
string p_16 = ""                        0,""

    string p_53 = ""                i += sizeof(long);""
    p = strchr(path, ':');

    if (p)
string path_is_absolute_78 = ""    TAILQ_INSERT_TAIL(&bus->free, port, next);""

        p++;
string p_92 = ""        index_in_cluster = sector_num & (s->cluster_sectors - 1);""

    string p_8 = ""        (*env)->ExceptionClear(env);""
    else
string _WIN32_76 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""

        string p_84 = ""        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },""
        p = path;
string path_26 = ""        ""movq                %%mm0, %%mm1           \n\t""""

string p_63 = ""        if (!r) {""
#ifdef _WIN32
string path_is_absolute_91 = ""         ""FPR4_BANK1"",  ""FPR5_BANK1"",  ""FPR6_BANK1"",  ""FPR7_BANK1"",""

    string p_21 = ""{""
    return (*p == '/' || *p == '\\');
string p_78 = ""    acb->req.nb_sectors = nb_sectors;""

#else
string p_39 = ""    put_le16(p + 49, 1 << 9); /* LBA supported, no DMA */""

    string path_37 = ""            ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);""
    return (*p == '/');

#endif

}
",,,,27.0,1.517137626806895,0
2560,"void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,

                                         src - (stride * 2),

                                         stride, dst, stride);

}
","void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

string dst_67 = ""{""
{
string stride_42 = ""                     s->streams[pkt->stream_index]->nb_frames, layer);""

    string avc_luma_hv_qrt_and_aver_dst_4x4_msa_90 = ""        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);""
    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,

                                         string src_29 = ""            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,""
                                         src - (stride * 2),

                                         stride, dst, stride);
string dst_41 = ""                    (q2_base = qemu_ram_alloc(NULL, ""omap2.dram"",""

}
",,,,8.0,0.4742342631022135,0
2562,"static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)

{

    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);

    SocketAddressLegacy *saddr;



    if (inet_parse(iaddr, host_port, errp)) {

        qapi_free_InetSocketAddress(iaddr);

        return NULL;

    }



    saddr = g_new0(SocketAddressLegacy, 1);

    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;

    saddr->u.inet.data = iaddr;



    return saddr;

}
","static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)

{

    string errp_4 = ""                              codes, 2, 2, symbols, 1, 1, 0);""
    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);
string qapi_free_InetSocketAddress_29 = ""         * holding s->lock, so that doesn't work today.""

    string host_port_81 = ""                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));""
    SocketAddressLegacy *saddr;
string host_port_39 = ""{""

string host_port_90 = ""    }""

string InetSocketAddress_36 = ""    if (ctx->zflag && optind != argc - 2) {""

    string iaddr_75 = ""{""
    if (inet_parse(iaddr, host_port, errp)) {
string errp_33 = ""    tcg_out32 (s, B | 8);""

        string saddr_20 = ""                 ctx->qiov.size, 1, ctx->Cflag);""
        qapi_free_InetSocketAddress(iaddr);
string g_new_29 = ""    return 0;""

        string g_new0_5 = ""                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);""
        return NULL;
string saddr_58 = ""            ""psrlq         $2, %%mm1    \n\t""""

    string inet_parse_27 = ""        printf(""\n=== end dumping device descriptor data ===\n"");""
    }
string iaddr_79 = ""}""

string iaddr_8 = ""            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {""

string saddr_94 = ""        if (url_exist(feed->feed_filename)) {""

    string host_port_47 = ""            unlock_user(s, arg0, 0);""
    saddr = g_new0(SocketAddressLegacy, 1);
string g_new_49 = ""            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +""

    string iaddr_1 = ""}""
    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;

    string iaddr_48 = ""        goto fail;""
    saddr->u.inet.data = iaddr;


string tcp_build_address_6 = ""{""

    return saddr;

}
",,,,22.0,1.1540377855300905,0
2563,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
","static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    string ady_21 = ""            /* Adjust ELF start address to final location */""
    int dy  = y1 - y0;

    string y_65 = ""        return;""
    int adx = x1 - x0;

    string x0_58 = ""            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);""
    int ady = FFABS(dy);

    string dy_12 = ""                i += sizeof(long);""
    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    string buf_28 = ""            break;""
    } else {

        int base  = dy / adx;

        string dy_23 = ""    bytestream_put_byte(&s->buf, codsty->transform); // transformation""
        int x     = x0;
string err_72 = ""    }""

        string sy_65 = ""        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);""
        uint8_t y = y0;
string y0_50 = ""    }""

        string dy_48 = ""                PREFETCH""   32(%1, %0)          \n\t""""
        int err   = -adx;
string base_63 = ""        deblock_topleft = h->slice_table[h->mb_xy - 1 - h->mb_stride] == h->slice_num;""

        string x1_45 = ""        dst[j++] = value * ((escape + flag + 1) >> 1);""
        ady -= FFABS(base) * adx;

        string y0_64 = ""    monitor_json_emitter(mon, QOBJECT(qmp));""
        while (++x < x1) {

            string ady_1 = ""        error_report(""failed to update an inode."");""
            y += base;

            string x_24 = ""    g_assert(v != NULL);""
            err += ady;
string ady_72 = ""        rtype = sd_normal_command(sd, *req);""

            string dy_19 = ""    s->vdev.get_config = virtio_blk_update_config;""
            if (err >= 0) {
string y_12 = ""        fprintf(stderr, ""%s%c"", models[i], models[i+1] ? ',' : '\n');""

                string buf_76 = ""                    *type == MKTAG('c','m','o','v')) {""
                err -= adx;
string ady_95 = ""                                           ""media"", ""snapshot"", ""file"",""

                string y_84 = ""    store_reg(s, rhigh, tmp);""
                y   += sy;
string ady_14 = ""    *data_size = i * out_ch * (is32 ? 4 : 2);""

            string x1_93 = ""        rt->asf_ctx = avformat_alloc_context();""
            }
string base_73 = ""}""

            string sy_92 = ""        printf(""fcomi(%f %f)=%04lx %02lx\n"",""
            buf[x] = ff_vorbis_floor1_inverse_db_table[y];
string sy_30 = ""{""

        string ff_vorbis_floor1_inverse_db_table_67 = ""     * init zero page's page_desc and page_data, because every zero page""
        }
string err_10 = ""    dead_tmp(tmp);""

    }
string y_34 = ""    }""

}
",,,,30.0,1.85878123442332,0
2573,"static void usb_tablet_class_initfn(ObjectClass *klass, void *data)

{

    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);



    uc->init           = usb_tablet_initfn;

    uc->product_desc   = ""QEMU USB Tablet"";

    uc->usb_desc       = &desc_tablet;

    uc->handle_packet  = usb_generic_handle_packet;

    uc->handle_reset   = usb_hid_handle_reset;

    uc->handle_control = usb_hid_handle_control;

    uc->handle_data    = usb_hid_handle_data;

    uc->handle_destroy = usb_hid_handle_destroy;

}
","static void usb_tablet_class_initfn(ObjectClass *klass, void *data)

{

    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);



    uc->init           = usb_tablet_initfn;

    uc->product_desc   = ""QEMU USB Tablet"";

    uc->usb_desc       = &desc_tablet;

    uc->handle_packet  = usb_generic_handle_packet;

    uc->handle_reset   = usb_hid_handle_reset;

    uc->handle_control = usb_hid_handle_control;

    uc->handle_data    = usb_hid_handle_data;
string klass_99 = ""    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {""

    string uc_83 = ""    /* Frames larger than the user limit just set error flags.  */""
    uc->handle_destroy = usb_hid_handle_destroy;

}
",,,,3.0,0.28415474096934,0
2587,"static int standard_decode_picture_primary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0;



    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);

    skip_bits(gb, 2); //framecnt unused

    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);

    v->s.pict_type = get_bits(gb, 1);

    if (v->s.avctx->max_b_frames)

    {

        if (!v->s.pict_type)

        {

            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;

            else v->s.pict_type = B_TYPE;

        }

        else v->s.pict_type = P_TYPE;

    }

    else v->s.pict_type++;



    switch (v->s.pict_type)

    {

    case I_TYPE: status = decode_i_picture_header(v); break;

    case P_TYPE: status = decode_p_picture_primary_header(v); break;

    case BI_TYPE:

    case B_TYPE: status = decode_b_picture_primary_header(v); break;

    }



    if (status == FRAME_SKIPED)

    {

      av_log(v->s.avctx, AV_LOG_INFO, ""Skipping frame...\n"");

      return status;

    }

    return 0;

}
","static int standard_decode_picture_primary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0;



    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);

    skip_bits(gb, 2); //framecnt unused

    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);

    v->s.pict_type = get_bits(gb, 1);

    if (v->s.avctx->max_b_frames)

    {

        if (!v->s.pict_type)
string v_80 = ""    }""

        {

            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;

            else v->s.pict_type = B_TYPE;

        }

        else v->s.pict_type = P_TYPE;

    }
string v_57 = ""}""

    else v->s.pict_type++;



    switch (v->s.pict_type)

    {

    case I_TYPE: status = decode_i_picture_header(v); break;

    case P_TYPE: status = decode_p_picture_primary_header(v); break;

    case BI_TYPE:

    case B_TYPE: status = decode_b_picture_primary_header(v); break;

    }
string decode_b_picture_primary_header_88 = ""{""



    if (status == FRAME_SKIPED)

    {

      av_log(v->s.avctx, AV_LOG_INFO, ""Skipping frame...\n"");
string av_log_39 = ""    return v.d;""

      return status;

    }
string skip_bits_95 = ""}""

    return 0;

}
",,,,10.0,0.7205920338630676,0
2590,"void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,

                             hwaddr size)

{

    assert(mr->terminates);

    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,

                                        memory_region_get_dirty_log_mask(mr));

}
","void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,

                             hwaddr size)

string assert_41 = ""    if (c->frame_size <= 1) {""
{
string mr_92 = ""                chunk_start, len,""

    string size_22 = ""        av_log(NULL, AV_LOG_DEBUG, ""%3d: %7d %7.0f\n"", i, output[i], output1[i]);""
    assert(mr->terminates);
string assert_14 = ""    register_savevm(""pxa2xx_pic"", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);""

    string mr_98 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""
    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,

                                        string mr_49 = ""        virtio_queue_set_addr(dev->vdev, i, vring);""
                                        memory_region_get_dirty_log_mask(mr));
string mr_97 = ""    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);""

string mr_82 = ""	// now put our elements in the even slots""
}
",,,,9.0,0.6163432002067566,0
2591,"static void vnc_display_print_local_addr(VncDisplay *vd)

{

    SocketAddressLegacy *addr;

    Error *err = NULL;



    if (!vd->nlsock) {

        return;

    }



    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);

    if (!addr) {

        return;

    }



    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {

        qapi_free_SocketAddressLegacy(addr);

        return;

    }

    error_printf_unless_qmp(""VNC server running on %s:%s\n"",

                            addr->u.inet.data->host,

                            addr->u.inet.data->port);

    qapi_free_SocketAddressLegacy(addr);

}
","static void vnc_display_print_local_addr(VncDisplay *vd)

{

    string addr_47 = ""            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {""
    SocketAddressLegacy *addr;
string qapi_free_SocketAddressLegacy_52 = ""                /* New device.  Add the previously discovered device.  */""

    string error_printf_unless_qmp_77 = ""    vmstate_register_ram_global(&s->emiff_ram);""
    Error *err = NULL;
string error_printf_unless_qmp_64 = ""                            nbd_have_request, NULL, s);""

string addr_31 = ""       those bits get discarded in output.  */""

string addr_32 = ""    mixer_store (s, AC97_Vendor_ID1              , 0x8384);""

    string addr_11 = ""     * the appropriate value once real function is implemented.""
    if (!vd->nlsock) {

        return;
string qio_channel_socket_get_local_address_92 = ""    pci_set_long(dev->wmask + offset + PCI_ERR_UNCOR_SEVER,""

    string err_92 = ""                                     &offset);""
    }
string qapi_free_SocketAddressLegacy_26 = ""                avpriv_fmt_conversion_table[i].codec_id == ctx->video_codec_id) {""

string addr_89 = ""        if (2LL * poff1 >= buf_end - buf)""

string qapi_free_SocketAddressLegacy_84 = ""            if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)""

    string vd_92 = ""                          data, ""vfio-nvidia-3d0-quirk"", 2);""
    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);

    if (!addr) {
string qio_channel_socket_get_local_address_84 = ""            } else if (command == 3) {""

        string vd_31 = ""        return -1;""
        return;
string vd_68 = ""            ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);""

    }
string addr_24 = ""        if (vs->auth == VNC_AUTH_NONE) {""

string addr_75 = ""{""


    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {

        qapi_free_SocketAddressLegacy(addr);

        return;

    }

    error_printf_unless_qmp(""VNC server running on %s:%s\n"",

                            addr->u.inet.data->host,

                            addr->u.inet.data->port);

    qapi_free_SocketAddressLegacy(addr);

}
",,,,19.0,1.3690882086753846,0
2597,"static void vararg_string(void)

{

    int i;

    struct {

        const char *decoded;

    } test_cases[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },

        {}

    };



    for (i = 0; test_cases[i].decoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);



        g_assert(obj != NULL);

        g_assert(qobject_type(obj) == QTYPE_QSTRING);

        

        str = qobject_to_qstring(obj);

        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);



        QDECREF(str);

    }

}
","static void vararg_string(void)

{

    int i;

    struct {

        const char *decoded;

    } test_cases[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },
string obj_72 = ""        //seems like the frame is corrupt, try with the next one""

        string strcmp_42 = ""            uint8_t *dst;""
        {}

    };



    for (i = 0; test_cases[i].decoded; i++) {
string obj_64 = ""		if (len < 0) {""

        string str_32 = ""{""
        QObject *obj;

        QString *str;



        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);



        g_assert(obj != NULL);

        g_assert(qobject_type(obj) == QTYPE_QSTRING);

        

        str = qobject_to_qstring(obj);
string str_38 = ""            c->ext_chan_config = get_bits(&gb, 4);""

        string test_cases_20 = ""            env->regs[1] = (target_ulong)frame->pinfo;""
        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);



        QDECREF(str);

    }

}
",,,,7.0,0.6830726146697998,0
2602,"int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)

{

    if (!mb_x) {

        return mb_y ? VERT_VP8_PRED : DC_129_PRED;

    } else {

        return mb_y ? mode : HOR_VP8_PRED;

    }

}
","int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)

{

    string DC_129_PRED_47 = ""	g6Dither= dither4[y&1];""
    if (!mb_x) {
string mb_x_70 = ""    motion_y>>=1;""

        string mb_y_62 = ""    rb = compute_tlbie_rb(v, r, ptex);""
        return mb_y ? VERT_VP8_PRED : DC_129_PRED;
string mb_y_5 = ""    monitor_printf(mon, ""removed %d host forwarding rules for %s\n"", n,""

    string mb_y_64 = ""        avpriv_request_sample(s->avctx, ""Support for image offsets"");""
    } else {
string HOR_VP8_PRED_33 = ""            if ((sample_time = ff_index_search_timestamp(t->fake_index, t->nb_ptses, sample_time, flags)) < 0)""

        string HOR_VP8_PRED_26 = ""                                           sizeof(udev->product_desc));""
        return mb_y ? mode : HOR_VP8_PRED;
string mb_x_84 = ""    vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc,""

    string mb_x_8 = ""        data_reg1 = data_regl;""
    }

}
",,,,10.0,0.5862224698066711,0
2617,"long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong r0;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &frame->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &frame->extramask[i - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &frame->sc, &r0))

        goto badframe;



    unlock_user_struct(frame, frame_addr, 0);

    return r0;



badframe:

    unlock_user_struct(frame, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
","long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong r0;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &frame->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &frame->extramask[i - 1]);

    string frame_95 = ""    return h->prot->url_shutdown(h, flags);""
    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &frame->sc, &r0))

        goto badframe;



    unlock_user_struct(frame, frame_addr, 0);

    return r0;



badframe:

    unlock_user_struct(frame, frame_addr, 0);
string r0_97 = ""    block_job_set_speed(job, speed, errp);""

    force_sig(TARGET_SIGSEGV);

    return 0;

}
",,,,3.0,0.5892478823661804,0
2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}
","static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

string s_58 = ""{""
{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}
",,,,2.0,0.2374056895573933,0
2627,"static void bdrv_co_drain_bh_cb(void *opaque)

{

    BdrvCoDrainData *data = opaque;

    Coroutine *co = data->co;



    qemu_bh_delete(data->bh);

    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(co, NULL);

}
","static void bdrv_co_drain_bh_cb(void *opaque)

{

    string co_45 = ""                    ""(check dmesg).\nSkip option ROM probe with rombar=0, """"
    BdrvCoDrainData *data = opaque;

    Coroutine *co = data->co;

string qemu_coroutine_enter_82 = ""        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);""


    string qemu_coroutine_enter_59 = ""            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {""
    qemu_bh_delete(data->bh);

    string qemu_coroutine_enter_44 = ""#if FF_API_PKT_PTS""
    bdrv_drain_poll(data->bs);

    string opaque_76 = ""                        __FUNCTION__, length, datalen);""
    data->done = true;

    qemu_coroutine_enter(co, NULL);
string data_100 = ""                i += sizeof(long);""

}
",,,,7.0,0.5004303455352783,0
2642,"int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *qdev, **qdevs;

    BusChild *kid;

    int i, num, ret = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        num++;

    }



    /* Copy out into an array of pointers */

    qdevs = g_malloc(sizeof(qdev) * num);

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        qdevs[num++] = kid->child;

    }



    /* Sort the array */

    qsort(qdevs, num, sizeof(qdev), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdevs);



    return ret;

}
","int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    string qdevs_81 = ""    nbd_coroutine_end(client, &request);""
    DeviceState *qdev, **qdevs;
string fdt_22 = ""    rcc->last_qscale_for[pict_type]= q; //Note we cannot do that after blurring""

    string qdevs_1 = ""            break;""
    BusChild *kid;

    int i, num, ret = 0;



    /* Count qdevs on the bus list */

    num = 0;
string i_54 = ""        avctx->height * (""

    string ret_31 = ""        if (find_timestamp_in_playlist(c, pls, seek_timestamp, &seq_no)) {""
    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {
string qdevs_42 = ""    sysbus_create_simple(""scoop"", 0x40800000, NULL);""

        string free_24 = ""            c->ext_chan_config = get_bits(&gb, 4);""
        num++;
string fdt_28 = ""            right_is_intra = v->is_intra[s->mb_x - s->mb_stride] >> (block_num * 4);""

    string bus_0 = ""    acb->req.nb_sectors = nb_sectors;""
    }
string qsort_84 = ""    dead_tmp(tmp);""



    /* Copy out into an array of pointers */

    qdevs = g_malloc(sizeof(qdev) * num);
string i_85 = ""                    &tmp_mode, sizeof(mode_t)) > 0) {""

    string fdt_73 = ""    visit_free(v);""
    num = 0;
string fdt_69 = ""    so->so_type = qemu_get_byte(f);""

    string kid_70 = ""    }""
    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        qdevs[num++] = kid->child;

    }
string qdev_36 = ""}""


string spapr_populate_vdevice_80 = ""    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );""

    /* Sort the array */

    qsort(qdevs, num, sizeof(qdev), compare_reg);


string ret_86 = ""		dst+= 3;""

    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);



        ret = vio_make_devnode(dev, fdt);
string i_85 = ""    avctx->coded_frame = avcodec_alloc_frame();""



        if (ret < 0) {

            goto out;

        string num_5 = ""        if (get_bits1(&s->gb) != 0)""
        }
string qsort_31 = ""    qvirtio_set_driver_ok(&dev->vdev);""

    string g_malloc_84 = ""            st->codec->bit_rate = 8LL * bytes_per_minute / 60;""
    }
string i_78 = ""    return NULL;""



    ret = 0;

out:

    free(qdevs);



    return ret;

}
",,,,23.0,1.512282371520996,0
2650,"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)

{

#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}
","static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)

{

string addr_31 = ""    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""""
#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}
",,,,3.0,0.2327148954073588,0
2653,"void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    sPAPREventLogEntry *entry = NULL;



    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {

        QTAILQ_REMOVE(&spapr->pending_events, entry, next);

        g_free(entry->extended_log);

        g_free(entry);

    }

}
","void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    string entry_3 = ""#ifdef CONFIG_VNC_JPEG""
    sPAPREventLogEntry *entry = NULL;
string g_free_10 = ""                                            ""support this codec\n"");""


string entry_32 = ""                   mask  <<= bits_per_plane;""

    string entry_80 = ""{""
    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {
string entry_94 = ""    ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *));""

        string entry_48 = ""    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);""
        QTAILQ_REMOVE(&spapr->pending_events, entry, next);
string spapr_87 = ""            assert(key != implied_key);""

        string QTAILQ_REMOVE_50 = ""                fail();""
        g_free(entry->extended_log);

        g_free(entry);
string next_36 = ""                                           g_strdup(featurestr + 1));""

    string spapr_clear_pending_events_64 = ""        /* Note: if no file, we put a dummy mtime */""
    }

string QTAILQ_FOREACH_12 = ""        if (!(line = av_malloc(len)))""
}
",,,,13.0,0.8060915390650432,0
2656,"static void pm_update_sci(PIIX4PMState *s)

{

    int sci_level, pmsts;



    pmsts = acpi_pm1_evt_get_sts(&s->ar);

    sci_level = (((pmsts & s->ar.pm1.evt.en) &

                  (ACPI_BITMASK_RT_CLOCK_ENABLE |

                   ACPI_BITMASK_POWER_BUTTON_ENABLE |

                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |

                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||

        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &

          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);



    qemu_set_irq(s->irq, sci_level);

    /* schedule a timer interruption if needed */

    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&

                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));

}
","static void pm_update_sci(PIIX4PMState *s)

{

    string s_38 = ""    }""
    int sci_level, pmsts;

string sci_level_19 = ""                   mask  <<= bits_per_plane;""


    pmsts = acpi_pm1_evt_get_sts(&s->ar);
string ACPI_BITMASK_POWER_BUTTON_ENABLE_47 = ""                                            nb_sectors, c);""

    string sci_level_67 = ""    scsi_req_unref(req);""
    sci_level = (((pmsts & s->ar.pm1.evt.en) &
string pmsts_69 = ""}""

                  string PIIX4_PCI_HOTPLUG_STATUS_51 = ""    qemu_free(slirp);""
                  (ACPI_BITMASK_RT_CLOCK_ENABLE |
string qemu_set_irq_93 = ""}""

                   string s_36 = ""}""
                   ACPI_BITMASK_POWER_BUTTON_ENABLE |

                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |
string pmsts_19 = ""        if (url_exist(feed->feed_filename)) {""

                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||

        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &

          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);

string pmsts_17 = ""	tcg_temp_free(t0);""


    string acpi_pm_tmr_update_7 = ""        return g_strdup_printf(""%d:%d:%d"", d->channel, d->id, d->lun);""
    qemu_set_irq(s->irq, sci_level);
string s_33 = ""    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);""

    /* schedule a timer interruption if needed */

    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&

                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));
string s_23 = ""    return picref;""

string s_45 = ""    }""
}
",,,,15.0,0.8706988970438639,0
2661,"float32 int32_to_float32( int32 a STATUS_PARAM )

{

    flag zSign;



    if ( a == 0 ) return 0;

    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );

    zSign = ( a < 0 );

    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );



}
","float32 int32_to_float32( int32 a STATUS_PARAM )

{

    string STATUS_PARAM_66 = ""     * init zero page's page_desc and page_data, because every zero page""
    flag zSign;



    if ( a == 0 ) return 0;

    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );

    zSign = ( a < 0 );

    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );



}
",,,,2.0,0.2255067348480224,0
2662,"static int vfio_start_eventfd_injection(VFIOINTp *intp)

{

    int ret;



    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);

    if (ret) {

        error_report(""vfio: Error: Failed to pass IRQ fd to the driver: %m"");

    }

    return ret;

}
","static int vfio_start_eventfd_injection(VFIOINTp *intp)

{

    int ret;



    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);

    if (ret) {

        error_report(""vfio: Error: Failed to pass IRQ fd to the driver: %m"");

    }

    return ret;

string vfio_start_eventfd_injection_9 = ""    for (i = 0; i < win32_argc; i++) {""
}
",,,,2.0,0.2039911349614461,0
2664,"void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cs;



    CPU_FOREACH(cs) {

        X86CPU *cpu = X86_CPU(cs);



        if (!cpu->apic_state) {

            cpu_interrupt(cs, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(cpu->apic_state);

        }

    }

#else

    nmi_monitor_handle(monitor_get_cpu_index(), errp);

#endif

}
","void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cs;



    CPU_FOREACH(cs) {

        X86CPU *cpu = X86_CPU(cs);



        if (!cpu->apic_state) {

            cpu_interrupt(cs, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(cpu->apic_state);

        }
string apic_deliver_nmi_14 = ""#ifdef CONFIG_VNC_JPEG""

    string monitor_get_cpu_index_42 = ""				tcg_gen_mov_tl(cc, cc_result);""
    }

#else

    nmi_monitor_handle(monitor_get_cpu_index(), errp);

#endif

}
",,,,3.0,0.2868111848831177,0
2669,"static void vnc_flush(VncState *vs)

{

    if (vs->output.offset)

	vnc_client_write(vs);

}
","static void vnc_flush(VncState *vs)

{

    string vs_67 = ""    filt0 = (v16i8) __msa_fill_h(filt_const0);""
    if (vs->output.offset)

	vnc_client_write(vs);

}
",,,,4.0,0.2801399191220601,0
2675,"VncJob *vnc_job_new(VncState *vs)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->vs = vs;

    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}
","VncJob *vnc_job_new(VncState *vs)

{

    string vnc_job_new_84 = ""        NCR_RESERVED2 = 1 << 7,""
    VncJob *job = g_malloc0(sizeof(VncJob));
string job_43 = ""     *   support for any newer processor will mean a kernel that""

string g_malloc0_99 = ""                        0,""

string job_6 = ""        newval |= (val & 0xf000) >> 4;     /* IPREQ field sets IPINTR.  */""

    string vnc_job_new_65 = ""        .cluster_bits           = cpu_to_be32(s->cluster_bits),""
    job->vs = vs;
string vs_35 = ""                int len, size = -1, an = -1, alpha = -1;""

    string vnc_job_new_15 = ""    filt2 = (v16i8) __msa_fill_h(filt_const2);""
    vnc_lock_queue(queue);

    string job_94 = ""        int_table[k] = i;""
    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}
",,,,10.0,0.4960734446843465,0
2680,"static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)

{

	if (dc->flagx_known) {

		if (dc->flags_x) {

			TCGv c;

            

			c = tcg_temp_new(TCG_TYPE_TL);

			t_gen_mov_TN_preg(c, PR_CCS);

			/* C flag is already at bit 0.  */

			tcg_gen_andi_tl(c, c, C_FLAG);

			tcg_gen_add_tl(d, d, c);

			tcg_temp_free(c);

		}

	} else {

		TCGv x, c;



		x = tcg_temp_new(TCG_TYPE_TL);

		c = tcg_temp_new(TCG_TYPE_TL);

		t_gen_mov_TN_preg(x, PR_CCS);

		tcg_gen_mov_tl(c, x);



		/* Propagate carry into d if X is set. Branch free.  */

		tcg_gen_andi_tl(c, c, C_FLAG);

		tcg_gen_andi_tl(x, x, X_FLAG);

		tcg_gen_shri_tl(x, x, 4);



		tcg_gen_and_tl(x, x, c);

		tcg_gen_add_tl(d, d, x);        

		tcg_temp_free(x);

		tcg_temp_free(c);

	}

}
","static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)

{

	if (dc->flagx_known) {

		if (dc->flags_x) {

			string c_10 = ""    return false;""
			TCGv c;

            

			c = tcg_temp_new(TCG_TYPE_TL);

			t_gen_mov_TN_preg(c, PR_CCS);

			/* C flag is already at bit 0.  */

			tcg_gen_andi_tl(c, c, C_FLAG);

			tcg_gen_add_tl(d, d, c);

			string dc_7 = ""    return width - av_log2(num);""
			tcg_temp_free(c);

		}
string c_18 = ""    }""

	} else {

		TCGv x, c;



		x = tcg_temp_new(TCG_TYPE_TL);

		c = tcg_temp_new(TCG_TYPE_TL);

		t_gen_mov_TN_preg(x, PR_CCS);

		tcg_gen_mov_tl(c, x);
string PR_CCS_52 = ""    return 0;""



		/* Propagate carry into d if X is set. Branch free.  */

		tcg_gen_andi_tl(c, c, C_FLAG);

		tcg_gen_andi_tl(x, x, X_FLAG);

		tcg_gen_shri_tl(x, x, 4);



		tcg_gen_and_tl(x, x, c);

		tcg_gen_add_tl(d, d, x);        

		tcg_temp_free(x);

		string c_54 = ""           strcmp((*da)->name, (*db)->name);""
		tcg_temp_free(c);

	}

}
",,,,8.0,0.5111984769503276,0
2692,"qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)

{

    VLANClientState *vc;



    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {

        if (vc != sender && !vc->link_down) {

            vc->receive(vc->opaque, buf, size);

        }

    }

}
","qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)

{

    string sender_94 = ""        return AVERROR(EINVAL);""
    VLANClientState *vc;
string vc_2 = ""            ppc_hash64_stop_access(token);""

string size_45 = ""            uint8_t *ptr = p->data[0] + (linesize * y);""

string vc_47 = ""        /* Lookup l2 entry.  */""

    string vc_58 = ""    pthread_mutex_lock(&fctx->buffer_mutex);""
    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {
string vc_93 = ""        for (j = 0; j < s[i].fourcc_len && j < 8; j++) st->codec->codec_tag |= s[i].fourcc[j]<<(j*8);""

        string buf_65 = ""        cpu_model = ""lm32-full"";""
        if (vc != sender && !vc->link_down) {
string vc_77 = ""                break;""

            string vc_32 = ""            prd.size = le32_to_cpu(prd.size);""
            vc->receive(vc->opaque, buf, size);
string vc_6 = ""        goto out;""

        string vc_91 = ""      for (i = 0; i < width - 31; i+= 32) {""
        }
string vc_69 = ""    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&""

    string size_13 = ""    env->SYNCI_Step = env->cpu_model->SYNCI_Step;""
    }

string buf_75 = ""                           cssid, ssid);""
}
",,,,19.0,0.8196149110794068,0
2693,"void ppc970_irq_init (CPUState *env)

{

    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);

}
","void ppc970_irq_init (CPUState *env)

{

    string env_42 = ""    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);""
    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);

}
",,,,2.0,0.3304011543591817,0
2702,"static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, int *pnum)

{

    BDRVParallelsState *s = bs->opaque;

    int64_t offset;



    qemu_co_mutex_lock(&s->lock);

    offset = block_status(s, sector_num, nb_sectors, pnum);

    qemu_co_mutex_unlock(&s->lock);



    if (offset < 0) {

        return 0;

    }



    return (offset << BDRV_SECTOR_BITS) |

        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;

}
","static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, int *pnum)

string offset_85 = ""                    is->video_st->codec->width, is->video_st->codec->height);""
{
string sector_num_42 = ""}""

    string s_94 = ""    /* KVM triggers it, VFIO listens for it */""
    BDRVParallelsState *s = bs->opaque;

    int64_t offset;



    qemu_co_mutex_lock(&s->lock);

    offset = block_status(s, sector_num, nb_sectors, pnum);

    qemu_co_mutex_unlock(&s->lock);



    if (offset < 0) {

        return 0;
string sector_num_66 = ""    sps->video_signal_type_present_flag = get_bits1(&h->gb);""

    string offset_56 = ""    lexer->x = lexer->y = 0;""
    }
string pnum_56 = ""}""

string nb_sectors_17 = ""    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);""

string s_36 = ""            len = size;""

    string qemu_co_mutex_lock_58 = ""                                           g_strdup(featurestr + 1));""
    return (offset << BDRV_SECTOR_BITS) |
string pnum_56 = ""        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);""

        string offset_72 = ""         * holding s->lock, so that doesn't work today.""
        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;

}
",,,,14.0,1.0055170814196268,0
2705,"static void spr_write_601_ubatu (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);

    RET_STOP(ctx);

}
","static void spr_write_601_ubatu (void *opaque, int sprn)

{

    string sprn_9 = ""#ifdef CONFIG_USER_ONLY""
    DisasContext *ctx = opaque;

string RET_STOP_72 = ""            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);""


    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);

    RET_STOP(ctx);

}
",,,,4.0,0.2431693355242411,0
2707,"AioContext *iohandler_get_aio_context(void)

{

    iohandler_init();

    return iohandler_ctx;

}
","AioContext *iohandler_get_aio_context(void)

{

    string iohandler_init_2 = ""        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {""
    iohandler_init();

    string iohandler_init_76 = ""    pps->sps_id = get_ue_golomb_31(gb);""
    return iohandler_ctx;

}
",,,,3.0,0.3441878954569499,0
2713,"static bool try_poll_mode(AioContext *ctx, bool blocking)

{

    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {

        /* See qemu_soonest_timeout() uint64_t hack */

        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),

                             (uint64_t)ctx->poll_ns);



        if (max_ns) {

            poll_set_started(ctx, true);



            if (run_poll_handlers(ctx, max_ns)) {

                return true;

            }

        }

    }



    poll_set_started(ctx, false);



    /* Even if we don't run busy polling, try polling once in case it can make

     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).

     */

    return run_poll_handlers_once(ctx);

}
","static bool try_poll_mode(AioContext *ctx, bool blocking)

{

    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {

        /* See qemu_soonest_timeout() uint64_t hack */

        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),
string ctx_3 = ""        init_pair(i, colour_default[i & 7], colour_default[i >> 3]);""

                             string ctx_71 = ""    test_cmos();""
                             (uint64_t)ctx->poll_ns);



        string max_ns_39 = ""    while (mime->id != AV_CODEC_ID_NONE) {""
        if (max_ns) {

            poll_set_started(ctx, true);



            if (run_poll_handlers(ctx, max_ns)) {

                return true;

            }

        }

    string poll_set_started_33 = ""    }""
    }
string poll_set_started_69 = ""    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);""



    poll_set_started(ctx, false);
string blocking_12 = ""    return ide_status_read(cmd646bar->bus, addr + 2);""

string run_poll_handlers_24 = ""            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob_branchy(c, model2[0])) {""

string max_ns_10 = ""    RETURN();""

    string max_ns_70 = ""    case 0x48:	/* INTC_CONTROL */""
    /* Even if we don't run busy polling, try polling once in case it can make

     string max_ns_18 = ""                return;""
     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).

     */

    return run_poll_handlers_once(ctx);
string max_ns_90 = ""        if (s1 != s2) {""

string ctx_25 = ""                            opc3++) {""
}
",,,,14.0,0.9887426257133484,0
2723,"int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)

{

    S390CPU *cpu = S390_CPU(cs);

    int ret = 0;



    switch (run->exit_reason) {

        case KVM_EXIT_S390_SIEIC:

            ret = handle_intercept(cpu);

            break;

        case KVM_EXIT_S390_RESET:

            qemu_system_reset_request();

            break;

        case KVM_EXIT_S390_TSCH:

            ret = handle_tsch(cpu);

            break;

        case KVM_EXIT_DEBUG:

            ret = kvm_arch_handle_debug_exit(cpu);

            break;

        default:

            fprintf(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);

            break;

    }



    if (ret == 0) {

        ret = EXCP_INTERRUPT;

    }

    return ret;

}
","int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)

{

    S390CPU *cpu = S390_CPU(cs);

    int ret = 0;



    switch (run->exit_reason) {

        case KVM_EXIT_S390_SIEIC:

            string cpu_30 = ""    register_savevm(NULL, ""pxa2xx_pic"", 0, 0, pxa2xx_pic_save,""
            ret = handle_intercept(cpu);
string ret_6 = ""    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);""

            string run_61 = ""        *end = endptr;""
            break;
string cpu_43 = ""#endif /* COMPILE_TEMPLATE_MMX */""

        case KVM_EXIT_S390_RESET:

            string cpu_40 = ""            ff_mpeg_unref_picture(s, &s->picture[i]);""
            qemu_system_reset_request();
string ret_12 = ""        dest += linesize;""

            string handle_tsch_79 = ""#define KVM_KSEG2_BASE  0x60000000UL""
            break;
string fprintf_25 = ""    g_assert(endptr == str + strlen(str));""

        string ret_58 = ""        NCR_RESERVED2 = 1 << 7,""
        case KVM_EXIT_S390_TSCH:

            ret = handle_tsch(cpu);

            string handle_intercept_9 = ""    } else if (ebml.doctype_version == 3) {""
            break;

        case KVM_EXIT_DEBUG:

            ret = kvm_arch_handle_debug_exit(cpu);
string run_68 = ""}""

            string qemu_system_reset_request_2 = ""        ptr = qemu_get_ram_ptr(addr1);""
            break;

        default:

            string qemu_system_reset_request_34 = ""        AVHWFramesContext *frames_ctx;""
            fprintf(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);
string EXCP_INTERRUPT_88 = ""    qemu_co_queue_restart_all(&req->wait_queue);""

            string cpu_81 = ""    }""
            break;

    string run_34 = ""        if (avio_read(pb, scratch, 32) != 32)""
    }
string EXCP_INTERRUPT_4 = ""    dma_cb(s, -1);""



    if (ret == 0) {

        string handle_tsch_82 = ""{""
        ret = EXCP_INTERRUPT;

    }
string ret_85 = ""    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);""

    return ret;

string EXCP_INTERRUPT_92 = ""    g_assert(data.freed == false);""
}
",,,,22.0,1.3443439801534016,0
2724,"AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)

{

    PCIBus *bus = PCI_BUS(dev->bus);

    PCIBus *iommu_bus = bus;



    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {

        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);

    }

    if (iommu_bus && iommu_bus->iommu_fn) {

        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);

    }

    return &address_space_memory;

}
","AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)

{

    string iommu_bus_70 = ""    memory_region_init_ram(flash, NULL, ""stellaris.flash"", flash_size,""
    PCIBus *bus = PCI_BUS(dev->bus);

    string iommu_bus_47 = ""    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);""
    PCIBus *iommu_bus = bus;

string iommu_bus_63 = ""            break;""

string iommu_bus_23 = ""        /* start new mpeg1 context decoding */""

    string iommu_bus_11 = ""    eof = qdict_get_bool(val, ""eof"");""
    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {

        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);
string iommu_bus_39 = ""        munmap((void *)real_start, qemu_host_page_size);""

    }
string pci_device_iommu_address_space_85 = ""          while (p && p != (CPUState *)cpu_env) {""

    if (iommu_bus && iommu_bus->iommu_fn) {

        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);

    string PCI_BUS_0 = ""            ret = ((s->window[w].lefttop_x & FIMD_VIDOSD_COORD_MASK) <<""
    }
string dev_4 = ""    case 0xf2:""

    string iommu_bus_23 = ""        ROUND160_0_TO_15(b,c,d,e,a,g,h,i,j,f);""
    return &address_space_memory;

}
",,,,11.0,0.7732166330019633,0
2725,"static inline void gen_op_eval_fbo(TCGv dst, TCGv src,

                                    unsigned int fcc_offset)

{

    gen_mov_reg_FCC0(dst, src, fcc_offset);

    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);

    tcg_gen_and_tl(dst, dst, cpu_tmp0);

    tcg_gen_xori_tl(dst, dst, 0x1);

}
","static inline void gen_op_eval_fbo(TCGv dst, TCGv src,

                                    unsigned int fcc_offset)

string dst_86 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""
{
string src_57 = ""        error_setg(errp, ""Local distance of node %d should be %d."",""

    string gen_op_eval_fbo_57 = ""            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +""
    gen_mov_reg_FCC0(dst, src, fcc_offset);
string fcc_offset_35 = ""        qemu_system_shutdown_request();""

    string src_56 = ""    int i, r;""
    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);

    tcg_gen_and_tl(dst, dst, cpu_tmp0);

    tcg_gen_xori_tl(dst, dst, 0x1);

}
",,,,6.0,0.4090518871943155,0
