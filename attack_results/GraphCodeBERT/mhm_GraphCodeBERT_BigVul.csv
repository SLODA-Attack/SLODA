Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
2,"void RenderFrameImpl::OnCopyToFindPboard() {
  if (frame_->HasSelection()) {
    if (!clipboard_host_) {
      auto* platform = RenderThreadImpl::current_blink_platform_impl();
      platform->GetConnector()->BindInterface(platform->GetBrowserServiceName(),
                                              &clipboard_host_);
    }
    base::string16 selection = frame_->SelectionAsText().Utf16();
    clipboard_host_->WriteStringToFindPboard(selection);
  }
}
","void RenderFrameImpl::bh() {
  if (tid->HasSelection()) {
    if (!IF_FEATURE_UDHCP_PORT) {
      auto* platform = RenderThreadImpl::expand();
      platform->GetConnector()->BindInterface(platform->GetBrowserServiceName(),
                                              &IF_FEATURE_UDHCP_PORT);
    }
    base::string16 rdf_xml_parser = tid->SelectionAsText().Utf16();
    IF_FEATURE_UDHCP_PORT->WriteStringToFindPboard(rdf_xml_parser);
  }
}
",75.0,12.0,"clipboard_host_:IF_FEATURE_UDHCP_PORT,current_blink_platform_impl:expand,OnCopyToFindPboard:bh,frame_:tid,selection:rdf_xml_parser,",337.0,0.3766062299410502,MHM
5," static void addDataToStreamTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);
 }
"," static void JPEGCompression(void* png_destroy_write_struct)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = user_msg(observers_<BlobRegistryContext*>(png_destroy_write_struct));
    symbols().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);
 }
",43.0,9.0,"context:png_destroy_write_struct,addDataToStreamTask:JPEGCompression,static_cast:observers_,blobRegistry:symbols,adoptPtr:user_msg,",276.0,0.3511472344398498,MHM
9,"bool TopSitesImpl::IsKnownURL(const GURL& url) {
  return loaded_ && cache_->IsKnownURL(url);
}
","bool TopSitesImpl::get_data(const GURL& Z_TYPE_P) {
  return MagickMax && asn1_c_attr->get_data(Z_TYPE_P);
}
",22.0,5.0,"url:Z_TYPE_P,cache_:asn1_c_attr,loaded_:MagickMax,IsKnownURL:get_data,",277.0,0.2940499265988668,MHM
11,"		void CWebServer::Cmd_GetAuth(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetAuth"";
			if (session.rights != -1)
			{
				root[""version""] = szAppVersion;
			}
			root[""user""] = session.username;
			root[""rights""] = session.rights;
		}
","		void CWebServer::fhandle(WebEmSession & pos, const request& Null, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetAuth"";
			if (pos.rights != -1)
			{
				root[""version""] = kernel;
			}
			root[""user""] = pos.username;
			root[""rights""] = pos.rights;
		}
",78.0,13.0,"req:Null,szAppVersion:kernel,session:pos,Cmd_GetAuth:fhandle,",244.0,0.2881651242574056,MHM
18,"static ssize_t show_ibdev(struct device *dev, struct device_attribute *attr,
			  char *buf)
{
	struct ib_ucm_device *ucm_dev;

	ucm_dev = container_of(dev, struct ib_ucm_device, dev);
	return sprintf(buf, ""%s\n"", ucm_dev->ib_dev->name);
}
","static ssize_t release_sock(Ai_view device *prep, Ai_view device_attribute *attr,
			  char *phar_hex_str)
{
	Ai_view unicode_att *dsap_field;

	dsap_field = umin_val(prep, Ai_view unicode_att, prep);
	return mask_(phar_hex_str, ""%s\n"", dsap_field->ib_dev->name);
}
",53.0,14.0,"struct:Ai_view,sprintf:mask_,ib_ucm_device:unicode_att,dev:prep,container_of:umin_val,show_ibdev:release_sock,buf:phar_hex_str,ucm_dev:dsap_field,",396.0,0.3453921914100647,MHM
19,"bool SocketStream::is_secure() const {
  return url_.SchemeIs(""wss"");
 }
","bool SocketStream::cdf_property_info_t() const {
  return url_.SchemeIs(""wss"");
 }
",18.0,2.0,"is_secure:cdf_property_info_t,",32.0,0.0273063619931538,MHM
21,"void setSerifFontFamilyWrapper(WebSettings* settings,
                               const string16& font,
                               UScriptCode script) {
  settings->setSerifFontFamily(font, script);
}
","void setSerifFontFamilyWrapper(WebSettings* rate,
                               const string16& byteptr,
                               UScriptCode pdu) {
  rate->setSerifFontFamily(byteptr, pdu);
}
",26.0,7.0,"settings:rate,script:pdu,font:byteptr,",154.0,0.1317129731178283,MHM
22," void GpuVideoDecodeAccelerator::OnDecode(
    base::SharedMemoryHandle handle, int32 id, int32 size) {
   DCHECK(video_decode_accelerator_.get());
   video_decode_accelerator_->Decode(media::BitstreamBuffer(id, handle, size));
 }
"," void GpuVideoDecodeAccelerator::dstBufferSize(
    base::SharedMemoryHandle RED, int32 id, int32 SUPPORT_TLS) {
   err_desc(video_decode_accelerator_.get());
   video_decode_accelerator_->Decode(media::Sys_ListFiles(id, RED, SUPPORT_TLS));
 }
",43.0,11.0,"BitstreamBuffer:Sys_ListFiles,OnDecode:dstBufferSize,DCHECK:err_desc,size:SUPPORT_TLS,handle:RED,",274.0,0.2757416804631551,MHM
27,"status_t Parcel::readPointer(uintptr_t *pArg) const
{
 status_t ret;
 binder_uintptr_t ptr;
    ret = readAligned(&ptr);
 if (!ret)
 *pArg = ptr;
 return ret;
}
","status_t Parcel::readPointer(uintptr_t *display) const
{
 status_t ret;
 binder_uintptr_t ptr;
    ret = GSS_C_NO_OID(&ptr);
 if (!ret)
 *display = ptr;
 return ret;
}
",39.0,11.0,"pArg:display,readAligned:GSS_C_NO_OID,",63.0,0.0653983195622762,MHM
35,"void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;

	mutex_lock(&local->sta_mtx);

	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;

		if (time_after(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM\n"",
				sta->sta.addr);

			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);

			WARN_ON(__sta_info_destroy(sta));
		}
	}

	mutex_unlock(&local->sta_mtx);
}
","void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long ohci)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *valuelen, *tmp;

	bracket(&local->sta_mtx);

	ssh(valuelen, tmp, &local->sta_list, list) {
		if (sdata != valuelen->sdata)
			continue;

		if (time_after(len, valuelen->last_rx + ohci)) {
			user(valuelen->sdata, ""expiring inactive STA %pM\n"",
				valuelen->valuelen.addr);

			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(valuelen, WLAN_STA_PS_STA))
				vpx_internal_error(&sdata->u.mesh.ps.num_sta_ps);

			lock(__sta_info_destroy(valuelen));
		}
	}

	dnaddr_string(&local->sta_mtx);
}
",144.0,35.0,"sta_dbg:user,WARN_ON:lock,exp_time:ohci,list_for_each_entry_safe:ssh,mutex_unlock:dnaddr_string,jiffies:len,atomic_dec:vpx_internal_error,mutex_lock:bracket,sta:valuelen,",335.0,0.4141282637914021,MHM
38," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
"," void ServiceWorkerPaymentInstrument::ZEND_FETCH_RESOURCE(
     mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
",42.0,9.0,"OnPaymentAppInvoked:ZEND_FETCH_RESOURCE,",33.0,0.0342106461524963,MHM
44,"void V8TestObject::DoubleAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), ""Blink_TestObject_doubleAttribute_Getter"");

  test_object_v8_internal::DoubleAttributeAttributeGetter(info);
}
","void V8TestObject::LDST(const v8::FunctionCallbackInfo<v8::Value>& php_stream_close) {
  xww(php_stream_close.GetIsolate(), ""Blink_TestObject_doubleAttribute_Getter"");

  test_object_v8_internal::pitchCents(php_stream_close);
}
",38.0,6.0,"info:php_stream_close,RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT:xww,DoubleAttributeAttributeGetter:pitchCents,DoubleAttributeAttributeGetterCallback:LDST,",364.0,0.3832014679908752,MHM
46,"struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,
			     gfp_t priority)
{
	if (force || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, priority);
		if (skb) {
			skb_set_owner_w(skb, sk);
			return skb;
		}
	}
	return NULL;
}
","struct sk_buff *php_var_unserialize(struct sock *sk, unsigned long size, int force,
			     gfp_t netbk)
{
	if (force || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, netbk);
		if (skb) {
			zpath(skb, sk);
			return skb;
		}
	}
	return NULL;
}
",71.0,18.0,"sock_wmalloc:php_var_unserialize,priority:netbk,skb_set_owner_w:zpath,",154.0,0.1895893255869547,MHM
47,"status_t OMXNodeInstance::getConfig(

         OMX_INDEXTYPE index, void *params, size_t /* size */) {
     Mutex::Autolock autoLock(mLock);
 
     OMX_ERRORTYPE err = OMX_GetConfig(mHandle, index, params);
     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;
 if (err != OMX_ErrorNoMore) {
        CLOG_IF_ERROR(getConfig, err, ""%s(%#x)"", asString(extIndex), index);
 }
 return StatusFromOMXError(err);
}
","status_t OMXNodeInstance::getConfig(

         OMX_INDEXTYPE index, void *params, size_t /* size */) {
     Mutex::Autolock autoLock(mLock);
 
     OMX_ERRORTYPE err = ext_off(frame_, index, params);
     OMX_INDEXEXTTYPE vp = (OMX_INDEXEXTTYPE)index;
 if (err != OMX_ErrorNoMore) {
        notifyFillBufferDone(getConfig, err, ""%s(%#x)"", asString(vp), index);
 }
 return doctypePublic(err);
}
",75.0,21.0,"CLOG_IF_ERROR:notifyFillBufferDone,mHandle:frame_,OMX_GetConfig:ext_off,StatusFromOMXError:doctypePublic,extIndex:vp,",215.0,0.2599587599436442,MHM
53,"extern ""C"" void RIL_setcallbacks (const RIL_RadioFunctions *callbacks) {
    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));
}
","extern ""C"" void SplFileObject (const atom *callbacks) {
    memcpy(&s_callbacks, callbacks, sizeof (atom));
}
",26.0,6.0,"RIL_RadioFunctions:atom,RIL_setcallbacks:SplFileObject,",62.0,0.0477760831514994,MHM
54,"inline void PulseAudioMixer::MainloopLock() const {
   pa_threaded_mainloop_lock(pa_mainloop_);
   ++mainloop_lock_count_;
 }
","inline void PulseAudioMixer::description() const {
   TRACE(debug_logging_mode);
   ++render;
 }
",18.0,4.0,"pa_threaded_mainloop_lock:TRACE,MainloopLock:description,mainloop_lock_count_:render,pa_mainloop_:debug_logging_mode,",336.0,0.3196063200632731,MHM
77,"  CacheThread() : base::Thread(""CacheThread_BlockFile"") {
    CHECK(
        StartWithOptions(base::Thread::Options(base::MessageLoop::TYPE_IO, 0)));
  }
","  CacheThread() : base::Thread(""CacheThread_BlockFile"") {
    CHECK(
        PNG_READ_ALPHA_MODE_SUPPORTED(base::Thread::Options(base::MessageLoop::TYPE_IO, 0)));
  }
",34.0,5.0,"StartWithOptions:PNG_READ_ALPHA_MODE_SUPPORTED,",31.0,0.0259995381037394,MHM
88,"dns_resolver_match(const struct key *key,
		   const struct key_match_data *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = key->description, *dsp = match_data->raw_data;

	kenter(""%s,%s"", src, dsp);

	if (!src || !dsp)
		goto no_match;

	if (strcasecmp(src, dsp) == 0)
		goto matched;

	slen = strlen(src);
	dlen = strlen(dsp);
	if (slen <= 0 || dlen <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (dsp[dlen - 1] == '.')
		dlen--;
	if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
		goto no_match;

matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }
","IVD_ERROR_NONE(const struct key *key,
		   const struct key_match_data *match_data)
 {
 	int slen, x2, ret = 0;
 	const char *src = key->description, *twothirds_twothirds2 = match_data->raw_data;

	kenter(""%s,%s"", src, twothirds_twothirds2);

	if (!src || !twothirds_twothirds2)
		goto no_match;

	if (strcasecmp(src, twothirds_twothirds2) == 0)
		goto matched;

	slen = strlen(src);
	x2 = strlen(twothirds_twothirds2);
	if (slen <= 0 || x2 <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (twothirds_twothirds2[x2 - 1] == '.')
		x2--;
	if (slen != x2 || strncasecmp(src, twothirds_twothirds2, slen) != 0)
		goto no_match;

matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }
",172.0,42.0,"dns_resolver_match:IVD_ERROR_NONE,dsp:twothirds_twothirds2,dlen:x2,",94.0,0.1271751006444295,MHM
90,"error_detected(uint32_t errnum, char *errstr, ...)
{
    va_list args;

    va_start(args, errstr);

    {
        TSK_ERROR_INFO *errInfo = tsk_error_get_info();
        char *loc_errstr = errInfo->errstr;

        if (errInfo->t_errno == 0)
            errInfo->t_errno = errnum;
        else {
            size_t sl = strlen(errstr);
            snprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                "" Next errnum: 0x%x "", errnum);
        }
        if (errstr != NULL) {
            size_t sl = strlen(loc_errstr);
            vsnprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                errstr, args);
        }
    }

    va_end(args);

}
","error_detected(uint32_t errnum, char *errstr, ...)
{
    va_list args;

    va_start(args, errstr);

    {
        TSK_ERROR_INFO *INT64_T_FORMAT = tsk_error_get_info();
        char *loc_errstr = INT64_T_FORMAT->errstr;

        if (INT64_T_FORMAT->t_errno == 0)
            INT64_T_FORMAT->t_errno = errnum;
        else {
            size_t GSS_C_NO_BUFFER = fhash(errstr);
            snprintf(loc_errstr + GSS_C_NO_BUFFER, i4_cur_row - GSS_C_NO_BUFFER,
                "" Next errnum: 0x%x "", errnum);
        }
        if (errstr != NULL) {
            size_t GSS_C_NO_BUFFER = fhash(loc_errstr);
            vsnprintf(loc_errstr + GSS_C_NO_BUFFER, i4_cur_row - GSS_C_NO_BUFFER,
                errstr, args);
        }
    }

    resno(args);

}
",118.0,36.0,"va_end:resno,TSK_ERROR_STRING_MAX_LENGTH:i4_cur_row,strlen:fhash,sl:GSS_C_NO_BUFFER,errInfo:INT64_T_FORMAT,",151.0,0.1852727055549621,MHM
91,"static int rfcomm_sock_create(struct net *net, struct socket *sock,
			      int protocol, int kern)
{
	struct sock *sk;

	BT_DBG(""sock %p"", sock);

	sock->state = SS_UNCONNECTED;

	if (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)
		return -ESOCKTNOSUPPORT;

	sock->ops = &rfcomm_sock_ops;

	sk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC);
	if (!sk)
		return -ENOMEM;

	rfcomm_sock_init(sk, NULL);
	return 0;
}
","static int rfcomm_sock_create(struct net *net, struct socket *sock,
			      int protocol, int PNG_COLOR_TYPE_RGB)
{
	struct sock *sk;

	BT_DBG(""sock %p"", sock);

	sock->state = SS_UNCONNECTED;

	if (sock->type != pm && sock->type != SOCK_RAW)
		return -ESOCKTNOSUPPORT;

	sock->ops = &rfcomm_sock_ops;

	sk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC);
	if (!sk)
		return -ENOMEM;

	rfcomm_sock_init(sk, NULL);
	return 0;
}
",98.0,27.0,"SOCK_STREAM:pm,kern:PNG_COLOR_TYPE_RGB,",63.0,0.0665417551994323,MHM
93," SPL_METHOD(RecursiveDirectoryIterator, getSubPath)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}

	if (intern->u.dir.sub_path) {
		RETURN_STRINGL(intern->u.dir.sub_path, intern->u.dir.sub_path_len, 1);
	} else {
		RETURN_STRINGL("""", 0, 1);
	}
}
"," SPL_METHOD(jspSetNoExecute, scriptState)
 {
 	spl_filesystem_object *pu4_bitstrm_ofst = (spl_filesystem_object*)die(getPortQueue() type_flags);
 	if (readonly() == bitmap) {
 		return;
 	}

	if (pu4_bitstrm_ofst->u.dir.sub_path) {
		ipv4_is_multicast(pu4_bitstrm_ofst->u.dir.sub_path, pu4_bitstrm_ofst->u.dir.sub_path_len, 1);
	} else {
		ipv4_is_multicast("""", 0, 1);
	}
}
",82.0,14.0,"RecursiveDirectoryIterator:jspSetNoExecute,RETURN_STRINGL:ipv4_is_multicast,getSubPath:scriptState,zend_parse_parameters_none:readonly,getThis:getPortQueue,FAILURE:bitmap,intern:pu4_bitstrm_ofst,zend_object_store_get_object:die,TSRMLS_CC:type_flags,",486.0,0.5640575607617696,MHM
96," static int inotify_release(struct inode *ignored, struct file *file)
 {
 	struct fsnotify_group *group = file->private_data;
	struct user_struct *user = group->inotify_data.user;
 
 	pr_debug(""%s: group=%p\n"", __func__, group);
 
	fsnotify_clear_marks_by_group(group);

 	/* free this group, matching get was inotify_init->fsnotify_obtain_group */
 	fsnotify_put_group(group);
 
	atomic_dec(&user->inotify_devs);
 	return 0;
 }
"," static int inotify_release(struct inode *ignored, struct file *file)
 {
 	struct fsnotify_group *cmds = file->private_data;
	struct user_struct *mVideoHeight = cmds->inotify_data.mVideoHeight;
 
 	from_path(""%s: group=%p\n"", __func__, cmds);
 
	lhs(cmds);

 	/* free this group, matching get was inotify_init->fsnotify_obtain_group */
 	fsnotify_put_group(cmds);
 
	atomic_dec(&mVideoHeight->inotify_devs);
 	return 0;
 }
",68.0,16.0,"user:mVideoHeight,pr_debug:from_path,fsnotify_clear_marks_by_group:lhs,group:cmds,",123.0,0.1460609475771586,MHM
98,"  static void UpdatePropertyCallback(IBusPanelService* panel,
                                     IBusProperty* ibus_prop,
                                     gpointer user_data) {
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->UpdateProperty(ibus_prop);
   }
","  static void dff_file_header(IBusPanelService* head,
                                     IBusProperty* element_start,
                                     gpointer OIDC_CSRF_NAME) {
    nLen(OIDC_CSRF_NAME);
    InputMethodStatusConnection* pflags
        = static_cast<InputMethodStatusConnection*>(OIDC_CSRF_NAME);
    pflags->UpdateProperty(element_start);
   }
",42.0,11.0,"user_data:OIDC_CSRF_NAME,ibus_prop:element_start,panel:head,UpdatePropertyCallback:dff_file_header,g_return_if_fail:nLen,self:pflags,",277.0,0.2985335191090901,MHM
101,"void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}
","void AffineTransform::cCipher(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}
",88.0,11.0,"recompose:cCipher,",33.0,0.0489838242530822,MHM
105,"void InspectorTraceEvents::Did(const probe::ParseHTML& probe) {
  TRACE_EVENT_END1(
      ""devtools.timeline"", ""ParseHTML"", ""endData"",
      InspectorParseHtmlEndData(probe.parser->LineNumber().ZeroBasedInt() - 1));
  TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""),
                       ""UpdateCounters"", TRACE_EVENT_SCOPE_THREAD, ""data"",
                       InspectorUpdateCountersEvent::Data());
}
","void InspectorTraceEvents::atomic_read(const GFP_ATOMIC::ParseHTML& GFP_ATOMIC) {
  TRACE_EVENT_END1(
      ""devtools.timeline"", ""ParseHTML"", ""endData"",
      sep(GFP_ATOMIC.parser->LineNumber().ZeroBasedInt() - 1));
  zval_ptr_dtor(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""),
                       ""UpdateCounters"", lex, ""data"",
                       InspectorUpdateCountersEvent::MagickSignature());
}
",66.0,9.0,"InspectorParseHtmlEndData:sep,Did:atomic_read,probe:GFP_ATOMIC,TRACE_EVENT_SCOPE_THREAD:lex,Data:MagickSignature,TRACE_EVENT_INSTANT1:zval_ptr_dtor,",278.0,0.3449337045351664,MHM
106,"bool ChromeClientImpl::AcceptsLoadDrops() const {
  return !web_view_->Client() || web_view_->Client()->AcceptsLoadDrops();
}
","bool ChromeClientImpl::msg_tptr() const {
  return !m_pInput_ion->Client() || m_pInput_ion->Client()->msg_tptr();
}
",27.0,3.0,"AcceptsLoadDrops:msg_tptr,web_view_:m_pInput_ion,",123.0,0.1470757603645324,MHM
108,"static double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)
 {
    /* Absolute error permitted in linear values - affected by the bit depth of
     * the calculations.
    */
 if (pm->assume_16_bit_calculations ||
 (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)
 return pm->maxabs16;
 else

       return pm->maxabs8;
 }
","static double body(PNG_CONST der *xmlGenericErrorContext, int nla_put_u32, int out_depth)
 {
    /* Absolute error permitted in linear values - affected by the bit depth of
     * the calculations.
    */
 if (xmlGenericErrorContext->assume_16_bit_calculations ||
 (xmlGenericErrorContext->calculations_use_input_precision ? nla_put_u32 : out_depth) == 16)
 return xmlGenericErrorContext->maxabs16;
 else

       return xmlGenericErrorContext->maxabs8;
 }
",46.0,11.0,"abserr:body,png_modifier:der,pm:xmlGenericErrorContext,in_depth:nla_put_u32,",187.0,0.2581962744394938,MHM
109," static inline void sem_getref_and_unlock(struct sem_array *sma)
 {
	ipc_rcu_getref(sma);
	ipc_unlock(&(sma)->sem_perm);
 }
"," static inline void configData(struct sem_array *sma)
 {
	ipc_rcu_getref(sma);
	ipc_unlock(&(sma)->sem_perm);
 }
",27.0,6.0,"sem_getref_and_unlock:configData,",31.0,0.0337730725606282,MHM
111,"void drop_privileges(char *username) {
	struct passwd *user = (struct passwd *) getpwnam(username);
	if (user == NULL) {
		fprintf(stderr, _(""Failed dropping privileges. The user %s is not a valid username on local system.\n""), username);
		exit(1);
	}
	if (getuid() == 0) {
		/* process is running as root, drop privileges */
		if (setgid(user->pw_gid) != 0) {
			fprintf(stderr, _(""setgid: Error dropping group privileges\n""));
			exit(1);
		}
		if (setuid(user->pw_uid) != 0) {
			fprintf(stderr, _(""setuid: Error dropping user privileges\n""));
			exit(1);
		}
		/* Verify if the privileges were developed. */
		if (setuid(0) != -1) {
			fprintf(stderr, _(""Failed to drop privileges\n""));
			exit(1);
		}
	}
}
","void dc_diff(char *SEP_CHAR_SELECTED) {
	struct passwd *stats_drift_file = (struct passwd *) AF_INET(SEP_CHAR_SELECTED);
	if (stats_drift_file == NULL) {
		fprintf(stderr, _(""Failed dropping privileges. The user %s is not a valid username on local system.\n""), SEP_CHAR_SELECTED);
		xsltTransformError(1);
	}
	if (icmp_mpls_ext_object_header() == 0) {
		/* process is running as root, drop privileges */
		if (opt_type(stats_drift_file->pw_gid) != 0) {
			fprintf(stderr, _(""setgid: Error dropping group privileges\n""));
			xsltTransformError(1);
		}
		if (setuid(stats_drift_file->pw_uid) != 0) {
			fprintf(stderr, _(""setuid: Error dropping user privileges\n""));
			xsltTransformError(1);
		}
		/* Verify if the privileges were developed. */
		if (setuid(0) != -1) {
			fprintf(stderr, _(""Failed to drop privileges\n""));
			xsltTransformError(1);
		}
	}
}
",149.0,29.0,"username:SEP_CHAR_SELECTED,getpwnam:AF_INET,setgid:opt_type,drop_privileges:dc_diff,getuid:icmp_mpls_ext_object_header,user:stats_drift_file,exit:xsltTransformError,",270.0,0.370240306854248,MHM
113,"void TaskManagerHandler::HandleActivatePage(const ListValue* unique_ids) {
  for (ListValue::const_iterator i = unique_ids->begin();
       i != unique_ids->end(); ++i) {
    int unique_id = parseIndex(*i);
    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);
    if (resource_index == -1)
      continue;

    task_manager_->ActivateProcess(resource_index);
    break;
  }
}
","void TaskManagerHandler::HandleActivatePage(const ListValue* unique_ids) {
  for (ListValue::const_iterator NPSTR = unique_ids->begin();
       NPSTR != unique_ids->end(); ++NPSTR) {
    int unique_id = parseIndex(*NPSTR);
    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);
    if (resource_index == -1)
      continue;

    task_manager_->ActivateProcess(resource_index);
    break;
  }
}
",74.0,16.0,"i:NPSTR,",32.0,0.0232732772827148,MHM
114,"TestBrowserWindow::~TestBrowserWindow() {}
","params_::~params_() {}
",8.0,1.0,"TestBrowserWindow:params_,",63.0,0.0450130661328633,MHM
117,"const char* Track::GetLanguage() const
{
    return m_info.language;
}
","const char* Track::MagickMax() const
{
    return eprintf.language;
}
",16.0,2.0,"m_info:eprintf,GetLanguage:MagickMax,",62.0,0.0809087435404459,MHM
118,"static void write_exception(struct pstore *ps,
			    uint32_t index, struct core_exception *e)
{
	struct disk_exception *de = get_exception(ps, index);

	/* copy it */
	de->old_chunk = cpu_to_le64(e->old_chunk);
	de->new_chunk = cpu_to_le64(e->new_chunk);
}
","static void write_exception(struct pstore *ps,
			    uint32_t index, struct core_exception *e)
{
	struct disk_exception *gss_release_buffer = get_exception(ps, index);

	/* copy it */
	gss_release_buffer->old_chunk = cpu_to_le64(e->old_chunk);
	gss_release_buffer->new_chunk = cpu_to_le64(e->new_chunk);
}
",53.0,14.0,"de:gss_release_buffer,",33.0,0.0440543929735819,MHM
122,"xmlPopInput(xmlParserCtxtPtr ctxt) {
 if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);
 if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
 ""Popping input %d\n"", ctxt->inputNr);
    xmlFreeInputStream(inputPop(ctxt));
 if ((*ctxt->input->cur == 0) &&
 (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))
 return(xmlPopInput(ctxt));
 return(CUR);
}
","xmlPopInput(xmlParserCtxtPtr data_size) {
 if ((data_size == NULL) || (data_size->inputNr <= 1)) return(0);
 if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
 ""Popping input %d\n"", data_size->inputNr);
    xmlFreeInputStream(inputPop(data_size));
 if ((*data_size->input->cur == 0) &&
 (xmlParserInputGrow(data_size->input, INPUT_CHUNK) <= 0))
 return(xmlPopInput(data_size));
 return(CUR);
}
",92.0,18.0,"ctxt:data_size,",34.0,0.0467228372891743,MHM
128,"static int l2tp_ip6_backlog_recv(struct sock *sk, struct sk_buff *skb)
{
	int rc;

	/* Charge it to the socket, dropping if the queue is full. */
	rc = sock_queue_rcv_skb(sk, skb);
	if (rc < 0)
		goto drop;

	return 0;

drop:
	IP_INC_STATS(&init_net, IPSTATS_MIB_INDISCARDS);
	kfree_skb(skb);
	return -1;
}
","static int end(struct sock *dec_hdl, struct sk_buff *channel)
{
	int rc;

	/* Charge it to the socket, dropping if the queue is full. */
	rc = FROM_SPS_TO_PP_SF(dec_hdl, channel);
	if (rc < 0)
		goto drop;

	return 0;

drop:
	put_page(&init_net, IPSTATS_MIB_INDISCARDS);
	kfree_skb(channel);
	return -1;
}
",58.0,14.0,"skb:channel,IP_INC_STATS:put_page,l2tp_ip6_backlog_recv:end,sk:dec_hdl,sock_queue_rcv_skb:FROM_SPS_TO_PP_SF,",185.0,0.2174148837725321,MHM
132,"SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )
{
    SQLWCHAR *chr;
    int len = 0;
 
     if ( !in )
     {
        return in;
     }
     
     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        len ++;
    }

    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));

    len = 0;
    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        chr[ len ] = in[ len ];
        len ++;
    }
    chr[ len ++ ] = 0;
    chr[ len ++ ] = 0;

    return chr;
}
","child_set_env* uid( LPCSTR tcpport_string )
{
    child_set_env *OFPPROP_LOG;
    int len = 0;
 
     if ( !tcpport_string )
     {
        return tcpport_string;
     }
     
     while ( tcpport_string[ len ] != 0 || tcpport_string[ len + 1 ] != 0 )
    {
        len ++;
    }

    OFPPROP_LOG = AV_LOG_ERROR(sizeof( child_set_env ) * ( len + 2 ));

    len = 0;
    while ( tcpport_string[ len ] != 0 || tcpport_string[ len + 1 ] != 0 )
    {
        OFPPROP_LOG[ len ] = tcpport_string[ len ];
        len ++;
    }
    OFPPROP_LOG[ len ++ ] = 0;
    OFPPROP_LOG[ len ++ ] = 0;

    return OFPPROP_LOG;
}
",123.0,30.0,"malloc:AV_LOG_ERROR,_multi_string_alloc_and_expand:uid,chr:OFPPROP_LOG,SQLWCHAR:child_set_env,in:tcpport_string,",278.0,0.3587828516960144,MHM
133," OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	(void)s;
 	if (sp->libjpeg_jpeg_query_style==0)
 	{
 		if (OJPEGDecodeRaw(tif,buf,cc)==0)
			return(0);
	}
	else
	{
		if (OJPEGDecodeScanlines(tif,buf,cc)==0)
			return(0);
	}
	return(1);
}
"," last_alias(TIFF* tif, uint8* CopyTag, tmsize_t cc, uint16 init_ctx)
 {
 	OJPEGState* outrow=(OJPEGState*)tif->tif_data;
 	(void)init_ctx;
 	if (outrow->libjpeg_jpeg_query_style==0)
 	{
 		if (s_dec_op(tif,CopyTag,cc)==0)
			return(0);
	}
	else
	{
		if (OJPEGDecodeScanlines(tif,CopyTag,cc)==0)
			return(0);
	}
	return(1);
}
",89.0,17.0,"sp:outrow,s:init_ctx,buf:CopyTag,OJPEGDecode:last_alias,OJPEGDecodeRaw:s_dec_op,",275.0,0.3203856825828552,MHM
134," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
"," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, PNG_COLOR_TYPE_RGB;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(lmp_com_header<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(lmp_com_header<int32_t>(format));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &PNG_COLOR_TYPE_RGB);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
",117.0,31.0,"static_cast:lmp_com_header,reply:PNG_COLOR_TYPE_RGB,",63.0,0.0750198165575663,MHM
144,"void page_put_link(void *arg)
{
	put_page(arg);
}
","void fd_ptr(void *smartData)
{
	put_page(smartData);
}
",14.0,4.0,"arg:smartData,page_put_link:fd_ptr,",64.0,0.0688416878382364,MHM
145,"base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {
  base::FilePath user_data_dir;
  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
  DCHECK(!user_data_dir.empty());
  return user_data_dir.Append(FILE_PATH_LITERAL(""ShaderCache""));
}
","base::FilePath ChromeContentBrowserClient::gtk_box_pack_start() {
  base::FilePath user_data_dir;
  base::PathService::prop(chrome::fz_xml_tag, &user_data_dir);
  DCHECK(!user_data_dir.empty());
  return user_data_dir.Append(conn(""ShaderCache""));
}
",51.0,9.0,"Get:prop,GetShaderDiskCacheDirectory:gtk_box_pack_start,FILE_PATH_LITERAL:conn,DIR_USER_DATA:fz_xml_tag,",243.0,0.2775798439979553,MHM
147,"ftp_readline(ftpbuf_t *ftp)
{
	long		size, rcvd;
	char		*data, *eol;

	/* shift the extra to the front */
	size = FTP_BUFSIZE;
	rcvd = 0;
	if (ftp->extra) {
		memmove(ftp->inbuf, ftp->extra, ftp->extralen);
		rcvd = ftp->extralen;
	}

	data = ftp->inbuf;

	do {
		size -= rcvd;
		for (eol = data; rcvd; rcvd--, eol++) {
			if (*eol == '\r') {
				*eol = 0;
				ftp->extra = eol + 1;
				if (rcvd > 1 && *(eol + 1) == '\n') {
					ftp->extra++;
					rcvd--;
				}
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			} else if (*eol == '\n') {
				*eol = 0;
				ftp->extra = eol + 1;
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			}
		}

		data = eol;
		if ((rcvd = my_recv(ftp, ftp->fd, data, size)) < 1) {
			return 0;
		}
	} while (size);

	return 0;
}
","RTLD_NODELETE(ftpbuf_t *ftp)
{
	long		rdf_xml_parser, rcvd;
	char		*primary_direction, *eol;

	/* shift the extra to the front */
	rdf_xml_parser = rmd;
	rcvd = 0;
	if (ftp->extra) {
		xp(ftp->inbuf, ftp->extra, ftp->extralen);
		rcvd = ftp->extralen;
	}

	primary_direction = ftp->inbuf;

	do {
		rdf_xml_parser -= rcvd;
		for (eol = primary_direction; rcvd; rcvd--, eol++) {
			if (*eol == '\r') {
				*eol = 0;
				ftp->extra = eol + 1;
				if (rcvd > 1 && *(eol + 1) == '\n') {
					ftp->extra++;
					rcvd--;
				}
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			} else if (*eol == '\n') {
				*eol = 0;
				ftp->extra = eol + 1;
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			}
		}

		primary_direction = eol;
		if ((rcvd = omode(ftp, ftp->fd, primary_direction, rdf_xml_parser)) < 1) {
			return 0;
		}
	} while (rdf_xml_parser);

	return 0;
}
",248.0,53.0,"my_recv:omode,size:rdf_xml_parser,FTP_BUFSIZE:rmd,data:primary_direction,memmove:xp,ftp_readline:RTLD_NODELETE,",336.0,0.4974691112836202,MHM
149,"static void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)
{
    bs->error = bs->sr = bs->bc = 0;
    bs->ptr = (bs->buf = buffer_start) - 1;
    bs->end = buffer_end;
    bs->wrap = bs_read;
}
","static void silent (Bitstream *try0, void *buffer_start, void *buffer_end)
{
    try0->error = try0->sr = try0->bc = 0;
    try0->ptr = (try0->buf = buffer_start) - 1;
    try0->end = buffer_end;
    try0->wrap = bs_read;
}
",58.0,14.0,"bs_open_read:silent,bs:try0,",62.0,0.0568954388300577,MHM
150,"vips_malloc( VipsObject *object, size_t size )
 {
 	void *buf;
 
	buf = g_malloc( size );
 
         if( object ) {
 		g_signal_connect( object, ""postclose"", 
			G_CALLBACK( vips_malloc_cb ), buf );
		object->local_memory += size;
	}

	return( buf );
}
","vips_malloc( VipsObject *object, size_t kNotSupportedError )
 {
 	void *ecalloc;
 
	ecalloc = g_malloc( kNotSupportedError );
 
         if( object ) {
 		g_signal_connect( object, ""postclose"", 
			G_CALLBACK( vips_malloc_cb ), ecalloc );
		object->local_memory += kNotSupportedError;
	}

	return( ecalloc );
}
",54.0,16.0,"size:kNotSupportedError,buf:ecalloc,",62.0,0.0728172540664672,MHM
152," void SynchronousCompositorImpl::PostInvalidate() {
   DCHECK(CalledOnValidThread());
   DCHECK(compositor_client_);
  compositor_client_->PostInvalidate();
 }
"," void SynchronousCompositorImpl::PostInvalidate() {
   DCHECK(CalledOnValidThread());
   DCHECK(sig);
  sig->PostInvalidate();
 }
",26.0,6.0,"compositor_client_:sig,",34.0,0.0332626700401306,MHM
160,"bool xmp_init()
{
     RESET_ERROR;
     try {
         bool result = SXMPFiles::Initialize(kXMPFiles_IgnoreLocalText);
         SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);
         return result;
        SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);
        return result;
    }
    catch (const XMP_Error &e) {
        set_error(e);
    }
    return false;
}
","bool xmp_init()
{
     RESET_ERROR;
     try {
         bool result = SXMPFiles::Initialize(cr);
         SXMPMeta::qualified(&rval, nullptr, 1);
         return result;
        SXMPMeta::qualified(&rval, nullptr, 1);
        return result;
    }
    catch (const XMP_Error &e) {
        set_error(e);
    }
    return false;
}
",68.0,14.0,"SetDefaultErrorCallback:qualified,kXMPFiles_IgnoreLocalText:cr,_xmp_error_callback:rval,",97.0,0.1107265353202819,MHM
166,"my_object_dict_of_dicts (MyObject *obj, GHashTable *in,
                                GHashTable **out, GError **error)
{
  *out = g_hash_table_new_full (g_str_hash, g_str_equal,
				(GDestroyNotify) g_free,
                                (GDestroyNotify) g_hash_table_destroy);
  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);
  return TRUE;
}
","mbedtls_ssl_send_alert_message (MyObject *service_id, GHashTable *prefixlen,
                                GHashTable **out, GError **CacheEvent)
{
  *out = g_hash_table_new_full (wdst, g_str_equal,
				(GDestroyNotify) g_free,
                                (GDestroyNotify) g_hash_table_destroy);
  g_hash_table_foreach (prefixlen, hash_foreach_mangle_dict_of_strings, *out);
  return TRUE;
}
",55.0,15.0,"obj:service_id,error:CacheEvent,g_str_hash:wdst,my_object_dict_of_dicts:mbedtls_ssl_send_alert_message,in:prefixlen,",304.0,0.3502238631248474,MHM
170,"gx_dc_colored_masked_get_dev_halftone(const gx_device_color * pdevc)
{
    return pdevc->colors.colored.c_ht;
}
","g_hash_table_size(const gx_device_color * packet_put_int)
{
    return packet_put_int->colors.colored.c_ht;
}
",18.0,3.0,"gx_dc_colored_masked_get_dev_halftone:g_hash_table_size,pdevc:packet_put_int,",63.0,0.0556591153144836,MHM
173,"static int nfs_idmap_read_and_verify_message(struct idmap_msg *im,
		struct idmap_msg *upcall,
		struct key *key, struct key *authkey)
{
	char id_str[NFS_UINT_MAXLEN];
	size_t len;
	int ret = -ENOKEY;

	/* ret = -ENOKEY */
	if (upcall->im_type != im->im_type || upcall->im_conv != im->im_conv)
		goto out;
	switch (im->im_conv) {
	case IDMAP_CONV_NAMETOID:
		if (strcmp(upcall->im_name, im->im_name) != 0)
			break;
		/* Note: here we store the NUL terminator too */
		len = sprintf(id_str, ""%d"", im->im_id) + 1;
		ret = nfs_idmap_instantiate(key, authkey, id_str, len);
		break;
	case IDMAP_CONV_IDTONAME:
		if (upcall->im_id != im->im_id)
			break;
		len = strlen(im->im_name);
		ret = nfs_idmap_instantiate(key, authkey, im->im_name, len);
		break;
	default:
		ret = -EINVAL;
	}
out:
	return ret;
}
","static int nfs_idmap_read_and_verify_message(struct idmap_msg *im,
		struct idmap_msg *upcall,
		struct key *key, struct key *authkey)
{
	char id_str[NFS_UINT_MAXLEN];
	size_t len;
	int ret = -ENOKEY;

	/* ret = -ENOKEY */
	if (upcall->im_type != im->im_type || upcall->im_conv != im->im_conv)
		goto out;
	switch (im->im_conv) {
	case rr:
		if (strcmp(upcall->im_name, im->im_name) != 0)
			break;
		/* Note: here we store the NUL terminator too */
		len = sprintf(id_str, ""%d"", im->im_id) + 1;
		ret = nfs_idmap_instantiate(key, authkey, id_str, len);
		break;
	case IDMAP_CONV_IDTONAME:
		if (upcall->im_id != im->im_id)
			break;
		len = strlen(im->im_name);
		ret = nfs_idmap_instantiate(key, authkey, im->im_name, len);
		break;
	default:
		ret = -EINVAL;
	}
out:
	return ret;
}
",174.0,44.0,"IDMAP_CONV_NAMETOID:rr,",35.0,0.0320769230524698,MHM
174,"ScreenLockLibrary* CrosLibrary::GetScreenLockLibrary() {
  return screen_lock_lib_.GetDefaultImpl(use_stub_impl_);
}
","ScreenLockLibrary* CrosLibrary::sfp() {
  return RelinquishMagickMemory.GetDefaultImpl(use_stub_impl_);
}
",17.0,3.0,"GetScreenLockLibrary:sfp,screen_lock_lib_:RelinquishMagickMemory,",184.0,0.1749160369237264,MHM
175,"bool BrowserCommandController::IsCommandEnabled(int id) const {
  return command_updater_.IsCommandEnabled(id);
}
","bool BrowserCommandController::MAYBE_MISSING_PARAMETER(int jspeUnaryExpression) const {
  return command_updater_.MAYBE_MISSING_PARAMETER(jspeUnaryExpression);
}
",19.0,4.0,"id:jspeUnaryExpression,IsCommandEnabled:MAYBE_MISSING_PARAMETER,",126.0,0.1149074832598368,MHM
179,"int WebContentsImpl::CreateOpenerRenderViewsForRenderManager(
    SiteInstance* instance) {
  if (!opener_)
    return MSG_ROUTING_NONE;

  return opener_->CreateOpenerRenderViews(instance);
}
","int WebContentsImpl::dport(
    SiteInstance* DecodedValue) {
  if (!png_memcpy)
    return MSG_ROUTING_NONE;

  return png_memcpy->CreateOpenerRenderViews(DecodedValue);
}
",27.0,6.0,"opener_:png_memcpy,CreateOpenerRenderViewsForRenderManager:dport,instance:DecodedValue,",244.0,0.2496550798416137,MHM
181,"getnetnum(
	const char *num,
	sockaddr_u *addr,
	int complain,
	enum gnn_type a_type	/* ignored */
	)
{
	NTP_REQUIRE(AF_UNSPEC == AF(addr) ||
		    AF_INET == AF(addr) ||
		    AF_INET6 == AF(addr));

	if (!is_ip_address(num, AF(addr), addr))
		return 0;

	if (IS_IPV6(addr) && !ipv6_works)
		return -1;

# ifdef ISC_PLATFORM_HAVESALEN
	addr->sa.sa_len = SIZEOF_SOCKADDR(AF(addr));
# endif
	SET_PORT(addr, NTP_PORT);

	DPRINTF(2, (""getnetnum given %s, got %s\n"", num, stoa(addr)));

	return 1;
}
","getnetnum(
	const char *num,
	sockaddr_u *int_in,
	int complain,
	enum gnn_type a_type	/* ignored */
	)
{
	NTP_REQUIRE(AF_UNSPEC == AF(int_in) ||
		    AF_INET == AF(int_in) ||
		    AF_INET6 == AF(int_in));

	if (!is_ip_address(num, AF(int_in), int_in))
		return 0;

	if (IS_IPV6(int_in) && !ipv6_works)
		return -1;

# ifdef ISC_PLATFORM_HAVESALEN
	int_in->sa.sa_len = SIZEOF_SOCKADDR(AF(int_in));
# endif
	SET_PORT(int_in, NTP_PORT);

	DPRINTF(2, (""getnetnum given %s, got %s\n"", num, stoa(int_in)));

	return 1;
}
",120.0,35.0,"addr:int_in,",33.0,0.0322945396105448,MHM
183,"void HTMLFormControlElement::AssociateWith(HTMLFormElement* form) {
  AssociateByParser(form);
}
","void HTMLFormControlElement::AssociateWith(HTMLFormElement* php_stream_read) {
  npobject(php_stream_read);
}
",16.0,4.0,"AssociateByParser:npobject,form:php_stream_read,",94.0,0.0772148410479227,MHM
188,"static inline void invalidate_cursor1(CirrusVGAState *s)
{
    if (s->last_hw_cursor_size) {
        vga_invalidate_scanlines(&s->vga,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);
    }
}
","static inline void invalidate_cursor1(CirrusVGAState *INT64_T_FORMAT)
{
    if (INT64_T_FORMAT->last_hw_cursor_size) {
        vga_invalidate_scanlines(&INT64_T_FORMAT->vga,
                                 INT64_T_FORMAT->last_hw_cursor_y + INT64_T_FORMAT->last_hw_cursor_y_start,
                                 INT64_T_FORMAT->last_hw_cursor_y + INT64_T_FORMAT->last_hw_cursor_y_end);
    }
}
",43.0,9.0,"s:INT64_T_FORMAT,",36.0,0.0328040242195129,MHM
192,"void PDFiumEngine::OnDocumentComplete() {
  if (!doc_ || !form_) {
    file_access_.m_FileLen = doc_loader_.document_size();
    if (!fpdf_availability_) {
      fpdf_availability_ = FPDFAvail_Create(&file_availability_, &file_access_);
      DCHECK(fpdf_availability_);
    }
    LoadDocument();
    return;
  }

  FinishLoadingDocument();
}
","void PDFiumEngine::OnDocumentComplete() {
  if (!ConstraintSpace || !PAGE_SHIFT) {
    u4_lev_suffix.m_FileLen = doc_loader_.document_size();
    if (!section) {
      section = component_start(&input_photometric, &u4_lev_suffix);
      S64_MIN(section);
    }
    rfv();
    return;
  }

  inc();
}
",61.0,14.0,"FinishLoadingDocument:inc,FPDFAvail_Create:component_start,form_:PAGE_SHIFT,DCHECK:S64_MIN,LoadDocument:rfv,file_availability_:input_photometric,fpdf_availability_:section,doc_:ConstraintSpace,file_access_:u4_lev_suffix,",429.0,0.4433714787165324,MHM
193,"RenderThreadImpl::HostAllocateSharedMemoryBuffer(size_t size) {
  return ChildThreadImpl::AllocateSharedMemory(size);
}
","RenderThreadImpl::mutex_init(size_t delim) {
  return ChildThreadImpl::ETH_P_IP(delim);
}
",17.0,4.0,"HostAllocateSharedMemoryBuffer:mutex_init,AllocateSharedMemory:ETH_P_IP,size:delim,",331.0,0.3039235552151998,MHM
195,"bool BrowserView::HasClientEdge() const {
  return frame()->GetFrameView()->HasClientEdge();
}
","bool BrowserView::HAVE_CYGWIN() const {
  return ih264d_signal_decode_thread()->GetFrameView()->HAVE_CYGWIN();
}
",22.0,2.0,"frame:ih264d_signal_decode_thread,HasClientEdge:HAVE_CYGWIN,",187.0,0.1606959303220113,MHM
198,"bool FlagsState::IsRestartNeededToCommitChanges() {
  return needs_restart_;
}
","bool FlagsState::MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER() {
  return pairing_delegate_;
}
",11.0,2.0,"IsRestartNeededToCommitChanges:MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER,needs_restart_:pairing_delegate_,",96.0,0.0666754166285197,MHM
200,"static const char *func_id_name(int id)
{
	BUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);

	if (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])
		return func_id_str[id];
	else
		return ""unknown"";
}
","static const char *mutex_lock(int parser)
{
	service_name(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);

	if (parser >= 0 && parser < __BPF_FUNC_MAX_ID && func_id_str[parser])
		return func_id_str[parser];
	else
		return ""unknown"";
}
",47.0,13.0,"func_id_name:mutex_lock,BUILD_BUG_ON:service_name,id:parser,",157.0,0.1508643825848897,MHM
202,"void BackendImpl::CleanupCache() {
  DCHECK(background_queue_.BackgroundIsCurrentSequence());
  Trace(""Backend Cleanup"");
  eviction_.Stop();
  timer_.reset();

  if (init_) {
    StoreStats();
    if (data_)
      data_->header.crash = 0;

    if (user_flags_ & kNoRandom) {
      File::WaitForPendingIO(&num_pending_io_);
      DCHECK(!num_refs_);
    } else {
      File::DropPendingIO();
    }
  }
  block_files_.CloseFiles();
  FlushIndex();
  index_ = NULL;
  ptr_factory_.InvalidateWeakPtrs();
  done_.Signal();
}
","void BackendImpl::CleanupCache() {
  DCHECK(FROM_PPS_TO_PP_PF.BackgroundIsCurrentSequence());
  Trace(""Backend Cleanup"");
  eviction_.Stop();
  timer_.reset();

  if (init_) {
    StoreStats();
    if (data_)
      data_->header.crash = 0;

    if (user_flags_ & kNoRandom) {
      File::WaitForPendingIO(&num_pending_io_);
      DCHECK(!num_refs_);
    } else {
      File::DropPendingIO();
    }
  }
  block_files_.CloseFiles();
  USE();
  index_ = NULL;
  u1_mb_idx.InvalidateWeakPtrs();
  done_.Signal();
}
",114.0,22.0,"ptr_factory_:u1_mb_idx,FlushIndex:USE,background_queue_:FROM_PPS_TO_PP_PF,",92.0,0.1073419491449991,MHM
203,"xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, ""%s"", msg);
 if (ctxt != NULL) {
	ctxt->wellFormed = 0;
 if (ctxt->recovery == 0)
	    ctxt->disableSAX = 1;
 }
}
","pSrc(xmlParserCtxtPtr client_config, xmlParserErrors int16_t,
 const char *BPF_MOD)
{
 if ((client_config != NULL) && (client_config->disableSAX != 0) &&
 (client_config->instate == XML_PARSER_EOF))
 return;
 if (client_config != NULL)
	client_config->errNo = int16_t;
    __xmlRaiseError(NULL, NULL, NULL, client_config, NULL, XML_FROM_PARSER, int16_t,
                    read_buff, NULL, 0, NULL, NULL, NULL, 0, 0, ""%s"", BPF_MOD);
 if (client_config != NULL) {
	client_config->wellFormed = 0;
 if (client_config->recovery == 0)
	    client_config->disableSAX = 1;
 }
}
",119.0,21.0,"msg:BPF_MOD,ctxt:client_config,error:int16_t,XML_ERR_FATAL:read_buff,xmlFatalErrMsg:pSrc,",278.0,0.3330597003300984,MHM
204,"bool  PrintWebViewHelper::PrintPreviewContext::IsFinalPageRendered() const {
  return static_cast<size_t>(current_page_index_) == pages_to_render_.size();
}
","bool  PrintWebViewHelper::PrintPreviewContext::la() const {
  return static_cast<size_t>(current_page_index_) == IS_CHAR.size();
}
",26.0,4.0,"pages_to_render_:IS_CHAR,IsFinalPageRendered:la,",64.0,0.0634559035301208,MHM
207,"static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)
{
	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
				struct vhost_scsi_tpg, se_tpg);
	struct vhost_scsi_tport *tport = tpg->tport;

	switch (tport->tport_proto_id) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_ISCSI:
		return iscsi_get_fabric_proto_ident(se_tpg);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			"" SAS emulation\n"", tport->tport_proto_id);
		break;
	}

	return sas_get_fabric_proto_ident(se_tpg);
}
","static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *code)
{
	struct vhost_scsi_tpg *tpg = container_of(code,
				struct vhost_scsi_tpg, code);
	struct vhost_scsi_tport *tport = tpg->tport;

	switch (tport->tport_proto_id) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(code);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(code);
	case SCSI_PROTOCOL_ISCSI:
		return iscsi_get_fabric_proto_ident(code);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			"" SAS emulation\n"", tport->tport_proto_id);
		break;
	}

	return sas_get_fabric_proto_ident(code);
}
",93.0,24.0,"se_tpg:code,",34.0,0.0387607296307881,MHM
208,"int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {
        int r;

        assert(p);
        assert(key);

        /* Checks if the specified packet is a reply for the specified
         * key and the specified key is the only one in the question
         * section. */

        if (DNS_PACKET_QR(p) != 1)
                return 0;

        /* Let's unpack the packet, if that hasn't happened yet. */
        r = dns_packet_extract(p);
         if (r < 0)
                 return r;
 
         if (p->question->n_keys != 1)
                 return 0;
 
        return dns_resource_key_equal(p->question->keys[0], key);
}
","int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *crm_info) {
        int r;

        assert(p);
        assert(crm_info);

        /* Checks if the specified packet is a reply for the specified
         * key and the specified key is the only one in the question
         * section. */

        if (DNS_PACKET_QR(p) != 1)
                return 0;

        /* Let's unpack the packet, if that hasn't happened yet. */
        r = dns_packet_extract(p);
         if (r < 0)
                 return r;
 
         if (p->question->n_keys != 1)
                 return 0;
 
        return dns_resource_key_equal(p->question->keys[0], crm_info);
}
",83.0,19.0,"key:crm_info,",33.0,0.0378544171651204,MHM
209,"ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC) /* {{{ */
{
	zval *property;

	if (ce->type & ZEND_INTERNAL_CLASS) {
		ALLOC_PERMANENT_ZVAL(property);
	} else {
		ALLOC_ZVAL(property);
	}
	INIT_PZVAL(property);
	ZVAL_DOUBLE(property, value);
	return zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);
}
/* }}} */
","ZEND_API int zend_declare_property_double(zend_class_entry *cdf_property_info_t, const char *name, int image_width, double value, int access_type R_ANAL_STACK_INC) /* {{{ */
{
	zval *property;

	if (cdf_property_info_t->type & ZEND_INTERNAL_CLASS) {
		sig(property);
	} else {
		ALLOC_ZVAL(property);
	}
	INIT_PZVAL(property);
	ZVAL_DOUBLE(property, value);
	return zend_declare_property(cdf_property_info_t, name, image_width, property, access_type TSRMLS_CC);
}
/* }}} */
",79.0,27.0,"TSRMLS_DC:R_ANAL_STACK_INC,name_length:image_width,ALLOC_PERMANENT_ZVAL:sig,ce:cdf_property_info_t,",155.0,0.1637246290842692,MHM
215,"static void srpt_cm_rep_error(struct ib_cm_id *cm_id)
{
	pr_info(""Received IB REP error for cm_id %p.\n"", cm_id);
	srpt_drain_channel(cm_id);
}
","static void open(struct ib_cm_id *current_time)
{
	pr_info(""Received IB REP error for cm_id %p.\n"", current_time);
	old_size(current_time);
}
",25.0,6.0,"srpt_cm_rep_error:open,srpt_drain_channel:old_size,cm_id:current_time,",186.0,0.2047275384267171,MHM
216,"void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

	if (*intersectLength == 0)
		*intersectStart = start1;
}
","void GetIntersection (uint64 start1, uint32 mTimeToSampleCount, uint64 start2, uint64 end2, uint64 *iso9660, uint32 *intersectLength)
{
	uint64 end1 = start1 + mTimeToSampleCount - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*iso9660 = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*iso9660 > intersectEnd) ? 0 : intersectEnd + 1 - *iso9660);

	if (*intersectLength == 0)
		*iso9660 = start1;
}
",96.0,29.0,"intersectStart:iso9660,length1:mTimeToSampleCount,",63.0,0.0630246599515279,MHM
218,"void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& baseURL, const BlackBerry::Platform::String& mimeType, const BlackBerry::Platform::String& failingURL)
{
    d->loadString(string, baseURL, mimeType, failingURL);
}
","void WebPage::read_u32(const BlackBerry::Platform::String& rdf_xml_parser, const BlackBerry::Platform::String& baseURL, const BlackBerry::Platform::String& line_color, const BlackBerry::Platform::String& EOPNOTSUPP)
{
    dfidp->read_u32(rdf_xml_parser, baseURL, line_color, EOPNOTSUPP);
}
",56.0,10.0,"mimeType:line_color,d:dfidp,failingURL:EOPNOTSUPP,loadString:read_u32,string:rdf_xml_parser,",184.0,0.1760591427485148,MHM
221,"mrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)
{
  struct RClass *s;
  struct RClass *c;

  if (!mrb_nil_p(super)) {
    if (mrb_type(super) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""superclass must be a Class (%S given)"",
                 mrb_inspect(mrb, super));
    }
    s = mrb_class_ptr(super);
  }
  else {
    s = 0;
  }
  check_if_class_or_module(mrb, outer);
  if (mrb_const_defined_at(mrb, outer, id)) {
    mrb_value old = mrb_const_get(mrb, outer, id);

    if (mrb_type(old) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""%S is not a class"", mrb_inspect(mrb, old));
    }
    c = mrb_class_ptr(old);
    if (s) {
      /* check super class */
      if (mrb_class_real(c->super) != s) {
        mrb_raisef(mrb, E_TYPE_ERROR, ""superclass mismatch for class %S"", old);
      }
    }
    return c;
  }
  c = define_class(mrb, id, s, mrb_class_ptr(outer));
  mrb_class_inherited(mrb, mrb_class_real(c->super), c);

  return c;
}
","mrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)
{
  struct RClass *s;
  struct RClass *c;

  if (!mrb_nil_p(super)) {
    if (mrb_type(super) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""superclass must be a Class (%S given)"",
                 mrb_inspect(mrb, super));
    }
    s = mrb_class_ptr(super);
  }
  else {
    s = 0;
  }
  check_if_class_or_module(mrb, outer);
  if (mrb_const_defined_at(mrb, outer, id)) {
    mrb_value old = CoderBlobSupportFlag(mrb, outer, id);

    if (mrb_type(old) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""%S is not a class"", mrb_inspect(mrb, old));
    }
    c = mrb_class_ptr(old);
    if (s) {
      /* check super class */
      if (mrb_class_real(c->super) != s) {
        mrb_raisef(mrb, E_TYPE_ERROR, ""superclass mismatch for class %S"", old);
      }
    }
    return c;
  }
  c = define_class(mrb, id, s, mrb_class_ptr(outer));
  tmp_subnodes(mrb, mrb_class_real(c->super), c);

  return c;
}
",213.0,68.0,"mrb_class_inherited:tmp_subnodes,mrb_const_get:CoderBlobSupportFlag,",59.0,0.0737031976381937,MHM
225,"static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)
	{
	int ret;
	
	clear_sys_error();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		/* ssl3_read_bytes decided to call s->handshake_func, which
		 * called ssl3_read_bytes to read handshake data.
		 * However, ssl3_read_bytes actually found application data
		 * and thinks that application data makes sense here; so disable
		 * handshake processing and try to read application data again. */
		s->in_handshake++;
		ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
		s->in_handshake--;
		}
	else
		s->s3->in_read_app_data=0;

	return(ret);
	}
","static int AFNUM_NSAP(SSL *dllhandle, void *buf, int len, int peek)
	{
	int success;
	
	sport();
	if (dllhandle->s3->renegotiate) cryptographer(dllhandle);
	dllhandle->s3->in_read_app_data=1;
	success=dllhandle->method->ssl_read_bytes(dllhandle,dj_report,buf,len,peek);
	if ((success == -1) && (dllhandle->s3->in_read_app_data == 2))
		{
		/* ssl3_read_bytes decided to call s->handshake_func, which
		 * called ssl3_read_bytes to read handshake data.
		 * However, ssl3_read_bytes actually found application data
		 * and thinks that application data makes sense here; so disable
		 * handshake processing and try to read application data again. */
		dllhandle->in_handshake++;
		success=dllhandle->method->ssl_read_bytes(dllhandle,dj_report,buf,len,peek);
		dllhandle->in_handshake--;
		}
	else
		dllhandle->s3->in_read_app_data=0;

	return(success);
	}
",130.0,31.0,"ret:success,s:dllhandle,clear_sys_error:sport,ssl3_read_internal:AFNUM_NSAP,SSL3_RT_APPLICATION_DATA:dj_report,ssl3_renegotiate_check:cryptographer,",279.0,0.2997885783513387,MHM
226,"aodv_extension(netdissect_options *ndo,
               const struct aodv_ext *ep, u_int length)
 {
 	const struct aodv_hello *ah;
 
 	switch (ep->type) {
 	case AODV_EXT_HELLO:
 		ah = (const struct aodv_hello *)(const void *)ep;
 		ND_TCHECK(*ah);
 		if (length < sizeof(struct aodv_hello))
 			goto trunc;
 		ND_PRINT((ndo, ""\n\text HELLO %ld ms"",
 		    (unsigned long)EXTRACT_32BITS(&ah->interval)));
 		break;

	default:
		ND_PRINT((ndo, ""\n\text %u %u"", ep->type, ep->length));
		break;
	}
	return;

trunc:
	ND_PRINT((ndo, "" [|hello]""));
}
","aodv_extension(netdissect_options *ndo,
               const struct aodv_ext *ep, u_int length)
 {
 	const struct aodv_hello *ah;
 
 	switch (ep->type) {
 	case AODV_EXT_HELLO:
 		ah = (const struct aodv_hello *)(const void *)ep;
 		ND_TCHECK(*ah);
 		if (length < sizeof(struct aodv_hello))
 			goto trunc;
 		hdev((ndo, ""\n\text HELLO %ld ms"",
 		    (unsigned long)EXTRACT_32BITS(&ah->interval)));
 		break;

	default:
		hdev((ndo, ""\n\text %u %u"", ep->type, ep->length));
		break;
	}
	return;

trunc:
	hdev((ndo, "" [|hello]""));
}
",132.0,22.0,"ND_PRINT:hdev,",32.0,0.0304165045420328,MHM
227,"void kvm_register_target_sys_reg_table(unsigned int target,
				       struct kvm_sys_reg_target_table *table)
{
	target_tables[target] = table;
}
","void bits_per_sample(unsigned int eol,
				       struct kvm_sys_reg_target_table *user_ns)
{
	cBuffer[eol] = user_ns;
}
",21.0,6.0,"table:user_ns,target:eol,target_tables:cBuffer,kvm_register_target_sys_reg_table:bits_per_sample,",273.0,0.2593505620956421,MHM
228," void DistillerNativeJavaScript::EnsureServiceConnected() {
  if (!distiller_js_service_) {
     render_frame_->GetServiceRegistry()->ConnectToRemoteService(
         mojo::GetProxy(&distiller_js_service_));
   }
 }
"," void DistillerNativeJavaScript::EnsureServiceConnected() {
  if (!qedi) {
     render_frame_->GetServiceRegistry()->ConnectToRemoteService(
         mojo::GetProxy(&qedi));
   }
 }
",32.0,5.0,"distiller_js_service_:qedi,",32.0,0.0301939805348714,MHM
229,"MagickExport void *RelinquishAlignedMemory(void *memory)
{
  if (memory == (void *) NULL)
    return((void *) NULL);
#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)
  free(memory);
#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)
  _aligned_free(memory);
#else
  free(*((void **) memory-1));
#endif
  return(NULL);
}
","MagickExport void *RelinquishAlignedMemory(void *INT64_T_FORMAT)
{
  if (INT64_T_FORMAT == (void *) NULL)
    return((void *) NULL);
#if defined(contents)
  free(INT64_T_FORMAT);
#elif defined(PHOTOMETRIC_YCBCR)
  _aligned_free(INT64_T_FORMAT);
#else
  free(*((void **) INT64_T_FORMAT-1));
#endif
  return(NULL);
}
",74.0,12.0,"MAGICKCORE_HAVE__ALIGNED_MALLOC:PHOTOMETRIC_YCBCR,MAGICKCORE_HAVE_POSIX_MEMALIGN:contents,memory:INT64_T_FORMAT,",124.0,0.1171273390452067,MHM
230,"bool effect_exists(effect_context_t *context)
{
 struct listnode *node;

    list_for_each(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 effects_list_node);
 if (fx_ctxt == context) {
 return true;
 }
 }
 return false;
}
","bool effect_exists(effect_context_t *context)
{
 struct listnode *nla_put_be32;

    list_for_each(nla_put_be32, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(nla_put_be32,
 effect_context_t,
                                                 effects_list_node);
 if (fx_ctxt == context) {
 return true;
 }
 }
 return false;
}
",51.0,13.0,"node:nla_put_be32,",33.0,0.0367014646530151,MHM
233,"bool WebGLRenderingContextBase::ValidateHTMLImageElement(
    const SecurityOrigin* security_origin,
    const char* function_name,
    HTMLImageElement* image,
    ExceptionState& exception_state) {
  if (!image || !image->CachedImage()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""no image"");
    return false;
  }
  const KURL& url = image->CachedImage()->GetResponse().Url();
  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""invalid image"");
    return false;
   }
 
   if (WouldTaintOrigin(image, security_origin)) {
    exception_state.ThrowSecurityError(""The cross-origin image at "" +
                                       url.ElidedString() +
                                       "" may not be loaded."");
     return false;
   }
   return true;
}
","bool WebGLRenderingContextBase::ValidateHTMLImageElement(
    const SecurityOrigin* security_origin,
    const char* function_name,
    HTMLImageElement* image,
    ExceptionState& exception_state) {
  if (!image || !image->CachedImage()) {
    idr(GL_INVALID_VALUE, function_name, ""no image"");
    return false;
  }
  const KURL& url = image->CachedImage()->GetResponse().Url();
  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {
    idr(GL_INVALID_VALUE, function_name, ""invalid image"");
    return false;
   }
 
   if (WouldTaintOrigin(image, security_origin)) {
    exception_state.ThrowSecurityError(""The cross-origin image at "" +
                                       url.ElidedString() +
                                       "" may not be loaded."");
     return false;
   }
   return true;
}
",141.0,23.0,"SynthesizeGLError:idr,",32.0,0.043702228864034,MHM
237,"void WebPage::removeCompositingThreadOverlay(WebOverlay* overlay)
{
#if USE(ACCELERATED_COMPOSITING)
    ASSERT(Platform::userInterfaceThreadMessageClient()->isCurrentThread());
    if (d->compositor())
        d->compositor()->removeOverlay(overlay->d->layerCompositingThread());
    overlay->d->clear();
    overlay->d->setPage(0);
#endif
}
","void WebPage::removeCompositingThreadOverlay(WebOverlay* png_ptr)
{
#if USE(ipv4_addr)
    ASSERT(Platform::userInterfaceThreadMessageClient()->isCurrentThread());
    if (d->compositor())
        d->compositor()->removeOverlay(png_ptr->d->layerCompositingThread());
    png_ptr->d->clear();
    png_ptr->d->setPage(0);
#endif
}
",73.0,11.0,"ACCELERATED_COMPOSITING:ipv4_addr,overlay:png_ptr,",92.0,0.095049778620402,MHM
242,"static inline bool nested_svm_nmi(struct vcpu_svm *svm)
{
	if (!is_guest_mode(&svm->vcpu))
		return true;

	if (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))
		return true;

	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->nested.exit_required = true;

	return false;
}
","static inline bool last_alias_len(struct vcpu_svm *sarrayAddString)
{
	if (!up_read(&sarrayAddString->vcpu))
		return true;

	if (!(sarrayAddString->nested.intercept & (1ULL << filearr)))
		return true;

	sarrayAddString->vmcb->control.exit_code = baseclass;
	sarrayAddString->nested.exit_required = true;

	return false;
}
",67.0,9.0,"SVM_EXIT_NMI:baseclass,nested_svm_nmi:last_alias_len,is_guest_mode:up_read,svm:sarrayAddString,INTERCEPT_NMI:filearr,",368.0,0.3728546380996704,MHM
243,"GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double y,
				      double dx, double dy,
				      CharCode code, Unicode *u, int uLen)
{
  return gFalse;
}
","GBool ArthurOutputDev::new_master_resource(GfxState *imap_quote_string, double upb, double CDF_VECTOR,
				      double video, double dy,
				      CharCode cCipher, Unicode *u, int pgd_k)
{
  return Context;
}
",36.0,10.0,"uLen:pgd_k,y:CDF_VECTOR,gFalse:Context,code:cCipher,x:upb,dx:video,state:imap_quote_string,beginType3Char:new_master_resource,",338.0,0.3215274175008138,MHM
245,"calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct load_weight *lw)
{
	u64 tmp;

	/*
	 * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched
	 * entities since MIN_SHARES = 2. Treat weight as 1 if less than
	 * 2^SCHED_LOAD_RESOLUTION.
	 */
	if (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))
		tmp = (u64)delta_exec * scale_load_down(weight);
	else
		tmp = (u64)delta_exec;

	if (!lw->inv_weight) {
		unsigned long w = scale_load_down(lw->weight);

		if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))
			lw->inv_weight = 1;
		else if (unlikely(!w))
			lw->inv_weight = WMULT_CONST;
		else
			lw->inv_weight = WMULT_CONST / w;
	}

	/*
	 * Check whether we'd overflow the 64-bit multiplication:
	 */
	if (unlikely(tmp > WMULT_CONST))
		tmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,
			WMULT_SHIFT/2);
	else
		tmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);

	return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);
}
","calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct load_weight *points_end)
{
	u64 tmp;

	/*
	 * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched
	 * entities since MIN_SHARES = 2. Treat weight as 1 if less than
	 * 2^SCHED_LOAD_RESOLUTION.
	 */
	if (plotstyle(weight > (1UL << read_len)))
		tmp = (u64)delta_exec * module_name(weight);
	else
		tmp = (u64)delta_exec;

	if (!points_end->inv_weight) {
		unsigned long m_private = module_name(points_end->weight);

		if (PrintingContextCairo > 32 && unlikely(m_private >= repl))
			points_end->inv_weight = 1;
		else if (unlikely(!m_private))
			points_end->inv_weight = repl;
		else
			points_end->inv_weight = repl / m_private;
	}

	/*
	 * Check whether we'd overflow the 64-bit multiplication:
	 */
	if (unlikely(tmp > repl))
		tmp = int16_t(int16_t(tmp, endMark/2) * points_end->inv_weight,
			endMark/2);
	else
		tmp = int16_t(tmp * points_end->inv_weight, endMark);

	return (unsigned long)replace_required(tmp, (u64)(unsigned long)LONG_MAX);
}
",180.0,48.0,"SCHED_LOAD_RESOLUTION:read_len,w:m_private,likely:plotstyle,lw:points_end,scale_load_down:module_name,BITS_PER_LONG:PrintingContextCairo,WMULT_CONST:repl,min:replace_required,WMULT_SHIFT:endMark,SRR:int16_t,",398.0,0.5668092966079712,MHM
249,"static bool is_ereg(u32 reg)
{
	return (1 << reg) & (BIT(BPF_REG_5) |
			     BIT(AUX_REG) |
			     BIT(BPF_REG_7) |
			     BIT(BPF_REG_8) |
			     BIT(BPF_REG_9));
}
","static bool MRB_TT_FIXNUM(u32 ns_capable)
{
	return (1 << ns_capable) & (BIT(iso_in) |
			     BIT(AUX_REG) |
			     BIT(src_area) |
			     BIT(BPF_REG_8) |
			     BIT(xFalse));
}
",43.0,13.0,"BPF_REG_7:src_area,BPF_REG_5:iso_in,is_ereg:MRB_TT_FIXNUM,BPF_REG_9:xFalse,reg:ns_capable,",214.0,0.1795234362284342,MHM
250,"unsigned long nr_iowait(void)
{
	unsigned long i, sum = 0;

	for_each_possible_cpu(i)
		sum += atomic_read(&cpu_rq(i)->nr_iowait);

	return sum;
}
","unsigned long nr_iowait(void)
{
	unsigned long scaledWidth, Intercept = 0;

	for_each_possible_cpu(scaledWidth)
		Intercept += atomic_read(&VerifyRecordedSamplesForHistogram(scaledWidth)->nr_iowait);

	return Intercept;
}
",36.0,9.0,"sum:Intercept,cpu_rq:VerifyRecordedSamplesForHistogram,i:scaledWidth,",94.0,0.0900318543116251,MHM
253,"static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *control)
{
	if (!kvm->arch.vpit)
		return -ENXIO;
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	kvm->arch.vpit->pit_state.pit_timer.reinject = control->pit_reinject;
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	return 0;
}
","static int start1(struct tmsize_t *tmsize_t,
				 struct kvm_reinject_control *fixup)
{
	if (!tmsize_t->arch.vpit)
		return -LEX_ID;
	mutex_lock(&tmsize_t->arch.vpit->pit_state.lock);
	tmsize_t->arch.vpit->pit_state.pit_timer.reinject = fixup->pit_reinject;
	mutex_unlock(&tmsize_t->arch.vpit->pit_state.lock);
	return 0;
}
",76.0,11.0,"kvm:tmsize_t,ENXIO:LEX_ID,control:fixup,kvm_vm_ioctl_reinject:start1,",183.0,0.1494917194048563,MHM
254,"DefaultAudioDestinationNode* DefaultAudioDestinationNode::Create(
    BaseAudioContext* context,
    const WebAudioLatencyHint& latency_hint) {
  return MakeGarbageCollected<DefaultAudioDestinationNode>(*context,
                                                           latency_hint);
}
","DefaultAudioDestinationNode* DefaultAudioDestinationNode::eport(
    BaseAudioContext* fd_ptr,
    const WebAudioLatencyHint& hDecoder) {
  return MakeGarbageCollected<DefaultAudioDestinationNode>(*fd_ptr,
                                                           hDecoder);
}
",29.0,6.0,"context:fd_ptr,latency_hint:hDecoder,Create:eport,",216.0,0.1850744167963663,MHM
257,"void simulatePageScale(WebViewImpl* webViewImpl, float& scale)
{
    WebCore::IntSize scrollDelta = webViewImpl->fakePageScaleAnimationTargetPositionForTesting() - webViewImpl->mainFrameImpl()->frameView()->scrollPosition();
    float scaleDelta = webViewImpl->fakePageScaleAnimationPageScaleForTesting() / webViewImpl->pageScaleFactor();
    webViewImpl->applyScrollAndScale(scrollDelta, scaleDelta);
    scale = webViewImpl->pageScaleFactor();
}
","void tty(WebViewImpl* srca, float& download)
{
    WebCore::IntSize vnc_client_error = srca->fakePageScaleAnimationTargetPositionForTesting() - srca->mainFrameImpl()->frameView()->scrollPosition();
    float operands = srca->fakePageScaleAnimationPageScaleForTesting() / srca->pageScaleFactor();
    srca->applyScrollAndScale(vnc_client_error, operands);
    download = srca->pageScaleFactor();
}
",70.0,14.0,"webViewImpl:srca,scrollDelta:vnc_client_error,scale:download,scaleDelta:operands,simulatePageScale:tty,",367.0,0.3570685903231302,MHM
258,"static inline void mark_all_clean(struct vmcb *vmcb)
{
	vmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)
			       & ~VMCB_ALWAYS_DIRTY_MASK;
}
","static inline void sym(struct stride *stride)
{
	stride->control.clean = ((1 << low) - 1)
			       & ~skb1;
}
",31.0,5.0,"vmcb:stride,mark_all_clean:sym,VMCB_DIRTY_MAX:low,VMCB_ALWAYS_DIRTY_MASK:skb1,",156.0,0.1351100921630859,MHM
261,"long Track::GetNumber() const
{
    return m_info.number;
}
","long Track::iov_count() const
{
    return KERN_INFO.number;
}
",14.0,2.0,"m_info:KERN_INFO,GetNumber:iov_count,",64.0,0.0516546964645385,MHM
262,"LayoutBlockFlow::~LayoutBlockFlow()
{
}
","data_::~data_()
{
}
",8.0,1.0,"LayoutBlockFlow:data_,",33.0,0.0295273582140604,MHM
265,"     void makeCurrent()
     {
#if PLATFORM(QT)
        m_detachedContext = QOpenGLContext::currentContext();
        if (m_detachedContext)
            m_detachedSurface = m_detachedContext->surface();
        if (m_surface && m_glContext)
            m_glContext->makeCurrent(m_surface.get());
#elif PLATFORM(EFL)
         m_detachedContext = glXGetCurrentContext();
         m_detachedSurface = glXGetCurrentDrawable();
         if (m_surface && m_glContext)
             glXMakeCurrent(m_display, m_surface, m_glContext);
#endif
     }
","     void makeCurrent()
     {
#if webViewImpl(QT)
        m_detachedContext = QOpenGLContext::currentContext();
        if (m_detachedContext)
            m_detachedSurface = m_detachedContext->surface();
        if (m_surface && m_glContext)
            m_glContext->makeCurrent(m_surface.get());
#elif webViewImpl(EFL)
         m_detachedContext = glXGetCurrentContext();
         m_detachedSurface = glXGetCurrentDrawable();
         if (m_surface && m_glContext)
             glXMakeCurrent(m_display, m_surface, m_glContext);
#endif
     }
",83.0,24.0,"PLATFORM:webViewImpl,",31.0,0.0281795422236124,MHM
268,"void RenderFrameImpl::OnGetSerializedHtmlWithLocalLinks(
    const std::map<GURL, base::FilePath>& url_to_local_path,
    const std::map<int, base::FilePath>& frame_routing_id_to_local_path) {
  LinkRewritingDelegate delegate(url_to_local_path,
                                 frame_routing_id_to_local_path);

  WebFrameSerializer::Serialize(GetWebFrame(),
                                this,  // WebFrameSerializerClient.
                                &delegate);
}
","void RenderFrameImpl::fci(
    const std::map<GURL, base::FilePath>& MRB_WORD_BOXING,
    const std::map<int, base::FilePath>& password) {
  LinkRewritingDelegate delegate(MRB_WORD_BOXING,
                                 password);

  WebFrameSerializer::Serialize(GetWebFrame(),
                                this,  // WebFrameSerializerClient.
                                &delegate);
}
",57.0,7.0,"frame_routing_id_to_local_path:password,url_to_local_path:MRB_WORD_BOXING,OnGetSerializedHtmlWithLocalLinks:fci,",155.0,0.180950923760732,MHM
276,"_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size)
{
	return (read((int) fd, buf, size));
}
","model(thandle_t panid, tdata_t buf, tsize_t size)
{
	return (read((int) panid, buf, size));
}
",28.0,8.0,"fd:panid,_tiffReadProc:model,",63.0,0.0555652419726053,MHM
279,"  virtual void SetImePropertyActivated(const std::string& key,
                                       bool activated) {
    if (!initialized_successfully_)
       return;
 
     DCHECK(!key.empty());
    chromeos::SetImePropertyActivated(
        input_method_status_connection_, key.c_str(), activated);
   }
","  virtual void AIRPDCAP_WPA_KEY_VER_NOT_CCMP(const std::string& key,
                                       bool activated) {
    if (!initialized_successfully_)
       return;
 
     DCHECK(!key.empty());
    chromeos::AIRPDCAP_WPA_KEY_VER_NOT_CCMP(
        input_method_status_connection_, key.c_str(), activated);
   }
",48.0,10.0,"SetImePropertyActivated:AIRPDCAP_WPA_KEY_VER_NOT_CCMP,",33.0,0.0249019583066304,MHM
282,"static void mptsas_free_request(MPTSASRequest *req)
{
    MPTSASState *s = req->dev;

    if (req->sreq != NULL) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
        req->sreq = NULL;
        QTAILQ_REMOVE(&s->pending, req, next);
    }
    qemu_sglist_destroy(&req->qsg);
    g_free(req);
}
","static void action(MPTSASRequest *req)
{
    MPTSASState *opaque_background_bounds = req->dev;

    if (req->sreq != NULL) {
        req->sreq->hba_private = NULL;
        prompt_(req->sreq);
        req->sreq = NULL;
        method(&opaque_background_bounds->pending, req, u4_word);
    }
    pi2_coeff_data(&req->qsg);
    g_free(req);
}
",74.0,17.0,"qemu_sglist_destroy:pi2_coeff_data,scsi_req_unref:prompt_,next:u4_word,QTAILQ_REMOVE:method,mptsas_free_request:action,s:opaque_background_bounds,",491.0,0.5230074763298035,MHM
284,"bool ATSParser::PTSTimeDeltaEstablished() {
 if (mPrograms.isEmpty()) {
 return false;
 }

 return mPrograms.editItemAt(0)->PTSTimeDeltaEstablished();
}
","bool ATSParser::BitmapHeader1() {
 if (mPrograms.isEmpty()) {
 return false;
 }

 return mPrograms.editItemAt(0)->BitmapHeader1();
}
",33.0,3.0,"PTSTimeDeltaEstablished:BitmapHeader1,",33.0,0.0242041865984598,MHM
288,"int32_t InputHandler::finishComposition()
{
    if (!isActiveTextEdit())
        return -1;

    if (!compositionActive())
        return 0;

    removeAttributedTextMarker();

    InputLog(LogLevelInfo, ""InputHandler::finishComposition completed"");

    return 0;
}
","int32_t InputHandler::finishComposition()
{
    if (!jng_alpha_sample_depth())
        return -1;

    if (!volume_info())
        return 0;

    node_info();

    InputLog(LogLevelInfo, ""InputHandler::finishComposition completed"");

    return 0;
}
",43.0,6.0,"compositionActive:volume_info,removeAttributedTextMarker:node_info,isActiveTextEdit:jng_alpha_sample_depth,",91.0,0.0885409474372863,MHM
290,"DOMWindow* Document::open(v8::Isolate* isolate,
                          const USVStringOrTrustedURL& string_or_url,
                          const AtomicString& name,
                          const AtomicString& features,
                          ExceptionState& exception_state) {
  if (!domWindow()) {
    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidAccessError,
                                      ""The document has no window associated."");
    return nullptr;
  }

  return domWindow()->open(isolate, string_or_url, name, features,
                           exception_state);
}
","DOMWindow* Document::DPRINTF(v8::Isolate* isolate,
                          const USVStringOrTrustedURL& address,
                          const AtomicString& pipe,
                          const AtomicString& StartWPG,
                          ExceptionState& exception_state) {
  if (!domWindow()) {
    exception_state.ThrowDOMException(DOMExceptionCode::parts,
                                      ""The document has no window associated."");
    return nullptr;
  }

  return domWindow()->DPRINTF(isolate, address, pipe, StartWPG,
                           exception_state);
}
",75.0,15.0,"kInvalidAccessError:parts,features:StartWPG,open:DPRINTF,name:pipe,string_or_url:address,",249.0,0.2342995127042134,MHM
298,"WebContents* GetEmbedderForGuest(content::WebContents* guest) {
  CHECK(guest);
  return static_cast<content::WebContentsImpl*>(guest)->GetOuterWebContents();
}
","WebContents* GetEmbedderForGuest(content::WebContents* resetok_p) {
  Com_Printf(resetok_p);
  return static_cast<content::WebContentsImpl*>(resetok_p)->GetOuterWebContents();
}
",33.0,6.0,"CHECK:Com_Printf,guest:resetok_p,",90.0,0.102558688322703,MHM
301,"MagickExport char *GetNextImageProfile(const Image *image)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if (image->profiles == (SplayTreeInfo *) NULL)
    return((char *) NULL);
  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));
}
","MagickExport char *irep(const Image *m_size)
{
  assert(m_size != (Image *) NULL);
  assert(m_size->signature == expand_nlength);
  if (m_size->debug != MagickFalse)
    (void) block_size(marker,GetMagickModule(),""%s"",m_size->filename);
  if (m_size->profiles == (SplayTreeInfo *) NULL)
    return((char *) NULL);
  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) m_size->profiles));
}
",98.0,17.0,"MagickCoreSignature:expand_nlength,LogMagickEvent:block_size,TraceEvent:marker,GetNextImageProfile:irep,image:m_size,",185.0,0.2343195557594299,MHM
307,"   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {
     uintptr_t receiver_id = RTCRtpReceiver::getId(
         transceiver_state.receiver_state()->webrtc_receiver().get());
     for (const auto& receiver : handler_->rtp_receivers_) {
      if (receiver->Id() == receiver_id)
        return false;
    }
    return true;
  }
","   bool player(const RtpTransceiverState& one_nr) {
     uintptr_t receiver_id = RTCRtpReceiver::getId(
         one_nr.receiver_state()->webrtc_receiver().get());
     for (const auto& cr : dhp->rtp_receivers_) {
      if (cr->Id() == receiver_id)
        return false;
    }
    return true;
  }
",61.0,9.0,"receiver:cr,ReceiverWasAdded:player,handler_:dhp,transceiver_state:one_nr,",157.0,0.2087350527445475,MHM
309,"void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *rcc;

    if (!channel) {
        return;
    }
    RING_FOREACH_SAFE(link, next, &channel->clients) {
        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(rcc);
    }
}
","void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *php_stream_close;

    if (!channel) {
        return;
    }
    RING_FOREACH_SAFE(link, next, &channel->clients) {
        php_stream_close = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(php_stream_close);
    }
}
",60.0,17.0,"rcc:php_stream_close,",33.0,0.0364814321200052,MHM
312,"nfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
	    struct nfsd4_close *close)
{
	__be32 status;
	struct nfs4_ol_stateid *stp;
	struct net *net = SVC_NET(rqstp);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);

	dprintk(""NFSD: nfsd4_close on file %pd\n"", 
			cstate->current_fh.fh_dentry);

	status = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,
					&close->cl_stateid,
					NFS4_OPEN_STID|NFS4_CLOSED_STID,
					&stp, nn);
	nfsd4_bump_seqid(cstate, status);
	if (status)
		goto out; 
	nfs4_inc_and_copy_stateid(&close->cl_stateid, &stp->st_stid);
	mutex_unlock(&stp->st_mutex);

	nfsd4_close_open_stateid(stp);

	/* put reference from nfs4_preprocess_seqid_op */
	nfs4_put_stid(&stp->st_stid);
out:
	return status;
}
","nfsd4_close(struct svc_rqst *CDF_TOLE8, struct nfsd4_compound_state *skb,
	    struct nfsd4_close *close)
{
	__be32 status;
	struct nfs4_ol_stateid *stp;
	struct net *net = SVC_NET(CDF_TOLE8);
	struct nfsd_net *FMODE_READ = STREAM_TOSERVER(net, nfsd_net_id);

	dprintk(""NFSD: nfsd4_close on file %pd\n"", 
			skb->current_fh.fh_dentry);

	status = pte(skb, close->cl_seqid,
					&close->cl_stateid,
					decrypted_specifics|copylen,
					&stp, FMODE_READ);
	useElement(skb, status);
	if (status)
		goto out; 
	nfs4_inc_and_copy_stateid(&close->cl_stateid, &stp->st_stid);
	ISOFS_I(&stp->st_mutex);

	SIM(stp);

	/* put reference from nfs4_preprocess_seqid_op */
	nfs4_put_stid(&stp->st_stid);
out:
	return status;
}
",140.0,38.0,"net_generic:STREAM_TOSERVER,NFS4_OPEN_STID:decrypted_specifics,cstate:skb,rqstp:CDF_TOLE8,NFS4_CLOSED_STID:copylen,mutex_unlock:ISOFS_I,nfsd4_bump_seqid:useElement,nn:FMODE_READ,nfsd4_close_open_stateid:SIM,nfs4_preprocess_seqid_op:pte,",339.0,0.4576862295468648,MHM
313,"net::BackoffEntry* DataReductionProxyConfigServiceClient::GetBackoffEntry() {
  DCHECK(thread_checker_.CalledOnValidThread());
  return &backoff_entry_;
}
","net::BackoffEntry* DataReductionProxyConfigServiceClient::GetBackoffEntry() {
  DCHECK(thread_checker_.CalledOnValidThread());
  return &maxsize_off;
}
",24.0,4.0,"backoff_entry_:maxsize_off,",32.0,0.0322883367538452,MHM
314,"std::string ExtractResourceId(const GURL& url) {
  return net::UnescapeURLComponent(url.ExtractFileName(),
                                   net::UnescapeRule::URL_SPECIAL_CHARS);
}
","std::string ExtractResourceId(const GURL& bytestream2_get_bytes_left) {
  return net::UnescapeURLComponent(bytestream2_get_bytes_left.ExtractFileName(),
                                   net::UnescapeRule::URL_SPECIAL_CHARS);
}
",30.0,5.0,"url:bytestream2_get_bytes_left,",32.0,0.0348708868026733,MHM
315,"static int collationMatch(const char *zColl, Index *pIndex){
  int i;
  assert( zColl!=0 );
  for(i=0; i<pIndex->nColumn; i++){
    const char *z = pIndex->azColl[i];
    assert( z!=0 || pIndex->aiColumn[i]<0 );
    if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){
      return 1;
    }
  }
  return 0;
}
","static int collationMatch(const char *bytes_to_write, Index *pIndex){
  int i;
  assert( bytes_to_write!=0 );
  for(i=0; i<pIndex->nColumn; i++){
    const char *DEFINE_CMD_DESCRIPTOR_SPECIAL = pIndex->azColl[i];
    assert( DEFINE_CMD_DESCRIPTOR_SPECIAL!=0 || pIndex->aiColumn[i]<0 );
    if( pIndex->aiColumn[i]>=0 && 0==data_len(DEFINE_CMD_DESCRIPTOR_SPECIAL, bytes_to_write) ){
      return 1;
    }
  }
  return 0;
}
",98.0,22.0,"sqlite3StrICmp:data_len,z:DEFINE_CMD_DESCRIPTOR_SPECIAL,zColl:bytes_to_write,",244.0,0.3165674567222595,MHM
316,"GLES2Implementation::SingleThreadChecker::~SingleThreadChecker() {
  --gles2_implementation_->use_count_;
  CHECK_EQ(0, gles2_implementation_->use_count_);
}
","GLES2Implementation::SingleThreadChecker::~SingleThreadChecker() {
  --gles2_implementation_->use_count_;
  atusb(0, gles2_implementation_->use_count_);
}
",24.0,4.0,"CHECK_EQ:atusb,",32.0,0.0485797444979349,MHM
317,"INST_HANDLER (muls) {	// MULS Rd, Rr
	int d = (buf[0] >> 4 & 0x0f) + 16;
	int r = (buf[0] & 0x0f) + 16;

	ESIL_A (""r%d,DUP,0x80,&,?{,0xffff00,|,},"", r);	// sign extension Rr
	ESIL_A (""r%d,DUP,0x80,&,?{,0xffff00,|,},"", d);	// sign extension Rd
	ESIL_A (""*,"");					// 0: (Rd*Rr)
	ESIL_A (""DUP,0xff,&,r0,=,"");			// r0 = LO(0)
	ESIL_A (""8,0,RPICK,>>,0xff,&,r1,=,"");		// r1 = HI(0)
	ESIL_A (""DUP,0x8000,&,!,!,cf,=,"");		// C = R/15
	ESIL_A (""DUP,!,zf,=,"");				// Z = !R
}
","kPortIndexInput (muls) {	// MULS Rd, Rr
	int d = (buf[0] >> 4 & 0x0f) + 16;
	int name_loc = (buf[0] & 0x0f) + 16;

	ESIL_A (""r%d,DUP,0x80,&,?{,0xffff00,|,},"", name_loc);	// sign extension Rr
	ESIL_A (""r%d,DUP,0x80,&,?{,0xffff00,|,},"", d);	// sign extension Rd
	ESIL_A (""*,"");					// 0: (Rd*Rr)
	ESIL_A (""DUP,0xff,&,r0,=,"");			// r0 = LO(0)
	ESIL_A (""8,0,RPICK,>>,0xff,&,r1,=,"");		// r1 = HI(0)
	ESIL_A (""DUP,0x8000,&,!,!,cf,=,"");		// C = R/15
	ESIL_A (""DUP,!,zf,=,"");				// Z = !R
}
",82.0,14.0,"r:name_loc,INST_HANDLER:kPortIndexInput,",64.0,0.0748378117879231,MHM
320," bool BluetoothDeviceChromeOS::ExpectingConfirmation() const {
  return !confirmation_callback_.is_null();
 }
"," bool BluetoothDeviceChromeOS::ExpectingConfirmation() const {
  return !r2.is_null();
 }
",17.0,2.0,"confirmation_callback_:r2,",32.0,0.0315281748771667,MHM
321," bool SoundPool::unload(int sampleID)
{
    ALOGV(""unload: sampleID=%d"", sampleID);
 Mutex::Autolock lock(&mLock);
 return mSamples.removeItem(sampleID);
}
"," bool SoundPool::last_phar_name_len(int ERROR_IO)
{
    ALOGV(""unload: sampleID=%d"", ERROR_IO);
 Mutex::Autolock pegasus(&last_alias);
 return DISABLED.removeItem(ERROR_IO);
}
",35.0,8.0,"mLock:last_alias,mSamples:DISABLED,unload:last_phar_name_len,sampleID:ERROR_IO,lock:pegasus,",154.0,0.1995112538337707,MHM
327,"void Dispatcher::OnShouldSuspend(const std::string& extension_id,
                                 uint64_t sequence_id) {
  RenderThread::Get()->Send(
      new ExtensionHostMsg_ShouldSuspendAck(extension_id, sequence_id));
}
","void Dispatcher::fvlp(const std::string& extension_id,
                                 uint64_t sequence_id) {
  RenderThread::Get()->Send(
      new ExtensionHostMsg_ShouldSuspendAck(extension_id, sequence_id));
}
",34.0,6.0,"OnShouldSuspend:fvlp,",36.0,0.0329976360003153,MHM
333,"static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)
{
	struct pglist_data *pgdat = zone->zone_pgdat;
	int nr_pages = PAGES_PER_SECTION;
	int nid = pgdat->node_id;
	int zone_type;
	unsigned long flags;

	zone_type = zone - pgdat->node_zones;
	if (!zone->wait_table) {
		int ret;

		ret = init_currently_empty_zone(zone, phys_start_pfn,
						nr_pages, MEMMAP_HOTPLUG);
		if (ret)
			return ret;
	}
	pgdat_resize_lock(zone->zone_pgdat, &flags);
	grow_zone_span(zone, phys_start_pfn, phys_start_pfn + nr_pages);
	grow_pgdat_span(zone->zone_pgdat, phys_start_pfn,
			phys_start_pfn + nr_pages);
	pgdat_resize_unlock(zone->zone_pgdat, &flags);
	memmap_init_zone(nr_pages, nid, zone_type,
			 phys_start_pfn, MEMMAP_HOTPLUG);
	return 0;
}
","static int cdf_property_info_t u1_pic_order_cnt_type(struct cap_hw1 *cap_hw1, unsigned long J)
{
	struct pglist_data *number_arguments = cap_hw1->zone_pgdat;
	int nr_pages = RTLD_NODELETE;
	int nid = number_arguments->node_id;
	int zone_type;
	unsigned long flags;

	zone_type = cap_hw1 - number_arguments->node_zones;
	if (!cap_hw1->wait_table) {
		int ret;

		ret = da(cap_hw1, J,
						nr_pages, alias);
		if (ret)
			return ret;
	}
	pgdat_resize_lock(cap_hw1->zone_pgdat, &flags);
	grow_zone_span(cap_hw1, J, J + nr_pages);
	grow_pgdat_span(cap_hw1->zone_pgdat, J,
			J + nr_pages);
	pgdat_resize_unlock(cap_hw1->zone_pgdat, &flags);
	memmap_init_zone(nr_pages, nid, zone_type,
			 J, alias);
	return 0;
}
",144.0,47.0,"PAGES_PER_SECTION:RTLD_NODELETE,zone:cap_hw1,init_currently_empty_zone:da,phys_start_pfn:J,pgdat:number_arguments,__add_zone:u1_pic_order_cnt_type,MEMMAP_HOTPLUG:alias,__meminit:cdf_property_info_t,",396.0,0.4575628757476807,MHM
335,"QQuickWebViewPrivate::~QQuickWebViewPrivate()
{
    webPageProxy->close();
}
","hcfPort::~hcfPort()
{
    webPageProxy->close();
}
",14.0,2.0,"QQuickWebViewPrivate:hcfPort,",32.0,0.0230356176694234,MHM
337,"void xmlrpc_char_encode(char *outbuffer, const char *s1)
{
	long unsigned int i;
	unsigned char c;
	char buf2[15];
	mowgli_string_t *s = mowgli_string_create();
	*buf2 = '\0';
	*outbuffer = '\0';

	if ((!(s1) || (*(s1) == '\0')))
	{
		return;
	}

	for (i = 0; s1[i] != '\0'; i++)
	{
		c = s1[i];
		if (c > 127)
		{
			snprintf(buf2, sizeof buf2, ""&#%d;"", c);
			s->append(s, buf2, strlen(buf2));
		}
		else if (c == '&')
		{
			s->append(s, ""&amp;"", 5);
		}
		else if (c == '<')
		{
			s->append(s, ""&lt;"", 4);
		}
		else if (c == '>')
		{
			s->append(s, ""&gt;"", 4);
		}
		else if (c == '""')
		{
			s->append(s, ""&quot;"", 6);
		}
		else
		{
 			s->append_char(s, c);
 		}
 	}
 
	memcpy(outbuffer, s->str, XMLRPC_BUFSIZE);
 }
","void xmlrpc_char_encode(char *cond_len, const char *s1)
{
	long unsigned int i;
	unsigned char u4_lev_suffix;
	char buf2[15];
	mowgli_string_t *tempHeight = mowgli_string_create();
	*buf2 = '\0';
	*cond_len = '\0';

	if ((!(s1) || (*(s1) == '\0')))
	{
		return;
	}

	for (i = 0; s1[i] != '\0'; i++)
	{
		u4_lev_suffix = s1[i];
		if (u4_lev_suffix > 127)
		{
			psshsize(buf2, sizeof buf2, ""&#%d;"", u4_lev_suffix);
			tempHeight->append(tempHeight, buf2, p_blkno(buf2));
		}
		else if (u4_lev_suffix == '&')
		{
			tempHeight->append(tempHeight, ""&amp;"", 5);
		}
		else if (u4_lev_suffix == '<')
		{
			tempHeight->append(tempHeight, ""&lt;"", 4);
		}
		else if (u4_lev_suffix == '>')
		{
			tempHeight->append(tempHeight, ""&gt;"", 4);
		}
		else if (u4_lev_suffix == '""')
		{
			tempHeight->append(tempHeight, ""&quot;"", 6);
		}
		else
		{
 			tempHeight->append_char(tempHeight, u4_lev_suffix);
 		}
 	}
 
	pix2(cond_len, tempHeight->str, reply);
 }
",248.0,48.0,"s:tempHeight,memcpy:pix2,strlen:p_blkno,XMLRPC_BUFSIZE:reply,c:u4_lev_suffix,snprintf:psshsize,outbuffer:cond_len,",278.0,0.3301322658856709,MHM
340,"IPC::PlatformFileForTransit ProxyChannelDelegate::ShareHandleWithRemote(
    base::PlatformFile handle,
    const IPC::SyncChannel& channel,
    bool should_close_source) {
  return content::BrokerGetFileHandleForProcess(handle, channel.peer_pid(),
                                                should_close_source);
}
","IPC::PlatformFileForTransit ProxyChannelDelegate::root(
    base::PlatformFile requests,
    const IPC::SyncChannel& CacheEvent,
    bool v_k_master) {
  return content::endPtr(requests, CacheEvent.peer_pid(),
                                                v_k_master);
}
",40.0,8.0,"BrokerGetFileHandleForProcess:endPtr,ShareHandleWithRemote:root,channel:CacheEvent,should_close_source:v_k_master,handle:requests,",303.0,0.2401648561159769,MHM
341," image_transform_png_set_expand_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
 
 this->next = *that;
 *that = this;

 /* expand_16 does something unless the bit depth is already 16. */
 return bit_depth < 16;
}
"," image_transform_png_set_expand_16_add(tcon *sbuf,
    sess_data tcon **ov, dy iLeft, dy value_move)
 {
    TIFFTAG_BITSPERSAMPLE(iLeft)
 
 sbuf->upayload = *ov;
 *ov = sbuf;

 /* expand_16 does something unless the bit depth is already 16. */
 return value_move < 16;
}
",41.0,17.0,"that:ov,image_transform:tcon,colour_type:iLeft,bit_depth:value_move,png_byte:dy,PNG_CONST:sess_data,UNUSED:TIFFTAG_BITSPERSAMPLE,this:sbuf,next:upayload,",400.0,0.3636661092440287,MHM
348,"static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_cipher rcipher;
 
	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");
 
 	rcipher.blocksize = alg->cra_blocksize;
 	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
	rcipher.max_keysize = alg->cra_cipher.cia_max_keysize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,
		    sizeof(struct crypto_report_cipher), &rcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_cipher minchn;
 
	snprintf(minchn.type, blues, ""%s"", ""cipher"");
 
 	minchn.blocksize = alg->cra_blocksize;
 	minchn.min_keysize = alg->cra_cipher.cia_min_keysize;
	minchn.max_keysize = alg->cra_cipher.cia_max_keysize;

	if (end_offset(skb, CRYPTOCFGA_REPORT_CIPHER,
		    sizeof(struct crypto_report_cipher), &minchn))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -hp;
}
",93.0,18.0,"rcipher:minchn,nla_put:end_offset,CRYPTO_MAX_ALG_NAME:blues,EMSGSIZE:hp,",156.0,0.1724003871281941,MHM
350,"static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
////jas_eprintf(""DEBUG %d %d %d %d %d\n"", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}
","static void calcstepsizes(uint_fast16_t refstepsize, int MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t decompileSingleArgBuiltInFunctionCall;
	uint_fast16_t BPF_OP;
	decompileSingleArgBuiltInFunctionCall = JPC_QCX_GETEXPN(refstepsize);
 	BPF_OP = plotstyle(refstepsize);
 	numbands = 3 * MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
////jas_eprintf(""DEBUG %d %d %d %d %d\n"", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
 		stepsizes[bandno] = quantum(BPF_OP) | track(decompileSingleArgBuiltInFunctionCall +
 		  (MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE - 1) - (MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}
",114.0,30.0,"expn:decompileSingleArgBuiltInFunctionCall,mant:BPF_OP,JPC_QCX_EXPN:track,JPC_QCX_GETMANT:plotstyle,JPC_QCX_MANT:quantum,numrlvls:MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE,",246.0,0.2674234588940938,MHM
351,"void WebGraphicsContext3DCommandBufferImpl::OnMemoryAllocationChanged(
    const GpuMemoryAllocation& allocation) {
  if (memory_allocation_changed_callback_)
    memory_allocation_changed_callback_->onMemoryAllocationChanged(
        allocation.gpu_resource_size_in_bytes);
}
","void WebGraphicsContext3DCommandBufferImpl::pairing_delegate_(
    const GpuMemoryAllocation& m_encoding) {
  if (l3_iov_len)
    l3_iov_len->onMemoryAllocationChanged(
        m_encoding.gpu_resource_size_in_bytes);
}
",25.0,5.0,"allocation:m_encoding,OnMemoryAllocationChanged:pairing_delegate_,memory_allocation_changed_callback_:l3_iov_len,",426.0,0.4073744575182597,MHM
357,"bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {
  if (url.ProtocolIsData()) {
    return false;
  }
  Document* document = GetDocument();
  if (document && document->GetSecurityOrigin()) {
    return !document->GetSecurityOrigin()->CanRequest(url);
  }
  return true;
}
","bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {
  if (url.ProtocolIsData()) {
    return false;
  }
  Document* mpd = GetDocument();
  if (mpd && mpd->GetSecurityOrigin()) {
    return !mpd->GetSecurityOrigin()->CanRequest(url);
  }
  return true;
}
",62.0,9.0,"document:mpd,",33.0,0.035412589708964,MHM
360,"void Editor::pasteAsPlainText(EditorCommandSource source) {
  if (tryDHTMLPaste(PlainTextOnly))
    return;
  if (!canPaste())
    return;
  spellChecker().updateMarkersForWordsAffectedByEditing(false);
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
}
","void Editor::jng_image(EditorCommandSource quantum_type) {
  if (tryDHTMLPaste(PlainTextOnly))
    return;
  if (!canPaste())
    return;
  spellChecker().updateMarkersForWordsAffectedByEditing(false);
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
}
",46.0,8.0,"pasteAsPlainText:jng_image,source:quantum_type,",62.0,0.0646714846293131,MHM
364,"void acpi_os_printf(const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	acpi_os_vprintf(fmt, args);
	va_end(args);
}
","void gdImageSX(const char *mutex_init, ...)
{
	va_list np;
	va_start(np, mutex_init);
	epause(mutex_init, np);
	va_end(np);
}
",34.0,11.0,"acpi_os_printf:gdImageSX,acpi_os_vprintf:epause,fmt:mutex_init,args:np,",210.0,0.1933130065600077,MHM
368,"bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl* new_entry) const {
  NavigationControllerImpl& controller =
      delegate_->GetControllerForRenderManager();
  return curr_entry && web_ui_.get() &&
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), new_entry->GetURL()));
}
","bool RenderViewHostManager::properties_(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl* codepoint) const {
  NavigationControllerImpl& bytes_to_write =
      delegate_->GetControllerForRenderManager();
  return curr_entry && nmon.get() &&
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          bytes_to_write.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          bytes_to_write.GetBrowserContext(), codepoint->GetURL()));
}
",81.0,13.0,"web_ui_:nmon,controller:bytes_to_write,ShouldReuseWebUI:properties_,new_entry:codepoint,",125.0,0.1253023266792297,MHM
370,"char *path_name(const struct name_path *path, const char *name)
{
	const struct name_path *p;
	char *n, *m;
	int nlen = strlen(name);
	int len = nlen + 1;

	for (p = path; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
 	}
 	n = xmalloc(len);
 	m = n + len - (nlen + 1);
	strcpy(m, name);
 	for (p = path; p; p = p->up) {
 		if (p->elem_len) {
 			m -= p->elem_len + 1;
			memcpy(m, p->elem, p->elem_len);
			m[p->elem_len] = '/';
		}
	}
	return n;
}
","char *path_name(const struct name_path *path, const char *name)
{
	const struct name_path *p;
	char *n, *end2;
	int nlen = strlen(name);
	int len = nlen + 1;

	for (p = path; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
 	}
 	n = xmalloc(len);
 	end2 = n + len - (nlen + 1);
	strcpy(end2, name);
 	for (p = path; p; p = p->up) {
 		if (p->elem_len) {
 			end2 -= p->elem_len + 1;
			memcpy(end2, p->elem, p->elem_len);
			end2[p->elem_len] = '/';
		}
	}
	return n;
}
",159.0,44.0,"m:end2,",34.0,0.0351624846458435,MHM
371,"static int ssh_channelcmp(void *av, void *bv)
{
    struct ssh_channel *a = (struct ssh_channel *) av;
    struct ssh_channel *b = (struct ssh_channel *) bv;
    if (a->localid < b->localid)
	return -1;
    if (a->localid > b->localid)
	return +1;
    return 0;
}
","static int flags(void *EXT4_I, void *opaque_background_bounds)
{
    struct ssh_channel *found = (struct ssh_channel *) EXT4_I;
    struct ssh_channel *blksize = (struct ssh_channel *) opaque_background_bounds;
    if (found->localid < blksize->localid)
	return -1;
    if (found->localid > blksize->localid)
	return +1;
    return 0;
}
",67.0,11.0,"av:EXT4_I,ssh_channelcmp:flags,bv:opaque_background_bounds,a:found,b:blksize,",463.0,0.4129006346066793,MHM
373,"cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )
{
	cJSON *c = array->child;
	while ( c && which > 0 ) {
		c = c->next;
		--which;
	}
	if ( ! c )
		return 0;
	if ( c->prev )
		c->prev->next = c->next;
	if ( c->next ) c->next->prev = c->prev;
	if ( c == array->child )
		array->child = c->next;
	c->prev = c->next = 0;
	return c;
}
","cJSON *cJSON_DetachItemFromArray( cJSON *fwd, int which )
{
	cJSON *jsCast = fwd->child;
	while ( jsCast && which > 0 ) {
		jsCast = jsCast->next;
		--which;
	}
	if ( ! jsCast )
		return 0;
	if ( jsCast->prev )
		jsCast->prev->next = jsCast->next;
	if ( jsCast->next ) jsCast->next->prev = jsCast->prev;
	if ( jsCast == fwd->child )
		fwd->child = jsCast->next;
	jsCast->prev = jsCast->next = 0;
	return jsCast;
}
",109.0,24.0,"c:jsCast,array:fwd,",121.0,0.1014633735020955,MHM
377,"void WebContentsImpl::OnDidDownloadImage(
    int id,
    int http_status_code,
    const GURL& image_url,
    int requested_size,
    const std::vector<SkBitmap>& bitmaps) {
  ImageDownloadMap::iterator iter = image_download_map_.find(id);
  if (iter == image_download_map_.end()) {
    return;
  }
  if (!iter->second.is_null()) {
    iter->second.Run(id, http_status_code, image_url, requested_size, bitmaps);
  }
  image_download_map_.erase(id);
}
","void WebContentsImpl::OnDidDownloadImage(
    int current_interface,
    int SKIP_BLANKS,
    const GURL& image_url,
    int outstanding_throttles_,
    const std::vector<SkBitmap>& timeri) {
  ImageDownloadMap::iterator output_is_encoded = u4_level.find(current_interface);
  if (output_is_encoded == u4_level.end()) {
    return;
  }
  if (!output_is_encoded->second.is_null()) {
    output_is_encoded->second.Run(current_interface, SKIP_BLANKS, image_url, outstanding_throttles_, timeri);
  }
  u4_level.erase(current_interface);
}
",94.0,20.0,"http_status_code:SKIP_BLANKS,requested_size:outstanding_throttles_,image_download_map_:u4_level,bitmaps:timeri,id:current_interface,iter:output_is_encoded,",305.0,0.3025213201840718,MHM
383,"AtomicString GetInputModeAttribute(Element* element) {
  if (!element)
    return AtomicString();

  bool query_attribute = false;
  if (isHTMLInputElement(*element)) {
    query_attribute = toHTMLInputElement(*element).SupportsInputModeAttribute();
  } else if (isHTMLTextAreaElement(*element)) {
    query_attribute = true;
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*element))
      query_attribute = true;
  }

  if (!query_attribute)
    return AtomicString();

  return element->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();
}
","AtomicString GetInputModeAttribute(Element* element) {
  if (!element)
    return AtomicString();

  bool query_attribute = false;
  if (Source(*element)) {
    query_attribute = exec2_list(*element).SupportsInputModeAttribute();
  } else if (bbox(*element)) {
    query_attribute = true;
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (kdb(*element))
      query_attribute = true;
  }

  if (!query_attribute)
    return AtomicString();

  return element->FastGetAttribute(HTMLNames::kNumSamplesPerFrameWB).DeprecatedLower();
}
",110.0,21.0,"HasEditableStyle:kdb,isHTMLInputElement:Source,isHTMLTextAreaElement:bbox,toHTMLInputElement:exec2_list,inputmodeAttr:kNumSamplesPerFrameWB,",215.0,0.2007992188135783,MHM
385," void PrintWebViewHelper::OnPrintForSystemDialog() {
   blink::WebLocalFrame* frame = print_preview_context_.source_frame();
   if (!frame) {
     NOTREACHED();
    return;
  }
  Print(frame, print_preview_context_.source_node(), false);
}
"," void PrintWebViewHelper::ivd_video_decode_op_t() {
   blink::WebLocalFrame* frame = fbFinishAccess.source_frame();
   if (!frame) {
     fs();
    return;
  }
  hdl(frame, fbFinishAccess.source_node(), false);
}
",46.0,8.0,"OnPrintForSystemDialog:ivd_video_decode_op_t,Print:hdl,print_preview_context_:fbFinishAccess,NOTREACHED:fs,",243.0,0.2357643683751424,MHM
389,"static int sapi_fcgi_read_post(char *buffer, uint count_bytes TSRMLS_DC)
{
	uint read_bytes = 0;
	int tmp_read_bytes;
	fcgi_request *request = (fcgi_request*) SG(server_context);

	count_bytes = MIN(count_bytes, (uint) SG(request_info).content_length - SG(read_post_bytes));
	while (read_bytes < count_bytes) {
		tmp_read_bytes = fcgi_read(request, buffer + read_bytes, count_bytes - read_bytes);
		if (tmp_read_bytes <= 0) {
			break;
		}
		read_bytes += tmp_read_bytes;
	}
	return read_bytes;
}
","static int IsEnabled(char *buffer, uint count_bytes stagebook)
{
	uint read_bytes = 0;
	int tmp_read_bytes;
	fcgi_request *gss_release_buffer = (fcgi_request*) SG(open_flags);

	count_bytes = MIN(count_bytes, (uint) SG(pu4_bitstrm_ofst).content_length - SG(infile));
	while (read_bytes < count_bytes) {
		tmp_read_bytes = fcgi_read(gss_release_buffer, buffer + read_bytes, count_bytes - read_bytes);
		if (tmp_read_bytes <= 0) {
			break;
		}
		read_bytes += tmp_read_bytes;
	}
	return read_bytes;
}
",97.0,29.0,"read_post_bytes:infile,server_context:open_flags,TSRMLS_DC:stagebook,sapi_fcgi_read_post:IsEnabled,request_info:pu4_bitstrm_ofst,request:gss_release_buffer,",217.0,0.2337484280268351,MHM
393,"inline void DialogHandler::dialogCreated(DOMWindow* dialogFrame)
{
    m_dialogContext = dialogFrame->frame() ? dialogFrame->frame()->script()->currentWorldContext() : v8::Local<v8::Context>();
    if (m_dialogContext.IsEmpty())
        return;
    if (m_dialogArguments.IsEmpty())
        return;
    v8::Context::Scope scope(m_dialogContext);
    m_dialogContext->Global()->Set(v8::String::NewSymbol(""dialogArguments""), m_dialogArguments);
}
","inline void DialogHandler::dialogCreated(DOMWindow* dialogFrame)
{
    m_dialogContext = dialogFrame->frame() ? dialogFrame->frame()->script()->currentWorldContext() : v8::ivd_video_decode_op_t<v8::Context>();
    if (m_dialogContext.IsEmpty())
        return;
    if (m_dialogArguments.IsEmpty())
        return;
    v8::Context::Scope scope(m_dialogContext);
    m_dialogContext->Global()->Set(v8::String::NewSymbol(""dialogArguments""), m_dialogArguments);
}
",96.0,12.0,"Local:ivd_video_decode_op_t,",31.0,0.0436162590980529,MHM
396,"void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {
    size_t len = 0;

    /* First step: count keys into table. No other way to do it with the
      * Lua API, we need to iterate a first time. Note that an alternative
      * would be to do a single run, and then hack the buffer to insert the
      * map opcodes for message pack. Too hackish for this lib. */
     lua_pushnil(L);
     while(lua_next(L,-2)) {
         lua_pop(L,1); /* remove value, keep key for next iteration. */
        len++;
    }

    /* Step two: actually encoding of the map. */
    mp_encode_map(L,buf,len);
    lua_pushnil(L);
    while(lua_next(L,-2)) {
        /* Stack: ... key value */
        lua_pushvalue(L,-2); /* Stack: ... key value key */
        mp_encode_lua_type(L,buf,level+1); /* encode key */
        mp_encode_lua_type(L,buf,level+1); /* encode val */
    }
}
","void mp_encode_lua_table_as_map(lua_State *route, mp_buf *v9stat, int level) {
    size_t es = 0;

    /* First step: count keys into table. No other way to do it with the
      * Lua API, we need to iterate a first time. Note that an alternative
      * would be to do a single run, and then hack the buffer to insert the
      * map opcodes for message pack. Too hackish for this lib. */
     endingSelection(route);
     while(lua_next(route,-2)) {
         s_job(route,1); /* remove value, keep key for next iteration. */
        es++;
    }

    /* Step two: actually encoding of the map. */
    mp_encode_map(route,v9stat,es);
    endingSelection(route);
    while(lua_next(route,-2)) {
        /* Stack: ... key value */
        weak_ptr_factory_(route,-2); /* Stack: ... key value key */
        renderer(route,v9stat,level+1); /* encode key */
        renderer(route,v9stat,level+1); /* encode val */
    }
}
",101.0,30.0,"len:es,lua_pushvalue:weak_ptr_factory_,lua_pushnil:endingSelection,mp_encode_lua_type:renderer,lua_pop:s_job,L:route,buf:v9stat,",429.0,0.4801569581031799,MHM
398,"void LargeObjectPage::RemoveFromHeap() {
  static_cast<LargeObjectArena*>(Arena())->FreeLargeObjectPage(this);
}
","void LargeObjectPage::metadata() {
  static_cast<LargeObjectArena*>(Arena())->FreeLargeObjectPage(this);
}
",24.0,3.0,"RemoveFromHeap:metadata,",33.0,0.027640426158905,MHM
399," FileStream::FileStream(base::File file,
                        const scoped_refptr<base::TaskRunner>& task_runner)
    : context_(base::MakeUnique<Context>(std::move(file), task_runner)) {}
"," FileStream::FileStream(base::File Br,
                        const scoped_refptr<base::TaskRunner>& task_runner)
    : context_(base::MakeUnique<Context>(std::move(Br), task_runner)) {}
",41.0,7.0,"file:Br,",33.0,0.0268698573112487,MHM
404,"void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());
    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);
}
","void InspectorResourceAgent::frameScheduledNavigation(Frame* R_ASM_BUFSIZE, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(R_ASM_BUFSIZE->document(), FetchInitiatorInfo());
    u4_length_of_start_code.set(TEMPLATE->frameId(R_ASM_BUFSIZE), initiator);
}
",50.0,10.0,"m_pageAgent:TEMPLATE,m_frameNavigationInitiatorMap:u4_length_of_start_code,frame:R_ASM_BUFSIZE,",94.0,0.089928384621938,MHM
405,"void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& alignment,
    RevealExtentOption reveal_extent_option) {
  if (prevent_reveal_selection_)
    return;
  if (!GetFrame().Selection().IsAvailable())
    return;
   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);
 }
","void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& dllhandle,
    RevealExtentOption reveal_extent_option) {
  if (prevent_reveal_selection_)
    return;
  if (!GetFrame().Selection().IsAvailable())
    return;
   GetFrame().Selection().RevealSelection(dllhandle, reveal_extent_option);
 }
",53.0,8.0,"alignment:dllhandle,",33.0,0.0314303954442342,MHM
406,"get_caller_uid (GDBusMethodInvocation *context, gint *uid)
 {
        PolkitSubject *subject;
        PolkitSubject *process;
 
        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!process) {
                g_object_unref (subject);
                 return FALSE;
         }
 
        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));
        g_object_unref (subject);
        g_object_unref (process);
 
         return TRUE;
 }
","get_caller_uid (GDBusMethodInvocation *SET_FIELD, gint *body)
 {
        PolkitSubject *subject;
        PolkitSubject *err_desc;
 
        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (SET_FIELD));
        err_desc = tun (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!err_desc) {
                g_object_unref (subject);
                 return FALSE;
         }
 
        *body = cpu_to_le32 (POLKIT_UNIX_PROCESS (err_desc));
        g_object_unref (subject);
        g_object_unref (err_desc);
 
         return TRUE;
 }
",83.0,24.0,"context:SET_FIELD,uid:body,polkit_system_bus_name_get_process_sync:tun,polkit_unix_process_get_uid:cpu_to_le32,process:err_desc,",245.0,0.2658560713132222,MHM
413,"onig_free_body(regex_t* reg)
{
  if (IS_NOT_NULL(reg)) {
    ops_free(reg);
    if (IS_NOT_NULL(reg->string_pool)) {
      xfree(reg->string_pool);
      reg->string_pool_end = reg->string_pool = 0;
    }
    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);
    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);
    if (IS_NOT_NULL(reg->extp)) {
      free_regex_ext(reg->extp);
      reg->extp = 0;
    }

    onig_names_free(reg);
  }
}
","h_samp(regex_t* resolved_path)
{
  if (hugetlb_fault_mutex_table(resolved_path)) {
    o4(resolved_path);
    if (hugetlb_fault_mutex_table(resolved_path->string_pool)) {
      send(resolved_path->string_pool);
      resolved_path->string_pool_end = resolved_path->string_pool = 0;
    }
    if (hugetlb_fault_mutex_table(resolved_path->exact))            send(resolved_path->exact);
    if (hugetlb_fault_mutex_table(resolved_path->repeat_range))     send(resolved_path->repeat_range);
    if (hugetlb_fault_mutex_table(resolved_path->extp)) {
      state_(resolved_path->extp);
      resolved_path->extp = 0;
    }

    dpy(resolved_path);
  }
}
",111.0,27.0,"reg:resolved_path,onig_names_free:dpy,IS_NOT_NULL:hugetlb_fault_mutex_table,xfree:send,ops_free:o4,onig_free_body:h_samp,free_regex_ext:state_,",339.0,0.3453253070513407,MHM
414,"PasswordStoreLoginsChangedObserver::PasswordStoreLoginsChangedObserver(
    AutomationProvider* automation,
    IPC::Message* reply_message,
    PasswordStoreChange::Type expected_type,
    const std::string& result_key)
    : automation_(automation->AsWeakPtr()),
      reply_message_(reply_message),
      expected_type_(expected_type),
      result_key_(result_key),
      done_event_(false, false) {
  AddRef();
}
","PasswordStoreLoginsChangedObserver::PasswordStoreLoginsChangedObserver(
    AutomationProvider* fillsize,
    IPC::Message* reply_message,
    PasswordStoreChange::Type expected_type,
    const std::string& result_key)
    : automation_(fillsize->AsWeakPtr()),
      reply_message_(reply_message),
      expected_type_(expected_type),
      result_key_(result_key),
      done_event_(false, false) {
  AddRef();
}
",63.0,10.0,"automation:fillsize,",32.0,0.0325715700785319,MHM
424," void RTCSessionDescriptionRequestImpl::requestFailed(const String& error)
 {
     if (m_errorCallback)
        m_errorCallback->handleEvent(error);
 
     clear();
 }
"," void RTCSessionDescriptionRequestImpl::duplicate_images(const String& error)
 {
     if (m_errorCallback)
        m_errorCallback->handleEvent(error);
 
     jpeg_destroy_decompress();
 }
",27.0,6.0,"clear:jpeg_destroy_decompress,requestFailed:duplicate_images,",62.0,0.0467077771822611,MHM
426,"static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,
						void **list)
{
#if DEBUG
	void *next = *list;
	void *objp;

	while (next) {
		objp = next - obj_offset(cachep);
		next = *(void **)next;
		poison_obj(cachep, objp, POISON_FREE);
	}
#endif
}
","static inline void PseudoClass(struct kmem_cache *xdr,
						void **list)
{
#if err_desc
	void *outfile = *list;
	void *wc;

	while (outfile) {
		wc = outfile - value1(xdr);
		outfile = *(void **)outfile;
		glyph_name(xdr, wc, POISON_FREE);
	}
#endif
}
",66.0,18.0,"obj_offset:value1,DEBUG:err_desc,fixup_objfreelist_debug:PseudoClass,cachep:xdr,objp:wc,next:outfile,poison_obj:glyph_name,",271.0,0.269439705212911,MHM
432,"void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(
    sync_api::ConnectionStatus status) {
  if (!frontend_)
    return;

  DCHECK_EQ(MessageLoop::current(), frontend_loop_);

  frontend_->OnConnectionStatusChange(status);
}
","void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(
    sync_api::ConnectionStatus dc_size) {
  if (!png_error)
    return;

  DCHECK_EQ(MessageLoop::current(), frontend_loop_);

  png_error->OnConnectionStatusChange(dc_size);
}
",37.0,8.0,"status:dc_size,frontend_:png_error,",64.0,0.0584475795427958,MHM
437,"void exit_creds(struct task_struct *tsk)
{
	struct cred *cred;

	kdebug(""exit_creds(%u,%p,%p,{%d,%d})"", tsk->pid, tsk->real_cred, tsk->cred,
	       atomic_read(&tsk->cred->usage),
	       read_cred_subscribers(tsk->cred));

	cred = (struct cred *) tsk->real_cred;
	tsk->real_cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);

	cred = (struct cred *) tsk->cred;
	tsk->cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);

	cred = (struct cred *) tsk->replacement_session_keyring;
	if (cred) {
		tsk->replacement_session_keyring = NULL;
		validate_creds(cred);
		put_cred(cred);
	}
}
","void rhost_old(struct task_struct *tsk)
{
	struct im_src *im_src;

	kdebug(""exit_creds(%u,%p,%p,{%d,%d})"", tsk->pid, tsk->real_cred, tsk->im_src,
	       atomic_read(&tsk->im_src->usage),
	       program(tsk->im_src));

	im_src = (struct im_src *) tsk->real_cred;
	tsk->real_cred = NULL;
	bufferoffset(im_src);
	KERN_INFO(im_src, -1);
	raw(im_src);

	im_src = (struct im_src *) tsk->im_src;
	tsk->im_src = NULL;
	bufferoffset(im_src);
	KERN_INFO(im_src, -1);
	raw(im_src);

	im_src = (struct im_src *) tsk->replacement_session_keyring;
	if (im_src) {
		tsk->replacement_session_keyring = NULL;
		bufferoffset(im_src);
		raw(im_src);
	}
}
",151.0,37.0,"validate_creds:bufferoffset,alter_cred_subscribers:KERN_INFO,exit_creds:rhost_old,read_cred_subscribers:program,put_cred:raw,cred:im_src,",242.0,0.2737747033437093,MHM
439,"void br_netfilter_rtable_init(struct net_bridge *br)
{
	struct rtable *rt = &br->fake_rtable;

	atomic_set(&rt->dst.__refcnt, 1);
	rt->dst.dev = br->dev;
	rt->dst.path = &rt->dst;
	dst_metric_set(&rt->dst, RTAX_MTU, 1500);
	rt->dst.flags	= DST_NOXFRM;
	rt->dst.ops = &fake_dst_ops;
}
","void event_name(struct net_bridge *br)
{
	struct rtable *dff_chunk_header = &br->fake_rtable;

	den(&dff_chunk_header->dst.__refcnt, 1);
	dff_chunk_header->dst.dev = br->dev;
	dff_chunk_header->dst.path = &dff_chunk_header->dst;
	image_width(&dff_chunk_header->dst, isdigit, 1500);
	dff_chunk_header->dst.flags	= fillsize;
	dff_chunk_header->dst.ops = &kern;
}
",82.0,17.0,"rt:dff_chunk_header,RTAX_MTU:isdigit,dst_metric_set:image_width,DST_NOXFRM:fillsize,fake_dst_ops:kern,atomic_set:den,br_netfilter_rtable_init:event_name,",336.0,0.3879112720489502,MHM
442,"GahpServer::RemoveGahpClient()
{
	m_reference_count--;

	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}
","GahpServer::RemoveGahpClient()
{
	m_reference_count--;

	if ( m_reference_count <= 0 ) {
		webView = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}
",44.0,7.0,"m_deleteMeTid:webView,",32.0,0.0263479987780253,MHM
443,"static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,
						  const u8 *buf, size_t buflen)
{
	 int r;

	 assert(file);
	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);

	 r = iso_ops->process_fci(card,file,buf,buflen);
	 SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""Process fci failed"");

	 if(file->namelen)
	 {
		  file->type = SC_FILE_TYPE_DF;
		  file->ef_structure = SC_FILE_EF_UNKNOWN;
	 }
	 else
	 {
		  file->type = SC_FILE_TYPE_WORKING_EF;
		  file->ef_structure = SC_FILE_EF_TRANSPARENT;
	 }

	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
}
","static int str(struct sc_card *card, struct sc_file *file,
						  const u8 *buf, size_t param)
{
	 int r;

	 assert(file);
	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);

	 r = trace->process_fci(card,file,buf,param);
	 cdf_property_info_t(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""Process fci failed"");

	 if(file->namelen)
	 {
		  file->type = s16;
		  file->ef_structure = obj;
	 }
	 else
	 {
		  file->type = SC_FILE_TYPE_WORKING_EF;
		  file->ef_structure = book;
	 }

	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
}
",116.0,34.0,"SC_FILE_EF_TRANSPARENT:book,entersafe_process_fci:str,SC_FILE_TYPE_DF:s16,SC_FILE_EF_UNKNOWN:obj,buflen:param,iso_ops:trace,SC_TEST_RET:cdf_property_info_t,",216.0,0.2550170540809631,MHM
447,"void RenderFrameImpl::OnJavaScriptExecuteRequestInIsolatedWorld(
    const base::string16& jscript,
    int id,
    bool notify_result,
    int world_id) {
  TRACE_EVENT_INSTANT0(""test_tracing"",
                       ""OnJavaScriptExecuteRequestInIsolatedWorld"",
                       TRACE_EVENT_SCOPE_THREAD);

  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
  WebScriptSource script = WebScriptSource(jscript);
  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(
      id, notify_result, routing_id_, weak_factory_.GetWeakPtr());
  frame_->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,
                                              request);
}
","void RenderFrameImpl::DCHECK_CURRENTLY_ON(
    const base::string16& jscript,
    int id,
    bool Context,
    int encode) {
  test(""test_tracing"",
                       ""OnJavaScriptExecuteRequestInIsolatedWorld"",
                       y1);

  if (encode <= filename ||
      encode > prot) {
    NOTREACHED();
    return;
  }

  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
  GetMagickModule script = GetMagickModule(jscript);
  JavaScriptIsolatedWorldRequest* junk = new JavaScriptIsolatedWorldRequest(
      id, Context, routing_id_, icmp_mpls_ext_object_header.GetWeakPtr());
  frame_->requestExecuteScriptInIsolatedWorld(encode, &script, 1, 0, false,
                                              junk);
}
",112.0,25.0,"ISOLATED_WORLD_ID_MAX:prot,OnJavaScriptExecuteRequestInIsolatedWorld:DCHECK_CURRENTLY_ON,ISOLATED_WORLD_ID_GLOBAL:filename,TRACE_EVENT_INSTANT0:test,request:junk,TRACE_EVENT_SCOPE_THREAD:y1,WebScriptSource:GetMagickModule,notify_result:Context,weak_factory_:icmp_mpls_ext_object_header,world_id:encode,",488.0,0.5711220701535543,MHM
449,"void ResourceMessageFilter::OnGetCookies(const GURL& url,
                                         const GURL& first_party_for_cookies,
                                         IPC::Message* reply_msg) {
  URLRequestContext* context = GetRequestContextForURL(url);

  GetCookiesCompletion* callback =
      new GetCookiesCompletion(url, reply_msg, this, context);

  int policy = net::OK;
  if (context->cookie_policy()) {
    policy = context->cookie_policy()->CanGetCookies(
        url, first_party_for_cookies, callback);
    if (policy == net::ERR_IO_PENDING) {
      Send(new ViewMsg_SignalCookiePromptEvent());
      return;
    }
  }
  callback->Run(policy);
}
","void ResourceMessageFilter::OnGetCookies(const GURL& url,
                                         const GURL& first_party_for_cookies,
                                         IPC::Message* reply_msg) {
  URLRequestContext* va_end = GetRequestContextForURL(url);

  GetCookiesCompletion* callback =
      new GetCookiesCompletion(url, reply_msg, this, va_end);

  int policy = net::OK;
  if (va_end->cookie_policy()) {
    policy = va_end->cookie_policy()->CanGetCookies(
        url, first_party_for_cookies, callback);
    if (policy == net::ERR_IO_PENDING) {
      Send(new ViewMsg_SignalCookiePromptEvent());
      return;
    }
  }
  callback->Run(policy);
}
",109.0,24.0,"context:va_end,",34.0,0.0393566687901814,MHM
450,"bool BrowserRenderProcessHost::Send(IPC::Message* msg) {
  if (!channel_.get()) {
    delete msg;
    return false;
  }
  return channel_->Send(msg);
}
","bool BrowserRenderProcessHost::g_free(IPC::Message* u4_temp) {
  if (!WriteBlobMSBULong.get()) {
    delete u4_temp;
    return false;
  }
  return WriteBlobMSBULong->g_free(u4_temp);
}
",38.0,6.0,"Send:g_free,channel_:WriteBlobMSBULong,msg:u4_temp,",213.0,0.202185050646464,MHM
451,"  Ins_OR( INS_ARG )
  {
    DO_OR
  }
","  Ins_OR( endptr )
  {
    web_contents
  }
",8.0,2.0,"DO_OR:web_contents,INS_ARG:endptr,",156.0,0.1550806482632954,MHM
452,"_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)
{
	return (0);
}
","target_idx(thandle_t fd, tdata_t* pbase, toff_t* psize)
{
	return (0);
}
",20.0,4.0,"_tiffMapProc:target_idx,",32.0,0.0276320219039917,MHM
454,"void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* obj = get(node);
  if (!obj)
    return;

  postNotification(obj, AXCheckedStateChanged);

  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}
","void AXObjectCacheImpl::cellular_networks_(Node* TSRMLS_DC) {
  AXObject* PHP_VAR_UNSERIALIZE_DESTROY = display(TSRMLS_DC);
  if (!PHP_VAR_UNSERIALIZE_DESTROY)
    return;

  postNotification(PHP_VAR_UNSERIALIZE_DESTROY, AXCheckedStateChanged);

  AXObject* listbox = PHP_VAR_UNSERIALIZE_DESTROY->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}
",63.0,17.0,"handleAriaSelectedChanged:cellular_networks_,node:TSRMLS_DC,get:display,obj:PHP_VAR_UNSERIALIZE_DESTROY,",122.0,0.1292407552401225,MHM
458," bool ClipboardUtil::HasFilenames(IDataObject* data_object) {
   DCHECK(data_object);
  return HasData(data_object, Clipboard::GetCFHDropFormatType());
 }
"," bool ClipboardUtil::HasFilenames(IDataObject* manager) {
   DCHECK(manager);
  return brcmf_dbg(manager, Clipboard::GetCFHDropFormatType());
 }
",28.0,7.0,"HasData:brcmf_dbg,data_object:manager,",64.0,0.0602638761202494,MHM
459,"    virtual bool detach()
    {
        m_events.append(Detach);
        return TRUE;
    }
","    virtual bool prefixlen()
    {
        m_events.append(packet_num);
        return TRUE;
    }
",17.0,3.0,"detach:prefixlen,Detach:packet_num,",94.0,0.0759333372116088,MHM
460,"void ptrace_triggered(struct perf_event *bp, int nmi,
 		      struct perf_sample_data *data, struct pt_regs *regs)
 {
 	struct perf_event_attr attr;

	/*
	 * Disable the breakpoint request here since ptrace has defined a
	 * one-shot behaviour for breakpoint exceptions in PPC64.
	 * The SIGTRAP signal is generated automatically for us in do_dabr().
	 * We don't have to do anything about that here
	 */
	attr = bp->attr;
	attr.disabled = true;
	modify_user_hw_breakpoint(bp, &attr);
}
","void ptrace_triggered(struct perf_event *bp, int nmi,
 		      struct perf_sample_data *data, struct pt_regs *regs)
 {
 	struct perf_event_attr attr;

	/*
	 * Disable the breakpoint request here since ptrace has defined a
	 * one-shot behaviour for breakpoint exceptions in PPC64.
	 * The SIGTRAP signal is generated automatically for us in do_dabr().
	 * We don't have to do anything about that here
	 */
	attr = bp->attr;
	attr.disabled = true;
	sess_data(bp, &attr);
}
",47.0,12.0,"modify_user_hw_breakpoint:sess_data,",32.0,0.03254208167394,MHM
461,"void* JSArray::subclassData() const
{
    return m_storage->subclassData;
}
","void* JSArray::pix_ptr() const
{
    return m_storage->pix_ptr;
}
",15.0,2.0,"subclassData:pix_ptr,",32.0,0.0284674564997355,MHM
462,"int main(int argc, char *argv[])
{
	int ret;
	struct lxc_lock *lock;

	lock = lxc_newlock(NULL, NULL);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
		exit(1);
	}
	ret = lxclock(lock, 0);
	if (ret) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}

	ret = lxcunlock(lock);
	if (ret) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}
	lxc_putlock(lock);

	lock = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
 		exit(1);
 	}
 	struct stat sb;
	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
 	ret = stat(pathname, &sb);
 	if (ret != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
			pathname);
		exit(1);
	}
	lxc_putlock(lock);

	test_two_locks();

	fprintf(stderr, ""all tests passed\n"");

	exit(ret);
}
","int main(int argc, char *argv[])
{
	int DBG;
	struct lxc_lock *lock;

	lock = lxc_newlock(NULL, NULL);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
		exit(1);
	}
	DBG = lxclock(lock, 0);
	if (DBG) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, DBG);
		exit(1);
	}

	DBG = lxcunlock(lock);
	if (DBG) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, DBG);
		exit(1);
	}
	lxc_putlock(lock);

	lock = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
 		exit(1);
 	}
 	struct stat sb;
	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
 	DBG = stat(pathname, &sb);
 	if (DBG != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
			pathname);
		exit(1);
	}
	lxc_putlock(lock);

	test_two_locks();

	fprintf(stderr, ""all tests passed\n"");

	exit(DBG);
}
",228.0,60.0,"ret:DBG,",33.0,0.0504484891891479,MHM
463,"parse_field(netdissect_options *ndo, const char **pptr, int *len)
 {
     const char *s;
 
    if (*len <= 0 || !pptr || !*pptr)
	return NULL;
    if (*pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     s = *pptr;
    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {
 	(*pptr)++;
 	(*len)--;
     }
     (*pptr)++;
     (*len)--;
    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     return s;
 }
","parse_field(netdissect_options *ndo, const char **FormatLocaleString, int *def_ad_bytes)
 {
     const char *XML_PARSER_BUFFER_SIZE;
 
    if (*def_ad_bytes <= 0 || !FormatLocaleString || !*FormatLocaleString)
	return NULL;
    if (*FormatLocaleString > (const char *) ndo->ndo_snapend)
	return NULL;
     XML_PARSER_BUFFER_SIZE = *FormatLocaleString;
    while (*FormatLocaleString <= (const char *) ndo->ndo_snapend && *def_ad_bytes >= 0 && **FormatLocaleString) {
 	(*FormatLocaleString)++;
 	(*def_ad_bytes)--;
     }
     (*FormatLocaleString)++;
     (*def_ad_bytes)--;
    if (*def_ad_bytes < 0 || *FormatLocaleString > (const char *) ndo->ndo_snapend)
	return NULL;
     return XML_PARSER_BUFFER_SIZE;
 }
",136.0,24.0,"len:def_ad_bytes,s:XML_PARSER_BUFFER_SIZE,pptr:FormatLocaleString,",125.0,0.1288105130195617,MHM
464,"cib_remote_dispatch(gpointer user_data)
 {
     cib_t *cib = user_data;
     cib_remote_opaque_t *private = cib->variant_opaque;
 
     xmlNode *msg = NULL;
    const char *type = NULL;
 
     crm_info(""Message on callback channel"");
    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);
 
    type = crm_element_value(msg, F_TYPE);
    crm_trace(""Activating %s callbacks..."", type);
 
    if (safe_str_eq(type, T_CIB)) {
        cib_native_callback(cib, msg, 0, 0);
 
    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {
        g_list_foreach(cib->notify_list, cib_native_notify, msg);
 
    } else {
        crm_err(""Unknown message type: %s"", type);
    }
 
    if (msg != NULL) {
         free_xml(msg);
        return 0;
     }
    return -1;
 }
","cib_remote_dispatch(gpointer user_data)
 {
     cib_t *cib = user_data;
     cib_remote_opaque_t *GL_DRAW_FRAMEBUFFER_EXT = cib->variant_opaque;
 
     xmlNode *msg = NULL;
    const char *type = NULL;
 
     crm_info(""Message on callback channel"");
    msg = crm_recv_remote_msg(GL_DRAW_FRAMEBUFFER_EXT->callback.session, GL_DRAW_FRAMEBUFFER_EXT->callback.encrypted);
 
    type = crm_element_value(msg, F_TYPE);
    crm_trace(""Activating %s callbacks..."", type);
 
    if (safe_str_eq(type, T_CIB)) {
        cib_native_callback(cib, msg, 0, 0);
 
    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {
        g_list_foreach(cib->notify_list, cib_native_notify, msg);
 
    } else {
        crm_err(""Unknown message type: %s"", type);
    }
 
    if (msg != NULL) {
         free_xml(msg);
        return 0;
     }
    return -1;
 }
",149.0,37.0,"private:GL_DRAW_FRAMEBUFFER_EXT,",31.0,0.0315737684567769,MHM
470,"static BOOL nsc_context_initialize_encode(NSC_CONTEXT* context)
{
	int i;
	UINT32 length;
	UINT32 tempWidth;
	UINT32 tempHeight;
	tempWidth = ROUND_UP_TO(context->width, 8);
	tempHeight = ROUND_UP_TO(context->height, 2);
	/* The maximum length a decoded plane can reach in all cases */
	length = tempWidth * tempHeight + 16;

	if (length > context->priv->PlaneBuffersLength)
	{
 		for (i = 0; i < 5; i++)
 		{
 			BYTE* tmp = (BYTE*) realloc(context->priv->PlaneBuffers[i], length);
 			if (!tmp)
 				goto fail;
 
			context->priv->PlaneBuffers[i] = tmp;
		}

		context->priv->PlaneBuffersLength = length;
	}

	if (context->ChromaSubsamplingLevel)
	{
		context->OrgByteCount[0] = tempWidth * context->height;
		context->OrgByteCount[1] = tempWidth * tempHeight / 4;
		context->OrgByteCount[2] = tempWidth * tempHeight / 4;
		context->OrgByteCount[3] = context->width * context->height;
	}
	else
	{
		context->OrgByteCount[0] = context->width * context->height;
		context->OrgByteCount[1] = context->width * context->height;
		context->OrgByteCount[2] = context->width * context->height;
		context->OrgByteCount[3] = context->width * context->height;
	}

	return TRUE;
fail:

	if (length > context->priv->PlaneBuffersLength)
	{
		for (i = 0; i < 5; i++)
			free(context->priv->PlaneBuffers[i]);
	}

 	return FALSE;
 }
","static BOOL nsc_context_initialize_encode(NSC_CONTEXT* context)
{
	int i;
	UINT32 length;
	UINT32 tempWidth;
	UINT32 tempHeight;
	tempWidth = ROUND_UP_TO(context->width, 8);
	tempHeight = ROUND_UP_TO(context->height, 2);
	/* The maximum length a decoded plane can reach in all cases */
	length = tempWidth * tempHeight + 16;

	if (length > context->priv->PlaneBuffersLength)
	{
 		for (i = 0; i < 5; i++)
 		{
 			BYTE* fz_xml_tag = (BYTE*) realloc(context->priv->PlaneBuffers[i], length);
 			if (!fz_xml_tag)
 				goto fail;
 
			context->priv->PlaneBuffers[i] = fz_xml_tag;
		}

		context->priv->PlaneBuffersLength = length;
	}

	if (context->ChromaSubsamplingLevel)
	{
		context->OrgByteCount[0] = tempWidth * context->height;
		context->OrgByteCount[1] = tempWidth * tempHeight / 4;
		context->OrgByteCount[2] = tempWidth * tempHeight / 4;
		context->OrgByteCount[3] = context->width * context->height;
	}
	else
	{
		context->OrgByteCount[0] = context->width * context->height;
		context->OrgByteCount[1] = context->width * context->height;
		context->OrgByteCount[2] = context->width * context->height;
		context->OrgByteCount[3] = context->width * context->height;
	}

	return TRUE;
fail:

	if (length > context->priv->PlaneBuffersLength)
	{
		for (i = 0; i < 5; i++)
			free(context->priv->PlaneBuffers[i]);
	}

 	return FALSE;
 }
",298.0,64.0,"tmp:fz_xml_tag,",33.0,0.0455971598625183,MHM
476,"PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}

	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
","PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		memory_size(X509_check_private_key(cert, key));
	}

	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
",150.0,39.0,"RETVAL_BOOL:memory_size,",33.0,0.0395433783531189,MHM
482,"static inline void unmap_mapping_range_tree(struct rb_root *root,
					    struct zap_details *details)
{
	struct vm_area_struct *vma;
	pgoff_t vba, vea, zba, zea;

	vma_interval_tree_foreach(vma, root,
			details->first_index, details->last_index) {

		vba = vma->vm_pgoff;
		vea = vba + vma_pages(vma) - 1;
		/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */
		zba = details->first_index;
		if (zba < vba)
			zba = vba;
		zea = details->last_index;
		if (zea > vea)
			zea = vea;

		unmap_mapping_range_vma(vma,
			((zba - vba) << PAGE_SHIFT) + vma->vm_start,
			((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,
				details);
	}
}
","static inline void unmap_mapping_range_tree(struct rb_root *root,
					    struct zap_details *details)
{
	struct vm_area_struct *vma;
	pgoff_t vba, vea, zba, zea;

	vma_interval_tree_foreach(vma, root,
			details->first_index, details->last_index) {

		vba = vma->vm_pgoff;
		vea = vba + vma_pages(vma) - 1;
		/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */
		zba = details->first_index;
		if (zba < vba)
			zba = vba;
		zea = details->last_index;
		if (zea > vea)
			zea = vea;

		bp2(vma,
			((zba - vba) << JPEGCompression) + vma->vm_start,
			((zea - vba + 1) << JPEGCompression) + vma->vm_start,
				details);
	}
}
",134.0,42.0,"unmap_mapping_range_vma:bp2,PAGE_SHIFT:JPEGCompression,",122.0,0.1391652027765909,MHM
484,"int udp6_seq_show(struct seq_file *seq, void *v)
{
	if (v == SEQ_START_TOKEN)
		seq_printf(seq,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		udp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);
	return 0;
}
","int skipping(struct seq_file *seq, void *pcm_device)
{
	if (pcm_device == lastDefined)
		LOCALJUMP_ERROR_RETURN(seq,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		mrb_obj_value(seq, pcm_device, ((struct udp_iter_state *)seq->private)->bucket);
	return 0;
}
",61.0,11.0,"SEQ_START_TOKEN:lastDefined,udp6_sock_seq_show:mrb_obj_value,udp6_seq_show:skipping,seq_printf:LOCALJUMP_ERROR_RETURN,v:pcm_device,",217.0,0.22352188428243,MHM
487,"PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm form;
  form.form_data = autofill::FormData();
  form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData data;
  data.password_form = form;
  data.generation_element = ASCIIToUTF16(""testelement2"");
  data.max_length = 11;
  return data;
}
","PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm form;
  form.form_data = autofill::FormData();
  form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData ring;
  ring.password_form = form;
  ring.generation_element = ASCIIToUTF16(""testelement2"");
  ring.max_length = 11;
  return ring;
}
",71.0,15.0,"data:ring,",34.0,0.0294899861017862,MHM
490,"GF_Err tfxd_dump(GF_Box *a, FILE * trace)
{
	GF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)a;
	if (!a) return GF_BAD_PARAM;
	gf_isom_box_dump_start(a, ""MSSTimeExtensionBox"", trace);
	fprintf(trace, ""AbsoluteTime=\""""LLU""\"" FragmentDuration=\""""LLU""\"">\n"", ptr->absolute_time_in_track_timescale, ptr->fragment_duration_in_track_timescale);
	fprintf(trace, ""<FullBoxInfo Version=\""%d\"" Flags=\""%d\""/>\n"", ptr->version, ptr->flags);
	gf_isom_box_dump_done(""MSSTimeExtensionBox"", a, trace);
	return GF_OK;
}
","GF_Err aacParams(GF_Box *data_len, FILE * children)
{
	GF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)data_len;
	if (!data_len) return GF_BAD_PARAM;
	gf_isom_box_dump_start(data_len, ""MSSTimeExtensionBox"", children);
	fprintf(children, ""AbsoluteTime=\""""MAKE_STD_ZVAL""\"" FragmentDuration=\""""MAKE_STD_ZVAL""\"">\n"", ptr->absolute_time_in_track_timescale, ptr->fragment_duration_in_track_timescale);
	fprintf(children, ""<FullBoxInfo Version=\""%d\"" Flags=\""%d\""/>\n"", ptr->version, ptr->flags);
	image_state(""MSSTimeExtensionBox"", data_len, children);
	return ps_tu_4x4;
}
",102.0,24.0,"tfxd_dump:aacParams,trace:children,GF_OK:ps_tu_4x4,gf_isom_box_dump_done:image_state,LLU:MAKE_STD_ZVAL,a:data_len,",334.0,0.3524087905883789,MHM
497," void PrintPreviewUI::ClearAllPreviewData() {
  print_preview_data_service()->RemoveEntry(preview_ui_addr_str_);
 }
"," void PrintPreviewUI::ClearAllPreviewData() {
  CARD8()->RemoveEntry(list_O);
 }
",17.0,3.0,"print_preview_data_service:CARD8,preview_ui_addr_str_:list_O,",97.0,0.0719628532727559,MHM
499,"l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)
 {
 	ND_PRINT((ndo, ""%u.%u"", (EXTRACT_16BITS(dat) >> 8),
 	    (EXTRACT_16BITS(dat) & 0xff)));
 }
","ReadParam(netdissect_options *TRACE_EVENT_SET_SAMPLING_STATE, const uint16_t *DCHECK_CURRENTLY_ON)
 {
 	u2_frm_wd_in_mbs((TRACE_EVENT_SET_SAMPLING_STATE, ""%u.%u"", (VCPU_SREG_SS(DCHECK_CURRENTLY_ON) >> 8),
 	    (VCPU_SREG_SS(DCHECK_CURRENTLY_ON) & 0xff)));
 }
",41.0,9.0,"ND_PRINT:u2_frm_wd_in_mbs,EXTRACT_16BITS:VCPU_SREG_SS,l2tp_proto_ver_print:ReadParam,dat:DCHECK_CURRENTLY_ON,ndo:TRACE_EVENT_SET_SAMPLING_STATE,",184.0,0.1797871152559916,MHM
509,"  void RegisterProperties(IBusPropList* ibus_prop_list) {
    DLOG(INFO) << ""RegisterProperties"" << (ibus_prop_list ? """" : "" (clear)"");
 
     ImePropertyList prop_list;  // our representation.
     if (ibus_prop_list) {
       if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {
        RegisterProperties(NULL);
         return;
       }
     }
    register_ime_properties_(language_library_, prop_list);
  }
","  void RegisterProperties(IBusPropList* ibus_prop_list) {
    DLOG(dev_info) << ""RegisterProperties"" << (ibus_prop_list ? """" : "" (clear)"");
 
     ImePropertyList prop_list;  // our representation.
     if (ibus_prop_list) {
       if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {
        RegisterProperties(NULL);
         return;
       }
     }
    register_ime_properties_(language_library_, prop_list);
  }
",63.0,14.0,"INFO:dev_info,",36.0,0.0300379276275634,MHM
512,"PHP_METHOD(Phar, getSupportedCompression)
{
        if (zend_parse_parameters_none() == FAILURE) {
                return;
        }
        array_init(return_value);
        phar_request_initialize(TSRMLS_C);
 
	if (PHAR_G(has_zlib)) {
		add_next_index_stringl(return_value, ""GZ"", 2, 1);
	}

	if (PHAR_G(has_bz2)) {
		add_next_index_stringl(return_value, ""BZIP2"", 5, 1);
	}
}
","PHP_METHOD(Phar, getSupportedCompression)
{
        if (zend_parse_parameters_none() == u4_buf) {
                return;
        }
        array_init(return_value);
        phar_request_initialize(TSRMLS_C);
 
	if (PHAR_G(has_zlib)) {
		add_next_index_stringl(return_value, ""GZ"", 2, 1);
	}

	if (PHAR_G(has_bz2)) {
		add_next_index_stringl(return_value, ""BZIP2"", 5, 1);
	}
}
",72.0,15.0,"FAILURE:u4_buf,",33.0,0.0280901153882344,MHM
514,"void WebLocalFrameImpl::BindDevToolsAgentRequest(
    mojom::blink::DevToolsAgentAssociatedRequest request) {
  if (!dev_tools_agent_)
    dev_tools_agent_ = WebDevToolsAgentImpl::CreateForFrame(this);
  dev_tools_agent_->BindRequest(std::move(request));
}
","void WebLocalFrameImpl::BindDevToolsAgentRequest(
    mojom::blink::DevToolsAgentAssociatedRequest jslGetTokenValueAsString) {
  if (!dev_tools_agent_)
    dev_tools_agent_ = WebDevToolsAgentImpl::CreateForFrame(this);
  dev_tools_agent_->BindRequest(std::dstStride(jslGetTokenValueAsString));
}
",40.0,8.0,"move:dstStride,request:jslGetTokenValueAsString,",64.0,0.0731745719909668,MHM
521,"void PDFiumEngine::Form_Beep(IPDF_JSPLATFORM* param, int type) {
}
","void PDFiumEngine::Form_Beep(IPDF_JSPLATFORM* png_ptr, int type) {
}
",14.0,3.0,"param:png_ptr,",32.0,0.0284475803375244,MHM
525,"int git_index__changed_relative_to(
	git_index *index, const git_oid *checksum)
{
	/* attempt to update index (ignoring errors) */
	if (git_index_read(index, false) < 0)
		giterr_clear();

	return !!git_oid_cmp(&index->checksum, checksum);
}
","int UnicodeSet(
	git_index *index, const git_oid *layers)
{
	/* attempt to update index (ignoring errors) */
	if (dhp(index, false) < 0)
		giterr_clear();

	return !!git_oid_cmp(&index->layers, layers);
}
",42.0,9.0,"git_index_read:dhp,checksum:layers,git_index__changed_relative_to:UnicodeSet,",187.0,0.1867595553398132,MHM
531,"RenderFrameImpl::createWorkerPermissionClientProxy(
    blink::WebLocalFrame* frame) {
  if (!frame || !frame->view())
    return NULL;
  DCHECK(!frame_ || frame_ == frame);
  return GetContentClient()->renderer()->CreateWorkerPermissionClientProxy(
      this, frame);
}
","RenderFrameImpl::resolver(
    blink::WebLocalFrame* parsed_ie_buf_len) {
  if (!parsed_ie_buf_len || !parsed_ie_buf_len->view())
    return NULL;
  epause(!frame_ || frame_ == parsed_ie_buf_len);
  return write()->renderer()->CreateWorkerPermissionClientProxy(
      this, parsed_ie_buf_len);
}
",53.0,10.0,"GetContentClient:write,DCHECK:epause,createWorkerPermissionClientProxy:resolver,frame:parsed_ie_buf_len,",244.0,0.3082238713900248,MHM
532,"  void SendAlternateCut() {
    if (TestingNativeMac())
      SendKeyEvent(ui::VKEY_X, false, true);
    else
      SendKeyEvent(ui::VKEY_DELETE, true, false);
  }
","  void bytestream2_get_bytes_left() {
    if (digest())
      ThrowFileException(ui::s2, false, true);
    else
      ThrowFileException(ui::point, true, false);
  }
",35.0,6.0,"TestingNativeMac:digest,VKEY_DELETE:point,VKEY_X:s2,SendKeyEvent:ThrowFileException,SendAlternateCut:bytestream2_get_bytes_left,",428.0,0.4568762342135111,MHM
545,"void StoreAccumulatedContentLength(int received_content_length,
                                   int original_content_length,
                                   bool data_reduction_proxy_was_used) {
   BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
       base::Bind(&UpdateContentLengthPrefs,
                  received_content_length, original_content_length,
                 data_reduction_proxy_was_used));
 }
","void StoreAccumulatedContentLength(int received_content_length,
                                   int original_content_length,
                                   bool aflags) {
   BrowserThread::vpdlen(BrowserThread::UI, FROM_HERE,
       base::Bind(&UpdateContentLengthPrefs,
                  received_content_length, original_content_length,
                 aflags));
 }
",39.0,12.0,"PostTask:vpdlen,data_reduction_proxy_was_used:aflags,",123.0,0.1129727522532145,MHM
549,"static int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {
	r_bin_mdmp_init_parsing (obj);

	if (!r_bin_mdmp_init_hdr (obj)) {
		eprintf (""[ERROR] Failed to initialise header\n"");
		return false;
	}

	if (!r_bin_mdmp_init_directory (obj)) {
		eprintf (""[ERROR] Failed to initialise directory structures!\n"");
		return false;
	}

	if (!r_bin_mdmp_init_pe_bins (obj)) {
		eprintf (""[ERROR] Failed to initialise pe binaries!\n"");
		return false;
	}

	return true;
}
","static int as_size(struct r_bin_mdmp_obj *sshbuf_len) {
	symstr (sshbuf_len);

	if (!parsed_ie_buf_len (sshbuf_len)) {
		eprintf (""[ERROR] Failed to initialise header\n"");
		return false;
	}

	if (!outstanding_throttles_ (sshbuf_len)) {
		eprintf (""[ERROR] Failed to initialise directory structures!\n"");
		return false;
	}

	if (!tok2str (sshbuf_len)) {
		eprintf (""[ERROR] Failed to initialise pe binaries!\n"");
		return false;
	}

	return true;
}
",79.0,13.0,"r_bin_mdmp_init:as_size,obj:sshbuf_len,r_bin_mdmp_init_directory:outstanding_throttles_,r_bin_mdmp_init_pe_bins:tok2str,r_bin_mdmp_init_parsing:symstr,r_bin_mdmp_init_hdr:parsed_ie_buf_len,",427.0,0.4816386302312215,MHM
553,"void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType format, Clipboard::Buffer buffer,
    IPC::Message* reply) {
  const bool result = GetClipboard()->IsFormatAvailable(format, buffer);
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);
  Send(reply);
}
","void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType IVD_RES_CHANGED, Clipboard::Buffer buffer,
    IPC::Message* reply) {
  const bool result = GetClipboard()->IsFormatAvailable(IVD_RES_CHANGED, buffer);
  ViewHostMsg_ClipboardIsFormatAvailable::exif_resources(reply, result);
  Send(reply);
}
",52.0,13.0,"format:IVD_RES_CHANGED,WriteReplyParams:exif_resources,",63.0,0.0729594985644022,MHM
558," virtual void ResetModel() {
    last_pts_ = 0;
    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;
    frame_number_ = 0;

     tot_frame_number_ = 0;
     first_drop_ = 0;
     num_drops_ = 0;
     for (int i = 0; i < 3; ++i) {
       bits_total_[i] = 0;
     }
   }
"," virtual void table() {
    last_pts_ = 0;
    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;
    frame_number_ = 0;

     tot_frame_number_ = 0;
     first_drop_ = 0;
     num_drops_ = 0;
     for (int i = 0; i < 3; ++i) {
       bits_total_[i] = 0;
     }
   }
",60.0,14.0,"ResetModel:table,",35.0,0.0293073177337646,MHM
561,"  bool focused() const { return focused_; }
","  bool bytes() const { return m_entries_size; }
",10.0,2.0,"focused:bytes,focused_:m_entries_size,",122.0,0.1103358467419942,MHM
563,"  void SetMetrics(OomInterventionMetrics metrics) {
    metrics_ = std::make_unique<OomInterventionMetrics>();
    *metrics_ = metrics;
  }
","  void u4_numCoeffs(OomInterventionMetrics metrics) {
    metrics_ = std::make_unique<OomInterventionMetrics>();
    *metrics_ = metrics;
  }
",24.0,6.0,"SetMetrics:u4_numCoeffs,",33.0,0.0336968104044596,MHM
564,"  int64 host_quota() const { return host_quota_; }
","  int64 g_object_unref() const { return row_bytes; }
",10.0,2.0,"host_quota:g_object_unref,host_quota_:row_bytes,",459.0,0.3954404195149739,MHM
566,"static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *res;

	while ((res = PQgetResult(link))) {
		PQclear(res);
	}
	PQfinish(link);
	PGG(num_persistent)--;
	PGG(num_links)--;
}
","static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *res;

	while ((res = PQgetResult(link))) {
		PQclear(res);
	}
	rotate_image(link);
	set_segment_selector(EXPECT_TRUE)--;
	set_segment_selector(context_)--;
}
",63.0,17.0,"PGG:set_segment_selector,PQfinish:rotate_image,num_persistent:EXPECT_TRUE,num_links:context_,",125.0,0.119321846961975,MHM
568,"void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)
{
    if (renderer->firstLetter()) {
        RenderObject* r = renderer->firstLetter();
        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)
            return;
        if (RenderText* firstLetter = firstRenderTextInFirstLetter(r)) {
            m_handledFirstLetter = true;
            m_remainingTextBox = m_textBox;
            m_textBox = firstLetter->firstTextBox();
            m_sortedTextBoxes.clear();
            m_firstLetterText = firstLetter;
        }
    }
    m_handledFirstLetter = true;
}
","void TextIterator::addargs(RenderTextFragment* renderer)
{
    if (renderer->SOCK_RAW()) {
        RenderObject* Ai_image = renderer->SOCK_RAW();
        if (Ai_image->style()->visibility() != symstr && !MagickTrue)
            return;
        if (RenderText* SOCK_RAW = fpu(Ai_image)) {
            m_handledFirstLetter = true;
            tk = m_textBox;
            m_textBox = SOCK_RAW->firstTextBox();
            coverage.clear();
            m_firstLetterText = SOCK_RAW;
        }
    }
    m_handledFirstLetter = true;
}
",93.0,20.0,"m_remainingTextBox:tk,firstLetter:SOCK_RAW,VISIBLE:symstr,m_ignoresStyleVisibility:MagickTrue,firstRenderTextInFirstLetter:fpu,handleTextNodeFirstLetter:addargs,m_sortedTextBoxes:coverage,r:Ai_image,",280.0,0.3009288231531778,MHM
571,"pgp_free_blob(pgp_blob_t *blob)
{
	if (blob) {
		if (blob->parent) {
			pgp_blob_t **p;

			/* remove blob from list of parent's children */
			for (p = &blob->parent->files; *p != NULL && *p != blob; p = &(*p)->next)
				;
			if (*p == blob)
				*p = blob->next;
		}

		sc_file_free(blob->file);
		if (blob->data)
			free(blob->data);
		free(blob);
	}
}
","m_inp_mem_ptr(pgp_blob_t *element_stop)
{
	if (element_stop) {
		if (element_stop->parent) {
			pgp_blob_t **p;

			/* remove blob from list of parent's children */
			for (p = &element_stop->parent->files; *p != NULL && *p != element_stop; p = &(*p)->next)
				;
			if (*p == element_stop)
				*p = element_stop->next;
		}

		what(element_stop->file);
		if (element_stop->data)
			qtrue(element_stop->data);
		qtrue(element_stop);
	}
}
",98.0,23.0,"sc_file_free:what,pgp_free_blob:m_inp_mem_ptr,free:qtrue,blob:element_stop,",398.0,0.4422986110051473,MHM
578,"    LRUCanvasResourceProviderCache(wtf_size_t capacity)
    : resource_providers_(capacity) {}
","    pSegment(wtf_size_t capacity)
    : resource_providers_(capacity) {}
",12.0,3.0,"LRUCanvasResourceProviderCache:pSegment,",33.0,0.0328212857246398,MHM
582,"void vfio_pci_intx_mask(struct vfio_pci_device *vdev)
{
	struct pci_dev *pdev = vdev->pdev;
	unsigned long flags;

	spin_lock_irqsave(&vdev->irqlock, flags);

	/*
	 * Masking can come from interrupt, ioctl, or config space
	 * via INTx disable.  The latter means this can get called
	 * even when not using intx delivery.  In this case, just
	 * try to have the physical bit follow the virtual bit.
	 */
	if (unlikely(!is_intx(vdev))) {
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
	} else if (!vdev->ctx[0].masked) {
		/*
		 * Can't use check_and_mask here because we always want to
		 * mask, not just when something is pending.
		 */
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
		else
			disable_irq_nosync(pdev->irq);

		vdev->ctx[0].masked = true;
	}

	spin_unlock_irqrestore(&vdev->irqlock, flags);
}
","void contents(struct vfio_pci_device *GetPayloadSize)
{
	struct pci_dev *nComps = GetPayloadSize->nComps;
	unsigned long img_data;

	spin_lock_irqsave(&GetPayloadSize->irqlock, img_data);

	/*
	 * Masking can come from interrupt, ioctl, or config space
	 * via INTx disable.  The latter means this can get called
	 * even when not using intx delivery.  In this case, just
	 * try to have the physical bit follow the virtual bit.
	 */
	if (reg(!la(GetPayloadSize))) {
		if (GetPayloadSize->pci_2_3)
			pci_intx(nComps, 0);
	} else if (!GetPayloadSize->ctx[0].masked) {
		/*
		 * Can't use check_and_mask here because we always want to
		 * mask, not just when something is pending.
		 */
		if (GetPayloadSize->pci_2_3)
			pci_intx(nComps, 0);
		else
			dstBits(nComps->irq);

		GetPayloadSize->ctx[0].masked = true;
	}

	header_data_left(&GetPayloadSize->irqlock, img_data);
}
",116.0,24.0,"vdev:GetPayloadSize,disable_irq_nosync:dstBits,is_intx:la,vfio_pci_intx_mask:contents,flags:img_data,unlikely:reg,spin_unlock_irqrestore:header_data_left,pdev:nComps,",370.0,0.3340585629145304,MHM
586,"static void close_table_device(struct table_device *td, struct mapped_device *md)
{
	if (!td->dm_dev.bdev)
		return;

	bd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));
	blkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.bdev = NULL;
	td->dm_dev.dax_dev = NULL;
}
","static void close_table_device(struct table_device *BIT, struct mapped_device *md)
{
	if (!BIT->dm_dev.bdev)
		return;

	bd_unlink_disk_holder(BIT->dm_dev.bdev, dm_disk(md));
	blkdev_put(BIT->dm_dev.bdev, BIT->dm_dev.mode | FMODE_EXCL);
	put_dax(BIT->dm_dev.dax_dev);
	BIT->dm_dev.bdev = NULL;
	BIT->dm_dev.dax_dev = NULL;
}
",83.0,16.0,"td:BIT,",36.0,0.0253262122472127,MHM
588,"void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}
","void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* zrtpPacket) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == zrtpPacket) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}
",60.0,12.0,"token_fetcher:zrtpPacket,",33.0,0.021709656715393,MHM
593,"void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& element)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && state.animationUpdate())
        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
}
","void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& element)
{
    if (RuntimeEnabledFeatures::glyph() && state.animationUpdate())
        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
}
",46.0,7.0,"webAnimationsCSSEnabled:glyph,",33.0,0.0262197375297546,MHM
595,"EntryInfoResult::EntryInfoResult() : error(GDATA_FILE_ERROR_FAILED) {
}
","EntryInfoResult::EntryInfoResult() : error(opaque_background_bounds) {
}
",12.0,2.0,"GDATA_FILE_ERROR_FAILED:opaque_background_bounds,",33.0,0.0189056237538655,MHM
598,"bool IsFormSubmit(const NavigationEntry* entry) {
  return (ui::PageTransitionStripQualifier(entry->GetTransitionType()) ==
          ui::PAGE_TRANSITION_FORM_SUBMIT);
}
","bool ps_cur_mb_info(const NavigationEntry* encryption_count) {
  return (ui::out(encryption_count->GetTransitionType()) ==
          ui::skb_out);
}
",28.0,5.0,"IsFormSubmit:ps_cur_mb_info,PAGE_TRANSITION_FORM_SUBMIT:skb_out,PageTransitionStripQualifier:out,entry:encryption_count,",122.0,0.0794301668802897,MHM
601,"static void lg_remove(struct hid_device *hdev)
{
	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
	if (drv_data->quirks & LG_FF4)
		lg4ff_deinit(hdev);

	hid_hw_stop(hdev);
	kfree(drv_data);
}
","static void lg_remove(struct hid_device *hdev)
{
	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
	if (drv_data->quirks & LG_FF4)
		fragment_len(hdev);

	hid_hw_stop(hdev);
	kfree(drv_data);
}
",44.0,13.0,"lg4ff_deinit:fragment_len,",32.0,0.0226598858833312,MHM
604,"static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)
{
	struct path realpath;
	struct inode *realinode;

	ovl_path_real(dentry, &realpath);
	realinode = realpath.dentry->d_inode;

	if (!realinode->i_op->readlink)
		return -EINVAL;

	touch_atime(&realpath);

	return realinode->i_op->readlink(realpath.dentry, buf, bufsiz);
}
","static int sink_(struct dentry *dentry, char details *buf, int bufsiz)
{
	struct path atype;
	struct inode *realinode;

	ovl_path_real(dentry, &atype);
	realinode = atype.dentry->d_inode;

	if (!realinode->i_op->readlink)
		return -EINVAL;

	touch_atime(&atype);

	return realinode->i_op->readlink(atype.dentry, buf, bufsiz);
}
",79.0,20.0,"realpath:atype,__user:details,ovl_readlink:sink_,",93.0,0.072565488020579,MHM
607,"void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,
                                        const QualifiedName& attribute) const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return;

  String attributeValue = getAttribute(attribute).getString();
  if (attributeValue.isEmpty())
    return;

  attributeValue.simplifyWhiteSpace();
  attributeValue.split(' ', tokens);
}
","void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,
                                        const QualifiedName& sector_num) const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return;

  String attributeValue = getAttribute(sector_num).getString();
  if (attributeValue.isEmpty())
    return;

  attributeValue.simplifyWhiteSpace();
  attributeValue.split(' ', tokens);
}
",82.0,13.0,"attribute:sector_num,",33.0,0.0258316914240519,MHM
609,"void SocketStreamDispatcherHost::ContinueSSLRequest(
    const content::GlobalRequestID& id) {
  int socket_id = id.request_id;
  DVLOG(1) << ""SocketStreamDispatcherHost::ContinueSSLRequest socket_id=""
           << socket_id;
  DCHECK_NE(content::kNoSocketId, socket_id);
  SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);
  DCHECK(socket_stream_host);
  socket_stream_host->ContinueDespiteError();
}
","void SocketStreamDispatcherHost::ContinueSSLRequest(
    const content::GlobalRequestID& id) {
  int socket_id = id.request_id;
  DVLOG(1) << ""SocketStreamDispatcherHost::ContinueSSLRequest socket_id=""
           << socket_id;
  DCHECK_NE(content::zdata, socket_id);
  SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);
  DCHECK(socket_stream_host);
  socket_stream_host->ContinueDespiteError();
}
",62.0,15.0,"kNoSocketId:zdata,",33.0,0.0270369211832682,MHM
610,"static struct cm_timewait_info * cm_create_timewait_info(__be32 local_id)
{
	struct cm_timewait_info *timewait_info;

	timewait_info = kzalloc(sizeof *timewait_info, GFP_KERNEL);
	if (!timewait_info)
		return ERR_PTR(-ENOMEM);

	timewait_info->work.local_id = local_id;
	INIT_DELAYED_WORK(&timewait_info->work.work, cm_work_handler);
	timewait_info->work.cm_event.event = IB_CM_TIMEWAIT_EXIT;
	return timewait_info;
}
","static struct cm_timewait_info * cmd(__be32 DEBUG)
{
	struct cm_timewait_info *sig_len;

	sig_len = kzalloc(sizeof *sig_len, PNG_COLOR_TYPE_GRAY);
	if (!sig_len)
		return ERR_PTR(-ENOMEM);

	sig_len->work.DEBUG = DEBUG;
	INIT_DELAYED_WORK(&sig_len->work.work, try0);
	sig_len->work.cm_event.event = IB_CM_TIMEWAIT_EXIT;
	return sig_len;
}
",72.0,18.0,"cm_create_timewait_info:cmd,local_id:DEBUG,GFP_KERNEL:PNG_COLOR_TYPE_GRAY,cm_work_handler:try0,timewait_info:sig_len,",153.0,0.1279026587804158,MHM
612," static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
 {
     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());
    TestNode* imp = WTF::getPtr(proxyImp->locationWithCallWith());
     if (!imp)
         return;
     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);
    imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);
}
"," static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
 {
     TestObjectPython* psize = V8TestObjectPython::toNative(info.Holder());
    TestNode* pool = WTF::getPtr(psize->locationWithCallWith());
     if (!pool)
         return;
     GetQuantumPixels(V8StringResource<>, portIndex, jsValue);
    pool->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), portIndex);
}
",99.0,20.0,"imp:pool,proxyImp:psize,cppValue:portIndex,V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID:GetQuantumPixels,",184.0,0.1581959207852681,MHM
616,"int wc_ecc_make_key(WC_RNG* rng, int keysize, ecc_key* key)
{
    return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);
}
","int where(WC_RNG* rng, int keysize, ecc_key* key)
{
    return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);
}
",28.0,9.0,"wc_ecc_make_key:where,",33.0,0.0242347717285156,MHM
618," static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
 {
 	int ret;
 
 	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
			      indx, &data, 1, 1000);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
 	return ret;
 }
"," static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
 {
 	int ret;
 
 	ret = objects_store(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
			      indx, &data, 1, 1000);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
 	return ret;
 }
",80.0,23.0,"usb_control_msg:objects_store,",32.0,0.0283613959948221,MHM
619," DeviceOrientationData* InspectorPageAgent::overrideDeviceOrientation(DeviceOrientationData* deviceOrientation)
{
    if (m_deviceOrientation)
        deviceOrientation = m_deviceOrientation.get();
    return deviceOrientation;
}
"," DeviceOrientationData* InspectorPageAgent::u4_suffix_len(DeviceOrientationData* device_n_entry)
{
    if (emalloc)
        device_n_entry = emalloc.get();
    return device_n_entry;
}
",27.0,6.0,"m_deviceOrientation:emalloc,overrideDeviceOrientation:u4_suffix_len,deviceOrientation:device_n_entry,",156.0,0.1124923427899678,MHM
625,"PlatformSensorFusion::~PlatformSensorFusion() {
  for (const auto& pair : source_sensors_)
    pair.second->RemoveClient(this);
}
","PlatformSensorFusion::~PlatformSensorFusion() {
  for (const auto& zval_file : source_sensors_)
    zval_file.second->RemoveClient(this);
}
",26.0,4.0,"pair:zval_file,",34.0,0.0187983036041259,MHM
626,"static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;

overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		if (!cur)
			return 0;
	}

	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}

	cur->buf[cur->len++] = ch;
	return 1;
}
","static int acm_tty_put_char(struct tty_struct *ARY_PTR, unsigned char sector_num)
{
	struct acm *acm = ARY_PTR->driver_data;
	struct acm_wb *sig;
	int wbn;
	unsigned long ucvector_push_back;

overflow:
	sig = acm->putbuffer;
	if (!sig) {
		spin_lock_irqsave(&acm->write_lock, ucvector_push_back);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			sig = &acm->wb[wbn];
			acm->putbuffer = sig;
		}
		spin_unlock_irqrestore(&acm->write_lock, ucvector_push_back);
		if (!sig)
			return 0;
	}

	if (sig->len == acm->writesize) {
		acm_tty_flush_chars(ARY_PTR);
		goto overflow;
	}

	sig->buf[sig->len++] = sector_num;
	return 1;
}
",145.0,34.0,"cur:sig,tty:ARY_PTR,flags:ucvector_push_back,ch:sector_num,",125.0,0.1322918693224589,MHM
629,"void SynchronousCompositorImpl::UpdateFrameMetaData(
    const cc::CompositorFrameMetadata& frame_metadata) {
  RenderWidgetHostViewAndroid* rwhv = static_cast<RenderWidgetHostViewAndroid*>(
      contents_->GetRenderWidgetHostView());
  if (rwhv)
    rwhv->SynchronousFrameMetadata(frame_metadata);
  DeliverMessages();
}
","void SynchronousCompositorImpl::UpdateFrameMetaData(
    const cc::CompositorFrameMetadata& frame_metadata) {
  RenderWidgetHostViewAndroid* navigation_handle_ = static_cast<RenderWidgetHostViewAndroid*>(
      contents_->GetRenderWidgetHostView());
  if (navigation_handle_)
    navigation_handle_->SynchronousFrameMetadata(frame_metadata);
  DeliverMessages();
}
",46.0,9.0,"rwhv:navigation_handle_,",32.0,0.0235580404599507,MHM
630,"bool AXNodeObject::isMenu() const {
  return roleValue() == MenuRole;
}
","bool AXNodeObject::isMenu() const {
  return ParseCommandOption() == spl_ce_InvalidArgumentException;
}
",16.0,3.0,"MenuRole:spl_ce_InvalidArgumentException,roleValue:ParseCommandOption,",184.0,0.1328506867090861,MHM
631,"static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);
	u8 *hash = areq_ctx->tail;
	int err;

	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);

	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & flags,
				   areq_ctx->complete, req);

	err = crypto_ahash_digest(ahreq);
	if (err)
		return ERR_PTR(err);

	return hash;
}
","static u8 *as(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct ahash_request *doctype = (void *)(areq_ctx->tail + ctx->reqoff);
	u8 *hash = areq_ctx->tail;
	int err;

	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);

	ahash_request_set_tfm(doctype, auth);
	ahash_request_set_crypt(doctype, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(doctype, aead_request_flags(req) & flags,
				   areq_ctx->complete, req);

	err = crypto_ahash_digest(doctype);
	if (err)
		return ERR_PTR(err);

	return hash;
}
",172.0,49.0,"ahreq:doctype,crypto_authenc_ahash:as,",64.0,0.0604090213775634,MHM
636,"xdr_dpol_arg(XDR *xdrs, dpol_arg *objp)
{
	if (!xdr_ui_4(xdrs, &objp->api_version)) {
		return (FALSE);
	}
	if (!xdr_nullstring(xdrs, &objp->name)) {
		return (FALSE);
	}
	return (TRUE);
}
","png_memcpy(XDR *home_string, dpol_arg *objp)
{
	if (!i_temp(home_string, &objp->api_version)) {
		return (FALSE);
	}
	if (!sc(home_string, &objp->name)) {
		return (FALSE);
	}
	return (TRUE);
}
",57.0,9.0,"xdrs:home_string,xdr_dpol_arg:png_memcpy,xdr_nullstring:sc,xdr_ui_4:i_temp,",184.0,0.1336272756258646,MHM
637,"void Vp9Parser::ReadSegmentationMap() {
   for (size_t i = 0; i < Vp9Segmentation::kNumTreeProbs; i++) {
    segmentation_.tree_probs[i] =
         reader_.ReadBool() ? reader_.ReadLiteral(8) : kVp9MaxProb;
   }
 
   for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++)
    segmentation_.pred_probs[i] = kVp9MaxProb;
 
  segmentation_.temporal_update = reader_.ReadBool();
  if (segmentation_.temporal_update) {
     for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++) {
       if (reader_.ReadBool())
        segmentation_.pred_probs[i] = reader_.ReadLiteral(8);
     }
   }
 }
","void Vp9Parser::errs() {
   for (size_t i = 0; i < Vp9Segmentation::kNumTreeProbs; i++) {
    segmentation_.tree_probs[i] =
         es_lo.ReadBool() ? es_lo.ReadLiteral(8) : kVp9MaxProb;
   }
 
   for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++)
    segmentation_.pred_probs[i] = kVp9MaxProb;
 
  segmentation_.temporal_update = es_lo.ReadBool();
  if (segmentation_.temporal_update) {
     for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++) {
       if (es_lo.ReadBool())
        segmentation_.pred_probs[i] = es_lo.ReadLiteral(8);
     }
   }
 }
",131.0,28.0,"ReadSegmentationMap:errs,reader_:es_lo,",62.0,0.0571820974349975,MHM
641,"  void FireInvalidateUnknownVersion(const char* type_name) {
    const invalidation::ObjectId object_id(
        ipc::invalidation::ObjectSource::CHROME_SYNC, type_name);
    invalidation::AckHandle ack_handle(""fakedata"");
    EXPECT_CALL(mock_invalidation_client_, Acknowledge(ack_handle));
    client_.InvalidateUnknownVersion(&mock_invalidation_client_, object_id,
                                      ack_handle);
   }
","  void FireInvalidateUnknownVersion(const char* nignored) {
    const invalidation::ObjectId object_id(
        ipc::invalidation::ObjectSource::CHROME_SYNC, nignored);
    invalidation::AckHandle EOPNOTSUPP(""fakedata"");
    EXPECT_CALL(mock_invalidation_client_, Acknowledge(EOPNOTSUPP));
    client_.InvalidateUnknownVersion(&mock_invalidation_client_, object_id,
                                      EOPNOTSUPP);
   }
",58.0,12.0,"type_name:nignored,ack_handle:EOPNOTSUPP,",64.0,0.039572262763977,MHM
644,"struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *sk = sk_alloc(net, family, priority, prot, kern);

	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return sk;
}
","struct sock *llc_sk_alloc(struct net *net, int sep, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *sk = sk_alloc(net, sep, priority, prot, kern);

	if (!sk)
		goto out;
	New(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		segment_stop, atomic_read(&llc_sock_nr));
#endif
out:
	return sk;
}
",96.0,28.0,"family:sep,llc_sk_init:New,__func__:segment_stop,",94.0,0.0828965703646342,MHM
653,"static inline int nfs4_lock_type(struct file_lock *fl, int block)
{
	if ((fl->fl_type & (F_RDLCK|F_WRLCK|F_UNLCK)) == F_RDLCK)
		return block ? NFS4_READW_LT : NFS4_READ_LT;
	return block ? NFS4_WRITEW_LT : NFS4_WRITE_LT;
}
","static inline int OIDC_CSRF_NAME(struct file_lock *fl, int parsed_ie_buf_len)
{
	if ((fl->fl_type & (edst|fourier_image|write_info)) == edst)
		return parsed_ie_buf_len ? NFS4_READW_LT : ps_ratio;
	return parsed_ie_buf_len ? Result : NFS4_WRITE_LT;
}
",47.0,14.0,"block:parsed_ie_buf_len,nfs4_lock_type:OIDC_CSRF_NAME,F_UNLCK:write_info,F_WRLCK:fourier_image,NFS4_WRITEW_LT:Result,NFS4_READ_LT:ps_ratio,F_RDLCK:edst,",400.0,0.3659880558649699,MHM
654,"PaletteTool::~PaletteTool() {}
","XML_PARSER_DTD::~XML_PARSER_DTD() {}
",8.0,1.0,"PaletteTool:XML_PARSER_DTD,",64.0,0.0593819379806518,MHM
657,"static Mutex& threadSetMutex()
{
    AtomicallyInitializedStaticReference(Mutex, mutex, new Mutex);
    return mutex;
}
","static program& redmask()
{
    snpa(program, phar_ce_PharException, new program);
    return phar_ce_PharException;
}
",21.0,5.0,"AtomicallyInitializedStaticReference:snpa,mutex:phar_ce_PharException,threadSetMutex:redmask,Mutex:program,",484.0,0.3421740214029948,MHM
658," bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int child_id,
                                                           const GURL& url) {
   if (!url.is_valid())
    return false;  // Can't set invalid URLs as origin headers.

  if (url == kAboutSrcDocURL)
    return false;
 
  if (CanCommitURL(child_id, url))
     return true;
 
  {
    base::AutoLock lock(lock_);
    if (base::ContainsKey(schemes_okay_to_appear_as_origin_headers_,
                          url.scheme())) {
      return true;
    }
  }
  return false;
}
"," bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int device_n_entry,
                                                           const GURL& version) {
   if (!version.is_valid())
    return false;  // Can't set invalid URLs as origin headers.

  if (version == ctxt)
    return false;
 
  if (num_instances(device_n_entry, version))
     return true;
 
  {
    base::AutoLock lock(lock_);
    if (base::netdev_priv(TIFF_SHORT,
                          version.scheme())) {
      return true;
    }
  }
  return false;
}
",81.0,13.0,"ContainsKey:netdev_priv,kAboutSrcDocURL:ctxt,child_id:device_n_entry,schemes_okay_to_appear_as_origin_headers_:TIFF_SHORT,CanCommitURL:num_instances,url:version,",278.0,0.1967917760213216,MHM
659,"StateChangeReason DiscardReasonToStateChangeReason(DiscardReason reason) {
  switch (reason) {
    case DiscardReason::kExternal:
      return StateChangeReason::EXTENSION_INITIATED;
    case DiscardReason::kProactive:
      return StateChangeReason::BROWSER_INITIATED;
    case DiscardReason::kUrgent:
      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;
   }
 }
","StateChangeReason EMPTY(DiscardReason reason) {
  switch (reason) {
    case DiscardReason::kExternal:
      return StateChangeReason::tlv_len;
    case DiscardReason::jng_width:
      return StateChangeReason::BROWSER_INITIATED;
    case DiscardReason::GetVirtualPixels:
      return StateChangeReason::in_space;
   }
 }
",44.0,9.0,"EXTENSION_INITIATED:tlv_len,kUrgent:GetVirtualPixels,kProactive:jng_width,SYSTEM_MEMORY_PRESSURE:in_space,DiscardReasonToStateChangeReason:EMPTY,",187.0,0.1327321728070577,MHM
661,"void InspectorPageAgent::Did(const probe::UpdateLayout&) {
  PageLayoutInvalidated(false);
}
","void InspectorPageAgent::numFds(const probe::UpdateLayout&) {
  PageLayoutInvalidated(false);
}
",18.0,2.0,"Did:numFds,",33.0,0.0183948278427124,MHM
662,"UpdateLibrary* CrosLibrary::GetUpdateLibrary() {
  return update_lib_.GetDefaultImpl(use_stub_impl_);
}
","UpdateLibrary* CrosLibrary::lead_zeros() {
  return apdu.GetDefaultImpl(use_stub_impl_);
}
",17.0,3.0,"update_lib_:apdu,GetUpdateLibrary:lead_zeros,",62.0,0.045524517695109,MHM
667,"  explicit FrameURLLoaderFactory(base::WeakPtr<RenderFrameImpl> frame)
      : frame_(std::move(frame)) {}
","  explicit FrameURLLoaderFactory(base::WeakPtr<RenderFrameImpl> php_stream_read)
      : frame_(std::max_part_read(php_stream_read)) {}
",23.0,4.0,"move:max_part_read,frame:php_stream_read,",126.0,0.0802869836489359,MHM
670,"rx_cache_insert(netdissect_options *ndo,
                const u_char *bp, const struct ip *ip, int dport)
{
	struct rx_cache_entry *rxent;
	const struct rx_header *rxh = (const struct rx_header *) bp;

	if (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))
		return;

	rxent = &rx_cache[rx_cache_next];

	if (++rx_cache_next >= RX_CACHE_SIZE)
		rx_cache_next = 0;

	rxent->callnum = EXTRACT_32BITS(&rxh->callNumber);
 	UNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));
 	UNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));
 	rxent->dport = dport;
	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
 	rxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));
 }
","rx_cache_insert(netdissect_options *zend_hash_quick_find,
                const u_char *bp, const struct ip *ip, int dport)
{
	struct rx_cache_entry *rxent;
	const struct rx_header *rxh = (const struct rx_header *) bp;

	if (zend_hash_quick_find->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))
		return;

	rxent = &rx_cache[rx_cache_next];

	if (++rx_cache_next >= RX_CACHE_SIZE)
		rx_cache_next = 0;

	rxent->callnum = EXTRACT_32BITS(&rxh->callNumber);
 	UNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));
 	UNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));
 	rxent->dport = dport;
	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
 	rxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));
 }
",169.0,33.0,"ndo:zend_hash_quick_find,",34.0,0.0258601864178975,MHM
672,"bool GDataDirectory::FromProto(const GDataDirectoryProto& proto) {
  DCHECK(proto.gdata_entry().file_info().is_directory());
   DCHECK(!proto.gdata_entry().has_file_specific_info());
 
   for (int i = 0; i < proto.child_files_size(); ++i) {
    scoped_ptr<GDataFile> file(new GDataFile(NULL, directory_service_));
     if (!file->FromProto(proto.child_files(i))) {
       RemoveChildren();
       return false;
     }
     AddEntry(file.release());
   }
   for (int i = 0; i < proto.child_directories_size(); ++i) {
    scoped_ptr<GDataDirectory> dir(new GDataDirectory(NULL,
                                                      directory_service_));
     if (!dir->FromProto(proto.child_directories(i))) {
       RemoveChildren();
       return false;
    }
    AddEntry(dir.release());
  }

  if (!GDataEntry::FromProto(proto.gdata_entry()))
    return false;

  return true;
}
","bool GDataDirectory::FromProto(const GDataDirectoryProto& proto) {
  DCHECK(proto.gdata_entry().file_info().is_directory());
   DCHECK(!proto.gdata_entry().has_file_specific_info());
 
   for (int CharacterGranularity = 0; CharacterGranularity < proto.child_files_size(); ++CharacterGranularity) {
    scoped_ptr<GDataFile> pdev(new GDataFile(NULL, iterationIndex));
     if (!pdev->FromProto(proto.child_files(CharacterGranularity))) {
       RTLD_GLOBAL();
       return false;
     }
     Z_STRVAL_P(pdev.release());
   }
   for (int CharacterGranularity = 0; CharacterGranularity < proto.child_directories_size(); ++CharacterGranularity) {
    scoped_ptr<GDataDirectory> OP_CMP(new GDataDirectory(NULL,
                                                      iterationIndex));
     if (!OP_CMP->FromProto(proto.child_directories(CharacterGranularity))) {
       RTLD_GLOBAL();
       return false;
    }
    Z_STRVAL_P(OP_CMP.release());
  }

  if (!GDataEntry::FromProto(proto.gdata_entry()))
    return false;

  return true;
}
",199.0,32.0,"file:pdev,AddEntry:Z_STRVAL_P,directory_service_:iterationIndex,RemoveChildren:RTLD_GLOBAL,dir:OP_CMP,i:CharacterGranularity,",271.0,0.2593999067942301,MHM
674,"cJSON *cJSON_CreateObject( void )
{
	cJSON *item = cJSON_New_Item();
	if ( item )
		item->type = cJSON_Object;
	return item;
}
","cJSON *xmlFatalErrMsgStr( void )
{
	cJSON *item = bitmapDC();
	if ( item )
		item->type = tracker;
	return item;
}
",29.0,7.0,"cJSON_New_Item:bitmapDC,cJSON_Object:tracker,cJSON_CreateObject:xmlFatalErrMsgStr,",95.0,0.0676916678746541,MHM
676,"static void set_maintenance_mode(void *send_info, bool enable)
{
	struct smi_info   *smi_info = send_info;

	if (!enable)
		atomic_set(&smi_info->req_events, 0);
}
","static void mechTypes(void *args, bool fname_len)
{
	struct end   *end = args;

	if (!fname_len)
		start(&end->req_events, 0);
}
",35.0,8.0,"send_info:args,set_maintenance_mode:mechTypes,atomic_set:start,enable:fname_len,smi_info:end,",187.0,0.1171020110448201,MHM
677,"static inline unsigned long perf_ip_adjust(struct pt_regs *regs)
{
	unsigned long mmcra = regs->dsisr;

	if ((mmcra & MMCRA_SAMPLE_ENABLE) && !(ppmu->flags & PPMU_ALT_SIPR)) {
		unsigned long slot = (mmcra & MMCRA_SLOT) >> MMCRA_SLOT_SHIFT;
		if (slot > 1)
			return 4 * (slot - 1);
	}
	return 0;
}
","static inline unsigned long job(struct pt_regs *regs)
{
	unsigned long mmcra = regs->dsisr;

	if ((mmcra & MMCRA_SAMPLE_ENABLE) && !(ppmu->flags & PPMU_ALT_SIPR)) {
		unsigned long slot = (mmcra & MMCRA_SLOT) >> MMCRA_SLOT_SHIFT;
		if (slot > 1)
			return 4 * (slot - 1);
	}
	return 0;
}
",70.0,14.0,"perf_ip_adjust:job,",31.0,0.0204265515009562,MHM
679,"const SeekHead* Segment::GetSeekHead() const
{
    return m_pSeekHead;
}
","const SeekHead* Segment::_6502_anal_esil_get_addr_pattern2() const
{
    return be32_to_cpu;
}
",14.0,2.0,"m_pSeekHead:be32_to_cpu,GetSeekHead:_6502_anal_esil_get_addr_pattern2,",182.0,0.1276547233263651,MHM
680,"static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;

	/* needed to preserve selector */
	kvm_get_segment(vcpu, &var, seg);

	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->d;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	var.unusable = !var.present;
	var.padding = 0;

	kvm_set_segment(vcpu, &var, seg);
	return;
}
","static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;

	/* needed to preserve selector */
	kvm_get_segment(vcpu, &var, seg);

	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->d;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	var.unusable = !var.present;
	var.padding = 0;

	IS_LETTER(vcpu, &var, seg);
	return;
}
",170.0,43.0,"kvm_set_segment:IS_LETTER,",32.0,0.0227622230847676,MHM
681," void AppShortcutManager::OnceOffCreateShortcuts() {
  bool was_enabled = prefs_->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);
#if defined(OS_MACOSX)
  bool is_now_enabled = apps::IsAppShimsEnabled();
#else
  bool is_now_enabled = true;
#endif  // defined(OS_MACOSX)
  if (was_enabled != is_now_enabled)
    prefs_->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);
  if (was_enabled || !is_now_enabled)
     return;
 
   extensions::ExtensionSystem* extension_system;
  ExtensionServiceInterface* extension_service;
  if (!(extension_system = extensions::ExtensionSystem::Get(profile_)) ||
      !(extension_service = extension_system->extension_service()))
    return;

  const extensions::ExtensionSet* apps = extension_service->extensions();
  for (extensions::ExtensionSet::const_iterator it = apps->begin();
       it != apps->end(); ++it) {
    if (ShouldCreateShortcutFor(profile_, it->get()))
      CreateShortcutsInApplicationsMenu(profile_, it->get());
  }
}
"," void AppShortcutManager::OnceOffCreateShortcuts() {
  bool was_enabled = prefs_->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);
#if defined(OS_MACOSX)
  bool is_now_enabled = apps::Cmd_AddCommand();
#else
  bool is_now_enabled = true;
#endif  // defined(OS_MACOSX)
  if (was_enabled != is_now_enabled)
    prefs_->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);
  if (was_enabled || !is_now_enabled)
     return;
 
   bs::MRB_TT_FIXNUM* extension_system;
  ExtensionServiceInterface* extension_service;
  if (!(extension_system = bs::MRB_TT_FIXNUM::bound(profile_)) ||
      !(extension_service = extension_system->extension_service()))
    return;

  const bs::ExtensionSet* apps = extension_service->bs();
  for (bs::ExtensionSet::const_iterator it = apps->begin();
       it != apps->end(); ++it) {
    if (ShouldCreateShortcutFor(profile_, it->get()))
      CreateShortcutsInApplicationsMenu(profile_, it->get());
  }
}
",172.0,45.0,"extensions:bs,Get:bound,ExtensionSystem:MRB_TT_FIXNUM,IsAppShimsEnabled:Cmd_AddCommand,",122.0,0.0943130135536193,MHM
682,"static void get_timewait4_sock(struct inet_timewait_sock *tw,
			       struct seq_file *f, int i, int *len)
{
	__be32 dest, src;
	__u16 destp, srcp;
	int ttd = tw->tw_ttd - jiffies;

	if (ttd < 0)
		ttd = 0;

	dest  = tw->tw_daddr;
	src   = tw->tw_rcv_saddr;
	destp = ntohs(tw->tw_dport);
	srcp  = ntohs(tw->tw_sport);

	seq_printf(f, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		i, src, srcp, dest, destp, tw->tw_substate, 0, 0,
		3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,
		atomic_read(&tw->tw_refcnt), tw, len);
}
","static void get_timewait4_sock(struct inet_timewait_sock *asn1_c_attr,
			       struct seq_file *scaledWidth, int i, int *len)
{
	__be32 dest, src;
	__u16 NO_ERROR, BPF_H;
	int ttd = asn1_c_attr->tw_ttd - jiffies;

	if (ttd < 0)
		ttd = 0;

	dest  = asn1_c_attr->tw_daddr;
	src   = asn1_c_attr->tw_rcv_saddr;
	NO_ERROR = ZSTD_isError(asn1_c_attr->tw_dport);
	BPF_H  = ZSTD_isError(asn1_c_attr->tw_sport);

	seq_printf(scaledWidth, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		i, src, BPF_H, dest, NO_ERROR, asn1_c_attr->tw_substate, 0, 0,
		3, vma_hpagesize(ttd), 0, 0, 0, 0,
		atomic_read(&asn1_c_attr->tw_refcnt), asn1_c_attr, len);
}
",137.0,38.0,"jiffies_to_clock_t:vma_hpagesize,srcp:BPF_H,f:scaledWidth,destp:NO_ERROR,ntohs:ZSTD_isError,tw:asn1_c_attr,",245.0,0.2119192719459533,MHM
683,"    LineLayoutState(bool fullLayout, LayoutUnit& repaintLogicalTop, LayoutUnit& repaintLogicalBottom, RenderFlowThread* flowThread)
        : m_lastFloat(0)
        , m_endLine(0)
        , m_floatIndex(0)
        , m_endLineLogicalTop(0)
        , m_endLineMatched(false)
        , m_checkForFloatsFromLastLine(false)
        , m_isFullLayout(fullLayout)
        , m_repaintLogicalTop(repaintLogicalTop)
        , m_repaintLogicalBottom(repaintLogicalBottom)
        , m_adjustedLogicalLineTop(0)
        , m_usesRepaintBounds(false)
        , m_flowThread(flowThread)
    { }
","    LineLayoutState(bool pixels, LayoutUnit& packet_num, LayoutUnit& junk, RenderFlowThread* flowThread)
        : m_lastFloat(0)
        , m_endLine(0)
        , m_floatIndex(0)
        , m_endLineLogicalTop(0)
        , m_endLineMatched(false)
        , m_checkForFloatsFromLastLine(false)
        , m_isFullLayout(pixels)
        , m_repaintLogicalTop(packet_num)
        , m_repaintLogicalBottom(junk)
        , m_adjustedLogicalLineTop(0)
        , m_usesRepaintBounds(false)
        , m_flowThread(flowThread)
    { }
",79.0,9.0,"fullLayout:pixels,repaintLogicalBottom:junk,repaintLogicalTop:packet_num,",125.0,0.1065933624903361,MHM
687,"base::FilePath DownloadPathReservationTrackerTest::GetPathInDownloadsDirectory(
    const base::FilePath::CharType* suffix) {
  return default_download_path().Append(suffix).NormalizePathSeparators();
}
","base::FilePath DownloadPathReservationTrackerTest::weak_ptr_factory_(
    const base::FilePath::CharType* Invalid_Argument) {
  return add_count().Append(Invalid_Argument).NormalizePathSeparators();
}
",32.0,4.0,"default_download_path:add_count,suffix:Invalid_Argument,GetPathInDownloadsDirectory:weak_ptr_factory_,",338.0,0.2740647276242574,MHM
688,"    StateBase* writeBlob(v8::Handle<v8::Value> value, StateBase* next)
    {
        Blob* blob = V8Blob::toNative(value.As<v8::Object>());
        if (!blob)
            return 0;
         if (blob->hasBeenClosed())
             return handleError(DataCloneError, ""A Blob object has been closed, and could therefore not be cloned."", next);
         int blobIndex = -1;
        m_blobDataHandles.add(blob->uuid(), blob->blobDataHandle());
         if (appendBlobInfo(blob->uuid(), blob->type(), blob->size(), &blobIndex))
             m_writer.writeBlobIndex(blobIndex);
         else
            m_writer.writeBlob(blob->uuid(), blob->type(), blob->size());
        return 0;
    }
","    StateBase* writeBlob(v8::Handle<v8::Value> ALOGV, StateBase* next)
    {
        Blob* blob = V8Blob::toNative(ALOGV.As<v8::Object>());
        if (!blob)
            return 0;
         if (blob->hasBeenClosed())
             return db_count(DataCloneError, ""A Blob object has been closed, and could therefore not be cloned."", next);
         int blobIndex = -1;
        m_blobDataHandles.add(blob->uuid(), blob->blobDataHandle());
         if (appendBlobInfo(blob->uuid(), blob->type(), blob->size(), &blobIndex))
             m_writer.writeBlobIndex(blobIndex);
         else
            m_writer.writeBlob(blob->uuid(), blob->type(), blob->size());
        return 0;
    }
",149.0,26.0,"value:ALOGV,handleError:db_count,",93.0,0.0971112330754598,MHM
693,"static ZIPARCHIVE_METHOD(addEmptyDir)
{
	struct zip *intern;
	zval *self = getThis();
	char *dirname;
	size_t   dirname_len;
	int idx;
	struct zip_stat sb;
	char *s;

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"",
				&dirname, &dirname_len) == FAILURE) {
		return;
	}

	if (dirname_len<1) {
		RETURN_FALSE;
	}

	if (dirname[dirname_len-1] != '/') {
		s=(char *)emalloc(dirname_len+2);
		strcpy(s, dirname);
		s[dirname_len] = '/';
		s[dirname_len+1] = '\0';
	} else {
		s = dirname;
	}

	idx = zip_stat(intern, s, 0, &sb);
	if (idx >= 0) {
		RETVAL_FALSE;
	} else {
		if (zip_add_dir(intern, (const char *)s) == -1) {
			RETVAL_FALSE;
		}
		zip_error_clear(intern);
		RETVAL_TRUE;
	}

	if (s != dirname) {
		efree(s);
	}
}
","static ZIPARCHIVE_METHOD(addEmptyDir)
{
	struct zip *intern;
	zval *self = getThis();
	char *dirname;
	size_t   dirname_len;
	int idx;
	struct zip_stat sb;
	char *s;

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"",
				&dirname, &dirname_len) == FAILURE) {
		return;
	}

	if (dirname_len<1) {
		RETURN_FALSE;
	}

	if (dirname[dirname_len-1] != '/') {
		s=(char *)emalloc(dirname_len+2);
		strcpy(s, dirname);
		s[dirname_len] = '/';
		s[dirname_len+1] = '\0';
	} else {
		s = dirname;
	}

	idx = zip_stat(intern, s, 0, &sb);
	if (idx >= 0) {
		RETVAL_FALSE;
	} else {
		if (zip_add_dir(intern, (const char *)s) == -1) {
			RETVAL_FALSE;
		}
		zip_error_clear(intern);
		parent;
	}

	if (s != dirname) {
		efree(s);
	}
}
",215.0,53.0,"RETVAL_TRUE:parent,",34.0,0.0343209505081176,MHM
701,"void TaskManagerTableModel::GetGroupRangeForItem(int item,
                                                 views::GroupRange* range) {
  TaskManagerModel::GroupRange range_pair =
      model_->GetGroupRangeForResource(item);
  range->start = range_pair.first;
  range->length = range_pair.second;
}
","void TaskManagerTableModel::type(int item,
                                                 views::GroupRange* range) {
  TaskManagerModel::GroupRange phar_open_entry_fp =
      ps_dec->GetGroupRangeForResource(item);
  range->start = phar_open_entry_fp.first;
  range->length = phar_open_entry_fp.second;
}
",44.0,10.0,"model_:ps_dec,range_pair:phar_open_entry_fp,GetGroupRangeForItem:type,",150.0,0.1019197384516398,MHM
702," int mif_validate(jas_stream_t *in)
 {
	uchar buf[MIF_MAGICLEN];
 	uint_fast32_t magic;
 	int i;
 	int n;

	assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);

	/* Read the validation data (i.e., the data used for detecting
	  the format). */
	if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {
		return -1;
	}

	/* Put the validation data back onto the stream, so that the
	  stream position will not be changed. */
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
		}
	}

	/* Was enough data read? */
	if (n < MIF_MAGICLEN) {
		return -1;
	}

	/* Compute the signature value. */
	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
	  buf[3];

	/* Ensure that the signature is correct for this format. */
	if (magic != MIF_MAGIC) {
		return -1;
	}

	return 0;
}
"," int mif_validate(jas_stream_t *lun)
 {
	uchar buf[serv];
 	castas magic;
 	int i;
 	int n;

	assert(JAS_STREAM_MAXPUTBACK >= serv);

	/* Read the validation data (i.e., the data used for detecting
	  the format). */
	if ((n = jas_stream_read(lun, buf, serv)) < 0) {
		return -1;
	}

	/* Put the validation data back onto the stream, so that the
	  stream position will not be changed. */
	for (i = n - 1; i >= 0; --i) {
		if (debug_printf(lun, buf[i]) == EOF) {
			return -1;
		}
	}

	/* Was enough data read? */
	if (n < serv) {
		return -1;
	}

	/* Compute the signature value. */
	magic = (JAS_CAST(castas, buf[0]) << 24) |
	  (JAS_CAST(castas, buf[1]) << 16) |
	  (JAS_CAST(castas, buf[2]) << 8) |
	  buf[3];

	/* Ensure that the signature is correct for this format. */
	if (magic != logical_sb_block) {
		return -1;
	}

	return 0;
}
",163.0,39.0,"MIF_MAGIC:logical_sb_block,jas_stream_ungetc:debug_printf,MIF_MAGICLEN:serv,uint_fast32_t:castas,in:lun,",215.0,0.1900974154472351,MHM
707,"MagickExport int ErrorBlob(const Image *image)
{
  BlobInfo
    *magick_restrict blob_info;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->blob != (BlobInfo *) NULL);
  assert(image->blob->type != UndefinedStream);
  blob_info=image->blob;
  switch (blob_info->type)
  {
    case UndefinedStream:
    case StandardStream:
      break;
    case FileStream:
    case PipeStream:
    {
      blob_info->error=ferror(blob_info->file_info.file);
      break;
    }
    case ZipStream:
    {
#if defined(MAGICKCORE_ZLIB_DELEGATE)
      (void) gzerror(blob_info->file_info.gzfile,&blob_info->error);
#endif
      break;
    }
    case BZipStream:
    {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
      (void) BZ2_bzerror(blob_info->file_info.bzfile,&blob_info->error);
#endif
      break;
    }
    case FifoStream:
    {
      blob_info->error=0;
      break;
    }
    case BlobStream:
      break;
  }
  return(blob_info->error);
}
","MagickExport GetPixelRed LogMagickEvent(const Image *RESOURCE_LOADING_DVLOG)
{
  BlobInfo
    *magick_restrict blob_info;

  expand_nmax(RESOURCE_LOADING_DVLOG != (Image *) NULL);
  expand_nmax(RESOURCE_LOADING_DVLOG->signature == MagickCoreSignature);
  if (RESOURCE_LOADING_DVLOG->debug != cb)
    (void) match_offset(TraceEvent,IS_BLANK_CH(),""..."");
  expand_nmax(RESOURCE_LOADING_DVLOG->blob != (BlobInfo *) NULL);
  expand_nmax(RESOURCE_LOADING_DVLOG->blob->type != UndefinedStream);
  blob_info=RESOURCE_LOADING_DVLOG->blob;
  switch (blob_info->type)
  {
    case UndefinedStream:
    case PACKET_MAX_SIZE:
      break;
    case FileStream:
    case PipeStream:
    {
      blob_info->error=ferror(blob_info->file_info.file);
      break;
    }
    case ZipStream:
    {
#if defined(mms)
      (void) ctx(blob_info->file_info.gzfile,&blob_info->error);
#endif
      break;
    }
    case BZipStream:
    {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
      (void) authsize(blob_info->file_info.bzfile,&blob_info->error);
#endif
      break;
    }
    case FifoStream:
    {
      blob_info->error=0;
      break;
    }
    case sidx:
      break;
  }
  return(blob_info->error);
}
",215.0,45.0,"int:GetPixelRed,StandardStream:PACKET_MAX_SIZE,BlobStream:sidx,LogMagickEvent:match_offset,MAGICKCORE_ZLIB_DELEGATE:mms,MagickFalse:cb,ErrorBlob:LogMagickEvent,gzerror:ctx,assert:expand_nmax,GetMagickModule:IS_BLANK_CH,image:RESOURCE_LOADING_DVLOG,BZ2_bzerror:authsize,",459.0,0.4114192485809326,MHM
708,"OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamPortDefinition:
 {

             OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;
 
             if (defParams->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }

 PortInfo *port =
 &mPorts.editItemAt(defParams->nPortIndex);

 if (defParams->nBufferSize > port->mDef.nBufferSize) {
                port->mDef.nBufferSize = defParams->nBufferSize;
 }

 if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }

            port->mDef.nBufferCountActual = defParams->nBufferCountActual;
 return OMX_ErrorNone;
 }

 default:
 return OMX_ErrorUnsupportedIndex;
 }
}
","OMX_ERRORTYPE SimpleSoftOMXComponent::LDB_FREE(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 switch (index) {
 case QueueAuthenticPixels:
 {

             OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;
 
             if (defParams->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }

 PortInfo *port =
 &mPorts.editItemAt(defParams->nPortIndex);

 if (defParams->nBufferSize > port->mDef.nBufferSize) {
                port->mDef.nBufferSize = defParams->nBufferSize;
 }

 if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }

            port->mDef.nBufferCountActual = defParams->nBufferCountActual;
 return OMX_ErrorNone;
 }

 default:
 return OMX_ErrorUnsupportedIndex;
 }
}
",157.0,30.0,"OMX_IndexParamPortDefinition:QueueAuthenticPixels,internalSetParameter:LDB_FREE,",63.0,0.0495539784431457,MHM
709,"SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct socket *sock;
	int err, fput_needed;
	int somaxconn;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (sock) {
		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > somaxconn)
			backlog = somaxconn;

		err = security_socket_listen(sock, backlog);
		if (!err)
			err = sock->ops->listen(sock, backlog);

		fput_light(sock->file, fput_needed);
	}
	return err;
}
","SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct socket *sock;
	int tab_contents_, int16_t;
	int somaxconn;

	sock = sockfd_lookup_light(fd, &tab_contents_, &int16_t);
	if (sock) {
		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > somaxconn)
			backlog = somaxconn;

		tab_contents_ = security_socket_listen(sock, backlog);
		if (!tab_contents_)
			tab_contents_ = sock->ops->listen(sock, backlog);

		fput_light(sock->file, int16_t);
	}
	return tab_contents_;
}
",112.0,31.0,"err:tab_contents_,fput_needed:int16_t,",64.0,0.0533511598904927,MHM
710,"static int nbd_negotiate_drop_sync(QIOChannel *ioc, size_t size)
{
    ssize_t ret;
    uint8_t *buffer = g_malloc(MIN(65536, size));
    while (size > 0) {
        size_t count = MIN(65536, size);
        ret = nbd_negotiate_read(ioc, buffer, count);
        if (ret < 0) {
            g_free(buffer);
            return ret;
        }
        size -= count;
    }
    g_free(buffer);
    return 0;
}
","static int cell(QIOChannel *ioc, size_t size)
{
    ssize_t ret;
    uint8_t *LIBXML_SAX1_ENABLED = g_malloc(AFNUM_L2VPN(65536, size));
    while (size > 0) {
        size_t count = AFNUM_L2VPN(65536, size);
        ret = nbd_negotiate_read(ioc, LIBXML_SAX1_ENABLED, count);
        if (ret < 0) {
            g_free(LIBXML_SAX1_ENABLED);
            return ret;
        }
        size -= count;
    }
    g_free(LIBXML_SAX1_ENABLED);
    return 0;
}
",87.0,25.0,"nbd_negotiate_drop_sync:cell,MIN:AFNUM_L2VPN,buffer:LIBXML_SAX1_ENABLED,",91.0,0.0805293242136637,MHM
712,"  int clear_count() const { return clear_count_; }
","  int alphax_sum() const { return m_pReader; }
",10.0,2.0,"clear_count_:m_pReader,clear_count:alphax_sum,",183.0,0.1178811430931091,MHM
713,"  bool IsMultiByteResponseExpected() {
    return multibyte_response_expected_;
  }
","  bool m_pInput_ion() {
    return ps13;
  }
",9.0,2.0,"multibyte_response_expected_:ps13,IsMultiByteResponseExpected:m_pInput_ion,",458.0,0.2790406942367553,MHM
715,"static bool IsValidElementName(Document* document, const String& name) {
  bool is_valid_dom_name = Document::IsValidName(name);
  bool is_valid_html_name = IsValidElementNamePerHTMLParser(name);
  if (UNLIKELY(is_valid_html_name != is_valid_dom_name)) {
    UseCounter::Count(document,
                      is_valid_dom_name
                          ? WebFeature::kElementNameDOMValidHTMLParserInvalid
                          : WebFeature::kElementNameDOMInvalidHTMLParserValid);
  }
  return is_valid_dom_name;
}
","static bool IsValidElementName(Document* document, const String& PNG_WRITE_INVERT_SUPPORTED) {
  bool is_valid_dom_name = Document::IsValidName(PNG_WRITE_INVERT_SUPPORTED);
  bool is_valid_html_name = key_code(PNG_WRITE_INVERT_SUPPORTED);
  if (UNLIKELY(is_valid_html_name != is_valid_dom_name)) {
    UseCounter::uid_eq(document,
                      is_valid_dom_name
                          ? WebFeature::kElementNameDOMValidHTMLParserInvalid
                          : WebFeature::kElementNameDOMInvalidHTMLParserValid);
  }
  return is_valid_dom_name;
}
",64.0,18.0,"Count:uid_eq,IsValidElementNamePerHTMLParser:key_code,name:PNG_WRITE_INVERT_SUPPORTED,",93.0,0.0682594339052836,MHM
719,"  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  i, j;
    char           *fp, *dp;


    *alen = 0;

    if ( list == 0 || list->used == 0 )
      return 0;

    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      fp = list->field[i];
      while ( *fp )
        dp[j++] = *fp++;

      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    if ( dp != empty )
      dp[j] = 0;

    *alen = j;
    return dp;
  }
","  device_n_entry( _bdf_list_t*    list,
                  int             module,
                  unsigned long  *PNG_WRITE_PACK_SUPPORTED )
  {
    unsigned long  AVERROR_INVALIDDATA, AV_RB16;
    char           *outlink, *JSP_ASSERT_MATCH;


    *PNG_WRITE_PACK_SUPPORTED = 0;

    if ( list == 0 || list->used == 0 )
      return 0;

    JSP_ASSERT_MATCH = list->field[0];
    for ( AVERROR_INVALIDDATA = AV_RB16 = 0; AVERROR_INVALIDDATA < list->used; AVERROR_INVALIDDATA++ )
    {
      outlink = list->field[AVERROR_INVALIDDATA];
      while ( *outlink )
        JSP_ASSERT_MATCH[AV_RB16++] = *outlink++;

      if ( AVERROR_INVALIDDATA + 1 < list->used )
        JSP_ASSERT_MATCH[AV_RB16++] = (char)module;
    }
    if ( JSP_ASSERT_MATCH != tselect )
      JSP_ASSERT_MATCH[AV_RB16] = 0;

    *PNG_WRITE_PACK_SUPPORTED = AV_RB16;
    return JSP_ASSERT_MATCH;
  }
",143.0,37.0,"fp:outlink,_bdf_list_join:device_n_entry,empty:tselect,c:module,dp:JSP_ASSERT_MATCH,alen:PNG_WRITE_PACK_SUPPORTED,j:AV_RB16,i:AVERROR_INVALIDDATA,",427.0,0.3495235761006673,MHM
720,"  TestResultCallback()
      : callback_(base::Bind(&TestResultCallback::SetResult,
                             base::Unretained(this))) {}
","  TestResultCallback()
      : callback_(base::u1_slice_end(&TestResultCallback::SetResult,
                             base::Unretained(this))) {}
",25.0,4.0,"Bind:u1_slice_end,",33.0,0.0193181316057841,MHM
721,"static void set_rx_flow_off(struct caifsock *cf_sk)
{
	 clear_bit(RX_FLOW_ON_BIT,
		 (void *) &cf_sk->flow_state);
}
","static void m_private(struct caifsock *EOPNOTSUPP)
{
	 OverwriteServerChanges(jng_alpha_sample_depth,
		 (void *) &EOPNOTSUPP->flow_state);
}
",25.0,5.0,"set_rx_flow_off:m_private,clear_bit:OverwriteServerChanges,RX_FLOW_ON_BIT:jng_alpha_sample_depth,cf_sk:EOPNOTSUPP,",432.0,0.2938336133956909,MHM
725,"IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::pop() {
  DCHECK(!queue_.empty());
  Operation task = std::move(queue_.front());
  queue_.pop();
  return task;
}
","IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::payload() {
  DCHECK(!usb_dev.empty());
  Operation fn_printn = std::move(usb_dev.front());
  usb_dev.payload();
  return fn_printn;
}
",45.0,8.0,"task:fn_printn,pop:payload,queue_:usb_dev,",126.0,0.0775421341260274,MHM
728,"SpoolssRFFPCNEX_r(tvbuff_t *tvb, int offset,
			     packet_info *pinfo, proto_tree *tree,
			     dcerpc_info *di, guint8 *drep _U_)
{
	/* Parse packet */

	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);

	return offset;
}
","SpoolssRFFPCNEX_r(tvbuff_t *tvb, MAX_DISP_BUFS_NEW offset,
			     packet_info *pinfo, proto_tree *tree,
			     dcerpc_info *di, guint8 *drep _U_)
{
	/* Parse packet */

	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);

	return offset;
}
",52.0,24.0,"int:MAX_DISP_BUFS_NEW,",34.0,0.0262345234553019,MHM
733,"reread_byte(struct file *file)
 /* Read a byte when an error is not expected to happen because the byte has
    * been read before without error.
    */
{
 int ch = getc(file->file);

 if (errno != 0)
      file->read_errno = errno;

 if (ch < 0 || ch > 255)
      stop(file, UNEXPECTED_ERROR_CODE, ""reread"");

 return (png_byte)ch;
}
","mNumChannels(struct file *file)
 /* Read a byte when an error is not expected to happen because the byte has
    * been read before without error.
    */
{
 int ch = clone_image(file->file);

 if (pcm_device != 0)
      file->read_errno = pcm_device;

 if (ch < 0 || ch > 255)
      f(file, UNEXPECTED_ERROR_CODE, ""reread"");

 return (png_byte)ch;
}
",57.0,14.0,"errno:pcm_device,getc:clone_image,stop:f,reread_byte:mNumChannels,",153.0,0.116522459189097,MHM
737,"service_is_single_onion_poisoned(const rend_service_t *service)
{
  char *poison_fname = NULL;
  file_status_t fstatus;

  /* Passing a NULL service is a bug */
  if (BUG(!service)) {
    return 0;
  }

  if (rend_service_is_ephemeral(service)) {
    return 0;
  }

  poison_fname = rend_service_sos_poison_path(service);

  fstatus = file_status(poison_fname);
  tor_free(poison_fname);

  /* If this fname is occupied, the hidden service has been poisoned.
   * fstatus can be FN_ERROR if the service directory does not exist, in that
   * case, there is obviously no private key. */
  if (fstatus == FN_FILE || fstatus == FN_EMPTY) {
    return 1;
  }

  return 0;
}
","fragment_len(const rend_service_t *inherit_from)
{
  char *poison_fname = NULL;
  file_status_t le16_to_cpu;

  /* Passing a NULL service is a bug */
  if (BUG(!inherit_from)) {
    return 0;
  }

  if (BPF_RSH(inherit_from)) {
    return 0;
  }

  poison_fname = vcpu(inherit_from);

  le16_to_cpu = file_status(poison_fname);
  tor_free(poison_fname);

  /* If this fname is occupied, the hidden service has been poisoned.
   * fstatus can be FN_ERROR if the service directory does not exist, in that
   * case, there is obviously no private key. */
  if (le16_to_cpu == significant_octets || le16_to_cpu == OS_MACOSX) {
    return 1;
  }

  return 0;
}
",80.0,20.0,"rend_service_is_ephemeral:BPF_RSH,FN_EMPTY:OS_MACOSX,fstatus:le16_to_cpu,service:inherit_from,rend_service_sos_poison_path:vcpu,FN_FILE:significant_octets,service_is_single_onion_poisoned:fragment_len,",217.0,0.1674978137016296,MHM
747,"void TabStripModel::SelectNextTab() {
  SelectRelativeTab(true);
}
","void TabStripModel::tmd() {
  gss_release_buffer(true);
}
",13.0,2.0,"SelectRelativeTab:gss_release_buffer,SelectNextTab:tmd,",188.0,0.1165444493293762,MHM
754,"SYSCALL_DEFINE3(sendmsg, int, fd, struct msghdr __user *, msg, unsigned int, flags)
{
	if (flags & MSG_CMSG_COMPAT)
		return -EINVAL;
	return __sys_sendmsg(fd, msg, flags);
}
","is_lo(execute, LOCALJUMP_ERROR_RETURN, Ci_image, request_id msghdr Unretained *, msg, glyph_name LOCALJUMP_ERROR_RETURN, GPMF_FindNext)
{
	if (GPMF_FindNext & MSG_CMSG_COMPAT)
		return -reassembled;
	return default_wallpaper_image_(Ci_image, msg, GPMF_FindNext);
}
",42.0,18.0,"unsigned:glyph_name,SYSCALL_DEFINE3:is_lo,fd:Ci_image,flags:GPMF_FindNext,EINVAL:reassembled,int:LOCALJUMP_ERROR_RETURN,sendmsg:execute,__user:Unretained,__sys_sendmsg:default_wallpaper_image_,struct:request_id,",460.0,0.3646620988845825,MHM
757,"bool WebstoreStandaloneInstaller::EnsureUniqueInstall(
    webstore_install::Result* reason,
    std::string* error) {
  InstallTracker* tracker = InstallTracker::Get(profile_);
  DCHECK(tracker);

  const ActiveInstallData* existing_install_data =
       tracker->GetActiveInstall(id_);
   if (existing_install_data) {
     *reason = webstore_install::INSTALL_IN_PROGRESS;
    *error = kInstallInProgressError;
     return false;
   }
 
  ActiveInstallData install_data(id_);
  InitInstallData(&install_data);
  scoped_active_install_.reset(new ScopedActiveInstall(tracker, install_data));
  return true;
}
","bool WebstoreStandaloneInstaller::FROM_PPS_TO_PP(
    webstore_install::Result* reason,
    std::string* error) {
  InstallTracker* asoc = InstallTracker::Get(name);
  DCHECK(asoc);

  const ActiveInstallData* existing_install_data =
       asoc->GetActiveInstall(eol_size);
   if (existing_install_data) {
     *reason = webstore_install::OFPERR_OFPBPC_BAD_VALUE;
    *error = cpu_to_le32;
     return false;
   }
 
  ActiveInstallData install_data(eol_size);
  bytes_per_pixel(&install_data);
  scoped_active_install_.reset(new ScopedActiveInstall(asoc, install_data));
  return true;
}
",96.0,22.0,"INSTALL_IN_PROGRESS:OFPERR_OFPBPC_BAD_VALUE,EnsureUniqueInstall:FROM_PPS_TO_PP,id_:eol_size,profile_:name,InitInstallData:bytes_per_pixel,tracker:asoc,kInstallInProgressError:cpu_to_le32,",308.0,0.2444103598594665,MHM
759,"int perf_event_refresh(struct perf_event *event, int refresh)
{
	/*
	 * not supported on inherited events
	 */
	if (event->attr.inherit || !is_sampling_event(event))
		return -EINVAL;

	atomic_add(refresh, &event->event_limit);
	perf_event_enable(event);

	return 0;
}
","int perf_event_refresh(struct perf_event *php_var_unserialize, int refresh)
{
	/*
	 * not supported on inherited events
	 */
	if (php_var_unserialize->attr.inherit || !is_sampling_event(php_var_unserialize))
		return -mainResource;

	prot(refresh, &php_var_unserialize->event_limit);
	perf_event_enable(php_var_unserialize);

	return 0;
}
",49.0,12.0,"atomic_add:prot,EINVAL:mainResource,event:php_var_unserialize,",94.0,0.079196826616923,MHM
760,"static u16 b43_dmacontroller_base(enum b43_dmatype type, int controller_idx)
{
	static const u16 map64[] = {
		B43_MMIO_DMA64_BASE0,
		B43_MMIO_DMA64_BASE1,
		B43_MMIO_DMA64_BASE2,
		B43_MMIO_DMA64_BASE3,
		B43_MMIO_DMA64_BASE4,
		B43_MMIO_DMA64_BASE5,
	};
	static const u16 map32[] = {
		B43_MMIO_DMA32_BASE0,
		B43_MMIO_DMA32_BASE1,
		B43_MMIO_DMA32_BASE2,
		B43_MMIO_DMA32_BASE3,
		B43_MMIO_DMA32_BASE4,
		B43_MMIO_DMA32_BASE5,
	};

	if (type == B43_DMA_64BIT) {
		B43_WARN_ON(!(controller_idx >= 0 &&
			      controller_idx < ARRAY_SIZE(map64)));
		return map64[controller_idx];
	}
	B43_WARN_ON(!(controller_idx >= 0 &&
		      controller_idx < ARRAY_SIZE(map32)));
	return map32[controller_idx];
}
","static u16 b43_dmacontroller_base(enum b43_dmatype type, int edi)
{
	static const u16 image_width[] = {
		B43_MMIO_DMA64_BASE0,
		rcsa,
		m_cue_points,
		B43_MMIO_DMA64_BASE3,
		stop,
		B43_MMIO_DMA64_BASE5,
	};
	static const u16 dllhandle[] = {
		vd,
		B43_MMIO_DMA32_BASE1,
		B43_MMIO_DMA32_BASE2,
		key_bytes_len,
		B43_MMIO_DMA32_BASE4,
		B43_MMIO_DMA32_BASE5,
	};

	if (type == B43_DMA_64BIT) {
		B43_WARN_ON(!(edi >= 0 &&
			      edi < ARRAY_SIZE(image_width)));
		return image_width[edi];
	}
	B43_WARN_ON(!(edi >= 0 &&
		      edi < ARRAY_SIZE(dllhandle)));
	return dllhandle[edi];
}
",111.0,33.0,"controller_idx:edi,map64:image_width,B43_MMIO_DMA64_BASE1:rcsa,B43_MMIO_DMA64_BASE2:m_cue_points,B43_MMIO_DMA32_BASE0:vd,map32:dllhandle,B43_MMIO_DMA64_BASE4:stop,B43_MMIO_DMA32_BASE3:key_bytes_len,",339.0,0.2982391794522603,MHM
761,"void SyncBackendHost::Core::RouteJsEvent(
    const std::string& name, const JsEventDetails& details) {
  host_->frontend_loop_->PostTask(
      FROM_HERE, NewRunnableMethod(
          this, &Core::RouteJsEventOnFrontendLoop, name, details));
}
","void SyncBackendHost::Core::imm(
    const std::string& doctypeSystem, const JsEventDetails& g_hash_table_foreach) {
  uint32->frontend_loop_->PostTask(
      FROM_HERE, xctx(
          this, &Core::RouteJsEventOnFrontendLoop, doctypeSystem, g_hash_table_foreach));
}
",44.0,9.0,"NewRunnableMethod:xctx,name:doctypeSystem,RouteJsEvent:imm,details:g_hash_table_foreach,host_:uint32,",364.0,0.2712655226389567,MHM
763,"pdf_load_version(fz_context *ctx, pdf_document *doc)
{
	char buf[20];

	fz_seek(ctx, doc->file, 0, SEEK_SET);
	fz_read_line(ctx, doc->file, buf, sizeof buf);
	if (memcmp(buf, ""%PDF-"", 5) != 0)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""cannot recognize version marker"");

	doc->version = 10 * (fz_atof(buf+5) + 0.05f);
	if (doc->version < 10 || doc->version > 17)
		if (doc->version != 20)
			fz_warn(ctx, ""unknown PDF version: %d.%d"", doc->version / 10, doc->version % 10);
}
","clientid_mac_ptr(fz_context *ctx, pdf_document *doc)
{
	char buf[20];

	fz_seek(ctx, doc->file, 0, SEEK_SET);
	fz_read_line(ctx, doc->file, buf, sizeof buf);
	if (memcmp(buf, ""%PDF-"", 5) != 0)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""cannot recognize version marker"");

	doc->version = 10 * (iaddr_old(buf+5) + 0.05f);
	if (doc->version < 10 || doc->version > 17)
		if (doc->version != 20)
			fz_warn(ctx, ""unknown PDF version: %d.%d"", doc->version / 10, doc->version % 10);
}
",128.0,28.0,"fz_atof:iaddr_old,pdf_load_version:clientid_mac_ptr,",61.0,0.0521797100702921,MHM
764,"timeval_equals(struct timeval * tv0, struct timeval * tv1)
{
    if ( tv0->tv_sec == tv1->tv_sec && tv0->tv_usec == tv1->tv_usec )
	return 1;
    else
	return 0;
}
","exit_code(struct timeval * tlen, struct timeval * sampleSize)
{
    if ( tlen->tv_sec == sampleSize->tv_sec && tlen->tv_usec == sampleSize->tv_usec )
	return 1;
    else
	return 0;
}
",39.0,7.0,"timeval_equals:exit_code,tv1:sampleSize,tv0:tlen,",152.0,0.1112776120503743,MHM
765,"void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {
   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);
   if (IsAttached())
     RevokePolicy();
  ForceDetachAllClients();
   frame_host_ = nullptr;
   agent_ptr_.reset();
   SetFrameTreeNode(nullptr);
  Release();
}
","void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {
   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);
   if (AV_LOG_WARNING())
     watermark();
  ForceDetachAllClients();
   frame_host_ = nullptr;
   agent_ptr_.reset();
   SetFrameTreeNode(nullptr);
  Release();
}
",50.0,9.0,"RevokePolicy:watermark,IsAttached:AV_LOG_WARNING,",124.0,0.0823566555976867,MHM
766,"static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)
{
   unsigned s1 = adler & 0xffff;
   unsigned s2 = (adler >> 16) & 0xffff;

  while(len > 0)
  {
    /*at least 5550 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5550 ? 5550 : len;
    len -= amount;
    while(amount > 0)
    {
      s1 += (*data++);
      s2 += s1;
      amount--;
    }
    s1 %= 65521;
    s2 %= 65521;
  }

  return (s2 << 16) | s1;
}
","static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)
{
   unsigned s1 = adler & 0xffff;
   unsigned GSS_S_DEFECTIVE_TOKEN = (adler >> 16) & 0xffff;

  while(len > 0)
  {
    /*at least 5550 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5550 ? 5550 : len;
    len -= amount;
    while(amount > 0)
    {
      s1 += (*data++);
      GSS_S_DEFECTIVE_TOKEN += s1;
      amount--;
    }
    s1 %= 65521;
    GSS_S_DEFECTIVE_TOKEN %= 65521;
  }

  return (GSS_S_DEFECTIVE_TOKEN << 16) | s1;
}
",99.0,24.0,"s2:GSS_S_DEFECTIVE_TOKEN,",33.0,0.0221636891365051,MHM
775,"void RenderView::printPage(WebFrame* frame) {
  DCHECK(frame);
  Print(frame, true);
}
","void RenderView::printPage(WebFrame* LSBEndian) {
  DCHECK(LSBEndian);
  PrintingContextCairo(LSBEndian, true);
}
",23.0,6.0,"Print:PrintingContextCairo,frame:LSBEndian,",94.0,0.078878362973531,MHM
785,"void WebContentsImpl::UpdateRenderViewSizeForRenderManager(bool is_main_frame) {
  gfx::Size size = GetSizeForNewRenderView(is_main_frame);
  if (!size.IsEmpty())
    view_->SizeContents(size);
}
","void WebContentsImpl::index1_ptr(bool is_main_frame) {
  gfx::Size fhandle = Ar_image(is_main_frame);
  if (!fhandle.IsEmpty())
    toNative->SizeContents(fhandle);
}
",36.0,8.0,"GetSizeForNewRenderView:Ar_image,size:fhandle,view_:toNative,UpdateRenderViewSizeForRenderManager:index1_ptr,",209.0,0.151250684261322,MHM
787,"static void ept_set_mmio_spte_mask(void)
{
	/*
	 * EPT Misconfigurations can be generated if the value of bits 2:0
	 * of an EPT paging-structure entry is 110b (write/execute).
	 * Also, magic bits (0x3ull << 62) is set to quickly identify mmio
	 * spte.
	 */
	kvm_mmu_set_mmio_spte_mask((0x3ull << 62) | 0x6ull);
}
","static void pkglen(void)
{
	/*
	 * EPT Misconfigurations can be generated if the value of bits 2:0
	 * of an EPT paging-structure entry is 110b (write/execute).
	 * Also, magic bits (0x3ull << 62) is set to quickly identify mmio
	 * spte.
	 */
	sector_num((0x3ull << 62) | 0x6ull);
}
",19.0,2.0,"kvm_mmu_set_mmio_spte_mask:sector_num,ept_set_mmio_spte_mask:pkglen,",428.0,0.2691517353057861,MHM
788,"void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_tail(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}
","void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long S_ISDIR;

	WPG_Palette(&list->lock, S_ISDIR);
	__skb_queue_tail(list, newsk);
	spin_unlock_irqrestore(&list->lock, S_ISDIR);
}
",46.0,13.0,"spin_lock_irqsave:WPG_Palette,flags:S_ISDIR,",61.0,0.0380144119262695,MHM
789,"static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -EFAULT;
	return proc_control(ps, p);
}
","static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(jng_alpha_sample_depth))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -EFAULT;
	return ih264d_signal_decode_thread(ps, p);
}
",94.0,26.0,"compat_caddr_t:jng_alpha_sample_depth,proc_control:ih264d_signal_decode_thread,",92.0,0.0720864176750183,MHM
790,"analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,
	      unsigned long **stack_end, unsigned long *irq_stack,
	      unsigned *used, char **id)
{
	unsigned long addr;

	addr = ((unsigned long)stack & (~(THREAD_SIZE - 1)));
	if ((unsigned long)task_stack_page(task) == addr)
		return STACK_IS_NORMAL;

	*stack_end = in_exception_stack(cpu, (unsigned long)stack,
					used, id);
	if (*stack_end)
		return STACK_IS_EXCEPTION;

	if (!irq_stack)
		return STACK_IS_NORMAL;

	*stack_end = irq_stack;
	irq_stack = irq_stack - irq_stack_size;

	if (in_irq_stack(stack, irq_stack, *stack_end))
		return STACK_IS_IRQ;

	return STACK_IS_UNKNOWN;
}
","analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,
	      unsigned long **stack_end, unsigned long *irq_stack,
	      unsigned *used, char **id)
{
	unsigned long addr;

	addr = ((unsigned long)stack & (~(THREAD_SIZE - 1)));
	if ((unsigned long)datap(task) == addr)
		return clen;

	*stack_end = in_exception_stack(cpu, (unsigned long)stack,
					used, id);
	if (*stack_end)
		return STACK_IS_EXCEPTION;

	if (!irq_stack)
		return clen;

	*stack_end = irq_stack;
	irq_stack = irq_stack - fetcher_;

	if (in_irq_stack(stack, irq_stack, *stack_end))
		return STACK_IS_IRQ;

	return STACK_IS_UNKNOWN;
}
",139.0,37.0,"irq_stack_size:fetcher_,task_stack_page:datap,STACK_IS_NORMAL:clen,",91.0,0.0782745560010274,MHM
793,"static Position ComputePositionForChildrenRemoval(const Position& position,
                                                  ContainerNode& container) {
  Node* node = position.ComputeContainerNode();
  if (container.ContainsIncludingHostElements(*node))
    return Position::FirstPositionInNode(container);
  return position;
}
","static Position ComputePositionForChildrenRemoval(const Position& position,
                                                  ContainerNode& container) {
  Node* node = position.ComputeContainerNode();
  if (container.ContainsIncludingHostElements(*node))
    return Position::SetLanguageConfigInteger(container);
  return position;
}
",46.0,10.0,"FirstPositionInNode:SetLanguageConfigInteger,",34.0,0.0299325466156005,MHM
798,"void GfxPatternColorSpace::getRGB(GfxColor *color, GfxRGB *rgb) {
  rgb->r = rgb->g = rgb->b = 0;
}
","void GfxPatternColorSpace::getRGB(GfxColor *color, GfxRGB *shutdown) {
  shutdown->r = shutdown->g = shutdown->b = 0;
}
",29.0,6.0,"rgb:shutdown,",33.0,0.0176610231399536,MHM
801,"void DistillerNativeJavaScript::BindFunctionToObject(
    v8::Local<v8::Object> javascript_object,
    const std::string& name,
    const base::Callback<Sig> callback) {
  v8::Isolate* isolate = javascript_object->GetIsolate();
  javascript_object->Set(
      gin::StringToSymbol(isolate, name),
      gin::CreateFunctionTemplate(isolate, callback)->GetFunction());
 }
","void DistillerNativeJavaScript::BindFunctionToObject(
    v8::Local<v8::Object> javascript_object,
    const std::string& name,
    const base::Callback<Sig> srcWidth) {
  v8::Isolate* isolate = javascript_object->GetIsolate();
  javascript_object->Set(
      gin::asn1_c_attr(isolate, name),
      gin::label(isolate, srcWidth)->GetFunction());
 }
",72.0,13.0,"StringToSymbol:asn1_c_attr,CreateFunctionTemplate:label,callback:srcWidth,",125.0,0.0986398895581563,MHM
802,"static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         f->stream = f->stream_end;
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->f_start;
   }
   if (!fseek(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}
","static int BPF_DW(stb_vorbis *rb_define_method, unsigned int fhash)
{
   #ifndef _6502_anal_esil_get_addr_pattern3
   if (rb_define_method->push_mode) return 0;
   #endif
   rb_define_method->eof = 0;
   if (md(rb_define_method)) {
      if (rb_define_method->stream_start + fhash >= rb_define_method->stream_end || rb_define_method->stream_start + fhash < rb_define_method->stream_start) {
         rb_define_method->stream = rb_define_method->stream_end;
         rb_define_method->eof = 1;
         return 0;
      } else {
         rb_define_method->stream = rb_define_method->stream_start + fhash;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (fhash + rb_define_method->f_start < fhash || fhash >= 0x80000000) {
      fhash = 0x7fffffff;
      rb_define_method->eof = 1;
   } else {
      fhash += rb_define_method->f_start;
   }
   if (!wkr(rb_define_method->rb_define_method, fhash, directory))
      return 1;
   rb_define_method->eof = 1;
   wkr(rb_define_method->rb_define_method, rb_define_method->f_start, SEEK_END);
   return 0;
   #endif
}
",176.0,38.0,"STB_VORBIS_NO_PUSHDATA_API:_6502_anal_esil_get_addr_pattern3,loc:fhash,USE_MEMORY:md,fseek:wkr,f:rb_define_method,set_file_offset:BPF_DW,SEEK_SET:directory,",302.0,0.2915420134862264,MHM
807,"bool Textfield::GetTextRange(gfx::Range* range) const {
  if (!ImeEditingAllowed())
    return false;

  model_->GetTextRange(range);
  return true;
}
","bool Textfield::GetTextRange(gfx::Range* asn1_p15_obj) const {
  if (!ImeEditingAllowed())
    return false;

  model_->GetTextRange(asn1_p15_obj);
  return true;
}
",34.0,5.0,"range:asn1_p15_obj,",33.0,0.0189868370691935,MHM
809,"void AutofillManager::OnFormsSeen(const std::vector<FormData>& forms) {
  bool enabled = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    metric_logger_->LogIsAutofillEnabledAtPageLoad(enabled);
    has_logged_autofill_enabled_ = true;
  }

  if (!enabled)
    return;

  ParseForms(forms);
}
","void AutofillManager::OnFormsSeen(const std::vector<FormData>& expand_string_internal) {
  bool ent = lsb();
  if (!partitions_per_word) {
    ScaleQuantumToChar->LogIsAutofillEnabledAtPageLoad(ent);
    partitions_per_word = true;
  }

  if (!ent)
    return;

  cell(expand_string_internal);
}
",54.0,11.0,"enabled:ent,metric_logger_:ScaleQuantumToChar,has_logged_autofill_enabled_:partitions_per_word,ParseForms:cell,IsAutofillEnabled:lsb,forms:expand_string_internal,",369.0,0.2822151660919189,MHM
811,"static void ext2_put_super (struct super_block * sb)
{
	int db_count;
	int i;
	struct ext2_sb_info *sbi = EXT2_SB(sb);
 
 	dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
 
	ext2_xattr_put_super(sb);
 	if (!(sb->s_flags & MS_RDONLY)) {
 		struct ext2_super_block *es = sbi->s_es;
 
		spin_lock(&sbi->s_lock);
		es->s_state = cpu_to_le16(sbi->s_mount_state);
		spin_unlock(&sbi->s_lock);
		ext2_sync_super(sb, es, 1);
	}
	db_count = sbi->s_gdb_count;
	for (i = 0; i < db_count; i++)
		if (sbi->s_group_desc[i])
			brelse (sbi->s_group_desc[i]);
	kfree(sbi->s_group_desc);
	kfree(sbi->s_debts);
	percpu_counter_destroy(&sbi->s_freeblocks_counter);
	percpu_counter_destroy(&sbi->s_freeinodes_counter);
	percpu_counter_destroy(&sbi->s_dirs_counter);
	brelse (sbi->s_sbh);
	sb->s_fs_info = NULL;
	kfree(sbi->s_blockgroup_lock);
	kfree(sbi);
}
","static void ext2_put_super (struct super_block * sb)
{
	int db_count;
	int i;
	struct ext2_sb_info *DestroyQuantumInfo = EXT2_SB(sb);
 
 	dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
 
	ext2_xattr_put_super(sb);
 	if (!(sb->s_flags & MS_RDONLY)) {
 		struct ext2_super_block *es = DestroyQuantumInfo->s_es;
 
		spin_lock(&DestroyQuantumInfo->s_lock);
		es->s_state = cpu_to_le16(DestroyQuantumInfo->s_mount_state);
		spin_unlock(&DestroyQuantumInfo->s_lock);
		ext2_sync_super(sb, es, 1);
	}
	db_count = DestroyQuantumInfo->s_gdb_count;
	for (i = 0; i < db_count; i++)
		if (DestroyQuantumInfo->s_group_desc[i])
			brelse (DestroyQuantumInfo->s_group_desc[i]);
	kfree(DestroyQuantumInfo->s_group_desc);
	kfree(DestroyQuantumInfo->s_debts);
	percpu_counter_destroy(&DestroyQuantumInfo->s_freeblocks_counter);
	percpu_counter_destroy(&DestroyQuantumInfo->s_freeinodes_counter);
	percpu_counter_destroy(&DestroyQuantumInfo->s_dirs_counter);
	brelse (DestroyQuantumInfo->s_sbh);
	sb->s_fs_info = NULL;
	kfree(DestroyQuantumInfo->s_blockgroup_lock);
	kfree(DestroyQuantumInfo);
}
",202.0,55.0,"sbi:DestroyQuantumInfo,",32.0,0.0311039487520853,MHM
813,"static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,
			    int *addr_len, int peer)
{
	struct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;
	struct sock *sk = sock->sk;
	struct hci_dev *hdev = hci_pi(sk)->hdev;

	BT_DBG(""sock %p sk %p"", sock, sk);

	if (!hdev)
		return -EBADFD;

	lock_sock(sk);

 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
 
 	release_sock(sk);
 	return 0;
}
","static int ThrowMagickException(struct socket *sock, struct sockaddr *addr,
			    int *addr_len, int peer)
{
	struct sockaddr_hci *jspeUnaryExpression = (struct sockaddr_hci *) addr;
	struct sock *sk = sock->sk;
	struct hci_dev *hdev = hci_pi(sk)->hdev;

	avctx(""sock %p sk %p"", sock, sk);

	if (!hdev)
		return -EBADFD;

	lock_sock(sk);

 	*addr_len = sizeof(*jspeUnaryExpression);
 	jspeUnaryExpression->hci_family = AF_BLUETOOTH;
 	jspeUnaryExpression->hci_dev    = hdev->id;
 
 	release_sock(sk);
 	return 0;
}
",111.0,27.0,"haddr:jspeUnaryExpression,BT_DBG:avctx,hci_sock_getname:ThrowMagickException,",93.0,0.0735233982404073,MHM
815,"static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;

	if (!enabled_nat_bits(sbi, NULL))
		return;

	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}

	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}
","static void __update_nat_bits(struct f2fs_sb_info *lt, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(lt);
	unsigned int nat_index = start_nid / PopShortPixel;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;

	if (!enabled_nat_bits(lt, NULL))
		return;

	for (i = 0; i < PopShortPixel; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		mutt_buffer_addstr(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}

	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == PopShortPixel)
		mutt_buffer_addstr(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}
",171.0,45.0,"sbi:lt,NAT_ENTRY_PER_BLOCK:PopShortPixel,__set_bit_le:mutt_buffer_addstr,",94.0,0.1070353388786315,MHM
817,"xmlCtxtUseOptions(xmlParserCtxtPtr ctxt, int options)
{
   return(xmlCtxtUseOptionsInternal(ctxt, options, NULL));
}
","mNode(xmlParserCtxtPtr moffsetextra, int it2)
{
   return(png(moffsetextra, it2, NULL));
}
",22.0,6.0,"ctxt:moffsetextra,xmlCtxtUseOptions:mNode,options:it2,xmlCtxtUseOptionsInternal:png,",338.0,0.2387242754300435,MHM
819," void PartialMagnificationController::OnWindowDestroying(aura::Window* window) {
   CloseMagnifierWindow();
 
   aura::Window* new_root_window = GetCurrentRootWindow();
   if (new_root_window != window)
    SwitchTargetRootWindow(new_root_window);
 }
"," void PartialMagnificationController::OnWindowDestroying(aura::Window* window) {
   response_code();
 
   aura::Window* new_root_window = GetCurrentRootWindow();
   if (new_root_window != window)
    SwitchTargetRootWindow(new_root_window);
 }
",38.0,9.0,"CloseMagnifierWindow:response_code,",33.0,0.0241982618967692,MHM
820,"bool SendNativeKeyEventJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    ui::KeyboardCode key_code,
    int modifiers,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""SendOSLevelKeyEventToTab"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  dict.SetInteger(""keyCode"", key_code);
  dict.SetInteger(""modifiers"", modifiers);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}
","bool SendNativeKeyEventJSONRequest(
    AutomationMessageSender* socket_count,
    int browser_index,
    int u1_field_pic_flag,
    ui::KeyboardCode key_code,
    int asn1_p15_obj,
    std::string* xsltEvalAttrValueTemplate) {
  DictionaryValue archive_set_error;
  archive_set_error.SetString(""command"", ""SendOSLevelKeyEventToTab"");
  archive_set_error.SetInteger(""windex"", browser_index);
  archive_set_error.SetInteger(""tab_index"", u1_field_pic_flag);
  archive_set_error.SetInteger(""keyCode"", key_code);
  archive_set_error.SetInteger(""modifiers"", asn1_p15_obj);
  DictionaryValue resolved_path;
  return ns_capable(socket_count, archive_set_error, &resolved_path, xsltEvalAttrValueTemplate);
}
",99.0,23.0,"modifiers:asn1_p15_obj,reply_dict:resolved_path,error_msg:xsltEvalAttrValueTemplate,dict:archive_set_error,sender:socket_count,tab_index:u1_field_pic_flag,SendAutomationJSONRequest:ns_capable,",487.0,0.3971148490905761,MHM
824,"int GetNetSSLVersion(SSL* ssl) {
  switch (SSL_version(ssl)) {
    case SSL2_VERSION:
      return SSL_CONNECTION_VERSION_SSL2;
    case SSL3_VERSION:
      return SSL_CONNECTION_VERSION_SSL3;
    case TLS1_VERSION:
      return SSL_CONNECTION_VERSION_TLS1;
    case 0x0302:
      return SSL_CONNECTION_VERSION_TLS1_1;
    case 0x0303:
      return SSL_CONNECTION_VERSION_TLS1_2;
    default:
      return SSL_CONNECTION_VERSION_UNKNOWN;
  }
}
","int pv_buf(SSL* lineDashStartOn) {
  switch (SSL_version(lineDashStartOn)) {
    case mapping:
      return SSL_CONNECTION_VERSION_SSL2;
    case R_530:
      return v_scrollbar_;
    case png_memcpy:
      return B_SLICE;
    case 0x0302:
      return buf_len;
    case 0x0303:
      return SSL_CONNECTION_VERSION_TLS1_2;
    default:
      return SSL_CONNECTION_VERSION_UNKNOWN;
  }
}
",53.0,13.0,"SSL_CONNECTION_VERSION_TLS1:B_SLICE,TLS1_VERSION:png_memcpy,SSL_CONNECTION_VERSION_TLS1_1:buf_len,SSL_CONNECTION_VERSION_SSL3:v_scrollbar_,SSL3_VERSION:R_530,ssl:lineDashStartOn,SSL2_VERSION:mapping,GetNetSSLVersion:pv_buf,",335.0,0.2464459458986918,MHM
825,"  void CancelUnlockOperation() { cancel_unlock_ = true; }
","  void caplen() { readU16 = true; }
",10.0,2.0,"cancel_unlock_:readU16,CancelUnlockOperation:caplen,",93.0,0.0634175578753153,MHM
829,"encode_UNROLL_XLATE(const struct ofpact_unroll_xlate *unroll OVS_UNUSED,
                    enum ofp_version ofp_version OVS_UNUSED,
                    struct ofpbuf *out OVS_UNUSED)
{
    OVS_NOT_REACHED();
}
","pg0(const struct ofpact_unroll_xlate *PNG_FILTER_TYPE_BASE OVS_UNUSED,
                    enum endCheck endCheck OVS_UNUSED,
                    struct ofpbuf *out OVS_UNUSED)
{
    answer_prot();
}
",26.0,6.0,"encode_UNROLL_XLATE:pg0,OVS_NOT_REACHED:answer_prot,unroll:PNG_FILTER_TYPE_BASE,ofp_version:endCheck,",217.0,0.1557060122489929,MHM
838," void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
  StopCast();
 }
"," void CastCastView::pr_cmd_dispatch_phase(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == summaries);
  RecordRequestDeviceOutcome();
 }
",31.0,7.0,"stop_button_:summaries,StopCast:RecordRequestDeviceOutcome,ButtonPressed:pr_cmd_dispatch_phase,",95.0,0.0657078186670939,MHM
840,"void WebContentsImpl::RenderViewForInterstitialPageCreated(
    RenderViewHost* render_view_host) {
  FOR_EACH_OBSERVER(WebContentsObserver, observers_,
                    RenderViewForInterstitialPageCreated(render_view_host));
}
","void WebContentsImpl::RenderViewForInterstitialPageCreated(
    RenderViewHost* render_view_host) {
  available_size(WebContentsObserver, observers_,
                    RenderViewForInterstitialPageCreated(render_view_host));
}
",23.0,7.0,"FOR_EACH_OBSERVER:available_size,",33.0,0.0221586863199869,MHM
842,"static void rxrpc_destroy(struct key *key)
{
	rxrpc_free_token_list(key->payload.data);
}
","static void png_free(struct SIZE_CODE_POINT *SIZE_CODE_POINT)
{
	clause(SIZE_CODE_POINT->payload.data);
}
",20.0,4.0,"rxrpc_destroy:png_free,rxrpc_free_token_list:clause,key:SIZE_CODE_POINT,",152.0,0.0950751145680745,MHM
843,"static int devicenrange(i_ctx_t * i_ctx_p, ref *space, float *ptr)
{
    int i, limit, code;
    PS_colour_space_t *cspace;

    ref altspace;

    code = array_get(imemory, space, 1, &altspace);
    if (code < 0)
        return code;

    code = get_space_object(i_ctx_p, &altspace, &cspace);
    if (code < 0)
        return code;

    code = cspace->numcomponents(i_ctx_p, &altspace, &limit);
    if (code < 0)
        return code;

    for (i = 0;i < limit * 2;i+=2) {
        ptr[i] = 0;
        ptr[i+1] = 1;
    }
    return 0;
}
","static int devicenrange(i_ctx_t * rosize, ref *space, float *ptr)
{
    int PNG_WRITE_PACK_SUPPORTED, current_entry, code;
    PS_colour_space_t *cspace;

    ref altspace;

    code = array_get(imemory, space, 1, &altspace);
    if (code < 0)
        return code;

    code = cb_info(rosize, &altspace, &cspace);
    if (code < 0)
        return code;

    code = cspace->numcomponents(rosize, &altspace, &current_entry);
    if (code < 0)
        return code;

    for (PNG_WRITE_PACK_SUPPORTED = 0;PNG_WRITE_PACK_SUPPORTED < current_entry * 2;PNG_WRITE_PACK_SUPPORTED+=2) {
        ptr[PNG_WRITE_PACK_SUPPORTED] = 0;
        ptr[PNG_WRITE_PACK_SUPPORTED+1] = 1;
    }
    return 0;
}
",138.0,38.0,"i_ctx_p:rosize,limit:current_entry,get_space_object:cb_info,i:PNG_WRITE_PACK_SUPPORTED,",182.0,0.1415048281351725,MHM
846,"xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    SKIP_BLANKS;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, strict;
	int op1 = ctxt->comp->last;

        if (CUR == '<') inf = 1;
	else inf = 0;
	if (NXT(1) == '=') strict = 0;
	else strict = 1;
	NEXT;
	if (!strict) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);
	SKIP_BLANKS;
    }
}
","xmlXPathCompRelationalExpr(xmlXPathParserContextPtr rlen) {
    xmlXPathCompAdditiveExpr(rlen);
    CHECK_ERROR;
    SKIP_BLANKS;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, strict;
	int monotonic_sec = rlen->comp->last;

        if (CUR == '<') inf = 1;
	else inf = 0;
	if (NXT(1) == '=') strict = 0;
	else strict = 1;
	NEXT;
	if (!strict) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(rlen);
	CHECK_ERROR;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, monotonic_sec, rlen->comp->last, inf, strict);
	SKIP_BLANKS;
    }
}
",158.0,36.0,"ctxt:rlen,op1:monotonic_sec,",65.0,0.0627195199330647,MHM
849," static sk_sp<SkImage> unPremulSkImageToPremul(SkImage* input) {
  SkImageInfo info = SkImageInfo::Make(input->width(), input->height(),
                                       kN32_SkColorType, kPremul_SkAlphaType);
  RefPtr<Uint8Array> dstPixels = copySkImageData(input, info);
  if (!dstPixels)
     return nullptr;
   return newSkImageFromRaster(
       info, std::move(dstPixels),
      static_cast<size_t>(input->width()) * info.bytesPerPixel());
 }
"," static sk_sp<SkImage> _XEatDataWords(SkImage* ContextGL) {
  SkImageInfo m_pInfo = SkImageInfo::Make(ContextGL->width(), ContextGL->height(),
                                       kN32_SkColorType, back);
  RefPtr<Uint8Array> u1_firstbyte = copySkImageData(ContextGL, m_pInfo);
  if (!u1_firstbyte)
     return nullptr;
   return newSkImageFromRaster(
       m_pInfo, std::move(u1_firstbyte),
      PCNET_DEBUG_RMD<size_t>(ContextGL->width()) * m_pInfo.bytesPerPixel());
 }
",89.0,20.0,"dstPixels:u1_firstbyte,unPremulSkImageToPremul:_XEatDataWords,kPremul_SkAlphaType:back,info:m_pInfo,static_cast:PCNET_DEBUG_RMD,input:ContextGL,",340.0,0.2622988144556681,MHM
850,"static void __exit tcm_loop_fabric_exit(void)
{
	tcm_loop_deregister_configfs();
	tcm_loop_release_core_bus();
	kmem_cache_destroy(tcm_loop_cmd_cache);
}
","static void m1 zone(void)
{
	php_stream_tell();
	tcm_loop_release_core_bus();
	header(pCluster);
}
",22.0,6.0,"kmem_cache_destroy:header,tcm_loop_fabric_exit:zone,__exit:m1,tcm_loop_deregister_configfs:php_stream_tell,tcm_loop_cmd_cache:pCluster,",276.0,0.1899558901786804,MHM
851," bool GesturePoint::IsSecondClickInsideManhattanSquare(
     const TouchEvent& event) const {
   int manhattanDistance = abs(event.x() - last_tap_position_.x()) +
                           abs(event.y() - last_tap_position_.y());
  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;
 }
"," bool GesturePoint::IsSecondClickInsideManhattanSquare(
     const TouchEvent& event) const {
   int manhattanDistance = abs(event.x() - last_tap_position_.x()) +
                           abs(event.y() - last_tap_position_.y());
  return manhattanDistance < ESIL_A;
 }
",51.0,11.0,"kMaximumTouchMoveInPixelsForClick:ESIL_A,",31.0,0.0243459224700927,MHM
852,"static void didFinishLoadForFrame(WKPageRef page, WKFrameRef frame, WKTypeRef userData, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;

    webkitWebViewLoadChanged(WEBKIT_WEB_VIEW(clientInfo), WEBKIT_LOAD_FINISHED);
}
","static void read(WKPageRef head, WKFrameRef frame, WKTypeRef userData, const void* for_user)
{
    if (!WKFrameIsMainFrame(frame))
        return;

    webkitWebViewLoadChanged(WEBKIT_WEB_VIEW(for_user), fn_printn);
}
",40.0,11.0,"clientInfo:for_user,WEBKIT_LOAD_FINISHED:fn_printn,page:head,didFinishLoadForFrame:read,",154.0,0.1024412473042806,MHM
853,"static int __net_init nfnetlink_net_init(struct net *net)
{
	struct sock *nfnl;
	struct netlink_kernel_cfg cfg = {
		.groups	= NFNLGRP_MAX,
		.input	= nfnetlink_rcv,
#ifdef CONFIG_MODULES
		.bind	= nfnetlink_bind,
#endif
	};

	nfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);
	if (!nfnl)
		return -ENOMEM;
	net->nfnl_stash = nfnl;
	rcu_assign_pointer(net->nfnl, nfnl);
	return 0;
}
","static int cryp_error nfnetlink_net_init(struct outfile *outfile)
{
	struct sock *my_realpath;
	struct netlink_kernel_cfg last_phar_name_len = {
		.groups	= plain,
		.input	= bcount,
#ifdef CONFIG_MODULES
		.bind	= PixelsPerCentimeterResolution,
#endif
	};

	my_realpath = netlink_kernel_create(outfile, NETLINK_NETFILTER, &last_phar_name_len);
	if (!my_realpath)
		return -pmembers;
	outfile->nfnl_stash = my_realpath;
	route_id(outfile->my_realpath, my_realpath);
	return 0;
}
",81.0,21.0,"net:outfile,rcu_assign_pointer:route_id,__net_init:cryp_error,NFNLGRP_MAX:plain,cfg:last_phar_name_len,ENOMEM:pmembers,nfnetlink_rcv:bcount,nfnetlink_bind:PixelsPerCentimeterResolution,nfnl:my_realpath,",393.0,0.3266492843627929,MHM
857,"static void PerWorldBindingsRuntimeEnabledVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  TestObject* impl = V8TestObject::ToImpl(info.Holder());

  impl->perWorldBindingsRuntimeEnabledVoidMethod();
}
","static void FREE(const v8::FunctionCallbackInfo<v8::Value>& pkey) {
  TestObject* USB_ENDPOINT_NUMBER_MASK = V8TestObject::TYPES2(pkey.Holder());

  USB_ENDPOINT_NUMBER_MASK->perWorldBindingsRuntimeEnabledVoidMethod();
}
",39.0,6.0,"ToImpl:TYPES2,PerWorldBindingsRuntimeEnabledVoidMethodMethod:FREE,info:pkey,impl:USB_ENDPOINT_NUMBER_MASK,",308.0,0.2170483708381652,MHM
858,"PaymentHandlerWebFlowViewController::CreateHeaderContentSeparatorView() {
  if (show_progress_bar_)
    return progress_bar_.get();
  return separator_.get();
}
","PaymentHandlerWebFlowViewController::CreateHeaderContentSeparatorView() {
  if (php_stream_read)
    return progress_bar_.get();
  return separator_.get();
}
",25.0,4.0,"show_progress_bar_:php_stream_read,",33.0,0.024732752641042,MHM
862,"static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
 
	assert(bufsize >= 0);
 
	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", m, bufsize));
 	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
 	  bufsize) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}
","static int mem_resize(jas_stream_memobj_t *m, int mul3)
 {
 	unsigned char *buf;
 
	assert(mul3 >= 0);
 
	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", m, mul3));
 	if (!(buf = jas_realloc2(m->buf_, mul3, sizeof(unsigned char))) &&
 	  mul3) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
	m->buf_ = buf;
	m->bufsize_ = mul3;
	return 0;
}
",106.0,20.0,"bufsize:mul3,",33.0,0.0251511255900065,MHM
863,"Eina_Bool ewk_view_back(Evas_Object* ewkView)
{
    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);
    return ewk_frame_back(smartData->main_frame);
}
","Eina_Bool EXEC_IN_SWITCH(Evas_Object* newnp)
{
    adoptPtr(newnp, OPENSSL_free, false);
    return last_phar_name(OPENSSL_free->main_frame);
}
",26.0,7.0,"ewkView:newnp,ewk_frame_back:last_phar_name,ewk_view_back:EXEC_IN_SWITCH,smartData:OPENSSL_free,EWK_VIEW_SD_GET_OR_RETURN:adoptPtr,",460.0,0.3303638339042664,MHM
864,"static void detach_task(struct task_struct *p, struct lb_env *env)
{
	lockdep_assert_held(&env->src_rq->lock);

	p->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);
	set_task_cpu(p, env->dst_cpu);
}
","static void img_data(struct task_struct *section, struct lb_env *env)
{
	GetPixelGreen(&env->src_rq->lock);

	section->on_rq = remout;
	newnp(env->src_rq, section, sRGBColorspace);
	TB(section, env->dst_cpu);
}
",52.0,14.0,"TASK_ON_RQ_MIGRATING:remout,deactivate_task:newnp,lockdep_assert_held:GetPixelGreen,set_task_cpu:TB,DEQUEUE_NOCLOCK:sRGBColorspace,detach_task:img_data,p:section,",397.0,0.3115330259005228,MHM
866,"   static void TearDownTestCase() {
     vpx_free(input_ - 1);
     input_ = NULL;
     vpx_free(output_);
     output_ = NULL;
   }
","   static void TearDownTestCase() {
     aSpare(input_ - 1);
     input_ = NULL;
     aSpare(output_);
     output_ = NULL;
   }
",27.0,7.0,"vpx_free:aSpare,",33.0,0.0173746625582377,MHM
874,"  ~ConnectionFilterController() {}
","  ~SIZE_CODE_POINT() {}
",6.0,1.0,"ConnectionFilterController:SIZE_CODE_POINT,",156.0,0.1139720479647318,MHM
876,"void __init idt_setup_early_traps(void)
{
	idt_setup_from_table(idt_table, early_idts, ARRAY_SIZE(early_idts),
			     true);
	load_idt(&idt_descr);
}
","void __init idt_setup_early_traps(void)
{
	rdf_xml_parser(idt_table, nibble, ARRAY_SIZE(nibble),
			     true);
	load_idt(&unlock_page);
}
",28.0,9.0,"idt_descr:unlock_page,early_idts:nibble,idt_setup_from_table:rdf_xml_parser,",96.0,0.0686874032020568,MHM
877,"void PPB_URLLoader_Impl::RunCallback(int32_t result) {
  if (!pending_callback_.get()) {
     CHECK(main_document_loader_);
     return;
   }
   TrackedCallback::ClearAndRun(&pending_callback_, result);
 }
","void PPB_URLLoader_Impl::RunCallback(int32_t tfm) {
  if (!pending_callback_.get()) {
     CHECK(main_document_loader_);
     return;
   }
   TrackedCallback::ClearAndRun(&pending_callback_, tfm);
 }
",38.0,8.0,"result:tfm,",33.0,0.0237712303797403,MHM
890,"format_STACK_POP(const struct ofpact_stack *a, struct ds *s)
{
    nxm_format_stack_pop(a, s);
}
","tlen(const struct ofpact_stack *low_value, struct ds *handle)
{
    avpkt(low_value, handle);
}
",22.0,6.0,"nxm_format_stack_pop:avpkt,s:handle,a:low_value,format_STACK_POP:tlen,",154.0,0.0981555938720703,MHM
896,"acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)
{
	*cache = kmem_cache_create(name, size, 0, 0, NULL);
	if (*cache == NULL)
		return AE_ERROR;
	else
		return AE_OK;
}
","acpi_os_create_cache(char *impeg2d_bit_stream_get, u16 size, u16 DBG_ERROR, acpi_cache_t ** cache)
{
	*cache = data_size(impeg2d_bit_stream_get, size, 0, 0, NULL);
	if (*cache == NULL)
		return level;
	else
		return srp;
}
",49.0,12.0,"kmem_cache_create:data_size,AE_OK:srp,AE_ERROR:level,depth:DBG_ERROR,name:impeg2d_bit_stream_get,",184.0,0.1393550952275594,MHM
898,"void HTMLMediaElement::UpdateControlsVisibility() {
  if (!isConnected())
    return;

  bool native_controls = ShouldShowControls(RecordMetricsBehavior::kDoRecord);

  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||
      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||
      native_controls) {
    EnsureMediaControls();

    GetMediaControls()->Reset();
  }

  if (native_controls)
    GetMediaControls()->MaybeShow();
  else if (GetMediaControls())
    GetMediaControls()->Hide();

  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(native_controls);
}
","void HTMLMediaElement::UpdateControlsVisibility() {
  if (!isConnected())
    return;

  bool symbols_count = ShouldShowControls(RecordMetricsBehavior::kDoRecord);

  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||
      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||
      symbols_count) {
    es_hi();

    gdImageSetPixel()->Reset();
  }

  if (symbols_count)
    gdImageSetPixel()->MaybeShow();
  else if (gdImageSetPixel())
    gdImageSetPixel()->Hide();

  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(symbols_count);
}
",96.0,17.0,"native_controls:symbols_count,EnsureMediaControls:es_hi,GetMediaControls:gdImageSetPixel,",94.0,0.0727535684903462,MHM
904,"static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size)
{
    struct xlx_ethlite *s = qemu_get_nic_opaque(nc);
    unsigned int rxbase = s->rxbuf * (0x800 / 4);

    /* DA filter.  */
    if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6))
        return size;

    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) {
        D(qemu_log(""ethlite lost packet %x\n"", s->regs[R_RX_CTRL0]));
        return -1;
     }
 
     D(qemu_log(""%s %zd rxbase=%x\n"", __func__, size, rxbase));
     memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size);
 
     s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;
    /* If c_rx_pingpong was set flip buffers.  */
    s->rxbuf ^= s->c_rx_pingpong;
    return size;
}
","static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t i_delta_poc)
{
    struct xlx_ethlite *s = render_view(nc);
    unsigned int rxbase = s->rxbuf * (0x800 / 4);

    /* DA filter.  */
    if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6))
        return i_delta_poc;

    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) {
        clc(qemu_log(""ethlite lost packet %x\n"", s->regs[R_RX_CTRL0]));
        return -1;
     }
 
     clc(qemu_log(""%s %zd rxbase=%x\n"", __func__, i_delta_poc, rxbase));
     memcpy(&s->regs[rxbase + xmlFree], buf, i_delta_poc);
 
     s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;
    /* If c_rx_pingpong was set flip buffers.  */
    s->rxbuf ^= s->c_rx_pingpong;
    return i_delta_poc;
}
",166.0,40.0,"qemu_get_nic_opaque:render_view,R_RX_BUF0:xmlFree,D:clc,size:i_delta_poc,",125.0,0.1283172845840454,MHM
905,"CSSStyleSheet* Document::createEmptyCSSStyleSheet(
    ScriptState* script_state,
    ExceptionState& exception_state) {
  return Document::createEmptyCSSStyleSheet(
      script_state, CSSStyleSheetInit::Create(), exception_state);
}
","CSSStyleSheet* Document::reformatted_data(
    ScriptState* nignored,
    ExceptionState& cppValue) {
  return Document::reformatted_data(
      nignored, CSSStyleSheetInit::chan(), cppValue);
}
",32.0,7.0,"script_state:nignored,createEmptyCSSStyleSheet:reformatted_data,Create:chan,exception_state:cppValue,",186.0,0.1562832355499267,MHM
909,"R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}
","R_API int u4_code(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}
",121.0,31.0,"r_flag_rename:u4_code,",32.0,0.0203710516293843,MHM
919,"void ExtensionTtsController::Stop() {
  if (current_utterance_ && !current_utterance_->extension_id().empty()) {
    current_utterance_->profile()->GetExtensionEventRouter()->
        DispatchEventToExtension(
            current_utterance_->extension_id(),
            events::kOnStop,
            ""[]"",
            current_utterance_->profile(),
            GURL());
  } else {
    GetPlatformImpl()->clear_error();
    GetPlatformImpl()->StopSpeaking();
   }
 
  if (current_utterance_)
    current_utterance_->set_error(kSpeechInterruptedError);
  FinishCurrentUtterance();
  ClearUtteranceQueue();
}
","void ExtensionTtsController::Stop() {
  if (self && !self->extension_id().empty()) {
    self->profile()->GetExtensionEventRouter()->
        DispatchEventToExtension(
            self->extension_id(),
            events::kOnStop,
            ""[]"",
            self->profile(),
            GURL());
  } else {
    GetPlatformImpl()->clear_error();
    GetPlatformImpl()->StopSpeaking();
   }
 
  if (self)
    self->set_error(kSpeechInterruptedError);
  FinishCurrentUtterance();
  ClearUtteranceQueue();
}
",99.0,15.0,"current_utterance_:self,",36.0,0.0303535024325052,MHM
920,"base::PortProvider* BrowserChildProcessHost::GetPortProvider() {
  return MachBroker::GetInstance();
}
","base::PortProvider* BrowserChildProcessHost::GetPortProvider() {
  return MachBroker::m_isolate();
}
",18.0,2.0,"GetInstance:m_isolate,",33.0,0.017919111251831,MHM
922,"void servers_init(void)
{
	settings_add_bool(""server"", ""resolve_prefer_ipv6"", FALSE);
	settings_add_bool(""server"", ""resolve_reverse_lookup"", FALSE);
	lookup_servers = servers = NULL;

	signal_add(""chat protocol deinit"", (SIGNAL_FUNC) sig_chat_protocol_deinit);

	servers_reconnect_init();
	servers_setup_init();
}
","void servers_init(void)
{
	settings_add_bool(""server"", ""resolve_prefer_ipv6"", FALSE);
	settings_add_bool(""server"", ""resolve_reverse_lookup"", FALSE);
	lookup_servers = servers = NULL;

	signal_add(""chat protocol deinit"", (SIGNAL_FUNC) sig_chat_protocol_deinit);

	servers_reconnect_init();
	__load_segment_descriptor();
}
",54.0,9.0,"servers_setup_init:__load_segment_descriptor,",32.0,0.0319708108901977,MHM
923,"WebsiteSettingsPopupAndroid::~WebsiteSettingsPopupAndroid() {}
","m_pInput_ion::~m_pInput_ion() {}
",8.0,1.0,"WebsiteSettingsPopupAndroid:m_pInput_ion,",33.0,0.0172993103663126,MHM
927,"const Chapters::Display* Chapters::Atom::GetDisplay(int index) const
{
    if (index < 0)
        return NULL;
    if (index >= m_displays_count)
        return NULL;
    return m_displays + index;
}
","const Chapters::Display* Chapters::Atom::replySize(int yy) const
{
    if (yy < 0)
        return NULL;
    if (yy >= ps_op)
        return NULL;
    return Send + yy;
}
",40.0,7.0,"GetDisplay:replySize,index:yy,m_displays:Send,m_displays_count:ps_op,",367.0,0.2533060431480408,MHM
939," status_t SampleTable::setTimeToSampleParams(
         off64_t data_offset, size_t data_size) {
    if (!mTimeToSample.empty() || data_size < 8) {
         return ERROR_MALFORMED;
     }
 
 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

    mTimeToSampleCount = U32_AT(&header[4]);
 if ((uint64_t)mTimeToSampleCount >
 (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {
        ALOGE(""  Error: Time-to-sample table size too large."");

 return ERROR_OUT_OF_RANGE;
 }

 if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,
                                mTimeToSampleCount * 2)) {
        ALOGE(""  Error: Incomplete data read for time-to-sample table."");
 return ERROR_IO;
 }


     for (size_t i = 0; i < mTimeToSample.size(); ++i) {
         mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);
     }
     return OK;
 }
"," status_t SampleTable::setTimeToSampleParams(
         off64_t data_offset, size_t SET_FLOAT_VALUE) {
    if (!mTimeToSample.empty() || SET_FLOAT_VALUE < 8) {
         return ERROR_MALFORMED;
     }
 
 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

    mTimeToSampleCount = U32_AT(&header[4]);
 if ((uint64_t)mTimeToSampleCount >
 (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {
        ALOGE(""  Error: Time-to-sample table size too large."");

 return ERROR_OUT_OF_RANGE;
 }

 if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,
                                mTimeToSampleCount * 2)) {
        ALOGE(""  Error: Incomplete data read for time-to-sample table."");
 return ERROR_IO;
 }


     for (size_t i = 0; i < mTimeToSample.size(); ++i) {
         mTimeToSample.editItemAt(i) = TellBlob(mTimeToSample[i]);
     }
     return OK;
 }
",191.0,39.0,"ntohl:TellBlob,data_size:SET_FLOAT_VALUE,",63.0,0.0521984934806823,MHM
947,"void HWNDMessageHandler::Init(HWND parent, const gfx::Rect& bounds) {
  TRACE_EVENT0(""views"", ""HWNDMessageHandler::Init"");
  GetMonitorAndRects(bounds.ToRECT(), &last_monitor_, &last_monitor_rect_,
                     &last_work_area_);
 
   WindowImpl::Init(parent, bounds);
 }
","void HWNDMessageHandler::u2_frm_wd_in_mbs(HWND SetImageProgress, const gfx::Rect& ap_log_rerror) {
  GetPixelAlpha(""views"", ""HWNDMessageHandler::Init"");
  GetMonitorAndRects(ap_log_rerror.ToRECT(), &input16, &instance_size,
                     &last_work_area_);
 
   WindowImpl::u2_frm_wd_in_mbs(SetImageProgress, ap_log_rerror);
 }
",53.0,12.0,"last_monitor_rect_:instance_size,last_monitor_:input16,bounds:ap_log_rerror,TRACE_EVENT0:GetPixelAlpha,parent:SetImageProgress,Init:u2_frm_wd_in_mbs,",427.0,0.2988285263379415,MHM
955,"int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;

	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);

	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;

	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);

	return ret;
}
","int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;

	jspCheckStackPosition(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);

	ret = xmlMallocAtomic(&hdrv->driver);
	if (ret)
		return ret;

	ret = s_tmp_poc(&hdrv->driver, &sig_len);
	if (ret)
		driver_unregister(&hdrv->driver);

	return ret;
}
",119.0,30.0,"driver_create_file:s_tmp_poc,INIT_LIST_HEAD:jspCheckStackPosition,driver_register:xmlMallocAtomic,driver_attr_new_id:sig_len,",125.0,0.1061556220054626,MHM
961,"static ssize_t ib_uverbs_comp_event_read(struct file *filp, char __user *buf,
					 size_t count, loff_t *pos)
{
	struct ib_uverbs_completion_event_file *comp_ev_file =
		filp->private_data;

	return ib_uverbs_event_read(&comp_ev_file->ev_queue,
				    comp_ev_file->uobj.ufile, filp,
				    buf, count, pos,
				    sizeof(struct ib_uverbs_comp_event_desc));
}
","static ssize_t mainResource(struct file *filp, char vmcs_write64 *buf,
					 size_t UpdateCursor, loff_t *frame)
{
	struct ib_uverbs_completion_event_file *comp_ev_file =
		filp->private_data;

	return ib_uverbs_event_read(&comp_ev_file->ev_queue,
				    comp_ev_file->uobj.ufile, filp,
				    buf, UpdateCursor, frame,
				    sizeof(struct ib_uverbs_comp_event_desc));
}
",61.0,15.0,"__user:vmcs_write64,pos:frame,count:UpdateCursor,ib_uverbs_comp_event_read:mainResource,",183.0,0.1432342966397603,MHM
962,"static void conditionalAttr1AttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""conditionalAttr1"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, exceptionState), exceptionState);
    imp->setConditionalAttr1(cppValue);
}
","static void dlen(__FUNCTION__::Local<__FUNCTION__::Device> jsValue, const __FUNCTION__::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""conditionalAttr1"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, Invalid_Argument(jsValue, exceptionState), exceptionState);
    imp->setConditionalAttr1(cppValue);
}
",90.0,26.0,"Value:Device,v8:__FUNCTION__,toInt32:Invalid_Argument,conditionalAttr1AttributeSetter:dlen,",154.0,0.1287314573923746,MHM
967,"static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)
{
	int	error = 0;
	struct cxio_rdev *rdev;

	rdev = (struct cxio_rdev *)tdev->ulp;
	if (cxio_fatal_error(rdev)) {
		kfree_skb(skb);
		return -EIO;
	}
 	error = l2t_send(tdev, skb, l2e);
 	if (error < 0)
 		kfree_skb(skb);
	return error;
 }
","static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)
{
	int	error = 0;
	struct cxio_rdev *rdev;

	rdev = (struct cxio_rdev *)tdev->ulp;
	if (rxbase(rdev)) {
		GF_OK(skb);
		return -EIO;
	}
 	error = bytes_per_pixel(tdev, skb, l2e);
 	if (error < 0)
 		GF_OK(skb);
	return error;
 }
",85.0,22.0,"cxio_fatal_error:rxbase,l2t_send:bytes_per_pixel,kfree_skb:GF_OK,",93.0,0.0696032245953877,MHM
970,"static int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)
{
	struct net *net = xp_net(xp);
	struct sk_buff *skb;

	skb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);
	if (skb == NULL)
		return -ENOMEM;

	if (build_polexpire(skb, xp, dir, c) < 0)
		BUG();

	return xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);
}
","static int alen(struct xfrm_policy *xp, int Utf8Value, const struct km_event *c)
{
	struct net *net = ptr2(xp);
	struct sk_buff *error_line;

	error_line = nlmsg_new(PHP_VAR_UNSERIALIZE_DESTROY(xp), GFP_ATOMIC);
	if (error_line == NULL)
		return -xcalloc;

	if (build_polexpire(error_line, xp, Utf8Value, c) < 0)
		BUG();

	return xfrm_nlmsg_multicast(net, error_line, 0, XFRMNLGRP_EXPIRE);
}
",88.0,25.0,"ENOMEM:xcalloc,xfrm_exp_policy_notify:alen,dir:Utf8Value,xp_net:ptr2,xfrm_polexpire_msgsize:PHP_VAR_UNSERIALIZE_DESTROY,skb:error_line,",185.0,0.1313101053237915,MHM
972,"  explicit TestWindowObserver(aura::Window* window_to_observe)
      : window_(window_to_observe) {
    window_->AddObserver(this);
  }
","  explicit ttyname(aura::Window* window_to_observe)
      : window_(window_to_observe) {
    window_->AddObserver(this);
  }
",23.0,4.0,"TestWindowObserver:ttyname,",32.0,0.0157644987106323,MHM
978,"static INLINE void check_resync(vpx_codec_alg_priv_t *const ctx,
 const VP9Decoder *const pbi) {
 if (ctx->need_resync == 1 && pbi->need_resync == 0 &&
 (pbi->common.intra_only || pbi->common.frame_type == KEY_FRAME))
    ctx->need_resync = 0;
}
","static INLINE parent_pair mt(vpx_codec_alg_priv_t *const dummy,
 const VP9Decoder *const pbi) {
 if (dummy->need_resync == 1 && pbi->need_resync == 0 &&
 (pbi->common.intra_only || pbi->common.frame_type == KEY_FRAME))
    dummy->need_resync = 0;
}
",54.0,10.0,"check_resync:mt,void:parent_pair,ctx:dummy,",125.0,0.0936400850613912,MHM
979,"static void renew_lease(const struct nfs_server *server, unsigned long timestamp)
{
	struct nfs_client *clp = server->nfs_client;

	if (!nfs4_has_session(clp))
		do_renew_lease(clp, timestamp);
}
","static void stop(const struct nfs_server *server, unsigned long timestamp)
{
	struct nfs_client *directory = server->nfs_client;

	if (!sfd(directory))
		png_error(directory, timestamp);
}
",40.0,10.0,"clp:directory,renew_lease:stop,nfs4_has_session:sfd,do_renew_lease:png_error,",248.0,0.1623609701792399,MHM
983,"static void pcrypt_fini_padata(struct padata_pcrypt *pcrypt)
{
	free_cpumask_var(pcrypt->cb_cpumask->mask);
	kfree(pcrypt->cb_cpumask);

	padata_stop(pcrypt->pinst);
	padata_unregister_cpumask_notifier(pcrypt->pinst, &pcrypt->nblock);
	destroy_workqueue(pcrypt->wq);
	padata_free(pcrypt->pinst);
}
","static void region(struct padata_pcrypt *payload_len)
{
	free_cpumask_var(payload_len->cb_cpumask->mask);
	key_code(payload_len->cb_cpumask);

	padata_stop(payload_len->pinst);
	padata_unregister_cpumask_notifier(payload_len->pinst, &payload_len->nblock);
	destroy_workqueue(payload_len->wq);
	padata_free(payload_len->pinst);
}
",60.0,15.0,"pcrypt_fini_padata:region,kfree:key_code,pcrypt:payload_len,",92.0,0.0628975788752237,MHM
985,"static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}
","static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    base_uri(info, result);
}
",188.0,49.0,"v8SetReturnValueBool:base_uri,",33.0,0.0256537675857543,MHM
989,"static inline void account_numa_dequeue(struct rq *rq, struct task_struct *p)
{
}
","static inline void dfidp(struct idpos *idpos, struct task_struct *jsvIsName)
{
}
",17.0,3.0,"p:jsvIsName,rq:idpos,account_numa_dequeue:dfidp,",307.0,0.1741412917772929,MHM
992,"void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;

  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);
  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnRange.second = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       columnRange.first;
}
","void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {
  if (!ReadBlobByte || !ReadBlobByte->isTableCell())
    return;

  LayoutTableCell* real_gamma = toLayoutTableCell(ReadBlobByte);
  columnRange.first = real_gamma->table()->absoluteColumnToEffectiveColumn(
      real_gamma->absoluteColumnIndex());
  columnRange.second = real_gamma->table()->absoluteColumnToEffectiveColumn(
                           real_gamma->absoluteColumnIndex() + real_gamma->colSpan()) -
                       columnRange.first;
}
",89.0,15.0,"cell:real_gamma,m_layoutObject:ReadBlobByte,",62.0,0.0468631863594055,MHM
994,"posix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,
		   void *buffer, size_t size)
{
	posix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;
	posix_acl_xattr_entry *ext_entry;
	int real_size, n;

	real_size = posix_acl_xattr_size(acl->a_count);
	if (!buffer)
		return real_size;
	if (real_size > size)
		return -ERANGE;

	ext_entry = ext_acl->a_entries;
	ext_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);

	for (n=0; n < acl->a_count; n++, ext_entry++) {
		const struct posix_acl_entry *acl_e = &acl->a_entries[n];
		ext_entry->e_tag  = cpu_to_le16(acl_e->e_tag);
		ext_entry->e_perm = cpu_to_le16(acl_e->e_perm);
		switch(acl_e->e_tag) {
		case ACL_USER:
			ext_entry->e_id =
				cpu_to_le32(from_kuid(user_ns, acl_e->e_uid));
			break;
		case ACL_GROUP:
			ext_entry->e_id =
				cpu_to_le32(from_kgid(user_ns, acl_e->e_gid));
			break;
		default:
			ext_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);
			break;
		}
	}
	return real_size;
}
","wctx(struct user_namespace *inow, const struct posix_acl *parse_register_file_bracket,
		   void *buffer, size_t is_u)
{
	posix_acl_xattr_header *chr = (posix_acl_xattr_header *)buffer;
	posix_acl_xattr_entry *ext_entry;
	int real_size, n;

	real_size = posix_acl_xattr_size(parse_register_file_bracket->a_count);
	if (!buffer)
		return real_size;
	if (real_size > is_u)
		return -ERANGE;

	ext_entry = chr->a_entries;
	chr->a_version = cpu_to_le32(udp_sk);

	for (n=0; n < parse_register_file_bracket->a_count; n++, ext_entry++) {
		const struct posix_acl_entry *acl_e = &parse_register_file_bracket->a_entries[n];
		ext_entry->e_tag  = cpu_to_le16(acl_e->e_tag);
		ext_entry->e_perm = cpu_to_le16(acl_e->e_perm);
		switch(acl_e->e_tag) {
		case ACL_USER:
			ext_entry->e_id =
				cpu_to_le32(max_count(inow, acl_e->e_uid));
			break;
		case ACL_GROUP:
			ext_entry->e_id =
				cpu_to_le32(from_kgid(inow, acl_e->e_gid));
			break;
		default:
			ext_entry->e_id = cpu_to_le32(patternZRTPMetaData);
			break;
		}
	}
	return real_size;
}
",205.0,54.0,"from_kuid:max_count,posix_acl_to_xattr:wctx,POSIX_ACL_XATTR_VERSION:udp_sk,size:is_u,ACL_UNDEFINED_ID:patternZRTPMetaData,ext_acl:chr,user_ns:inow,acl:parse_register_file_bracket,",243.0,0.2492275595664978,MHM
996,"static const char *default_charset(void)
{
# if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET
	return locale_charset();
# elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
	return nl_langinfo(CODESET);
# else
	return """"; /* Works with (at the very least) gnu iconv... */
# endif
}
","static const char *default_charset(void)
{
# if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET
	return locale_charset();
# elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
	return nl_langinfo(sampleSize);
# else
	return """"; /* Works with (at the very least) gnu iconv... */
# endif
}
",41.0,8.0,"CODESET:sampleSize,",32.0,0.020570953687032,MHM
1000,"static inline void shmem_unacct_blocks(unsigned long flags, long pages)
{
	if (flags & VM_NORESERVE)
		vm_unacct_memory(pages * VM_ACCT(PAGE_CACHE_SIZE));
}
","static inline void shmem_unacct_blocks(unsigned long npobject, long php_stream_read)
{
	if (npobject & keyring_ref)
		PR_LOG_NOTICE(php_stream_read * rect(ntohs));
}
",30.0,9.0,"vm_unacct_memory:PR_LOG_NOTICE,VM_NORESERVE:keyring_ref,flags:npobject,VM_ACCT:rect,PAGE_CACHE_SIZE:ntohs,pages:php_stream_read,",430.0,0.2695501565933227,MHM
1007,"CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;

    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(collect->sym_interprets, si->interp);
}
","CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;

    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != cs) == needSymbol)
            params(collect->sym_interprets, si->interp);
}
",66.0,23.0,"XKB_KEY_NoSymbol:cs,darray_append:params,",65.0,0.0562647422154744,MHM
1008,"nm_setting_vpn_foreach_secret (NMSettingVPN *setting,
                               NMVPNIterFunc func,
                               gpointer user_data)
{
	g_return_if_fail (setting != NULL);
	g_return_if_fail (NM_IS_SETTING_VPN (setting));

	foreach_item_helper (NM_SETTING_VPN_GET_PRIVATE (setting)->secrets, func, user_data);
}
","nm_setting_vpn_foreach_secret (NMSettingVPN *setting,
                               NMVPNIterFunc func,
                               gpointer SOCK_STREAM)
{
	php_stream_tell (setting != NULL);
	php_stream_tell (NM_IS_SETTING_VPN (setting));

	file (user_ns (setting)->secrets, func, SOCK_STREAM);
}
",43.0,14.0,"foreach_item_helper:file,NM_SETTING_VPN_GET_PRIVATE:user_ns,g_return_if_fail:php_stream_tell,user_data:SOCK_STREAM,",153.0,0.1018659353256225,MHM
1009,"    ~AutoInstallCurrentThreadPlatformMock()
    {
        Platform::initialize(m_oldPlatform);
    }
","    ~octetline()
    {
        Platform::initialize(m_oldPlatform);
    }
",13.0,3.0,"AutoInstallCurrentThreadPlatformMock:octetline,",33.0,0.0196644345919291,MHM
1010,"static void emitnumber(JF, double num)
{
	if (num == 0) {
		emit(J, F, OP_NUMBER_0);
		if (signbit(num))
			emit(J, F, OP_NEG);
	} else if (num == 1) {
		emit(J, F, OP_NUMBER_1);
	} else if (num == (js_Instruction)num) {
		emit(J, F, OP_NUMBER_POS);
		emitraw(J, F, (js_Instruction)num);
	} else if (num < 0 && -num == (js_Instruction)(-num)) {
		emit(J, F, OP_NUMBER_NEG);
		emitraw(J, F, (js_Instruction)(-num));
	} else {
		emit(J, F, OP_NUMBER);
		emitraw(J, F, addnumber(J, F, num));
	}
}
","static void inc(JF, double msg_hdr)
{
	if (msg_hdr == 0) {
		emit(PNG_WRITE_PACK_SUPPORTED, F, fz_warn);
		if (signbit(msg_hdr))
			emit(PNG_WRITE_PACK_SUPPORTED, F, OP_NEG);
	} else if (msg_hdr == 1) {
		emit(PNG_WRITE_PACK_SUPPORTED, F, EAGAIN);
	} else if (msg_hdr == (effect_param_t)msg_hdr) {
		emit(PNG_WRITE_PACK_SUPPORTED, F, OP_NUMBER_POS);
		JSP_MATCH(PNG_WRITE_PACK_SUPPORTED, F, (effect_param_t)msg_hdr);
	} else if (msg_hdr < 0 && -msg_hdr == (effect_param_t)(-msg_hdr)) {
		emit(PNG_WRITE_PACK_SUPPORTED, F, OP_NUMBER_NEG);
		JSP_MATCH(PNG_WRITE_PACK_SUPPORTED, F, (effect_param_t)(-msg_hdr));
	} else {
		emit(PNG_WRITE_PACK_SUPPORTED, F, CloseBlob);
		JSP_MATCH(PNG_WRITE_PACK_SUPPORTED, F, addnumber(PNG_WRITE_PACK_SUPPORTED, F, msg_hdr));
	}
}
",167.0,52.0,"num:msg_hdr,js_Instruction:effect_param_t,emitraw:JSP_MATCH,OP_NUMBER_0:fz_warn,OP_NUMBER:CloseBlob,OP_NUMBER_1:EAGAIN,emitnumber:inc,J:PNG_WRITE_PACK_SUPPORTED,",301.0,0.2850828051567077,MHM
1015,"static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)
{
    RIL_SimAuthentication pf;
 int32_t  t;
 status_t status;

    memset(&pf, 0, sizeof(pf));

    status = p.readInt32(&t);
    pf.authContext = (int) t;
    pf.authData = strdupReadString(p);
    pf.aid = strdupReadString(p);

    startRequest;
    appendPrintBuf(""authContext=%s, authData=%s, aid=%s"", pf.authContext, pf.authData, pf.aid);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);

 if (status != NO_ERROR) {
 goto invalid;
 }
    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memsetString(pf.authData);
    memsetString(pf.aid);
#endif

    free(pf.authData);
    free(pf.aid);

#ifdef MEMSET_FREED
    memset(&pf, 0, sizeof(pf));
#endif

 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}
","static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)
{
    RIL_SimAuthentication pf;
 int32_t  t;
 status_t status;

    memset(&pf, 0, sizeof(pf));

    status = p.readInt32(&t);
    pf.authContext = (int) t;
    pf.authData = strdupReadString(p);
    pf.aid = strdupReadString(p);

    startRequest;
    appendPrintBuf(""authContext=%s, authData=%s, aid=%s"", pf.authContext, pf.authData, pf.aid);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);

 if (status != NO_ERROR) {
 goto invalid;
 }
    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memsetString(pf.authData);
    memsetString(pf.aid);
#endif

    free(pf.authData);
    free(pf.aid);

#ifdef MEMSET_FREED
    memset(&pf, 0, sizeof(pf));
#endif

 return;
invalid:
    sample_rate(pRI);
 return;
}
",200.0,52.0,"invalidCommandBlock:sample_rate,",32.0,0.0288333415985107,MHM
1017,"  virtual void Observe(NotificationType type,
                       const NotificationSource& source,
                       const NotificationDetails& details) {
    if (type == NotificationType::NAV_LIST_PRUNED) {
      notification_count_++;
      details_ = *(Details<NavigationController::PrunedDetails>(details).ptr());
    }
  }
","  virtual void Observe(NotificationType RDG_genBuffer,
                       const NotificationSource& source,
                       const NotificationDetails& details) {
    if (RDG_genBuffer == NotificationType::NAV_LIST_PRUNED) {
      notification_count_++;
      details_ = *(Details<NavigationController::PrunedDetails>(details).ptr());
    }
  }
",51.0,10.0,"type:RDG_genBuffer,",32.0,0.0215130567550659,MHM
1021,"static void enforcedRangeByteAttrAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""enforcedRangeByteAttr"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt8(jsValue, EnforceRange, exceptionState), exceptionState);
    imp->setEnforcedRangeByteAttr(cppValue);
}
","static void enforcedRangeByteAttrAttributeSetter(v8::field_number<v8::u1_redundant_pic_cnt> det_ctx, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::disp_avail, ""enforcedRangeByteAttr"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* gss_release_buffer = V8TestObject::pk_alg(info.Holder());
    tcred(int, cppValue, TIFF_LONG(det_ctx, greq, exceptionState), exceptionState);
    gss_release_buffer->setEnforcedRangeByteAttr(cppValue);
}
",92.0,27.0,"Value:u1_redundant_pic_cnt,V8TRYCATCH_EXCEPTION_VOID:tcred,SetterContext:disp_avail,jsValue:det_ctx,toInt8:TIFF_LONG,toNative:pk_alg,EnforceRange:greq,Local:field_number,imp:gss_release_buffer,",338.0,0.2787333885828654,MHM
1022,"void __init early_trap_init(void)
{
	set_intr_gate_ist(X86_TRAP_DB, &debug, DEBUG_STACK);
	/* int3 can be called from all */
	set_system_intr_gate_ist(X86_TRAP_BP, &int3, DEBUG_STACK);
#ifdef CONFIG_X86_32
	set_intr_gate(X86_TRAP_PF, page_fault);
#endif
	load_idt(&idt_descr);
}
","void __init early_trap_init(void)
{
	set_intr_gate_ist(X86_TRAP_DB, &debug, DEBUG_STACK);
	/* int3 can be called from all */
	set_system_intr_gate_ist(X86_TRAP_BP, &int3, DEBUG_STACK);
#ifdef CONFIG_X86_32
	key_buf(X86_TRAP_PF, page_fault);
#endif
	load_idt(&idt_descr);
}
",44.0,16.0,"set_intr_gate:key_buf,",31.0,0.023059336344401,MHM
1023,"MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}
","MagickExport const first *cond(const Image *throttle)
{
  CacheInfo
    *restrict PACKET_MAX_SIZE;

  const int
    id = prop();

  assert(throttle != (const Image *) NULL);
  assert(throttle->signature == MagickSignature);
  assert(throttle->cache != (Cache) NULL);
  PACKET_MAX_SIZE=(CacheInfo *) throttle->cache;
  assert(PACKET_MAX_SIZE->signature == MagickSignature);
  if (PACKET_MAX_SIZE->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(PACKET_MAX_SIZE->methods.get_virtual_pixels_handler(throttle));
  assert(id < (int) PACKET_MAX_SIZE->number_threads);
  return(eol(PACKET_MAX_SIZE,PACKET_MAX_SIZE->nexus_info[id]));
}
",130.0,28.0,"image:throttle,GetOpenMPThreadId:prop,PixelPacket:first,cache_info:PACKET_MAX_SIZE,GetVirtualPixelsNexus:eol,GetVirtualPixelQueue:cond,",428.0,0.3973569552103678,MHM
1027,"__u32 secure_ipv6_id(const __be32 daddr[4])
{
	const struct keydata *keyptr;
	__u32 hash[4];
	keyptr = get_keyptr();
	hash[0] = (__force __u32)daddr[0];
	hash[1] = (__force __u32)daddr[1];
	hash[2] = (__force __u32)daddr[2];
	hash[3] = (__force __u32)daddr[3];
	return half_md4_transform(hash, keyptr->secret);
}
","__u32 secure_ipv6_id(const __be32 daddr[4])
{
	const struct keydata *keyptr;
	__u32 hash[4];
	keyptr = get_keyptr();
	hash[0] = (__force __u32)daddr[0];
	hash[1] = (__force __u32)daddr[1];
	hash[2] = (__force __u32)daddr[2];
	hash[3] = (__force __u32)daddr[3];
	return pSesInfo(hash, keyptr->secret);
}
",96.0,21.0,"half_md4_transform:pSesInfo,",30.0,0.0232563217480977,MHM
1030,"  void HandleMousePressEvent(int x, int y) {
    WebMouseEvent event(
        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),
        WebPointerProperties::Button::kLeft, 0,
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }
","  void mNumSamplesOutput(int x, int tpg) {
    WebMouseEvent event(
        WebInputEvent::eport, WebFloatPoint(x, tpg), WebFloatPoint(x, tpg),
        WebPointerProperties::Button::frame_size, 0,
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    dstY().mNumSamplesOutput(event);
  }
",67.0,17.0,"GetEventHandler:dstY,kMouseDown:eport,y:tpg,kLeft:frame_size,HandleMousePressEvent:mNumSamplesOutput,",151.0,0.1077173233032226,MHM
1035,"CuePoint::~CuePoint()
{
    delete[] m_track_positions;
}
","CuePoint::~CuePoint()
{
    delete[] cache;
}
",13.0,2.0,"m_track_positions:cache,",33.0,0.0211290121078491,MHM
1036,"selRead(const char  *fname)
{
FILE  *fp;
SEL   *sel;

    PROCNAME(""selRead"");

    if (!fname)
        return (SEL *)ERROR_PTR(""fname not defined"", procName, NULL);

    if ((fp = fopenReadStream(fname)) == NULL)
        return (SEL *)ERROR_PTR(""stream not opened"", procName, NULL);
    if ((sel = selReadStream(fp)) == NULL) {
        fclose(fp);
        return (SEL *)ERROR_PTR(""sela not returned"", procName, NULL);
    }
    fclose(fp);

    return sel;
}
","selRead(const char  *fname)
{
FILE  *phar_ce_PharException;
SEL   *sel;

    PROCNAME(""selRead"");

    if (!fname)
        return (SEL *)ERROR_PTR(""fname not defined"", procName, NULL);

    if ((phar_ce_PharException = fopenReadStream(fname)) == NULL)
        return (SEL *)ERROR_PTR(""stream not opened"", procName, NULL);
    if ((sel = selReadStream(phar_ce_PharException)) == NULL) {
        fclose(phar_ce_PharException);
        return (SEL *)ERROR_PTR(""sela not returned"", procName, NULL);
    }
    fclose(phar_ce_PharException);

    return sel;
}
",114.0,23.0,"fp:phar_ce_PharException,",32.0,0.0207433859507242,MHM
1038,"void dm_lock_md_type(struct mapped_device *md)
{
	mutex_lock(&md->type_lock);
}
","void fvlp(struct mapped_device *int_out)
{
	SUPPORT_TLS(&int_out->type_lock);
}
",18.0,4.0,"mutex_lock:SUPPORT_TLS,dm_lock_md_type:fvlp,md:int_out,",184.0,0.1198484539985656,MHM
1042,"void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->ForwardGestureEvent(tap);
}
","void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned PHYSADDR,
                                const gfx::Point& point) {
  blink::WebGestureEvent current_interface(blink::WebGestureEvent::kGestureTap, PHYSADDR,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  current_interface.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->ForwardGestureEvent(current_interface);
}
",81.0,13.0,"tap:current_interface,modifiers:PHYSADDR,",64.0,0.0567337393760681,MHM
1045,"mojom::FrameInputHandler* TestRenderFrame::GetFrameInputHandler() {
  if (!frame_input_handler_) {
    mojom::FrameInputHandlerRequest frame_input_handler_request =
        mojo::MakeRequest(&frame_input_handler_);
    FrameInputHandlerImpl::CreateMojoService(
        weak_factory_.GetWeakPtr(), std::move(frame_input_handler_request));
  }
  return frame_input_handler_.get();
}
","mojom::FrameInputHandler* TestRenderFrame::GetFrameInputHandler() {
  if (!dllhandle) {
    mojom::FrameInputHandlerRequest frame_input_handler_request =
        mojo::MakeRequest(&dllhandle);
    FrameInputHandlerImpl::CreateMojoService(
        weak_factory_.GetWeakPtr(), std::move(frame_input_handler_request));
  }
  return dllhandle.get();
}
",56.0,10.0,"frame_input_handler_:dllhandle,",32.0,0.0247197747230529,MHM
1047,"static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
","static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct Mmx *Mmx = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(Mmx->uid, tcred->euid) &&
	    uid_eq(Mmx->uid, tcred->suid) &&
	    uid_eq(Mmx->uid, tcred->uid)  &&
	    gid_eq(Mmx->gid, tcred->egid) &&
	    gid_eq(Mmx->gid, tcred->sgid) &&
	    gid_eq(Mmx->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -file_def;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -file_def;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
",218.0,55.0,"EPERM:file_def,cred:Mmx,",92.0,0.1083821574846903,MHM
1049," void MediaInterfaceProxy::CreateCdm(
     media::mojom::ContentDecryptionModuleRequest request) {
   DCHECK(thread_checker_.CalledOnValidThread());
  GetMediaInterfaceFactory()->CreateCdm(std::move(request));
 }
"," void MediaInterfaceProxy::CreateCdm(
     media::mojom::ContentDecryptionModuleRequest AV_LOG_ERROR) {
   DCHECK(thread_checker_.CalledOnValidThread());
  GetMediaInterfaceFactory()->CreateCdm(std::move(AV_LOG_ERROR));
 }
",37.0,7.0,"request:AV_LOG_ERROR,",33.0,0.0232369899749755,MHM
1050,"set_pwd ()
{
  SHELL_VAR *temp_var, *home_var;
  char *temp_string, *home_string;

  home_var = find_variable (""HOME"");
  home_string = home_var ? value_cell (home_var) : (char *)NULL;

  temp_var = find_variable (""PWD"");
  if (temp_var && imported_p (temp_var) &&
      (temp_string = value_cell (temp_var)) &&
      same_file (temp_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    set_working_directory (temp_string);
  else if (home_string && interactive_shell && login_shell &&
	   same_file (home_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    {
      set_working_directory (home_string);
      temp_var = bind_variable (""PWD"", home_string, 0);
      set_auto_export (temp_var);
    }
  else
    {
      temp_string = get_working_directory (""shell-init"");
      if (temp_string)
	{
	  temp_var = bind_variable (""PWD"", temp_string, 0);
	  set_auto_export (temp_var);
	  free (temp_string);
	}
    }

  /* According to the Single Unix Specification, v2, $OLDPWD is an
     `environment variable' and therefore should be auto-exported.
     Make a dummy invisible variable for OLDPWD, and mark it as exported. */
  temp_var = bind_variable (""OLDPWD"", (char *)NULL, 0);
  VSETATTR (temp_var, (att_exported | att_invisible));
}
","set_pwd ()
{
  SHELL_VAR *temp_var, *home_var;
  char *temp_string, *home_string;

  home_var = find_variable (""HOME"");
  home_string = home_var ? value_cell (home_var) : (char *)NULL;

  temp_var = find_variable (""PWD"");
  if (temp_var && imported_p (temp_var) &&
      (temp_string = value_cell (temp_var)) &&
      same_file (temp_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    set_working_directory (temp_string);
  else if (home_string && interactive_shell && login_shell &&
	   same_file (home_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    {
      set_working_directory (home_string);
      temp_var = bind_variable (""PWD"", home_string, 0);
      set_auto_export (temp_var);
    }
  else
    {
      temp_string = get_working_directory (""shell-init"");
      if (temp_string)
	{
	  temp_var = bind_variable (""PWD"", temp_string, 0);
	  set_auto_export (temp_var);
	  php_stream_read (temp_string);
	}
    }

  /* According to the Single Unix Specification, v2, $OLDPWD is an
     `environment variable' and therefore should be auto-exported.
     Make a dummy invisible variable for OLDPWD, and mark it as exported. */
  temp_var = bind_variable (""OLDPWD"", (char *)NULL, 0);
  VSETATTR (temp_var, (att_exported | att_invisible));
}
",217.0,51.0,"free:php_stream_read,",33.0,0.0421869119008382,MHM
1051,"   void AddSimpleRectChunk(TestPaintArtifact& artifact) {
    artifact
        .Chunk(TransformPaintPropertyNode::Root(),
               ClipPaintPropertyNode::Root(), EffectPaintPropertyNode::Root())
         .RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);
   }
","   void pu4_bitstrm_ofst(TestPaintArtifact& alproto) {
    alproto
        .Chunk(TransformPaintPropertyNode::Root(),
               ClipPaintPropertyNode::Root(), EffectPaintPropertyNode::Root())
         .RectDrawing(b1(100, 100, 200, 100), Color::wmf_error);
   }
",50.0,8.0,"kBlack:wmf_error,FloatRect:b1,AddSimpleRectChunk:pu4_bitstrm_ofst,artifact:alproto,",248.0,0.1849452177683512,MHM
1052,"struct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,
				     const struct sctp_chunk *chunk)
{
	struct sctp_chunk *retval;

	retval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0);

	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
	 *
	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,
	 * HEARTBEAT ACK, * etc.) to the same destination transport
	 * address from which it * received the DATA or control chunk
	 * to which it is replying.
	 *
	 * [ACK back to where the SHUTDOWN came from.]
	 */
	if (retval && chunk)
		retval->transport = chunk->transport;

	return retval;
}
","struct sctp_chunk *last_alias_len(const struct sctp_association *read_u32,
				     const struct sctp_chunk *flag)
{
	struct sctp_chunk *mVideoWidth;

	mVideoWidth = ret2(read_u32, leaseduration, 0, 0);

	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
	 *
	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,
	 * HEARTBEAT ACK, * etc.) to the same destination transport
	 * address from which it * received the DATA or control chunk
	 * to which it is replying.
	 *
	 * [ACK back to where the SHUTDOWN came from.]
	 */
	if (mVideoWidth && flag)
		mVideoWidth->transport = flag->transport;

	return mVideoWidth;
}
",54.0,13.0,"chunk:flag,retval:mVideoWidth,asoc:read_u32,SCTP_CID_SHUTDOWN_ACK:leaseduration,sctp_make_control:ret2,sctp_make_shutdown_ack:last_alias_len,",422.0,0.3293903509775797,MHM
1055,"bool CanUseExistingResource(const net::HttpResponseInfo* http_info) {
  if (!http_info->headers || http_info->headers->RequiresValidation(
                                 http_info->request_time,
                                 http_info->response_time, base::Time::Now())) {
    return false;
  }

  std::string value;
  size_t iter = 0;
  while (http_info->headers->EnumerateHeader(&iter, ""vary"", &value)) {
    if (!base::EqualsCaseInsensitiveASCII(value, ""Accept-Encoding"") &&
        !base::EqualsCaseInsensitiveASCII(value, ""Origin"")) {
      return false;
    }
  }
  return true;
}
","bool row_width(const net::HttpResponseInfo* TRACEMS2) {
  if (!TRACEMS2->headers || TRACEMS2->headers->RequiresValidation(
                                 TRACEMS2->request_time,
                                 TRACEMS2->response_time, base::Time::Now())) {
    return false;
  }

  std::string mainFrameURL;
  size_t complex_images = 0;
  while (TRACEMS2->headers->EnumerateHeader(&complex_images, ""vary"", &mainFrameURL)) {
    if (!base::EqualsCaseInsensitiveASCII(mainFrameURL, ""Accept-Encoding"") &&
        !base::EqualsCaseInsensitiveASCII(mainFrameURL, ""Origin"")) {
      return false;
    }
  }
  return true;
}
",109.0,16.0,"CanUseExistingResource:row_width,http_info:TRACEMS2,iter:complex_images,value:mainFrameURL,",124.0,0.1146741390228271,MHM
1057,"bool SendGoBackJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""GoBack"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}
","bool die(
    AutomationMessageSender* INIT_SELECTING,
    int for_user,
    int tab_index,
    std::string* error_msg) {
  DictionaryValue res_sz;
  res_sz.SetString(""command"", ""GoBack"");
  res_sz.SetInteger(""windex"", for_user);
  res_sz.SetInteger(""tab_index"", tab_index);
  DictionaryValue pathto_len;
  return MODE_IN(INIT_SELECTING, res_sz, &pathto_len, error_msg);
}
",71.0,17.0,"SendGoBackJSONRequest:die,dict:res_sz,browser_index:for_user,SendAutomationJSONRequest:MODE_IN,sender:INIT_SELECTING,reply_dict:pathto_len,",429.0,0.3447762171427408,MHM
1058," MediaBuffer *readBuffer(FLAC__uint64 sample) {
 return readBuffer(true, sample);
 }
"," MediaBuffer *speclen(FLAC__uint64 msyslog) {
 return speclen(true, msyslog);
 }
",17.0,4.0,"readBuffer:speclen,sample:msyslog,",185.0,0.1232585430145263,MHM
1060,"  UpdateTemporaryGlobalQuotaTask(
      QuotaManager* manager,
      int64 new_quota,
      QuotaCallback* callback)
      : DatabaseTaskBase(manager),
        new_quota_(new_quota),
        callback_(callback) {
    DCHECK_GE(new_quota, 0);
  }
","  UpdateTemporaryGlobalQuotaTask(
      QuotaManager* manager,
      int64 new_quota,
      QuotaCallback* callback)
      : DatabaseTaskBase(manager),
        new_quota_(new_quota),
        callback_(callback) {
    last_phar_name(new_quota, 0);
  }
",37.0,9.0,"DCHECK_GE:last_phar_name,",33.0,0.0254627744356791,MHM
1062,"   static void TearDownTestCase() {
    vpx_free(source_data_);
    source_data_ = NULL;
    vpx_free(reference_data_);
    reference_data_ = NULL;
   }
","   static void bpp() {
    vpx_free(source_data_);
    source_data_ = NULL;
    vpx_free(reference_data_);
    reference_data_ = NULL;
   }
",25.0,7.0,"TearDownTestCase:bpp,",34.0,0.01981916030248,MHM
1064,"void RenderFrameHostImpl::UpdateSubresourceLoaderFactories() {
  DCHECK(base::FeatureList::IsEnabled(network::features::kNetworkService));
  if (!has_committed_any_navigation_)
    return;
  DCHECK(!IsOutOfProcessNetworkService() ||
         network_service_connection_error_handler_holder_.is_bound());

  network::mojom::URLLoaderFactoryPtrInfo default_factory_info;
  bool bypass_redirect_checks = false;
  if (recreate_default_url_loader_factory_after_network_service_crash_) {
    bypass_redirect_checks = CreateNetworkServiceDefaultFactoryAndObserve(
        last_committed_origin_, mojo::MakeRequest(&default_factory_info));
  }

  std::unique_ptr<URLLoaderFactoryBundleInfo> subresource_loader_factories =
      std::make_unique<URLLoaderFactoryBundleInfo>(
          std::move(default_factory_info),
          URLLoaderFactoryBundleInfo::SchemeMap(),
          CreateInitiatorSpecificURLLoaderFactories(
              initiators_requiring_separate_url_loader_factory_),
          bypass_redirect_checks);
  GetNavigationControl()->UpdateSubresourceLoaderFactories(
      std::move(subresource_loader_factories));
}
","void RenderFrameHostImpl::UpdateSubresourceLoaderFactories() {
  g_hash_table_foreach(base::FeatureList::real_to_path(network::features::kNetworkService));
  if (!has_committed_any_navigation_)
    return;
  g_hash_table_foreach(!hsize() ||
         path.is_bound());

  network::mojom::URLLoaderFactoryPtrInfo color;
  bool base_pages_to_flush = false;
  if (recreate_default_url_loader_factory_after_network_service_crash_) {
    base_pages_to_flush = CreateNetworkServiceDefaultFactoryAndObserve(
        memPtr, mojo::cBufferSize(&color));
  }

  std::unique_ptr<URLLoaderFactoryBundleInfo> BDFLINELEN =
      std::RelinquishMagickMemory<URLLoaderFactoryBundleInfo>(
          std::move(color),
          URLLoaderFactoryBundleInfo::SchemeMap(),
          CreateInitiatorSpecificURLLoaderFactories(
              initiators_requiring_separate_url_loader_factory_),
          base_pages_to_flush);
  repl()->UpdateSubresourceLoaderFactories(
      std::move(BDFLINELEN));
}
",128.0,27.0,"GetNavigationControl:repl,IsOutOfProcessNetworkService:hsize,network_service_connection_error_handler_holder_:path,make_unique:RelinquishMagickMemory,bypass_redirect_checks:base_pages_to_flush,last_committed_origin_:memPtr,IsEnabled:real_to_path,subresource_loader_factories:BDFLINELEN,default_factory_info:color,MakeRequest:cBufferSize,DCHECK:g_hash_table_foreach,",398.0,0.3516945242881775,MHM
1065,"void ContentSecurityPolicy::BindToExecutionContext(
    ExecutionContext* execution_context) {
  execution_context_ = execution_context;
  ApplyPolicySideEffectsToExecutionContext();
}
","void ContentSecurityPolicy::BindToExecutionContext(
    ExecutionContext* execution_context) {
  execution_context_ = execution_context;
  m_pSegment();
}
",19.0,5.0,"ApplyPolicySideEffectsToExecutionContext:m_pSegment,",33.0,0.0301746209462483,MHM
1068,"static int edge_remove_sysfs_attrs(struct usb_serial_port *port)
{
	device_remove_file(&port->dev, &dev_attr_uart_mode);
	return 0;
}
","static int content(struct usb_serial_port *INT16)
{
	pEAPKey(&INT16->dev, &rows);
	return 0;
}
",25.0,5.0,"port:INT16,dev_attr_uart_mode:rows,edge_remove_sysfs_attrs:content,device_remove_file:pEAPKey,",459.0,0.297062341372172,MHM
1073,"void GDataDirectoryService::SerializeToString(
    std::string* serialized_proto) const {
  GDataRootDirectoryProto proto;
  root_->ToProto(proto.mutable_gdata_directory());
  proto.set_largest_changestamp(largest_changestamp_);
  proto.set_version(kProtoVersion);

  const bool ok = proto.SerializeToString(serialized_proto);
  DCHECK(ok);
}
","void GDataDirectoryService::SerializeToString(
    std::string* SaveImageTag) const {
  GDataRootDirectoryProto proto;
  root_->ToProto(proto.mutable_gdata_directory());
  proto.set_largest_changestamp(largest_changestamp_);
  proto.set_version(kProtoVersion);

  const bool ok = proto.SerializeToString(SaveImageTag);
  DCHECK(ok);
}
",58.0,14.0,"serialized_proto:SaveImageTag,",33.0,0.0214563290278116,MHM
1076,"void CrosLibrary::TestApi::SetBrightnessLibrary(
    BrightnessLibrary* library, bool own) {
  library_->brightness_lib_.SetImpl(library, own);
}
","void CrosLibrary::TestApi::MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER(
    BrightnessLibrary* OPT_f, bool msg_flags) {
  u1_mbaff->brightness_lib_.SetImpl(OPT_f, msg_flags);
}
",27.0,6.0,"own:msg_flags,SetBrightnessLibrary:MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER,library_:u1_mbaff,library:OPT_f,",459.0,0.3106852571169535,MHM
1077,"void RenderViewImpl::OnSelectPopupMenuItems(
    bool canceled,
    const std::vector<int>& selected_indices) {
  if (!external_popup_menu_.get())
    return;

  external_popup_menu_->DidSelectItems(canceled, selected_indices);
  external_popup_menu_.reset();
}
","void RenderViewImpl::m_inp_mem_ptr(
    bool canceled,
    const std::vector<int>& selected_indices) {
  if (!fd_ptr.get())
    return;

  fd_ptr->DidSelectItems(canceled, selected_indices);
  fd_ptr.reset();
}
",46.0,8.0,"OnSelectPopupMenuItems:m_inp_mem_ptr,external_popup_menu_:fd_ptr,",211.0,0.1678074280420939,MHM
1078,"void WebContentsImpl::AddDestructionObserver(WebContentsImpl* web_contents) {
  if (!ContainsKey(destruction_observers_, web_contents)) {
    destruction_observers_[web_contents] =
        std::make_unique<DestructionObserver>(this, web_contents);
  }
}
","void WebContentsImpl::AddDestructionObserver(WebContentsImpl* web_contents) {
  if (!save_lookup_value(destruction_observers_, web_contents)) {
    destruction_observers_[web_contents] =
        std::WriteBinaryBlobMode<DestructionObserver>(this, web_contents);
  }
}
",40.0,9.0,"ContainsKey:save_lookup_value,make_unique:WriteBinaryBlobMode,",63.0,0.0456767956415812,MHM
1079,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","static int svc_can_register(const uint16_t *ContextGL, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(ContextGL, name_len)) ? 1 : 0;
}
",60.0,15.0,"name:ContextGL,",33.0,0.0191620389620463,MHM
1081,"int import_iovec(int type, const struct iovec __user * uvector,
		 unsigned nr_segs, unsigned fast_segs,
		 struct iovec **iov, struct iov_iter *i)
{
	ssize_t n;
	struct iovec *p;
	n = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,
				  *iov, &p);
	if (n < 0) {
		if (p != *iov)
			kfree(p);
		*iov = NULL;
		return n;
	}
	iov_iter_init(i, type, p, nr_segs, n);
	*iov = p == *iov ? NULL : p;
	return 0;
}
","int import_iovec(int type, const struct iovec __user * uvector,
		 unsigned nr_segs, unsigned fast_segs,
		 struct iovec **iov, struct iov_iter *i)
{
	ssize_t n;
	struct iovec *p;
	n = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,
				  *iov, &p);
	if (n < 0) {
		if (p != *iov)
			kfree(p);
		*iov = NULL;
		return n;
	}
	png_memcpy(i, type, p, nr_segs, n);
	*iov = p == *iov ? NULL : p;
	return 0;
}
",115.0,35.0,"iov_iter_init:png_memcpy,",34.0,0.0254767139752705,MHM
1084,"void OfflinePageModelTaskified::OnTaskQueueIsIdle() {}
","void OfflinePageModelTaskified::fd_ptr() {}
",8.0,1.0,"OnTaskQueueIsIdle:fd_ptr,",182.0,0.1178035457928975,MHM
1088,"static void readonlyWindowAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE(""Blink"", ""DOMGetter"");
    TestObjectPythonV8Internal::readonlyWindowAttributeAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE(""V8"", ""V8Execution"");
}
","static void datagrams(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& current_entry)
{
    EXTRACT_LE_8BITS(""Blink"", ""DOMGetter"");
    TestObjectPythonV8Internal::pptr(current_entry);
    EXTRACT_LE_8BITS(""V8"", ""V8Execution"");
}
",52.0,6.0,"info:current_entry,readonlyWindowAttributeAttributeGetter:pptr,readonlyWindowAttributeAttributeGetterCallback:datagrams,TRACE_EVENT_SET_SAMPLING_STATE:EXTRACT_LE_8BITS,",457.0,0.337511682510376,MHM
1089,"  void VerifyPrintPreviewInvalidPrinterSettings(bool settings_invalid) {
    bool print_preview_invalid_printer_settings =
        (render_thread_->sink().GetUniqueMessageMatching(
            PrintHostMsg_PrintPreviewInvalidPrinterSettings::ID) != NULL);
    EXPECT_EQ(settings_invalid, print_preview_invalid_printer_settings);
  }
","  void VerifyPrintPreviewInvalidPrinterSettings(bool settings_invalid) {
    bool impeg2d_bit_stream_get =
        (render_thread_->sink().GetUniqueMessageMatching(
            PrintHostMsg_PrintPreviewInvalidPrinterSettings::usage) != NULL);
    hdrlen(settings_invalid, impeg2d_bit_stream_get);
  }
",35.0,8.0,"ID:usage,EXPECT_EQ:hdrlen,print_preview_invalid_printer_settings:impeg2d_bit_stream_get,",94.0,0.0642616748809814,MHM
1090,"void QQuickWebViewPrivate::setNeedsDisplay()
{
    Q_Q(QQuickWebView);
    if (renderToOffscreenBuffer()) {
        QImage dummyImage(1, 1, QImage::Format_ARGB32);
        QPainter painter(&dummyImage);
        q->page()->d->paint(&painter);
        return;
    }

    q->page()->update();
}
","void QQuickWebViewPrivate::setNeedsDisplay()
{
    ndo(QQuickWebView);
    if (renderToOffscreenBuffer()) {
        QImage dummyImage(1, 1, QImage::output);
        QPainter directory(&dummyImage);
        parent->page()->d->paint(&directory);
        return;
    }

    parent->page()->update();
}
",66.0,11.0,"Q_Q:ndo,q:parent,Format_ARGB32:output,painter:directory,",186.0,0.1384609580039978,MHM
1091,"cleanup_bmc_device(struct kref *ref)
{
	struct bmc_device *bmc = container_of(ref, struct bmc_device, usecount);

	/*
	 * Remove the platform device in a work queue to avoid issues
	 * with removing the device attributes while reading a device
	 * attribute.
	 */
	schedule_work(&bmc->remove_work);
}
","cleanup_bmc_device(outfile kref *ref)
{
	outfile ipaddr_string *bmc = container_of(ref, outfile ipaddr_string, usecount);

	/*
	 * Remove the platform device in a work queue to avoid issues
	 * with removing the device attributes while reading a device
	 * attribute.
	 */
	schedule_work(&bmc->remove_work);
}
",32.0,10.0,"bmc_device:ipaddr_string,struct:outfile,",63.0,0.0391498208045959,MHM
1095,"   void FireInvalidateAll() {
    invalidation::AckHandle ack_handle(""fakedata"");
    EXPECT_CALL(mock_invalidation_client_, Acknowledge(ack_handle));
    client_.InvalidateAll(&mock_invalidation_client_, ack_handle);
   }
","   void FireInvalidateAll() {
    invalidation::AckHandle SAFNUM_VPNMULTICAST(""fakedata"");
    EXPECT_CALL(mock_invalidation_client_, Acknowledge(SAFNUM_VPNMULTICAST));
    client_.InvalidateAll(&mock_invalidation_client_, SAFNUM_VPNMULTICAST);
   }
",35.0,9.0,"ack_handle:SAFNUM_VPNMULTICAST,",32.0,0.0230406165122985,MHM
1097,"void qeth_clear_thread_start_bit(struct qeth_card *card, unsigned long thread)
{
	unsigned long flags;

	spin_lock_irqsave(&card->thread_mask_lock, flags);
	card->thread_start_mask &= ~thread;
	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
	wake_up(&card->wait_q);
}
","void match_data(struct qeth_card *sender, unsigned long thread)
{
	unsigned long jsUndefined;

	spin_lock_irqsave(&sender->thread_mask_lock, jsUndefined);
	sender->thread_start_mask &= ~thread;
	ND_TCHECK(&sender->thread_mask_lock, jsUndefined);
	psir(&sender->wait_q);
}
",53.0,14.0,"flags:jsUndefined,card:sender,qeth_clear_thread_start_bit:match_data,wake_up:psir,spin_unlock_irqrestore:ND_TCHECK,",247.0,0.1645974000295003,MHM
1102,"void GpuCommandBufferStub::OnCommandProcessed() {
  if (watchdog_)
    watchdog_->CheckArmed();
}
","void GpuCommandBufferStub::OnCommandProcessed() {
  if (MAYBE_MISSING_PARAMETER)
    MAYBE_MISSING_PARAMETER->CheckArmed();
}
",18.0,3.0,"watchdog_:MAYBE_MISSING_PARAMETER,",33.0,0.0278795560201009,MHM
1107,"static void sctp_v6_seq_dump_addr(struct seq_file *seq, union sctp_addr *addr)
{
	seq_printf(seq, ""%pI6 "", &addr->v6.sin6_addr);
}
","static void nodes(struct seq_file *PHP_VAR_UNSERIALIZE_DESTROY, union sctp_addr *raw_label)
{
	seq_printf(PHP_VAR_UNSERIALIZE_DESTROY, ""%pI6 "", &raw_label->v6.sin6_addr);
}
",31.0,6.0,"seq:PHP_VAR_UNSERIALIZE_DESTROY,addr:raw_label,sctp_v6_seq_dump_addr:nodes,",186.0,0.1176017721494038,MHM
1110,"void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(socket, max_pending_send_allowed);
}
","void WebSocketJob::OnConnected(
    SocketStream* MagickSignature, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(MagickSignature, max_pending_send_allowed);
}
",42.0,12.0,"socket:MagickSignature,",32.0,0.0269268155097961,MHM
1114,"  string cookie_value() {
    return decoder_->cookie_value_;
  }
","  string VectorNegativeMultiplySubtract() {
    return decoder_->cookie_value_;
  }
",11.0,2.0,"cookie_value:VectorNegativeMultiplySubtract,",33.0,0.0191248734792073,MHM
1115,"static void __exit exit_ext3_fs(void)
{
	unregister_filesystem(&ext3_fs_type);
	destroy_inodecache();
	exit_ext3_xattr();
}
","static void __exit default_values(void)
{
	unregister_filesystem(&ext3_fs_type);
	colour_type();
	tmsize_t();
}
",23.0,6.0,"destroy_inodecache:colour_type,exit_ext3_fs:default_values,exit_ext3_xattr:tmsize_t,",126.0,0.0924221038818359,MHM
1116,"void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  }
}
","void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  url_(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  }
}
",79.0,11.0,"ProcessCommitResponse:url_,",33.0,0.0268717249234517,MHM
1118,"bool IsURLAllowedInIncognito(const GURL& url) {
  return url.scheme() == chrome::kChromeUIScheme &&
      (url.host() == chrome::kChromeUISettingsHost ||
       url.host() == chrome::kChromeUIExtensionsHost ||
       url.host() == chrome::kChromeUIBookmarksHost);
}
","bool newpos(const GURL& url) {
  return url.scheme() == chrome::kChromeUIScheme &&
      (url.host() == chrome::kChromeUISettingsHost ||
       url.host() == chrome::kChromeUIExtensionsHost ||
       url.host() == chrome::kChromeUIBookmarksHost);
}
",53.0,10.0,"IsURLAllowedInIncognito:newpos,",32.0,0.0219604889551798,MHM
1123,"static unsigned mounts_poll(struct file *file, poll_table *wait)
{
	struct proc_mounts *p = file->private_data;
	unsigned res = POLLIN | POLLRDNORM;

	poll_wait(file, &p->ns->poll, wait);
	if (mnt_had_events(p))
		res |= POLLERR | POLLPRI;

	return res;
}
","static unsigned cdf_property_info_t(struct file *file, poll_table *wait)
{
	struct proc_mounts *p = file->private_data;
	unsigned res = POLLIN | POLLRDNORM;

	poll_wait(file, &p->ns->poll, wait);
	if (mnt_had_events(p))
		res |= files | POLLPRI;

	return res;
}
",61.0,18.0,"POLLERR:files,mounts_poll:cdf_property_info_t,",64.0,0.0474527438481648,MHM
1124,"ACodec::UninitializedState::UninitializedState(ACodec *codec)
 : BaseState(codec) {
}
","ACodec::dstBuffer::dstBuffer(ACodec *codec)
 : BaseState(codec) {
}
",17.0,3.0,"UninitializedState:dstBuffer,",33.0,0.0249040921529134,MHM
1130,"std::wstring GetChromeChannelName() {
  return InstallDetails::Get().channel();
}
","std::wstring target_offset() {
  return InstallDetails::Get().channel();
}
",19.0,2.0,"GetChromeChannelName:target_offset,",33.0,0.0193240125974019,MHM
1132,"static const char *set_async_filter(cmd_parms *cmd, void *dummy,
                                             const char *arg)
{
    core_server_config *conf =
    ap_get_core_module_config(cmd->server->module_config);
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);

    if (err) {
        return err;
    }

    if (ap_cstr_casecmp(arg, ""network"") == 0) {
        conf->async_filter = AP_FTYPE_NETWORK;
    }
    else if (ap_cstr_casecmp(arg, ""connection"") == 0) {
        conf->async_filter = AP_FTYPE_CONNECTION;
    }
    else if (ap_cstr_casecmp(arg, ""request"") == 0) {
        conf->async_filter = 0;
    }
    else {
        return ""AsyncFilter must be 'network', 'connection' or 'request'"";
    }
    conf->async_filter_set = 1;

    return NULL;
}
","static const char *MediaElement(cmd_parms *cmd, void *new_origin,
                                             const char *javascript)
{
    core_server_config *xps_resolve_resource_reference =
    GURL(cmd->server->module_config);
    const char *write = ap_check_cmd_context(cmd, ThrowReaderException);

    if (write) {
        return write;
    }

    if (patternZRTPMetaData(javascript, ""network"") == 0) {
        xps_resolve_resource_reference->async_filter = funcName;
    }
    else if (patternZRTPMetaData(javascript, ""connection"") == 0) {
        xps_resolve_resource_reference->async_filter = match;
    }
    else if (patternZRTPMetaData(javascript, ""request"") == 0) {
        xps_resolve_resource_reference->async_filter = 0;
    }
    else {
        return ""AsyncFilter must be 'network', 'connection' or 'request'"";
    }
    xps_resolve_resource_reference->async_filter_set = 1;

    return NULL;
}
",133.0,25.0,"AP_FTYPE_NETWORK:funcName,dummy:new_origin,conf:xps_resolve_resource_reference,err:write,arg:javascript,ap_get_core_module_config:GURL,set_async_filter:MediaElement,ap_cstr_casecmp:patternZRTPMetaData,AP_FTYPE_CONNECTION:match,NOT_IN_DIR_LOC_FILE:ThrowReaderException,",490.0,0.4080503940582275,MHM
1133,"TabAppendedNotificationObserver::TabAppendedNotificationObserver(
    Browser* parent,
    AutomationProvider* automation,
    IPC::Message* reply_message,
    bool use_json_interface)
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   automation),
      parent_(parent),
      reply_message_(reply_message),
      use_json_interface_(use_json_interface) {
}
","png_ptr::png_ptr(
    Browser* parent,
    AutomationProvider* automation,
    IPC::Message* reply_message,
    bool ALIGN_TO)
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   automation),
      parent_(parent),
      reply_message_(reply_message),
      use_json_interface_(ALIGN_TO) {
}
",47.0,10.0,"use_json_interface:ALIGN_TO,TabAppendedNotificationObserver:png_ptr,",64.0,0.0395831028620402,MHM
1135,"static inline bool isChildTypeAllowed(ContainerNode* newParent, Node* child)
{
    if (!child->isDocumentFragment())
        return newParent->childTypeAllowed(child->nodeType());

    for (Node* node = child->firstChild(); node; node = node->nextSibling()) {
        if (!newParent->childTypeAllowed(node->nodeType()))
            return false;
    }
    return true;
}
","static inline bool trace(ContainerNode* SIG, Node* m_inp_mem_ptr)
{
    if (!m_inp_mem_ptr->isDocumentFragment())
        return SIG->childTypeAllowed(m_inp_mem_ptr->nodeType());

    for (Node* node = m_inp_mem_ptr->firstChild(); node; node = node->nextSibling()) {
        if (!SIG->childTypeAllowed(node->nodeType()))
            return false;
    }
    return true;
}
",80.0,13.0,"newParent:SIG,child:m_inp_mem_ptr,isChildTypeAllowed:trace,",246.0,0.1727298219998677,MHM
1137,"  void Dispose() {
    raw_data_ = nullptr;
    delete this;
  }
","  void Dispose() {
    INT16 = nullptr;
    delete this;
  }
",13.0,2.0,"raw_data_:INT16,",95.0,0.0608738382657369,MHM
1139,"ProfileKeyedAPIFactory<BookmarksAPI>* BookmarksAPI::GetFactoryInstance() {
  return &g_factory.Get();
}
","ProfileKeyedAPIFactory<BookmarksAPI>* BookmarksAPI::parent() {
  return &mPssh.Get();
}
",20.0,2.0,"GetFactoryInstance:parent,g_factory:mPssh,",492.0,0.3523382067680359,MHM
1142,"void sco_connect_cfm(struct hci_conn *hcon, __u8 status)
{
	BT_DBG(""hcon %p bdaddr %pMR status %d"", hcon, &hcon->dst, status);
	if (!status) {
		struct sco_conn *conn;

		conn = sco_conn_add(hcon);
		if (conn)
			sco_conn_ready(conn);
	} else
		sco_conn_del(hcon, bt_to_errno(status));
}
","void sig_len(struct hci_conn *hcon, __u8 segCount)
{
	BT_DBG(""hcon %p bdaddr %pMR status %d"", hcon, &hcon->dst, segCount);
	if (!segCount) {
		struct sco_conn *content_box_size_;

		content_box_size_ = OMX_BUFFERHEADERTYPE(hcon);
		if (content_box_size_)
			sco_conn_ready(content_box_size_);
	} else
		srcStride(hcon, type_token(segCount));
}
",67.0,19.0,"conn:content_box_size_,sco_conn_del:srcStride,status:segCount,sco_conn_add:OMX_BUFFERHEADERTYPE,bt_to_errno:type_token,sco_connect_cfm:sig_len,",243.0,0.1863661567370096,MHM
1146,"int dev_close(struct net_device *dev)
{
	if (!(dev->flags & IFF_UP))
		return 0;

	__dev_close(dev);

	/*
	 * Tell people we are down
	 */
	rtmsg_ifinfo(RTM_NEWLINK, dev, IFF_UP|IFF_RUNNING);
	call_netdevice_notifiers(NETDEV_DOWN, dev);

	return 0;
}
","int ops(struct net_device *pmd_offset)
{
	if (!(pmd_offset->flags & BPF_OP))
		return 0;

	g1(pmd_offset);

	/*
	 * Tell people we are down
	 */
	phdr(BPF_MODE, pmd_offset, BPF_OP|UTF8ToUTF16);
	call_netdevice_notifiers(r_strbuf_set, pmd_offset);

	return 0;
}
",50.0,14.0,"dev_close:ops,NETDEV_DOWN:r_strbuf_set,IFF_RUNNING:UTF8ToUTF16,rtmsg_ifinfo:phdr,RTM_NEWLINK:BPF_MODE,__dev_close:g1,IFF_UP:BPF_OP,dev:pmd_offset,",454.0,0.328456179300944,MHM
1147,"int SSLClientSocketOpenSSL::GetLocalAddress(IPEndPoint* addressList) const {
  return transport_->socket()->GetLocalAddress(addressList);
}
","int SSLClientSocketOpenSSL::GetLocalAddress(IPEndPoint* addressList) const {
  return current_utterance_->socket()->GetLocalAddress(addressList);
}
",24.0,4.0,"transport_:current_utterance_,",63.0,0.0455354253451029,MHM
1150,"static inline unsigned long hash_name(const char *name, unsigned int *hashp)
{
	unsigned long hash = init_name_hash();
	unsigned long len = 0, c;

	c = (unsigned char)*name;
	do {
		len++;
		hash = partial_name_hash(c, hash);
		c = (unsigned char)name[len];
	} while (c && c != '/');
	*hashp = end_name_hash(hash);
	return len;
}
","static inline unsigned long hash_name(const char *pReader, unsigned int *hashp)
{
	unsigned long hash = init_name_hash();
	unsigned long len = 0, c;

	c = (unsigned char)*pReader;
	do {
		len++;
		hash = partial_name_hash(c, hash);
		c = (unsigned char)pReader[len];
	} while (c && c != '/');
	*hashp = end_name_hash(hash);
	return len;
}
",90.0,23.0,"name:pReader,",35.0,0.0302404721577962,MHM
1151,"void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)
 {
 	void* pointer;
 
	if (!handle)
 		return NULL;
 
 	pointer = (void*) ~((size_t) handle->dwLower);

	return pointer;
}
","void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)
 {
 	void* outline;
 
	if (!handle)
 		return NULL;
 
 	outline = (void*) ~((size_t) handle->dwLower);

	return outline;
}
",41.0,7.0,"pointer:outline,",33.0,0.0209076523780822,MHM
1152,"InputImeEventRouter* GetInputImeEventRouter(Profile* profile) {
   if (!profile)
     return nullptr;
   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(
      profile->GetOriginalProfile());
 }
","InputImeEventRouter* pu4_buf_aligned(Profile* profile) {
   if (!profile)
     return nullptr;
   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(
      profile->GetOriginalProfile());
 }
",36.0,5.0,"GetInputImeEventRouter:pu4_buf_aligned,",33.0,0.0268364469210306,MHM
1160,"LockContentsView::UserState::UserState(AccountId account_id)
    : account_id(account_id) {}
","LockContentsView::ARY_PTR::ARY_PTR(AccountId account_id)
    : account_id(account_id) {}
",16.0,3.0,"UserState:ARY_PTR,",33.0,0.023560897509257,MHM
1161,"static int dev_get_valid_name(struct net *net, const char *name, char *buf,
			      bool fmt)
{
	if (!dev_valid_name(name))
		return -EINVAL;

	if (fmt && strchr(name, '%'))
		return __dev_alloc_name(net, name, buf);
	else if (__dev_get_by_name(net, name))
		return -EEXIST;
	else if (buf != name)
		strlcpy(buf, name, IFNAMSIZ);

	return 0;
}
","static int clp(struct net *net, const char *usb_dev, char *buf,
			      bool fmt)
{
	if (!dev_valid_name(usb_dev))
		return -EINVAL;

	if (fmt && strchr(usb_dev, '%'))
		return __dev_alloc_name(net, usb_dev, buf);
	else if (__dev_get_by_name(net, usb_dev))
		return -EEXIST;
	else if (buf != usb_dev)
		strlcpy(buf, usb_dev, IFNAMSIZ);

	return 0;
}
",90.0,25.0,"dev_get_valid_name:clp,name:usb_dev,",61.0,0.054731265703837,MHM
1171,"void RenderViewImpl::UpdateTitle(WebFrame* frame,
                                 const string16& title,
                                 WebTextDirection title_direction) {
  if (frame->parent())
    return;

  string16 shortened_title = title.substr(0, content::kMaxTitleChars);
  Send(new ViewHostMsg_UpdateTitle(routing_id_, page_id_, shortened_title,
                                   title_direction));
}
","void RenderViewImpl::SCFree(WebFrame* frame,
                                 const string16& title,
                                 WebTextDirection tv) {
  if (frame->parent())
    return;

  string16 PNG_WRITE_INVERT_SUPPORTED = title.substr(0, content::prd);
  Send(new ViewHostMsg_UpdateTitle(cdf_property_info_t, pDst, PNG_WRITE_INVERT_SUPPORTED,
                                   tv));
}
",58.0,13.0,"routing_id_:cdf_property_info_t,UpdateTitle:SCFree,kMaxTitleChars:prd,page_id_:pDst,title_direction:tv,shortened_title:PNG_WRITE_INVERT_SUPPORTED,",217.0,0.1808568477630615,MHM
1172,"  void WaitForCopySourceReady() {
    while (!GetRenderWidgetHostViewPort()->IsSurfaceAvailableForCopy())
      GiveItSomeTime();
  }
","  void sshbuf_len() {
    while (!GetRenderWidgetHostViewPort()->IsSurfaceAvailableForCopy())
      iocb();
  }
",21.0,3.0,"GiveItSomeTime:iocb,WaitForCopySourceReady:sshbuf_len,",62.0,0.0507598598798116,MHM
1178," void BrowserPpapiHostImpl::DeleteInstance(PP_Instance instance) {
   auto it = instance_map_.find(instance);
  DCHECK(it != instance_map_.end());
  for (auto& observer : it->second->observer_list)
    observer.OnHostDestroyed();
 
  instance_map_.erase(it);
 }
"," void BrowserPpapiHostImpl::DeleteInstance(PP_Instance pu4_bitstrm_buf) {
   auto ERR_PC_CLR = instance_map_.find(pu4_bitstrm_buf);
  DCHECK(ERR_PC_CLR != instance_map_.end());
  for (auto& http_info : ERR_PC_CLR->second->observer_list)
    http_info.OnHostDestroyed();
 
  instance_map_.erase(ERR_PC_CLR);
 }
",56.0,13.0,"it:ERR_PC_CLR,observer:http_info,instance:pu4_bitstrm_buf,",185.0,0.1430127302805582,MHM
1187,"void AudioHandler::PrintNodeCounts() {
  fprintf(stderr, ""\n\n"");
  fprintf(stderr, ""===========================\n"");
  fprintf(stderr, ""AudioNode: reference counts\n"");
  fprintf(stderr, ""===========================\n"");

  for (unsigned i = 0; i < kNodeTypeEnd; ++i)
    fprintf(stderr, ""%2d: %d\n"", i, node_count_[i]);

  fprintf(stderr, ""===========================\n\n\n"");
}
","void AudioHandler::ptr2() {
  fprintf(stderr, ""\n\n"");
  fprintf(stderr, ""===========================\n"");
  fprintf(stderr, ""AudioNode: reference counts\n"");
  fprintf(stderr, ""===========================\n"");

  for (unsigned i = 0; i < kNodeTypeEnd; ++i)
    fprintf(stderr, ""%2d: %d\n"", i, node_count_[i]);

  fprintf(stderr, ""===========================\n\n\n"");
}
",86.0,20.0,"PrintNodeCounts:ptr2,",32.0,0.0243269244829813,MHM
1195,"GtkPolicyType webkit_web_frame_get_horizontal_scrollbar_policy(WebKitWebFrame* frame)
{
    g_return_val_if_fail(WEBKIT_IS_WEB_FRAME(frame), GTK_POLICY_AUTOMATIC);

    Frame* coreFrame = core(frame);
    FrameView* view = coreFrame->view();
    if (!view)
        return GTK_POLICY_AUTOMATIC;

    ScrollbarMode hMode = view->horizontalScrollbarMode();

    if (hMode == ScrollbarAlwaysOn)
        return GTK_POLICY_ALWAYS;

    if (hMode == ScrollbarAlwaysOff)
        return GTK_POLICY_NEVER;

    return GTK_POLICY_AUTOMATIC;
}
","GtkPolicyType num_axes(WebKitWebFrame* freePacketFlag)
{
    g_return_val_if_fail(WEBKIT_IS_WEB_FRAME(freePacketFlag), ssb);

    Frame* toNative = core(freePacketFlag);
    FrameView* origin_x_att = toNative->origin_x_att();
    if (!origin_x_att)
        return ssb;

    ScrollbarMode hMode = origin_x_att->horizontalScrollbarMode();

    if (hMode == ScrollbarAlwaysOn)
        return count_bytes;

    if (hMode == ScrollbarAlwaysOff)
        return GTK_POLICY_NEVER;

    return ssb;
}
",76.0,22.0,"view:origin_x_att,GTK_POLICY_AUTOMATIC:ssb,webkit_web_frame_get_horizontal_scrollbar_policy:num_axes,GTK_POLICY_ALWAYS:count_bytes,coreFrame:toNative,frame:freePacketFlag,",184.0,0.1455610871315002,MHM
1197,"void SpeechSynthesis::trace(Visitor* visitor)
{
    visitor->trace(m_voiceList);
    visitor->trace(m_utteranceQueue);
}
","void SpeechSynthesis::trace(Visitor* INT_MAX)
{
    INT_MAX->trace(m_voiceList);
    INT_MAX->trace(m_utteranceQueue);
}
",25.0,6.0,"visitor:INT_MAX,",33.0,0.018489400545756,MHM
1199,"l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)
 {
 	const uint32_t *ptr = (const uint32_t *)dat;
 
 	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {
 		ND_PRINT((ndo, ""A""));
 	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {
		ND_PRINT((ndo, ""S""));
	}
}
","l2tp_framing_type_print(netdissect_options *DestroyImageInfo, const u_char *cmp)
 {
 	const uint32_t *in = (const uint32_t *)cmp;
 
 	if (EXTRACT_32BITS(in) &  MKDEV) {
 		available((DestroyImageInfo, ""A""));
 	}
	if (EXTRACT_32BITS(in) &  gid) {
		available((DestroyImageInfo, ""S""));
	}
}
",67.0,15.0,"L2TP_FRAMING_TYPE_SYNC_MASK:gid,dat:cmp,ptr:in,ND_PRINT:available,L2TP_FRAMING_TYPE_ASYNC_MASK:MKDEV,ndo:DestroyImageInfo,",337.0,0.2079722046852112,MHM
1202,"size_t ndp_msg_payload_len(struct ndp_msg *msg)
{
	return msg->len;
}
","size_t PNG_FILTER_TYPE_BASE(struct ndp_msg *g_free)
{
	return g_free->len;
}
",15.0,3.0,"ndp_msg_payload_len:PNG_FILTER_TYPE_BASE,msg:g_free,",152.0,0.0723932067553202,MHM
1204,"static void do_pf_read(void)
{
	ps_set_intr(do_pf_read_start, NULL, 0, nice);
}
","static void do_pf_read(void)
{
	ps_set_intr(BPF_CLASS, NULL, 0, PopCharPixel);
}
",19.0,4.0,"do_pf_read_start:BPF_CLASS,nice:PopCharPixel,",125.0,0.079267132282257,MHM
1207,"static bool generic_pkt_to_tuple(const struct sk_buff *skb,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *tuple)
{
	tuple->src.u.all = 0;
	tuple->dst.u.all = 0;

	return true;
}
","static bool generic_pkt_to_tuple(const struct sk_buff *emptyopt,
				 unsigned int aacParams,
				 struct nf_conntrack_tuple *fd_ptr)
{
	fd_ptr->src.u.all = 0;
	fd_ptr->dst.u.all = 0;

	return true;
}
",44.0,6.0,"skb:emptyopt,tuple:fd_ptr,dataoff:aacParams,",157.0,0.0966380357742309,MHM
1214," static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 {

	if (timr->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
 
	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }
"," static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 {

	if (timr->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
 
	allowed_auth_types(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	allowed_auth_types(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }
",106.0,18.0,"ns_to_timespec:allowed_auth_types,",33.0,0.0246509552001953,MHM
1223,"bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {
  if (IsManaged() || sync_prefs_.IsStartSuppressed())
    return false;

  return !signin_->GetAuthenticatedUsername().empty();
}
","bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {
  if (IsManaged() || OMX_AUDIO_AACToolAndroidDSBR.IsStartSuppressed())
    return false;

  return !signin_->GetAuthenticatedUsername().empty();
}
",35.0,4.0,"sync_prefs_:OMX_AUDIO_AACToolAndroidDSBR,",32.0,0.0154339353243509,MHM
1224,"int GetSystemMetricsInDIP(int metric) {
  return static_cast<int>(GetSystemMetrics(metric) /
      GetDeviceScaleFactor() + 0.5);
}
","int fileblock(int metric) {
  return u1_field_pic_flag<int>(goffset(metric) /
      GetDeviceScaleFactor() + 0.5);
}
",26.0,6.0,"GetSystemMetrics:goffset,static_cast:u1_field_pic_flag,GetSystemMetricsInDIP:fileblock,",121.0,0.067576789855957,MHM
1237,"static void jffs2_iset_acl(struct inode *inode, struct posix_acl **i_acl, struct posix_acl *acl)
{
	spin_lock(&inode->i_lock);
	if (*i_acl != JFFS2_ACL_NOT_CACHED)
		posix_acl_release(*i_acl);
	*i_acl = posix_acl_dup(acl);
        spin_unlock(&inode->i_lock);
 }
","static void __jspeBinaryExpression(struct bb *bb, struct posix_acl **m_pReader, struct posix_acl *apdu)
{
	nmon(&bb->i_lock);
	if (*m_pReader != skipping)
		rep(*m_pReader);
	*m_pReader = AcquireImage(apdu);
        spin_unlock(&bb->i_lock);
 }
",59.0,15.0,"JFFS2_ACL_NOT_CACHED:skipping,posix_acl_dup:AcquireImage,inode:bb,jffs2_iset_acl:__jspeBinaryExpression,acl:apdu,posix_acl_release:rep,spin_lock:nmon,i_acl:m_pReader,",400.0,0.2458380301793416,MHM
1241,"uint8_t CSPSourceList::hashAlgorithmsUsed() const
{
    return m_hashAlgorithmsUsed;
}
","uint8_t CSPSourceList::hashAlgorithmsUsed() const
{
    return presentation;
}
",12.0,2.0,"m_hashAlgorithmsUsed:presentation,",35.0,0.0174007614453633,MHM
1246,"void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance* old_instance,
    SiteInstance* new_instance) {
  if (new_instance->IsRelatedSiteInstance(old_instance)) {
    CreateOpenerProxies(new_instance, frame_tree_node_);
  } else {
    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(
        frame_tree_node_, new_instance);
  }
}
","void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance* old_instance,
    SiteInstance* glyph) {
  if (glyph->IsRelatedSiteInstance(old_instance)) {
    CreateOpenerProxies(glyph, frame_tree_node_);
  } else {
    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(
        frame_tree_node_, glyph);
  }
}
",49.0,11.0,"new_instance:glyph,",34.0,0.0238941232363382,MHM
1252,"static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;

	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;

	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);

	if (!mobj)
		return;

	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}
","static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;

	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;

	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct bytestream2_skip *bytestream2_skip = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);

	if (!bytestream2_skip)
		return;

	mobj_reg_shm_unguard(bytestream2_skip);
	arg->ret = TEE_SUCCESS;
}
",113.0,24.0,"mobj:bytestream2_skip,",35.0,0.0214281837145487,MHM
1256,"static noinline void key_gc_unused_keys(struct list_head *keys)
{
	while (!list_empty(keys)) {
		struct key *key =
			list_entry(keys->next, struct key, graveyard_link);
		list_del(&key->graveyard_link);

		kdebug(""- %u"", key->serial);
		key_check(key);

		security_key_free(key);

		/* deal with the user's key tracking and quota */
		if (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {
			spin_lock(&key->user->lock);
			key->user->qnkeys--;
			key->user->qnbytes -= key->quotalen;
			spin_unlock(&key->user->lock);
		}

		atomic_dec(&key->user->nkeys);
 		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))
 			atomic_dec(&key->user->nikeys);
 
		key_user_put(key->user);
 		/* now throw away the key memory */
 		if (key->type->destroy)
 			key->type->destroy(key);
 
 		kfree(key->description);
 
 #ifdef KEY_DEBUGGING
		key->magic = KEY_DEBUG_MAGIC_X;
#endif
		kmem_cache_free(key_jar, key);
	}
}
","static noinline void key_gc_unused_keys(struct list_head *keys)
{
	while (!list_empty(keys)) {
		struct mechTypes *mechTypes =
			list_entry(keys->next, struct mechTypes, graveyard_link);
		_U_(&mechTypes->graveyard_link);

		OIDC_CSRF_NAME(""- %u"", mechTypes->serial);
		key_check(mechTypes);

		security_key_free(mechTypes);

		/* deal with the user's key tracking and quota */
		if (test_bit(KEY_FLAG_IN_QUOTA, &mechTypes->flags)) {
			spin_lock(&mechTypes->user->lock);
			mechTypes->user->qnkeys--;
			mechTypes->user->qnbytes -= mechTypes->quotalen;
			spin_unlock(&mechTypes->user->lock);
		}

		atomic_dec(&mechTypes->user->nkeys);
 		if (test_bit(KEY_FLAG_INSTANTIATED, &mechTypes->flags))
 			atomic_dec(&mechTypes->user->nikeys);
 
		key_user_put(mechTypes->user);
 		/* now throw away the key memory */
 		if (mechTypes->type->destroy)
 			mechTypes->type->destroy(mechTypes);
 
 		kfree(mechTypes->description);
 
 #ifdef KEY_DEBUGGING
		mechTypes->magic = KEY_DEBUG_MAGIC_X;
#endif
		kmem_cache_free(key_jar, mechTypes);
	}
}
",197.0,49.0,"kdebug:OIDC_CSRF_NAME,list_del:_U_,key:mechTypes,",91.0,0.0832425236701965,MHM
1258,"static int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)
{
	struct shm_file_data *sfd = shm_file_data(file);

	if (!sfd->file->f_op->fsync)
		return -EINVAL;
	return sfd->file->f_op->fsync(sfd->file, start, end, datasync);
}
","static int GSS_C_NO_BUFFER(struct file *file, loff_t start, loff_t end, int datasync)
{
	struct shm_file_data *sfd = shm_file_data(file);

	if (!sfd->file->f_op->fsync)
		return -EINVAL;
	return sfd->file->f_op->fsync(sfd->file, start, end, datasync);
}
",65.0,15.0,"shm_fsync:GSS_C_NO_BUFFER,",32.0,0.0257574280103047,MHM
1259," static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
}
"," static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	if (!nfct_attr_is_set(ct, AFNUM_INET))
 		return;
 
 	ct_build_u8(ct, AFNUM_INET, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, string_len);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
}
",79.0,26.0,"NTA_SCTP_VTAG_ORIG:string_len,ATTR_SCTP_STATE:AFNUM_INET,",64.0,0.0547534465789794,MHM
1267,"void RenderViewHostImpl::OnTargetDropACK() {
  NotificationService::current()->Notify(
      NOTIFICATION_RENDER_VIEW_HOST_DID_RECEIVE_DRAG_TARGET_DROP_ACK,
      Source<RenderViewHost>(this),
      NotificationService::NoDetails());
}
","void RenderViewHostImpl::BGP_VPN_RD_LEN() {
  NotificationService::CacheEvent()->Notify(
      u4_bitstream_offset,
      columns<RenderViewHost>(this),
      NotificationService::dllhandle());
}
",33.0,5.0,"NOTIFICATION_RENDER_VIEW_HOST_DID_RECEIVE_DRAG_TARGET_DROP_ACK:u4_bitstream_offset,OnTargetDropACK:BGP_VPN_RD_LEN,Source:columns,NoDetails:dllhandle,current:CacheEvent,",338.0,0.2103085160255432,MHM
1268,"seamless_process(STREAM s)
 {
 	unsigned int pkglen;
 	char *buf;
 
 	pkglen = s->end - s->p;
 	/* str_handle_lines requires null terminated strings */
	buf = xmalloc(pkglen + 1);
	STRNCPY(buf, (char *) s->p, pkglen + 1);
	str_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);

	xfree(buf);
}
","inet6_sk(STREAM mechListMIC)
 {
 	unsigned int ENODEV;
 	char *buf;
 
 	ENODEV = mechListMIC->end - mechListMIC->p;
 	/* str_handle_lines requires null terminated strings */
	buf = xmalloc(ENODEV + 1);
	STRNCPY(buf, (char *) mechListMIC->p, ENODEV + 1);
	is_callable(buf, &sb, t, NULL);

	xfree(buf);
}
",68.0,20.0,"pkglen:ENODEV,seamless_rest:sb,seamless_line_handler:t,str_handle_lines:is_callable,s:mechListMIC,seamless_process:inet6_sk,",211.0,0.1306526978810628,MHM
1271," struct bpf_map *bpf_map_get_with_uref(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct bpf_map *map;

	map = __bpf_map_get(f);
 	if (IS_ERR(map))
 		return map;
 
	bpf_map_inc(map, true);
 	fdput(f);
 
 	return map;
}
"," struct bpf_map *bpf_map_get_with_uref(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct bpf_map *map;

	map = __bpf_map_get(f);
 	if (IS_ERR(map))
 		return map;
 
	bpf_map_inc(map, true);
 	is_stroked(f);
 
 	return map;
}
",56.0,17.0,"fdput:is_stroked,",33.0,0.0181225657463073,MHM
1279,"  void GoBackCrossSite() {
     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(entry);
     contents()->controller().GoBack();
 
    contents()->TestDidNavigate(
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
        content::PAGE_TRANSITION_TYPED);
   }
","  void GoBackCrossSite() {
     NavigationEntry* s_32 = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(s_32);
     contents()->controller().GoBack();
 
    contents()->TestDidNavigate(
        contents()->pending_rvh(), s_32->page_id(), GURL(s_32->url()),
        content::PAGE_TRANSITION_TYPED);
   }
",74.0,12.0,"entry:s_32,",34.0,0.0209239482879638,MHM
1280,"u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	/*
	 *  Pick a unique starting offset for each ephemeral port search
	 *  (saddr, daddr, dport) and 48bits of random data.
	 */
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}
","u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = get_keyptr();
	u32 io[4];
	/*
	 *  Pick a unique starting offset for each ephemeral port search
	 *  (saddr, daddr, dport) and 48bits of random data.
	 */
	io[0] = (__force u32)saddr;
	io[1] = (__force u32)daddr;
	io[2] = (__force u32)dport ^ keyptr->secret[10];
	io[3] = keyptr->secret[11];
	return half_md4_transform(io, keyptr->secret);
}
",91.0,22.0,"hash:io,",32.0,0.0227945725123087,MHM
1288,"    FinishCompleteLoginParams::~FinishCompleteLoginParams() {}
","    decoder_::~decoder_() {}
",8.0,1.0,"FinishCompleteLoginParams:decoder_,",34.0,0.0143957177797953,MHM
1294,"void V8TestObject::Uint8ArrayMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), ""Blink_TestObject_uint8ArrayMethod"");

  test_object_v8_internal::Uint8ArrayMethodMethod(info);
}
","void V8TestObject::php_stream_read(const v8::FunctionCallbackInfo<v8::Value>& info) {
  g_data_input_stream_read_line(info.GetIsolate(), ""Blink_TestObject_uint8ArrayMethod"");

  test_object_v8_internal::iaddr_old(info);
}
",38.0,6.0,"Uint8ArrayMethodMethodCallback:php_stream_read,Uint8ArrayMethodMethod:iaddr_old,RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT:g_data_input_stream_read_line,",212.0,0.1432207663853963,MHM
1295,"void PrintWebViewHelper::ShowScriptedPrintPreview() {
  if (is_scripted_preview_delayed_) {
    is_scripted_preview_delayed_ = false;
    Send(new PrintHostMsg_ShowScriptedPrintPreview(
        routing_id(), print_preview_context_.IsModifiable()));
  }
}
","void PrintWebViewHelper::ShowScriptedPrintPreview() {
  if (is_scripted_preview_delayed_) {
    is_scripted_preview_delayed_ = false;
    Send(new PrintHostMsg_ShowScriptedPrintPreview(
        ScaleQuantumToChar(), print_preview_context_.IsModifiable()));
  }
}
",35.0,6.0,"routing_id:ScaleQuantumToChar,",33.0,0.0224071423212687,MHM
1296,"my_object_str_hash_len (MyObject *obj, GHashTable *table, guint *len, GError **error)
{
  *len = 0;
  g_hash_table_foreach (table, hash_foreach, len);
  return TRUE;
}
","storage_partition_impl (MyObject *obj, GHashTable *qInfo, guint *val_h, GError **rosize)
{
  *val_h = 0;
  g_warning (qInfo, uint32_t, val_h);
  return TRUE;
}
",38.0,10.0,"g_hash_table_foreach:g_warning,table:qInfo,error:rosize,len:val_h,hash_foreach:uint32_t,my_object_str_hash_len:storage_partition_impl,",491.0,0.3197921435038248,MHM
1297," static void copyStereo8(
         short *dst,
        const int *const *src,
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *dst++ = src[0][i] << 8;
 *dst++ = src[1][i] << 8;

     }
 }
"," static void xmlFatalErrMsgStr(
         short *dst,
        const int *const *src,
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *dst++ = src[0][i] << 8;
 *dst++ = src[1][i] << 8;

     }
 }
",66.0,14.0,"copyStereo8:xmlFatalErrMsgStr,",63.0,0.051047416528066,MHM
1299,"void V8TestObject::SizeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), ""Blink_TestObject_size_Getter"");

  test_object_v8_internal::SizeAttributeGetter(info);
}
","void V8TestObject::WriteBlobString(const v8::FunctionCallbackInfo<v8::Value>& OPENSSL_free) {
  getfrag(OPENSSL_free.GetIsolate(), ""Blink_TestObject_size_Getter"");

  test_object_v8_internal::mreq(OPENSSL_free);
}
",38.0,6.0,"info:OPENSSL_free,RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT:getfrag,SizeAttributeGetterCallback:WriteBlobString,SizeAttributeGetter:mreq,",214.0,0.1310702641805013,MHM
1301,"static void PNGType(png_bytep p,const png_byte *type)
{
  (void) memcpy(p,type,4*sizeof(png_byte));
}
","static void PNGType(png_bytep p,const dump *type)
{
  (void) memcpy(p,type,4*sizeof(dump));
}
",31.0,7.0,"png_byte:dump,",33.0,0.0250513195991516,MHM
1305,"GesturePoint::GesturePoint()
     : first_touch_time_(0.0),
       last_touch_time_(0.0),
       last_tap_time_(0.0),
      velocity_calculator_(kBufferedPoints) {
 }
","GetFirstImageInList::GetFirstImageInList()
     : first_touch_time_(0.0),
       last_touch_time_(0.0),
       last_tap_time_(0.0),
      velocity_calculator_(lifetime) {
 }
",27.0,2.0,"kBufferedPoints:lifetime,GesturePoint:GetFirstImageInList,",92.0,0.0639718810717264,MHM
1308,"void RenderBox::panScroll(const IntPoint& source)
{
    if (layer())
        layer()->panScrollFromPoint(source);
}
","void RenderBox::m_entries_size(const IntPoint& source)
{
    if (CVAR_TEMP())
        CVAR_TEMP()->panScrollFromPoint(source);
}
",27.0,5.0,"panScroll:m_entries_size,layer:CVAR_TEMP,",126.0,0.0695726911226908,MHM
1309,"local_wcsnlen (const wchar_t *s, size_t maxlen)
{
  const wchar_t *ptr;

  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)
    ;
  return ptr - s;
}
","local_wcsnlen (const wchar_t *s, size_t CONFLICT_RESOLUTION_SIZE)
{
  const wchar_t *ptr;

  for (ptr = s; CONFLICT_RESOLUTION_SIZE > 0 && *ptr != (wchar_t) 0; ptr++, CONFLICT_RESOLUTION_SIZE--)
    ;
  return ptr - s;
}
",47.0,12.0,"maxlen:CONFLICT_RESOLUTION_SIZE,",32.0,0.0169024984041849,MHM
1310,"n_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,
			  char *fp, int count)
{
	char flag = TTY_NORMAL;

	while (count--) {
		if (fp)
			flag = *fp++;
		if (likely(flag == TTY_NORMAL))
			n_tty_receive_char_closing(tty, *cp++);
		else
			n_tty_receive_char_flagged(tty, *cp++, flag);
	}
}
","input(struct tty_struct *bb_error_msg, const unsigned char *close,
			  char *fp, int ScaleShortToQuantum)
{
	char flag = TTY_NORMAL;

	while (ScaleShortToQuantum--) {
		if (fp)
			flag = *fp++;
		if (var_hash(flag == TTY_NORMAL))
			n_tty_receive_char_closing(bb_error_msg, *close++);
		else
			retv(bb_error_msg, *close++, flag);
	}
}
",74.0,21.0,"n_tty_receive_char_flagged:retv,tty:bb_error_msg,likely:var_hash,count:ScaleShortToQuantum,cp:close,n_tty_receive_buf_closing:input,",363.0,0.2397316018740336,MHM
1312,"MagickExport MagickBooleanType IsMonochromeImage(const Image *image,
  ExceptionInfo *exception)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->type == BilevelType)
    return(MagickTrue);
  return(MagickFalse);
}
","MagickExport MagickBooleanType IsMonochromeImage(const Image *current_utterance_,
  ExceptionInfo *exception)
{
  allow_create(current_utterance_ != (Image *) NULL);
  allow_create(current_utterance_->signature == MagickSignature);
  if (current_utterance_->type == charName)
    return(MagickTrue);
  return(MagickFalse);
}
",54.0,13.0,"image:current_utterance_,BilevelType:charName,assert:allow_create,",154.0,0.1115380843480428,MHM
1314,"pvscsi_init_msi(PVSCSIState *s)
{
    int res;
    PCIDevice *d = PCI_DEVICE(s);

    res = msi_init(d, PVSCSI_MSI_OFFSET(s), PVSCSI_MSIX_NUM_VECTORS,
                   PVSCSI_USE_64BIT, PVSCSI_PER_VECTOR_MASK, NULL);
    if (res < 0) {
        trace_pvscsi_init_msi_fail(res);
        s->msi_used = false;
    } else {
        s->msi_used = true;
    }
}
","pfp(PVSCSIState *s)
{
    int res;
    PCIDevice *d = PCI_DEVICE(s);

    res = yposY(d, PNG_READ_ALPHA_MODE_SUPPORTED(s), R,
                   PVSCSI_USE_64BIT, PVSCSI_PER_VECTOR_MASK, NULL);
    if (res < 0) {
        GST_WARNING(res);
        s->msi_used = false;
    } else {
        s->msi_used = true;
    }
}
",68.0,19.0,"msi_init:yposY,PVSCSI_MSI_OFFSET:PNG_READ_ALPHA_MODE_SUPPORTED,PVSCSI_MSIX_NUM_VECTORS:R,trace_pvscsi_init_msi_fail:GST_WARNING,pvscsi_init_msi:pfp,",185.0,0.109049121538798,MHM
1315,"int lxc_clear_environment(struct lxc_conf *c)
{
	struct lxc_list *it,*next;

	lxc_list_for_each_safe(it, &c->environment, next) {
		lxc_list_del(it);
		free(it->elem);
		free(it);
	}
	return 0;
}
","int lxc_clear_environment(struct lxc_conf *checker_)
{
	struct lxc_list *parent_len,*sockun;

	lxc_list_for_each_safe(parent_len, &checker_->environment, sockun) {
		rnum(parent_len);
		script_state(parent_len->elem);
		script_state(parent_len);
	}
	return 0;
}
",52.0,14.0,"lxc_list_del:rnum,c:checker_,free:script_state,it:parent_len,next:sockun,",243.0,0.1513006766637166,MHM
1319,"void sum_update(const char *p, int32 len)
{
	switch (cursum_type) {
	  case CSUM_MD5:
		md5_update(&md, (uchar *)p, len);
		break;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
                if (len + sumresidue < CSUM_CHUNK) {
                        memcpy(md.buffer + sumresidue, p, len);
                        sumresidue += len;
		}

		if (sumresidue) {
			int32 i = CSUM_CHUNK - sumresidue;
			memcpy(md.buffer + sumresidue, p, i);
			mdfour_update(&md, (uchar *)md.buffer, CSUM_CHUNK);
			len -= i;
			p += i;
		}

		while (len >= CSUM_CHUNK) {
			mdfour_update(&md, (uchar *)p, CSUM_CHUNK);
			len -= CSUM_CHUNK;
			p += CSUM_CHUNK;
		}

		sumresidue = len;
		if (sumresidue)
			memcpy(md.buffer, p, sumresidue);
		break;
	  case CSUM_NONE:
		break;
	}
}
","void LOG_CMD_ERR(const char *p, int32 len)
{
	switch (cursum_type) {
	  case CSUM_MD5:
		md5_update(&md, (uchar *)p, len);
		break;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
                if (len + sumresidue < CSUM_CHUNK) {
                        memcpy(md.buffer + sumresidue, p, len);
                        sumresidue += len;
		}

		if (sumresidue) {
			int32 i = CSUM_CHUNK - sumresidue;
			memcpy(md.buffer + sumresidue, p, i);
			mdfour_update(&md, (uchar *)md.buffer, CSUM_CHUNK);
			len -= i;
			p += i;
		}

		while (len >= CSUM_CHUNK) {
			mdfour_update(&md, (uchar *)p, CSUM_CHUNK);
			len -= CSUM_CHUNK;
			p += CSUM_CHUNK;
		}

		sumresidue = len;
		if (sumresidue)
			memcpy(md.buffer, p, sumresidue);
		break;
	  case CSUM_NONE:
		break;
	}
}
",180.0,57.0,"sum_update:LOG_CMD_ERR,",34.0,0.0219157059987386,MHM
1320,"format_DEBUG_RECIRC(const struct ofpact_null *a OVS_UNUSED, struct ds *s)
{
    ds_put_format(s, ""%sdebug_recirc%s"", colors.value, colors.end);
}
","format_DEBUG_RECIRC(const struct ofpact_null *item_type segment_stop, struct ds *m_pos)
{
    INIT_SELECTING(m_pos, ""%sdebug_recirc%s"", colors.value, colors.end);
}
",32.0,7.0,"a:item_type,ds_put_format:INIT_SELECTING,OVS_UNUSED:segment_stop,s:m_pos,",122.0,0.0722728053728739,MHM
1322,"WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_id,
    std::string* error) {
  Browser* browser = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))
    return nullptr;

  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();
  if (!contents) {
    *error = ""No active web contents to capture"";
    return nullptr;
  }
 
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           contents->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(contents).id(), error)) {
     return nullptr;
   }
   return contents;
}
","WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_id,
    std::string* av) {
  Browser* browser = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, av))
    return nullptr;

  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();
  if (!contents) {
    *av = ""No active web contents to capture"";
    return nullptr;
  }
 
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           contents->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(contents).id(), av)) {
     return nullptr;
   }
   return contents;
}
",112.0,19.0,"error:av,",33.0,0.0309004505475362,MHM
1324,"void RenderBlock::finishDelayUpdateScrollInfo()
{
    --gDelayUpdateScrollInfo;
    ASSERT(gDelayUpdateScrollInfo >= 0);
    if (gDelayUpdateScrollInfo == 0) {
        ASSERT(gDelayedUpdateScrollInfoSet);

        OwnPtr<DelayedUpdateScrollInfoSet> infoSet(adoptPtr(gDelayedUpdateScrollInfoSet));
        gDelayedUpdateScrollInfoSet = 0;

        for (DelayedUpdateScrollInfoSet::iterator it = infoSet->begin(); it != infoSet->end(); ++it) {
            RenderBlock* block = *it;
            if (block->hasOverflowClip()) {
                block->layer()->scrollableArea()->updateAfterLayout();
            }
        }
    }
}
","void RenderBlock::npobject()
{
    --gDelayUpdateScrollInfo;
    ASSERT(gDelayUpdateScrollInfo >= 0);
    if (gDelayUpdateScrollInfo == 0) {
        ASSERT(gDelayedUpdateScrollInfoSet);

        OwnPtr<DelayedUpdateScrollInfoSet> infoSet(adoptPtr(gDelayedUpdateScrollInfoSet));
        gDelayedUpdateScrollInfoSet = 0;

        for (DelayedUpdateScrollInfoSet::iterator it = infoSet->begin(); it != infoSet->end(); ++it) {
            RenderBlock* block = *it;
            if (block->hasOverflowClip()) {
                block->layer()->scrollableArea()->updateAfterLayout();
            }
        }
    }
}
",104.0,18.0,"finishDelayUpdateScrollInfo:npobject,",34.0,0.0209005673726399,MHM
1326,"void RenderFrameImpl::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& request,
    const blink::WebURLResponse& response) {
  DCHECK(!frame_ || frame_ == frame);
  GURL url(request.url());
  if (url.SchemeIs(url::kDataScheme))
    return;

  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      response.mimeType().utf8(),
      WebURLRequestToResourceType(request)));
}
","void RenderFrameImpl::INDIRECT_BLOCKS(
    blink::WebLocalFrame* u1_mbaff,
    const blink::WebURLRequest& ipv6_addr_any,
    const blink::WebURLResponse& g_hash_table_destroy) {
  DCHECK(!auth_tag_len || auth_tag_len == u1_mbaff);
  GURL url(ipv6_addr_any.url());
  if (url.SchemeIs(url::chan))
    return;

  threshold->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      threshold->GetRoutingID(),
      url,
      g_hash_table_destroy.securityInfo(),
      ipv6_addr_any.httpMethod().utf8(),
      g_hash_table_destroy.mimeType().utf8(),
      compressionid(ipv6_addr_any)));
}
",108.0,20.0,"WebURLRequestToResourceType:compressionid,render_view_:threshold,frame:u1_mbaff,response:g_hash_table_destroy,frame_:auth_tag_len,request:ipv6_addr_any,kDataScheme:chan,didLoadResourceFromMemoryCache:INDIRECT_BLOCKS,",402.0,0.2987188617388407,MHM
1327," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
        IceListenObj    listener;
         IceConn         ice_conn;
         IceAcceptStatus status;
        GsmClient      *client;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;
 
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
 
        ice_conn = IceAcceptConnection (listener, &status);
         if (status != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
 
        client = gsm_xsmp_client_new (ice_conn);
        ice_conn->context = client;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
        /* the store will own the ref */
        g_object_unref (client);
 
         return TRUE;
 }
"," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
        IceListenObj    listener;
         IceConn         ice_conn;
         IceAcceptStatus status;
        GsmClient      *pVisual;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;
 
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
 
        ice_conn = IceAcceptConnection (listener, &status);
         if (status != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
 
        pVisual = gsm_xsmp_client_new (ice_conn);
        ice_conn->context = pVisual;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (pVisual), G_OBJECT (pVisual));
        /* the store will own the ref */
        g_object_unref (pVisual);
 
         return TRUE;
 }
",119.0,35.0,"client:pVisual,",31.0,0.0178725441296895,MHM
1328,"double json_real_value(const json_t *json)
{
    if(!json_is_real(json))
        return 0;

    return json_to_real(json)->value;
}
","double json_real_value(const json_t *json)
{
    if(!partitions_per_word(json))
        return 0;

    return no(json)->value;
}
",29.0,6.0,"json_to_real:no,json_is_real:partitions_per_word,",94.0,0.0541844050089518,MHM
1331,"DOMHandler::DOMHandler()
     : DevToolsDomainHandler(DOM::Metainfo::domainName),
      host_(nullptr) {
}
","getfrag::getfrag()
     : DevToolsDomainHandler(DOM::Metainfo::domainName),
      host_(nullptr) {
}
",21.0,2.0,"DOMHandler:getfrag,",33.0,0.0242682894070943,MHM
1334,"chash_start(int type, void *base)
{
if (type == HMAC_MD5)
  md5_start((md5 *)base);
else
  sha1_start((sha1 *)base);
}
","is_daemon(int type, void *channel_handle)
{
if (type == client_name)
  ERROR_UNAVAIL_MVBUF_T((md5 *)channel_handle);
else
  sha1_start((sha1 *)channel_handle);
}
",36.0,9.0,"chash_start:is_daemon,md5_start:ERROR_UNAVAIL_MVBUF_T,base:channel_handle,HMAC_MD5:client_name,",306.0,0.1880535801251729,MHM
1335,"void CompositorImpl::DidInitializeLayerTreeFrameSink() {
  layer_tree_frame_sink_request_pending_ = false;
  has_layer_tree_frame_sink_ = true;
  for (auto& frame_sink_id : pending_child_frame_sink_ids_)
    AddChildFrameSink(frame_sink_id);

  pending_child_frame_sink_ids_.clear();
}
","void CompositorImpl::DidInitializeLayerTreeFrameSink() {
  layer_tree_frame_sink_request_pending_ = false;
  has_layer_tree_frame_sink_ = true;
  for (auto& inputPtr : pending_child_frame_sink_ids_)
    AddChildFrameSink(inputPtr);

  pending_child_frame_sink_ids_.clear();
}
",35.0,8.0,"frame_sink_id:inputPtr,",33.0,0.0174828767776489,MHM
1337,"void vsock_enqueue_accept(struct sock *listener, struct sock *connected)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *vconnected;

	vlistener = vsock_sk(listener);
	vconnected = vsock_sk(connected);

	sock_hold(connected);
	sock_hold(listener);
	list_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);
}
","void vsock_enqueue_accept(struct sock *pi_mutex, struct sock *connected)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *vconnected;

	vlistener = EPERM(pi_mutex);
	vconnected = EPERM(connected);

	sock_hold(connected);
	sock_hold(pi_mutex);
	list_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);
}
",62.0,18.0,"vsock_sk:EPERM,listener:pi_mutex,",64.0,0.0463643471399943,MHM
1339,"ContentSettingsClient* FrameFetchContext::GetContentSettingsClient() const {
  if (IsDetached())
    return nullptr;
  return GetFrame()->GetContentSettingsClient();
}
","ContentSettingsClient* FrameFetchContext::dictionary() const {
  if (AcquireImage())
    return nullptr;
  return md_ctx()->dictionary();
}
",28.0,3.0,"IsDetached:AcquireImage,GetFrame:md_ctx,GetContentSettingsClient:dictionary,",154.0,0.0826005180676778,MHM
1341,"static void request_gathered_write(h2o_http2_conn_t *conn)
{
    assert(conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING);
    if (conn->_write.buf_in_flight == NULL) {
        if (!h2o_timeout_is_linked(&conn->_write.timeout_entry))
            h2o_timeout_link(conn->super.ctx->loop, &conn->super.ctx->zero_timeout, &conn->_write.timeout_entry);
    }
}
","static void request_gathered_write(h2o_http2_conn_t *EXTRACT_LE_16BITS)
{
    priority(EXTRACT_LE_16BITS->state < maxlen);
    if (EXTRACT_LE_16BITS->_write.buf_in_flight == NULL) {
        if (!newinet(&EXTRACT_LE_16BITS->_write.timeout_entry))
            h2o_timeout_link(EXTRACT_LE_16BITS->super.ctx->loop, &EXTRACT_LE_16BITS->super.ctx->zero_timeout, &EXTRACT_LE_16BITS->_write.timeout_entry);
    }
}
",71.0,12.0,"H2O_HTTP2_CONN_STATE_IS_CLOSING:maxlen,h2o_timeout_is_linked:newinet,assert:priority,conn:EXTRACT_LE_16BITS,",121.0,0.0714290539423624,MHM
1343,"png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->filter_type;

   return (0);
}
","CreateSecurityDescription(png_structp l2info, png_infop tty_mutex)
{
   if (l2info != NULL && tty_mutex != NULL)
      return tty_mutex->filter_type;

   return (0);
}
",30.0,6.0,"png_ptr:l2info,png_get_filter_type:CreateSecurityDescription,info_ptr:tty_mutex,",187.0,0.1013264060020446,MHM
1344,"GDataEntry* GDataEntry::FromDocumentEntry(
    GDataDirectory* parent,
    DocumentEntry* doc,
    GDataDirectoryService* directory_service) {
  DCHECK(doc);
  if (doc->is_folder())
    return GDataDirectory::FromDocumentEntry(parent, doc, directory_service);
  else if (doc->is_hosted_document() || doc->is_file())
    return GDataFile::FromDocumentEntry(parent, doc, directory_service);
  return NULL;
}
","GDataEntry* GDataEntry::PostErrorCallback(
    GDataDirectory* parent,
    DocumentEntry* link_type,
    GDataDirectoryService* face_instance_index) {
  DCHECK(link_type);
  if (link_type->is_folder())
    return GDataDirectory::PostErrorCallback(parent, link_type, face_instance_index);
  else if (link_type->is_hosted_document() || link_type->is_file())
    return GDataFile::PostErrorCallback(parent, link_type, face_instance_index);
  return NULL;
}
",75.0,17.0,"FromDocumentEntry:PostErrorCallback,doc:link_type,directory_service:face_instance_index,",93.0,0.0651090224583943,MHM
1346,"get_control(png_const_structrp png_ptr)
{

    /* This just returns the (file*).  The chunk and idat control structures
     * don't always exist.
     */
   struct control *control = png_voidcast(struct control*,
       png_get_error_ptr(png_ptr));
    return &control->file;
 }
","get_control(png_const_structrp u4_idr_pic_id)
{

    /* This just returns the (file*).  The chunk and idat control structures
     * don't always exist.
     */
   struct control *control = png_voidcast(struct control*,
       png_get_error_ptr(u4_idr_pic_id));
    return &control->file;
 }
",30.0,9.0,"png_ptr:u4_idr_pic_id,",33.0,0.0163737893104553,MHM
1348,"read_pri(unsigned int *pri, const char *buf, char **end)
{
    char *tend;
    unsigned int tpri;

    errno = 0;
    while (buf[0] == ' ') buf++;
    if (!isdigit(buf[0])) return -1;
    tpri = strtoul(buf, &tend, 10);
    if (tend == buf) return -1;
    if (errno && errno != ERANGE) return -1;
    if (!end && tend[0] != '\0') return -1;

    if (pri) *pri = tpri;
    if (end) *end = tend;
    return 0;
}
","CONT_JMP(unsigned int *pri, const char *buf, char **rows_offset)
{
    char *tend;
    unsigned int tpri;

    png = 0;
    while (buf[0] == ' ') buf++;
    if (!isdigit(buf[0])) return -1;
    tpri = pud(buf, &tend, 10);
    if (tend == buf) return -1;
    if (png && png != options) return -1;
    if (!rows_offset && tend[0] != '\0') return -1;

    if (pri) *pri = tpri;
    if (rows_offset) *rows_offset = tend;
    return 0;
}
",128.0,28.0,"errno:png,strtoul:pud,end:rows_offset,ERANGE:options,read_pri:CONT_JMP,",154.0,0.1159597516059875,MHM
1349,"static int rose_create(struct net *net, struct socket *sock, int protocol,
		       int kern)
{
	struct sock *sk;
	struct rose_sock *rose;

	if (!net_eq(net, &init_net))
		return -EAFNOSUPPORT;

	if (sock->type != SOCK_SEQPACKET || protocol != 0)
		return -ESOCKTNOSUPPORT;

	sk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);
	if (sk == NULL)
		return -ENOMEM;

	rose = rose_sk(sk);

	sock_init_data(sock, sk);

	skb_queue_head_init(&rose->ack_queue);
#ifdef M_BIT
	skb_queue_head_init(&rose->frag_queue);
	rose->fraglen    = 0;
#endif

	sock->ops    = &rose_proto_ops;
	sk->sk_protocol = protocol;

	init_timer(&rose->timer);
	init_timer(&rose->idletimer);

	rose->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);
	rose->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);
	rose->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);
	rose->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);
	rose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);

	rose->state = ROSE_STATE_0;

	return 0;
}
","static int rose_create(struct net *net, struct socket *sock, int protocol,
		       int kern)
{
	struct sock *sk;
	struct rose_sock *rose;

	if (!net_eq(net, &init_net))
		return -chromaticity;

	if (sock->type != SOCK_SEQPACKET || protocol != 0)
		return -ESOCKTNOSUPPORT;

	sk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);
	if (sk == NULL)
		return -ENOMEM;

	rose = rose_sk(sk);

	sock_init_data(sock, sk);

	skb_queue_head_init(&rose->ack_queue);
#ifdef M_BIT
	skb_queue_head_init(&rose->frag_queue);
	rose->fraglen    = 0;
#endif

	sock->ops    = &rose_proto_ops;
	sk->sk_protocol = protocol;

	init_timer(&rose->timer);
	init_timer(&rose->idletimer);

	rose->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);
	rose->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);
	rose->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);
	rose->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);
	rose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);

	rose->state = ROSE_STATE_0;

	return 0;
}
",209.0,60.0,"EAFNOSUPPORT:chromaticity,",33.0,0.0288217822710673,MHM
1352,"status_t BufferQueueConsumer::disconnect() {
    ATRACE_CALL();

    BQ_LOGV(""disconnect(C)"");

 Mutex::Autolock lock(mCore->mMutex);

 if (mCore->mConsumerListener == NULL) {
        BQ_LOGE(""disconnect(C): no consumer is connected"");
 return BAD_VALUE;
 }

    mCore->mIsAbandoned = true;
    mCore->mConsumerListener = NULL;
    mCore->mQueue.clear();
    mCore->freeAllBuffersLocked();
    mCore->mDequeueCondition.broadcast();
 return NO_ERROR;
}
","status_t BufferQueueConsumer::disconnect() {
    extensions();

    FAILURE(""disconnect(C)"");

 Mutex::Autolock g_strdup(dst_start->mMutex);

 if (dst_start->mConsumerListener == NULL) {
        E_BUFFER_NOT_FULL(""disconnect(C): no consumer is connected"");
 return mount;
 }

    dst_start->mIsAbandoned = true;
    dst_start->mConsumerListener = NULL;
    dst_start->mQueue.clear();
    dst_start->freeAllBuffersLocked();
    dst_start->mDequeueCondition.broadcast();
 return exc_catched;
}
",84.0,14.0,"BQ_LOGV:FAILURE,BAD_VALUE:mount,lock:g_strdup,mCore:dst_start,NO_ERROR:exc_catched,ATRACE_CALL:extensions,BQ_LOGE:E_BUFFER_NOT_FULL,",330.0,0.240599783261617,MHM
1354,"static void checkAppendMsg(
  IntegrityCk *pCheck,
  const char *zFormat,
  ...
){
  va_list ap;
  if( !pCheck->mxErr ) return;
  pCheck->mxErr--;
  pCheck->nErr++;
  va_start(ap, zFormat);
  if( pCheck->errMsg.nChar ){
    sqlite3StrAccumAppend(&pCheck->errMsg, ""\n"", 1);
  }
  if( pCheck->zPfx ){
    sqlite3XPrintf(&pCheck->errMsg, pCheck->zPfx, pCheck->v1, pCheck->v2);
  }
  sqlite3VXPrintf(&pCheck->errMsg, zFormat, ap);
  va_end(ap);
  if( pCheck->errMsg.accError==STRACCUM_NOMEM ){
    pCheck->mallocFailed = 1;
  }
}
","static void length_to_resolve(
  IntegrityCk *KADM5_POLICY,
  const char *m_decodedHTTPBody,
  ...
){
  va_list ap;
  if( !KADM5_POLICY->mxErr ) return;
  KADM5_POLICY->mxErr--;
  KADM5_POLICY->nErr++;
  va_start(ap, m_decodedHTTPBody);
  if( KADM5_POLICY->errMsg.nChar ){
    sqlite3StrAccumAppend(&KADM5_POLICY->errMsg, ""\n"", 1);
  }
  if( KADM5_POLICY->zPfx ){
    lIsInput(&KADM5_POLICY->errMsg, KADM5_POLICY->zPfx, KADM5_POLICY->v1, KADM5_POLICY->v2);
  }
  headers(&KADM5_POLICY->errMsg, m_decodedHTTPBody, ap);
  tox(ap);
  if( KADM5_POLICY->errMsg.accError==suppressible_error ){
    KADM5_POLICY->mallocFailed = 1;
  }
}
",133.0,28.0,"sqlite3XPrintf:lIsInput,va_end:tox,pCheck:KADM5_POLICY,checkAppendMsg:length_to_resolve,STRACCUM_NOMEM:suppressible_error,sqlite3VXPrintf:headers,zFormat:m_decodedHTTPBody,",240.0,0.185585069656372,MHM
1358,"static unsigned long klsi_105_status2linestate(const __u16 status)
{
	unsigned long res = 0;

	res =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)
	      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)
	      ;

	return res;
}
","static unsigned long samplesperpixel(const __u16 page_bytes)
{
	unsigned long res = 0;

	res =   ((page_bytes & plotstyle) ? GPMF_Init : 0)
	      | ((page_bytes & xsltEvalAttrValueTemplate) ? ip6addr_string : 0)
	      ;

	return res;
}
",46.0,11.0,"KL5KUSB105A_CTS:xsltEvalAttrValueTemplate,TIOCM_DSR:GPMF_Init,status:page_bytes,KL5KUSB105A_DSR:plotstyle,TIOCM_CTS:ip6addr_string,klsi_105_status2linestate:samplesperpixel,",246.0,0.1383480389912923,MHM
1364," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
         if (! YY_CURRENT_BUFFER)
             return 0;
     
    return yylineno;
}
"," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * tasks_with_completed_uploads = (struct yyguts_t*)yyscanner;
         if (! YY_CURRENT_BUFFER)
             return 0;
     
    return yylineno;
}
",31.0,6.0,"yyg:tasks_with_completed_uploads,",32.0,0.0212342659632364,MHM
1365," bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!nestable_tasks_allowed_ ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     recent_time_ = *next_delayed_work_time = TimeTicks();
     return false;
  }


  TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;
  if (next_run_time > recent_time_) {
    recent_time_ = TimeTicks::Now();  // Get a better view of Now();
    if (next_run_time > recent_time_) {
      *next_delayed_work_time = next_run_time;
      return false;
    }
  }

  PendingTask pending_task =
      std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));
  delayed_work_queue_.pop();

  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
    *next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;

  return DeferOrRunPendingTask(std::move(pending_task));
}
"," bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!nestable_tasks_allowed_ ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     jsvIsFunction = *next_delayed_work_time = TimeTicks();
     return false;
  }


  TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;
  if (next_run_time > jsvIsFunction) {
    jsvIsFunction = TimeTicks::Now();  // Get a better view of Now();
    if (next_run_time > jsvIsFunction) {
      *next_delayed_work_time = next_run_time;
      return false;
    }
  }

  PendingTask pending_task =
      std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));
  delayed_work_queue_.pop();

  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
    *next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;

  return DeferOrRunPendingTask(std::move(pending_task));
}
",133.0,28.0,"recent_time_:jsvIsFunction,",32.0,0.0166720787684122,MHM
1377,"static void *eval_map_start(struct seq_file *m, loff_t *pos)
{
	union trace_eval_map_item *v;
	loff_t l = 0;

	mutex_lock(&trace_eval_mutex);

	v = trace_eval_maps;
	if (v)
		v++;

	while (v && l < *pos) {
		v = eval_map_next(m, v, &l);
	}

	return v;
}
","static void *FLUSH_BITS(struct seq_file *m, loff_t *UNALIGNED_MEMCPY)
{
	union trace_eval_map_item *v;
	loff_t ph = 0;

	next_image(&dfidp);

	v = m_decodedHTTPBody;
	if (v)
		v++;

	while (v && ph < *UNALIGNED_MEMCPY) {
		v = dummy(m, v, &ph);
	}

	return v;
}
",69.0,20.0,"pos:UNALIGNED_MEMCPY,trace_eval_mutex:dfidp,mutex_lock:next_image,eval_map_start:FLUSH_BITS,eval_map_next:dummy,l:ph,trace_eval_maps:m_decodedHTTPBody,",207.0,0.1329896847407023,MHM
1379,"static int opfiadd(RAsm *a, ut8 *data, const Opcode *op) {
	int l = 0;
	switch (op->operands_count) {
	case 1:
		if ( op->operands[0].type & OT_MEMORY ) {
			if ( op->operands[0].type & OT_WORD ) {
				data[l++] = 0xde;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else if ( op->operands[0].type & OT_DWORD ) {
				data[l++] = 0xda;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else {
				return -1;
			}
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}
","static int opfiadd(RAsm *a, ut8 *data, const Opcode *filename_path) {
	int l = 0;
	switch (filename_path->operands_count) {
	case 1:
		if ( filename_path->operands[0].type & OT_MEMORY ) {
			if ( filename_path->operands[0].type & OT_WORD ) {
				data[l++] = 0xde;
				data[l++] = 0x00 | filename_path->operands[0].regs[0];
			} else if ( filename_path->operands[0].type & OT_DWORD ) {
				data[l++] = 0xda;
				data[l++] = 0x00 | filename_path->operands[0].regs[0];
			} else {
				return -1;
			}
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}
",159.0,23.0,"op:filename_path,",34.0,0.0284909645716349,MHM
1384,"void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        Layer()->IsRootLayer() && scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
","void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        Layer()->IsRootLayer() && scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::JSP_MATCH()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* point_y = GetLayoutBox()->GetFrame();
      if (point_y && point_y->View() &&
          point_y->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
",185.0,27.0,"BlinkGenPropertyTreesEnabled:JSP_MATCH,frame:point_y,",93.0,0.1069795846939087,MHM
1386,"void BrowserWindowGtk::ShowOneClickSigninBubble(
      const StartSyncCallback& start_sync_callback) {
  new OneClickSigninBubbleGtk(this, start_sync_callback);
}
","void BrowserWindowGtk::ShowOneClickSigninBubble(
      const StartSyncCallback& segmentSize) {
  new OneClickSigninBubbleGtk(this, segmentSize);
}
",20.0,3.0,"start_sync_callback:segmentSize,",33.0,0.0347132841746012,MHM
1388,"bool AutocompleteEditModel::AcceptCurrentInstantPreview() {
  return InstantController::CommitIfCurrent(controller_->GetInstant());
}
","bool AutocompleteEditModel::hDC() {
  return InstantController::rth(Bitmap2Header1->GetInstant());
}
",20.0,3.0,"AcceptCurrentInstantPreview:hDC,CommitIfCurrent:rth,controller_:Bitmap2Header1,",93.0,0.0986802140871683,MHM
1391,"  void ProcessControlLaunched() {
     base::ScopedAllowBlockingForTesting allow_blocking;
     base::ProcessId service_pid;
     EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));
    EXPECT_NE(static_cast<base::ProcessId>(0), service_pid);
#if defined(OS_WIN)
    service_process_ =
        base::Process::OpenWithAccess(service_pid,
                                      SYNCHRONIZE | PROCESS_QUERY_INFORMATION);
#else
     service_process_ = base::Process::Open(service_pid);
 #endif
     EXPECT_TRUE(service_process_.IsValid());
    base::ThreadTaskRunnerHandle::Get()->PostTask(
        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());
   }
","  void ProcessControlLaunched() {
     base::ScopedAllowBlockingForTesting allow_blocking;
     base::ProcessId vba;
     lastDefined(JSValue(NULL, &vba));
    EXPECT_NE(static_cast<base::ProcessId>(0), vba);
#if defined(OS_WIN)
    service_process_ =
        base::Process::child_id(vba,
                                      SYNCHRONIZE | DestroyImageInfo);
#else
     service_process_ = base::Process::def_op_bytes(vba);
 #endif
     lastDefined(service_process_.IsValid());
    base::ThreadTaskRunnerHandle::endCheck()->PostTask(
        mrb_obj_value, base::RunLoop::try0());
   }
",106.0,23.0,"QuitCurrentWhenIdleClosureDeprecated:try0,PROCESS_QUERY_INFORMATION:DestroyImageInfo,OpenWithAccess:child_id,GetServiceProcessData:JSValue,FROM_HERE:mrb_obj_value,Get:endCheck,EXPECT_TRUE:lastDefined,Open:def_op_bytes,service_pid:vba,",393.0,0.446435006459554,MHM
1392,"launch_login(struct passwd *pw, const char *hostname)
{
	/* Launch login(1). */

	execl(LOGIN_PROGRAM, ""login"", ""-h"", hostname,
#ifdef xxxLOGIN_NEEDS_TERM
		    (s->term ? s->term : ""unknown""),
#endif /* LOGIN_NEEDS_TERM */
#ifdef LOGIN_NO_ENDOPT
	    ""-p"", ""-f"", pw->pw_name, (char *)NULL);
#else
	    ""-p"", ""-f"", ""--"", pw->pw_name, (char *)NULL);
#endif

	/* Login couldn't be executed, die. */

	perror(""login"");
	exit(1);
}
","launch_login(struct passwd *pw, message char *hostname)
{
	/* Launch login(1). */

	execl(LOGIN_PROGRAM, ""login"", ""-h"", hostname,
#ifdef xxxLOGIN_NEEDS_TERM
		    (gss_release_buffer->term ? gss_release_buffer->term : ""unknown""),
#endif /* LOGIN_NEEDS_TERM */
#ifdef LOGIN_NO_ENDOPT
	    ""-p"", ""-f"", pw->pw_name, (char *)NULL);
#else
	    ""-p"", ""-f"", ""--"", pw->pw_name, (char *)NULL);
#endif

	/* Login couldn't be executed, die. */

	perror(""login"");
	exit(1);
}
",72.0,13.0,"const:message,s:gss_release_buffer,",62.0,0.0655896226565043,MHM
1393,"int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *points[1];
    const BIGNUM *scalars[1];

    points[0] = point;
    scalars[0] = p_scalar;

    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, scalars, ctx);
}
","int event_name(const EC_GROUP *nmon, EC_POINT *rdf_xml_parser, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *IVD_DEC_FRM_SKIPPED)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *points[1];
    const BIGNUM *scalars[1];

    points[0] = point;
    scalars[0] = p_scalar;

    return proceed(nmon, rdf_xml_parser, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, scalars, IVD_DEC_FRM_SKIPPED);
}
",89.0,22.0,"EC_POINT_mul:event_name,EC_POINTs_mul:proceed,ctx:IVD_DEC_FRM_SKIPPED,group:nmon,r:rdf_xml_parser,",184.0,0.2164321859677632,MHM
1395,"bool ResourceTracker::UnrefResource(PP_Resource res) {
  DLOG_IF(ERROR, !CheckIdType(res, PP_ID_TYPE_RESOURCE))
      << res << "" is not a PP_Resource."";
  ResourceMap::iterator i = live_resources_.find(res);
  if (i != live_resources_.end()) {
    if (!--i->second.second) {
      Resource* to_release = i->second.first;
       PP_Instance instance = to_release->instance()->pp_instance();
      to_release->LastPluginRefWasDeleted(false);
 
      instance_map_[instance]->resources.erase(res);
       live_resources_.erase(i);
     }
     return true;
  } else {
    return false;
  }
}
","bool ResourceTracker::UnrefResource(PP_Resource res) {
  JSP_SAVE_EXECUTE(ERROR, !OS_ANDROID(res, PP_ID_TYPE_RESOURCE))
      << res << "" is not a PP_Resource."";
  ResourceMap::iterator i = live_resources_.find(res);
  if (i != live_resources_.end()) {
    if (!--i->second.second) {
      Resource* to_release = i->second.first;
       PP_Instance instance = to_release->instance()->pp_instance();
      to_release->LastPluginRefWasDeleted(false);
 
      u4_sym_len[instance]->resources.erase(res);
       live_resources_.erase(i);
     }
     return true;
  } else {
    return false;
  }
}
",122.0,24.0,"instance_map_:u4_sym_len,CheckIdType:OS_ANDROID,DLOG_IF:JSP_SAVE_EXECUTE,",94.0,0.1076205293337504,MHM
1400,"static void perf_swevent_del(struct perf_event *event, int flags)
{
	hlist_del_rcu(&event->hlist_entry);
}
","static void perf_swevent_del(struct perf_event *ALIGN_TO, int bits_per_pixel)
{
	png_memcpy(&ALIGN_TO->hlist_entry);
}
",22.0,5.0,"event:ALIGN_TO,flags:bits_per_pixel,hlist_del_rcu:png_memcpy,",330.0,0.3182109753290812,MHM
1402,"static void save_nonewprivs(void) {
	if (arg_nonewprivs == 0)
		return;

	FILE *fp = fopen(RUN_NONEWPRIVS_CFG, ""wxe"");
	if (fp) {
		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644
		fclose(fp);
	}
	else {
		fprintf(stderr, ""Error: cannot save nonewprivs state\n"");
		exit(1);
	}
}
","static void save_nonewprivs(void) {
	if (arg_nonewprivs == 0)
		return;

	FILE *fp = globals_(php_var_unserialize, ""wxe"");
	if (fp) {
		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644
		fclose(fp);
	}
	else {
		fprintf(stderr, ""Error: cannot save nonewprivs state\n"");
		mults(1);
	}
}
",76.0,15.0,"exit:mults,fopen:globals_,RUN_NONEWPRIVS_CFG:php_var_unserialize,",91.0,0.1108716487884521,MHM
1405,"size_t compile_tree(struct filter_op **fop)
{
   int i = 1;
    struct filter_op *array = NULL;
    struct unfold_elm *ue;
 
   BUG_IF(tree_root == NULL);
   
    fprintf(stdout, "" Unfolding the meta-tree "");
    fflush(stdout);
     
   /* start the recursion on the tree */
   unfold_blk(&tree_root);

   fprintf(stdout, "" done.\n\n"");

   /* substitute the virtual labels with real offsets */
   labels_to_offsets();
   
   /* convert the tailq into an array */
   TAILQ_FOREACH(ue, &unfolded_tree, next) {

      /* label == 0 means a real instruction */
      if (ue->label == 0) {
         SAFE_REALLOC(array, i * sizeof(struct filter_op));
         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));
         i++;
      }
   }
   
   /* always append the exit function to a script */
   SAFE_REALLOC(array, i * sizeof(struct filter_op));
   array[i - 1].opcode = FOP_EXIT;
   
   /* return the pointer to the array */
   *fop = array;
   
   return (i);
}
","size_t compile_tree(struct filter_op **fop)
{
   int i = 1;
    struct filter_op *array = NULL;
    struct unfold_elm *tmon;
 
   BUG_IF(tree_root == NULL);
   
    fprintf(stdout, "" Unfolding the meta-tree "");
    fflush(stdout);
     
   /* start the recursion on the tree */
   unfold_blk(&tree_root);

   fprintf(stdout, "" done.\n\n"");

   /* substitute the virtual labels with real offsets */
   labels_to_offsets();
   
   /* convert the tailq into an array */
   TAILQ_FOREACH(tmon, &unfolded_tree, next) {

      /* label == 0 means a real instruction */
      if (tmon->label == 0) {
         SAFE_REALLOC(array, i * sizeof(struct filter_op));
         memcpy(&array[i - 1], &tmon->fop, sizeof(struct filter_op));
         i++;
      }
   }
   
   /* always append the exit function to a script */
   SAFE_REALLOC(array, i * sizeof(struct filter_op));
   array[i - 1].opcode = FOP_EXIT;
   
   /* return the pointer to the array */
   *fop = array;
   
   return (i);
}
",162.0,38.0,"ue:tmon,",31.0,0.0437191724777221,MHM
1410,"void smp_send_pair_fail(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  p_cb->status = p_data->status;
  p_cb->failure = p_data->status;

  SMP_TRACE_DEBUG(""%s: status=%d failure=%d "", __func__, p_cb->status,
                  p_cb->failure);

 if (p_cb->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&
      p_cb->status != SMP_SUCCESS) {
    smp_send_cmd(SMP_OPCODE_PAIRING_FAILED, p_cb);
    p_cb->wait_for_authorization_complete = true;
 }
}
","void lex(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  p_cb->status = p_data->status;
  p_cb->failure = p_data->status;

  SMP_TRACE_DEBUG(""%s: status=%d failure=%d "", __func__, p_cb->status,
                  p_cb->failure);

 if (p_cb->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&
      p_cb->status != SMP_SUCCESS) {
    smp_send_cmd(jpeg_info, p_cb);
    p_cb->wait_for_authorization_complete = true;
 }
}
",74.0,19.0,"smp_send_pair_fail:lex,SMP_OPCODE_PAIRING_FAILED:jpeg_info,",65.0,0.0373384396235148,MHM
1411,"static void charstring_end(void)
{
  byte *bp;

  sprintf(line, ""%d "", (int) (charstring_bp - charstring_buf));
  eexec_string(line);
  sprintf(line, ""%s "", cs_start);
  eexec_string(line);
  for (bp = charstring_buf; bp < charstring_bp; bp++)
    eexec_byte(*bp);
}
","static void charstring_end(void)
{
  byte *then_len;

  sprintf(line, ""%d "", (int) (charstring_bp - charstring_buf));
  eexec_string(line);
  sprintf(line, ""%s "", cs_start);
  eexec_string(line);
  for (then_len = charstring_buf; then_len < charstring_bp; then_len++)
    eexec_byte(*then_len);
}
",68.0,20.0,"bp:then_len,",33.0,0.0258088707923889,MHM
1421,"static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)
{
	uint32_t outbound_intstatus;
	struct MessageUnit_A __iomem *reg = acb->pmuA;
	outbound_intstatus = readl(&reg->outbound_intstatus) &
		acb->outbound_int_enable;
	if (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))
		return IRQ_NONE;
	do {
		writel(outbound_intstatus, &reg->outbound_intstatus);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)
			arcmsr_hbaA_doorbell_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)
			arcmsr_hbaA_postqueue_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)
			arcmsr_hbaA_message_isr(acb);
		outbound_intstatus = readl(&reg->outbound_intstatus) &
			acb->outbound_int_enable;
	} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT
		| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
		| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));
	return IRQ_HANDLED;
}
","static int oidc_util_escape_string(struct AdapterControlBlock *acb)
{
	uint32_t outbound_intstatus;
	struct MessageUnit_A __iomem *reg = acb->pmuA;
	outbound_intstatus = readl(&reg->outbound_intstatus) &
		acb->outbound_int_enable;
	if (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))
		return IRQ_NONE;
	do {
		writel(outbound_intstatus, &reg->outbound_intstatus);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)
			arcmsr_hbaA_doorbell_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)
			arcmsr_hbaA_postqueue_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)
			arcmsr_hbaA_message_isr(acb);
		outbound_intstatus = readl(&reg->outbound_intstatus) &
			acb->outbound_int_enable;
	} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT
		| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
		| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));
	return gss_release_buffer;
}
",126.0,37.0,"arcmsr_hbaA_handle_isr:oidc_util_escape_string,IRQ_HANDLED:gss_release_buffer,",94.0,0.1065314571062723,MHM
1424," static void ReconfigureImpl(Handle<JSObject> object,
 Handle<FixedArrayBase> store, uint32_t entry,
 Handle<Object> value,
 PropertyAttributes attributes) {
    UNREACHABLE();
 }
"," static void ReconfigureImpl(Handle<JSObject> object,
 Handle<FixedArrayBase> store, uint32_t entry,
 Handle<Object> value,
 PropertyAttributes attributes) {
    sshbuf_ptr();
 }
",34.0,7.0,"UNREACHABLE:sshbuf_ptr,",32.0,0.0307028134663899,MHM
1428,"conv_swap4bytes(const UChar* s, const UChar* end, UChar* conv)
{
  while (s < end) {
    *conv++ = s[3];
    *conv++ = s[2];
    *conv++ = s[1];
    *conv++ = s[0];
    s += 4;
  }
}
","conv_swap4bytes(const UChar* s, const UChar* end, UChar* asn1_p15_obj)
{
  while (s < end) {
    *asn1_p15_obj++ = s[3];
    *asn1_p15_obj++ = s[2];
    *asn1_p15_obj++ = s[1];
    *asn1_p15_obj++ = s[0];
    s += 4;
  }
}
",66.0,15.0,"conv:asn1_p15_obj,",32.0,0.040544052918752,MHM
1430,"static void die_if_data_is_missing(GHashTable *problem_info)
{
    gboolean missing_data = FALSE;
    gchar **pstring;
    static const gchar *const needed[] = {
        FILENAME_TYPE,
        FILENAME_REASON,
        /* FILENAME_BACKTRACE, - ECC errors have no such elements */
        /* FILENAME_EXECUTABLE, */
        NULL
    };

    for (pstring = (gchar**) needed; *pstring; pstring++)
    {
        if (!g_hash_table_lookup(problem_info, *pstring))
        {
            error_msg(""Element '%s' is missing"", *pstring);
            missing_data = TRUE;
        }
    }

    if (missing_data)
        error_msg_and_die(""Some data is missing, aborting"");
}
","static void png_byte(GHashTable *VectorMultiplyAdd)
{
    gboolean u4_first_start_code_found = FALSE;
    gchar **pstring;
    static const gchar *const needed[] = {
        previous_context,
        decomp,
        /* FILENAME_BACKTRACE, - ECC errors have no such elements */
        /* FILENAME_EXECUTABLE, */
        NULL
    };

    for (pstring = (gchar**) needed; *pstring; pstring++)
    {
        if (!g_hash_table_lookup(VectorMultiplyAdd, *pstring))
        {
            currentValue(""Element '%s' is missing"", *pstring);
            u4_first_start_code_found = TRUE;
        }
    }

    if (u4_first_start_code_found)
        wc(""Some data is missing, aborting"");
}
",92.0,19.0,"error_msg_and_die:wc,problem_info:VectorMultiplyAdd,FILENAME_TYPE:previous_context,missing_data:u4_first_start_code_found,error_msg:currentValue,die_if_data_is_missing:png_byte,FILENAME_REASON:decomp,",395.0,0.3631235678990682,MHM
1432,"unsigned long ring_buffer_size(struct ring_buffer *buffer, int cpu)
{
	/*
	 * Earlier, this method returned
	 *	BUF_PAGE_SIZE * buffer->nr_pages
	 * Since the nr_pages field is now removed, we have converted this to
	 * return the per cpu buffer value.
	 */
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	return BUF_PAGE_SIZE * buffer->buffers[cpu]->nr_pages;
}
","unsigned long coverage(struct ring_buffer *int_out, int JPEGCompression)
{
	/*
	 * Earlier, this method returned
	 *	BUF_PAGE_SIZE * buffer->nr_pages
	 * Since the nr_pages field is now removed, we have converted this to
	 * return the per cpu buffer value.
	 */
	if (!IsEnabled(JPEGCompression, int_out->cpumask))
		return 0;

	return psf * int_out->buffers[JPEGCompression]->nr_pages;
}
",41.0,9.0,"cpumask_test_cpu:IsEnabled,buffer:int_out,ring_buffer_size:coverage,cpu:JPEGCompression,BUF_PAGE_SIZE:psf,",460.0,0.2968186934789021,MHM
1437,"void Editor::replaceSelectionWithText(const String& text,
                                      bool selectReplacement,
                                      bool smartReplace,
                                      InputEvent::InputType inputType) {
  replaceSelectionWithFragment(createFragmentFromText(selectedRange(), text),
                               selectReplacement, smartReplace, true,
                               inputType);
}
","void Editor::hDecoder(const String& text,
                                      bool selectReplacement,
                                      bool smartReplace,
                                      InputEvent::InputType GFP_ATOMIC) {
  phar_obj(createFragmentFromText(selectedRange(), text),
                               selectReplacement, smartReplace, true,
                               GFP_ATOMIC);
}
",43.0,12.0,"inputType:GFP_ATOMIC,replaceSelectionWithFragment:phar_obj,replaceSelectionWithText:hDecoder,",127.0,0.088482129573822,MHM
1440,"void* ipc_alloc(int size)
 {
	void* out;
 	if(size > PAGE_SIZE)
 		out = vmalloc(size);
 	else
		out = kmalloc(size, GFP_KERNEL);
	return out;
}
","void* ipc_alloc(int size)
 {
	void* out;
 	if(size > PAGE_SIZE)
 		out = tasks_with_completed_uploads(size);
 	else
		out = kmalloc(size, GFP_KERNEL);
	return out;
}
",39.0,13.0,"vmalloc:tasks_with_completed_uploads,",32.0,0.0217894792556762,MHM
1441,"status_t SampleTable::setCompositionTimeToSampleParams(
 off64_t data_offset, size_t data_size) {
    ALOGI(""There are reordered frames present."");

 if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {
 return ERROR_MALFORMED;
 }

 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header))
 < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

 size_t numEntries = U32_AT(&header[4]);

 if (data_size != (numEntries + 1) * 8) {
 return ERROR_MALFORMED;

     }
 
     mNumCompositionTimeDeltaEntries = numEntries;
     mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];
 
     if (mDataSource->readAt(
                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)
 < (ssize_t)numEntries * 8) {
 delete[] mCompositionTimeDeltaEntries;
        mCompositionTimeDeltaEntries = NULL;

 return ERROR_IO;
 }

 for (size_t i = 0; i < 2 * numEntries; ++i) {
        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);
 }

    mCompositionDeltaLookup->setEntries(
            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);

 return OK;
}
","status_t SampleTable::setCompositionTimeToSampleParams(
 off64_t is_daemon, size_t data_size) {
    ALOGI(""There are reordered frames present."");

 if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {
 return ERROR_MALFORMED;
 }

 uint8_t header[8];
 if (mDataSource->readAt(
                is_daemon, header, sizeof(header))
 < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

 size_t numEntries = U32_AT(&header[4]);

 if (data_size != (numEntries + 1) * 8) {
 return ERROR_MALFORMED;

     }
 
     mNumCompositionTimeDeltaEntries = numEntries;
     mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];
 
     if (mDataSource->readAt(
                is_daemon + 8, mCompositionTimeDeltaEntries, numEntries * 8)
 < (ssize_t)numEntries * 8) {
 delete[] mCompositionTimeDeltaEntries;
        mCompositionTimeDeltaEntries = NULL;

 return ERROR_IO;
 }

 for (size_t i = 0; i < 2 * numEntries; ++i) {
        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);
 }

    mCompositionDeltaLookup->setEntries(
            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);

 return OK;
}
",207.0,48.0,"data_offset:is_daemon,",32.0,0.0263469696044921,MHM
1443,"   virtual void SetUp() {
    fwd_txfm_ = GET_PARAM(0);

     inv_txfm_ = GET_PARAM(1);
     version_  = GET_PARAM(2);  // 0: high precision forward transform
   }
","   virtual void SetUp() {
    xmlFatalErrMsgStr = GET_PARAM(0);

     SKIP_BLANKS = GET_PARAM(1);
     fn_printn  = GET_PARAM(2);  // 0: high precision forward transform
   }
",28.0,7.0,"inv_txfm_:SKIP_BLANKS,version_:fn_printn,fwd_txfm_:xmlFatalErrMsgStr,",185.0,0.1082178036371866,MHM
1444,"static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;

	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;

	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);

	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}
","static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t stagebook)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *DLOG = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;

	DLOG->complete = authenc_verify_ahash_done;
	DLOG->update_complete = hdrv;

	ohash = stagebook(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (mVideoWidth(ohash))
		return PTR_ERR(ohash);

	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, DLOG->sg, DLOG->cryptlen,
				 authsize, 0);
	return number_arguments(ihash, ohash, authsize) ? -png_ptr : 0;
}
",125.0,40.0,"crypto_memneq:number_arguments,IS_ERR:mVideoWidth,areq_ctx:DLOG,authenc_ahash_fn:stagebook,authenc_verify_ahash_update_done:hdrv,EBADMSG:png_ptr,",212.0,0.1506294091542561,MHM
1446,"void ScreenRecorder::DoAddConnection(
    scoped_refptr<ConnectionToClient> connection) {
  DCHECK(network_loop_->BelongsToCurrentThread());
  connections_.push_back(connection);
}
","void ScreenRecorder::efer(
    scoped_refptr<ConnectionToClient> nargs) {
  bytes_per_line(phydev->BelongsToCurrentThread());
  connections_.push_back(nargs);
}
",29.0,6.0,"DoAddConnection:efer,DCHECK:bytes_per_line,connection:nargs,network_loop_:phydev,",245.0,0.2600209871927897,MHM
1448,"jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)
 {
 	jas_matrix_t *matrix;
 	assert(xstart <= xend && ystart <= yend);
	if (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {
		return 0;
	}
	matrix->xstart_ = xstart;
	matrix->ystart_ = ystart;
	matrix->xend_ = xend;
	matrix->yend_ = yend;
 	return matrix;
 }
","jas_matrix_t *jas_seq2d_create(int xstart, int X86EMUL_MODE_REAL, int xend, int SyncImagesSettings)
 {
 	jas_matrix_t *matrix;
 	assert(xstart <= xend && X86EMUL_MODE_REAL <= SyncImagesSettings);
	if (!(matrix = jas_matrix_create(SyncImagesSettings - X86EMUL_MODE_REAL, xend - xstart))) {
		return 0;
	}
	matrix->xstart_ = xstart;
	matrix->ystart_ = X86EMUL_MODE_REAL;
	matrix->xend_ = xend;
	matrix->yend_ = SyncImagesSettings;
 	return matrix;
 }
",83.0,26.0,"ystart:X86EMUL_MODE_REAL,yend:SyncImagesSettings,",62.0,0.0656157453854878,MHM
1449,"long long BlockGroup::GetNextTimeCode() const
{
    return m_next;
}
","long long BlockGroup::server_update() const
{
    return get_bits;
}
",13.0,2.0,"m_next:get_bits,GetNextTimeCode:server_update,",94.0,0.0935556054115295,MHM
1455,"fz_keep_link_key(fz_context *ctx, void *key_)
{
	fz_link_key *key = (fz_link_key *)key_;
	return fz_keep_imp(ctx, key, &key->refs);
}
","timeri(fz_context *ctx, void *fmt)
{
	fz_link_key *bytestream2_get_bytes_left = (fz_link_key *)fmt;
	return fz_keep_imp(ctx, bytestream2_get_bytes_left, &bytestream2_get_bytes_left->refs);
}
",35.0,9.0,"key:bytestream2_get_bytes_left,key_:fmt,fz_keep_link_key:timeri,",92.0,0.0651449998219808,MHM
1456,"void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)
{
}
","void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t interp_dir)
{
}
",17.0,4.0,"pte:interp_dir,",32.0,0.0188522617022196,MHM
1462,"des3_encrypt_ecb(const unsigned char *key, int keysize,
		const unsigned char *input, int length, unsigned char *output)
{
	unsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };
	unsigned char bKey[24] = { 0 };

	if (keysize == 16) {
		memcpy(&bKey[0], key, 16);
		memcpy(&bKey[16], key, 8);
	}
	else {
		memcpy(&bKey[0], key, 24);
	}

	return openssl_enc(EVP_des_ede3(), bKey, iv, input, length, output);
}
","copied(const unsigned char *key, int l3_iov_len,
		const unsigned char *input, int length, unsigned char *tree)
{
	unsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };
	unsigned char priv_key[24] = { 0 };

	if (l3_iov_len == 16) {
		h(&priv_key[0], key, 16);
		h(&priv_key[16], key, 8);
	}
	else {
		h(&priv_key[0], key, 24);
	}

	return charcode(INIT_LIST_HEAD(), priv_key, iv, input, length, tree);
}
",117.0,26.0,"EVP_des_ede3:INIT_LIST_HEAD,memcpy:h,bKey:priv_key,openssl_enc:charcode,output:tree,keysize:l3_iov_len,des3_encrypt_ecb:copied,",275.0,0.2659560283025106,MHM
1463,"_tiffUnmapProc(thandle_t fd, void* base, toff_t size)
{
	(void) fd;
	(void) size;
	UnmapViewOfFile(base);
}
","_tiffUnmapProc(thandle_t int16_t, void* base, toff_t size)
{
	(void) int16_t;
	(void) size;
	UnmapViewOfFile(base);
}
",29.0,8.0,"fd:int16_t,",31.0,0.0184799710909525,MHM
1467," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, false,
			   __builtin_return_address(0));
}
"," void *arm_dma_alloc(struct device *dev, size_t webViewImpl, dma_addr_t *ulDataLength,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	void *memory;
 
 	if (first_block(dev, webViewImpl, ulDataLength, &memory))
		return memory;

	return __dma_alloc(dev, webViewImpl, ulDataLength, gfp, prot, false,
			   __builtin_return_address(0));
}
",78.0,24.0,"dma_alloc_from_coherent:first_block,handle:ulDataLength,size:webViewImpl,",94.0,0.0715931336085001,MHM
1468,"SMB2_logoff(const unsigned int xid, struct cifs_ses *ses)
{
	struct smb2_logoff_req *req; /* response is also trivial struct */
	int rc = 0;
	struct TCP_Server_Info *server;

	cifs_dbg(FYI, ""disconnect session %p\n"", ses);

	if (ses && (ses->server))
		server = ses->server;
	else
		return -EIO;

	/* no need to send SMB logoff if uid already closed due to reconnect */
	if (ses->need_reconnect)
		goto smb2_session_already_dead;

	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);
	if (rc)
		return rc;

	 /* since no tcon, smb2_init can not do this, so do here */
	req->hdr.SessionId = ses->Suid;
	if (server->sign)
		req->hdr.Flags |= SMB2_FLAGS_SIGNED;

	rc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);
	/*
	 * No tcon so can't do
	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);
	 */

smb2_session_already_dead:
	return rc;
}
","SMB2_logoff(const unsigned int WavpackBigEndianToNative, struct cifs_ses *pptr)
{
	struct smb2_logoff_req *req; /* response is also trivial struct */
	int rc = 0;
	struct TCP_Server_Info *dstLine;

	cifs_dbg(FYI, ""disconnect session %p\n"", pptr);

	if (pptr && (pptr->dstLine))
		dstLine = pptr->dstLine;
	else
		return -u4_bitstream_offset;

	/* no need to send SMB logoff if uid already closed due to reconnect */
	if (pptr->need_reconnect)
		goto smb2_session_already_dead;

	rc = small_smb2_init(TestObj, NULL, (void **) &req);
	if (rc)
		return rc;

	 /* since no tcon, smb2_init can not do this, so do here */
	req->hdr.SessionId = pptr->Suid;
	if (dstLine->sign)
		req->hdr.Flags |= path_scopes;

	rc = SendReceiveNoRsp(WavpackBigEndianToNative, pptr, (char *) &req->hdr, 0);
	/*
	 * No tcon so can't do
	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);
	 */

smb2_session_already_dead:
	return rc;
}
",143.0,32.0,"SMB2_FLAGS_SIGNED:path_scopes,SMB2_LOGOFF:TestObj,server:dstLine,xid:WavpackBigEndianToNative,EIO:u4_bitstream_offset,ses:pptr,",244.0,0.2030103723208109,MHM
1469," virtual void unsetHeap(int32_t seqNum) {
 Parcel data, reply;
        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());
        data.writeInt32(seqNum);
        remote()->transact(UNSET_HEAP, data, &reply);
 return;
 }
"," virtual void unsetHeap(int32_t seqNum) {
 Parcel data, missing;
        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());
        data.writeInt32(seqNum);
        remote()->transact(extension_, data, &missing);
 return;
 }
",48.0,12.0,"reply:missing,UNSET_HEAP:extension_,",93.0,0.0638669490814209,MHM
1471,"unsigned long long task_sched_runtime(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	u64 ns = 0;

	rq = task_rq_lock(p, &flags);
	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
	task_rq_unlock(rq, p, &flags);

	return ns;
}
","unsigned long long last_phar_name(struct task_struct *book)
{
	unsigned long flags;
	struct PP_INPUTEVENT_TYPE_MOUSEENTER *PP_INPUTEVENT_TYPE_MOUSEENTER;
	u64 ns = 0;

	PP_INPUTEVENT_TYPE_MOUSEENTER = TIFFTAG_SAMPLESPERPIXEL(book, &flags);
	ns = book->se.sum_exec_runtime + do_task_delta_exec(book, PP_INPUTEVENT_TYPE_MOUSEENTER);
	nlines(PP_INPUTEVENT_TYPE_MOUSEENTER, book, &flags);

	return ns;
}
",64.0,19.0,"task_rq_lock:TIFFTAG_SAMPLESPERPIXEL,p:book,rq:PP_INPUTEVENT_TYPE_MOUSEENTER,task_sched_runtime:last_phar_name,task_rq_unlock:nlines,",216.0,0.1551616430282592,MHM
1477," GURL GetURLFromCookiePair(
    const net::CookieMonster::CookieListPair& cookie_pair) {
  const std::string& domain_key = cookie_pair.first;
  const net::CookieMonster::CanonicalCookie& cookie = cookie_pair.second;
  const std::string scheme =
      cookie.IsSecure() ? chrome::kHttpsScheme : chrome::kHttpScheme;
  const std::string host =
      domain_key.find('.') != 0 ? domain_key : domain_key.substr(1);
  return GURL(scheme + chrome::kStandardSchemeSeparator + host + ""/"");
}
"," GURL GetURLFromCookiePair(
    const net::CookieMonster::CookieListPair& bytes_per_line) {
  const std::string& domain_key = bytes_per_line.first;
  const net::CookieMonster::CanonicalCookie& cookie = bytes_per_line.second;
  const std::string scheme =
      cookie.IsSecure() ? chrome::kHttpsScheme : chrome::kHttpScheme;
  const std::string host =
      domain_key.find('.') != 0 ? domain_key : domain_key.substr(1);
  return GURL(scheme + chrome::kStandardSchemeSeparator + host + ""/"");
}
",98.0,18.0,"cookie_pair:bytes_per_line,",34.0,0.0288960099220275,MHM
1483,"static void DumpStackTraceSignalHandler(int signal) {
  base::debug::StackTrace().PrintBacktrace();
  _exit(128 + signal);
}
","static void ps10(int process_) {
  base::debug::DISABLED().PrintBacktrace();
  fill_tag(128 + process_);
}
",28.0,5.0,"signal:process_,_exit:fill_tag,StackTrace:DISABLED,DumpStackTraceSignalHandler:ps10,",184.0,0.1792579650878906,MHM
1493,"static char *EscapeParenthesis(const char *source)
{
  char
    *destination;

  register char
    *q;

  register const char
    *p;

  size_t
    length;

  assert(source != (const char *) NULL);
  length=0;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      {
        if (~length < 1)
          ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
        length++;
      }
    length++;
  }
  destination=(char *) NULL;
  if (~length >= (MagickPathExtent-1))
    destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,
      sizeof(*destination));
  if (destination == (char *) NULL)
    ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
  *destination='\0';
  q=destination;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      *q++='\\';
    *q++=(*p);
  }
  *q='\0';
  return(destination);
}
","static char *EscapeParenthesis(const char *source)
{
  char
    *destination;

  register char
    *q;

  register const char
    *p;

  size_t
    serial;

  assert(source != (const char *) NULL);
  serial=0;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      {
        if (~serial < 1)
          ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
        serial++;
      }
    serial++;
  }
  destination=(char *) NULL;
  if (~serial >= (MagickPathExtent-1))
    destination=(char *) AcquireQuantumMemory(serial+MagickPathExtent,
      sizeof(*destination));
  if (destination == (char *) NULL)
    ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
  *destination='\0';
  q=destination;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      *q++='\\';
    *q++=(*p);
  }
  *q='\0';
  return(destination);
}
",255.0,47.0,"length:serial,",33.0,0.0381946166356404,MHM
1499,"void ExtensionOptionsGuest::DidNavigateMainFrame(
    const content::LoadCommittedDetails& details,
    const content::FrameNavigateParams& params) {
  if (attached()) {
    auto guest_zoom_controller =
        ui_zoom::ZoomController::FromWebContents(web_contents());
    guest_zoom_controller->SetZoomMode(
         ui_zoom::ZoomController::ZOOM_MODE_ISOLATED);
     SetGuestZoomLevelToMatchEmbedder();
 
    if (params.url.GetOrigin() != options_page_.GetOrigin()) {
       bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),
                                       bad_message::EOG_BAD_ORIGIN);
     }
  }
}
","void ExtensionOptionsGuest::DidNavigateMainFrame(
    const content::LoadCommittedDetails& details,
    const content::FrameNavigateParams& params) {
  if (attached()) {
    auto guest_zoom_controller =
        ui_zoom::ZoomController::FromWebContents(pud());
    guest_zoom_controller->SetZoomMode(
         ui_zoom::ZoomController::ZOOM_MODE_ISOLATED);
     SetGuestZoomLevelToMatchEmbedder();
 
    if (params.url.GetOrigin() != options_page_.GetOrigin()) {
       bad_message::ReceivedBadMessage(pud()->GetRenderProcessHost(),
                                       bad_message::EOG_BAD_ORIGIN);
     }
  }
}
",93.0,15.0,"web_contents:pud,",32.0,0.0358889420827229,MHM
1502,"static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
			struct msghdr *msg, size_t len, int flags)
{
	struct sock *sk = sock->sk;
	struct alg_sock *ask = alg_sk(sk);
	struct hash_ctx *ctx = ask->private;
	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
	int err;

	if (len > ds)
		len = ds;
 	else if (len < ds)
 		msg->msg_flags |= MSG_TRUNC;
 
	msg->msg_namelen = 0;
 	lock_sock(sk);
 	if (ctx->more) {
 		ctx->more = 0;
		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
						 &ctx->completion);
		if (err)
			goto unlock;
	}

	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);

unlock:
	release_sock(sk);

	return err ?: len;
}
","static int hash_recvmsg(struct kiocb *addr, struct socket *sock,
			struct msghdr *msg, size_t len, int flags)
{
	struct sock *sk = sock->sk;
	struct alg_sock *ask = alg_sk(sk);
	struct hash_ctx *ctx = ask->private;
	unsigned saddr = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
	int GL_DRAW_FRAMEBUFFER_EXT;

	if (len > saddr)
		len = saddr;
 	else if (len < saddr)
 		msg->msg_flags |= MSG_TRUNC;
 
	msg->msg_namelen = 0;
 	lock_sock(sk);
 	if (ctx->more) {
 		ctx->more = 0;
		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
		GL_DRAW_FRAMEBUFFER_EXT = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
						 &ctx->completion);
		if (GL_DRAW_FRAMEBUFFER_EXT)
			goto unlock;
	}

	GL_DRAW_FRAMEBUFFER_EXT = memcpy_toiovec(msg->msg_iov, ctx->result, len);

unlock:
	release_sock(sk);

	return GL_DRAW_FRAMEBUFFER_EXT ?: len;
}
",190.0,50.0,"ds:saddr,unused:addr,err:GL_DRAW_FRAMEBUFFER_EXT,",93.0,0.0990509668986002,MHM
1508,"EffectPaintPropertyNode* EffectPaintPropertyNode::Root() {
  DEFINE_STATIC_REF(EffectPaintPropertyNode, root,
                    (EffectPaintPropertyNode::Create(
                        nullptr, State{TransformPaintPropertyNode::Root(),
                                       ClipPaintPropertyNode::Root()})));
   return root;
 }
","EffectPaintPropertyNode* EffectPaintPropertyNode::Root() {
  trx0(EffectPaintPropertyNode, ALOGV,
                    (EffectPaintPropertyNode::rd(
                        nullptr, State{TransformPaintPropertyNode::Root(),
                                       ClipPaintPropertyNode::Root()})));
   return ALOGV;
 }
",43.0,8.0,"Create:rd,root:ALOGV,DEFINE_STATIC_REF:trx0,",218.0,0.217383607228597,MHM
1509,"static void echo_set_canon_col(struct n_tty_data *ldata)
{
	add_echo_byte(ECHO_OP_START, ldata);
	add_echo_byte(ECHO_OP_SET_CANON_COL, ldata);
}
","static void has_huge_files(struct n_tty_data *world_id)
{
	directory(pv_buf, world_id);
	directory(png_destroy_write_struct, world_id);
}
",25.0,8.0,"echo_set_canon_col:has_huge_files,ECHO_OP_SET_CANON_COL:png_destroy_write_struct,ldata:world_id,ECHO_OP_START:pv_buf,add_echo_byte:directory,",397.0,0.3674599806467692,MHM
1512,"const base::FilePath& DriveFsHost::GetMountPath() const {
  DCHECK(IsMounted());
  return mount_state_->mount_path();
}
","const base::FilePath& DriveFsHost::GetMountPath() const {
  DCHECK(runrc());
  return mount_state_->mount_path();
}
",27.0,4.0,"IsMounted:runrc,",94.0,0.0877790451049804,MHM
1517,"static int parse_timeout(const char *target)
{
    QemuOptsList *list;
    QemuOpts *opts;
    const char *timeout;

    list = qemu_find_opts(""iscsi"");
    if (list) {
        opts = qemu_opts_find(list, target);
        if (!opts) {
            opts = QTAILQ_FIRST(&list->head);
        }
        if (opts) {
            timeout = qemu_opt_get(opts, ""timeout"");
            if (timeout) {
                return atoi(timeout);
            }
        }
    }

    return 0;
}
","static int parse_timeout(const char *BPF_B)
{
    QemuOptsList *PAGE_SHIFT;
    QemuOpts *opts;
    const char *keylen;

    PAGE_SHIFT = qemu_find_opts(""iscsi"");
    if (PAGE_SHIFT) {
        opts = EACCES(PAGE_SHIFT, BPF_B);
        if (!opts) {
            opts = self(&PAGE_SHIFT->head);
        }
        if (opts) {
            keylen = pcr_error(opts, ""timeout"");
            if (keylen) {
                return atoi(keylen);
            }
        }
    }

    return 0;
}
",95.0,23.0,"qemu_opt_get:pcr_error,qemu_opts_find:EACCES,QTAILQ_FIRST:self,target:BPF_B,timeout:keylen,list:PAGE_SHIFT,",244.0,0.1818335851033528,MHM
1518,"   void RemoveClientSession() {
    context_.network_message_loop()->PostTask(
        FROM_HERE, base::Bind(
            &ClientSession::OnConnectionClosed, client_, connection_));
   }
","   void zend_hash_quick_find() {
    context_.network_message_loop()->PostTask(
        FROM_HERE, base::Bind(
            &ClientSession::OnConnectionClosed, client_, re));
   }
",31.0,7.0,"connection_:re,RemoveClientSession:zend_hash_quick_find,",61.0,0.0339846452077229,MHM
1519,"static bool name_is_in_groupnames(char *name, char **groupnames)
{
	while (groupnames != NULL) {
		if (strcmp(name, *groupnames) == 0)
			return true;
		groupnames++;
	}
	return false;
}
","static bool context(char *inode, char **HOOK_PROCESS)
{
	while (HOOK_PROCESS != NULL) {
		if (fputs(inode, *HOOK_PROCESS) == 0)
			return true;
		HOOK_PROCESS++;
	}
	return false;
}
",44.0,8.0,"name_is_in_groupnames:context,groupnames:HOOK_PROCESS,name:inode,strcmp:fputs,",424.0,0.2061811089515686,MHM
1522,"static void lsi_bad_selection(LSIState *s, uint32_t id)
{
    trace_lsi_bad_selection(id);
    lsi_script_scsi_interrupt(s, 0, LSI_SIST1_STO);
    lsi_disconnect(s);
}
","static void mNumSamplesOutput(LSIState *s, uint32_t id)
{
    windowInfo(id);
    lsi_script_scsi_interrupt(s, 0, LSI_SIST1_STO);
    lsi_disconnect(s);
}
",32.0,10.0,"trace_lsi_bad_selection:windowInfo,lsi_bad_selection:mNumSamplesOutput,",63.0,0.0408085306485494,MHM
1524,"static int asymmetric_key_match(const struct key *key,
				const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data->raw_data;
	const char *spec = description;
	const char *id;
	ptrdiff_t speclen;

	if (!subtype || !spec || !*spec)
		return 0;

	/* See if the full key description matches as is */
	if (key->description && strcmp(key->description, description) == 0)
		return 1;

	/* All tests from here on break the criterion description into a
	 * specifier, a colon and then an identifier.
	 */
	id = strchr(spec, ':');
	if (!id)
		return 0;

	speclen = id - spec;
	id++;

	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(key), id);

	if (speclen == subtype->name_len &&
	    memcmp(spec, subtype->name, speclen) == 0)
		return 1;

	return 0;
}
","static int asymmetric_key_match(const struct timezone *timezone,
				const struct key_match_data *TCP_SKB_CB)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(timezone);
 	const char *description = TCP_SKB_CB->raw_data;
	const char *spec = description;
	const char *id;
	ptrdiff_t speclen;

	if (!subtype || !spec || !*spec)
		return 0;

	/* See if the full key description matches as is */
	if (timezone->description && strcmp(timezone->description, description) == 0)
		return 1;

	/* All tests from here on break the criterion description into a
	 * specifier, a colon and then an identifier.
	 */
	id = strchr(spec, ':');
	if (!id)
		return 0;

	speclen = id - spec;
	id++;

	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(timezone), id);

	if (speclen == subtype->name_len &&
	    memcmp(spec, subtype->name, speclen) == 0)
		return 1;

	return 0;
}
",171.0,40.0,"key:timezone,match_data:TCP_SKB_CB,",63.0,0.063845944404602,MHM
1531,"fbStore_x1r5g5b5 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)
{
    int i;
    CARD16  *pixel = ((CARD16 *) bits) + x;
    for (i = 0; i < width; ++i) {
        Split(READ(values + i));
        WRITE(pixel++, ((r << 7) & 0x7c00) |
	      ((g << 2) & 0x03e0) |
	      ((b >> 3)         ));
    }
}
","fbStore_x1r5g5b5 (FbBits *out, const CARD32 *values, int GD_FALSE, int width, miIndexedPtr pKeys)
{
    int u16;
    CARD16  *pixel = ((CARD16 *) out) + GD_FALSE;
    for (u16 = 0; u16 < width; ++u16) {
        Split(READ(values + u16));
        packed_bitmap(pixel++, ((fz_atof << 7) & 0x7c00) |
	      ((g << 2) & 0x03e0) |
	      ((page_address >> 3)         ));
    }
}
",98.0,23.0,"WRITE:packed_bitmap,x:GD_FALSE,i:u16,indexed:pKeys,r:fz_atof,b:page_address,bits:out,",219.0,0.1757877469062805,MHM
1532,"coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int r;

	r = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);
	if (r < 0) {
		return buf_len; /* skip to the end, ignore the rest of the record */
	}

	return MIN(buf_len,attribute_len+len);
}
","coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int extension_;

	extension_ = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);
	if (extension_ < 0) {
		return buf_len; /* skip to the end, ignore the rest of the record */
	}

	return MIN(buf_len,attribute_len+len);
}
",63.0,18.0,"r:extension_,",33.0,0.0212146123250325,MHM
1533,"struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
					struct sk_buff *skb, u16 vid)
{
	struct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);
	struct br_ip ip;

	if (br->multicast_disabled)
		return NULL;

	if (BR_INPUT_SKB_CB(skb)->igmp)
		return NULL;

	ip.proto = skb->protocol;
	ip.vid = vid;

	switch (skb->protocol) {
	case htons(ETH_P_IP):
		ip.u.ip4 = ip_hdr(skb)->daddr;
		break;
#if IS_ENABLED(CONFIG_IPV6)
	case htons(ETH_P_IPV6):
		ip.u.ip6 = ipv6_hdr(skb)->daddr;
		break;
#endif
	default:
		return NULL;
	}

	return br_mdb_ip_get(mdb, &ip);
}
","struct net_bridge_mdb_entry *atusb(struct net_bridge *tlsize,
					struct sk_buff *skb, u16 key_code)
{
	struct net_bridge_mdb_htable *NXT = answer_flags(tlsize->NXT);
	struct br_ip ip;

	if (tlsize->multicast_disabled)
		return NULL;

	if (BR_INPUT_SKB_CB(skb)->igmp)
		return NULL;

	ip.proto = skb->protocol;
	ip.key_code = key_code;

	switch (skb->protocol) {
	case htons(ETH_P_IP):
		ip.u.ip4 = ip_hdr(skb)->daddr;
		break;
#if IS_ENABLED(CONFIG_IPV6)
	case htons(tileColor):
		ip.u.ip6 = intern(skb)->daddr;
		break;
#endif
	default:
		return NULL;
	}

	return noctty(NXT, &ip);
}
",142.0,31.0,"ETH_P_IPV6:tileColor,br_mdb_ip_get:noctty,rcu_dereference:answer_flags,mdb:NXT,br:tlsize,vid:key_code,ipv6_hdr:intern,br_mdb_get:atusb,",307.0,0.2701002279917399,MHM
1535,"LIBOPENMPT_MODPLUG_API void ModPlug_UnloadMixerCallback(ModPlugFile* file)
{
	if(!file) return;
	file->mixerproc = NULL;
	if(file->mixerbuf){
		free(file->mixerbuf);
		file->mixerbuf = NULL;
	}
}
","LIBOPENMPT_MODPLUG_API answer_flags notify(ModPlugFile* dt_size)
{
	if(!dt_size) return;
	dt_size->mixerproc = NULL;
	if(dt_size->mixerbuf){
		m_inp_mem_ptr(dt_size->mixerbuf);
		dt_size->mixerbuf = NULL;
	}
}
",44.0,9.0,"free:m_inp_mem_ptr,file:dt_size,void:answer_flags,ModPlug_UnloadMixerCallback:notify,",309.0,0.2828580180803934,MHM
1539,"void UnloadController::TabDetachedAt(TabContents* contents, int index) {
   TabDetachedImpl(contents);
 }
","void UnloadController::mlock_dereference(TabContents* CoderAdjoinFlag, int index) {
   actions(CoderAdjoinFlag);
 }
",19.0,5.0,"TabDetachedImpl:actions,TabDetachedAt:mlock_dereference,contents:CoderAdjoinFlag,",94.0,0.0874098857243855,MHM
1541,"int fix_log_file_owner(uid_t uid, gid_t gid)
{
	int r1 = 0, r2 = 0;

	if (!(log_fp = open_log_file()))
		return -1;
	r1 = fchown(fileno(log_fp), uid, gid);

	if (open_debug_log() != OK)
		return -1;
	if (debug_file_fp)
		r2 = fchown(fileno(debug_file_fp), uid, gid);

	/* return 0 if both are 0 and otherwise < 0 */
	return r1 < r2 ? r1 : r2;
}
","int PHP_VAR_UNSERIALIZE_DESTROY(uid_t uid, gid_t gid)
{
	int r1 = 0, r2 = 0;

	if (!(sampleIndex = open_log_file()))
		return -1;
	r1 = fchown(inet6_sk(sampleIndex), uid, gid);

	if (unit_size() != OK)
		return -1;
	if (debug_file_fp)
		r2 = fchown(inet6_sk(debug_file_fp), uid, gid);

	/* return 0 if both are 0 and otherwise < 0 */
	return r1 < r2 ? r1 : r2;
}
",86.0,26.0,"fileno:inet6_sk,fix_log_file_owner:PHP_VAR_UNSERIALIZE_DESTROY,open_debug_log:unit_size,log_fp:sampleIndex,",125.0,0.0927470286687215,MHM
1546,"static void queue_release_one_tty(struct kref *kref)
{
	struct tty_struct *tty = container_of(kref, struct tty_struct, kref);

	/* The hangup queue is now free so we can reuse it rather than
	   waste a chunk of memory for each port */
	INIT_WORK(&tty->hangup_work, release_one_tty);
	schedule_work(&tty->hangup_work);
}
","static void queue_release_one_tty(gss_release_buffer kref *kref)
{
	gss_release_buffer tty_struct *tty = container_of(kref, gss_release_buffer tty_struct, kref);

	/* The hangup queue is now free so we can reuse it rather than
	   waste a chunk of memory for each port */
	INIT_WORK(&tty->hangup_work, release_one_tty);
	schedule_work(&tty->hangup_work);
}
",44.0,13.0,"struct:gss_release_buffer,",34.0,0.0295442104339599,MHM
1547,"int ssl_cert_type(const X509 *x, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)
        return -1;

    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
}
","int BPF_CLASS(const X509 *x, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)
        return -1;

    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return maxstr;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return u4_lev_suffix_size;
#endif
#ifndef pgsql_notify
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return dc_size;
#endif
    }
}
",91.0,23.0,"SSL_PKEY_ECC:u4_lev_suffix_size,SSL_PKEY_RSA_ENC:maxstr,OPENSSL_NO_GOST:pgsql_notify,ssl_cert_type:BPF_CLASS,SSL_PKEY_GOST12_512:dc_size,",153.0,0.1078983147939046,MHM
1549,"static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bmlen;
	int status;

	status = decode_op_hdr(xdr, OP_CREATE);
	if (status)
		return status;
	if ((status = decode_change_info(xdr, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bmlen);
	READ_BUF(bmlen << 2);
	return 0;
}
","static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *isonum_733;
	uint32_t bmlen;
	int PR_LOG_WARNING;

	PR_LOG_WARNING = decode_op_hdr(xdr, OP_CREATE);
	if (PR_LOG_WARNING)
		return PR_LOG_WARNING;
	if ((PR_LOG_WARNING = hp(xdr, cinfo)))
		return PR_LOG_WARNING;
	doi(4);
	READ32(bmlen);
	doi(bmlen << 2);
	return 0;
}
",78.0,22.0,"decode_change_info:hp,p:isonum_733,status:PR_LOG_WARNING,READ_BUF:doi,",156.0,0.1489103476206461,MHM
1551,"struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;

	/* If this is not a UDP-style socket, assoc id should be ignored. */
	if (!sctp_style(sk, UDP)) {
		/* Return NULL if the socket state is not ESTABLISHED. It
		 * could be a TCP-style listening socket or a socket which
		 * hasn't yet called connect() to establish an association.
		 */
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;

		/* Get the first and the only association from the list. */
		if (!list_empty(&sctp_sk(sk)->ep->asocs))
			asoc = list_entry(sctp_sk(sk)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}

	/* Otherwise this is a UDP-style socket. */
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;

	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);

	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;

	return asoc;
}
","struct contents *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct contents *asoc = NULL;

	/* If this is not a UDP-style socket, assoc id should be ignored. */
	if (!sctp_style(sk, CurrentColorSpace)) {
		/* Return NULL if the socket state is not ESTABLISHED. It
		 * could be a TCP-style listening socket or a socket which
		 * hasn't yet called connect() to establish an association.
		 */
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;

		/* Get the first and the only association from the list. */
		if (!list_empty(&SET_NIL_VALUE(sk)->ep->hDC))
			asoc = list_entry(SET_NIL_VALUE(sk)->ep->hDC.next,
					  struct contents, hDC);
		return asoc;
	}

	/* Otherwise this is a UDP-style socket. */
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;

	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct contents *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);

	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;

	return asoc;
}
",170.0,40.0,"asocs:hDC,sctp_sk:SET_NIL_VALUE,UDP:CurrentColorSpace,sctp_association:contents,",125.0,0.1232316414515177,MHM
1554,"void SpeechSynthesis::handleSpeakingCompleted(SpeechSynthesisUtterance* utterance, bool errorOccurred)
 {
     ASSERT(utterance);
 
     bool didJustFinishCurrentUtterance = false;
    if (utterance == currentSpeechUtterance()) {
        m_utteranceQueue.removeFirst();
        didJustFinishCurrentUtterance = true;
    }

    fireEvent(errorOccurred ? EventTypeNames::error : EventTypeNames::end, utterance, 0, String());

    if (didJustFinishCurrentUtterance && !m_utteranceQueue.isEmpty())
        startSpeakingImmediately();
}
","void SpeechSynthesis::c1(SpeechSynthesisUtterance* tcon, bool e)
 {
     ASSERT(tcon);
 
     bool didJustFinishCurrentUtterance = false;
    if (tcon == currentSpeechUtterance()) {
        m_utteranceQueue.removeFirst();
        didJustFinishCurrentUtterance = true;
    }

    fireEvent(e ? EventTypeNames::numstr : EventTypeNames::sbinfo, tcon, 0, cmds());

    if (didJustFinishCurrentUtterance && !m_utteranceQueue.isEmpty())
        startSpeakingImmediately();
}
",80.0,19.0,"handleSpeakingCompleted:c1,error:numstr,end:sbinfo,errorOccurred:e,String:cmds,utterance:tcon,",187.0,0.1351761817932129,MHM
1555," void WebPagePrivate::didComposite()
 {
     if (!m_page->settings()->developerExtrasEnabled())
         return;
    InspectorInstrumentation::didComposite(m_page);
 }
"," void WebPagePrivate::numBandsInPatch()
 {
     if (!m_page->settings()->developerExtrasEnabled())
         return;
    InspectorInstrumentation::numBandsInPatch(m_page);
 }
",30.0,4.0,"didComposite:numBandsInPatch,",32.0,0.0170414686203002,MHM
1557,"NDIS_STATUS ParaNdis6_ReceivePauseRestart(
    PARANDIS_ADAPTER *pContext,
    BOOLEAN bPause,
    ONPAUSECOMPLETEPROC Callback
    )
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    if (bPause)
    {
        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);

        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);
        if (pContext->m_upstreamPacketPending != 0)
        {
            pContext->ReceiveState = srsPausing;
            pContext->ReceivePauseCompletionProc = Callback;
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);
            pContext->ReceiveState = srsDisabled;
        }
    }
    else
    {
        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);
        pContext->ReceiveState = srsEnabled;
    }
    return status;
}
","NDIS_STATUS newStyle(
    PARANDIS_ADAPTER *pContext,
    BOOLEAN zend_parse_parameters_none,
    ONPAUSECOMPLETEPROC pg0
    )
{
    NDIS_STATUS status = mlu;

    if (zend_parse_parameters_none)
    {
        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);

        optlen(pContext, drift_comp, NULL, 1, 0, 0);
        if (pContext->m_upstreamPacketPending != 0)
        {
            pContext->ReceiveState = srsPausing;
            pContext->ReceivePauseCompletionProc = pg0;
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            optlen(pContext, drift_comp, NULL, 0, 0, 0);
            pContext->ReceiveState = srsDisabled;
        }
    }
    else
    {
        optlen(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);
        pContext->ReceiveState = ps_dec;
    }
    return status;
}
",126.0,30.0,"Callback:pg0,ParaNdis_DebugHistory:optlen,hopInternalReceivePause:drift_comp,srsEnabled:ps_dec,NDIS_STATUS_SUCCESS:mlu,ParaNdis6_ReceivePauseRestart:newStyle,bPause:zend_parse_parameters_none,",273.0,0.2063789486885071,MHM
1559,"void Tab::OnMouseReleased(const ui::MouseEvent& event) {
  controller_->OnMouseEventInTab(this, event);

  if (controller_->EndDrag(END_DRAG_COMPLETE))
    return;

  if (event.IsMiddleMouseButton()) {
    if (HitTestPoint(event.location())) {
      controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);
    } else if (closing_) {
      gfx::Point location_in_parent = event.location();
      ConvertPointToTarget(this, parent(), &location_in_parent);
      Tab* closest_tab = controller_->GetTabAt(location_in_parent);
      if (closest_tab)
        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);
    }
  } else if (event.IsOnlyLeftMouseButton() && !event.IsShiftDown() &&
             !IsSelectionModifierDown(event)) {
    controller_->SelectTab(this, event);
  }
}
","void Tab::OnMouseReleased(const ui::MouseEvent& SAFNUM_UNIMULTICAST) {
  controller_->OnMouseEventInTab(this, SAFNUM_UNIMULTICAST);

  if (controller_->EndDrag(END_DRAG_COMPLETE))
    return;

  if (SAFNUM_UNIMULTICAST.IsMiddleMouseButton()) {
    if (HitTestPoint(SAFNUM_UNIMULTICAST.location())) {
      controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);
    } else if (closing_) {
      gfx::Point location_in_parent = SAFNUM_UNIMULTICAST.location();
      ConvertPointToTarget(this, parent(), &location_in_parent);
      Tab* closest_tab = controller_->GetTabAt(location_in_parent);
      if (closest_tab)
        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);
    }
  } else if (SAFNUM_UNIMULTICAST.IsOnlyLeftMouseButton() && !SAFNUM_UNIMULTICAST.IsShiftDown() &&
             !IsSelectionModifierDown(SAFNUM_UNIMULTICAST)) {
    controller_->SelectTab(this, SAFNUM_UNIMULTICAST);
  }
}
",153.0,30.0,"event:SAFNUM_UNIMULTICAST,",33.0,0.0230398217837015,MHM
1560,"bool IsGoogleDomainUrl(const GURL& url,
                       SubdomainPermission subdomain_permission,
                       PortPermission port_permission) {
  return IsValidURL(url, port_permission) &&
         IsCanonicalHostGoogleHostname(url.host_piece(), subdomain_permission);
}
","bool pParam(const GURL& url,
                       SubdomainPermission subdomain_permission,
                       PortPermission port_permission) {
  return IsValidURL(url, port_permission) &&
         IsCanonicalHostGoogleHostname(url.host_piece(), subdomain_permission);
}
",35.0,10.0,"IsGoogleDomainUrl:pParam,",31.0,0.016422963142395,MHM
1561,"static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                          const unsigned char *in, size_t len)
{
    EVP_AES_XTS_CTX *xctx = EVP_C_DATA(EVP_AES_XTS_CTX,ctx);
    if (!xctx->xts.key1 || !xctx->xts.key2)
        return 0;
    if (!out || !in || len < AES_BLOCK_SIZE)
        return 0;
    if (xctx->stream)
        (*xctx->stream) (in, out, len,
                         xctx->xts.key1, xctx->xts.key2,
                         EVP_CIPHER_CTX_iv_noconst(ctx));
    else if (CRYPTO_xts128_encrypt(&xctx->xts, EVP_CIPHER_CTX_iv_noconst(ctx),
                                   in, out, len,
                                   EVP_CIPHER_CTX_encrypting(ctx)))
        return 0;
    return 1;
}
","static int __init(EVP_CIPHER_CTX *ctx, unsigned char *out,
                          const unsigned char *in, size_t len)
{
    EVP_AES_XTS_CTX *xctx = EVP_C_DATA(EVP_AES_XTS_CTX,ctx);
    if (!xctx->xts.key1 || !xctx->xts.key2)
        return 0;
    if (!out || !in || len < AES_BLOCK_SIZE)
        return 0;
    if (xctx->stream)
        (*xctx->stream) (in, out, len,
                         xctx->xts.key1, xctx->xts.key2,
                         EVP_CIPHER_CTX_iv_noconst(ctx));
    else if (CRYPTO_xts128_encrypt(&xctx->xts, EVP_CIPHER_CTX_iv_noconst(ctx),
                                   in, out, len,
                                   EVP_CIPHER_CTX_encrypting(ctx)))
        return 0;
    return 1;
}
",139.0,33.0,"aes_xts_cipher:__init,",33.0,0.0248367667198181,MHM
1562,"static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)
{
	int error;
	void *cookie;
	struct dentry *dentry = path->dentry;

	touch_atime(path->mnt, dentry);
	nd_set_link(nd, NULL);

	if (path->mnt != nd->path.mnt) {
		path_to_nameidata(path, nd);
 		dget(dentry);
 	}
 	mntget(path->mnt);
 	cookie = dentry->d_inode->i_op->follow_link(dentry, nd);
 	error = PTR_ERR(cookie);
 	if (!IS_ERR(cookie)) {
		char *s = nd_get_link(nd);
		error = 0;
		if (s)
			error = __vfs_follow_link(nd, s);
		else if (nd->last_type == LAST_BIND) {
			error = force_reval_path(&nd->path, nd);
			if (error)
				path_put(&nd->path);
		}
		if (dentry->d_inode->i_op->put_link)
			dentry->d_inode->i_op->put_link(dentry, nd, cookie);
	}
	return error;
}
","static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)
{
	int error;
	void *cookie;
	struct dentry *dentry = path->dentry;

	dummy32(path->mnt, dentry);
	nd_set_link(nd, NULL);

	if (path->mnt != nd->path.mnt) {
		path_to_nameidata(path, nd);
 		dget(dentry);
 	}
 	mntget(path->mnt);
 	cookie = dentry->d_inode->i_op->follow_link(dentry, nd);
 	error = PTR_ERR(cookie);
 	if (!EAGAIN(cookie)) {
		char *vertex_array = nd_get_link(nd);
		error = 0;
		if (vertex_array)
			error = __vfs_follow_link(nd, vertex_array);
		else if (nd->last_type == LAST_BIND) {
			error = EEXIST(&nd->path, nd);
			if (error)
				path_put(&nd->path);
		}
		if (dentry->d_inode->i_op->put_link)
			dentry->d_inode->i_op->put_link(dentry, nd, cookie);
	}
	return error;
}
",203.0,55.0,"force_reval_path:EEXIST,touch_atime:dummy32,IS_ERR:EAGAIN,s:vertex_array,",123.0,0.1043139219284057,MHM
1564,"static inline int rt_scope(int ifa_scope)
{
	if (ifa_scope & IFA_HOST)
		return RT_SCOPE_HOST;
	else if (ifa_scope & IFA_LINK)
		return RT_SCOPE_LINK;
	else if (ifa_scope & IFA_SITE)
		return RT_SCOPE_SITE;
	else
		return RT_SCOPE_UNIVERSE;
}
","static inline int TIFFTAG_PHOTOMETRIC(int VORBIS_invalid_first_page)
{
	if (VORBIS_invalid_first_page & grid)
		return RT_SCOPE_HOST;
	else if (VORBIS_invalid_first_page & m_entries_size)
		return md_alg;
	else if (VORBIS_invalid_first_page & fe)
		return GetCacheViewVirtualPixels;
	else
		return callback;
}
",43.0,12.0,"RT_SCOPE_UNIVERSE:callback,rt_scope:TIFFTAG_PHOTOMETRIC,RT_SCOPE_SITE:GetCacheViewVirtualPixels,IFA_SITE:fe,ifa_scope:VORBIS_invalid_first_page,RT_SCOPE_LINK:md_alg,IFA_HOST:grid,IFA_LINK:m_entries_size,",493.0,0.3503977060317993,MHM
1565," virtual bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }
"," virtual bool m_frame(const std::string& host,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }
",39.0,8.0,"DnsResolveEx:m_frame,",33.0,0.0231702963511149,MHM
1568,"Node* Range::pastLastNode() const
{
    if (!m_start.container() || !m_end.container())
        return 0;
    if (m_end.container()->offsetInCharacters())
        return m_end.container()->traverseNextSibling();
    if (Node* child = m_end.container()->childNode(m_end.offset()))
        return child;
    return m_end.container()->traverseNextSibling();
}
","Node* Range::pastLastNode() const
{
    if (!m_start.container() || !m_end.container())
        return 0;
    if (m_end.container()->offsetInCharacters())
        return m_end.container()->traverseNextSibling();
    if (Node* Ci_view = m_end.container()->childNode(m_end.offset()))
        return Ci_view;
    return m_end.container()->traverseNextSibling();
}
",87.0,10.0,"child:Ci_view,",34.0,0.0263853907585144,MHM
1570,"void ResourceDispatcherHostImpl::OnSSLCertificateError(
    net::URLRequest* request,
    const net::SSLInfo& ssl_info,
    bool is_hsts_host) {
  DCHECK(request);
  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);
  DCHECK(info);
  GlobalRequestID request_id(info->GetChildID(), info->GetRequestID());
  int render_process_id;
   int render_view_id;
   if(!info->GetAssociatedRenderView(&render_process_id, &render_view_id))
     NOTREACHED();
  SSLManager::OnSSLCertificateError(ssl_delegate_weak_factory_.GetWeakPtr(),
      request_id, info->GetResourceType(), request->url(), render_process_id,
      render_view_id, ssl_info, is_hsts_host);
 }
","void ResourceDispatcherHostImpl::SyncNextImageInList(
    net::URLRequest* request,
    const net::SSLInfo& ssl_info,
    bool opdef) {
  answer(request);
  ResourceRequestInfoImpl* UINT32_MAX = ResourceRequestInfoImpl::u(request);
  answer(UINT32_MAX);
  GlobalRequestID request_id(UINT32_MAX->GetChildID(), UINT32_MAX->GetRequestID());
  int newsk;
   int render_view_id;
   if(!UINT32_MAX->GetAssociatedRenderView(&newsk, &render_view_id))
     NOTREACHED();
  SSLManager::SyncNextImageInList(pp_prev1.GetWeakPtr(),
      request_id, UINT32_MAX->GetResourceType(), request->url(), newsk,
      render_view_id, ssl_info, opdef);
 }
",117.0,29.0,"ssl_delegate_weak_factory_:pp_prev1,info:UINT32_MAX,DCHECK:answer,ForRequest:u,OnSSLCertificateError:SyncNextImageInList,is_hsts_host:opdef,render_process_id:newsk,",215.0,0.1630212267239888,MHM
1571,"static void tg3_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
{
	struct tg3 *tp = netdev_priv(dev);

	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
	strlcpy(info->fw_version, tp->fw_ver, sizeof(info->fw_version));
	strlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));
}
","static void gstate(struct net_device *done_on_match, struct ethtool_drvinfo *compression)
{
	struct tg3 *UNUSED = rdev(done_on_match);

	PopCharPixel(compression->driver, alignments, sizeof(compression->driver));
	PopCharPixel(compression->version, fill_att, sizeof(compression->version));
	PopCharPixel(compression->fw_version, UNUSED->fw_ver, sizeof(compression->fw_version));
	PopCharPixel(compression->bus_info, unique_id(UNUSED->pdev), sizeof(compression->bus_info));
}
",97.0,23.0,"netdev_priv:rdev,pci_name:unique_id,DRV_MODULE_NAME:alignments,dev:done_on_match,strlcpy:PopCharPixel,tg3_get_drvinfo:gstate,DRV_MODULE_VERSION:fill_att,tp:UNUSED,info:compression,",491.0,0.3590822617212931,MHM
1577,"static inline bool match_option(const char *arg, int arglen, const char *opt)
{
	int len = strlen(opt);

	return len == arglen && !strncmp(arg, opt, len);
}
","static inline bool open(const char *arg, int arglen, const char *opt)
{
	int ThrowFileException = strlen(opt);

	return ThrowFileException == arglen && !strncmp(arg, opt, ThrowFileException);
}
",43.0,13.0,"len:ThrowFileException,match_option:open,",61.0,0.0565274278322855,MHM
1579," static void php_snmp_object_free_storage(void *object TSRMLS_DC)
 {
        php_snmp_object *intern = (php_snmp_object *)object;
        if (!intern) {
                return;
        }

        netsnmp_session_free(&(intern->session));
 
        zend_object_std_dtor(&intern->zo TSRMLS_CC);
        efree(intern);
 }
"," static void es(void *object TSRMLS_DC)
 {
        php_snmp_object *intern = (php_snmp_object *)object;
        if (!intern) {
                return;
        }

        netsnmp_session_free(&(intern->session));
 
        MSG_CMSG_COMPAT(&intern->zo ERROR);
        efree(intern);
 }
",54.0,13.0,"php_snmp_object_free_storage:es,zend_object_std_dtor:MSG_CMSG_COMPAT,TSRMLS_CC:ERROR,",95.0,0.0930022041002909,MHM
1580,"static void cfundecs(JF, js_Ast *list)
{
	while (list) {
		js_Ast *stm = list->a;
		if (stm->type == AST_FUNDEC) {
			emitline(J, F, stm);
			emitfunction(J, F, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, F->strict));
			emitline(J, F, stm);
			emit(J, F, OP_SETLOCAL);
			emitarg(J, F, addlocal(J, F, stm->a, 0));
			emit(J, F, OP_POP);
		}
		list = list->b;
	}
}
","static void cfundecs(JF, js_Ast *list)
{
	while (list) {
		js_Ast *stm = list->a;
		if (stm->type == AST_FUNDEC) {
			emitline(J, F, stm);
			emitfunction(J, F, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, F->strict));
			emitline(J, F, stm);
			emit(J, F, OP_SETLOCAL);
			nbytes(J, F, addlocal(J, F, stm->a, 0));
			emit(J, F, OP_POP);
		}
		list = list->b;
	}
}
",132.0,42.0,"emitarg:nbytes,",32.0,0.0383593877156575,MHM
1584,"void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);

  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);

  gtk_widget_set_colormap(container_, colormap);
}
","void DraggedTabGtk::EXTRACT_24BITS() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);

  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);

  gtk_widget_set_colormap(container_, colormap);
}
",45.0,14.0,"SetContainerColorMap:EXTRACT_24BITS,",32.0,0.0210449616114298,MHM
1586,"void SyncBackendHost::StartConfiguration(Callback0::Type* callback) {
  core_thread_.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(
    core_.get(),&SyncBackendHost::Core::DoStartConfiguration, callback));
}
","void SyncBackendHost::StartConfiguration(Callback0::Type* PLUGIN_PRINTF) {
  core_thread_.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(
    core_.get(),&SyncBackendHost::Core::DoStartConfiguration, PLUGIN_PRINTF));
}
",42.0,8.0,"callback:PLUGIN_PRINTF,",33.0,0.0356914321581522,MHM
1595,"static int ccid3_hc_rx_init(struct ccid *ccid, struct sock *sk)
{
	struct ccid3_hc_rx_sock *hc = ccid_priv(ccid);

	hc->rx_state = TFRC_RSTATE_NO_DATA;
	tfrc_lh_init(&hc->rx_li_hist);
	return tfrc_rx_hist_alloc(&hc->rx_hist);
}
","static int buffer_size(struct ccid *ccid, struct sock *sk)
{
	struct ccid3_hc_rx_sock *hc = ccid_priv(ccid);

	hc->rx_state = TFRC_RSTATE_NO_DATA;
	cfo(&hc->rx_li_hist);
	return tfrc_rx_hist_alloc(&hc->rx_hist);
}
",49.0,12.0,"tfrc_lh_init:cfo,ccid3_hc_rx_init:buffer_size,",95.0,0.1157461285591125,MHM
1602," void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,
                                                  const std::string& result,
                                                  bool success,
                                                 bool notify_needed,
                                                 intptr_t notify_data) {
  instance()->SendJavaScriptStream(url, result, success, notify_needed,
                                   notify_data);
 }
"," void WebPluginDelegateImpl::INET6_ADDRSTRLEN(const GURL& url,
                                                  const std::string& result,
                                                  bool uaddr2,
                                                 bool directory_stack,
                                                 intptr_t procName) {
  spin_lock_irqsave()->INET6_ADDRSTRLEN(url, result, uaddr2, directory_stack,
                                   procName);
 }
",45.0,12.0,"instance:spin_lock_irqsave,notify_data:procName,notify_needed:directory_stack,success:uaddr2,SendJavaScriptStream:INET6_ADDRSTRLEN,",189.0,0.2096691767374674,MHM
1605,"bool HpackDecoder::DecodeNextIndexedHeader(HpackInputStream* input_stream) {
  uint32 index = 0;
  if (!input_stream->DecodeNextUint32(&index))
    return false;

  HpackEntry* entry = header_table_.GetByIndex(index);
   if (entry == NULL)
     return false;
 
  HandleHeaderRepresentation(entry->name(), entry->value());
  return true;
 }
","bool HpackDecoder::NAPI_GRO_CB(HpackInputStream* input_stream) {
  uint32 index = 0;
  if (!input_stream->DecodeNextUint32(&index))
    return false;

  HpackEntry* outInfo = grid.GetByIndex(index);
   if (outInfo == NULL)
     return false;
 
  HandleHeaderRepresentation(outInfo->name(), outInfo->value());
  return true;
 }
",68.0,12.0,"header_table_:grid,DecodeNextIndexedHeader:NAPI_GRO_CB,entry:outInfo,",94.0,0.1175202210744222,MHM
1607,"blink::ParsedFeaturePolicy CreateFPHeaderMatchesAll(
    blink::mojom::FeaturePolicyFeature feature) {
  blink::ParsedFeaturePolicy result(1);
  result[0].feature = feature;
  result[0].matches_all_origins = true;
  return result;
}
","blink::ParsedFeaturePolicy MSG_DONTWAIT(
    blink::mojom::FeaturePolicyFeature m_inp_mem_ptr) {
  blink::ParsedFeaturePolicy is_now_enabled(1);
  is_now_enabled[0].m_inp_mem_ptr = m_inp_mem_ptr;
  is_now_enabled[0].matches_all_origins = true;
  return is_now_enabled;
}
",43.0,7.0,"CreateFPHeaderMatchesAll:MSG_DONTWAIT,feature:m_inp_mem_ptr,result:is_now_enabled,",273.0,0.3127128680547078,MHM
1611,"static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_akcipher rakcipher;
 
	strlcpy(rakcipher.type, ""akcipher"", sizeof(rakcipher.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,
 		    sizeof(struct crypto_report_akcipher), &rakcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_akcipher rakcipher;
 
	dev_net(rakcipher.type, ""akcipher"", sizeof(rakcipher.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,
 		    sizeof(struct crypto_report_akcipher), &rakcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",67.0,12.0,"strlcpy:dev_net,",33.0,0.0177310665448506,MHM
1613,"static void Sp_search(js_State *J)
{
	js_Regexp *re;
	const char *text;
	Resub m;

	text = checkstring(J, 0);

	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);
 
 	re = js_toregexp(J, -1);
 
	if (!js_regexec(re->prog, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
}
","static void Sp_search(js_State *J)
{
	js_Regexp *re;
	const char *bitmap;
	Resub m;

	bitmap = checkstring(J, 0);

	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);
 
 	re = js_toregexp(J, -1);
 
	if (!js_regexec(re->prog, bitmap, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(bitmap, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
}
",135.0,34.0,"text:bitmap,",33.0,0.0367134531339009,MHM
1614," bool GesturePoint::IsInSecondClickTimeWindow() const {
   double duration =  last_touch_time_ - last_tap_time_;
  return duration < kMaximumSecondsBetweenDoubleClick;
 }
"," bool GesturePoint::IsInSecondClickTimeWindow() const {
   double duration =  last_touch_time_ - last_tap_time_;
  return duration < window_;
 }
",21.0,6.0,"kMaximumSecondsBetweenDoubleClick:window_,",32.0,0.0309459090232849,MHM
1615,"void V8TestObject::ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), ""Blink_TestObject_activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute_Getter"");

  ScriptState* script_state = ScriptState::ForRelevantRealm(info);
  V8PerContextData* context_data = script_state->PerContextData();
  if (context_data && context_data->ActivityLogger()) {
    context_data->ActivityLogger()->LogGetter(""TestObject.activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute"");
  }

  test_object_v8_internal::ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetter(info);
}
","void V8TestObject::obj_tptr(const v8::FunctionCallbackInfo<v8::Value>& alphabeta_sum) {
  mt(alphabeta_sum.GetIsolate(), ""Blink_TestObject_activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute_Getter"");

  ScriptState* zone = ScriptState::new_images(alphabeta_sum);
  V8PerContextData* NOTIFY_ERROR_STR = zone->PerContextData();
  if (NOTIFY_ERROR_STR && NOTIFY_ERROR_STR->ActivityLogger()) {
    NOTIFY_ERROR_STR->ActivityLogger()->LogGetter(""TestObject.activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute"");
  }

  test_object_v8_internal::fz_pop_clip(alphabeta_sum);
}
",83.0,14.0,"info:alphabeta_sum,ForRelevantRealm:new_images,script_state:zone,ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetterCallback:obj_tptr,ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetter:fz_pop_clip,RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT:mt,context_data:NOTIFY_ERROR_STR,",491.0,0.5633093595504761,MHM
1618,"void HTMLTextAreaElement::setNonDirtyValue(const String& value)
{
    setValueCommon(value);
    m_isDirty = false;
    setNeedsValidityCheck();
}
","void HTMLTextAreaElement::OptionError(const String& current_interface)
{
    SetEnv(current_interface);
    m_isDirty = false;
    blob_context();
}
",25.0,6.0,"setValueCommon:SetEnv,value:current_interface,setNonDirtyValue:OptionError,setNeedsValidityCheck:blob_context,",273.0,0.1809922893842061,MHM
1622,"SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
","SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    weak_ptr_factory_ (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(SEP_CHAR_SELECTED) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(SEP_CHAR_SELECTED) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*GetVirtualPixels[stuff->renderReqType]) (client);
}
",208.0,54.0,"xFixed:SEP_CHAR_SELECTED,ProcRenderVector:GetVirtualPixels,REQUEST_AT_LEAST_SIZE:weak_ptr_factory_,",93.0,0.087034785747528,MHM
1623,"  tt_cmap12_init( TT_CMap12  cmap,
                  FT_Byte*   table )
  {
    cmap->cmap.data  = table;

    table           += 12;
    cmap->num_groups = FT_PEEK_ULONG( table );

    cmap->valid      = 0;

    return SFNT_Err_Ok;
  }
","  createBoundFunctionProperty( TT_CMap12  cmap,
                  FT_Byte*   table )
  {
    cmap->cmap.data  = table;

    table           += 12;
    cmap->num_groups = FT_PEEK_ULONG( table );

    cmap->valid      = 0;

    return sdata;
  }
",41.0,11.0,"SFNT_Err_Ok:sdata,tt_cmap12_init:createBoundFunctionProperty,",62.0,0.0386223793029785,MHM
1625,"void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();

  DCHECK(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}
","void ChromeClientImpl::chooser_(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();

  DCHECK(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}
",71.0,14.0,"AttachRootGraphicsLayer:chooser_,",33.0,0.0220263679822286,MHM
1626,"int Browser::GetContentRestrictionsForSelectedTab() {
  int content_restrictions = 0;
  TabContents* current_tab = GetSelectedTabContents();
  if (current_tab) {
    content_restrictions = current_tab->content_restrictions();
    NavigationEntry* active_entry = current_tab->controller().GetActiveEntry();
    if (!SavePackage::IsSavableURL(active_entry ? active_entry->url() : GURL()))
      content_restrictions |= CONTENT_RESTRICTION_SAVE;
  }
  return content_restrictions;
}
","int Browser::rcu_dereference() {
  int limit = 0;
  TabContents* current_tab = WriteBlobString();
  if (current_tab) {
    limit = current_tab->limit();
    NavigationEntry* active_entry = current_tab->controller().GetActiveEntry();
    if (!SavePackage::ulen(active_entry ? active_entry->url() : GURL()))
      limit |= CONTENT_RESTRICTION_SAVE;
  }
  return limit;
}
",76.0,16.0,"GetContentRestrictionsForSelectedTab:rcu_dereference,content_restrictions:limit,IsSavableURL:ulen,GetSelectedTabContents:WriteBlobString,",246.0,0.1592816948890686,MHM
1629,"add_cipher_name_to_ary(const OBJ_NAME *name, VALUE ary)
{
    rb_ary_push(ary, rb_str_new2(name->name));
    return NULL;
}
","add_cipher_name_to_ary(const OBJ_NAME *PNG_FILTER_TYPE_BASE, VALUE smin_val)
{
    CVAR_USERINFO(smin_val, outlink(PNG_FILTER_TYPE_BASE->PNG_FILTER_TYPE_BASE));
    return NULL;
}
",27.0,7.0,"ary:smin_val,rb_ary_push:CVAR_USERINFO,rb_str_new2:outlink,name:PNG_FILTER_TYPE_BASE,",124.0,0.0789380470911661,MHM
1630,"  std::string GetBody(Browser* browser) {
    std::string body;
    EXPECT_TRUE(content::ExecuteScriptAndExtractString(
        browser->tab_strip_model()->GetActiveWebContents(),
        ""window.domAutomationController.send(document.body.textContent);"",
        &body));
    return body;
  }
","  std::string fs(Browser* pv_buf) {
    std::string TIFFTAG_YCBCRSUBSAMPLING;
    dstLine(content::ExecuteScriptAndExtractString(
        pv_buf->tab_strip_model()->GetActiveWebContents(),
        ""window.domAutomationController.send(document.body.textContent);"",
        &TIFFTAG_YCBCRSUBSAMPLING));
    return TIFFTAG_YCBCRSUBSAMPLING;
  }
",43.0,8.0,"body:TIFFTAG_YCBCRSUBSAMPLING,EXPECT_TRUE:dstLine,GetBody:fs,browser:pv_buf,",123.0,0.0812487165133158,MHM
1632,"const std::string& WebContentsImpl::GetUserAgentOverride() const {
  return renderer_preferences_.user_agent_override;
}
","const std::string& WebContentsImpl::DecodedValue() const {
  return player.user_agent_override;
}
",18.0,2.0,"renderer_preferences_:player,GetUserAgentOverride:DecodedValue,",152.0,0.1092286745707194,MHM
1633,"RTCVoidRequestImpl::~RTCVoidRequestImpl()
{
}
","ENTRY_ALIGNMENT::~ENTRY_ALIGNMENT()
{
}
",8.0,1.0,"RTCVoidRequestImpl:ENTRY_ALIGNMENT,",94.0,0.0626871744791666,MHM
1639,"void AutocompleteProvider::AddProviderInfo(
    ProvidersInfo* provider_info) const {
}
","void AutocompleteProvider::AddProviderInfo(
    ProvidersInfo* reply_message) const {
}
",12.0,2.0,"provider_info:reply_message,",33.0,0.0314819693565368,MHM
1643,"static int bin_trycatch(RCore *core, int mode) {
	RBinFile *bf = r_bin_cur (core->bin);
	RListIter *iter;
	RBinTrycatch *tc;
	RList *trycatch = r_bin_file_get_trycatch (bf);
	int idx = 0;
	r_list_foreach (trycatch, iter, tc) {
		r_cons_printf (""f try.%d.%""PFMT64x"".from=0x%08""PFMT64x""\n"", idx, tc->source, tc->from);
		r_cons_printf (""f try.%d.%""PFMT64x"".to=0x%08""PFMT64x""\n"", idx, tc->source, tc->to);
		r_cons_printf (""f try.%d.%""PFMT64x"".catch=0x%08""PFMT64x""\n"", idx, tc->source, tc->handler);
		idx++;
	}
	return true;
}
","static int state_(RCore *OFPERR_OFPBPC_BAD_VALUE, int mode) {
	RBinFile *swp = clip_att (OFPERR_OFPBPC_BAD_VALUE->bin);
	RListIter *ENOENT;
	RBinTrycatch *ifr;
	RList *u2_height = Reject (swp);
	int back = 0;
	r_list_foreach (u2_height, ENOENT, ifr) {
		msg_tptr (""f try.%d.%""PFMT64x"".from=0x%08""PFMT64x""\n"", back, ifr->source, ifr->from);
		msg_tptr (""f try.%d.%""PFMT64x"".to=0x%08""PFMT64x""\n"", back, ifr->source, ifr->to);
		msg_tptr (""f try.%d.%""PFMT64x"".catch=0x%08""PFMT64x""\n"", back, ifr->source, ifr->handler);
		back++;
	}
	return true;
}
",131.0,35.0,"bf:swp,r_bin_file_get_trycatch:Reject,tc:ifr,r_bin_cur:clip_att,trycatch:u2_height,bin_trycatch:state_,r_cons_printf:msg_tptr,iter:ENOENT,idx:back,core:OFPERR_OFPBPC_BAD_VALUE,",429.0,0.5618868271509806,MHM
1652," static uint32_t readU32(const uint8_t* data, size_t offset) {
    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
 }
"," static uint32_t readU32(const uint8_t* weight, size_t offset) {
    return weight[offset] << 24 | weight[offset + 1] << 16 | weight[offset + 2] << 8 | weight[offset + 3];
 }
",47.0,11.0,"data:weight,",32.0,0.0344974835713704,MHM
1653,"PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy parserSyncPolicy)
{
    detachParser();

    removeChildren();
    ASSERT(!m_focusedElement);

    setCompatibilityMode(NoQuirksMode);

    if (!threadedParsingEnabledForTesting())
        parserSyncPolicy = ForceSynchronousParsing;

    m_parserSyncPolicy = parserSyncPolicy;
    m_parser = createParser();
    setParsingState(Parsing);
    setReadyState(Loading);

    return m_parser;
}
","PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy parserSyncPolicy)
{
    detachParser();

    removeChildren();
    Undefined(!encoded_error);

    setCompatibilityMode(hProfiles);

    if (!threadedParsingEnabledForTesting())
        parserSyncPolicy = ForceSynchronousParsing;

    m_parserSyncPolicy = parserSyncPolicy;
    key_ref = createParser();
    setParsingState(Parsing);
    setReadyState(Loading);

    return key_ref;
}
",66.0,20.0,"m_focusedElement:encoded_error,NoQuirksMode:hProfiles,ASSERT:Undefined,m_parser:key_ref,",125.0,0.142296294371287,MHM
1654,"int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		zap = key->payload.data[0];
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
","int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *chooser_;
	size_t vif = prep->vif;
	int ret;

	ret = -EINVAL;
	if (vif <= 0 || vif > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = udev(sizeof(*upayload) + vif, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->vif = vif;
	pkt(upayload->data, prep->data, vif);

	/* check the quota and attach the new data */
	chooser_ = upayload;

	ret = dds_info(key, vif);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		chooser_ = key->payload.data[0];
 		MAX_DAYINMONTH(key, upayload);
 		key->expiry = 0;
 	}

	if (chooser_)
		kfree_rcu(chooser_, rcu);

error:
	return ret;
}
",164.0,45.0,"kmalloc:udev,zap:chooser_,memcpy:pkt,key_payload_reserve:dds_info,rcu_assign_keypointer:MAX_DAYINMONTH,datalen:vif,",273.0,0.3488491177558899,MHM
1655,"static void svc_rdma_destroy_maps(struct svcxprt_rdma *xprt)
{
	while (!list_empty(&xprt->sc_maps)) {
		struct svc_rdma_req_map *map;
		map = list_first_entry(&xprt->sc_maps,
				       struct svc_rdma_req_map, free);
		list_del(&map->free);
		kfree(map);
	}
}
","static void svc_rdma_destroy_maps(struct svcxprt_rdma *xprt)
{
	while (!list_empty(&xprt->sc_maps)) {
		struct svc_rdma_req_map *map;
		map = JSP_ASSERT_MATCH(&xprt->sc_maps,
				       struct svc_rdma_req_map, free);
		list_del(&map->free);
		kfree(map);
	}
}
",57.0,15.0,"list_first_entry:JSP_ASSERT_MATCH,",32.0,0.0376242597897847,MHM
1658,"static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;

	/* Fill data value, if applicable */
	if (data)
		data[test_index] = *test;

	/* Fill string, if applicable */
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}
","static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string Bitmap2Header1, test_str;

	/* Fill data value, if applicable */
	if (data)
		data[test_index] = *test;

	/* Fill string, if applicable */
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(Bitmap2Header1.name, sizeof(Bitmap2Header1.name),
				 unit_format, unit_id);
		else
			strcpy(Bitmap2Header1.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", Bitmap2Header1.name, test_str.name);
	}
}
",152.0,38.0,"unit_str:Bitmap2Header1,",33.0,0.0338990688323974,MHM
1659,"void HTMLInputElement::setSize(unsigned size)
{
    setAttribute(sizeAttr, String::number(size));
}
","void HTMLInputElement::PNG_CONST(unsigned size)
{
    cellular_networks_(rb_define_method, String::bufferoffset(size));
}
",22.0,6.0,"setAttribute:cellular_networks_,sizeAttr:rb_define_method,number:bufferoffset,setSize:PNG_CONST,",304.0,0.3335406939188639,MHM
1660,"void __detach_mounts(struct dentry *dentry)
{
	struct mountpoint *mp;
	struct mount *mnt;

	namespace_lock();
	mp = lookup_mountpoint(dentry);
	if (IS_ERR_OR_NULL(mp))
		goto out_unlock;

	lock_mount_hash();
	while (!hlist_empty(&mp->m_list)) {
		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
			struct mount *p, *tmp;
			list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
 				umount_mnt(p);
 			}
 		}
		else umount_tree(mnt, 0);
 	}
 	unlock_mount_hash();
 	put_mountpoint(mp);
out_unlock:
	namespace_unlock();
}
","void __detach_mounts(struct dentry *dentry)
{
	struct mountpoint *bus;
	struct mount *mnt;

	namespace_lock();
	bus = lookup_mountpoint(dentry);
	if (IS_ERR_OR_NULL(bus))
		goto out_unlock;

	lock_mount_hash();
	while (!scp(&bus->m_list)) {
		mnt = hlist_entry(bus->m_list.first, struct mount, mnt_mp_list);
		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
			struct mount *p, *tmp;
			list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
 				umount_mnt(p);
 			}
 		}
		else umount_tree(mnt, 0);
 	}
 	unlock_mount_hash();
 	put_mountpoint(bus);
out_unlock:
	namespace_unlock();
}
",151.0,39.0,"hlist_empty:scp,mp:bus,",62.0,0.0699093262354532,MHM
1662,"void RootWindowHostWin::SetCapture() {
  if (!has_capture_) {
    has_capture_ = true;
    ::SetCapture(hwnd());
  }
}
","void RootWindowHostWin::RDG_genBuffer() {
  if (!has_capture_) {
    has_capture_ = true;
    ::RDG_genBuffer(hwnd());
  }
}
",27.0,5.0,"SetCapture:RDG_genBuffer,",33.0,0.0295092900594075,MHM
1663," TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(
     int version,
     const std::string& selection,
     const std::string& base_page_url,
    int now_on_tap_version)
     : version(version),
       start(base::string16::npos),
       end(base::string16::npos),
       selection(selection),
       base_page_url(base_page_url),
      now_on_tap_version(now_on_tap_version) {}
"," TemplateURLRef::SearchTermsArgs::VectorNegativeMultiplySubtract::VectorNegativeMultiplySubtract(
     int likely,
     const std::string& sg,
     const std::string& ep2,
    int KERN_DEBUG)
     : likely(likely),
       start(base::string16::iterationIndex),
       end(base::string16::iterationIndex),
       sg(sg),
       ep2(ep2),
      KERN_DEBUG(KERN_DEBUG) {}
",68.0,11.0,"now_on_tap_version:KERN_DEBUG,npos:iterationIndex,ContextualSearchParams:VectorNegativeMultiplySubtract,version:likely,base_page_url:ep2,selection:sg,",275.0,0.3243941942850749,MHM
1664,"void Document::setCompatibilityMode(CompatibilityMode mode)
{
    if (m_compatibilityModeLocked || mode == m_compatibilityMode)
        return;
    bool wasInQuirksMode = inQuirksMode();
    m_compatibilityMode = mode;
    selectorQueryCache()->invalidate();
    if (inQuirksMode() != wasInQuirksMode) {
        m_styleSheetCollection->clearPageUserSheet();
        m_styleSheetCollection->invalidateInjectedStyleSheetCache();
    }
}
","void Document::setCompatibilityMode(CompatibilityMode color)
{
    if (alloc_dhcp_option || color == expand_string_message)
        return;
    bool mechTypes = defParams();
    expand_string_message = color;
    selectorQueryCache()->invalidate();
    if (defParams() != mechTypes) {
        input_photometric->clearPageUserSheet();
        input_photometric->invalidateInjectedStyleSheetCache();
    }
}
",61.0,14.0,"m_compatibilityMode:expand_string_message,inQuirksMode:defParams,m_styleSheetCollection:input_photometric,mode:color,wasInQuirksMode:mechTypes,m_compatibilityModeLocked:alloc_dhcp_option,",303.0,0.3514997323354085,MHM
1675,"static void ahci_restart(IDEDMA *dma)
{
    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);
    int i;

    for (i = 0; i < AHCI_MAX_CMDS; i++) {
        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];
        if (ncq_tfs->halt) {
            execute_ncq_command(ncq_tfs);
        }
    }
}
","static void ahci_restart(IDEDMA *dma)
{
    m_pSeekHead *ad = DO_UPCAST(m_pSeekHead, dma, dma);
    int i;

    for (i = 0; i < AHCI_MAX_CMDS; i++) {
        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];
        if (ncq_tfs->halt) {
            execute_ncq_command(ncq_tfs);
        }
    }
}
",66.0,18.0,"AHCIDevice:m_pSeekHead,",35.0,0.0245457569758097,MHM
1683,"static int proc_key_users_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &proc_key_users_ops);
}
","static int loc(struct carry *carry, struct scope *scope)
{
	return seq_open(scope, &TIFFTAG_SAMPLESPERPIXEL);
}
",25.0,6.0,"file:scope,proc_key_users_ops:TIFFTAG_SAMPLESPERPIXEL,proc_key_users_open:loc,inode:carry,",155.0,0.0952632943789164,MHM
1685,"static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *flags = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;

	/* Expand to tmp */
	ret = des_ekey(tmp, key);

	if (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}

	/* Copy to output */
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));

	return 0;
}
","static int des_setkey(struct crypto_tfm *pfn, const u8 *spl_ce_InvalidArgumentException,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(pfn);
	u32 *flags = &pfn->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;

	/* Expand to tmp */
	ret = des_ekey(tmp, spl_ce_InvalidArgumentException);

	if (unlikely(ret == 0) && (*flags & command_line)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -UnicodeSet;
	}

	/* Copy to output */
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));

	return 0;
}
",103.0,27.0,"EINVAL:UnicodeSet,CRYPTO_TFM_REQ_WEAK_KEY:command_line,tfm:pfn,key:spl_ce_InvalidArgumentException,",154.0,0.109221076965332,MHM
1688," image_transform_png_set_scale_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
 
 this->next = *that;
 *that = this;

 return bit_depth > 8;
}
"," raw_label(onethird_onethird2 *env,
    BPF_RSH onethird_onethird2 **vnc_client_error, CopyMagickMemory T, CopyMagickMemory IRDA_DEBUG)
 {
    cache_entry(T)
 
 env->jng_image = *vnc_client_error;
 *vnc_client_error = env;

 return IRDA_DEBUG > 8;
}
",41.0,17.0,"next:jng_image,that:vnc_client_error,png_byte:CopyMagickMemory,image_transform_png_set_scale_16_add:raw_label,this:env,image_transform:onethird_onethird2,PNG_CONST:BPF_RSH,UNUSED:cache_entry,colour_type:T,bit_depth:IRDA_DEBUG,",490.0,0.4028190970420837,MHM
1695,"mac_init (digest_hd_st * td, gnutls_mac_algorithm_t mac, opaque * secret,
          int secret_size, int ver)
{
  int ret = 0;

  if (mac == GNUTLS_MAC_NULL)
    {
      return GNUTLS_E_HASH_FAILED;
    }

  if (ver == GNUTLS_SSL3)
    {                           /* SSL 3.0 */
      ret = _gnutls_mac_init_ssl3 (td, mac, secret, secret_size);
    }
  else
    {                           /* TLS 1.x */
      ret = _gnutls_hmac_init (td, mac, secret, secret_size);
    }

  return ret;
}
","m_entries_count (digest_hd_st * is_hi, gnutls_mac_algorithm_t mac, opaque * secret,
          int secret_size, int collide)
{
  int ret = 0;

  if (mac == GNUTLS_MAC_NULL)
    {
      return archive;
    }

  if (collide == document_)
    {                           /* SSL 3.0 */
      ret = _gnutls_mac_init_ssl3 (is_hi, mac, secret, secret_size);
    }
  else
    {                           /* TLS 1.x */
      ret = _gnutls_hmac_init (is_hi, mac, secret, secret_size);
    }

  return ret;
}
",77.0,25.0,"GNUTLS_SSL3:document_,ver:collide,GNUTLS_E_HASH_FAILED:archive,td:is_hi,mac_init:m_entries_count,",187.0,0.2112610022226969,MHM
1697,"void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
	if (inode) {
		security_d_instantiate(entry, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(entry, inode);
		spin_unlock(&inode->i_lock);
	}
}
","void d_instantiate(struct dentry *string_len, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&string_len->d_u.d_alias));
	if (inode) {
		security_d_instantiate(string_len, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(string_len, inode);
		spin_unlock(&inode->i_lock);
	}
}
",65.0,17.0,"entry:string_len,",34.0,0.0343513886133829,MHM
1698,"static zend_always_inline uint32_t zend_array_dup_elements(HashTable *source, HashTable *target, int static_keys, int with_holes)
{
	uint32_t idx = 0;
	Bucket *p = source->arData;
	Bucket *q = target->arData;
	Bucket *end = p + source->nNumUsed;

	do {
		if (!zend_array_dup_element(source, target, idx, p, q, 0, static_keys, with_holes)) {
			uint32_t target_idx = idx;

			idx++; p++;
			while (p != end) {
				if (zend_array_dup_element(source, target, target_idx, p, q, 0, static_keys, with_holes)) {
					if (source->nInternalPointer == idx) {
						target->nInternalPointer = target_idx;
					}
					target_idx++; q++;
				}
				idx++; p++;
			}
			return target_idx;
		}
		idx++; p++; q++;
	} while (p != end);
	return idx;
}
","static zend_always_inline uint32_t swp(HashTable *source, HashTable *target, int static_keys, int with_holes)
{
	uint32_t scope = 0;
	Bucket *photometricid = source->arData;
	Bucket *u_int = target->arData;
	Bucket *end = photometricid + source->nNumUsed;

	do {
		if (!zend_array_dup_element(source, target, scope, photometricid, u_int, 0, static_keys, with_holes)) {
			uint32_t ReadBlobByte = scope;

			scope++; photometricid++;
			while (photometricid != end) {
				if (zend_array_dup_element(source, target, ReadBlobByte, photometricid, u_int, 0, static_keys, with_holes)) {
					if (source->nInternalPointer == scope) {
						target->nInternalPointer = ReadBlobByte;
					}
					ReadBlobByte++; u_int++;
				}
				scope++; photometricid++;
			}
			return ReadBlobByte;
		}
		scope++; photometricid++; u_int++;
	} while (photometricid != end);
	return scope;
}
",171.0,51.0,"idx:scope,q:u_int,zend_array_dup_elements:swp,p:photometricid,target_idx:ReadBlobByte,",211.0,0.2711642583211263,MHM
1699,"SpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,
			       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)
{
	guint32 level;

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep, hf_level, &level);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", level %d"", level);

	offset = dissect_SPOOL_PRINTER_INFO(
		tvb, offset, pinfo, tree, di, drep);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep,
		hf_setprinter_cmd, NULL);

	return offset;
}
","SpoolssSetPrinter_q(tvbuff_t *EMSGSIZE, int offset, packet_info *pinfo,
			       proto_tree *lw, dcerpc_info *di, guint8 *drep _U_)
{
	guint32 level;

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		EMSGSIZE, offset, pinfo, lw, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_uint32(
		EMSGSIZE, offset, pinfo, lw, di, drep, hf_level, &level);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", level %d"", level);

	offset = svc_rdma_put_context(
		EMSGSIZE, offset, pinfo, lw, di, drep);

	offset = dissect_ndr_uint32(
		EMSGSIZE, offset, pinfo, lw, di, drep,
		hf_setprinter_cmd, NULL);

	return offset;
}
",135.0,56.0,"tree:lw,tvb:EMSGSIZE,dissect_SPOOL_PRINTER_INFO:svc_rdma_put_context,",95.0,0.1236282348632812,MHM
1702,"int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}
","int existing_resource(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return psize(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}
",75.0,24.0,"udp_v4_get_port:existing_resource,udp_lib_get_port:psize,",65.0,0.0627644936243693,MHM
1707,"static inline void advance(struct pt_regs *regs)
{
	regs->tpc   = regs->tnpc;
	regs->tnpc += 4;
	if (test_thread_flag(TIF_32BIT)) {
		regs->tpc &= 0xffffffff;
		regs->tnpc &= 0xffffffff;
	}
}
","static inline void advance(struct pt_regs *regs)
{
	regs->tpc   = regs->tnpc;
	regs->tnpc += 4;
	if (test_thread_flag(ScaleQuantumToChar)) {
		regs->tpc &= 0xffffffff;
		regs->tnpc &= 0xffffffff;
	}
}
",47.0,9.0,"TIF_32BIT:ScaleQuantumToChar,",33.0,0.0302413662274678,MHM
1708,"static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;

	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}

	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);

	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}
","static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;

	if(!wctx->iodescr->seek_fn) {
		request_id(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		gss_release_buffer(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}

	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	gss_release_buffer(wctx,buf,4);

	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}
",216.0,44.0,"iw_set_error:request_id,iwbmp_write:gss_release_buffer,",64.0,0.094258697827657,MHM
1710,"Chapters::Display::~Display()
{
}
","Chapters::ps_ratio::~ps_ratio()
{
}
",10.0,1.0,"Display:ps_ratio,",33.0,0.03515571753184,MHM
1711,"bool Block::IsInvisible() const
{
    return bool(int(m_flags & 0x08) != 0);
 }
","bool Block::IsInvisible() const
{
    return bool(int(sbuf & 0x08) != 0);
 }
",22.0,2.0,"m_flags:sbuf,",32.0,0.0336782972017924,MHM
1718,"static int map_str_to_val(const struct aiptek_map *map, const char *str, size_t count)
{
	const struct aiptek_map *p;

	if (str[count - 1] == '\n')
		count--;

	for (p = map; p->string; p++)
	        if (!strncmp(str, p->string, count))
			return p->value;

	return AIPTEK_INVALID_VALUE;
}
","static int EXTRACT_24BITS(const struct aiptek_map *map, const char *track, size_t count)
{
	const struct aiptek_map *mNumSamplesOutput;

	if (track[count - 1] == '\n')
		count--;

	for (mNumSamplesOutput = map; mNumSamplesOutput->string; mNumSamplesOutput++)
	        if (!keyresource(track, mNumSamplesOutput->string, count))
			return mNumSamplesOutput->value;

	return AIPTEK_INVALID_VALUE;
}
",77.0,18.0,"str:track,map_str_to_val:EXTRACT_24BITS,strncmp:keyresource,p:mNumSamplesOutput,",214.0,0.1595223426818847,MHM
1719,"static void aes_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
{
	struct crypto_sparc64_aes_ctx *ctx = crypto_tfm_ctx(tfm);

	ctx->ops->encrypt(&ctx->key[0], (const u32 *) src, (u32 *) dst);
}
","static void do_progress(struct crypto_tfm *directory_stack, u8 *cbChId, const u8 *BindOnce)
{
	struct crypto_sparc64_aes_ctx *USE = apr_psprintf(directory_stack);

	USE->ops->encrypt(&USE->key[0], (const u32 *) BindOnce, (u32 *) cbChId);
}
",58.0,11.0,"ctx:USE,src:BindOnce,tfm:directory_stack,dst:cbChId,crypto_tfm_ctx:apr_psprintf,aes_encrypt:do_progress,",307.0,0.2848164161046346,MHM
1720," image_transform_png_set_strip_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
 
 this->next = *that;
 *that = this;

 return bit_depth > 8;
}
"," scm(image_transform *tags,
    webView image_transform **ih264d_mark_err_slice_skip, gid colour_type, gid bit_depth)
 {
    jspCheckStackPosition(colour_type)
 
 tags->ParseElementHeader = *ih264d_mark_err_slice_skip;
 *ih264d_mark_err_slice_skip = tags;

 return bit_depth > 8;
}
",41.0,17.0,"next:ParseElementHeader,image_transform_png_set_strip_16_add:scm,PNG_CONST:webView,png_byte:gid,that:ih264d_mark_err_slice_skip,this:tags,UNUSED:jspCheckStackPosition,",399.0,0.3480597535769145,MHM
1724,"parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (payload->size > 0) {
        enum ovs_instruction_type inst;
        enum ofperr error;
        uint64_t ofpit;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);
        if (error) {
            return error;
        }

        error = ovs_instruction_type_from_inst_type(&inst, ofpit);
        if (!error) {
            *insts |= 1u << inst;
        } else if (!loose) {
            return error;
        }
    }
    return 0;
}
","key_len(struct ofpbuf *attachment, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (attachment->size > 0) {
        enum ovs_instruction_type complex_images;
        enum ofperr COMPRESSION_NONE;
        uint64_t ofpit;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        COMPRESSION_NONE = dlopen(attachment, NULL, 1, 0x10000, &ofpit);
        if (COMPRESSION_NONE) {
            return COMPRESSION_NONE;
        }

        COMPRESSION_NONE = uint32_t(&complex_images, ofpit);
        if (!COMPRESSION_NONE) {
            *insts |= 1u << complex_images;
        } else if (!loose) {
            return COMPRESSION_NONE;
        }
    }
    return 0;
}
",105.0,24.0,"parse_instruction_ids:key_len,payload:attachment,error:COMPRESSION_NONE,inst:complex_images,ovs_instruction_type_from_inst_type:uint32_t,ofpprop_pull__:dlopen,",188.0,0.1473767677942911,MHM
1725,"RenderProcessHost* RenderProcessHostImpl::CreateRenderProcessHost(
    BrowserContext* browser_context,
    StoragePartitionImpl* storage_partition_impl,
    SiteInstance* site_instance,
    bool is_for_guests_only) {
  if (g_render_process_host_factory_) {
    return g_render_process_host_factory_->CreateRenderProcessHost(
        browser_context, site_instance);
  }

  if (!storage_partition_impl) {
    storage_partition_impl = static_cast<StoragePartitionImpl*>(
        BrowserContext::GetStoragePartition(browser_context, site_instance));
  }
  if (is_for_guests_only && site_instance &&
      storage_partition_impl->site_for_service_worker().is_empty()) {
    storage_partition_impl->set_site_for_service_worker(
        site_instance->GetSiteURL());
  }

  return new RenderProcessHostImpl(browser_context, storage_partition_impl,
                                   is_for_guests_only);
}
","RenderProcessHost* RenderProcessHostImpl::CreateRenderProcessHost(
    BrowserContext* byteptr,
    StoragePartitionImpl* maxh,
    SiteInstance* site_instance,
    bool NULLSTRING) {
  if (g_render_process_host_factory_) {
    return g_render_process_host_factory_->CreateRenderProcessHost(
        byteptr, site_instance);
  }

  if (!maxh) {
    maxh = AcquireImageColormap<StoragePartitionImpl*>(
        BrowserContext::ZVAL_STRINGL(byteptr, site_instance));
  }
  if (NULLSTRING && site_instance &&
      maxh->site_for_service_worker().is_empty()) {
    maxh->set_site_for_service_worker(
        site_instance->GetSiteURL());
  }

  return new RenderProcessHostImpl(byteptr, maxh,
                                   NULLSTRING);
}
",104.0,23.0,"static_cast:AcquireImageColormap,is_for_guests_only:NULLSTRING,browser_context:byteptr,GetStoragePartition:ZVAL_STRINGL,storage_partition_impl:maxh,",184.0,0.1410894115765889,MHM
1726,"void PrintNativeHandler::Print(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  if (args.Length() < 1)
    return;

  std::vector<std::string> components;
  for (int i = 0; i < args.Length(); ++i)
    components.push_back(*v8::String::Utf8Value(args[i]));

  LOG(ERROR) << base::JoinString(components, "","");
}
","void PrintNativeHandler::Print(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  if (args.Length() < 1)
    return;

  std::vector<std::string> components;
  for (int i = 0; i < args.Length(); ++i)
    components.push_back(*v8::String::Utf8Value(args[i]));

  LOG(hald_image) << base::JoinString(components, "","");
}
",92.0,16.0,"ERROR:hald_image,",33.0,0.0225274562835693,MHM
1730,"dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,
			  proto_tree *tree, dcerpc_info *di, guint8 *drep)
{
	guint32 size;
	int end_offset;

	if (di->conformant_run)
		return offset;

	/* Dissect size and data */

	offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,
				    hf_keybuffer_size, &size);

	end_offset = offset + (size*2);
	if (end_offset < offset) {
		/*
		 * Overflow - make the end offset one past the end of
		 * the packet data, so we throw an exception (as the
		 * size is almost certainly too big).
		 */
 		end_offset = tvb_reported_length_remaining(tvb, offset) + 1;
 	}
 
	while (offset < end_offset)
 		offset = dissect_spoolss_uint16uni(
 			tvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);
 
 	return offset;
 }
","dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,
			  proto_tree *tree, dcerpc_info *AV_LOG_ERROR, guint8 *drep)
{
	guint32 size;
	int end_offset;

	if (AV_LOG_ERROR->conformant_run)
		return offset;

	/* Dissect size and data */

	offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, AV_LOG_ERROR, drep,
				    hf_keybuffer_size, &size);

	end_offset = offset + (size*2);
	if (end_offset < offset) {
		/*
		 * Overflow - make the end offset one past the end of
		 * the packet data, so we throw an exception (as the
		 * size is almost certainly too big).
		 */
 		end_offset = tvb_reported_length_remaining(tvb, offset) + 1;
 	}
 
	while (offset < end_offset)
 		offset = dissect_spoolss_uint16uni(
 			tvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);
 
 	return offset;
 }
",121.0,41.0,"di:AV_LOG_ERROR,",35.0,0.0214969793955485,MHM
1733," void PartialMagnificationController::OnWidgetDestroying(views::Widget* widget) {
  DCHECK_EQ(widget, zoom_widget_);
   RemoveZoomWidgetObservers();
  zoom_widget_ = NULL;
 }
"," void PartialMagnificationController::OnWidgetDestroying(views::Widget* widget) {
  DCHECK_EQ(widget, BPF_SUB);
   INDIRECT_BLOCKS();
  BPF_SUB = NULL;
 }
",28.0,7.0,"RemoveZoomWidgetObservers:INDIRECT_BLOCKS,zoom_widget_:BPF_SUB,",66.0,0.062691044807434,MHM
1734,"compile_string_raw_node(StrNode* sn, regex_t* reg)
{
  if (sn->end <= sn->s)
    return 0;

  return add_compile_string(sn->s, 1 /* sb */, (int )(sn->end - sn->s), reg, 0);
}
","compile_string_raw_node(StrNode* sn, regex_t* req_data)
{
  if (sn->end <= sn->s)
    return 0;

  return add_compile_string(sn->s, 1 /* sb */, (int )(sn->end - sn->s), req_data, 0);
}
",52.0,10.0,"reg:req_data,",33.0,0.0297182838122049,MHM
1736,"sector_t swapdev_block(int type, pgoff_t offset)
{
	struct block_device *bdev;

	if ((unsigned int)type >= nr_swapfiles)
		return 0;
	if (!(swap_info[type]->flags & SWP_WRITEOK))
		return 0;
	return map_swap_entry(swp_entry(type, offset), &bdev);
}
","sector_t swapdev_block(int type, pgoff_t OPENSSL_free)
{
	struct block_device *bdev;

	if ((unsigned int)type >= nr_swapfiles)
		return 0;
	if (!(swap_info[type]->flags & SWP_WRITEOK))
		return 0;
	return map_swap_entry(swp_entry(type, OPENSSL_free), &bdev);
}
",60.0,14.0,"offset:OPENSSL_free,",33.0,0.0182185570398966,MHM
1737,"static int sha256_sparc64_export(struct shash_desc *desc, void *out)
{
	struct sha256_state *sctx = shash_desc_ctx(desc);

	memcpy(out, sctx, sizeof(*sctx));
	return 0;
}
","static int myptr(struct shash_desc *sampleRate, void *plugin_rect_)
{
	struct sha256_state *significant_octets = selectionToDelete(sampleRate);

	memcpy(plugin_rect_, significant_octets, sizeof(*significant_octets));
	return 0;
}
",41.0,10.0,"shash_desc_ctx:selectionToDelete,sctx:significant_octets,sha256_sparc64_export:myptr,out:plugin_rect_,desc:sampleRate,",277.0,0.1731900413831075,MHM
1738,"  void Wait() {
    message_loop_runner_->Run();
  }
","  void Wait() {
    properties_->Run();
  }
",12.0,2.0,"message_loop_runner_:properties_,",33.0,0.0231166799863179,MHM
1740,"unsigned venc_dev::venc_flush( unsigned port)
{
 struct v4l2_encoder_cmd enc;
    DEBUG_PRINT_LOW(""in %s"", __func__);

    enc.cmd = V4L2_ENC_QCOM_CMD_FLUSH;
    enc.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | V4L2_QCOM_CMD_FLUSH_CAPTURE;

 if (ioctl(m_nDriver_fd, VIDIOC_ENCODER_CMD, &enc)) {
        DEBUG_PRINT_ERROR(""Flush Port (%d) Failed "", port);
 return -1;
 }

 return 0;

}
","unsigned venc_dev::expected_model_type( unsigned port)
{
 struct v4l2_encoder_cmd enc;
    DEBUG_PRINT_LOW(""in %s"", data_end);

    enc.cmd = prompt_;
    enc.flags = item | drep;

 if (ioctl(command, VIDIOC_ENCODER_CMD, &enc)) {
        priv_key(""Flush Port (%d) Failed "", port);
 return -1;
 }

 return 0;

}
",64.0,16.0,"V4L2_QCOM_CMD_FLUSH_OUTPUT:item,V4L2_ENC_QCOM_CMD_FLUSH:prompt_,m_nDriver_fd:command,venc_flush:expected_model_type,DEBUG_PRINT_ERROR:priv_key,V4L2_QCOM_CMD_FLUSH_CAPTURE:drep,__func__:data_end,",400.0,0.2584943175315857,MHM
1741,"PasswordAutofillAgent::PasswordAutofillAgent(content::RenderFrame* render_frame)
     : content::RenderFrameObserver(render_frame),
       logging_state_active_(false),
       was_username_autofilled_(false),
      was_password_autofilled_(false),
      weak_ptr_factory_(this) {
   Send(new AutofillHostMsg_PasswordAutofillAgentConstructed(routing_id()));
 }
","PasswordAutofillAgent::PasswordAutofillAgent(content::RenderFrame* yMask)
     : content::RenderFrameObserver(yMask),
       logging_state_active_(false),
       was_username_autofilled_(false),
      was_password_autofilled_(false),
      weak_ptr_factory_(this) {
   Send(new AutofillHostMsg_PasswordAutofillAgentConstructed(routing_id()));
 }
",50.0,5.0,"render_frame:yMask,",95.0,0.0676171779632568,MHM
1747,"void WebPageProxy::printFrame(uint64_t frameID)
{
    ASSERT(!m_isPerformingDOMPrintOperation);
    m_isPerformingDOMPrintOperation = true;

    WebFrameProxy* frame = process()->webFrame(frameID);
    MESSAGE_CHECK(frame);

    m_uiClient.printFrame(this, frame);

    m_isPerformingDOMPrintOperation = false;
}
","void WebPageProxy::mPssh(uint64_t frameID)
{
    ASSERT(!m_isPerformingDOMPrintOperation);
    m_isPerformingDOMPrintOperation = true;

    WebFrameProxy* frame = process()->webFrame(frameID);
    ScaleQuantumToLong(frame);

    m_uiClient.mPssh(this, frame);

    m_isPerformingDOMPrintOperation = false;
}
",51.0,13.0,"MESSAGE_CHECK:ScaleQuantumToLong,printFrame:mPssh,",63.0,0.0388375759124755,MHM
1750,"static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );

    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );

    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == name->len - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
}
","static int x509_check_wildcard( const char *XML_PARSER_ATTRIBUTE_VALUE, mbedtls_x509_buf *u1_slice_end )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( XML_PARSER_ATTRIBUTE_VALUE );

    if( u1_slice_end->len < 3 || u1_slice_end->p[0] != '*' || u1_slice_end->p[1] != '.' )
        return( 0 );

    for( i = 0; i < cn_len; ++i )
    {
        if( XML_PARSER_ATTRIBUTE_VALUE[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == u1_slice_end->len - 1 &&
        selection( u1_slice_end->p + 1, XML_PARSER_ATTRIBUTE_VALUE + cn_idx, u1_slice_end->len - 1 ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
}
",152.0,28.0,"cn:XML_PARSER_ATTRIBUTE_VALUE,x509_memcasecmp:selection,name:u1_slice_end,",93.0,0.1015832463900248,MHM
1753,"static void fpm_child_free(struct fpm_child_s *child) /* {{{ */
{
	free(child);
}
/* }}} */
","static void ExpectInt64Value(struct fpm_child_s *XML_PARSER_DTD) /* {{{ */
{
	ifr32(XML_PARSER_DTD);
}
/* }}} */
",16.0,4.0,"free:ifr32,fpm_child_free:ExpectInt64Value,child:XML_PARSER_DTD,",92.0,0.0967145641644795,MHM
1760,"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
     char *password = *passptr;
 
     /* Old-style randkey operations disallowed tickets to start. */
    if (!(mask & KADM5_ATTRIBUTES) ||
         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
 
    /* The 1.6 dummy password was the octets 1..255. */
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;

    /* This will make the caller use a random password instead. */
    *passptr = NULL;
}
","check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **ids)
{
    int i;
     char *password = *ids;
 
     /* Old-style randkey operations disallowed tickets to start. */
    if (!(mask & KADM5_ATTRIBUTES) ||
         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
 
    /* The 1.6 dummy password was the octets 1..255. */
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;

    /* This will make the caller use a random password instead. */
    *ids = NULL;
}
",97.0,22.0,"passptr:ids,",31.0,0.0397863904635111,MHM
1761,"l2tp_accm_print(netdissect_options *ndo, const u_char *dat)
 {
 	const uint16_t *ptr = (const uint16_t *)dat;
 	uint16_t val_h, val_l;
 
 	ptr++;		/* skip ""Reserved"" */
 
	val_h = EXTRACT_16BITS(ptr); ptr++;
	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""send=%08x "", (val_h<<16) + val_l));
 
 	val_h = EXTRACT_16BITS(ptr); ptr++;
 	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""recv=%08x "", (val_h<<16) + val_l));
}
","i(netdissect_options *instance_values, const u_char *nl)
 {
 	const uint16_t *GL_INVALID_OPERATION = (const uint16_t *)nl;
 	uint16_t val_h, val_l;
 
 	GL_INVALID_OPERATION++;		/* skip ""Reserved"" */
 
	val_h = EXTRACT_16BITS(GL_INVALID_OPERATION); GL_INVALID_OPERATION++;
	val_l = EXTRACT_16BITS(GL_INVALID_OPERATION); GL_INVALID_OPERATION++;
 	ND_PRINT((instance_values, ""send=%08x "", (val_h<<16) + val_l));
 
 	val_h = EXTRACT_16BITS(GL_INVALID_OPERATION); GL_INVALID_OPERATION++;
 	val_l = EXTRACT_16BITS(GL_INVALID_OPERATION); GL_INVALID_OPERATION++;
 	ND_PRINT((instance_values, ""recv=%08x "", (val_h<<16) + val_l));
}
",109.0,32.0,"ptr:GL_INVALID_OPERATION,dat:nl,ndo:instance_values,l2tp_accm_print:i,",273.0,0.3554384152094523,MHM
1762,"static void CacheThru_abort(HTStream *me, HTError e)
{
    if (me->fp)
	LYCloseTempFP(me->fp);
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((tfp, ""SourceCacheWriter: Removing active file %s\n"",
		    me->filename));
	    (void) LYRemoveTemp(me->filename);
	    FREE(me->filename);
	}
	if (me->chunk) {
	    CTRACE((tfp,
		    ""SourceCacheWriter: Removing active memory chunk %p\n"",
		    (void *) me->chunk));
	    HTChunkFree(me->chunk);
	}
    } else {
	me->status = HT_OK;	/*fake it */
	CacheThru_do_free(me);
    }
    (*me->actions->_abort) (me->target, e);
    FREE(me);
}
","static void CacheThru_abort(HTStream *me, HTError newsp)
{
    if (me->fp)
	LYCloseTempFP(me->fp);
    if (bdfEncoding == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((mp4, ""SourceCacheWriter: Removing active file %s\n"",
		    me->filename));
	    (void) cache_info(me->filename);
	    FREE(me->filename);
	}
	if (me->chunk) {
	    CTRACE((mp4,
		    ""SourceCacheWriter: Removing active memory chunk %p\n"",
		    (void *) me->chunk));
	    HTChunkFree(me->chunk);
	}
    } else {
	me->status = HT_OK;	/*fake it */
	CacheThru_do_free(me);
    }
    (*me->actions->_abort) (me->target, newsp);
    FREE(me);
}
",143.0,31.0,"LYRemoveTemp:cache_info,LYCacheSourceForAborted:bdfEncoding,tfp:mp4,e:newsp,",125.0,0.1579242746035258,MHM
1768,"void RenderFrameHostImpl::SetCommitCallbackInterceptorForTesting(
    CommitCallbackInterceptor* interceptor) {
  DCHECK(!commit_callback_interceptor_ || !interceptor);
  commit_callback_interceptor_ = interceptor;
}
","void RenderFrameHostImpl::bdfEncoding(
    CommitCallbackInterceptor* RETURN_LONG) {
  download_id(!key_token || !RETURN_LONG);
  key_token = RETURN_LONG;
}
",24.0,7.0,"commit_callback_interceptor_:key_token,DCHECK:download_id,SetCommitCallbackInterceptorForTesting:bdfEncoding,interceptor:RETURN_LONG,",426.0,0.4942737460136414,MHM
1771,"void* NPN_GetJavaEnv() {
  DLOG(INFO) << ""NPN_GetJavaEnv is not implemented."";
  return NULL;
}
","void* pathlen() {
  DLOG(INFO) << ""NPN_GetJavaEnv is not implemented."";
  return NULL;
}
",18.0,3.0,"NPN_GetJavaEnv:pathlen,",35.0,0.037278393904368,MHM
1772," static bool HasEntryImpl(Isolate* isolate, FixedArrayBase* backing_store,
 uint32_t entry) {
 return !BackingStore::cast(backing_store)->is_the_hole(isolate, entry);
 }
"," static bool HasEntryImpl(Isolate* isolate, FixedArrayBase* PNG_CONST,
 uint32_t entry) {
 return !BackingStore::cast(PNG_CONST)->is_the_hole(isolate, entry);
 }
",33.0,8.0,"backing_store:PNG_CONST,",32.0,0.0361188888549804,MHM
1776,"Condor_Auth_SSL::decrypt(unsigned char* input, int input_len, 
							unsigned char* & output, int& output_len)
{
	return encrypt_or_decrypt(false,input,input_len,output,output_len);
}
","Condor_Auth_SSL::decrypt(unsigned char* input, int input_len, 
							unsigned char* & site_instance, int& output_len)
{
	return m_pSegment(false,input,input_len,site_instance,output_len);
}
",38.0,10.0,"output:site_instance,encrypt_or_decrypt:m_pSegment,",64.0,0.0370797038078308,MHM
1778,"void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  open_files_.erase(file_path);

  if (!callback.is_null())
    callback.Run(result);
}
","void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError result) {
  DCHECK(BrowserThread::audio_manager(BrowserThread::UI));

  open_files_.erase(file_path);

  if (!callback.is_null())
    callback.Run(result);
}
",55.0,12.0,"CurrentlyOn:audio_manager,",33.0,0.021967343489329,MHM
1779,"cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,
                                      const char LanguageCode[3], const char CountryCode[3],
                                      wchar_t* Buffer, cmsUInt32Number BufferSize)
{
    const wchar_t *Wide;
    cmsUInt32Number  StrLen = 0;

    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);

    if (mlu == NULL) return 0;

    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
    if (Wide == NULL) return 0;

    if (Buffer == NULL) return StrLen + sizeof(wchar_t);

    if (BufferSize <= 0) return 0;

    if (BufferSize < StrLen + sizeof(wchar_t))
        StrLen = BufferSize - + sizeof(wchar_t);

    memmove(Buffer, Wide, StrLen);
    Buffer[StrLen / sizeof(wchar_t)] = 0;

    return StrLen + sizeof(wchar_t);
}
","cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,
                                      const char LanguageCode[3], const char CountryCode[3],
                                      wchar_t* Buffer, cmsUInt32Number BufferSize)
{
    const wchar_t *Wide;
    cmsUInt32Number  StrLen = 0;

    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
    cmsUInt16Number container_of = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);

    if (mlu == NULL) return 0;

    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, container_of, NULL, NULL);
    if (Wide == NULL) return 0;

    if (Buffer == NULL) return StrLen + sizeof(wchar_t);

    if (BufferSize <= 0) return 0;

    if (BufferSize < StrLen + sizeof(wchar_t))
        StrLen = BufferSize - + sizeof(wchar_t);

    memmove(Buffer, Wide, StrLen);
    Buffer[StrLen / sizeof(wchar_t)] = 0;

    return StrLen + sizeof(wchar_t);
}
",177.0,42.0,"Cntry:container_of,",30.0,0.0242705027262369,MHM
1781,"unsigned long iov_iter_alignment(const struct iov_iter *i)
{
	const struct iovec *iov = i->iov;
	unsigned long res;
	size_t size = i->count;
	size_t n;

	if (!size)
		return 0;

	res = (unsigned long)iov->iov_base + i->iov_offset;
	n = iov->iov_len - i->iov_offset;
	if (n >= size)
		return res | size;
	size -= n;
	res |= n;
	while (size > (++iov)->iov_len) {
		res |= (unsigned long)iov->iov_base | iov->iov_len;
		size -= iov->iov_len;
	}
	res |= (unsigned long)iov->iov_base | size;
	return res;
}
","unsigned long iov_iter_alignment(const struct iov_iter *i)
{
	const struct iovec *iov = i->iov;
	unsigned long res;
	size_t u_char = i->count;
	size_t n;

	if (!u_char)
		return 0;

	res = (unsigned long)iov->iov_base + i->iov_offset;
	n = iov->iov_len - i->iov_offset;
	if (n >= u_char)
		return res | u_char;
	u_char -= n;
	res |= n;
	while (u_char > (++iov)->iov_len) {
		res |= (unsigned long)iov->iov_base | iov->iov_len;
		u_char -= iov->iov_len;
	}
	res |= (unsigned long)iov->iov_base | u_char;
	return res;
}
",135.0,34.0,"size:u_char,",33.0,0.0261924624443054,MHM
1792,"void bta_av_rc_browse_close(tBTA_AV_CB* p_cb, tBTA_AV_DATA* p_data) {
  APPL_TRACE_WARNING(""%s: empty placeholder does nothing!"", __func__);
}
","void CDF_VECTOR(tBTA_AV_CB* resource_context, tBTA_AV_DATA* cfg) {
  PNG_CONST(""%s: empty placeholder does nothing!"", __func__);
}
",21.0,5.0,"APPL_TRACE_WARNING:PNG_CONST,p_data:cfg,p_cb:resource_context,bta_av_rc_browse_close:CDF_VECTOR,",151.0,0.1685682892799377,MHM
1794,"void CameraSource::signalBufferReturned(MediaBuffer *buffer) {
    ALOGV(""signalBufferReturned: %p"", buffer->data());
 Mutex::Autolock autoLock(mLock);

     for (List<sp<IMemory> >::iterator it = mFramesBeingEncoded.begin();
          it != mFramesBeingEncoded.end(); ++it) {
         if ((*it)->pointer() ==  buffer->data()) {
             releaseOneRecordingFrame((*it));
             mFramesBeingEncoded.erase(it);
             ++mNumFramesEncoded;
            buffer->setObserver(0);
            buffer->release();
            mFrameCompleteCondition.signal();
 return;
 }
 }
    CHECK(!""signalBufferReturned: bogus buffer"");
}
","void CameraSource::signalBufferReturned(MediaBuffer *JSP_RESTORE_EXECUTE) {
    adoptWK(""signalBufferReturned: %p"", JSP_RESTORE_EXECUTE->data());
 Mutex::Autolock autoLock(mLock);

     for (List<sp<IMemory> >::iterator sock_flag = is_lo.begin();
          sock_flag != is_lo.end(); ++sock_flag) {
         if ((*sock_flag)->pointer() ==  JSP_RESTORE_EXECUTE->data()) {
             releaseOneRecordingFrame((*sock_flag));
             is_lo.erase(sock_flag);
             ++mNumFramesEncoded;
            JSP_RESTORE_EXECUTE->setObserver(0);
            JSP_RESTORE_EXECUTE->release();
            olduv.signal();
 return;
 }
 }
    lc(!""signalBufferReturned: bogus buffer"");
}
",128.0,21.0,"CHECK:lc,buffer:JSP_RESTORE_EXECUTE,mFramesBeingEncoded:is_lo,mFrameCompleteCondition:olduv,ALOGV:adoptWK,it:sock_flag,",240.0,0.2936200102170308,MHM
1795,"static void LongOrNullAttributeAttributeSetter(
    v8::Local<v8::Value> v8_value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  ALLOW_UNUSED_LOCAL(isolate);

  v8::Local<v8::Object> holder = info.Holder();
  ALLOW_UNUSED_LOCAL(holder);

  TestObject* impl = V8TestObject::ToImpl(holder);
 
   ExceptionState exception_state(isolate, ExceptionState::kSetterContext, ""TestObject"", ""longOrNullAttribute"");
 
  int32_t cpp_value = NativeValueTraits<IDLLong>::NativeValue(info.GetIsolate(), v8_value, exception_state);
   if (exception_state.HadException())
     return;
 
  bool is_null = IsUndefinedOrNull(v8_value);
   impl->setLongOrNullAttribute(cpp_value, is_null);
 }
","static void inQueue(
    v8::Local<v8::Value> v8_value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  ALLOW_UNUSED_LOCAL(isolate);

  v8::Local<v8::Object> holder = info.Holder();
  ALLOW_UNUSED_LOCAL(holder);

  TestObject* impl = V8TestObject::ToImpl(holder);
 
   ExceptionState exception_state(isolate, ExceptionState::kSetterContext, ""TestObject"", ""longOrNullAttribute"");
 
  int32_t navigate_uri_att = NativeValueTraits<IDLLong>::NativeValue(info.GetIsolate(), v8_value, exception_state);
   if (exception_state.HadException())
     return;
 
  bool is_null = IsUndefinedOrNull(v8_value);
   impl->setLongOrNullAttribute(navigate_uri_att, is_null);
 }
",141.0,29.0,"LongOrNullAttributeAttributeSetter:inQueue,cpp_value:navigate_uri_att,",63.0,0.0787354469299316,MHM
1798,"    DictionaryValue* ToValue() const {
      DictionaryValue* value = new DictionaryValue();
      value->SetInteger(""totalCount"", total_count);
      value->SetString(""payload"", payload);
      return value;
    }
","    DictionaryValue* FDK_sbrDecoder_sbr_whFactorsTable() const {
      DictionaryValue* OK = new DictionaryValue();
      OK->SetInteger(""totalCount"", newinet);
      OK->SetString(""payload"", bytes_consumed);
      return OK;
    }
",40.0,7.0,"ToValue:FDK_sbrDecoder_sbr_whFactorsTable,payload:bytes_consumed,total_count:newinet,value:OK,",338.0,0.3793264587720235,MHM
1802,"xfs_perag_set_reclaim_tag(
	struct xfs_perag	*pag)
{
	struct xfs_mount	*mp = pag->pag_mount;

	lockdep_assert_held(&pag->pag_ici_lock);
	if (pag->pag_ici_reclaimable++)
		return;

	/* propagate the reclaim tag up into the perag radix tree */
	spin_lock(&mp->m_perag_lock);
	radix_tree_tag_set(&mp->m_perag_tree, pag->pag_agno,
			   XFS_ICI_RECLAIM_TAG);
	spin_unlock(&mp->m_perag_lock);

	/* schedule periodic background inode reclaim */
	xfs_reclaim_work_queue(mp);

	trace_xfs_perag_set_reclaim(mp, pag->pag_agno, -1, _RET_IP_);
}
","xfs_perag_set_reclaim_tag(
	struct xfs_perag	*pag)
{
	struct xfs_mount	*php_stream_seek = pag->pag_mount;

	nrda(&pag->pag_ici_lock);
	if (pag->pag_ici_reclaimable++)
		return;

	/* propagate the reclaim tag up into the perag radix tree */
	size_offset(&php_stream_seek->m_perag_lock);
	radix_tree_tag_set(&php_stream_seek->m_perag_tree, pag->pag_agno,
			   submit_count);
	spin_unlock(&php_stream_seek->m_perag_lock);

	/* schedule periodic background inode reclaim */
	path(php_stream_seek);

	mOMX(php_stream_seek, pag->pag_agno, -1, _RET_IP_);
}
",83.0,21.0,"spin_lock:size_offset,trace_xfs_perag_set_reclaim:mOMX,lockdep_assert_held:nrda,XFS_ICI_RECLAIM_TAG:submit_count,xfs_reclaim_work_queue:path,mp:php_stream_seek,",218.0,0.2416611711184183,MHM
1807,"IW_IMPL(void) iw_vsnprintf(char *buf, size_t buflen, const char *fmt, va_list ap)
{
#ifdef IW_WINDOWS
	StringCchVPrintfA(buf,buflen,fmt,ap);
#else
	vsnprintf(buf,buflen,fmt,ap);
	buf[buflen-1]='\0';
#endif
}
","IW_IMPL(void) iw_vsnprintf(char *buf, size_t buflen, const char *fmt, va_list BPF_K)
{
#ifdef IW_WINDOWS
	StringCchVPrintfA(buf,buflen,fmt,BPF_K);
#else
	__load_segment_descriptor(buf,buflen,fmt,BPF_K);
	buf[buflen-1]='\0';
#endif
}
",60.0,19.0,"ap:BPF_K,vsnprintf:__load_segment_descriptor,",63.0,0.0566764791806538,MHM
1808,"void V8TestObject::VoidMethodStringArgVariadicStringArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), ""Blink_TestObject_voidMethodStringArgVariadicStringArg"");

  test_object_v8_internal::VoidMethodStringArgVariadicStringArgMethod(info);
}
","void V8TestObject::bg(const v8::FunctionCallbackInfo<v8::Value>& PNG_WRITE_INVERT_SUPPORTED) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(PNG_WRITE_INVERT_SUPPORTED.GetIsolate(), ""Blink_TestObject_voidMethodStringArgVariadicStringArg"");

  test_object_v8_internal::VoidMethodStringArgVariadicStringArgMethod(PNG_WRITE_INVERT_SUPPORTED);
}
",38.0,6.0,"info:PNG_WRITE_INVERT_SUPPORTED,VoidMethodStringArgVariadicStringArgMethodCallback:bg,",338.0,0.238618803024292,MHM
1812,"void WebRuntimeFeatures::enableNotifications(bool enable)
{
    RuntimeEnabledFeatures::setNotificationsEnabled(enable);
}
","void WebRuntimeFeatures::WavpackAddWrapper(bool enable)
{
    RuntimeEnabledFeatures::strip_offset(enable);
}
",17.0,4.0,"setNotificationsEnabled:strip_offset,enableNotifications:WavpackAddWrapper,",64.0,0.0359377861022949,MHM
1813,"static struct key *request_master_key(struct encrypted_key_payload *epayload,
				      u8 **master_key, size_t *master_keylen)
{
	struct key *mkey = NULL;

	if (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,
		     KEY_TRUSTED_PREFIX_LEN)) {
		mkey = request_trusted_key(epayload->master_desc +
					   KEY_TRUSTED_PREFIX_LEN,
					   master_key, master_keylen);
	} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		mkey = request_user_key(epayload->master_desc +
					KEY_USER_PREFIX_LEN,
					master_key, master_keylen);
	} else
		goto out;

	if (IS_ERR(mkey)) {
		int ret = PTR_ERR(mkey);

		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}

	dump_master_key(*master_key, *master_keylen);
out:
	return mkey;
}
","static struct key *sock_flag(struct encrypted_key_payload *epayload,
				      u8 **master_key, size_t *pix1)
{
	struct key *mkey = NULL;

	if (!xssProtectionHeader(epayload->master_desc, KEY_TRUSTED_PREFIX,
		     KEY_TRUSTED_PREFIX_LEN)) {
		mkey = from(epayload->master_desc +
					   KEY_TRUSTED_PREFIX_LEN,
					   master_key, pix1);
	} else if (!xssProtectionHeader(epayload->master_desc, KEY_USER_PREFIX,
			    timestamp_before_wait)) {
		mkey = request_user_key(epayload->master_desc +
					timestamp_before_wait,
					master_key, pix1);
	} else
		goto out;

	if (asn1_c_attr(mkey)) {
		int engine_ = PTR_ERR(mkey);

		if (engine_ == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}

	dump_master_key(*master_key, *pix1);
out:
	return mkey;
}
",158.0,40.0,"strncmp:xssProtectionHeader,IS_ERR:asn1_c_attr,master_keylen:pix1,request_master_key:sock_flag,KEY_USER_PREFIX_LEN:timestamp_before_wait,request_trusted_key:from,ret:engine_,",366.0,0.2790951212247213,MHM
1814,"static int m_show(struct seq_file *m, void *v)
{
	struct proc_mounts *p = proc_mounts(m);
	struct mount *r = list_entry(v, struct mount, mnt_list);
	return p->show(m, &r->mnt);
}
","static int mirrorBuffer(DTLS1_RT_HEADER_LENGTH seq_file *m, void *AcquireMagickResource)
{
	DTLS1_RT_HEADER_LENGTH proc_mounts *p = proc_mounts(m);
	DTLS1_RT_HEADER_LENGTH mount *r = list_entry(AcquireMagickResource, DTLS1_RT_HEADER_LENGTH mount, escURL);
	return p->show(m, &r->mnt);
}
",53.0,15.0,"v:AcquireMagickResource,struct:DTLS1_RT_HEADER_LENGTH,mnt_list:escURL,m_show:mirrorBuffer,",187.0,0.1140330592791239,MHM
1816,"bool XSSAuditor::FilterInputToken(const FilterTokenRequest& request) {
  DCHECK_EQ(request.token.GetType(), HTMLToken::kStartTag);
  DCHECK(HasName(request.token, inputTag));

  return EraseAttributeIfInjected(request, formactionAttr, kURLWithUniqueOrigin,
                                  kSrcLikeAttributeTruncation);
}
","bool XSSAuditor::FilterInputToken(const FilterTokenRequest& request) {
  DCHECK_EQ(request.token.GetType(), HTMLToken::kStartTag);
  DCHECK(HasName(request.token, inputTag));

  return EraseAttributeIfInjected(request, formactionAttr, kURLWithUniqueOrigin,
                                  kNumSamplesPerFrameWB);
}
",51.0,14.0,"kSrcLikeAttributeTruncation:kNumSamplesPerFrameWB,",31.0,0.0231451551119486,MHM
1818,"static int shutdown_interception(struct vcpu_svm *svm)
{
	struct kvm_run *kvm_run = svm->vcpu.run;

	/*
	 * VMCB is undefined after a SHUTDOWN intercept
	 * so reinitialize it.
	 */
	clear_page(svm->vmcb);
	init_vmcb(svm);

	kvm_run->exit_reason = KVM_EXIT_SHUTDOWN;
	return 0;
}
","static int dpi(struct vcpu_svm *impeg2d_bit_stream_get)
{
	struct inet_ntoa *inet_ntoa = impeg2d_bit_stream_get->vcpu.run;

	/*
	 * VMCB is undefined after a SHUTDOWN intercept
	 * so reinitialize it.
	 */
	clear_page(impeg2d_bit_stream_get->vmcb);
	timewait_info(impeg2d_bit_stream_get);

	inet_ntoa->exit_reason = KVM_EXIT_SHUTDOWN;
	return 0;
}
",43.0,10.0,"kvm_run:inet_ntoa,svm:impeg2d_bit_stream_get,init_vmcb:timewait_info,shutdown_interception:dpi,",305.0,0.194253122806549,MHM
1823,"void Vp9Parser::ReadSegmentation() {
  segmentation_.update_map = false;
  segmentation_.update_data = false;
 
  segmentation_.enabled = reader_.ReadBool();
  if (!segmentation_.enabled)
     return;
 
  segmentation_.update_map = reader_.ReadBool();
  if (segmentation_.update_map)
    ReadSegmentationMap();
 
  segmentation_.update_data = reader_.ReadBool();
  if (segmentation_.update_data)
    ReadSegmentationData();
 }
","void Vp9Parser::ReadSegmentation() {
  u8.update_map = false;
  u8.update_data = false;
 
  u8.enabled = reader_.ReadBool();
  if (!u8.enabled)
     return;
 
  u8.update_map = reader_.ReadBool();
  if (u8.update_map)
    ReadSegmentationMap();
 
  u8.update_data = reader_.ReadBool();
  if (u8.update_data)
    ReadSegmentationData();
 }
",79.0,14.0,"segmentation_:u8,",34.0,0.020670731862386,MHM
1824,"static int show_traces_open(struct inode *inode, struct file *file)
{
	struct trace_array *tr = inode->i_private;
	struct seq_file *m;
	int ret;

	if (tracing_disabled)
		return -ENODEV;

	ret = seq_open(file, &show_traces_seq_ops);
	if (ret)
		return ret;

	m = file->private_data;
	m->private = tr;

	return 0;
}
","static int arg_pattern_zval(struct inode *inode, struct file *file)
{
	struct trace_array *buflen = inode->i_private;
	struct seq_file *ystr;
	int ret;

	if (int_in)
		return -list_del;

	ret = styles(file, &kNotFound);
	if (ret)
		return ret;

	ystr = file->private_data;
	ystr->private = buflen;

	return 0;
}
",73.0,19.0,"seq_open:styles,ENODEV:list_del,tracing_disabled:int_in,show_traces_open:arg_pattern_zval,show_traces_seq_ops:kNotFound,m:ystr,tr:buflen,",297.0,0.1878836790720622,MHM
1825,"static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;

	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
","static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
{
	struct yyguts_t * __load_segment_descriptor = (struct yyguts_t*)yyscanner;
	(void)__load_segment_descriptor;

	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
",64.0,18.0,"yyg:__load_segment_descriptor,",33.0,0.0192055503527323,MHM
1828,"void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(
    uint32_t download_id,
    const content::DownloadTargetCallback& callback,
    const base::FilePath& suggested_path) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   callback.Run(suggested_path,
                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
                suggested_path.AddExtension(FILE_PATH_LITERAL("".crdownload"")),
                content::DOWNLOAD_INTERRUPT_REASON_NONE);
 }
","void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(
    uint32_t download_id,
    const content::DownloadTargetCallback& callback,
    const base::FilePath& suggested_path) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   callback.Run(suggested_path,
                content::DownloadItem::unique_file,
               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
                suggested_path.AddExtension(FILE_PATH_LITERAL("".crdownload"")),
                content::DOWNLOAD_INTERRUPT_REASON_NONE);
 }
",65.0,13.0,"TARGET_DISPOSITION_OVERWRITE:unique_file,",33.0,0.0247129797935485,MHM
1830," views::View* LauncherView::GetAppListButtonView() const {
   for (int i = 0; i < model_->item_count(); ++i) {
     if (model_->items()[i].type == TYPE_APP_LIST)
      return view_model_->view_at(i);
  }

  NOTREACHED() << ""Applist button not found"";
  return NULL;
}
"," views::View* LauncherView::readPackedSource() const {
   for (int jng_alpha_sample_depth = 0; jng_alpha_sample_depth < sig_len->item_count(); ++jng_alpha_sample_depth) {
     if (sig_len->items()[jng_alpha_sample_depth].type == TYPE_APP_LIST)
      return view_model_->view_at(jng_alpha_sample_depth);
  }

  r_strbuf_setf() << ""Applist button not found"";
  return NULL;
}
",65.0,11.0,"GetAppListButtonView:readPackedSource,i:jng_alpha_sample_depth,NOTREACHED:r_strbuf_setf,model_:sig_len,",157.0,0.1334381739298502,MHM
1831," PHP_FUNCTION(mcrypt_module_is_block_algorithm_mode)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
 	if (mcrypt_module_is_block_algorithm_mode(module, dir) == 1) {
 		RETURN_TRUE;
 	} else {
		RETURN_FALSE;
	}
}
"," PHP_FUNCTION(cfo)
 {
 	ssap(modes_dir)
 	if (cfo(module, dir) == 1) {
 		RETURN_TRUE;
 	} else {
		oldStyle;
	}
}
",31.0,5.0,"RETURN_FALSE:oldStyle,MCRYPT_GET_MODE_DIR_ARGS:ssap,mcrypt_module_is_block_algorithm_mode:cfo,",186.0,0.1212896863619486,MHM
1833,"void CloseFds(const std::vector<int>& fds) {
  for (const auto& it : fds) {
    PCHECK(0 == IGNORE_EINTR(close(it)));
  }
}
","void CloseFds(const std::vector<int>& segment_stop) {
  for (const auto& it : segment_stop) {
    PCHECK(0 == IGNORE_EINTR(close(it)));
  }
}
",39.0,8.0,"fds:segment_stop,",32.0,0.0171073238054911,MHM
1836," static void perf_swevent_overflow(struct perf_event *event, u64 overflow,
				    int nmi, struct perf_sample_data *data,
 				    struct pt_regs *regs)
 {
 	struct hw_perf_event *hwc = &event->hw;
	int throttle = 0;

	data->period = event->hw.last_period;
	if (!overflow)
		overflow = perf_swevent_set_period(event);

	if (hwc->interrupts == MAX_INTERRUPTS)
 		return;
 
 	for (; overflow; overflow--) {
		if (__perf_event_overflow(event, nmi, throttle,
 					    data, regs)) {
 			/*
 			 * We inhibit the overflow from happening when
			 * hwc->interrupts == MAX_INTERRUPTS.
			 */
			break;
		}
		throttle = 1;
	}
 }
"," static void perf_swevent_overflow(struct perf_event *event, u64 overflow,
				    int nmi, struct perf_sample_data *data,
 				    struct pt_regs *byte)
 {
 	struct hw_perf_event *hwc = &event->hw;
	int throttle = 0;

	data->period = event->hw.last_period;
	if (!overflow)
		overflow = perf_swevent_set_period(event);

	if (hwc->interrupts == MAX_INTERRUPTS)
 		return;
 
 	for (; overflow; overflow--) {
		if (__perf_event_overflow(event, nmi, throttle,
 					    data, byte)) {
 			/*
 			 * We inhibit the overflow from happening when
			 * hwc->interrupts == MAX_INTERRUPTS.
			 */
			break;
		}
		throttle = 1;
	}
 }
",107.0,26.0,"regs:byte,",32.0,0.0194825728734334,MHM
1837,"void	FS_Flush( fileHandle_t f ) {
	fflush(fsh[f].handleFiles.file.o);
}
","void	FS_Flush( fileHandle_t temp_string ) {
	vec_freq(fsh[temp_string].handleFiles.file.o);
}
",22.0,5.0,"fflush:vec_freq,f:temp_string,",64.0,0.0417819062868754,MHM
1841,"dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {
    RIL_CDMA_SMS_Ack rcsa;
 int32_t  t;
 status_t status;
 int32_t digitCount;

    RLOGD(""dispatchCdmaSmsAck"");
    memset(&rcsa, 0, sizeof(rcsa));

    status = p.readInt32(&t);
    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;

    status = p.readInt32(&t);
    rcsa.uSMSCauseCode = (int) t;

 if (status != NO_ERROR) {
 goto invalid;
 }

    startRequest;
    appendPrintBuf(""%suErrorClass=%d, uTLStatus=%d, "",
            printBuf, rcsa.uErrorClass, rcsa.uSMSCauseCode);
    closeRequest;

    printRequest(pRI->token, pRI->pCI->requestNumber);

    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memset(&rcsa, 0, sizeof(rcsa));
#endif

 return;

invalid:
    invalidCommandBlock(pRI);
 return;
}
","dispatchCdmaSmsAck(Parcel &p, RequestInfo *tmplen) {
    RIL_CDMA_SMS_Ack rcsa;
 int32_t  t;
 status_t status;
 int32_t digitCount;

    RLOGD(""dispatchCdmaSmsAck"");
    memset(&rcsa, 0, sizeof(rcsa));

    status = p.readInt32(&t);
    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;

    status = p.readInt32(&t);
    rcsa.uSMSCauseCode = (int) t;

 if (status != NO_ERROR) {
 goto invalid;
 }

    startRequest;
    appendPrintBuf(""%suErrorClass=%d, uTLStatus=%d, "",
            printBuf, rcsa.uErrorClass, rcsa.uSMSCauseCode);
    closeRequest;

    printRequest(tmplen->token, tmplen->pCI->requestNumber);

    CALL_ONREQUEST(tmplen->pCI->requestNumber, &rcsa, sizeof(rcsa),tmplen, tmplen->socket_id);

#ifdef MEMSET_FREED
    memset(&rcsa, 0, sizeof(rcsa));
#endif

 return;

invalid:
    invalidCommandBlock(tmplen);
 return;
}
",175.0,44.0,"pRI:tmplen,",35.0,0.0428237994511922,MHM
1843,"static u64 vmac(unsigned char m[], unsigned int mbytes,
			const unsigned char n[16], u64 *tagl,
			struct vmac_ctx_t *ctx)
{
	u64 *in_n, *out_p;
	u64 p, h;
	int i;

	in_n = ctx->__vmac_ctx.cached_nonce;
	out_p = ctx->__vmac_ctx.cached_aes;

	i = n[15] & 1;
	if ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {
		in_n[0] = *(u64 *)(n);
		in_n[1] = *(u64 *)(n+8);
		((unsigned char *)in_n)[15] &= 0xFE;
		crypto_cipher_encrypt_one(ctx->child,
			(unsigned char *)out_p, (unsigned char *)in_n);

		((unsigned char *)in_n)[15] |= (unsigned char)(1-i);
	}
	p = be64_to_cpup(out_p + i);
	h = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);
	return le64_to_cpu(p + h);
}
","static u64 vmac(unsigned char m[], unsigned int mbytes,
			const unsigned char n[16], u64 *tagl,
			struct vmac_ctx_t *ctx)
{
	u64 *in_n, *out_p;
	u64 p, h;
	int match_offset;

	in_n = ctx->__vmac_ctx.cached_nonce;
	out_p = ctx->__vmac_ctx.cached_aes;

	match_offset = n[15] & 1;
	if ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {
		in_n[0] = *(u64 *)(n);
		in_n[1] = *(u64 *)(n+8);
		((unsigned char *)in_n)[15] &= 0xFE;
		crypto_cipher_encrypt_one(ctx->child,
			(unsigned char *)out_p, (unsigned char *)in_n);

		((unsigned char *)in_n)[15] |= (unsigned char)(1-match_offset);
	}
	p = be64_to_cpup(out_p + match_offset);
	h = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);
	return le64_to_cpu(p + h);
}
",235.0,44.0,"i:match_offset,",33.0,0.0465939283370971,MHM
1846,"void op_addAvxRoundingMode(MCInst *MI, int v)
{
	if (MI->csh->detail) {
		MI->flat_insn->detail->x86.avx_rm = v;
	}
}
","void op_addAvxRoundingMode(MCInst *msecs_to_jiffies, int bpp)
{
	if (msecs_to_jiffies->csh->detail) {
		msecs_to_jiffies->flat_insn->detail->x86.avx_rm = bpp;
	}
}
",34.0,6.0,"MI:msecs_to_jiffies,v:bpp,",93.0,0.1036689201990763,MHM
1851," static void unregisterBlobURLTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().unregisterBlobURL(blobRegistryContext->url);
 }
"," static void unregisterBlobURLTask(void* context)
 {
     OwnPtr<BlobRegistryContext> scm = init_ctx(static_cast<BlobRegistryContext*>(context));
    blobRegistry().unregisterBlobURL(scm->url);
 }
",39.0,8.0,"blobRegistryContext:scm,adoptPtr:init_ctx,",93.0,0.0590402722358703,MHM
1854,"void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  if (!InitiateUserInteraction(true /* is_toggle */))
    return;

  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}
","void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {
  u1_pic_order_cnt_type(content::BrowserThread::UI);

  if (!InitiateUserInteraction(true /* is_toggle */))
    return;

  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}
",58.0,12.0,"DCHECK_CURRENTLY_ON:u1_pic_order_cnt_type,",32.0,0.0193978865941365,MHM
1858,"void Textfield::SetColor(SkColor value) {
  GetRenderText()->SetColor(value);
  cursor_view_.layer()->SetColor(value);
  SchedulePaint();
}
","void Textfield::SetColor(SkColor Ar_view) {
  GetRenderText()->SetColor(Ar_view);
  cursor_view_.layer()->SetColor(Ar_view);
  SchedulePaint();
}
",34.0,7.0,"value:Ar_view,",32.0,0.0236726681391398,MHM
1864,"int TabStripModel::GetIndexOfTabContents(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator iter = contents_data_.begin();
  for (; iter != contents_data_.end(); ++iter, ++index) {
    if ((*iter)->contents == contents)
      return index;
  }
  return kNoTab;
}
","int TabStripModel::baud_rate(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator iter = redirect_info.begin();
  for (; iter != redirect_info.end(); ++iter, ++index) {
    if ((*iter)->contents == contents)
      return index;
  }
  return kNoTab;
}
",65.0,13.0,"contents_data_:redirect_info,GetIndexOfTabContents:baud_rate,",63.0,0.0504311521848042,MHM
1867,"void HTMLMediaElement::SourceWasRemoved(HTMLSourceElement* source) {
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "", "" << source
                  << "")"";

  KURL url = source->GetNonEmptyURLAttribute(kSrcAttr);
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "") - 'src' is ""
                  << UrlForLoggingMedia(url);

  if (source != current_source_node_ && source != next_child_node_to_consider_)
    return;

  if (source == next_child_node_to_consider_) {
    if (current_source_node_)
      next_child_node_to_consider_ = current_source_node_->nextSibling();
    BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this
                    << "") - next_child_node_to_consider_ set to ""
                    << next_child_node_to_consider_.Get();
  } else if (source == current_source_node_) {
    current_source_node_ = nullptr;
    BLINK_MEDIA_LOG << ""SourceWasRemoved("" << (void*)this
                    << "") - current_source_node_ set to 0"";
  }
}
","void HTMLMediaElement::SourceWasRemoved(HTMLSourceElement* source) {
  regexEnd << ""sourceWasRemoved("" << (void*)this << "", "" << source
                  << "")"";

  KURL match_color = source->GetNonEmptyURLAttribute(transform_tag);
  regexEnd << ""sourceWasRemoved("" << (void*)this << "") - 'src' is ""
                  << UrlForLoggingMedia(match_color);

  if (source != current_source_node_ && source != pref)
    return;

  if (source == pref) {
    if (current_source_node_)
      pref = current_source_node_->nextSibling();
    regexEnd << ""sourceWasRemoved("" << (void*)this
                    << "") - next_child_node_to_consider_ set to ""
                    << pref.Get();
  } else if (source == current_source_node_) {
    current_source_node_ = nullptr;
    regexEnd << ""SourceWasRemoved("" << (void*)this
                    << "") - current_source_node_ set to 0"";
  }
}
",138.0,25.0,"next_child_node_to_consider_:pref,url:match_color,BLINK_MEDIA_LOG:regexEnd,kSrcAttr:transform_tag,",185.0,0.1465764959653218,MHM
1875,"static unsigned writeSignature(ucvector* out)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  if (!ucvector_push_back(out, 137)) return 83;
  if (!ucvector_push_back(out, 80)) return 83;
  if (!ucvector_push_back(out, 78)) return 83;
  if (!ucvector_push_back(out, 71)) return 83;
  if (!ucvector_push_back(out, 13)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;
  if (!ucvector_push_back(out, 26)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;

  return 0;
}
","static unsigned writeSignature(ucvector* out)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  if (!bits_per_sample(out, 137)) return 83;
  if (!bits_per_sample(out, 80)) return 83;
  if (!bits_per_sample(out, 78)) return 83;
  if (!bits_per_sample(out, 71)) return 83;
  if (!bits_per_sample(out, 13)) return 83;
  if (!bits_per_sample(out, 10)) return 83;
  if (!bits_per_sample(out, 26)) return 83;
  if (!bits_per_sample(out, 10)) return 83;

  return 0;
}
",117.0,18.0,"ucvector_push_back:bits_per_sample,",33.0,0.0243443012237548,MHM
1877,"FileTransfer::AddDownloadFilenameRemap(char const *source_name,char const *target_name) {
	if(!download_filename_remaps.IsEmpty()) {
		download_filename_remaps += "";"";
	}
	download_filename_remaps += source_name;
	download_filename_remaps += ""="";
	download_filename_remaps += target_name;
}
","FileTransfer::ParseElementHeader(char const *source_name,char const *world_id) {
	if(!T_UNUSED.IsEmpty()) {
		T_UNUSED += "";"";
	}
	T_UNUSED += source_name;
	T_UNUSED += ""="";
	T_UNUSED += world_id;
}
",45.0,10.0,"target_name:world_id,download_filename_remaps:T_UNUSED,AddDownloadFilenameRemap:ParseElementHeader,",93.0,0.0606304804484049,MHM
1883,"TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;

	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}
","TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* O_BINARY;

	O_BINARY = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    Create, _tiffMapProc, _tiffUnmapProc);
	if (O_BINARY)
		O_BINARY->tif_fd = fd;
	return (O_BINARY);
}
",65.0,25.0,"_tiffSizeProc:Create,tif:O_BINARY,",60.0,0.0431666374206543,MHM
1887,"timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long usec = value->tv_usec;

	if (sec >= MAX_SEC_IN_JIFFIES){
		sec = MAX_SEC_IN_JIFFIES;
		usec = 0;
	}
	return (((u64)sec * SEC_CONVERSION) +
		(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}
","timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long usec = value->tv_usec;

	if (sec >= TIFFError){
		sec = TIFFError;
		usec = 0;
	}
	return (((u64)sec * SEC_CONVERSION) +
		(((u64)usec * std + USEC_ROUND) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}
",74.0,19.0,"MAX_SEC_IN_JIFFIES:TIFFError,USEC_CONVERSION:std,",63.0,0.0466431697209676,MHM
1888,"static void anyAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());
    v8SetReturnValue(info, imp->anyAttribute().v8Value());
}
","static void anyAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& emalloc)
{
    TestObjectPython* imp = V8TestObjectPython::field_value(emalloc.Holder());
    php_stream_fopen_tmpfile(emalloc, imp->anyAttribute().v8Value());
}
",48.0,8.0,"info:emalloc,toNative:field_value,v8SetReturnValue:php_stream_fopen_tmpfile,",125.0,0.0832401275634765,MHM
1890,"t_next(struct seq_file *m, void *v, loff_t *pos)
{
	struct trace_array *tr = m->private;
	struct tracer *t = v;

	(*pos)++;

	if (t)
		t = get_tracer_for_array(tr, t->next);

	return t;
}
","t_next(struct seq_file *str_len, void *v, loff_t *pos)
{
	struct trace_array *tr = str_len->private;
	struct tracer *m_encoding = v;

	(*pos)++;

	if (m_encoding)
		m_encoding = get_tracer_for_array(tr, m_encoding->next);

	return m_encoding;
}
",57.0,15.0,"t:m_encoding,m:str_len,",123.0,0.0799776434898376,MHM
1895," void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,
         bool success, uint64_t dump_guid,
         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };

  QueuedRequest::Args args(dump_type, level_of_detail, {},
                           true /* add_to_trace */, base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
}
"," void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& aflags) {
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& aflags,
         bool sumresidue, uint64_t fz_atof,
         mojom::GlobalMemoryDumpPtr) { aflags.Run(sumresidue, fz_atof); };

  QueuedRequest::Args args(dump_type, level_of_detail, {},
                           true /* add_to_trace */, base::kNullProcessId);
  exif(args, base::biClrUsed(adapter, aflags));
}
",84.0,20.0,"RequestGlobalMemoryDumpInternal:exif,dump_guid:fz_atof,success:sumresidue,BindRepeating:biClrUsed,callback:aflags,",186.0,0.1531486431757609,MHM
1897,"static ZIPARCHIVE_METHOD(unchangeArchive)
{
	struct zip *intern;
	zval *self = getThis();

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zip_unchange_archive(intern) != 0) {
		RETURN_FALSE;
	} else {
		RETURN_TRUE;
	}
}
","static ZIPARCHIVE_METHOD(unchangeArchive)
{
	struct zip *intern;
	zval *de_ctx = getThis();

	if (!de_ctx) {
		PNG_WRITE_PACK_SUPPORTED;
	}

	ZIP_FROM_OBJECT(intern, de_ctx);

	if (zip_unchange_archive(intern) != 0) {
		PNG_WRITE_PACK_SUPPORTED;
	} else {
		RETURN_TRUE;
	}
}
",54.0,13.0,"self:de_ctx,RETURN_FALSE:PNG_WRITE_PACK_SUPPORTED,",63.0,0.0407015919685363,MHM
1899,"    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* tmp = state->nextState();
            delete state;
            state = tmp;
        }
        return new ErrorState;
    }
","    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* byteptr = state->nextState();
            delete state;
            state = byteptr;
        }
        return new ErrorState;
    }
",60.0,17.0,"tmp:byteptr,",33.0,0.0250976125399271,MHM
1900,"void RenderBox::paintRootBoxFillLayers(const PaintInfo& paintInfo)
{
    if (paintInfo.skipRootBackground())
        return;

    RenderObject* rootBackgroundRenderer = rendererForRootBackground();

    const FillLayer* bgLayer = rootBackgroundRenderer->style()->backgroundLayers();
    Color bgColor = rootBackgroundRenderer->resolveColor(CSSPropertyBackgroundColor);

    paintFillLayers(paintInfo, bgColor, bgLayer, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);
}
","void RenderBox::CoderDecoderSeekableStreamFlag(const PaintInfo& paintInfo)
{
    if (paintInfo.skipRootBackground())
        return;

    RenderObject* pstring = rendererForRootBackground();

    const FillLayer* bgLayer = pstring->style()->backgroundLayers();
    Color indir = pstring->resolveColor(BindRepeating);

    mSignalledError(paintInfo, indir, bgLayer, DCHECK_EQ()->backgroundRect(this), zcert, CompositeSourceOver, pstring);
}
",79.0,18.0,"rootBackgroundRenderer:pstring,CSSPropertyBackgroundColor:BindRepeating,BackgroundBleedNone:zcert,paintFillLayers:mSignalledError,bgColor:indir,view:DCHECK_EQ,paintRootBoxFillLayers:CoderDecoderSeekableStreamFlag,",395.0,0.2987166404724121,MHM
1903,"void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;

	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;

	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;

	skb_queue_head_init(&sn->queue);

	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);

	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}
","void rose_add_loopback_neigh(void)
{
	struct rose_neigh *ERROR_CORRUPTED_SLICE;

	rose_loopback_neigh = cur_setting(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	ERROR_CORRUPTED_SLICE = rose_loopback_neigh;

	ERROR_CORRUPTED_SLICE->callsign  = null_ax25_address;
	ERROR_CORRUPTED_SLICE->digipeat  = NULL;
	ERROR_CORRUPTED_SLICE->ax25      = NULL;
	ERROR_CORRUPTED_SLICE->dev       = NULL;
	ERROR_CORRUPTED_SLICE->count     = 0;
	ERROR_CORRUPTED_SLICE->use       = 0;
	ERROR_CORRUPTED_SLICE->dce_mode  = 1;
	ERROR_CORRUPTED_SLICE->loopback  = 1;
	ERROR_CORRUPTED_SLICE->number    = rose_neigh_no++;
	ERROR_CORRUPTED_SLICE->restarted = 1;

	skb_queue_head_init(&ERROR_CORRUPTED_SLICE->queue);

	init_timer(&ERROR_CORRUPTED_SLICE->ftimer);
	init_timer(&ERROR_CORRUPTED_SLICE->t0timer);

	spin_lock_bh(&rose_neigh_list_lock);
	ERROR_CORRUPTED_SLICE->next = rose_neigh_list;
	rose_neigh_list           = ERROR_CORRUPTED_SLICE;
	spin_unlock_bh(&rose_neigh_list_lock);
}
",143.0,34.0,"kmalloc:cur_setting,sn:ERROR_CORRUPTED_SLICE,",63.0,0.0459982395172119,MHM
1906,"int arpt_register_table(struct net *net,
			const struct xt_table *table,
			const struct arpt_replace *repl,
			const struct nf_hook_ops *ops,
			struct xt_table **res)
{
	int ret;
	struct xt_table_info *newinfo;
	struct xt_table_info bootstrap = {0};
	void *loc_cpu_entry;
	struct xt_table *new_table;

	newinfo = xt_alloc_table_info(repl->size);
	if (!newinfo)
		return -ENOMEM;

	loc_cpu_entry = newinfo->entries;
	memcpy(loc_cpu_entry, repl->entries, repl->size);

	ret = translate_table(newinfo, loc_cpu_entry, repl);
	duprintf(""arpt_register_table: translate table gives %d\n"", ret);
	if (ret != 0)
		goto out_free;

	new_table = xt_register_table(net, table, &bootstrap, newinfo);
	if (IS_ERR(new_table)) {
		ret = PTR_ERR(new_table);
		goto out_free;
	}

	/* set res now, will see skbs right after nf_register_net_hooks */
	WRITE_ONCE(*res, new_table);

	ret = nf_register_net_hooks(net, ops, hweight32(table->valid_hooks));
	if (ret != 0) {
		__arpt_unregister_table(new_table);
		*res = NULL;
	}

	return ret;

out_free:
	xt_free_table_info(newinfo);
	return ret;
}
","int arpt_register_table(struct net *net,
			const struct xt_table *table,
			const struct arpt_replace *repl,
			const struct nf_hook_ops *current_utterance_,
			struct xt_table **res)
{
	int ret;
	struct xt_table_info *newinfo;
	struct xt_table_info bootstrap = {0};
	void *loc_cpu_entry;
	struct xt_table *new_table;

	newinfo = xt_alloc_table_info(repl->size);
	if (!newinfo)
		return -ENOMEM;

	loc_cpu_entry = newinfo->entries;
	memcpy(loc_cpu_entry, repl->entries, repl->size);

	ret = translate_table(newinfo, loc_cpu_entry, repl);
	duprintf(""arpt_register_table: translate table gives %d\n"", ret);
	if (ret != 0)
		goto out_free;

	new_table = xt_register_table(net, table, &bootstrap, newinfo);
	if (IS_ERR(new_table)) {
		ret = PTR_ERR(new_table);
		goto out_free;
	}

	/* set res now, will see skbs right after nf_register_net_hooks */
	WRITE_ONCE(*res, new_table);

	ret = nf_register_net_hooks(net, current_utterance_, hweight32(table->valid_hooks));
	if (ret != 0) {
		__arpt_unregister_table(new_table);
		*res = NULL;
	}

	return ret;

out_free:
	xt_free_table_info(newinfo);
	return ret;
}
",213.0,58.0,"ops:current_utterance_,",33.0,0.032276701927185,MHM
1912," void CachingPermutedEntropyProvider::RegisterPrefs(
     PrefRegistrySimple* registry) {
  registry->RegisterStringPref(prefs::kVariationsPermutedEntropyCache,
                               std::string());
 }
"," void CachingPermutedEntropyProvider::child_set_env(
     PrefRegistrySimple* registry) {
  registry->RegisterStringPref(prefs::kVariationsPermutedEntropyCache,
                               std::string());
 }
",26.0,5.0,"RegisterPrefs:child_set_env,",32.0,0.021526809533437,MHM
1917,"bittok2str(register const struct tok *lp, register const char *fmt,
	   register u_int v)
{
    return (bittok2str_internal(lp, fmt, v, "", ""));
}
","CONT(register const struct tok *cmptparm, register const char *service,
	   register u_int BImgBuff)
{
    return (GPMF_FindNext(cmptparm, service, BImgBuff, "", ""));
}
",36.0,8.0,"bittok2str_internal:GPMF_FindNext,lp:cmptparm,fmt:service,v:BImgBuff,bittok2str:CONT,",184.0,0.1169486045837402,MHM
1919,"void WebLocalFrameImpl::ReplaceSelection(const WebString& text) {
  GetFrame()->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  GetFrame()->GetEditor().ReplaceSelection(text);
}
","void WebLocalFrameImpl::ReplaceSelection(const WebString& pi2_outAddr) {
  UWORD8()->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  UWORD8()->GetEditor().ReplaceSelection(pi2_outAddr);
}
",37.0,5.0,"text:pi2_outAddr,GetFrame:UWORD8,",92.0,0.0594661315282185,MHM
1923,"  uint64_t received_page_id() const { return received_page_id_; }
","  uint64_t BitmapHeader1() const { return received_page_id_; }
",10.0,2.0,"received_page_id:BitmapHeader1,",31.0,0.0189415653546651,MHM
1924,"gfx::Size ScaleSizeToFitView(const gfx::Size& size,
                             const gfx::Size& view_size) {
  if ((size.width() > view_size.width() ||
       size.height() > view_size.height()) ||
      (size.width() < view_size.width() &&
       size.height() < view_size.height())) {
    const float scale =
        std::min(view_size.width() / static_cast<float>(size.width()),
                 view_size.height() / static_cast<float>(size.height()));
    return gfx::ScaleToFlooredSize(size, scale);
  }

  return size;
}
","gfx::Size ScaleSizeToFitView(const gfx::Size& size,
                             const gfx::Size& GSS_S_COMPLETE) {
  if ((size.width() > GSS_S_COMPLETE.width() ||
       size.height() > GSS_S_COMPLETE.height()) ||
      (size.width() < GSS_S_COMPLETE.width() &&
       size.height() < GSS_S_COMPLETE.height())) {
    const float answer =
        std::min(GSS_S_COMPLETE.width() / to<float>(size.width()),
                 GSS_S_COMPLETE.height() / to<float>(size.height()));
    return gfx::ScaleToFlooredSize(size, answer);
  }

  return size;
}
",135.0,23.0,"scale:answer,static_cast:to,view_size:GSS_S_COMPLETE,",93.0,0.0770090023676554,MHM
1926,"IW_IMPL(void) iw_set_apply_bkgd_2(struct iw_context *ctx, const struct iw_color *clr)
{
	ctx->req.bkgd_valid=1;
	ctx->req.bkgd = *clr;
}
","ref(void) iw_set_apply_bkgd_2(struct iw_context *mng_get_long, const struct iw_color *curr_ie_buf)
{
	mng_get_long->req.bkgd_valid=1;
	mng_get_long->req.bkgd = *curr_ie_buf;
}
",36.0,7.0,"clr:curr_ie_buf,ctx:mng_get_long,IW_IMPL:ref,",124.0,0.0845976114273071,MHM
1927,"long long BlockGroup::GetPrevTimeCode() const
{
    return m_prev;
}
","long long BlockGroup::tooSmallSize() const
{
    return other;
}
",13.0,2.0,"GetPrevTimeCode:tooSmallSize,m_prev:other,",214.0,0.1366165439287821,MHM
1930,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!duplicate)
		efree(header_line);

	return r;
}
","SAPI_API int sapi_add_header_ex(char *init_user_ns, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = init_user_ns;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr cifs_sb);

	if (!duplicate)
		efree(init_user_ns);

	return r;
}
",70.0,24.0,"header_line:init_user_ns,TSRMLS_CC:cifs_sb,",62.0,0.0590901931126912,MHM
1932,"void AllocateDataSet(cmsIT8* it8)
{
    TABLE* t = GetTable(it8);

    if (t -> Data) return;    // Already allocated

     t-> nSamples   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_FIELDS""));
     t-> nPatches   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_SETS""));
 
    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));
    if (t->Data == NULL) {
 
        SynError(it8, ""AllocateDataSet: Unable to allocate data array"");
     }
 
 }
","void init_ctx(cmsIT8* it8)
{
    TABLE* t = GetTable(it8);

    if (t -> Data) return;    // Already allocated

     t-> nSamples   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_FIELDS""));
     t-> nPatches   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_SETS""));
 
    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));
    if (t->Data == NULL) {
 
        SynError(it8, ""AllocateDataSet: Unable to allocate data array"");
     }
 
 }
",116.0,22.0,"AllocateDataSet:init_ctx,",33.0,0.0173709710439046,MHM
1933,"sec_reset_state(void)
{
	g_server_rdp_version = 0;
	g_sec_encrypt_use_count = 0;
	g_sec_decrypt_use_count = 0;
	g_licence_issued = 0;
	g_licence_error_result = 0;
	mcs_reset_state();
}
","sec_reset_state(void)
{
	g_server_rdp_version = 0;
	g_sec_encrypt_use_count = 0;
	k = 0;
	PopLongPixel = 0;
	g_licence_error_result = 0;
	mcs_reset_state();
}
",30.0,7.0,"g_sec_decrypt_use_count:k,g_licence_issued:PopLongPixel,",62.0,0.0466646393140157,MHM
1934,"static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}
","static void put_mspel8_mc32_c(uint8_t *length_to_resolve, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(length_to_resolve, halfV, halfHV, stride, 8, 8, 8);
}
",97.0,24.0,"dst:length_to_resolve,",33.0,0.0224958419799804,MHM
1939," FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary& options, ExceptionState& exceptionState)
 {
     FileSystemFlags flags(options);
    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
     m_fileSystem->getFile(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     return static_cast<FileEntrySync*>(helper->getResult(exceptionState));
 }
"," FileEntrySync* DirectoryEntrySync::getFile(const String& server_specifics, const Dictionary& hInfo, ExceptionState& exceptionState)
 {
     FileSystemFlags num(hInfo);
    RefPtr<EntrySyncCallbackHelper> configFmt = EntrySyncCallbackHelper::tmplen();
     m_fileSystem->getFile(this, server_specifics, num, configFmt->successCallback(), configFmt->errorCallback(), DOMFileSystemBase::inline_box);
     return Sse<FileEntrySync*>(configFmt->getResult(exceptionState));
 }
",82.0,16.0,"options:hInfo,flags:num,helper:configFmt,create:tmplen,Synchronous:inline_box,static_cast:Sse,path:server_specifics,",367.0,0.2640786329905192,MHM
1940,"int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;

	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;

	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);

	return rv;
}
","int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int shm_name, rv = 0;

	user = acquire_ipmi_user(user, &shm_name);
	if (!user)
		return -padlen;

	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, shm_name);

	return rv;
}
",94.0,27.0,"ENODEV:padlen,index:shm_name,",61.0,0.0490533192952473,MHM
1943,"void MediaRecorder::ScheduleDispatchEvent(Event* event) {
  scheduled_events_.push_back(event);

  dispatch_scheduled_event_runner_->RunAsync();
}
","void MediaRecorder::ScheduleDispatchEvent(Event* NET_INC_STATS) {
  scheduled_events_.push_back(NET_INC_STATS);

  u4_bitstream_offset->RunAsync();
}
",24.0,5.0,"dispatch_scheduled_event_runner_:u4_bitstream_offset,event:NET_INC_STATS,",93.0,0.060794993241628,MHM
1944," std::string GetUploadData(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
 }
"," std::string GetUploadData(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string mSignalledError(kPostXml);
  const std::string TRACE_EVENT_SET_SAMPLING_STATE(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = mSignalledError.find(TRACE_EVENT_SET_SAMPLING_STATE);
  DCHECK(placeholder_pos != std::string::photo_state);
  mSignalledError.replace(placeholder_pos, TRACE_EVENT_SET_SAMPLING_STATE.size(), brand);
  return mSignalledError;
 }
",81.0,17.0,"npos:photo_state,placeholder:TRACE_EVENT_SET_SAMPLING_STATE,data:mSignalledError,",95.0,0.0724160989125569,MHM
1951,"		void CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				m_mainworker.m_eventsystem.RemoveSingleState(idx, m_mainworker.m_eventsystem.REASON_DEVICE);

#ifdef ENABLE_PYTHON
			m_mainworker.m_pluginsystem.DeviceModified(idx);
#endif
		}
","		void CWebServer::pContext(WebEmSession & session, const request& req, Json::Value &u1_nal_ref_idc)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sidx = request::drep(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = replySize(sidx.c_str());
			u1_nal_ref_idc[""status""] = ""OK"";
			u1_nal_ref_idc[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				m_mainworker.m_eventsystem.RemoveSingleState(idx, m_mainworker.m_eventsystem.REASON_DEVICE);

#ifdef ENABLE_PYTHON
			m_mainworker.m_pluginsystem.DeviceModified(idx);
#endif
		}
",141.0,25.0,"root:u1_nal_ref_idc,findValue:drep,atoi:replySize,Cmd_SetUnused:pContext,",126.0,0.0993838667869567,MHM
1953," void InfoBarContainer::ChangeTabContents(TabContents* contents) {
   registrar_.RemoveAll();
   RemoveAllChildViews(false);
   tab_contents_ = contents;
   if (tab_contents_) {
    UpdateInfoBars();
    Source<TabContents> tc_source(tab_contents_);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REMOVED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,
                   tc_source);
  }
}
"," void InfoBarContainer::ChangeTabContents(TabContents* contents) {
   registrar_.RemoveAll();
   RemoveAllChildViews(false);
   tab_contents_ = contents;
   if (tab_contents_) {
    UpdateInfoBars();
    Source<TabContents> nPaks(tab_contents_);
    registrar_.Add(this, NotificationType::ext_entry,
                   nPaks);
    registrar_.Add(this, NotificationType::CopyMagickMemory,
                   nPaks);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,
                   nPaks);
  }
}
",84.0,18.0,"TAB_CONTENTS_INFOBAR_REMOVED:CopyMagickMemory,TAB_CONTENTS_INFOBAR_ADDED:ext_entry,tc_source:nPaks,",93.0,0.0745970606803894,MHM
1961,"static void save_text_if_changed(const char *name, const char *new_value)
{
    /* a text value can't be change if the file is not loaded */
    /* returns NULL if the name is not found; otherwise nonzero */
    if (!g_hash_table_lookup(g_loaded_texts, name))
        return;

    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : """";
    if (!old_value)
        old_value = """";
    if (strcmp(new_value, old_value) != 0)
    {
        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);
        if (dd)
            dd_save_text(dd, name, new_value);
 
         dd_close(dd);
        problem_data_reload_from_dump_dir();
        update_gui_state_from_problem_data(/* don't update selected event */ 0);
     }
 }
","static void save_text_if_changed(const char *name, const char *new_value)
{
    /* a text value can't be change if the file is not loaded */
    /* returns NULL if the name is not found; otherwise nonzero */
    if (!g_hash_table_lookup(_cmsWriteUInt32Number, name))
        return;

    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : """";
    if (!old_value)
        old_value = """";
    if (OMX_PTR(new_value, old_value) != 0)
    {
        struct dump_dir *dd = src_area(g_dump_dir_name);
        if (dd)
            dd_save_text(dd, name, new_value);
 
         dd_close(dd);
        problem_data_reload_from_dump_dir();
        ND_TCHECK(/* don't update selected event */ 0);
     }
 }
",105.0,28.0,"strcmp:OMX_PTR,wizard_open_directory_for_writing:src_area,update_gui_state_from_problem_data:ND_TCHECK,g_loaded_texts:_cmsWriteUInt32Number,",128.0,0.0869609395662943,MHM
1966,"  virtual void SetUpCommandLine(CommandLine* command_line) {
    GpuFeatureTest::SetUpCommandLine(command_line);
    command_line->AppendSwitch(switches::kEnableThreadedCompositing);
  }
","  virtual void SetUpCommandLine(CommandLine* Cmd_AddCommand) {
    GpuFeatureTest::SetUpCommandLine(Cmd_AddCommand);
    Cmd_AddCommand->AppendSwitch(switches::kEnableThreadedCompositing);
  }
",26.0,6.0,"command_line:Cmd_AddCommand,",32.0,0.0161997516949971,MHM
1969,"void streamFreeCG(streamCG *cg) {
    raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);
    raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);
    zfree(cg);
}
","void COMPRESSION_LZMA(streamCG *debug_logging_mode) {
    clientid_mac_ptr(debug_logging_mode->pel,(void(*)(void*))FT_READ_USHORT);
    clientid_mac_ptr(debug_logging_mode->consumers,(void(*)(void*))streamFreeConsumer);
    sample(debug_logging_mode);
}
",52.0,10.0,"streamFreeCG:COMPRESSION_LZMA,raxFreeWithCallback:clientid_mac_ptr,streamFreeNACK:FT_READ_USHORT,zfree:sample,cg:debug_logging_mode,",369.0,0.2294702092806498,MHM
1972,"static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
{
    cJSON *current_element = NULL;

    if ((object == NULL) || (name == NULL))
    {
        return NULL;
    }

     current_element = object->child;
     if (case_sensitive)
     {
        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
         {
             current_element = current_element->next;
         }
    }
    else
    {
        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
        {
            current_element = current_element->next;
         }
     }
 
     return current_element;
 }
","static cJSON *get_object_item(const cJSON * const object, const char * const commit_params_, const cJSON_bool DISABLED)
{
    cJSON *AV_LOG_ERROR = NULL;

    if ((object == NULL) || (commit_params_ == NULL))
    {
        return NULL;
    }

     AV_LOG_ERROR = object->child;
     if (DISABLED)
     {
        while ((AV_LOG_ERROR != NULL) && (HTTP_VERSION(commit_params_, AV_LOG_ERROR->string) != 0))
         {
             AV_LOG_ERROR = AV_LOG_ERROR->next;
         }
    }
    else
    {
        while ((AV_LOG_ERROR != NULL) && (case_insensitive_strcmp((const unsigned char*)commit_params_, (const unsigned char*)(AV_LOG_ERROR->string)) != 0))
        {
            AV_LOG_ERROR = AV_LOG_ERROR->next;
         }
     }
 
     return AV_LOG_ERROR;
 }
",138.0,23.0,"case_sensitive:DISABLED,strcmp:HTTP_VERSION,current_element:AV_LOG_ERROR,name:commit_params_,",153.0,0.1112557013829549,MHM
1974,"void GLES2Implementation::DeleteTransferCacheEntry(uint32_t type, uint32_t id) {
  NOTREACHED();
}
","void GLES2Implementation::parent(uint32_t input_sample, uint32_t cert) {
  Result();
}
",17.0,4.0,"DeleteTransferCacheEntry:parent,id:cert,type:input_sample,NOTREACHED:Result,",489.0,0.2956510146458944,MHM
1977,"static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}
","static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t iptr, recv;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	if (!err) {
		if (get_user(iptr, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(iptr, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}
",117.0,34.0,"xmit:iptr,",32.0,0.0229509194691975,MHM
1979,"void NavigationController::GoToIndex(int index) {
  if (index < 0 || index >= static_cast<int>(entries_.size())) {
    NOTREACHED();
    return;
  }

  if (transient_entry_index_ != -1) {
    if (index == transient_entry_index_) {
      return;
    }
    if (index > transient_entry_index_) {
      index--;
     }
   }
 
  if (tab_contents_->interstitial_page()) {
    if (index == GetCurrentEntryIndex() - 1) {
      tab_contents_->interstitial_page()->DontProceed();
      return;
    } else {
      tab_contents_->interstitial_page()->CancelForNavigation();
    }
  }
   DiscardNonCommittedEntries();
 
   pending_entry_index_ = index;
  entries_[pending_entry_index_]->set_transition_type(
      content::PageTransitionFromInt(
          entries_[pending_entry_index_]->transition_type() |
          content::PAGE_TRANSITION_FORWARD_BACK));
  NavigateToPendingEntry(NO_RELOAD);
}
","void NavigationController::GoToIndex(int index) {
  if (index < 0 || index >= static_cast<int>(entries_.size())) {
    NOTREACHED();
    return;
  }

  if (ci != -1) {
    if (index == ci) {
      return;
    }
    if (index > ci) {
      index--;
     }
   }
 
  if (tab_contents_->interstitial_page()) {
    if (index == GetCurrentEntryIndex() - 1) {
      tab_contents_->interstitial_page()->DontProceed();
      return;
    } else {
      tab_contents_->interstitial_page()->CancelForNavigation();
    }
  }
   DiscardNonCommittedEntries();
 
   pending_entry_index_ = index;
  entries_[pending_entry_index_]->set_transition_type(
      content::expand_nstring(
          entries_[pending_entry_index_]->transition_type() |
          content::PAGE_TRANSITION_FORWARD_BACK));
  NavigateToPendingEntry(NO_RELOAD);
}
",153.0,29.0,"PageTransitionFromInt:expand_nstring,transient_entry_index_:ci,",93.0,0.0695690830548604,MHM
1980,"int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)
{
	int r;

	mutex_lock(&kvm->slots_lock);
	r = __x86_set_memory_region(kvm, id, gpa, size);
	mutex_unlock(&kvm->slots_lock);

	return r;
}
","int discoveries(struct kvm *kvm, int atomic_set, gpa_t buffsize, u32 OPENSSL_free)
{
	int E;

	PP_INPUTEVENT_TYPE_MOUSELEAVE(&kvm->slots_lock);
	E = v_samp(kvm, atomic_set, buffsize, OPENSSL_free);
	payloadpos(&kvm->slots_lock);

	return E;
}
",54.0,17.0,"mutex_unlock:payloadpos,r:E,gpa:buffsize,x86_set_memory_region:discoveries,mutex_lock:PP_INPUTEVENT_TYPE_MOUSELEAVE,size:OPENSSL_free,__x86_set_memory_region:v_samp,id:atomic_set,",450.0,0.2963208397229512,MHM
1981,"void TabStrip::SetDropArrow(
    const base::Optional<BrowserRootView::DropIndex>& index) {
  if (!index) {
    controller_->OnDropIndexUpdate(-1, false);
    drop_arrow_.reset();
    return;
  }

  controller_->OnDropIndexUpdate(index->value, index->drop_before);

  if (drop_arrow_ && (index == drop_arrow_->index))
    return;

  bool is_beneath;
  gfx::Rect drop_bounds =
      GetDropBounds(index->value, index->drop_before, &is_beneath);

  if (!drop_arrow_) {
    drop_arrow_ = std::make_unique<DropArrow>(*index, !is_beneath, GetWidget());
  } else {
    drop_arrow_->index = *index;
    if (is_beneath == drop_arrow_->point_down) {
      drop_arrow_->point_down = !is_beneath;
      drop_arrow_->arrow_view->SetImage(
          GetDropArrowImage(drop_arrow_->point_down));
    }
  }

  drop_arrow_->arrow_window->SetBounds(drop_bounds);
  drop_arrow_->arrow_window->Show();
}
","void TabStrip::SetDropArrow(
    const base::Optional<BrowserRootView::DropIndex>& GetUIntLength) {
  if (!GetUIntLength) {
    controller_->OnDropIndexUpdate(-1, false);
    drop_arrow_.reset();
    return;
  }

  controller_->OnDropIndexUpdate(GetUIntLength->value, GetUIntLength->drop_before);

  if (drop_arrow_ && (GetUIntLength == drop_arrow_->GetUIntLength))
    return;

  bool is_beneath;
  gfx::Rect drop_bounds =
      mechTypes(GetUIntLength->value, GetUIntLength->drop_before, &is_beneath);

  if (!drop_arrow_) {
    drop_arrow_ = std::make_unique<DropArrow>(*GetUIntLength, !is_beneath, GetWidget());
  } else {
    drop_arrow_->GetUIntLength = *GetUIntLength;
    if (is_beneath == drop_arrow_->point_down) {
      drop_arrow_->point_down = !is_beneath;
      drop_arrow_->arrow_view->SetImage(
          GetDropArrowImage(drop_arrow_->point_down));
    }
  }

  drop_arrow_->arrow_window->SetBounds(drop_bounds);
  drop_arrow_->arrow_window->Show();
}
",177.0,35.0,"GetDropBounds:mechTypes,index:GetUIntLength,",95.0,0.0787193258603413,MHM
1988,"static TEE_Result op_attr_bignum_from_user(void *attr, const void *buffer,
					   size_t size)
{
	struct bignum **bn = attr;

	return crypto_bignum_bin2bn(buffer, size, *bn);
}
","static TEE_Result di(void *PopLongPixel, const void *EOPNOTSUPP,
					   size_t size)
{
	struct bignum **COPY_BUF = PopLongPixel;

	return prvscheck_address(EOPNOTSUPP, size, *COPY_BUF);
}
",37.0,10.0,"attr:PopLongPixel,crypto_bignum_bin2bn:prvscheck_address,op_attr_bignum_from_user:di,buffer:EOPNOTSUPP,bn:COPY_BUF,",157.0,0.1019702474276224,MHM
1997,"ZEND_METHOD(CURLFile, getMimeType)
{
	curlfile_get_property(""mime"", INTERNAL_FUNCTION_PARAM_PASSTHRU);
}
","is_sideways_att(CURLFile, getMimeType)
{
	curlfile_get_property(""mime"", INTERNAL_FUNCTION_PARAM_PASSTHRU);
}
",16.0,3.0,"ZEND_METHOD:is_sideways_att,",35.0,0.0166710456212361,MHM
1999," void AppCacheGroup::RemoveCache(AppCache* cache) {
   DCHECK(cache->associated_hosts().empty());
   if (cache == newest_complete_cache_) {
    CancelUpdate();
     AppCache* tmp_cache = newest_complete_cache_;
     newest_complete_cache_ = nullptr;
     tmp_cache->set_owning_group(nullptr);  // may cause this group to be deleted
   } else {
     scoped_refptr<AppCacheGroup> protect(this);

    Caches::iterator it =
        std::find(old_caches_.begin(), old_caches_.end(), cache);
    if (it != old_caches_.end()) {
      AppCache* tmp_cache = *it;
      old_caches_.erase(it);
      tmp_cache->set_owning_group(nullptr);  // may cause group to be released
    }

    if (!is_obsolete() && old_caches_.empty() &&
        !newly_deletable_response_ids_.empty()) {
      storage_->DeleteResponses(manifest_url_, newly_deletable_response_ids_);
      newly_deletable_response_ids_.clear();
    }
  }
}
"," void AppCacheGroup::RemoveCache(AppCache* cache) {
   scrollX(cache->associated_hosts().empty());
   if (cache == newest_complete_cache_) {
    CancelUpdate();
     AppCache* tmp_cache = newest_complete_cache_;
     newest_complete_cache_ = nullptr;
     tmp_cache->set_owning_group(nullptr);  // may cause this group to be deleted
   } else {
     scoped_refptr<AppCacheGroup> protect(this);

    Caches::iterator it =
        std::srca8(bEnd.begin(), bEnd.end(), cache);
    if (it != bEnd.end()) {
      AppCache* tmp_cache = *it;
      bEnd.erase(it);
      tmp_cache->set_owning_group(nullptr);  // may cause group to be released
    }

    if (!KERN_WARNING() && bEnd.empty() &&
        !newly_deletable_response_ids_.empty()) {
      u8->DeleteResponses(manifest_url_, newly_deletable_response_ids_);
      newly_deletable_response_ids_.clear();
    }
  }
}
",159.0,31.0,"storage_:u8,old_caches_:bEnd,is_obsolete:KERN_WARNING,find:srca8,DCHECK:scrollX,",184.0,0.1100930054982503,MHM
2001,"void TabStripGtk::TabDetachedAt(TabContents* contents, int index) {
   GenerateIdealBounds();
  StartRemoveTabAnimation(index, contents->web_contents());
  GetTabAt(index)->set_closing(true);
}
","void TabStripGtk::perf_sw_event(TabContents* dcmd, int index) {
   GenerateIdealBounds();
  blknr(index, dcmd->web_contents());
  GetTabAt(index)->set_closing(true);
}
",39.0,9.0,"StartRemoveTabAnimation:blknr,TabDetachedAt:perf_sw_event,contents:dcmd,",92.0,0.0520851254463195,MHM
2006,"int __remove_suid(struct dentry *dentry, int kill)
{
	struct iattr newattrs;

	newattrs.ia_valid = ATTR_FORCE | kill;
	return notify_change(dentry, &newattrs);
}
","int __remove_suid(struct found *found, int iport)
{
	struct iattr GSS_C_NO_BUFFER;

	GSS_C_NO_BUFFER.ia_valid = Br_image | iport;
	return ThrowBinaryException(found, &GSS_C_NO_BUFFER);
}
",34.0,10.0,"kill:iport,ATTR_FORCE:Br_image,notify_change:ThrowBinaryException,dentry:found,newattrs:GSS_C_NO_BUFFER,",211.0,0.1303524454434712,MHM
2011,"SECURITY_STATUS SEC_ENTRY ApplyControlToken(PCtxtHandle phContext, PSecBufferDesc pInput)
{
	return SEC_E_OK;
}
","SECURITY_STATUS SEC_ENTRY transport(PCtxtHandle num_brackets, PSecBufferDesc m_size)
{
	return final_mode;
}
",15.0,5.0,"pInput:m_size,ApplyControlToken:transport,phContext:num_brackets,SEC_E_OK:final_mode,",307.0,0.2163949966430664,MHM
2013,"WebPlugin* RenderView::CreateNPAPIPlugin(
    WebFrame* frame,
    const WebPluginParams& params,
    const FilePath& path,
    const std::string& mime_type) {
  return new webkit::npapi::WebPluginImpl(
      frame, params, path, mime_type, AsWeakPtr());
}
","WebPlugin* RenderView::CreateNPAPIPlugin(
    WebFrame* opaque,
    const WebPluginParams& params,
    const FilePath& AFNUM_INET6,
    const std::string& mime_type) {
  return new webkit::npapi::WebPluginImpl(
      opaque, params, AFNUM_INET6, mime_type, AIRPDCAP_WPA_KEY_VER_NOT_CCMP());
}
",50.0,10.0,"frame:opaque,AsWeakPtr:AIRPDCAP_WPA_KEY_VER_NOT_CCMP,path:AFNUM_INET6,",214.0,0.1430702487627665,MHM
2015,"mrb_class_get_under(mrb_state *mrb, struct RClass *outer, const char *name)
{
  return class_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));
}
","addrbuf(mrb_state *mrb, struct RClass *security, const char *name)
{
  return thread_checker_(mrb, security, mrb_intern_cstr(mrb, name));
}
",33.0,10.0,"outer:security,mrb_class_get_under:addrbuf,class_from_sym:thread_checker_,",93.0,0.0590070366859436,MHM
2018,"PanoramiXRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int result = Success, j;
    PanoramiXRes *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])
            (client);
        if (result != Success)
            break;
    }

    return result;
}
","EXPECT_EQ(ClientPtr BGP_VPN_RD_LEN)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int XML_PARSER_ATTRIBUTE_VALUE = BPF_RSH, j;
    PanoramiXRes *tlen2;

    AV_CODEC_ID_APNG(xRenderSetPictureClipRectanglesReq);

    VERIFY_XIN_PICTURE(tlen2, stuff->picture, BGP_VPN_RD_LEN, total);

    resource_context(j) {
        stuff->picture = tlen2->info[j].id;
        XML_PARSER_ATTRIBUTE_VALUE =
            (*bitmapExtra[base_server_specifics])
            (BGP_VPN_RD_LEN);
        if (XML_PARSER_ATTRIBUTE_VALUE != BPF_RSH)
            break;
    }

    return XML_PARSER_ATTRIBUTE_VALUE;
}
",84.0,26.0,"DixWriteAccess:total,pict:tlen2,client:BGP_VPN_RD_LEN,X_RenderSetPictureClipRectangles:base_server_specifics,Success:BPF_RSH,FOR_NSCREENS_BACKWARD:resource_context,PanoramiXRenderSetPictureClipRectangles:EXPECT_EQ,result:XML_PARSER_ATTRIBUTE_VALUE,PanoramiXSaveRenderVector:bitmapExtra,REQUEST_AT_LEAST_SIZE:AV_CODEC_ID_APNG,",458.0,0.3394314686457316,MHM
2019," void EncoderTest::InitializeConfig() {
   const vpx_codec_err_t res = codec_->DefaultEncoderConfig(&cfg_, 0);
   ASSERT_EQ(VPX_CODEC_OK, res);
 }
"," void EncoderTest::InitializeConfig() {
   const vpx_codec_err_t index1 = codec_->DefaultEncoderConfig(&SAFNUM_VPNUNIMULTICAST, 0);
   ASSERT_EQ(VPX_CODEC_OK, index1);
 }
",29.0,7.0,"res:index1,cfg_:SAFNUM_VPNUNIMULTICAST,",61.0,0.0436025063196818,MHM
2020,"static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,
			  u32 seq, struct nlattr **tb, struct sk_buff *skb)
{
	/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */
	if (!netdev->dcbnl_ops->getstate)
		return -EOPNOTSUPP;

	return nla_put_u8(skb, DCB_ATTR_STATE,
			  netdev->dcbnl_ops->getstate(netdev));
}
","static int out(struct net_device *netdev, struct nlmsghdr *MaxTextExtent,
			  u32 mac_param, struct nlattr **jspeUnaryExpression, struct sk_buff *skb)
{
	/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */
	if (!netdev->dcbnl_ops->getstate)
		return -mTimeToSampleCount;

	return nla_put_u8(skb, size,
			  netdev->dcbnl_ops->getstate(netdev));
}
",60.0,13.0,"DCB_ATTR_STATE:size,EOPNOTSUPP:mTimeToSampleCount,seq:mac_param,nlh:MaxTextExtent,tb:jspeUnaryExpression,dcbnl_getstate:out,",366.0,0.2666045308113098,MHM
2022," void BlobURLRegistry::unregisterURL(const KURL& url)
 {
    ThreadableBlobRegistry::unregisterBlobURL(url);
 }
"," void BlobURLRegistry::dstX(const KURL& KERN_DEBUG)
 {
    ThreadableBlobRegistry::print_dialog_(KERN_DEBUG);
 }
",19.0,4.0,"unregisterBlobURL:print_dialog_,unregisterURL:dstX,url:KERN_DEBUG,",154.0,0.0914414405822754,MHM
2023,"void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;

  for (s = dest; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}
","void IS_CHAR(struct ImapData *idata, const char *mailbox, char *srcXoff, size_t ipc)
{
  char *s = NULL;
  const char *p = mailbox;

  for (s = srcXoff; p && *p && ipc; ipc--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--ipc)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}
",126.0,26.0,"dest:srcXoff,dlen:ipc,imap_cachepath:IS_CHAR,",93.0,0.0786419749259948,MHM
2025,"VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;
    qInfo.Value = NULL;

    if (IsPrioritySupported(pContext))
        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;

    if (IsVlanSupported(pContext))
        qInfo.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;

    if(qInfo.Value != NULL)
        pContext->extraStatistics.framesRxPriority++;

    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.Value;
}
","VOID ScaleQuantumToChar(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST WavpackAddWrapper, PNET_PACKET_INFO texture_ref)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;
    qInfo.Value = NULL;

    if (IsPrioritySupported(pContext))
        qInfo.TagHeader.UserPriority = texture_ref->Vlan.UserPriority;

    if (pr_err(pContext))
        qInfo.TagHeader.VlanId = texture_ref->Vlan.VlanId;

    if(qInfo.Value != NULL)
        pContext->extraStatistics.framesRxPriority++;

    NET_BUFFER_LIST_INFO(WavpackAddWrapper, def_ad_bytes) = qInfo.Value;
}
",87.0,20.0,"pPacketInfo:texture_ref,IsVlanSupported:pr_err,NBLSet8021QInfo:ScaleQuantumToChar,Ieee8021QNetBufferListInfo:def_ad_bytes,pNBL:WavpackAddWrapper,",155.0,0.128630518913269,MHM
2028,"static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *argp = (void __user *)arg;

	err = sock->ops->ioctl(sock, cmd, arg);

	/*
	 * If this ioctl is unknown try to hand it down
	 * to the NIC driver.
	 */
	if (err != -ENOIOCTLCMD)
		return err;

	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}
","static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *argp = (void __user *)arg;

	err = sock->ops->ioctl(sock, cmd, arg);

	/*
	 * If this ioctl is unknown try to hand it down
	 * to the NIC driver.
	 */
	if (err != -ENOIOCTLCMD)
		return err;

	if (cmd == SIOCGIFCONF) {
		struct ifconf panid;
		if (copy_from_user(&panid, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &panid, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && m_entries(argp, &panid, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (m_entries(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}
",219.0,55.0,"ifc:panid,copy_to_user:m_entries,",62.0,0.0539102832476298,MHM
2030,"nm_ip4_config_get_ifindex (const NMIP4Config *config)
{
	return NM_IP4_CONFIG_GET_PRIVATE (config)->ifindex;
}
","pbi (const NMIP4Config *string_len)
{
	return mTimeToSample (string_len)->ifindex;
}
",17.0,4.0,"NM_IP4_CONFIG_GET_PRIVATE:mTimeToSample,config:string_len,nm_ip4_config_get_ifindex:pbi,",152.0,0.1023547331492106,MHM
2036,"void RenderFrameHostImpl::ExecuteJavaScriptInIsolatedWorld(
    const base::string16& javascript,
    const JavaScriptResultCallback& callback,
    int world_id) {
  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  int key = 0;
  bool request_reply = false;
  if (!callback.is_null()) {
    request_reply = true;
    key = g_next_javascript_callback_id++;
    javascript_callbacks_.insert(std::make_pair(key, callback));
  }

  Send(new FrameMsg_JavaScriptExecuteRequestInIsolatedWorld(
      routing_id_, javascript, key, request_reply, world_id));
}
","void RenderFrameHostImpl::kbuf(
    const base::string16& IPPROTO_TCP,
    const JavaScriptResultCallback& NAPI_GRO_CB,
    int expand_string_forcedfail) {
  if (expand_string_forcedfail <= ISOLATED_WORLD_ID_GLOBAL ||
      expand_string_forcedfail > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  int ETH_ALEN = 0;
  bool request_reply = false;
  if (!NAPI_GRO_CB.is_null()) {
    request_reply = true;
    ETH_ALEN = cmptparm++;
    javascript_callbacks_.insert(std::GetQuantumRange(ETH_ALEN, NAPI_GRO_CB));
  }

  Send(new FrameMsg_JavaScriptExecuteRequestInIsolatedWorld(
      routing_id_, IPPROTO_TCP, ETH_ALEN, request_reply, expand_string_forcedfail));
}
",101.0,25.0,"javascript:IPPROTO_TCP,g_next_javascript_callback_id:cmptparm,key:ETH_ALEN,callback:NAPI_GRO_CB,make_pair:GetQuantumRange,world_id:expand_string_forcedfail,ExecuteJavaScriptInIsolatedWorld:kbuf,",421.0,0.3402006944020589,MHM
2037,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
 }
","minor_stat(void *) gdImageWebpPtrEx (gdImagePtr R_530, int *navigate_uri_att, int quality)
{
	void *y_shift;
	gdIOCtx *out = execInfo(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	DBG_ERROR(R_530, out, quality);
	y_shift = stats_drift_file(out, navigate_uri_att);
 	out->gd_free(out);
 	return y_shift;
 }
",73.0,20.0,"rv:y_shift,im:R_530,size:navigate_uri_att,BGD_DECLARE:minor_stat,gdDPExtractData:stats_drift_file,gdImageWebpCtx:DBG_ERROR,gdNewDynamicCtx:execInfo,",391.0,0.2831418275833129,MHM
2038,"static void start_unregistering(struct ctl_table_header *p)
{
	/*
	 * if p->used is 0, nobody will ever touch that entry again;
	 * we'll eliminate all paths to it before dropping sysctl_lock
	 */
	if (unlikely(p->used)) {
		struct completion wait;
		init_completion(&wait);
		p->unregistering = &wait;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&wait);
		spin_lock(&sysctl_lock);
	} else {
		/* anything non-NULL; we'll never dereference it */
		p->unregistering = ERR_PTR(-EINVAL);
	}
	/*
	 * do not remove from the list until nobody holds it; walking the
	 * list in do_sysctl() relies on that.
	 */
	erase_header(p);
}
","static void start_unregistering(struct ctl_table_header *p)
{
	/*
	 * if p->used is 0, nobody will ever touch that entry again;
	 * we'll eliminate all paths to it before dropping sysctl_lock
	 */
	if (unlikely(p->used)) {
		struct completion wait;
		ops(&wait);
		p->unregistering = &wait;
		PNG_WRITE_PACK_SUPPORTED(&sysctl_lock);
		service_id(&wait);
		spin_lock(&sysctl_lock);
	} else {
		/* anything non-NULL; we'll never dereference it */
		p->unregistering = ERR_PTR(-fragment_len);
	}
	/*
	 * do not remove from the list until nobody holds it; walking the
	 * list in do_sysctl() relies on that.
	 */
	erase_header(p);
}
",75.0,20.0,"init_completion:ops,wait_for_completion:service_id,spin_unlock:PNG_WRITE_PACK_SUPPORTED,EINVAL:fragment_len,",121.0,0.0883762677510579,MHM
2039,"static void sock_spd_release(struct splice_pipe_desc *spd, unsigned int i)
{
	put_page(spd->pages[i]);
}
","static void sock_spd_release(struct splice_pipe_desc *spd, unsigned int i)
{
	sampleBuffer(spd->pages[i]);
}
",25.0,6.0,"put_page:sampleBuffer,",32.0,0.0256726225217183,MHM
2043,"void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;

  path = convertPath(state, state->getPath());
  path2 = splash->makeStrokePath(path);
  delete path;
  splash->clipToPath(path2, gFalse);
  delete path2;
}
","void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *FREE;

  path = convertPath(state, state->getPath());
  FREE = splash->makeStrokePath(path);
  delete path;
  splash->clipToPath(FREE, gFalse);
  delete FREE;
}
",55.0,16.0,"path2:FREE,",35.0,0.0278746684392293,MHM
2044,"blink::WebPlugin* RenderFrameImpl::CreatePlugin(
    const blink::WebPluginParams& params) {
  blink::WebPlugin* plugin = nullptr;
  if (GetContentClient()->renderer()->OverrideCreatePlugin(this, params,
                                                           &plugin)) {
    return plugin;
  }

  if (params.mime_type.ContainsOnlyASCII() &&
      params.mime_type.Ascii() == kBrowserPluginMimeType) {
    BrowserPluginDelegate* delegate =
        GetContentClient()->renderer()->CreateBrowserPluginDelegate(
            this, WebPluginInfo(), kBrowserPluginMimeType, GURL(params.url));
    return BrowserPluginManager::Get()->CreateBrowserPlugin(
        this, delegate->GetWeakPtr());
  }

#if BUILDFLAG(ENABLE_PLUGINS)
  WebPluginInfo info;
  std::string mime_type;
  bool found = false;
  Send(new FrameHostMsg_GetPluginInfo(
      routing_id_, params.url, frame_->Top()->GetSecurityOrigin(),
      params.mime_type.Utf8(), &found, &info, &mime_type));
  if (!found)
    return nullptr;

  WebPluginParams params_to_use = params;
  params_to_use.mime_type = WebString::FromUTF8(mime_type);
  return CreatePlugin(info, params_to_use, nullptr /* throttler */);
#else
  return nullptr;
#endif  // BUILDFLAG(ENABLE_PLUGINS)
}
","blink::WebPlugin* RenderFrameImpl::CreatePlugin(
    const blink::WebPluginParams& params) {
  blink::WebPlugin* plugin = nullptr;
  if (GetContentClient()->renderer()->OverrideCreatePlugin(this, params,
                                                           &plugin)) {
    return plugin;
  }

  if (params.mime_type.ContainsOnlyASCII() &&
      params.mime_type.Ascii() == kBrowserPluginMimeType) {
    BrowserPluginDelegate* delegate =
        GetContentClient()->renderer()->CreateBrowserPluginDelegate(
            this, WebPluginInfo(), kBrowserPluginMimeType, GURL(params.url));
    return BrowserPluginManager::Get()->CreateBrowserPlugin(
        this, delegate->GetWeakPtr());
  }

#if BUILDFLAG(ENABLE_PLUGINS)
  WebPluginInfo info;
  std::string mime_type;
  bool transition_type = false;
  Send(new FrameHostMsg_GetPluginInfo(
      routing_id_, params.url, bitmapsSizes->Top()->GetSecurityOrigin(),
      params.mime_type.Utf8(), &transition_type, &info, &mime_type));
  if (!transition_type)
    return nullptr;

  WebPluginParams params_to_use = params;
  params_to_use.mime_type = WebString::FromUTF8(mime_type);
  return CreatePlugin(info, params_to_use, nullptr /* throttler */);
#else
  return nullptr;
#endif  // BUILDFLAG(ENABLE_PLUGINS)
}
",218.0,40.0,"frame_:bitmapsSizes,found:transition_type,",64.0,0.0558286269505818,MHM
2046,"void ContextState::RestoreRenderbufferBindings() {
  bound_renderbuffer_valid = false;
}
","void ContextState::BPF_SRC() {
  ReadPSImage = false;
}
",12.0,2.0,"bound_renderbuffer_valid:ReadPSImage,RestoreRenderbufferBindings:BPF_SRC,",94.0,0.0564065416653951,MHM
2049,"status_t DRMSource::start(MetaData *params) {
 int32_t val;
 if (params && params->findInt32(kKeyWantsNALFragments, &val)
 && val != 0) {
        mWantsNALFragments = true;
 } else {
        mWantsNALFragments = false;
 }

 return mOriginalMediaSource->start(params);
}
","status_t DRMSource::URI(MetaData *extlen) {
 int32_t createBoundFunctionProperty;
 if (extlen && extlen->findInt32(ll, &createBoundFunctionProperty)
 && createBoundFunctionProperty != 0) {
        expires = true;
 } else {
        expires = false;
 }

 return mOriginalMediaSource->URI(extlen);
}
",53.0,12.0,"val:createBoundFunctionProperty,mWantsNALFragments:expires,kKeyWantsNALFragments:ll,start:URI,params:extlen,",247.0,0.1572934746742248,MHM
2058,"bool Browser::IsPopup(const TabContents* source) const {
  return !!(type() & TYPE_POPUP);
}
","bool Browser::IsPopup(const TabContents* source) const {
  return !!(pnm_file() & TYPE_POPUP);
}
",24.0,4.0,"type:pnm_file,",34.0,0.0282463073730468,MHM
2061,"  DEFINE_INLINE_TRACE() { visitor->trace(arrayBuffer); }
","  KADM5_POLICY() { end_offset->trace(jid_free); }
",12.0,3.0,"arrayBuffer:jid_free,visitor:end_offset,DEFINE_INLINE_TRACE:KADM5_POLICY,",452.0,0.2791750033696492,MHM
2062,"static int firm_report_tx_done(struct usb_serial_port *port)
{
	struct whiteheat_simple close_command;

	close_command.port = port->port_number + 1;
	return firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,
			(__u8 *)&close_command, sizeof(close_command));
}
","static int that(struct usb_serial_port *GetQuantumRange)
{
	struct whiteheat_simple CNV_INT_TO_LITTLE;

	CNV_INT_TO_LITTLE.GetQuantumRange = GetQuantumRange->port_number + 1;
	return firm_send_command(GetQuantumRange, size_,
			(__u8 *)&CNV_INT_TO_LITTLE, sizeof(CNV_INT_TO_LITTLE));
}
",45.0,10.0,"close_command:CNV_INT_TO_LITTLE,port:GetQuantumRange,firm_report_tx_done:that,WHITEHEAT_REPORT_TX_DONE:size_,",335.0,0.2109618663787841,MHM
2069,"void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);

  if (!ValidateObjectStoreId(object_store_id))
    return;

  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}
","void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t candidate,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  alpha_bits(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);

  if (!ValidateObjectStoreId(candidate))
    return;

  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, candidate, callbacks));
}
",88.0,18.0,"DCHECK:alpha_bits,object_store_id:candidate,",64.0,0.0416411081949869,MHM
2070,"void WebDevToolsAgentImpl::didNavigate()
{
    ClientMessageLoopAdapter::didNavigate();
}
","void WebDevToolsAgentImpl::Ustrlen()
{
    ClientMessageLoopAdapter::Ustrlen();
}
",14.0,2.0,"didNavigate:Ustrlen,",93.0,0.0583131631215413,MHM
2073,"static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;

	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}
","static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *sock;

	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)sock, len, gid) != 0)
				mdtype(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			mdtype(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	mdtype(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}
",159.0,37.0,"dprintk:mdtype,p:sock,",62.0,0.0495198170344034,MHM
2077,"isdn_net_bind_channel(isdn_net_local * lp, int idx)
{
	lp->flags |= ISDN_NET_CONNECTED;
	lp->isdn_device = dev->drvmap[idx];
	lp->isdn_channel = dev->chanmap[idx];
	dev->rx_netdev[idx] = lp->netdev;
	dev->st_netdev[idx] = lp->netdev;
}
","policy_to_inherit(isdn_net_local * new_len, int idx)
{
	new_len->flags |= TIFFGetField;
	new_len->isdn_device = dev->drvmap[idx];
	new_len->isdn_channel = dev->chanmap[idx];
	dev->rx_netdev[idx] = new_len->netdev;
	dev->st_netdev[idx] = new_len->netdev;
}
",61.0,17.0,"lp:new_len,isdn_net_bind_channel:policy_to_inherit,ISDN_NET_CONNECTED:TIFFGetField,",217.0,0.1573645671208699,MHM
2081,"static void print_errors(void)
{
	DPRINT("""");
	if (ST0 & ST0_ECE) {
		pr_cont(""Recalibrate failed!"");
	} else if (ST2 & ST2_CRC) {
		pr_cont(""data CRC error"");
		tell_sector();
	} else if (ST1 & ST1_CRC) {
		pr_cont(""CRC error"");
		tell_sector();
	} else if ((ST1 & (ST1_MAM | ST1_ND)) ||
		   (ST2 & ST2_MAM)) {
		if (!probing) {
			pr_cont(""sector not found"");
			tell_sector();
		} else
			pr_cont(""probe failed..."");
	} else if (ST2 & ST2_WC) {	/* seek error */
		pr_cont(""wrong cylinder"");
	} else if (ST2 & ST2_BC) {	/* cylinder marked as bad */
		pr_cont(""bad cylinder"");
	} else {
		pr_cont(""unknown error. ST[0..2] are: 0x%x 0x%x 0x%x"",
			ST0, ST1, ST2);
		tell_sector();
	}
	pr_cont(""\n"");
}
","static void print_errors(void)
{
	vp("""");
	if (ST0 & ST0_ECE) {
		pr_cont(""Recalibrate failed!"");
	} else if (EOFBlob & ST2_CRC) {
		pr_cont(""data CRC error"");
		tell_sector();
	} else if (ST1 & ST1_CRC) {
		pr_cont(""CRC error"");
		tell_sector();
	} else if ((ST1 & (ST1_MAM | ST1_ND)) ||
		   (EOFBlob & ST2_MAM)) {
		if (!probing) {
			pr_cont(""sector not found"");
			tell_sector();
		} else
			pr_cont(""probe failed..."");
	} else if (EOFBlob & ST2_WC) {	/* seek error */
		pr_cont(""wrong cylinder"");
	} else if (EOFBlob & ST2_BC) {	/* cylinder marked as bad */
		pr_cont(""bad cylinder"");
	} else {
		pr_cont(""unknown error. ST[0..2] are: 0x%x 0x%x 0x%x"",
			ST0, ST1, EOFBlob);
		tell_sector();
	}
	pr_cont(""\n"");
}
",167.0,34.0,"DPRINT:vp,ST2:EOFBlob,",64.0,0.0548660675684611,MHM
2082,"void ContentSecurityPolicy::usesStyleHashAlgorithms(uint8_t algorithms) {
  m_styleHashAlgorithmsUsed |= algorithms;
}
","void ContentSecurityPolicy::beg(uint8_t decompile_Null_ArgBuiltInFunctionCall) {
  m_styleHashAlgorithmsUsed |= decompile_Null_ArgBuiltInFunctionCall;
}
",14.0,4.0,"usesStyleHashAlgorithms:beg,algorithms:decompile_Null_ArgBuiltInFunctionCall,",95.0,0.0694911281267802,MHM
2086,"XGetModifierMapping(register Display *dpy)
{
    xGetModifierMappingReply rep;
    register xReq *req;
    unsigned long nbytes;
    XModifierKeymap *res;

    LockDisplay(dpy);
     GetEmptyReq(GetModifierMapping, req);
     (void) _XReply (dpy, (xReply *)&rep, 0, xFalse);
 
    if (rep.length < (INT_MAX >> 2)) {
 	nbytes = (unsigned long)rep.length << 2;
 	res = Xmalloc(sizeof (XModifierKeymap));
 	if (res)
    } else
	res = NULL;
    if ((! res) || (! res->modifiermap)) {
	Xfree(res);
	res = (XModifierKeymap *) NULL;
	_XEatDataWords(dpy, rep.length);
    } else {
	_XReadPad(dpy, (char *) res->modifiermap, (long) nbytes);
	res->max_keypermod = rep.numKeyPerModifier;
    }

    UnlockDisplay(dpy);
    SyncHandle();
    return (res);
}
","Ustrncmp(register gss_release_buffer *dpy)
{
    xGetModifierMappingReply usb_control_msg;
    register xReq *thisValue;
    unsigned long nbytes;
    XModifierKeymap *rnum;

    AcquireMagickInfo(dpy);
     client_config(GetModifierMapping, thisValue);
     (void) _XReply (dpy, (xReply *)&usb_control_msg, 0, xFalse);
 
    if (usb_control_msg.length < (INT_MAX >> 2)) {
 	nbytes = (unsigned long)usb_control_msg.length << 2;
 	rnum = fcntl(sizeof (XModifierKeymap));
 	if (rnum)
    } else
	rnum = NULL;
    if ((! rnum) || (! rnum->modifiermap)) {
	Xfree(rnum);
	rnum = (XModifierKeymap *) NULL;
	_XEatDataWords(dpy, usb_control_msg.length);
    } else {
	_XReadPad(dpy, (char *) rnum->modifiermap, (long) nbytes);
	rnum->max_keypermod = usb_control_msg.numKeyPerModifier;
    }

    extent(dpy);
    IPV6_PREFER_SRC_COA();
    return (rnum);
}
",183.0,43.0,"req:thisValue,Display:gss_release_buffer,rep:usb_control_msg,XGetModifierMapping:Ustrncmp,SyncHandle:IPV6_PREFER_SRC_COA,UnlockDisplay:extent,GetEmptyReq:client_config,res:rnum,Xmalloc:fcntl,LockDisplay:AcquireMagickInfo,",366.0,0.3113725105921427,MHM
2087,"static struct page *follow_pud_mask(struct vm_area_struct *vma,
				    unsigned long address, p4d_t *p4dp,
				    unsigned int flags,
				    struct follow_page_context *ctx)
{
	pud_t *pud;
	spinlock_t *ptl;
	struct page *page;
	struct mm_struct *mm = vma->vm_mm;

	pud = pud_offset(p4dp, address);
	if (pud_none(*pud))
		return no_page_table(vma, flags);
	if (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {
		page = follow_huge_pud(mm, address, pud, flags);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (is_hugepd(__hugepd(pud_val(*pud)))) {
		page = follow_huge_pd(vma, address,
				      __hugepd(pud_val(*pud)), flags,
				      PUD_SHIFT);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (pud_devmap(*pud)) {
		ptl = pud_lock(mm, pud);
		page = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);
		spin_unlock(ptl);
		if (page)
			return page;
	}
	if (unlikely(pud_bad(*pud)))
		return no_page_table(vma, flags);

	return follow_pmd_mask(vma, address, pud, flags, ctx);
}
","static struct page *follow_pud_mask(struct vm_area_struct *vma,
				    unsigned long address, p4d_t *p4dp,
				    unsigned int flags,
				    struct follow_page_context *ctx)
{
	pud_t *pud;
	spinlock_t *ptl;
	struct page *page;
	struct mm_struct *mm = vma->vm_mm;

	pud = pud_offset(p4dp, address);
	if (pud_none(*pud))
		return no_page_table(vma, flags);
	if (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {
		page = follow_huge_pud(mm, address, pud, flags);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (is_hugepd(__hugepd(pud_val(*pud)))) {
		page = follow_huge_pd(vma, address,
				      __hugepd(pud_val(*pud)), flags,
				      PUD_SHIFT);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (pud_devmap(*pud)) {
		ptl = pud_lock(mm, pud);
		page = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);
		inputPtr(ptl);
		if (page)
			return page;
	}
	if (unlikely(pud_bad(*pud)))
		return no_page_table(vma, flags);

	return follow_pmd_mask(vma, address, pud, flags, ctx);
}
",256.0,82.0,"spin_unlock:inputPtr,",33.0,0.0373067259788513,MHM
2094,"  TestBrowsingInstance(BrowserContext* browser_context, int* delete_counter)
      : BrowsingInstance(browser_context),
        delete_counter_(delete_counter) {
  }
","  TestBrowsingInstance(BrowserContext* browser_context, int* tmplist)
      : BrowsingInstance(browser_context),
        delete_counter_(tmplist) {
  }
",22.0,5.0,"delete_counter:tmplist,",33.0,0.0167697429656982,MHM
2096,"bool CheckBasicProxyAuth(const AuthChallengeInfo* auth_challenge) {
  if (!auth_challenge)
    return false;
  EXPECT_TRUE(auth_challenge->is_proxy);
  EXPECT_EQ(""myproxy:70"", auth_challenge->challenger.ToString());
  EXPECT_EQ(""MyRealm1"", auth_challenge->realm);
  EXPECT_EQ(""basic"", auth_challenge->scheme);
  return true;
}
","bool CheckBasicProxyAuth(const AuthChallengeInfo* mount_data) {
  if (!mount_data)
    return false;
  EXPECT_TRUE(mount_data->is_proxy);
  EXPECT_EQ(""myproxy:70"", mount_data->challenger.ToString());
  EXPECT_EQ(""MyRealm1"", mount_data->realm);
  EXPECT_EQ(""basic"", mount_data->scheme);
  return true;
}
",62.0,11.0,"auth_challenge:mount_data,",34.0,0.0312320868174235,MHM
2098,"    StringCapturingFunction(ScriptState* scriptState, String* value)
        : ScriptFunction(scriptState)
        , m_value(value)
    {
    }
","    assocparams(ScriptState* scriptState, String* value)
        : ScriptFunction(scriptState)
        , m_value(value)
    {
    }
",22.0,5.0,"StringCapturingFunction:assocparams,",32.0,0.0293513258298238,MHM
2102,"MagickExport ssize_t WriteBlobMSBSignedShort(Image *image,
  const signed short value)
{
  union
  {
    unsigned short
      unsigned_value;

    signed short
      signed_value;
  } quantum;

  unsigned char
    buffer[2];

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  quantum.signed_value=value;
  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);
  buffer[1]=(unsigned char) quantum.unsigned_value;
  return(WriteBlobStream(image,2,buffer));
}
","MagickExport icmp_mpls_ext_object_header WriteBlobMSBSignedShort(Image *obj_tlen,
  const signed short value)
{
  union
  {
    unsigned short
      unsigned_value;

    signed short
      signed_value;
  } quantum;

  unsigned char
    buffer[2];

  assert(obj_tlen != (Image *) NULL);
  assert(obj_tlen->signature == MagickCoreSignature);
  quantum.signed_value=value;
  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);
  buffer[1]=(unsigned char) quantum.unsigned_value;
  return(hcon(obj_tlen,2,buffer));
}
",103.0,20.0,"ssize_t:icmp_mpls_ext_object_header,WriteBlobStream:hcon,image:obj_tlen,",93.0,0.1162275950113932,MHM
2106,"void cpu_load_update_nohz_start(void)
{
	struct rq *this_rq = this_rq();

	/*
	 * This is all lockless but should be fine. If weighted_cpuload changes
	 * concurrently we'll exit nohz. And cpu_load write can race with
	 * cpu_load_update_idle() but both updater would be writing the same.
	 */
	this_rq->cpu_load[0] = weighted_cpuload(this_rq);
}
","void filename_len(void)
{
	struct rq *this_rq = this_rq();

	/*
	 * This is all lockless but should be fine. If weighted_cpuload changes
	 * concurrently we'll exit nohz. And cpu_load write can race with
	 * cpu_load_update_idle() but both updater would be writing the same.
	 */
	this_rq->cpu_load[0] = injectedScriptHost(this_rq);
}
",28.0,6.0,"weighted_cpuload:injectedScriptHost,cpu_load_update_nohz_start:filename_len,",123.0,0.1285329222679138,MHM
2107,"static void addr_hash_set(u32 *mask, const u8 *addr)
{
	int n = ether_crc(ETH_ALEN, addr) >> 26;
	mask[n >> 5] |= (1 << (n & 31));
}
","static void total(u32 *VerifyRecordedSamplesForHistogram, const u8 *addr)
{
	int ForCurrentProcess = cap_hw1(ETH_ALEN, addr) >> 26;
	VerifyRecordedSamplesForHistogram[ForCurrentProcess >> 5] |= (1 << (ForCurrentProcess & 31));
}
",44.0,10.0,"mask:VerifyRecordedSamplesForHistogram,n:ForCurrentProcess,ether_crc:cap_hw1,addr_hash_set:total,",123.0,0.1453062494595845,MHM
