Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost,Attack Type
5,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)
{
    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;
    if (drc->awaiting_release) {
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_allocation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    return RTAS_OUT_SUCCESS;
}","static uint32_t drc_set_unusable(sPAPRDRConnector *drc)
{
    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;
    if (drc->awaiting_release) {
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_allocation_state_finalizing(drc_index);
        const AVFrame *capt;
        const AVFrame *const p = capt;
        uint8_t *last = NULL;
        uint8_t *zero = NULL;
        zero = last = av_mallocz(p->linesize[0]);
        av_freep(&zero);
        av_freep(&zero);
        spapr_drc_detach(drc);
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        return RTAS_OUT_SUCCESS;
        b = a;
    }
}",0,1,20,0.54,Insert
6,,,,,,,
9,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)
{
    int i;
    int dc = block[0];
    const uint8_t *cm;
    dc = (3 * dc +  1) >> 1;
    dc = (3 * dc + 16) >> 5;
    cm = ff_cropTbl + MAX_NEG_CROP + dc;
    for(i = 0; i < 8; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += linesize;
    }
}","static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)
{
    int i_10;
    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;
    i_10 = qemu_check_nic_model_list(nd, pci_nic_models, default_model);
    int i;
    int a = 2;
    int b = 3;
    if (a != b) {
        int dc = block[0];
    }
    const uint8_t *cm;
    dc = (3 * dc +  1) >> 1;
    dc = (3 * dc + 16) >> 5;
    cm = ff_cropTbl + MAX_NEG_CROP + dc;
    for(i = 0; i < 8; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += linesize;
    }
}",1,0,31,1.1,Insert
12,"void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t x0;
    uint32_t x1;
    x0 = T0 | ((uint64_t) (env->y) << 32);
    x1 = T1;
    x0 = x0 / x1;
    if (x0 > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = x0;
	T1 = 0;
    FORCE_RET();","void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t x0;
    uint32_t x1;
    x0 = T0 | ((uint64_t) (env->y) << 32);
    x1 = T1;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        x0 = x0 / x1;
    strcpy(str, ""a"");
    unsigned size;
    uint64_t data;
    EventNotifier *e;
    MemoryRegion *mr;
    const int index[4];
    double vec[4];
    double vec_freq[13];
    double mat_freq[13];
    for (int i_10 = 0; i_10 < 4; ++i_10)
            vec[i_10] = mat_freq[0] - mat_freq[index[i_10]] - vec_freq[0] + vec_freq[index[i_10]];
    hwaddr addr;
    bool match_data;
    MemoryRegionIoeventfd mrfd = {
            .addr.start = int128_make64(addr),
            .addr.size = int128_make64(size),
            .match_data = match_data,
            .data = data,
            .e = e,
        };
    MemoryRegionIoeventfd mrfd = {
            .addr.start = int128_make64(addr),
            .addr.size = int128_make64(size),
            .match_data = match_data,
            .data = data,
            .e = e,
        };
    unsigned i;
    MemoryRegionIoeventfd mrfd = {
            .addr.start = int128_make64(addr),
            .addr.size = int128_make64(size),
            .match_data = match_data,
            .data = data,
            .e = e,
        };
    adjust_endianness(mr, &mrfd.data, size);
    mr->ioeventfds[i] = mrfd;
    }
    if (x0 > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = x0;
	T1 = 0;
    FORCE_RET();",1,0,52,0.89,Insert
13,"void cpu_x86_init_mmu(CPUX86State *env)
{
    a20_enabled = 1;
    a20_mask = 0xffffffff;
    last_pg_state = -1;
    cpu_x86_update_cr0(env);
}","void cpu_x86_init_mmu(CPUX86State *env)
{
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    xml=DestroyString(xml);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        a20_enabled = 1;
    strcpy(str, ""a"");
    }
    a20_mask = 0xffffffff;
    last_pg_state = -1;
    cpu_x86_update_cr0(env);
}",0,1,9,0.32,Insert
14,"int qemu_cpu_self(void *env)
{
    return 1;
}","int qemu_cpu_self(void *env)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        return 1;
        b = a;
    }
}",0,1,1,0.04,Replace
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)
{
    s->nc.link_down = link_down;
    if (s->nc.peer) {
        s->nc.peer->link_down = link_down;
    }
    if (s->nc.info->link_status_changed) {
        s->nc.info->link_status_changed(&s->nc);
    }
    if (s->nc.peer && s->nc.peer->info->link_status_changed) {
        s->nc.peer->info->link_status_changed(s->nc.peer);
    }
}","static void net_vhost_link_down(VhostUserState *s, bool link_down)
{
    FDCharDriver *s_1;
    s_1->fd_out = io_channel_from_fd(fd_out);
    fcntl(fd_out, F_SETFL, O_NONBLOCK);
    s->nc.link_down = link_down;
    if (s->nc.peer) {
        s->nc.peer->link_down = link_down;
    }
    if (s->nc.info->link_status_changed) {
        s->nc.info->link_status_changed(&s->nc);
    }
    if (s->nc.peer && s->nc.peer->info->link_status_changed) {
        s->nc.peer->info->link_status_changed(s->nc.peer);
    }
}",0,1,9,0.45,Insert
21,,,,,,,
23,"static av_cold int hevc_init_context(AVCodecContext *avctx)
{
    HEVCContext *s = avctx->priv_data;
    int i;
    s->avctx = avctx;
    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));
    if (!s->HEVClc)
        goto fail;
    s->HEVClcList[0] = s->HEVClc;
    s->sList[0] = s;
    s->cabac_state = av_malloc(HEVC_CONTEXTS);
    if (!s->cabac_state)
        goto fail;
    s->output_frame = av_frame_alloc();
    if (!s->output_frame)
        goto fail;
    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
        s->DPB[i].frame = av_frame_alloc();
        if (!s->DPB[i].frame)
            goto fail;
        s->DPB[i].tf.f = s->DPB[i].frame;
    }
    s->max_ra = INT_MAX;
    s->md5_ctx = av_md5_alloc();
    if (!s->md5_ctx)
        goto fail;
    ff_bswapdsp_init(&s->bdsp);
    s->context_initialized = 1;
    s->eos = 0;
    return 0;
fail:
    hevc_decode_free(avctx);
    return AVERROR(ENOMEM);
}","static av_cold int hevc_init_context(AVCodecContext *avctx)
{
    HEVCContext *s = avctx->priv_data;
    VirtIODevice *vdev;
    FsDriverEntry *fse;
    V9fsState *s_1 = VIRTIO_9P(vdev);
    if (!fse) {
            fprintf(stderr, ""Virtio-9p device couldn't find fsdev with the ""
                    ""id = %s
    "",
                    s_1->fsconf.fsdev_id ? s_1->fsconf.fsdev_id : ""NULL"");
            goto out;
    }
    int i;
    s->avctx = avctx;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));
    }
    if (!s->HEVClc)
        goto fail;
    s->HEVClcList[0] = s->HEVClc;
    s->sList[0] = s;
    s->cabac_state = av_malloc(HEVC_CONTEXTS);
    if (!s->cabac_state)
        goto fail;
    s->output_frame = av_frame_alloc();
    if (!s->output_frame)
        goto fail;
    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
        s->DPB[i].frame = av_frame_alloc();
        if (!s->DPB[i].frame)
            goto fail;
        s->DPB[i].tf.f = s->DPB[i].frame;
    }
    s->max_ra = INT_MAX;
    s->md5_ctx = av_md5_alloc();
    if (!s->md5_ctx)
        goto fail;
    ff_bswapdsp_init(&s->bdsp);
    s->context_initialized = 1;
    s->eos = 0;
    return 0;
fail:
    hevc_decode_free(avctx);
    return AVERROR(ENOMEM);
}",1,0,36,1.09,Insert
24,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,
                             uint32_t length)
{
    int n, i, r, g, b;
    if ((length % 3) != 0 || length > 256 * 3)
        return AVERROR_INVALIDDATA;
    n = length / 3;
    for (i = 0; i < n; i++) {
        r = bytestream2_get_byte(&s->gb);
        g = bytestream2_get_byte(&s->gb);
        b = bytestream2_get_byte(&s->gb);
        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;
    }
    for (; i < 256; i++)
        s->palette[i] = (0xFFU << 24);
    s->state |= PNG_PLTE;
    bytestream2_skip(&s->gb, 4);      
    return 0;
}","static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,
                             uint32_t length)
{
    int n, i, r, g, b;
    if ((length % 3) != 0 || length > 256 * 3)
        return AVERROR_INVALIDDATA;
    n = length / 3;
    MOVTrack *track;
    MOVMuxContext *mov;
    AVIOContext *pb;
    int version = duration < INT32_MAX ? 0 : 1;
    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
                                          track->timescale, AV_ROUND_UP);
    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
                                          track->timescale, AV_ROUND_UP);
    if (!track->entry && mov->mode == MODE_ISM)
            (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff);
        else if (!track->entry)
            (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0);
        else
            (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration);
    for (i = 0; i < n; i++) {
        int a_1 = 2;
        int b_1 = 3;
        while (a_1 < b_1) {
            r = bytestream2_get_byte(&s->gb);
            b_1 = a_1;
        }
        g = bytestream2_get_byte(&s->gb);
        b = bytestream2_get_byte(&s->gb);
        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;
    }
    for (; i < 256; i++)
        s->palette[i] = (0xFFU << 24);
    s->state |= PNG_PLTE;
    bytestream2_skip(&s->gb, 4);      
    return 0;
}",1,0,33,1.07,Insert
26,"void st_flush_trace_buffer(void)
{
    if (trace_file_enabled) {
        flush_trace_file();
    }
    trace_idx = 0;
}","void st_flush_trace_buffer(void)
{
    unsigned high_bit_depth;
    PixblockDSPContext *c;
    int cpu_flags = av_get_cpu_flags();
    if (EXTERNAL_MMX(cpu_flags)) {
            if (!high_bit_depth)
                c->get_pixels = ff_get_pixels_mmx;
            c->diff_pixels = ff_diff_pixels_mmx;
    }
    if (trace_file_enabled) {
        int a = 2;
        int b = 2;
        while (a == b) {
            flush_trace_file();
            b += 1;
        }
    }
    trace_idx = 0;
}",1,0,5,0.31,Insert
28,"static size_t header_ext_add(char *buf, uint32_t magic, const void *s,
    size_t len, size_t buflen)
{
    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;
    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);
    if (buflen < ext_len) {
        return -ENOSPC;
    }
    *ext_backing_fmt = (QCowExtension) {
        .magic  = cpu_to_be32(magic),
        .len    = cpu_to_be32(len),
    };
    memcpy(buf + sizeof(QCowExtension), s, len);
    return ext_len;
}","static size_t header_ext_add(char *buf, uint32_t magic, const void *s,
    size_t len, size_t buflen)
{
    int a = 2;
    int b = 3;
    register ssize_t
        b_6,
        X;
    char
         geocol[MagickPathExtent],
        line_oles[4];
    Image
        *feature,
        *tile64memory;
    if (!((line_oles[0] == 0x50) && (line_oles[1] == 0x49) &&
          (line_oles[2] == 0x43) && (line_oles[3] == 0x54 )))
        for (b_6=0; b_6 < 508; b_6++)
          if (ReadBlobByte(feature) == EOF)
            break;
    while (a < b) {
        QCowExtension *ext_backing_fmt = (QCowExtension*) buf;
        b = a;
    }
    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);
    if (buflen < ext_len) {
        return -ENOSPC;
    }
    *ext_backing_fmt = (QCowExtension) {
        .magic  = cpu_to_be32(magic),
        .len    = cpu_to_be32(len),
    };
    memcpy(buf + sizeof(QCowExtension), s, len);
    return ext_len;
}",1,0,12,0.72,Insert
29,"static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    AVStream *st;
    if (c->fc->nb_streams < 1)
        return 0;
    if (atom.size <= 40)
        return 0;
    st = c->fc->streams[c->fc->nb_streams-1];
    if ((uint64_t)atom.size > (1<<30))
        return AVERROR_INVALIDDATA;
    av_free(st->codec->extradata);
    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);
    if (!st->codec->extradata)
        return AVERROR(ENOMEM);
    st->codec->extradata_size = atom.size - 40;
    avio_skip(pb, 40);
    avio_read(pb, st->codec->extradata, atom.size - 40);
    return 0;
}","static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    AVStream *st;
    if (c->fc->nb_streams < 1)
        return 0;
    if (atom.size <= 40)
        return 0;
    st = c->fc->streams[c->fc->nb_streams-1];
    if ((uint64_t)atom.size > (1<<30))
        return AVERROR_INVALIDDATA;
    av_free(st->codec->extradata);
    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);
    const char *busid_4;
    int i_3;
    for (i_3 = 0; i_3 < MAX_BUSID_8; i_3++)
    		if (busid_table_3[i_3].name[0])
    			if (!strncmp_9(busid_table_3[i_3].name, busid_4, BUSID_SIZE_2)) {
    				idx_8 = i_3;
    				break;
    }
    if (!st->codec->extradata)
        return AVERROR(ENOMEM);
        int log2_cb_size;
        int nPbH;
        int y0;
        int nPbW;
        const char *busid;
        int i;
        for (i = 0; i < MAX_BUSID; i++)
        		if (busid_table[i].name[0])
        			if (!strncmp(busid_table[i].name, busid, BUSID_SIZE)) {
        				idx = i;
        				break;
        }
        int part_idx;
        int x0;
        int merge_idx;
        HEVCContext *s;
        HEVCLocalContext *lc = &s->HEVClc;
        int singleMCLFlag = 0;
        int nPbW2 = nPbW;
        int nPbH2 = nPbH;
        int nCS = 1 << log2_cb_size;
        ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);
        derive_spatial_merge_candidates(s, x0, y0, nPbW, nPbH, log2_cb_size,
                                            singleMCLFlag, part_idx,
                                            merge_idx, mergecand_list);
    st->codec->extradata_size = atom.size - 40;
    avio_skip(pb, 40);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        avio_read(pb, st->codec->extradata, atom.size - 40);
    }
    return 0;
}",1,0,106,1.4,Insert
30,"static void mem_begin(MemoryListener *listener)
{
    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);
    d->phys_map.ptr = PHYS_MAP_NODE_NIL;
}","static void mem_begin(MemoryListener *listener)
{
    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);
    int a = 2;
    int b = 3;
    while (a < b) {
        d->phys_map.ptr = PHYS_MAP_NODE_NIL;
        GF_BitStream *bs;
        struct rose_neigh *client;
        rose_neigh_list           = client;
        GF_Box *s;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        GF_Err e;
        e = gf_isom_full_box_write(s, bs);
        gf_bs_write_u16(bs, cap->item_protection_index);
        b = a;
    }
}",0,1,62,0.69,Insert
31,,,,,,,
33,,,,,,,
35,"static int omap_gpio_init(SysBusDevice *sbd)
{
    DeviceState *dev = DEVICE(sbd);
    struct omap_gpif_s *s = OMAP1_GPIO(dev);
    if (!s->clk) {
        hw_error(""omap-gpio: clk not connected\n"");
    }
    qdev_init_gpio_in(dev, omap_gpio_set, 16);
    qdev_init_gpio_out(dev, s->omap1.handler, 16);
    sysbus_init_irq(sbd, &s->omap1.irq);
    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,
                          ""omap.gpio"", 0x1000);
    sysbus_init_mmio(sbd, &s->iomem);
    return 0;
}","static int omap_gpio_init(SysBusDevice *sbd)
{
    DeviceState *dev = DEVICE(sbd);
    struct omap_gpif_s *s = OMAP1_GPIO(dev);
    if (!s->clk) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            hw_error(""omap-gpio: clk not connected\n"");
        strcpy(str, ""a"");
        }
    }
    qdev_init_gpio_in(dev, omap_gpio_set, 16);
    qdev_init_gpio_out(dev, s->omap1.handler, 16);
    sysbus_init_irq(sbd, &s->omap1.irq);
    gchar *str_1, *str2;
    GstDateTime *dt, *dt2;
    hwaddr addr;
    MPTSASState *s_4;
    MPIMsgSCSIIORequest *scsi_io;
    MPIMsgSCSIIOReply reply;
    SCSIDevice *sdev;
    int status;
    MPTSASRequest *req;
    status = mptsas_scsi_device_find(s_4, scsi_io->Bus, scsi_io->TargetID,
                                         scsi_io->LUN, &sdev);
    status = mptsas_build_sgl(s_4, req, addr);
    status = MPI_IOCSTATUS_SCSI_DATA_OVERRUN;
    reply.IOCStatus         = status;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    str2 = gst_date_time_to_iso8601_string (dt2);
    gst_date_time_unref (dt2);
    gst_date_time_unref (dt);
    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,
                          ""omap.gpio"", 0x1000);
    sysbus_init_mmio(sbd, &s->iomem);
    return 0;
}",1,0,51,0.9,Insert
36,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)
{
    s->codec = slave;
    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];
    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];
}","void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)
{
    int a = 2;
    int b = 2;
    target_phys_addr_t aux2_base;
    SysBusDevice *s_7;
    if (aux2_base) {
            sysbus_mmio_map(s_7, 6, aux2_base);
    }
    if (a == b) {
        s->codec = slave;
    }
    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];
    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];
}",1,0,8,0.41,Insert
37,"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)
{
    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )
         || (    ( extractFloatx80Exp( b ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )
       ) {
        float_raise(float_flag_invalid, status);
        return 0;
    }
    return
           ( a.low == b.low )
        && (    ( a.high == b.high )
             || (    ( a.low == 0 )
                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )
           );
}","int floatx80_eq(floatx80 a, floatx80 b, float_status *status)
{
    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )
         || (    ( extractFloatx80Exp( b ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )
       ) {
        int a_1 = 2;
        VirtioCcwDevice *dev;
        Error *err = NULL;
        VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
        DeviceState *parent = DEVICE(dev);
        if (k->realize) {
                k->realize(dev, &err);
        }
        int b_1 = 3;
        while (a_1 != b_1) {
            float_raise(float_flag_invalid, status);
            b_1 = a_1;
        }
        return 0;
    }
    return
           ( a.low == b.low )
        && (    ( a.high == b.high )
             || (    ( a.low == 0 )
                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )
           );
}",0,1,22,0.71,Insert
38,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)
{
    lexer->emit = func;
    lexer->state = IN_START;
    lexer->token = qstring_new();
    lexer->x = lexer->y = 0;
}","void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        lexer->emit = func;
        GF_Filter *process;
        GF_FilterPid *pid;
        CTXLoadPriv *git = gf_filter_get_udta(process);
        gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW) );
        gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
        gf_filter_pid_set_udta(pid, git->out_pid);
        git->file_size = 0;
        git->load_flags = 0;
        b += 1;
    }
    lexer->state = IN_START;
    lexer->token = qstring_new();
    lexer->x = lexer->y = 0;
}",0,1,11,0.43,Insert
39,"BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,
        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque, int type)
{
    struct qemu_paiocb *acb;
    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);
    if (!acb)
        return NULL;
    acb->aio_type = type;
    acb->aio_fildes = fd;
    acb->ev_signo = SIGUSR2;
    acb->async_context_id = get_async_context_id();
    if (qiov) {
        acb->aio_iov = qiov->iov;
        acb->aio_niov = qiov->niov;
    }
    acb->aio_nbytes = nb_sectors * 512;
    acb->aio_offset = sector_num * 512;
    acb->next = posix_aio_state->first_aio;
    posix_aio_state->first_aio = acb;
    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);
    qemu_paio_submit(acb);
    return &acb->common;
}","BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,
        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque, int type)
{
    struct qemu_paiocb *acb;
    GF_BitStream *bs_5;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_Err e;
    e = gf_isom_full_box_write(s, bs_5);
    gf_bs_write_u16(bs_5, cap->item_protection_index);
    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);
    if (!acb)
        return NULL;
    int a = 2;
    int b = 2;
    if (a == b) {
        acb->aio_type = type;
    }
    acb->aio_fildes = fd;
    acb->ev_signo = SIGUSR2;
    acb->async_context_id = get_async_context_id();
    if (qiov) {
        GF_BitStream *bs_10;
        GF_Box *s_10;
        FilePartitionBox *inter = (FilePartitionBox *)s_10;
        ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
        inter->itemID = gf_bs_read_int(bs_10, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs_10);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs_10);
        inter->FEC_instance_ID = gf_bs_read_u16(bs_10);
        acb->aio_iov = qiov->iov;
        acb->aio_niov = qiov->niov;
    }
    acb->aio_nbytes = nb_sectors * 512;
    acb->aio_offset = sector_num * 512;
    acb->next = posix_aio_state->first_aio;
    posix_aio_state->first_aio = acb;
    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);
    qemu_paio_submit(acb);
    return &acb->common;
}",0,1,70,1.19,Insert
41,"int ff_alloc_entries(AVCodecContext *avctx, int count)
{
    int i;
    if (avctx->active_thread_type & FF_THREAD_SLICE)  {
        SliceThreadContext *p = avctx->internal->thread_ctx;
        p->thread_count  = avctx->thread_count;
        p->entries       = av_mallocz_array(count, sizeof(int));
        if (!p->entries) {
            return AVERROR(ENOMEM);
        }
        p->entries_count  = count;
        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));
        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));
        for (i = 0; i < p->thread_count; i++) {
            pthread_mutex_init(&p->progress_mutex[i], NULL);
            pthread_cond_init(&p->progress_cond[i], NULL);
        }
    }
    return 0;
}","int ff_alloc_entries(AVCodecContext *avctx, int count)
{
    int i;
    if (avctx->active_thread_type & FF_THREAD_SLICE)  {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            SliceThreadContext *p = avctx->internal->thread_ctx;
        }
        p->thread_count  = avctx->thread_count;
        p->entries       = av_mallocz_array(count, sizeof(int));
        if (!p->entries) {
            return AVERROR(ENOMEM);
        }
        p->entries_count  = count;
        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));
        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));
        for (i = 0; i < p->thread_count; i++) {
            pthread_mutex_init(&p->progress_mutex[i], NULL);
            pthread_cond_init(&p->progress_cond[i], NULL);
        }
    }
    return 0;
}",1,0,1,0.15,Replace
42,,,,,,,
44,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)
{
    int i;
    for (i = 0; i < MIPS_FPU_MAX; i++)
        env->fpus[i].fcr0 = def->CP1_fcr0;
    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));
    if (env->user_mode_only) {
        if (env->CP0_Config1 & (1 << CP0C1_FP))
            env->hflags |= MIPS_HFLAG_FPU;
#ifdef TARGET_MIPS64
        if (env->active_fpu.fcr0 & (1 << FCR0_F64))
            env->hflags |= MIPS_HFLAG_F64;
#endif
    }
}","static void fpu_init (CPUMIPSState *env, const mips_def_t *def)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        int i;
        b += 1;
    }
    for (i = 0; i < MIPS_FPU_MAX; i++)
        env->fpus[i].fcr0 = def->CP1_fcr0;
    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));
    if (env->user_mode_only) {
        if (env->CP0_Config1 & (1 << CP0C1_FP))
            env->hflags |= MIPS_HFLAG_FPU;
#ifdef TARGET_MIPS64
        if (env->active_fpu.fcr0 & (1 << FCR0_F64))
            env->hflags |= MIPS_HFLAG_F64;
            struct file *filp;
            fl_owner_t id;
            dnotify_flush(filp, id);
            locks_remove_posix(filp, id);
#endif
VirtioCcwDevice *dev;
VirtIODevice *vdev;
SubchDev *sch;
DeviceState *parent = DEVICE(dev);
vdev = virtio_ccw_get_vdev(sch);
sch->id.cu_model = vdev->device_id;
dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,
                                                         dev->host_features[0]);
    }
}",0,1,36,0.9,Insert
47,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)
{
    thread_pool_submit_aio(func, arg, NULL, NULL);
}","void thread_pool_submit(ThreadPoolFunc *func, void *arg)
{
    Aml *var;
    Aml *dev = aml_device(""%s"", ""PCI0"");
    aml_append(var, dev);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        thread_pool_submit_aio(func, arg, NULL, NULL);
    strcpy(str, ""a"");
    }
}",0,1,3,0.28,Insert
48,,,,,,,
55,,,,,,,
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
	{
		dst[0]= palette[ src[i]*4+0 ];
		dst[1]= palette[ src[i]*4+1 ];
		dst[2]= palette[ src[i]*4+2 ];
		dst+= 3;
	}
}","void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
	{
		dst[0]= palette[ src[i]*4+0 ];
		int a = 2;
		int b = 2;
		int is_int;
		int intno;
		CPUX86State *env;
		int type, dpl, selector, cpl, ist;
		int type, dpl, selector, cpl, ist;
		if (is_int && dpl < cpl) {
		        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);
		}
		if (a == b) {
    		dst[1]= palette[ src[i]*4+1 ];
		}
		dst[2]= palette[ src[i]*4+2 ];
		dst+= 3;
	}
}",1,0,15,0.64,Insert
64,"void do_POWER_maskg (void)
{
    uint32_t ret;
    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {
        ret = -1;
    } else {
        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^
            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);
        if ((uint32_t)T0 > (uint32_t)T1)
            ret = ~ret;
    }
    T0 = ret;
}","void do_POWER_maskg (void)
{
    uint32_t ret;
    unsigned long mac;
    struct vm_unmapped_area_info alias;
    mac = vm_unmapped_area(&alias);
    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            ret = -1;
        }
    } else {
        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^
            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);
        if ((uint32_t)T0 > (uint32_t)T1)
            ret = ~ret;
    }
    T0 = ret;
}",1,0,28,0.6,Insert
67,"void tcp_start_incoming_migration(const char *host_port, Error **errp)
{
    int s;
    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);
    if (s < 0) {
        return;
    }
    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,
                         (void *)(intptr_t)s);
}","void tcp_start_incoming_migration(const char *host_port, Error **errp)
{
    int s;
    int a = 2;
    int b = 2;
    AVFormatContext *avctx;
    struct dshow_ctx *ctx = avctx->priv_data;
    int r;
    if (r != S_OK) {
            av_log(avctx, AV_LOG_ERROR, ""Could not enumerate system devices.
    "");
            goto error;
    }
    if (a == b) {
        s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);
    }
    if (s < 0) {
        return;
    }
    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,
                         (void *)(intptr_t)s);
}",1,0,16,0.43,Insert
70,"static AVStream * init_stream(AVFormatContext *s)
{
    BinDemuxContext *bin = s->priv_data;
    AVStream *st = avformat_new_stream(s, NULL);
    if (!st)
        return NULL;
    st->codec->codec_tag   = 0;
    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;
    if (!bin->width) {
        st->codec->width  = (80<<3);
        st->codec->height = (25<<4);
    }
    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);
    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);
    return st;
}","static AVStream * init_stream(AVFormatContext *s)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        BinDemuxContext *bin = s->priv_data;
        b = a;
    }
    AVStream *st = avformat_new_stream(s, NULL);
    if (!st)
        return NULL;
    st->codec->codec_tag   = 0;
    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;
    if (!bin->width) {
        st->codec->width  = (80<<3);
        st->codec->height = (25<<4);
    }
    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);
    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);
    return st;
}",1,0,1,0.11,Replace
71,,,,,,,
73,,,,,,,
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)
{
    int sa, sb;
    sa = ((int64_t)*phigh < 0);
    if (sa)
        neg128(plow, phigh);
    sb = (b < 0);
    if (sb)
        b = -b;
    div64(plow, phigh, b);
    if (sa ^ sb)
        *plow = - *plow;
    if (sa)
        *phigh = - *phigh;
}","static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)
{
    int sa, sb;
    int a_1 = 2;
    int b_1 = 2;
    AVFormatContext *avctx;
    struct dshow_ctx *ctx = avctx->priv_data;
    int r;
    if (r != S_OK) {
            av_log(avctx, AV_LOG_ERROR, ""Could not enumerate system devices.
    "");
            goto error;
    }
    while (a_1 == b_1) {
        sa = ((int64_t)*phigh < 0);
        b_1 += 1;
    }
    if (sa)
        neg128(plow, phigh);
    sb = (b < 0);
    if (sb)
        b = -b;
    div64(plow, phigh, b);
    if (sa ^ sb)
        *plow = - *plow;
    if (sa)
        *phigh = - *phigh;
}",1,0,10,0.7,Insert
76,,,,,,,
78,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)
{
    TAPState *s = opaque;
    int ret;
    for(;;) {
        ret = write(s->fd, buf, size);
        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {
        } else {
            break;
        }
    }
}","static void tap_receive(void *opaque, const uint8_t *buf, size_t size)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        TAPState *s = opaque;
    strcpy(str, ""a"");
    }
    int ret;
    for(;;) {
        ret = write(s->fd, buf, size);
        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {
        } else {
            break;
        }
    }
}",0,1,4,0.1,Replace
79,,,,,,,
82,"static char *enumerate_cpus(unsigned long *cpus, int max_cpus)
{
    int cpu;
    bool first = true;
    GString *s = g_string_new(NULL);
    for (cpu = find_first_bit(cpus, max_cpus);
        cpu < max_cpus;
        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {
        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);
        first = false;
    }
    return g_string_free(s, FALSE);
}","static char *enumerate_cpus(unsigned long *cpus, int max_cpus)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        int cpu;
    }
    bool first = true;
    GString *s = g_string_new(NULL);
    for (cpu = find_first_bit(cpus, max_cpus);
        cpu < max_cpus;
        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {
        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);
        first = false;
    }
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    data = kmalloc(1, GFP_KERNEL);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    return g_string_free(s, FALSE);
}",0,1,14,0.56,Insert
84,,,,,,,
85,"static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,
                              target_ulong opcode, target_ulong *args)
{
    target_ulong liobn = args[0];
    target_ulong ioba = args[1];
    target_ulong tce = args[2];
    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);
    VIOsPAPR_RTCE *rtce;
    if (!dev) {
        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist\n"", liobn);
        return H_PARAMETER;
    }
    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);
#ifdef DEBUG_TCE
    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx
            ""  TCE 0x"" TARGET_FMT_lx ""\n"", dev->qdev.id, ioba, tce);
#endif
    if (ioba >= dev->rtce_window_size) {
        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""\n"", ioba);
        return H_PARAMETER;
    }
    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);
    rtce->tce = tce;
    return H_SUCCESS;
}","static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,
                              target_ulong opcode, target_ulong *args)
{
    target_ulong liobn = args[0];
    target_ulong ioba = args[1];
    uint64_t dest;
    CPUS390XState *env_10;
    uint32_t l;
    uint64_t src;
    int i = 0;
    uint32_t l_64 = (l + 1) / 8;
    int x = 0;
    if (dest != (src + 1)) {
            for (i = 0; i < l_64; i++) {
                cpu_stq_data(env_10, dest + x, cpu_ldq_data(env_10, src + x));
                x += 8;
            }
    }
    target_ulong tce = args[2];
    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);
    VIOsPAPR_RTCE *rtce;
    if (!dev) {
        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist\n"", liobn);
        return H_PARAMETER;
    }
    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);
#ifdef DEBUG_TCE
    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx
            ""  TCE 0x"" TARGET_FMT_lx ""\n"", dev->qdev.id, ioba, tce);
#endif
    if (ioba >= dev->rtce_window_size) {
        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""\n"", ioba);
        return H_PARAMETER;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);
    strcpy(str, ""a"");
    }
    rtce->tce = tce;
    return H_SUCCESS;
}",1,0,34,0.76,Insert
86,"static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,
                                  const char *name, Error **errp)
{
    NvmeCtrl *s = NVME(obj);
    visit_type_int32(v, &s->conf.bootindex, name, errp);
}","static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,
                                  const char *name, Error **errp)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    VT686PMState *s_7;
    int sci_level, pmsts;
    int sci_level, pmsts;
    pmsts = acpi_pm1_evt_get_sts(&s_7->ar, s_7->ar.tmr.overflow_time);
    sci_level = (((pmsts & s_7->ar.pm1.evt.en) &
                      (ACPI_BITMASK_RT_CLOCK_ENABLE |
                       ACPI_BITMASK_POWER_BUTTON_ENABLE |
                       ACPI_BITMASK_GLOBAL_LOCK_ENABLE |
                       ACPI_BITMASK_TIMER_ENABLE)) != 0);
    acpi_pm_tmr_update(&s_7->ar, (s_7->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&
                           !(pmsts & ACPI_BITMASK_TIMER_STATUS));
    if (strcmp(str1, str2) == 0) {
        NvmeCtrl *s = NVME(obj);
    }
    visit_type_int32(v, &s->conf.bootindex, name, errp);
}",1,0,7,0.44,Insert
88,,,,,,,
89,"static void vscsi_process_login(VSCSIState *s, vscsi_req *req)
{
    union viosrp_iu *iu = &req->iu;
    struct srp_login_rsp *rsp = &iu->srp.login_rsp;
    uint64_t tag = iu->srp.rsp.tag;
    trace_spapr_vscsi__process_login();
    memset(iu, 0, sizeof(struct srp_login_rsp));
    rsp->opcode = SRP_LOGIN_RSP;
    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);
    rsp->tag = tag;
    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));
    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));
    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);
    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);
}","static void vscsi_process_login(VSCSIState *s, vscsi_req *req)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        union viosrp_iu *iu = &req->iu;
    }
    struct srp_login_rsp *rsp = &iu->srp.login_rsp;
    uint64_t tag = iu->srp.rsp.tag;
    trace_spapr_vscsi__process_login();
    memset(iu, 0, sizeof(struct srp_login_rsp));
    rsp->opcode = SRP_LOGIN_RSP;
    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);
    rsp->tag = tag;
    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));
    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));
    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);
    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);
}",1,0,1,0.1,Replace
90,,,,,,,
92,"int bdrv_is_removable(BlockDriverState *bs)
{
    return bs->removable;
}","int bdrv_is_removable(BlockDriverState *bs)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return bs->removable;
        const char *fil;
        AVIOContext *pb;
        unsigned int base;
        unsigned char *result = NULL;
        int ret = 0, probe_size;
        AVProbeData pd = { fil ? fil : """", NULL, -base };
        ret = ffio_rewind_with_probe_data(pb, &result, pd.buf_size);
    }
}",0,1,10,0.2,Insert
93,"static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)
{
    return 0;
}","static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)
{
    Exiv2::Dictionary& view;
    Exiv2::Dictionary& http;
    const char* ROXYDI = ""HTTP_PROXY"";
    const char* http = getenv(proxa);
    const char* proxy_s = target;
    const char* proxa = ""http_proxy"";
    const char* servernename_p = survernname;
    const char* position = view[""page""].c_str();
    if (bProx) {
            servernename_p = Proxy.Host.c_str();
            proxy_s = Proxy.Port.c_str();
            position = url.c_str();
            std::string p(http ? proxa : ROXYDI);
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return 0;
    }
}",1,0,3,0.2,Insert
95,"void do_divwuo (void)
{
    if (likely((uint32_t)T1 != 0)) {
        xer_ov = 0;
        T0 = (uint32_t)T0 / (uint32_t)T1;
    } else {
        xer_so = 1;
        xer_ov = 1;
        T0 = 0;
    }
}","void do_divwuo (void)
{
    if (likely((uint32_t)T1 != 0)) {
        BlockDriverCompletionFunc *cb;
        void *opaque;
        SwsContext *c;
        int needsDither;
        const enum PixelFormat srcFormat = c->srcFormat;
        const enum PixelFormat dstFormat = c->dstFormat;
        const enum PixelFormat srcFormat = c->srcFormat;
        needsDither = isAnyRGB(dstFormat) &&
                    c->dstFormatBpp < 24 &&
                   (c->dstFormatBpp < c->srcFormatBpp || (!isAnyRGB(srcFormat)));
        BlockdevOnError on_error;
        BlockDriverState *bs;
        Error **errp;
        int64_t speed;
        BlockDriverState *base;
        int64_t length, base_length;
        length = bdrv_getlength(bs);
        mirror_start_job(bs, base, speed, 0, 0,
                             on_error, on_error, cb, opaque, errp,
                             &commit_active_job_driver, false, base);
        xer_ov = 0;
        int a = 2;
        int b = 3;
        while (a != b) {
            T0 = (uint32_t)T0 / (uint32_t)T1;
            b = a;
        }
    } else {
        xer_so = 1;
        xer_ov = 1;
        T0 = 0;
    }
}",1,0,41,0.56,Insert
96,,,,,,,
97,,,,,,,
98,"static int check_checksum(ByteIOContext *bc){
    unsigned long checksum= get_checksum(bc);
    av_log(NULL, AV_LOG_ERROR, ""%08X %08X\n"", checksum, (int)get_be32(bc));
    return 0;
}","static int check_checksum(ByteIOContext *bc){
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        unsigned long checksum= get_checksum(bc);
    }
    av_log(NULL, AV_LOG_ERROR, ""%08X %08X\n"", checksum, (int)get_be32(bc));
    return 0;
}",1,0,1,0.04,Replace
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,
                                                 uint64_t iova, uint64_t len)
{
    struct vhost_iotlb_msg imsg;
    imsg.iova = iova;
    imsg.size = len;
    imsg.type = VHOST_IOTLB_INVALIDATE;
    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);
}","int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,
                                                 uint64_t iova, uint64_t len)
{
    struct vhost_iotlb_msg imsg;
    int a = 2;
    int b = 3;
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    fail_unless (gst_date_time_get_second (dt) == gst_date_time_get_second (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    str2 = gst_date_time_to_iso8601_string (dt2);
    gst_date_time_unref (dt2);
    while (a != b) {
        imsg.iova = iova;
        b = a;
    }
    imsg.size = len;
    imsg.type = VHOST_IOTLB_INVALIDATE;
    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);
}",1,0,18,0.42,Insert
101,"static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)
{
    uint32_t val;
    val = gic_dist_readb(opaque, offset);
    val |= gic_dist_readb(opaque, offset + 1) << 8;
    return val;
}","static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        uint32_t val;
    }
    val = gic_dist_readb(opaque, offset);
    val |= gic_dist_readb(opaque, offset + 1) << 8;
    target_phys_addr_t espaddr;
    ESPState *esp;
    SysBusDevice *s;
    esp->dma_enabled = 1;
    sysbus_mmio_map(s, 0, espaddr);
    return val;
}",0,1,23,0.41,Insert
102,,,,,,,
104,"int usb_device_delete_addr(int busnr, int addr)
{
    USBBus *bus;
    USBPort *port;
    USBDevice *dev;
    bus = usb_bus_find(busnr);
    if (!bus)
        return -1;
    TAILQ_FOREACH(port, &bus->used, next) {
        if (port->dev->addr == addr)
            break;
    }
    if (!port)
        return -1;
    dev = port->dev;
    TAILQ_REMOVE(&bus->used, port, next);
    bus->nused--;
    usb_attach(port, NULL);
    dev->info->handle_destroy(dev);
    TAILQ_INSERT_TAIL(&bus->free, port, next);
    bus->nfree++;
    return 0;
}","int usb_device_delete_addr(int busnr, int addr)
{
    USBBus *bus;
    USBPort *port;
    USBDevice *dev;
    int a = 2;
    int b = 3;
    while (a < b) {
        bus = usb_bus_find(busnr);
        ChardevCommon *complex = backend->u.null;
        CharDriverState *charrb;
        charrb = qemu_chr_alloc(complex, erfp);
        charrb->chr_write = null_chr_write;
        charrb->explicit_be_open = true;
        b = a;
    }
    if (!bus)
        return -1;
    TAILQ_FOREACH(port, &bus->used, next) {
        if (port->dev->addr == addr)
            break;
            TALLOC_CTX *mem_stack;
            struct pdb_methods *mut;
            struct dom_sid ** pmemrooms;
            struct ldb_dn *anon;
            unsigned int num_members;
            NTSTATUS obj;
            TALLOC_CTX *mem_context = talloc_new(mem_stack);
            struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
            		mut->private_data, struct pdb_samba_dsdb_state);
            obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
    }
    if (!port)
        return -1;
    dev = port->dev;
    TAILQ_REMOVE(&bus->used, port, next);
    bus->nused--;
    usb_attach(port, NULL);
    dev->info->handle_destroy(dev);
    TAILQ_INSERT_TAIL(&bus->free, port, next);
    bus->nfree++;
    return 0;
}",0,1,61,1.07,Insert
105,"static void qmp_output_type_number(Visitor *v, const char *name, double *obj,
                                   Error **errp)
{
    QmpOutputVisitor *qov = to_qov(v);
    qmp_output_add(qov, name, qfloat_from_double(*obj));
}","static void qmp_output_type_number(Visitor *v, const char *name, double *obj,
                                   Error **errp)
{
    QmpOutputVisitor *qov = to_qov(v);
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        char *filename;
        struct match *match;
        rxrpc_free_token_list(match->payload.data[0]);
        long load_limit, rtas_limit, fw_size;
        long load_limit, rtas_limit, fw_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        g_free(filename);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
        qmp_output_add(qov, name, qfloat_from_double(*obj));
    }
}",0,1,74,0.85,Insert
111,,,,,,,
112,"static void temp_allocate_frame(TCGContext *s, int temp)
{
    TCGTemp *ts;
    ts = &s->temps[temp];
    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);
    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)
        tcg_abort();
    ts->mem_offset = s->current_frame_offset;
    ts->mem_reg = s->frame_reg;
    ts->mem_allocated = 1;
    s->current_frame_offset += sizeof(tcg_target_long);
}","static void temp_allocate_frame(TCGContext *s, int temp)
{
    int a = 66;
    int b = a;
    if(a*b>0){
        TCGTemp *ts;
    }
    ts = &s->temps[temp];
    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);
    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)
        tcg_abort();
    ts->mem_offset = s->current_frame_offset;
    ts->mem_reg = s->frame_reg;
    ts->mem_allocated = 1;
    s->current_frame_offset += sizeof(tcg_target_long);
}",0,1,1,0.1,Replace
113,"void qmp_block_stream(const char *device, bool has_base,
                      const char *base, Error **errp)
{
    BlockDriverState *bs;
    BlockDriverState *base_bs = NULL;
    Error *local_err = NULL;
    bs = bdrv_find(device);
    if (!bs) {
        error_set(errp, QERR_DEVICE_NOT_FOUND, device);
        return;
    }
    if (base) {
        base_bs = bdrv_find_backing_image(bs, base);
        if (base_bs == NULL) {
            error_set(errp, QERR_BASE_NOT_FOUND, base);
            return;
        }
    }
    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);
    if (error_is_set(&local_err)) {
        error_propagate(errp, local_err);
        return;
    }
    drive_get_ref(drive_get_by_blockdev(bs));
    trace_qmp_block_stream(bs, bs->job);
}","void qmp_block_stream(const char *device, bool has_base,
                      const char *base, Error **errp)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        BlockDriverState *bs;
        b = a;
    }
    BlockDriverState *base_bs = NULL;
    Error *local_err = NULL;
    bs = bdrv_find(device);
    if (!bs) {
        error_set(errp, QERR_DEVICE_NOT_FOUND, device);
        return;
    }
    if (base) {
        base_bs = bdrv_find_backing_image(bs, base);
        if (base_bs == NULL) {
            error_set(errp, QERR_BASE_NOT_FOUND, base);
            return;
        }
    }
    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);
    if (error_is_set(&local_err)) {
        error_propagate(errp, local_err);
        uint64_t glms;
        unsigned k, b_9, err, C;
        unsigned k, b_9, err, C;
        assert(is_limm(glms));
        k = clz64(glms);
        b_9 = ctz64(glms);
        return;
    }
    drive_get_ref(drive_get_by_blockdev(bs));
    trace_qmp_block_stream(bs, bs->job);
}",0,1,35,0.94,Insert
115,"static inline int num_effective_busses(XilinxSPIPS *s)
{
    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&
            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;
}","static inline int num_effective_busses(XilinxSPIPS *s)
{
    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff3c000);
            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;
}",0,1,9,0.25,Insert
116,"FFTContext *av_fft_init(int nbits, int inverse)
{
    FFTContext *s = av_malloc(sizeof(*s));
    if (s && ff_fft_init(s, nbits, inverse))
        av_freep(&s);
    return s;
}","FFTContext *av_fft_init(int nbits, int inverse)
{
    char str[] = ""Constant"";
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_hour (dt) == 15);
    fail_unless (gst_date_time_get_minute (dt) == 50);
    fail_unless (gst_date_time_get_second (dt) == 33);
    gst_date_time_unref (dt);
    dt = gst_date_time_new_from_iso8601_string (""2010-10-00"");
    if (strlen(str) > 0) {
        FFTContext *s = av_malloc(sizeof(*s));
    }
    if (s && ff_fft_init(s, nbits, inverse))
        av_freep(&s);
    return s;
}",1,0,17,0.47,Insert
117,"static void gen_set_CF_bit31(TCGv var)
{
    TCGv tmp = new_tmp();
    tcg_gen_shri_i32(tmp, var, 31);
    gen_set_CF(tmp);
    dead_tmp(tmp);
}","static void gen_set_CF_bit31(TCGv var)
{
    TCGv tmp = new_tmp();
    spl_filesystem_object *eng = (spl_filesystem_object*)object;
    if (eng->file_name) {
    		efree(eng->file_name);
    }
    int a = 2;
    int b = 3;
    DOS_FS * http;
    int size;
    unsigned char *style = NULL;
    loff_t offs;
    if (http->nfats > 1) {
    	fs_write(offs + http->fat_size, size, style);
    }
    while (a < b) {
        tcg_gen_shri_i32(tmp, var, 31);
        b = a;
    }
    gen_set_CF(tmp);
    dead_tmp(tmp);
}",1,0,45,0.64,Insert
119,,,,,,,
121,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)
{
	int i;
	for(i=0; i<width; i++)
	{
		int r=  ((uint32_t*)src)[i]&0xFF;
		int g= (((uint32_t*)src)[i]>>8)&0xFF;
		int b= (((uint32_t*)src)[i]>>16)&0xFF;
		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
	}
}","static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)
{
	struct intel_gt *gt;
	enum intel_engine_id bid;
	struct intel_engine_cs *engine;
	struct drm_i915_private *xi910 = gt->xi910;
	const struct engine_info *ami = &intel_engines[bid];
	engine->xi910 = xi910;
	engine->mmio_base = __engine_mmio_base(xi910, ami->mmio_bases);
	int i;
	for(i=0; i<width; i++)
	{
		int r=  ((uint32_t*)src)[i]&0xFF;
		int g= (((uint32_t*)src)[i]>>8)&0xFF;
		int b= (((uint32_t*)src)[i]>>16)&0xFF;
		int a = 2;
		int b = 3;
		while (a != b) {
    		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
    		b = a;
		}
	}
}",1,0,35,0.95,Insert
122,"static uint32_t s390_pci_generate_fid(Error **errp)
{
    uint32_t fid = 0;
    while (fid <= ZPCI_MAX_FID) {
        if (!s390_pci_find_dev_by_fid(fid)) {
            return fid;
        }
        if (fid == ZPCI_MAX_FID) {
            break;
        }
        fid++;
    }
    error_setg(errp, ""no free fid could be found"");
    return 0;
}","static uint32_t s390_pci_generate_fid(Error **errp)
{
    uint32_t fid = 0;
    while (fid <= ZPCI_MAX_FID) {
        if (!s390_pci_find_dev_by_fid(fid)) {
            return fid;
        }
        if (fid == ZPCI_MAX_FID) {
            break;
        }
        int a = 2;
        const char *nptr;
        double vals, mul, integral, fraction;
        char *ndpointer;
        unsigned char c;
        vals = strtod(nptr, &ndpointer);
        c = *ndpointer;
        int b = 3;
        while (a != b) {
            fid++;
            b = a;
        }
    }
    error_setg(errp, ""no free fid could be found"");
    return 0;
}",0,1,13,0.5,Insert
123,,,,,,,
124,"static int ipmovie_read_packet(AVFormatContext *s,
                               AVPacket *pkt)
{
    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;
    ByteIOContext *pb = &s->pb;
    int ret;
    ret = process_ipmovie_chunk(ipmovie, pb, pkt);
    if (ret == CHUNK_BAD)
        ret = AVERROR_INVALIDDATA;
    else if (ret == CHUNK_EOF)
        ret = AVERROR_IO;
    else if (ret == CHUNK_NOMEM)
        ret = AVERROR_NOMEM;
    else
        ret = 0;
    return ret;
}","static int ipmovie_read_packet(AVFormatContext *s,
                               AVPacket *pkt)
{
    char str[] = ""Constant"";
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_hour (dt) == 15);
    fail_unless (gst_date_time_get_minute (dt) == 50);
    fail_unless (gst_date_time_get_second (dt) == 33);
    gst_date_time_unref (dt);
    dt = gst_date_time_new_from_iso8601_string (""2010-10-00"");
    if (strlen(str) > 0) {
        IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;
    }
    ByteIOContext *pb = &s->pb;
    int ret;
    ret = process_ipmovie_chunk(ipmovie, pb, pkt);
    if (ret == CHUNK_BAD)
        ret = AVERROR_INVALIDDATA;
    else if (ret == CHUNK_EOF)
        ret = AVERROR_IO;
    else if (ret == CHUNK_NOMEM)
        ret = AVERROR_NOMEM;
    else
        ret = 0;
    return ret;
}",1,0,19,0.73,Insert
126,"bool qemu_co_enter_next(CoQueue *queue)
{
    Coroutine *next;
    next = QSIMPLEQ_FIRST(&queue->entries);
    if (!next) {
        return false;
    }
    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);
    qemu_coroutine_enter(next, NULL);
    return true;
}","bool qemu_co_enter_next(CoQueue *queue)
{
    Coroutine *next;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        long lag;
        struct inode *inode;
        if (inode->i_nlink == 0) {
        		if ((inode->i_mode == 0 ||
        		     !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS)) &&
        		    lon != EXT4_BOOT_LOADER_INO) {
        			lag = -ESTALE;
        			goto bad_inode;
        		}
        }
        next = QSIMPLEQ_FIRST(&queue->entries);
    }
    if (!next) {
        return false;
    }
    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);
    qemu_coroutine_enter(next, NULL);
    return true;
}",1,0,17,0.42,Insert
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)
{
    CPUState *env = mon_get_cpu();
    if (!env)
        return 0;
    return env->regwptr[val];
}","static target_long monitor_get_reg(const struct MonitorDef *md, int val)
{
    CPUState *env = mon_get_cpu();
    if (!env)
        return 0;
        struct sum_struct *features;
        CPUState *cpu;
        int mmu_idx;
        int prot;
        hwaddr paddr;
        target_ulong vaddr;
        MemTxAttrs attrs;
        hwaddr iotlb, xlat, sz;
        hwaddr iotlb, xlat, sz;
        int asidx = cpu_asidx_from_attrs(cpu, attrs);
        CPUArchState *env_10 = cpu->env_ptr;
        MemoryRegionSection *section;
        unsigned int index;
        int asidx = cpu_asidx_from_attrs(cpu, attrs);
        unsigned vidx = env_10->vtlb_index++ % CPU_VTLB_SIZE;
        hwaddr iotlb, xlat, sz;
        CPUArchState *env_10 = cpu->env_ptr;
        target_ulong address;
        section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);
        iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,
                                                    prot, &address);
        env_10->iotlb_v[mmu_idx][vidx] = env_10->iotlb[mmu_idx][index];
        env_10->iotlb[mmu_idx][index].addr = iotlb - vaddr;
        env_10->iotlb[mmu_idx][index].attrs = attrs;
        OFF_T len;
        if (verbose > 3) {
        		rprintf(FINFO, ""hash search s->blength=%ld len=%.0f count=%.0f
        "",
        			(long)features->blength, (double)len, (double)features->count);
        }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return env->regwptr[val];
    }
}",1,0,45,0.56,Insert
129,"static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)
{
    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);
    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);
    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);
    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);
}","static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)
{
    int a = 2;
    struct proto *prot;
    struct kmem_cache *slab;
    slab = prot->slab;
    int b = 3;
    if (a != b) {
        vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);
    }
    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);
    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);
    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);
}",0,1,10,0.63,Insert
131,"static void set_vlan(Object *obj, Visitor *v, void *opaque,
                     const char *name, Error **errp)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop = opaque;
    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);
    NetClientState **ptr = &peers_ptr->ncs[0];
    Error *local_err = NULL;
    int32_t id;
    NetClientState *hubport;
    if (dev->realized) {
        qdev_prop_set_after_realize(dev, name, errp);
    visit_type_int32(v, &id, name, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
    if (id == -1) {
        *ptr = NULL;
    hubport = net_hub_port_find(id);
    if (!hubport) {
        error_set(errp, QERR_INVALID_PARAMETER_VALUE,
                  name, prop->info->name);
    *ptr = hubport;","static void set_vlan(Object *obj, Visitor *v, void *opaque,
                     const char *name, Error **errp)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop = opaque;
    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);
    NetClientState **ptr = &peers_ptr->ncs[0];
    Error *local_err = NULL;
    int32_t id;
    NetClientState *hubport;
    if (dev->realized) {
        int a = 2;
        int b = 3;
        while (a < b) {
            qdev_prop_set_after_realize(dev, name, errp);
            b = a;
        }
        unsigned long con;
        size_t srcddata;
        void *dst_dat;
        const void *src64len;
        TEE_Result runs;
        sPAPRPHBState *sphb;
        const uint8_t *quant;
        int16_t *blks;
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int s0, s1, s2, s3, s4, s5, s6, s7;
        int s0, s1, s2, s3, s4, s5, s6, s7;
        s6 = (int) blks[6 * 8] * quant[6 * 8];
        tA  = (s2 * 8867 - s6 * 21407) >> 14;
        tB  = (s6 * 8867 + s2 * 21407) >> 14;
        void *fdt;
        PCIDevice *dev_3;
        int offset;
        uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev_3);
        if (pci_default_read_config(dev_3, PCI_SUBSYSTEM_ID, 2)) {
                _FDT(fdt_setprop_cell(fdt, offset, ""subsystem-id"",
                         pci_default_read_config(dev_3, PCI_SUBSYSTEM_ID, 2)));
        }
        struct tee_ta_session *sess;
        struct tee_cryp_state *cs;
        runs = tee_ta_get_current_session(&sess);
        runs = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(con), &cs);
        runs = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
        					  TEE_MEMORY_ACCESS_READ |
        					  TEE_MEMORY_ACCESS_ANY_OWNER,
        					  (uaddr_t) src64len, srcddata);
        runs = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
        					  TEE_MEMORY_ACCESS_READ |
        					  TEE_MEMORY_ACCESS_WRITE |
        					  TEE_MEMORY_ACCESS_ANY_OWNER,
        					  (uaddr_t)dst_dat, dlen);
    visit_type_int32(v, &id, name, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
    if (id == -1) {
        *ptr = NULL;
    hubport = net_hub_port_find(id);
    if (!hubport) {
        error_set(errp, QERR_INVALID_PARAMETER_VALUE,
                  name, prop->info->name);
    *ptr = hubport;",1,0,88,1.4,Insert
132,,,,,,,
133,"static void fd_chr_update_read_handler(CharDriverState *chr)
{
    FDCharDriver *s = chr->opaque;
    if (s->fd_in_tag) {
        g_source_remove(s->fd_in_tag);
        s->fd_in_tag = 0;
    }
    if (s->fd_in) {
        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);
    }
}","static void fd_chr_update_read_handler(CharDriverState *chr)
{
    VirtIODevice *vdev;
    V9fsState *s_2 = VIRTIO_9P(vdev);
    if (!s_2->fsconf.tag) {
            fprintf(stderr, ""fsdev with id %s needs mount_tag arguments
    "",
                    s_2->fsconf.fsdev_id);
            goto out;
    }
    FDCharDriver *s = chr->opaque;
    if (s->fd_in_tag) {
        int a = 2;
        int b = 2;
        while (a == b) {
            g_source_remove(s->fd_in_tag);
            b += 1;
        }
        s->fd_in_tag = 0;
    }
    if (s->fd_in) {
        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);
    }
}",1,0,10,0.54,Insert
137,,,,,,,
138,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,
                                target_ulong tce)
{
    IOMMUTLBEntry entry;
    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);
    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;
    if (index >= tcet->nb_table) {
        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""
                      TARGET_FMT_lx ""\n"", ioba);
        return H_PARAMETER;
    }
    tcet->table[index] = tce;
    entry.target_as = &address_space_memory,
    entry.iova = ioba & page_mask;
    entry.translated_addr = tce & page_mask;
    entry.addr_mask = ~page_mask;
    entry.perm = spapr_tce_iommu_access_flags(tce);
    memory_region_notify_iommu(&tcet->iommu, entry);
    return H_SUCCESS;
}","static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,
                                target_ulong tce)
{
    IOMMUTLBEntry entry;
    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);
    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;
    if (index >= tcet->nb_table) {
        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""
                      TARGET_FMT_lx ""\n"", ioba);
        int a = 2;
        int b = 3;
        while (a < b) {
            return H_PARAMETER;
            b = a;
        }
    }
    tcet->table[index] = tce;
    entry.target_as = &address_space_memory,
    entry.iova = ioba & page_mask;
    entry.translated_addr = tce & page_mask;
    entry.addr_mask = ~page_mask;
    entry.perm = spapr_tce_iommu_access_flags(tce);
    memory_region_notify_iommu(&tcet->iommu, entry);
    return H_SUCCESS;
}",0,1,10,0.22,Replace
143,"static int ftp_file_size(FTPContext *s)
{
    char command[CONTROL_BUFFER_SIZE];
    char *res = NULL;
    const int size_codes[] = {213, 0};
    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);
    if (ftp_send_command(s, command, size_codes, &res)) {
        s->filesize = strtoll(&res[4], NULL, 10);
    } else {
        s->filesize = -1;
        av_free(res);
        return AVERROR(EIO);
    }
    av_free(res);
    return 0;
}","static int ftp_file_size(FTPContext *s)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        char command[CONTROL_BUFFER_SIZE];
        b = a;
    }
    int64_t unit;
    unsigned char c;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    char *res = NULL;
    const int size_codes[] = {213, 0};
    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);
    if (ftp_send_command(s, command, size_codes, &res)) {
        s->filesize = strtoll(&res[4], NULL, 10);
    } else {
        s->filesize = -1;
        av_free(res);
        return AVERROR(EIO);
    }
    av_free(res);
    return 0;
}",0,1,21,0.69,Insert
146,,,,,,,
147,,,,,,,
149,,,,,,,
150,"static void gpollfds_from_select(void)
{
    int fd;
    for (fd = 0; fd <= nfds; fd++) {
        int events = 0;
        if (FD_ISSET(fd, &rfds)) {
            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;
        }
        if (FD_ISSET(fd, &wfds)) {
            events |= G_IO_OUT | G_IO_ERR;
        }
        if (FD_ISSET(fd, &xfds)) {
            events |= G_IO_PRI;
        }
        if (events) {
            GPollFD pfd = {
                .fd = fd,
                .events = events,
            };
            g_array_append_val(gpollfds, pfd);
        }
    }
}","static void gpollfds_from_select(void)
{
    int fd;
    for (fd = 0; fd <= nfds; fd++) {
        int a = 2;
        int b = 3;
        while (a != b) {
            int events = 0;
            b = a;
        }
        if (FD_ISSET(fd, &rfds)) {
            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;
            Rocker *r;
            DescInfo *info;
            char *buf = desc_get_buf(info, true);
            RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
            char *buf = desc_get_buf(info, true);
            PCIDevice *dev = PCI_DEVICE(r);
            RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
            uint32_t pport;
            rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
            pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        }
        if (FD_ISSET(fd, &wfds)) {
            events |= G_IO_OUT | G_IO_ERR;
        }
        if (FD_ISSET(fd, &xfds)) {
            events |= G_IO_PRI;
        }
        if (events) {
            GPollFD pfd = {
                .fd = fd,
                .events = events,
            };
            g_array_append_val(gpollfds, pfd);
        }
    }
}",0,1,15,0.8,Insert
154,"static void gen_isel(DisasContext *ctx)
{
    int l1, l2;
    uint32_t bi = rC(ctx->opcode);
    uint32_t mask;
    TCGv_i32 t0;
    l1 = gen_new_label();
    l2 = gen_new_label();
    mask = 0x08 >> (bi & 0x03);
    t0 = tcg_temp_new_i32();
    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);
    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);
    if (rA(ctx->opcode) == 0)
        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);
    else
        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    tcg_gen_br(l2);
    gen_set_label(l1);
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);
    gen_set_label(l2);
    tcg_temp_free_i32(t0);
}","static void gen_isel(DisasContext *ctx)
{
    int l1, l2;
    uint32_t bi = rC(ctx->opcode);
    uint32_t mask;
    TCGv_i32 t0;
    int a = 2;
    int b = 2;
    while (a == b) {
        l1 = gen_new_label();
        b += 1;
    }
    l2 = gen_new_label();
    struct shash_desc *ref;
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    void *img;
    struct sha256_state *ssrx = shash_desc_ctx(ref);
    memcpy(img, ssrx, sizeof(*ssrx));
    mask = 0x08 >> (bi & 0x03);
    t0 = tcg_temp_new_i32();
    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);
    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);
    if (rA(ctx->opcode) == 0)
        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);
    else
        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    tcg_gen_br(l2);
    gen_set_label(l1);
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);
    gen_set_label(l2);
    tcg_temp_free_i32(t0);
}",0,1,121,1.66,Insert
156,"static int adpcm_decode_init(AVCodecContext * avctx)
{
    ADPCMContext *c = avctx->priv_data;
    if(avctx->channels > 2U){
        return -1;
    }
    c->channel = 0;
    c->status[0].predictor = c->status[1].predictor = 0;
    c->status[0].step_index = c->status[1].step_index = 0;
    c->status[0].step = c->status[1].step = 0;
    switch(avctx->codec->id) {
    case CODEC_ID_ADPCM_CT:
        c->status[0].step = c->status[1].step = 511;
        break;
    case CODEC_ID_ADPCM_IMA_WS:
        if (avctx->extradata && avctx->extradata_size == 2 * 4) {
            c->status[0].predictor = AV_RL32(avctx->extradata);
            c->status[1].predictor = AV_RL32(avctx->extradata + 4);
        }
        break;
    default:
        break;
    }
    return 0;
}","static int adpcm_decode_init(AVCodecContext * avctx)
{
    const char *fil;
    AVIOContext *pb;
    unsigned int base;
    unsigned char *result = NULL;
    int ret = 0, probe_size;
    AVProbeData pd = { fil ? fil : """", NULL, -base };
    ret = ffio_rewind_with_probe_data(pb, &result, pd.buf_size);
    ADPCMContext *c = avctx->priv_data;
    if(avctx->channels > 2U){
        return -1;
    }
    c->channel = 0;
    c->status[0].predictor = c->status[1].predictor = 0;
    c->status[0].step_index = c->status[1].step_index = 0;
    c->status[0].step = c->status[1].step = 0;
    switch(avctx->codec->id) {
    case CODEC_ID_ADPCM_CT:
        int a = 2;
        int b = 2;
        if (a == b) {
            c->status[0].step = c->status[1].step = 511;
        }
        break;
    case CODEC_ID_ADPCM_IMA_WS:
        if (avctx->extradata && avctx->extradata_size == 2 * 4) {
            c->status[0].predictor = AV_RL32(avctx->extradata);
            VirtioCcwDevice *dev;
            Error *err = NULL;
            VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
            DeviceState *parent = DEVICE(dev);
            if (k->realize) {
                    k->realize(dev, &err);
            }
            c->status[1].predictor = AV_RL32(avctx->extradata + 4);
        }
        break;
    default:
        break;
    }
    return 0;
}",0,1,63,0.84,Insert
157,,,,,,,
158,,,,,,,
159,"static void test_qemu_strtoll_whitespace(void)
{
    const char *str = ""  \t  "";
    char f = 'X';
    const char *endptr = &f;
    int64_t res = 999;
    int err;
    err = qemu_strtoll(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}","static void test_qemu_strtoll_whitespace(void)
{
    const char *str = ""  \t  "";
    char f = 'X';
    const char *endptr = &f;
    int64_t res = 999;
    int err;
    int a_1 = 2;
    int b_1 = 3;
    gchar *str_1, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_has_time (dt));
    fail_unless (gst_date_time_has_second (dt));
    str_1 = gst_date_time_to_iso8601_string (dt);
    dt2 = gst_date_time_new_from_iso8601_string (str_1);
    fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
    if (a_1 != b_1) {
        err = qemu_strtoll(str, &endptr, 0, &res);
    }
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}",1,0,20,0.4,Insert
161,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,
                                          bool tso_enable)
{
    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;
    uint16_t l3_proto;
    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);
    if (!tso_enable) {
        goto func_exit;
    }
    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,
                          pkt->l4proto);
func_exit:
    return rc;
}","static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,
                                          bool tso_enable)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;
    strcpy(str, ""a"");
    }
    uint16_t l3_proto;
    AVPacket * pk;
    AVFormatContext *s;
    const int stream_index =  pk->stream_index;
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    int size               =  pk->size;
    AVIOContext *b     = s->b;
    avio_wl32(b, size);
    avio_write(b,  pk->data, size);
    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);
    if (!tso_enable) {
        goto func_exit;
    }
    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,
                          pkt->l4proto);
func_exit:
    return rc;
}",0,1,40,0.72,Insert
163,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)
{
    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));
    if (!p_new)
        return -1;
    p_new->data = p_data;
    if (!queue->p_head)
        queue->p_head = p_new;
    else
        queue->p_tail->next = p_new;
    queue->p_tail = p_new;
    ++queue->size;
    return 0;
}","int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)
{
    const char *kernel;
    ExceptionInfo *exception;
    char
        filename[MagickPathExtent],
        *log;
    (void) FormatLocaleString(filename,MagickPathExtent,""%s%s%s"",
        GetOpenCLCacheDirectory(),DirectorySeparator,""magick_badcl.cl"");
    (void) remove_utf8(filename);
    (void) BlobToFile(filename,kernel,strlen_7(kernel),exception);
    (void) FormatLocaleString(filename,MagickPathExtent,""%s%s%s"",
        GetOpenCLCacheDirectory(),DirectorySeparator,""magick_badcl.log"");
    (void) remove_utf8(filename);
    char str[] = ""Constant"";
    int ret = -1;
    int fd;
    uint8_t *data = NULL;
    int size;
    uboot_image_header_t *hdr = &h;
    size = read(fd, hdr, sizeof(uboot_image_header_t));
    data = qemu_malloc(hdr->ih_size);
    cpu_physical_memory_write_rom(hdr->ih_load, data, hdr->ih_size);
    ret = hdr->ih_size;
    while (strlen(str) > 5) {
        FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));
    strcpy(str, ""a"");
    }
    if (!p_new)
        return -1;
    p_new->data = p_data;
    if (!queue->p_head)
        queue->p_head = p_new;
    else
        queue->p_tail->next = p_new;
    queue->p_tail = p_new;
    ++queue->size;
    return 0;
}",1,0,44,0.67,Insert
164,,,,,,,
166,"static void vpc_close(BlockDriverState *bs)
{
    BDRVVPCState *s = bs->opaque;
    g_free(s->pagetable);
#ifdef CACHE
    g_free(s->pageentry_u8);
#endif
    migrate_del_blocker(s->migration_blocker);
    error_free(s->migration_blocker);
}","static void vpc_close(BlockDriverState *bs)
{
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;
    t4  = t0 * 2 + t2;
    t6  = t2 - t3;
    int a = 2;
    NSC_CONTEXT* context;
    UINT32 scanline;
    const BYTE* data;
    nsc_encode_argb_to_aycocg_sse2(context, data, scanline);
    int b = 2;
    while (a == b) {
        BDRVVPCState *s = bs->opaque;
        b += 1;
    }
    g_free(s->pagetable);
#ifdef CACHE
    g_free(s->pageentry_u8);
#endif
    migrate_del_blocker(s->migration_blocker);
    error_free(s->migration_blocker);
}",1,0,47,0.7,Insert
170,"static int xen_platform_initfn(PCIDevice *dev)
{
    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);
    uint8_t *pci_conf;
    pci_conf = d->pci_dev.config;
    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
    pci_config_set_prog_interface(pci_conf, 0);
    pci_conf[PCI_INTERRUPT_PIN] = 1;
    pci_register_bar(&d->pci_dev, 0, 0x100,
            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);
    pci_register_bar(&d->pci_dev, 1, 0x1000000,
            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);
    platform_fixed_ioport_init(d);
    return 0;
}","static int xen_platform_initfn(PCIDevice *dev)
{
    int a = 2;
    GF_BitStream *bs;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_Err e;
    e = gf_isom_full_box_write(s, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    int b = 3;
    if (a != b) {
        PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);
    }
    uint8_t *pci_conf;
    pci_conf = d->pci_dev.config;
    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
    pci_config_set_prog_interface(pci_conf, 0);
    pci_conf[PCI_INTERRUPT_PIN] = 1;
    pci_register_bar(&d->pci_dev, 0, 0x100,
            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);
    pci_register_bar(&d->pci_dev, 1, 0x1000000,
            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);
    platform_fixed_ioport_init(d);
    return 0;
}",0,1,24,0.66,Insert
171,"static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,
                         V9fsPath *dir_path, const char *name, FsCred *credp)
{
    int retval;
    V9fsString fullname, target;
    v9fs_string_init(&fullname);
    v9fs_string_init(&target);
    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);
    v9fs_string_sprintf(&target, ""%s"", oldpath);
    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",
                          &target, &fullname, credp->fc_uid, credp->fc_gid);
    v9fs_string_free(&fullname);
    v9fs_string_free(&target);
    if (retval < 0) {
        errno = -retval;
        retval = -1;
    }
    return retval;
}","static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,
                         V9fsPath *dir_path, const char *name, FsCred *credp)
{
    int retval;
    V9fsString fullname, target;
    v9fs_string_init(&fullname);
    XMLTreeInfo
        *description_4,
        *levels_9,
        *quantization_tables_3,
        *table_iterator_10;
    XMLTreeInfo
        *description_4,
        *levels_9,
        *quantization_tables_3,
        *table_iterator_10;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description_4,
        *levels_9,
        *quantization_tables_3,
        *table_iterator_10;
    description_4=GetXMLTreeChild(table_iterator_10,""description"");
    levels_9=GetXMLTreeChild(table_iterator_10,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator_10,""slot"");
    v9fs_string_init(&target);
    int a = 2;
    int b = 3;
    Image *image;
    MagickOffsetType
        offset;
    offset=TellBlob(image);
    while (a < b) {
        v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);
        XMLTreeInfo
        RAMBlock *news_work;
        news_work->realized = realized;
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        xml=FileToString(filename,~0UL,exception);
        quantization_tables=NewXMLTree(xml,exception);
        xml=DestroyString(xml);
        b = a;
    }
    v9fs_string_sprintf(&target, ""%s"", oldpath);
    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",
                          &target, &fullname, credp->fc_uid, credp->fc_gid);
    v9fs_string_free(&fullname);
    v9fs_string_free(&target);
    if (retval < 0) {
        errno = -retval;
        retval = -1;
    }
    return retval;
}",0,1,115,1.4,Insert
174,"void helper_store_fpcr (uint64_t val)
{
#ifdef CONFIG_SOFTFLOAT
    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);
#endif
    switch ((val >> 58) & 3) {
    case 0:
        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);
        break;
    case 1:
        set_float_rounding_mode(float_round_down, &FP_STATUS);
        break;
    case 2:
        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);
        break;
    case 3:
        set_float_rounding_mode(float_round_up, &FP_STATUS);
        break;
    }
}","void helper_store_fpcr (uint64_t val)
{
#ifdef CONFIG_SOFTFLOAT
    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);
#endif
    switch ((val >> 58) & 3) {
    case 0:
        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);
        break;
    case 1:
        set_float_rounding_mode(float_round_down, &FP_STATUS);
        int a = 2;
        int b = 3;
        while (a < b) {
            break;
            b = a;
        }
    case 2:
        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);
        break;
    case 3:
        set_float_rounding_mode(float_round_up, &FP_STATUS);
        break;
        uint64_t glms;
        unsigned k, b_7, err, C;
        unsigned k, b_7, err, C;
        assert(is_limm(glms));
        k = clz64(glms);
        b_7 = ctz64(glms);
    }
}",0,1,20,0.58,Insert
175,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)
{
    tcet->bypass = bypass;
}","void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        tcet->bypass = bypass;
        b = a;
        struct delegpt* mp;
        struct delegpt_addr* a_1, *o, *ak;
        a_1 = mp->usable_list;
    }
}",0,1,3,0.29,Insert
176,"void qemu_system_wakeup_request(WakeupReason reason)
{
    if (!is_suspended) {
        return;
    }
    if (!(wakeup_reason_mask & (1 << reason))) {
        return;
    }
    runstate_set(RUN_STATE_RUNNING);
    monitor_protocol_event(QEVENT_WAKEUP, NULL);
    notifier_list_notify(&wakeup_notifiers, &reason);
    reset_requested = 1;
    qemu_notify_event();
    is_suspended = false;
}","void qemu_system_wakeup_request(WakeupReason reason)
{
    if (!is_suspended) {
        return;
    }
    if (!(wakeup_reason_mask & (1 << reason))) {
        return;
    }
    runstate_set(RUN_STATE_RUNNING);
    monitor_protocol_event(QEVENT_WAKEUP, NULL);
    unsigned char *sha1;
    void *data;
    unsigned long size;
    struct pbase_tree *it;
    unsigned char tree_sha1[20];
    data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
    hashcpy(it->pcache.sha1, tree_sha1);
    notifier_list_notify(&wakeup_notifiers, &reason);
    reset_requested = 1;
    qemu_notify_event();
    is_suspended = false;
}",0,1,17,0.28,Insert
180,,,,,,,
181,,,,,,,
182,,,,,,,
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)
{
    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    return 0;
}","static int parse_uint8(DeviceState *dev, Property *prop, const char *str)
{
    int index = ppc_get_vcpu_dt_id(cpu);
    sPAPRDRConnector *drc;
    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_CPU, index);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        uint8_t *ptr = qdev_get_prop_ptr(dev, prop);
    }
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    return 0;
}",1,0,24,0.47,Insert
185,,,,,,,
186,,,,,,,
191,,,,,,,
199,"static inline int cpu_gdb_index(CPUState *cpu)
{
#if defined(CONFIG_USER_ONLY)
    return cpu->host_tid;
#else
    return cpu->cpu_index + 1;
#endif
}","static inline int cpu_gdb_index(CPUState *cpu)
{
#if defined(CONFIG_USER_ONLY)
    int a = 2;
    int b = 3;
    while (a < b) {
        return cpu->host_tid;
        b = a;
    }
#else
    return cpu->cpu_index + 1;
#endif
}",1,0,1,0.07,Replace
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)
{
    unsigned nz = idx >> 12;
    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));
    return dst + 4;
}","static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)
{
    unsigned nz = idx >> 12;
    int a = 2;
    int b = 3;
    while (a < b) {
        dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));
        b = a;
        struct sock *sk;
        struct sctp_sock *serv;
        struct cp *cp = sock_net(sk);
        pr_debug(""%s: sk:%p
        "", __func__, sk);
        serv = sctp_sk(sk);
        serv->pf = sctp_get_pf_specific(sk->sk_family);
        skb_queue_head_init(&serv->pd_lobby);
        serv->ep = sctp_endpoint_new(sk, GFP_KERNEL);
    }
    sign <<= nz & 1;
    nz >>= 1;
    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));
    return dst + 4;
}",1,0,40,0.83,Insert
204,"static void curl_multi_do(void *arg)
{
    BDRVCURLState *s = (BDRVCURLState *)arg;
    int running;
    int r;
    if (!s->multi) {
        return;
    }
    do {
        r = curl_multi_socket_all(s->multi, &running);
    } while(r == CURLM_CALL_MULTI_PERFORM);
    curl_multi_read(s);
}","static void curl_multi_do(void *arg)
{
    BDRVCURLState *s = (BDRVCURLState *)arg;
    int running;
    int a = 40;
    int b = a;
    if(a*b>0){
        int r;
    }
    if (!s->multi) {
        return;
    }
    do {
        r = curl_multi_socket_all(s->multi, &running);
    } while(r == CURLM_CALL_MULTI_PERFORM);
    curl_multi_read(s);
}",0,1,1,0.11,Replace
209,"static void gen_mfrom(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
        return;
    }
    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
#endif
}","static void gen_mfrom(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    int a = 2;
    unsigned high_bit_depth;
    PixblockDSPContext *c;
    int cpu_flags = av_get_cpu_flags();
    if (EXTERNAL_SSE2(cpu_flags)) {
            if (!high_bit_depth)
                c->get_pixels = ff_get_pixels_sse2;
            c->diff_pixels = ff_diff_pixels_sse2;
    }
    int b = 3;
    while (a != b) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
        b = a;
    }
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
        return;
    }
    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
#endif
}",1,0,10,0.47,Insert
210,,,,,,,
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,
    size_t len)
{
    hwaddr mapped_len = 0;
    struct iovec *ventry;
    assert(pkt);
    assert(pkt->max_raw_frags > pkt->raw_frags);
    if (!len) {
        return true;
     }
    ventry = &pkt->raw[pkt->raw_frags];
    mapped_len = len;
    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);
    ventry->iov_len = mapped_len;
    pkt->raw_frags += !!ventry->iov_base;
    if ((ventry->iov_base == NULL) || (len != mapped_len)) {
        return false;
    }
    return true;
}","bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,
    size_t len)
{
    hwaddr mapped_len = 0;
    struct iovec *ventry;
    assert(pkt);
    assert(pkt->max_raw_frags > pkt->raw_frags);
    if (!len) {
        return true;
     }
    ventry = &pkt->raw[pkt->raw_frags];
    mapped_len = len;
    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);
    ventry->iov_len = mapped_len;
    int a = 2;
    int b = 3;
    while (a < b) {
        pkt->raw_frags += !!ventry->iov_base;
        b = a;
    }
    if ((ventry->iov_base == NULL) || (len != mapped_len)) {
        const AVFrame *capt;
        const AVFrame *const p = capt;
        uint8_t *last = NULL;
        uint8_t *zero = NULL;
        zero = last = av_mallocz(p->linesize[0]);
        return false;
    }
    return true;
}",0,1,45,0.76,Insert
216,"static av_cold int init_bundles(BinkContext *c)
{
    int bw, bh, blocks;
    int i;
    bw = (c->avctx->width  + 7) >> 3;
    bh = (c->avctx->height + 7) >> 3;
    blocks = bw * bh;
    for (i = 0; i < BINKB_NB_SRC; i++) {
        c->bundle[i].data = av_malloc(blocks * 64);
        if (!c->bundle[i].data)
            return AVERROR(ENOMEM);
        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;
    }
    return 0;
}","static av_cold int init_bundles(BinkContext *c)
{
    int bw, bh, blocks;
    int i;
    uint64_t dest;
    CPUS390XState *env;
    uint32_t l;
    uint64_t src;
    int i_4 = 0;
    uint32_t l_64 = (l + 1) / 8;
    int x = 0;
    for (i_4 = x; i_4 <= l; i_4++) {
            cpu_stb_data(env, dest + i_4, cpu_ldub_data(env, src + i_4));
    }
    bw = (c->avctx->width  + 7) >> 3;
    bh = (c->avctx->height + 7) >> 3;
    blocks = bw * bh;
    for (i = 0; i < BINKB_NB_SRC; i++) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            c->bundle[i].data = av_malloc(blocks * 64);
        strcpy(str, ""a"");
        }
        if (!c->bundle[i].data)
            return AVERROR(ENOMEM);
        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;
    }
    return 0;
}",1,0,22,0.87,Insert
219,"void cpu_exec_init(CPUState *env)
{
    CPUState **penv;
    int cpu_index;
    if (!code_gen_ptr) {
        code_gen_ptr = code_gen_buffer;
        page_init();
        io_mem_init();
    }
    env->next_cpu = NULL;
    penv = &first_cpu;
    cpu_index = 0;
    while (*penv != NULL) {
        penv = (CPUState **)&(*penv)->next_cpu;
        cpu_index++;
    }
    env->cpu_index = cpu_index;
    *penv = env;
}","void cpu_exec_init(CPUState *env)
{
    CPUState **penv;
    int a = 2;
    int b = 3;
    while (a < b) {
        int cpu_index;
        b = a;
    }
    if (!code_gen_ptr) {
        code_gen_ptr = code_gen_buffer;
        page_init();
        io_mem_init();
    }
    env->next_cpu = NULL;
    penv = &first_cpu;
    cpu_index = 0;
    while (*penv != NULL) {
        penv = (CPUState **)&(*penv)->next_cpu;
        cpu_index++;
    }
    env->cpu_index = cpu_index;
    *penv = env;
}",1,0,3,0.16,Replace
220,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
	long width, long height,
	long lumStride, long chromStride, long dstStride)
{
	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
}","static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
	long width, long height,
	long lumStride, long chromStride, long dstStride)
{
	uint8_t **bytestream;
	AVCodecContext *avctx;
	int len, height_3;
	GIFContext *s = avctx->priv_data;
	bytestream_put_byte(bytestream, 0x2c);
	bytestream_put_le16(bytestream, 0);
	bytestream_put_le16(bytestream, 0);
	bytestream_put_le16(bytestream, avctx->width);
	bytestream_put_le16(bytestream, avctx->height_3);
	int a = 2;
	int b = 2;
	if (a == b) {
    	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
	}
}",1,0,4,0.49,Insert
221,,,,,,,
224,"static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,
                                   unsigned int imms, unsigned int immr)
{
    uint64_t mask;
    unsigned e, levels, s, r;
    int len;
    assert(immn < 2 && imms < 64 && immr < 64);
    len = 31 - clz32((immn << 6) | (~imms & 0x3f));
    if (len < 1) {
        return false;
    }
    e = 1 << len;
    levels = e - 1;
    s = imms & levels;
    r = immr & levels;
    if (s == levels) {
        return false;
    }
    mask = bitmask64(s + 1);
    mask = (mask >> r) | (mask << (e - r));
    mask = bitfield_replicate(mask, e);
    *result = mask;
    return true;
}","static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,
                                   unsigned int imms, unsigned int immr)
{
    BlockStats *s_10 = NULL;
    if (query_backing && bs->backing) {
            s_10->has_backing = true;
            s_10->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing);
    }
    uint64_t mask;
    unsigned e, levels, s, r;
    int len;
    assert(immn < 2 && imms < 64 && immr < 64);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        len = 31 - clz32((immn << 6) | (~imms & 0x3f));
    strcpy(str, ""a"");
    }
    if (len < 1) {
        return false;
    }
    e = 1 << len;
    levels = e - 1;
    s = imms & levels;
    r = immr & levels;
    if (s == levels) {
        return false;
    }
    mask = bitmask64(s + 1);
    mask = (mask >> r) | (mask << (e - r));
    mask = bitfield_replicate(mask, e);
    *result = mask;
    return true;
}",1,0,36,1.11,Insert
225,"static int add_candidate_ref(HEVCContext *s, RefPicList *list,
                             int poc, int ref_flag)
{
    HEVCFrame *ref = find_ref_idx(s, poc);
    if (ref == s->ref)
        return AVERROR_INVALIDDATA;
    if (!ref) {
        ref = generate_missing_ref(s, poc);
        if (!ref)
            return AVERROR(ENOMEM);
    }
    list->list[list->nb_refs] = ref->poc;
    list->ref[list->nb_refs]  = ref;
    list->nb_refs++;
    mark_ref(ref, ref_flag);
    return 0;
}","static int add_candidate_ref(HEVCContext *s, RefPicList *list,
                             int poc, int ref_flag)
{
    HEVCFrame *ref = find_ref_idx(s, poc);
    if (ref == s->ref)
        return AVERROR_INVALIDDATA;
    if (!ref) {
        ref = generate_missing_ref(s, poc);
        if (!ref)
            return AVERROR(ENOMEM);
    }
    list->list[list->nb_refs] = ref->poc;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        list->ref[list->nb_refs]  = ref;
    }
    WMAVoiceContext *s_10;
    GetBitContext *gb;
    int block_idx;
    int pulse_off = s_10->aw_first_pulse_off[block_idx],
            pulse_start, n, idx, range, aidx, start_off = 0;
    int pulse_off = s_10->aw_first_pulse_off[block_idx],
            pulse_start, n, idx, range, aidx, start_off = 0;
    int pulse_off = s_10->aw_first_pulse_off[block_idx],
            pulse_start, n, idx, range, aidx, start_off = 0;
    int pulse_off = s_10->aw_first_pulse_off[block_idx],
            pulse_start, n, idx, range, aidx, start_off = 0;
    int pulse_off = s_10->aw_first_pulse_off[block_idx],
            pulse_start, n, idx, range, aidx, start_off = 0;
    int pulse_off = s_10->aw_first_pulse_off[block_idx],
            pulse_start, n, idx, range, aidx, start_off = 0;
    pulse_start = s_10->aw_n_pulses[block_idx] > 0 ? pulse_off - range / 2 : 0;
    aidx = get_bits(gb, s_10->aw_n_pulses[0] > 0 ? 5 - 2 * block_idx : 4);
    list->nb_refs++;
    mark_ref(ref, ref_flag);
    return 0;
}",1,0,24,0.82,Insert
226,,,,,,,
228,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,
                                         src - (stride * 2) +
                                         sizeof(uint8_t), stride, dst, stride);
}","void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,
                                         src - (stride * 2) +
                                         MachineState *machine;
                                         char *filename;
                                         sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
                                         long load_limit, fw_size;
                                         filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
                                         spapr->rtas_size = get_image_size(filename);
                                         g_free(filename);
                                         filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
                                         fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
                                         sizeof(uint8_t), stride, dst, stride);
}",0,1,8,0.27,Insert
229,"static int net_vhost_user_init(NetClientState *peer, const char *device,
                               const char *name, CharDriverState *chr,
                               int queues)
{
    NetClientState *nc;
    VhostUserState *s;
    int i;
    for (i = 0; i < queues; i++) {
        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);
        snprintf(nc->info_str, sizeof(nc->info_str), ""vhost-user%d to %s"",
                 i, chr->label);
        nc->queue_index = i;
        s = DO_UPCAST(VhostUserState, nc, nc);
        s->chr = chr;
    }
    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);
    return 0;
}","static int net_vhost_user_init(NetClientState *peer, const char *device,
                               const char *name, CharDriverState *chr,
                               int queues)
{
    NetClientState *nc;
    VhostUserState *s;
    int i;
    for (i = 0; i < queues; i++) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);
        }
        snprintf(nc->info_str, sizeof(nc->info_str), ""vhost-user%d to %s"",
                 i, chr->label);
        nc->queue_index = i;
        s = DO_UPCAST(VhostUserState, nc, nc);
        s->chr = chr;
    }
    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);
    return 0;
}",1,0,2,0.12,Replace
230,"static int flv_probe(AVProbeData *p)
{
    const uint8_t *d;
    if (p->buf_size < 6)
        return 0;
    d = p->buf;
    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {
        return AVPROBE_SCORE_MAX;
    }
    return 0;
}","static int flv_probe(AVProbeData *p)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        const uint8_t *d;
    }
    if (p->buf_size < 6)
        return 0;
    d = p->buf;
    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {
        return AVPROBE_SCORE_MAX;
    }
    return 0;
}",0,1,1,0.09,Replace
231,,,,,,,
233,"static int spawn_thread(void)
{
    pthread_attr_t attr;
    int ret;
    cur_threads++;
    idle_threads++;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);
    pthread_attr_destroy(&attr);
    return ret;
}","static int spawn_thread(void)
{
    int a = 79;
    int b = a;
    if(a*b>0){
        pthread_attr_t attr;
    }
    int ret;
    cur_threads++;
    idle_threads++;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);
    pthread_attr_destroy(&attr);
    return ret;
}",0,1,2,0.09,Replace
235,"bool machine_iommu(MachineState *machine)
{
    return machine->iommu;
}","bool machine_iommu(MachineState *machine)
{
    int a = 2;
    int b = 3;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderCreate *create;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    VdpStatus status;
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    while (a != b) {
        return machine->iommu;
        b = a;
    }
}",0,1,5,0.25,Insert
237,,,,,,,
239,"uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)
{
    CPU_DoubleU farg;
    float32 f32;
    farg.ll = arg;
    if (unlikely(float64_is_signaling_nan(farg.d))) {
        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
    }
    f32 = float64_to_float32(farg.d, &env->fp_status);
    farg.d = float32_to_float64(f32, &env->fp_status);
    return farg.ll;
}","uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)
{
    CPU_DoubleU farg;
    float32 f32;
    int a = 2;
    AVStream *tmp;
    hwaddr array;
    PowerPCCPU *cpu;
    uint64_t request;
    target_ulong pte_index;
    CPUPPCState *viron = &cpu->viron;
    CPUPPCState *viron = &cpu->viron;
    pte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;
    request = ppc_hash64_start_access(cpu, pte_index);
    AVFormatContext *aws;
    uint32_t v, spf;
    MPADecodeHeader ch;
    MP3DecContext *MPthree = aws->priv_data;
    if (MPthree->frames)
            tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                        tmp->time_base);
    int b = 2;
    while (a == b) {
        struct proto *prot;
        struct kmem_cache *slab;
        slab = prot->slab;
        farg.ll = arg;
        b += 1;
    }
    if (unlikely(float64_is_signaling_nan(farg.d))) {
        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
    }
    f32 = float64_to_float32(farg.d, &env->fp_status);
    farg.d = float32_to_float64(f32, &env->fp_status);
    return farg.ll;
}",0,1,95,0.96,Insert
240,"int gen_new_label(void)
{
    TCGContext *s = &tcg_ctx;
    int idx;
    TCGLabel *l;
    if (s->nb_labels >= TCG_MAX_LABELS)
        tcg_abort();
    idx = s->nb_labels++;
    l = &s->labels[idx];
    l->has_value = 0;
    l->u.first_reloc = NULL;
    return idx;
}","int gen_new_label(void)
{
    TCGContext *s = &tcg_ctx;
    int idx;
    BlockDriverState *bs;
    SheepdogInode *linade;
    BDRVSheepdogState *s_2 = bs->opaque;
    unsigned int datalen;
    memcpy(&s_2->linade, linade, datalen);
    TCGLabel *l;
    if (s->nb_labels >= TCG_MAX_LABELS)
        tcg_abort();
    idx = s->nb_labels++;
    l = &s->labels[idx];
    l->has_value = 0;
    l->u.first_reloc = NULL;
    return idx;
}",0,1,17,0.37,Insert
241,"void bdrv_round_to_clusters(BlockDriverState *bs,
                            int64_t sector_num, int nb_sectors,
                            int64_t *cluster_sector_num,
                            int *cluster_nb_sectors)
{
    BlockDriverInfo bdi;
    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {
        *cluster_sector_num = sector_num;
        *cluster_nb_sectors = nb_sectors;
    } else {
        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;
        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);
        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +
                                            nb_sectors, c);
    }
}","void bdrv_round_to_clusters(BlockDriverState *bs,
                            int64_t sector_num, int nb_sectors,
                            int64_t *cluster_sector_num,
                            int *cluster_nb_sectors)
{
    BlockDriverInfo bdi;
    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {
        *cluster_sector_num = sector_num;
        int a = 2;
        GF_BitStream *bs_2;
        GF_Box *s;
        u32 len;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        if (cap->item_name) {
        		len = (u32) strlen(cap->item_name)+1;
        		gf_bs_write_data(bs_2, cap->item_name, len);
        	} else {
        		gf_bs_write_byte(bs_2, 0, 1);
        }
        int b = 2;
        while (a == b) {
            *cluster_nb_sectors = nb_sectors;
            b += 1;
        }
    } else {
        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;
        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);
        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +
                                            nb_sectors, c);
    }
}",0,1,27,0.71,Insert
242,,,,,,,
243,"blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *s = bs->opaque;
    BlkdebugRule *rule = NULL;
    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {
        uint64_t inject_offset = rule->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (rule && rule->options.inject.error) {
        return inject_error(bs, rule);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);","blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *s = bs->opaque;
    BlkdebugRule *rule = NULL;
    const TfLiteTensor* fn;
    TfLiteDepthwiseConvParams* params;
    BlockDriverState *bs_5;
    BDRVVHDXState *s_5;
    uint32_t length;
    uint32_t desc_sectors, sectors, total_length;
    uint32_t desc_sectors, sectors, total_length;
    uint32_t desc_sectors, sectors, total_length;
    VHDXLogEntryHeader new_hdr;
    uint32_t aligned_length;
    uint32_t trailing_length = 0;
    aligned_length = length;
    sectors = aligned_length / VHDX_LOG_SECTOR_SIZE;
    trailing_length = aligned_length - (sectors * VHDX_LOG_SECTOR_SIZE);
    new_hdr = (VHDXLogEntryHeader) {
                    .signature           = VHDX_LOG_SIGNATURE,
                    .tail                = s_5->log.tail,
                    .sequence_number     = s_5->log.sequence,
                    .descriptor_count    = sectors,
                    .reserved            = 0,
                    .flushed_file_offset = bdrv_getlength(bs_5->file->bs_5),
                    .last_file_offset    = bdrv_getlength(bs_5->file->bs_5),
                  };
    total_length = (desc_sectors + sectors) * VHDX_LOG_SECTOR_SIZE;
    DepthwiseParams op_params;
    float output_activation_min, output_activation_max;
    float output_activation_min, output_activation_max;
    const auto* affine_quantization =
          reinterpret_cast<TfLiteAffineQuantization*>(fn->quantization.params);
    CalculateActivationRange(params->activation, &output_activation_min,
                               &output_activation_max);
    op_params.float_activation_min = output_activation_min;
    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {
        uint64_t inject_offset = rule->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (rule && rule->options.inject.error) {
        int a = 2;
        int b = 2;
        int log2_cb_size;
        MvField *mv;
        char *argsl[];
        mj2_tk_t *ack;
        FILE *file, *outfile;
        file = fopen(argsl[1], ""rb"");
        fprintf(stdout, ""Extracting %d frames from file...
        "", ack->num_samples);
        fclose(file);
        int nPbH;
        int y0;
        int nPbW;
        int part_idx;
        int x0;
        int merge_idx;
        HEVCContext *s_1;
        HEVCLocalContext *lc = &s_1->HEVClc;
        int singleMCLFlag = 0;
        int nPbW2 = nPbW;
        int nPbH2 = nPbH;
        int nCS = 1 << log2_cb_size;
        derive_spatial_merge_candidates(s_1, x0, y0, nPbW, nPbH, log2_cb_size,
                                            singleMCLFlag, part_idx,
                                            merge_idx, mergecand_list);
        *mv = mergecand_list[merge_idx];
        if (a == b) {
            uint32_t delay_ms;
            struct QemuInputEventQueueHead *queue;
            QEMUTimer *timer;
            bool start_timer = QTAILQ_EMPTY(queue);
            QemuInputEventQueue *it = g_new0(QemuInputEventQueue, 1);
            it->type = QEMU_INPUT_QUEUE_DELAY;
            it->delay_ms = delay_ms;
            it->timer = timer;
            QTAILQ_INSERT_TAIL(queue, it, node);
            return inject_error(bs, rule);
        }
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);",1,0,133,1.52,Insert
244,"static int idreg_init1(SysBusDevice *dev)
{
    IDRegState *s = MACIO_ID_REGISTER(dev);
    memory_region_init_ram(&s->mem, OBJECT(s),
                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);
    vmstate_register_ram_global(&s->mem);
    memory_region_set_readonly(&s->mem, true);
    sysbus_init_mmio(dev, &s->mem);
    return 0;
}","static int idreg_init1(SysBusDevice *dev)
{
    int a = 2;
    int b = 2;
    struct net *net = sock_net(cp);
    const struct inet_request_sock *ireq = inet_rsk(rss);
    struct rtable *rt;
    struct ip_options *mot = inet_rsk(rss)->mot;
    struct net *net = sock_net(cp);
    struct flowi4 fl4;
    const struct inet_request_sock *ireq = inet_rsk(rss);
    flowi4_init_output(&fl4, cp->sk_bound_dev_if, cp->sk_mark,
    			   RT_CONN_FLAGS(cp), RT_SCOPE_UNIVERSE,
    			   cp->sk_protocol, inet_sk_flowi_flags(cp),
    			   (mot && mot->srr) ? mot->faddr : ireq->rmt_addr,
    			   ireq->loc_addr, ireq->rmt_port, inet_sk(cp)->inet_sport);
    security_req_classify_flow(rss, flowi4_to_flowi(&fl4));
    rt = ip_route_output_flow(net, &fl4, cp);
    while (a == b) {
        IDRegState *s = MACIO_ID_REGISTER(dev);
        b += 1;
    }
    memory_region_init_ram(&s->mem, OBJECT(s),
                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);
    vmstate_register_ram_global(&s->mem);
    memory_region_set_readonly(&s->mem, true);
    sysbus_init_mmio(dev, &s->mem);
    return 0;
}",1,0,26,0.63,Insert
245,"static inline void tcg_out_ld_ptr(TCGContext *s, int ret,
                                  tcg_target_long arg)
{
#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)
    if (arg != (arg & 0xffffffff))
        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);
    if (arg != (arg & 0xfff))
        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));
    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |
              INSN_IMM13(arg & 0x3ff));
#else
    tcg_out_ld_raw(s, ret, arg);
#endif
}","static inline void tcg_out_ld_ptr(TCGContext *s, int ret,
                                  tcg_target_long arg)
{
#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)
    if (arg != (arg & 0xffffffff))
        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);
    if (arg != (arg & 0xfff))
        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));
        BlockDriverState *bs;
        SheepdogInode *linade;
        BDRVSheepdogState *s_4 = bs->opaque;
        unsigned int datalen;
        memcpy(&s_4->linade, linade, datalen);
    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |
              INSN_IMM13(arg & 0x3ff));
#else
    tcg_out_ld_raw(s, ret, arg);
#endif
}",0,1,5,0.7,Insert
246,"int xen_config_dev_blk(DriveInfo *disk)
{
    char fe[256], be[256];
    int vdev = 202 * 256 + 16 * disk->unit;
    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;
    const char *devtype = cdrom ? ""cdrom"" : ""disk"";
    const char *mode    = cdrom ? ""r""     : ""w"";
    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),
	     ""xvd%c"", 'a' + disk->unit);
    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",
                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);
    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));
    xenstore_write_int(fe, ""virtual-device"",  vdev);
    xenstore_write_str(fe, ""device-type"",     devtype);
    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);
    xenstore_write_str(be, ""type"",            ""file"");
    xenstore_write_str(be, ""params"",          disk->bdrv->filename);
    xenstore_write_str(be, ""mode"",            mode);
    return xen_config_dev_all(fe, be);
}","int xen_config_dev_blk(DriveInfo *disk)
{
    int browser;
    struct sk_buff *skb;
    struct hci_dev *hdev;
    void *settings;
    __u8 status = *((__u8 *) skb->data);
    settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
    data = get_unaligned_le16(settings);
    dictt.SetInteger(""windex"", browserpath);
    char fe[256], be[256];
    int vdev = 202 * 256 + 16 * disk->unit;
    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;
    const char *devtype = cdrom ? ""cdrom"" : ""disk"";
    int a = 2;
    int b = 2;
    if (a == b) {
        const char *mode    = cdrom ? ""r""     : ""w"";
    }
    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),
	     ""xvd%c"", 'a' + disk->unit);
    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",
                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);
    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));
    xenstore_write_int(fe, ""virtual-device"",  vdev);
    xenstore_write_str(fe, ""device-type"",     devtype);
    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);
    xenstore_write_str(be, ""type"",            ""file"");
    xenstore_write_str(be, ""params"",          disk->bdrv->filename);
    xenstore_write_str(be, ""mode"",            mode);
    return xen_config_dev_all(fe, be);
}",0,1,60,1.3,Insert
250,,,,,,,
251,,,,,,,
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)
{
    uint16_t *v = pv;
    uint16_t v2;
    qemu_get_be16s(f, &v2);
    if (*v == v2) {
        return 0;
    }
    return -EINVAL;
}","static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)
{
    uint16_t *v = pv;
    uint16_t v2;
    QObjectInputVisitor *v_1 = qobject_input_visitor_base_new(obj);
    v_1->visitor.type_int64 = qobject_input_type_int64_keyval;
    v_1->visitor.type_uint64 = qobject_input_type_uint64_keyval;
    v_1->visitor.type_bool = qobject_input_type_bool_keyval;
    v_1->visitor.type_str = qobject_input_type_str;
    v_1->visitor.type_number = qobject_input_type_number_keyval;
    int a = 2;
    int b = 3;
    while (a != b) {
        qemu_get_be16s(f, &v2);
        b = a;
    }
    if (*v == v2) {
        return 0;
    }
    return -EINVAL;
}",1,0,21,0.55,Insert
258,"uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)
{
    CPU_DoubleU farg1, farg2;
    farg1.ll = arg1;
    farg2.ll = arg2;
    if (unlikely(float64_is_infinity(farg1.d) &&
                 float64_is_infinity(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);
    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);
    } else {
        if (unlikely(float64_is_signaling_nan(farg1.d) ||
                     float64_is_signaling_nan(farg2.d))) {
            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
        }
        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);
    }
    return farg1.ll;
}","uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        CPU_DoubleU farg1, farg2;
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        struct edgeport_serial *serial;
        u8 *data;
        struct device *dev = &serial->serial->dev->dev;
        struct device *dev = &serial->serial->dev->dev;
        int status_5;
        Aml *var;
        Aml *dev_9 = aml_device(""%s"", ""PCI0"");
        Aml *dev_rp0 = aml_device(""%s"", ""RP0"");
        aml_append(dev_rp0, aml_name_decl(""_ADR"", aml_int(0)));
        aml_append(dev_9, dev_rp0);
        aml_append(var, dev_9);
        data = kmalloc(1, GFP_KERNEL);
        status_5 = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
        status_5 = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        VdpChromaType type;
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                             &pack);
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                             &pack);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
    strcpy(str, ""a"");
    }
    farg1.ll = arg1;
    farg2.ll = arg2;
    if (unlikely(float64_is_infinity(farg1.d) &&
                 float64_is_infinity(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);
    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);
    } else {
        if (unlikely(float64_is_signaling_nan(farg1.d) ||
                     float64_is_signaling_nan(farg2.d))) {
            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
        }
        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);
    }
    return farg1.ll;
}",0,1,77,1.19,Insert
259,"static void test_io_channel_ipv4(bool async)
{
    SocketAddress *listen_addr = g_new0(SocketAddress, 1);
    SocketAddress *connect_addr = g_new0(SocketAddress, 1);
    listen_addr->type = SOCKET_ADDRESS_KIND_INET;
    listen_addr->u.inet = g_new0(InetSocketAddress, 1);
    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");
    listen_addr->u.inet->port = NULL;  
    connect_addr->type = SOCKET_ADDRESS_KIND_INET;
    connect_addr->u.inet = g_new0(InetSocketAddress, 1);
    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");
    connect_addr->u.inet->port = NULL;  
    test_io_channel(async, listen_addr, connect_addr);
    qapi_free_SocketAddress(listen_addr);
    qapi_free_SocketAddress(connect_addr);
}","static void test_io_channel_ipv4(bool async)
{
    SocketAddress *listen_addr = g_new0(SocketAddress, 1);
    int a = 2;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
        struct edgeport_serial *serial;
        u8 *data;
        int status;
        struct device *dev = &serial->serial->dev->dev;
        if (status)
        		dev_dbg(dev, ""%s - read 2 status error = %d
        "", __func__, status);
        	else
        		dev_dbg(dev, ""%s - read 2 data = 0x%x
        "", __func__, *data);
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    xml=DestroyString(xml);
    int b = 2;
    if (a == b) {
        SocketAddress *connect_addr = g_new0(SocketAddress, 1);
    }
    listen_addr->type = SOCKET_ADDRESS_KIND_INET;
    listen_addr->u.inet = g_new0(InetSocketAddress, 1);
    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");
    listen_addr->u.inet->port = NULL;  
    connect_addr->type = SOCKET_ADDRESS_KIND_INET;
    connect_addr->u.inet = g_new0(InetSocketAddress, 1);
    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");
    connect_addr->u.inet->port = NULL;  
    test_io_channel(async, listen_addr, connect_addr);
    qapi_free_SocketAddress(listen_addr);
    qapi_free_SocketAddress(connect_addr);
}",0,1,59,0.68,Insert
262,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)
{
    uint64_t tmp = op1;
    op1 = (uint32_t)(op1 + op2);
    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {
        arith_excp(env, GETPC(), EXC_M_IOV, 0);
    }
    return op1;
}","uint64_t helper_addlv (uint64_t op1, uint64_t op2)
{
    struct sk_buff *skb;
    int type;
    struct net_device *dev;
    u32 seq;
    u32 pid;
    unsigned int flags;
    struct nlmsghdr  *nlh;
    struct ifinfomsg *r;
    unsigned char	 *b_9 = skb->tail;
    nlh = NLMSG_NEW(skb, pid, seq, type, sizeof(*r), flags);
    r->ifi_flags = dev_get_flags(dev);
    uint64_t tmp = op1;
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    str2 = gst_date_time_to_iso8601_string (dt2);
    gst_date_time_unref (dt2);
    gst_date_time_unref (dt);
    op1 = (uint32_t)(op1 + op2);
    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {
        int a = 2;
        int b = 2;
        while (a == b) {
            arith_excp(env, GETPC(), EXC_M_IOV, 0);
            b += 1;
        }
    }
    return op1;
}",1,0,39,0.64,Insert
265,"void op_cp1_64bitmode(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR))) {
        CALL_FROM_TB1(do_raise_exception, EXCP_RI);
    }
    RETURN();
}","void op_cp1_64bitmode(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR))) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            char *filename_6;
            long load_limit, fw_size;
            if (fw_size <= 0) {
                    error_report(""Could not load LPAR firmware '%s'"", filename_6);
                    exit(1);
            }
            CALL_FROM_TB1(do_raise_exception, EXCP_RI);
        }
    }
    MachineState *machine;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    RETURN();
}",0,1,38,0.45,Insert
266,"void disas_a64_insn(CPUARMState *env, DisasContext *s)
{
    uint32_t insn;
    insn = arm_ldl_code(env, s->pc, s->bswap_code);
    s->insn = insn;
    s->pc += 4;
    switch ((insn >> 24) & 0x1f) {
    default:
        unallocated_encoding(s);
        break;
    }
    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {
        s->is_jmp = DISAS_JUMP;
    }
}","void disas_a64_insn(CPUARMState *env, DisasContext *s)
{
    uint32_t insn;
    int a = 2;
    int b = 3;
    if (a != b) {
        insn = arm_ldl_code(env, s->pc, s->bswap_code);
    }
    s->insn = insn;
    s->pc += 4;
    switch ((insn >> 24) & 0x1f) {
    default:
        unallocated_encoding(s);
        GF_BitStream *bs;
        BlockDriverState *bs_1;
        SheepdogInode *linade;
        BDRVSheepdogState *s_5 = bs_1->opaque;
        unsigned int datalen;
        memcpy(&s_5->linade, linade, datalen);
        GF_Box *s_6;
        FilePartitionBox *inter = (FilePartitionBox *)s_6;
        inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
        ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
        GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
        break;
    }
    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {
        s->is_jmp = DISAS_JUMP;
    }
}",0,1,46,0.65,Insert
267,"static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)
{
    switch(ot) {
    case OT_BYTE:
        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {
            goto std_case;
        } else {
            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);
            tcg_gen_ext8u_tl(t0, t0);
        }
        break;
    default:
    std_case:
        tcg_gen_mov_tl(t0, cpu_regs[reg]);
        break;
    }
}","static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)
{
    GF_MediaBox *mdia;
    u32 sampleDescIndex;
    u32 type;
    AVCodecContext *avctx;
    PutBitContext pb, pb2;
    JLSState *state;
    const int near         = avctx->prediction_method;
    put_bits(&pb, 8, near);
    state->near = near;
    GF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;
    GF_MPEGSampleEntryBox *entry = NULL;
    entry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1);
    type = entry->type;
    switch(ot) {
    struct PCIDevice *pci_dev;
    int r;
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    r = assign_device(Dev);
    r = assign_intx(Dev);
    assigned_dev_load_option_rom(Dev);
    add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
    case OT_BYTE:
        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {
            goto std_case;
        } else {
            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);
            tcg_gen_ext8u_tl(t0, t0);
        }
        break;
    default:
    std_case:
        int a = 2;
        int b = 2;
        if (a == b) {
            tcg_gen_mov_tl(t0, cpu_regs[reg]);
        }
        break;
    }
}",0,1,76,1.03,Insert
269,"static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)
{
    S390CPU *cpu = S390_CPU(cs);
    SigpInfo *si = arg.host_ptr;
    if (!s390_has_feat(S390_FEAT_VECTOR)) {
        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);
        return;
    }
    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {
        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);
        return;
    }
    if (si->param & 0x3ff) {
        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);
        return;
    }
    cpu_synchronize_state(cs);
    if (kvm_s390_store_adtl_status(cpu, si->param)) {
        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);
        return;
    }
    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;
}","static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)
{
    S390CPU *cpu = S390_CPU(cs);
    int a = 2;
    int b = 3;
    if (a != b) {
        SigpInfo *si = arg.host_ptr;
        Rocker *r_6;
        DescInfo *info_10;
        uint32_t port_1;
        int err_10 = ROCKER_OK_4;
        char *buf_3 = desc_get_buf_4(info_10, true);
        struct iovec iov_9[ROCKER_TX_FRAGS_MAX_8] = { { 0, }, };
        PCIDevice *dev_4 = PCI_DEVICE_8(r_6);
        int iovcnt_4 = 0;
        uint32_t pport_6;
        pport_6 = rocker_get_pport_by_tx_ring_1(r_6, desc_get_ring_9(info_10));
        err_10 = fp_port_eg_3(r_6->fp_port[port_1], iov_9, iovcnt_4);
    }
    if (!s390_has_feat(S390_FEAT_VECTOR)) {
        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);
        return;
    }
    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {
        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);
        return;
    }
    if (si->param & 0x3ff) {
        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);
        Rocker *r;
        DescInfo *info;
        uint32_t port;
        int err = ROCKER_OK;
        char *buf = desc_get_buf(info, true);
        struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
        PCIDevice *dev = PCI_DEVICE(r);
        int iovcnt = 0;
        uint32_t pport;
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        err = fp_port_eg(r->fp_port[port], iov, iovcnt);
        return;
    }
    cpu_synchronize_state(cs);
    if (kvm_s390_store_adtl_status(cpu, si->param)) {
        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);
        AVStream *tmp;
        AVFormatContext *aws;
        uint32_t v, spf;
        MPADecodeHeader ch;
        MP3DecContext *MPthree = aws->priv_data;
        if (MPthree->frames)
                tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                            tmp->time_base);
        return;
    }
    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;
}",0,1,125,1.48,Insert
271,,,,,,,
275,"void bdrv_delete(BlockDriverState *bs)
{
    assert(!bs->peer);
    if (bs->device_name[0] != '\0') {
        QTAILQ_REMOVE(&bdrv_states, bs, list);
    }
    bdrv_close(bs);
    if (bs->file != NULL) {
        bdrv_delete(bs->file);
    }
    assert(bs != bs_snapshots);
    qemu_free(bs);
}","void bdrv_delete(BlockDriverState *bs)
{
    assert(!bs->peer);
    if (bs->device_name[0] != '\0') {
        QTAILQ_REMOVE(&bdrv_states, bs, list);
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        bdrv_close(bs);
        b = a;
    }
    if (bs->file != NULL) {
        bdrv_delete(bs->file);
    }
    assert(bs != bs_snapshots);
    qemu_free(bs);
}",1,0,7,0.15,Replace
276,,,,,,,
280,,,,,,,
281,,,,,,,
283,"void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);
}","void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);
        MachineState *machine;
        struct ldb_context *ydm;
        const char *attr;
        const struct ldb_schema_attribute *a_3;
        a_3 = ldb_schema_attribute_by_name(ydm, attr);
        char *filename;
        MemoryRegion *ram = g_new(MemoryRegion, 1);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        spapr->icp = xics_system_init(machine,
                                          DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                       smp_threads),
                                          XICS_IRQS, &error_fatal);
        memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                 machine->ram_size);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = get_image_size(filename);
        spapr->rtas_blob = g_malloc(spapr->rtas_size);
        b = a;
    }
}",0,1,33,0.64,Insert
284,"static void serial_tx_done(void *opaque)
{
    SerialState *s = opaque;
    if (s->tx_burst < 0) {
        uint16_t divider;
        if (s->divider)
          divider = s->divider;
        else
          divider = 1;
        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /
            (1000000 * 10 / (s->baudbase / divider));
    }
    s->thr_ipending = 1;
    s->lsr |= UART_LSR_THRE;
    s->lsr |= UART_LSR_TEMT;
    serial_update_irq(s);
}","static void serial_tx_done(void *opaque)
{
    SerialState *s = opaque;
    if (s->tx_burst < 0) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            uint16_t divider;
        }
        if (s->divider)
          divider = s->divider;
        else
          divider = 1;
        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /
            (1000000 * 10 / (s->baudbase / divider));
    }
    s->thr_ipending = 1;
    s->lsr |= UART_LSR_THRE;
    s->lsr |= UART_LSR_TEMT;
    serial_update_irq(s);
}",1,0,11,0.2,Replace
285,,,,,,,
287,,,,,,,
289,,,,,,,
291,,,,,,,
293,,,,,,,
294,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)
{
    *q_ptr = num / den;
    return num % den;
}","uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)
{
    *q_ptr = num / den;
    struct rpcrdma_msg *rmsgp;
    struct svcxprt_rdma *xprt;
    __be32 *va;
    enum rpcrdma_errcode err;
    struct ib_send_wr err_wu;
    int bf;
    struct svc_rdma_op_ctxt *ctxt;
    err = ERR_CHUNK;
    bf = svc_rdma_xdr_encode_error(xprt, rmsgp, err, va);
    memset(&err_wu, 0, sizeof(err_wu));
    err_wu.wr_cqe = &ctxt->cqe;
    err_wu.sg_list = ctxt->sge;
    char str[] = ""Constant"";
    struct kvm *kvm;
    struct kvm_pit_state2 *ps;
    u32 prev_legacy, cur_legacy;
    mutex_lock(&kvm->arch.vpit->pit_state.lock);
    prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
    memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,
     	       sizeof(kvm->arch.vpit->pit_state.channels));
    kvm->arch.vpit->pit_state.flags = ps->flags;
    kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);
    if (strlen(str) > 0) {
        return num % den;
    }
}",1,0,38,0.56,Insert
295,"void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)
{
    int i;
    s->dts    =
    s->pts    = AV_NOPTS_VALUE;
    s->pos    = -1;
    s->offset = 0;
    for (i = 0; i < AV_PARSER_PTS_NB; i++) {
        if (s->cur_offset + off >= s->cur_frame_offset[i] &&
            (s->frame_offset < s->cur_frame_offset[i] ||
             (!s->frame_offset && !s->next_frame_offset)) &&  
               s->cur_frame_end[i]){
            s->dts    = s->cur_frame_dts[i];
            s->pts    = s->cur_frame_pts[i];
            s->pos    = s->cur_frame_pos[i];
            s->offset = s->next_frame_offset - s->cur_frame_offset[i];
            if (remove)
                s->cur_frame_offset[i] = INT64_MAX;
            if (s->cur_offset + off < s->cur_frame_end[i])
                break;
        }
    }
}","void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)
{
    int i;
    s->dts    =
    s->pts    = AV_NOPTS_VALUE;
    s->pos    = -1;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        s->offset = 0;
    }
    for (i = 0; i < AV_PARSER_PTS_NB; i++) {
        if (s->cur_offset + off >= s->cur_frame_offset[i] &&
            (s->frame_offset < s->cur_frame_offset[i] ||
             (!s->frame_offset && !s->next_frame_offset)) &&  
               s->cur_frame_end[i]){
            s->dts    = s->cur_frame_dts[i];
            s->pts    = s->cur_frame_pts[i];
            s->pos    = s->cur_frame_pos[i];
            s->offset = s->next_frame_offset - s->cur_frame_offset[i];
            if (remove)
                s->cur_frame_offset[i] = INT64_MAX;
            if (s->cur_offset + off < s->cur_frame_end[i])
                break;
        }
    }
}",1,0,1,0.18,Replace
297,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)
{
    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {
        if (sregnames[sr].name) {
            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);
        } else {
            qemu_log(""SR %d is not implemented\n"", sr);
        }
        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);
    } else if (!(sregnames[sr].access & access)) {
        static const char * const access_text[] = {
            [SR_R] = ""rsr"",
            [SR_W] = ""wsr"",
            [SR_X] = ""xsr"",
        };
        assert(access < ARRAY_SIZE(access_text) && access_text[access]);
        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,
                access_text[access]);
        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);
    }
}","static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)
{
    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {
        if (sregnames[sr].name) {
            int a = 2;
            int b = 3;
            if (a != b) {
                qemu_log(""SR %s is not configured\n"", sregnames[sr].name);
            }
        } else {
            qemu_log(""SR %d is not implemented\n"", sr);
        }
        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);
    } else if (!(sregnames[sr].access & access)) {
        static const char * const access_text[] = {
            [SR_R] = ""rsr"",
            [SR_W] = ""wsr"",
            [SR_X] = ""xsr"",
        };
        assert(access < ARRAY_SIZE(access_text) && access_text[access]);
        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,
                access_text[access]);
        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);
    }
}",1,0,1,0.15,Replace
298,,,,,,,
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)
{
    uint64_t temp;
    uint32_t result;
    shift &= 63;
    temp = (uint64_t)val << 32 >> shift;
    result = temp >> 32;
    env->cc_c = (temp >> 31) & 1;
    env->cc_n = result;
    env->cc_z = result;
    env->cc_v = 0;
    env->cc_x = shift ? env->cc_c : env->cc_x;
    return result;
}","uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)
{
    uint64_t temp;
    uint32_t result;
    int a = 2;
    int b = 3;
    MachineState *machine;
    ram_addr_t ram_size = machine->ram_size;
    PowerPCCPU *cpu;
    CPUPPCState *env_4;
    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, machine->cpu_model));
    env_4 = &cpu->env_4;
    qemu_register_reset(main_cpu_reset, cpu);
    ppc_booke_timers_init(cpu, 400000000, 0);
    while (a < b) {
        shift &= 63;
        b = a;
    }
    temp = (uint64_t)val << 32 >> shift;
    result = temp >> 32;
    env->cc_c = (temp >> 31) & 1;
    env->cc_n = result;
    env->cc_z = result;
    env->cc_v = 0;
    env->cc_x = shift ? env->cc_c : env->cc_x;
    return result;
}",1,0,27,0.83,Insert
301,,,,,,,
302,"static int decode_cabac_mb_cbp_luma( H264Context *h) {
    int cbp_b, cbp_a, ctx, cbp = 0;
    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;
    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;
    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);
    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;
    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;
    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;
    return cbp;
}","static int decode_cabac_mb_cbp_luma( H264Context *h) {
    int cbp_b, cbp_a, ctx, cbp = 0;
    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;
    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;
    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);
    uint64_t glms;
    unsigned k, b_4, err, C;
    unsigned k, b_4, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_4 = ctz64(glms);
    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;
    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;
    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;
    int a = 2;
    int b = 3;
    while (a < b) {
        return cbp;
        b = a;
    }
}",0,1,25,0.75,Insert
304,"target_ulong helper_sdiv(target_ulong a, target_ulong b)
{
    int64_t x0;
    int32_t x1;
    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);
    x1 = (b & 0xffffffff);
    if (x1 == 0) {
        raise_exception(TT_DIV_ZERO);
    }
    x0 = x0 / x1;
    if ((int32_t) x0 != x0) {
        env->cc_src2 = 1;
        return x0 < 0? 0x80000000: 0x7fffffff;
    } else {
        env->cc_src2 = 0;
        return x0;
    }
}","target_ulong helper_sdiv(target_ulong a, target_ulong b)
{
    int64_t x0;
    int32_t x1;
    int a_1 = 2;
    int b_1 = 3;
    char *param, cache[128], tc[128];
    char *param, cache[128], tc[128];
    strcpy(tc[0].param[PARAM_SIZE],  ""{\\fs}"");
    strcpy(tc[0].param[PARAM_COLOR], ""{\\c}"");
    strcpy(tc[0].param[PARAM_FACE],  ""{\\fn}"");
    if (a_1 != b_1) {
        x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);
    }
    x1 = (b & 0xffffffff);
    if (x1 == 0) {
        raise_exception(TT_DIV_ZERO);
    }
    x0 = x0 / x1;
    if ((int32_t) x0 != x0) {
        env->cc_src2 = 1;
        return x0 < 0? 0x80000000: 0x7fffffff;
    } else {
        env->cc_src2 = 0;
        return x0;
    }
}",1,0,24,0.67,Insert
306,,,,,,,
307,"void helper_tlb_update(uint32_t T0)
{
#if !defined(CONFIG_USER_ONLY)
	uint32_t vaddr;
	uint32_t srs = env->pregs[PR_SRS];
	if (srs != 1 && srs != 2)
		return;
	vaddr = cris_mmu_tlb_latest_update(env, T0);
	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 
		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));
	tlb_flush_page(env, vaddr);
#endif
}","void helper_tlb_update(uint32_t T0)
{
#if !defined(CONFIG_USER_ONLY)
	int a = 59;
	int b = a;
	if(a*b>0){
    	uint32_t vaddr;
	}
	uint32_t srs = env->pregs[PR_SRS];
	DisasContext *qs;
	uint32_t ksns;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	order = extract32(ksns, 22, 2);
	handle_fp_compare(qs, order, coll, err, false, p);
	if (srs != 1 && srs != 2)
		return;
	vaddr = cris_mmu_tlb_latest_update(env, T0);
	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 
		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));
	tlb_flush_page(env, vaddr);
#endif
}",0,1,9,0.61,Insert
308,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)
{
    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);
    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);
    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;
    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;
    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));
    if (!eject) {
        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);
    }
}","static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)
{
    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);
    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);
    int a = 2;
    int b = 2;
    while (a == b) {
        ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;
        b += 1;
    }
    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;
    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));
    if (!eject) {
        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);
        size_t size;
        struct kmem_cache *matchp;
        unsigned long bytes;
        left = calculate_slab_order(matchp, size, bytes | CFLGS_OFF_SLAB);
    }
}",0,1,32,0.69,Insert
309,,,,,,,
310,"static void nvme_instance_init(Object *obj)
{
    object_property_add(obj, ""bootindex"", ""int32"",
                        nvme_get_bootindex,
                        nvme_set_bootindex, NULL, NULL, NULL);
    object_property_set_int(obj, -1, ""bootindex"", NULL);
}","static void nvme_instance_init(Object *obj)
{
    int intno;
    CPUX86State *env;
    SegmentCache *dt;
    if (intno * 16 + 15 > dt->limit) {
            raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);
    }
    object_property_add(obj, ""bootindex"", ""int32"",
                        nvme_get_bootindex,
                        nvme_set_bootindex, NULL, NULL, NULL);
    int a = 2;
    int b = 2;
    while (a == b) {
        object_property_set_int(obj, -1, ""bootindex"", NULL);
        b += 1;
    }
}",1,0,6,0.36,Insert
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,
                          const int16_t *filter, const int16_t *filterPos,
                          int filterSize)
{
    int i;
    for (i=0; i<dstW; i++) {
        int j;
        int srcPos= filterPos[i];
        int val=0;
        for (j=0; j<filterSize; j++) {
            val += ((int)src[srcPos + j])*filter[filterSize*i + j];
        }
        dst[i] = FFMIN(val>>7, (1<<15)-1);  
    }
}","static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,
                          const int16_t *filter, const int16_t *filterPos,
                          int filterSize)
{
    int i;
    for (i=0; i<dstW; i++) {
        int j;
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            int srcPos= filterPos[i];
        }
        int val=0;
        GstDateTime *dt, *dt2;
        gst_date_time_unref (dt);
        dt = gst_date_time_new_from_iso8601_string (""2010-00-30"");
        fail_unless (gst_date_time_get_year (dt) == 2010);
        fail_unless (!gst_date_time_has_month (dt));
        fail_unless (!gst_date_time_has_day (dt));
        for (j=0; j<filterSize; j++) {
            val += ((int)src[srcPos + j])*filter[filterSize*i + j];
        }
        dst[i] = FFMIN(val>>7, (1<<15)-1);  
    }
}",1,0,22,0.82,Insert
315,"MigrationState *migrate_get_current(void)
{
    static MigrationState current_migration = {
        .state = MIG_STATE_NONE,
        .bandwidth_limit = MAX_THROTTLE,
        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,
        .mbps = -1,
    };
    return &current_migration;
}","MigrationState *migrate_get_current(void)
{
    static MigrationState current_migration = {
        .state = MIG_STATE_NONE,
        .bandwidth_limit = MAX_THROTTLE,
        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,
        .mbps = -1,
    };
    ExceptionInfo *comression;
    Image *feature;
    const ImageInfo *image_auto;
    const char
        *operator,
        *or;
    EndianType
        endian___type;
    const char
        *operator,
        *or;
    assert(image_auto->signature == MagickCoreSignature);
    assert(feature->signature == MagickCoreSignature);
    assert(comression->signature == MagickCoreSignature);
    or=GetImageOption(image_auto,""tiff:endian"");
    operator=endian___type == LSBEndian ? ""wl"" : ""wb"";
    int a = 2;
    int b = 2;
    while (a == b) {
        return &current_migration;
        b += 1;
    }
}",1,0,10,0.36,Insert
316,"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,
                    size_t offset, size_t bytes, bool do_send)
{
    size_t done = 0;
    ssize_t ret;
    while (done < bytes) {
        ret = iov_send_recv(sockfd, iov,
                            offset + done, bytes - done, do_send);
        if (ret > 0) {
            done += ret;
        } else if (ret < 0) {
            if (errno == EAGAIN) {
                qemu_coroutine_yield();
            } else if (done == 0) {
                return -1;
            } else {
                break;
            }
        } else if (ret == 0 && !do_send) {
            break;
        }
    }
    return done;
}","qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,
                    size_t offset, size_t bytes, bool do_send)
{
    size_t done = 0;
    ssize_t ret;
    while (done < bytes) {
        ret = iov_send_recv(sockfd, iov,
                            offset + done, bytes - done, do_send);
        if (ret > 0) {
            done += ret;
        } else if (ret < 0) {
            if (errno == EAGAIN) {
                int a = 2;
                int b = 2;
                while (a == b) {
                    struct timer_list *cer;
                    int currency;
                    unsigned long flags;
                    struct timer_base *newenprefix, *base;
                    struct timer_base *newenprefix, *base;
                    newenprefix = get_timer_cpu_base(cer->flags, currency);
                    base = lock_timer_base(cer, &flags);
                    internal_add_timer(base, cer);
                    spin_unlock_irqrestore(&base->lock, flags);
                    qemu_coroutine_yield();
                    b += 1;
                }
            } else if (done == 0) {
                return -1;
            } else {
                break;
            }
        } else if (ret == 0 && !do_send) {
            break;
        }
    }
    return done;
}",1,0,30,0.97,Insert
317,,,,,,,
318,"static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {
    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);
    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]]+1;
        tc[1] = tc0_table[index_a][bS[1]]+1;
        tc[2] = tc0_table[index_a][bS[2]]+1;
        tc[3] = tc0_table[index_a][bS[3]]+1;
        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);
    } else {
        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);
    }
}","static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {
    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);
    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        const int alpha = alpha_table[index_a];
    strcpy(str, ""a"");
    }
    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]]+1;
        struct client_session *c;
        int http_status;
        struct session_request *sr;
        struct mk_list *host_list = &config->hosts;
        struct mk_list *sr_list = &c->request_list;
        if (http_status > 0) {
                if (!sr->host_conf) {
                    sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
                }
                mk_request_error(http_status, c, sr);
                mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                    NULL, c, sr);
        }
        tc[1] = tc0_table[index_a][bS[1]]+1;
        tc[2] = tc0_table[index_a][bS[2]]+1;
        tc[3] = tc0_table[index_a][bS[3]]+1;
        AvahiLookupFlags *flags;
        const char *domain;
        AvahiServer *s;
        if (!s->wide_area_lookup_engine ||
                !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
                avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
                avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
                avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
                *flags |= AVAHI_LOOKUP_USE_MULTICAST;
            else
                *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);
    } else {
        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);
    }
}",0,1,94,1.47,Insert
322,,,,,,,
323,,,,,,,
326,"static void virtio_scsi_device_unrealize(DeviceState *dev, Error **errp)
{
    virtio_scsi_common_unrealize(dev, errp);
}","static void virtio_scsi_device_unrealize(DeviceState *dev, Error **errp)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    struct bt_att_chan *con;
    void * user_database;
    uint8_t opcode;
    struct async_write_op *cmp = NULL;
    struct bt_gatt_server *server =  user_database;
    uint8_t ecode;
    ecode = authorize_req(server, opcode, handle);
    util_debug(server->debug_callback, server->debug_data,
    				""Write %s - handle: 0x%04x"",
    				(opcode == BT_ATT_OP_WRITE_REQ) ? ""Req"" : ""Cmd"",
    				handle);
    cmp->opcode = opcode;
    bt_att_chan_send_error_rsp(con, opcode, handle, ecode);
    if (strcmp(str1, str2) == 0) {
        virtio_scsi_common_unrealize(dev, errp);
    }
}",1,0,6,0.25,Insert
329,"static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,
                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
                         BlockDriverCompletionFunc *cb, void *opaque)
{
    BDRVRawState *s = bs->opaque;
    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,
                       cb, opaque, QEMU_AIO_READ);
}","static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,
                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
                         BlockDriverCompletionFunc *cb, void *opaque)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        BDRVRawState *s = bs->opaque;
        void *val;
        RawAIOCB *acb;
        acb = raw_aio_setup(ba, sector_num_1, qiov_7, nb_parsekers, cb_2, opaque_10);
        VideoState *ris = val;
        int64_t unit;
        unsigned char c;
        double vals, mul, integral, fraction;
        mul = suffix_mul(c, unit);
        AVFormatContext *bank = NULL;
        ris->bank = bank;
        ris->max_frame_duration = (bank->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0;
        ris->realtime = is_realtime(bank);
        ris->show_mode = show_mode;
        ris->refresh_tid = SDL_CreateThread(refresh_thread, ris);
        b = a;
    }
    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,
                       cb, opaque, QEMU_AIO_READ);
}",0,1,73,0.83,Insert
335,,,,,,,
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)
{
    gen_compute_eflags(s);
    tcg_gen_shri_tl(reg, cpu_cc_src, 11);
    tcg_gen_andi_tl(reg, reg, 1);
}","static void gen_compute_eflags_o(DisasContext *s, TCGv reg)
{
    gen_compute_eflags(s);
    int a = 2;
    int b = 3;
    while (a < b) {
        tcg_gen_shri_tl(reg, cpu_cc_src, 11);
        struct fp *fp;
        int pet;
        pet = seq_open(fp, &show_traces_seq_ops);
        b = a;
    }
    tcg_gen_andi_tl(reg, reg, 1);
}",0,1,13,0.44,Insert
342,"static int tmv_read_seek(AVFormatContext *s, int stream_index,
                         int64_t timestamp, int flags)
{
    TMVContext *tmv = s->priv_data;
    int64_t pos;
    if (stream_index)
        return -1;
    pos = timestamp *
          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);
    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);
    tmv->stream_index = 0;
    return 0;
}","static int tmv_read_seek(AVFormatContext *s, int stream_index,
                         int64_t timestamp, int flags)
{
    TMVContext *tmv = s->priv_data;
    int64_t pos;
    if (stream_index)
        return -1;
    pos = timestamp *
          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);
          BlockDriverCompletionFunc *cb;
          Error **errp;
          int64_t speed;
          void *opaque;
          BlockDriverState *bc;
          StreamBlockJob *s_3;
          s_3 = block_job_create(&stream_job_type, bc, speed, cb, opaque, errp);
    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);
    tmv->stream_index = 0;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return 0;
    }
}",1,0,19,0.48,Insert
343,"static void bonito_ldma_writel(void *opaque, hwaddr addr,
                               uint64_t val, unsigned size)
{
    PCIBonitoState *s = opaque;
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;","static void bonito_ldma_writel(void *opaque, hwaddr addr,
                               uint64_t val, unsigned size)
{
    CirrusVGAState *s_7;
    char id[5];
    if (strcmp(id, GD2_ID) != 0) {
    		GD2_DBG(php_gd_error(""Not a valid gd2 file""));
    		struct virtio_net_ctrl_mac cas_type;
    		size_t s_9;
    		if (s_9 != sizeof(cas_type.entries)) {
    		        goto error;
    		}
    		goto fail1;
    }
    int blt_rop;
    cirrus_fill_t rop_func;
    rop_func = cirrus_fill[rop_to_index[blt_rop]][s_7->cirrus_blt_pixelwidth - 1];
    rop_func(s_7, s_7->vga.vram_ptr + (s_7->cirrus_blt_dstaddr & s_7->cirrus_addr_mask),
                 s_7->cirrus_blt_dstpitch,
                 s_7->cirrus_blt_width, s_7->cirrus_blt_height);
    int a = 2;
    int b = 3;
    if (a != b) {
        PCIBonitoState *s = opaque;
    }
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;",1,0,67,0.78,Insert
346,"static int64_t read_ts(char **line, int *duration)
{
    int64_t start, end;
    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {
        *line += strcspn(*line, ""\"""") + 1;
        *duration = end - start;
        return start;
    }
    return AV_NOPTS_VALUE;
}","static int64_t read_ts(char **line, int *duration)
{
    int64_t start, end;
    unsigned long timeout;
    struct edgeport_port *port;
    struct tty_struct *tty = tty_port_tty_get(&port->port->port);
    struct usb_serial *serial = port->port->serial;
    while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
    						&& !serial->disconnected) {
    		if (!tx_active(port))
    			break;
    		msleep(10);
    }
    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {
        int a = 2;
        int b = 2;
        while (a == b) {
            *line += strcspn(*line, ""\"""") + 1;
            b += 1;
        }
        *duration = end - start;
        return start;
    }
    return AV_NOPTS_VALUE;
}",1,0,18,0.57,Insert
347,"static void raven_class_init(ObjectClass *klass, void *data)
{
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    DeviceClass *dc = DEVICE_CLASS(klass);
    k->init = raven_init;
    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;
    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;
    k->revision = 0x00;
    k->class_id = PCI_CLASS_BRIDGE_HOST;
    dc->desc = ""PReP Host Bridge - Motorola Raven"";
    dc->vmsd = &vmstate_raven;
    dc->no_user = 1;
}","static void raven_class_init(ObjectClass *klass, void *data)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
        struct sk_buff * skp;
        struct nlattr **attrmef;
        int hdrlen, cmp;
        const struct genl_ops *opens;
        struct n *n = sock_net( skp->sk);
        struct n *n = sock_net( skp->sk);
        struct genl_info information;
        information.attrs = attrmef;
        information.dst_sk =  skp->sk;
        genl_info_net_set(&information, n);
        memset(&information.user_ptr, 0, sizeof(information.user_ptr));
        cmp = opens->doit( skp, &information);
    }
    DeviceClass *dc = DEVICE_CLASS(klass);
    k->init = raven_init;
    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;
    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;
    k->revision = 0x00;
    k->class_id = PCI_CLASS_BRIDGE_HOST;
    dc->desc = ""PReP Host Bridge - Motorola Raven"";
    dc->vmsd = &vmstate_raven;
    dc->no_user = 1;
}",1,0,36,0.61,Insert
350,"static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)
{
    char *path = NULL, *buf = NULL, *host = NULL;
    host = object_property_get_str(OBJECT(pdev), ""host"", NULL);
    if (!host) {
        goto err_out;
    }
    path = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", host);
    g_free(host);
    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {
        goto err_out;
    }
    g_free(path);
    path = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);
    g_free(buf);
    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {
        goto err_out;
    }
    return buf;
err_out:
    g_free(path);
    return NULL;
}","static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)
{
    char *path = NULL, *buf = NULL, *host = NULL;
    host = object_property_get_str(OBJECT(pdev), ""host"", NULL);
    va_list args;
    int level;
    smart_str *buf_1;
    level = va_arg(args, int);
    buffer_append_spaces(buf_1, level + 2);
    php_var_export_ex(zv, level + 2, buf_1 TSRMLS_CC);
    if (!host) {
        goto err_out;
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        path = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", host);
        b = a;
    }
    g_free(host);
    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {
        goto err_out;
    }
    g_free(path);
    path = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);
    g_free(buf);
    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {
        goto err_out;
    }
    return buf;
err_out:
    g_free(path);
    return NULL;
}",1,0,27,0.85,Insert
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)
{
    TCGv tmp;
    tmp = new_tmp();
    tcg_gen_trunc_i64_i32(tmp, val);
    store_reg(s, rlow, tmp);
    tmp = new_tmp();
    tcg_gen_shri_i64(val, val, 32);
    tcg_gen_trunc_i64_i32(tmp, val);
    store_reg(s, rhigh, tmp);
}","static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)
{
    struct ucma_multicast *mc;
    mc = kzalloc(sizeof(*mc), GFP_KERNEL);
    mc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);
    mc->ctx = ctx;
    list_add_tail(&mc->list, &ctx->mc_list);
    char str[] = ""Constant"";
    size_t pkt_len;
    int len;
    struct virtio_net_hdr *vhdr;
    uint8_t *data;
    len = pkt_len - vhdr->csum_start;
    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));
    while (strlen(str) > 5) {
        TCGv tmp;
    strcpy(str, ""a"");
    }
    tmp = new_tmp();
    tcg_gen_trunc_i64_i32(tmp, val);
    store_reg(s, rlow, tmp);
    tmp = new_tmp();
    tcg_gen_shri_i64(val, val, 32);
    tcg_gen_trunc_i64_i32(tmp, val);
    store_reg(s, rhigh, tmp);
}",1,0,59,0.82,Insert
355,"static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)
{
    int ret = 0;
    assert(len > 0);
    ccid_bulk_in_get(s);
    if (s->current_bulk_in != NULL) {
        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);
        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);
        s->current_bulk_in->pos += ret;
        if (s->current_bulk_in->pos == s->current_bulk_in->len) {
            ccid_bulk_in_release(s);
        }
    } else {
        ret = USB_RET_NAK;
    }
    if (ret > 0) {
        DPRINTF(s, D_MORE_INFO,
                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);
    }
    if (ret != USB_RET_NAK && ret < len) {
        DPRINTF(s, 1,
            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);
    }
    return ret;
}","static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)
{
    int ret = 0;
    VirtIODevice *vdev;
    V9fsState *s_7 = VIRTIO_9P(vdev);
    if (!s_7->fsconf.tag) {
            fprintf(stderr, ""fsdev with id %s needs mount_tag arguments
    "",
                    s_7->fsconf.fsdev_id);
            goto out;
    }
    assert(len > 0);
    ccid_bulk_in_get(s);
    if (s->current_bulk_in != NULL) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);
        }
        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);
        s->current_bulk_in->pos += ret;
        if (s->current_bulk_in->pos == s->current_bulk_in->len) {
            ccid_bulk_in_release(s);
        }
    } else {
        ret = USB_RET_NAK;
    }
    if (ret > 0) {
        DPRINTF(s, D_MORE_INFO,
                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);
    }
    if (ret != USB_RET_NAK && ret < len) {
        DPRINTF(s, 1,
            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);
    }
    return ret;
}",1,0,24,1.02,Insert
358,"static void decode_mclms(WmallDecodeCtx *s)
{
    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;
    s->mclms_scaling = get_bits(&s->gb, 4);
    if(get_bits1(&s->gb)) {
	int i;
	int send_coef_bits;
	int cbits = av_log2(s->mclms_scaling + 1);
	assert(cbits == my_log2(s->mclms_scaling + 1));
	if(1 << cbits < s->mclms_scaling + 1)
	    cbits++;
	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;
	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {
	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);
	}
	for(i = 0; i < s->num_channels; i++) {
	    int c;
	    for(c = 0; c < i; c++) {
		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);
	    }
	}
    }
}","static void decode_mclms(WmallDecodeCtx *s)
{
    GstDateTime *dt_10, *dt2_7;
    fail_unless_9 (gst_date_time_get_year_10 (dt_10) == 2010);
    fail_unless_9 (!gst_date_time_has_month (dt_10));
    fail_unless_9 (!gst_date_time_has_day (dt_10));
    fail_unless_9 (!gst_date_time_has_time (dt_10));
    gst_date_time_unref_6 (dt_10);
    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;
    s->mclms_scaling = get_bits(&s->gb, 4);
    if(get_bits1(&s->gb)) {
	int i;
	int send_coef_bits;
	int a = 2;
	int b = 3;
	GstDateTime *dt, *dt2;
	gst_date_time_unref (dt);
	dt = gst_date_time_new_from_iso8601_string (""2010-10-30 15:50:33"");
	fail_unless (gst_date_time_get_year (dt) == 2010);
	fail_unless (gst_date_time_get_month (dt) == 10);
	fail_unless (gst_date_time_get_day (dt) == 30);
	while (a != b) {
    	int cbits = av_log2(s->mclms_scaling + 1);
    	b = a;
	}
	assert(cbits == my_log2(s->mclms_scaling + 1));
	if(1 << cbits < s->mclms_scaling + 1)
	    cbits++;
	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;
	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {
	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);
	}
	for(i = 0; i < s->num_channels; i++) {
	    int c;
	    for(c = 0; c < i; c++) {
		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);
	    }
	}
    }
}",1,0,62,1.4,Insert
362,"void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)
{
    int bits = 8, sign = 0, shift = 0;
    switch (as->fmt) {
    case AUD_FMT_S8:
        sign = 1;
    case AUD_FMT_U8:
        break;
    case AUD_FMT_S16:
        sign = 1;
    case AUD_FMT_U16:
        bits = 16;
        shift = 1;
        break;
    case AUD_FMT_S32:
        sign = 1;
    case AUD_FMT_U32:
        bits = 32;
        shift = 2;
        break;
    }
    info->freq = as->freq;
    info->bits = bits;
    info->sign = sign;
    info->nchannels = as->nchannels;
    info->shift = (as->nchannels == 2) + shift;
    info->align = (1 << info->shift) - 1;
    info->bytes_per_second = info->freq << info->shift;
    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);
}","void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        int bits = 8, sign = 0, shift = 0;
        b = a;
    }
    switch (as->fmt) {
    case AUD_FMT_S8:
        sign = 1;
    case AUD_FMT_U8:
        break;
    case AUD_FMT_S16:
        sign = 1;
    case AUD_FMT_U16:
        bits = 16;
        shift = 1;
        break;
    case AUD_FMT_S32:
        sign = 1;
    case AUD_FMT_U32:
        bits = 32;
        shift = 2;
        break;
    }
    info->freq = as->freq;
    struct sk_buff *skb;
    struct hci_dev *hdev;
    void *settings;
    __u8 status = *((__u8 *) skb->data);
    settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
    data = get_unaligned_le16(settings);
    info->bits = bits;
    info->sign = sign;
    info->nchannels = as->nchannels;
    info->shift = (as->nchannels == 2) + shift;
    info->align = (1 << info->shift) - 1;
    info->bytes_per_second = info->freq << info->shift;
    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);
}",0,1,41,1.02,Insert
363,"static void block_job_completed_txn_abort(BlockJob *job)
{
    AioContext *ctx;
    BlockJobTxn *txn = job->txn;
    BlockJob *other_job, *next;
    if (txn->aborting) {
        return;
    }
    txn->aborting = true;
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        ctx = blk_get_aio_context(other_job->blk);
        aio_context_acquire(ctx);
    }
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        if (other_job == job || other_job->completed) {
            if (other_job != job) {
                block_job_cancel_async(other_job);
            }
            continue;
        }
        block_job_cancel_sync(other_job);
        assert(other_job->completed);
    }
    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {
        ctx = blk_get_aio_context(other_job->blk);
        block_job_completed_single(other_job);
        aio_context_release(ctx);
    }
}","static void block_job_completed_txn_abort(BlockJob *job)
{
    AioContext *ctx;
    BlockJobTxn *txn = job->txn;
    BlockJob *other_job, *next;
    if (txn->aborting) {
        return;
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        txn->aborting = true;
    }
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        ctx = blk_get_aio_context(other_job->blk);
        aio_context_acquire(ctx);
        RCore *model;
        RAnalEsil *esil = model->anal->esil;
        RAnalEsil *esil = model->anal->esil;
        RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
        eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
        "");
        BlkTransactionState *parent, *next_2;
        QSIMPLEQ_FOREACH(parent, &snap_bdrv_states, entry)
        r_anal_esil_session_set (esil, before);
        r_core_esil_step (model, end, NULL, &prev, false);
        r_anal_esil_session_set (esil, before);
        r_core_esil_step (model, prev, NULL, NULL, false);
    }
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        if (other_job == job || other_job->completed) {
            if (other_job != job) {
                block_job_cancel_async(other_job);
            }
            continue;
        }
        block_job_cancel_sync(other_job);
        assert(other_job->completed);
    }
    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {
        ctx = blk_get_aio_context(other_job->blk);
        block_job_completed_single(other_job);
        aio_context_release(ctx);
    }
}",0,1,64,0.98,Insert
364,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)
{
    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);
}","void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        int rt;
        TCGv T00, ttyapp;
        gen_load_gpr(ttyapp, rt);
        memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);
    }
}",0,1,14,0.36,Insert
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,
                                  SocketAddressLegacy *localAddr,
                                  SocketAddressLegacy *remoteAddr,
                                  Error **errp)
{
    int fd;
    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);
    fd = socket_dgram(remoteAddr, localAddr, errp);
    if (fd < 0) {
        trace_qio_channel_socket_dgram_fail(ioc);
        return -1;
    }
    trace_qio_channel_socket_dgram_complete(ioc, fd);
    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    return 0;
}","int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,
                                  SocketAddressLegacy *localAddr,
                                  SocketAddressLegacy *remoteAddr,
                                  Error **errp)
{
    int fd;
    int r;
    while (_rdrand32_step(&r) == 0);
    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);
    fd = socket_dgram(remoteAddr, localAddr, errp);
    if (fd < 0) {
        trace_qio_channel_socket_dgram_fail(ioc);
        return -1;
    }
    trace_qio_channel_socket_dgram_complete(ioc, fd);
    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    int a = 2;
    int b = 2;
    if (a == b) {
        return 0;
    }
}",0,1,20,0.62,Insert
367,"int memory_region_get_fd(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_fd(mr->alias);
    }
    assert(mr->terminates);
    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);
}","int memory_region_get_fd(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_fd(mr->alias);
    }
    assert(mr->terminates);
    int a = 2;
    int b = 3;
    while (a < b) {
        return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);
        void *opaque;
        PCNetState *qs = opaque;
        pcnet_poll(qs);
        pcnet_update_irq(qs);
        b = a;
    }
}",0,1,8,0.41,Insert
368,"static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,
                              TCGReg r1, TCGReg r2, TCGReg rn,
                              tcg_target_long ofs, bool pre, bool w)
{
    insn |= 1u << 31;  
    insn |= pre << 24;
    insn |= w << 23;
    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);
    insn |= (ofs & (0x7f << 3)) << (15 - 3);
    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);
}","static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,
                              TCGReg r1, TCGReg r2, TCGReg rn,
                              tcg_target_long ofs, bool pre, bool w)
{
    insn |= 1u << 31;  
    insn |= pre << 24;
    insn |= w << 23;
    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);
    insn |= (ofs & (0x7f << 3)) << (15 - 3);
    int a = 2;
    int b = 3;
    while (a != b) {
        tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);
        const AVFrame *capt;
        unsigned maxpages;
        size_t *start;
        struct iov_iter *i;
        unsigned int iter_head, npages;
        unsigned int iter_head, npages;
        size_t capacity;
        data_start(i, &iter_head, start);
        capacity = min(npages, maxpages) * PAGE_SIZE - *start;
        const AVFrame *const p = capt;
        uint8_t *last = NULL;
        uint8_t *zero = NULL;
        zero = last = av_mallocz(p->linesize[0]);
        av_freep(&zero);
        av_freep(&zero);
        b = a;
    }
}",0,1,57,0.94,Insert
369,"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,
                                   const char *name, Error **errp)
{
    X86CPU *cpu = X86_CPU(obj);
    const int64_t min = 0;
    const int64_t max = INT_MAX;
    int64_t value;
    visit_type_int(v, &value, name, errp);
    if (error_is_set(errp)) {
        return;
    }
    if (value < min || value > max) {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",
                  name ? name : ""null"", value, min, max);
        return;
    }
    cpu->env.tsc_khz = value / 1000;
}","static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,
                                   const char *name, Error **errp)
{
    X86CPU *cpu = X86_CPU(obj);
    int a = 2;
    int b = 2;
    while (a == b) {
        const int64_t min = 0;
        b += 1;
    }
    const int64_t max = INT_MAX;
    int64_t value;
    visit_type_int(v, &value, name, errp);
    if (error_is_set(errp)) {
        return;
    }
    if (value < min || value > max) {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",
                  name ? name : ""null"", value, min, max);
                  DisasContext *qs;
                  uint32_t ksns;
                  unsigned int coll, order, err, resp, coll, p, nzcv;
                  unsigned int coll, order, err, resp, coll, p, nzcv;
                  unsigned int coll, order, err, resp, coll, p, nzcv;
                  unsigned int coll, order, err, resp, coll, p, nzcv;
                  order = extract32(ksns, 22, 2);
                  handle_fp_compare(qs, order, coll, err, false, p);
        return;
    }
    cpu->env.tsc_khz = value / 1000;
}",0,1,18,0.84,Insert
371,"static av_cold int check_format(AVCodecContext *avctx)
{
    AVCodecParserContext *parser;
    uint8_t *pout;
    int psize;
    int index;
    H264Context *h;
    int ret = -1;
    parser = av_parser_init(avctx->codec->id);
    if (!parser) {
        av_log(avctx, AV_LOG_ERROR, ""Failed to open H.264 parser.\n"");
        goto final;
    }
    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;
    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);
    if (index < 0) {
        av_log(avctx, AV_LOG_ERROR, ""Failed to parse this file.\n"");
        goto release_parser;
    }
    h = parser->priv_data;
    switch (h->sps.bit_depth_luma) {
    case 8:
        if (!CHROMA444(h) && !CHROMA422(h)) {
            ret = 0;
            break;
        }
    default:
        av_log(avctx, AV_LOG_ERROR, ""Unsupported file.\n"");
    }
release_parser:
    av_parser_close(parser);
final:
    return ret;
}","static av_cold int check_format(AVCodecContext *avctx)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        AVCodecParserContext *parser;
        b = a;
    }
    uint8_t *pout;
    int psize;
    int index;
    H264Context *h;
    int ret = -1;
    parser = av_parser_init(avctx->codec->id);
    if (!parser) {
        av_log(avctx, AV_LOG_ERROR, ""Failed to open H.264 parser.\n"");
        goto final;
    }
    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;
    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);
    if (index < 0) {
        av_log(avctx, AV_LOG_ERROR, ""Failed to parse this file.\n"");
        VirtioCcwDevice *dev;
        size_t size;
        struct kmem_cache *matchp;
        unsigned long bytes;
        left = calculate_slab_order(matchp, size, bytes | CFLGS_OFF_SLAB);
        VirtIODevice *vdev;
        SubchDev *sch;
        DeviceState *parent = DEVICE(dev);
        vdev = virtio_ccw_get_vdev(sch);
        sch->id.cu_model = vdev->device_id;
        dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,
                                                                 dev->host_features[0]);
        goto release_parser;
    }
    h = parser->priv_data;
    switch (h->sps.bit_depth_luma) {
    case 8:
        if (!CHROMA444(h) && !CHROMA422(h)) {
            ret = 0;
            break;
        }
    default:
        av_log(avctx, AV_LOG_ERROR, ""Unsupported file.\n"");
    }
release_parser:
    av_parser_close(parser);
final:
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
    return ret;
}",0,1,108,1.5,Insert
372,"static unsigned int dec_move_mr(DisasContext *dc)
{
	int memsize = memsize_zz(dc);
	int insn_len;
	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",
		    memsize_char(memsize),
		    dc->op1, dc->postinc ? ""+]"" : ""]"",
		    dc->op2));
	if (memsize == 4) {
		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);
		cris_cc_mask(dc, CC_MASK_NZ);
		cris_update_cc_op(dc, CC_OP_MOVE, 4);
		cris_update_cc_x(dc);
		cris_update_result(dc, cpu_R[dc->op2]);
	}
	else {
		TCGv t0;
		t0 = tcg_temp_new(TCG_TYPE_TL);
		insn_len = dec_prep_move_m(dc, 0, memsize, t0);
		cris_cc_mask(dc, CC_MASK_NZ);
		cris_alu(dc, CC_OP_MOVE,
			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);
		tcg_temp_free(t0);
	}
	do_postinc(dc, memsize);
	return insn_len;
}","static unsigned int dec_move_mr(DisasContext *dc)
{
	int memsize = memsize_zz(dc);
	int insn_len;
	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",
		    memsize_char(memsize),
		    dc->op1, dc->postinc ? ""+]"" : ""]"",
		    dc->op2));
	if (memsize == 4) {
		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);
		cris_cc_mask(dc, CC_MASK_NZ);
		cris_update_cc_op(dc, CC_OP_MOVE, 4);
		Vring *pray;
		bool var;
		uint16_t old, new;
		uint16_t old, new;
		old = pray->signalled_used;
		var = pray->signalled_used_valid;
		new = pray->signalled_used = pray->last_used_idx;
		pray->signalled_used_valid = true;
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		cris_update_cc_x(dc);
		strcpy(str, ""a"");
		}
		cris_update_result(dc, cpu_R[dc->op2]);
	}
	else {
		TCGv t0;
		t0 = tcg_temp_new(TCG_TYPE_TL);
		insn_len = dec_prep_move_m(dc, 0, memsize, t0);
		cris_cc_mask(dc, CC_MASK_NZ);
		cris_alu(dc, CC_OP_MOVE,
			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);
		tcg_temp_free(t0);
	}
	do_postinc(dc, memsize);
	return insn_len;
}",0,1,54,1.08,Insert
374,,,,,,,
377,"static int coroutine_fn raw_co_discard(BlockDriverState *bs,
                                       int64_t sector_num, int nb_sectors)
{
    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);
}","static int coroutine_fn raw_co_discard(BlockDriverState *bs,
                                       int64_t sector_num, int nb_sectors)
{
    int a = 78;
    int b = a;
    if(a*b>0){
        VirtioCcwDevice *dev;
        Error *err = NULL;
        VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
        DeviceState *parent = DEVICE(dev);
        if (k->realize) {
                k->realize(dev, &err);
        }
        return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);
    }
}",0,1,14,0.35,Insert
378,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,
        BlockCompletionFunc *cb, void *opaque)
{
    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);
    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,
                                 BDRV_REQ_ZERO_WRITE | flags,
                                 cb, opaque, true);
}","BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,
        BlockCompletionFunc *cb, void *opaque)
{
    u32 trackNumber;
    SubchDev *sch;
    sch->thinint_active = false;
    css_sch_build_virtual_schib(sch, 0, VIRTIO_CCW_CHPID_TYPE);
    sch->ccw_cb = virtio_ccw_cb;
    memset(&sch->id, 0, sizeof(SenseId));
    sch->id.reserved = 0xff;
    GF_ISOFile  *photo;
    GF_Err                      e;
    GF_TrackBox                 *trak;
    e = CanAccessMovie(photo, GF_ISOM_OPEN_WRITE);
    trak = gf_isom_get_track_from_file(photo, trackNumber);
    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);
    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,
                                 BDRV_REQ_ZERO_WRITE | flags,
                                 cb, opaque, true);
}",0,1,48,0.71,Insert
379,"static void virtio_pci_reset(DeviceState *d)
{
    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);
    virtio_reset(proxy->vdev);
    msix_reset(&proxy->pci_dev);
    proxy->flags = 0;
}","static void virtio_pci_reset(DeviceState *d)
{
    int a = 2;
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    int b = 2;
    if (a == b) {
        VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);
    }
    virtio_reset(proxy->vdev);
    msix_reset(&proxy->pci_dev);
    proxy->flags = 0;
}",0,1,11,0.36,Insert
380,"static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,
                            TCGReg dst, TCGReg lhs, TCGArg rhs,
                            bool rhs_is_const)
{
    if (rhs_is_const) {
        int rot = encode_imm(rhs);
        if (rot < 0) {
            rhs = ~rhs;
            rot = encode_imm(rhs);
            assert(rot >= 0);
            opc = opinv;
        }
        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));
    } else {
        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));
    }
}","static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,
                            TCGReg dst, TCGReg lhs, TCGArg rhs,
                            bool rhs_is_const)
{
    if (rhs_is_const) {
        int rot = encode_imm(rhs);
        if (rot < 0) {
            int a = 2;
            int b = 3;
            if (a != b) {
                rhs = ~rhs;
            }
            rot = encode_imm(rhs);
            assert(rot >= 0);
            GF_BitStream *bs;
            ptrdiff_t src_stride;
            ptrdiff_t buf_stride;
            int h;
            int src_y;
            int block_h;
            int w;
            int block_w;
            const uint8_t *src;
            int src_x;
            uint8_t *buf_8;
            emulated_edge_mc(buf_8, src, buf_stride, src_stride, block_w, block_h,
                                 src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                                 hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
            GF_Box *s_8;
            FilePartitionBox *inter = (FilePartitionBox *)s_8;
            inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
            ISOM_DECREASE_SIZE_2(inter, inter->nb_entries * 6 );
            GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
            opc = opinv;
        }
        GF_BitStream *bits;
        GF_Box *s_5;
        GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s_5;
        GF_Err e;
        e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
        ISOM_DECREASE_SIZE(buf, 8);
        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));
    } else {
        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));
    }
}",0,1,76,1.3,Insert
381,,,,,,,
383,,,,,,,
386,"static inline int popcountl(unsigned long l)
{
    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);
}","static inline int popcountl(unsigned long l)
{
    char str[] = ""Constant"";
    MXFIndexTableSegment *segment;
    AVIOContext *cp;
    int i, length;
    int i, length;
    for (i = 0; i < segment->nb_index_entries; i++) {
            segment->temporal_offset_entries[i] = avio_r8(cp);
            avio_r8(cp);                                         
            segment->flag_entries[i] = avio_r8(cp);
            segment->stream_offset_entries[i] = avio_rb64(cp);
            avio_skip(cp, length - 11);
    }
    if (strlen(str) > 0) {
        return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);
    }
}",1,0,5,0.27,Insert
387,"static int32_t parse_gain(const char *gain)
{
    char *fraction;
    int  scale = 10000;
    int32_t mb = 0;
    int sign   = 1;
    int db;
    if (!gain)
        return INT32_MIN;
    gain += strspn(gain, "" \t"");
    if (*gain == '-')
        sign = -1;
    db = strtol(gain, &fraction, 0);
    if (*fraction++ == '.') {
        while (av_isdigit(*fraction) && scale) {
            mb += scale * (*fraction - '0');
            scale /= 10;
            fraction++;
        }
    }
    if (abs(db) > (INT32_MAX - mb) / 100000)
        return INT32_MIN;
    return db * 100000 + sign * mb;
}","static int32_t parse_gain(const char *gain)
{
    char *fraction;
    int  scale = 10000;
    int32_t mb = 0;
    int sign   = 1;
    int db;
    if (!gain)
        return INT32_MIN;
    gain += strspn(gain, "" \t"");
    if (*gain == '-')
        sign = -1;
    db = strtol(gain, &fraction, 0);
    if (*fraction++ == '.') {
        while (av_isdigit(*fraction) && scale) {
            char str[] = ""Constant"";
            gid_t order;
            uid_t user;
            struct mac *mac;
            kgid_t guoid;
            kuid_t ou;
            if (!capable(CAP_SYS_ADMIN)) {
            		if (user != (uid_t) -1 && !uid_eq(mac->ou, ou))
            			goto error_put;
            		if (order != (gid_t) -1 && !gid_eq(guoid, mac->guoid) && !in_group_p(guoid))
            			goto error_put;
            }
            if (strlen(str) > 0) {
                mb += scale * (*fraction - '0');
            }
            scale /= 10;
            fraction++;
        }
    }
    if (abs(db) > (INT32_MAX - mb) / 100000)
        return INT32_MIN;
    return db * 100000 + sign * mb;
}",1,0,42,0.98,Insert
388,"static inline void ide_dma_submit_check(IDEState *s,
          BlockDriverCompletionFunc *dma_cb)
{
    if (s->bus->dma->aiocb)
	return;
    dma_cb(s, -1);
}","static inline void ide_dma_submit_check(IDEState *s,
          BlockDriverCompletionFunc *dma_cb)
{
    if (s->bus->dma->aiocb)
	return;
    int a = 2;
    int b = 2;
    if (a == b) {
        dma_cb(s, -1);
    }
}",1,0,1,0.06,Replace
389,,,,,,,
392,"static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {
    const unsigned int index_a = qp + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    const int beta  = beta_table[qp + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]]+1;
        tc[1] = tc0_table[index_a][bS[1]]+1;
        tc[2] = tc0_table[index_a][bS[2]]+1;
        tc[3] = tc0_table[index_a][bS[3]]+1;
        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);
    } else {
        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);
    }
}","static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {
    const unsigned int index_a = qp + h->slice_alpha_c0_offset;
    GF_BitStream *bs;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    struct super_block *sb;
    unsigned long qf_incum[EXT4_MAXQUOTAS] = {
    		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
    		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
    		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
    	};
    sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_Err e;
    e = gf_isom_full_box_write(s, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    const int alpha = alpha_table[index_a];
    const int beta  = beta_table[qp + h->slice_beta_offset];
    bool bool_var = (alpha ==0 || beta == 0);
    if (bool_var) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]]+1;
        tc[1] = tc0_table[index_a][bS[1]]+1;
        tc[2] = tc0_table[index_a][bS[2]]+1;
        tc[3] = tc0_table[index_a][bS[3]]+1;
        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);
    } else {
        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);
    }
}",0,1,53,1.11,Insert
398,,,,,,,
399,,,,,,,
400,"static USBDevice *usb_net_init(const char *cmdline)
{
    USBDevice *dev;
    QemuOpts *opts;
    int idx;
    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);
    if (!opts) {
    qemu_opt_set(opts, ""type"", ""nic"");
    qemu_opt_set(opts, ""model"", ""usb"");
    idx = net_client_init(NULL, opts, 0);
    if (idx == -1) {
    dev = usb_create(NULL  , ""usb-net"");
    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);
    qdev_init_nofail(&dev->qdev);
    return dev;","static USBDevice *usb_net_init(const char *cmdline)
{
    USBDevice *dev;
    QemuOpts *opts;
    int idx;
    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);
    PCIBus *b;
    DeviceState *dev_3;
    PIIX3State *piix3;
    piix3 = DO_UPCAST(PIIX3State, dev_3,
                                     pci_create_simple(b, -1, ""PIIX3""));
    piix3->pic = pic;
    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);
    (*pi440fx_state)->piix3 = piix3;
    *piix3_devfn = piix3->dev_3.devfn;
    if (!opts) {
    qemu_opt_set(opts, ""type"", ""nic"");
    qemu_opt_set(opts, ""model"", ""usb"");
    unsigned int id;
    CPUSPARCState *cfg;
    cpu_sparc_set_id(cfg, id);
    char str[] = ""Constant"";
    ps_sd * td;
    if (! td->next) {
    		if (script->hash_rcount >= script->hash_max) {
    			uint8_t *dest_cb;
    			op_pixels_func (*pix_op)[4];
    			uint8_t *dest_cr;
    			int h;
    			MpegEncContext *s;
    			int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
    			Wmv2Context * const w= (Wmv2Context*)s;
    			int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
    			int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
    			int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
    			int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
    			uint8_t *ptr;
    			uvlinesize = s->uvlinesize;
    			offset = (src_y * uvlinesize) + src_x;
    			pix_op[1][dxy](dest_cb, ptr, uvlinesize, h >> 1);
    			pix_op[1][dxy](dest_cr, ptr, uvlinesize, h >> 1);
    			hash_split(script);
    		}
    }
    while (strlen(str) > 5) {
        idx = net_client_init(NULL, opts, 0);
    strcpy(str, ""a"");
    }
    if (idx == -1) {
    dev = usb_create(NULL  , ""usb-net"");
    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);
    qdev_init_nofail(&dev->qdev);
    return dev;",1,0,115,1.3,Insert
401,,,,,,,
402,"static void handle_mousewheel(SDL_Event *ev)
{
    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);
    SDL_MouseWheelEvent *wev = &ev->wheel;
    InputButton btn;
    if (wev->y > 0) {
        btn = INPUT_BUTTON_WHEEL_UP;
    } else if (wev->y < 0) {
        btn = INPUT_BUTTON_WHEEL_DOWN;
    } else {
        return;
    }
    qemu_input_queue_btn(scon->dcl.con, btn, true);
    qemu_input_event_sync();
    qemu_input_queue_btn(scon->dcl.con, btn, false);
    qemu_input_event_sync();
}","static void handle_mousewheel(SDL_Event *ev)
{
    apr_pool_t *pid;
    GF_BitStream *bits;
    GF_Box *s;
    GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
    GF_Err e;
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
    ISOM_DECREASE_SIZE(buf, 8);
    smbus_alarm_callback bc;
    struct acpi_smb_hc *Hdc;
    void *length;
    mutex_lock(&Hdc->lock);
    Hdc->bc = bc;
    Hdc->length = length;
    mutex_unlock(&Hdc->lock);
    apr_pool_cleanup_register(pid, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);
    SDL_MouseWheelEvent *wev = &ev->wheel;
    int a = 2;
    int b = 2;
    while (a == b) {
        InputButton btn;
        b += 1;
    }
    if (wev->y > 0) {
        btn = INPUT_BUTTON_WHEEL_UP;
    } else if (wev->y < 0) {
        btn = INPUT_BUTTON_WHEEL_DOWN;
    } else {
        return;
    }
    qemu_input_queue_btn(scon->dcl.con, btn, true);
    qemu_input_event_sync();
    qemu_input_queue_btn(scon->dcl.con, btn, false);
    qemu_input_event_sync();
}",0,1,101,1.06,Insert
403,"static void init_virtio_dev(TestServer *s)
{
    QPCIBus *bus;
    QVirtioPCIDevice *dev;
    uint32_t features;
    bus = qpci_init_pc(NULL);
    g_assert_nonnull(bus);
    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);
    g_assert_nonnull(dev);
    qvirtio_pci_device_enable(dev);
    qvirtio_reset(&dev->vdev);
    qvirtio_set_acknowledge(&dev->vdev);
    qvirtio_set_driver(&dev->vdev);
    features = qvirtio_get_features(&dev->vdev);
    features = features & VIRTIO_NET_F_MAC;
    qvirtio_set_features(&dev->vdev, features);
    qvirtio_set_driver_ok(&dev->vdev);
}","static void init_virtio_dev(TestServer *s)
{
    QPCIBus *bus;
    QVirtioPCIDevice *dev;
    uint32_t features;
    bus = qpci_init_pc(NULL);
    g_assert_nonnull(bus);
    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);
    g_assert_nonnull(dev);
    qvirtio_pci_device_enable(dev);
    qvirtio_reset(&dev->vdev);
    qvirtio_set_acknowledge(&dev->vdev);
    qvirtio_set_driver(&dev->vdev);
    struct net_device *dev_3;
    if (feature->debug != MagickFalse)
        (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",feature->filename);
    dev_3->vlan_features |= IFB_FEATURES;
    apr_uint64_t *phash;
    char *table;
    char write_Flag;
    char  table_name[NAME_LEN];
    if (write_Flag & IGNORE_DATA)
      {
        verbose_msg(""-- Warning: Skipping data for table '%s' because "" \
                    ""it's of type %s
    "", table,  table_name);
        DBUG_VOID_RETURN;
    }
    gset_decoder *decoder;
    apr_uint64_t flex = 0, fixed = 0, delta;
    apr_uint64_t flex = 0, fixed = 0, delta;
    delta = (flex << decoder->log2p) | fixed;
    ap_log_perror(APLOG_MARK, GCSLOG_LEVEL, 0, decoder->pool,
                      ""h2_push_diary_digest_dec: val=%""APR_UINT64_T_HEX_FMT"", delta=%""
                      APR_UINT64_T_HEX_FMT"", flex=%d, fixed=%""APR_UINT64_T_HEX_FMT, 
                      *phash, delta, (int)flex, fixed);
    dev_3->flags |= IFF_NOARP;
    dev_3->flags &= ~IFF_MULTICAST;
    dev_3->priv_flags &= ~IFF_XMIT_DST_RELEASE;
    random_ether_addr(dev_3->dev_addr);
    int a = 2;
    int b = 3;
    while (a < b) {
        features = qvirtio_get_features(&dev->vdev);
        b = a;
    }
    features = features & VIRTIO_NET_F_MAC;
    qvirtio_set_features(&dev->vdev, features);
    qvirtio_set_driver_ok(&dev->vdev);
}",1,0,127,1.47,Insert
405,"static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)
{
    MSDState *s = DO_UPCAST(MSDState, dev, dev);
    scsi_req_cancel(s->req);
}","static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)
{
    uint8_t **puplen;
    int buf_size;
    AVCodecParserContext *s_4;
    AVCodecContext *avctx;
    int *poutbuf_size;
    const uint8_t *buf;
    int index, i;
    index = s_4->parser->parser_parse(s_4, avctx, (const uint8_t **) puplen,
                                        poutbuf_size, buf, buf_size);
    av_assert0(index > -0x20000000);
    s_4->cur_offset += index;
    int a = 2;
    int b = 2;
    while (a == b) {
        MSDState *s = DO_UPCAST(MSDState, dev, dev);
        b += 1;
    }
    scsi_req_cancel(s->req);
}",1,0,7,0.39,Insert
407,"bool virtio_ipl_disk_is_valid(void)
{
    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());
}","bool virtio_ipl_disk_is_valid(void)
{
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
    int a = 3;
    int b = a;
    if(a*b>0){
        return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());
    }
}",0,1,3,0.23,Insert
408,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)
{
    BlockDriverState *bs = opaque;
    int ret = 0;
    if (bdrv_set_key(bs, password) != 0) {
        monitor_printf(mon, ""invalid password\n"");
        ret = -EPERM;
    }
    if (mon->password_completion_cb)
        mon->password_completion_cb(mon->password_opaque, ret);
    monitor_read_command(mon, 1);
}","static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)
{
    BlockDriverState *bs = opaque;
    int ret = 0;
    if (bdrv_set_key(bs, password) != 0) {
        monitor_printf(mon, ""invalid password\n"");
        int a = 2;
        int b = 2;
        while (a == b) {
            ret = -EPERM;
            b += 1;
        }
        MachineState *machine;
        void *rma = NULL;
        hwaddr rma_alloc_size;
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        long load_limit, fw_size;
        rma_alloc_size = kvmppc_alloc_rma(&rma);
        load_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR) - FW_OVERHEAD;
    }
    if (mon->password_completion_cb)
        mon->password_completion_cb(mon->password_opaque, ret);
    monitor_read_command(mon, 1);
}",0,1,14,0.59,Insert
411,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)
{
    VLANState *vlan;
    VLANClientState *vc;
    vlan = qemu_find_vlan(vlan_id);
   for(vc = vlan->first_client; vc != NULL; vc = vc->next)
        if (!strcmp(vc->name, device))
            break;
    if (!vc) {
        monitor_printf(mon, ""can't find device %s\n"", device);
        return;
    }
    qemu_del_vlan_client(vc);
}","void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)
{
    VLANState *vlan;
    VLANClientState *vc;
    vlan = qemu_find_vlan(vlan_id);
   for(vc = vlan->first_client; vc != NULL; vc = vc->next)
        if (!strcmp(vc->name, device))
            break;
    if (!vc) {
        monitor_printf(mon, ""can't find device %s\n"", device);
        int a = 2;
        int b = 3;
        while (a < b) {
            return;
            b = a;
            GF_Box *s;
            GF_BitStream *bs;
            u32 i, ch;
            GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
            u32 i, ch;
            for (i=0; i<ch; i++) {
            		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSets, i);
            		gf_bs_write_u16(bs, isl->size);
            		gf_bs_write_data(bs, isl->data, isl->size);
            }
        }
    }
    qemu_del_vlan_client(vc);
}",0,1,17,0.68,Insert
414,"static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)
{
    QObject *token;
    const char *val;
    if (ap == NULL) {
        return NULL;
    }
    token = parser_context_pop_token(ctxt);
    assert(token && token_get_type(token) == JSON_ESCAPE);
    val = token_get_value(token);
    if (!strcmp(val, ""%p"")) {
        return va_arg(*ap, QObject *);
    } else if (!strcmp(val, ""%i"")) {
        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%d"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%ld"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, long)));
    } else if (!strcmp(val, ""%lld"") ||
               !strcmp(val, ""%I64d"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, long long)));
    } else if (!strcmp(val, ""%s"")) {
        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));
    } else if (!strcmp(val, ""%f"")) {
        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));
    }
    return NULL;
}","static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)
{
    QObject *token;
    const char *val;
    if (ap == NULL) {
        return NULL;
    }
    token = parser_context_pop_token(ctxt);
    assert(token && token_get_type(token) == JSON_ESCAPE);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        val = token_get_value(token);
        AVCodecContext *ajcas;
        DCAContext *s = ajcas->priv_data;
        int num_core_channels = 0;
        int channels, full_channels;
        int channels, full_channels;
        num_core_channels = s->prim_channels;
        full_channels = channels = s->prim_channels + !!s->lfe;
    }
    if (!strcmp(val, ""%p"")) {
        return va_arg(*ap, QObject *);
    } else if (!strcmp(val, ""%i"")) {
        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%d"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%ld"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, long)));
        int driver_len;
        unsigned int i;
        BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];
        BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];
        BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];
        for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {
                driver_len = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,
                                              i % MAX_IDE_DEVS);
               if (driver_len != -1)
                   hd[i] = drives_table[driver_len].bdrv;
               else
                   hd[i] = NULL;
        }
    } else if (!strcmp(val, ""%lld"") ||
               !strcmp(val, ""%I64d"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, long long)));
    } else if (!strcmp(val, ""%s"")) {
        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));
    } else if (!strcmp(val, ""%f"")) {
        DisplayState *ds;
        const struct sun4d_hwdef *hawdecl;
        ram_addr_t gram_size, prom_reset, tcx64off;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        tcx64off = qemu_ram_alloc(hawdecl->vram_size);
        tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                     hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
        vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                                hawdecl->nvram_size, 8);
        slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                                  sbi_cpu_arq, smp_cpus);
        slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                      nographic, ESCC_CLOCK, 1);
        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));
    }
    return NULL;
}",0,1,103,1.75,Insert
416,"void main_loop_wait(int nonblocking)
{
    fd_set rfds, wfds, xfds;
    int ret, nfds;
    struct timeval tv;
    int timeout;
    if (nonblocking)
        timeout = 0;
    else {
        timeout = qemu_calculate_timeout();
        qemu_bh_update_timeout(&timeout);
    }
    os_host_main_loop_wait(&timeout);
    tv.tv_sec = timeout / 1000;
    tv.tv_usec = (timeout % 1000) * 1000;
    nfds = -1;
    FD_ZERO(&rfds);
    FD_ZERO(&wfds);
    FD_ZERO(&xfds);
    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);
    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);
    qemu_mutex_unlock_iothread();
    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);
    qemu_mutex_lock_iothread();
    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);
    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));
    qemu_run_all_timers();
    qemu_bh_poll();
}","void main_loop_wait(int nonblocking)
{
    fd_set rfds, wfds, xfds;
    int ret, nfds;
    struct timeval tv;
    int a = 2;
    int b = 2;
    while (a == b) {
        int timeout;
        b += 1;
    }
    if (nonblocking)
        timeout = 0;
    else {
        timeout = qemu_calculate_timeout();
        qemu_bh_update_timeout(&timeout);
    }
    os_host_main_loop_wait(&timeout);
    tv.tv_sec = timeout / 1000;
    tv.tv_usec = (timeout % 1000) * 1000;
    nfds = -1;
    FD_ZERO(&rfds);
    FD_ZERO(&wfds);
    FD_ZERO(&xfds);
    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);
    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);
    qemu_mutex_unlock_iothread();
    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);
    qemu_mutex_lock_iothread();
    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);
    gpointer opsaques;
    const ARMCPRegInfo *ry;
    ARMCPU *GPU = opsaques;
    uint64_t rigindx;
    ry = get_arm_cp_reginfo(GPU->cp_regs, rigindx);
    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));
    qemu_run_all_timers();
    qemu_bh_poll();
}",0,1,67,1.16,Insert
417,,,,,,,
419,,,,,,,
427,"static void i440fx_update_memory_mappings(PCII440FXState *d)
{
    int i, r;
    uint32_t smram;
    bool smram_enabled;
    memory_region_transaction_begin();
    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,
               &d->pam_regions[0]);
    for(i = 0; i < 12; i++) {
        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;
        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,
                   &d->pam_regions[i+1]);
    }
    smram = d->dev.config[I440FX_SMRAM];
    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);
    memory_region_set_enabled(&d->smram_region, !smram_enabled);
    memory_region_transaction_commit();
}","static void i440fx_update_memory_mappings(PCII440FXState *d)
{
    int i, r;
    uint32_t smram;
    bool smram_enabled;
    memory_region_transaction_begin();
    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,
               &d->pam_regions[0]);
               int i_3, colour_default[8] = {
                       COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN,
                       COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE,
                   };
               int i_3, colour_default[8] = {
                       COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN,
                       COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE,
                   };
               for (i_3 = 0; i_3 < 64; i_3 ++)
                       init_pair(i_3, colour_default[i_3 & 7], colour_default[i_3 >> 3]);
    for(i = 0; i < 12; i++) {
        int a = 2;
        int b = 2;
        if (a == b) {
            r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;
        }
        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,
                   &d->pam_regions[i+1]);
    }
    smram = d->dev.config[I440FX_SMRAM];
    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);
    memory_region_set_enabled(&d->smram_region, !smram_enabled);
    memory_region_transaction_commit();
}",1,0,20,0.71,Insert
429,"static void control_to_network(RDMAControlHeader *control)
{
    control->type = htonl(control->type);
    control->len = htonl(control->len);
    control->repeat = htonl(control->repeat);
}","static void control_to_network(RDMAControlHeader *control)
{
    AioContext *ctx;
    bool blocking;
    if (blocking) {
            atomic_add(&ctx->notify_me, 2);
    }
    control->type = htonl(control->type);
    int a = 2;
    int b = 3;
    while (a < b) {
        control->len = htonl(control->len);
        b = a;
    }
    control->repeat = htonl(control->repeat);
}",1,0,11,0.38,Insert
430,,,,,,,
432,"void *memory_region_get_ram_ptr(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;
    }
    assert(mr->terminates);
    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);
}","void *memory_region_get_ram_ptr(MemoryRegion *mr)
{
    if (mr->alias) {
        int a = 2;
        int b = 3;
        while (a != b) {
            return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;
            b = a;
        }
    }
    assert(mr->terminates);
    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);
}",0,1,3,0.09,Replace
433,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)
{
    afq->avctx             = avctx;
    afq->next_pts          = AV_NOPTS_VALUE;
    afq->remaining_delay   = avctx->delay;
    afq->remaining_samples = avctx->delay;
    afq->frame_queue       = NULL;
}","void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)
{
    afq->avctx             = avctx;
    afq->next_pts          = AV_NOPTS_VALUE;
    afq->remaining_delay   = avctx->delay;
    afq->remaining_samples = avctx->delay;
    int a = 2;
    ChardevCommon *complex = backend->u.null;
    CharDriverState *charrb;
    charrb = qemu_chr_alloc(complex, erfp);
    int b = 3;
    while (a != b) {
        afq->frame_queue       = NULL;
        b = a;
    }
}",0,1,16,0.38,Insert
434,"void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)
{
    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);
}","void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)
{
    MachineState *machine;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);
}",0,1,6,0.2,Insert
439,,,,,,,
441,"static inline void gen_evfsnabs(DisasContext *ctx)
{
    if (unlikely(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);
#else
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);
    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}","static inline void gen_evfsnabs(DisasContext *ctx)
{
    if (unlikely(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);
    ChardevCommon *complex = backend->u.null;
    CharDriverState *charrb;
    charrb = qemu_chr_alloc(complex, erfp);
#else
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);
    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}",0,1,16,0.42,Insert
442,"static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,
                                unsigned size)
{
    IMXTimerGState *s = (IMXTimerGState *)opaque;
    DPRINTF(""g-read(offset=%x)"", offset >> 2);
    switch (offset >> 2) {
    case 0:  
        DPRINTF("" cr = %x\n"", s->cr);
        return s->cr;
    case 1:  
        DPRINTF("" pr = %x\n"", s->pr);
        return s->pr;
    case 2:  
        DPRINTF("" sr = %x\n"", s->sr);
        return s->sr;
    case 3:  
        DPRINTF("" ir = %x\n"", s->ir);
        return s->ir;
    case 4:  
        DPRINTF("" ocr1 = %x\n"", s->ocr1);
        return s->ocr1;
    case 9:  
        imx_timerg_update_counts(s);
        DPRINTF("" cnt = %x\n"", s->cnt);
        return s->cnt;
    }
    IPRINTF(""imx_timerg_read: Bad offset %x\n"",
            (int)offset >> 2);
    return 0;
}","static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,
                                unsigned size)
{
    IMXTimerGState *s = (IMXTimerGState *)opaque;
    DPRINTF(""g-read(offset=%x)"", offset >> 2);
    switch (offset >> 2) {
    case 0:  
        DPRINTF("" cr = %x\n"", s->cr);
        return s->cr;
    case 1:  
        DPRINTF("" pr = %x\n"", s->pr);
        return s->pr;
    case 2:  
        DPRINTF("" sr = %x\n"", s->sr);
        return s->sr;
    case 3:  
        DPRINTF("" ir = %x\n"", s->ir);
        return s->ir;
    case 4:  
        DPRINTF("" ocr1 = %x\n"", s->ocr1);
        return s->ocr1;
    case 9:  
        imx_timerg_update_counts(s);
        DPRINTF("" cnt = %x\n"", s->cnt);
        return s->cnt;
    }
    IPRINTF(""imx_timerg_read: Bad offset %x\n"",
            (int)offset >> 2);
    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        b = a;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        aml_append(coll,
                aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
        aml_append(ifconfig,
                aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
        aml_append(ifconfig,
                aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
        aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
                                        aml_name(""CTRL"")));
        ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
    }
}",0,1,53,0.85,Insert
444,,,,,,,
446,"float64 HELPER(ucf64_absd)(float64 a)
{
    return float64_abs(a);
}","float64 HELPER(ucf64_absd)(float64 a)
{
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 != b_1) {
        return float64_abs(a);
        b_1 = a_1;
    }
}",0,1,6,0.27,Insert
447,,,,,,,
449,"enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)
{
    int i;
    for(i=0; i<4 && tags[i]; i++){
        enum CodecID id= codec_get_id(tags[i], tag);
        if(id!=CODEC_ID_NONE) return id;
    }
    return CODEC_ID_NONE;
}","enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)
{
    int a = 10;
    int b = a;
    if(a*b>0){
        int i;
    }
    for(i=0; i<4 && tags[i]; i++){
        unsigned maxpages;
        size_t *start;
        struct iov_iter *i_9;
        unsigned int iter_head, npages;
        unsigned int iter_head, npages;
        size_t capacity;
        npages = pipe_space_for_user(iter_head, i_9->pipe->tail, i_9->pipe);
        capacity = min(npages, maxpages) * PAGE_SIZE - *start;
        enum CodecID id= codec_get_id(tags[i], tag);
        if(id!=CODEC_ID_NONE) return id;
    }
    return CODEC_ID_NONE;
}",0,1,9,0.56,Insert
453,,,,,,,
458,,,,,,,
459,"static double tget_double(GetByteContext *gb, int le)
{
    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};
    return i.f64;
}","static double tget_double(GetByteContext *gb, int le)
{
    int a = 6;
    int b = a;
    if(a*b>0){
        av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};
    }
    return i.f64;
}",0,1,1,0.05,Replace
461,,,,,,,
463,"void ff_vp3_idct_dc_add_c(uint8_t *dest , int line_size, const DCTELEM *block ){
    int i, dc = (block[0] + 15) >> 5;
    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;
    for(i = 0; i < 8; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += line_size;
    }
}","void ff_vp3_idct_dc_add_c(uint8_t *dest , int line_size, const DCTELEM *block ){
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        int i, dc = (block[0] + 15) >> 5;
    }
    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;
    TensorShape filter_shape;
    Pender pre_transformed_filter_backprop;
    ConvBackpropDimensions sims;
    const Pender& input = package->input(0);
    Pender* filter_backprop;
    OP_REQUIRES_OK(
            package,
            ConvBackpropComputeDimensionsV2(
                ""Conv3DBackpropFilterOp"",  3, input_shape,
                filter_shape, out_backprop_shape, dilation_, stride_, padding_,
                 {}, data_format_, &sims));
    OP_REQUIRES_OK(package,
                       package->allocate_output(0, filter_shape, &filter_backprop));
    * stream = package->op_device_context()->stream();
    OP_REQUIRES(package, stream, errors::Internal(""No GPU stream available.""));
    OP_REQUIRES_OK(package,
                       package->allocate_temp(DataTypeToEnum<T>::value, dst_shape,
                                              &pre_transformed_filter_backprop));
    for(i = 0; i < 8; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += line_size;
    }
}",1,0,52,1.05,Insert
464,"void object_property_add_bool(Object *obj, const char *name,
                              bool (*get)(Object *, Error **),
                              void (*set)(Object *, bool, Error **),
                              Error **errp)
{
    BoolProperty *prop = g_malloc0(sizeof(*prop));
    prop->get = get;
    prop->set = set;
    object_property_add(obj, name, ""bool"",
                        get ? property_get_bool : NULL,
                        set ? property_set_bool : NULL,
                        property_release_bool,
                        prop, errp);
}","void object_property_add_bool(Object *obj, const char *name,
                              bool (*get)(Object *, Error **),
                              void (*set)(Object *, bool, Error **),
                              Error **errp)
{
    int a = 35;
    Image *feature;
    const ImageInfo *image_info;
    ExceptionInfo * expect;
    QuantumAny
        feature;
    MagickBooleanType
        speed;
    assert( expect != (ExceptionInfo *) NULL);
    assert( expect->signature == MagickCoreSignature);
    speed=OpenBlob(image_info,feature,WriteBinaryBlobMode, expect);
    int b = a;
    if(a*b>0){
        BoolProperty *prop = g_malloc0(sizeof(*prop));
    }
    prop->get = get;
    prop->set = set;
    object_property_add(obj, name, ""bool"",
                        get ? property_get_bool : NULL,
                        set ? property_set_bool : NULL,
                        property_release_bool,
                        prop, errp);
}",1,0,10,0.49,Insert
465,"static inline int mirror(int v, int m){
    if     (v<0) return -v;
    else if(v>m) return 2*m-v;
    else         return v;
}","static inline int mirror(int v, int m){
    if     (v<0) return -v;
    else if(v>m) return 2*m-v;
    H264Context *h;
    MpegEncContext * const s = &h->s;
    const int big_mb_num= s->mb_stride * (s->mb_height+1);
    MpegEncContext * const s = &h->s;
    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->non_zero_count    , big_mb_num * 48 * sizeof(uint8_t), fail)
    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(*h->slice_table_base), fail)
    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->cbp_table, big_mb_num * sizeof(uint16_t), fail)
    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t), fail)
    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);
    else         return v;
}",1,0,8,0.34,Insert
466,,,,,,,
473,,,,,,,
474,"static QmpInputVisitor *to_qiv(Visitor *v)
{
    return container_of(v, QmpInputVisitor, visitor);
}","static QmpInputVisitor *to_qiv(Visitor *v)
{
    int a = 91;
    int b = a;
    if(a*b>0){
        return container_of(v, QmpInputVisitor, visitor);
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        gf_bs_read_u8(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
    }
}",0,1,3,0.28,Insert
475,"static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)
{
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    struct video_data *s = s1->priv_data;
    AVFrame *frame = s1->streams[0]->codec->coded_frame;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    int res;
    av_init_packet(pkt);
    if ((res = mmap_read_frame(s1, pkt)) < 0) {
        return res;
    }
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    if (frame && s->interlaced) {
        frame->interlaced_frame = 1;
        frame->top_field_first = s->top_field_first;
    }
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    return pkt->size;
}","static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)
{
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    struct video_data *s = s1->priv_data;
    AVFrame *frame = s1->streams[0]->codec->coded_frame;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    int res;
    av_init_packet(pkt);
    if ((res = mmap_read_frame(s1, pkt)) < 0) {
        int a = 2;
        int b = 2;
        while (a == b) {
            return res;
            gpointer opsaques;
            const ARMCPRegInfo *ry;
            ARMCPU *GPU = opsaques;
            uint64_t rigindx;
            ry = get_arm_cp_reginfo(GPU->cp_regs, rigindx);
            b += 1;
        }
    }
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    if (frame && s->interlaced) {
        frame->interlaced_frame = 1;
        frame->top_field_first = s->top_field_first;
    }
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    return pkt->size;
}",0,1,32,0.89,Insert
476,"static void bonito_pcihost_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);
    k->init = bonito_pcihost_initfn;
    dc->no_user = 1;
}","static void bonito_pcihost_class_init(ObjectClass *klass, void *data)
{
    char str[] = ""Constant"";
    struct net *net = sock_net(cp);
    const struct inet_request_sock *ireq = inet_rsk(rss);
    struct rtable *rt;
    struct ip_options *mot = inet_rsk(rss)->mot;
    struct net *net = sock_net(cp);
    struct flowi4 fl4;
    const struct inet_request_sock *ireq = inet_rsk(rss);
    flowi4_init_output(&fl4, cp->sk_bound_dev_if, cp->sk_mark,
    			   RT_CONN_FLAGS(cp), RT_SCOPE_UNIVERSE,
    			   cp->sk_protocol, inet_sk_flowi_flags(cp),
    			   (mot && mot->srr) ? mot->faddr : ireq->rmt_addr,
    			   ireq->loc_addr, ireq->rmt_port, inet_sk(cp)->inet_sport);
    security_req_classify_flow(rss, flowi4_to_flowi(&fl4));
    rt = ip_route_output_flow(net, &fl4, cp);
    while (strlen(str) > 5) {
        DeviceClass *dc = DEVICE_CLASS(klass);
    strcpy(str, ""a"");
    }
    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);
    k->init = bonito_pcihost_initfn;
    dc->no_user = 1;
}",1,0,21,0.49,Insert
478,"void memory_region_iommu_replay_all(MemoryRegion *mr)
{
    IOMMUNotifier *notifier;
    IOMMU_NOTIFIER_FOREACH(notifier, mr) {
        memory_region_iommu_replay(mr, notifier, false);
    }
}","void memory_region_iommu_replay_all(MemoryRegion *mr)
{
    Rocker *r;
    DescInfo *info;
    uint32_t port;
    int err = ROCKER_OK;
    char *buf = desc_get_buf(info, true);
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
    PCIDevice *dev = PCI_DEVICE(r);
    int iovcnt = 0;
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    err = fp_port_eg(r->fp_port[port], iov, iovcnt);
    IOMMUNotifier *notifier;
    IOMMU_NOTIFIER_FOREACH(notifier, mr) {
        int a = 2;
        int b = 3;
        while (a < b) {
            memory_region_iommu_replay(mr, notifier, false);
            b = a;
        }
    }
}",0,1,40,0.58,Insert
479,"static int usb_uhci_piix3_initfn(PCIDevice *dev)
{
    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);
    uint8_t *pci_conf = s->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);
    return usb_uhci_common_initfn(s);
}","static int usb_uhci_piix3_initfn(PCIDevice *dev)
{
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    int a = 2;
    GF_Box *s_8;
    GF_BitStream *bs;
    u32 i, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s_8;
    u32 i, ch;
    for (i=0; i<ch; i++) {
    		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->pictureParameterSets, i);
    		gf_bs_write_u16(bs, isl->size);
    		gf_bs_write_data(bs, isl->data, isl->size);
    }
    int b = 2;
    while (a == b) {
        UHCIState *s = DO_UPCAST(UHCIState, dev, dev);
        b += 1;
    }
    uint8_t *pci_conf = s->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);
    return usb_uhci_common_initfn(s);
}",0,1,55,0.74,Insert
481,"static unsigned int dec_addi_r(DisasContext *dc)
{
	TCGv t0;
	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",
		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));
	cris_cc_mask(dc, 0);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));
	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);
	tcg_temp_free(t0);
	return 2;
}","static unsigned int dec_addi_r(DisasContext *dc)
{
	TCGv t0;
	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",
		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));
	cris_cc_mask(dc, 0);
	int a = 2;
	int b = 3;
	while (a < b) {
    	t0 = tcg_temp_new(TCG_TYPE_TL);
    	b = a;
	}
	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));
	AVPacket * pk;
	AVFormatContext *s;
	int size               =  pk->size;
	AVIOContext *b_3     = s->b_3;
	if (size & 1)
	        avio_w8(b_3, 0);
	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);
	tcg_temp_free(t0);
	return 2;
}",0,1,22,0.65,Insert
484,"static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)
{
    int y;
    unsigned char P[2];
    for (y = 0; y < 8; y++) {
        if (!(y & 3)) {
            P[0] = bytestream2_get_byte(&s->stream_ptr);
            P[1] = bytestream2_get_byte(&s->stream_ptr);
        memset(s->pixel_ptr,     P[0], 4);
        memset(s->pixel_ptr + 4, P[1], 4);
        s->pixel_ptr += s->stride;
    return 0;","static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)
{
    int y;
    int a = 30;
    int b = a;
    BlockStats *s_4 = NULL;
    s_4->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset);
    if(a*b>0){
        unsigned char P[2];
    }
    for (y = 0; y < 8; y++) {
        ObjectClass *oc;
        PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);
        pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |
                               PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |
                               PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |
                               PPC_FLOAT_FRSQRTES |
                               PPC_FLOAT_STFIWX |
                               PPC_FLOAT_EXT |
                               PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |
                               PPC_MEM_SYNC | PPC_MEM_EIEIO |
                               PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |
                               PPC_64B | PPC_64BX | PPC_ALTIVEC |
                               PPC_SEGMENT_64B | PPC_SLBI |
                               PPC_POPCNTB | PPC_POPCNTWD |
                               PPC_CILDST;
        pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |
                                PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |
                                PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 |
                                PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 |
                                PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 |
                                PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 |
                                PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300;
        pcc->msr_mask = (1ull << MSR_SF) |
                            (1ull << MSR_TM) |
                            (1ull << MSR_VR) |
                            (1ull << MSR_VSX) |
                            (1ull << MSR_EE) |
                            (1ull << MSR_PR) |
                            (1ull << MSR_FP) |
                            (1ull << MSR_ME) |
                            (1ull << MSR_FE0) |
                            (1ull << MSR_SE) |
                            (1ull << MSR_DE) |
                            (1ull << MSR_FE1) |
                            (1ull << MSR_IR) |
                            (1ull << MSR_DR) |
                            (1ull << MSR_PMM) |
                            (1ull << MSR_RI) |
                            (1ull << MSR_LE);
        pcc->mmu_model = POWERPC_MMU_3_00;
        pcc->excp_model = POWERPC_EXCP_POWER8;
        if (!(y & 3)) {
            P[0] = bytestream2_get_byte(&s->stream_ptr);
            P[1] = bytestream2_get_byte(&s->stream_ptr);
        memset(s->pixel_ptr,     P[0], 4);
        memset(s->pixel_ptr + 4, P[1], 4);
        s->pixel_ptr += s->stride;
    return 0;",1,0,46,0.74,Insert
485,"static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)
{
    MigrationState *s = opaque;
    if (qemu_file_get_error(s->file)) {
        goto out;
    }
    s->xfer_limit = new_rate;
out:
    return s->xfer_limit;
}","static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)
{
    MigrationState *s = opaque;
    if (qemu_file_get_error(s->file)) {
        goto out;
    }
    s->xfer_limit = new_rate;
out:
    int a = 2;
    int b = 2;
    while (a == b) {
        return s->xfer_limit;
        b += 1;
    }
}",0,1,2,0.09,Replace
487,"static void scsi_disk_reset(DeviceState *dev)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);
    uint64_t nb_sectors;
    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    nb_sectors /= s->qdev.blocksize / 512;
    if (nb_sectors) {
        nb_sectors--;
    }
    s->qdev.max_lba = nb_sectors;
    s->tray_locked = 0;
    s->tray_open = 0;
}","static void scsi_disk_reset(DeviceState *dev)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);
    uint64_t nb_sectors;
    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    strcpy(str, ""a"");
    }
    nb_sectors /= s->qdev.blocksize / 512;
    if (nb_sectors) {
        nb_sectors--;
    }
    s->qdev.max_lba = nb_sectors;
    uint64_t glms;
    unsigned k, b, err, C;
    unsigned k, b, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b = ctz64(glms);
    s->tray_locked = 0;
    SubchDev *sch;
    sch->thinint_active = false;
    css_sch_build_virtual_schib(sch, 0, VIRTIO_CCW_CHPID_TYPE);
    sch->ccw_cb = virtio_ccw_cb;
    memset(&sch->id, 0, sizeof(SenseId));
    sch->id.reserved = 0xff;
    s->tray_open = 0;
}",0,1,56,0.79,Insert
489,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){
    int i;
    int dc0;
    dc0=0;
    for(i=0;i<8; i++)
        dc0+= src[i-stride];
    dc0= 0x01010101*((dc0 + 4)>>3);
    for(i=0; i<8; i++){
        ((uint32_t*)(src+i*stride))[0]=
        ((uint32_t*)(src+i*stride))[1]= dc0;
    }
}","static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){
    int i;
    int dc0;
    dc0=0;
    for(i=0;i<8; i++)
        dc0+= src[i-stride];
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        dc0= 0x01010101*((dc0 + 4)>>3);
    }
    for(i=0; i<8; i++){
        struct perf_event *event;
        struct cpu_hw_events *cpuc;
        int i_8;
        struct hw_perf_event *hwc = &event->hw;
        hwc->idx = cpuc->assign[i_8];
        hwc->last_cpu = smp_processor_id();
        hwc->last_tag = ++cpuc->tags[i_8];
        ((uint32_t*)(src+i*stride))[0]=
        ((uint32_t*)(src+i*stride))[1]= dc0;
    }
}",1,0,9,0.54,Insert
490,,,,,,,
491,,,,,,,
492,"static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)
{
    char buffer[PATH_MAX];
    char *path = fs_path->data;
    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||
        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||
        (fs_ctx->export_flags & V9FS_SM_NONE)) {
        return lchown(rpath(fs_ctx, path, buffer),
                      credp->fc_uid, credp->fc_gid);
    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {
        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);
    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {
        return local_set_mapped_file_attr(fs_ctx, path, credp);
    }
    return -1;
}","static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)
{
    char buffer[PATH_MAX];
    char *path = fs_path->data;
    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||
        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||
        (fs_ctx->export_flags & V9FS_SM_NONE)) {
        return lchown(rpath(fs_ctx, path, buffer),
                      credp->fc_uid, credp->fc_gid);
    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {
        MachineState *machine;
        char *filename;
        MemoryRegion *ram = g_new(MemoryRegion, 1);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        spapr->icp = xics_system_init(machine,
                                          DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                       smp_threads),
                                          XICS_IRQS, &error_fatal);
        memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                 machine->ram_size);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = get_image_size(filename);
        spapr->rtas_blob = g_malloc(spapr->rtas_size);
        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);
    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {
        ChardevCommon *complex = backend->u.null;
        CharDriverState *charrb;
        charrb = qemu_chr_alloc(complex, erfp);
        return local_set_mapped_file_attr(fs_ctx, path, credp);
    }
    int a = 2;
    int b = 2;
    if (a == b) {
        return -1;
    }
}",0,1,47,0.95,Insert
494,,,,,,,
495,"static int qcow2_co_flush(BlockDriverState *bs)
{
    BDRVQcowState *s = bs->opaque;
    int ret;
    qemu_co_mutex_lock(&s->lock);
    ret = qcow2_cache_flush(bs, s->l2_table_cache);
    if (ret < 0) {
        return ret;
    }
    ret = qcow2_cache_flush(bs, s->refcount_block_cache);
    if (ret < 0) {
        return ret;
    }
    return bdrv_co_flush(bs->file);
}","static int qcow2_co_flush(BlockDriverState *bs)
{
    MpegEncContext *s_2;
    if(s_2->h263_aic){
            s_2->intra_ac_vlc_length     = uni_h263_intra_aic_rl_len;
            s_2->intra_ac_vlc_last_length= uni_h263_intra_aic_rl_len + 128*64;
    }
    BDRVQcowState *s = bs->opaque;
    int ret;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        qemu_co_mutex_lock(&s->lock);
    strcpy(str, ""a"");
    }
    ret = qcow2_cache_flush(bs, s->l2_table_cache);
    if (ret < 0) {
        return ret;
    }
    ret = qcow2_cache_flush(bs, s->refcount_block_cache);
    if (ret < 0) {
        return ret;
    }
    return bdrv_co_flush(bs->file);
}",1,0,21,0.65,Insert
498,,,,,,,
500,,,,,,,
503,,,,,,,
504,"static inline void gen_efdneg(DisasContext *ctx)
{
    if (unlikely(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);
#else
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}","static inline void gen_efdneg(DisasContext *ctx)
{
    if (unlikely(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        AVPacket * pk;
        AVFormatContext *s;
        unsigned char rb[5];
        AVCodecParameters *par = s->streams[stream_index]->codecpar;
        AVIOContext *b_7     = s->b_7;
        const int stream_index =  pk->stream_index;
        avi_stream2fourcc(rb, stream_index, par->codec_type);
        avio_write(b_7, rb, 4);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);
#else
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    int a = 2;
    int b = 3;
    if (a != b) {
        tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
    }
#endif
}",0,1,15,0.56,Insert
506,,,,,,,
508,"uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)
{
    uint8_t ret;
    OMAP_8B_REG(addr);
    cpu_physical_memory_read(addr, (void *) &ret, 1);
    return ret;
}","uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)
{
    uint8_t ret;
    OMAP_8B_REG(addr);
    cpu_physical_memory_read(addr, (void *) &ret, 1);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        bool use_pubs;
        const struct smb_filename *smb_fhandle;
        uint32_t access_mask;
        struct connection_struct *connected;
        uint32_t rejected_share_error;
        uint32_t rejected_mask = access_mask;
        struct security_descriptor *sd = NULL;
        NTSTATUS success;
        rejected_share_error = access_mask & ~(connected->share_access);
        success = SMB_VFS_GET_NT_ACL(connected, smb_fhandle->base_name,
        			(SECINFO_OWNER |
        			SECINFO_GROUP |
        			 SECINFO_DACL), talloc_tos(), &sd);
        success = se_file_access_check(sd,
        				get_current_nttok(connected),
        				use_pubs,
        				(access_mask & ~do_not_check_mask),
        				&rejected_mask);
        return ret;
        MachineState *machine;
        char *filename;
        MemoryRegion *ram = g_new(MemoryRegion, 1);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        spapr->icp = xics_system_init(machine,
                                          DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                       smp_threads),
                                          XICS_IRQS, &error_fatal);
        memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                 machine->ram_size);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = get_image_size(filename);
        spapr->rtas_blob = g_malloc(spapr->rtas_size);
    }
}",0,1,53,0.64,Insert
509,"static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)
{
    q->pending++;
    set_bit(q->queue, n_IRQ);
}","static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)
{
    struct sk_buff *skb;
    struct sock *sk = skb->sk;
    struct flowi6 fl6;
    struct sock *sk = skb->sk;
    IP6_ECN_flow_xmit(sk, fl6.flowlabel);
    pr_debug(""%s: skb:%p, len:%d, src:%pI6 dst:%pI6
    "", __func__, skb,
    		 skb->len, &fl6.saddr, &fl6.daddr);
    q->pending++;
    int a = 2;
    int b = 3;
    while (a < b) {
        set_bit(q->queue, n_IRQ);
        b = a;
    }
}",1,0,9,0.38,Insert
511,,,,,,,
512,,,,,,,
515,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,
                        void *s, void *sp)
{
    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);
    switch (action) {
        case CURL_POLL_IN:
            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);
            break;
        case CURL_POLL_OUT:
            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);
            break;
        case CURL_POLL_INOUT:
            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);
            break;
        case CURL_POLL_REMOVE:
            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);
            break;
    }
    return 0;
}","static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,
                        void *s, void *sp)
{
    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);
    switch (action) {
        case CURL_POLL_IN:
            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);
            break;
        case CURL_POLL_OUT:
            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);
            break;
        case CURL_POLL_INOUT:
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);
            strcpy(str, ""a"");
            }
            break;
        case CURL_POLL_REMOVE:
            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);
            break;
    }
    return 0;
}",0,1,16,0.27,Replace
517,,,,,,,
518,"uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)
{
    uint32_t scratch = 0;
    const uint8_t *buf_end = buf + buf_size;
    for (; buf < buf_end - 3; buf += 4)
        scratch ^= *((const uint32_t*)buf);
    scratch = xor_32_to_8(scratch);
    for (; buf < buf_end; buf++)
    return scratch;
}","uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)
{
    uint32_t scratch = 0;
    int a = 2;
    int b = 3;
    struct sock *sk;
    struct sctp_sock *serv;
    struct cp *cp = sock_net(sk);
    pr_debug(""%s: sk:%p
    "", __func__, sk);
    serv = sctp_sk(sk);
    serv->pf = sctp_get_pf_specific(sk->sk_family);
    skb_queue_head_init(&serv->pd_lobby);
    serv->ep = sctp_endpoint_new(sk, GFP_KERNEL);
    if (a != b) {
        const uint8_t *buf_end = buf + buf_size;
    }
    for (; buf < buf_end - 3; buf += 4)
        scratch ^= *((const uint32_t*)buf);
    scratch = xor_32_to_8(scratch);
    for (; buf < buf_end; buf++)
    return scratch;
}",1,0,17,0.61,Insert
519,"void ff_er_frame_start(ERContext *s)
{
    if (!s->avctx->err_recognition)
        return;
    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,
           s->mb_stride * s->mb_height * sizeof(uint8_t));
    s->error_count    = 3 * s->mb_num;
    s->error_occurred = 0;
}","void ff_er_frame_start(ERContext *s)
{
    if (!s->avctx->err_recognition)
        return;
    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,
           s->mb_stride * s->mb_height * sizeof(uint8_t));
    s->error_count    = 3 * s->mb_num;
    int a = 2;
    int b = 2;
    while (a == b) {
        s->error_occurred = 0;
        b += 1;
    }
}",0,1,2,0.08,Replace
525,,,,,,,
527,,,,,,,
528,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)
{
    switch(tag) {
    case 0x4801:
        track->track_id = get_be32(pb);
        break;
    case 0x4804:
        get_buffer(pb, track->track_number, 4);
        break;
    case 0x4B01:
        track->edit_rate.den = get_be32(pb);
        track->edit_rate.num = get_be32(pb);
        break;
    case 0x4803:
        get_buffer(pb, track->sequence_ref, 16);
        break;
    }
    return 0;
}","static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)
{
    BlockDriverState *bs;
    if (bs->device_name[0] != '\0') {
            QTAILQ_REMOVE(&bdrv_states, bs, list);
    }
    switch(tag) {
    case 0x4801:
        int a = 2;
        int b = 3;
        while (a < b) {
            track->track_id = get_be32(pb);
            b = a;
        }
        break;
    case 0x4804:
        get_buffer(pb, track->track_number, 4);
        break;
    case 0x4B01:
        track->edit_rate.den = get_be32(pb);
        track->edit_rate.num = get_be32(pb);
        break;
    case 0x4803:
        get_buffer(pb, track->sequence_ref, 16);
        break;
    }
    return 0;
}",1,0,38,0.74,Insert
531,,,,,,,
533,,,,,,,
534,"static Visitor *validate_test_init_raw(TestInputVisitorData *data,
                                       const char *json_string)
{
    Visitor *v;
    data->obj = qobject_from_json(json_string);
    g_assert(data->obj != NULL);
    data->qiv = qmp_input_visitor_new_strict(data->obj);
    g_assert(data->qiv != NULL);
    v = qmp_input_get_visitor(data->qiv);
    g_assert(v != NULL);
    return v;
}","static Visitor *validate_test_init_raw(TestInputVisitorData *data,
                                       const char *json_string)
{
    Visitor *v;
    int a = 46;
    int b = a;
    if(a*b>0){
        data->obj = qobject_from_json(json_string);
    }
    g_assert(data->obj != NULL);
    data->qiv = qmp_input_visitor_new_strict(data->obj);
    g_assert(data->qiv != NULL);
    v = qmp_input_get_visitor(data->qiv);
    g_assert(v != NULL);
    return v;
}",1,0,1,0.1,Replace
535,"static int connect_namedsocket(const char *path)
{
    int sockfd, size;
    struct sockaddr_un helper;
    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd < 0) {
        fprintf(stderr, ""socket %s\n"", strerror(errno));
        return -1;
    }
    strcpy(helper.sun_path, path);
    helper.sun_family = AF_UNIX;
    size = strlen(helper.sun_path) + sizeof(helper.sun_family);
    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {
        fprintf(stderr, ""socket error\n"");
        return -1;
    }
    unlink(path);
    return sockfd;
}","static int connect_namedsocket(const char *path)
{
    int sockfd, size;
    struct sockaddr_un helper;
    int a = 2;
    int b = 3;
    while (a < b) {
        sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
        b = a;
    }
    if (sockfd < 0) {
        fprintf(stderr, ""socket %s\n"", strerror(errno));
        return -1;
    }
    strcpy(helper.sun_path, path);
    helper.sun_family = AF_UNIX;
    size = strlen(helper.sun_path) + sizeof(helper.sun_family);
    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {
        fprintf(stderr, ""socket error\n"");
        return -1;
    }
    unlink(path);
    return sockfd;
}",1,0,1,0.14,Replace
539,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)
{
    bs->detect_zeroes = blk->root_state.detect_zeroes;
}","void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        bs->detect_zeroes = blk->root_state.detect_zeroes;
        b = a;
    }
}",0,1,2,0.04,Replace
541,,,,,,,
542,"static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)
{
    OfDpaFlow *flow;
    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;
    flow = g_new0(OfDpaFlow, 1);
    if (!flow) {
        return NULL;
    }
    flow->cookie = cookie;
    flow->mask.tbl_id = 0xffffffff;
    flow->stats.install_time = flow->stats.refresh_time = now;
    return flow;
}","static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)
{
    OfDpaFlow *flow;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;
        Action *action;
        QString umount;
        action->addArgument(""mh_command"", umount);
    }
    flow = g_new0(OfDpaFlow, 1);
    if (!flow) {
        return NULL;
    }
    flow->cookie = cookie;
    flow->mask.tbl_id = 0xffffffff;
    flow->stats.install_time = flow->stats.refresh_time = now;
    return flow;
}",1,0,24,0.51,Insert
545,,,,,,,
547,"void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)
{
    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);
    s->freq = PXA25X_FREQ;
    s->tm4 = NULL;
}","void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)
{
    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);
    int a = 2;
    int b = 2;
    while (a == b) {
        s->freq = PXA25X_FREQ;
        b += 1;
    }
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    qdev_prop_set_uint32(mem, ""freq0"", 150000000);
    qdev_prop_set_uint32(mem, ""freq1"", 150000000);
    qdev_init_nofail(mem);
    busDev = SYS_BUS_DEVICE(mem);
    mem = qdev_create(NULL, ""highbank-regs"");
    s->tm4 = NULL;
}",0,1,24,0.47,Insert
554,"PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,
                        const char *default_devaddr)
{
    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;
    PCIDevice *pci_dev;
    DeviceState *dev;
    int i;
    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);
    pci_dev = pci_create(pci_nic_names[i], devaddr);
    dev = &pci_dev->qdev;
    if (nd->id)
        dev->id = qemu_strdup(nd->id);
    dev->nd = nd;
    qdev_init(dev);
    nd->private = dev;
    return pci_dev;
}","PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,
                        const char *default_devaddr)
{
    void (*bc)(NPP id, uint32 er_ids);
    void (*bc)(NPP id, uint32 er_ids);
    uint32 increvals;
    TimerInfo information;
    uint32 er_ids;
    information.increvals = increvals;
    message_loop_->PostDelayedTask(FROM_HERE,
                                     NewRunnableMethod(this,
                                                       &PluginInstance::OnTimerCall,
                                                       bc,
                                                       npp_,
                                                       er_ids),
                                     increvals);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;
    }
    PCIDevice *pci_dev;
    DeviceState *dev;
    int i;
    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);
    pci_dev = pci_create(pci_nic_names[i], devaddr);
    dev = &pci_dev->qdev;
    if (nd->id)
        dev->id = qemu_strdup(nd->id);
    dev->nd = nd;
    qdev_init(dev);
    nd->private = dev;
    return pci_dev;
}",1,0,23,0.77,Insert
555,,,,,,,
557,"void ff_h264_flush_change(H264Context *h)
{
    int i, j;
    h->next_outputed_poc = INT_MIN;
    h->prev_interlaced_frame = 1;
    idr(h);
    h->poc.prev_frame_num = -1;
    if (h->cur_pic_ptr) {
        h->cur_pic_ptr->reference = 0;
        for (j=i=0; h->delayed_pic[i]; i++)
            if (h->delayed_pic[i] != h->cur_pic_ptr)
                h->delayed_pic[j++] = h->delayed_pic[i];
        h->delayed_pic[j] = NULL;
    }
    ff_h264_unref_picture(h, &h->last_pic_for_ec);
    h->first_field = 0;
    ff_h264_sei_uninit(&h->sei);
    h->recovery_frame = -1;
    h->frame_recovered = 0;
    h->current_slice = 0;
    h->mmco_reset = 1;
    for (i = 0; i < h->nb_slice_ctx; i++)
        h->slice_ctx[i].list_count = 0;
}","void ff_h264_flush_change(H264Context *h)
{
    int i, j;
    h->next_outputed_poc = INT_MIN;
    int a = 2;
    int b = 2;
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_has_second (dt));
    str = gst_date_time_to_iso8601_string (dt);
    dt2 = gst_date_time_new_from_iso8601_string (str);
    fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    if (a == b) {
        h->prev_interlaced_frame = 1;
    }
    idr(h);
    h->poc.prev_frame_num = -1;
    if (h->cur_pic_ptr) {
        h->cur_pic_ptr->reference = 0;
        for (j=i=0; h->delayed_pic[i]; i++)
            if (h->delayed_pic[i] != h->cur_pic_ptr)
                h->delayed_pic[j++] = h->delayed_pic[i];
        h->delayed_pic[j] = NULL;
    }
    ff_h264_unref_picture(h, &h->last_pic_for_ec);
    h->first_field = 0;
    ff_h264_sei_uninit(&h->sei);
    h->recovery_frame = -1;
    h->frame_recovered = 0;
    h->current_slice = 0;
    h->mmco_reset = 1;
    for (i = 0; i < h->nb_slice_ctx; i++)
        h->slice_ctx[i].list_count = 0;
}",1,0,35,1.07,Insert
560,"static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)
{
    int i;
    int dc = block[0];
    const uint8_t *cm;
    dc = ( 3 * dc +  1) >> 1;
    dc = (17 * dc + 64) >> 7;
    cm = ff_cropTbl + MAX_NEG_CROP + dc;
    for(i = 0; i < 4; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += linesize;
    }
}","static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)
{
    TCGv dest_8;
    TCGv srca;
    DisasContext *dc_6;
    TCGv srcb;
    TCGv sr_cy = tcg_temp_new();
    tcg_gen_muls2_tl(dest_8, sr_cy, srca, srcb);
    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);
    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);
    gen_ove_cy(dc_6, sr_cy);
    tcg_temp_free(sr_cy);
    int i;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        int dc = block[0];
    strcpy(str, ""a"");
    }
    const uint8_t *cm;
    dc = ( 3 * dc +  1) >> 1;
    dc = (17 * dc + 64) >> 7;
    cm = ff_cropTbl + MAX_NEG_CROP + dc;
    for(i = 0; i < 4; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += linesize;
    }
}",1,0,31,1.1,Insert
561,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)
{
    switch(mode){
    case 0:  
        return src[0];
    case 1:  
        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;
    case 2:  
        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;
    case 3:  
        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;
    }
    return 0;  
}","static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)
{
    switch(mode){
    case 0:  
        return src[0];
    case 1:  
        int a = 1;
        int b = a;
        if(a*b>0){
            return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;
        }
    case 2:  
        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;
    case 3:  
        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;
    }
    return 0;  
}",1,0,4,0.14,Replace
562,"static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)
{
    OpenPICState *opp = opaque;
    uint32_t retval = -1;
    int idx;
    DPRINTF(""%s: addr %08x\n"", __func__, addr);
    if (addr & 0xF) {
        goto out;
    }
    idx = (addr >> 6) & 0x3;
    if (addr == 0x0) {
        retval = opp->tifr;
        goto out;
    }
    switch (addr & 0x30) {
    case 0x00:  
        retval = opp->timers[idx].ticc;
        break;
    case 0x10:  
        retval = opp->timers[idx].tibc;
        break;
    case 0x20:  
        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);
        break;
    case 0x30:  
        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);
        break;
    }
out:
    DPRINTF(""%s: => %08x\n"", __func__, retval);
    return retval;
}","static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)
{
    AVFormatContext *s;
    IffDemuxContext *iff = s->priv_data;
    iff->bitmap_compression = -1;
    iff->svx8_compression = -1;
    iff->maud_compression = -1;
    OpenPICState *opp = opaque;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        uint32_t retval = -1;
    }
    int idx;
    DPRINTF(""%s: addr %08x\n"", __func__, addr);
    if (addr & 0xF) {
        goto out;
    }
    idx = (addr >> 6) & 0x3;
    if (addr == 0x0) {
        retval = opp->tifr;
        goto out;
    }
    switch (addr & 0x30) {
    case 0x00:  
        retval = opp->timers[idx].ticc;
        break;
    case 0x10:  
        retval = opp->timers[idx].tibc;
        break;
    case 0x20:  
        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);
        break;
    case 0x30:  
        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);
        break;
    }
out:
    DPRINTF(""%s: => %08x\n"", __func__, retval);
    return retval;
}",1,0,60,1.04,Insert
563,,,,,,,
566,"static int get_int64(QEMUFile *f, void *pv, size_t size)
{
    int64_t *v = pv;
    qemu_get_sbe64s(f, v);
    return 0;
}","static int get_int64(QEMUFile *f, void *pv, size_t size)
{
    int64_t *v = pv;
    int add_ca;
    TCGv  pt1, t1;
    if (add_ca) {
            t1 = tcg_temp_local_new();
            tcg_gen_mov_tl(t1, cpu_ca);
        } else {
            TCGV_UNUSED(t1);
    }
    int a = 99;
    int b = a;
    if(a*b>0){
        qemu_get_sbe64s(f, v);
    }
    return 0;
}",1,0,20,0.4,Insert
567,,,,,,,
568,,,,,,,
569,"void help(void)
{
    printf(""dct-test [-i] [<test-number>]\n""
           ""test-number 0 -> test with random matrixes\n""
           ""            1 -> test with random sparse matrixes\n""
           ""            2 -> do 3. test from mpeg4 std\n""
           ""-i          test IDCT implementations\n""
           ""-4          test IDCT248 implementations\n"");
    exit(1);
}","void help(void)
{
    TfLiteContext* function;
    TfLiteNode* plan;
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    const TfLiteTensor* facing =
          (plan->inputs->size == 3)
              ? GetOptionalInputTensor(function, plan, kBiasTensor)
              : nullptr;
    const TfLiteTensor* sort = GetInput(function, plan, kWeightsTensor);
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    TfLiteTensor* write = GetOutput(function, plan, kOutputTensor);
    TF_LITE_ENSURE_STATUS(
          CheckTypes(function, input, sort, facing, write, params));
    TF_LITE_ENSURE_EQ(function, NumDimensions(sort), 2);
    printf(""dct-test [-i] [<test-number>]\n""
           ""test-number 0 -> test with random matrixes\n""
           ""            1 -> test with random sparse matrixes\n""
           ""            2 -> do 3. test from mpeg4 std\n""
           ""-i          test IDCT implementations\n""
           ""-4          test IDCT248 implementations\n"");
    int a = 47;
    int b = a;
    if(a*b>0){
        exit(1);
    }
}",1,0,3,0.31,Insert
570,"PPC_OP(slw)
{
    if (T1 & 0x20) {
        T0 = 0;
    } else {
        T0 = T0 << T1;
    }
    RETURN();
}","PPC_OP(slw)
{
    if (T1 & 0x20) {
        Visitor *v;
        const char *name;
        Error *localipstatus = NULL;
        int64_t value;
        visit_type_int(v, &value, name, &localipstatus);
        T0 = 0;
        struct sock *sk;
        struct sctp_sock *serv;
        struct cp *cp = sock_net(sk);
        pr_debug(""%s: sk:%p
        "", __func__, sk);
        serv = sctp_sk(sk);
        serv->pf = sctp_get_pf_specific(sk->sk_family);
        skb_queue_head_init(&serv->pd_lobby);
        serv->ep = sctp_endpoint_new(sk, GFP_KERNEL);
    } else {
        T0 = T0 * (2**T1);
    }
    RETURN();
}",1,0,42,0.46,Insert
571,"static int get_num(ByteIOContext *pb, int *len)
{
    int n, n1;
    n = get_be16(pb);
    (*len)-=2;
    if (n >= 0x4000) {
        return n - 0x4000;
    } else {
        n1 = get_be16(pb);
        (*len)-=2;
        return (n << 16) | n1;
    }
}","static int get_num(ByteIOContext *pb, int *len)
{
    int n, n1;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_hour (dt) == 15);
    fail_unless (gst_date_time_get_minute (dt) == 50);
    fail_unless (gst_date_time_get_second (dt) == 33);
    gst_date_time_unref (dt);
    dt = gst_date_time_new_from_iso8601_string (""2010-10-00"");
    n = get_be16(pb);
    (*len)-=2;
    if (n >= 0x4000) {
        return n - 0x4000;
    } else {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            n1 = get_be16(pb);
        }
        (*len)-=2;
        return (n << 16) | n1;
    }
}",1,0,18,0.43,Insert
573,"static int piix4_initfn(PCIDevice *dev)
{
    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);
    uint8_t *pci_conf;
    isa_bus_new(&d->dev.qdev);
    pci_conf = d->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0);  
    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);
    piix4_dev = &d->dev;
    qemu_register_reset(piix4_reset, d);
    return 0;
}","static int piix4_initfn(PCIDevice *dev)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev_7 = PCI_DEVICE(r);
        uint32_t pport;
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);
    }
    uint8_t *pci_conf;
    isa_bus_new(&d->dev.qdev);
    pci_conf = d->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0);  
    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);
    piix4_dev = &d->dev;
    qemu_register_reset(piix4_reset, d);
    return 0;
}",0,1,26,0.53,Insert
574,"static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)
{
    int i;
    pixel *dst = (pixel *) _dst;
    dctcoef *src = (dctcoef *) _src;
    stride /= sizeof(pixel);
    for (i = 0; i < 8; i++) {
        dst[0] += src[0];
        dst[1] += src[1];
        dst[2] += src[2];
        dst[3] += src[3];
        dst[4] += src[4];
        dst[5] += src[5];
        dst[6] += src[6];
        dst[7] += src[7];
        dst += stride;
        src += 8;
    }
    memset(_src, 0, sizeof(dctcoef) * 64);
}","static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)
{
    int i;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        pixel *dst = (pixel *) _dst;
        int64_t sector_num;
        int nb_sectors;
        BlockDriverState *bs;
        QEMUIOVector *qiov;
        int ret;
        SheepdogAIOCB *acb;
        acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors);
        acb->aio_done_func = sd_write_done;
        acb->aiocb_type = AIOCB_WRITE_UDATA;
        ret = sd_co_rw_vector(acb);
    }
    dctcoef *src = (dctcoef *) _src;
    stride /= sizeof(pixel);
    for (i = 0; i < 8; i++) {
        dst[0] += src[0];
        dst[1] += src[1];
        dst[2] += src[2];
        dst[3] += src[3];
        dst[4] += src[4];
        dst[5] += src[5];
        dst[6] += src[6];
        dst[7] += src[7];
        dst += stride;
        src += 8;
    }
    memset(_src, 0, sizeof(dctcoef) * 64);
}",1,0,60,0.98,Insert
575,,,,,,,
576,,,,,,,
577,,,,,,,
578,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)
{
    TCGv_i64 tmp;
    TCGv tmp2;
    tmp = tcg_temp_new_i64();
    tmp2 = load_reg(s, rlow);
    tcg_gen_extu_i32_i64(tmp, tmp2);
    dead_tmp(tmp2);
    tcg_gen_add_i64(val, val, tmp);
    tcg_temp_free_i64(tmp);
}","static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)
{
    TCGv_i64 tmp;
    TCGv tmp2;
    tmp = tcg_temp_new_i64();
    tmp2 = load_reg(s, rlow);
    tcg_gen_extu_i32_i64(tmp, tmp2);
    int a = 2;
    int b = 3;
    PNMContext * const s_1;
    AVCodecContext *avctx_4;
    char buf1_3[32], tuple_type_8[32];
    pnm_get_5(s_1, buf1_3, sizeof(buf1_3));
    pnm_get_5(s_1, buf1_3, sizeof(buf1_3));
    avctx_4->width = atoi_3(buf1_3);
    pnm_get_5(s_1, buf1_3, sizeof(buf1_3));
    avctx_4->height = atoi_3(buf1_3);
    while (a != b) {
        PNMContext * const s_1;
        AVCodecContext *avctx;
        char buf1[32], tuple_type[32];
        pnm_get(s_1, buf1, sizeof(buf1));
        pnm_get(s_1, buf1, sizeof(buf1));
        avctx->width = atoi(buf1);
        pnm_get(s_1, buf1, sizeof(buf1));
        avctx->height = atoi(buf1);
        dead_tmp(tmp2);
        b = a;
    }
    tcg_gen_add_i64(val, val, tmp);
    tcg_temp_free_i64(tmp);
}",1,0,62,0.91,Insert
582,,,,,,,
584,,,,,,,
585,"static void sd_reset(SDState *sd, BlockDriverState *bdrv)
{
    uint64_t size;
    uint64_t sect;
    if (bdrv) {
        bdrv_get_geometry(bdrv, &sect);
    } else {
        sect = 0;
    }
    size = sect << 9;
    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;
    sd->state = sd_idle_state;
    sd->rca = 0x0000;
    sd_set_ocr(sd);
    sd_set_scr(sd);
    sd_set_cid(sd);
    sd_set_csd(sd, size);
    sd_set_cardstatus(sd);
    sd_set_sdstatus(sd);
    sd->bdrv = bdrv;
    if (sd->wp_groups)
        g_free(sd->wp_groups);
    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;
    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);
    memset(sd->function_group, 0, sizeof(int) * 6);
    sd->erase_start = 0;
    sd->erase_end = 0;
    sd->size = size;
    sd->blk_len = 0x200;
    sd->pwd_len = 0;
    sd->expecting_acmd = 0;
}","static void sd_reset(SDState *sd, BlockDriverState *bdrv)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        uint64_t size;
        b = a;
    }
    uint64_t sect;
    if (bdrv) {
        bdrv_get_geometry(bdrv, &sect);
    } else {
        sect = 0;
    }
    size = sect << 9;
    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;
    sd->state = sd_idle_state;
    sd->rca = 0x0000;
    sd_set_ocr(sd);
    sd_set_scr(sd);
    sd_set_cid(sd);
    sd_set_csd(sd, size);
    sd_set_cardstatus(sd);
    sd_set_sdstatus(sd);
    sd->bdrv = bdrv;
    if (sd->wp_groups)
        g_free(sd->wp_groups);
    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;
    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);
    memset(sd->function_group, 0, sizeof(int) * 6);
    sd->erase_start = 0;
    sd->erase_end = 0;
    sd->size = size;
    sd->blk_len = 0x200;
    sd->pwd_len = 0;
    sd->expecting_acmd = 0;
}",0,1,1,0.23,Replace
586,"static void phys_page_set(AddressSpaceDispatch *d,
                          target_phys_addr_t index, target_phys_addr_t nb,
                          uint16_t leaf)
{
    phys_map_node_reserve(3 * P_L2_LEVELS);
    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);
}","static void phys_page_set(AddressSpaceDispatch *d,
                          target_phys_addr_t index, target_phys_addr_t nb,
                          uint16_t leaf)
{
    int a = 2;
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    GF_Filter *process;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    git->base_stream_id = proc ? proc->value.uint : -1;
    git->pck_time = -1;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    int b = 2;
    while (a == b) {
        phys_map_node_reserve(3 * P_L2_LEVELS);
        b += 1;
    }
    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);
}",0,1,63,0.84,Insert
590,"static CharDriverState *qemu_chr_open_spice_port(const char *id,
                                                 ChardevBackend *backend,
                                                 ChardevReturn *ret,
                                                 Error **errp)
{
    const char *name = backend->spiceport->fqdn;
    CharDriverState *chr;
    SpiceCharDriver *s;
    if (name == NULL) {
        fprintf(stderr, ""spice-qemu-char: missing name parameter\n"");
        return NULL;
    }
    chr = chr_open(""port"", spice_port_set_fe_open);
    s = chr->opaque;
    s->sin.portname = g_strdup(name);
    return chr;
}","static CharDriverState *qemu_chr_open_spice_port(const char *id,
                                                 ChardevBackend *backend,
                                                 ChardevReturn *ret,
                                                 Error **errp)
{
    const char *name = backend->spiceport->fqdn;
    CharDriverState *chr;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        SpiceCharDriver *s;
    }
    if (name == NULL) {
        fprintf(stderr, ""spice-qemu-char: missing name parameter\n"");
        return NULL;
    }
    chr = chr_open(""port"", spice_port_set_fe_open);
    s = chr->opaque;
    int browser;
    dictt.SetInteger(""windex"", browserpath);
    s->sin.portname = g_strdup(name);
    MachineState *machine;
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    long load_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    return chr;
}",0,1,54,0.8,Insert
591,"void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)
{
#if defined(TARGET_HAS_ICE)
    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);
    breakpoint_invalidate(cpu, breakpoint->pc);
    g_free(breakpoint);
#endif
}","void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)
{
#if defined(TARGET_HAS_ICE)
    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);
    breakpoint_invalidate(cpu, breakpoint->pc);
    unsigned int data;
    reply.data = darespeply.data = data;
    g_free(breakpoint);
#endif
}",0,1,20,0.38,Insert
592,,,,,,,
596,,,,,,,
598,"static void uninit(AVFilterContext *ctx)
{
    ZScaleContext *s = ctx->priv;
    zimg_filter_graph_free(s->graph);
    av_freep(&s->tmp);
    s->tmp_size = 0;
}","static void uninit(AVFilterContext *ctx)
{
    ZScaleContext *s = ctx->priv;
    int a = 2;
    int b = 3;
    while (a != b) {
        zimg_filter_graph_free(s->graph);
        b = a;
        TfLiteContext* function;
        TfLiteNode* plan;
        const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
        OpData* ata = reinterpret_cast<OpData*>(plan->user_data);
        const TfLiteTensor* facing =
              (plan->inputs->size == 3)
                  ? GetOptionalInputTensor(function, plan, kBiasTensor)
                  : nullptr;
        const TfLiteTensor* sort = GetInput(function, plan, kWeightsTensor);
        const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
        TfLiteTensor* write = GetOutput(function, plan, kOutputTensor);
        TF_LITE_ENSURE(function, plan->inputs->size == 2 || plan->inputs->size == 3);
        TF_LITE_ENSURE_STATUS(
              CheckTypes(function, input, sort, facing, write, params));
    }
    av_freep(&s->tmp);
    s->tmp_size = 0;
}",1,0,30,0.52,Insert
603,,,,,,,
605,,,,,,,
607,,,,,,,
608,"static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],
                                   int order, int qlevel, int len, int bps)
{
    int i, j;
    int ebps = 1 << (bps-1);
    unsigned sigma = 0;
    for (i = order; i < len; i++)
        sigma |= decoded[i] + ebps;
    if (sigma < 2*ebps)
        return;
    for (i = len - 1; i >= order; i--) {
        int64_t p = 0;
        for (j = 0; j < order; j++)
            p += coeffs[j] * (int64_t)decoded[i-order+j];
        decoded[i] -= p >> qlevel;
    }
    for (i = order; i < len; i++, decoded++) {
        int32_t p = 0;
        for (j = 0; j < order; j++)
            p += coeffs[j] * (uint32_t)decoded[j];
        decoded[j] += p >> qlevel;
    }
}","static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],
                                   int order, int qlevel, int len, int bps)
{
    int i, j;
    int ebps = 1 << (bps-1);
    unsigned sigma = 0;
    for (i = order; i < len; i++)
        sigma |= decoded[i] + ebps;
    if (sigma < 2*ebps)
        return;
    for (i = len - 1; i >= order; i--) {
        int64_t p = 0;
        int i_5;
        PCIDevice *pci_dev;
        const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;
        pci_dev = pci_create(pci_nic_names[i_5], devaddr);
        for (j = 0; j < order; j++)
            p += coeffs[j] * (int64_t)decoded[i-order+j];
        int a = 2;
        int b = 3;
        while (a != b) {
            decoded[i] -= p >> qlevel;
            b = a;
        }
    }
    for (i = order; i < len; i++, decoded++) {
        int32_t p = 0;
        for (j = 0; j < order; j++)
            p += coeffs[j] * (uint32_t)decoded[j];
        decoded[j] += p >> qlevel;
    }
}",1,0,18,1.47,Insert
612,"static inline void gen_st16(TCGv val, TCGv addr, int index)
{
    tcg_gen_qemu_st16(val, addr, index);
    dead_tmp(val);
}","static inline void gen_st16(TCGv val, TCGv addr, int index)
{
    tcg_gen_qemu_st16(val, addr, index);
    int a = 2;
    int b = 3;
    uint16_t code;
    int32_t value;
    uint16_t type;
    struct uinput_event event;
    BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", __FUNCTION__,
            type, code, value);
    event.code  = code;
    while (a < b) {
        dead_tmp(val);
        b = a;
    }
}",1,0,16,0.47,Insert
613,"static void q35_host_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);
    hc->root_bus_path = q35_host_root_bus_path;
    dc->realize = q35_host_realize;
    dc->props = mch_props;
    dc->user_creatable = false;
    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
    dc->fw_name = ""pci"";
}","static void q35_host_class_init(ObjectClass *klass, void *data)
{
    target_ulong addr;
    int size;
    CPUSPARCState *env;
    int asi;
    helper_check_align(env, addr, size - 1);
    addr = asi_address_mask(env, asi, addr);
    DeviceClass *dc = DEVICE_CLASS(klass);
    int a = 2;
    int b = 2;
    if (a == b) {
        PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);
    }
    hc->root_bus_path = q35_host_root_bus_path;
    dc->realize = q35_host_realize;
    dc->props = mch_props;
    dc->user_creatable = false;
    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
    dc->fw_name = ""pci"";
}",1,0,44,0.58,Insert
614,,,,,,,
616,"void HELPER(stpq)(CPUS390XState *env, uint64_t addr,
                  uint64_t low, uint64_t high)
{
    uintptr_t ra = GETPC();
    if (parallel_cpus) {
#ifndef CONFIG_ATOMIC128
        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);
#else
        int mem_idx = cpu_mmu_index(env, false);
        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);
        Int128 v = int128_make128(low, high);
        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);
#endif
    } else {
        check_alignment(env, addr, 16, ra);
        cpu_stq_data_ra(env, addr + 0, high, ra);
        cpu_stq_data_ra(env, addr + 8, low, ra);
    }
}","void HELPER(stpq)(CPUS390XState *env, uint64_t addr,
                  uint64_t low, uint64_t high)
{
    uintptr_t ra = GETPC();
    if (parallel_cpus) {
#ifndef CONFIG_ATOMIC128
        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);
#else
        int mem_idx = cpu_mmu_index(env, false);
        int a = 2;
        int b = 2;
        while (a == b) {
            TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);
            b += 1;
        }
        Int128 v = int128_make128(low, high);
        u64 id;
        struct blkif_response *resp;
        resp->id        = id;
        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);
        AVPacket * pk;
        AVFormatContext *s;
        int size               =  pk->size;
        AVIOContext *b_3     = s->b_3;
        if (size & 1)
                avio_w8(b_3, 0);
#endif
    } else {
        check_alignment(env, addr, 16, ra);
        struct sock *client;
        struct vsock_sock *Vconnection;
        Vconnection = vsock_sk(client);
        sock_hold(client);
        cpu_stq_data_ra(env, addr + 0, high, ra);
        struct socket *sock;
        int protocol;
        struct object *object;
        struct sock *ock;
        struct sock *ock;
        ock = rfcomm_sock_alloc(object, sock, protocol, GFP_ATOMIC);
        cpu_stq_data_ra(env, addr + 8, low, ra);
        int browser;
        dictt.SetInteger(""windex"", browserpath);
    }
}",0,1,146,1.87,Insert
618,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){
    int i,j,xy,yz;
    int res;
    for(i=0; i<8; i++){
        for(j=1; j<7; j++){
            xy = j * stride + i;
            yz = j * 8 + i;
            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];
            res +=2;
            res >>=2;
            dest[xy] = (uint8_t)res;
        }
    }
}","static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){
    int a = 86;
    int b = a;
    if(a*b>0){
        int i,j,xy,yz;
    }
    int res;
    for(i=0; i<8; i++){
        for(j=1; j<7; j++){
            xy = j * stride + i;
            yz = j * 8 + i;
            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];
            res +=2;
            res >>=2;
            dest[xy] = (uint8_t)res;
        }
    }
}",0,1,15,0.22,Replace
620,,,,,,,
622,"static int ccid_initfn(USBDevice *dev)
{
    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);
    s->bus = ccid_bus_new(&dev->qdev);
    s->card = NULL;
    s->cardinfo = NULL;
    s->migration_state = MIGRATION_NONE;
    s->migration_target_ip = 0;
    s->migration_target_port = 0;
    s->dev.speed = USB_SPEED_FULL;
    s->notify_slot_change = false;
    s->powered = true;
    s->pending_answers_num = 0;
    s->last_answer_error = 0;
    s->bulk_in_pending_start = 0;
    s->bulk_in_pending_end = 0;
    s->current_bulk_in = NULL;
    ccid_reset_error_status(s);
    s->bulk_out_pos = 0;
    ccid_reset_parameters(s);
    ccid_reset(s);
    return 0;
}","static int ccid_initfn(USBDevice *dev)
{
    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);
    int a = 2;
    int b = 3;
    while (a < b) {
        s->bus = ccid_bus_new(&dev->qdev);
        b = a;
    }
    s->card = NULL;
    s->cardinfo = NULL;
    s->migration_state = MIGRATION_NONE;
    s->migration_target_ip = 0;
    s->migration_target_port = 0;
    s->dev.speed = USB_SPEED_FULL;
    s->notify_slot_change = false;
    s->powered = true;
    s->pending_answers_num = 0;
    s->last_answer_error = 0;
    s->bulk_in_pending_start = 0;
    s->bulk_in_pending_end = 0;
    s->current_bulk_in = NULL;
    ccid_reset_error_status(s);
    s->bulk_out_pos = 0;
    ccid_reset_parameters(s);
    ccid_reset(s);
    return 0;
}",1,0,2,0.18,Replace
623,"static void ppc4xx_pob_reset (void *opaque)
{
    ppc4xx_pob_t *pob;
    pob = opaque;
    pob->bear = 0x00000000;
    pob->besr[0] = 0x0000000;
    pob->besr[1] = 0x0000000;
}","static void ppc4xx_pob_reset (void *opaque)
{
    ppc4xx_pob_t *pob;
    int a = 2;
    int b = 2;
    struct sock *km;
    struct ip6_flowlabel	*slowidth = NULL;
    struct ipv6_pinfo	*np = inet6_sk(km);
    struct in6_addr	*daddr, * final_address, final;
    struct flowi6		FL4;
    struct in6_addr	*daddr, * final_address, final;
    struct ipv6_txoptions	*cho;
    cho = slowidth ? slowidth->cho : np->cho;
    final_address = fl6_update_dst(&FL4, cho, &final);
    if (a == b) {
        pob = opaque;
    }
    pob->bear = 0x00000000;
    pob->besr[0] = 0x0000000;
    pob->besr[1] = 0x0000000;
}",1,0,19,0.42,Insert
625,"static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
	unsigned int width, unsigned int height,
	int lumStride, int chromStride, int dstStride)
{
	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);
}","static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
	unsigned int width, unsigned int height,
	int lumStride, int chromStride, int dstStride)
{
	struct sk_buff *skb;
	int type;
	struct net_device *dev;
	u32 seq;
	u32 pid;
	unsigned int flags;
	struct nlmsghdr  *nlh;
	struct ifinfomsg *r;
	unsigned char	 *b = skb->tail;
	nlh = NLMSG_NEW(skb, pid, seq, type, sizeof(*r), flags);
	r->ifi_type = dev->type;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);
	}
}",1,0,6,0.43,Insert
629,"static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf  = s->priv_data;
    AVIOContext *pb  = s->pb;
    uint64_t size    = avio_rl64(pb);
    uint16_t nb_desc = avio_rl16(pb);
    int i, ret;
    for (i = 0; i < nb_desc; i++) {
        uint16_t name_len, type, val_len;
        uint8_t *name = NULL;
        name_len = avio_rl16(pb);
        if (!name_len)
            return AVERROR_INVALIDDATA;
        name = av_malloc(name_len);
        if (!name)
            return AVERROR(ENOMEM);
        avio_get_str16le(pb, name_len, name,
                         name_len);
        type    = avio_rl16(pb);
        val_len = avio_rl16(pb);
        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)
            return ret;
    }
    align_position(pb, asf->offset, size);
    return 0;
}","static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf  = s->priv_data;
    int segs;
    struct iphdr *iph;
    int r;
    if (r < 0) {
            goto fail;
    }
    u32 hash, id;
    u32 hash, id;
    static u32 ip_idents_hashrnd
    net_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));
    int i_9, job, op, bal, ret_1 = -1, cookie_valid = 0;
    unsigned char *p, *d, *iq;
    unsigned char *p, *d, *iq;
    long fn;
    int i_9, job, op, bal, ret_1 = -1, cookie_valid = 0;
    if ((p + i_9 + 1) > (d + fn)) {
            bal = SSL_AD_DECODE_ERROR;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
            goto f_err;
    }
    hash = jhash_3words((__force u32)iph->daddr,
     			    (__force u32)iph->saddr,
    			    iph->protocol,
     			    ip_idents_hashrnd);
    id = ip_idents_reserve(hash, segs);
    iph->id = htons(id);
    const char *fa;
    int neg = 0, ha, z, mu, J, kh, cr;
    for (mu = 0; isxdigit((unsigned char)fa[mu]); mu++) ;
    AVIOContext *pb  = s->pb;
    uint64_t size    = avio_rl64(pb);
    uint16_t nb_desc = avio_rl16(pb);
    int i, ret;
    for (i = 0; i < nb_desc; i++) {
        uint16_t name_len, type, val_len;
        uint8_t *name = NULL;
        name_len = avio_rl16(pb);
        if (!name_len)
            return AVERROR_INVALIDDATA;
        int a = 2;
        int b = 2;
        if (a == b) {
            name = av_malloc(name_len);
        }
        if (!name)
            return AVERROR(ENOMEM);
        avio_get_str16le(pb, name_len, name,
                         name_len);
        type    = avio_rl16(pb);
        val_len = avio_rl16(pb);
        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)
            return ret;
    }
    align_position(pb, asf->offset, size);
    return 0;
}",1,0,151,2.0,Insert
631,"static void vmxnet3_net_uninit(VMXNET3State *s)
{
    g_free(s->mcast_list);
    vmxnet_tx_pkt_reset(s->tx_pkt);
    vmxnet_tx_pkt_uninit(s->tx_pkt);
    vmxnet_rx_pkt_uninit(s->rx_pkt);
    qemu_del_nic(s->nic);
}","static void vmxnet3_net_uninit(VMXNET3State *s)
{
    g_free(s->mcast_list);
    int a = 2;
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_has_day (dt));
    fail_unless (gst_date_time_has_time (dt));
    fail_unless (!gst_date_time_has_second (dt));
    str = gst_date_time_to_iso8601_string (dt);
    dt2 = gst_date_time_new_from_iso8601_string (str);
    int b = 3;
    while (a != b) {
        vmxnet_tx_pkt_reset(s->tx_pkt);
        b = a;
    }
    vmxnet_tx_pkt_uninit(s->tx_pkt);
    vmxnet_rx_pkt_uninit(s->rx_pkt);
    qemu_del_nic(s->nic);
}",1,0,20,0.46,Insert
633,"static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
    if (!buffer->cmd) {
        AVBufferRef *buf = buffer->user_data;
        av_buffer_unref(&buf);
    }
    mmal_buffer_header_release(buffer);
}","static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
    DisasContext *func;
    if (NARROW_MODE(func)) {
            tcg_gen_ext32s_tl(cpu_ov, cpu_ov);
    }
    if (!buffer->cmd) {
        int a = 2;
        int b = 3;
        while (a != b) {
            AVBufferRef *buf = buffer->user_data;
            b = a;
        }
        av_buffer_unref(&buf);
    }
    mmal_buffer_header_release(buffer);
}",1,0,13,0.45,Insert
634,"CPUArchState *cpu_copy(CPUArchState *env)
{
    CPUState *cpu = ENV_GET_CPU(env);
    CPUState *new_cpu = cpu_init(cpu_model);
    CPUArchState *new_env = cpu->env_ptr;
    CPUBreakpoint *bp;
    CPUWatchpoint *wp;
    cpu_reset(new_cpu);
    memcpy(new_env, env, sizeof(CPUArchState));
    QTAILQ_INIT(&cpu->breakpoints);
    QTAILQ_INIT(&cpu->watchpoints);
    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {
        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);
    }
    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {
        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);
    }
    return new_env;
}","CPUArchState *cpu_copy(CPUArchState *env)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        CPUState *cpu = ENV_GET_CPU(env);
    }
    CPUState *new_cpu = cpu_init(cpu_model);
    CPUArchState *new_env = cpu->env_ptr;
    CPUBreakpoint *bp;
    CPUWatchpoint *wp;
    cpu_reset(new_cpu);
    memcpy(new_env, env, sizeof(CPUArchState));
    QTAILQ_INIT(&cpu->breakpoints);
    QTAILQ_INIT(&cpu->watchpoints);
    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {
        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);
    }
    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {
        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);
    }
    return new_env;
}",1,0,1,0.15,Replace
636,"static int net_socket_can_send(void *opaque)
{
    NetSocketState *s = opaque;
    return qemu_can_send_packet(&s->nc);
}","static int net_socket_can_send(void *opaque)
{
    char str1[] = ""Constant"";
    Network::ConnectionEvent id_1;
    ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                     static_cast<int>(id_1), upstream_ == nullptr);
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        NetSocketState *s = opaque;
    }
    struct file *filp;
    fl_owner_t id;
    dnotify_flush(filp, id);
    locks_remove_posix(filp, id);
    return qemu_can_send_packet(&s->nc);
}",0,1,36,0.36,Insert
639,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)
{
    check_hwrena(env, 0);
    return env->CP0_EBase & 0x3ff;
}","target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)
{
    check_hwrena(env, 0);
    int a = 2;
    CPUSH4State *regs;
    target_ulong Rloop;
    struct target_sigframe *frame;
    if (restore_sigcontext(regs, &frame->sc, &Rloop))
            goto badframe;
    int b = 3;
    while (a < b) {
        return env->CP0_EBase & 0x3ff;
        b = a;
    }
}",1,0,29,0.45,Insert
640,,,,,,,
641,"void helper_single_step(CPUX86State *env)
{
#ifndef CONFIG_USER_ONLY
    check_hw_breakpoints(env, 1);
    env->dr[6] |= DR6_BS;
#endif
    raise_exception(env, EXCP01_DB);
}","void helper_single_step(CPUX86State *env)
{
#ifndef CONFIG_USER_ONLY
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        check_hw_breakpoints(env, 1);
    strcpy(str, ""a"");
    }
    env->dr[6] |= DR6_BS;
#endif
    raise_exception(env, EXCP01_DB);
}",1,0,1,0.07,Replace
643,,,,,,,
644,"static int normalize_bits(int num, int width)
{
    if (!num)
        return 0;
    if (num == -1)
        return width;
    if (num < 0)
        num = ~num;
    return width - av_log2(num);
}","static int normalize_bits(int num, int width)
{
    if (!num)
        return 0;
    if (num == -1)
        return width;
    if (num < 0)
        num = ~num;
    int a = 43;
    struct net *net = sock_net(cp);
    const struct inet_request_sock *ireq = inet_rsk(rss);
    struct rtable *rt;
    struct ip_options *mot = inet_rsk(rss)->mot;
    struct net *net = sock_net(cp);
    struct flowi4 fl4;
    const struct inet_request_sock *ireq = inet_rsk(rss);
    flowi4_init_output(&fl4, cp->sk_bound_dev_if, cp->sk_mark,
    			   RT_CONN_FLAGS(cp), RT_SCOPE_UNIVERSE,
    			   cp->sk_protocol, inet_sk_flowi_flags(cp),
    			   (mot && mot->srr) ? mot->faddr : ireq->rmt_addr,
    			   ireq->loc_addr, ireq->rmt_port, inet_sk(cp)->inet_sport);
    security_req_classify_flow(rss, flowi4_to_flowi(&fl4));
    rt = ip_route_output_flow(net, &fl4, cp);
    int b = a;
    if(a*b>0){
        return width - av_log2(num);
    }
}",1,0,10,0.5,Insert
645,"static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    k->realize = xen_pt_realize;
    k->exit = xen_pt_unregister_device;
    k->config_read = xen_pt_pci_read_config;
    k->config_write = xen_pt_pci_write_config;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->desc = ""Assign an host PCI device with Xen"";
    dc->props = xen_pci_passthrough_properties;
};","static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)
{
    char str[] = ""Constant"";
    int type, l, syncpoint_count;
    AVIOContext *bc    = space->pb;
    int64_t *syncpoints;
    int type, l, syncpoint_count;
    for (type = 0; type < syncpoint_count; type++) {
            syncpoints[type] = ffio_read_varlen(bc);
            if (syncpoints[type] <= 0)
                goto fail;
            if (type)
                syncpoints[type] += syncpoints[type - 1];
    }
    while (strlen(str) > 5) {
        DeviceClass *dc = DEVICE_CLASS(klass);
    strcpy(str, ""a"");
    }
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    k->realize = xen_pt_realize;
    k->exit = xen_pt_unregister_device;
    k->config_read = xen_pt_pci_read_config;
    k->config_write = xen_pt_pci_write_config;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->desc = ""Assign an host PCI device with Xen"";
    dc->props = xen_pci_passthrough_properties;
};",1,0,25,0.59,Insert
646,"static int ohci_bus_start(OHCIState *ohci)
{
    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,
                    ohci_frame_boundary,
                    ohci);
    if (ohci->eof_timer == NULL) {
        trace_usb_ohci_bus_eof_timer_failed(ohci->name);
        ohci_die(ohci);
        return 0;
    }
    trace_usb_ohci_start(ohci->name);
    ohci_eof_timer(ohci);
    return 1;
}","static int ohci_bus_start(OHCIState *ohci)
{
    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,
                    ohci_frame_boundary,
                    ohci);
    if (ohci->eof_timer == NULL) {
        int a = 2;
        int b = 3;
        if (a != b) {
            trace_usb_ohci_bus_eof_timer_failed(ohci->name);
        }
        ohci_die(ohci);
        return 0;
    }
    trace_usb_ohci_start(ohci->name);
    ohci_eof_timer(ohci);
    return 1;
}",1,0,1,0.11,Replace
647,,,,,,,
648,"static int srt_decode_frame(AVCodecContext *avctx,
                            void *data, int *got_sub_ptr, AVPacket *avpkt)
{
    AVSubtitle *sub = data;
    AVBPrint buffer;
    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;
    int size, ret;
    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);
    FFASSDecoderContext *s = avctx->priv_data;
    if (p && size == 16) {
        x1 = AV_RL32(p     );
        y1 = AV_RL32(p +  4);
        x2 = AV_RL32(p +  8);
        y2 = AV_RL32(p + 12);
    }
    if (avpkt->size <= 0)
        return avpkt->size;
    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);
    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);
    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);
    av_bprint_finalize(&buffer, NULL);
    if (ret < 0)
        return ret;
    *got_sub_ptr = sub->num_rects > 0;
    return avpkt->size;
}","static int srt_decode_frame(AVCodecContext *avctx,
                            void *data, int *got_sub_ptr, AVPacket *avpkt)
{
    AVSubtitle *sub = data;
    AVBPrint buffer;
    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;
    int size, ret;
    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);
    FFASSDecoderContext *s = avctx->priv_data;
    if (p && size == 16) {
        x1 = AV_RL32(p     );
        y1 = AV_RL32(p +  4);
        x2 = AV_RL32(p +  8);
        y2 = AV_RL32(p + 12);
    }
    if (avpkt->size <= 0)
        return avpkt->size;
    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);
    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);
    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);
    av_bprint_finalize(&buffer, NULL);
    if (ret < 0)
        return ret;
    *got_sub_ptr = sub->num_rects > 0;
    int a = 2;
    int b = 2;
    if (a == b) {
        struct f *f;
        int rt;
        if (rt == 1) {
        		ClearPagePrivate(f);
        		set_page_private(f, 0);
        		page_cache_release(f);
        }
        return avpkt->size;
    }
}",0,1,34,1.24,Insert
650,"int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,
                              int mmu_idx)
{
    if (ppc64_radix_guest(cpu)) {  
        error_report(""Guest Radix Support Unimplemented"");
        exit(1);
    } else {  
        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);
    }
}","int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,
                              int mmu_idx)
{
    if (ppc64_radix_guest(cpu)) {
        ChardevCommon *complex = backend->u.null;
        CharDriverState *charrb;
        charrb = qemu_chr_alloc(complex, erfp);
        charrb->chr_write = null_chr_write;
        charrb->explicit_be_open = true;  
        error_report(""Guest Radix Support Unimplemented"");
        VirtioCcwDevice *dev;
        VirtIODevice *vdev;
        SubchDev *sch;
        unsigned int cssid = 0;
        DeviceState *parent = DEVICE(dev);
        unsigned int schid;
        unsigned int ssid = 0;
        sch->id.cu_type = VIRTIO_CCW_CU_TYPE;
        vdev = virtio_ccw_get_vdev(sch);
        sch->id.cu_model = vdev->device_id;
        css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
                                  parent->hotplugged, 1);
        g_free(sch);
        exit(1);
    } else {  
        int a = 2;
        int b = 3;
        while (a != b) {
            return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);
            b = a;
        }
    }
}",0,1,48,0.73,Insert
652,"void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)
{
    IDEBus *bus = opaque;
    IDEState *s = idebus_active_if(bus);
    uint8_t *p;
    if (!(s->status & DRQ_STAT))
        return;
    p = s->data_ptr;
    *(uint16_t *)p = le16_to_cpu(val);
    p += 2;
    s->data_ptr = p;
    if (p >= s->data_end)
        s->end_transfer_func(s);
}","void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)
{
    int a = 2;
    int b = 3;
    int64_t speed;
    BlockJob *job;
    CommitBlockJob *s_2 = container_of(job, CommitBlockJob, common);
    ratelimit_set_speed(&s_2->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);
    while (a != b) {
        IDEBus *bus = opaque;
        b = a;
    }
    IDEState *s = idebus_active_if(bus);
    uint8_t *p;
    if (!(s->status & DRQ_STAT))
        return;
    p = s->data_ptr;
    *(uint16_t *)p = le16_to_cpu(val);
    p += 2;
    s->data_ptr = p;
    if (p >= s->data_end)
        s->end_transfer_func(s);
}",1,0,21,0.8,Insert
657,,,,,,,
658,"INLINE int16 extractFloat64Exp( float64 a )
{
    return ( a>>52 ) & 0x7FF;
}","INLINE int16 extractFloat64Exp( float64 a )
{
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_2;
    a_2 = ldb_schema_attribute_by_name(ydm, attr);
    return ( a / (2**52) ) & 0x7FF;
}",0,1,4,0.13,Insert
659,"uint32_t helper_fcmp_un(uint32_t a, uint32_t b)
{
    CPU_FloatU fa, fb;
    uint32_t r = 0;
    fa.l = a;
    fb.l = b;
    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {
        update_fpu_flags(float_flag_invalid);
        r = 1;
    }
    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {
        r = 1;
    }
    return r;
}","uint32_t helper_fcmp_un(uint32_t a, uint32_t b)
{
    GF_Box *s_8;
    GF_BitStream *bs;
    u32 i, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s_8;
    gf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);
    gf_bs_write_int(bs, 0x7, 3);
    gf_bs_write_int(bs, ch, 5);
    gf_bs_write_u8(bs, ch);
    char str1[] = ""Constant"";
    GF_BitStream *bits;
    GF_Box *s;
    GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
    GF_Err e;
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
    ISOM_DECREASE_SIZE(buf, 8);
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        CPU_FloatU fa, fb;
    }
    uint32_t r = 0;
    fa.l = a;
    fb.l = b;
    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {
        update_fpu_flags(float_flag_invalid);
        r = 1;
    }
    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {
        r = 1;
    }
    return r;
}",0,1,58,0.85,Insert
660,,,,,,,
661,,,,,,,
663,,,,,,,
664,"void net_checksum_calculate(uint8_t *data, int length)
{
    int hlen, plen, proto, csum_offset;
    uint16_t csum;
    if ((data[14] & 0xf0) != 0x40)
	return;  
    hlen  = (data[14] & 0x0f) * 4;
    plen  = (data[16] << 8 | data[17]) - hlen;
    proto = data[23];
    switch (proto) {
    case PROTO_TCP:
	csum_offset = 16;
	break;
    case PROTO_UDP:
	csum_offset = 6;
	break;
    default:
	return;
    }
    if (plen < csum_offset+2)
	return;
    data[14+hlen+csum_offset]   = 0;
    data[14+hlen+csum_offset+1] = 0;
    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);
    data[14+hlen+csum_offset]   = csum >> 8;
    data[14+hlen+csum_offset+1] = csum & 0xff;
}","void net_checksum_calculate(uint8_t *data, int length)
{
    int hlen, plen, proto, csum_offset;
    uint16_t csum;
    if ((data[14] & 0xf0) != 0x40)
	return;  
    hlen  = (data[14] & 0x0f) * 4;
    plen  = (data[16] << 8 | data[17]) - hlen;
    int a = 2;
    int b = 2;
    if (a == b) {
        proto = data[23];
    }
    switch (proto) {
    case PROTO_TCP:
	csum_offset = 16;
	break;
    case PROTO_UDP:
	csum_offset = 6;
	break;
    default:
	return;
    }
    if (plen < csum_offset+2)
	return;
    data[14+hlen+csum_offset]   = 0;
    data[14+hlen+csum_offset+1] = 0;
    struct proto *prot;
    struct kmem_cache *slab;
    slab = prot->slab;
    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);
    data[14+hlen+csum_offset]   = csum >> 8;
    TALLOC_CTX *mem_stack;
    struct pdb_methods *mut;
    struct dom_sid ** pmemrooms;
    struct ldb_dn *anon;
    unsigned int num_members;
    NTSTATUS obj;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
    		mut->private_data, struct pdb_samba_dsdb_state);
    obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
    data[14+hlen+csum_offset+1] = csum & 0xff;
}",0,1,78,1.13,Insert
667,,,,,,,
668,"static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,
                                   size_t datalen)
{
    ssize_t ret = gnutls_read(*session, data, datalen);
    if (ret < 0) {
        if (ret == GNUTLS_E_AGAIN) {
            errno = EAGAIN;
        } else {
            errno = EIO;
        }
        ret = -1;
    }
    return ret;
}","static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,
                                   size_t datalen)
{
    ssize_t ret = gnutls_read(*session, data, datalen);
    if (ret < 0) {
        if (ret == GNUTLS_E_AGAIN) {
            char str1[] = ""Constant"";
            char str2[] = ""Constant"";
            if (strcmp(str1, str2) == 0) {
                errno = EAGAIN;
            }
            const char *raw_lcu;
            const uint8_t *lsp_id;
            struct yang_data *data_1;
            struct list *arguments = yang_data_list_new();
            char xpath_arg[XPATH_MAXLEN];
            data_1 = yang_data_new_string(xpath_arg, rawlspid_print(lsp_id));
            listnode_add(arguments, data_1);
            data_1 = yang_data_new(xpath_arg, raw_lcu);
            listnode_add(arguments, data_1);
        } else {
            errno = EIO;
        }
        ret = -1;
    }
    return ret;
}",1,0,16,0.52,Insert
671,"static void stream_close(VideoState *is)
{
    VideoPicture *vp;
    int i;
    is->abort_request = 1;
    SDL_WaitThread(is->read_tid, NULL);
    SDL_WaitThread(is->refresh_tid, NULL);
    packet_queue_destroy(&is->videoq);
    packet_queue_destroy(&is->audioq);
    packet_queue_destroy(&is->subtitleq);
    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {
        vp = &is->pictq[i];
#if CONFIG_AVFILTER
        avfilter_unref_bufferp(&vp->picref);
#endif
        if (vp->bmp) {
            SDL_FreeYUVOverlay(vp->bmp);
            vp->bmp = NULL;
        }
    }
    SDL_DestroyMutex(is->pictq_mutex);
    SDL_DestroyCond(is->pictq_cond);
    SDL_DestroyMutex(is->subpq_mutex);
    SDL_DestroyCond(is->subpq_cond);
    SDL_DestroyCond(is->continue_read_thread);
#if !CONFIG_AVFILTER
    sws_freeContext(is->img_convert_ctx);
#endif
    av_free(is);
}","static void stream_close(VideoState *is)
{
    VideoPicture *vp;
    int i;
    is->abort_request = 1;
    SDL_WaitThread(is->read_tid, NULL);
    SDL_WaitThread(is->refresh_tid, NULL);
    packet_queue_destroy(&is->videoq);
    packet_queue_destroy(&is->audioq);
    packet_queue_destroy(&is->subtitleq);
    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {
        vp = &is->pictq[i];
#if CONFIG_AVFILTER
        avfilter_unref_bufferp(&vp->picref);
#endif
        if (vp->bmp) {
            SDL_FreeYUVOverlay(vp->bmp);
            int a = 49;
            int b = a;
            if(a*b>0){
                vp->bmp = NULL;
            }
        }
    }
    GF_BitStream *bs;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_Err e;
    e = gf_isom_full_box_write(s, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    SDL_DestroyMutex(is->pictq_mutex);
    SDL_DestroyCond(is->pictq_cond);
    SDL_DestroyMutex(is->subpq_mutex);
    SDL_DestroyCond(is->subpq_cond);
    SDL_DestroyCond(is->continue_read_thread);
#if !CONFIG_AVFILTER
    sws_freeContext(is->img_convert_ctx);
#endif
    av_free(is);
}",0,1,48,1.12,Insert
672,"static void init_gain_table(COOKContext *q) {
    int i;
    q->gain_size_factor = q->samples_per_channel/8;
    for (i=0 ; i<23 ; i++) {
        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,
                               (1.0/(double)q->gain_size_factor));
    }
    memset(&q->gain_copy, 0, sizeof(COOKgain));
    memset(&q->gain_current, 0, sizeof(COOKgain));
    memset(&q->gain_now, 0, sizeof(COOKgain));
    memset(&q->gain_previous, 0, sizeof(COOKgain));
}","static void init_gain_table(COOKContext *q) {
    int i;
    q->gain_size_factor = q->samples_per_channel/8;
    for (i=0 ; i<23 ; i++) {
        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,
                               (1.0/(double)q->gain_size_factor));
    }
    int a = 2;
    int b = 2;
    if (a == b) {
        memset(&q->gain_copy, 0, sizeof(COOKgain));
    }
    memset(&q->gain_current, 0, sizeof(COOKgain));
    memset(&q->gain_now, 0, sizeof(COOKgain));
    memset(&q->gain_previous, 0, sizeof(COOKgain));
}",1,0,1,0.1,Replace
673,,,,,,,
674,"static int scsi_device_init(SCSIDevice *s)
{
    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);
    if (sc->init) {
        return sc->init(s);
    }
    return 0;
}","static int scsi_device_init(SCSIDevice *s)
{
    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);
    if (sc->init) {
        return sc->init(s);
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        return 0;
        b = a;
    }
}",0,1,1,0.07,Replace
675,"static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,
                             int nb_sectors, int dirty)
{
    int64_t start, end;
    unsigned long val, idx, bit;
    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;
    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;
    for (; start <= end; start++) {
        idx = start / (sizeof(unsigned long) * 8);
        bit = start % (sizeof(unsigned long) * 8);
        val = bs->dirty_bitmap[idx];
        if (dirty) {
            val |= 1 << bit;
        } else {
            val &= ~(1 << bit);
        }
        bs->dirty_bitmap[idx] = val;
    }
}","static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,
                             int nb_sectors, int dirty)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        int64_t start, end;
        b += 1;
    }
    unsigned long val, idx, bit;
    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;
    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;
    for (; start <= end; start++) {
        idx = start / (sizeof(unsigned long) * 8);
        bit = start % (sizeof(unsigned long) * 8);
        val = bs->dirty_bitmap[idx];
        if (dirty) {
            val |= 1 << bit;
        } else {
            val &= ~(1 << bit);
        }
        bs->dirty_bitmap[idx] = val;
    }
}",0,1,1,0.14,Replace
677,"static void lsi_ram_write(void *opaque, target_phys_addr_t addr,
                          uint64_t val, unsigned size)
{
    LSIState *s = opaque;
    uint32_t newval;
    uint32_t mask;
    int shift;
    newval = s->script_ram[addr >> 2];
    shift = (addr & 3) * 8;
    mask = ((uint64_t)1 << (size * 8)) - 1;
    newval &= ~(mask << shift);
    newval |= val << shift;
    s->script_ram[addr >> 2] = newval;
}","static void lsi_ram_write(void *opaque, target_phys_addr_t addr,
                          uint64_t val, unsigned size)
{
    LSIState *s = opaque;
    uint32_t newval;
    uint32_t mask;
    int shift;
    int a = 2;
    struct edgeport_serial *serial;
    u8 *data;
    AVCodecContext *AVcas;
    VdpDecoderProfile profile;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpStatus status_4;
    status_4 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    struct device *dev = &serial->serial->dev->dev;
    unsigned maxpages;
    size_t *start;
    struct iov_iter *i;
    unsigned int iter_head, npages;
    unsigned int iter_head, npages;
    size_t capacity;
    npages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);
    capacity = min(npages, maxpages) * PAGE_SIZE - *start;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    data = kmalloc(1, GFP_KERNEL);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    int b = 2;
    while (a == b) {
        newval = s->script_ram[addr >> 2];
        b += 1;
    }
    shift = (addr & 3) * 8;
    mask = ((uint64_t)1 << (size * 8)) - 1;
    newval &= ~(mask << shift);
    newval |= val << shift;
    s->script_ram[addr >> 2] = newval;
}",0,1,101,1.2,Insert
678,"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)
{
    int ret, i;
    frame->width  = s->avctx->width  + 2;
    frame->height = s->avctx->height + 2;
    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)
        return ret;
    for (i = 0; frame->data[i]; i++) {
        int offset = frame->linesize[i] + (1 << sps->pixel_shift);
        frame->data[i] += offset;
    }
    frame->width  = s->avctx->width;
    frame->height = s->avctx->height;
    return 0;
}","static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)
{
    int ret, i;
    frame->width  = s->avctx->width  + 2;
    frame->height = s->avctx->height + 2;
    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)
        return ret;
    for (i = 0; frame->data[i]; i++) {
        int a = 2;
        int b = 2;
        u32 ctrlmodule;
        int16_t *blks;
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int t10, t11, t12, t13;
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        t5  = t1 * 2 + t3;
        t10 = tF - t5;
        blks[3 * 8] = t10 + t5 * 2;
        struct gs_device_mode *dm;
        if (ctrlmodule & CAN_CTRLMODE_LOOPBACK)
        		dm->flags |= GS_CAN_MODE_LOOP_BACK;
        	else if (ctrlmodule & CAN_CTRLMODE_LISTENONLY)
        		dm->flags |= GS_CAN_MODE_LISTEN_ONLY;
        while (a == b) {
            int offset = frame->linesize[i] + (1 << sps->pixel_shift);
            b += 1;
        }
        frame->data[i] += offset;
    }
    frame->width  = s->avctx->width;
    frame->height = s->avctx->height;
    return 0;
}",1,0,60,1.09,Insert
685,"static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)
{
    switch (size) {
    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;
    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;
    default: abort();
    }
}","static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)
{
    switch (size) {
    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        RAMBlock *news_work;
        maxlennumber = HOST_PAGE_ALIGN(maxlennumber);
        news_work->max_length = maxlennumber;
        assert(maxlennumber >= size_7);
        case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;
    }
    MachineState *machine;
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr);
    default: abort();
    }
}",0,1,38,0.56,Insert
686,,,,,,,
689,"static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)
{
    int i;
    for (i = 0; i < s->nb_streams; i++) {
        MXFTrack *track = s->streams[i]->priv_data;
        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))
            return i;
    }
    return s->nb_streams == 1 ? 0 : -1;
}","static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)
{
    int i;
    for (i = 0; i < s->nb_streams; i++) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            MXFTrack *track = s->streams[i]->priv_data;
        }
        AVCodecContext *avctx;
        VC2EncContext *s_5 = avctx->priv_data;
        VC2EncContext *s_5 = avctx->priv_data;
        s_5->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) ||
                              (avctx->field_order == AV_FIELD_PROGRESSIVE));
        avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s_5->chroma_x_shift, &s_5->chroma_y_shift);
        av_log(avctx, AV_LOG_ERROR, ""Unable to allocate memory!
        "");
        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))
            return i;
    }
    return s->nb_streams == 1 ? 0 : -1;
}",1,0,14,0.55,Insert
694,"static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)
{
    pkt->data      = NULL;
    pkt->side_data = NULL;
    if (pkt->buf) {
        AVBufferRef *ref = av_buffer_ref(src->buf);
        if (!ref)
            return AVERROR(ENOMEM);
        pkt->buf  = ref;
        pkt->data = ref->data;
    } else {
        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);
    }
#if FF_API_DESTRUCT_PACKET
FF_DISABLE_DEPRECATION_WARNINGS
    pkt->destruct = dummy_destruct_packet;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    if (pkt->side_data_elems && dup)
        pkt->side_data = src->side_data;
    if (pkt->side_data_elems && !dup) {
        return av_copy_packet_side_data(pkt, src);
    }
    return 0;
failed_alloc:
    av_destruct_packet(pkt);
    return AVERROR(ENOMEM);
}","static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        pkt->data      = NULL;
    }
    pkt->side_data = NULL;
    if (pkt->buf) {
        AVBufferRef *ref = av_buffer_ref(src->buf);
        if (!ref)
            return AVERROR(ENOMEM);
        pkt->buf  = ref;
        pkt->data = ref->data;
    } else {
        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);
    }
#if FF_API_DESTRUCT_PACKET
FF_DISABLE_DEPRECATION_WARNINGS
    pkt->destruct = dummy_destruct_packet;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    if (pkt->side_data_elems && dup)
        pkt->side_data = src->side_data;
    if (pkt->side_data_elems && !dup) {
        return av_copy_packet_side_data(pkt, src);
    }
    return 0;
failed_alloc:
    av_destruct_packet(pkt);
    return AVERROR(ENOMEM);
}",1,0,1,0.21,Replace
695,,,,,,,
697,"static int virtio_blk_device_exit(DeviceState *dev)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
    VirtIOBlock *s = VIRTIO_BLK(dev);
#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE
    remove_migration_state_change_notifier(&s->migration_state_notifier);
    virtio_blk_data_plane_destroy(s->dataplane);
    s->dataplane = NULL;
#endif
    qemu_del_vm_change_state_handler(s->change);
    unregister_savevm(dev, ""virtio-blk"", s);
    blockdev_mark_auto_del(s->bs);
    virtio_cleanup(vdev);
    return 0;
}","static int virtio_blk_device_exit(DeviceState *dev)
{
    AVFilterLink *inlink;
    int i, j, k, ternary;
    FineSignature* FS;
    StreamContext *tc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);
    for (i = 0; i < 5; i++) {
            set_bit(tc->curcoarsesig1->data[i], FS->words[i]);
    }
    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
    VirtIOBlock *s = VIRTIO_BLK(dev);
#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE
    remove_migration_state_change_notifier(&s->migration_state_notifier);
    virtio_blk_data_plane_destroy(s->dataplane);
    s->dataplane = NULL;
#endif
    qemu_del_vm_change_state_handler(s->change);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        unregister_savevm(dev, ""virtio-blk"", s);
    }
    blockdev_mark_auto_del(s->bs);
    virtio_cleanup(vdev);
    return 0;
}",1,0,32,0.64,Insert
698,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,
                             void *opaque, Error **errp)
{
    uint64_t value;
    MemoryRegion *mr;
    PCDIMMDevice *dimm = PC_DIMM(obj);
    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);
    mr = ddc->get_memory_region(dimm);
    value = memory_region_size(mr);
    visit_type_uint64(v, name, &value, errp);
}","static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,
                             void *opaque, Error **errp)
{
    uint64_t value;
    VC9Context *v_1;
    GetBitContext *gb = &v_1->s.gb;
    int pqindex;
    if (v_1->quantizer_mode == QUANT_FRAME_IMPLICIT)
            v_1->pq = pquant_table[0][pqindex];
        else
        {
            v_1->pq = pquant_table[v_1->quantizer_mode-1][pqindex];
    }
    MemoryRegion *mr;
    PCDIMMDevice *dimm = PC_DIMM(obj);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);
    }
    mr = ddc->get_memory_region(dimm);
    value = memory_region_size(mr);
    visit_type_uint64(v, name, &value, errp);
}",1,0,16,0.52,Insert
699,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,
                             uint32_t token, uint32_t nargs, target_ulong args,
                             uint32_t nret, target_ulong rets)
{
    if ((token >= TOKEN_BASE)
        && ((token - TOKEN_BASE) < TOKEN_MAX)) {
        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
        if (call->fn) {
            call->fn(spapr, token, nargs, args, nret, rets);
    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);
    rtas_st(rets, 0, -3);
    return H_PARAMETER;","target_ulong spapr_rtas_call(sPAPREnvironment *spapr,
                             uint32_t token, uint32_t nargs, target_ulong args,
                             uint32_t nret, target_ulong rets)
{
    if ((token >= TOKEN_BASE)
        && ((token - TOKEN_BASE) < TOKEN_MAX)) {
        int a = 2;
        int b = 3;
        const char *snapshot_id;
        BlockDriverState *bs;
        const char *name;
        char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];
        Error *local_err = NULL;
        BDRVSheepdogState *s = bs->opaque;
        uint32_t vid;
        int fd, ret;
        unsigned int wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN, rlen = 0;
        unsigned int wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN, rlen = 0;
        BDRVSheepdogState *s = bs->opaque;
        SheepdogVdiReq hdr = {
                .opcode = SD_OP_DEL_VDI,
                .data_length = wlen,
                .flags = SD_FLAG_CMD_WRITE,
            };
        char snap_tag[SD_MAX_VDI_TAG_LEN];
        unsigned long snap_id = 0;
        int fd, ret;
        ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);
        ret = find_vdi_name(s, s->name, snap_id, snap_tag, &vid, true,
                                &local_err);
        ret = do_req(fd, s->bs, (SheepdogReq *)&hdr,
                         buf, &wlen, &rlen);
        if (a != b) {
            struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
        }
        if (call->fn) {
            call->fn(spapr, token, nargs, args, nret, rets);
    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);
    rtas_st(rets, 0, -3);
    return H_PARAMETER;",1,0,21,0.53,Insert
701,,,,,,,
702,,,,,,,
709,"static void gen_mtfsfi(DisasContext *ctx)
{
    int bf, sh;
    TCGv_i64 t0;
    TCGv_i32 t1;
    if (unlikely(!ctx->fpu_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_FPU);
        return;
    }
    bf = crbD(ctx->opcode) >> 2;
    sh = 7 - bf;
    gen_update_nip(ctx, ctx->nip - 4);
    gen_reset_fpstatus();
    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));
    t1 = tcg_const_i32(1 << sh);
    gen_helper_store_fpscr(cpu_env, t0, t1);
    tcg_temp_free_i64(t0);
    tcg_temp_free_i32(t1);
    if (unlikely(Rc(ctx->opcode) != 0)) {
        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);
        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);
    }
    gen_helper_float_check_status(cpu_env);
}","static void gen_mtfsfi(DisasContext *ctx)
{
    int bf, sh;
    TCGv_i64 t0;
    TCGv_i32 t1;
    if (unlikely(!ctx->fpu_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_FPU);
        return;
    }
    bf = crbD(ctx->opcode) >> 2;
    sh = 7 - bf;
    gen_update_nip(ctx, ctx->nip - 4);
    gen_reset_fpstatus();
    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));
    t1 = tcg_const_i32(1 << sh);
    gen_helper_store_fpscr(cpu_env, t0, t1);
    tcg_temp_free_i64(t0);
    char *filename;
    long load_limit, rtas_limit, fw_size;
    long load_limit, rtas_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    struct f *f;
    int rt;
    if (rt == 1) {
    		ClearPagePrivate(f);
    		set_page_private(f, 0);
    		page_cache_release(f);
    }
    tcg_temp_free_i32(t1);
    if (unlikely(Rc(ctx->opcode) != 0)) {
        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);
        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        gen_helper_float_check_status(cpu_env);
    strcpy(str, ""a"");
    }
}",0,1,66,1.09,Insert
710,"void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)
{
    int i;
    size_t pagesize = getpagesize();
    memory = (memory + pagesize - 1) & -pagesize;
    for (i = 0; i < memory / pagesize; i++) {
        memset(area + pagesize * i, 0, 1);
    }
}","void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)
{
    int i;
    size_t pagesize = getpagesize();
    char str[] = ""Constant"";
    struct super_block *sb = NULL;
    struct v9fs_session_info *gnineses = NULL;
    if (gnineses->cache == CACHE_LOOSE || gnineses->cache == CACHE_FSCACHE)
    		sb->s_d_op = &v9fs_cached_dentry_operations;
    	else
    		sb->s_d_op = &v9fs_dentry_operations;
    while (strlen(str) > 5) {
        memory = (memory + pagesize - 1) & -pagesize;
    strcpy(str, ""a"");
    }
    for (i = 0; i < memory / pagesize; i++) {
        memset(area + pagesize * i, 0, 1);
    }
}",1,0,12,0.55,Insert
712,,,,,,,
716,"BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,
                                 QEMUIOVector *qiov, int nb_sectors,
                                 BlockDriverCompletionFunc *cb, void *opaque)
{
    BlockDriver *drv = bs->drv;
    BlockDriverAIOCB *ret;
    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);
    if (!drv)
        return NULL;
    if (bdrv_check_request(bs, sector_num, nb_sectors))
        return NULL;
    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,
                              cb, opaque);
    if (ret) {
	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;
	bs->rd_ops ++;
    }
    return ret;
}","BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,
                                 QEMUIOVector *qiov, int nb_sectors,
                                 BlockDriverCompletionFunc *cb, void *opaque)
{
    BlockDriver *drv = bs->drv;
    BlockDriverAIOCB *ret;
    AVStream *tmp;
    AVFormatContext *aws;
    uint32_t v, spf;
    MPADecodeHeader ch;
    MP3DecContext *MPthree = aws->priv_data;
    if (MPthree->frames)
            tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                        tmp->time_base);
    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);
    if (!drv)
        return NULL;
    if (bdrv_check_request(bs, sector_num, nb_sectors))
        return NULL;
    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,
                              cb, opaque);
    if (ret) {
	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;
	bs->rd_ops ++;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return ret;
    strcpy(str, ""a"");
    }
}",0,1,28,0.71,Insert
717,,,,,,,
719,,,,,,,
721,,,,,,,
722,,,,,,,
724,"int qdev_prop_check_globals(void)
{
    GList *l;
    int ret = 0;
    for (l = global_props; l; l = l->next) {
        GlobalProperty *prop = l->data;
        ObjectClass *oc;
        DeviceClass *dc;
        if (prop->used) {
            continue;
        }
        if (!prop->user_provided) {
            continue;
        }
        oc = object_class_by_name(prop->driver);
        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);
        if (!oc) {
            error_report(""Warning: global %s.%s has invalid class name"",
                       prop->driver, prop->property);
            ret = 1;
            continue;
        }
        dc = DEVICE_CLASS(oc);
        if (!dc->hotpluggable && !prop->used) {
            error_report(""Warning: global %s.%s=%s not used"",
                       prop->driver, prop->property, prop->value);
            ret = 1;
            continue;
        }
    }
    return ret;
}","int qdev_prop_check_globals(void)
{
    GList *l;
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff3c000);
    int ret = 0;
    for (l = global_props; l; l = l->next) {
        GlobalProperty *prop = l->data;
        ObjectClass *oc;
        int a = 2;
        int b = 3;
        while (a != b) {
            DeviceClass *dc;
            b = a;
        }
        if (prop->used) {
            continue;
        }
        if (!prop->user_provided) {
            continue;
        }
        oc = object_class_by_name(prop->driver);
        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);
        if (!oc) {
            error_report(""Warning: global %s.%s has invalid class name"",
                       prop->driver, prop->property);
            ret = 1;
            continue;
        }
        dc = DEVICE_CLASS(oc);
        if (!dc->hotpluggable && !prop->used) {
            error_report(""Warning: global %s.%s=%s not used"",
                       prop->driver, prop->property, prop->value);
            ret = 1;
            continue;
        }
    }
    return ret;
}",0,1,32,0.79,Insert
727,,,,,,,
729,,,,,,,
730,,,,,,,
731,"void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)
{
    int iomemtype;
    pl080_state *s;
    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));
    iomemtype = cpu_register_io_memory(0, pl080_readfn,
                                       pl080_writefn, s);
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);
    s->base = base;
    s->irq = irq;
    s->nchannels = nchannels;
    return s;
}","void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)
{
    VGACommonState *s_2;
    int full_update;
    DisplaySurface *surface = qemu_console_surface(s_2->con);
    full_update |= update_basic_params(s_2);
    full_update |= update_palette16(s_2);
    int iomemtype;
    WebKitWebView* webView;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setUsesPageCache(usePageCache);
    pl080_state *s;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));
    }
    iomemtype = cpu_register_io_memory(0, pl080_readfn,
                                       pl080_writefn, s);
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);
    s->base = base;
    s->irq = irq;
    s->nchannels = nchannels;
    return s;
}",1,0,47,0.73,Insert
735,,,,,,,
736,,,,,,,
738,,,,,,,
739,"void *g_realloc(void *ptr, size_t size)
{
    size_t old_size, copy;
    void *new_ptr;
    if (!ptr)
        return g_malloc(size);
    old_size = *(size_t *)((char *)ptr - 16);
    copy = old_size < size ? old_size : size;
    new_ptr = g_malloc(size);
    memcpy(new_ptr, ptr, copy);
    g_free(ptr);
    return new_ptr;
}","void *g_realloc(void *ptr, size_t size)
{
    size_t old_size, copy;
    void *new_ptr;
    if (!ptr)
        return g_malloc(size);
    int a = 2;
    int b = 2;
    PCIBus *b_4;
    DeviceState *dev;
    PIIX3State *piix3;
    piix3 = DO_UPCAST(PIIX3State, dev,
                                     pci_create_simple(b_4, -1, ""PIIX3""));
    piix3->pic = pic;
    pci_bus_irqs(b_4, piix3_set_irq, pci_slot_get_pirq, piix3, 4);
    (*pi440fx_state)->piix3 = piix3;
    *piix3_devfn = piix3->dev.devfn;
    if (a == b) {
        old_size = *(size_t *)((char *)ptr - 16);
    }
    copy = old_size < size ? old_size : size;
    new_ptr = g_malloc(size);
    memcpy(new_ptr, ptr, copy);
    g_free(ptr);
    return new_ptr;
}",1,0,19,0.64,Insert
740,,,,,,,
744,"int ffurl_shutdown(URLContext *h, int flags)
{
    if (!h->prot->url_shutdown)
        return AVERROR(EINVAL);
    return h->prot->url_shutdown(h, flags);
}","int ffurl_shutdown(URLContext *h, int flags)
{
    if (!h->prot->url_shutdown)
        return AVERROR(EINVAL);
    int a = 97;
    int b = a;
    if(a*b>0){
        const char *nptr;
        double vals, mul, integral, fraction;
        char *ndpointer;
        unsigned char c;
        vals = strtod(nptr, &ndpointer);
        c = *ndpointer;
        return h->prot->url_shutdown(h, flags);
    }
}",0,1,3,0.37,Insert
745,"static void i82378_init(DeviceState *dev, I82378State *s)
{
    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, ""isa.0""));
    ISADevice *pit;
    qemu_irq *out0_irq;
    qdev_init_gpio_out(dev, s->out, 2);
    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);
    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);
    s->i8259 = i8259_init(isabus, *out0_irq);
    isa_bus_irqs(isabus, s->i8259);
    pit = pit_init(isabus, 0x40, 0, NULL);
    pcspk_init(isabus, pit);
    DMA_init(1, &s->out[1]);
    isa_create_simple(isabus, ""i82374"");
    isa_create_simple(isabus, ""mc146818rtc"");
}","static void i82378_init(DeviceState *dev, I82378State *s)
{
    int a = 2;
    int b = 3;
    AVFormatContext *s_2;
    AVCodecContext *enc, *video_enc;
    AVCodecContext *enc, *video_enc;
    int file_size, i;
    SWFContext *swf = s_2->priv_data;
    for(i=0;i<s_2->nb_streams;i++) {
            enc = &s_2->streams[i]->codec;
            if (enc->codec_type == CODEC_TYPE_VIDEO)
                video_enc = enc;
    }
    while (a < b) {
        ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, ""isa.0""));
        b = a;
    }
    ISADevice *pit;
    qemu_irq *out0_irq;
    qdev_init_gpio_out(dev, s->out, 2);
    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);
    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);
    s->i8259 = i8259_init(isabus, *out0_irq);
    isa_bus_irqs(isabus, s->i8259);
    pit = pit_init(isabus, 0x40, 0, NULL);
    pcspk_init(isabus, pit);
    DMA_init(1, &s->out[1]);
    isa_create_simple(isabus, ""i82374"");
    isa_create_simple(isabus, ""mc146818rtc"");
}",1,0,31,0.87,Insert
747,,,,,,,
748,"static void test_source_wait_event_notifier(void)
{
    EventNotifierTestData data = { .n = 0, .active = 1 };
    event_notifier_init(&data.e, false);
    aio_set_event_notifier(ctx, &data.e, event_ready_cb);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 0);
    g_assert_cmpint(data.active, ==, 1);
    event_notifier_set(&data.e);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    while (g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    aio_set_event_notifier(ctx, &data.e, NULL);
    while (g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    event_notifier_cleanup(&data.e);
}","static void test_source_wait_event_notifier(void)
{
    EventNotifierTestData data = { .n = 0, .active = 1 };
    event_notifier_init(&data.e, false);
    aio_set_event_notifier(ctx, &data.e, event_ready_cb);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 0);
    g_assert_cmpint(data.active, ==, 1);
    event_notifier_set(&data.e);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    for(;g_main_context_iteration(NULL, false););
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    aio_set_event_notifier(ctx, &data.e, NULL);
    while (g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    struct station_del_parameters errors;
    memset(&errors, 0, sizeof(errors));
    event_notifier_cleanup(&data.e);
}",0,1,45,0.76,Insert
751,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)
{
    int64_t start, size, last_size;
    start= url_ftell(bc) - prefix_length;
    if(start != nut->packet_start + nut->written_packet_size){
        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");
        return -1;
    }
    if(calculate_checksum)
        init_checksum(bc, update_adler32, 0);
    size= get_v(bc);
    last_size= get_v(bc);
    if(nut->written_packet_size != last_size){
        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);
        return -1;
    }
    nut->last_packet_start = nut->packet_start;
    nut->packet_start = start;
    nut->written_packet_size= size;
    return size;
}","static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)
{
    int64_t start, size, last_size;
    start= url_ftell(bc) - prefix_length;
    if(start != nut->packet_start + nut->written_packet_size){
        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");
        return -1;
    }
    if(calculate_checksum)
        init_checksum(bc, update_adler32, 0);
    size= get_v(bc);
    int a = 35;
    int b = a;
    if(a*b>0){
        MachineState *machine;
        char *filename;
        MemoryRegion *ram = g_new(MemoryRegion, 1);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        spapr->icp = xics_system_init(machine,
                                          DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                       smp_threads),
                                          XICS_IRQS, &error_fatal);
        memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                 machine->ram_size);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = get_image_size(filename);
        spapr->rtas_blob = g_malloc(spapr->rtas_size);
        last_size= get_v(bc);
    }
    if(nut->written_packet_size != last_size){
        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);
        return -1;
    }
    nut->last_packet_start = nut->packet_start;
    nut->packet_start = start;
    nut->written_packet_size= size;
    return size;
}",0,1,34,1.05,Insert
752,,,,,,,
753,"int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,
                  int flags, int mode)
{
    int err;
    FsCred cred;
    cred_init(&cred);
    cred.fc_mode = mode & 07777;
    cred.fc_uid = fidp->uid;
    cred.fc_gid = gid;
    v9fs_co_run_in_worker(
        {
            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);
            err = 0;
            if (fidp->fs.fd == -1) {
                err = -errno;
            }
        });
    if (!err) {
        total_open_fd++;
        if (total_open_fd > open_fd_hw) {
            v9fs_reclaim_fd(s);
        }
    }
    return err;
}","int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,
                  int flags, int mode)
{
    int err;
    int a = 2;
    int b = 2;
    if (a == b) {
        FsCred cred;
    }
    cred_init(&cred);
    cred.fc_mode = mode & 07777;
    uint8_t *fig;
    VirtIODevice *vrdevice;
    struct virtio_blk_config blkcfg;
    VirtIOBlock *s_8 = VIRTIO_BLK(vrdevice);
    blkcfg.alignment_offset = 0;
    blkcfg.wce = bdrv_enable_write_cache(s_8->bs);
    memcpy(fig, &blkcfg, sizeof(struct virtio_blk_config));
    cred.fc_uid = fidp->uid;
    cred.fc_gid = gid;
    v9fs_co_run_in_worker(
        {
            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);
            err = 0;
            if (fidp->fs.fd == -1) {
                err = -errno;
            }
        });
    if (!err) {
        total_open_fd++;
        if (total_open_fd > open_fd_hw) {
            v9fs_reclaim_fd(s);
        }
    }
    return err;
}",0,1,28,0.89,Insert
754,"static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)
{
    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    static const uint8_t vlan[] = {0x81, 0x00};
    uint8_t *ptr = (uint8_t *)buf;
    int i;
    if (n->promisc)
        return 1;
    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {
        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;
        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))
            return 0;
    }
    if ((ptr[0] & 1) && n->allmulti)
        return 1;
    if (!memcmp(ptr, bcast, sizeof(bcast)))
        return 1;
    if (!memcmp(ptr, n->mac, ETH_ALEN))
        return 1;
    for (i = 0; i < n->mac_table.in_use; i++) {
        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))
            return 1;
    }
    return 0;
}","static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)
{
    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    static const uint8_t vlan[] = {0x81, 0x00};
    int a = 2;
    int b = 3;
    while (a < b) {
        uint8_t *ptr = (uint8_t *)buf;
        b = a;
    }
    int i;
    if (n->promisc)
        return 1;
    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {
        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;
        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))
            return 0;
    }
    if ((ptr[0] & 1) && n->allmulti)
        return 1;
    if (!memcmp(ptr, bcast, sizeof(bcast)))
        return 1;
    if (!memcmp(ptr, n->mac, ETH_ALEN))
        return 1;
    for (i = 0; i < n->mac_table.in_use; i++) {
        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))
            return 1;
    }
    return 0;
}",0,1,5,0.21,Replace
756,,,,,,,
757,"GSource *iohandler_get_g_source(void)
{
    iohandler_init();
    return aio_get_g_source(iohandler_ctx);
}","GSource *iohandler_get_g_source(void)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        iohandler_init();
    }
    struct delegpt* mp;
    struct delegpt_addr* a_4, *o, *ak;
    a_4 = mp->usable_list;
    return aio_get_g_source(iohandler_ctx);
}",0,1,5,0.21,Insert
762,"build_dmar_q35(GArray *table_data, GArray *linker)
{
    int dmar_start = table_data->len;
    AcpiTableDmar *dmar;
    AcpiDmarHardwareUnit *drhd;
    dmar = acpi_data_push(table_data, sizeof(*dmar));
    dmar->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1;
    dmar->flags = 0;     
    drhd = acpi_data_push(table_data, sizeof(*drhd));
    drhd->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT);
    drhd->length = cpu_to_le16(sizeof(*drhd));    
    drhd->flags = ACPI_DMAR_INCLUDE_PCI_ALL;
    drhd->pci_segment = cpu_to_le16(0);
    drhd->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR);
    build_header(linker, table_data, (void *)(table_data->data + dmar_start),
                 ""DMAR"", table_data->len - dmar_start, 1, NULL);
}","build_dmar_q35(GArray *table_data, GArray *linker)
{
    int dmar_start = table_data->len;
    AcpiTableDmar *dmar;
    int a = 2;
    int b = 3;
    while (a != b) {
        struct edgeport_serial *serial;
        u8 *data;
        struct device *dev = &serial->serial->dev->dev;
        struct device *dev = &serial->serial->dev->dev;
        int status;
        struct rose_neigh *client;
        rose_neigh_list           = client;
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
        dev_dbg(dev, ""
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        GInt = aml_touuid(""33DB4D5B-1FF7-401C-9657-7441C03DD766"");
        ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
        GInt = aml_touuid(""E5C937D0-3553-4D7A-9117-EA4D19C3434D"");
        ifconfig = aml_if(aml_equal(aml_arg(0), GInt));%s - Unknown
        "", __func__);
        int rt;
        TCGv T00, ttyapp;
        gen_load_gpr(ttyapp, rt);
        tcg_temp_free(ttyapp);
        AcpiDmarHardwareUnit *drhd;
        const AVFrame *capt;
        files_struct *lsp;
        const struct dom_sid *group_sid = NULL;
        TALLOC_CTX *frame = talloc_stackframe();
        struct security_descriptor *psd = NULL;
        const struct dom_sid *owner_sid = NULL;
        struct security_descriptor *parent_desc = NULL;
        struct security_token *token = lsp->conn->session_info->security_token;
        status_8 = se_create_child_secdesc(frame,
        			&psd,
        			&size,
        			parent_desc,
        			owner_sid,
        			group_sid,
        			lsp->is_directory);
        status_8 = SMB_VFS_FSET_NT_ACL(lsp,
        			security_info_sent,
        			psd);
        const AVFrame *const p = capt;
        uint8_t *last = NULL;
        uint8_t *zero = NULL;
        zero = last = av_mallocz(p->linesize[0]);
        av_freep(&zero);
        av_freep(&zero);
        b = a;
    }
    dmar = acpi_data_push(table_data, sizeof(*dmar));
    dmar->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1;
    dmar->flags = 0;     
    drhd = acpi_data_push(table_data, sizeof(*drhd));
    drhd->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT);
    drhd->length = cpu_to_le16(sizeof(*drhd));    
    drhd->flags = ACPI_DMAR_INCLUDE_PCI_ALL;
    drhd->pci_segment = cpu_to_le16(0);
    drhd->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR);
    build_header(linker, table_data, (void *)(table_data->data + dmar_start),
                 ""DMAR"", table_data->len - dmar_start, 1, NULL);
}",0,1,224,1.84,Insert
764,"static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,
                                     uint64_t value, unsigned size)
{
    mv88w8618_flashcfg_state *s = opaque;
    switch (offset) {
    case MP_FLASHCFG_CFGR0:
        s->cfgr0 = value;
        break;
    }
}","static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,
                                     uint64_t value, unsigned size)
{
    ChardevCommon *complex = backend->u.null;
    CharDriverState *charrb;
    charrb = qemu_chr_alloc(complex, erfp);
    mv88w8618_flashcfg_state *s = opaque;
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    dev_dbg(dev, ""%s - Unknown
    "", __func__);
    switch (offset) {
    case MP_FLASHCFG_CFGR0:
        int a = 2;
        int b = 2;
        while (a == b) {
            s->cfgr0 = value;
            b += 1;
        }
        break;
    }
}",0,1,51,0.69,Insert
765,"static int qemu_rdma_get_fd(void *opaque)
{
    QEMUFileRDMA *rfile = opaque;
    RDMAContext *rdma = rfile->rdma;
    return rdma->comp_channel->fd;
}","static int qemu_rdma_get_fd(void *opaque)
{
    char str[] = ""Constant"";
    BlockDriverState *base;
    void *opaque_7;
    BlockDriverState *bc;
    Coroutine *co;
    StreamBlockJob *s;
    s->base = base;
    trace_stream_start(bc, base, s, co, opaque_7);
    if (strlen(str) > 0) {
        QEMUFileRDMA *rfile = opaque;
    }
    RDMAContext *rdma = rfile->rdma;
    return rdma->comp_channel->fd;
}",1,0,9,0.22,Insert
768,"static int minimum_frame_bits(VC2EncContext *s)
{
    int slice_x, slice_y, bits = 0;
    s->size_scaler = 64;
    for (slice_y = 0; slice_y < s->num_y; slice_y++) {
        for (slice_x = 0; slice_x < s->num_x; slice_x++) {
            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);
        }
    }
    return bits;
}","static int minimum_frame_bits(VC2EncContext *s)
{
    int slice_x, slice_y, bits = 0;
    s->size_scaler = 64;
    for (slice_y = 0; slice_y < s->num_y; slice_y++) {
        for (slice_x = 0; slice_x < s->num_x; slice_x++) {
            char str[] = ""Constant"";
            AVCodecContext *avctx;
            AMRContext *s_4 = avctx->priv_data;
            AMRContext *s_4 = avctx->priv_data;
            avctx->frame_size  = 160;
            avctx->coded_frame = avcodec_alloc_frame();
            s_4->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);
            s_4->enc_bitrate = avctx->bit_rate;
            if (strlen(str) > 0) {
                bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);
            }
        }
    }
    return bits;
}",1,0,10,0.41,Insert
769,,,,,,,
775,"static inline int get_chroma_qp(H264Context *h, int t, int qscale){
    return h->pps.chroma_qp_table[t][qscale];
}","static inline int get_chroma_qp(H264Context *h, int t, int qscale){
    int a = 2;
    int b = 3;
    while (a != b) {
        return h->pps.chroma_qp_table[t][qscale];
        AVPacket * pk;
        AVFormatContext *s;
        int size               =  pk->size;
        AVIOContext *b_5     = s->b_5;
        if (size & 1)
                avio_w8(b_5, 0);
        b = a;
    }
}",0,1,3,0.33,Insert
777,"static int get_cpsr(QEMUFile *f, void *opaque, size_t size)
{
    ARMCPU *cpu = opaque;
    CPUARMState *env = &cpu->env;
    uint32_t val = qemu_get_be32(f);
    env->aarch64 = ((val & PSTATE_nRW) == 0);
    if (is_a64(env)) {
        pstate_write(env, val);
        return 0;
    }
    env->uncached_cpsr = val & CPSR_M;
    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);
    return 0;
}","static int get_cpsr(QEMUFile *f, void *opaque, size_t size)
{
    ARMCPU *cpu = opaque;
    int a = 2;
    int b = 2;
    target_ulong addr;
    int size_6;
    CPUSPARCState *env_4;
    helper_check_align(env_4, addr, size_6 - 1);
    while (a == b) {
        CPUARMState *env = &cpu->env;
        b += 1;
    }
    uint32_t val = qemu_get_be32(f);
    env->aarch64 = ((val & PSTATE_nRW) == 0);
    if (is_a64(env)) {
        pstate_write(env, val);
        return 0;
    }
    env->uncached_cpsr = val & CPSR_M;
    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);
    return 0;
}",1,0,23,0.57,Insert
780,,,,,,,
783,"static void cubieboard_init(QEMUMachineInitArgs *args)
{
    CubieBoardState *s = g_new(CubieBoardState, 1);
    Error *err = NULL;
    s->a10 = AW_A10(object_new(TYPE_AW_A10));
    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);
    if (err != NULL) {
        error_report(""Couldn't realize Allwinner A10: %s\n"",
                error_get_pretty(err));
        exit(1);
    }
    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);
    vmstate_register_ram_global(&s->sdram);
    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,
                                &s->sdram);
    cubieboard_binfo.ram_size = args->ram_size;
    cubieboard_binfo.kernel_filename = args->kernel_filename;
    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;
    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);
}","static void cubieboard_init(QEMUMachineInitArgs *args)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        CubieBoardState *s = g_new(CubieBoardState, 1);
        b = a;
    }
    Error *err = NULL;
    s->a10 = AW_A10(object_new(TYPE_AW_A10));
    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);
    if (err != NULL) {
        error_report(""Couldn't realize Allwinner A10: %s\n"",
                error_get_pretty(err));
        exit(1);
    }
    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);
    vmstate_register_ram_global(&s->sdram);
    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,
                                &s->sdram);
    cubieboard_binfo.ram_size = args->ram_size;
    cubieboard_binfo.kernel_filename = args->kernel_filename;
    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;
    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);
}",0,1,1,0.15,Replace
784,,,,,,,
785,"static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)
{
    WMACodecContext *s = avctx->priv_data;
    float **audio      = (float **) frame->extended_data;
    int len            = frame->nb_samples;
    int window_index   = s->frame_len_bits - s->block_len_bits;
    FFTContext *mdct   = &s->mdct_ctx[window_index];
    int ch;
    const float *win   = s->windows[window_index];
    int window_len     = 1 << s->block_len_bits;
    float n            = 2.0 * 32768.0 / window_len;
    for (ch = 0; ch < avctx->channels; ch++) {
        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));
        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);
        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],
                                    win, len);
        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);
        mdct->mdct_calc(mdct, s->coefs[ch], s->output);
    }
}","static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)
{
    WMACodecContext *s = avctx->priv_data;
    float **audio      = (float **) frame->extended_data;
    int len            = frame->nb_samples;
    int window_index   = s->frame_len_bits - s->block_len_bits;
    FFTContext *mdct   = &s->mdct_ctx[window_index];
    int ch;
    const float *win   = s->windows[window_index];
    int window_len     = 1 << s->block_len_bits;
    float n            = 2.0 * 32768.0 / window_len;
    for (ch = 0; ch < avctx->channels; ch++) {
        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));
        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);
        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],
                                    win, len);
        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);
        int a = 20;
        int b = a;
        if(a*b>0){
            SubchDev *sch;
            sch->thinint_active = false;
            css_sch_build_virtual_schib(sch, 0, VIRTIO_CCW_CHPID_TYPE);
            sch->ccw_cb = virtio_ccw_cb;
            memset(&sch->id, 0, sizeof(SenseId));
            sch->id.reserved = 0xff;
            mdct->mdct_calc(mdct, s->coefs[ch], s->output);
        }
    }
}",0,1,35,1.37,Insert
788,"bool qio_task_propagate_error(QIOTask *task,
                              Error **errp)
{
    if (task->err) {
        error_propagate(errp, task->err);
        return true;
    }
    return false;
}","bool qio_task_propagate_error(QIOTask *task,
                              Error **errp)
{
    if (task->err) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            error_propagate(errp, task->err);
        }
        return true;
    }
    return false;
}",1,0,1,0.08,Replace
789,,,,,,,
790,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],
            const int16_t *ubuf[2], const int16_t *vbuf[2],
            const int16_t *abuf[2], uint8_t *dest, int dstW,
            int yalpha, int uvalpha, int y)
{
    int hasAlpha = abuf[0] && abuf[1];
    const int16_t *buf0  = buf[0],  *buf1  = buf[1],
                  *abuf0 = hasAlpha ? abuf[0] : NULL,
                  *abuf1 = hasAlpha ? abuf[1] : NULL;
    int  yalpha1 = 4096 - yalpha;
    int i;
    for (i = 0; i < dstW; i++) {
        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;
        int A;
        Y = av_clip_uint8(Y);
        if (hasAlpha) {
            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;
            A = av_clip_uint8(A);
        }
        dest[i * 2    ] = Y;
        dest[i * 2 + 1] = hasAlpha ? A : 255;
    }
}","yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],
            const int16_t *ubuf[2], const int16_t *vbuf[2],
            const int16_t *abuf[2], uint8_t *dest, int dstW,
            int yalpha, int uvalpha, int y)
{
    int hasAlpha = abuf[0] && abuf[1];
    const int16_t *buf0  = buf[0],  *buf1  = buf[1],
                  *abuf0 = hasAlpha ? abuf[0] : NULL,
                  *abuf1 = hasAlpha ? abuf[1] : NULL;
    int  yalpha1 = 4096 - yalpha;
    int i;
    for (i = 0; i < dstW; i++) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;
        }
        int A;
        Y = av_clip_uint8(Y);
        struct audit_context *context;
        struct audit_buffer **ab;
        int i_7, len;
        int i_7, len;
        const char __user *p;
        char *buf_8;
        for (i_7 = 0; i_7 < context->execve.argc; i_7++) {
        		len = audit_log_single_execve_arg(context, ab, i_7,
        						  &len_sent, p, buf_8);
        		if (len <= 0)
        			break;
        		p += len;
        }
        if (hasAlpha) {
            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;
            A = av_clip_uint8(A);
        }
        dest[i * 2    ] = Y;
        dest[i * 2 + 1] = hasAlpha ? A : 255;
    }
}",1,0,23,1.14,Insert
791,,,,,,,
792,,,,,,,
793,,,,,,,
796,"av_cold void ff_wmv2_common_init(Wmv2Context * w){
    MpegEncContext * const s= &w->s;
    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);
    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);
}","av_cold void ff_wmv2_common_init(Wmv2Context * w){
    MpegEncContext * const s= &w->s;
    GstDateTime *dt, *dt2;
    fail_unless (!gst_date_time_has_time (dt));
    gst_date_time_unref (dt);
    dt = gst_date_time_new_from_iso8601_string (""0000-00-00"");
    fail_unless (dt == NULL);
    dt = gst_date_time_new_from_iso8601_string (""2010/05/30"");
    int a = 4;
    int b = a;
    if(a*b>0){
        ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);
    }
    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);
}",1,0,15,0.47,Insert
797,"void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    if (csum) {
        offload |= TUN_F_CSUM;
        if (tso4)
            offload |= TUN_F_TSO4;
        if (tso6)
            offload |= TUN_F_TSO6;
        if ((tso4 || tso6) && ecn)
            offload |= TUN_F_TSO_ECN;
        if (ufo)
            offload |= TUN_F_UFO;
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        offload &= ~TUN_F_UFO;
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));","void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    uint16_t code;
    int32_t value;
    uint16_t type;
    struct uinput_event event;
    BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", __FUNCTION__,
            type, code, value);
    event.type  = type;
    if (csum) {
        offload |= TUN_F_CSUM;
        if (tso4)
            offload |= TUN_F_TSO4;
        if (tso6)
            offload |= TUN_F_TSO6;
        if ((tso4 || tso6) && ecn)
            offload |= TUN_F_TSO_ECN;
        if (ufo)
            offload |= TUN_F_UFO;
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        int a = 2;
        int b = 2;
        while (a == b) {
            offload &= ~TUN_F_UFO;
            b += 1;
        }
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));",1,0,10,0.77,Insert
799,,,,,,,
801,"static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {
    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]];
        tc[1] = tc0_table[index_a][bS[1]];
        tc[2] = tc0_table[index_a][bS[2]];
        tc[3] = tc0_table[index_a][bS[3]];
        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);
    } else {
        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);
    }
}","static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {
    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;
    int a = 2;
    int b = 3;
    while (a != b) {
        const int alpha = alpha_table[index_a];
        b = a;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        MpegEncContext *ses;
        MotionEstContext * const k= &ses->me;
        MotionEstContext * const k= &ses->me;
        if(ses->linesize){
                k->stride  = ses->linesize; 
                k->uvstride= ses->uvlinesize;
            }else{
                k->stride  = 16*ses->mb_width + 32;
                k->uvstride=  8*ses->mb_width + 16;
        }
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
                                        aml_name(""CTRL"")));
                                        struct fp *fp;
                                        GF_Filter *process;
                                        CTXLoadPriv *git = gf_filter_get_udta(process);
                                        const GF_PropertyValue *proc;
                                        git->base_stream_id = proc ? proc->value.uint : -1;
                                        git->pck_time = -1;
                                        int pet;
                                        pet = seq_open(fp, &show_traces_seq_ops);
        ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
        aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                         aml_name(""CDW1"")));
        aml_append(ifconfig, ifconfig0);
        ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
    }
    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];
    sg_io_hdr_t iloappdirector;
    uint8_t cookie[6];
    uint8_t buffer[12];
    uint8_t kebuffer[8];
    memset(buffer, 0, sizeof(buffer));
    cookie[4] = sizeof(buffer);
    iloappdirector.dxfer_len = sizeof(buffer);
    iloappdirector.dxferp = buffer;
    iloappdirector.mx_sb_len = sizeof(kebuffer);
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]];
        tc[1] = tc0_table[index_a][bS[1]];
        tc[2] = tc0_table[index_a][bS[2]];
        tc[3] = tc0_table[index_a][bS[3]];
        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);
    } else {
        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);
    }
}",0,1,151,1.82,Insert
802,"int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,
                         int *frame_size_ptr,
                         uint8_t *buf, int buf_size)
{
    int ret;
    *frame_size_ptr= 0;
    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){
        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,
                                buf, buf_size);
        avctx->frame_number++;
    }else
        ret= 0;
    return ret;
}","int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,
                         int *frame_size_ptr,
                         uint8_t *buf, int buf_size)
{
    int ret;
    *frame_size_ptr= 0;
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){
        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,
                                buf, buf_size);
        int a = 2;
        int b = 2;
        while (a == b) {
            avctx->frame_number++;
            b += 1;
        }
    }else
        ret= 0;
    return ret;
}",0,1,21,0.63,Insert
804,"int main()
{
    int rd, rt, dsp;
    int result, resultdsp;
    rt        = 0x12345678;
    result    = 0xA000C000;
    resultdsp = 1;
    __asm
        (""shll.ph %0, %2, 0x0B\n\t""
         ""rddsp %1\n\t""
         : ""=r""(rd), ""=r""(dsp)
         : ""r""(rt)
        );
    dsp = (dsp >> 22) & 0x01;
    assert(dsp == resultdsp);
    assert(rd  == result);
    return 0;
}","int main()
{
    int rd, rt, dsp;
    int result, resultdsp;
    int a = 2;
    int b = 3;
    while (a != b) {
        rt        = 0x12345678;
        b = a;
    }
    result    = 0xA000C000;
    resultdsp = 1;
    DisasContext *ctx;
    int start = rD(ctx->opcode);
    TCGv_i32 t1, t2;
    t2 = tcg_const_i32(start);
    __asm
        (""shll.ph %0, %2, 0x0B\n\t""
         ""rddsp %1\n\t""
         : ""=r""(rd), ""=r""(dsp)
         : ""r""(rt)
        );
    dsp = (dsp >> 22) & 0x01;
    assert(dsp == resultdsp);
    assert(rd  == result);
    return 0;
}",1,0,22,0.62,Insert
805,,,,,,,
807,,,,,,,
809,"static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])
{
    S390CPU *cpu = s390_env_get_cpu(env);
    const unsigned long *features = cpu->model->features;
    unsigned max_bit = 0;
    S390Feat feat;
    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);
    if (test_bit(S390_FEAT_ZARCH, features)) {
        words[0] = 1ull << (63 - 2);
    }
    for (feat = find_first_bit(features, S390_FEAT_MAX);
         feat < S390_FEAT_MAX;
         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {
        const S390FeatDef *def = s390_feat_def(feat);
        if (def->type == S390_FEAT_TYPE_STFL) {
            unsigned bit = def->bit;
            if (bit > max_bit) {
                max_bit = bit;
            }
            assert(bit / 64 < MAX_STFL_WORDS);
            words[bit / 64] |= 1ULL << (63 - bit % 64);
        }
    }
    return max_bit / 64;
}","static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])
{
    AVCodecContext * avnc;
    MP3On4DecodeContext *this = avnc->priv_data;
    MP3On4DecodeContext *this = avnc->priv_data;
    this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
    avnc->channels = mp3Channels[this->chan_cfg];
    avnc->priv_data = this->mp3decctx[0];
    decode_init(avnc);
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p_9,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p_9);
    avnc->priv_data = this;
    S390CPU *cpu = s390_env_get_cpu(env);
    const unsigned long *features = cpu->model->features;
    unsigned max_bit = 0;
    S390Feat feat;
    struct sk_buff *skb;
    struct hci_dev *hdev;
    void *settings;
    __u8 status = *((__u8 *) skb->data);
    settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
    data = get_unaligned_le16(settings);
    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);
    if (test_bit(S390_FEAT_ZARCH, features)) {
        words[0] = 1ull << (63 - 2);
    }
    for (feat = find_first_bit(features, S390_FEAT_MAX);
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    err = extract32(ksns, 16, 5);
    handle_fp_compare(qs, order, coll, err, false, p);
         feat < S390_FEAT_MAX;
         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            const S390FeatDef *def = s390_feat_def(feat);
        strcpy(str, ""a"");
        }
        if (def->type == S390_FEAT_TYPE_STFL) {
            unsigned bit = def->bit;
            if (bit > max_bit) {
                max_bit = bit;
            }
            assert(bit / 64 < MAX_STFL_WORDS);
            words[bit / 64] |= 1ULL << (63 - bit % 64);
        }
    }
    return max_bit / 64;
}",0,1,115,1.61,Insert
810,,,,,,,
813,"S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)
{
    S390CPU *cpu;
    Error *err = NULL;
    cpu = cpu_s390x_create(cpu_model, &err);
    if (err != NULL) {
        goto out;
    }
    object_property_set_int(OBJECT(cpu), core_id, ""core-id"", &err);
    if (err != NULL) {
        goto out;
    }
    object_property_set_bool(OBJECT(cpu), true, ""realized"", &err);
out:
    if (err) {
        error_propagate(errp, err);
        object_unref(OBJECT(cpu));
        cpu = NULL;
    }
    return cpu;
}","S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        S390CPU *cpu;
        b = a;
    }
    Error *err = NULL;
    cpu = cpu_s390x_create(cpu_model, &err);
    if (err != NULL) {
        goto out;
    }
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_4;
    a_4 = ldb_schema_attribute_by_name(ydm, attr);
    object_property_set_int(OBJECT(cpu), core_id, ""core-id"", &err);
    if (err != NULL) {
        goto out;
    }
    object_property_set_bool(OBJECT(cpu), true, ""realized"", &err);
out:
    if (err) {
        error_propagate(errp, err);
        object_unref(OBJECT(cpu));
        cpu = NULL;
    }
    struct domain_device *dev;
    struct asd_sas_port *port;
    struct sas_ha_struct *ha = port->ha;
    sas_notify_lldd_dev_gone(dev);
    spin_lock_irq(&port->dev_list_lock);
    list_del_init(&dev->dev_list_node);
    spin_unlock_irq(&port->dev_list_lock);
    sas_put_device(dev);
    return cpu;
}",0,1,56,1.0,Insert
814,"aio_compute_timeout(AioContext *ctx)
{
    int64_t deadline;
    int timeout = -1;
    QEMUBH *bh;
    for (bh = atomic_rcu_read(&ctx->first_bh); bh;
         bh = atomic_rcu_read(&bh->next)) {
        if (bh->scheduled) {
            if (bh->idle) {
                timeout = 10000000;
            } else {
                return 0;
            }
        }
    }
    deadline = timerlistgroup_deadline_ns(&ctx->tlg);
    if (deadline == 0) {
        return 0;
    } else {
        return qemu_soonest_timeout(timeout, deadline);
    }
}","aio_compute_timeout(AioContext *ctx)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        int64_t deadline;
        b = a;
    }
    int timeout = -1;
    QEMUBH *bh;
    for (bh = atomic_rcu_read(&ctx->first_bh); bh;
         bh = atomic_rcu_read(&bh->next)) {
        if (bh->scheduled) {
            if (bh->idle) {
                timeout = 10000000;
            } else {
                return 0;
            }
        }
    }
    deadline = timerlistgroup_deadline_ns(&ctx->tlg);
    if (deadline == 0) {
        return 0;
    } else {
        return qemu_soonest_timeout(timeout, deadline);
    }
}",0,1,17,0.28,Replace
815,,,,,,,
817,,,,,,,
818,"static int video_open(VideoState *is){
    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;
    int w,h;
    if(is_full_screen) flags |= SDL_FULLSCREEN;
    else               flags |= SDL_RESIZABLE;
    if (is_full_screen && fs_screen_width) {
        w = fs_screen_width;
        h = fs_screen_height;
    } else if(!is_full_screen && screen_width){
        w = screen_width;
        h = screen_height;
    }else if (is->video_st && is->video_st->codec->width){
        w = is->video_st->codec->width;
        h = is->video_st->codec->height;
    } else {
        w = 640;
        h = 480;
    }
#ifndef SYS_DARWIN
    screen = SDL_SetVideoMode(w, h, 0, flags);
#else
    screen = SDL_SetVideoMode(w, h, 24, flags);
#endif
    if (!screen) {
        fprintf(stderr, ""SDL: could not set video mode - exiting\n"");
        return -1;
    }
    SDL_WM_SetCaption(""FFplay"", ""FFplay"");
    is->width = screen->w;
    is->height = screen->h;
    return 0;
}","static int video_open(VideoState *is){
    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;
    int w,h;
    if(is_full_screen) flags |= SDL_FULLSCREEN;
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    else               flags |= SDL_RESIZABLE;
    if (is_full_screen && fs_screen_width) {
        w = fs_screen_width;
        h = fs_screen_height;
    } else if(!is_full_screen && screen_width){
        w = screen_width;
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            h = screen_height;
        strcpy(str, ""a"");
        }
    }else if (is->video_st && is->video_st->codec->width){
        w = is->video_st->codec->width;
        h = is->video_st->codec->height;
    } else {
        w = 640;
        h = 480;
    }
#ifndef SYS_DARWIN
    screen = SDL_SetVideoMode(w, h, 0, flags);
#else
    screen = SDL_SetVideoMode(w, h, 24, flags);
#endif
    if (!screen) {
        fprintf(stderr, ""SDL: could not set video mode - exiting\n"");
        return -1;
    }
    SDL_WM_SetCaption(""FFplay"", ""FFplay"");
    is->width = screen->w;
    is->height = screen->h;
    return 0;
}",0,1,47,1.21,Insert
819,"static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)
{
    struct nand_state_t *s = opaque;
    uint32_t r;
    int rdy;
    r = nand_getio(s->nand);
    nand_getpins(s->nand, &rdy);
    s->rdy = rdy;
    DNAND(printf(""%s addr=%x r=%x\n"", __func__, addr, r));
    return r;
}","static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)
{
    struct nand_state_t *s = opaque;
    uint32_t r;
    int rdy;
    r = nand_getio(s->nand);
    nand_getpins(s->nand, &rdy);
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    qdev_init_nofail(mem);
    busDev = SYS_BUS_DEVICE(mem);
    s->rdy = rdy;
    char str1[] = ""Constant"";
    AVStream *tmp;
    AVFormatContext *aws;
    uint32_t v, spf;
    MPADecodeHeader ch;
    MP3DecContext *MPthree = aws->priv_data;
    if (MPthree->frames)
            tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                        tmp->time_base);
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        DNAND(printf(""%s addr=%x r=%x\n"", __func__, addr, r));
    }
    target_phys_addr_t espaddr;
    SysBusDevice *s_2;
    sysbus_mmio_map(s_2, 0, espaddr);
    return r;
}",0,1,87,1.02,Insert
820,,,,,,,
821,,,,,,,
823,"static void put_uint8(QEMUFile *f, void *pv, size_t size)
{
    uint8_t *v = pv;
    qemu_put_8s(f, v);
}","static void put_uint8(QEMUFile *f, void *pv, size_t size)
{
    SwsContext *c;
    const enum PixelFormat srcFormat = c->srcFormat;
    const enum PixelFormat dstFormat = c->dstFormat;
    const enum PixelFormat srcFormat = c->srcFormat;
    if ((srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) &&
            (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21)) {
            c->swScale = planarToNv12Wrapper;
    }
    uint8_t *v = pv;
    int planes;
    size_t input_forwards_size;
    uint8_t* input_window;
    size_t input_backwards_size;
    uint8_t* input_stack[MAX_FAST_RE_STACK];
    uint8_t* input = input_window;
    int sp = 0;
    int max_bytes_matched;
    int input_incr;
    max_bytes_matched = planes & RE_FLAGS_BACKWARDS ?
          (int) input_backwards_size :
          (int) input_forwards_size;
    input_incr = planes & RE_FLAGS_BACKWARDS ? -1 : 1;
    input_stack[sp] = input;
    int a = 19;
    int b = a;
    if(a*b>0){
        qemu_put_8s(f, v);
    }
}",1,0,35,0.55,Insert
826,"static void qemu_tcg_init_vcpu(CPUState *cpu)
{
    char thread_name[VCPU_THREAD_NAME_SIZE];
    static QemuCond *tcg_halt_cond;
    static QemuThread *tcg_cpu_thread;
    if (!tcg_cpu_thread) {
        cpu->thread = g_malloc0(sizeof(QemuThread));
        cpu->halt_cond = g_malloc0(sizeof(QemuCond));
        qemu_cond_init(cpu->halt_cond);
        tcg_halt_cond = cpu->halt_cond;
        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, ""CPU %d/TCG"",
                 cpu->cpu_index);
        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,
                           cpu, QEMU_THREAD_JOINABLE);
#ifdef _WIN32
        cpu->hThread = qemu_thread_get_handle(cpu->thread);
#endif
        while (!cpu->created) {
            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
        }
        tcg_cpu_thread = cpu->thread;
    } else {
        cpu->thread = tcg_cpu_thread;
        cpu->halt_cond = tcg_halt_cond;
    }
}","static void qemu_tcg_init_vcpu(CPUState *cpu)
{
    char thread_name[VCPU_THREAD_NAME_SIZE];
    static QemuCond *tcg_halt_cond;
    static QemuThread *tcg_cpu_thread;
    if (!tcg_cpu_thread) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            cpu->thread = g_malloc0(sizeof(QemuThread));
        strcpy(str, ""a"");
        }
        cpu->halt_cond = g_malloc0(sizeof(QemuCond));
        qemu_cond_init(cpu->halt_cond);
        tcg_halt_cond = cpu->halt_cond;
        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, ""CPU %d/TCG"",
                 cpu->cpu_index);
        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,
                           cpu, QEMU_THREAD_JOINABLE);
#ifdef _WIN32
        cpu->hThread = qemu_thread_get_handle(cpu->thread);
#endif
        while (!cpu->created) {
            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
        }
        tcg_cpu_thread = cpu->thread;
    } else {
        cpu->thread = tcg_cpu_thread;
        cpu->halt_cond = tcg_halt_cond;
    }
}",1,0,1,0.19,Replace
827,"ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)
{
    ssize_t ret;
#ifdef CONFIG_VNC_TLS
    if (vs->tls.session) {
        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);
    } else {
#endif  
        ret = send(vs->csock, (const void *)data, datalen, 0);
#ifdef CONFIG_VNC_TLS
    }
#endif  
    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);
    return vnc_client_io_error(vs, ret, socket_error());
}","ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)
{
    ssize_t ret;
#ifdef CONFIG_VNC_TLS
    if (vs->tls.session) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            ret = vnc_client_write_tls(&vs->tls.session, data, datalen);
        }
    } else {
#endif  
        ret = send(vs->csock, (const void *)data, datalen, 0);
#ifdef CONFIG_VNC_TLS
    }
#endif
struct atusb *atusb;
struct usb_device *bus_name = atusb->bus_name;
int ret_1;
struct usb_device *bus_name = atusb->bus_name;
unsigned char buffer[3];
if (ret_1 >= 0) {
		atusb->fw_ver_maj = buffer[0];
		atusb->fw_ver_min = buffer[1];
		atusb->fw_hw_type = buffer[2];
		dev_info(&bus_name->dev,
			 ""Firmware: major: %u, minor: %u, hardware type: %u
"",
			 atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);
}  
    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);
    return vnc_client_io_error(vs, ret, socket_error());
}",1,0,10,0.48,Insert
829,"static int libgsm_decode_frame(AVCodecContext *avctx,
                               void *data, int *data_size,
                               AVPacket *avpkt) {
    uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);
    if (*data_size < out_size) {
        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");
        return AVERROR(EINVAL);
    }
    if (buf_size < avctx->block_align) {
        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");
        return AVERROR_INVALIDDATA;
    }
    switch(avctx->codec_id) {
    case CODEC_ID_GSM:
        if(gsm_decode(avctx->priv_data,buf,data)) return -1;
        break;
    case CODEC_ID_GSM_MS:
        if(gsm_decode(avctx->priv_data,buf,data) ||
           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;
    }
    *data_size = out_size;
    return avctx->block_align;
}","static int libgsm_decode_frame(AVCodecContext *avctx,
                               void *data, int *data_size,
                               AVPacket *avpkt) {
    uint64_t glms;
    unsigned k, b_7, err, C;
    unsigned k, b_7, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_7 = ctz64(glms);
    uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);
    if (*data_size < out_size) {
        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");
        return AVERROR(EINVAL);
    }
    if (buf_size < avctx->block_align) {
        int a = 2;
        int b = 2;
        if (a == b) {
            av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");
        }
        return AVERROR_INVALIDDATA;
    }
    switch(avctx->codec_id) {
    case CODEC_ID_GSM:
        if(gsm_decode(avctx->priv_data,buf,data)) return -1;
        break;
    case CODEC_ID_GSM_MS:
        if(gsm_decode(avctx->priv_data,buf,data) ||
           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;
    }
    *data_size = out_size;
    return avctx->block_align;
}",0,1,27,0.88,Insert
830,,,,,,,
832,,,,,,,
834,"static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, int *num_same)
{
    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;
    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;
    uint8_t bitmap[BDRV_SECTOR_SIZE];
    int ret;
    int changed;
    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));
    if (ret < 0) {
        return ret;
    }
    bitnum &= BITS_PER_BITMAP_SECTOR - 1;
    changed = cow_test_bit(bitnum, bitmap);
    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);
    return changed;
}","static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, int *num_same)
{
    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;
    strcpy(str, ""a"");
    }
    uint8_t bitmap[BDRV_SECTOR_SIZE];
    int ret;
    int changed;
    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));
    if (ret < 0) {
        return ret;
    }
    bitnum &= BITS_PER_BITMAP_SECTOR - 1;
    changed = cow_test_bit(bitnum, bitmap);
    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);
    return changed;
}",1,0,4,0.16,Replace
835,"bool timerlist_expired(QEMUTimerList *timer_list)
{
    int64_t expire_time;
    if (!atomic_read(&timer_list->active_timers)) {
        return false;
    }
    qemu_mutex_lock(&timer_list->active_timers_lock);
    if (!timer_list->active_timers) {
        qemu_mutex_unlock(&timer_list->active_timers_lock);
        return false;
    }
    expire_time = timer_list->active_timers->expire_time;
    qemu_mutex_unlock(&timer_list->active_timers_lock);
    return expire_time < qemu_clock_get_ns(timer_list->clock->type);
}","bool timerlist_expired(QEMUTimerList *timer_list)
{
    int64_t expire_time;
    if (!atomic_read(&timer_list->active_timers)) {
        return false;
    }
    qemu_mutex_lock(&timer_list->active_timers_lock);
    if (!timer_list->active_timers) {
        qemu_mutex_unlock(&timer_list->active_timers_lock);
        int a = 2;
        int b = 3;
        while (a != b) {
            return false;
            b = a;
        }
    }
    expire_time = timer_list->active_timers->expire_time;
    qemu_mutex_unlock(&timer_list->active_timers_lock);
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    return expire_time < qemu_clock_get_ns(timer_list->clock->type);
}",0,1,19,0.5,Insert
838,"static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
{
    uint64_t start = MAX(r1.start, r2.start);
    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);
    return addrrange_make(start, end - start + 1);
}","static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
{
    AVCodecContext *avctx;
    PixletContext *tc = avctx->priv_data;
    PixletContext *tc = avctx->priv_data;
    if (tc->depth < 8 || tc->depth > 15) {
            avpriv_request_sample(avctx, ""Depth %d"", tc->depth);
    }
    uint64_t start = MAX(r1.start, r2.start);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);
    }
    return addrrange_make(start, end - start + 1);
}",1,0,7,0.48,Insert
842,"static uint32_t dcr_read_pob (void *opaque, int dcrn)
{
    ppc4xx_pob_t *pob;
    uint32_t ret;
    pob = opaque;
    switch (dcrn) {
    case POB0_BEAR:
        ret = pob->bear;
        break;
    case POB0_BESR0:
    case POB0_BESR1:
        ret = pob->besr[dcrn - POB0_BESR0];
        break;
    default:
        ret = 0;
        break;
    }
    return ret;
}","static uint32_t dcr_read_pob (void *opaque, int dcrn)
{
    int ret_8 = 0;
    if (ret_8 < 0) {
            fprintf(stderr, ""ERROR writing reftable: %s
    "", strerror(-ret_8));
            goto fail;
    }
    ppc4xx_pob_t *pob;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        uint32_t ret;
    }
    pob = opaque;
    switch (dcrn) {
    case POB0_BEAR:
        ret = pob->bear;
        break;
    case POB0_BESR0:
    case POB0_BESR1:
        ret = pob->besr[dcrn - POB0_BESR0];
        break;
    default:
        ret = 0;
        break;
    }
    return ret;
}",1,0,21,0.56,Insert
848,"av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)
{
    VAAPIEncodeContext *ctx = avctx->priv_data;
    VAAPIEncodePicture *pic, *next;
    for (pic = ctx->pic_start; pic; pic = next) {
        next = pic->next;
        vaapi_encode_free(avctx, pic);
    }
    if (ctx->va_context != VA_INVALID_ID) {
        vaDestroyContext(ctx->hwctx->display, ctx->va_context);
        ctx->va_context = VA_INVALID_ID;
    }
    if (ctx->va_config != VA_INVALID_ID) {
        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);
        ctx->va_config = VA_INVALID_ID;
    }
    if (ctx->codec->close)
        ctx->codec->close(avctx);
    av_buffer_pool_uninit(&ctx->output_buffer_pool);
    av_freep(&ctx->codec_sequence_params);
    av_freep(&ctx->codec_picture_params);
    av_buffer_unref(&ctx->recon_frames_ref);
    av_buffer_unref(&ctx->input_frames_ref);
    av_buffer_unref(&ctx->device_ref);
    av_freep(&ctx->priv_data);
    return 0;
}","av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)
{
    VAAPIEncodeContext *ctx = avctx->priv_data;
    VAAPIEncodePicture *pic, *next;
    for (pic = ctx->pic_start; pic; pic = next) {
        next = pic->next;
        vaapi_encode_free(avctx, pic);
    }
    if (ctx->va_context != VA_INVALID_ID) {
        vaDestroyContext(ctx->hwctx->display, ctx->va_context);
        ctx->va_context = VA_INVALID_ID;
    }
    if (ctx->va_config != VA_INVALID_ID) {
        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);
        ctx->va_config = VA_INVALID_ID;
    }
    if (ctx->codec->close)
        ctx->codec->close(avctx);
    av_buffer_pool_uninit(&ctx->output_buffer_pool);
    av_freep(&ctx->codec_sequence_params);
    av_freep(&ctx->codec_picture_params);
    av_buffer_unref(&ctx->recon_frames_ref);
    av_buffer_unref(&ctx->input_frames_ref);
    av_buffer_unref(&ctx->device_ref);
    av_freep(&ctx->priv_data);
    int a = 2;
    int b = 3;
    while (a < b) {
        return 0;
        b = a;
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    }
}",0,1,33,0.86,Insert
849,"static ssize_t socket_read(int sockfd, void *buff, size_t size)
{
    ssize_t retval, total = 0;
    while (size) {
        retval = read(sockfd, buff, size);
        if (retval == 0) {
            return -EIO;
        }
        if (retval < 0) {
            if (errno == EINTR) {
                continue;
            }
            return -errno;
        }
        size -= retval;
        buff += retval;
        total += retval;
    }
    return total;
}","static ssize_t socket_read(int sockfd, void *buff, size_t size)
{
    ssize_t retval, total = 0;
    while (size) {
        retval = read(sockfd, buff, size);
        if (retval == 0) {
            return -EIO;
        }
        if (retval < 0) {
            if (errno == EINTR) {
                continue;
            }
            int a = 2;
            int b = 3;
            if (a != b) {
                return -errno;
            }
            uint64_t glms;
            unsigned k, b_5, err, C;
            unsigned k, b_5, err, C;
            assert(is_limm(glms));
            k = clz64(glms);
            b_5 = ctz64(glms);
        }
        size -= retval;
        buff += retval;
        total += retval;
    }
    return total;
}",0,1,21,0.56,Insert
850,"AioContext *blk_get_aio_context(BlockBackend *blk)
{
    return bdrv_get_aio_context(blk->bs);
}","AioContext *blk_get_aio_context(BlockBackend *blk)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        DisasContext *qs;
        uint32_t ksns;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        order = extract32(ksns, 22, 2);
        handle_fp_compare(qs, order, coll, err, false, p);
        return bdrv_get_aio_context(blk->bs);
        b = a;
    }
}",0,1,4,0.29,Insert
852,"UuidInfo *qmp_query_uuid(Error **errp)
{
    UuidInfo *info = g_malloc0(sizeof(*info));
    char uuid[64];
    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],
                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],
                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],
                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],
                   qemu_uuid[14], qemu_uuid[15]);
    info->UUID = g_strdup(uuid);
    return info;
}","UuidInfo *qmp_query_uuid(Error **errp)
{
    UuidInfo *info = g_malloc0(sizeof(*info));
    char uuid[64];
    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],
                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],
                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],
                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],
                   qemu_uuid[14], qemu_uuid[15]);
                   Rocker *r;
                   DescInfo *info_8;
                   char *buf = desc_get_buf(info_8, true);
                   PCIDevice *dev = PCI_DEVICE(r);
                   uint32_t pport;
                   pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info_8));
    info->UUID = g_strdup(uuid);
    int a = 2;
    int b = 3;
    while (a < b) {
        return info;
        b = a;
    }
}",0,1,11,0.65,Insert
856,"static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)
{
    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);
    DeviceState *vdev = DEVICE(&dev->vdev);
    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));
    if (qdev_init(vdev) < 0) {
        return -1;
    }
    object_property_set_link(OBJECT(dev),
                             OBJECT(dev->vdev.conf.default_backend), ""rng"",
                             NULL);
    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));
}","static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)
{
    char str[] = ""Constant"";
    void * user_database;
    uint8_t opcode;
    struct gatt_db_attribute *attr;
    struct async_write_op *cmp = NULL;
    struct bt_gatt_server *server =  user_database;
    uint8_t ecode;
    ecode = authorize_req(server, opcode, handle);
    attr = gatt_db_get_attribute(server->db, handle);
    util_debug(server->debug_callback, server->debug_data,
    				""Write %s - handle: 0x%04x"",
    				(opcode == BT_ATT_OP_WRITE_REQ) ? ""Req"" : ""Cmd"",
    				handle);
    ecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);
    cmp->server = bt_gatt_server_ref(server);
    while (strlen(str) > 5) {
        VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);
    strcpy(str, ""a"");
    }
    DeviceState *vdev = DEVICE(&dev->vdev);
    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));
    if (qdev_init(vdev) < 0) {
        return -1;
    }
    object_property_set_link(OBJECT(dev),
                             OBJECT(dev->vdev.conf.default_backend), ""rng"",
                             NULL);
    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));
}",1,0,12,0.5,Insert
857,"static void apic_update_irq(APICState *s)
{
    int irrv, ppr;
    if (!(s->spurious_vec & APIC_SV_ENABLE))
        return;
    irrv = get_highest_priority_int(s->irr);
    if (irrv < 0)
        return;
    ppr = apic_get_ppr(s);
    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))
        return;
    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
}","static void apic_update_irq(APICState *s)
{
    int irrv, ppr;
    if (!(s->spurious_vec & APIC_SV_ENABLE))
        return;
    irrv = get_highest_priority_int(s->irr);
    if (irrv < 0)
        return;
    ppr = apic_get_ppr(s);
    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))
        return;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
        BlockDriverState *bs;
        SheepdogInode *linade;
        BDRVSheepdogState *s_10 = bs->opaque;
        unsigned int datalen;
        memcpy(&s_10->linade, linade, datalen);
    }
}",0,1,9,0.48,Insert
859,,,,,,,
863,"static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a,
                           TCGArg b, bool b_const, TCGLabel *l)
{
    intptr_t offset;
    bool need_cmp;
    if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) {
        need_cmp = false;
    } else {
        need_cmp = true;
        tcg_out_cmp(s, ext, a, b, b_const);
    }
    if (!l->has_value) {
        tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0);
        offset = tcg_in32(s) >> 5;
    } else {
        offset = l->u.value_ptr - s->code_ptr;
        assert(offset == sextract64(offset, 0, 19));
    }
    if (need_cmp) {
        tcg_out_insn(s, 3202, B_C, c, offset);
    } else if (c == TCG_COND_EQ) {
        tcg_out_insn(s, 3201, CBZ, ext, a, offset);
    } else {
        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);
    }
}","static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a,
                           TCGArg b, bool b_const, TCGLabel *l)
{
    intptr_t offset;
    bool need_cmp;
    if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) {
        need_cmp = false;
    } else {
        need_cmp = true;
        register const xmlChar *m;
        m = ctxt->input->cur;
        char str_1[] = ""Constant"";
        while (strlen(str_1) > 5) {
            tcg_out_cmp(s, ext, a, b, b_const);
        strcpy(str_1, ""a"");
        }
    }
    if (!l->has_value) {
        tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0);
        offset = tcg_in32(s) >> 5;
    } else {
        offset = l->u.value_ptr - s->code_ptr;
        assert(offset == sextract64(offset, 0, 19));
        PutBitContext pb, pb2;
        JLSState *state;
        ls_store_lse(state, &pb);
        av_freep(&state);
        struct proto *prot;
        struct kmem_cache *slab;
        slab = prot->slab;
        av_freep(&state);
    }
    if (need_cmp) {
        tcg_out_insn(s, 3202, B_C, c, offset);
    } else if (c == TCG_COND_EQ) {
        tcg_out_insn(s, 3201, CBZ, ext, a, offset);
    } else {
        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);
    }
}",0,1,106,1.84,Insert
866,,,,,,,
869,"static int write_fragments(struct Tracks *tracks, int start_index,
                           AVIOContext *in)
{
    char dirname[100], filename[500];
    int i, j;
    for (i = start_index; i < tracks->nb_tracks; i++) {
        struct Track *track = tracks->tracks[i];
        const char *type    = track->is_video ? ""video"" : ""audio"";
        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);
        mkdir(dirname, 0777);
        for (j = 0; j < track->chunks; j++) {
            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",
                     dirname, type, track->offsets[j].time);
            avio_seek(in, track->offsets[j].offset, SEEK_SET);
            write_fragment(filename, in);
        }
    }
    return 0;
}","static int write_fragments(struct Tracks *tracks, int start_index,
                           AVIOContext *in)
{
    char dirname[100], filename[500];
    int a = 81;
    int b = a;
    if(a*b>0){
        int i, j;
    }
    for (i = start_index; i < tracks->nb_tracks; i++) {
        struct Track *track = tracks->tracks[i];
        const char *type    = track->is_video ? ""video"" : ""audio"";
        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);
        mkdir(dirname, 0777);
        for (j = 0; j < track->chunks; j++) {
            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",
                     dirname, type, track->offsets[j].time);
            avio_seek(in, track->offsets[j].offset, SEEK_SET);
            write_fragment(filename, in);
        }
    }
    return 0;
}",0,1,4,0.16,Replace
870,,,,,,,
871,,,,,,,
872,"static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,
                                 unsigned size)
{
    PICCommonState *s = opaque;
    return s->elcr;
}","static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,
                                 unsigned size)
{
    PICCommonState *s = opaque;
    AVPacket * pk;
    AVFormatContext *s_8;
    int size_7               =  pk->size_7;
    AVIOContext *b     = s_8->b;
    if (size_7 & 1)
            avio_w8(b, 0);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return s->elcr;
        VirtioCcwDevice *dev;
        VirtIODevice *vdev;
        SubchDev *sch;
        unsigned int cssid = 0;
        DeviceState *parent = DEVICE(dev);
        unsigned int schid;
        unsigned int ssid = 0;
        sch->id.cu_type = VIRTIO_CCW_CU_TYPE;
        vdev = virtio_ccw_get_vdev(sch);
        sch->id.cu_model = vdev->device_id;
        css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
                                  parent->hotplugged, 1);
        g_free(sch);
    }
}",0,1,37,0.5,Insert
874,,,,,,,
875,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,
                            const DisasInsn *di)
{
    unsigned r2 = extract32(insn, 21, 5);
    unsigned r1 = extract32(insn, 16, 5);
    unsigned cf = extract32(insn, 12, 4);
    unsigned rt = extract32(insn,  0, 5);
    TCGv tcg_r1, tcg_r2;
    ExitStatus ret;
    if (cf) {
        nullify_over(ctx);
    }
    tcg_r1 = load_gpr(ctx, r1);
    tcg_r2 = load_gpr(ctx, r2);
    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);
    return nullify_end(ctx, ret);
}","static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,
                            const DisasInsn *di)
{
    unsigned r2 = extract32(insn, 21, 5);
    unsigned r1 = extract32(insn, 16, 5);
    unsigned cf = extract32(insn, 12, 4);
    unsigned rt = extract32(insn,  0, 5);
    TCGv tcg_r1, tcg_r2;
    ExitStatus ret;
    if (cf) {
        nullify_over(ctx);
    }
    tcg_r1 = load_gpr(ctx, r1);
    tcg_r2 = load_gpr(ctx, r2);
    int a = 2;
    int b = 3;
    while (a != b) {
        ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);
        b = a;
    }
    return nullify_end(ctx, ret);
}",1,0,22,0.29,Replace
878,,,,,,,
883,,,,,,,
885,"VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)
{
    VIOsPAPRDevice *sdev;
    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);
    if (!sdev && reg == 0) {
        return spapr_vty_get_default(spapr->vio_bus);
    return sdev;","VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)
{
    VIOsPAPRDevice *sdev;
    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);
    if (!sdev && reg == 0) {
        int a = 2;
        int b = 3;
        while (a < b) {
            return spapr_vty_get_default(spapr->vio_bus);
            b = a;
        }
    return sdev;",1,0,4,0.09,Replace
886,,,,,,,
887,,,,,,,
889,"static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,
                               unsigned int epid)
{
    XHCISlot *slot;
    XHCIEPContext *epctx;
    int i;
    trace_usb_xhci_ep_disable(slotid, epid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    assert(epid >= 1 && epid <= 31);
    slot = &xhci->slots[slotid-1];
    if (!slot->eps[epid-1]) {
        DPRINTF(""xhci: slot %d ep %d already disabled\n"", slotid, epid);
        return CC_SUCCESS;
    xhci_ep_nuke_xfers(xhci, slotid, epid);
    epctx = slot->eps[epid-1];
    if (epctx->nr_pstreams) {
        xhci_free_streams(epctx);
    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);
    timer_free(epctx->kick_timer);
    g_free(epctx);
    slot->eps[epid-1] = NULL;
    return CC_SUCCESS;","static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,
                               unsigned int epid)
{
    XHCISlot *slot;
    XHCIEPContext *epctx;
    int i;
    trace_usb_xhci_ep_disable(slotid, epid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    assert(epid >= 1 && epid <= 31);
    slot = &xhci->slots[slotid-1];
    BlockDriverState *bs;
    BlockDriverState *base;
    Error **errp;
    int64_t length, base_length;
    const int index_6[4];
    double mul_2;
    int n_4 = 6;
    double mat_5[4][4];
    double kernel_8[] = {
            (5204 + 2520 * mul_2 + 1092 * mul2_10 + 3280 * mul3_5) / 12096,
            (2943 -  210 * mul_2 -  273 * mul2_10 - 2460 * mul3_5) / 12096,
            ( 486 -  924 * mul_2 -  546 * mul2_10 +  984 * mul3_5) / 12096,
             (  17 -  126 * mul_2 +  273 * mul2_10 -  164 * mul3_5) / 12096,
         };
    double mat_freq_7[13];
    memcpy_8(mat_freq_7, kernel_8, sizeof(kernel_8));
    memset_6(mat_freq_7 + 4, 0, sizeof(mat_freq_7) - sizeof(kernel_8));
    coeff_filter_8(mat_freq_7, n_4, kernel_8);
    calc_matrix_2(mat_5, mat_freq_7, index_6);
    int64_t length, base_length;
    if (length > base_length) {
            if (bdrv_truncate(base, length) < 0) {
                error_setg(errp, ""Top image %s is larger than base image %s, and ""
                                 ""resize of base image failed"",
                                 bs->filename, base->filename);
                goto error_restore_flags;
            }
    }
    if (!slot->eps[epid-1]) {
        DPRINTF(""xhci: slot %d ep %d already disabled\n"", slotid, epid);
        return CC_SUCCESS;
    xhci_ep_nuke_xfers(xhci, slotid, epid);
    epctx = slot->eps[epid-1];
    if (epctx->nr_pstreams) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            xhci_free_streams(epctx);
        }
        zend_bool duplicate;
        char *header_line;
        if (!duplicate)
        		efree(header_line);
    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);
    const int index[4];
    char buffer[32 * 1024 + 1];
    while (sleep_ >= 0 && send(sockfd, buffer, n_2, 0) == SOCKET_ERROR  ) {
            Sleep(snooze);
            sleep_ -= snooze;
    }
    double mul;
    int n = 6;
    double mat[4][4];
    double kernel[] = {
            (5204 + 2520 * mul + 1092 * mul2 + 3280 * mul3) / 12096,
            (2943 -  210 * mul -  273 * mul2 - 2460 * mul3) / 12096,
            ( 486 -  924 * mul -  546 * mul2 +  984 * mul3) / 12096,
             (  17 -  126 * mul +  273 * mul2 -  164 * mul3) / 12096,
         };
    double mat_freq[13];
    memcpy(mat_freq, kernel, sizeof(kernel));
    memset(mat_freq + 4, 0, sizeof(mat_freq) - sizeof(kernel));
    coeff_filter(mat_freq, n, kernel);
    calc_matrix(mat, mat_freq, index);
    timer_free(epctx->kick_timer);
    g_free(epctx);
    slot->eps[epid-1] = NULL;
    return CC_SUCCESS;",1,0,227,1.98,Insert
890,"int pvpanic_init(ISABus *bus)
{
    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);
    return 0;
}","int pvpanic_init(ISABus *bus)
{
    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return 0;
    }
}",1,0,2,0.05,Replace
895,"static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)
{
    int i;
    float (*output)[256] = ctx->audio_block.block_output;
    for (i = 0; i < 256; i++)
        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);
    memset(output[2], 0, sizeof(output[2]));
    memset(output[3], 0, sizeof(output[3]));
    memset(output[4], 0, sizeof(output[4]));
}","static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)
{
    int i;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        float (*output)[256] = ctx->audio_block.block_output;
    }
    for (i = 0; i < 256; i++)
        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        u32 i_2;
        for (i_2=0;i_2 < inter->nb_entries; i_2++) {
        		inter->entries[i_2].block_count = gf_bs_read_u16(bs);
        		inter->entries[i_2].block_size = gf_bs_read_u32(bs);
        }
    memset(output[2], 0, sizeof(output[2]));
    const char *fil;
    AVIOContext *pb;
    unsigned int base;
    unsigned char *result = NULL;
    int ret = 0, probe_size;
    AVProbeData pd = { fil ? fil : """", NULL, -base };
    ret = ffio_rewind_with_probe_data(pb, &result, pd.buf_size);
    memset(output[3], 0, sizeof(output[3]));
    struct inode *inode;
    wait_queue_head_t *wriq;
    DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
    wriq = bit_waitqueue(&inode->i_state, __I_NEW);
    spin_unlock(&inode->i_lock);
    spin_unlock(&inode_hash_lock);
    spin_lock(&inode_hash_lock);
    memset(output[4], 0, sizeof(output[4]));
}",0,1,73,1.02,Insert
896,,,,,,,
899,"static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,
                          int nb_sectors, QEMUIOVector *qiov,
                          int offset)
{
    BDRVNBDState *s = bs->opaque;
    struct nbd_request request;
    struct nbd_reply reply;
    request.type = NBD_CMD_READ;
    request.from = sector_num * 512;
    request.len = nb_sectors * 512;
    nbd_coroutine_start(s, &request);
    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {
        reply.error = errno;
    } else {
        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);
    }
    nbd_coroutine_end(s, &request);
    return -reply.error;
}","static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,
                          int nb_sectors, QEMUIOVector *qiov,
                          int offset)
{
    BDRVNBDState *s = bs->opaque;
    struct nbd_request request;
    struct nbd_reply reply;
    request.type = NBD_CMD_READ;
    request.from = sector_num * 512;
    request.len = nb_sectors * 512;
    nbd_coroutine_start(s, &request);
    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {
        reply.error = errno;
    } else {
        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);
    }
    nbd_coroutine_end(s, &request);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return -reply.error;
    strcpy(str, ""a"");
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
    aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                     aml_name(""CDW1"")));
    aml_append(ifconfig, ifconfig0);
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
    aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
                                     aml_name(""CDW1"")));
    }
}",0,1,36,0.91,Insert
900,,,,,,,
908,"target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,
                             target_ulong r2)
{
    int64_t t1 = extract64(r1, 0, 32);
    int64_t t2 = extract64(r2, 0, 32);
    int64_t result = t1 * t2;
    return suov32(env, result);
}","target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,
                             target_ulong r2)
{
    BlockDriverState *bs;
    IscsiLun *iscsilun = bs->opaque;
    IscsiLun *iscsilun = bs->opaque;
    if (iscsilun->bl.opt_xfer_len &&
            iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {
            bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *
                                            iscsilun->block_size);
    }
    int64_t t1 = extract64(r1, 0, 32);
    int64_t t2 = extract64(r2, 0, 32);
    int64_t result = t1 * t2;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return suov32(env, result);
    }
}",1,0,18,0.52,Insert
910,"static void virtio_rng_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);
    dc->props = virtio_rng_properties;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    vdc->realize = virtio_rng_device_realize;
    vdc->unrealize = virtio_rng_device_unrealize;
    vdc->get_features = get_features;
    vdc->load = virtio_rng_load_device;
}","static void virtio_rng_class_init(ObjectClass *klass, void *data)
{
    BlockDriverCompletionFunc *cb;
    Error **errp;
    int64_t speed;
    BlockDriverState *base;
    void *opaque;
    BlockDriverState *bc;
    Coroutine *co;
    StreamBlockJob *s;
    s = block_job_create(&stream_job_type, bc, speed, cb, opaque, errp);
    AVFormatContext *s_3;
    AVStream   *st = NULL;
    ASFContext *asf       = s_3->priv_data;
    int ret, type, picsize, desc_len;
    if (av_dict_set(&st->metadata, ""comment"", ff_id3v2_picture_types[type], 0) < 0)
            av_log(s_3, AV_LOG_WARNING, ""av_dict_set failed.
    "");
    trace_stream_start(bc, base, s, co, opaque);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    MOVTrack *track;
    AVIOContext *pb;
    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
                                          track->timescale, AV_ROUND_UP);
    int version = duration < INT32_MAX ? 0 : 1;
    if (version == 1) {
            avio_wb64(pb, track->time);
            avio_wb64(pb, track->time);
        } else {
            avio_wb32(pb, track->time);  
            avio_wb32(pb, track->time);  
    }
    if (strcmp(str1, str2) == 0) {
        DeviceClass *dc = DEVICE_CLASS(klass);
    }
    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);
    dc->props = virtio_rng_properties;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    vdc->realize = virtio_rng_device_realize;
    vdc->unrealize = virtio_rng_device_unrealize;
    vdc->get_features = get_features;
    vdc->load = virtio_rng_load_device;
}",1,0,77,0.91,Insert
915,"static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)
{
    DeviceState *dev;
    SysBusDevice *s;
    RamDevice *d;
    dev = qdev_create(NULL, ""memory"");
    s = sysbus_from_qdev(dev);
    d = FROM_SYSBUS(RamDevice, s);
    d->size = RAM_size;
    qdev_init(dev);
    sysbus_mmio_map(s, 0, addr);
}","static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)
{
    AVCodecContext *avctx;
    Mpeg1Context *s1  = avctx->priv_data;
    MpegEncContext *s_10 = &s1->mpeg_enc_ctx;
    if (s_10->avctx->hwaccel) {
            if (s_10->avctx->hwaccel->end_frame(s_10->avctx) < 0)
                av_log(avctx, AV_LOG_ERROR,
                       ""hardware accelerator failed to decode picture
    "");
    }
    DeviceState *dev;
    SysBusDevice *s;
    RamDevice *d;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        dev = qdev_create(NULL, ""memory"");
    strcpy(str, ""a"");
    }
    s = sysbus_from_qdev(dev);
    d = FROM_SYSBUS(RamDevice, s);
    d->size = RAM_size;
    qdev_init(dev);
    sysbus_mmio_map(s, 0, addr);
}",1,0,21,0.6,Insert
921,,,,,,,
922,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)
{
    uint32_t startlen = read_u32(data, 0);
    VNC_DEBUG(""Got client start len %d\n"", startlen);
    if (startlen > SASL_DATA_MAX_LEN) {
        VNC_DEBUG(""Too much SASL data %d\n"", startlen);
        vnc_client_error(vs);
        return -1;
    }
    if (startlen == 0)
        return protocol_client_auth_sasl_start(vs, NULL, 0);
    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);
    return 0;
}","static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        uint32_t startlen = read_u32(data, 0);
    }
    VNC_DEBUG(""Got client start len %d\n"", startlen);
    if (startlen > SASL_DATA_MAX_LEN) {
        VNC_DEBUG(""Too much SASL data %d\n"", startlen);
        vnc_client_error(vs);
        return -1;
    }
    if (startlen == 0)
        return protocol_client_auth_sasl_start(vs, NULL, 0);
    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);
    return 0;
}",1,0,2,0.12,Replace
923,"static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,
                                  cavs_vector *col_mv)
{
    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;
    int den = h->direct_den[col_mv->ref];
    int m = FF_SIGNBIT(col_mv->x);
    pmv_fw->dist = h->dist[1];
    pmv_bw->dist = h->dist[0];
    pmv_fw->ref = 1;
    pmv_bw->ref = 0;
    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;
    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);
    m = FF_SIGNBIT(col_mv->y);
    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;
    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);
}","static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,
                                  cavs_vector *col_mv)
{
    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;
    int64_t speed;
    BlockJob *job;
    StreamBlockJob *s = container_of(job, StreamBlockJob, common);
    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);
    int den = h->direct_den[col_mv->ref];
    int m = FF_SIGNBIT(col_mv->x);
    pmv_fw->dist = h->dist[1];
    pmv_bw->dist = h->dist[0];
    pmv_fw->ref = 1;
    pmv_bw->ref = 0;
    int a = 2;
    int b = 2;
    while (a == b) {
        pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;
        b += 1;
    }
    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);
    m = FF_SIGNBIT(col_mv->y);
    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;
    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);
}",1,0,35,1.07,Insert
924,,,,,,,
925,"static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,
                                target_ulong pc2, TCGv r_cond)
{
    int l1;
    l1 = gen_new_label();
    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);
    gen_goto_tb(dc, 0, pc2, pc1);
    gen_set_label(l1);
    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);
}","static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,
                                target_ulong pc2, TCGv r_cond)
{
    CPUState *env;
    const sigset_t *sigset;
    struct kvm_signal_mask * sigmak;
    int r;
    sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
    sigmak->len = 8;
    memcpy( sigmak->sigset, sigset, sizeof(*sigset));
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
    free( sigmak);
    int l1;
    l1 = gen_new_label();
    int a = 2;
    int b = 3;
    while (a != b) {
        tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);
        b = a;
    }
    gen_goto_tb(dc, 0, pc2, pc1);
    gen_set_label(l1);
    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);
}",0,1,14,0.53,Insert
929,,,,,,,
930,"static void free_geotags(TiffContext *const s)
{
    int i;
    for (i = 0; i < s->geotag_count; i++) {
        if (s->geotags[i].val)
            av_freep(&s->geotags[i].val);
    }
    av_freep(&s->geotags);
}","static void free_geotags(TiffContext *const s)
{
    int i;
    for (i = 0; i < s->geotag_count; i++) {
        if (s->geotags[i].val)
            av_freep(&s->geotags[i].val);
    }
    int a = 2;
    int b = 3;
    AVFormatContext *s_9;
    char playback_time[AV_TIMECODE_STR_SIZE];
    AVIOContext *pb = s_9->pb;
    AVIOContext *pb = s_9->pb;
    av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);
    av_dict_set(&s_9->metadata, ""playback_time"", playback_time, 0);
    while (a != b) {
        av_freep(&s->geotags);
        b = a;
    }
}",1,0,5,0.4,Insert
931,"void ff_bink_idct_c(DCTELEM *block)
{
    int i;
    DCTELEM temp[64];
    for (i = 0; i < 8; i++)
        bink_idct_col(&temp[i], &block[i]);
    for (i = 0; i < 8; i++) {
        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );
    }
}","void ff_bink_idct_c(DCTELEM *block)
{
    int i;
    DCTELEM temp[64];
    for (i = 0; i < 8; i++)
        bink_idct_col(&temp[i], &block[i]);
    for (i = 0; i < 8; i++) {
        int a = 2;
        int b = 2;
        MpegEncContext *s;
        double q;
        RateControlEntry *rce;
        RateControlContext *rcc= &s->rc_context;
        const double last_non_b_q= rcc->last_qscale_for[rcc->last_non_b_pict_type];
        AVCodecContext *a_8= s->avctx;
        const int pict_type= rce->new_pict_type;
        const double last_p_q    = rcc->last_qscale_for[P_TYPE];
        if     (pict_type==I_TYPE && (a_8->i_quant_factor>0.0 || rcc->last_non_b_pict_type==P_TYPE))
                q= last_p_q    *FFABS(a_8->i_quant_factor) + a_8->i_quant_offset;
            else if(pict_type==B_TYPE && a_8->b_quant_factor>0.0)
                q= last_non_b_q*    a_8->b_quant_factor  + a_8->b_quant_offset;
        if (a == b) {
            IDCT_ROW( (&block[8*i]), (&temp[8*i]) );
        }
    }
}",1,0,16,0.53,Insert
932,"PCIBus *pci_pmac_init(qemu_irq *pic)
{
    DeviceState *dev;
    SysBusDevice *s;
    UNINState *d;
    dev = qdev_create(NULL, ""Uni-north main"");
    qdev_init_nofail(dev);
    s = sysbus_from_qdev(dev);
    d = FROM_SYSBUS(UNINState, s);
    d->host_state.bus = pci_register_bus(&d->busdev.qdev, ""pci"",
                                         pci_unin_set_irq, pci_unin_map_irq,
                                         pic, 11 << 3, 4);
    pci_create_simple(d->host_state.bus, 11 << 3, ""Uni-north main"");
    sysbus_mmio_map(s, 0, 0xf2800000);
    sysbus_mmio_map(s, 1, 0xf2c00000);
#if 0
    pci_create_simple(d->host_state.bus, 12 << 3, ""DEC 21154"");
#endif
    pci_create_simple(d->host_state.bus, 13 << 3, ""Uni-north AGP"");
#if 0
    pci_create_simple(d->host_state.bus, 14 << 3, ""Uni-north internal"");
#endif
    return d->host_state.bus;
}","PCIBus *pci_pmac_init(qemu_irq *pic)
{
    DeviceState *dev;
    SysBusDevice *s;
    UNINState *d;
    dev = qdev_create(NULL, ""Uni-north main"");
    qdev_init_nofail(dev);
    s = sysbus_from_qdev(dev);
    d = FROM_SYSBUS(UNINState, s);
    d->host_state.bus = pci_register_bus(&d->busdev.qdev, ""pci"",
                                         pci_unin_set_irq, pci_unin_map_irq,
                                         pic, 11 << 3, 4);
    pci_create_simple(d->host_state.bus, 11 << 3, ""Uni-north main"");
    sysbus_mmio_map(s, 0, 0xf2800000);
    sysbus_mmio_map(s, 1, 0xf2c00000);
#if 0
    int a = 2;
    int b = 3;
    while (a != b) {
        pci_create_simple(d->host_state.bus, 12 << 3, ""DEC 21154"");
        b = a;
    }
#endif
CPUState *cpu;
CPUState *cpu_2;
int prot_2;
hwaddr paddr_10;
target_ulong vaddr_7;
MemTxAttrs attrs_3;
hwaddr iotlb_10, xlat_2, sz_8;
hwaddr iotlb_10, xlat_2, sz_8;
MemoryRegionSection *section_10;
int asidx_8 = cpu_asidx_from_attrs_6(cpu_2, attrs_3);
hwaddr iotlb_10, xlat_2, sz_8;
CPUArchState *env_2 = cpu_2->env_ptr;
target_ulong address_2;
section_10 = address_space_translate_for_iotlb_4(cpu_2, asidx_8, paddr_10, &xlat_2, &sz_8);
iotlb_10 = memory_region_section_get_iotlb_7(cpu_2, section_10, vaddr_7, paddr_10, xlat_2,
                                            prot_2, &address_2);
int prot;
hwaddr paddr;
target_ulong vaddr;
MemTxAttrs attrs;
hwaddr iotlb, xlat, sz;
hwaddr iotlb, xlat, sz;
MemoryRegionSection *section;
int asidx = cpu_asidx_from_attrs(cpu, attrs);
hwaddr iotlb, xlat, sz;
CPUArchState *env = cpu->env_ptr;
target_ulong address;
section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);
iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,
                                            prot, &address);
    pci_create_simple(d->host_state.bus, 13 << 3, ""Uni-north AGP"");
#if 0
    pci_create_simple(d->host_state.bus, 14 << 3, ""Uni-north internal"");
#endif
    return d->host_state.bus;
}",1,0,91,1.24,Insert
934,"static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,
                                              target_ulong eaddr, uint32_t pid)
{
#if !defined(FLUSH_ALL_TLBS)
    CPUState *cs = CPU(ppc_env_get_cpu(env));
    ppcemb_tlb_t *tlb;
    hwaddr raddr;
    target_ulong page, end;
    int i;
    for (i = 0; i < env->nb_tlb; i++) {
        tlb = &env->tlb.tlbe[i];
        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {
            end = tlb->EPN + tlb->size;
            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {
                tlb_flush_page(cs, page);
            }
            tlb->prot &= ~PAGE_VALID;
            break;
        }
    }
#else
    ppc4xx_tlb_invalidate_all(env);
#endif
}","static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,
                                              target_ulong eaddr, uint32_t pid)
{
#if !defined(FLUSH_ALL_TLBS)
    int a = 2;
    int b = 2;
    while (a == b) {
        CPUState *cs = CPU(ppc_env_get_cpu(env));
        b += 1;
    }
    ppcemb_tlb_t *tlb;
    hwaddr raddr;
    target_ulong page, end;
    int i;
    for (i = 0; i < env->nb_tlb; i++) {
        tlb = &env->tlb.tlbe[i];
        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {
            end = tlb->EPN + tlb->size;
            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {
                tlb_flush_page(cs, page);
            }
            tlb->prot &= ~PAGE_VALID;
            break;
        }
    }
#else
    ppc4xx_tlb_invalidate_all(env);
#endif
}",0,1,14,0.28,Replace
936,,,,,,,
938,,,,,,,
940,"static void pcie_pci_bridge_write_config(PCIDevice *d,
        uint32_t address, uint32_t val, int len)
{
    pci_bridge_write_config(d, address, val, len);
    msi_write_config(d, address, val, len);
    shpc_cap_write_config(d, address, val, len);
}","static void pcie_pci_bridge_write_config(PCIDevice *d,
        uint32_t address, uint32_t val, int len)
{
    pci_bridge_write_config(d, address, val, len);
    int a = 2;
    int b = 2;
    if (a == b) {
        msi_write_config(d, address, val, len);
    }
    shpc_cap_write_config(d, address, val, len);
}",1,0,1,0.06,Replace
941,"static ram_addr_t find_ram_offset(ram_addr_t size)
{
    RAMBlock *block, *next_block;
    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;
    assert(size != 0);  
    if (QTAILQ_EMPTY(&ram_list.blocks))
        return 0;
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        ram_addr_t end, next = RAM_ADDR_MAX;
        end = block->offset + block->length;
        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {
            if (next_block->offset >= end) {
                next = MIN(next, next_block->offset);
            }
        }
        if (next - end >= size && next - end < mingap) {
            offset = end;
            mingap = next - end;
        }
    }
    if (offset == RAM_ADDR_MAX) {
        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",
                (uint64_t)size);
        abort();
    }
    return offset;
}","static ram_addr_t find_ram_offset(ram_addr_t size)
{
    RAMBlock *block, *next_block;
    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;
    assert(size != 0);  
    if (QTAILQ_EMPTY(&ram_list.blocks))
        return 0;
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        ram_addr_t end, next = RAM_ADDR_MAX;
        end = block->offset + block->length;
        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {
            if (next_block->offset >= end) {
                next = MIN(next, next_block->offset);
            }
        }
        if (next - end >= size && next - end < mingap) {
            offset = end;
            mingap = next - end;
        }
    }
    if (offset == RAM_ADDR_MAX) {
        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",
                (uint64_t)size);
        abort();
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        return offset;
        b = a;
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        VdpChromaType type;
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                             &pack);
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                             &pack);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
    }
}",0,1,22,1.15,Insert
942,,,,,,,
944,"static void flush_queued_work(CPUState *cpu)
{
    struct qemu_work_item *wi;
    if (cpu->queued_work_first == NULL) {
        return;
    }
    while ((wi = cpu->queued_work_first)) {
        cpu->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
        if (wi->free) {
            g_free(wi);
        }
    }
    cpu->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}","static void flush_queued_work(CPUState *cpu)
{
    struct qemu_work_item *wi;
    if (cpu->queued_work_first == NULL) {
        return;
    }
    while ((wi = cpu->queued_work_first)) {
        cpu->queued_work_first = wi->next;
        wi->func(wi->data);
        int a = 2;
        int b = 2;
        if (a == b) {
            wi->done = true;
        }
        if (wi->free) {
            g_free(wi);
            DeviceState *mem = NULL;
            SysBusDevice *busDev;
            busDev = SYS_BUS_DEVICE(mem);
            sysbus_mmio_map(busDev, 0, 0xfff3c000);
        }
    }
    cpu->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}",0,1,23,0.61,Insert
945,,,,,,,
946,"long do_sigreturn(CPUCRISState *env)
{
	struct target_signal_frame *frame;
	abi_ulong frame_addr;
	target_sigset_t target_set;
	sigset_t set;
	int i;
	frame_addr = env->regs[R_SP];
	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))
		goto badframe;
	if (__get_user(target_set.sig[0], &frame->sc.oldmask))
		goto badframe;
	for(i = 1; i < TARGET_NSIG_WORDS; i++) {
		if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))
			goto badframe;
	}
	target_to_host_sigset_internal(&set, &target_set);
        do_sigprocmask(SIG_SETMASK, &set, NULL);
	restore_sigcontext(&frame->sc, env);
	unlock_user_struct(frame, frame_addr, 0);
	return env->regs[10];
  badframe:
	unlock_user_struct(frame, frame_addr, 0);
	force_sig(TARGET_SIGSEGV);
}","long do_sigreturn(CPUCRISState *env)
{
	struct sock *shop;
	const struct dst_entry *dst = __sk_dst_get(shop);
	__u8 rcv_wscale;
	u32 rcv_wnd;
	struct tcp_sock *tp = tcp_sk(shop);
	tcp_select_initial_window(shop, tcp_full_space(shop),
					  tp->advmss - (tp->rx_opt.ts_recent_stamp ? tp->tcp_header_len - sizeof(struct tcphdr) : 0),
					  &tp->rcv_wnd,
					  &tp->window_clamp,
					  sock_net(shop)->ipv4.sysctl_tcp_window_scaling,
					  &rcv_wscale,
					  rcv_wnd);
	shop->sk_err = 0;
	sock_reset_flag(shop, SOCK_DONE);
	inet_csk(shop)->icsk_rto = tcp_timeout_init(shop);
	inet_csk(shop)->icsk_retransmits = 0;
	struct target_signal_frame *frame;
	abi_ulong frame_addr;
	target_sigset_t target_set;
	sigset_t set;
	int i;
	frame_addr = env->regs[R_SP];
	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))
		goto badframe;
	if (__get_user(target_set.sig[0], &frame->sc.oldmask))
		goto badframe;
	for(i = 1; i < TARGET_NSIG_WORDS; i++) {
		if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))
			goto badframe;
	}
	target_to_host_sigset_internal(&set, &target_set);
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            do_sigprocmask(SIG_SETMASK, &set, NULL);
        }
	restore_sigcontext(&frame->sc, env);
	unlock_user_struct(frame, frame_addr, 0);
	return env->regs[10];
  badframe:
	unlock_user_struct(frame, frame_addr, 0);
	force_sig(TARGET_SIGSEGV);
}",1,0,36,1.01,Insert
950,"void op_cp1_registers(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {
        CALL_FROM_TB1(do_raise_exception, EXCP_RI);
    }
    RETURN();
}","void op_cp1_registers(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {
        int a = 2;
        int b = 2;
        while (a == b) {
            CALL_FROM_TB1(do_raise_exception, EXCP_RI);
            GF_BitStream *bs;
            GF_Box *s;
            FilePartitionBox *inter = (FilePartitionBox *)s;
            inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
            ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
            GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
            b += 1;
        }
    }
    RETURN();
}",0,1,13,0.37,Insert
952,,,,,,,
954,,,,,,,
955,,,,,,,
956,"static void flush_queued_work(CPUState *env)
{
    struct qemu_work_item *wi;
    if (!env->queued_work_first)
        return;
    while ((wi = env->queued_work_first)) {
        env->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
    }
    env->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}","static void flush_queued_work(CPUState *env)
{
    struct qemu_work_item *wi;
    if (!env->queued_work_first)
        return;
    while ((wi = env->queued_work_first)) {
        env->queued_work_first = wi->next;
        int a = 2;
        int b = 2;
        if (a == b) {
            wi->func(wi->data);
            GetBitContext *db;
            int profile_lengtho, level_idc, constraint_set_flags = 0;
            SPS * spr;
            profile_lengtho           = get_bits(db, 8);
            spr->profile_lengtho          = profile_lengtho;
        }
        wi->done = true;
    }
    env->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}",0,1,13,0.47,Insert
959,,,,,,,
962,"static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)
{
    int i;
    S390PCIBusDevice *pbdev;
    S390pciState *s = s390_get_phb();
    if (!target) {
        return NULL;
    }
    for (i = 0; i < PCI_SLOT_MAX; i++) {
        pbdev = s->pbdev[i];
        if (!pbdev) {
            continue;
        }
        if (!strcmp(pbdev->target, target)) {
            return pbdev;
        }
    }
    return NULL;
}","static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)
{
    int i;
    S390PCIBusDevice *pbdev;
    S390pciState *s = s390_get_phb();
    if (!target) {
        return NULL;
    }
    for (i = 0; i < PCI_SLOT_MAX; i++) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        struct cfg80211_registered_device *rdev;
        struct sk_buff *img;
        NLA_PUT_U32(img, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
        genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), img, 0,
        				nl80211_mlme_mcgrp.id, GFP_KERNEL);
        if (strcmp(str1, str2) == 0) {
            pbdev = s->pbdev[i];
        }
        GF_Box *s_1;
        GF_BitStream *bs;
        u32 i_4, ch;
        GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s_1;
        u32 i_4, ch;
        for (i_4=0; i_4<ch; i_4++) {
        		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->pictureParameterSets, i_4);
        		gf_bs_write_u16(bs, isl->size);
        		gf_bs_write_data(bs, isl->data, isl->size);
        }
        if (!pbdev) {
            continue;
        }
        if (!strcmp(pbdev->target, target)) {
            const char *fil;
            AVIOContext *pb;
            unsigned int base;
            unsigned char *result = NULL;
            int ret = 0, probe_size;
            AVProbeData pd = { fil ? fil : """", NULL, -base };
            ret = ffio_rewind_with_probe_data(pb, &result, pd.buf_size);
            return pbdev;
        }
    }
    return NULL;
}",0,1,79,0.81,Insert
963,,,,,,,
964,"ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,
                  void *priv_data, RTPDynamicProtocolHandler *handler)
{
    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));
    if (!s)
        return NULL;
    s->ic = ic;
    s->streams = &ic->streams[first_stream_of_set_idx];
    do {
        s->n_streams++;
    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&
             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);
    s->prev_set_id    = -1;
    s->prev_stream_id = -1;
    s->prev_timestamp = -1;
    s->parse_packet = handler->parse_packet;
    s->dynamic_protocol_context = priv_data;
    return s;
}","ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,
                  void *priv_data, RTPDynamicProtocolHandler *handler)
{
    char str[] = ""Constant"";
    ObjectClass *oc;
    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);
    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |
                            PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |
                            PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206;
    pcc->msr_mask = 0x800000000284FF36ULL;
    pcc->mmu_model = POWERPC_MMU_2_06;
    pcc->excp_model = POWERPC_EXCP_POWER7;
    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;
    if (strlen(str) > 0) {
        RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));
    }
    if (!s)
        return NULL;
    s->ic = ic;
    s->streams = &ic->streams[first_stream_of_set_idx];
    do {
        s->n_streams++;
    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&
             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);
    s->prev_set_id    = -1;
    s->prev_stream_id = -1;
    s->prev_timestamp = -1;
    s->parse_packet = handler->parse_packet;
    s->dynamic_protocol_context = priv_data;
    return s;
}",1,0,40,0.88,Insert
969,"static int intel_hda_init(PCIDevice *pci)
{
    IntelHDAState *d = DO_UPCAST(IntelHDAState, pci, pci);
    uint8_t *conf = d->pci.config;
    d->name = d->pci.qdev.info->name;
    pci_config_set_vendor_id(conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(conf, 0x2668);
    pci_config_set_revision(conf, 1);
    pci_config_set_class(conf, PCI_CLASS_MULTIMEDIA_HD_AUDIO);
    pci_config_set_interrupt_pin(conf, 1);
    conf[0x40] = 0x01;
    d->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read,
                                          intel_hda_mmio_write, d,
                                          DEVICE_NATIVE_ENDIAN);
    pci_register_bar_simple(&d->pci, 0, 0x4000, 0, d->mmio_addr);
    if (d->msi) {
        msi_init(&d->pci, 0x50, 1, true, false);
    }
    hda_codec_bus_init(&d->pci.qdev, &d->codecs,
                       intel_hda_response, intel_hda_xfer);
    return 0;
}","static int intel_hda_init(PCIDevice *pci)
{
    IntelHDAState *d = DO_UPCAST(IntelHDAState, pci, pci);
    uint8_t *conf = d->pci.config;
    d->name = d->pci.qdev.info->name;
    pci_config_set_vendor_id(conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(conf, 0x2668);
    pci_config_set_revision(conf, 1);
    pci_config_set_class(conf, PCI_CLASS_MULTIMEDIA_HD_AUDIO);
    pci_config_set_interrupt_pin(conf, 1);
    conf[0x40] = 0x01;
    d->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read,
                                          intel_hda_mmio_write, d,
                                          DEVICE_NATIVE_ENDIAN);
    pci_register_bar_simple(&d->pci, 0, 0x4000, 0, d->mmio_addr);
    if (d->msi) {
        msi_init(&d->pci, 0x50, 1, true, false);
    }
    hda_codec_bus_init(&d->pci.qdev, &d->codecs,
                       intel_hda_response, intel_hda_xfer);
    int a = 2;
    int b = 3;
    while (a < b) {
        return 0;
        b = a;
        QEMUMachineInitArgs *args;
        char *filename;
        ram_addr_t ram_size = args->ram_size;
        long load_limit, rtas_limit, fw_size;
        spapr->next_irq = XICS_IRQ_BASE;
        spapr->ram_limit = ram_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        spapr_events_init(spapr);
    }
}",0,1,54,1.18,Insert
970,"static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,
        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque)
{
    RawAIOCB *acb;
    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);
    if (!acb)
        return NULL;
    if (qemu_paio_write(&acb->aiocb) < 0) {
        raw_aio_remove(acb);
        return NULL;
    }
    return &acb->common;
}","static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,
        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        RawAIOCB *acb;
        b = a;
    }
    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);
    if (!acb)
        return NULL;
    if (qemu_paio_write(&acb->aiocb) < 0) {
        raw_aio_remove(acb);
        return NULL;
    }
    return &acb->common;
}",0,1,5,0.13,Replace
972,"static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)
{
    uint32_t ret;
    switch (ot) {
    case MO_8:
        ret = cpu_ldub_code(env, s->pc);
        s->pc++;
        break;
    case MO_16:
        ret = cpu_lduw_code(env, s->pc);
        s->pc += 2;
        break;
    case MO_32:
#ifdef TARGET_X86_64
    case MO_64:
#endif
        ret = cpu_ldl_code(env, s->pc);
        s->pc += 4;
        break;
    default:
        tcg_abort();
    }
    return ret;
}","static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)
{
    uint32_t ret;
    switch (ot) {
    case MO_8:
        ret = cpu_ldub_code(env, s->pc);
        s->pc++;
        break;
    case MO_16:
        ret = cpu_lduw_code(env, s->pc);
        s->pc += 2;
        break;
    case MO_32:
#ifdef TARGET_X86_64
    case MO_64:
#endif
        ret = cpu_ldl_code(env, s->pc);
        int a = 2;
        int b = 3;
        if (a != b) {
            s->pc += 4;
        }
        break;
    default:
        tcg_abort();
    }
    return ret;
}",0,1,12,0.26,Replace
973,,,,,,,
975,"static int kvm_put_xcrs(CPUState *env)
{
#ifdef KVM_CAP_XCRS
    struct kvm_xcrs xcrs;
    if (!kvm_has_xcrs())
        return 0;
    xcrs.nr_xcrs = 1;
    xcrs.flags = 0;
    xcrs.xcrs[0].xcr = 0;
    xcrs.xcrs[0].value = env->xcr0;
    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);
#else
    return 0;
#endif
}","static int kvm_put_xcrs(CPUState *env)
{
#ifdef KVM_CAP_XCRS
    int a = 82;
    int b = a;
    if(a*b>0){
        struct kvm_xcrs xcrs;
        unsigned long array;
        struct net_bridge_mdb_entry *this = (void *)array;
        struct net_bridge_mdb_htable *mdb;
        hlist_del_rcu(&this->hlist[mdb->ver]);
        del_timer(&this->query_timer);
        call_rcu_bh(&this->rcu, br_multicast_free_group);
    }
    if (!kvm_has_xcrs())
        return 0;
    xcrs.nr_xcrs = 1;
    xcrs.flags = 0;
    xcrs.xcrs[0].xcr = 0;
    xcrs.xcrs[0].value = env->xcr0;
    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);
#else
    return 0;
#endif
}",0,1,15,0.45,Insert
977,,,,,,,
978,,,,,,,
979,"void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)
{
    BlockJob *job = find_block_job(device);
    if (!job) {
        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);
        return;
    }
    block_job_set_speed(job, speed, errp);
}","void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)
{
    int a = 2;
    void *opacity;
    NBDClient *parent = opacity;
    NBDRequest *patch;
    patch = nbd_request_get(parent);
    client_close(parent);
    int b = 2;
    while (a == b) {
        BlockJob *job = find_block_job(device);
        b += 1;
    }
    if (!job) {
        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);
        return;
    }
    block_job_set_speed(job, speed, errp);
}",0,1,14,0.41,Insert
983,"static abi_long do_socket(int domain, int type, int protocol)
{
    int target_type = type;
    int ret;
    ret = target_to_host_sock_type(&type);
    if (ret) {
        return ret;
    }
    if (domain == PF_NETLINK)
        return -TARGET_EAFNOSUPPORT;
    if (domain == AF_PACKET ||
        (domain == AF_INET && type == SOCK_PACKET)) {
        protocol = tswap16(protocol);
    }
    ret = get_errno(socket(domain, type, protocol));
    if (ret >= 0) {
        ret = sock_flags_fixup(ret, target_type);
        if (type == SOCK_PACKET) {
            fd_trans_register(ret, &target_packet_trans);
        }
    }
    return ret;
}","static abi_long do_socket(int domain, int type, int protocol)
{
    int target_type = type;
    int a = 2;
    int b = 3;
    while (a != b) {
        int ret;
        b = a;
    }
    ret = target_to_host_sock_type(&type);
    if (ret) {
        return ret;
    }
    if (domain == PF_NETLINK)
        return -TARGET_EAFNOSUPPORT;
    if (domain == AF_PACKET ||
        (domain == AF_INET && type == SOCK_PACKET)) {
        protocol = tswap16(protocol);
    }
    ret = get_errno(socket(domain, type, protocol));
    if (ret >= 0) {
        ret = sock_flags_fixup(ret, target_type);
        if (type == SOCK_PACKET) {
            fd_trans_register(ret, &target_packet_trans);
            char *filename;
            filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
            filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
            register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                                     &savevm_htab_handlers, spapr);
        }
    }
    return ret;
}",0,1,25,1.01,Insert
984,"int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    CPUState *cs = CPU(cpu);
    uint32_t *hc = (uint32_t*)buf;
    struct kvm_ppc_pvinfo pvinfo;
    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&
        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {
        memcpy(buf, pvinfo.hcall, buf_len);
        return 0;
    }
    hc[0] = 0x3860ffff;
    hc[1] = 0x60000000;
    hc[2] = 0x60000000;
    hc[3] = 0x60000000;
    return 0;
}","int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    CPUState *cs = CPU(cpu);
    uint32_t *hc = (uint32_t*)buf;
    int a = 2;
    int b = 2;
    if (a == b) {
        struct kvm_ppc_pvinfo pvinfo;
        CPUState *viron;
        qemu_irq *irq;
        QEMUBH *rb;
        rb = qemu_bh_new(tick_irq, viron);
        rb = qemu_bh_new(stick_irq, viron);
        rb = qemu_bh_new(hstick_irq, viron);
        irq = qemu_allocate_irqs(cpu_set_irq, viron, MAX_PILS);
    }
    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&
        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {
        memcpy(buf, pvinfo.hcall, buf_len);
        return 0;
    }
    hc[0] = 0x3860ffff;
    hc[1] = 0x60000000;
    hc[2] = 0x60000000;
    hc[3] = 0x60000000;
    return 0;
}",0,1,29,0.72,Insert
985,,,,,,,
990,,,,,,,
991,"int float64_eq_signaling( float64 a, float64 b STATUS_PARAM )
{
    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )
         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )
       ) {
        float_raise( float_flag_invalid STATUS_VAR);
        return 0;
    }
    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );
}","int float64_eq_signaling( float64 a, float64 b STATUS_PARAM )
{
    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )
         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )
       ) {
        float_raise( float_flag_invalid STATUS_VAR);
        void *opacity;
        NBDClient *parent = opacity;
        NBDRequest *patch;
        patch = nbd_request_get(parent);
        client_close(parent);
        return 0;
        uint64_t glms;
        unsigned k, b_3, err, C;
        unsigned k, b_3, err, C;
        assert(is_limm(glms));
        k = clz64(glms);
        b_3 = ctz64(glms);
    }
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 != b_1) {
        return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );
        b_1 = a_1;
    }
}",0,1,35,0.66,Insert
993,"int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,
                        uint8_t *buf, int len, int is_write)
{
    int l;
    target_phys_addr_t phys_addr;
    target_ulong page;
    while (len > 0) {
        page = addr & TARGET_PAGE_MASK;
        phys_addr = cpu_get_phys_page_debug(env, page);
        if (phys_addr == -1)
            return -1;
        l = (page + TARGET_PAGE_SIZE) - addr;
        if (l > len)
            l = len;
        phys_addr += (addr & ~TARGET_PAGE_MASK);
        if (is_write)
            cpu_physical_memory_write_rom(phys_addr, buf, l);
        else
            cpu_physical_memory_rw(phys_addr, buf, l, is_write);
        len -= l;
        buf += l;
        addr += l;
    }
    return 0;
}","int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,
                        uint8_t *buf, int len, int is_write)
{
    int l;
    target_phys_addr_t phys_addr;
    target_ulong page;
    while (len > 0) {
        page = addr & TARGET_PAGE_MASK;
        char *filename;
        long load_limit, rtas_limit, fw_size;
        long load_limit, rtas_limit, fw_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        g_free(filename);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
        phys_addr = cpu_get_phys_page_debug(env, page);
        if (phys_addr == -1)
            return -1;
        l = (page + TARGET_PAGE_SIZE) - addr;
        if (l > len)
            l = len;
        phys_addr += (addr & ~TARGET_PAGE_MASK);
        if (is_write)
            cpu_physical_memory_write_rom(phys_addr, buf, l);
        else
            cpu_physical_memory_rw(phys_addr, buf, l, is_write);
            CPUState *env_1;
            const sigset_t *sigset;
            struct kvm_signal_mask * sigmak;
            int r;
            sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
            sigmak->len = 8;
            memcpy( sigmak->sigset, sigset, sizeof(*sigset));
            r = kvm_vcpu_ioctl(env_1, KVM_SET_SIGNAL_MASK,  sigmak);
            free( sigmak);
        len -= l;
        buf += l;
        addr += l;
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        b = a;
    }
}",0,1,53,1.18,Insert
994,,,,,,,
998,"float32 HELPER(ucf64_abss)(float32 a)
{
    return float32_abs(a);
}","float32 HELPER(ucf64_abss)(float32 a)
{
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    int a_1 = 2;
    int b_1 = 2;
    if (a_1 == b_1) {
        return float32_abs(a);
    }
}",0,1,12,0.21,Insert
999,,,,,,,
1001,"static inline void gen_outs(DisasContext *s, TCGMemOp ot)
{
    if (use_icount)
        gen_io_start();
    gen_string_movl_A0_ESI(s);
    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);
    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);
    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);
    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);
    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
    gen_op_movl_T0_Dshift(ot);
    gen_op_add_reg_T0(s->aflag, R_ESI);
    if (use_icount)
        gen_io_end();
}","static inline void gen_outs(DisasContext *s, TCGMemOp ot)
{
    GF_BitStream *bs;
    GF_Box *s_4;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_4;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_4;
    GF_Err e;
    e = gf_isom_full_box_write(s_4, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    if (use_icount)
        gen_io_start();
    int a = 2;
    int b = 2;
    while (a == b) {
        gen_string_movl_A0_ESI(s);
        b += 1;
    }
    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);
    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);
    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);
    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);
    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
    gen_op_movl_T0_Dshift(ot);
    gen_op_add_reg_T0(s->aflag, R_ESI);
    if (use_icount)
        gen_io_end();
}",0,1,17,0.61,Insert
1004,,,,,,,
1006,,,,,,,
1007,,,,,,,
1008,,,,,,,
1010,"static int raw_init_encoder(AVCodecContext *avctx)
{
    avctx->coded_frame = (AVFrame *)avctx->priv_data;
    avctx->coded_frame->pict_type = FF_I_TYPE;
    avctx->coded_frame->key_frame = 1;
    avctx->codec_tag = findFourCC(avctx->pix_fmt);
    return 0;
}","static int raw_init_encoder(AVCodecContext *avctx)
{
    avctx->coded_frame = (AVFrame *)avctx->priv_data;
    int a = 2;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    int b = 2;
    while (a == b) {
        avctx->coded_frame->pict_type = FF_I_TYPE;
        b += 1;
    }
    avctx->coded_frame->key_frame = 1;
    avctx->codec_tag = findFourCC(avctx->pix_fmt);
    return 0;
}",0,1,24,0.4,Insert
1012,,,,,,,
1013,"void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);
}","void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    int a = 2;
    VirtioCcwDevice *dev;
    Error *err_3 = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err_3);
    }
    int b = 3;
    while (a != b) {
        avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);
        RAMBlock *news_work;
        news_work = g_malloc0(sizeof(*news_work));
        news_work->err = err;
        news_work->realized = realized;
        news_work->used_length = size;
        news_work->max_length = maxlennumber;
        b = a;
    }
}",0,1,37,0.61,Insert
1014,,,,,,,
1015,"static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,
                       unsigned int size, int mem_index)
{
    int l1 = gen_new_label();
    TCGv taddr = tcg_temp_local_new();
    TCGv tval = tcg_temp_local_new();
    TCGv t1 = tcg_temp_local_new();
    dc->postinc = 0;
    cris_evaluate_flags(dc);
    tcg_gen_mov_tl(taddr, addr);
    tcg_gen_mov_tl(tval, val);
    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);
    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);
    if (size == 1) {
        tcg_gen_qemu_st8(tval, taddr, mem_index);
    } else if (size == 2) {
        tcg_gen_qemu_st16(tval, taddr, mem_index);
    } else {
        tcg_gen_qemu_st32(tval, taddr, mem_index);
    }
    gen_set_label(l1);
    tcg_gen_shri_tl(t1, t1, 1);   
    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1);  
    tcg_temp_free(t1);
    tcg_temp_free(tval);
    tcg_temp_free(taddr);
}","static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,
                       unsigned int size, int mem_index)
{
    int l1 = gen_new_label();
    TCGv taddr = tcg_temp_local_new();
    TCGv tval = tcg_temp_local_new();
    TCGv t1 = tcg_temp_local_new();
    dc->postinc = 0;
    cris_evaluate_flags(dc);
    tcg_gen_mov_tl(taddr, addr);
    tcg_gen_mov_tl(tval, val);
    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);
    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);
    if (size == 1) {
        tcg_gen_qemu_st8(tval, taddr, mem_index);
    } else if (size == 2) {
        tcg_gen_qemu_st16(tval, taddr, mem_index);
    } else {
        tcg_gen_qemu_st32(tval, taddr, mem_index);
    }
    Aml *var;
    Aml *dev = aml_device(""%s"", ""PCI0"");
    aml_append(var, dev);
    gen_set_label(l1);
    AVPacket * pk;
    AVFormatContext *s;
    int size_4               =  pk->size_4;
    AVIOContext *b     = s->b;
    if (size_4 & 1)
            avio_w8(b, 0);
    tcg_gen_shri_tl(t1, t1, 1);
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    qdev_prop_set_uint32(mem, ""freq0"", 150000000);
    qdev_prop_set_uint32(mem, ""freq1"", 150000000);
    qdev_init_nofail(mem);
    busDev = SYS_BUS_DEVICE(mem);
    mem = qdev_create(NULL, ""highbank-regs"");   
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1);  
    strcpy(str, ""a"");
    }
    tcg_temp_free(t1);
    tcg_temp_free(tval);
    tcg_temp_free(taddr);
}",0,1,125,1.73,Insert
1016,"static void ide_trim_bh_cb(void *opaque)
{
    TrimAIOCB *iocb = opaque;
    iocb->common.cb(iocb->common.opaque, iocb->ret);
    qemu_bh_delete(iocb->bh);
    iocb->bh = NULL;
    qemu_aio_unref(iocb);
}","static void ide_trim_bh_cb(void *opaque)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        TrimAIOCB *iocb = opaque;
        b += 1;
    }
    iocb->common.cb(iocb->common.opaque, iocb->ret);
    qemu_bh_delete(iocb->bh);
    iocb->bh = NULL;
    qemu_aio_unref(iocb);
}",0,1,2,0.07,Replace
1018,,,,,,,
1021,,,,,,,
1022,"static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)
{
    int ret;
    FailingMuxerPacketData *data = av_malloc(sizeof(*data));
    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));
    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));
    pkt->pts = pkt->dts = pts;
    pkt->duration = 1;
    return ret;","static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)
{
    int ret;
    int a = 2;
    int b = 3;
    const char *function;
    const char *type;
    struct keyring_index_key index_key = {
    		.function	= function,
    	};
    if (!index_key.type->match || !index_key.type->instantiate ||
     	    (!index_key.function && !index_key.type->preparse))
     		goto error_put_type;
    if (a != b) {
        FailingMuxerPacketData *data = av_malloc(sizeof(*data));
    }
    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));
    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));
    pkt->pts = pkt->dts = pts;
    pkt->duration = 1;
    return ret;",1,0,17,0.61,Insert
1024,"static int get_pcm(HEVCContext *s, int x, int y)
{
    int log2_min_pu_size = s->sps->log2_min_pu_size;
    int x_pu             = x >> log2_min_pu_size;
    int y_pu             = y >> log2_min_pu_size;
    if (x < 0 || x_pu >= s->sps->min_pu_width ||
        y < 0 || y_pu >= s->sps->min_pu_height)
        return 2;
    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];
}","static int get_pcm(HEVCContext *s, int x, int y)
{
    int log2_min_pu_size = s->sps->log2_min_pu_size;
    int x_pu             = x >> log2_min_pu_size;
    AVCodecContext *ajcas;
    DCAContext *s_8 = ajcas->priv_data;
    int num_core_channels = 0;
    int channels, full_channels;
    int channels, full_channels;
    num_core_channels = s_8->prim_channels;
    full_channels = channels = s_8->prim_channels + !!s_8->lfe;
    int y_pu             = y >> log2_min_pu_size;
    if (x < 0 || x_pu >= s->sps->min_pu_width ||
        y < 0 || y_pu >= s->sps->min_pu_height)
        return 2;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];
    strcpy(str, ""a"");
    }
}",0,1,15,0.57,Insert
1026,,,,,,,
1032,"static inline int cris_addc_pi_m(int a, int **b)
{
	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));
	return a;
}","static inline int cris_addc_pi_m(int a, int **b)
{
	Image *inject_cache;
	ExceptionInfo *exception;
	Image
	    *group84__pixel;
	group84__pixel=CloneImage(inject_cache,0,0,MagickTrue,exception);
	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));
	int a_1 = 2;
	int b_1 = 3;
	if (a_1 != b_1) {
    	return a;
	}
}",1,0,6,0.27,Insert
1033,"static void vmgenid_query_monitor_test(void)
{
    QemuUUID expected, measured;
    gchar *cmd;
    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);
    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""
                          ""guid=%s"", VGID_GUID);
    qtest_start(cmd);
    read_guid_from_monitor(&measured);
    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);
    qtest_quit(global_qtest);
    g_free(cmd);
}","static void vmgenid_query_monitor_test(void)
{
    QemuUUID expected, measured;
    gchar *cmd;
    int a = 2;
    int b = 2;
    if (a == b) {
        g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);
    }
    Object *obj;
    Visitor *tv;
    Error **grp;
    const char *label;
    void *opaque;
    EnumProperty *prop = opaque;
    int value;
    value = prop->get(obj, grp);
    visit_type_enum(tv, &value, prop->strings, NULL, label, grp);
    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""
                          ""guid=%s"", VGID_GUID);
    qtest_start(cmd);
    read_guid_from_monitor(&measured);
    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);
    qtest_quit(global_qtest);
    g_free(cmd);
}",1,0,36,0.71,Insert
1039,"static inline void gen_op_movl_seg_T0_vm(int seg_reg)
{
    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);
    tcg_gen_st32_tl(cpu_T[0], cpu_env, 
                    offsetof(CPUX86State,segs[seg_reg].selector));
    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);
    tcg_gen_st_tl(cpu_T[0], cpu_env, 
                  offsetof(CPUX86State,segs[seg_reg].base));
}","static inline void gen_op_movl_seg_T0_vm(int seg_reg)
{
    int a = 2;
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    av_freep(&zero);
    av_freep(&zero);
    int b = 2;
    while (a == b) {
        tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);
        b += 1;
    }
    tcg_gen_st32_tl(cpu_T[0], cpu_env, 
                    offsetof(CPUX86State,segs[seg_reg].selector));
    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);
    tcg_gen_st_tl(cpu_T[0], cpu_env, 
                  offsetof(CPUX86State,segs[seg_reg].base));
}",0,1,13,0.5,Insert
1040,"static void vc1_v_overlap_c(uint8_t* src, int stride)
{
    int i;
    int a, b, c, d;
    int d1, d2;
    int rnd = 1;
    for(i = 0; i < 8; i++) {
        a = src[-2*stride];
        b = src[-stride];
        c = src[0];
        d = src[stride];
        d1 = (a - d + 3 + rnd) >> 3;
        d2 = (a - d + b - c + 4 - rnd) >> 3;
        src[-2*stride] = a - d1;
        src[-stride] = b - d2;
        src[0] = c + d2;
        src[stride] = d + d1;
        src++;
        rnd = !rnd;
    }
}","static void vc1_v_overlap_c(uint8_t* src, int stride)
{
    int i;
    AVFormatContext *s;
    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;
    HLSContext *c_5 = s->priv_data;
    if (u) {
            update_options(&c_5->user_agent, ""user-agent"", u);
            update_options(&c_5->cookies, ""cookies"", u);
            update_options(&c_5->headers, ""headers"", u);
            update_options(&c_5->http_proxy, ""http_proxy"", u);
    }
    int a, b, c, d;
    int d1, d2;
    int rnd = 1;
    for(i = 0; i < 8; i++) {
        a = src[-2*stride];
        b = src[-stride];
        c = src[0];
        d = src[stride];
        d1 = (a - d + 3 + rnd) >> 3;
        int a_1 = 2;
        int b_1 = 3;
        while (a_1 != b_1) {
            d2 = (a - d + b - c + 4 - rnd) >> 3;
            b_1 = a_1;
        }
        src[-2*stride] = a - d1;
        src[-stride] = b - d2;
        src[0] = c + d2;
        src[stride] = d + d1;
        src++;
        rnd = !rnd;
    }
}",1,0,34,1.28,Insert
1043,"static void usb_msd_realize_bot(USBDevice *dev, Error **errp)
{
    MSDState *s = DO_UPCAST(MSDState, dev, dev);
    usb_desc_create_serial(dev);
    usb_desc_init(dev);
    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),
                 &usb_msd_scsi_info_bot, NULL);
    s->bus.qbus.allow_hotplug = 0;
    usb_msd_handle_reset(dev);
}","static void usb_msd_realize_bot(USBDevice *dev, Error **errp)
{
    int a = 2;
    int b = 3;
    int offset;
    void *fdt;
    CPUPPCState *env = &cpu->env;
    _FDT((fdt_setprop_cell(fdt, offset, ""cpu-version"", env->spr[SPR_PVR])));
    _FDT((fdt_setprop_cell(fdt, offset, ""d-cache-block-size"",
                               env->dcache_line_size)));
    _FDT((fdt_setprop_cell(fdt, offset, ""d-cache-line-size"",
                               env->dcache_line_size)));
    _FDT((fdt_setprop_cell(fdt, offset, ""i-cache-block-size"",
                               env->icache_line_size)));
    _FDT((fdt_setprop_cell(fdt, offset, ""i-cache-line-size"",
                               env->icache_line_size)));
    while (a < b) {
        MSDState *s = DO_UPCAST(MSDState, dev, dev);
        b = a;
    }
    usb_desc_create_serial(dev);
    usb_desc_init(dev);
    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),
                 &usb_msd_scsi_info_bot, NULL);
    s->bus.qbus.allow_hotplug = 0;
    usb_msd_handle_reset(dev);
}",1,0,34,0.68,Insert
1045,"int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)
{
    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,
                            sizeof(diag_501), 0) ||
        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,
                            sizeof(diag_501), 1)) {
        return -EINVAL;
    }
    return 0;
}","int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)
{
    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,
                            sizeof(diag_501), 0) ||
        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,
                            sizeof(diag_501), 1)) {
        int a = 2;
        int b = 3;
        while (a < b) {
            soxr_io_spec_t io_spec = soxr_io_spec(type, type);
            soxr_error_t error;
            soxr_quality_spec_t q_spec = soxr_quality_spec((int)((precision-2)/4), (SOXR_HI_PREC_CLOCK|SOXR_ROLLOFF_NONE)*!!cheby);
            c = (struct ResampleContext *)
                    soxr_create(in_rate, out_rate, 0, &error, &io_spec, &q_spec, 0);
            return -EINVAL;
            b = a;
        }
    }
    return 0;
}",1,0,5,0.36,Insert
1046,"static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,
                                       uint64_t i)
{
    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)
                                    + (i << RDMA_REG_CHUNK_SHIFT));
}","static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,
                                       uint64_t i)
{
    struct dvb_usb_adapter *d;
    u8 ibuf[] = { 0 };
    u8 obuf[3] = { 0xe, 0x80, 0 };
    if (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)
     		err(""command 0x51 transfer failed."");
    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)
                                    + (i << RDMA_REG_CHUNK_SHIFT));
}",1,0,9,0.2,Insert
1050,"static int sox_read_packet(AVFormatContext *s,
                           AVPacket *pkt)
{
    int ret, size;
    if (url_feof(s->pb))
        return AVERROR_EOF;
    size = SOX_SAMPLES*s->streams[0]->codec->block_align;
    ret = av_get_packet(s->pb, pkt, size);
    if (ret < 0)
        return AVERROR(EIO);
    pkt->stream_index = 0;
    pkt->size = ret;
    return 0;
}","static int sox_read_packet(AVFormatContext *s,
                           AVPacket *pkt)
{
    int ret, size;
    if (url_feof(s->pb))
        return AVERROR_EOF;
    size = SOX_SAMPLES*s->streams[0]->codec->block_align;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        ret = av_get_packet(s->pb, pkt, size);
    }
    if (ret < 0)
        return AVERROR(EIO);
    pkt->stream_index = 0;
    pkt->size = ret;
    return 0;
}",1,0,5,0.11,Replace
1051,"static av_cold int svq1_encode_init(AVCodecContext *avctx)
{
    SVQ1Context * const s = avctx->priv_data;
    dsputil_init(&s->dsp, avctx);
    avctx->coded_frame= (AVFrame*)&s->picture;
    s->frame_width = avctx->width;
    s->frame_height = avctx->height;
    s->y_block_width = (s->frame_width + 15) / 16;
    s->y_block_height = (s->frame_height + 15) / 16;
    s->c_block_width = (s->frame_width / 4 + 15) / 16;
    s->c_block_height = (s->frame_height / 4 + 15) / 16;
    s->avctx= avctx;
    s->m.avctx= avctx;
    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));
    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));
    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));
    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));
    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));
    h263_encode_init(&s->m);  
    return 0;
}","static av_cold int svq1_encode_init(AVCodecContext *avctx)
{
    PNMContext * const s_2;
    AVCodecContext *avctx_3;
    char buf1[32], tuple_type[32];
    pnm_get(s_2, buf1, sizeof(buf1));
    pnm_get(s_2, buf1, sizeof(buf1));
    avctx_3->width = atoi(buf1);
    pnm_get(s_2, buf1, sizeof(buf1));
    avctx_3->height = atoi(buf1);
    int a = 65;
    int b = a;
    if(a*b>0){
        SVQ1Context * const s = avctx->priv_data;
    }
    dsputil_init(&s->dsp, avctx);
    avctx->coded_frame= (AVFrame*)&s->picture;
    s->frame_width = avctx->width;
    s->frame_height = avctx->height;
    s->y_block_width = (s->frame_width + 15) / 16;
    s->y_block_height = (s->frame_height + 15) / 16;
    s->c_block_width = (s->frame_width / 4 + 15) / 16;
    s->c_block_height = (s->frame_height / 4 + 15) / 16;
    s->avctx= avctx;
    s->m.avctx= avctx;
    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));
    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));
    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));
    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));
    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));
    h263_encode_init(&s->m);  
    return 0;
}",1,0,38,0.89,Insert
1055,"static void csrhci_reset(struct csrhci_s *s)
{
    s->out_len = 0;
    s->out_size = FIFO_LEN;
    s->in_len = 0;
    s->baud_delay = NANOSECONDS_PER_SECOND;
    s->enable = 0;
    s->in_hdr = INT_MAX;
    s->in_data = INT_MAX;
    s->modem_state = 0;
    s->modem_state |= CHR_TIOCM_CTS;
    memset(&s->bd_addr, 0, sizeof(bdaddr_t));
}","static void csrhci_reset(struct csrhci_s *s)
{
    s->out_len = 0;
    int s_8;
    int opts;
    if (fcntl(s_8, F_SETFL, opts) < 0)
             APPL_TRACE_ERROR(""set blocking (%s)"", strerror(errno));
    s->out_size = FIFO_LEN;
    s->in_len = 0;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        s->baud_delay = NANOSECONDS_PER_SECOND;
    strcpy(str, ""a"");
    }
    s->enable = 0;
    s->in_hdr = INT_MAX;
    s->in_data = INT_MAX;
    s->modem_state = 0;
    s->modem_state |= CHR_TIOCM_CTS;
    memset(&s->bd_addr, 0, sizeof(bdaddr_t));
}",1,0,22,0.5,Insert
1056,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)
{
	unsigned i;
	unsigned num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}","void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)
{
	unsigned i;
	unsigned num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	int a_1 = 23;
	void *opaque;
	struct QemuInputEventQueueHead *qa = opaque;
	QemuInputEventQueue *item;
	g_assert(!QTAILQ_EMPTY(qa));
	item = QTAILQ_FIRST(qa);
	QTAILQ_REMOVE(qa, item, node);
	int b_1 = a_1;
	double mul;
	double mat_freq[13];
	int n = 6;
	double kernel[] = {
	        (5204 + 2520 * mul + 1092 * mul2 + 3280 * mul3) / 12096,
	        (2943 -  210 * mul -  273 * mul2 - 2460 * mul3) / 12096,
	        ( 486 -  924 * mul -  546 * mul2 +  984 * mul3) / 12096,
	         (  17 -  126 * mul +  273 * mul2 -  164 * mul3) / 12096,
	     };
	double vec_freq[13];
	memcpy(mat_freq, kernel, sizeof(kernel));
	memset(mat_freq + 4, 0, sizeof(mat_freq) - sizeof(kernel));
	coeff_filter(mat_freq, n, kernel);
	coeff_filter(vec_freq, n, kernel);
	if(a_1*b_1>0){
    	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
	}
}",1,0,51,0.83,Insert
1057,,,,,,,
1058,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)
{
    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };
    int i;
    int bit     = 0;
    int bits    = 0;
    int prevbit = 0;
    unsigned val;
    for (i = 0; i < 7; i++) {
        if (prevbit && bit)
            break;
        prevbit = bit;
        bit = get_bits1(gb);
        if (bit && !prevbit)
            bits += series[i];
    }
    bits--;
    if (bits < 0 || bits > 31) {
        *value = 0;
        return -1;
    } else if (bits == 0) {
        *value = 0;
        return 0;
    }
    val  = get_bits_long(gb, bits);
    val |= 1 << bits;
    *value = val - 1;
    return 0;
}","static int lag_decode_prob(GetBitContext *gb, uint32_t *value)
{
    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };
    struct vrend_blitter_ctx *blit_ctx;
    int i_5;
    for (i_5 = 0; i_5 < 4; i_5++)
          blit_ctx->vertices[i_5][0][3] = 1;
    int i;
    int bit     = 0;
    int bits    = 0;
    int prevbit = 0;
    unsigned val;
    for (i = 0; i < 7; i++) {
        if (prevbit && bit)
            break;
        prevbit = bit;
        bit = get_bits1(gb);
        if (bit && !prevbit)
            bits += series[i];
    }
    bits--;
    if (bits < 0 || bits > 31) {
        *value = 0;
        return -1;
    } else if (bits == 0) {
        *value = 0;
        return 0;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        val  = get_bits_long(gb, bits);
    strcpy(str, ""a"");
    }
    val |= 1 << bits;
    *value = val - 1;
    return 0;
}",1,0,39,0.91,Insert
1060,"static void test_validate_fail_union_flat(TestInputVisitorData *data,
                                          const void *unused)
{
    UserDefFlatUnion *tmp = NULL;
    Error *errp = NULL;
    Visitor *v;
    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");
    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);
    g_assert(error_is_set(&errp));
    qapi_free_UserDefFlatUnion(tmp);
}","static void test_validate_fail_union_flat(TestInputVisitorData *data,
                                          const void *unused)
{
    UserDefFlatUnion *tmp = NULL;
    int a = 2;
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_7     = s->b_7;
    if (size & 1)
            avio_w8(b_7, 0);
    int b = 2;
    while (a == b) {
        Error *errp = NULL;
        b += 1;
    }
    Visitor *v;
    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");
    int rt;
    int (*compare)(const char *, const char *, size_t);
    const char *name1;
    const char *name2;
    int cmp;
    unsigned char c1, mc7;
    cmp = compare(name1, name2, len);
    c1 = name1[len];
    TCGv T00, ttyapp;
    Aml *var;
    Aml *dev = aml_device(""%s"", ""PCI0"");
    Aml *dev_rp0 = aml_device(""%s"", ""RP0"");
    aml_append(dev_rp0, aml_name_decl(""_ADR"", aml_int(0)));
    aml_append(dev, dev_rp0);
    aml_append(var, dev);
    gen_load_gpr(ttyapp, rt);
    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);
    g_assert(error_is_set(&errp));
    qapi_free_UserDefFlatUnion(tmp);
}",0,1,105,1.03,Insert
1061,"void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)
{
#if defined(DEBUG_MMU)
    printf(""CR4 update: CR4=%08x\n"", (uint32_t)env->cr[4]);
#endif
    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=
        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {
        tlb_flush(env, 1);
    }
    if (!(env->cpuid_features & CPUID_SSE))
        new_cr4 &= ~CR4_OSFXSR_MASK;
    if (new_cr4 & CR4_OSFXSR_MASK)
        env->hflags |= HF_OSFXSR_MASK;
    else
        env->hflags &= ~HF_OSFXSR_MASK;
    env->cr[4] = new_cr4;
}","void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)
{
#if defined(DEBUG_MMU)
    printf(""CR4 update: CR4=%08x\n"", (uint32_t)env->cr[4]);
#endif
    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=
        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {
        char str[] = ""Constant"";
        GetBitContext *db;
        int profile_lengtho, level_idc, constraint_set_flags = 0;
        SPS * spr;
        profile_lengtho           = get_bits(db, 8);
        spr->profile_lengtho          = profile_lengtho;
        while (strlen(str) > 5) {
            tlb_flush(env, 1);
        strcpy(str, ""a"");
        }
    }
    if (!(env->cpuid_features & CPUID_SSE))
        new_cr4 &= ~CR4_OSFXSR_MASK;
    if (new_cr4 & CR4_OSFXSR_MASK)
        env->hflags |= HF_OSFXSR_MASK;
    else
        env->hflags &= ~HF_OSFXSR_MASK;
        Unit *uci;
        const char *key;
        assert(key);
        (void) hashmap_remove_value(uci->manager->watch_bus, key, uci);
    env->cr[4] = new_cr4;
}",0,1,37,0.8,Insert
1063,"static void unix_wait_for_connect(int fd, Error *err, void *opaque)
{
    MigrationState *s = opaque;
    if (fd < 0) {
        DPRINTF(""migrate connect error: %s\n"", error_get_pretty(err));
        s->file = NULL;
        migrate_fd_error(s);
    } else {
        DPRINTF(""migrate connect success\n"");
        s->file = qemu_fopen_socket(fd, ""wb"");
        migrate_fd_connect(s);
    }
}","static void unix_wait_for_connect(int fd, Error *err, void *opaque)
{
    MigrationState *s = opaque;
    int size;
    OpusStreamContext *s_6;
    int ret, i, consumed;
    int samples    = s_6->packet.frame_duration;
    int redundancy = 0;
    if (s_6->packet.mode == OPUS_MODE_HYBRID && consumed + 37 <= size * 8)
            redundancy = opus_rc_p2model(&s_6->rc, 12);
        else if (s_6->packet.mode == OPUS_MODE_SILK && consumed + 17 <= size * 8)
            redundancy = 1;
    if (fd < 0) {
        int a = 2;
        int b = 3;
        if (a != b) {
            DPRINTF(""migrate connect error: %s\n"", error_get_pretty(err));
        }
        s->file = NULL;
        migrate_fd_error(s);
    } else {
        DPRINTF(""migrate connect success\n"");
        s->file = qemu_fopen_socket(fd, ""wb"");
        migrate_fd_connect(s);
    }
}",1,0,19,0.59,Insert
1068,"static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(n);
    NetClientState *nc = qemu_get_queue(n->nic);
    int queues = n->multiqueue ? n->max_queues : 1;
    if (!get_vhost_net(nc->peer)) {
        return;
    }
    if (!!n->vhost_started ==
        (virtio_net_started(n, status) && !nc->peer->link_down)) {
        return;
    }
    if (!n->vhost_started) {
        int r;
        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {
            return;
        }
        n->vhost_started = 1;
        r = vhost_net_start(vdev, n->nic->ncs, queues);
        if (r < 0) {
            error_report(""unable to start vhost net: %d: ""
                         ""falling back on userspace virtio"", -r);
            n->vhost_started = 0;
        }
    } else {
        vhost_net_stop(vdev, n->nic->ncs, queues);
        n->vhost_started = 0;
    }
}","static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(n);
    NetClientState *nc = qemu_get_queue(n->nic);
    int a = 45;
    int b = a;
    if(a*b>0){
        int queues = n->multiqueue ? n->max_queues : 1;
    }
    if (!get_vhost_net(nc->peer)) {
        return;
    }
    if (!!n->vhost_started ==
        (virtio_net_started(n, status) && !nc->peer->link_down)) {
        return;
    }
    if (!n->vhost_started) {
        int r;
        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {
            return;
        }
        n->vhost_started = 1;
        r = vhost_net_start(vdev, n->nic->ncs, queues);
        if (r < 0) {
            error_report(""unable to start vhost net: %d: ""
                         ""falling back on userspace virtio"", -r);
            n->vhost_started = 0;
        }
    } else {
        vhost_net_stop(vdev, n->nic->ncs, queues);
        n->vhost_started = 0;
        DisasContext *qs;
        uint32_t ksns;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        order = extract32(ksns, 22, 2);
        handle_fp_compare(qs, order, coll, err, false, p);
    }
}",0,1,27,1.01,Insert
1069,"static void spapr_cpu_core_host_initfn(Object *obj)
{
    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);
    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");
    ObjectClass *oc = object_class_by_name(name);
    g_assert(oc);
    g_free((void *)name);
    core->cpu_class = oc;
}","static void spapr_cpu_core_host_initfn(Object *obj)
{
    int a = 74;
    int b = a;
    if(a*b>0){
        sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);
    }
    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");
    ObjectClass *oc = object_class_by_name(name);
    g_assert(oc);
    g_free((void *)name);
    core->cpu_class = oc;
}",0,1,1,0.07,Replace
1071,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
{
    unsigned int i;
    for (i = 0; m68k_cpu_defs[i].name; i++) {
        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);
    }
}","void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
{
    int a = 2;
    int b = 3;
    while (a < b) {
        unsigned int i;
        b = a;
    }
    for (i = 0; m68k_cpu_defs[i].name; i++) {
        unsigned maxpages;
        size_t *start;
        struct iov_iter *i_2;
        unsigned int iter_head, npages;
        unsigned int iter_head, npages;
        size_t capacity;
        data_start(i_2, &iter_head, start);
        capacity = min(npages, maxpages) * PAGE_SIZE - *start;
        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);
    }
}",0,1,8,0.52,Insert
1072,"int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,
                              PCIHotplugState state)
{
    int slot = PCI_SLOT(dev->devfn);
    int bsel = acpi_pcihp_get_bsel(dev->bus);
    if (bsel < 0) {
        return -1;
    }
    if (state == PCI_COLDPLUG_ENABLED) {
        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);
        return 0;
    }
    if (state == PCI_HOTPLUG_ENABLED) {
        enable_device(s, bsel, slot);
    } else {
        disable_device(s, bsel, slot);
    }
    return 0;
}","int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,
                              PCIHotplugState state)
{
    int slot = PCI_SLOT(dev->devfn);
    int bsel = acpi_pcihp_get_bsel(dev->bus);
    if (bsel < 0) {
        return -1;
        BlockDriverState *bs;
        SheepdogInode *linade;
        BDRVSheepdogState *s_10 = bs->opaque;
        unsigned int datalen;
        memcpy(&s_10->linade, linade, datalen);
    }
    if (state == PCI_COLDPLUG_ENABLED) {
        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);
        return 0;
    }
    if (state == PCI_HOTPLUG_ENABLED) {
        enable_device(s, bsel, slot);
    } else {
        disable_device(s, bsel, slot);
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        return 0;
        b = a;
    }
}",0,1,19,0.73,Insert
1073,,,,,,,
1074,"static void test_flush_nodev(void)
{
    QPCIDevice *dev;
    QPCIBar bmdma_bar, ide_bar;
    ide_test_start("""");
    dev = get_pci_device(&bmdma_bar, &ide_bar);
    qpci_io_writeb(dev, ide_bar, reg_device, 0);
    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);
    ide_test_quit();
}","static void test_flush_nodev(void)
{
    Exiv2::Dictionary& view;
    Exiv2::Dictionary& http;
    const char* ROXYDI = ""HTTP_PROXY"";
    const char* http = getenv(proxa);
    const char* proxy_s = target;
    const char* proxa = ""http_proxy"";
    const char* servernename_p = survernname;
    const char* position = view[""page""].c_str();
    if (bProx) {
            servernename_p = Proxy.Host.c_str();
            proxy_s = Proxy.Port.c_str();
            position = url.c_str();
            std::string p(http ? proxa : ROXYDI);
    }
    QPCIDevice *dev;
    lua_State *GL;
    mp_buf *buf;
    int type;
    while(lua_next(GL,-2)) {
            lua_pushvalue(GL,-2);  
            mp_encode_lua_type(GL,buf,type+1);  
            mp_encode_lua_type(GL,buf,type+1);  
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        QPCIBar bmdma_bar, ide_bar;
    strcpy(str, ""a"");
    }
    ide_test_start("""");
    dev = get_pci_device(&bmdma_bar, &ide_bar);
    qpci_io_writeb(dev, ide_bar, reg_device, 0);
    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);
    ide_test_quit();
}",1,0,48,0.68,Insert
1075,,,,,,,
1077,,,,,,,
1079,,,,,,,
1080,"static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)
{
    uint32_t val;
    val = bswap32(cpu_inl(addr & IOPORTS_MASK));
    return val;
}","static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)
{
    AVStream *tmp;
    AVFormatContext *aws;
    uint32_t v, spf;
    struct PCIDevice *pci_dev;
    int r;
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    r = assign_device(Dev);
    r = assign_intx(Dev);
    assigned_dev_load_option_rom(Dev);
    add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
    MPADecodeHeader ch;
    MP3DecContext *MPthree = aws->priv_data;
    if (MPthree->frames)
            tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                        tmp->time_base);
    uint32_t val;
    char str1[] = ""Constant"";
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        val = bswap32(cpu_inl(addr & IOPORTS_MASK));
    }
    return val;
}",0,1,93,0.89,Insert
1081,,,,,,,
1085,,,,,,,
1087,,,,,,,
1089,"static void get_sensor_evt_enable(IPMIBmcSim *ibs,
                                  uint8_t *cmd, unsigned int cmd_len,
                                  uint8_t *rsp, unsigned int *rsp_len,
                                  unsigned int max_rsp_len)
{
    IPMISensor *sens;
    IPMI_CHECK_CMD_LEN(3);
    if ((cmd[2] > MAX_SENSORS) ||
        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {
        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;
        return;
    }
    sens = ibs->sensors + cmd[2];
    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));
    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);
    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);
    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);
    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);
}","static void get_sensor_evt_enable(IPMIBmcSim *ibs,
                                  uint8_t *cmd, unsigned int cmd_len,
                                  uint8_t *rsp, unsigned int *rsp_len,
                                  unsigned int max_rsp_len)
{
    const page_load_metrics::mojom::PageLoadTiming& timing;
    const page_load_metrics::PageLoadExtraInfo& info;
    bool is_user_initiated_navigation =
          info.user_initiated_info.browser_initiated ||
          timing.input_to_navigation_start;
    if (timing.parse_timing->parse_start) {
        BlkActionState *common;
        DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);
        DriveBackup *backup;
        Error *local_err = NULL;
        assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);
        backup = common->action->u.drive_backup.data;
        do_drive_backup(backup, common->block_job_txn, &local_err);
        builder.SetParseTiming_NavigationToParseStart(
            timing.parse_timing->parse_start.value().InMilliseconds());
    }
    IPMISensor *sens;
    target_ulong addr;
    void *data;
    AVPacket *avpkt;
    AVCodecContext *avctx;
    AVFrame * const p = &s->picture;
    PTXContext * const s = avctx->priv_data;
    const uint8_t *buf = avpkt->data;
    if (p->data[0])
            avctx->release_buffer(avctx, p);
    int size;
    CPUSPARCState *env;
    int asi;
    helper_check_align(env, addr, size - 1);
    addr = asi_address_mask(env, asi, addr);
    IPMI_CHECK_CMD_LEN(3);
    if ((cmd[2] > MAX_SENSORS) ||
        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {
        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;
        return;
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        sens = ibs->sensors + cmd[2];
        b = a;
    }
    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));
    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);
    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);
    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);
    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);
}",1,0,121,1.33,Insert
1090,"struct omap_uart_s *omap_uart_init(hwaddr base,
                qemu_irq irq, omap_clk fclk, omap_clk iclk,
                qemu_irq txdma, qemu_irq rxdma,
                const char *label, CharDriverState *chr)
{
    struct omap_uart_s *s = (struct omap_uart_s *)
            g_malloc0(sizeof(struct omap_uart_s));
    s->base = base;
    s->fclk = fclk;
    s->irq = irq;
    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,
                               omap_clk_getrate(fclk)/16,
                               chr ?: qemu_chr_new(label, ""null"", NULL),
                               DEVICE_NATIVE_ENDIAN);
    return s;
}","struct omap_uart_s *omap_uart_init(hwaddr base,
                qemu_irq irq, omap_clk fclk, omap_clk iclk,
                qemu_irq txdma, qemu_irq rxdma,
                const char *label, CharDriverState *chr)
{
    WebKitWebView* webView;
    struct iovec *iov;
    unsigned int iov_cnt;
    struct virtio_net_ctrl_mac cas_type;
    size_t s_3;
    s_3 = iov_to_buf(iov, iov_cnt, 0, &cas_type.entries,
                       sizeof(cas_type.entries));
    cas_type.entries = ldl_p(&cas_type.entries);
    iov_discard_front(&iov, &iov_cnt, cas_type.entries * ETH_ALEN);
    s_3 = iov_to_buf(iov, iov_cnt, 0, &cas_type.entries,
                       sizeof(cas_type.entries));
    cas_type.entries = ldl_p(&cas_type.entries);
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setFrameFlatteningEnabled(enableFrameFlattening);
    struct omap_uart_s *s = (struct omap_uart_s *)
            g_malloc0(sizeof(struct omap_uart_s));
    s->base = base;
    int a = 2;
    int b = 3;
    while (a < b) {
        s->fclk = fclk;
        b = a;
    }
    s->irq = irq;
    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,
                               omap_clk_getrate(fclk)/16,
                               chr ?: qemu_chr_new(label, ""null"", NULL),
                               DEVICE_NATIVE_ENDIAN);
    return s;
}",1,0,42,0.89,Insert
1094,,,,,,,
1095,,,,,,,
1097,"static av_cold void init_atrac3_transforms(ATRAC3Context *q) {
    float enc_window[256];
    int i;
    for (i=0 ; i<256; i++)
        enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;
    if (!mdct_window[0])
        for (i=0 ; i<256; i++) {
            mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]);
            mdct_window[511-i] = mdct_window[i];
        }
    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);
}","static av_cold void init_atrac3_transforms(ATRAC3Context *q) {
    float enc_window[256];
    int i;
    for (i=0 ; i<256; i++)
        enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;
    if (!mdct_window[0])
        for (i=0 ; i<256; i++) {
            int a = 2;
            int b = 3;
            BlockDriverCompletionFunc *cb;
            void *opaque;
            BlockdevOnError on_error;
            BlockDriverState *bs;
            Error **errp;
            int64_t speed;
            BlockDriverState *base;
            int64_t length, base_length;
            length = bdrv_getlength(bs);
            mirror_start_job(bs, base, speed, 0, 0,
                                 on_error, on_error, cb, opaque, errp,
                                 &commit_active_job_driver, false, base);
            while (a != b) {
                mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]);
                b = a;
            }
            mdct_window[511-i] = mdct_window[i];
        }
    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);
}",1,0,22,0.8,Insert
1099,"void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)
{
    LM32JuartState *s = LM32_JUART(d);
    unsigned char ch = jtx & 0xff;
    trace_lm32_juart_set_jtx(s->jtx);
    s->jtx = jtx;
    if (s->chr) {
        qemu_chr_fe_write_all(s->chr, &ch, 1);
    }
}","void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)
{
    BDRVVVFATState* s_10;
    bootsector_t* bootsector;
    s_10->offset_to_fat = s_10->offset_to_bootsector + 1;
    bootsector = (bootsector_t *)(s_10->first_sectors
                                      + s_10->offset_to_bootsector * 0x200);
    bootsector->jump[0]=0xeb;
    bootsector->jump[1]=0x3e;
    bootsector->jump[2]=0x90;
    LM32JuartState *s = LM32_JUART(d);
    unsigned char ch = jtx & 0xff;
    trace_lm32_juart_set_jtx(s->jtx);
    s->jtx = jtx;
    if (s->chr) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            qemu_chr_fe_write_all(s->chr, &ch, 1);
        }
    }
}",1,0,12,0.36,Insert
1101,,,,,,,
1102,,,,,,,
1107,,,,,,,
1108,"void qmp_migrate_cancel(Error **errp)
{
    migrate_fd_cancel(migrate_get_current());
}","void qmp_migrate_cancel(Error **errp)
{
    const uint8_t *lsp_id;
    const struct isis_circuit *circuit;
    struct yang_data *data;
    struct list *arguments = yang_data_list_new();
    struct isis_area *area = circuit->area;
    const char *xpath = ""/frr-isisd:lsp-error-detected"";
    char xpath_arg[XPATH_MAXLEN];
    struct isis_area *area = circuit->area;
    notif_prep_instance_hdr(xpath, area, ""default"", arguments);
    notif_prepr_iface_hdr(xpath, circuit, arguments);
    snprintf(xpath_arg, sizeof(xpath_arg), ""%s/lsp-id"", xpath);
    data = yang_data_new_string(xpath_arg, rawlspid_print(lsp_id));
    snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
    int a = 2;
    int b = 2;
    if (a == b) {
        migrate_fd_cancel(migrate_get_current());
    }
}",1,0,22,0.34,Insert
1110,,,,,,,
1112,"static void msmouse_chr_close (struct CharDriverState *chr)
{
    MouseState *mouse = chr->opaque;
    qemu_input_handler_unregister(mouse->hs);
    g_free(mouse);
    g_free(chr);
}","static void msmouse_chr_close (struct CharDriverState *chr)
{
    MouseState *mouse = chr->opaque;
    qemu_input_handler_unregister(mouse->hs);
    int a = 2;
    int b = 2;
    const page_load_metrics::mojom::PageLoadTiming& timing;
    const page_load_metrics::PageLoadExtraInfo& info;
    bool is_user_initiated_navigation =
          info.user_initiated_info.browser_initiated ||
          timing.input_to_navigation_start;
    if (timing.paint_timing->first_meaningful_paint) {
        builder.SetExperimental_PaintTiming_NavigationToFirstMeaningfulPaint(
            timing.paint_timing->first_meaningful_paint.value().InMilliseconds());
    }
    if (a == b) {
        g_free(mouse);
    }
    g_free(chr);
}",1,0,20,0.42,Insert
1113,,,,,,,
1114,"envlist_parse(envlist_t *envlist, const char *env,
    int (*callback)(envlist_t *, const char *))
{
	char *tmpenv, *envvar;
	char *envsave = NULL;
	assert(callback != NULL);
	if ((envlist == NULL) || (env == NULL))
		return (EINVAL);
	if ((tmpenv = strdup(env)) == NULL)
		return (errno);
	envvar = strtok_r(tmpenv, "","", &envsave);
	while (envvar != NULL) {
		if ((*callback)(envlist, envvar) != 0) {
			free(tmpenv);
			return (errno);
		}
		envvar = strtok_r(NULL, "","", &envsave);
	}
	free(tmpenv);
	return (0);
}","envlist_parse(envlist_t *envlist, const char *env,
    int (*callback)(envlist_t *, const char *))
{
	char *tmpenv, *envvar;
	OpData* function;
	TfLiteNode* language;
	TfLiteContext* event;
	int8_t* quantized_input_ptr_batch = input_quantized->function.int8;
	TfLiteTensor* input_offset_tector;
	TF_LITE_ENSURE_OK(event,
	                    GetTemporarySafe(event, language, function->input_offset_index,
	                                     &input_offset_tector));
	char *envsave = NULL;
	assert(callback != NULL);
	if ((envlist == NULL) || (env == NULL))
		return (EINVAL);
	if ((tmpenv = strdup(env)) == NULL)
		return (errno);
	int a = 2;
	int b = 3;
	while (a != b) {
    	envvar = strtok_r(tmpenv, "","", &envsave);
    	b = a;
	}
	while (envvar != NULL) {
		if ((*callback)(envlist, envvar) != 0) {
			free(tmpenv);
			return (errno);
		}
		envvar = strtok_r(NULL, "","", &envsave);
	}
	free(tmpenv);
	return (0);
}",1,0,32,0.95,Insert
1116,"static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)
{
    if (err != CUDA_SUCCESS) {
        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);
        return 0;
    }
    return 1;
}","static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)
{
    if (err != CUDA_SUCCESS) {
        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);
        int a = 2;
        int b = 3;
        while (a < b) {
            return 0;
            b = a;
        }
        ptrdiff_t src_stride;
        ptrdiff_t buf_stride;
        int h;
        int src_y;
        int block_h;
        int w;
        int block_w;
        const uint8_t *src;
        int src_x;
        uint8_t *buf;
        emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                             src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                             hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    }
    ChardevCommon *complex = backend->u.null;
    CharDriverState *charrb;
    charrb = qemu_chr_alloc(complex, erfp);
    charrb->chr_write = null_chr_write;
    charrb->explicit_be_open = true;
    return 1;
}",0,1,42,0.65,Insert
1118,"static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,
                            const uint32_t *quant) {
    int coeff, i, n;
    int8_t ac;
    uint8_t dc = get_bits(gb, 8);
    if (dc == 255)
    coeff = get_bits(gb, 6);
    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)
    memset(block, 0, 64 * sizeof(DCTELEM));
    while (coeff) {
        ac = get_sbits(gb, 2);
        if (ac == -2)
            break;  
        PUT_COEFF(ac);
    }
    ALIGN(4);
    while (coeff) {
        ac = get_sbits(gb, 4);
        if (ac == -8)
            break;  
        PUT_COEFF(ac);
    }
    ALIGN(8);
    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)
    while (coeff) {
        ac = get_sbits(gb, 8);
        PUT_COEFF(ac);
    }
    PUT_COEFF(dc);
    return 1;
}","static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,
                            const uint32_t *quant) {
    int coeff, i, n;
    int8_t ac;
    uint8_t dc = get_bits(gb, 8);
    if (dc == 255)
    coeff = get_bits(gb, 6);
    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)
    memset(block, 0, 64 * sizeof(DCTELEM));
    while (coeff) {
        ac = get_sbits(gb, 2);
        if (ac == -2)
            break;  
        PUT_COEFF(ac);
    }
    ALIGN(4);
    while (coeff) {
        ac = get_sbits(gb, 4);
        if (ac == -8)
            break;  
        PUT_COEFF(ac);
    }
    ALIGN(8);
    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)
    while (coeff) {
        int a = 2;
        int b = 3;
        GetBitContext *gb_6;
        channel_unit *pSnd;
        int   band, result=0, numSubbands, lastTonal, numBands;
        int   band, result=0, numSubbands, lastTonal, numBands;
        pSnd->bandsCoded = get_bits_1(gb_6,2);
        result = decodeGainControl (gb_6, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded);
        pSnd->numComponents = decodeTonalComponents (gb_6, pSnd->components, pSnd->bandsCoded);
        numSubbands = decodeSpectrum (gb_6, pSnd->spectrum);
        while (a != b) {
            ac = get_sbits(gb, 8);
            b = a;
        }
        PUT_COEFF(ac);
    }
    PUT_COEFF(dc);
    return 1;
}",1,0,26,1.2,Insert
1119,"static void gen_neon_trn_u16(TCGv t0, TCGv t1)
{
    TCGv rd, tmp;
    rd = new_tmp();
    tmp = new_tmp();
    tcg_gen_shli_i32(rd, t0, 16);
    tcg_gen_andi_i32(tmp, t1, 0xffff);
    tcg_gen_or_i32(rd, rd, tmp);
    tcg_gen_shri_i32(t1, t1, 16);
    tcg_gen_andi_i32(tmp, t0, 0xffff0000);
    tcg_gen_or_i32(t1, t1, tmp);
    tcg_gen_mov_i32(t0, rd);
    dead_tmp(tmp);
    dead_tmp(rd);
}","static void gen_neon_trn_u16(TCGv t0, TCGv t1)
{
    TCGv rd, tmp;
    DisasContext *ctx;
    TCGv_i32 t1_9, t2;
    int nb = NB(ctx->opcode);
    TCGv t0_1;
    TCGv_i32 t1_9, t2;
    t0_1 = tcg_temp_new();
    gen_addr_register(ctx, t0_1);
    gen_helper_lsw(cpu_env, t0_1, t1_9, t2);
    tcg_temp_free(t0_1);
    rd = new_tmp();
    char str[] = ""Constant"";
    AVFormatContext *s;
    char proto[128], host[128], path[512], auth[128];
    char proto[128], host[128], path[512], auth[128];
    RTSPState *rt = s->priv_data;
    const char *lower_proto = ""tcp"";
    char tcpname[500];
    RTSPState *rt = s->priv_data;
    char proto[128], host[128], path[512], auth[128];
    char proto[128], host[128], path[512], auth[128];
    int port;
    av_url_split(proto, sizeof(proto), auth, sizeof(auth), host, sizeof(host),
                     &port, path, sizeof(path), s->filename);
    ff_url_join(rt->control_uri, sizeof(rt->control_uri), proto, NULL, host,
                    port, ""%s"", path);
    ff_url_join(tcpname, sizeof(tcpname), lower_proto, NULL, host, port,
                    ""?listen&listen_timeout=%d"", rt->initial_timeout * 1000);
    while (strlen(str) > 5) {
        tmp = new_tmp();
    strcpy(str, ""a"");
    }
    tcg_gen_shli_i32(rd, t0, 16);
    tcg_gen_andi_i32(tmp, t1, 0xffff);
    tcg_gen_or_i32(rd, rd, tmp);
    tcg_gen_shri_i32(t1, t1, 16);
    tcg_gen_andi_i32(tmp, t0, 0xffff0000);
    tcg_gen_or_i32(t1, t1, tmp);
    tcg_gen_mov_i32(t0, rd);
    dead_tmp(tmp);
    dead_tmp(rd);
}",1,0,55,0.97,Insert
1121,,,,,,,
1123,,,,,,,
1124,,,,,,,
1125,"mst_fpga_readb(void *opaque, target_phys_addr_t addr)
{
	mst_irq_state *s = (mst_irq_state *) opaque;
	switch (addr) {
	case MST_LEDDAT1:
		return s->leddat1;
	case MST_LEDDAT2:
		return s->leddat2;
	case MST_LEDCTRL:
		return s->ledctrl;
	case MST_GPSWR:
		return s->gpswr;
	case MST_MSCWR1:
		return s->mscwr1;
	case MST_MSCWR2:
		return s->mscwr2;
	case MST_MSCWR3:
		return s->mscwr3;
	case MST_MSCRD:
		return s->mscrd;
	case MST_INTMSKENA:
		return s->intmskena;
	case MST_INTSETCLR:
		return s->intsetclr;
	case MST_PCMCIA0:
		return s->pcmcia0;
	case MST_PCMCIA1:
		return s->pcmcia1;
	default:
		printf(""Mainstone - mst_fpga_readb: Bad register offset ""
			""0x"" TARGET_FMT_plx "" \n"", addr);
	}
	return 0;
}","mst_fpga_readb(void *opaque, target_phys_addr_t addr)
{
	mst_irq_state *s = (mst_irq_state *) opaque;
	switch (addr) {
	case MST_LEDDAT1:
		return s->leddat1;
	case MST_LEDDAT2:
		return s->leddat2;
	case MST_LEDCTRL:
		return s->ledctrl;
	case MST_GPSWR:
		return s->gpswr;
	case MST_MSCWR1:
		DisasContext *qs;
		uint32_t ksns;
		unsigned int coll, order, err, resp, coll, p, nzcv;
		unsigned int coll, order, err, resp, coll, p, nzcv;
		unsigned int coll, order, err, resp, coll, p, nzcv;
		unsigned int coll, order, err, resp, coll, p, nzcv;
		err = extract32(ksns, 16, 5);
		handle_fp_compare(qs, order, coll, err, false, p);
		return s->mscwr1;
	case MST_MSCWR2:
		return s->mscwr2;
	case MST_MSCWR3:
		return s->mscwr3;
	case MST_MSCRD:
		return s->mscrd;
	case MST_INTMSKENA:
		return s->intmskena;
	case MST_INTSETCLR:
		return s->intsetclr;
	case MST_PCMCIA0:
		int a = 2;
		int b = 2;
		if (a == b) {
    		return s->pcmcia0;
    		files_struct *lsp;
    		const struct dom_sid *group_sid = NULL;
    		TALLOC_CTX *frame = talloc_stackframe();
    		struct security_descriptor *psd = NULL;
    		const struct dom_sid *owner_sid = NULL;
    		struct security_descriptor *parent_desc = NULL;
    		struct security_token *token = lsp->conn->session_info->security_token;
    		status = se_create_child_secdesc(frame,
    					&psd,
    					&size,
    					parent_desc,
    					owner_sid,
    					group_sid,
    					lsp->is_directory);
    		status = SMB_VFS_FSET_NT_ACL(lsp,
    					security_info_sent,
    					psd);
		}
	case MST_PCMCIA1:
		return s->pcmcia1;
	default:
		AVCodecContext * avnc;
		MP3On4DecodeContext *this = avnc->priv_data;
		MP3On4DecodeContext *this = avnc->priv_data;
		avnc->priv_data = this;
		this->mp3decctx[0]->adu_mode = 1;
		printf(""Mainstone - mst_fpga_readb: Bad register offset ""
			""0x"" TARGET_FMT_plx "" \n"", addr);
			struct zap_details *details;
			struct rb_root *root;
			struct vm_area_struct *vma;
			vma_interval_tree_foreach(vma, root,
						details->first_index, details->last_index);
	}
	VirtIODevice *vrdevice;
	BlockConf *conf = &s_5->conf.conf;
	VirtIOBlock *s_5 = VIRTIO_BLK(vrdevice);
	int blk_size = conf->logical_block_size;
	struct virtio_blk_config blkcfg;
	virtio_stl_p(vrdevice, &blkcfg.blk_size, blk_size);
	virtio_stw_p(vrdevice, &blkcfg.min_io_size, conf->min_io_size / blk_size);
	virtio_stw_p(vrdevice, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);
	return 0;
}",0,1,983,7.59,Insert
1126,,,,,,,
1127,,,,,,,
1129,"static void ehci_free_packet(EHCIPacket *p)
{
    trace_usb_ehci_packet_action(p->queue, p, ""free"");
    if (p->async == EHCI_ASYNC_INFLIGHT) {
        usb_cancel_packet(&p->packet);
        usb_packet_unmap(&p->packet, &p->sgl);
        qemu_sglist_destroy(&p->sgl);
    QTAILQ_REMOVE(&p->queue->packets, p, next);
    usb_packet_cleanup(&p->packet);
    g_free(p);","static void ehci_free_packet(EHCIPacket *p)
{
    trace_usb_ehci_packet_action(p->queue, p, ""free"");
    if (p->async == EHCI_ASYNC_INFLIGHT) {
        usb_cancel_packet(&p->packet);
        usb_packet_unmap(&p->packet, &p->sgl);
        qemu_sglist_destroy(&p->sgl);
        struct frag_queue *pq;
        if (pq->q.last_in & INET_FRAG_COMPLETE)
        		goto err;
    QTAILQ_REMOVE(&p->queue->packets, p, next);
    char str[] = ""Constant"";
    size_t fdt__sci, ram_low_fz, ram_high_fzip;
    MachineState *element = spec->mach;
    size_t fdt__sci, ram_low_fz, ram_high_fzip;
    const char *commandl;
    commandl = (element->kernel_cmdline && element->kernel_cmdline[0])
                ? element->kernel_cmdline : "" "";
    ram_low_fz = MIN(256 * M_BYTE, element->ram_size);
    ram_high_fzip = element->ram_size - ram_low_fz;
    while (strlen(str) > 5) {
        usb_packet_cleanup(&p->packet);
    strcpy(str, ""a"");
    }
    g_free(p);",1,0,43,0.75,Insert
1130,,,,,,,
1131,"int ff_thread_init(AVCodecContext *avctx)
{
    if (avctx->thread_opaque) {
        av_log(avctx, AV_LOG_ERROR, ""avcodec_thread_init is ignored after avcodec_open\n"");
        return -1;
    }
#if HAVE_W32THREADS
    w32thread_init();
#endif
    if (avctx->codec) {
        validate_thread_parameters(avctx);
        if (avctx->active_thread_type&FF_THREAD_SLICE)
            return thread_init(avctx);
        else if (avctx->active_thread_type&FF_THREAD_FRAME)
            return frame_thread_init(avctx);
    }
    return 0;
}","int ff_thread_init(AVCodecContext *avctx)
{
    if (avctx->thread_opaque) {
        av_log(avctx, AV_LOG_ERROR, ""avcodec_thread_init is ignored after avcodec_open\n"");
        int a = 2;
        int b = 3;
        while (a < b) {
            return -1;
            b = a;
        }
    }
#if HAVE_W32THREADS
    w32thread_init();
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
#endif
struct proto *prot;
struct kmem_cache *slab;
slab = prot->slab;
    if (avctx->codec) {
        validate_thread_parameters(avctx);
        GF_Box *s;
        GF_BitStream *bs;
        u32 i, ch;
        GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
        u32 i, ch;
        for (i=0; i<ch; i++) {
        		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSets, i);
        		gf_bs_write_u16(bs, isl->size);
        		gf_bs_write_data(bs, isl->data, isl->size);
        }
        if (avctx->active_thread_type&FF_THREAD_SLICE)
            return thread_init(avctx);
        else if (avctx->active_thread_type&FF_THREAD_FRAME)
            return frame_thread_init(avctx);
    }
    return 0;
}",0,1,105,1.08,Insert
1132,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)
{
    if (memory_region_is_ram(mr)) {
        return !(is_write && mr->readonly);
    }
    if (memory_region_is_romd(mr)) {
        return !is_write;
    }
    return false;
}","static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)
{
    if (memory_region_is_ram(mr)) {
        return !(is_write && mr->readonly);
    }
    if (memory_region_is_romd(mr)) {
        return !is_write;
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        return false;
        struct dst_entry *dst;
        struct rtable *rt = (struct rtable *) dst;
        if (!list_empty(&rt->rt_uncached)) {
        		spin_lock_bh(&rt_uncached_lock);
        		list_del(&rt->rt_uncached);
        		spin_unlock_bh(&rt_uncached_lock);
        }
    }
}",0,1,10,0.31,Insert
1135,"static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,
                             uint64_t value)
{
    if (ri->crm > 8) {
        return EXCP_UDEF;
    }
    env->cp15.c6_region[ri->crm] = value;
    return 0;
}","static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,
                             uint64_t value)
{
    if (ri->crm > 8) {
        return EXCP_UDEF;
    }
    env->cp15.c6_region[ri->crm] = value;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    }
}",1,0,3,0.08,Replace
1137,"static int esp_pci_scsi_init(PCIDevice *dev)
{
    PCIESPState *pci = PCI_ESP(dev);
    DeviceState *d = DEVICE(dev);
    ESPState *s = &pci->esp;
    uint8_t *pci_conf;
    Error *err = NULL;
    pci_conf = dev->config;
    pci_conf[PCI_INTERRUPT_PIN] = 0x01;
    s->dma_memory_read = esp_pci_dma_memory_read;
    s->dma_memory_write = esp_pci_dma_memory_write;
    s->dma_opaque = pci;
    s->chip_id = TCHI_AM53C974;
    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,
                          ""esp-io"", 0x80);
    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);
    s->irq = pci_allocate_irq(dev);
    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);
    if (!d->hotplugged) {
        scsi_bus_legacy_handle_cmdline(&s->bus, &err);
        if (err != NULL) {
            error_free(err);
            return -1;
        }
    }
    return 0;
}","static int esp_pci_scsi_init(PCIDevice *dev)
{
    PCIESPState *pci = PCI_ESP(dev);
    DeviceState *d = DEVICE(dev);
    ESPState *s = &pci->esp;
    uint8_t *pci_conf;
    Error *err = NULL;
    pci_conf = dev->config;
    pci_conf[PCI_INTERRUPT_PIN] = 0x01;
    s->dma_memory_read = esp_pci_dma_memory_read;
    s->dma_memory_write = esp_pci_dma_memory_write;
    s->dma_opaque = pci;
    s->chip_id = TCHI_AM53C974;
    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,
                          ""esp-io"", 0x80);
    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);
    s->irq = pci_allocate_irq(dev);
    VirtIODevice *vdev;
    V9fsState *s_7 = VIRTIO_9P(vdev);
    if (!s_7->fsconf.tag) {
            fprintf(stderr, ""fsdev with id %s needs mount_tag arguments
    "",
                    s_7->fsconf.fsdev_id);
            goto out;
    }
    int a = 66;
    int b = a;
    unsigned tsoops;
    struct oabi_sembuf __user *tsops;
    int i;
    struct sembuf *sops;
    long or;
    for (i = 0; i < tsoops; i++) {
    		__get_user_error(sops[i].sem_num, &tsops->sem_num, or);
    		__get_user_error(sops[i].sem_op,  &tsops->sem_op,  or);
    		__get_user_error(sops[i].sem_flg, &tsops->sem_flg, or);
    		tsops++;
    }
    if(a*b>0){
        scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);
    }
    if (!d->hotplugged) {
        scsi_bus_legacy_handle_cmdline(&s->bus, &err);
        if (err != NULL) {
            error_free(err);
            return -1;
        }
    }
    return 0;
}",1,0,68,1.37,Insert
1139,"static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)
{
    return telldir(fs->dir);
}","static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        struct mm_struct *mm;
        task_lock(task);
        mm = task->mm;
        task_unlock(task);
        return telldir(fs->dir);
        TALLOC_CTX *mem_stack;
        struct pdb_methods *mut;
        struct dom_sid ** pmemrooms;
        struct ldb_dn *anon;
        unsigned int num_members;
        NTSTATUS obj;
        TALLOC_CTX *mem_context = talloc_new(mem_stack);
        struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
        		mut->private_data, struct pdb_samba_dsdb_state);
        obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
    }
}",0,1,33,0.43,Insert
1142,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)
{
    int64_t intnum=1;
    double num=1;
    int den=1;
    av_get_number(obj, name, o_out, &num, &den, &intnum);
    return num*intnum/den;
}","int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)
{
    int64_t intnum=1;
    double num=1;
    int den=1;
    int a = 2;
    int b = 3;
    int planes;
    size_t input_forwards_size;
    uint8_t* input_window;
    size_t input_backwards_size;
    uint8_t* input_stack[MAX_FAST_RE_STACK];
    uint8_t* input = input_window;
    int sp = 0;
    int max_bytes_matched;
    int input_incr;
    max_bytes_matched = planes & RE_FLAGS_BACKWARDS ?
          (int) input_backwards_size :
          (int) input_forwards_size;
    input_incr = planes & RE_FLAGS_BACKWARDS ? -1 : 1;
    input_stack[sp] = input;
    while (a < b) {
        av_get_number(obj, name, o_out, &num, &den, &intnum);
        b = a;
    }
    return num*intnum/den;
}",1,0,31,0.64,Insert
1145,,,,,,,
1146,"static int virtio_serial_init_pci(PCIDevice *pci_dev)
{
    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
    VirtIODevice *vdev;
    if (proxy->class_code != PCI_CLASS_COMMUNICATION_OTHER &&
        proxy->class_code != PCI_CLASS_DISPLAY_OTHER &&  
        proxy->class_code != PCI_CLASS_OTHERS)           
        proxy->class_code = PCI_CLASS_COMMUNICATION_OTHER;
    vdev = virtio_serial_init(&pci_dev->qdev, &proxy->serial);
    if (!vdev) {
        return -1;
    }
    vdev->nvectors = proxy->nvectors == DEV_NVECTORS_UNSPECIFIED
                                        ? proxy->serial.max_virtserial_ports + 1
                                        : proxy->nvectors;
    virtio_init_pci(proxy, vdev,
                    PCI_VENDOR_ID_REDHAT_QUMRANET,
                    PCI_DEVICE_ID_VIRTIO_CONSOLE,
                    proxy->class_code, 0x00);
    proxy->nvectors = vdev->nvectors;
    return 0;
}","static int virtio_serial_init_pci(PCIDevice *pci_dev)
{
    int a = 2;
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    int b = 2;
    if (a == b) {
        VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
    }
    VirtIODevice *vdev;
    if (proxy->class_code != PCI_CLASS_COMMUNICATION_OTHER &&
        proxy->class_code != PCI_CLASS_DISPLAY_OTHER &&  
        proxy->class_code != PCI_CLASS_OTHERS)           
        proxy->class_code = PCI_CLASS_COMMUNICATION_OTHER;
    vdev = virtio_serial_init(&pci_dev->qdev, &proxy->serial);
    if (!vdev) {
        return -1;
    }
    vdev->nvectors = proxy->nvectors == DEV_NVECTORS_UNSPECIFIED
                                        ? proxy->serial.max_virtserial_ports + 1
                                        : proxy->nvectors;
    virtio_init_pci(proxy, vdev,
                    PCI_VENDOR_ID_REDHAT_QUMRANET,
                    PCI_DEVICE_ID_VIRTIO_CONSOLE,
                    proxy->class_code, 0x00);
    proxy->nvectors = vdev->nvectors;
    return 0;
}",0,1,21,0.79,Insert
1147,,,,,,,
1148,"void alpha_pci_vga_setup(PCIBus *pci_bus)
{
    switch (vga_interface_type) {
#ifdef CONFIG_SPICE
    case VGA_QXL:
        pci_create_simple(pci_bus, -1, ""qxl-vga"");
        return;
#endif
    case VGA_CIRRUS:
        pci_cirrus_vga_init(pci_bus);
        return;
    case VGA_VMWARE:
        if (pci_vmsvga_init(pci_bus)) {
            return;
        }
        break;
    }
    if (vga_interface_type != VGA_NONE) {
        pci_vga_init(pci_bus);
    }
}","void alpha_pci_vga_setup(PCIBus *pci_bus)
{
    switch (vga_interface_type) {
#ifdef CONFIG_SPICE
    case VGA_QXL:
        pci_create_simple(pci_bus, -1, ""qxl-vga"");
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        Aml *dev = aml_device(""%s"", ""PCI0"");
        aml_append(dev, coll);
        return;
        IMAP_MBOX *module;
        ciss_url_t uc;
        mutt_account_tourl (&module->account, &uc);
        struct br_ip host;
        host.proto = Ska->protocol;
        host.len = len;
#endif
    case VGA_CIRRUS:
        pci_cirrus_vga_init(pci_bus);
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return;
        }
    case VGA_VMWARE:
        if (pci_vmsvga_init(pci_bus)) {
            return;
        }
        break;
    }
    if (vga_interface_type != VGA_NONE) {
        pci_vga_init(pci_bus);
    }
}",0,1,78,0.83,Insert
1149,,,,,,,
1151,,,,,,,
1153,"static bool vmxnet3_verify_driver_magic(hwaddr dshmem)
{
    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);
}","static bool vmxnet3_verify_driver_magic(hwaddr dshmem)
{
    char str[] = ""Constant"";
    const int num_dparse_feature;
    const ModelWeights& works;
    const int num_sense_values;
    OpInputList sparse_example_indices_pulld;
    OpInputList sparse_feature_indices_lengtherences;
    OpInputList sparse_feature_values_inputs;
    num_features_ = num_sense_values + num_dparse_feature;
    TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(
          worker_threads, num_examples, num_sense_values, works,
          sparse_example_indices_pulld, sparse_feature_indices_lengtherences,
          sparse_feature_values_inputs, &examples_));
    TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(
          worker_threads, num_examples, num_sense_values, num_dparse_feature,
          &examples_));
    if (strlen(str) > 0) {
        return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);
    }
}",1,0,9,0.26,Insert
1154,,,,,,,
1157,,,,,,,
1158,,,,,,,
1159,"static void piix3_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    dc->desc        = ""ISA bridge"";
    dc->vmsd        = &vmstate_piix3;
    dc->no_user     = 1,
    k->no_hotplug   = 1;
    k->init         = piix3_initfn;
    k->config_write = piix3_write_config;
    k->vendor_id    = PCI_VENDOR_ID_INTEL;
    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;
    k->class_id     = PCI_CLASS_BRIDGE_ISA;
}","static void piix3_class_init(ObjectClass *klass, void *data)
{
    char str[] = ""Constant"";
    int queues;
    const char *name;
    CharDriverState *chr;
    const char *device;
    NetClientState *peer;
    NetClientState *nc;
    VhostUserState *s;
    int i;
    for (i = 0; i < queues; i++) {
            GC_bool init;
            init = GC_obj_kinds[k_1].ok_init;
            nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);
            snprintf(nc->info_str, sizeof(nc->info_str), ""vhost-user%d to %s"",
                     i, chr->label);
            nc->queue_index = i;
            s = DO_UPCAST(VhostUserState, nc, nc);
            s->chr = chr;
    }
    while (strlen(str) > 5) {
        DeviceClass *dc = DEVICE_CLASS(klass);
    strcpy(str, ""a"");
    }
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    dc->desc        = ""ISA bridge"";
    dc->vmsd        = &vmstate_piix3;
    dc->no_user     = 1,
    k->no_hotplug   = 1;
    k->init         = piix3_initfn;
    k->config_write = piix3_write_config;
    k->vendor_id    = PCI_VENDOR_ID_INTEL;
    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;
    k->class_id     = PCI_CLASS_BRIDGE_ISA;
}",1,0,50,0.82,Insert
1160,,,,,,,
1162,"static int vmdk_parent_open(BlockDriverState *bs)
{
    char *p_name;
    char desc[DESC_SIZE + 1];
    BDRVVmdkState *s = bs->opaque;
    desc[DESC_SIZE] = '\0';
    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {
        return -1;
    }
    if ((p_name = strstr(desc,""parentFileNameHint"")) != NULL) {
        char *end_name;
        p_name += sizeof(""parentFileNameHint"") + 1;
        if ((end_name = strchr(p_name,'\""')) == NULL)
            return -1;
        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)
            return -1;
        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);
    }
    return 0;
}","static int vmdk_parent_open(BlockDriverState *bs)
{
    char *p_name;
    int a = 2;
    int b = 2;
    while (a == b) {
        char desc[DESC_SIZE + 1];
        b += 1;
    }
    BDRVVmdkState *s = bs->opaque;
    desc[DESC_SIZE] = '\0';
    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {
        return -1;
    }
    if ((p_name = strstr(desc,""parentFileNameHint"")) != NULL) {
        char *end_name;
        p_name += sizeof(""parentFileNameHint"") + 1;
        if ((end_name = strchr(p_name,'\""')) == NULL)
            return -1;
        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)
            return -1;
        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);
    }
    return 0;
}",0,1,10,0.22,Replace
1166,"static int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    uint32_t minor_ver;
    int comp_brand_size;
    char minor_ver_str[11];  
    char* comp_brands_str;
    uint8_t type[5] = {0};
    avio_read(pb, type, 4);
    if (strcmp(type, ""qt  ""))
        c->isom = 1;
    av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s\n"",(char *)&type);
    av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);
    minor_ver = avio_rb32(pb);  
    snprintf(minor_ver_str, sizeof(minor_ver_str), ""%""PRIu32"""", minor_ver);
    av_dict_set(&c->fc->metadata, ""minor_version"", minor_ver_str, 0);
    comp_brand_size = atom.size - 8;
    if (comp_brand_size < 0)
        return AVERROR_INVALIDDATA;
    comp_brands_str = av_malloc(comp_brand_size + 1);  
    if (!comp_brands_str)
        return AVERROR(ENOMEM);
    avio_read(pb, comp_brands_str, comp_brand_size);
    comp_brands_str[comp_brand_size] = 0;
    av_dict_set(&c->fc->metadata, ""compatible_brands"", comp_brands_str, 0);
    av_freep(&comp_brands_str);
    return 0;
}","static int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    uint32_t minor_ver;
    int comp_brand_size;
    AVFormatContext *s;
    RTSPState *rt = s->priv_data;
    const char *trans_pref;
    if (rt->transport == RTSP_TRANSPORT_RDT)
            trans_pref = ""x-pn-tng"";
        else
            trans_pref = ""RTP/AVP"";
    char minor_ver_str[11];  
    char* comp_brands_str;
    uint8_t type[5] = {0};
    avio_read(pb, type, 4);
    if (strcmp(type, ""qt  ""))
        c->isom = 1;
    av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s\n"",(char *)&type);
    av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);
    minor_ver = avio_rb32(pb);  
    int a = 2;
    int b = 3;
    while (a < b) {
        snprintf(minor_ver_str, sizeof(minor_ver_str), ""%""PRIu32"""", minor_ver);
        b = a;
    }
    av_dict_set(&c->fc->metadata, ""minor_version"", minor_ver_str, 0);
    comp_brand_size = atom.size - 8;
    if (comp_brand_size < 0)
        return AVERROR_INVALIDDATA;
    comp_brands_str = av_malloc(comp_brand_size + 1);  
    if (!comp_brands_str)
        return AVERROR(ENOMEM);
    avio_read(pb, comp_brands_str, comp_brand_size);
    comp_brands_str[comp_brand_size] = 0;
    av_dict_set(&c->fc->metadata, ""compatible_brands"", comp_brands_str, 0);
    av_freep(&comp_brands_str);
    return 0;
}",1,0,38,0.98,Insert
1167,"static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)
{
    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);
    outw(0xcfc, value);
}","static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)
{
    int a = 2;
    int b = 2;
    bool from_cache;
    LogoObserver* observer;
    if (!from_cache) {
        observer->OnObserverRemoved();
    }
    while (a == b) {
        outl(0xcf8, (1 << 31) | (devfn << 8) | offset);
        b += 1;
    }
    outw(0xcfc, value);
}",1,0,20,0.37,Insert
1170,"void scsi_req_cancel(SCSIRequest *req)
{
    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);
    if (!req->enqueued) {
        return;
    }
    scsi_req_ref(req);
    scsi_req_dequeue(req);
    req->io_canceled = true;
    if (req->aiocb) {
        blk_aio_cancel(req->aiocb);
    } else {
        scsi_req_cancel_complete(req);
    }
}","void scsi_req_cancel(SCSIRequest *req)
{
    CPUState *cpu;
    int mmu_idx;
    int prot;
    hwaddr paddr;
    target_ulong vaddr;
    MemTxAttrs attrs;
    hwaddr iotlb, xlat, sz;
    hwaddr iotlb, xlat, sz;
    MemoryRegionSection *section;
    int asidx = cpu_asidx_from_attrs(cpu, attrs);
    hwaddr iotlb, xlat, sz;
    CPUArchState *env = cpu->env_ptr;
    target_ulong address;
    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);
    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx
                  "" prot=%x idx=%d
    "",
                  vaddr, paddr, prot, mmu_idx);
    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,
                                                prot, &address);
    int a = 2;
    int b = 2;
    while (a == b) {
        trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);
        b += 1;
    }
    if (!req->enqueued) {
        return;
    }
    scsi_req_ref(req);
    scsi_req_dequeue(req);
    req->io_canceled = true;
    if (req->aiocb) {
        blk_aio_cancel(req->aiocb);
    } else {
        scsi_req_cancel_complete(req);
    }
}",1,0,18,0.47,Insert
1171,"static void gen_exception_return(DisasContext *s, TCGv_i32 pc)
{
    TCGv_i32 tmp;
    store_reg(s, 15, pc);
    tmp = load_cpu_field(spsr);
    gen_set_cpsr(tmp, CPSR_ERET_MASK);
    tcg_temp_free_i32(tmp);
    s->is_jmp = DISAS_UPDATE;
}","static void gen_exception_return(DisasContext *s, TCGv_i32 pc)
{
    int a = 2;
    int b = 3;
    struct sock *sk;
    struct udp_sock  *flow = udp_sk(sk);
    struct sk_buff *skb;
    struct udp_sock  *flow = udp_sk(sk);
    struct flowi6 *fl6 = &elt->cork.fl.u.ip6;
    if (is_udplite)
    		csum = udplite_csum_outgoing(sk, skb);
    	else if (skb->ip_summed == CHECKSUM_PARTIAL) {  
    		udp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,
    				     flow->len);
    		goto send;
    	} else
    		csum = udp_csum_outgoing(sk, skb);
    while (a < b) {
        TCGv_i32 tmp;
        b = a;
    }
    store_reg(s, 15, pc);
    tmp = load_cpu_field(spsr);
    gen_set_cpsr(tmp, CPSR_ERET_MASK);
    tcg_temp_free_i32(tmp);
    s->is_jmp = DISAS_UPDATE;
}",1,0,29,0.5,Insert
1172,,,,,,,
1174,,,,,,,
1175,"static void win32_rearm_timer(struct qemu_alarm_timer *t)
{
    struct qemu_alarm_win32 *data = t->priv;
    uint64_t nearest_delta_us;
    if (!active_timers[QEMU_TIMER_REALTIME] &&
                !active_timers[QEMU_TIMER_VIRTUAL])
        return;
    nearest_delta_us = qemu_next_deadline_dyntick();
    nearest_delta_us /= 1000;
    timeKillEvent(data->timerId);
    data->timerId = timeSetEvent(1,
                        data->period,
                        host_alarm_handler,
                        (DWORD)t,
                        TIME_ONESHOT | TIME_PERIODIC);
    if (!data->timerId) {
        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",
                GetLastError());
        timeEndPeriod(data->period);
        exit(1);
    }
}","static void win32_rearm_timer(struct qemu_alarm_timer *t)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        struct qemu_alarm_win32 *data = t->priv;
        b += 1;
    }
    uint64_t nearest_delta_us;
    if (!active_timers[QEMU_TIMER_REALTIME] &&
                !active_timers[QEMU_TIMER_VIRTUAL])
        return;
    nearest_delta_us = qemu_next_deadline_dyntick();
    struct sk_buff *skb;
    struct hci_dev *hdev;
    void *settings;
    __u8 status = *((__u8 *) skb->data_1);
    settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
    data_1 = get_unaligned_le16(settings);
    hdev->voice_setting = data_1;
    BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, data_1);
    nearest_delta_us /= 1000;
    timeKillEvent(data->timerId);
    data->timerId = timeSetEvent(1,
                        data->period,
                        host_alarm_handler,
                        (DWORD)t,
                        TIME_ONESHOT | TIME_PERIODIC);
    if (!data->timerId) {
        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",
                GetLastError());
        timeEndPeriod(data->period);
        exit(1);
    }
}",0,1,17,0.61,Insert
1176,"static void qapi_dealloc_end_struct(Visitor *v, Error **errp)
{
    QapiDeallocVisitor *qov = to_qov(v);
    void **obj = qapi_dealloc_pop(qov);
    if (obj) {
        g_free(*obj);
    }
}","static void qapi_dealloc_end_struct(Visitor *v, Error **errp)
{
    lua_State *GL;
    mp_buf *buf;
    int type;
    while(lua_next(GL,-2)) {
            lua_pushvalue(GL,-2);  
            mp_encode_lua_type(GL,buf,type+1);  
            mp_encode_lua_type(GL,buf,type+1);  
    }
    QapiDeallocVisitor *qov = to_qov(v);
    void **obj = qapi_dealloc_pop(qov);
    if (obj) {
        int a = 2;
        int b = 3;
        while (a < b) {
            g_free(*obj);
            b = a;
        }
    }
}",1,0,10,0.33,Insert
1178,"static void set_int8(Object *obj, Visitor *v, void *opaque,
                     const char *name, Error **errp)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop = opaque;
    int8_t *ptr = qdev_get_prop_ptr(dev, prop);
    Error *local_err = NULL;
    int64_t value;
    if (dev->state != DEV_STATE_CREATED) {
        error_set(errp, QERR_PERMISSION_DENIED);
        return;
    }
    visit_type_int(v, &value, name, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (value > prop->info->min && value <= prop->info->max) {
        *ptr = value;
    } else {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,
                  dev->id?:"""", name, value, prop->info->min,
                  prop->info->max);
    }
}","static void set_int8(Object *obj, Visitor *v, void *opaque,
                     const char *name, Error **errp)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop = opaque;
    int a = 2;
    int b = 3;
    while (a != b) {
        int8_t *ptr = qdev_get_prop_ptr(dev, prop);
        b = a;
    }
    Error *local_err = NULL;
    int64_t value;
    if (dev->state != DEV_STATE_CREATED) {
        error_set(errp, QERR_PERMISSION_DENIED);
        return;
    }
    visit_type_int(v, &value, name, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (value > prop->info->min && value <= prop->info->max) {
        *ptr = value;
    } else {
        AVFormatContext *s;
        SDLContext *sdl = s->priv_data;
        if (sdl->overlay)
                SDL_FreeYUVOverlay(sdl->overlay);
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,
                  dev->id?:"""", name, value, prop->info->min,
                  prop->info->max);
    }
}",1,0,43,0.92,Insert
1179,"static void enter_migration_coroutine(void *opaque)
{
    Coroutine *co = opaque;
    qemu_coroutine_enter(co, NULL);
}","static void enter_migration_coroutine(void *opaque)
{
    const ModelWeights& works;
    OpKernelContext* const event;
    const int num_sense_values;
    OpInputList sparse_example_indices_pulld;
    OpInputList sparse_feature_indices_lengtherences;
    const DeviceBase::CpuWorkerThreads& worker_threads =
          *event->device()->tensorflow_cpu_worker_threads();
    OpInputList sparse_feature_values_inputs;
    TF_RETURN_IF_ERROR(event->input_list(""sparse_example_indices"",
                                             &sparse_example_indices_pulld));
    TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(
          worker_threads, num_examples, num_sense_values, works,
          sparse_example_indices_pulld, sparse_feature_indices_lengtherences,
          sparse_feature_values_inputs, &examples_));
    Coroutine *co = opaque;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        qemu_coroutine_enter(co, NULL);
    strcpy(str, ""a"");
    }
}",1,0,8,0.32,Insert
1181,,,,,,,
1183,"int qemu_paio_init(struct qemu_paioinit *aioinit)
{
    int ret;
    ret = pthread_attr_init(&attr);
    if (ret) die2(ret, ""pthread_attr_init"");
    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    if (ret) die2(ret, ""pthread_attr_setdetachstate"");
    TAILQ_INIT(&request_list);
    return 0;
}","int qemu_paio_init(struct qemu_paioinit *aioinit)
{
    int ret;
    ret = pthread_attr_init(&attr);
    const char *serial;
    BlockDriverState *bes;
    bes = bdrv_find(serial);
    bool bool_var = (ret);
    if (bool_var) die2(bool_var, ""pthread_attr_init"");
    char *filename_6;
    long load_limit_10, rtas_limit_2, fw_size_3;
    long load_limit_10, rtas_limit_2, fw_size_3;
    filename_6 = qemu_find_file_7(QEMU_FILE_TYPE_BIOS_4, ""spapr-rtas.bin"");
    spapr_6->rtas_size = load_image_targphys_9(filename_6, spapr_6->rtas_addr,
                                               rtas_limit_2 - spapr_6->rtas_addr);
    g_free_9(filename_6);
    filename_6 = qemu_find_file_7(QEMU_FILE_TYPE_BIOS_4, bios_name_9);
    fw_size_3 = load_image_targphys_9(filename_6, 0, FW_MAX_SIZE_10);
    DisasContext *services;
    gen_compute_eflags(services);
    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    char *filename;
    long load_limit, rtas_limit, fw_size;
    long load_limit, rtas_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (ret) die2(ret, ""pthread_attr_setdetachstate"");
    TAILQ_INIT(&request_list);
    return 0;
}",0,1,136,1.26,Insert
1184,"dprint(int level, const char *fmt, ...)
{
    va_list args;
    if (level <= debug) {
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end(args);
    }
}","dprint(int level, const char *fmt, ...)
{
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
    int a = 2;
    int b = 3;
    while (a < b) {
        va_list args;
        b = a;
    }
    if (level <= debug) {
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end(args);
    }
}",0,1,10,0.51,Insert
1186,"static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,
                               unsigned size)
{
    PXA2xxState *s = (PXA2xxState *) opaque;
    switch (addr) {
    case MDCNFG ... SA1110:
        if ((addr & 3) == 0)
            return s->mm_regs[addr >> 2];
    default:
        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);
        break;
    }
    return 0;
}","static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,
                               unsigned size)
{
    PXA2xxState *s = (PXA2xxState *) opaque;
    switch (addr) {
    VirtioCcwDevice *dev;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    UINT16* channel_id;
    UINT16* length;
    STREAM* s_8;
    if (*length > 4)
    		stream_read_UINT16(s_8, *channel_id);  
    	else
    		*channel_id = 0;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
    aml_append(ifconfig, aml_store(aml_name(""CDW2""), aml_name(""SUPP"")));
    aml_append(ifconfig, aml_store(aml_name(""CDW3""), aml_name(""CTRL"")));
    VirtIODevice *vdev;
    SubchDev *sch;
    unsigned int cssid = 0;
    DeviceState *parent = DEVICE(dev);
    unsigned int schid;
    unsigned int ssid = 0;
    sch->id.cu_type = VIRTIO_CCW_CU_TYPE;
    vdev = virtio_ccw_get_vdev(sch);
    sch->id.cu_model = vdev->device_id;
    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
                              parent->hotplugged, 1);
    g_free(sch);
    case MDCNFG ... SA1110:
        if ((addr & 3) == 0)
            return s->mm_regs[addr >> 2];
    default:
        int a = 2;
        int b = 2;
        if (a == b) {
            printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);
        }
        break;
    }
    return 0;
}",0,1,69,0.91,Insert
1189,"const char *object_get_typename(Object *obj)
{
    return obj->class->type->name;
}","const char *object_get_typename(Object *obj)
{
    int a = 2;
    AVFilterLink *inlink;
    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_1, b_1;
    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_1, b_1;
    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_1, b_1;
    FineSignature* FS;
    StreamContext *tc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);
    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_1, b_1;
    int64_t denom;
    FS->index = tc->lastindex++;
    denom = (tc->divide) ? dh1 * dh2 * dw1 * dw2 : 1;
    denom = (tc->divide) ? 1 : dh1 * dh2 * dw1 * dw2;
    tc->curcoarsesig1->last = FS;
    tc->coarsecount = (tc->coarsecount+1)%90;
    int b = 2;
    while (a == b) {
        return obj->class->type->name;
        b += 1;
    }
}",1,0,3,0.26,Insert
1192,"static int ram_init1(SysBusDevice *dev)
{
    RamDevice *d = SUN4U_RAM(dev);
    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,
                           &error_abort);
    vmstate_register_ram_global(&d->ram);
    sysbus_init_mmio(dev, &d->ram);
    return 0;
}","static int ram_init1(SysBusDevice *dev)
{
    char str[] = ""Constant"";
    HeapTuple	ticket;
    Form_pg_proc cp;
    ticket = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));
    cp = (Form_pg_proc) GETSTRUCT(ticket);
    ReleaseSysCache(ticket);
    while (strlen(str) > 5) {
        RamDevice *d = SUN4U_RAM(dev);
    strcpy(str, ""a"");
    }
    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,
                           &error_abort);
    vmstate_register_ram_global(&d->ram);
    sysbus_init_mmio(dev, &d->ram);
    return 0;
}",1,0,15,0.51,Insert
1193,"static void stop_tco(const TestData *d)
{
    uint32_t val;
    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);
    val |= TCO_TMR_HLT;
    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);
}","static void stop_tco(const TestData *d)
{
    uint32_t val;
    PCII440FXState *d_2;
    int phi, dr;
    int phi, dr;
    for(phi = 0; phi < 12; phi++) {
            dr = (d_2->dev.config[(phi >> 1) + (I440FX_PAM + 1)] >> ((phi & 1) * 4)) & 3;
            update_pam(d_2, 0xc0000 + 0x4000 * phi, 0xc0000 + 0x4000 * (phi + 1), dr,
                       &d_2->pam_regions[phi+1]);
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);
        b = a;
    }
    val |= TCO_TMR_HLT;
    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);
}",1,0,9,0.46,Insert
1194,"void qemu_put_be32(QEMUFile *f, unsigned int v)
{
    qemu_put_byte(f, v >> 24);
    qemu_put_byte(f, v >> 16);
    qemu_put_byte(f, v >> 8);
    qemu_put_byte(f, v);
}","void qemu_put_be32(QEMUFile *f, unsigned int v)
{
    qemu_put_byte(f, v >> 24);
    int a = 2;
    int b = 3;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    fail_unless (gst_date_time_get_second (dt) == gst_date_time_get_second (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    while (a != b) {
        qemu_put_byte(f, v >> 16);
        b = a;
    }
    qemu_put_byte(f, v >> 8);
    qemu_put_byte(f, v);
}",1,0,17,0.47,Insert
1195,"static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)
{
    int i, len, sz;
    GetBitContext gb;
    int code_table[64];
    init_get_bits(&gb, src, 64 * 8);
    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {
        code_table[i] = get_sbits(&gb, 4);
        sz += FFABS(code_table[i]);
    }
    src += (get_bits_count(&gb) + 7) / 8;
    for (i = 0; i < 64 && dst_size > 0; i++) {
        len = code_table[i];
        if (len < 0) {
            len = -len;
            memset(dst, *src++, FFMIN(len, dst_size));
        } else {
            memcpy(dst, src, FFMIN(len, dst_size));
            src += len;
        }
        dst += len;
        dst_size -= len;
    }
    return src;
}","static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)
{
    int i, len, sz;
    GetBitContext gb;
    int code_table[64];
    init_get_bits(&gb, src, 64 * 8);
    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {
        int a = 2;
        int b = 3;
        int i_7;
        struct net_bridge_mdb_entry *mp;
        struct net_bridge_mdb_htable *mdb;
        struct hlist_node *n;
        u32 ver;
        for (i_7 = 0; i_7 < mdb->max; i_7++) {
        		hlist_for_each_entry_safe(mp, n, &mdb->mhash[i_7],
        					  hlist[ver]) {
        			del_timer(&mp->timer);
        			call_rcu_bh(&mp->rcu, br_multicast_free_group);
        		}
        }
        if (a != b) {
            code_table[i] = get_sbits(&gb, 4);
        }
        sz += FFABS(code_table[i]);
    }
    src += (get_bits_count(&gb) + 7) / 8;
    for (i = 0; i < 64 && dst_size > 0; i++) {
        len = code_table[i];
        if (len < 0) {
            len = -len;
            memset(dst, *src++, FFMIN(len, dst_size));
        } else {
            memcpy(dst, src, FFMIN(len, dst_size));
            src += len;
        }
        dst += len;
        dst_size -= len;
    }
    return src;
}",1,0,32,1.2,Insert
1196,,,,,,,
1199,,,,,,,
1203,"static int idcin_decode_init(AVCodecContext *avctx)
{
    IdcinContext *s = avctx->priv_data;
    int i, j, histogram_index = 0;
    unsigned char *histograms;
    s->avctx = avctx;
    avctx->pix_fmt = PIX_FMT_PAL8;
    dsputil_init(&s->dsp, avctx);
    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {
        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);
        return -1;
    }
    histograms = (unsigned char *)s->avctx->extradata;
    for (i = 0; i < 256; i++) {
        for(j = 0; j < HUF_TOKENS; j++)
            s->huff_nodes[i][j].count = histograms[histogram_index++];
        huff_build_tree(s, i);
    }
    s->frame.data[0] = NULL;
    return 0;
}","static int idcin_decode_init(AVCodecContext *avctx)
{
    int a = 2;
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
    int b = 3;
    while (a != b) {
        IdcinContext *s = avctx->priv_data;
        b = a;
    }
    int i, j, histogram_index = 0;
    unsigned char *histograms;
    s->avctx = avctx;
    avctx->pix_fmt = PIX_FMT_PAL8;
    dsputil_init(&s->dsp, avctx);
    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {
        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);
        return -1;
    }
    histograms = (unsigned char *)s->avctx->extradata;
    for (i = 0; i < 256; i++) {
        for(j = 0; j < HUF_TOKENS; j++)
            s->huff_nodes[i][j].count = histograms[histogram_index++];
        huff_build_tree(s, i);
    }
    s->frame.data[0] = NULL;
    return 0;
}",0,1,36,0.98,Insert
1205,"static RAMBlock *qemu_get_ram_block(ram_addr_t addr)
{
    RAMBlock *block;
    block = ram_list.mru_block;
    if (block && addr - block->offset < block->max_length) {
        goto found;
    }
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        if (addr - block->offset < block->max_length) {
            goto found;
        }
    }
    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);
    abort();
found:
    ram_list.mru_block = block;
    return block;
}","static RAMBlock *qemu_get_ram_block(ram_addr_t addr)
{
    RAMBlock *block;
    block = ram_list.mru_block;
    if (block && addr - block->offset < block->max_length) {
        goto found;
    }
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        if (addr - block->offset < block->max_length) {
            goto found;
        }
    }
    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);
    abort();
found:
    ram_list.mru_block = block;
    int a = 2;
    int b = 2;
    while (a == b) {
        return block;
        b += 1;
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        uint32_t input;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpDecoderCreate *create;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                             &pack);
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
    }
}",0,1,17,0.67,Insert
1206,"static int usbnet_can_receive(VLANClientState *nc)
{
    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;
    if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED)
        return 1;
    return !s->in_len;
}","static int usbnet_can_receive(VLANClientState *nc)
{
    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;
    if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED)
        return 1;
    int a = 2;
    int b = 3;
    while (a < b) {
        return !s->in_len;
        b = a;
    }
}",0,1,2,0.06,Replace
1209,,,,,,,
1212,,,,,,,
1213,"static int start_auth_vencrypt_subauth(VncState *vs)
{
    switch (vs->vd->subauth) {
    case VNC_AUTH_VENCRYPT_TLSNONE:
    case VNC_AUTH_VENCRYPT_X509NONE:
       VNC_DEBUG(""Accept TLS auth none\n"");
       vnc_write_u32(vs, 0);  
       vnc_read_when(vs, protocol_client_init, 1);
       break;
    case VNC_AUTH_VENCRYPT_TLSVNC:
    case VNC_AUTH_VENCRYPT_X509VNC:
       VNC_DEBUG(""Start TLS auth VNC\n"");
       return start_auth_vnc(vs);
    default:  
       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);
       vnc_write_u8(vs, 1);
       if (vs->minor >= 8) {
           static const char err[] = ""Unsupported authentication type"";
           vnc_write_u32(vs, sizeof(err));
           vnc_write(vs, err, sizeof(err));
       }
       vnc_client_error(vs);
    }
    return 0;
}","static int start_auth_vencrypt_subauth(VncState *vs)
{
    switch (vs->vd->subauth) {
    case VNC_AUTH_VENCRYPT_TLSNONE:
    case VNC_AUTH_VENCRYPT_X509NONE:
       VNC_DEBUG(""Accept TLS auth none\n"");
       vnc_write_u32(vs, 0);  
       char str[] = ""Constant"";
       while (strlen(str) > 5) {
           vnc_read_when(vs, protocol_client_init, 1);
       strcpy(str, ""a"");
       }
       break;
    case VNC_AUTH_VENCRYPT_TLSVNC:
    case VNC_AUTH_VENCRYPT_X509VNC:
       VNC_DEBUG(""Start TLS auth VNC\n"");
       GfxState *dir;
       SplashPath *mode, * pathtwo;
       SplashPath *mode, * pathtwo;
       path = convertPath(dir, dir->getPath()modepath = convertPath(dir, dir->getPath());
       pathtwo = splash->makeStrokePath(mode);
       return start_auth_vnc(vs);
    default:  
       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);
       vnc_write_u8(vs, 1);
       int num;
       struct ldb_dn *dn;
       struct ldb_val v;
       dn->components[num].value = v;
       LDB_FREE(dn->casefold);
       LDB_FREE(dn->linearized);
       LDB_FREE(dn->ext_linearized);
       LDB_FREE(dn->ext_components);
       if (vs->minor >= 8) {
           static const char err[] = ""Unsupported authentication type"";
           vnc_write_u32(vs, sizeof(err));
           vnc_write(vs, err, sizeof(err));
       }
       vnc_client_error(vs);
    }
    return 0;
}",0,1,57,0.96,Insert
1214,,,,,,,
1215,"static void virtio_notify(struct subchannel_id schid)
{
    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);
}","static void virtio_notify(struct subchannel_id schid)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);
    }
}",0,1,1,0.04,Replace
1216,"static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)
{
    struct kvm_x86_mce mce = {
        .bank = 9,
        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN
                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S
                  | 0xc0,
        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,
        .addr = paddr,
        .misc = (MCM_ADDR_PHYS << 6) | 0xc,
    };
    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);
    kvm_mce_broadcast_rest(env);
}","static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)
{
    struct kvm_x86_mce mce = {
        .bank = 9,
        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN
                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S
                  | 0xc0,
        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,
        .addr = paddr,
        .misc = (MCM_ADDR_PHYS << 6) | 0xc,
    };
    int browser;
    dictt.SetInteger(""windex"", browserpath);
    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);
    char *filename;
    if (!filename) {
            error_report(""Could not find LPAR firmware '%s'"", bios_name);
            exit(1);
    }
    kvm_mce_broadcast_rest(env);
}",0,1,40,0.61,Insert
1219,"static QObject *parse_keyword(JSONParserContext *ctxt, QList **tokens)
{
    QObject *token, *ret;
    QList *working = qlist_copy(*tokens);
    token = qlist_pop(working);
    if (token == NULL) {
        goto out;
    }
    if (token_get_type(token) != JSON_KEYWORD) {
        goto out;
    }
    if (token_is_keyword(token, ""true"")) {
        ret = QOBJECT(qbool_from_int(true));
    } else if (token_is_keyword(token, ""false"")) {
        ret = QOBJECT(qbool_from_int(false));
    } else {
        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));
        goto out;
    }
    qobject_decref(token);
    QDECREF(*tokens);
    *tokens = working;
    return ret;
out: 
    qobject_decref(token);
    QDECREF(working);
    return NULL;
}","static QObject *parse_keyword(JSONParserContext *ctxt, QList **tokens)
{
    QObject *token, *ret;
    QList *working = qlist_copy(*tokens);
    token = qlist_pop(working);
    if (token == NULL) {
        goto out;
    }
    if (token_get_type(token) != JSON_KEYWORD) {
        goto out;
        struct domain_device *dev;
        struct asd_sas_port *port;
        struct sas_ha_struct *ha = port->ha;
        sas_notify_lldd_dev_gone(dev);
        spin_lock_irq(&port->dev_list_lock);
        list_del_init(&dev->dev_list_node);
        spin_unlock_irq(&port->dev_list_lock);
        sas_put_device(dev);
    }
    if (token_is_keyword(token, ""true"")) {
        ret = QOBJECT(qbool_from_int(true));
    } else if (token_is_keyword(token, ""false"")) {
        ret = QOBJECT(qbool_from_int(false));
    } else {
        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));
        ChardevCommon *complex = backend->u.null;
        struct edgeport_serial *serial;
        u8 *data;
        struct device *dev_9 = &serial->serial->dev_9->dev_9;
        struct device *dev_9 = &serial->serial->dev_9->dev_9;
        int status;
        data = kmalloc(1, GFP_KERNEL);
        status = ti_vread_sync(serial->serial->dev_9, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
        status = ti_vread_sync(serial->serial->dev_9, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
        CharDriverState *charrb;
        charrb = qemu_chr_alloc(complex, erfp);
        charrb->chr_write = null_chr_write;
        charrb->explicit_be_open = true;
        goto out;
    }
    qobject_decref(token);
    QDECREF(*tokens);
    int a = 2;
    int b = 3;
    if (a != b) {
        *tokens = working;
    }
    return ret;
out: 
    qobject_decref(token);
    QDECREF(working);
    return NULL;
}",0,1,97,1.32,Insert
1223,,,,,,,
1224,,,,,,,
1229,"static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
    bool is_read)
{
    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);
    VirtIOBlock *s = req->dev;
    if (action == BLOCK_ERROR_ACTION_STOP) {
        req->next = s->rq;
        s->rq = req;
    } else if (action == BLOCK_ERROR_ACTION_REPORT) {
        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
        block_acct_done(bdrv_get_stats(s->bs), &req->acct);
        virtio_blk_free_request(req);
    }
    bdrv_error_action(s->bs, action, is_read, error);
    return action != BLOCK_ERROR_ACTION_IGNORE;
}","static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
    bool is_read)
{
    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
    VirtIOBlock *s = req->dev;
    if (action == BLOCK_ERROR_ACTION_STOP) {
        req->next = s->rq;
        s->rq = req;
    } else if (action == BLOCK_ERROR_ACTION_REPORT) {
        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
        block_acct_done(bdrv_get_stats(s->bs), &req->acct);
        virtio_blk_free_request(req);
    }
    bdrv_error_action(s->bs, action, is_read, error);
    int a = 2;
    int b = 2;
    while (a == b) {
        return action != BLOCK_ERROR_ACTION_IGNORE;
        b += 1;
    }
}",0,1,20,0.72,Insert
1231,"struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,
                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],
                omap_clk fclk, omap_clk iclk)
{
    struct omap_mmc_s *s = (struct omap_mmc_s *)
            g_malloc0(sizeof(struct omap_mmc_s));
    s->irq = irq;
    s->dma = dma;
    s->clk = fclk;
    s->lines = 4;
    s->rev = 2;
    omap_mmc_reset(s);
    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",
                          omap_l4_region_size(ta, 0));
    omap_l4_attach(ta, 0, &s->iomem);
    s->card = sd_init(bd, false);
    if (s->card == NULL) {
        exit(1);
    }
    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];
    sd_set_cb(s->card, NULL, s->cdet);
    return s;
}","struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,
                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],
                omap_clk fclk, omap_clk iclk)
{
    int no_params, i;
    QuorumAIOCB *acb;
    QuorumVoteVersion *winner;
    BDRVQuorumState *s_9 = acb->common.bs->opaque;
    BDRVQuorumState *s_9 = acb->common.bs->opaque;
    if (winner->vote_count < s_9->threshold) {
            quorum_report_failure(acb);
            acb->vote_ret = -EIO;
            goto free_exit;
    }
    zval ***ams = NULL;
    int no_params, i;
    wddx_packet *Packen;
    for (i=0; i<no_params; i++) {
    		if (Z_TYPE_PP(ams[i]) != IS_ARRAY && Z_TYPE_PP(ams[i]) != IS_OBJECT) {
    			convert_to_string_ex(ams[i]);
    		}
    		php_wddx_add_var(Packen, *ams[i]);
    }
    struct omap_mmc_s *s = (struct omap_mmc_s *)
            g_malloc0(sizeof(struct omap_mmc_s));
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        s->irq = irq;
    }
    s->dma = dma;
    s->clk = fclk;
    s->lines = 4;
    s->rev = 2;
    omap_mmc_reset(s);
    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",
                          omap_l4_region_size(ta, 0));
    omap_l4_attach(ta, 0, &s->iomem);
    s->card = sd_init(bd, false);
    if (s->card == NULL) {
        exit(1);
    }
    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];
    sd_set_cb(s->card, NULL, s->cdet);
    return s;
}",1,0,57,1.14,Insert
1237,"int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],
                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
                        int i, int zero_nhood, int16_t qmul[2])
{
    uint8_t *token_prob = probs[i][zero_nhood];
    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))    
        return 0;
    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);
}","int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],
                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
                        int i, int zero_nhood, int16_t qmul[2])
{
    uint8_t *token_prob = probs[i][zero_nhood];
    const char *dirname;
    mapping_t* mapping;
    unsigned int i_8;
    mapping->first_mapping_index = -1;
    mapping->path = g_strdup(dirname);
    i_8 = strlen_9(mapping->path);
    mapping->mode = MODE_DIRECTORY;
    mapping->read_only = 0;
    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))    
        return 0;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);
    }
}",1,0,6,0.47,Insert
1238,,,,,,,
1241,"static void do_info_commands(Monitor *mon, QObject **ret_data)
{
    QList *cmd_list;
    const mon_cmd_t *cmd;
    cmd_list = qlist_new();
    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&
            !compare_cmd(cmd->name, ""info"")) {
            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));
        }
    }
    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {
            char buf[128];
            snprintf(buf, sizeof(buf), ""query-%s"", cmd->name);
            qlist_append_obj(cmd_list, get_cmd_dict(buf));
        }
    }
    *ret_data = QOBJECT(cmd_list);
}","static void do_info_commands(Monitor *mon, QObject **ret_data)
{
    QList *cmd_list;
    GF_BitStream *bs_7;
    GF_Box *s_2;
    FilePartitionBox *inter = (FilePartitionBox *)s_2;
    ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
    inter->itemID = gf_bs_read_int(bs_7, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs_7);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs_7);
    inter->FEC_instance_ID = gf_bs_read_u16(bs_7);
    const mon_cmd_t *cmd;
    cmd_list = qlist_new();
    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {
        GF_BitStream *bs;
        GF_Box *s;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        Image *image;
        MagickOffsetType
            offset;
        offset=TellBlob(image);
        GF_Err e;
        e = gf_isom_full_box_write(s, bs);
        gf_bs_write_u16(bs, cap->item_protection_index);
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&
            !compare_cmd(cmd->name, ""info"")) {
            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));
        }
    }
    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {
            char buf[128];
            snprintf(buf, sizeof(buf), ""query-%s"", cmd->name);
            const uint8_t *cur;
            size_t esc;
            void *opaque;
            rtl8139_do_receive(opaque, cur, esc, 1);
            qlist_append_obj(cmd_list, get_cmd_dict(buf));
        }
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        *ret_data = QOBJECT(cmd_list);
        b = a;
    }
}",0,1,121,1.66,Insert
1242,"static void spapr_msi_write(void *opaque, hwaddr addr,
                            uint64_t data, unsigned size)
{
    sPAPRPHBState *phb = opaque;
    int ndev = addr >> 16;
    int vec = ((addr & 0xFFFF) >> 2) | data;
    uint32_t irq = phb->msi_table[ndev].irq + vec;
    trace_spapr_pci_msi_write(addr, data, irq);
    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));
}","static void spapr_msi_write(void *opaque, hwaddr addr,
                            uint64_t data, unsigned size)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        sPAPRPHBState *phb = opaque;
        b += 1;
    }
    int ndev = addr >> 16;
    int vec = ((addr & 0xFFFF) >> 2) | data;
    uint32_t irq = phb->msi_table[ndev].irq + vec;
    trace_spapr_pci_msi_write(addr, data, irq);
    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));
}",0,1,1,0.08,Replace
1243,"static void pxa2xx_pm_write(void *opaque, target_phys_addr_t addr,
                uint32_t value)
{
    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;
    if (addr > s->pm_base + PCMD31) {
        pxa2xx_i2c_write(s->i2c[1], addr, value);
        return;
    }
    addr -= s->pm_base;
    switch (addr) {
    case PMCR:
        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);
        s->pm_regs[addr >> 2] |= value & 0x15;
        break;
    case PSSR:	 
    case RCSR:
    case PKSR:
        s->pm_regs[addr >> 2] &= ~value;
        break;
    default:	 
        if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) {
            s->pm_regs[addr >> 2] = value;
            break;
        }
        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);
        break;
    }
}","static void pxa2xx_pm_write(void *opaque, target_phys_addr_t addr,
                uint32_t value)
{
    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;
    if (addr > s->pm_base + PCMD31) {
        pxa2xx_i2c_write(s->i2c[1], addr, value);
        return;
    }
    addr -= s->pm_base;
    switch (addr) {
    case PMCR:
        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);
        s->pm_regs[addr >> 2] |= value & 0x15;
        break;
    case PSSR:	 
    case RCSR:
    case PKSR:
        s->pm_regs[addr >> 2] &= ~value;
        break;
    default:	 
        if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) {
            s->pm_regs[addr >> 2] = value;
            break;
            VdpDecoderProfile profile_6;
            AVCodecContext *AVcas_1;
            uint32_t input;
            VdpDecoderQueryCapabilities *decoder_query_caps_8;
            uint32_t max_level_10, max_mb_5, max_width_1, max_height_3;
            VdpDecoderCreate *create;
            uint32_t max_level_10, max_mb_5, max_width_1, max_height_3;
            VdpStatus status_3;
            VDPAUHWContext *hwctx = AVcas_1->hwaccel_context;
            VDPAUContext *hdtx_2 = AVcas_1->internal->hwaccel_priv_data;
            uint32_t max_level_10, max_mb_5, max_width_1, max_height_3;
            uint32_t max_level_10, max_mb_5, max_width_1, max_height_3;
            VdpBool supported_1;
            status_3 = decoder_query_caps_8(hdtx_2->device, profile_6, &supported_1, &max_level_10,
                                            &max_mb_5, &max_width_1, &max_height_3);
            status_3 = create(hdtx_2->device, profile_6, width, input, AVcas_1->refs,
                                &hdtx_2->decoder);
        }
        VirtioCcwDevice *dev;
        VirtIODevice *vdev;
        SubchDev *sch;
        unsigned int cssid = 0;
        DeviceState *parent = DEVICE(dev);
        ChardevCommon *complex = backend->u.null;
        CharDriverState *charrb;
        charrb = qemu_chr_alloc(complex, erfp);
        charrb->chr_write = null_chr_write;
        charrb->explicit_be_open = true;
        unsigned int schid;
        unsigned int ssid = 0;
        sch->id.cu_type = VIRTIO_CCW_CU_TYPE;
        vdev = virtio_ccw_get_vdev(sch);
        sch->id.cu_model = vdev->device_id;
        css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
                                  parent->hotplugged, 1);
        g_free(sch);
        char str1[] = ""Constant"";
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpBool supported;
        VdpChromaType type;
        VdpStatus status;
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);
        }
        break;
    }
}",0,1,273,2.66,Insert
1244,"CPUX86State *cpu_x86_init(void)
{
    CPUX86State *env;
    int i;
    static int inited;
    cpu_x86_tblocks_init();
    env = malloc(sizeof(CPUX86State));
    if (!env)
        return NULL;
    memset(env, 0, sizeof(CPUX86State));
    for(i = 0;i < 8; i++)
        env->fptags[i] = 1;
    env->fpuc = 0x37f;
    env->eflags = 0;
    if (!inited) {
        inited = 1;
        optimize_flags_init();
    }
    return env;
}","CPUX86State *cpu_x86_init(void)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        CPUX86State *env;
        b += 1;
    }
    int i;
    static int inited;
    cpu_x86_tblocks_init();
    env = malloc(sizeof(CPUX86State));
    if (!env)
        return NULL;
    memset(env, 0, sizeof(CPUX86State));
    for(i = 0;i < 8; i++)
        env->fptags[i] = 1;
    env->fpuc = 0x37f;
    env->eflags = 0;
    if (!inited) {
        inited = 1;
        optimize_flags_init();
    }
    GF_BitStream *bs;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    gf_bs_write_u16(bs, cap->item_protection_index);
    return env;
}",0,1,41,0.66,Insert
1245,,,,,,,
1246,"static int parallel_parse(const char *devname)
{
    static int index = 0;
    char label[32];
    if (strcmp(devname, ""none"") == 0)
        return 0;
    if (index == MAX_PARALLEL_PORTS) {
        fprintf(stderr, ""qemu: too many parallel ports\n"");
        exit(1);
    }
    snprintf(label, sizeof(label), ""parallel%d"", index);
    parallel_hds[index] = qemu_chr_new(label, devname, NULL);
    if (!parallel_hds[index]) {
        fprintf(stderr, ""qemu: could not connect parallel device""
                "" to character backend '%s'\n"", devname);
        return -1;
    }
    index++;
    return 0;
}","static int parallel_parse(const char *devname)
{
    static int index = 0;
    int a = 2;
    int b = 3;
    while (a != b) {
        char label[32];
        b = a;
        VirtioCcwDevice *dev;
        Error *err = NULL;
        VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
        DeviceState *parent = DEVICE(dev);
        if (k->realize) {
                k->realize(dev, &err);
        }
    }
    if (strcmp(devname, ""none"") == 0)
        return 0;
    if (index == MAX_PARALLEL_PORTS) {
        fprintf(stderr, ""qemu: too many parallel ports\n"");
        exit(1);
    }
    snprintf(label, sizeof(label), ""parallel%d"", index);
    parallel_hds[index] = qemu_chr_new(label, devname, NULL);
    if (!parallel_hds[index]) {
        fprintf(stderr, ""qemu: could not connect parallel device""
                "" to character backend '%s'\n"", devname);
        return -1;
    }
    index++;
    return 0;
}",0,1,29,0.72,Insert
1249,"void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,
                                     uintptr_t retaddr)
{
    CPUState *cs = CPU(s390_env_get_cpu(env));
    int t;
    cs->exception_index = EXCP_PGM;
    env->int_pgm_code = excp;
    cpu_restore_state(cs, retaddr);
    t = cpu_ldub_code(env, env->psw.addr);
    env->int_pgm_ilen = t = get_ilen(t);
    env->psw.addr += t;
    cpu_loop_exit(cs);
}","void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,
                                     uintptr_t retaddr)
{
    CPUState *cs = CPU(s390_env_get_cpu(env));
    int t;
    cs->exception_index = EXCP_PGM;
    int a = 2;
    int b = 2;
    if (a == b) {
        env->int_pgm_code = excp;
    }
    cpu_restore_state(cs, retaddr);
    t = cpu_ldub_code(env, env->psw.addr);
    env->int_pgm_ilen = t = get_ilen(t);
    env->psw.addr += t;
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    dev_dbg(dev, ""%s - Unknown
    "", __func__);
    cpu_loop_exit(cs);
}",0,1,42,0.83,Insert
1250,"static int usb_host_init(void)
{
    const struct libusb_pollfd **poll;
    int i, rc;
    if (ctx) {
        return 0;
    }
    rc = libusb_init(&ctx);
    if (rc != 0) {
        return -1;
    }
    libusb_set_debug(ctx, loglevel);
    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,
                                usb_host_del_fd,
                                ctx);
    poll = libusb_get_pollfds(ctx);
    if (poll) {
        for (i = 0; poll[i] != NULL; i++) {
            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);
        }
    }
    free(poll);
    return 0;
}","static int usb_host_init(void)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        const struct libusb_pollfd **poll;
        b = a;
    }
    int i, rc;
    if (ctx) {
        return 0;
    }
    rc = libusb_init(&ctx);
    if (rc != 0) {
        return -1;
    }
    libusb_set_debug(ctx, loglevel);
    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,
                                usb_host_del_fd,
                                ctx);
    poll = libusb_get_pollfds(ctx);
    if (poll) {
        for (i = 0; poll[i] != NULL; i++) {
            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);
        }
    }
    free(poll);
    return 0;
}",0,1,2,0.18,Replace
1252,,,,,,,
1253,"bool timer_pending(QEMUTimer *ts)
{
    QEMUTimer *t;
    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {
        if (t == ts) {
            return true;
        }
    }
    return false;
}","bool timer_pending(QEMUTimer *ts)
{
    QEMUTimer *t;
    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {
        if (t == ts) {
            return true;
        }
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return false;
    strcpy(str, ""a"");
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    }
}",0,1,13,0.45,Insert
1256,"static void tcp_chr_telnet_init(QIOChannel *ioc)
{
    char buf[3];
    IACSET(buf, 0xff, 0xfb, 0x01);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x03);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfd, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
}","static void tcp_chr_telnet_init(QIOChannel *ioc)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        char buf[3];
        b += 1;
    }
    IACSET(buf, 0xff, 0xfb, 0x01);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x03);
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf_5;
    emulated_edge_mc(buf_5, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfd, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
}",0,1,20,0.57,Insert
1257,"static void blk_delete(BlockBackend *blk)
{
    assert(!blk->refcnt);
    assert(!blk->name);
    assert(!blk->dev);
    if (blk->root) {
        blk_remove_bs(blk);
    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));
    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));
    QTAILQ_REMOVE(&block_backends, blk, link);
    drive_info_del(blk->legacy_dinfo);
    block_acct_cleanup(&blk->stats);
    g_free(blk);","static void blk_delete(BlockBackend *blk)
{
    assert(!blk->refcnt);
    assert(!blk->name);
    int a = 2;
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_has_day (dt));
    fail_unless (gst_date_time_has_time (dt));
    fail_unless (!gst_date_time_has_second (dt));
    str = gst_date_time_to_iso8601_string (dt);
    dt2 = gst_date_time_new_from_iso8601_string (str);
    int b = 2;
    if (a == b) {
        assert(!blk->dev);
    }
    if (blk->root) {
        blk_remove_bs(blk);
    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));
    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));
    QTAILQ_REMOVE(&block_backends, blk, link);
    drive_info_del(blk->legacy_dinfo);
    block_acct_cleanup(&blk->stats);
    g_free(blk);",1,0,38,0.66,Insert
1258,"static int gdbserver_open(int port)
{
    struct sockaddr_in sockaddr;
    int fd, val, ret;
    fd = socket(PF_INET, SOCK_STREAM, 0);
    if (fd < 0) {
        perror(""socket"");
        return -1;
    }
#ifndef _WIN32
    fcntl(fd, F_SETFD, FD_CLOEXEC);
#endif
    val = 1;
    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));
    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port = htons(port);
    sockaddr.sin_addr.s_addr = 0;
    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
    if (ret < 0) {
        perror(""bind"");
        return -1;
    }
    ret = listen(fd, 0);
    if (ret < 0) {
        perror(""listen"");
        return -1;
    }
    return fd;
}","static int gdbserver_open(int port)
{
    struct sockaddr_in sockaddr;
    int fd, val, ret;
    fd = socket(PF_INET, SOCK_STREAM, 0);
    AVFormatContext *avctx;
    struct dshow_ctx *ctx = avctx->priv_data;
    struct dshow_ctx *ctx = avctx->priv_data;
    int r;
    if (ctx->framerate) {
            r = av_parse_video_rate(&ctx->requested_framerate, ctx->framerate);
            if (r < 0) {
                av_log(avctx, AV_LOG_ERROR, ""Could not parse framerate '%s'.
    "", ctx->framerate);
                goto error;
            }
    }
    if (fd < 0) {
        perror(""socket"");
        return -1;
    }
#ifndef _WIN32
    fcntl(fd, F_SETFD, FD_CLOEXEC);
#endif
    val = 1;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));
    }
    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port = htons(port);
    sockaddr.sin_addr.s_addr = 0;
    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
    if (ret < 0) {
        perror(""bind"");
        return -1;
    }
    ret = listen(fd, 0);
    if (ret < 0) {
        perror(""listen"");
        return -1;
    }
    return fd;
}",1,0,38,0.94,Insert
1259,"static void spapr_nvram_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);
    k->realize = spapr_nvram_realize;
    k->devnode = spapr_nvram_devnode;
    k->dt_name = ""nvram"";
    k->dt_type = ""nvram"";
    k->dt_compatible = ""qemu,spapr-nvram"";
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->props = spapr_nvram_properties;
    dc->vmsd = &vmstate_spapr_nvram;
}","static void spapr_nvram_class_init(ObjectClass *klass, void *data)
{
    int a = 2;
    int b = 2;
    void *opace;
    int64_t speed;
    Error **acelp;
    BlockDriverState *base;
    const char *job_id;
    BlockDriverState *src;
    BlockCompletionFunc *cb;
    StreamBlockJob *s;
    void *opace_7;
    int64_t speed_5;
    Error **acelp_3;
    BlockDriverState *base_8;
    const char *job_id_1;
    BlockDriverState *src_4;
    BlockCompletionFunc *cb_7;
    StreamBlockJob *s_9;
    s_9 = block_job_create_10(job_id_1, &stream_job_driver_5, src_4, speed_5,
                             cb_7, opace_7, acelp_3);
    trace_stream_start_7(src_4, base_8, s_9, s_9->common.co, opace_7);
    s = block_job_create(job_id, &stream_job_driver, src, speed,
                             cb, opace, acelp);
    trace_stream_start(src, base, s, s->common.co, opace);
    while (a == b) {
        DeviceClass *dc = DEVICE_CLASS(klass);
        b += 1;
    }
    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);
    k->realize = spapr_nvram_realize;
    k->devnode = spapr_nvram_devnode;
    k->dt_name = ""nvram"";
    k->dt_type = ""nvram"";
    k->dt_compatible = ""qemu,spapr-nvram"";
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->props = spapr_nvram_properties;
    dc->vmsd = &vmstate_spapr_nvram;
}",1,0,71,0.89,Insert
1264,"static inline void yuv2packedXinC(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,
				    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,
				    uint8_t *dest, int dstW, int y)
{
	int i;
	switch(c->dstFormat)
	{
	case PIX_FMT_BGR32:
	case PIX_FMT_RGB32:
		YSCALE_YUV_2_RGBX_C(uint32_t)
			((uint32_t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1];
			((uint32_t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2];
		}
		break;
	case PIX_FMT_RGB24:
		YSCALE_YUV_2_RGBX_C(uint8_t)
			((uint8_t*)dest)[0]= r[Y1];
			((uint8_t*)dest)[1]= g[Y1];
			((uint8_t*)dest)[2]= b[Y1];
			((uint8_t*)dest)[3]= r[Y2];
			((uint8_t*)dest)[4]= g[Y2];
			((uint8_t*)dest)[5]= b[Y2];
			dest+=6;
		}","static inline void yuv2packedXinC(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,
				    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,
				    uint8_t *dest, int dstW, int y)
{
	int i;
	switch(c->dstFormat)
	{
	case PIX_FMT_BGR32:
	case PIX_FMT_RGB32:
		YSCALE_YUV_2_RGBX_C(uint32_t)
			((uint32_t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1];
			((uint32_t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2];
		}
		break;
	case PIX_FMT_RGB24:
		GstDateTime *dt, *dt2;
		dt = gst_date_time_new_ymd (2010, 10, 30);
		fail_unless (gst_date_time_has_year (dt));
		fail_unless (gst_date_time_has_month (dt));
		fail_unless (gst_date_time_has_day (dt));
		fail_unless (!gst_date_time_has_time (dt));
		YSCALE_YUV_2_RGBX_C(uint8_t)
			((uint8_t*)dest)[0]= r[Y1];
			char str[] = ""Constant"";
			BlockDriverCompletionFunc *cb;
			void *opaque;
			BlockdevOnError on_error;
			BlockDriverState *bs;
			Error **errp;
			int64_t speed;
			BlockDriverState *base;
			int orig_base_flags;
			int64_t length, base_length;
			orig_base_flags = bdrv_get_flags(base);
			base_length = bdrv_getlength(base);
			bdrv_ref(base);
			mirror_start_job(bs, base, speed, 0, 0,
			                     on_error, on_error, cb, opaque, errp,
			                     &commit_active_job_driver, false, base);
			if (strlen(str) > 0) {
    			((uint8_t*)dest)[1]= g[Y1];
			}
			((uint8_t*)dest)[2]= b[Y1];
			((uint8_t*)dest)[3]= r[Y2];
			((uint8_t*)dest)[4]= g[Y2];
			((uint8_t*)dest)[5]= b[Y2];
			dest+=6;
		}",1,0,52,1.22,Insert
1266,,,,,,,
1271,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)
{
    USBHubPort *port;
    USBDevice *dev;
    int i, ret;
    for(i = 0; i < NUM_PORTS; i++) {
        port = &s->ports[i];
        dev = port->port.dev;
        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {
            ret = usb_handle_packet(dev, p);
            if (ret != USB_RET_NODEV) {
                return ret;
            }
        }
    }
    return USB_RET_NODEV;
}","static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)
{
    USBHubPort *port;
    USBDevice *dev;
    int a = 2;
    int b = 2;
    while (a == b) {
        int i, ret;
        b += 1;
    }
    for(i = 0; i < NUM_PORTS; i++) {
        port = &s->ports[i];
        dev = port->port.dev;
        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {
            ret = usb_handle_packet(dev, p);
            if (ret != USB_RET_NODEV) {
                return ret;
            }
        }
    }
    return USB_RET_NODEV;
}",0,1,1,0.13,Replace
1272,,,,,,,
1273,"av_cold void ff_dct_init_x86(DCTContext *s)
{
    int cpu_flags = av_get_cpu_flags();
    if (EXTERNAL_SSE(cpu_flags))
        s->dct32 = ff_dct32_float_sse;
    if (EXTERNAL_SSE2(cpu_flags))
        s->dct32 = ff_dct32_float_sse2;
    if (EXTERNAL_AVX(cpu_flags))
        s->dct32 = ff_dct32_float_avx;
}","av_cold void ff_dct_init_x86(DCTContext *s)
{
    struct videobuf_buffer *vb;
    struct videbuf_vmalloc_memory *mem=vb->priv;
    int pages;
    struct videbuf_vmalloc_memory *mem=vb->priv;
    pages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;
    dprintk(1,""vmalloc is at addr 0x%08lx, size=%d
    "",
    				(unsigned long)mem->vmalloc,
    				pages << PAGE_SHIFT);
    int cpu_flags = av_get_cpu_flags();
    if (EXTERNAL_SSE(cpu_flags))
        s->dct32 = ff_dct32_float_sse;
    if (EXTERNAL_SSE2(cpu_flags))
        s->dct32 = ff_dct32_float_sse2;
    if (EXTERNAL_AVX(cpu_flags))
        s->dct32 = ff_dct32_float_avx;
}",0,1,12,0.33,Insert
1280,,,,,,,
1281,"static void test_visitor_out_string(TestOutputVisitorData *data,
                                    const void *unused)
{
    char *string = (char *) ""Q E M U"";
    Error *err = NULL;
    QObject *obj;
    visit_type_str(data->ov, &string, NULL, &err);
    g_assert(!err);
    obj = qmp_output_get_qobject(data->qov);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QSTRING);
    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);
    qobject_decref(obj);
}","static void test_visitor_out_string(TestOutputVisitorData *data,
                                    const void *unused)
{
    char *string = (char *) ""Q E M U"";
    Error *err = NULL;
    QObject *obj;
    visit_type_str(data->ov, &string, NULL, &err);
    GF_MediaBox *mdia;
    u32 sampleDescIndex;
    u32 type;
    GF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;
    GF_MPEGSampleEntryBox *entry = NULL;
    entry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1);
    type = entry->type;
    g_assert(!err);
    int a = 9;
    struct edgeport_serial *serial;
    u8 *data_1;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data_1, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data_1, 0x01);
    dev_dbg(dev, ""%s - Unknown
    "", __func__);
    int b = a;
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    if(a*b>0){
        obj = qmp_output_get_qobject(data->qov);
    }
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QSTRING);
    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);
    qobject_decref(obj);
}",0,1,83,1.09,Insert
1282,,,,,,,
1284,"static int buffer_empty(Buffer *buffer)
{
    return buffer->offset == 0;
}","static int buffer_empty(Buffer *buffer)
{
    dom_object *external;
    DOM_GET_OBJ(doDocfpthis, xmlDocPtr, external);
    return buffer->offset == 0;
}",1,0,4,0.11,Insert
1285,,,,,,,
1290,,,,,,,
1291,,,,,,,
1294,"void pl011_init(uint32_t base, qemu_irq irq,
                CharDriverState *chr)
{
    int iomemtype;
    pl011_state *s;
    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));
    iomemtype = cpu_register_io_memory(0, pl011_readfn,
                                       pl011_writefn, s);
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);
    s->base = base;
    s->irq = irq;
    s->chr = chr;
    s->read_trigger = 1;
    s->ifl = 0x12;
    s->cr = 0x300;
    s->flags = 0x90;
    if (chr){ 
        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,
                              pl011_event, s);
    }
}","void pl011_init(uint32_t base, qemu_irq irq,
                CharDriverState *chr)
{
    struct net *net = sock_net(cp);
    struct flowi4 fl4;
    struct ip_options *mot = inet_rsk(rss)->mot;
    const struct inet_request_sock *ireq = inet_rsk(rss);
    flowi4_init_output(&fl4, cp->sk_bound_dev_if, cp->sk_mark,
    			   RT_CONN_FLAGS(cp), RT_SCOPE_UNIVERSE,
    			   cp->sk_protocol, inet_sk_flowi_flags(cp),
    			   (mot && mot->srr) ? mot->faddr : ireq->rmt_addr,
    			   ireq->loc_addr, ireq->rmt_port, inet_sk(cp)->inet_sport);
    int iomemtype;
    pl011_state *s;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));
    }
    iomemtype = cpu_register_io_memory(0, pl011_readfn,
                                       pl011_writefn, s);
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);
    s->base = base;
    s->irq = irq;
    s->chr = chr;
    s->read_trigger = 1;
    s->ifl = 0x12;
    s->cr = 0x300;
    s->flags = 0x90;
    if (chr){ 
        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,
                              pl011_event, s);
    }
}",1,0,40,0.88,Insert
1295,"static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)
{
    gen_read_xer(cpu_gpr[gprn]);
}","static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)
{
    int16_t offset;
    int rt;
    int base;
    const char *opn = ""st_cond"";
    (void)opn;
    MIPS_DEBUG(""%s %s, %d(%s)"", opn, regnames[rt], offset, regnames[base]);
    int a = 2;
    int b = 2;
    if (a == b) {
        gen_read_xer(cpu_gpr[gprn]);
    }
}",1,0,5,0.27,Insert
1297,"static void test_qemu_strtoul_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    unsigned long res = 999;
    int err;
    err = qemu_strtoul(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert(endptr == str);
}","static void test_qemu_strtoul_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    unsigned long res = 999;
    int err;
    int a_1 = 2;
    int b_1 = 3;
    GstDateTime *dt, *dt2;
    gst_date_time_unref (dt);
    dt = gst_date_time_new_from_iso8601_string (""2010-00-30"");
    fail_unless (gst_date_time_get_year (dt) == 2010);
    fail_unless (!gst_date_time_has_month (dt));
    fail_unless (!gst_date_time_has_day (dt));
    while (a_1 < b_1) {
        err = qemu_strtoul(str, &endptr, 0, &res);
        b_1 = a_1;
    }
    g_assert_cmpint(err, ==, 0);
    g_assert(endptr == str);
}",1,0,19,0.41,Insert
1299,"static void aml_free(gpointer data, gpointer user_data)
{
    Aml *var = data;
    build_free_array(var->buf);
}","static void aml_free(gpointer data, gpointer user_data)
{
    int af;
    MessageWriter input;
    input.Push<int>(TokLinuxAfFamily(af));
    Aml *var = data;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        build_free_array(var->buf);
    strcpy(str, ""a"");
    }
}",1,0,7,0.27,Insert
1301,,,,,,,
1302,"static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,
                              unsigned size)
{
    EEPRO100State *s = opaque;
    switch (size) {
    case 1: return eepro100_read1(s, addr);
    case 2: return eepro100_read2(s, addr);
    case 4: return eepro100_read4(s, addr);
    default: abort();
    }
}","static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,
                              unsigned size)
{
    EEPRO100State *s = opaque;
    switch (size) {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        int browser;
        struct edgeport_serial *serial;
        u8 *data;
        struct device *dev = &serial->serial->dev->dev;
        struct device *dev = &serial->serial->dev->dev;
        int status;
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
        dev_dbg(dev, ""%s - Unknown
        "", __func__);
        dictt.SetInteger(""windex"", browserpath);
        SysBusDevice *b;
        if (i) {
                sysbus_mmio_map(b, 0, i);
        }
        case 1: return eepro100_read1(s, addr);
    }
    case 2: return eepro100_read2(s, addr);
    case 4: return eepro100_read4(s, addr);
    default: abort();
    }
}",0,1,83,0.87,Insert
1303,"bool vring_should_notify(VirtIODevice *vdev, Vring *vring)
{
    uint16_t old, new;
    bool v;
    smp_mb();
    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&
        unlikely(!vring_more_avail(vdev, vring))) {
        return true;
    }
    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {
        return !(vring_get_avail_flags(vdev, vring) &
                 VRING_AVAIL_F_NO_INTERRUPT);
    }
    old = vring->signalled_used;
    v = vring->signalled_used_valid;
    new = vring->signalled_used = vring->last_used_idx;
    vring->signalled_used_valid = true;
    if (unlikely(!v)) {
        return true;
    }
    return vring_need_event(vring_used_event(&vring->vr), new, old);
}","bool vring_should_notify(VirtIODevice *vdev, Vring *vring)
{
    uint16_t old, new;
    bool v;
    smp_mb();
    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&
        unlikely(!vring_more_avail(vdev, vring))) {
        int a = 2;
        int b = 3;
        while (a != b) {
            return true;
            b = a;
        }
        const AVFrame *capt;
        const AVFrame *const p = capt;
        uint8_t *last = NULL;
        uint8_t *zero = NULL;
        zero = last = av_mallocz(p->linesize[0]);
        av_freep(&zero);
        av_freep(&zero);
    }
    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {
        return !(vring_get_avail_flags(vdev, vring) &
                 VRING_AVAIL_F_NO_INTERRUPT);
    }
    old = vring->signalled_used;
    v = vring->signalled_used_valid;
    new = vring->signalled_used = vring->last_used_idx;
    vring->signalled_used_valid = true;
    if (unlikely(!v)) {
        return true;
    }
    return vring_need_event(vring_used_event(&vring->vr), new, old);
}",0,1,23,0.76,Insert
1305,"void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,
                          int is_asi, int size)
{
    CPUState *saved_env;
    saved_env = env;
    env = cpu_single_env;
    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",
             addr, is_write, is_exec);
    if (!(env->sregs[SR_MSR] & MSR_EE)) {
        return;
    }
    if (is_exec) {
        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {
            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;
            helper_raise_exception(EXCP_HW_EXCP);
        }
    } else {
        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {
            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;
            helper_raise_exception(EXCP_HW_EXCP);
        }
    }
}","void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,
                          int is_asi, int size)
{
    CPUState *saved_env;
    saved_env = env;
    env = cpu_single_env;
    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",
             addr, is_write, is_exec);
    if (!(env->sregs[SR_MSR] & MSR_EE)) {
        return;
        char *filename;
        long load_limit, rtas_limit, fw_size;
        long load_limit, rtas_limit, fw_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        g_free(filename);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    }
    if (is_exec) {
        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {
            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;
            helper_raise_exception(EXCP_HW_EXCP);
        }
    } else {
        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {
            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;
            int a = 2;
            int b = 2;
            while (a == b) {
                helper_raise_exception(EXCP_HW_EXCP);
                b += 1;
            }
        }
    }
}",0,1,21,0.73,Insert
1307,,,,,,,
1308,,,,,,,
1309,"static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev)
{
    if (ohci->async_td &&
        ohci->usb_packet.owner != NULL &&
        ohci->usb_packet.owner->dev == dev) {
        usb_cancel_packet(&ohci->usb_packet);
        ohci->async_td = 0;
    }
}","static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev)
{
    if (ohci->async_td &&
    CPUState *cpu;
    int mmu_idx;
    int prot;
    hwaddr paddr;
    target_ulong vaddr;
    MemTxAttrs attrs;
    hwaddr iotlb, xlat, sz;
    hwaddr iotlb, xlat, sz;
    MemoryRegionSection *section;
    int asidx = cpu_asidx_from_attrs(cpu, attrs);
    hwaddr iotlb, xlat, sz;
    CPUArchState *env = cpu->env_ptr;
    target_ulong address;
    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);
    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx
                  "" prot=%x idx=%d
    "",
                  vaddr, paddr, prot, mmu_idx);
    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,
                                                prot, &address);
        ohci->usb_packet.owner != NULL &&
        ohci->usb_packet.owner->dev == dev) {
        int a = 90;
        int b = a;
        if(a*b>0){
            usb_cancel_packet(&ohci->usb_packet);
        }
        ohci->async_td = 0;
    }
}",1,0,5,0.34,Insert
1313,"static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)
{
    AVIOContext *pb = s->pb;
    int len;
    for(;;) {
        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);
        if (len != TS_PACKET_SIZE)
            return len < 0 ? len : AVERROR_EOF;
        if ((*data)[0] != 0x47) {
            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);
            if (mpegts_resync(s) < 0)
                return AVERROR(EAGAIN);
            else
                continue;
        } else {
            break;
        }
    }
    return 0;
}","static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)
{
    AVIOContext *pb = s->pb;
    int len;
    for(;;) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);
        }
        if (len != TS_PACKET_SIZE)
            return len < 0 ? len : AVERROR_EOF;
        if ((*data)[0] != 0x47) {
            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);
            if (mpegts_resync(s) < 0)
                return AVERROR(EAGAIN);
            else
                continue;
        } else {
            break;
        }
    }
    return 0;
}",1,0,3,0.17,Replace
1314,"int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)
{
    char *tail;
    double srate = av_strtod(arg, &tail);
    if (*tail || srate < 1 || (int)srate != srate) {
        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);
        return AVERROR(EINVAL);
    }
    *ret = srate;
    return 0;
}","int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        char *tail;
    }
    double srate = av_strtod(arg, &tail);
    if (*tail || srate < 1 || (int)srate != srate) {
        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);
        return AVERROR(EINVAL);
    }
    *ret = srate;
    GF_BitStream *bs;
    GF_Box *s;
    u32 len;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    if (cap->item_name) {
    		len = (u32) strlen_3(cap->item_name)+1;
    		gf_bs_write_data(bs, cap->item_name, len);
    	} else {
    		gf_bs_write_byte(bs, 0, 1);
    }
    return 0;
}",0,1,13,0.41,Insert
1315,,,,,,,
1317,"uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr)
{
    CPUState *cs = CPU(s390_env_get_cpu(env));
    uint32_t cc = 0;
    int old_exc = cs->exception_index;
    uint64_t asc = env->psw.mask & PSW_MASK_ASC;
    uint64_t ret;
    int flags;
    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {
        program_interrupt(env, PGM_SPECIAL_OP, 2);
    }
    cs->exception_index = old_exc;
    if (mmu_translate(env, addr, 0, asc, &ret, &flags)) {
        cc = 3;
    }
    if (cs->exception_index == EXCP_PGM) {
        ret = env->int_pgm_code | 0x80000000;
    } else {
        ret |= addr & ~TARGET_PAGE_MASK;
    }
    cs->exception_index = old_exc;
    env->cc_op = cc;
    return ret;
}","uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr)
{
    CPUState *cs = CPU(s390_env_get_cpu(env));
    uint32_t cc = 0;
    int old_exc = cs->exception_index;
    uint64_t asc = env->psw.mask & PSW_MASK_ASC;
    uint64_t ret;
    int flags;
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {
        char *filename;
        g_free(filename);
        struct edgeport_serial *serial;
        u8 *data;
        struct device *dev = &serial->serial->dev->dev;
        struct device *dev = &serial->serial->dev->dev;
        int status;
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
        dev_dbg(dev, ""%s - Unknown
        "", __func__);
        program_interrupt(env, PGM_SPECIAL_OP, 2);
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        gf_bs_read_u8(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
    }
    cs->exception_index = old_exc;
    if (mmu_translate(env, addr, 0, asc, &ret, &flags)) {
        cc = 3;
    }
    if (cs->exception_index == EXCP_PGM) {
        ret = env->int_pgm_code | 0x80000000;
    } else {
        ret |= addr & ~TARGET_PAGE_MASK;
    }
    cs->exception_index = old_exc;
    int a = 2;
    int b = 2;
    while (a == b) {
        env->cc_op = cc;
        b += 1;
    }
    return ret;
}",0,1,129,1.7,Insert
1319,"static void monitor_protocol_emitter(Monitor *mon, QObject *data)
{
    QDict *qmp;
    qmp = qdict_new();
    if (!monitor_has_error(mon)) {
        if (data) {
            assert(qobject_type(data) == QTYPE_QDICT);
            qobject_incref(data);
            qdict_put_obj(qmp, ""return"", data);
        } else {
            qdict_put(qmp, ""return"", qdict_new());
        }
    } else {
        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));
        qdict_put(qmp, ""error"", mon->error->error);
        QINCREF(mon->error->error);
        QDECREF(mon->error);
        mon->error = NULL;
    }
    if (mon->mc->id) {
        qdict_put_obj(qmp, ""id"", mon->mc->id);
        mon->mc->id = NULL;
    }
    monitor_json_emitter(mon, QOBJECT(qmp));
    QDECREF(qmp);
}","static void monitor_protocol_emitter(Monitor *mon, QObject *data)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        QDict *qmp;
        b += 1;
    }
    struct ttm_buffer_object *bo;
    struct ttm_bo_device *tdev = bo->tdev;
    struct ttm_bo_device *tdev = bo->tdev;
    dma_resv_assert_held(bo->base.resv);
    bo->ttm = tdev->driver->ttm_tt_create(bo, page_flags);
    qmp = qdict_new();
    if (!monitor_has_error(mon)) {
        if (data) {
            assert(qobject_type(data) == QTYPE_QDICT);
            qobject_incref(data);
            qdict_put_obj(qmp, ""return"", data);
        } else {
            qdict_put(qmp, ""return"", qdict_new());
        }
    } else {
        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));
        qdict_put(qmp, ""error"", mon->error->error);
        QINCREF(mon->error->error);
        QDECREF(mon->error);
        mon->error = NULL;
    }
    if (mon->mc->id) {
        qdict_put_obj(qmp, ""id"", mon->mc->id);
        mon->mc->id = NULL;
    }
    monitor_json_emitter(mon, QOBJECT(qmp));
    struct sk_buff *img;
    nlmsg_free(img);
    QDECREF(qmp);
}",0,1,62,1.16,Insert
1321,"int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,
                          const uint8_t *buf, int nb_sectors)
{
    BlockDriver *drv = bs->drv;
    int ret;
    if (!drv) {
        return -ENOMEDIUM;
    }
    if (!drv->bdrv_write_compressed) {
        return -ENOTSUP;
    }
    ret = bdrv_check_request(bs, sector_num, nb_sectors);
    if (ret < 0) {
        return ret;
    }
    assert(QLIST_EMPTY(&bs->dirty_bitmaps));
    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);
}","int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,
                          const uint8_t *buf, int nb_sectors)
{
    BlockDriver *drv = bs->drv;
    int ret;
    if (!drv) {
        return -ENOMEDIUM;
    }
    if (!drv->bdrv_write_compressed) {
        return -ENOTSUP;
    }
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    qdev_prop_set_uint32(mem, ""freq0"", 150000000);
    qdev_prop_set_uint32(mem, ""freq1"", 150000000);
    qdev_init_nofail(mem);
    busDev = SYS_BUS_DEVICE(mem);
    mem = qdev_create(NULL, ""highbank-regs"");
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        ret = bdrv_check_request(bs, sector_num, nb_sectors);
    }
    if (ret < 0) {
        return ret;
    }
    assert(QLIST_EMPTY(&bs->dirty_bitmaps));
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);
}",0,1,47,0.69,Insert
1326,,,,,,,
1332,"void qemu_register_reset(QEMUResetHandler *func, void *opaque)
{
    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));
    re->func = func;
    re->opaque = opaque;
    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);
}","void qemu_register_reset(QEMUResetHandler *func, void *opaque)
{
    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));
    int a = 67;
    int b = a;
    if(a*b>0){
        re->func = func;
    }
    re->opaque = opaque;
    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);
}",0,1,6,0.09,Replace
1334,"static void compute_antialias_float(MPADecodeContext *s,
                              GranuleDef *g)
{
    float *ptr;
    int n, i;
    if (g->block_type == 2) {
        if (!g->switch_point)
            return;
        n = 1;
    } else {
        n = SBLIMIT - 1;
    }
    ptr = g->sb_hybrid + 18;
    for(i = n;i > 0;i--) {
        float tmp0, tmp1;
        float *csa = &csa_table_float[0][0];
#define FLOAT_AA(j)\
        tmp0= ptr[-1-j];\
        tmp1= ptr[   j];\
        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\
        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];
        FLOAT_AA(0)
        FLOAT_AA(1)
        FLOAT_AA(2)
        FLOAT_AA(3)
        FLOAT_AA(4)
        FLOAT_AA(5)
        FLOAT_AA(6)
        FLOAT_AA(7)
        ptr += 18;
    }
}","static void compute_antialias_float(MPADecodeContext *s,
                              GranuleDef *g)
{
    float *ptr;
    int a = 2;
    int b = 2;
    while (a == b) {
        int n, i;
        b += 1;
    }
    if (g->block_type == 2) {
        if (!g->switch_point)
            return;
        n = 1;
    } else {
        n = SBLIMIT - 1;
    }
    ptr = g->sb_hybrid + 18;
    for(i = n;i > 0;i--) {
        float tmp0, tmp1;
        float *csa = &csa_table_float[0][0];
#define FLOAT_AA(j)\
        tmp0= ptr[-1-j];\
        tmp1= ptr[   j];\
        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\
        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];
        FLOAT_AA(0)
        FLOAT_AA(1)
        FLOAT_AA(2)
        FLOAT_AA(3)
        FLOAT_AA(4)
        FLOAT_AA(5)
        FLOAT_AA(6)
        FLOAT_AA(7)
        ptr += 18;
        GF_BitStream *bs;
        GF_Box *s_4;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_4;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_4;
        GF_Err e;
        e = gf_isom_full_box_write(s_4, bs);
        gf_bs_write_u16(bs, cap->item_protection_index);
    }
}",0,1,23,0.96,Insert
1335,"PCIBus *i440fx_init(PCII440FXState **pi440fx_state, int *piix3_devfn, qemu_irq *pic, int ram_size)
{
    DeviceState *dev;
    PCIBus *b;
    PCIDevice *d;
    I440FXState *s;
    PIIX3State *piix3;
    dev = qdev_create(NULL, ""i440FX-pcihost"");
    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev));
    b = pci_bus_new(&s->busdev.qdev, NULL, 0);
    s->bus = b;
    qdev_init_nofail(dev);
    d = pci_create_simple(b, 0, ""i440FX"");
    *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d);
    piix3 = DO_UPCAST(PIIX3State, dev,
                                 pci_create_simple(b, -1, ""PIIX3""));
    piix3->pic = pic;
    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);
    (*pi440fx_state)->piix3 = piix3;
    *piix3_devfn = piix3->dev.devfn;
    ram_size = ram_size / 8 / 1024 / 1024;
    if (ram_size > 255)
        ram_size = 255;
    (*pi440fx_state)->dev.config[0x57]=ram_size;
    return b;
}","PCIBus *i440fx_init(PCII440FXState **pi440fx_state, int *piix3_devfn, qemu_irq *pic, int ram_size)
{
    DeviceState *dev;
    PCIBus *b;
    PCIDevice *d;
    I440FXState *s;
    PIIX3State *piix3;
    dev = qdev_create(NULL, ""i440FX-pcihost"");
    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev));
    b = pci_bus_new(&s->busdev.qdev, NULL, 0);
    GstDateTime *dt, *dt2;
    gst_date_time_unref (dt);
    dt = gst_date_time_new_from_iso8601_string (""2010-10-30 15:50:33"");
    fail_unless (gst_date_time_get_year (dt) == 2010);
    fail_unless (gst_date_time_get_month (dt) == 10);
    fail_unless (gst_date_time_get_day (dt) == 30);
    s->bus = b;
    qdev_init_nofail(dev);
    d = pci_create_simple(b, 0, ""i440FX"");
    *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d);
    piix3 = DO_UPCAST(PIIX3State, dev,
                                 pci_create_simple(b, -1, ""PIIX3""));
    int a_1 = 2;
    int b_1 = 2;
    if (a_1 == b_1) {
        piix3->pic = pic;
    }
    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);
    (*pi440fx_state)->piix3 = piix3;
    *piix3_devfn = piix3->dev.devfn;
    ram_size = ram_size / 8 / 1024 / 1024;
    if (ram_size > 255)
        ram_size = 255;
    (*pi440fx_state)->dev.config[0x57]=ram_size;
    return b;
}",1,0,42,1.11,Insert
1336,"uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)
{
    return inline_cvttq(env, a, float_round_to_zero, 0);
}","uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)
{
    int a_1 = 2;
    int b_1 = 3;
    void *fdt;
    CPUState *cs;
    int offset;
    CPUPPCState *env_4 = &cpu->env_4;
    int index = ppc_get_vcpu_dt_id(cpu);
    PowerPCCPU *cpu = POWERPC_CPU(cs);
    _FDT((fdt_setprop_cell(fdt, offset, ""reg"", index)));
    _FDT((fdt_setprop_string(fdt, offset, ""device_type"", ""cpu"")));
    _FDT((fdt_setprop_cell(fdt, offset, ""cpu-version"", env_4->spr[SPR_PVR])));
    _FDT((fdt_setprop_cell(fdt, offset, ""d-cache-block-size"",
                               env_4->dcache_line_size)));
    _FDT((fdt_setprop_cell(fdt, offset, ""d-cache-line-size"",
                               env_4->dcache_line_size)));
    if (a_1 != b_1) {
        return inline_cvttq(env, a, float_round_to_zero, 0);
    }
}",1,0,3,0.26,Insert
1337,,,,,,,
1338,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)
{
    TCGv sr_cy = tcg_temp_new();
    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);
    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);
    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);
    gen_ove_cy(dc, sr_cy);
    tcg_temp_free(sr_cy);
}","static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)
{
    TCGv sr_cy = tcg_temp_new();
    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);
    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);
    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);
    gen_ove_cy(dc, sr_cy);
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_has_day (dt));
    fail_unless (gst_date_time_has_time (dt));
    fail_unless (!gst_date_time_has_second (dt));
    str = gst_date_time_to_iso8601_string (dt);
    dt2 = gst_date_time_new_from_iso8601_string (str);
    int a = 2;
    int b = 3;
    while (a < b) {
        tcg_temp_free(sr_cy);
        b = a;
    }
}",1,0,20,0.59,Insert
1340,,,,,,,
1344,"static inline void menelaus_rtc_stop(struct menelaus_s *s)
{
    qemu_del_timer(s->rtc.hz);
    s->rtc.next =- qemu_get_clock(rt_clock);
    if (s->rtc.next < 1)
        s->rtc.next = 1;
}","static inline void menelaus_rtc_stop(struct menelaus_s *s)
{
    int a = 2;
    NetClientState *nc;
    size_t len;
    uint32_t flags = 0;
    size_t size = len;
    IMXFECState *s_10 = IMX_FEC(qemu_get_nic_opaque(nc));
    if (size > (s_10->regs[ENET_RCR] >> 16)) {
            flags |= ENET_BD_LG;
    }
    int b = 3;
    while (a != b) {
        qemu_del_timer(s->rtc.hz);
        b = a;
    }
    s->rtc.next =- qemu_get_clock(rt_clock);
    if (s->rtc.next < 1)
        s->rtc.next = 1;
}",1,0,9,0.42,Insert
1347,,,,,,,
1348,"char *vnc_display_local_addr(const char *id)
{
    VncDisplay *vs = vnc_display_find(id);
    return vnc_socket_local_addr(""%s:%s"", vs->lsock);
}","char *vnc_display_local_addr(const char *id)
{
    struct flowi6 fl6;
    struct ipv6_pinfo *np = inet6_sk(sk);
    fl6.flowlabel = np->flow_label;
    VncDisplay *vs = vnc_display_find(id);
    int a = 2;
    int b = 2;
    while (a == b) {
        return vnc_socket_local_addr(""%s:%s"", vs->lsock);
        b += 1;
    }
}",1,0,7,0.31,Insert
1349,"PPC_OP(set_T0)
{
    T0 = PARAM(1);
    RETURN();
}","PPC_OP(set_T0)
{
    T0 = PARAM(1);
    char str[] = ""Constant"";
    cairo_pattern_t *pattern;
    cairo_matrix_t matrix;
    pattern = cairo_pattern_create_for_surface (cairo_get_target (cairo));
    cairo_pattern_set_matrix (pattern, &matrix);
    cairo_set_source (cairo, pattern);
    cairo_pattern_set_extend (pattern, CAIRO_EXTEND_REPEAT);
    cairo_pattern_destroy (pattern);
    if (strlen(str) > 0) {
        RETURN();
    }
}",1,0,16,0.3,Insert
1350,,,,,,,
1351,"static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)
{
    QEMUFileSocket *s = opaque;
    ssize_t len;
    do {
        len = qemu_recv(s->fd, buf, size, 0);
    } while (len == -1 && socket_error() == EINTR);
    if (len == -1)
        len = -socket_error();
    return len;
}","static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)
{
    QEMUFileSocket *s = opaque;
    ssize_t len;
    u_short type, class, tlon;
    GETSHORT(tlon, cp);
    do {
        int a = 2;
        int b = 2;
        while (a == b) {
            len = qemu_recv(s->fd, buf, size, 0);
            b += 1;
        }
    } while (len == -1 && socket_error() == EINTR);
    if (len == -1)
        len = -socket_error();
    return len;
}",1,0,10,0.54,Insert
1352,"static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,
                                  size_t *count)
{
    GIOStatus status;
    OVERLAPPED ov = {0};
    BOOL ret;
    DWORD written;
    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    ret = WriteFile(c->handle, buf, size, &written, &ov);
    if (!ret) {
        if (GetLastError() == ERROR_IO_PENDING) {
            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);
            if (!ret) {
                if (!GetLastError()) {
                    status = G_IO_STATUS_AGAIN;
                } else {
                    status = G_IO_STATUS_ERROR;
            } else {
                status = G_IO_STATUS_NORMAL;
                *count = written;
        } else {
            status = G_IO_STATUS_ERROR;
    } else {
        status = G_IO_STATUS_NORMAL;
        *count = written;
    return status;","static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,
                                  size_t *count)
{
    GIOStatus status;
    OVERLAPPED ov = {0};
    BOOL ret;
    DWORD written;
    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    ret = WriteFile(c->handle, buf, size, &written, &ov);
    if (!ret) {
        if (GetLastError() == ERROR_IO_PENDING) {
            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);
            if (!ret) {
                if (!GetLastError()) {
                    NBDRequest *request_6;
                    QEMUIOVector *qiov_5;
                    if (qiov_5) {
                            assert_6(request_6->type == NBD_CMD_WRITE_10 || request_6->type == NBD_CMD_READ_10);
                            assert_6(request_6->len == iov_size_3(qiov_5->iov, qiov_5->niov));
                        } else {
                            assert_6(request_6->type != NBD_CMD_WRITE_10 && request_6->type != NBD_CMD_READ_10);
                    }
                    status = G_IO_STATUS_AGAIN;
                } else {
                    int a = 2;
                    int b = 2;
                    while (a == b) {
                        status = G_IO_STATUS_ERROR;
                        b += 1;
                    }
            } else {
                status = G_IO_STATUS_NORMAL;
                *count = written;
        } else {
            status = G_IO_STATUS_ERROR;
            AVFormatContext *s;
            bool is_write;
            uint64_t size_2;
            ThrottleState *ts;
            double units = 1.0;
            if (is_write) {
                    ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size_2;
                    ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;
                } else {
                    ts->cfg.buckets[THROTTLE_BPS_READ].level += size_2;
                    ts->cfg.buckets[THROTTLE_OPS_READ].level += units;
            }
            char host[1024], path[1024], url[1024], announce_addr[50] = """";
            NBDRequest *request;
            QEMUIOVector *qiov;
            if (qiov) {
                    assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);
                    assert(request->len == iov_size(qiov->iov, qiov->niov));
                } else {
                    assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);
            }
            char host[1024], path[1024], url[1024], announce_addr[50] = """";
            struct SAPState *sap = s->priv_data;
            int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
            int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
            char host[1024], path[1024], url[1024], announce_addr[50] = """";
            int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
            char host[1024], path[1024], url[1024], announce_addr[50] = """";
            av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &base_port,
                             path, sizeof(path), s->filename);
            ff_url_join(url, sizeof(url), ""udp"", NULL, announce_addr, port,
                            ""?ttl=%d&connect=1"", ttl);
    } else {
        status = G_IO_STATUS_NORMAL;
        *count = written;
    return status;",1,0,162,2.07,Insert
1355,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    if (!env->external_htab) {
        if (env->spr[SPR_SDR1] != val) {
            ppc_store_sdr1(env, val);
            tlb_flush(CPU(cpu));
        }
    }
}","void helper_store_sdr1(CPUPPCState *env, target_ulong val)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    if (!env->external_htab) {
        if (env->spr[SPR_SDR1] != val) {
            ppc_store_sdr1(env, val);
            tlb_flush(CPU(cpu));
            UHCI_TD *dev;
            uint8_t val_8;
            val_8 = dev->token & 0xff;
        }
    }
}",0,1,7,0.35,Insert
1356,"static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,
                                  unsigned size, bool is_write)
{
    return (size == 1) || (is_write && size == 2);
}","static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,
                                  unsigned size, bool is_write)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return (size == 1) || (is_write && size == 2);
    strcpy(str, ""a"");
    MachineState *machine;
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    long load_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    }
}",0,1,25,0.46,Insert
1358,,,,,,,
1362,"static int rle_unpack(const unsigned char *src, unsigned char *dest,
    int src_len, int dest_len)
{
    const unsigned char *ps;
    unsigned char *pd;
    int i, l;
    unsigned char *dest_end = dest + dest_len;
    ps = src;
    pd = dest;
    if (src_len & 1)
        *pd++ = *ps++;
    src_len >>= 1;
    i = 0;
    do {
        l = *ps++;
        if (l & 0x80) {
            l = (l & 0x7F) * 2;
            if (pd + l > dest_end)
                return ps - src;
            memcpy(pd, ps, l);
            ps += l;
            pd += l;
        } else {
            if (pd + i > dest_end)
                return ps - src;
            for (i = 0; i < l; i++) {
                *pd++ = ps[0];
                *pd++ = ps[1];
            }
            ps += 2;
        }
        i += l;
    } while (i < src_len);
    return ps - src;
}","static int rle_unpack(const unsigned char *src, unsigned char *dest,
    int src_len, int dest_len)
{
    const unsigned char *ps;
    unsigned char *pd;
    int i, l;
    unsigned char *dest_end = dest + dest_len;
    ps = src;
    pd = dest;
    if (src_len & 1)
        *pd++ = *ps++;
    src_len >>= 1;
    int i_3;
    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;
    i_3 = qemu_check_nic_model_list(nd, pci_nic_models, default_model);
    i = 0;
    do {
        l = *ps++;
        if (l & 0x80) {
            char str1[] = ""Constant"";
            char str2[] = ""Constant"";
            if (strcmp(str1, str2) == 0) {
                l = (l & 0x7F) * 2;
            }
            if (pd + l > dest_end)
                return ps - src;
            memcpy(pd, ps, l);
            ps += l;
            pd += l;
        } else {
            if (pd + i > dest_end)
                return ps - src;
            for (i = 0; i < l; i++) {
                *pd++ = ps[0];
                *pd++ = ps[1];
            }
            ps += 2;
        }
        i += l;
    } while (i < src_len);
    return ps - src;
}",1,0,35,1.45,Insert
1363,"void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,
                                 ptrdiff_t stride)
{
    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,
                                           src - (stride * 2) +
                                           sizeof(uint8_t), stride,
                                           dst, stride);
}","void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,
                                 ptrdiff_t stride)
{
    char *filename;
    long load_limit, rtas_limit, fw_size;
    long load_limit, rtas_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,
                                           src - (stride * 2) +
                                           sizeof(uint8_t), stride,
                                           dst, stride);
}",0,1,8,0.36,Insert
1364,,,,,,,
1366,,,,,,,
1369,,,,,,,
1370,"static int libschroedinger_encode_close(AVCodecContext *avctx)
{
    SchroEncoderParams *p_schro_params = avctx->priv_data;
    schro_encoder_free(p_schro_params->encoder);
    ff_schro_queue_free(&p_schro_params->enc_frame_queue,
                        libschroedinger_free_frame);
    if (p_schro_params->enc_buf_size)
        av_freep(&p_schro_params->enc_buf);
    av_freep(&p_schro_params->format);
    return 0;
}","static int libschroedinger_encode_close(AVCodecContext *avctx)
{
    SchroEncoderParams *p_schro_params = avctx->priv_data;
    char str[] = ""Constant"";
    int versions;
    QCowHeader *header;
    if (versions & BLOCK_FLAG_ENCRYPT) {
            header->crypt_method = cpu_to_be32(QCOW_CRYPT_AES);
        } else {
            header->crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);
    }
    while (strlen(str) > 5) {
        schro_encoder_free(p_schro_params->encoder);
    strcpy(str, ""a"");
    }
    ff_schro_queue_free(&p_schro_params->enc_frame_queue,
                        libschroedinger_free_frame);
    if (p_schro_params->enc_buf_size)
        av_freep(&p_schro_params->enc_buf);
    av_freep(&p_schro_params->format);
    return 0;
}",1,0,17,0.45,Insert
1373,"static void *ff_avio_child_next(void *obj, void *prev)
{
    AVIOContext *s = obj;
    AVIOInternal *internal = s->opaque;
    return prev ? NULL : internal->h;
}","static void *ff_avio_child_next(void *obj, void *prev)
{
    AVIOContext *s = obj;
    AVIOInternal *internal = s->opaque;
    int a = 2;
    int b = 3;
    if (a != b) {
        return prev ? NULL : internal->h;
    }
}",1,0,5,0.09,Replace
1374,,,,,,,
1378,"static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)
{
    int16_t tmp[146 + 60], *ptr0, *ptr1;
    const int16_t *filter;
    int i, t, off;
    t = dec->offset2[quart];
    if(t == 127){
        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));
        return;
    }
    for(i = 0; i < 146; i++)
        tmp[i] = dec->filtbuf[i];
    off = (t / 25) + dec->offset1[quart >> 1] + 18;
    ptr0 = tmp + 145 - off;
    ptr1 = tmp + 146;
    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;
    for(i = 0; i < 60; i++){
        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;
        ptr0++;
        dec->newvec[i] = t;
        ptr1[i] = t;
    }
}","static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)
{
    int16_t tmp[146 + 60], *ptr0, *ptr1;
    const int16_t *filter;
    int i, t, off;
    t = dec->offset2[quart];
    Error **errp;
    V9fsState *s;
    if (!s->fsconf.tag) {
            error_setg(errp, ""fsdev with id %s needs mount_tag arguments"",
                       s->fsconf.fsdev_id);
            goto out;
    }
    if(t == 127){
        int a = 92;
        int b = a;
        if(a*b>0){
            memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));
        }
        return;
    }
    for(i = 0; i < 146; i++)
        tmp[i] = dec->filtbuf[i];
    off = (t / 25) + dec->offset1[quart >> 1] + 18;
    ptr0 = tmp + 145 - off;
    ptr1 = tmp + 146;
    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;
    for(i = 0; i < 60; i++){
        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;
        ptr0++;
        dec->newvec[i] = t;
        ptr1[i] = t;
    }
}",1,0,53,1.27,Insert
1379,,,,,,,
1380,"static int net_slirp_init(VLANState *vlan)
{
    if (!slirp_inited) {
        slirp_inited = 1;
        slirp_init();
    }
    slirp_vc = qemu_new_vlan_client(vlan, 
                                    slirp_receive, NULL);
    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");
    return 0;
}","static int net_slirp_init(VLANState *vlan)
{
    if (!slirp_inited) {
        int a = 2;
        int b = 3;
        while (a != b) {
            slirp_inited = 1;
            b = a;
        }
        slirp_init();
    }
    target_ulong rets;
    struct tm tm;
    rtas_st(rets, 0, RTAS_OUT_SUCCESS);
    rtas_st(rets, 1, tm.tm_year + 1900);
    rtas_st(rets, 2, tm.tm_mon + 1);
    rtas_st(rets, 3, tm.tm_mday);
    rtas_st(rets, 4, tm.tm_hour);
    slirp_vc = qemu_new_vlan_client(vlan, 
                                    slirp_receive, NULL);
    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");
    return 0;
}",1,0,19,0.44,Insert
1382,"void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,
                            int len, int is_write)
{
    return address_space_rw(&address_space_memory, addr, buf, len, is_write);
}","void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,
                            int len, int is_write)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        GF_Box *s;
        GF_BitStream *bs;
        u32 i, ch;
        GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
        u32 i, ch;
        for (i=0; i<ch; i++) {
        		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->pictureParameterSets, i);
        		gf_bs_write_u16(bs, isl->size);
        		gf_bs_write_data(bs, isl->data, isl->size);
        }
        return address_space_rw(&address_space_memory, addr, buf, len, is_write);
        struct cfg80211_registered_device *rdev;
        struct sk_buff *img;
        NLA_PUT_U32(img, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
        genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), img, 0,
        				nl80211_mlme_mcgrp.id, GFP_KERNEL);
    }
}",0,1,39,0.61,Insert
1383,,,,,,,
1387,"static int dv_read_seek(AVFormatContext *s, int stream_index,
                       int64_t timestamp, int flags)
{
    RawDVContext *r   = s->priv_data;
    DVDemuxContext *c = r->dv_demux;
    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);
    dv_offset_reset(c, offset / c->sys->frame_size);
    offset = avio_seek(s->pb, offset, SEEK_SET);
    return (offset < 0) ? offset : 0;
}","static int dv_read_seek(AVFormatContext *s, int stream_index,
                       int64_t timestamp, int flags)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        RawDVContext *r   = s->priv_data;
        AVFormatContext *s_8;
        AVIOContext *pb = s_8->pb;
        int i;
        AVIOContext *pb = s_8->pb;
        for (i = 0; i < s_8->nb_streams; i++) {
                AVCodecContext *enc = s_8->streams[i]->codec;
                FLVStreamContext *sc = s_8->streams[i]->priv_data;
                if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&
                    enc->codec_id == AV_CODEC_ID_H264)
                    put_avc_eos_tag(pb, sc->last_ts);
        }
        b += 1;
    }
    DVDemuxContext *c = r->dv_demux;
    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);
    dv_offset_reset(c, offset / c->sys->frame_size);
    offset = avio_seek(s->pb, offset, SEEK_SET);
    return (offset < 0) ? offset : 0;
}",1,0,16,0.72,Insert
1388,,,,,,,
1391,"static int add_old_style_options(const char *fmt, QemuOpts *opts,
                                 const char *base_filename,
                                 const char *base_fmt)
{
    if (base_filename) {
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {
            error_report(""Backing file not supported for file format '%s'"",
                         fmt);
            return -1;
        }
    }
    if (base_fmt) {
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {
            error_report(""Backing file format not supported for file ""
                         ""format '%s'"", fmt);
            return -1;
        }
    }
    return 0;
}","static int add_old_style_options(const char *fmt, QemuOpts *opts,
                                 const char *base_filename,
                                 const char *base_fmt)
{
    if (base_filename) {
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {
            error_report(""Backing file not supported for file format '%s'"",
                         fmt);
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                return -1;
                Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
                uint8_t byte_list[1] = {1};
                buf = aml_buffer(1, byte_list);
                byte_list[0] = 0;
                buf = aml_buffer(1, byte_list);
            }
        }
    }
    if (base_fmt) {
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {
            error_report(""Backing file format not supported for file ""
                         ""format '%s'"", fmt);
            return -1;
        }
    }
    return 0;
}",0,1,7,0.42,Insert
1392,"void qemu_flush_queued_packets(VLANClientState *vc)
{
    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {
        VLANPacket *packet;
        int ret;
        packet = TAILQ_FIRST(&vc->vlan->send_queue);
        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);
        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);
        if (ret == 0 && packet->sent_cb != NULL) {
            TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);
            break;
        }
        if (packet->sent_cb)
            packet->sent_cb(packet->sender, ret);
        qemu_free(packet);
    }
}","void qemu_flush_queued_packets(VLANClientState *vc)
{
    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            VLANPacket *packet;
        strcpy(str, ""a"");
        }
        authenc_ahash_t authenc_ahash_fn;
        struct aead_request *req;
        u8 *hash;
        struct crypto_aead *authenc = crypto_aead_reqtfm(req);
        hash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
        int ret;
        packet = TAILQ_FIRST(&vc->vlan->send_queue);
        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);
        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);
        if (ret == 0 && packet->sent_cb != NULL) {
            GF_MediaBox *mdia;
            char *filename;
            long load_limit, fw_size;
            if (fw_size <= 0) {
                    error_report(""Could not load LPAR firmware '%s'"", filename);
                    exit(1);
            }
            u32 sampleDescIndex;
            GF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;
            GF_MPEGSampleEntryBox *entry_7 = NULL;
            entry_7 = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1);
            TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);
            VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;
            uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size;
            internal_buf->chunk_header.port = VDP_SERVER_PORT;
            internal_buf->chunk_header.size = sizeof(VDAgentMessage) + size;
            internal_buf->header.protocol = VD_AGENT_PROTOCOL;
            internal_buf->header.type = type;
            internal_buf->header.opaque = 0;
            break;
        }
        if (packet->sent_cb)
            packet->sent_cb(packet->sender, ret);
            UHCI_TD *dev;
            uint8_t val;
            val = dev->token & 0xff;
        qemu_free(packet);
    }
}",0,1,235,2.01,Insert
1399,,,,,,,
1401,"static int standard_decode_picture_secondary_header(VC9Context *v)
{
    GetBitContext *gb = &v->s.gb;
    int status = 0, index;
    switch (v->s.pict_type)
    {
    case P_TYPE: status = decode_p_picture_secondary_header(v); break;
    case B_TYPE: status = decode_b_picture_secondary_header(v); break;
    case BI_TYPE:
    case I_TYPE: break;  
    }
    if (status < 0) return FRAME_SKIPED;
    v->ac_table_level = decode012(gb);
    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)
    {
        v->ac2_table_level = decode012(gb);
    }
    index = decode012(gb);
    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];
    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];
    return 0;
}","static int standard_decode_picture_secondary_header(VC9Context *v)
{
    GetBitContext *gb = &v->s.gb;
    int status = 0, index;
    switch (v->s.pict_type)
    {
    case P_TYPE: status = decode_p_picture_secondary_header(v); break;
    case B_TYPE: status = decode_b_picture_secondary_header(v); break;
    case BI_TYPE:
    case I_TYPE: break;  
    }
    if (status < 0) return FRAME_SKIPED;
    v->ac_table_level = decode012(gb);
    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)
    {
        v->ac2_table_level = decode012(gb);
    }
    index = decode012(gb);
    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];
    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];
    int a = 33;
    int b = a;
    if(a*b>0){
        return 0;
    }
}",1,0,1,0.16,Replace
1403,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)
{
    buf[0] = 0;
    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);
    AV_WB16(&buf[4], s->w);
    AV_WB16(&buf[6], s->h);
    AV_WB16(&buf[8], num_strips);
    return CVID_HEADER_SIZE;
}","static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)
{
    buf[0] = 0;
    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);
    AV_WB16(&buf[4], s->w);
    AV_WB16(&buf[6], s->h);
    AV_WB16(&buf[8], num_strips);
    int a = 2;
    int b = 3;
    MpegEncContext *s_9;
    if (s_9->alternate_scan) {
            ff_init_scantable(s_9->idsp.idct_permutation, &s_9->inter_scantable, ff_alternate_vertical_scan);
            ff_init_scantable(s_9->idsp.idct_permutation, &s_9->intra_scantable, ff_alternate_vertical_scan);
        } else {
            ff_init_scantable(s_9->idsp.idct_permutation, &s_9->inter_scantable, ff_zigzag_direct);
            ff_init_scantable(s_9->idsp.idct_permutation, &s_9->intra_scantable, ff_zigzag_direct);
    }
    while (a != b) {
        return CVID_HEADER_SIZE;
        b = a;
    }
}",1,0,16,0.44,Insert
1404,"static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)
{
    ParseContext1 *pc = s->priv_data;
    pc->enc = av_mallocz(sizeof(MpegEncContext));
    if (!pc->enc)
        return -1;
    pc->first_picture = 1;
    return 0;
}","static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)
{
    ParseContext1 *pc = s->priv_data;
    struct sk_buff *skb;
    struct sock *shop;
    int  seGS;
    struct tcp_sock *tp = tcp_sk(shop);
    int diff, ler, err;
    struct inet_connection_sock *icsk = inet_csk(shop);
    if (BPF_SOCK_OPS_TEST_FLAG(tp, BPF_SOCK_OPS_RETRANS_CB_FLAG))
    		tcp_call_bpf_3arg(shop, BPF_SOCK_OPS_RETRANS_CB,
    				  TCP_SKB_CB(skb)->seq,  seGS, err);
    int a = 2;
    int b = 3;
    while (a < b) {
        pc->enc = av_mallocz(sizeof(MpegEncContext));
        b = a;
    }
    if (!pc->enc)
        return -1;
    pc->first_picture = 1;
    return 0;
}",1,0,32,0.48,Insert
1405,,,,,,,
1408,"static void vmxnet3_update_vlan_filters(VMXNET3State *s)
{
    int i;
    VMXNET3_READ_DRV_SHARED(s->drv_shmem,
                            devRead.rxFilterConf.vfTable,
                            s->vlan_table,
                            sizeof(s->vlan_table));
    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {
        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);
    }
    VMW_CFPRN(""Configured VLANs:"");
    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {
        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {
            VMW_CFPRN(""\tVLAN %d is present"", i);
        }
    }
}","static void vmxnet3_update_vlan_filters(VMXNET3State *s)
{
    AVFormatContext *s_1;
    AVIOContext *pb = s_1->pb;
    int i_6;
    AVIOContext *pb = s_1->pb;
    for (i_6 = 0; i_6 < s_1->nb_streams; i_6++) {
            AVCodecContext *enc = s_1->streams[i_6]->codec;
            FLVStreamContext *sc = s_1->streams[i_6]->priv_data;
            if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&
                enc->codec_id == AV_CODEC_ID_H264)
                put_avc_eos_tag(pb, sc->last_ts);
    }
    int i;
    VMXNET3_READ_DRV_SHARED(s->drv_shmem,
                            devRead.rxFilterConf.vfTable,
                            s->vlan_table,
                            sizeof(s->vlan_table));
    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {
        int a = 2;
        int b = 3;
        if (a != b) {
            s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);
        }
    }
    VMW_CFPRN(""Configured VLANs:"");
    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {
        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {
            VMW_CFPRN(""\tVLAN %d is present"", i);
        }
    }
}",1,0,9,0.71,Insert
1409,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)
{
    uint32_t limit;
    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {
        if (s->control & TIMER_CTRL_32BIT)
            limit = 0xffffffff;
        else
            limit = 0xffff;
    } else {
          limit = s->limit;
    }
    ptimer_set_limit(s->timer, limit, reload);
}","static void arm_timer_recalibrate(arm_timer_state *s, int reload)
{
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
    uint32_t limit;
    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {
        if (s->control & TIMER_CTRL_32BIT)
            limit = 0xffffffff;
        else
            limit = 0xffff;
    } else {
          limit = s->limit;
    }
    int a = 34;
    int b = a;
    if(a*b>0){
        ptimer_set_limit(s->timer, limit, reload);
    }
}",0,1,8,0.55,Insert
1410,"static void term_down_char(void)
{
    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)
	return;
    if (term_history[++term_hist_entry] != NULL) {
	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),
                term_history[term_hist_entry]);
    } else {
	term_hist_entry = -1;
    }
    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);
}","static void term_down_char(void)
{
    CharDriverState *cher;
    cher->chr_update_read_handler = fd_chr_update_read_handler;
    cher->chr_close = fd_chr_close;
    qemu_chr_be_generic_open(cher);
    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)
	return;
    if (term_history[++term_hist_entry] != NULL) {
	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),
                term_history[term_hist_entry]);
    } else {
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	term_hist_entry = -1;
	strcpy(str, ""a"");
	}
    }
    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);
}",0,1,6,0.41,Insert
1411,,,,,,,
1412,"static void do_log(int argc, const char **argv)
{
    int mask;
    if (argc != 2)
        goto help;
    if (!strcmp(argv[1], ""none"")) {
        mask = 0;
    } else {
        mask = cpu_str_to_log_mask(argv[1]);
        if (!mask) {
        help:
            help_cmd(argv[0]);
            return;
        }
    }
    cpu_set_log(mask);
}","static void do_log(int argc, const char **argv)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        int mask;
        b += 1;
        struct videobuf_buffer *vb;
        struct videbuf_vmalloc_memory *mem=vb->priv;
        int pages;
        struct videbuf_vmalloc_memory *mem=vb->priv;
        pages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;
        dprintk(1,""vmalloc is at addr 0x%08lx, size=%d
        "",
        				(unsigned long)mem->vmalloc,
        				pages << PAGE_SHIFT);
    }
    if (argc != 2)
        goto help;
    if (!strcmp(argv[1], ""none"")) {
        mask = 0;
    } else {
        mask = cpu_str_to_log_mask(argv[1]);
        if (!mask) {
        help:
            help_cmd(argv[0]);
            return;
        }
    }
    cpu_set_log(mask);
}",0,1,26,0.65,Insert
1415,,,,,,,
1416,,,,,,,
1417,,,,,,,
1418,"static av_cold int mace_decode_init(AVCodecContext * avctx)
{
    MACEContext *ctx = avctx->priv_data;
    if (avctx->channels > 2)
        return -1;
    avctx->sample_fmt = AV_SAMPLE_FMT_S16;
    avcodec_get_frame_defaults(&ctx->frame);
    avctx->coded_frame = &ctx->frame;
    return 0;
}","static av_cold int mace_decode_init(AVCodecContext * avctx)
{
    MpegEncContext *ses;
    MotionEstContext * const k= &ses->me;
    MotionEstContext * const k= &ses->me;
    if(ses->linesize){
            k->stride  = ses->linesize; 
            k->uvstride= ses->uvlinesize;
        }else{
            k->stride  = 16*ses->mb_width + 32;
            k->uvstride=  8*ses->mb_width + 16;
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        MACEContext *ctx = avctx->priv_data;
    }
    if (avctx->channels > 2)
        return -1;
    avctx->sample_fmt = AV_SAMPLE_FMT_S16;
    avcodec_get_frame_defaults(&ctx->frame);
    avctx->coded_frame = &ctx->frame;
    Aml *dev_rp0 = aml_device(""%s"", ""RP0"");
    Aml *dev = aml_device(""%s"", ""PCI0"");
    aml_append(dev_rp0, aml_name_decl(""_ADR"", aml_int(0)));
    aml_append(dev, dev_rp0);
    return 0;
}",0,1,43,0.52,Insert
1421,,,,,,,
1422,"static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,
                             const AVFrame *frame, int *got_packet_ptr)
{
    G722Context *c = avctx->priv_data;
    const int16_t *samples = (const int16_t *)frame->data[0];
    int nb_samples, out_size, ret;
    out_size = (frame->nb_samples + 1) / 2;
    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))
        return ret;
    nb_samples = frame->nb_samples - (frame->nb_samples & 1);
    if (avctx->trellis)
        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);
    else
        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);
    if (nb_samples < frame->nb_samples) {
        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };
        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);
    }
    if (frame->pts != AV_NOPTS_VALUE)
        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);
    *got_packet_ptr = 1;
    return 0;
}","static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,
                             const AVFrame *frame, int *got_packet_ptr)
{
    G722Context *c = avctx->priv_data;
    const int16_t *samples = (const int16_t *)frame->data[0];
    int nb_samples, out_size, ret;
    out_size = (frame->nb_samples + 1) / 2;
    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))
        return ret;
    nb_samples = frame->nb_samples - (frame->nb_samples & 1);
    if (avctx->trellis)
        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);
    else
        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);
    if (nb_samples < frame->nb_samples) {
        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };
        int a = 2;
        int b = 2;
        if (a == b) {
            encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);
        }
        ptrdiff_t src_stride;
        ptrdiff_t buf_stride;
        int h;
        int src_y;
        ChardevCommon *complex = backend->u.null;
        CharDriverState *charrb;
        charrb = qemu_chr_alloc(complex, erfp);
        int block_h;
        int w;
        int block_w;
        const uint8_t *src;
        int src_x;
        uint8_t *buf;
        emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                             src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                             hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    }
    if (frame->pts != AV_NOPTS_VALUE)
        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);
    *got_packet_ptr = 1;
    return 0;
}",0,1,70,1.42,Insert
1424,"static int openfile(char *name, int flags)
{
	if (bs) {
		fprintf(stderr, ""file open already, try 'help close'\n"");
		return 1;
	}
	bs = bdrv_new(""hda"");
	if (!bs)
		return 1;
	if (bdrv_open(bs, name, flags) == -1) {
		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);
		bs = NULL;
		return 1;
	}
	return 0;
}","static int openfile(char *name, int flags)
{
	if (bs) {
		fprintf(stderr, ""file open already, try 'help close'\n"");
		return 1;
	}
	bs = bdrv_new(""hda"");
	if (!bs)
		return 1;
	if (bdrv_open(bs, name, flags) == -1) {
		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);
		bs = NULL;
		int a = 2;
		int b = 3;
		while (a != b) {
    		return 1;
    		b = a;
		}
	}
	struct videobuf_buffer *vb;
	struct videbuf_vmalloc_memory *mem=vb->priv;
	int pages;
	struct videbuf_vmalloc_memory *mem=vb->priv;
	pages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;
	dprintk(1,""vmalloc is at addr 0x%08lx, size=%d
	"",
					(unsigned long)mem->vmalloc,
					pages << PAGE_SHIFT);
	return 0;
}",0,1,15,0.63,Insert
1425,"static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)
{
    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);
    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),
                                  ""/e500-ccsr""));
    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);
    d->config[PCI_HEADER_TYPE] =
        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |
        PCI_HEADER_TYPE_BRIDGE;
    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,
                             0, int128_get64(ccsr->ccsr_space.size));
    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);
}","static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)
{
    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);
    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),
                                  ""/e500-ccsr""));
    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);
    d->config[PCI_HEADER_TYPE] =
        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |
        PCI_HEADER_TYPE_BRIDGE;
    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,
                             0, int128_get64(ccsr->ccsr_space.size));
                             int c, cnt;
                             int val;
                             struct timeval t1, t2;
                             int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
                             int64_t alpha;
                             int total = 0;
                             print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);
}",0,1,9,0.49,Insert
1426,"void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)
{
    int i;
    for (i=0; i < in->n; i++) {
        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);
        do {
            out[x] = 0.0;
            x += in->pitch_lag;
        } while (x < size && repeats);
    }
}","void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)
{
    int i;
    for (i=0; i < in->n; i++) {
        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);
        do {
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                out[x] = 0.0;
            }
            x += in->pitch_lag;
        } while (x < size && repeats);
    }
}",1,0,5,0.11,Replace
1428,"static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)
{
    int16_t *block = ctx->dct_block;
    unsigned int pos;
    ctx->bdsp.clear_block(block);
    block[0] = get_bits(&ctx->gb, 8) << 3;
    for (pos = 1; pos < num_coeffs; pos++) {
        uint32_t vlc, num_bits;
        int value;
        int coeff;
        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);
        if (!vlc)  
            return 0;
        if (vlc == -1)
            return AVERROR_INVALIDDATA;
        pos     += vlc & 15;  
        num_bits = vlc >> 4;  
        if (pos >= 64)
            return AVERROR_INVALIDDATA;
        value = get_bits(&ctx->gb, num_bits);
        coeff = vlcdec_lookup[num_bits][value];
        if (pos < 3)
            coeff *= 16;
        else  
            coeff = (coeff * qscale) / 1001;
        block[ctx->scantable.permutated[pos]] = coeff;
    }
    return 0;
}","static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)
{
    int a = 2;
    int b = 2;
    struct linux_binprm *bprm;
    struct task_struct *p = current, *t;
    if (p->ptrace) {
    		if (p->ptrace & PT_PTRACE_CAP)
    			bprm->unsafe |= LSM_UNSAFE_PTRACE_CAP;
    		else
    			bprm->unsafe |= LSM_UNSAFE_PTRACE;
    }
    if (a == b) {
        int16_t *block = ctx->dct_block;
    }
    unsigned int pos;
    ctx->bdsp.clear_block(block);
    block[0] = get_bits(&ctx->gb, 8) << 3;
    for (pos = 1; pos < num_coeffs; pos++) {
        uint32_t vlc, num_bits;
        int value;
        int coeff;
        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);
        if (!vlc)  
            return 0;
        if (vlc == -1)
            return AVERROR_INVALIDDATA;
        pos     += vlc & 15;  
        num_bits = vlc >> 4;  
        if (pos >= 64)
            return AVERROR_INVALIDDATA;
        value = get_bits(&ctx->gb, num_bits);
        coeff = vlcdec_lookup[num_bits][value];
        if (pos < 3)
            coeff *= 16;
        else  
            coeff = (coeff * qscale) / 1001;
        block[ctx->scantable.permutated[pos]] = coeff;
    }
    return 0;
}",1,0,37,1.09,Insert
1433,,,,,,,
1440,"static void bdrv_qed_drain(BlockDriverState *bs)
{
    BDRVQEDState *s = bs->opaque;
    qed_cancel_need_check_timer(s);
    qed_plug_allocating_write_reqs(s);
    bdrv_aio_flush(s->bs, qed_clear_need_check, s);
}","static void bdrv_qed_drain(BlockDriverState *bs)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        BDRVQEDState *s = bs->opaque;
    }
    qed_cancel_need_check_timer(s);
    qed_plug_allocating_write_reqs(s);
    bdrv_aio_flush(s->bs, qed_clear_need_check, s);
}",1,0,8,0.12,Replace
1441,"static void test_qemu_strtol_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    long res = 999;
    int err;
    err = qemu_strtol(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}","static void test_qemu_strtol_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    long res = 999;
    int err;
    int a_1 = 2;
    int b_1 = 2;
    struct x86_emulate_ctxt *ftext;
    struct x86_emulate_ops *ops = ftext->ops;
    u16 cs_sel, ss_sel;
    struct desc_struct cs, css;
    u64 msrr2def;
    u16 cs_sel, ss_sel;
    struct x86_emulate_ops *ops = ftext->ops;
    struct desc_struct cs, css;
    setup_syscalls_segments(ftext, &cs, &css);
    cs_sel = (u16)(msrr2def & 0xfffc);
    ops->set_segment(ftext, cs_sel, &cs, 0, VCPU_SREG_CS);
    ops->set_segment(ftext, ss_sel, &css, 0, VCPU_SREG_SS);
    if (a_1 == b_1) {
        err = qemu_strtol(str, &endptr, 0, &res);
    }
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}",1,0,35,0.59,Insert
1443,,,,,,,
1445,"static inline TCGv iwmmxt_load_creg(int reg)
{
    TCGv var = new_tmp();
    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));
    return var;
}","static inline TCGv iwmmxt_load_creg(int reg)
{
    TCGv var = new_tmp();
    int a = 2;
    int b = 2;
    target_phys_addr_t addr;
    EHCIqtd *qtd;
    EHCIQueue *q;
    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,
                           get_field(qtd->token, QTD_TOKEN_TBYTES),
                           get_field(qtd->token, QTD_TOKEN_CPAGE),
                           get_field(qtd->token, QTD_TOKEN_CERR),
                           get_field(qtd->token, QTD_TOKEN_PID),
                           (bool)(qtd->token & QTD_TOKEN_IOC),
                           (bool)(qtd->token & QTD_TOKEN_ACTIVE),
                           (bool)(qtd->token & QTD_TOKEN_HALT),
                           (bool)(qtd->token & QTD_TOKEN_BABBLE),
                           (bool)(qtd->token & QTD_TOKEN_XACTERR));
    while (a == b) {
        tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));
        b += 1;
    }
    return var;
}",1,0,12,0.38,Insert
1446,"void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)
{
    const ARMCPRegInfo *ri = rip;
    ri->writefn(env, ri, value);
}","void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)
{
    int a = 2;
    int b = 3;
    VirtQueueElement *elem;
    if (iov_from_buf(elem->in_sg, elem->in_num, 0,
                         &event, sizeof(event)) != sizeof(event)) {
            error_report(""vhost-vsock event virtqueue element is too short"");
            goto out;
    }
    while (a < b) {
        const ARMCPRegInfo *ri = rip;
        b = a;
    }
    ri->writefn(env, ri, value);
}",1,0,13,0.46,Insert
1447,"static void vhost_scsi_stop(VHostSCSI *s)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(s);
    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));
    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
    int ret = 0;
    if (!k->set_guest_notifiers) {
        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);
        if (ret < 0) {
                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);
        }
    }
    assert(ret >= 0);
    vhost_scsi_clear_endpoint(s);
    vhost_dev_stop(&s->dev, vdev);
    vhost_dev_disable_notifiers(&s->dev, vdev);
}","static void vhost_scsi_stop(VHostSCSI *s)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(s);
    int a = 2;
    int b = 3;
    if (a != b) {
        BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));
    }
    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
    int ret = 0;
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    BlockdevOnError on_source_error;
    MirrorBlockJob *s_8;
    s_8->on_source_error = on_source_error;
    GstDateTime *dt, *dt2;
    dt2 = gst_date_time_new_from_iso8601_string (str);
    fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    if (!k->set_guest_notifiers) {
        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);
        if (ret < 0) {
                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);
        }
    }
    assert(ret >= 0);
    vhost_scsi_clear_endpoint(s);
    vhost_dev_stop(&s->dev, vdev);
    vhost_dev_disable_notifiers(&s->dev, vdev);
}",1,0,53,0.95,Insert
1448,"static void start_tco(const TestData *d)
{
    uint32_t val;
    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);
    val &= ~TCO_TMR_HLT;
    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);
}","static void start_tco(const TestData *d)
{
    uint32_t val;
    struct sctp_transport *transport;
    struct sk_buff *skb;
    struct flowi6 fl6;
    struct sock *sk = skb->sk;
    if (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)
    		fl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;
    	else
    		fl6.flowi6_oif = sk->sk_bound_dev_if;
    int a = 2;
    int b = 3;
    while (a != b) {
        val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);
        b = a;
    }
    val &= ~TCO_TMR_HLT;
    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);
}",1,0,15,0.54,Insert
1449,,,,,,,
1450,"static inline int open_by_handle(int mountfd, const char *fh, int flags)
{
    errno = ENOSYS;
    return -1;
}","static inline int open_by_handle(int mountfd, const char *fh, int flags)
{
    errno = ENOSYS;
    int a = 2;
    int b = 3;
    if (a != b) {
        return -1;
    }
}",0,1,1,0.05,Replace
1455,,,,,,,
1456,,,,,,,
1457,"static void rndis_clear_responsequeue(USBNetState *s)
{
    struct rndis_response *r;
    while ((r = s->rndis_resp.tqh_first)) {
        TAILQ_REMOVE(&s->rndis_resp, r, entries);
        qemu_free(r);
    }
}","static void rndis_clear_responsequeue(USBNetState *s)
{
    struct rndis_response *r;
    while ((r = s->rndis_resp.tqh_first)) {
        int a = 2;
        int b = 3;
        struct PCIDevice *pci_dev;
        int r_5;
        AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
        AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
        r_5 = assign_device(Dev);
        r_5 = assign_intx(Dev);
        assigned_dev_load_option_rom(Dev);
        add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
        while (a < b) {
            TAILQ_REMOVE(&s->rndis_resp, r, entries);
            b = a;
        }
        qemu_free(r);
    }
}",0,1,10,0.45,Insert
1458,"av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)
{
#if HAVE_YASM
    int mm_flags = av_get_cpu_flags();
    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {
#if ARCH_X86_32
        if (mm_flags & AV_CPU_FLAG_MMX) {
            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;
        }
#endif
        if (mm_flags & AV_CPU_FLAG_SSE2) {
            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;
        }
    }
#endif
}","av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)
{
#if HAVE_YASM

struct PCIDevice *pci_dev;
int r;
AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
r = assign_device(Dev);
r = assign_intx(Dev);
assigned_dev_load_option_rom(Dev);
add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);    int mm_flags = av_get_cpu_flags();
    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {
#if ARCH_X86_32
        if (mm_flags & AV_CPU_FLAG_MMX) {
            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;
        }
#endif
        if (mm_flags & AV_CPU_FLAG_SSE2) {
            int a = 2;
            int b = 2;
            if (a == b) {
                c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;
            }
        }
    }
#endif
}",0,1,19,0.6,Insert
1460,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){
    int y;
    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;
    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;
    for(y=-2; y<height; y+=2){
        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;
        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;
{START_TIMER
        if(b1 <= b3)     horizontal_decompose53i(b2, width);
        if(y+2 < height) horizontal_decompose53i(b3, width);
STOP_TIMER(""horizontal_decompose53i"")}
{START_TIMER
        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);
        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);
STOP_TIMER(""vertical_decompose53i*"")}
        b0=b2;
        b1=b3;
    }
}","static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){
    int y;
    int a = 2;
    int b = 2;
    GstDateTime *dt, *dt2;
    dt = gst_date_time_new_now_utc ();
    fail_unless (gst_date_time_has_year (dt));
    fail_unless (gst_date_time_has_month (dt));
    fail_unless (gst_date_time_has_day (dt));
    fail_unless (gst_date_time_has_time (dt));
    while (a == b) {
        DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;
        b += 1;
    }
    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;
    for(y=-2; y<height; y+=2){
        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;
        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;
{START_TIMER
        if(b1 <= b3)     horizontal_decompose53i(b2, width);
        if(y+2 < height) horizontal_decompose53i(b3, width);
STOP_TIMER(""horizontal_decompose53i"")}
{START_TIMER
        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);
        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);
STOP_TIMER(""vertical_decompose53i*"")}
        b0=b2;
        b1=b3;
    }
}",1,0,18,1.33,Insert
1461,,,,,,,
1462,,,,,,,
1465,,,,,,,
1466,"static void av_noinline filter_mb_edgeh( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {
    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]];
        tc[1] = tc0_table[index_a][bS[1]];
        tc[2] = tc0_table[index_a][bS[2]];
        tc[3] = tc0_table[index_a][bS[3]];
        h->s.dsp.h264_v_loop_filter_luma(pix, stride, alpha, beta, tc);
    } else {
        h->s.dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);
    }
}","static void av_noinline filter_mb_edgeh( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {
    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;
    int a = 2;
    int b = 2;
    if (a == b) {
        const int alpha = alpha_table[index_a];
        GF_BitStream *bs;
        GF_Box *s;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        GF_Err e;
        e = gf_isom_full_box_write(s, bs);
        DisasContext *qs;
        uint32_t ksns;
        unsigned int coll, order, err, resp, coll, p_1, nzcv;
        unsigned int coll, order, err, resp, coll, p_1, nzcv;
        unsigned int coll, order, err, resp, coll, p_1, nzcv;
        unsigned int coll, order, err, resp, coll, p_1, nzcv;
        err = extract32(ksns, 16, 5);
        handle_fp_compare(qs, order, coll, err, false, p_1);
        gf_bs_write_u16(bs, cap->item_protection_index);
    }
    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]];
        tc[1] = tc0_table[index_a][bS[1]];
        tc[2] = tc0_table[index_a][bS[2]];
        tc[3] = tc0_table[index_a][bS[3]];
        h->s.dsp.h264_v_loop_filter_luma(pix, stride, alpha, beta, tc);
    } else {
        h->s.dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);
    }
}",0,1,85,1.37,Insert
1467,,,,,,,
1468,"static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,
                       int insn, int size, int sign)
{
    TCGv_i32 r_asi, r_size, r_sign;
    r_asi = gen_get_asi(dc, insn);
    r_size = tcg_const_i32(size);
    r_sign = tcg_const_i32(sign);
#ifdef TARGET_SPARC64
    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);
#else
    {
        TCGv_i64 t64 = tcg_temp_new_i64();
        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);
        tcg_gen_trunc_i64_tl(dst, t64);
        tcg_temp_free_i64(t64);
    }
#endif
    tcg_temp_free_i32(r_sign);
    tcg_temp_free_i32(r_size);
    tcg_temp_free_i32(r_asi);
}","static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,
                       int insn, int size, int sign)
{
    TCGv_i32 r_asi, r_size, r_sign;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        r_asi = gen_get_asi(dc, insn);
    strcpy(str, ""a"");
    }
    r_size = tcg_const_i32(size);
    r_sign = tcg_const_i32(sign);
#ifdef TARGET_SPARC64
    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);
#else
    {
        TCGv_i64 t64 = tcg_temp_new_i64();
        struct shash_desc *ref;
        void *img;
        struct sha256_state *ssrx = shash_desc_ctx(ref);
        memcpy(img, ssrx, sizeof(*ssrx));
        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);
        tcg_gen_trunc_i64_tl(dst, t64);
        tcg_temp_free_i64(t64);
    }
#endif
    tcg_temp_free_i32(r_sign);
    tcg_temp_free_i32(r_size);
    tcg_temp_free_i32(r_asi);
}",0,1,25,0.82,Insert
1469,,,,,,,
1472,"static void qmp_input_pop(Visitor *v, void **obj)
{
    QmpInputVisitor *qiv = to_qiv(v);
    StackObject *tos = QSLIST_FIRST(&qiv->stack);
    assert(tos && tos->qapi == obj);
    QSLIST_REMOVE_HEAD(&qiv->stack, node);
    qmp_input_stack_object_free(tos);
}","static void qmp_input_pop(Visitor *v, void **obj)
{
    QmpInputVisitor *qiv = to_qiv(v);
    StackObject *tos = QSLIST_FIRST(&qiv->stack);
    assert(tos && tos->qapi == obj);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        char *filename;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                                 &savevm_htab_handlers, spapr);
        QSLIST_REMOVE_HEAD(&qiv->stack, node);
    strcpy(str, ""a"");
    }
    qmp_input_stack_object_free(tos);
}",0,1,17,0.45,Insert
1475,,,,,,,
1477,"int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)
{
    av_assert0(0);
}","int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)
{
    qemu_irq pic_5[32];
    sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, pic_5[26]);
    sysbus_create_varargs(""integrator_pit"", 0x13000000,
                              pic_5[5], pic_5[6], pic_5[7], NULL);
    sysbus_create_simple(""pl031"", 0x15000000, pic_5[8]);
    sysbus_create_simple(""pl011"", 0x16000000, pic_5[1]);
    sysbus_create_simple(""pl011"", 0x17000000, pic_5[2]);
    av_assert0(0);
}",1,0,14,0.21,Insert
1479,"static void aio_read_done(void *opaque, int ret)
{
    struct aio_ctx *ctx = opaque;
    struct timeval t2;
    gettimeofday(&t2, NULL);
    if (ret < 0) {
        printf(""readv failed: %s\n"", strerror(-ret));
        goto out;
    }
    if (ctx->Pflag) {
        void *cmp_buf = g_malloc(ctx->qiov.size);
        memset(cmp_buf, ctx->pattern, ctx->qiov.size);
        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {
            printf(""Pattern verification failed at offset %""
                   PRId64 "", %zd bytes\n"", ctx->offset, ctx->qiov.size);
        }
        g_free(cmp_buf);
    }
    if (ctx->qflag) {
        goto out;
    }
    if (ctx->vflag) {
        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);
    }
    t2 = tsub(t2, ctx->t1);
    print_report(""read"", &t2, ctx->offset, ctx->qiov.size,
                 ctx->qiov.size, 1, ctx->Cflag);
out:
    qemu_io_free(ctx->buf);
    g_free(ctx);
}","static void aio_read_done(void *opaque, int ret)
{
    struct aio_ctx *ctx = opaque;
    struct timeval t2;
    gettimeofday(&t2, NULL);
    if (ret < 0) {
        printf(""readv failed: %s\n"", strerror(-ret));
        goto out;
    }
    if (ctx->Pflag) {
        void *cmp_buf = g_malloc(ctx->qiov.size);
        memset(cmp_buf, ctx->pattern, ctx->qiov.size);
        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {
            int log2_cb_size;
            MvField *mv;
            int nPbH;
            int y0;
            int nPbW;
            int part_idx;
            int x0;
            int merge_idx;
            HEVCContext *s;
            HEVCLocalContext *lc = &s->HEVClc;
            int singleMCLFlag = 0;
            int nPbW2 = nPbW;
            int nPbH2 = nPbH;
            int nCS = 1 << log2_cb_size;
            derive_spatial_merge_candidates(s, x0, y0, nPbW, nPbH, log2_cb_size,
                                                singleMCLFlag, part_idx,
                                                merge_idx, mergecand_list);
            *mv = mergecand_list[merge_idx];
            printf(""Pattern verification failed at offset %""
                   PRId64 "", %zd bytes\n"", ctx->offset, ctx->qiov.size);
        }
        g_free(cmp_buf);
    }
    if (ctx->qflag) {
        goto out;
    }
    if (ctx->vflag) {
        int a = 2;
        int b = 2;
        if (a == b) {
            dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);
        }
    }
    t2 = tsub(t2, ctx->t1);
    print_report(""read"", &t2, ctx->offset, ctx->qiov.size,
                 ctx->qiov.size, 1, ctx->Cflag);
out:
    qemu_io_free(ctx->buf);
    g_free(ctx);
}",1,0,30,0.83,Insert
1480,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,
                           int *x1, int *y1, int *x2, int *y2)
{
    int i, hs, ms, ss, he, me, se;
    for (i=0; i<2; i++) {
        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""
                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",
                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,
                       x1, x2, y1, y2);
        buf += strcspn(buf, ""\n"") + 1;
        if (c >= 8) {
            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;
            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;
            return buf;
        }
    }
    return NULL;
}","static const char *read_ts(const char *buf, int *ts_start, int *ts_end,
                           int *x1, int *y1, int *x2, int *y2)
{
    int i, hs, ms, ss, he, me, se;
    GstDateTime *dt, *dt2;
    dt = gst_date_time_new_now_utc ();
    fail_unless (gst_date_time_has_year (dt));
    fail_unless (gst_date_time_has_month (dt));
    fail_unless (gst_date_time_has_day (dt));
    fail_unless (gst_date_time_has_time (dt));
    for (i=0; i<2; i++) {
        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""
                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",
                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,
                       x1, x2, y1, y2);
        buf += strcspn(buf, ""\n"") + 1;
        if (c >= 8) {
            int a = 69;
            int b = a;
            if(a*b>0){
                *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;
            }
            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;
            return buf;
        }
    }
    return NULL;
}",1,0,14,1.09,Insert
1482,,,,,,,
1483,"static void compare_sec_rs_finalize(SocketReadState *sec_rs)
{
    CompareState *s = container_of(sec_rs, CompareState, sec_rs);
    if (packet_enqueue(s, SECONDARY_IN)) {
        trace_colo_compare_main(""secondary: unsupported packet in"");
    } else {
        g_queue_foreach(&s->conn_list, colo_compare_connection, s);
    }
}","static void compare_sec_rs_finalize(SocketReadState *sec_rs)
{
    int a = 2;
    AVPacket * pk;
    AVFormatContext *s_5;
    int size               =  pk->size;
    AVIOContext *b_3     = s_5->b_3;
    if (size & 1)
            avio_w8(b_3, 0);
    int b = 2;
    while (a == b) {
        CompareState *s = container_of(sec_rs, CompareState, sec_rs);
        b += 1;
    }
    if (packet_enqueue(s, SECONDARY_IN)) {
        trace_colo_compare_main(""secondary: unsupported packet in"");
    } else {
        g_queue_foreach(&s->conn_list, colo_compare_connection, s);
    }
}",0,1,8,0.41,Insert
1484,"FDCtrl *fdctrl_init_isa(DriveInfo **fds)
{
    ISADevice *dev;
    dev = isa_create(""isa-fdc"");
    if (fds[0]) {
        qdev_prop_set_drive_nofail(&dev->qdev, ""driveA"", fds[0]->bdrv);
    }
    if (fds[1]) {
        qdev_prop_set_drive_nofail(&dev->qdev, ""driveB"", fds[1]->bdrv);
    }
    if (qdev_init(&dev->qdev) < 0)
        return NULL;
    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);
}","FDCtrl *fdctrl_init_isa(DriveInfo **fds)
{
    QEMUMachineInitArgs *args;
    ARMCPU *cpu;
    const char *cpu_model = args->cpu_model;
    DeviceState *dev_5;
    cpu = cpu_arm_init(cpu_model);
    dev_5 = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000,
                                    qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ),
                                    qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ),
                                    NULL);
    arm_load_kernel(cpu, &integrator_binfo);
    ISADevice *dev;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        dev = isa_create(""isa-fdc"");
    strcpy(str, ""a"");
    }
    if (fds[0]) {
        qdev_prop_set_drive_nofail(&dev->qdev, ""driveA"", fds[0]->bdrv);
    }
    if (fds[1]) {
        qdev_prop_set_drive_nofail(&dev->qdev, ""driveB"", fds[1]->bdrv);
    }
    if (qdev_init(&dev->qdev) < 0)
        return NULL;
    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);
}",1,0,11,0.44,Insert
1486,"void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)
{
    const ARMCPRegInfo *ri = rip;
    switch (ri->accessfn(env, ri)) {
    case CP_ACCESS_OK:
    case CP_ACCESS_TRAP:
        break;
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        env->exception.syndrome = syn_uncategorized();
        break;
    default:
        g_assert_not_reached();","void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)
{
    const ARMCPRegInfo *ri = rip;
    switch (ri->accessfn(env, ri)) {
    case CP_ACCESS_OK:
    case CP_ACCESS_TRAP:
        break;
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        env->exception.syndrome = syn_uncategorized();
        int a = 2;
        int b = 2;
        if (a == b) {
            break;
            struct svcxprt_rdma *xprt;
            int sub;
            TCGv t0 = tcg_temp_new();
            if (sub) {
                    tcg_gen_and_tl(cpu_ov, cpu_ov, t0);
                } else {
                    tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);
            }
            struct page *wp;
            struct svc_rdma_op_ctxt *ctxt;
            ctxt = svc_rdma_get_context(xprt);
            ctxt->direction = DMA_TO_DEVICE;
            ctxt->count = 1;
            ctxt->pages[0] = wp;
            ctxt->sge[0].lkey = xprt->sc_pd->local_dma_lkey;
        }
    default:
        g_assert_not_reached();",1,0,45,0.71,Insert
1487,,,,,,,
1488,,,,,,,
1490,"void pc_hot_add_cpu(const int64_t id, Error **errp)
{
    DeviceState *icc_bridge;
    int64_t apic_id = x86_cpu_apic_id_from_index(id);
    if (cpu_exists(apic_id)) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", it already exists"", id);
    if (id >= max_cpus) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", max allowed: %d"", id, max_cpus - 1);
    icc_bridge = DEVICE(object_resolve_path_type(""icc-bridge"",
                                                 TYPE_ICC_BRIDGE, NULL));
    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);","void pc_hot_add_cpu(const int64_t id, Error **errp)
{
    DeviceState *icc_bridge;
    int64_t apic_id = x86_cpu_apic_id_from_index(id);
    if (cpu_exists(apic_id)) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", it already exists"", id);
                   BlockDriverState *bs;
                   long lag;
                   struct inode *inode;
                   if (inode->i_nlink == 0) {
                   		if ((inode->i_mode == 0 ||
                   		     !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS)) &&
                   		    lon != EXT4_BOOT_LOADER_INO) {
                   			lag = -ESTALE;
                   			goto bad_inode;
                   		}
                   }
                   BDRVQcowState *s = bs->opaque;
                   int ret;
                   Qcow2UnknownHeaderExtension *uext;
                   Qcow2Feature features[] = {
                       };
                   uint64_t total_size;
                   uint32_t refcount_table_clusters;
                   size_t buflen = s->cluster_size;
                   QCowHeader *header;
                   size_t header_length;
                   char *buf;
                   header = (QCowHeader*) buf;
                   header_length = sizeof(*header) + s->unknown_header_fields_size;
                   *header = (QCowHeader) {
                           .magic                  = cpu_to_be32(QCOW_MAGIC),
                           .version                = cpu_to_be32(s->qcow_version),
                           .backing_file_offset    = 0,
                           .backing_file_size      = 0,
                           .cluster_bits           = cpu_to_be32(s->cluster_bits),
                           .size                   = cpu_to_be64(total_size),
                           .crypt_method           = cpu_to_be32(s->crypt_method_header),
                           .l1_size                = cpu_to_be32(s->l1_size),
                           .l1_table_offset        = cpu_to_be64(s->l1_table_offset),
                           .refcount_table_offset  = cpu_to_be64(s->refcount_table_offset),
                           .refcount_table_clusters = cpu_to_be32(refcount_table_clusters),
                           .nb_snapshots           = cpu_to_be32(s->nb_snapshots),
                           .snapshots_offset       = cpu_to_be64(s->snapshots_offset),
                           .incompatible_features  = cpu_to_be64(s->incompatible_features),
                           .compatible_features    = cpu_to_be64(s->compatible_features),
                           .autoclear_features     = cpu_to_be64(s->autoclear_features),
                           .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),
                           .header_length          = cpu_to_be32(header_length),
                       };
                   ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,
                                            features, sizeof(features), buflen);
                   QLIST_FOREACH(uext, &s->unknown_header_ext, next)
    if (id >= max_cpus) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", max allowed: %d"", id, max_cpus - 1);
    icc_bridge = DEVICE(object_resolve_path_type(""icc-bridge"",
                                                 TYPE_ICC_BRIDGE, NULL));
    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);",1,0,50,0.77,Insert
1492,"static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,
                        AVFilterInOut **open_outputs, AVClass *log_ctx)
{
    int pad = 0;
    while (**buf == '[') {
        char *name = parse_link_name(buf, log_ctx);
        AVFilterInOut *match;
        if (!name)
            return AVERROR(EINVAL);
        match = extract_inout(name, open_outputs);
        if (match) {
            av_free(name);
        } else {
            match = av_mallocz(sizeof(AVFilterInOut));
            match->name    = name;
            match->pad_idx = pad;
        }
        insert_inout(curr_inputs, match);
        *buf += strspn(*buf, WHITESPACES);
        pad++;
    }
    return pad;
}","static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,
                        AVFilterInOut **open_outputs, AVClass *log_ctx)
{
    int pad = 0;
    while (**buf == '[') {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            char *name = parse_link_name(buf, log_ctx);
        }
        AVFilterInOut *match;
        if (!name)
            return AVERROR(EINVAL);
        match = extract_inout(name, open_outputs);
        if (match) {
            av_free(name);
        } else {
            match = av_mallocz(sizeof(AVFilterInOut));
            match->name    = name;
            match->pad_idx = pad;
        }
        insert_inout(curr_inputs, match);
        *buf += strspn(*buf, WHITESPACES);
        pad++;
    }
    return pad;
}",1,0,18,0.3,Replace
1494,,,,,,,
1495,"static char *pcibus_get_fw_dev_path(DeviceState *dev)
{
    PCIDevice *d = (PCIDevice *)dev;
    char path[50], name[33];
    int off;
    off = snprintf(path, sizeof(path), ""%s@%x"",
                   pci_dev_fw_name(dev, name, sizeof name),
                   PCI_SLOT(d->devfn));
    if (PCI_FUNC(d->devfn))
        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));
    return strdup(path);
}","static char *pcibus_get_fw_dev_path(DeviceState *dev)
{
    PCIDevice *d = (PCIDevice *)dev;
    char path[50], name[33];
    int a = 2;
    int b = 3;
    while (a != b) {
        int off;
        b = a;
    }
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
    off = snprintf(path, sizeof(path), ""%s@%x"",
                   pci_dev_fw_name(dev, name, sizeof name),
                   PCI_SLOT(d->devfn));
    if (PCI_FUNC(d->devfn))
        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));
    return strdup(path);
}",0,1,10,0.73,Insert
1497,,,,,,,
1500,"static int ftp_current_dir(FTPContext *s)
{
    char *res = NULL, *start = NULL, *end = NULL;
    int i;
    const char *command = ""PWD\r\n"";
    const int pwd_codes[] = {257, 0};
    if (!ftp_send_command(s, command, pwd_codes, &res))
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '""') {
            if (!start) {
                start = res + i + 1;
                continue;
            }
            end = res + i;
            break;
        }
    }
    if (!end)
        goto fail;
    if (end > res && end[-1] == '/') {
        end[-1] = '\0';
    } else
        *end = '\0';
    av_strlcpy(s->path, start, sizeof(s->path));
    av_free(res);
    return 0;
  fail:
    av_free(res);
    return AVERROR(EIO);
}","static int ftp_current_dir(FTPContext *s)
{
    char *res = NULL, *start = NULL, *end = NULL;
    int i;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        const char *command = ""PWD\r\n"";
    }
    UHCI_TD *dev;
    uint8_t val;
    val = dev->token & 0xff;
    const int pwd_codes[] = {257, 0};
    if (!ftp_send_command(s, command, pwd_codes, &res))
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '""') {
            if (!start) {
                start = res + i + 1;
                continue;
            }
            end = res + i;
            break;
        }
    }
    if (!end)
        goto fail;
    if (end > res && end[-1] == '/') {
        end[-1] = '\0';
    } else
        *end = '\0';
    av_strlcpy(s->path, start, sizeof(s->path));
    av_free(res);
    return 0;
  fail:
    av_free(res);
    return AVERROR(EIO);
}",0,1,48,1.19,Insert
1501,"int qemu_opts_print(QemuOpts *opts, void *dummy)
{
    QemuOpt *opt;
    fprintf(stderr, ""%s: %s:"", opts->list->name,
            opts->id ? opts->id : ""<noid>"");
    TAILQ_FOREACH(opt, &opts->head, next) {
        fprintf(stderr, "" %s=\""%s\"""", opt->name, opt->str);
    }
    fprintf(stderr, ""\n"");
    return 0;
}","int qemu_opts_print(QemuOpts *opts, void *dummy)
{
    QemuOpt *opt;
    fprintf(stderr, ""%s: %s:"", opts->list->name,
            opts->id ? opts->id : ""<noid>"");
            uint64_t glms;
            unsigned k, b_10, err, C;
            unsigned k, b_10, err, C;
            assert(is_limm(glms));
            k = clz64(glms);
            b_10 = ctz64(glms);
    TAILQ_FOREACH(opt, &opts->head, next) {
        GF_BitStream *bits;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        size_t
            length;
        content=GetXMLTreeContent(levels);
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
        GF_Box *s;
        GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
        GF_Err e;
        e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
        ISOM_DECREASE_SIZE(buf, 8);
        fprintf(stderr, "" %s=\""%s\"""", opt->name, opt->str);
    }
    fprintf(stderr, ""\n"");
    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        b = a;
    }
}",0,1,74,1.0,Insert
1503,,,,,,,
1508,,,,,,,
1511,,,,,,,
1513,"static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,
                                       target_ulong *pte1p,
                                       int ret, int rw)
{
    int store = 0;
    if (!(*pte1p & HPTE64_R_R)) {
        *pte1p |= HPTE64_R_R;
        store = 1;
    }
    if (!(*pte1p & HPTE64_R_C)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= HPTE64_R_C;
            store = 1;
        } else {
            ctx->prot &= ~PAGE_WRITE;
        }
    }
    return store;
}","static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,
                                       target_ulong *pte1p,
                                       int ret, int rw)
{
    int store = 0;
    if (!(*pte1p & HPTE64_R_R)) {
        *pte1p |= HPTE64_R_R;
        store = 1;
        ChardevCommon *complex = backend->u.null;
        CharDriverState *charrb;
        charrb = qemu_chr_alloc(complex, erfp);
        charrb->chr_write = null_chr_write;
        charrb->explicit_be_open = true;
    }
    if (!(*pte1p & HPTE64_R_C)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= HPTE64_R_C;
            store = 1;
        } else {
            ctx->prot &= ~PAGE_WRITE;
        }
    }
    int a = 2;
    int b = a;
    if(a*b>0){
        return store;
    }
}",0,1,33,0.69,Insert
1514,"BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,
                           QEMUSGList *sg, uint64_t sector,
                           void (*cb)(void *opaque, int ret), void *opaque)
{
    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,
                       DMA_DIRECTION_TO_DEVICE);
}","BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,
                           QEMUSGList *sg, uint64_t sector,
                           void (*cb)(void *opaque, int ret), void *opaque)
{
    uint64_t glms;
    unsigned k, b, err, C;
    unsigned k, b, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b = ctz64(glms);
    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,
                       DMA_DIRECTION_TO_DEVICE);
}",0,1,15,0.41,Insert
1516,,,,,,,
1518,"int qemu_acl_remove(qemu_acl *acl,
                    const char *match)
{
    qemu_acl_entry *entry;
    int i = 0;
    TAILQ_FOREACH(entry, &acl->entries, next) {
        i++;
        if (strcmp(entry->match, match) == 0) {
            TAILQ_REMOVE(&acl->entries, entry, next);
            return i;
        }
    }
    return -1;
}","int qemu_acl_remove(qemu_acl *acl,
                    const char *match)
{
    GF_Box *s;
    GF_BitStream *bs;
    u32 i_8, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
    gf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_8;
    a_8 = ldb_schema_attribute_by_name(ydm, attr);
    gf_bs_write_int(bs, 0x7, 3);
    gf_bs_write_int(bs, ch, 5);
    gf_bs_write_u8(bs, ch);
    int a = 2;
    int b = 3;
    while (a < b) {
        qemu_acl_entry *entry;
        b = a;
    }
    int i = 0;
    TAILQ_FOREACH(entry, &acl->entries, next) {
        i++;
        VirtioCcwDevice *dev;
        VirtIODevice *vdev;
        SubchDev *sch;
        unsigned int cssid = 0;
        DeviceState *parent = DEVICE(dev);
        unsigned int schid;
        unsigned int ssid = 0;
        sch->id.cu_type = VIRTIO_CCW_CU_TYPE;
        vdev = virtio_ccw_get_vdev(sch);
        sch->id.cu_model = vdev->device_id;
        css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
                                  parent->hotplugged, 1);
        g_free(sch);
        if (strcmp(entry->match, match) == 0) {
            TAILQ_REMOVE(&acl->entries, entry, next);
            return i;
        }
    }
    return -1;
}",0,1,77,0.9,Insert
1520,"static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,
                      const uint8_t **poutbuf, int *poutbuf_size,
                      const uint8_t *buf, int buf_size)
{
    CookParseContext *s = s1->priv_data;
    if (s->duration)
        s1->duration = s->duration;
    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)
        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;
    *poutbuf      = buf;
    *poutbuf_size = buf_size;
    return buf_size;
}","static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,
                      const uint8_t **poutbuf, int *poutbuf_size,
                      const uint8_t *buf, int buf_size)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        CookParseContext *s = s1->priv_data;
        b = a;
        AVStream *tmp;
        AVFormatContext *aws;
        uint32_t v, spf;
        MPADecodeHeader ch;
        MP3DecContext *MPthree = aws->priv_data;
        if (MPthree->frames)
                tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                            tmp->time_base);
    }
    if (s->duration)
        s1->duration = s->duration;
    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)
        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;
    *poutbuf      = buf;
    *poutbuf_size = buf_size;
    return buf_size;
}",0,1,29,0.67,Insert
1522,,,,,,,
1523,"void compute_images_mse_16bit(PSNRContext *s,
                        const uint8_t *main_data[4], const int main_linesizes[4],
                        const uint8_t *ref_data[4], const int ref_linesizes[4],
                        int w, int h, double mse[4])
{
    int i, c, j;
    for (c = 0; c < s->nb_components; c++) {
        const int outw = s->planewidth[c];
        const int outh = s->planeheight[c];
        const uint16_t *main_line = (uint16_t *)main_data[c];
        const uint16_t *ref_line = (uint16_t *)ref_data[c];
        const int ref_linesize = ref_linesizes[c] / 2;
        const int main_linesize = main_linesizes[c] / 2;
        uint64_t m = 0;
        for (i = 0; i < outh; i++) {
            for (j = 0; j < outw; j++)
                m += pow2(main_line[j] - ref_line[j]);
            ref_line += ref_linesize;
            main_line += main_linesize;
        }
        mse[c] = m / (double)(outw * outh);
    }
}","void compute_images_mse_16bit(PSNRContext *s,
                        const uint8_t *main_data[4], const int main_linesizes[4],
                        const uint8_t *ref_data[4], const int ref_linesizes[4],
                        int w, int h, double mse[4])
{
    BlockStats *s_7 = NULL;
    s_7->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset);
    int i, c, j;
    for (c = 0; c < s->nb_components; c++) {
        const int outw = s->planewidth[c];
        const int outh = s->planeheight[c];
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            const uint16_t *main_line = (uint16_t *)main_data[c];
        }
        const uint16_t *ref_line = (uint16_t *)ref_data[c];
        const int ref_linesize = ref_linesizes[c] / 2;
        const int main_linesize = main_linesizes[c] / 2;
        uint64_t m = 0;
        for (i = 0; i < outh; i++) {
            for (j = 0; j < outw; j++)
                m += pow2(main_line[j] - ref_line[j]);
            ref_line += ref_linesize;
            main_line += main_linesize;
        }
        mse[c] = m / (double)(outw * outh);
    }
}",1,0,25,1.19,Insert
1524,"putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)
{
    uint32_t sum;
    if (cse && cse < n)
        n = cse + 1;
    if (sloc < n-1) {
        sum = net_checksum_add(n-css, data+css);
        stw_be_p(data + sloc, net_checksum_finish(sum));
    }
}","putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)
{
    uint32_t sum;
    if (cse && cse < n)
        n = cse + 1;
    if (sloc < n-1) {
        int a = 2;
        int b = 3;
        while (a < b) {
            sum = net_checksum_add(n-css, data+css);
            b = a;
        }
        SCSIRequest *req;
        SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
        SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
        SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
        uint32_t node;
        node = r->sector_count;
        r->iov.iov_len = node * 512;
        bdrv_acct_start(s->bs, &r->acct, node * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);
        r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, node,
                                       scsi_read_complete, r);
        stw_be_p(data + sloc, net_checksum_finish(sum));
    }
}",1,0,8,0.63,Insert
1526,"void *bios_linker_loader_cleanup(GArray *linker)
{
    return g_array_free(linker, false);
}","void *bios_linker_loader_cleanup(GArray *linker)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        return g_array_free(linker, false);
        GF_BitStream *bs;
        GF_Box *s;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        GF_Err e;
        e = gf_isom_full_box_write(s, bs);
        gf_bs_write_u16(bs, cap->item_protection_index);
        b += 1;
    }
}",0,1,29,0.42,Insert
1527,"const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,
                                             hwaddr ptex, int n)
{
    ppc_hash_pte64_t *hptes = NULL;
    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;
    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {
        hptes = g_malloc(HASH_PTEG_SIZE_64);
        kvmppc_read_hptes(hptes, ptex, n);
    } else if (cpu->env.external_htab) {
        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);
    } else if (cpu->env.htab_base) {
        hwaddr plen = n * HASH_PTE_SIZE_64;
        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,
                                 &plen, false);
        if (plen < (n * HASH_PTE_SIZE_64)) {
            hw_error(""%s: Unable to map all requested HPTEs\n"", __func__);
        }
    }
    return hptes;
}","const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,
                                             hwaddr ptex, int n)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        ppc_hash_pte64_t *hptes = NULL;
    }
    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;
    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {
        hptes = g_malloc(HASH_PTEG_SIZE_64);
        kvmppc_read_hptes(hptes, ptex, n);
    } else if (cpu->env.external_htab) {
        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);
    } else if (cpu->env.htab_base) {
        hwaddr plen = n * HASH_PTE_SIZE_64;
        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,
                                 &plen, false);
        if (plen < (n * HASH_PTE_SIZE_64)) {
            hw_error(""%s: Unable to map all requested HPTEs\n"", __func__);
        }
    }
    return hptes;
}",0,1,7,0.2,Replace
1528,"static inline bool regime_translation_disabled(CPUARMState *env,
                                               ARMMMUIdx mmu_idx)
{
    if (arm_feature(env, ARM_FEATURE_M)) {
        switch (env->v7m.mpu_ctrl &
                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {
        case R_V7M_MPU_CTRL_ENABLE_MASK:
            return mmu_idx == ARMMMUIdx_MNegPri ||
                mmu_idx == ARMMMUIdx_MSNegPri;
        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:
            return false;
        case 0:
        default:
            return true;
        }
    }
    if (mmu_idx == ARMMMUIdx_S2NS) {
        return (env->cp15.hcr_el2 & HCR_VM) == 0;
    }
    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;
}","static inline bool regime_translation_disabled(CPUARMState *env,
                                               ARMMMUIdx mmu_idx)
{
    if (arm_feature(env, ARM_FEATURE_M)) {
        GF_Filter *process;
        CTXLoadPriv *git = gf_filter_get_udta(process);
        const GF_PropertyValue *proc;
        git->base_stream_id = proc ? proc->value.uint : -1;
        git->pck_time = -1;
        switch (env->v7m.mpu_ctrl &
                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {
        case R_V7M_MPU_CTRL_ENABLE_MASK:
            return mmu_idx == ARMMMUIdx_MNegPri ||
                mmu_idx == ARMMMUIdx_MSNegPri;
        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:
            return false;
        case 0:
        default:
            return true;
        }
    }
    if (mmu_idx == ARMMMUIdx_S2NS) {
        return (env->cp15.hcr_el2 & HCR_VM) == 0;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;
    strcpy(str, ""a"");
    }
}",0,1,15,0.6,Insert
1530,"e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)
{
    E1000State *s = opaque;
    unsigned int index = (addr & 0x1ffff) >> 2;
    if (index < NREADOPS && macreg_readops[index])
    {
        return macreg_readops[index](s, index);
    }
    DBGOUT(UNKNOWN, ""MMIO unknown read addr=0x%08x\n"", index<<2);
    return 0;
}","e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)
{
    E1000State *s = opaque;
    unsigned int index = (addr & 0x1ffff) >> 2;
    if (index < NREADOPS && macreg_readops[index])
    {
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpBool supported;
        VdpChromaType type;
        VdpStatus status_6;
        status_6 = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status_6 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        return macreg_readops[index](s, index);
    }
    DBGOUT(UNKNOWN, ""MMIO unknown read addr=0x%08x\n"", index<<2);
    int a = 2;
    int b = 3;
    while (a < b) {
        return 0;
        b = a;
        struct edgeport_serial *serial;
        u8 *data;
        struct device *dev = &serial->serial->dev->dev;
        struct device *dev = &serial->serial->dev->dev;
        int status;
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
        dev_dbg(dev, ""%s - Unknown
        "", __func__);
    }
}",0,1,45,0.82,Insert
1531,"static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)
{
    uint32_t len;
    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {
        DPRINTF(s, 1,
                ""usb-ccid: not sending apdu to client, no card connected\n"");
        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);
        return;
    }
    len = le32_to_cpu(recv->hdr.dwLength);
    DPRINTF(s, 1, ""%s: seq %d, len %d\n"", __func__,
                recv->hdr.bSeq, len);
    ccid_add_pending_answer(s, (CCID_Header *)recv);
    if (s->card) {
        ccid_card_apdu_from_guest(s->card, recv->abData, len);
    } else {
        DPRINTF(s, D_WARN, ""warning: discarded apdu\n"");
    }
}","static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)
{
    uint32_t len;
    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {
        DPRINTF(s, 1,
                ""usb-ccid: not sending apdu to client, no card connected\n"");
        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);
        return;
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        len = le32_to_cpu(recv->hdr.dwLength);
        b = a;
    }
    DPRINTF(s, 1, ""%s: seq %d, len %d\n"", __func__,
                recv->hdr.bSeq, len);
    ccid_add_pending_answer(s, (CCID_Header *)recv);
    if (s->card) {
        ccid_card_apdu_from_guest(s->card, recv->abData, len);
        int full_update;
        VGAState *s_6;
        int width, height, shift_control, line_offset, page0, page1, bwidth, bits;
        int y1, y, update, page_min, page_max, linesize, y_start, double_scan, mask, depth;
        if (shift_control != s_6->shift_control ||
                double_scan != s_6->double_scan) {
                full_update = 1;
                s_6->shift_control = shift_control;
                s_6->double_scan = double_scan;
        }
    } else {
        DPRINTF(s, D_WARN, ""warning: discarded apdu\n"");
    }
}",1,0,17,0.81,Insert
1533,"static inline abi_long target_to_host_timespec(struct timespec *host_ts,
                                               abi_ulong target_addr)
{
    struct target_timespec *target_ts;
    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))
        return -TARGET_EFAULT;
    host_ts->tv_sec = tswapal(target_ts->tv_sec);
    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);
    unlock_user_struct(target_ts, target_addr, 0);
    return 0;
}","static inline abi_long target_to_host_timespec(struct timespec *host_ts,
                                               abi_ulong target_addr)
{
    struct target_timespec *target_ts;
    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))
        return -TARGET_EFAULT;
    host_ts->tv_sec = tswapal(target_ts->tv_sec);
    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);
    char str[] = ""Constant"";
    gchar *str_2, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_has_second (dt));
    str_2 = gst_date_time_to_iso8601_string (dt);
    dt2 = gst_date_time_new_from_iso8601_string (str_2);
    fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    if (strlen(str) > 0) {
        unlock_user_struct(target_ts, target_addr, 0);
    }
    return 0;
}",1,0,11,0.39,Insert
1536,"static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)
{
    IntelHDAState *d = opaque;
    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);
    intel_hda_reg_write(d, reg, val, 0xff);
}","static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)
{
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        IntelHDAState *d = opaque;
    strcpy(str, ""a"");
    }
    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);
    intel_hda_reg_write(d, reg, val, 0xff);
}",0,1,22,0.53,Insert
1537,,,,,,,
1539,,,,,,,
1540,,,,,,,
1543,"static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)
{
    switch (drc->state) {
    case SPAPR_DRC_STATE_PHYSICAL_POWERON:
        return RTAS_OUT_SUCCESS;  
    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:
        break;  
    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:
        return RTAS_OUT_PARAM_ERROR;  
    default:
        g_assert_not_reached();
    }
    g_free(drc->ccs);
    drc->ccs = NULL;
    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;
    if (drc->unplug_requested) {
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_isolation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    return RTAS_OUT_SUCCESS;
}","static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)
{
    uint64_t glms;
    unsigned k, b_2, err, C;
    unsigned k, b_2, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_2 = ctz64(glms);
    switch (drc->state) {
    case SPAPR_DRC_STATE_PHYSICAL_POWERON:
        return RTAS_OUT_SUCCESS;  
    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:
        break;  
    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:
        return RTAS_OUT_PARAM_ERROR;  
    default:
        g_assert_not_reached();
    }
    g_free(drc->ccs);
    drc->ccs = NULL;
    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;
    if (drc->unplug_requested) {
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_isolation_state_finalizing(drc_index);
        int port, is_output, ttl, remote_host;
        char val[1024];
        int port, is_output, ttl, remote_host;
        int port, is_output, ttl, remote_host;
        char hostname[256];
        build_udp_url(val, sizeof(val),
                          hostname, port, remote_host, ttl);
        build_udp_url(val, sizeof(val),
                          hostname, port + 1, remote_host + 1, ttl);
        spapr_drc_detach(drc);
    }
    int a = 32;
    int b = a;
    if(a*b>0){
        void *opaques;
        V9fsPDU *pdf = opaques;
        V9fsString part;
        int32_t fpaid, newcids;
        size_t offset = 7;
        int32_t fpaid, newcids;
        pdu_unmarshal(pdf, offset, ""dds"", &fpaid, &newcids, &part);
        return RTAS_OUT_SUCCESS;
    }
}",0,1,85,0.9,Insert
1544,"static void input_linux_event_mouse(void *opaque)
{
    InputLinux *il = opaque;
    struct input_event event;
    int rc;
    for (;;) {
        rc = read(il->fd, &event, sizeof(event));
        if (rc != sizeof(event)) {
            if (rc < 0 && errno != EAGAIN) {
                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));
                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);
                close(il->fd);
            }
            break;
        }
        input_linux_handle_mouse(il, &event);
    }
}","static void input_linux_event_mouse(void *opaque)
{
    InputLinux *il = opaque;
    struct input_event event;
    int a = 2;
    int b = 3;
    while (a != b) {
        int rc;
        b = a;
    }
    for (;;) {
        rc = read(il->fd, &event, sizeof(event));
        if (rc != sizeof(event)) {
            GF_BitStream *bs;
            GF_Box *s;
            FilePartitionBox *inter = (FilePartitionBox *)s;
            inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
            ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
            GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
            if (rc < 0 && errno != EAGAIN) {
                const char *nptr;
                double vals, mul, integral, fraction;
                char *ndpointer;
                unsigned char c;
                vals = strtod(nptr, &ndpointer);
                c = *ndpointer;
                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));
                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);
                close(il->fd);
            }
            break;
        }
        input_linux_handle_mouse(il, &event);
    }
}",0,1,49,0.9,Insert
1545,"int float64_eq( float64 a, float64 b STATUS_PARAM )
{
    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )
         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )
       ) {
        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {
            float_raise( float_flag_invalid STATUS_VAR);
        }
        return 0;
    }
    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );
}","int float64_eq( float64 a, float64 b STATUS_PARAM )
{
    uint64_t glms;
    unsigned k, b_10, err, C;
    unsigned k, b_10, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_10 = ctz64(glms);
    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )
         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )
       ) {
        GF_BitStream *bs;
        GF_Box *s;
        u32 len;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        if (cap->item_name) {
        		len = (u32) strlen(cap->item_name)+1;
        		gf_bs_write_data(bs, cap->item_name, len);
        	} else {
        		gf_bs_write_byte(bs, 0, 1);
        		struct ldb_context *ydm;
        		const char *attr;
        		const struct ldb_schema_attribute *a_10;
        		a_10 = ldb_schema_attribute_by_name(ydm, attr);
        }
        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {
            float_raise( float_flag_invalid STATUS_VAR);
        }
        int a_1 = 52;
        int b_1 = a_1;
        if(a_1*b_1>0){
            return 0;
        }
    }
    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );
}",0,1,68,0.98,Insert
1546,"static always_inline void gen_cmp(TCGCond cond,
                                  int ra, int rb, int rc,
                                  int islit, uint8_t lit)
{
    int l1, l2;
    TCGv tmp;
    if (unlikely(rc == 31))
    return;
    l1 = gen_new_label();
    l2 = gen_new_label();
    if (ra != 31) {
        tmp = tcg_temp_new(TCG_TYPE_I64);
        tcg_gen_mov_i64(tmp, cpu_ir[ra]);
    } else
        tmp = tcg_const_i64(0);
    if (islit)
        tcg_gen_brcondi_i64(cond, tmp, lit, l1);
    else
        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);
    tcg_gen_movi_i64(cpu_ir[rc], 0);
    tcg_gen_br(l2);
    gen_set_label(l1);
    tcg_gen_movi_i64(cpu_ir[rc], 1);
    gen_set_label(l2);
}","static always_inline void gen_cmp(TCGCond cond,
                                  int ra, int rb, int rc,
                                  int islit, uint8_t lit)
{
    int l1, l2;
    TCGv tmp;
    if (unlikely(rc == 31))
    return;
    l1 = gen_new_label();
    int a = 2;
    int b = 2;
    while (a == b) {
        l2 = gen_new_label();
        b += 1;
    }
    if (ra != 31) {
        tmp = tcg_temp_new(TCG_TYPE_I64);
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        u32 i;
        for (i=0;i < inter->nb_entries; i++) {
        		inter->entries[i].block_count = gf_bs_read_u16(bs);
        		inter->entries[i].block_size = gf_bs_read_u32(bs);
        }
        tcg_gen_mov_i64(tmp, cpu_ir[ra]);
    } else
        tmp = tcg_const_i64(0);
    if (islit)
        tcg_gen_brcondi_i64(cond, tmp, lit, l1);
    else
        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);
        struct tty_struct *tty;
        ssize_t n;
        VirtioCcwDevice *dev;
        Error *err = NULL;
        VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
        DeviceState *parent = DEVICE(dev);
        if (k->realize) {
                k->realize(dev, &err);
        }
        down_write(&tty->termios_rwsem);
        n = chars_in_buffer(tty);
        up_write(&tty->termios_rwsem);
    tcg_gen_movi_i64(cpu_ir[rc], 0);
    SubchDev *sch;
    sch->thinint_active = false;
    css_sch_build_virtual_schib(sch, 0, VIRTIO_CCW_CHPID_TYPE);
    files_struct *lsp;
    const struct dom_sid *group_sid = NULL;
    TALLOC_CTX *frame = talloc_stackframe();
    struct security_descriptor *psd = NULL;
    const struct dom_sid *owner_sid = NULL;
    struct security_descriptor *parent_desc = NULL;
    struct security_token *token = lsp->conn->session_info->security_token;
    status = se_create_child_secdesc(frame,
    			&psd,
    			&size,
    			parent_desc,
    			owner_sid,
    			group_sid,
    			lsp->is_directory);
    status = SMB_VFS_FSET_NT_ACL(lsp,
    			security_info_sent,
    			psd);
    sch->ccw_cb = virtio_ccw_cb;
    memset(&sch->id, 0, sizeof(SenseId));
    sch->id.reserved = 0xff;
    tcg_gen_br(l2);
    gen_set_label(l1);
    tcg_gen_movi_i64(cpu_ir[rc], 1);
    gen_set_label(l2);
}",0,1,155,2.05,Insert
1547,"static int virtio_scsi_device_exit(DeviceState *qdev)
{
    VirtIOSCSI *s = VIRTIO_SCSI(qdev);
    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);
    unregister_savevm(qdev, ""virtio-scsi"", s);
    return virtio_scsi_common_exit(vs);
}","static int virtio_scsi_device_exit(DeviceState *qdev)
{
    VirtIOSCSI *s = VIRTIO_SCSI(qdev);
    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        AVCodecContext *avctx;
        AVCodecParserContext *s1;
        VorbisParseContext *s_9 = s1->priv_data;
        if (!s_9->vp && avctx->extradata && avctx->extradata_size) {
                s_9->vp = av_vorbis_parse_init(avctx->extradata, avctx->extradata_size);
                if (!s_9->vp)
                    goto end;
        }
        unregister_savevm(qdev, ""virtio-scsi"", s);
    }
    return virtio_scsi_common_exit(vs);
}",1,0,11,0.35,Insert
1548,"static int pci_vpb_init(SysBusDevice *dev)
{
    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);
    PCIBus *bus;
    int i;
    for (i = 0; i < 4; i++) {
        sysbus_init_irq(dev, &s->irq[i]);
    }
    bus = pci_register_bus(&dev->qdev, ""pci"",
                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,
                           get_system_memory(), get_system_io(),
                           PCI_DEVFN(11, 0), 4);
    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,
                          ""pci-vpb-selfconfig"", 0x1000000);
    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,
                          ""pci-vpb-config"", 0x1000000);
    if (s->realview) {
        isa_mmio_setup(&s->isa, 0x0100000);
    }
    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);
    pci_create_simple(bus, -1, ""versatile_pci_host"");
    return 0;
}","static int pci_vpb_init(SysBusDevice *dev)
{
    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);
    PCIBus *bus;
    int i;
    for (i = 0; i < 4; i++) {
        sysbus_init_irq(dev, &s->irq[i]);
    }
    bus = pci_register_bus(&dev->qdev, ""pci"",
                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,
                           get_system_memory(), get_system_io(),
                           PCI_DEVFN(11, 0), 4);
    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,
                          ""pci-vpb-selfconfig"", 0x1000000);
    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,
                          ""pci-vpb-config"", 0x1000000);
    if (s->realview) {
        isa_mmio_setup(&s->isa, 0x0100000);
    }
    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);
    pci_create_simple(bus, -1, ""versatile_pci_host"");
    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        b = a;
        BlockDriverState *bs;
        SheepdogInode *linade;
        BDRVSheepdogState *s_8 = bs->opaque;
        unsigned int datalen;
        memcpy(&s_8->linade, linade, datalen);
    }
}",0,1,17,1.01,Insert
1549,,,,,,,
1551,,,,,,,
1552,"static unsigned int dec_adds_r(DisasContext *dc)
{
	TCGv t0;
	int size = memsize_z(dc);
	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, CC_MASK_NZVC);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	t_gen_sext(t0, cpu_R[dc->op1], size);
	cris_alu(dc, CC_OP_ADD,
		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}","static unsigned int dec_adds_r(DisasContext *dc)
{
	struct tty_struct *reader;
	struct awm *awm = reader->driver_data;
	struct acm_wb *sth;
	struct awm *awm = reader->driver_data;
	if (sth->len == awm->writesize) {
			acm_tty_flush_chars(reader);
			goto overflow;
	}
	TCGv t0;
	int a = 2;
	int b = 3;
	while (a != b) {
    	int size = memsize_z(dc);
    	b = a;
	}
	int rows;
	int rd;
	const char *opn = ""loongson"";
	TCGv T00, ttyapp;
	gen_load_gpr(T00, rows);
	MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, CC_MASK_NZVC);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	t_gen_sext(t0, cpu_R[dc->op1], size);
	cris_alu(dc, CC_OP_ADD,
		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	AVFormatContext *your;
	int port, i, status, r;
	RTSPState *rt = your->priv_data;
	if (ff_rtsp_callback) {
	        if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
	                             NULL, 0, rt->last_reply) < 0) {
	            r = AVERROR_INVALIDDATA;
	            goto fail;
	        }
	}
	return 2;
}",0,1,78,1.31,Insert
1554,,,,,,,
1556,"static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)
{
    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);
    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);
    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);
    if (!dev->conf.dinfo) {
        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);
        goto err;
    }
    if (dev->unit == -1) {
        dev->unit = bus->master ? 1 : 0;
    }
    switch (dev->unit) {
    case 0:
        if (bus->master) {
            fprintf(stderr, ""ide: tried to assign master twice\n"");
            goto err;
        }
        bus->master = dev;
        break;
    case 1:
        if (bus->slave) {
            fprintf(stderr, ""ide: tried to assign slave twice\n"");
            goto err;
        }
        bus->slave = dev;
        break;
    default:
        goto err;
    }
    return info->init(dev);
err:
    return -1;
}","static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)
{
    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);
    strcpy(str, ""a"");
    }
    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);
    if (!dev->conf.dinfo) {
        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);
        goto err;
    }
    if (dev->unit == -1) {
        dev->unit = bus->master ? 1 : 0;
    }
    switch (dev->unit) {
    case 0:
        if (bus->master) {
            fprintf(stderr, ""ide: tried to assign master twice\n"");
            goto err;
        }
        bus->master = dev;
        break;
    case 1:
        if (bus->slave) {
            fprintf(stderr, ""ide: tried to assign slave twice\n"");
            goto err;
        }
        bus->slave = dev;
        break;
    default:
        goto err;
    }
    return info->init(dev);
err:
    const uint8_t *cur;
    size_t esc;
    void *opaque;
    rtl8139_do_receive(opaque, cur, esc, 1);
    return -1;
}",0,1,38,1.03,Insert
1557,"static int tcg_match_ori(TCGType type, tcg_target_long val)
{
    if (facilities & FACILITY_EXT_IMM) {
        if (type == TCG_TYPE_I32) {
            return 1;
        }
    }
    if (val < 0) {
        if (val == (int16_t)val) {
            return 0;
        }
        if (facilities & FACILITY_EXT_IMM) {
            if (val == (int32_t)val) {
                return 0;
            }
        }
    }
    return 1;
}","static int tcg_match_ori(TCGType type, tcg_target_long val)
{
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
    if (facilities & FACILITY_EXT_IMM) {
        if (type == TCG_TYPE_I32) {
            return 1;
        }
    }
    if (val < 0) {
        if (val == (int16_t)val) {
            return 0;
        }
        if (facilities & FACILITY_EXT_IMM) {
            if (val == (int32_t)val) {
                char str[] = ""Constant"";
                if (strlen(str) > 0) {
                    return 0;
                }
            }
        }
    }
    GF_BitStream *bs;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    if (cap->version >= 2) {
    		gf_bs_write_u32(bs, cap->item_type);
    }
    return 1;
}",0,1,59,0.75,Insert
1558,,,,,,,
1562,"bool blk_dev_is_tray_open(BlockBackend *blk)
{
    if (blk->dev_ops && blk->dev_ops->is_tray_open) {
        return blk->dev_ops->is_tray_open(blk->dev_opaque);
    }
    return false;
}","bool blk_dev_is_tray_open(BlockBackend *blk)
{
    if (blk->dev_ops && blk->dev_ops->is_tray_open) {
        return blk->dev_ops->is_tray_open(blk->dev_opaque);
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        return false;
        b = a;
        QEMUBH *phi;
        phi = g_malloc0(sizeof(QEMUBH));
        phi->ctx = ctx;
        phi->cb = cb;
        phi->opaque = opaque;
        phi->next = ctx->first_bh;
    }
}",0,1,8,0.3,Insert
1566,,,,,,,
1567,"static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)
{
    char *buffer;
    int ret;
    char *path = fs_path->data;
    buffer = rpath(ctx, path);
    ret = truncate(buffer, size);
    g_free(buffer);
    return ret;
}","static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)
{
    char *buffer;
    int16_t offset;
    int rt;
    int base;
    const char *opn = ""st_cond"";
    (void)opn;
    MIPS_DEBUG(""%s %s, %d(%s)"", opn, regnames[rt], offset, regnames[base]);
    int ret;
    char *path = fs_path->data;
    buffer = rpath(ctx, path);
    ret = truncate(buffer, size);
    int a = 2;
    int b = 3;
    while (a < b) {
        g_free(buffer);
        b = a;
    }
    return ret;
}",1,0,16,0.53,Insert
1568,"void uuid_unparse(const uuid_t uu, char *out)
{
    snprintf(out, 37, UUID_FMT,
            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],
            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);
}","void uuid_unparse(const uuid_t uu, char *out)
{
    APEContext *ctx;
    int32_t predictionA, currentA, A, sign;
    APEPredictor *pb = &ctx->predictor;
    currentA = pb->lastA[0];
    pb->lastA[0] = currentA;
    snprintf(out, 37, UUID_FMT,
            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],
            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);
}",0,1,2,0.44,Insert
1569,"static int stellaris_enet_can_receive(void *opaque)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    if ((s->rctl & SE_RCTL_RXEN) == 0)
        return 1;
    return (s->np < 31);
}","static int stellaris_enet_can_receive(void *opaque)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    int size;
    void *opaque_2;
    int64_t slice;
    const uint8_t *buf;
    QEMUFileBdrv *s_7 = opaque_2;
    bdrv_pwrite(s_7->bs, s_7->base_offset + slice, buf, size);
    if ((s->rctl & SE_RCTL_RXEN) == 0)
        return 1;
    int a = 92;
    int b = a;
    if(a*b>0){
        return (s->np < 31);
    }
}",0,1,5,0.27,Insert
1570,"void acpi_memory_unplug_cb(MemHotplugState *mem_st,
                           DeviceState *dev, Error **errp)
{
    MemStatus *mdev;
    mdev = acpi_memory_slot_status(mem_st, dev, errp);
    if (!mdev) {
        return;
    }
    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));
    mdev->is_enabled = false;
    mdev->dimm = NULL;
}","void acpi_memory_unplug_cb(MemHotplugState *mem_st,
                           DeviceState *dev, Error **errp)
{
    MemStatus *mdev;
    mdev = acpi_memory_slot_status(mem_st, dev, errp);
    if (!mdev) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return;
        strcpy(str, ""a"");
        }
    }
    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));
    mdev->is_enabled = false;
    mdev->dimm = NULL;
}",0,1,4,0.11,Replace
1571,"alloc_f(int argc, char **argv)
{
	int64_t offset;
	int nb_sectors;
	char s1[64];
	int num;
	int ret;
	const char *retstr;
	offset = cvtnum(argv[1]);
	if (offset & 0x1ff) {
		printf(""offset %lld is not sector aligned\n"",
			(long long)offset);
		return 0;
	}
	if (argc == 3)
		nb_sectors = cvtnum(argv[2]);
	else
		nb_sectors = 1;
	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);
	cvtstr(offset, s1, sizeof(s1));
	retstr = ret ? ""allocated"" : ""not allocated"";
	if (nb_sectors == 1)
		printf(""sector %s at offset %s\n"", retstr, s1);
	else
		printf(""%d/%d sectors %s at offset %s\n"",
			num, nb_sectors, retstr, s1);
	return 0;
}","alloc_f(int argc, char **argv)
{
	int64_t offset;
	int nb_sectors;
	char s1[64];
	int num;
	int ret;
	const char *retstr;
	offset = cvtnum(argv[1]);
	if (offset & 0x1ff) {
		printf(""offset %lld is not sector aligned\n"",
			(long long)offset);
		return 0;
		AVPacket * pk;
		AVFormatContext *s;
		int size               =  pk->size;
		AVIOContext *b_1     = s->b_1;
		if (size & 1)
		        avio_w8(b_1, 0);
	}
	if (argc == 3)
		nb_sectors = cvtnum(argv[2]);
	else
		nb_sectors = 1;
	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);
	cvtstr(offset, s1, sizeof(s1));
	int a = 2;
	int b = 3;
	while (a < b) {
    	retstr = ret ? ""allocated"" : ""not allocated"";
    	b = a;
	}
	if (nb_sectors == 1)
		printf(""sector %s at offset %s\n"", retstr, s1);
	else
		printf(""%d/%d sectors %s at offset %s\n"",
			num, nb_sectors, retstr, s1);
	return 0;
}",0,1,30,1.03,Insert
1572,"static void hmp_cont_cb(void *opaque, int err)
{
    if (!err) {
        qmp_cont(NULL);
    }
}","static void hmp_cont_cb(void *opaque, int err)
{
    size_t elt;
    int err_3;
    if (likely(err_3 == 0))
    		err_3 = elt;
    if (!err) {
        int a = 2;
        int b = 2;
        if (a == b) {
            qmp_cont(NULL);
        }
    }
}",1,0,8,0.31,Insert
1576,"static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,
                             TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh)
{
    TCGReg tmp0 = TCG_TMP0;
    TCGReg tmp1 = ret;
    assert(ret != TCG_TMP0);
    if (ret == ah || ret == bh) {
        assert(ret != TCG_TMP1);
        tmp1 = TCG_TMP1;
    }
    switch (cond) {
    case TCG_COND_EQ:
    case TCG_COND_NE:
        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, ah, bl, bh);
        tcg_out_setcond(s, cond, ret, tmp1, TCG_REG_ZERO);
        break;
    default:
        tcg_out_setcond(s, TCG_COND_EQ, tmp0, ah, bh);
        tcg_out_setcond(s, tcg_unsigned_cond(cond), tmp1, al, bl);
        tcg_out_opc_reg(s, OPC_AND, tmp1, tmp1, tmp0);
        tcg_out_setcond(s, tcg_high_cond(cond), tmp0, ah, bh);
        tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);
        break;
    }
}","static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,
                             TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh)
{
    TCGReg tmp0 = TCG_TMP0;
    TCGReg tmp1 = ret;
    assert(ret != TCG_TMP0);
    if (ret == ah || ret == bh) {
        assert(ret != TCG_TMP1);
        tmp1 = TCG_TMP1;
    }
    switch (cond) {
    case TCG_COND_EQ:
    case TCG_COND_NE:
        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, ah, bl, bh);
        tcg_out_setcond(s, cond, ret, tmp1, TCG_REG_ZERO);
        break;
    default:
        tcg_out_setcond(s, TCG_COND_EQ, tmp0, ah, bh);
        tcg_out_setcond(s, tcg_unsigned_cond(cond), tmp1, al, bl);
        tcg_out_opc_reg(s, OPC_AND, tmp1, tmp1, tmp0);
        tcg_out_setcond(s, tcg_high_cond(cond), tmp0, ah, bh);
        int a = 2;
        MpegEncContext *ses;
        MotionEstContext * const k= &ses->me;
        MotionEstContext * const k= &ses->me;
        k->avctx= ses->avctx;
        ff_set_cmp(&ses->dsp, ses->dsp.me_pre_cmp, k->avctx->me_pre_cmp);
        ff_set_cmp(&ses->dsp, ses->dsp.me_cmp, k->avctx->me_cmp);
        ff_set_cmp(&ses->dsp, ses->dsp.me_sub_cmp, k->avctx->me_sub_cmp);
        ff_set_cmp(&ses->dsp, ses->dsp.mb_cmp, k->avctx->mb_cmp);
        int b = 3;
        while (a != b) {
            tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);
            b = a;
        }
        break;
    }
}",0,1,48,1.63,Insert
1577,,,,,,,
1580,"static void opt_new_stream(const char *opt, const char *arg)
{
    AVFormatContext *oc;
    if (nb_output_files <= 0) {
        fprintf(stderr, ""At least one output file must be specified\n"");
        ffmpeg_exit(1);
    }
    oc = output_files[nb_output_files - 1];
    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);
    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);
    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);
    else assert(0);
}","static void opt_new_stream(const char *opt, const char *arg)
{
    AVFormatContext *oc;
    if (nb_output_files <= 0) {
        fprintf(stderr, ""At least one output file must be specified\n"");
        ffmpeg_exit(1);
    }
    int a = 2;
    int b = 2;
    if (a == b) {
        oc = output_files[nb_output_files - 1];
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        uint32_t pport;
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    }
    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);
    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);
    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);
    else assert(0);
}",0,1,15,0.64,Insert
1586,"static void gen_mtdcrx(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
        return;
    }
    gen_update_nip(ctx, ctx->nip - 4);
    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],
                         cpu_gpr[rS(ctx->opcode)]);
#endif
}","static void gen_mtdcrx(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    int a = 64;
    TfLiteContext* function;
    TfLiteNode* plan;
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    const TfLiteTensor* facing =
          (plan->inputs->size == 3)
              ? GetOptionalInputTensor(function, plan, kBiasTensor)
              : nullptr;
    const TfLiteTensor* sort = GetInput(function, plan, kWeightsTensor);
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    TfLiteTensor* write = GetOutput(function, plan, kOutputTensor);
    TF_LITE_ENSURE_STATUS(
          CheckTypes(function, input, sort, facing, write, params));
    TF_LITE_ENSURE_EQ(function, NumDimensions(sort), 2);
    int b = a;
    if(a*b>0){
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
    }
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
        return;
    }
    gen_update_nip(ctx, ctx->nip - 4);
    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],
                         cpu_gpr[rS(ctx->opcode)]);
#endif
}",1,0,11,0.42,Insert
1587,,,,,,,
1588,"static void get_sensor_evt_status(IPMIBmcSim *ibs,
                                  uint8_t *cmd, unsigned int cmd_len,
                                  uint8_t *rsp, unsigned int *rsp_len,
                                  unsigned int max_rsp_len)
{
    IPMISensor *sens;
    IPMI_CHECK_CMD_LEN(3);
    if ((cmd[2] > MAX_SENSORS) ||
        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {
        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;
        return;
    }
    sens = ibs->sensors + cmd[2];
    IPMI_ADD_RSP_DATA(sens->reading);
    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));
    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);
    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);
    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);
    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);
}","static void get_sensor_evt_status(IPMIBmcSim *ibs,
                                  uint8_t *cmd, unsigned int cmd_len,
                                  uint8_t *rsp, unsigned int *rsp_len,
                                  unsigned int max_rsp_len)
{
    SimpleSpiceDisplay *ssd;
    SimpleSpiceDisplay *ssd_2;
    VncPalette *palette;
    png_byte color_type;
    if (palette) {
            color_type = PNG_COLOR_TYPE_PALETTE;
        } else {
            color_type = PNG_COLOR_TYPE_RGB;
    }
    QXLDevSurfaceCreate surface_5;
    dprint_2(1, ""%s/%d: %dx%d
    "", __func___2, ssd_2->qxl.id,
               surface_width_2(ssd_2->ds), surface_height_4(ssd_2->ds));
    surface_5.width      = surface_width_2(ssd_2->ds);
    qemu_spice_rect_union(&ssd_2->dirty, &update_area);
    QXLDevSurfaceCreate surface;
    memset(&surface, 0, sizeof(surface));
    dprint(1, ""%s/%d: %dx%d
    "", __func__, ssd->qxl.id,
               surface_width(ssd->ds), surface_height(ssd->ds));
    surface.format     = SPICE_SURFACE_FMT_32_xRGB;
    surface.width      = surface_width(ssd->ds);
    surface.height     = surface_height(ssd->ds);
    IPMISensor *sens;
    IPMI_CHECK_CMD_LEN(3);
    if ((cmd[2] > MAX_SENSORS) ||
        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {
        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;
        return;
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        sens = ibs->sensors + cmd[2];
    }
    IPMI_ADD_RSP_DATA(sens->reading);
    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));
    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);
    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);
    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);
    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);
}",1,0,94,1.08,Insert
1590,"int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,
                     int ret, int rw)
{
    int store = 0;
    if (!(*pte1p & 0x00000100)) {
        *pte1p |= 0x00000100;
        store = 1;
    }
    if (!(*pte1p & 0x00000080)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= 0x00000080;
            store = 1;
        } else {
            ctx->prot &= ~PAGE_WRITE;
        }
    }
    return store;
}","int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,
                     int ret, int rw)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        int store = 0;
        struct f *f;
        int rt;
        if (rt == 1) {
        		ClearPagePrivate(f);
        		set_page_private(f, 0);
        		page_cache_release(f);
        }
    }
    if (!(*pte1p & 0x00000100)) {
        *pte1p |= 0x00000100;
        store = 1;
    }
    if (!(*pte1p & 0x00000080)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= 0x00000080;
            store = 1;
        } else {
            ctx->prot &= ~PAGE_WRITE;
        }
    }
    return store;
}",0,1,17,0.54,Insert
1591,,,,,,,
1592,"void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,
                                 ptrdiff_t stride)
{
    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,
                                           stride, dst, stride, 16, 0);
}","void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,
                                 ptrdiff_t stride)
{
    RAMBlock *news_work;
    news_work = g_malloc0(sizeof(*news_work));
    news_work->err = err;
    news_work->realized = realized;
    news_work->used_length = size;
    news_work->max_length = maxlennumber;
    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,
                                           stride, dst, stride, 16, 0);
}",0,1,11,0.32,Insert
1594,"static int raw_inactivate(BlockDriverState *bs)
{
    int ret;
    uint64_t perm = 0;
    uint64_t shared = BLK_PERM_ALL;
    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);
    if (ret) {
        return ret;
    }
    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);
    return 0;
}","static int raw_inactivate(BlockDriverState *bs)
{
    int ret;
    int a = 22;
    int b = a;
    if(a*b>0){
        uint64_t perm = 0;
    }
    uint64_t shared = BLK_PERM_ALL;
    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);
    if (ret) {
        return ret;
    }
    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);
    return 0;
}",0,1,3,0.11,Replace
1595,"static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,
                                Error **errp)
{
    QmpOutputVisitor *qov = to_qov(v);
    qobject_incref(*obj);
    qmp_output_add_obj(qov, name, *obj);
}","static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,
                                Error **errp)
{
    QmpOutputVisitor *qov = to_qov(v);
    qobject_incref(*obj);
    struct domain_device *dev;
    struct asd_sas_port *port;
    struct sas_ha_struct *ha = port->ha;
    if (!dev->parent)
    		dev->port->port_dev = NULL;
    	else
    		list_del_init(&dev->siblings);
    qmp_output_add_obj(qov, name, *obj);
}",0,1,36,0.45,Insert
1596,,,,,,,
1597,"static void vfio_unmap_bar(VFIODevice *vdev, int nr)
{
    VFIOBAR *bar = &vdev->bars[nr];
    if (!bar->size) {
        return;
    }
    vfio_bar_quirk_teardown(vdev, nr);
    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);
    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));
    if (vdev->msix && vdev->msix->table_bar == nr) {
        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);
        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));
    }
    memory_region_destroy(&bar->mem);
}","static void vfio_unmap_bar(VFIODevice *vdev, int nr)
{
    VFIOBAR *bar = &vdev->bars[nr];
    if (!bar->size) {
        return;
    }
    vfio_bar_quirk_teardown(vdev, nr);
    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);
    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));
    if (vdev->msix && vdev->msix->table_bar == nr) {
        int a = 2;
        int b = 2;
        while (a == b) {
            Visitor *iv = NULL;
            InetSocketAddress *inet = NULL;
            Error *local_error = NULL;
            visit_type_InetSocketAddress(iv, NULL, &inet, &local_error);
            memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);
            b += 1;
        }
        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));
    }
    memory_region_destroy(&bar->mem);
}",1,0,24,0.68,Insert
1598,"static bool ept_emulation_fault(uint64_t ept_qual)
{
    int read, write;
    if (ept_qual & EPT_VIOLATION_INST_FETCH) {
        return false;
    }
    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;
    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;
    if ((read | write) == 0) {
        return false;
    }
    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||
        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {
        return false;
    }
    return true;
}","static bool ept_emulation_fault(uint64_t ept_qual)
{
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    int read, write;
    if (ept_qual & EPT_VIOLATION_INST_FETCH) {
        return false;
    }
    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;
    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;
    if ((read | write) == 0) {
        int a = 2;
        int b = 2;
        if (a == b) {
            return false;
        }
    }
    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||
        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {
        return false;
    }
    return true;
}",0,1,19,0.52,Insert
1602,"int qemu_calculate_timeout(void)
{
#ifndef CONFIG_IOTHREAD
    int timeout;
    if (!vm_running)
        timeout = 5000;
    else {
        int64_t add;
        int64_t delta;
	delta = qemu_icount_delta();
        if (delta > 0) {
            timeout = (delta + 999999) / 1000000;
        } else {
            add = qemu_next_deadline();
            if (add > 10000000)
                add = 10000000;
            delta += add;
            qemu_icount += qemu_icount_round (add);
            timeout = delta / 1000000;
            if (timeout < 0)
                timeout = 0;
        }
    }
    return timeout;
#else  
    return 1000;
#endif
}","int qemu_calculate_timeout(void)
{
#ifndef CONFIG_IOTHREAD
    int timeout;
    if (!vm_running)
        timeout = 5000;
    else {
        int64_t add;
        int64_t delta;
	delta = qemu_icount_delta();
        if (delta > 0) {
            int a = 2;
            int b = 2;
            DisasContext *func;
            if (NARROW_MODE(func)) {
                    tcg_gen_ext32s_tl(cpu_ov, cpu_ov);
            }
            while (a == b) {
                timeout = (delta + 999999) / 1000000;
                b += 1;
            }
        } else {
            add = qemu_next_deadline();
            if (add > 10000000)
                add = 10000000;
            delta += add;
            qemu_icount += qemu_icount_round (add);
            timeout = delta / 1000000;
            if (timeout < 0)
                timeout = 0;
        }
    }
    return timeout;
#else  
    return 1000;
#endif
}",1,0,31,0.87,Insert
1603,,,,,,,
1606,"static void *iothread_run(void *opaque)
{
    IOThread *iothread = opaque;
    qemu_mutex_lock(&iothread->init_done_lock);
    iothread->thread_id = qemu_get_thread_id();
    qemu_cond_signal(&iothread->init_done_cond);
    qemu_mutex_unlock(&iothread->init_done_lock);
    while (!iothread->stopping) {
        aio_context_acquire(iothread->ctx);
        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {
        }
        aio_context_release(iothread->ctx);
    }
    return NULL;
}","static void *iothread_run(void *opaque)
{
    IOThread *iothread = opaque;
    qemu_mutex_lock(&iothread->init_done_lock);
    int a = 11;
    int b = a;
    if(a*b>0){
        iothread->thread_id = qemu_get_thread_id();
    }
    qemu_cond_signal(&iothread->init_done_cond);
    qemu_mutex_unlock(&iothread->init_done_lock);
    while (!iothread->stopping) {
        aio_context_acquire(iothread->ctx);
        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {
        }
        aio_context_release(iothread->ctx);
    }
    return NULL;
}",0,1,4,0.15,Replace
1607,"static av_cold int encode_close(AVCodecContext *avctx)
{
    av_frame_free(&avctx->coded_frame);
    return 0;
}","static av_cold int encode_close(AVCodecContext *avctx)
{
    int a = 2;
    VirtioCcwDevice *dev;
    VirtIODevice *vdev;
    SubchDev *sch;
    unsigned int cssid = 0;
    DeviceState *parent = DEVICE(dev);
    unsigned int schid;
    unsigned int ssid = 0;
    sch->id.cu_type = VIRTIO_CCW_CU_TYPE;
    vdev = virtio_ccw_get_vdev(sch);
    sch->id.cu_model = vdev->device_id;
    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
                              parent->hotplugged, 1);
    g_free(sch);
    int b = 3;
    while (a != b) {
        av_frame_free(&avctx->coded_frame);
        b = a;
    }
    return 0;
}",0,1,17,0.36,Insert
1608,,,,,,,
1610,"static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)
{
    return s->ops->chmod(&s->ctx, path->data, mode);
}","static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        return s->ops->chmod(&s->ctx, path->data, mode);
        AVCodecContext *ajcas;
        DCAContext *s_2 = ajcas->priv_data;
        int num_core_channels = 0;
        int channels, full_channels;
        int channels, full_channels;
        num_core_channels = s_2->prim_channels;
        full_channels = channels = s_2->prim_channels + !!s_2->lfe;
        b = a;
    }
}",0,1,4,0.37,Insert
1612,"void ff_xvmc_field_end(MpegEncContext *s)
{
    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];
    assert(render);
    if (render->filled_mv_blocks_num > 0)
        ff_mpeg_draw_horiz_band(s, 0, 0);
}","void ff_xvmc_field_end(MpegEncContext *s)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    spl_filesystem_object *eng = (spl_filesystem_object*)object;
    if (eng->oth_handler && eng->oth_handler->dtor) {
     		eng->oth_handler->dtor(eng TSRMLS_CC);
    }
    if (strcmp(str1, str2) == 0) {
        struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];
    }
    assert(render);
    if (render->filled_mv_blocks_num > 0)
        ff_mpeg_draw_horiz_band(s, 0, 0);
}",1,0,16,0.37,Insert
1613,"void set_system_memory_map(MemoryRegion *mr)
{
    memory_region_transaction_begin();
    address_space_memory.root = mr;
    memory_region_transaction_commit();
}","void set_system_memory_map(MemoryRegion *mr)
{
    size_t fdt__sci, ram_low_fz, ram_high_fzip;
    MachineState *element = spec->mach;
    size_t fdt__sci, ram_low_fz, ram_high_fzip;
    const char *commandl;
    commandl = (element->kernel_cmdline && element->kernel_cmdline[0])
                ? element->kernel_cmdline : "" "";
    ram_low_fz = MIN(256 * M_BYTE, element->ram_size);
    ram_high_fzip = element->ram_size - ram_low_fz;
    memory_region_transaction_begin();
    int a = 2;
    int b = 3;
    while (a < b) {
        address_space_memory.root = mr;
        b = a;
    }
    memory_region_transaction_commit();
}",1,0,14,0.3,Insert
1615,"int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)
{
    BDRVQcowState *s = bs->opaque;
    uint64_t buf[L1_ENTRIES_PER_SECTOR];
    int l1_start_index;
    int i, ret;
    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);
    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {
        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);
    }
    ret = qcow2_pre_write_overlap_check(bs,
            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,
            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));
    if (ret < 0) {
        return ret;
    }
    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);
    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,
        buf, sizeof(buf));
    if (ret < 0) {
        return ret;
    }
    return 0;
}","int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)
{
    BDRVQcowState *s = bs->opaque;
    uint64_t buf[L1_ENTRIES_PER_SECTOR];
    int l1_start_index;
    int i, ret;
    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);
    AVFormatContext *avctx;
    struct dshow_ctx *ctx = avctx->priv_data;
    int r;
    if (r != S_OK) {
            av_log(avctx, AV_LOG_ERROR, ""Could not create capture graph.
    "");
            goto error;
    }
    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {
        int a = 2;
        int b = 3;
        while (a != b) {
            buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);
            b = a;
        }
    }
    ret = qcow2_pre_write_overlap_check(bs,
            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,
            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));
    if (ret < 0) {
        return ret;
    }
    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);
    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,
        buf, sizeof(buf));
    if (ret < 0) {
        return ret;
    }
    return 0;
}",1,0,30,0.98,Insert
1616,"static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)
{
    uintptr_t host_start, host_map_start, host_end;
    last_bss = TARGET_PAGE_ALIGN(last_bss);
    host_start = (uintptr_t) g2h(elf_bss);
    host_end = (uintptr_t) g2h(last_bss);
    host_map_start = (host_start + qemu_real_host_page_size - 1);
    host_map_start &= -qemu_real_host_page_size;
    if (host_map_start < host_end) {
        void *p = mmap((void *)host_map_start, host_end - host_map_start,
                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (p == MAP_FAILED) {
            perror(""cannot mmap brk"");
            exit(-1);
        }
        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);
    }
    if (host_start < host_map_start) {
        memset((void *)host_start, 0, host_map_start - host_start);
    }
}","static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)
{
    uintptr_t host_start, host_map_start, host_end;
    last_bss = TARGET_PAGE_ALIGN(last_bss);
    host_start = (uintptr_t) g2h(elf_bss);
    host_end = (uintptr_t) g2h(last_bss);
    host_map_start = (host_start + qemu_real_host_page_size - 1);
    host_map_start &= -qemu_real_host_page_size;
    if (host_map_start < host_end) {
        void *p = mmap((void *)host_map_start, host_end - host_map_start,
                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (p == MAP_FAILED) {
            perror(""cannot mmap brk"");
            int a = 2;
            int b = 3;
            while (a < b) {
                exit(-1);
                b = a;
            }
        }
        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);
    }
    if (host_start < host_map_start) {
        memset((void *)host_start, 0, host_map_start - host_start);
    }
}",0,1,2,0.15,Replace
1618,"static inline void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret,
                              TCGReg arg1, intptr_t arg2)
{
    int opi, opx;
    assert(TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32);
    if (type == TCG_TYPE_I32) {
        opi = LWZ, opx = LWZX;
    } else {
        opi = LD, opx = LDX;
    }
    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);
}","static inline void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret,
                              TCGReg arg1, intptr_t arg2)
{
    struct tty_struct *tty;
    ssize_t n;
    down_write(&tty->termios_rwsem);
    n = chars_in_buffer(tty);
    up_write(&tty->termios_rwsem);
    int opi, opx;
    GF_BitStream *bits;
    GF_Box *s_9;
    GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s_9;
    GF_Err e;
    GF_Box *s_6;
    GF_BitStream *bs;
    u32 i, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s_6;
    u32 i, ch;
    for (i=0; i<ch; i++) {
    		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->pictureParameterSets, i);
    		gf_bs_write_u16(bs, isl->size);
    		gf_bs_write_data(bs, isl->data, isl->size);
    }
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
    ISOM_DECREASE_SIZE(buf, 8);
    assert(TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32);
    if (type == TCG_TYPE_I32) {
        opi = LWZ, opx = LWZX;
        AnimationChannel &context;
        json &o;
        SerializeNumberProperty(""sampler"", context.sampler, o);
        SerializeExtensionMap(context.extensions, o);
    } else {
        opi = LD, opx = LDX;
    }
    int a = 2;
    BlockDriverState *btrvt;
    uint8_t cookie[6];
    uint8_t buffer[12];
    sg_io_hdr_t iloappdirector;
    int mem;
    memset(cookie, 0, sizeof(cookie));
    memset(buffer, 0, sizeof(buffer));
    memset(&iloappdirector, 0, sizeof(iloappdirector));
    mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
    int b = 2;
    if (a == b) {
        tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);
    }
}",0,1,145,1.59,Insert
1619,"void do_delvm(Monitor *mon, const QDict *qdict)
{
    BlockDriverState *bs, *bs1;
    Error *err = NULL;
    const char *name = qdict_get_str(qdict, ""name"");
    bs = find_vmstate_bs();
    if (!bs) {
        monitor_printf(mon, ""No block device supports snapshots\n"");
        return;
    }
    bs1 = NULL;
    while ((bs1 = bdrv_next(bs1))) {
        if (bdrv_can_snapshot(bs1)) {
            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);
            if (err) {
                monitor_printf(mon,
                               ""Error while deleting snapshot on device '%s':""
                               "" %s\n"",
                               bdrv_get_device_name(bs),
                               error_get_pretty(err));
                error_free(err);
            }
        }
    }
}","void do_delvm(Monitor *mon, const QDict *qdict)
{
    BlockDriverState *bs, *bs1;
    Error *err = NULL;
    const char *name = qdict_get_str(qdict, ""name"");
    bs = find_vmstate_bs();
    if (!bs) {
        monitor_printf(mon, ""No block device supports snapshots\n"");
        return;
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        bs1 = NULL;
        b = a;
    }
    while ((bs1 = bdrv_next(bs1))) {
        if (bdrv_can_snapshot(bs1)) {
            void *val;
            VideoState *ris = val;
            AVFormatContext *bank = NULL;
            ris->bank = bank;
            ris->max_frame_duration = (bank->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0;
            ris->realtime = is_realtime(bank);
            ris->show_mode = show_mode;
            ris->refresh_tid = SDL_CreateThread(refresh_thread, ris);
            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);
            if (err) {
                monitor_printf(mon,
                               ""Error while deleting snapshot on device '%s':""
                               "" %s\n"",
                               bdrv_get_device_name(bs),
                               error_get_pretty(err));
                error_free(err);
            }
        }
    }
}",0,1,36,0.92,Insert
1620,"void object_property_add(Object *obj, const char *name, const char *type,
                         ObjectPropertyAccessor *get,
                         ObjectPropertyAccessor *set,
                         ObjectPropertyRelease *release,
                         void *opaque, Error **errp)
{
    ObjectProperty *prop;
    QTAILQ_FOREACH(prop, &obj->properties, node) {
        if (strcmp(prop->name, name) == 0) {
            error_setg(errp, ""attempt to add duplicate property '%s'""
                       "" to object (type '%s')"", name,
                       object_get_typename(obj));
            return;
        }
    }
    prop = g_malloc0(sizeof(*prop));
    prop->name = g_strdup(name);
    prop->type = g_strdup(type);
    prop->get = get;
    prop->set = set;
    prop->release = release;
    prop->opaque = opaque;
    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);
}","void object_property_add(Object *obj, const char *name, const char *type,
                         ObjectPropertyAccessor *get,
                         ObjectPropertyAccessor *set,
                         ObjectPropertyRelease *release,
                         void *opaque, Error **errp)
{
    ObjectProperty *prop;
    QTAILQ_FOREACH(prop, &obj->properties, node) {
        if (strcmp(prop->name, name) == 0) {
            error_setg(errp, ""attempt to add duplicate property '%s'""
                       "" to object (type '%s')"", name,
                       object_get_typename(obj));
            return;
        }
    }
    prop = g_malloc0(sizeof(*prop));
    prop->name = g_strdup(name);
    prop->type = g_strdup(type);
    prop->get = get;
    prop->set = set;
    int a = 51;
    int b = a;
    if(a*b>0){
        prop->release = release;
    }
    void *frame;
    union tpacket_uhdr hash;
    hash.raw = frame;
    prop->opaque = opaque;
    TALLOC_CTX *mem_stack;
    struct pdb_methods *mut;
    struct dom_sid ** pmemrooms;
    struct ldb_dn *anon;
    unsigned int num_members;
    NTSTATUS obj_9;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
    		mut->private_data, struct pdb_samba_dsdb_state);
    obj_9 = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);
}",0,1,53,1.25,Insert
1623,"static void blk_send_response_all(struct XenBlkDev *blkdev)
{
    struct ioreq *ioreq;
    int send_notify = 0;
    while (!LIST_EMPTY(&blkdev->finished)) {
        ioreq = LIST_FIRST(&blkdev->finished);
	send_notify += blk_send_response_one(ioreq);
	ioreq_release(ioreq);
    }
    if (send_notify)
	xen_be_send_notify(&blkdev->xendev);
}","static void blk_send_response_all(struct XenBlkDev *blkdev)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        struct ioreq *ioreq;
    }
    int send_notify = 0;
    while (!LIST_EMPTY(&blkdev->finished)) {
        ioreq = LIST_FIRST(&blkdev->finished);
	send_notify += blk_send_response_one(ioreq);
	ioreq_release(ioreq);
	AVPacket * pk;
	AVFormatContext *s;
	int size               =  pk->size;
	AVIOContext *b_2     = s->b_2;
	if (size & 1)
	        avio_w8(b_2, 0);
    }
    if (send_notify)
	xen_be_send_notify(&blkdev->xendev);
}",0,1,13,0.33,Insert
1628,"static void save_native_fp_fsave(CPUState *env)
{
    int fptag, i, j;
    uint16_t fpuc;
    struct fpstate fp1, *fp = &fp1;
    asm volatile (""fsave %0"" : : ""m"" (*fp));
    env->fpuc = fp->fpuc;
    env->fpstt = (fp->fpus >> 11) & 7;
    env->fpus = fp->fpus & ~0x3800;
    fptag = fp->fptag;
    for(i = 0;i < 8; i++) {
        env->fptags[i] = ((fptag & 3) == 3);
        fptag >>= 2;
    }
    j = env->fpstt;
    for(i = 0;i < 8; i++) {
        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);
        j = (j + 1) & 7;
    }
    fpuc = 0x037f | (env->fpuc & (3 << 10));
    asm volatile(""fldcw %0"" : : ""m"" (fpuc));
}","static void save_native_fp_fsave(CPUState *env)
{
    int fptag, i, j;
    uint16_t fpuc;
    struct fpstate fp1, *fp = &fp1;
    asm volatile (""fsave %0"" : : ""m"" (*fp));
    env->fpuc = fp->fpuc;
    env->fpstt = (fp->fpus >> 11) & 7;
    env->fpus = fp->fpus & ~0x3800;
    fptag = fp->fptag;
    for(i = 0;i < 8; i++) {
        env->fptags[i] = ((fptag & 3) == 3);
        fptag >>= 2;
    }
    int a = 36;
    int b = a;
    if(a*b>0){
        j = env->fpstt;
    }
    for(i = 0;i < 8; i++) {
        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);
        j = (j + 1) & 7;
    }
    fpuc = 0x037f | (env->fpuc & (3 << 10));
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *cur  = NULL;
    cur  = p->data[0];
    asm volatile(""fldcw %0"" : : ""m"" (fpuc));
}",0,1,45,0.94,Insert
1633,"static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)
{
    char buffer[32];
    if (time) {
        time -= 2082844800;   
        strftime(buffer, sizeof(buffer), ""%Y-%m-%d %H:%M:%S"", gmtime(&time));
        av_metadata_set2(metadata, ""creation_time"", buffer, 0);
    }
}","static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)
{
    char buffer[32];
    if (time) {
        time -= 2082844800;   
        strftime(buffer, sizeof(buffer), ""%Y-%m-%d %H:%M:%S"", gmtime(&time));
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            av_metadata_set2(metadata, ""creation_time"", buffer, 0);
        strcpy(str, ""a"");
        }
    }
}",1,0,5,0.11,Replace
1637,"static int virtio_blk_exit_pci(PCIDevice *pci_dev)
{
    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);
    return virtio_exit_pci(pci_dev);
}","static int virtio_blk_exit_pci(PCIDevice *pci_dev)
{
    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
    struct zap_details *details;
    struct rb_root *root;
    struct vm_area_struct *vma;
    vma_interval_tree_foreach(vma, root,
    			details->first_index, details->last_index);
    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    if (!saved_server_config_defines) {
            init_config_defines(cli->pool);
    }
    return virtio_exit_pci(pci_dev);
}",0,1,55,0.46,Insert
1639,,,,,,,
1640,,,,,,,
1642,,,,,,,
1643,"static int compare_int64(const void *a, const void *b)
{
    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;
    return va < vb ? -1 : va > vb ? +1 : 0;
}","static int compare_int64(const void *a, const void *b)
{
    BlockDriverState *bs;
    IscsiLun *iscsilun = bs->opaque;
    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;
    IscsiLun *iscsilun = bs->opaque;
    if (max_xfer_len * iscsilun->block_size < INT_MAX) {
            bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;
    }
    char str_1[] = ""Constant"";
    while (strlen(str_1) > 5) {
        int64_t va = *(int64_t *)a, vb = *(int64_t *)b;
    strcpy(str_1, ""a"");
    }
    return va < vb ? -1 : va > vb ? +1 : 0;
}",1,0,7,0.34,Insert
1649,"void aio_set_event_notifier(AioContext *ctx,
                            EventNotifier *notifier,
                            bool is_external,
                            EventNotifierHandler *io_read,
                            AioPollFn *io_poll)
{
    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,
                       (IOHandler *)io_read, NULL, io_poll, notifier);
}","void aio_set_event_notifier(AioContext *ctx,
                            EventNotifier *notifier,
                            bool is_external,
                            EventNotifierHandler *io_read,
                            AioPollFn *io_poll)
{
    char *filename;
    g_free(filename);
    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,
                       (IOHandler *)io_read, NULL, io_poll, notifier);
}",0,1,6,0.23,Insert
1650,,,,,,,
1653,"static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,
                                 unsigned npfd, int64_t timeout)
{
    if (!ctx->epoll_available) {
        return false;
    }
    if (aio_epoll_enabled(ctx)) {
        return true;
    }
    if (npfd >= EPOLL_ENABLE_THRESHOLD) {
        if (aio_epoll_try_enable(ctx)) {
            return true;
        } else {
            aio_epoll_disable(ctx);
        }
    }
    return false;
}","static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,
                                 unsigned npfd, int64_t timeout)
{
    if (!ctx->epoll_available) {
        return false;
    }
    if (aio_epoll_enabled(ctx)) {
        return true;
    }
    if (npfd >= EPOLL_ENABLE_THRESHOLD) {
        if (aio_epoll_try_enable(ctx)) {
            return true;
        } else {
            aio_epoll_disable(ctx);
        }
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        return false;
        const char
            *attribute,
            *content;
        char
            *p,
            *xml;
        double
            value;
        value=InterpretLocaleValue(content,&p);
        (void) value;
    }
}",0,1,11,0.39,Insert
1654,"static void aarch64_cpu_register_types(void)
{
    int i;
    type_register_static(&aarch64_cpu_type_info);
    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {
        aarch64_cpu_register(&aarch64_cpus[i]);
    }
}","static void aarch64_cpu_register_types(void)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        int i;
    }
    type_register_static(&aarch64_cpu_type_info);
    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {
        aarch64_cpu_register(&aarch64_cpus[i]);
        DeviceState *mem = NULL;
        SysBusDevice *busDev;
        qdev_prop_set_uint32(mem, ""freq0"", 150000000);
        qdev_prop_set_uint32(mem, ""freq1"", 150000000);
        qdev_init_nofail(mem);
        busDev = SYS_BUS_DEVICE(mem);
        mem = qdev_create(NULL, ""highbank-regs"");
    }
}",0,1,9,0.4,Insert
1656,,,,,,,
1657,,,,,,,
1658,,,,,,,
1659,"void HELPER(wsr_ibreakenable)(uint32_t v)
{
    uint32_t change = v ^ env->sregs[IBREAKENABLE];
    unsigned i;
    for (i = 0; i < env->config->nibreak; ++i) {
        if (change & (1 << i)) {
            tb_invalidate_phys_page_range(
                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);
        }
    }
    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);
}","void HELPER(wsr_ibreakenable)(uint32_t v)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        uint32_t change = v ^ env->sregs[IBREAKENABLE];
    }
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    unsigned i;
    for (i = 0; i < env->config->nibreak; ++i) {
        if (change & (1 << i)) {
            tb_invalidate_phys_page_range(
                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);
        }
    }
    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);
}",0,1,18,0.65,Insert
1660,"static void openrisc_cpu_class_init(ObjectClass *oc, void *data)
{
    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);
    CPUClass *cc = CPU_CLASS(occ);
    DeviceClass *dc = DEVICE_CLASS(oc);
    occ->parent_realize = dc->realize;
    dc->realize = openrisc_cpu_realizefn;
    occ->parent_reset = cc->reset;
    cc->reset = openrisc_cpu_reset;
    cc->class_by_name = openrisc_cpu_class_by_name;
    cc->has_work = openrisc_cpu_has_work;
    cc->do_interrupt = openrisc_cpu_do_interrupt;
    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;
    cc->dump_state = openrisc_cpu_dump_state;
    cc->set_pc = openrisc_cpu_set_pc;
    cc->gdb_read_register = openrisc_cpu_gdb_read_register;
    cc->gdb_write_register = openrisc_cpu_gdb_write_register;
#ifdef CONFIG_USER_ONLY
    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;
#else
    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;
    dc->vmsd = &vmstate_openrisc_cpu;
#endif
    cc->gdb_num_core_regs = 32 + 3;
    dc->cannot_destroy_with_object_finalize_yet = true;
}","static void openrisc_cpu_class_init(ObjectClass *oc, void *data)
{
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    void (*bc)(NPP id, uint32 er_ids);
    void (*bc)(NPP id, uint32 er_ids);
    uint32 increvals;
    TimerInfo information;
    uint32 er_ids;
    er_ids = next_timer_info_;
    timers_[er_ids] = information;
    message_loop_->PostDelayedTask(FROM_HERE,
                                     NewRunnableMethod(this,
                                                       &PluginInstance::OnTimerCall,
                                                       bc,
                                                       npp_,
                                                       er_ids),
                                     increvals);
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_has_day (dt));
    fail_unless (gst_date_time_has_time (dt));
    fail_unless (!gst_date_time_has_second (dt));
    str = gst_date_time_to_iso8601_string (dt);
    dt2 = gst_date_time_new_from_iso8601_string (str);
    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);
    CPUClass *cc = CPU_CLASS(occ);
    int a = 21;
    int b = a;
    if(a*b>0){
        DeviceClass *dc = DEVICE_CLASS(oc);
    }
    occ->parent_realize = dc->realize;
    dc->realize = openrisc_cpu_realizefn;
    occ->parent_reset = cc->reset;
    cc->reset = openrisc_cpu_reset;
    cc->class_by_name = openrisc_cpu_class_by_name;
    cc->has_work = openrisc_cpu_has_work;
    cc->do_interrupt = openrisc_cpu_do_interrupt;
    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;
    cc->dump_state = openrisc_cpu_dump_state;
    cc->set_pc = openrisc_cpu_set_pc;
    cc->gdb_read_register = openrisc_cpu_gdb_read_register;
    cc->gdb_write_register = openrisc_cpu_gdb_write_register;
#ifdef CONFIG_USER_ONLY
    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;
#else
    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;
    dc->vmsd = &vmstate_openrisc_cpu;
#endif
    cc->gdb_num_core_regs = 32 + 3;
    dc->cannot_destroy_with_object_finalize_yet = true;
}",1,0,75,1.19,Insert
1661,"static void tcp_accept_incoming_migration(void *opaque)
{
    struct sockaddr_in addr;
    socklen_t addrlen = sizeof(addr);
    int s = (intptr_t)opaque;
    QEMUFile *f;
    int c;
    do {
        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);
    } while (c == -1 && socket_error() == EINTR);
    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);
    closesocket(s);
    DPRINTF(""accepted migration\n"");
    if (c == -1) {
        fprintf(stderr, ""could not accept migration connection\n"");
        goto out;
    }
    f = qemu_fopen_socket(c, ""rb"");
    if (f == NULL) {
        fprintf(stderr, ""could not qemu_fopen socket\n"");
        goto out;
    }
    process_incoming_migration(f);
    return;
out:
    closesocket(c);
}","static void tcp_accept_incoming_migration(void *opaque)
{
    struct sockaddr_in addr;
    socklen_t addrlen = sizeof(addr);
    int s = (intptr_t)opaque;
    QEMUFile *f;
    void *opaque_2;
    target_phys_addr_t addr_10;
    int offset = addr_10;
    struct omap_intr_handler_s *s_5 = (struct omap_intr_handler_s *) opaque_2;
    int bank_no, line_no;
    struct omap_intr_handler_bank_s *bank = NULL;
    if ((offset & 0xf80) == 0x80) {
            bank_no = (offset & 0x60) >> 5;
            if (bank_no < s_5->nbanks) {
                offset &= ~0x60;
                bank = &s_5->bank[bank_no];
            }
    }
    int c;
    do {
        int a = 2;
        int b = 3;
        while (a != b) {
            c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);
            b = a;
        }
    } while (c == -1 && socket_error() == EINTR);
    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);
    closesocket(s);
    DPRINTF(""accepted migration\n"");
    if (c == -1) {
        fprintf(stderr, ""could not accept migration connection\n"");
        goto out;
    }
    f = qemu_fopen_socket(c, ""rb"");
    if (f == NULL) {
        fprintf(stderr, ""could not qemu_fopen socket\n"");
        goto out;
    }
    process_incoming_migration(f);
    return;
out:
    closesocket(c);
}",1,0,58,0.96,Insert
1662,"static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)
{
    int i;
    assert(dest->niov == source->niov);
    assert(dest->size == source->size);
    for (i = 0; i < source->niov; i++) {
        assert(dest->iov[i].iov_len == source->iov[i].iov_len);
        memcpy(dest->iov[i].iov_base,
               source->iov[i].iov_base,
               source->iov[i].iov_len);
    }
}","static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)
{
    int i;
    assert(dest->niov == source->niov);
    int a = 2;
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (!gst_date_time_has_second (dt));
    str = gst_date_time_to_iso8601_string (dt);
    dt2 = gst_date_time_new_from_iso8601_string (str);
    fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    int b = 3;
    while (a != b) {
        assert(dest->size == source->size);
        b = a;
    }
    for (i = 0; i < source->niov; i++) {
        assert(dest->iov[i].iov_len == source->iov[i].iov_len);
        memcpy(dest->iov[i].iov_base,
               source->iov[i].iov_base,
               source->iov[i].iov_len);
    }
}",1,0,27,0.85,Insert
1666,"int xen_be_send_notify(struct XenDevice *xendev)
{
    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);
}","int xen_be_send_notify(struct XenDevice *xendev)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
        return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);
    }
}",0,1,8,0.21,Insert
1667,"static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)
{
    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&
        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {
        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&
            timestamp < st->pts_wrap_reference)
            return timestamp + (1ULL<<st->pts_wrap_bits);
        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&
            timestamp >= st->pts_wrap_reference)
            return timestamp - (1ULL<<st->pts_wrap_bits);
    }
    return timestamp;
}","static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)
{
    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&
        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {
        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&
            timestamp < st->pts_wrap_reference)
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                return timestamp + (1ULL<<st->pts_wrap_bits);
            strcpy(str, ""a"");
            }
        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&
            timestamp >= st->pts_wrap_reference)
            return timestamp - (1ULL<<st->pts_wrap_bits);
    }
    return timestamp;
}",0,1,8,0.15,Replace
1669,"static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,
                                  uint32_t val)
{
    MiscState *s = opaque;
    uint32_t saddr;
    saddr = addr & LED_MAXADDR;
    MISC_DPRINTF(""Write diagnostic LED reg 0x"" TARGET_FMT_plx "" =  %x\n"", addr,
                 val);
    switch (saddr) {
    case 0:
        s->leds = val;
        break;
    default:
        break;
    }
}","static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,
                                  uint32_t val)
{
    MiscState *s = opaque;
    uint32_t saddr;
    saddr = addr & LED_MAXADDR;
    MISC_DPRINTF(""Write diagnostic LED reg 0x"" TARGET_FMT_plx "" =  %x\n"", addr,
                 val);
                 DeviceState *mem = NULL;
                 SysBusDevice *busDev;
                 qdev_prop_set_uint32(mem, ""freq0"", 150000000);
                 qdev_prop_set_uint32(mem, ""freq1"", 150000000);
                 qdev_init_nofail(mem);
                 busDev = SYS_BUS_DEVICE(mem);
                 FDCharDriver *s_2;
                 s_2->fd_out = io_channel_from_fd(fd_out);
                 fcntl(fd_out, F_SETFL, O_NONBLOCK);
                 mem = qdev_create(NULL, ""highbank-regs"");
    switch (saddr) {
    case 0:
        int a = 2;
        int b = 3;
        while (a < b) {
            s->leds = val;
            b = a;
        }
        break;
    default:
        break;
        VirtioCcwDevice *dev;
        VirtIODevice *vdev;
        SubchDev *sch;
        unsigned int cssid = 0;
        DeviceState *parent = DEVICE(dev);
        unsigned int schid;
        unsigned int ssid = 0;
        sch->id.cu_type = VIRTIO_CCW_CU_TYPE;
        vdev = virtio_ccw_get_vdev(sch);
        sch->id.cu_model = vdev->device_id;
        css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
                                  parent->hotplugged, 1);
        g_free(sch);
    }
}",0,1,75,0.96,Insert
1671,,,,,,,
1672,"static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,
                             TCGReg rd, TCGReg rn, uint64_t limm)
{
    unsigned h, l, r, c;
    assert(is_limm(limm));
    h = clz64(limm);
    l = ctz64(limm);
    if (l == 0) {
        r = 0;                   
        c = ctz64(~limm) - 1;
        if (h == 0) {
            r = clz64(~limm);    
            c += r;
        }
    } else {
        r = 64 - l;              
        c = r - h - 1;
    }
    if (ext == TCG_TYPE_I32) {
        r &= 31;
        c &= 31;
    }
    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);
}","static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,
                             TCGReg rd, TCGReg rn, uint64_t limm)
{
    unsigned h, l, r, c;
    assert(is_limm(limm));
    h = clz64(limm);
    char str1[] = ""Constant"";
    GF_BitStream *bits;
    GF_Box *s_3;
    GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s_3;
    struct net_device *netdev;
    struct cfg80211_registered_device *rdev;
    struct sk_buff *img;
    void *hrm;
    img = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
    hrm = nl80211hdr_put(img, 0, 0, 0, NL80211_CMD_DISCONNECT);
    NLA_PUT_U32(img, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
    NLA_PUT_U32(img, NL80211_ATTR_IFINDEX, netdev->ifindex);
    genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), img, 0,
    				nl80211_mlme_mcgrp.id, GFP_KERNEL);
    GF_Err e;
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
    ISOM_DECREASE_SIZE(buf, 8);
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        l = ctz64(limm);
    }
    if (l == 0) {
        r = 0;                   
        c = ctz64(~limm) - 1;
        if (h == 0) {
            r = clz64(~limm);    
            c += r;
        }
    } else {
        r = 64 - l;              
        c = r - h - 1;
    }
    if (ext == TCG_TYPE_I32) {
        r &= 31;
        c &= 31;
    }
    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);
}",0,1,81,1.3,Insert
1675,"static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,
                                            const char *json_string)
{
    return visitor_input_test_init_internal(data, json_string, NULL);
}","static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,
                                            const char *json_string)
{
    int a = 2;
    MachineState *machine;
    char *filename;
    DisasContext *qs;
    BlkTransactionState *parent, *next;
    QSIMPLEQ_FOREACH(parent, &snap_bdrv_states, entry)
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    err = extract32(ksns, 16, 5);
    handle_fp_compare(qs, order, coll, err, false, p);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    long load_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    int b = 3;
    while (a != b) {
        return visitor_input_test_init_internal(data, json_string, NULL);
        b = a;
    }
}",0,1,86,0.87,Insert
1676,"static void do_info_version(Monitor *mon)
{
    monitor_printf(mon, ""%s\n"", QEMU_VERSION);
}","static void do_info_version(Monitor *mon)
{
    void *rma = NULL;
    hwaddr rma_alloc_size;
    MemoryRegion *sysmem = get_system_memory();
    MemoryRegion *rma_region;
    if (rma_alloc_size && rma) {
            rma_region = g_new(MemoryRegion, 1);
            memory_region_init_ram_ptr(rma_region, NULL, ""ppc_spapr.rma"",
                                       rma_alloc_size, rma);
            vmstate_register_ram_global(rma_region);
            memory_region_add_subregion(sysmem, 0, rma_region);
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        monitor_printf(mon, ""%s\n"", QEMU_VERSION);
    }
}",0,1,4,0.22,Insert
1679,"void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_4w_msa(src + stride - 2,
                           src - (stride * 2) +
                           sizeof(uint8_t), stride, dst, stride, 4);
}","void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_4w_msa(src + stride - 2,
                           src - (stride * 2) +
                           GF_Filter *process;
                           GF_FilterPid *pid;
                           CTXLoadPriv *git = gf_filter_get_udta(process);
                           gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW) );
                           gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
                           gf_filter_pid_set_udta(pid, git->out_pid);
                           git->file_size = 0;
                           git->load_flags = 0;
                           sizeof(uint8_t), stride, dst, stride, 4);
}",0,1,1,0.28,Insert
1685,,,,,,,
1686,"static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,
                                   int size)
{
    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);
    memcpy(&scon->iov[scon->iov_bs], buf, size);
    scon->iov_data_len += size;
    scon->iov_sclp_rest += size;
    scon->iov_bs += size;
    scon->event.event_pending = true;
}","static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,
                                   int size)
{
    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        memcpy(&scon->iov[scon->iov_bs], buf, size);
    }
    scon->iov_data_len += size;
    scon->iov_sclp_rest += size;
    scon->iov_bs += size;
    scon->event.event_pending = true;
}",1,0,3,0.1,Replace
1687,"static void usbredir_do_attach(void *opaque)
{
    USBRedirDevice *dev = opaque;
    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(
                                    usb_redir_cap_ep_info_max_packet_size) &&
                                    usb_redir_cap_64bits_ids))) {
        ERROR(""usb-redir-host lacks capabilities needed for use with XHCI\n"");
        usbredir_reject_device(dev);
        return;
    }
    if (usb_device_attach(&dev->dev) != 0) {
        WARNING(""rejecting device due to speed mismatch\n"");
        usbredir_reject_device(dev);
    }
}","static void usbredir_do_attach(void *opaque)
{
    USBRedirDevice *dev = opaque;
    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(
                                    usb_redir_cap_ep_info_max_packet_size) &&
                                    usb_redir_cap_64bits_ids))) {
        int a = 2;
        int b = 2;
        if (a == b) {
            ERROR(""usb-redir-host lacks capabilities needed for use with XHCI\n"");
        }
        usbredir_reject_device(dev);
        return;
    }
    if (usb_device_attach(&dev->dev) != 0) {
        TfLiteContext* function;
        TfLiteNode* plan;
        const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
        const TfLiteTensor* facing =
              (plan->inputs->size == 3)
                  ? GetOptionalInputTensor(function, plan, kBiasTensor)
                  : nullptr;
        const TfLiteTensor* sort = GetInput(function, plan, kWeightsTensor);
        const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
        TfLiteIntArray* output_size_array = nullptr;
        TfLiteTensor* write = GetOutput(function, plan, kOutputTensor);
        TF_LITE_ENSURE_STATUS(
              CheckTypes(function, input, sort, facing, write, params));
        TF_LITE_ENSURE_OK(function,
                            function->ResizeTensor(function, write, output_size_array));
        WARNING(""rejecting device due to speed mismatch\n"");
        usbredir_reject_device(dev);
    }
}",1,0,18,0.52,Insert
1688,"static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)
{
    int ch, bw_code;
    if (cutoff) {
        int fbw_coeffs;
        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);
        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;
        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);
    } else {
        bw_code = 50;
    }
    for (ch = 0; ch < s->fbw_channels; ch++) {
        s->bandwidth_code[ch] = bw_code;
        s->nb_coefs[ch]       = bw_code * 3 + 73;
    }
    if (s->lfe_on)
        s->nb_coefs[s->lfe_channel] = 7;  
}","static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        int ch, bw_code;
        b = a;
        UINT16* channel_id;
        UINT16* length;
        STREAM* s_4;
        if (*length > 4)
        		stream_read_UINT16(s_4, *channel_id);  
        	else
        		*channel_id = 0;
    }
    if (cutoff) {
        int fbw_coeffs;
        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);
        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;
        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);
    } else {
        bw_code = 50;
    }
    for (ch = 0; ch < s->fbw_channels; ch++) {
        s->bandwidth_code[ch] = bw_code;
        s->nb_coefs[ch]       = bw_code * 3 + 73;
    }
    if (s->lfe_on)
        s->nb_coefs[s->lfe_channel] = 7;  
}",0,1,18,0.78,Insert
1690,"static void xtensa_kc705_init(MachineState *machine)
{
    static const LxBoardDesc kc705_board = {
        .flash_base = 0xf0000000,
        .flash_size = 0x08000000,
        .flash_boot_base = 0x06000000,
        .flash_sector_size = 0x20000,
        .sram_size = 0x2000000,
    };
    lx_init(&kc705_board, machine);
}","static void xtensa_kc705_init(MachineState *machine)
{
    static const LxBoardDesc kc705_board = {
        .flash_base = 0xf0000000,
        .flash_size = 0x08000000,
        .flash_boot_base = 0x06000000,
        .flash_sector_size = 0x20000,
        .sram_size = 0x2000000,
    };
    int a = 35;
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
    int b = a;
    if(a*b>0){
        lx_init(&kc705_board, machine);
    }
}",0,1,5,0.26,Insert
1691,"static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,
                               unsigned int len)
{
    unsigned int offset;
    int i;
    offset = 0;
    for (i = 0; i < elem->in_num; i++) {
        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);
        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,
                                  elem->in_sg[i].iov_len,
                                  1, size);
        offset += size;
    }
    for (i = 0; i < elem->out_num; i++)
        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,
                                  elem->out_sg[i].iov_len,
                                  0, elem->out_sg[i].iov_len);
}","static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,
                               unsigned int len)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        unsigned int offset;
    }
    int i;
    offset = 0;
    for (i = 0; i < elem->in_num; i++) {
        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);
        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,
                                  elem->in_sg[i].iov_len,
                                  1, size);
                                  VirtioCcwDevice *dev;
                                  Error *err = NULL;
                                  VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
                                  DeviceState *parent = DEVICE(dev);
                                  if (k->realize) {
                                          k->realize(dev, &err);
                                  }
        offset += size;
    }
    for (i = 0; i < elem->out_num; i++)
        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,
                                  elem->out_sg[i].iov_len,
                                  0, elem->out_sg[i].iov_len);
}",0,1,27,0.99,Insert
1692,"static int vmdk_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    BDRVVmdkState *s;
    int ret = -1;
    int i;
    VmdkExtent *e;
    assert(state != NULL);
    assert(state->bs != NULL);
    if (queue == NULL) {
        error_setg(errp, ""No reopen queue for VMDK extents"");
        goto exit;
    }
    s = state->bs->opaque;
    assert(s != NULL);
    for (i = 0; i < s->num_extents; i++) {
        e = &s->extents[i];
        if (e->file != state->bs->file) {
            bdrv_reopen_queue(queue, e->file, state->flags);
        }
    }
    ret = 0;
exit:
    return ret;
}","static int vmdk_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    BDRVVmdkState *s;
    int ret = -1;
    int i;
    VmdkExtent *e;
    assert(state != NULL);
    assert(state->bs != NULL);
    if (queue == NULL) {
        error_setg(errp, ""No reopen queue for VMDK extents"");
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            goto exit;
        strcpy(str, ""a"");
        }
    }
    s = state->bs->opaque;
    assert(s != NULL);
    for (i = 0; i < s->num_extents; i++) {
        e = &s->extents[i];
        if (e->file != state->bs->file) {
            AVCodecContext *avctx;
            void *rma = NULL;
            hwaddr rma_alloc_size;
            MemoryRegion *sysmem = get_system_memory();
            MemoryRegion *rma_region;
            int c_7, cnt;
            int val;
            struct timeval t1, t2;
            int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
            int64_t alpha;
            int total = 0;
            print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
            if (rma_alloc_size && rma) {
                    rma_region = g_new(MemoryRegion, 1);
                    memory_region_init_ram_ptr(rma_region, NULL, ""ppc_spapr.rma"",
                                               rma_alloc_size, rma);
                    vmstate_register_ram_global(rma_region);
                    memory_region_add_subregion(sysmem, 0, rma_region);
            }
            int sample_scale, c, n, i_3;
            int sample_scale, c, n, i_3;
            PCMDecode *s_10 = avctx->priv_data;
            sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
            n = avctx->channels * sample_scale;
            bdrv_reopen_queue(queue, e->file, state->flags);
        }
    }
    ret = 0;
exit:
    return ret;
}",0,1,91,1.36,Insert
1693,"static inline void tcg_out_goto_label(TCGContext *s, int label_index)
{
    TCGLabel *l = &s->labels[label_index];
    if (!l->has_value) {
        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);
        tcg_out_goto_noaddr(s);
    } else {
        tcg_out_goto(s, l->u.value_ptr);
    }
}","static inline void tcg_out_goto_label(TCGContext *s, int label_index)
{
    TCGLabel *l = &s->labels[label_index];
    if (!l->has_value) {
        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);
        tcg_out_goto_noaddr(s);
    } else {
        const AVFrame *capt;
        char *dn, *ufn;
        char *dn, *ufn;
        ufn = ldap_dn2ufn(dn);
        const AVFrame *const p = capt;
        uint8_t *last = NULL;
        uint8_t *zero = NULL;
        zero = last = av_mallocz(p->linesize[0]);
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            tcg_out_goto(s, l->u.value_ptr);
        }
    }
}",0,1,41,0.64,Insert
1695,,,,,,,
1696,"static int xenfb_send_motion(struct XenInput *xenfb,
			     int rel_x, int rel_y, int rel_z)
{
    union xenkbd_in_event event;
    memset(&event, 0, XENKBD_IN_EVENT_SIZE);
    event.type = XENKBD_TYPE_MOTION;
    event.motion.rel_x = rel_x;
    event.motion.rel_y = rel_y;
#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207
    event.motion.rel_z = rel_z;
#endif
    return xenfb_kbd_event(xenfb, &event);
}","static int xenfb_send_motion(struct XenInput *xenfb,
			     int rel_x, int rel_y, int rel_z)
{
    union xenkbd_in_event event;
    memset(&event, 0, XENKBD_IN_EVENT_SIZE);
    event.type = XENKBD_TYPE_MOTION;
    event.motion.rel_x = rel_x;
    event.motion.rel_y = rel_y;
#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207
    event.motion.rel_z = rel_z;
    struct sk_buff *skb;
    struct hci_dev *hdev;
    void *settings;
    __u8 status = *((__u8 *) skb->data);
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *dev = aml_device(""%s"", ""PCI0"");
    aml_append(dev, coll);
    settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
    data = get_unaligned_le16(settings);
#endif
GF_ISOFile  *photo;
voidpf timeout;
timeout=RelinquishMagickMemory(timeout);
GF_TrackBox                 *trak;
if (!photo->keep_utc)
		trak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return xenfb_kbd_event(xenfb, &event);
    strcpy(str, ""a"");
    }
}",0,1,119,1.19,Insert
1700,"static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)
{
    int pos = 0;
    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",
                    info->name, info->bus_info->name);
    if (info->alias)
        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);
    if (info->desc)
        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);
    if (info->no_user)
        pos += snprintf(dest+pos, len-pos, "", no-user"");
    return pos;
}","static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)
{
    int pos_part1 = -6;
    int pos_part2 = 6;
    int pos = pos_part1 + pos_part2;
    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",
                    info->name, info->bus_info->name);
                    DeviceState *mem = NULL;
                    SysBusDevice *busDev;
                    qdev_prop_set_uint32(mem, ""freq0"", 150000000);
                    qdev_prop_set_uint32(mem, ""freq1"", 150000000);
                    qdev_init_nofail(mem);
                    busDev = SYS_BUS_DEVICE(mem);
                    mem = qdev_create(NULL, ""highbank-regs"");
    if (info->alias)
        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);
    if (info->desc)
        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);
    if (info->no_user)
        pos += snprintf(dest+pos, len-pos, "", no-user"");
    return pos;
}",0,1,10,0.89,Insert
1704,"static int write_l1_entry(BlockDriverState *bs, int l1_index)
{
    BDRVQcowState *s = bs->opaque;
    uint64_t buf[L1_ENTRIES_PER_SECTOR];
    int l1_start_index;
    int i, ret;
    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);
    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {
        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);
    }
    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);
    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,
        buf, sizeof(buf));
    if (ret < 0) {
        return ret;
    }
    return 0;
}","static int write_l1_entry(BlockDriverState *bs, int l1_index)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        BDRVQcowState *s = bs->opaque;
        b += 1;
    }
    uint64_t buf[L1_ENTRIES_PER_SECTOR];
    int l1_start_index;
    int i, ret;
    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {
        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);
    }
    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);
    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,
        buf, sizeof(buf));
    if (ret < 0) {
        return ret;
    }
    return 0;
}",1,0,22,0.85,Insert
1706,,,,,,,
1707,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)
{
    int r, b;
    b = cdt[p2];
    r = cdt[p1]<<16;
    return (b+r) << 1;
}","static int make_cdt24_entry(int p1, int p2, int16_t *cdt)
{
    char *param, cache[128], tc[128];
    char *param, cache[128], tc[128];
    tc[0].tag[0] = 0;
    strcpy_5(tc[0].param[PARAM_SIZE],  ""{\\fs}"");
    strcpy_5(tc[0].param[PARAM_COLOR], ""{\\c}"");
    strcpy_5(tc[0].param[PARAM_FACE],  ""{\\fn}"");
    int r, b;
    char str_1[] = ""Constant"";
    while (strlen(str_1) > 5) {
        b = cdt[p2];
    strcpy(str_1, ""a"");
    }
    r = cdt[p1]<<16;
    return (b+r) << 1;
}",1,0,10,0.43,Insert
1710,"static inline void downmix_3f_2r_to_mono(float *samples)
{
    int i;
    for (i = 0; i < 256; i++) {
        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);
        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;
    }
}","static inline void downmix_3f_2r_to_mono(float *samples)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        int i;
        const AVFrame *capt;
        const AVFrame *const p = capt;
        uint8_t *last = NULL;
        uint8_t *zero = NULL;
        zero = last = av_mallocz(p->linesize[0]);
        av_freep(&zero);
        av_freep(&zero);
    }
    for (i = 0; i < 256; i++) {
        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);
        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;
    }
}",0,1,26,0.67,Insert
1711,,,,,,,
1712,"static int no_init_in (HWVoiceIn *hw, struct audsettings *as)
{
    audio_pcm_init_info (&hw->info, as);
    hw->samples = 1024;
    return 0;
}","static int no_init_in (HWVoiceIn *hw, struct audsettings *as)
{
    audio_pcm_init_info (&hw->info, as);
    int a = 2;
    int b = 2;
    if (a == b) {
        hw->samples = 1024;
    }
    return 0;
}",1,0,1,0.05,Replace
1714,"static int block_save_complete(QEMUFile *f, void *opaque)
{
    int ret;
    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",
            block_mig_state.submitted, block_mig_state.transferred);
    ret = flush_blks(f);
    if (ret) {
        return ret;
    }
    blk_mig_reset_dirty_cursor();
    blk_mig_lock();
    assert(block_mig_state.submitted == 0);
    blk_mig_unlock();
    do {
        ret = blk_mig_save_dirty_block(f, 0);
        if (ret < 0) {
            return ret;
        }
    } while (ret == 0);
    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);
    DPRINTF(""Block migration completed\n"");
    qemu_put_be64(f, BLK_MIG_FLAG_EOS);
    blk_mig_cleanup();
    return 0;
}","static int block_save_complete(QEMUFile *f, void *opaque)
{
    int ret;
    int64_t sector_num;
    int nb_sectors;
    NbdClientSession *client;
    struct nbd_request request;
    ssize_t ret_2;
    request.type = NBD_CMD_READ;
    request.from = sector_num * 512;
    request.len = nb_sectors * 512;
    nbd_coroutine_start(client, &request);
    ret_2 = nbd_co_send_request(client, &request, NULL, 0);
    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",
            block_mig_state.submitted, block_mig_state.transferred);
    ret = flush_blks(f);
    if (ret) {
        return ret;
    }
    blk_mig_reset_dirty_cursor();
    blk_mig_lock();
    assert(block_mig_state.submitted == 0);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        blk_mig_unlock();
    }
    do {
        ret = blk_mig_save_dirty_block(f, 0);
        if (ret < 0) {
            return ret;
        }
    } while (ret == 0);
    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);
    DPRINTF(""Block migration completed\n"");
    qemu_put_be64(f, BLK_MIG_FLAG_EOS);
    blk_mig_cleanup();
    return 0;
}",1,0,32,0.74,Insert
1716,"void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)
{
    c->high = 255;
    c->bits = -16;
    c->buffer = buf;
    c->end = buf + buf_size;
    c->code_word = bytestream_get_be24(&c->buffer);
}","void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)
{
    CPUState *cpu;
    int prot;
    hwaddr paddr;
    target_ulong vaddr;
    MemTxAttrs attrs;
    hwaddr iotlb, xlat, sz;
    hwaddr iotlb, xlat, sz;
    MemoryRegionSection *section;
    int asidx = cpu_asidx_from_attrs(cpu, attrs);
    hwaddr iotlb, xlat, sz;
    CPUArchState *env = cpu->env_ptr;
    target_ulong address;
    assert_cpu_is_self(cpu);
    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);
    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,
                                                prot, &address);
    c->high = 255;
    c->bits = -16;
    int a = 2;
    int b = 3;
    if (a != b) {
        c->buffer = buf;
    }
    c->end = buf + buf_size;
    c->code_word = bytestream_get_be24(&c->buffer);
}",1,0,20,0.53,Insert
1719,"void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)
{
    uintptr_t addr = (uintptr_t)data;
    g_assert(addr >= QPCI_PIO_LIMIT);
    dev->bus->memread(dev->bus, addr, buf, len);
}","void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)
{
    const int stride;
    const int stride_5;
    const int lim_q1_10;
    const int filter_q1_8;
    const int filter_p1_2;
    const int lim_p1_10;
    const int lim_p0q0_2;
    const int audio_7;
    const int binary_1;
    uint8_t *src_7;
    rv40_weak_loop_filter_3(src_7, stride_5, 1, filter_p1_2, filter_q1_8,
                              audio_7, binary_1, lim_p0q0_2, lim_q1_10, lim_p1_10);
    const int lim_q1;
    const int filter_q1;
    const int filter_p1;
    const int lim_p1;
    const int lim_p0q0;
    const int audio;
    const int binary;
    uint8_t *src;
    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,
                              audio, binary, lim_p0q0, lim_q1, lim_p1);
    int a = 2;
    int b = 3;
    while (a != b) {
        uintptr_t addr = (uintptr_t)data;
        b = a;
    }
    g_assert(addr >= QPCI_PIO_LIMIT);
    dev->bus->memread(dev->bus, addr, buf, len);
}",1,0,39,0.73,Insert
1721,"void Release(void *ctx)
{
    ContextInfo *ci;
    ci = (ContextInfo *) ctx;
    if (ci->cache) {
        imlib_context_set_image(ci->cache->image);
        imlib_free_image();
        av_free(ci->cache);
    }
    if (ctx) {
        if (ci->imageOverlaid) {
            imlib_context_set_image(ci->imageOverlaid);
            imlib_free_image();
        }
        ff_eval_free(ci->expr_x);
        ff_eval_free(ci->expr_y);
        ff_eval_free(ci->expr_R);
        ff_eval_free(ci->expr_G);
        ff_eval_free(ci->expr_B);
        sws_freeContext(ci->toRGB_convert_ctx);
        sws_freeContext(ci->fromRGB_convert_ctx);
        av_free(ctx);
    }
}","void Release(void *ctx)
{
    ContextInfo *ci;
    int64_t sector_num;
    void (*cb)(void *opaque, int ret);
    int nsector, remainder;
    int extra = 0;
    DBDMA_io *io = opaque;
    MACIO_DPRINTF(""--- DMA write transfer - addr: %"" HWADDR_PRIx "" len: %x
    "",
                      io->addr, io->len);
    MACIO_DPRINTF(""--- Block write transfer   - sector_num: %""PRIx64""  ""
                      ""nsector: %x
    "", sector_num, nsector + extra);
    ci = (ContextInfo *) ctx;
    if (ci->cache) {
        int a = 2;
        int b = 2;
        while (a == b) {
            imlib_context_set_image(ci->cache->image);
            b += 1;
        }
        imlib_free_image();
        av_free(ci->cache);
    }
    if (ctx) {
        if (ci->imageOverlaid) {
            imlib_context_set_image(ci->imageOverlaid);
            imlib_free_image();
        }
        ff_eval_free(ci->expr_x);
        ff_eval_free(ci->expr_y);
        ff_eval_free(ci->expr_R);
        ff_eval_free(ci->expr_G);
        ff_eval_free(ci->expr_B);
        sws_freeContext(ci->toRGB_convert_ctx);
        sws_freeContext(ci->fromRGB_convert_ctx);
        av_free(ctx);
    }
}",1,0,32,0.82,Insert
1722,,,,,,,
1723,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,
                                                         PutBitContext *pb, const float *in, float *out,
                                                         const float *scaled, int size, int scale_idx,
                                                         int cb, const float lambda, const float uplim,
                                                         int *bits, const float ROUNDING) {
    int i;
    if (bits)
        *bits = 0;
    if (out) {
        for (i = 0; i < size; i += 4) {
           out[i  ] = 0.0f;
           out[i+1] = 0.0f;
           out[i+2] = 0.0f;
           out[i+3] = 0.0f;
        }
    }
}","static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,
                                                         PutBitContext *pb, const float *in, float *out,
                                                         const float *scaled, int size, int scale_idx,
                                                         int cb, const float lambda, const float uplim,
                                                         int *bits, const float ROUNDING) {
    uint32_t pvr;
    ppc_def_t **def;
    int i_6, ret;
    int i_6, ret;
    for (i_6 = 0; ppc_defs[i_6].name != NULL; i_6++) {
            if ((pvr & ppc_defs[i_6].pvr_mask) ==
                (ppc_defs[i_6].pvr & ppc_defs[i_6].pvr_mask)) {
                *def = &ppc_defs[i_6];
                ret = 0;
                break;
            }
    }
    int i;
    if (bits)
        *bits = 0;
    if (out) {
        GDateTime *gdt, *gdt2;
        GstDateTime *dt, *dt2;
        fail_unless (gst_date_time_get_day (dt) ==
              g_date_time_get_day_of_month (gdt));
        fail_unless (gst_date_time_get_hour (dt) == 15);
        fail_unless (gst_date_time_get_minute (dt) == 50);
        fail_unless (!gst_date_time_has_second (dt));
        gst_date_time_unref (dt);
        for (i = 0; i < size; i += 4) {
           char str1[] = ""Constant"";
           char str2[] = ""Constant"";
           if (strcmp(str1, str2) == 0) {
               out[i  ] = 0.0f;
           }
           out[i+1] = 0.0f;
           out[i+2] = 0.0f;
           out[i+3] = 0.0f;
        }
    }
}",1,0,48,1.05,Insert
1724,,,,,,,
1725,,,,,,,
1726,"static void coroutine_fn c1_fn(void *opaque)
{
    Coroutine *c2 = opaque;
    qemu_coroutine_enter(c2, NULL);
}","static void coroutine_fn c1_fn(void *opaque)
{
    Coroutine *c2 = opaque;
    QDict *addr = NULL;
    Visitor *iv = NULL;
    QObject *crumpled_addr = NULL;
    qdict_extract_subqdict(options, &addr, ""server."");
    crumpled_addr = qdict_crumple(addr, errp);
    iv = qobject_input_visitor_new(crumpled_addr);
    qobject_decref(crumpled_addr);
    int a = 2;
    int b = 3;
    while (a < b) {
        qemu_coroutine_enter(c2, NULL);
        b = a;
    }
}",1,0,13,0.41,Insert
1727,,,,,,,
1728,,,,,,,
1729,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)
{
    unsigned i;
    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {
        ERRPRINT(""Can't write to data buffer: buffer full\n"");
        return;
    }
    for (i = 0; i < size; i++) {
        s->fifo_buffer[s->data_count] = value & 0xFF;
        s->data_count++;
        value >>= 8;
        if (s->data_count >= (s->blksize & 0x0fff)) {
            DPRINT_L2(""write buffer filled with %u bytes of data\n"",
                    s->data_count);
            s->data_count = 0;
            s->prnsts &= ~SDHC_SPACE_AVAILABLE;
            if (s->prnsts & SDHC_DOING_WRITE) {
                SDHCI_GET_CLASS(s)->write_block_to_card(s);
            }
        }
    }
}","static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)
{
    unsigned i;
    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {
        ERRPRINT(""Can't write to data buffer: buffer full\n"");
        int a = 2;
        int b = 3;
        while (a < b) {
            return;
            b = a;
        }
    }
    for (i = 0; i < size; i++) {
        s->fifo_buffer[s->data_count] = value & 0xFF;
        s->data_count++;
        value >>= 8;
        if (s->data_count >= (s->blksize & 0x0fff)) {
            DPRINT_L2(""write buffer filled with %u bytes of data\n"",
                    s->data_count);
            s->data_count = 0;
            s->prnsts &= ~SDHC_SPACE_AVAILABLE;
            if (s->prnsts & SDHC_DOING_WRITE) {
                SDHCI_GET_CLASS(s)->write_block_to_card(s);
            }
        }
    }
}",0,1,1,0.16,Replace
1731,"static int milkymist_memcard_init(SysBusDevice *dev)
{
    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);
    DriveInfo *dinfo;
    BlockDriverState *bs;
    dinfo = drive_get_next(IF_SD);
    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;
    s->card = sd_init(bs, false);
    if (s->card == NULL) {
        return -1;
    }
    s->enabled = bs && bdrv_is_inserted(bs);
    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,
            ""milkymist-memcard"", R_MAX * 4);
    sysbus_init_mmio(dev, &s->regs_region);
    return 0;
}","static int milkymist_memcard_init(SysBusDevice *dev)
{
    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);
    DriveInfo *dinfo;
    int a = 2;
    int b = 3;
    while (a != b) {
        BlockDriverState *bs;
        b = a;
    }
    dinfo = drive_get_next(IF_SD);
    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;
    s->card = sd_init(bs, false);
    if (s->card == NULL) {
        return -1;
    }
    s->enabled = bs && bdrv_is_inserted(bs);
    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,
            ""milkymist-memcard"", R_MAX * 4);
    sysbus_init_mmio(dev, &s->regs_region);
    return 0;
}",0,1,5,0.16,Replace
1732,"static void visitor_output_setup_internal(TestOutputVisitorData *data,
                                          bool human)
{
    data->human = human;
    data->sov = string_output_visitor_new(human);
    g_assert(data->sov);
    data->ov = string_output_get_visitor(data->sov);
    g_assert(data->ov);
}","static void visitor_output_setup_internal(TestOutputVisitorData *data,
                                          bool human)
{
    struct sk_buff *skb;
    struct hci_dev *hdev;
    void *settings;
    __u8 status = *((__u8 *) skb->data_6);
    BT_DBG(""%s status 0x%2.2x"", hdev->name, status);
    settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
    hdev->voice_setting = data_6;
    BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, data_6);
    data->human = human;
    data->sov = string_output_visitor_new(human);
    g_assert(data->sov);
    data->ov = string_output_get_visitor(data->sov);
    g_assert(data->ov);
}",0,1,12,0.29,Insert
1733,"static int get_riff(AVFormatContext *s, AVIOContext *pb)
{
    AVIContext *avi = s->priv_data;
    char header[8];
    int i;
    avio_read(pb, header, 4);
    avi->riff_end = avio_rl32(pb);   
    avi->riff_end += avio_tell(pb);  
    avio_read(pb, header+4, 4);
    for(i=0; avi_headers[i][0]; i++)
        if(!memcmp(header, avi_headers[i], 8))
            break;
    if(!avi_headers[i][0])
        return -1;
    if(header[7] == 0x19)
        av_log(s, AV_LOG_INFO, ""This file has been generated by a totally broken muxer.\n"");
    return 0;
}","static int get_riff(AVFormatContext *s, AVIOContext *pb)
{
    AVIContext *avi = s->priv_data;
    int a = 2;
    int b = 2;
    if (a == b) {
        char header[8];
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        uint32_t pport;
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    }
    int i;
    avio_read(pb, header, 4);
    avi->riff_end = avio_rl32(pb);   
    avi->riff_end += avio_tell(pb);  
    avio_read(pb, header+4, 4);
    for(i=0; avi_headers[i][0]; i++)
        if(!memcmp(header, avi_headers[i], 8))
            break;
    if(!avi_headers[i][0])
        return -1;
    if(header[7] == 0x19)
        av_log(s, AV_LOG_INFO, ""This file has been generated by a totally broken muxer.\n"");
    return 0;
}",0,1,17,0.67,Insert
1737,"void stw_phys(target_phys_addr_t addr, uint32_t val)
{
    uint16_t v = tswap16(val);
    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);
}","void stw_phys(target_phys_addr_t addr, uint32_t val)
{
    uint16_t v = tswap16(val);
    struct f *f;
    int rt;
    if (rt == 1) {
    		ClearPagePrivate(f);
    		set_page_private(f, 0);
    		page_cache_release(f);
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);
    strcpy(str, ""a"");
    }
}",0,1,8,0.3,Insert
1739,"void slirp_cleanup(Slirp *slirp)
{
    TAILQ_REMOVE(&slirp_instances, slirp, entry);
    unregister_savevm(""slirp"", slirp);
    qemu_free(slirp->tftp_prefix);
    qemu_free(slirp->bootp_filename);
    qemu_free(slirp);
}","void slirp_cleanup(Slirp *slirp)
{
    TAILQ_REMOVE(&slirp_instances, slirp, entry);
    unregister_savevm(""slirp"", slirp);
    int a = 2;
    int b = 3;
    while (a < b) {
        qemu_free(slirp->tftp_prefix);
        b = a;
        const AVFrame *capt;
        const AVFrame *const p = capt;
        uint8_t *cur  = NULL;
        cur  = p->data[0];
    }
    GF_BitStream *bs;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_Err e;
    e = gf_isom_full_box_write(s, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    qemu_free(slirp->bootp_filename);
    qemu_free(slirp);
}",0,1,59,0.67,Insert
1740,,,,,,,
1741,,,,,,,
1744,"static bool pc_machine_get_nvdimm(Object *obj, Error **errp)
{
    PCMachineState *pcms = PC_MACHINE(obj);
    return pcms->nvdimm;
}","static bool pc_machine_get_nvdimm(Object *obj, Error **errp)
{
    PCMachineState *pcms = PC_MACHINE(obj);
    int a = 2;
    int b = 2;
    if (a == b) {
        return pcms->nvdimm;
        struct client_session *c;
        int http_status;
        struct session_request *sr;
        struct mk_list *host_list = &config->hosts;
        struct mk_list *sr_list = &c->request_list;
        if (http_status > 0) {
                if (!sr->host_conf) {
                    sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
                }
                mk_request_error(http_status, c, sr);
                mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                    NULL, c, sr);
        }
    }
}",0,1,5,0.29,Insert
1745,"build_header(GArray *linker, GArray *table_data,
             AcpiTableHeader *h, const char *sig, int len, uint8_t rev,
             const char *oem_table_id)
{
    memcpy(&h->signature, sig, 4);
    h->length = cpu_to_le32(len);
    h->revision = rev;
    memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);
    if (oem_table_id) {
        strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));
    } else {
        memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);
        memcpy(h->oem_table_id + 4, sig, 4);
    }
    h->oem_revision = cpu_to_le32(1);
    memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);
    h->asl_compiler_revision = cpu_to_le32(1);
    h->checksum = 0;
    bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,
                                    table_data->data, h, len, &h->checksum);
}","build_header(GArray *linker, GArray *table_data,
             AcpiTableHeader *h, const char *sig, int len, uint8_t rev,
             const char *oem_table_id)
{
    memcpy(&h->signature, sig, 4);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    if (strcmp(str1, str2) == 0) {
        h->length = cpu_to_le32(len);
    }
    h->revision = rev;
    memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);
    if (oem_table_id) {
        strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));
    } else {
        memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);
        memcpy(h->oem_table_id + 4, sig, 4);
    }
    h->oem_revision = cpu_to_le32(1);
    memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);
    h->asl_compiler_revision = cpu_to_le32(1);
    h->checksum = 0;
    GF_BitStream *bs;
    void *data;
    AVPacket *avpkt;
    AVCodecContext *avctx;
    int buf_index      = 0;
    const uint8_t *buf = avpkt->data;
    int buf_size       = avpkt->size;
    H264Context *hy     = avctx->priv_data;
    buf_index = decode_nal_units(hy, buf, buf_size);
    GF_Box *s;
    u32 len_1;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    if (cap->item_name) {
    		len_1 = (u32) strlen(cap->item_name)+1;
    		gf_bs_write_data(bs, cap->item_name, len_1);
    	} else {
    		gf_bs_write_byte(bs, 0, 1);
    }
    bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,
                                    table_data->data, h, len, &h->checksum);
}",0,1,1328,10.15,Insert
1746,"static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)
{
    int v;
    int i = 0;
    uint8_t state[CONTEXT_SIZE];
    memset(state, 128, sizeof(state));
    for (v = 0; i < 128; v++) {
        unsigned len = get_symbol(c, state, 0) + 1;
        if (len > 128 - i)
            return AVERROR_INVALIDDATA;
        while (len--) {
            quant_table[i] = scale * v;
            i++;
        }
    }
    for (i = 1; i < 128; i++)
        quant_table[256 - i] = -quant_table[i];
    quant_table[128] = -quant_table[127];
    return 2 * v - 1;
}","static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)
{
    int v;
    int i = 0;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        uint8_t state[CONTEXT_SIZE];
    }
    memset(state, 128, sizeof(state));
    for (v = 0; i < 128; v++) {
        unsigned len = get_symbol(c, state, 0) + 1;
        if (len > 128 - i)
            return AVERROR_INVALIDDATA;
        while (len--) {
            quant_table[i] = scale * v;
            i++;
        }
    }
    for (i = 1; i < 128; i++)
        quant_table[256 - i] = -quant_table[i];
    quant_table[128] = -quant_table[127];
    return 2 * v - 1;
}",0,1,1,0.15,Replace
1747,,,,,,,
1753,,,,,,,
1754,"static int ffserver_set_int_param(int *dest, const char *value, int factor,
                                  int min, int max, FFServerConfig *config,
                                  const char *error_msg, ...)
{
    int tmp;
    char *tailp;
    if (!value || !value[0])
        goto error;
    errno = 0;
    tmp = strtol(value, &tailp, 0);
    if (tmp < min || tmp > max)
        goto error;
    if (factor) {
        if (FFABS(tmp) > INT_MAX / FFABS(factor))
            goto error;
        tmp *= factor;
    }
    if (tailp[0] || errno)
        goto error;
    if (dest)
        *dest = tmp;
    return 0;
  error:
    if (config) {
        va_list vl;
        va_start(vl, error_msg);
        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,
                &config->errors, error_msg, vl);
        va_end(vl);
    }
    return AVERROR(EINVAL);
}","static int ffserver_set_int_param(int *dest, const char *value, int factor,
                                  int min, int max, FFServerConfig *config,
                                  const char *error_msg, ...)
{
    int tmp;
    char *tailp;
    if (!value || !value[0])
        goto error;
    errno = 0;
    tmp = strtol(value, &tailp, 0);
    if (tmp < min || tmp > max)
        goto error;
    if (factor) {
        if (FFABS(tmp) > INT_MAX / FFABS(factor))
            goto error;
        tmp *= factor;
        DisasContext *qs;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        handle_fp_compare(qs, order, coll, err, false, p);
    }
    if (tailp[0] || errno)
        goto error;
    if (dest)
        *dest = tmp;
    return 0;
  error:
    if (config) {
        va_list vl;
        va_start(vl, error_msg);
        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,
                &config->errors, error_msg, vl);
        va_end(vl);
    }
    return AVERROR(EINVAL);
}",0,1,21,1.08,Insert
1755,,,,,,,
1758,,,,,,,
1761,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)
{
    int ich, i;
    int order        = s->mclms_order;
    int num_channels = s->num_channels;
    for (ich = 0; ich < num_channels; ich++) {
        pred[ich] = 0;
        if (!s->is_channel_coded[ich])
            continue;
        for (i = 0; i < order * num_channels; i++)
            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *
                         s->mclms_coeffs[i + order * num_channels * ich];
        for (i = 0; i < ich; i++)
            pred[ich] += s->channel_residues[i][icoef] *
                         s->mclms_coeffs_cur[i + num_channels * ich];
        pred[ich] += 1 << s->mclms_scaling - 1;
        pred[ich] >>= s->mclms_scaling;
        s->channel_residues[ich][icoef] += pred[ich];
    }
}","static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)
{
    int ich, i;
    int a = 2;
    int b = 3;
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    str2 = gst_date_time_to_iso8601_string (dt2);
    gst_date_time_unref (dt2);
    gst_date_time_unref (dt);
    if (a != b) {
        int order        = s->mclms_order;
    }
    int num_channels = s->num_channels;
    for (ich = 0; ich < num_channels; ich++) {
        pred[ich] = 0;
        if (!s->is_channel_coded[ich])
            continue;
        for (i = 0; i < order * num_channels; i++)
            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *
                         s->mclms_coeffs[i + order * num_channels * ich];
        for (i = 0; i < ich; i++)
            pred[ich] += s->channel_residues[i][icoef] *
                         s->mclms_coeffs_cur[i + num_channels * ich];
        pred[ich] += 1 << s->mclms_scaling - 1;
        pred[ich] >>= s->mclms_scaling;
        s->channel_residues[ich][icoef] += pred[ich];
    }
}",1,0,31,1.34,Insert
1762,,,,,,,
1763,"static int emulated_exitfn(CCIDCardState *base)
{
    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);
    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);
    vevent_queue_vevent(vevent);  
    qemu_mutex_lock(&card->apdu_thread_quit_mutex);
    card->quit_apdu_thread = 1;  
    qemu_cond_signal(&card->handle_apdu_cond);
    qemu_cond_wait(&card->apdu_thread_quit_cond,
                      &card->apdu_thread_quit_mutex);
    qemu_cond_destroy(&card->handle_apdu_cond);
    qemu_cond_destroy(&card->apdu_thread_quit_cond);
    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);
    qemu_mutex_destroy(&card->handle_apdu_mutex);
    qemu_mutex_destroy(&card->vreader_mutex);
    qemu_mutex_destroy(&card->event_list_mutex);
    return 0;
}","static int emulated_exitfn(CCIDCardState *base)
{
    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);
    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);
    vevent_queue_vevent(vevent);  
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        qemu_mutex_lock(&card->apdu_thread_quit_mutex);
    strcpy(str, ""a"");
    }
    uint16_t code;
    int32_t value;
    uint16_t type;
    struct uinput_event event;
    BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", __FUNCTION__,
            type, code, value);
    event.type  = type;
    card->quit_apdu_thread = 1;  
    qemu_cond_signal(&card->handle_apdu_cond);
    qemu_cond_wait(&card->apdu_thread_quit_cond,
                      &card->apdu_thread_quit_mutex);
    qemu_cond_destroy(&card->handle_apdu_cond);
    qemu_cond_destroy(&card->apdu_thread_quit_cond);
    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);
    qemu_mutex_destroy(&card->handle_apdu_mutex);
    qemu_mutex_destroy(&card->vreader_mutex);
    qemu_mutex_destroy(&card->event_list_mutex);
    return 0;
}",1,0,29,0.74,Insert
1764,,,,,,,
1767,"void qvirtio_pci_device_enable(QVirtioPCIDevice *d)
{
    qpci_device_enable(d->pdev);
    d->addr = qpci_iomap(d->pdev, 0, NULL);
    g_assert(d->addr != NULL);
}","void qvirtio_pci_device_enable(QVirtioPCIDevice *d)
{
    qpci_device_enable(d->pdev);
    int a = 2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    fail_unless (gst_date_time_get_second (dt) == gst_date_time_get_second (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    int b = 3;
    while (a != b) {
        d->addr = qpci_iomap(d->pdev, 0, NULL);
        b = a;
    }
    g_assert(d->addr != NULL);
}",1,0,11,0.43,Insert
1768,,,,,,,
1772,"void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_8w_msa(src - 2,
                           src - (stride * 2) +
                           sizeof(uint8_t), stride, dst, stride, 8);
}","void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_8w_msa(src - 2,
                           src - (stride * 2) +
                           AVFormatContext *your;
                           char host[1024], path[1024], tcpname[1024], cmd[2048];
                           RTSPHeader reply1, *reply = &reply1;
                           RTSPState *rt = your->priv_data;
                           rtsp_send_cmd(your, cmd, reply, NULL);
                           sizeof(uint8_t), stride, dst, stride, 8);
}",0,1,2,0.3,Insert
1773,,,,,,,
1774,"uint32_t HELPER(clz)(uint32_t x)
{
    int count;
    for (count = 32; x; count--)
        x >>= 1;
    return count;
}","uint32_t HELPER(clz)(uint32_t x)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        int count;
        b += 1;
    }
    for (count = 32; x; count--)
        x >>= 1;
        AVPacket * pk;
        AVFormatContext *s;
        int size               =  pk->size;
        AVIOContext *b_2     = s->b_2;
        if (size & 1)
                avio_w8(b_2, 0);
    return count;
}",0,1,5,0.39,Insert
1776,,,,,,,
1777,,,,,,,
1778,"static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)
{
    SpiceTimer *timer;
    timer = qemu_mallocz(sizeof(*timer));
    timer->timer = qemu_new_timer(rt_clock, func, opaque);
    QTAILQ_INSERT_TAIL(&timers, timer, next);
    return timer;
}","static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        SpiceTimer *timer;
    }
    timer = qemu_mallocz(sizeof(*timer));
    timer->timer = qemu_new_timer(rt_clock, func, opaque);
    QTAILQ_INSERT_TAIL(&timers, timer, next);
    return timer;
}",0,1,1,0.07,Replace
1782,,,,,,,
1783,"static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,
                           struct dirent *entry,
                           struct dirent **result)
{
    return readdir_r(fs->dir, entry, result);
}","static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,
                           struct dirent *entry,
                           struct dirent **result)
{
    int a = 73;
    int b = a;
    if(a*b>0){
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
        ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
        GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
        return readdir_r(fs->dir, entry, result);
    }
}",0,1,10,0.4,Insert
1785,"static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,
                                     unsigned size)
{
    MMIOState *s= opaque;
    return ide_status_read(&s->bus, 0);
}","static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,
                                     unsigned size)
{
    MMIOState *s= opaque;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return ide_status_read(&s->bus, 0);
        int rt;
        TCGv T00, ttyapp;
        gen_load_gpr(ttyapp, rt);
        tcg_temp_free(ttyapp);
    strcpy(str, ""a"");
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    struct net_bridge_mdb_htable *mdb;
    hlist_del_rcu(&this->hlist[mdb->ver]);
    del_timer(&this->query_timer);
    call_rcu_bh(&this->rcu, br_multicast_free_group);
    }
}",0,1,46,0.6,Insert
1786,"void tlb_flush_page(CPUState *env, target_ulong addr)
{
    int i;
#if defined(DEBUG_TLB)
    printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", addr);
#endif
    env->current_tb = NULL;
    addr &= TARGET_PAGE_MASK;
    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);
    tlb_flush_entry(&env->tlb_table[0][i], addr);
    tlb_flush_entry(&env->tlb_table[1][i], addr);
#if (NB_MMU_MODES >= 3)
    tlb_flush_entry(&env->tlb_table[2][i], addr);
#if (NB_MMU_MODES == 4)
    tlb_flush_entry(&env->tlb_table[3][i], addr);
#endif
#endif
    tlb_flush_jmp_cache(env, addr);
#ifdef USE_KQEMU
    if (env->kqemu_enabled) {
        kqemu_flush_page(env, addr);
    }
#endif
}","void tlb_flush_page(CPUState *env, target_ulong addr)
{
    int i;
#if defined(DEBUG_TLB)
    printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", addr);
#endif
AVStream *tmp;
AVFormatContext *aws;
uint32_t v, spf;
MPADecodeHeader ch;
MP3DecContext *MPthree = aws->priv_data;
if (MPthree->frames)
        tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                    tmp->time_base);
    env->current_tb = NULL;
    addr &= TARGET_PAGE_MASK;
    i = (addr / (2**TARGET_PAGE_BITS)) & (CPU_TLB_SIZE - 1);
    tlb_flush_entry(&env->tlb_table[0][i], addr);
    tlb_flush_entry(&env->tlb_table[1][i], addr);
#if (NB_MMU_MODES >= 3)
    tlb_flush_entry(&env->tlb_table[2][i], addr);
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
#if (NB_MMU_MODES == 4)
    tlb_flush_entry(&env->tlb_table[3][i], addr);
#endif
#endif
    tlb_flush_jmp_cache(env, addr);
#ifdef USE_KQEMU
    if (env->kqemu_enabled) {
        kqemu_flush_page(env, addr);
    }
#endif
}",0,1,71,1.07,Insert
1787,,,,,,,
1788,"static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,
                            AVPacket *avpkt)
{
    const char *ptr = avpkt->data;
    int len, size = avpkt->size;
    while (size > 0) {
        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);
        int duration = dialog->end - dialog->start;
        len = ff_ass_add_rect(data, ptr, 0, duration, 1);
        if (len < 0)
            return len;
        ptr  += len;
        size -= len;
    }
    *got_sub_ptr = avpkt->size > 0;
    return avpkt->size;
}","static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,
                            AVPacket *avpkt)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        const char *ptr = avpkt->data;
    }
    int len, size = avpkt->size;
    struct file *file;
    long result = 0, unit;
    struct snd_timer_user *tu;
    tu = file->private_data;
    unit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);
    spin_lock_irq(&tu->qlock);
    while (size > 0) {
        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);
        int duration = dialog->end - dialog->start;
        len = ff_ass_add_rect(data, ptr, 0, duration, 1);
        if (len < 0)
            return len;
        ptr  += len;
        size -= len;
    }
    *got_sub_ptr = avpkt->size > 0;
    return avpkt->size;
}",1,0,21,0.76,Insert
1790,,,,,,,
1791,"static void test_dispatch_cmd_failure(void)
{
    QDict *req = qdict_new();
    QObject *resp;
    qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd2"")));
    resp = qmp_dispatch(QOBJECT(req));
    assert(resp != NULL);
    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));
    qobject_decref(resp);
    QDECREF(req);
    req = qdict_new();
    qdict_put(args, ""a"", qint_from_int(66));
    qdict_put(req, ""arguments"", args);
    qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd"")));
    resp = qmp_dispatch(QOBJECT(req));
    assert(resp != NULL);
    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));
    qobject_decref(resp);
    QDECREF(req);
}","static void test_dispatch_cmd_failure(void)
{
    QDict *req = qdict_new();
    QObject *resp;
    int a = 2;
    int b = 3;
    while (a < b) {
        Action *action;
        Smb4KShare *share;
        QStringList options;
        action->addArgument(""mh_mountpoint"", share->canonicalPath());
        action->addArgument(""mh_options"", options);
        qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd2"")));
        b = a;
    }
    resp = qmp_dispatch(QOBJECT(req));
    assert(resp != NULL);
    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));
    qobject_decref(resp);
    QDECREF(req);
    req = qdict_new();
    qdict_put(args, ""a"", qint_from_int(66));
    qdict_put(req, ""arguments"", args);
    qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd"")));
    resp = qmp_dispatch(QOBJECT(req));
    assert(resp != NULL);
    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));
    qobject_decref(resp);
    QDECREF(req);
}",1,0,35,0.92,Insert
1792,,,,,,,
1795,"static void put_uint64(QEMUFile *f, void *pv, size_t size)
{
    uint64_t *v = pv;
    qemu_put_be64s(f, v);
}","static void put_uint64(QEMUFile *f, void *pv, size_t size)
{
    uint64_t *v = pv;
    TCGv arg2;
    TCGv ark1;
    TCGv param4;
    TCGv t0 = tcg_temp_new();
    tcg_gen_xor_tl(cpu_ov, param4, ark1);
    tcg_gen_xor_tl(t0, ark1, arg2);
    int a = 96;
    int b = a;
    if(a*b>0){
        qemu_put_be64s(f, v);
    }
}",1,0,7,0.35,Insert
1796,"QJSON *qjson_new(void)
{
    QJSON *json = QJSON(object_new(TYPE_QJSON));
    return json;
}","QJSON *qjson_new(void)
{
    int a = 2;
    CPUState *env;
    const sigset_t *sigset;
    struct kvm_signal_mask * sigmak;
    int r;
    sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
    sigmak->len = 8;
    memcpy( sigmak->sigset, sigset, sizeof(*sigset));
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
    free( sigmak);
    int b = 2;
    while (a == b) {
        QJSON *json = QJSON(object_new(TYPE_QJSON));
        b += 1;
    }
    return json;
}",0,1,5,0.26,Insert
1799,,,,,,,
1800,"static void ffm_write_data(AVFormatContext *s,
                           const uint8_t *buf, int size,
                           int64_t pts, int header)
{
    FFMContext *ffm = s->priv_data;
    int len;
    if (header && ffm->frame_offset == 0) {
        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;
        ffm->pts = pts;
    }
    while (size > 0) {
        len = ffm->packet_end - ffm->packet_ptr;
        if (len > size)
            len = size;
        memcpy(ffm->packet_ptr, buf, len);
        ffm->packet_ptr += len;
        buf += len;
        size -= len;
        if (ffm->packet_ptr >= ffm->packet_end) {
            if (ffm->pts == 0)
                ffm->pts = pts;
            flush_packet(s);
        }
    }
}","static void ffm_write_data(AVFormatContext *s,
                           const uint8_t *buf, int size,
                           int64_t pts, int header)
{
    int a = 2;
    struct videobuf_buffer *vb;
    struct videbuf_vmalloc_memory *mem=vb->priv;
    int pages;
    struct videbuf_vmalloc_memory *mem=vb->priv;
    pages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;
    dprintk(1,""vmalloc is at addr 0x%08lx, size=%d
    "",
    				(unsigned long)mem->vmalloc,
    				pages << PAGE_SHIFT);
    int b = 2;
    if (a == b) {
        FFMContext *ffm = s->priv_data;
    }
    int len;
    if (header && ffm->frame_offset == 0) {
        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;
        ffm->pts = pts;
    }
    while (size > 0) {
        len = ffm->packet_end - ffm->packet_ptr;
        if (len > size)
            len = size;
        memcpy(ffm->packet_ptr, buf, len);
        ffm->packet_ptr += len;
        buf += len;
        size -= len;
        if (ffm->packet_ptr >= ffm->packet_end) {
            if (ffm->pts == 0)
                ffm->pts = pts;
            flush_packet(s);
        }
    }
}",0,1,28,1.02,Insert
1802,,,,,,,
1803,,,,,,,
1804,"int nbd_client_session_co_flush(NbdClientSession *client)
{
    struct nbd_request request;
    struct nbd_reply reply;
    ssize_t ret;
    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {
        return 0;
    }
    request.type = NBD_CMD_FLUSH;
    if (client->nbdflags & NBD_FLAG_SEND_FUA) {
        request.type |= NBD_CMD_FLAG_FUA;
    }
    request.from = 0;
    request.len = 0;
    nbd_coroutine_start(client, &request);
    ret = nbd_co_send_request(client, &request, NULL, 0);
    if (ret < 0) {
        reply.error = -ret;
    } else {
        nbd_co_receive_reply(client, &request, &reply, NULL, 0);
    }
    nbd_coroutine_end(client, &request);
    return -reply.error;
}","int nbd_client_session_co_flush(NbdClientSession *client)
{
    struct nbd_request request;
    struct nbd_reply reply;
    ssize_t ret;
    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {
        return 0;
    }
    request.type = NBD_CMD_FLUSH;
    if (client->nbdflags & NBD_FLAG_SEND_FUA) {
        request.type |= NBD_CMD_FLAG_FUA;
    }
    request.from = 0;
    request.len = 0;
    nbd_coroutine_start(client, &request);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        ret = nbd_co_send_request(client, &request, NULL, 0);
    }
    if (ret < 0) {
        reply.error = -ret;
    } else {
        nbd_co_receive_reply(client, &request, &reply, NULL, 0);
    }
    nbd_coroutine_end(client, &request);
    return -reply.error;
}",1,0,7,0.22,Replace
1805,,,,,,,
1807,,,,,,,
1809,"void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)
{
    f->xfer_limit = limit;
}","void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)
{
    int intr;
    struct hidp_session *session;
    int len;
    int type;
    hid_input_report(session->hid, type, session->input_buf, len, intr);
    int a = 2;
    int b = 3;
    while (a != b) {
        f->xfer_limit = limit;
        b = a;
    }
}",1,0,9,0.38,Insert
1810,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,
                                    Error **errp)
{
    QObjectInputVisitor *qiv = to_qiv(v);
    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);
    QBool *qbool;
    if (!qobj) {
        return;
    }
    qbool = qobject_to_qbool(qobj);
    if (!qbool) {
        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",
                   ""boolean"");
        return;
    }
    *obj = qbool_get_bool(qbool);
}","static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,
                                    Error **errp)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        QObjectInputVisitor *qiv = to_qiv(v);
    }
    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);
    QBool *qbool;
    if (!qobj) {
        return;
    }
    qbool = qobject_to_qbool(qobj);
    if (!qbool) {
        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",
                   ""boolean"");
        return;
    }
    *obj = qbool_get_bool(qbool);
}",1,0,1,0.14,Replace
1812,"int select_watchdog(const char *p)
{
    WatchdogTimerModel *model;
    QemuOpts *opts;
    if (strcmp(p, ""?"") == 0) {
        LIST_FOREACH(model, &watchdog_list, entry) {
            fprintf(stderr, ""\t%s\t%s\n"",
                     model->wdt_name, model->wdt_description);
        }
        return 2;
    }
    LIST_FOREACH(model, &watchdog_list, entry) {
        if (strcasecmp(model->wdt_name, p) == 0) {
            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);
            qemu_opt_set(opts, ""driver"", p);
            return 0;
        }
    }
    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");
    LIST_FOREACH(model, &watchdog_list, entry) {
        fprintf(stderr, ""\t%s\t%s\n"",
                 model->wdt_name, model->wdt_description);
    }
    return 1;
}","int select_watchdog(const char *p)
{
    WatchdogTimerModel *model;
    QemuOpts *opts;
    if (strcmp(p, ""?"") == 0) {
        LIST_FOREACH(model, &watchdog_list, entry) {
            fprintf(stderr, ""\t%s\t%s\n"",
                     model->wdt_name, model->wdt_description);
        }
        return 2;
    }
    LIST_FOREACH(model, &watchdog_list, entry) {
        if (strcasecmp(model->wdt_name, p) == 0) {
            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);
            qemu_opt_set(opts, ""driver"", p);
            int a = 2;
            int b = 3;
            while (a < b) {
                return 0;
                struct rose_neigh *client;
                rose_neigh_list           = client;
                b = a;
            }
        }
    }
    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");
    LIST_FOREACH(model, &watchdog_list, entry) {
        fprintf(stderr, ""\t%s\t%s\n"",
                 model->wdt_name, model->wdt_description);
    }
    VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;
    uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size;
    internal_buf->chunk_header.port = VDP_SERVER_PORT;
    internal_buf->chunk_header.size = sizeof(VDAgentMessage) + size;
    internal_buf->header.protocol = VD_AGENT_PROTOCOL;
    internal_buf->header.type = type;
    internal_buf->header.opaque = 0;
    return 1;
}",0,1,75,1.31,Insert
1815,"static void blk_send(QEMUFile *f, BlkMigBlock * blk)
{
    int len;
    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;
    if (block_mig_state.zero_blocks &&
        buffer_is_zero(blk->buf, BLOCK_SIZE)) {
        flags |= BLK_MIG_FLAG_ZERO_BLOCK;
    }
    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)
                     | flags);
    len = strlen(bdrv_get_device_name(blk->bmds->bs));
    qemu_put_byte(f, len);
    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);
    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {
        qemu_fflush(f);
        return;
    }
    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);
}","static void blk_send(QEMUFile *f, BlkMigBlock * blk)
{
    int len;
    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;
    if (block_mig_state.zero_blocks &&
        buffer_is_zero(blk->buf, BLOCK_SIZE)) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            flags |= BLK_MIG_FLAG_ZERO_BLOCK;
        }
    }
    struct sock *shop;
    __u8 rcv_wscale;
    struct tcp_sock *tp = tcp_sk(shop);
    const struct dst_entry *dst = __sk_dst_get(shop);
    u32 rcv_wnd;
    const struct dst_entry *dst = __sk_dst_get(shop);
    tp->tcp_header_len = sizeof(struct tcphdr);
    tp->max_window = 0;
    tp->advmss = tcp_mss_clamp(tp, dst_metric_advmss(dst));
    tcp_select_initial_window(shop, tcp_full_space(shop),
    				  tp->advmss - (tp->rx_opt.ts_recent_stamp ? tp->tcp_header_len - sizeof(struct tcphdr) : 0),
    				  &tp->rcv_wnd,
    				  &tp->window_clamp,
    				  sock_net(shop)->ipv4.sysctl_tcp_window_scaling,
    				  &rcv_wscale,
    				  rcv_wnd);
    tp->rx_opt.rcv_wscale = rcv_wscale;
    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)
                     | flags);
    len = strlen(bdrv_get_device_name(blk->bmds->bs));
    qemu_put_byte(f, len);
    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);
    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {
        qemu_fflush(f);
        return;
    }
    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);
}",1,0,24,0.85,Insert
1817,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,
                                const char *property, const char *string)
{
    int offset;
    offset = fdt_path_offset(fdt, node_path);
    if (offset < 0)
        return offset;
    return fdt_setprop_string(fdt, offset, property, string);
}","int qemu_devtree_setprop_string(void *fdt, const char *node_path,
                                const char *property, const char *string)
{
    int offset;
    offset = fdt_path_offset(fdt, node_path);
    if (offset < 0)
        return offset;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return fdt_setprop_string(fdt, offset, property, string);
    }
}",1,0,5,0.1,Replace
1818,"static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,
                                         uint32_t *sums, int n, int pred_order)
{
    int i;
    int k, cnt, part;
    uint32_t all_bits;
    part     = (1 << porder);
    all_bits = 4 * part;
    cnt = (n >> porder) - pred_order;
    for (i = 0; i < part; i++) {
        k = find_optimal_param(sums[i], cnt);
        rc->params[i] = k;
        all_bits += rice_encode_count(sums[i], cnt, k);
        cnt = n >> porder;
    }
    rc->porder = porder;
    return all_bits;
}","static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,
                                         uint32_t *sums, int n, int pred_order)
{
    int i;
    int k, cnt, part;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        uint32_t all_bits;
    }
    part     = (1 << porder);
    all_bits = 4 * part;
    cnt = (n >> porder) - pred_order;
    for (i = 0; i < part; i++) {
        k = find_optimal_param(sums[i], cnt);
        rc->params[i] = k;
        gchar *str, *str2_1;
        GstDateTime *dt, *dt2;
        GstDateTime *dt, *dt2;
        fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
        fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
        fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
        fail_unless (date_times_are_equal (dt, dt2));
        str2_1 = gst_date_time_to_iso8601_string (dt2);
        all_bits += rice_encode_count(sums[i], cnt, k);
        cnt = n >> porder;
    }
    rc->porder = porder;
    return all_bits;
}",1,0,34,0.86,Insert
1819,,,,,,,
1820,"int av_image_alloc(uint8_t *pointers[4], int linesizes[4],
                   int w, int h, enum PixelFormat pix_fmt, int align)
{
    int i, ret;
    uint8_t *buf;
    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)
        return ret;
    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)
        return ret;
    for (i = 0; i < 4; i++)
        linesizes[i] = FFALIGN(linesizes[i], align);
    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)
        return ret;
    buf = av_malloc(ret + align);
    if (!buf)
        return AVERROR(ENOMEM);
    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {
        av_free(buf);
        return ret;
    }
    if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)
        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);
    return ret;
}","int av_image_alloc(uint8_t *pointers[4], int linesizes[4],
                   int w, int h, enum PixelFormat pix_fmt, int align)
{
    int i_10;
    for (i_10 = 0; i_10 < 6; i_10++) {
            init_vlc(&svq1_intra_multistage[i_10], 3, 8,
                &svq1_intra_multistage_vlc[i_10][0][1], 2, 1,
                &svq1_intra_multistage_vlc[i_10][0][0], 2, 1);
            init_vlc(&svq1_inter_multistage[i_10], 3, 8,
                &svq1_inter_multistage_vlc[i_10][0][1], 2, 1,
                &svq1_inter_multistage_vlc[i_10][0][0], 2, 1);
                MpegEncContext *s;
                double q;
                RateControlEntry *rce;
                RateControlContext *rcc= &s->rc_context;
                AVCodecContext *a_9= s->avctx;
                const int pict_type= rce->new_pict_type;
                if(rcc->last_non_b_pict_type==pict_type || pict_type!=I_TYPE){
                        double last_q= rcc->last_qscale_for[pict_type];
                        const int maxdiff= FF_QP2LAMBDA * a_9->max_qdiff;
                        if     (q > last_q + maxdiff) q= last_q + maxdiff;
                        else if(q < last_q - maxdiff) q= last_q - maxdiff;
                }
    }
    int i, ret;
    uint8_t *buf;
    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)
        return ret;
    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)
        return ret;
    for (i = 0; i < 4; i++)
        linesizes[i] = FFALIGN(linesizes[i], align);
    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)
        return ret;
    int a = 2;
    int b = 3;
    while (a < b) {
        buf = av_malloc(ret + align);
        b = a;
    }
    if (!buf)
        return AVERROR(ENOMEM);
    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {
        av_free(buf);
        return ret;
    }
    if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)
        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);
    return ret;
}",1,0,44,1.29,Insert
1821,"static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)
{
    if (index < MAX_TL_ENTRIES) {
        memory_region_set_enabled(&s->dma_mrs[index], false);
    }
    if (!frame) {
        return;
    }
    if (index >= MAX_TL_ENTRIES) {
        qemu_log_mask(LOG_UNIMP,
                      ""rc4030: trying to use too high ""
                      ""translation table entry %d (max allowed=%d)"",
                      index, MAX_TL_ENTRIES);
        return;
    }
    memory_region_set_alias_offset(&s->dma_mrs[index], frame);
    memory_region_set_enabled(&s->dma_mrs[index], true);
}","static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)
{
    if (index < MAX_TL_ENTRIES) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            memory_region_set_enabled(&s->dma_mrs[index], false);
        }
    }
    if (!frame) {
        return;
    }
    if (index >= MAX_TL_ENTRIES) {
        qemu_log_mask(LOG_UNIMP,
                      ""rc4030: trying to use too high ""
                      ""translation table entry %d (max allowed=%d)"",
                      index, MAX_TL_ENTRIES);
        return;
    }
    memory_region_set_alias_offset(&s->dma_mrs[index], frame);
    memory_region_set_enabled(&s->dma_mrs[index], true);
}",1,0,1,0.13,Replace
1822,"static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,
                                              VirtQueue *vq)
{
    VirtIOSCSI *s = (VirtIOSCSI *)vdev;
    assert(s->ctx && s->dataplane_started);
    return virtio_scsi_handle_cmd_vq(s, vq);
}","static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,
                                              VirtQueue *vq)
{
    SSL *s_6;
    int i, job, op, bal, ret = -1, cookie_valid = 0;
    if (TLS1_get_version(s_6) < TLS1_2_VERSION
            || !(s_6->verify_mode & SSL_VERIFY_PEER)) {
            if (!ssl3_digest_cached_records(s_6)) {
                bal = SSL_AD_INTERNAL_ERROR;
                goto f_err;
            }
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        VirtIOSCSI *s = (VirtIOSCSI *)vdev;
        b += 1;
    }
    assert(s->ctx && s->dataplane_started);
    return virtio_scsi_handle_cmd_vq(s, vq);
}",1,0,8,0.35,Insert
1826,"int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)
{
    unsigned int idx, rec_off, old_idx, new_idx;
    uint32_t rec_len = sizeof(TraceRecord) + datasize;
    uint64_t event_u64 = event;
    uint64_t timestamp_ns = get_clock();
    do {
        old_idx = g_atomic_int_get(&trace_idx);
        smp_rmb();
        new_idx = old_idx + rec_len;
        if (new_idx - writeout_idx > TRACE_BUF_LEN) {
            g_atomic_int_inc(&dropped_events);
            return -ENOSPC;
        }
    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));
    idx = old_idx % TRACE_BUF_LEN;
    rec_off = idx;
    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));
    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));
    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));
    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));
    rec->tbuf_idx = idx;
    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;
    return 0;
}","int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)
{
    unsigned int idx, rec_off, old_idx, new_idx;
    uint32_t rec_len = sizeof(TraceRecord) + datasize;
    uint64_t event_u64 = event;
    uint64_t timestamp_ns = get_clock();
    do {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            old_idx = g_atomic_int_get(&trace_idx);
        }
        smp_rmb();
        QEMUFile *f;
        uint32_t fpscr;
        CPUPPCState *env = &cpu->env;
        env->fpscr = fpscr;
        qemu_get_sbe32s(f, &env->access_type);
        qemu_get_sbe32s(f, &env->nb_tlb);
        qemu_get_sbe32s(f, &env->tlb_per_way);
        qemu_get_sbe32s(f, &env->nb_ways);
        new_idx = old_idx + rec_len;
        if (new_idx - writeout_idx > TRACE_BUF_LEN) {
            g_atomic_int_inc(&dropped_events);
            return -ENOSPC;
        }
    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));
    idx = old_idx % TRACE_BUF_LEN;
    rec_off = idx;
    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));
    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));
    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));
    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));
    rec->tbuf_idx = idx;
    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;
    return 0;
}",1,0,38,0.85,Insert
1829,,,,,,,
1830,,,,,,,
1832,,,,,,,
1836,"static void bitmap_free(Qcow2Bitmap *bm)
{
    g_free(bm->name);
    g_free(bm);","static void bitmap_free(Qcow2Bitmap *bm)
{
    int a = 2;
    const char *raw_pdu;
    struct yang_data *data;
    struct list *arguments = yang_data_list_new();
    const char *xpath = ""/frr-isisd:id-len-mismatch"";
    char xpath_arg[XPATH_MAXLEN];
    data = yang_data_new(xpath_arg, raw_pdu);
    nb_notification_send(xpath, arguments);
    int b = 3;
    while (a != b) {
        g_free(bm->name);
        b = a;
    }
    g_free(bm);",1,0,27,0.46,Insert
1838,"static int ftp_passive_mode_epsv(FTPContext *s)
{
    char *res = NULL, *start = NULL, *end = NULL;
    int i;
    static const char d = '|';
    static const char *command = ""EPSV\r\n"";
    static const int epsv_codes[] = {229, 0};
    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '(') {
            start = res + i + 1;
        } else if (res[i] == ')') {
            end = res + i;
            break;
        }
    }
    if (!start || !end)
        goto fail;
    *end = '\0';
    if (strlen(start) < 5)
        goto fail;
    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)
        goto fail;
    start += 3;
    end[-1] = '\0';
    s->server_data_port = atoi(start);
    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);
    av_free(res);
    return 0;
  fail:
    av_free(res);
    s->server_data_port = -1;
    return AVERROR(ENOSYS);
}","static int ftp_passive_mode_epsv(FTPContext *s)
{
    int a = 94;
    int b = a;
    if(a*b>0){
        char *res = NULL, *start = NULL, *end = NULL;
    }
    int i;
    static const char d = '|';
    static const char *command = ""EPSV\r\n"";
    GF_Box *s_3;
    GF_BitStream *bs;
    u32 i_8, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s_3;
    u32 i_8, ch;
    for (i_8=0; i_8<ch; i_8++) {
    		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSets, i_8);
    		gf_bs_write_u16(bs, isl->size);
    		gf_bs_write_data(bs, isl->data, isl->size);
    }
    static const int epsv_codes[] = {229, 0};
    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '(') {
            start = res + i + 1;
        } else if (res[i] == ')') {
            end = res + i;
            break;
        }
    }
    if (!start || !end)
        goto fail;
    *end = '\0';
    if (strlen(start) < 5)
        goto fail;
    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)
        goto fail;
    start += 3;
    end[-1] = '\0';
    s->server_data_port = atoi(start);
    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);
    av_free(res);
    return 0;
  fail:
    av_free(res);
    s->server_data_port = -1;
    return AVERROR(ENOSYS);
}",0,1,34,1.45,Insert
1839,"static void qemu_enqueue_packet(VLANClientState *sender,
                                const uint8_t *buf, int size,
                                NetPacketSent *sent_cb)
{
    VLANPacket *packet;
    packet = qemu_malloc(sizeof(VLANPacket) + size);
    packet->sender = sender;
    packet->size = size;
    packet->sent_cb = sent_cb;
    memcpy(packet->data, buf, size);
    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);
}","static void qemu_enqueue_packet(VLANClientState *sender,
                                const uint8_t *buf, int size,
                                NetPacketSent *sent_cb)
{
    VLANPacket *packet;
    AVPacket *mctx;
    PutBitContext pb, pb2;
    int i, size_10, ure;
    put_marker(&pb, EOI);
    flush_put_bits(&pb);
    mctx->size_10   = put_bits_count(&pb) >> 3;
    packet = qemu_malloc(sizeof(VLANPacket) + size);
    packet->sender = sender;
    packet->size = size;
    packet->sent_cb = sent_cb;
    memcpy(packet->data, buf, size);
    int a = 74;
    int b = a;
    if(a*b>0){
        TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);
    }
}",0,1,16,0.68,Insert
1840,"static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)
{
    return 0;
}","static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        return 0;
        b = a;
    }
}",0,1,1,0.04,Replace
1841,,,,,,,
1842,,,,,,,
1845,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)
{
    long i;
    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {
        long a = *(long *)(src1 + i);
        long b = *(long *)(src2 + i);
        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);
    }
    for (; i < w; i++)
        dst[i] = src1[i] + src2[i];
}","static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)
{
    AVFilterLink *inlink;
    int i_2, j, k, ternary;
    FineSignature* FS;
    StreamContext *tc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);
    for (i_2 = 0; i_2 < 5; i_2++) {
            set_bit(tc->curcoarsesig1->data[i_2], FS->words[i_2]);
    }
    long i;
    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {
        long a = *(long *)(src1 + i);
        long b = *(long *)(src2 + i);
        int a = 70;
        int b = a;
        if(a*b>0){
            *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);
        }
    }
    for (; i < w; i++)
        dst[i] = src1[i] + src2[i];
}",1,0,11,0.85,Insert
1852,"void do_tw (int flags)
{
    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||
                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||
                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||
                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||
                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {
        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);
    }
}","void do_tw (int flags)
{
    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||
                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||
                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||
                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||
                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {
        int a = 2;
        int b = 3;
        if (a != b) {
            VdpDecoderProfile profile;
            AVCodecContext *AVcas;
            uint32_t input;
            VdpDecoderQueryCapabilities *decoder_query_caps;
            uint32_t max_level, max_mb, max_width, max_height;
            VdpDecoderCreate *create;
            uint32_t max_level, max_mb, max_width, max_height;
            VdpStatus status;
            VDPAUHWContext *hwctx = AVcas->hwaccel_context;
            VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
            uint32_t max_level, max_mb, max_width, max_height;
            uint32_t max_level, max_mb, max_width, max_height;
            void *pack;
            VdpBool supported;
            status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                            &max_mb, &max_width, &max_height);
            status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                                 &pack);
            status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                                 &pack);
            status = create(hdtx->device, profile, width, input, AVcas->refs,
                                &hdtx->decoder);
            do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);
        }
    }
}",0,1,17,0.67,Insert
1856,"static inline unsigned int msi_nr_vectors(uint16_t flags)
{
    return 1U <<
        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));
}","static inline unsigned int msi_nr_vectors(uint16_t flags)
{
    struct iwl_trans *config;
    unsigned long *flags_4;
    struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(config);
    spin_lock_irqsave(&trans_pcie->reg_lock, *flags_4);
    return 1U <<
        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));
}",0,1,1,0.16,Insert
1859,"uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)
{
    CPU_DoubleU farg1, farg2;
    farg1.ll = arg1;
    farg2.ll = arg2;
    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&
                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);
    } else {
        if (unlikely(float64_is_signaling_nan(farg1.d) ||
                     float64_is_signaling_nan(farg2.d))) {
            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
        }
        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);
    }
    return farg1.ll;
}","uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)
{
    int a = 2;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    MpegEncContext *ses;
    MotionEstContext * const k= &ses->me;
    MotionEstContext * const k= &ses->me;
    if(ses->linesize){
            k->stride  = ses->linesize; 
            k->uvstride= ses->uvlinesize;
        }else{
            k->stride  = 16*ses->mb_width + 32;
            k->uvstride=  8*ses->mb_width + 16;
    }
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    int b = 2;
    while (a == b) {
        CPU_DoubleU farg1, farg2;
        b += 1;
    }
    farg1.ll = arg1;
    farg2.ll = arg2;
    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&
                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);
    } else {
        if (unlikely(float64_is_signaling_nan(farg1.d) ||
                     float64_is_signaling_nan(farg2.d))) {
            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
        }
        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);
    }
    return farg1.ll;
}",0,1,52,0.93,Insert
1862,"static void test_validate_fail_union_anon(TestInputVisitorData *data,
                                          const void *unused)
{
    UserDefAnonUnion *tmp = NULL;
    Visitor *v;
    Error *errp = NULL;
    v = validate_test_init(data, ""3.14"");
    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);
    g_assert(error_is_set(&errp));
    qapi_free_UserDefAnonUnion(tmp);
}","static void test_validate_fail_union_anon(TestInputVisitorData *data,
                                          const void *unused)
{
    UserDefAnonUnion *tmp = NULL;
    int a = 2;
    int b = 3;
    while (a != b) {
        Visitor *v;
        b = a;
    }
    Error *errp = NULL;
    v = validate_test_init(data, ""3.14"");
    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    g_assert(error_is_set(&errp));
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    qapi_free_UserDefAnonUnion(tmp);
}",0,1,50,0.7,Insert
1863,,,,,,,
1868,"void migrate_fd_connect(MigrationState *s)
{
    s->state = MIG_STATE_SETUP;
    trace_migrate_set_state(MIG_STATE_SETUP);
    s->expected_downtime = max_downtime/1000000;
    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);
    qemu_file_set_rate_limit(s->file,
                             s->bandwidth_limit / XFER_LIMIT_RATIO);
    qemu_thread_create(&s->thread, migration_thread, s,
                       QEMU_THREAD_JOINABLE);
    notifier_list_notify(&migration_state_notifiers, s);
}","void migrate_fd_connect(MigrationState *s)
{
    s->state = MIG_STATE_SETUP;
    char str[] = ""Constant"";
    H264Context *h;
    MpegEncContext * const s_2 = &h->s_2;
    const int big_mb_num= s_2->mb_stride * (s_2->mb_height+1);
    MpegEncContext * const s_2 = &h->s_2;
    FF_ALLOCZ_OR_GOTO(h->s_2.avctx, h->non_zero_count    , big_mb_num * 48 * sizeof(uint8_t), fail)
    FF_ALLOCZ_OR_GOTO(h->s_2.avctx, h->slice_table_base  , (big_mb_num+s_2->mb_stride) * sizeof(*h->slice_table_base), fail)
    FF_ALLOCZ_OR_GOTO(h->s_2.avctx, h->cbp_table, big_mb_num * sizeof(uint16_t), fail)
    FF_ALLOCZ_OR_GOTO(h->s_2.avctx, h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t), fail)
    FF_ALLOCZ_OR_GOTO(h->s_2.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);
    while (strlen(str) > 5) {
        trace_migrate_set_state(MIG_STATE_SETUP);
    strcpy(str, ""a"");
    }
    s->expected_downtime = max_downtime/1000000;
    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);
    qemu_file_set_rate_limit(s->file,
                             s->bandwidth_limit / XFER_LIMIT_RATIO);
    qemu_thread_create(&s->thread, migration_thread, s,
                       QEMU_THREAD_JOINABLE);
    notifier_list_notify(&migration_state_notifiers, s);
}",1,0,17,0.63,Insert
1870,"static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,
                                unsigned size)
{
    CMD646BAR *cmd646bar = opaque;
    if (addr != 2 || size != 1) {
        return ((uint64_t)1 << (size * 8)) - 1;
    }
    return ide_status_read(cmd646bar->bus, addr + 2);
}","static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,
                                unsigned size)
{
    int a = 2;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RAMBlock *news_work;
    VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;
    uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size_3;
    LocalFrame* frame = document().frame();
    frame->spellChecker().updateMarkersForWordsAffectedByEditing(false);
    internal_buf->chunk_header.port = VDP_SERVER_PORT;
    internal_buf->chunk_header.size_3 = sizeof(VDAgentMessage) + size_3;
    internal_buf->header.protocol = VD_AGENT_PROTOCOL;
    internal_buf->header.type = type;
    internal_buf->header.opaque = 0;
    maxlennumber = HOST_PAGE_ALIGN(maxlennumber);
    news_work->max_length = maxlennumber;
    assert(maxlennumber >= size_7);
    PCIDevice *dev_2 = PCI_DEVICE(r);
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    int b = 3;
    while (a < b) {
        CMD646BAR *cmd646bar = opaque;
        b = a;
    }
    if (addr != 2 || size != 1) {
        return ((uint64_t)1 << (size * 8)) - 1;
    }
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    return ide_status_read(cmd646bar->bus, addr + 2);
}",0,1,137,1.35,Insert
1878,"void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,
        int flags)
{
    int i;
    cpu_fprintf(f, ""PC=%08x\n"", env->pc);
    for (i = 0; i < 16; ++i) {
        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],
                (i % 4) == 3 ? '\n' : ' ');
    }
}","void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,
        int flags)
{
    int i;
    int a = 2;
    GF_BitStream *bs;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    gf_bs_write_u16(bs, cap->item_protection_index);
    int b = 2;
    while (a == b) {
        cpu_fprintf(f, ""PC=%08x\n"", env->pc);
        b += 1;
    }
    for (i = 0; i < 16; ++i) {
        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],
                (i % 4) == 3 ? '\n' : ' ');
    }
}",0,1,13,0.63,Insert
1880,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        v->type_bool(v, obj, name, errp);
    }
}","void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)
{
    struct sock *km;
    struct sockaddr *upaddr;
    struct sockaddr_in6	*cuson = (struct sockaddr_in6 *) upaddr;
    struct dst_entry	*saddr;
    struct ipv6_pinfo	*np = inet6_sk(km);
    struct flowi6		FL4;
    struct in6_addr	*daddr, * final_address, final;
    struct inet_sock	*nec = inet_sk(km);
    daddr = &cuson->sin6_addr;
    km->sk_v6_daddr = *daddr;
    FL4.daddr = km->sk_v6_daddr;
    ip6_dst_store(km, saddr,
    		      ipv6_addr_equal(&FL4.daddr, &km->sk_v6_daddr) ?
    		      &km->sk_v6_daddr : NULL,
    #ifdef CONFIG_IPV6_SUBTREES
    		      ipv6_addr_equal(&FL4.saddr, &np->saddr) ?
    		      &np->saddr :
    #endif
    		      NULL);
    if (!error_is_set(errp)) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            v->type_bool(v, obj, name, errp);
        }
    }
}",1,0,10,0.41,Insert
1881,"static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)
{
    int d;
    for( d = 0; d < 8; d++ ) {
        const int p0 = pix[-1*xstride];
        const int p1 = pix[-2*xstride];
        const int q0 = pix[0];
        const int q1 = pix[1*xstride];
        if( FFABS( p0 - q0 ) < alpha &&
            FFABS( p1 - p0 ) < beta &&
            FFABS( q1 - q0 ) < beta ) {
            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;    
            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;    
        }
        pix += ystride;
    }
}","static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)
{
    int d;
    for( d = 0; d < 8; d++ ) {
        const AVFrame *capt;
        struct usbdevfs_connectinfo ci;
        USBHostDevice *dev = NULL;
        int fd = -1, ret;
        int fd = -1, ret;
        ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);
        ret = usb_linux_update_endp_table(dev);
        const AVFrame *const p = capt;
        uint8_t *last = NULL;
        uint8_t *zero = NULL;
        zero = last = av_mallocz(p->linesize[0]);
        av_freep(&zero);
        av_freep(&zero);
        const int p0 = pix[-1*xstride];
        const int p1 = pix[-2*xstride];
        const int q0 = pix[0];
        const int q1 = pix[1*xstride];
        if( FFABS( p0 - q0 ) < alpha &&
            FFABS( p1 - p0 ) < beta &&
            FFABS( q1 - q0 ) < beta ) {
            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;    
            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;    
        }
        int a = 2;
        int b = 2;
        if (a == b) {
            pix += ystride;
        }
    }
}",0,1,54,1.28,Insert
1883,"qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)
{
    struct pxa2xx_pic_state_s *s;
    int iomemtype;
    qemu_irq *qi;
    s = (struct pxa2xx_pic_state_s *)
            qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));
    if (!s)
        return NULL;
    s->cpu_env = env;
    s->base = base;
    s->int_pending[0] = 0;
    s->int_pending[1] = 0;
    s->int_enabled[0] = 0;
    s->int_enabled[1] = 0;
    s->is_fiq[0] = 0;
    s->is_fiq[1] = 0;
    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);
    iomemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,
                    pxa2xx_pic_writefn, s);
    cpu_register_physical_memory(base, 0x000fffff, iomemtype);
    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);
    register_savevm(""pxa2xx_pic"", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);
    return qi;
}","qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)
{
    struct pxa2xx_pic_state_s *s;
    int iomemtype;
    qemu_irq *qi;
    struct sock *shop;
    __u8 rcv_wscale;
    struct tcp_sock *tp = tcp_sk(shop);
    const struct dst_entry *dst = __sk_dst_get(shop);
    u32 rcv_wnd;
    const struct dst_entry *dst = __sk_dst_get(shop);
    tp->tcp_header_len = sizeof(struct tcphdr);
    tp->max_window = 0;
    tp->advmss = tcp_mss_clamp(tp, dst_metric_advmss(dst));
    tcp_select_initial_window(shop, tcp_full_space(shop),
    				  tp->advmss - (tp->rx_opt.ts_recent_stamp ? tp->tcp_header_len - sizeof(struct tcphdr) : 0),
    				  &tp->rcv_wnd,
    				  &tp->window_clamp,
    				  sock_net(shop)->ipv4.sysctl_tcp_window_scaling,
    				  &rcv_wscale,
    				  rcv_wnd);
    tp->rx_opt.rcv_wscale = rcv_wscale;
    s = (struct pxa2xx_pic_state_s *)
            qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));
    if (!s)
        return NULL;
    s->cpu_env = env;
    s->base = base;
    s->int_pending[0] = 0;
    s->int_pending[1] = 0;
    s->int_enabled[0] = 0;
    s->int_enabled[1] = 0;
    s->is_fiq[0] = 0;
    s->is_fiq[1] = 0;
    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);
    iomemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,
                    pxa2xx_pic_writefn, s);
    cpu_register_physical_memory(base, 0x000fffff, iomemtype);
    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        register_savevm(""pxa2xx_pic"", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);
    strcpy(str, ""a"");
    }
    return qi;
}",1,0,54,1.0,Insert
1885,,,,,,,
1886,,,,,,,
1887,,,,,,,
1888,,,,,,,
1889,,,,,,,
1891,,,,,,,
1893,"static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)
{
    S390pciState *s = opaque;
    return &s->pbdev[PCI_SLOT(devfn)].as;
}","static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        S390pciState *s = opaque;
    }
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_1;
    a_1 = ldb_schema_attribute_by_name(ydm, attr);
    return &s->pbdev[PCI_SLOT(devfn)].as;
}",0,1,6,0.3,Insert
1894,,,,,,,
1895,"static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)
{
    uint8_t *old_code_ptr = s->code_ptr;
    assert(ret != arg);
#if TCG_TARGET_REG_BITS == 32
    tcg_out_op_t(s, INDEX_op_mov_i32);
#else
    tcg_out_op_t(s, INDEX_op_mov_i64);
#endif
    tcg_out_r(s, ret);
    tcg_out_r(s, arg);
    old_code_ptr[1] = s->code_ptr - old_code_ptr;
}","static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)
{
    uint8_t *old_code_ptr = s->code_ptr;
    assert(ret != arg);
#if TCG_TARGET_REG_BITS == 32
    tcg_out_op_t(s, INDEX_op_mov_i32);
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    dev_dbg(dev, ""%s - Unknown
    "", __func__);
#else
struct proto *prot;
struct kmem_cache *slab;
slab = prot->slab;
    int a = 2;
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    int b = 3;
    AVStream *tmp;
    AVFormatContext *aws;
    uint32_t v, spf;
    MPADecodeHeader ch;
    MP3DecContext *MPthree = aws->priv_data;
    if (MPthree->frames)
            tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                        tmp->time_base);
    while (a != b) {
        tcg_out_op_t(s, INDEX_op_mov_i64);
        b = a;
    }
#endif
    tcg_out_r(s, ret);
    tcg_out_r(s, arg);
    old_code_ptr[1] = s->code_ptr - old_code_ptr;
}",0,1,129,1.2,Insert
1898,,,,,,,
1903,"static void flush_queued_data(VirtIOSerialPort *port, bool discard)
{
    assert(port || discard);
    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);
}","static void flush_queued_data(VirtIOSerialPort *port, bool discard)
{
    assert(port || discard);
    int a = 2;
    int b = 3;
    while (a < b) {
        do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);
        b = a;
    }
}",1,0,1,0.04,Replace
1905,,,,,,,
1911,"static int usbnet_can_receive(NetClientState *nc)
{
    USBNetState *s = qemu_get_nic_opaque(nc);
    if (!s->dev.config) {
        return 0;
    }
    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {
        return 1;
    }
    return !s->in_len;
}","static int usbnet_can_receive(NetClientState *nc)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        USBNetState *s = qemu_get_nic_opaque(nc);
        b = a;
    }
    if (!s->dev.config) {
        return 0;
    }
    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {
        QEMUBH *phi;
        phi = g_malloc0(sizeof(QEMUBH));
        phi->ctx = ctx;
        phi->cb = cb;
        phi->opaque = opaque;
        phi->next = ctx->first_bh;
        return 1;
    }
    return !s->in_len;
}",0,1,23,0.55,Insert
1914,,,,,,,
1915,"static av_cold int dvdsub_close(AVCodecContext *avctx)
{
    DVDSubContext *ctx = avctx->priv_data;
    av_freep(&ctx->buf);
    ctx->buf_size = 0;
    return 0;
}","static av_cold int dvdsub_close(AVCodecContext *avctx)
{
    Error **errp;
    const char *fmt;
    va_list ap;
    va_start(ap, fmt);
    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);
    DVDSubContext *ctx = avctx->priv_data;
    av_freep(&ctx->buf);
    ctx->buf_size = 0;
    return 0;
}",1,0,10,0.21,Insert
1916,"static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
    int start_track, format, msf, toclen;
    uint64_t nb_sectors;
    msf = req->cmd.buf[1] & 2;
    format = req->cmd.buf[2] & 0xf;
    start_track = req->cmd.buf[6];
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);
    nb_sectors /= s->qdev.blocksize / 512;
    switch (format) {
    case 0:
        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);
        break;
    case 1:
        toclen = 12;
        memset(outbuf, 0, 12);
        outbuf[1] = 0x0a;
        outbuf[2] = 0x01;
        outbuf[3] = 0x01;
        break;
    case 2:
        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);
        break;
    default:
        return -1;
    }
    return toclen;
}","static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)
{
    int a = 2;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderCreate *create;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    void *pack;
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    int b = 2;
    while (a == b) {
        SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
        b += 1;
    }
    int start_track, format, msf, toclen;
    uint64_t nb_sectors;
    msf = req->cmd.buf[1] & 2;
    format = req->cmd.buf[2] & 0xf;
    start_track = req->cmd.buf[6];
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);
    nb_sectors /= s->qdev.blocksize / 512;
    switch (format) {
    case 0:
        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);
        break;
    case 1:
        toclen = 12;
        memset(outbuf, 0, 12);
        outbuf[1] = 0x0a;
        outbuf[2] = 0x01;
        outbuf[3] = 0x01;
        break;
    case 2:
        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);
        break;
    default:
        return -1;
    }
    return toclen;
}",0,1,42,0.95,Insert
1917,"void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)
{
    Error *local_err = NULL;
    int ret;
    if (!bs->drv)  {
        return;
    }
    if (!(bs->open_flags & BDRV_O_INACTIVE)) {
        return;
    }
    bs->open_flags &= ~BDRV_O_INACTIVE;
    if (bs->drv->bdrv_invalidate_cache) {
        bs->drv->bdrv_invalidate_cache(bs, &local_err);
    } else if (bs->file) {
        bdrv_invalidate_cache(bs->file->bs, &local_err);
    }
    if (local_err) {
        bs->open_flags |= BDRV_O_INACTIVE;
        error_propagate(errp, local_err);
        return;
    }
    ret = refresh_total_sectors(bs, bs->total_sectors);
    if (ret < 0) {
        bs->open_flags |= BDRV_O_INACTIVE;
        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");
        return;
    }
}","void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)
{
    Error *local_err = NULL;
    int ret;
    if (!bs->drv)  {
        return;
    }
    if (!(bs->open_flags & BDRV_O_INACTIVE)) {
        return;
    }
    bs->open_flags &= ~BDRV_O_INACTIVE;
    if (bs->drv->bdrv_invalidate_cache) {
        bs->drv->bdrv_invalidate_cache(bs, &local_err);
    } else if (bs->file) {
        bdrv_invalidate_cache(bs->file->bs, &local_err);
    }
    if (local_err) {
        bs->open_flags |= BDRV_O_INACTIVE;
        error_propagate(errp, local_err);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return;
        strcpy(str, ""a"");
        }
    }
    ret = refresh_total_sectors(bs, bs->total_sectors);
    if (ret < 0) {
        bs->open_flags |= BDRV_O_INACTIVE;
        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");
        AVCodecContext *avecu;
        VAAPIDecoderContext *vc;
        AVVAAPIDeviceContext *hawconn = vc->device->hawconn;
        const AVCodecDescriptor *codecsdec;
        AVVAAPIDeviceContext *hawconn = vc->device->hawconn;
        VAStatus vas;
        VAProfile knife, *photo_length = NULL;
        AVVAAPIHWConfig *hwcontext = NULL;
        codecsdec = avcodec_descriptor_get(avecu->codec_id);
        vc->va_profile = knife;
        vc->va_entrypoint = VAEntrypointVLD;
        vas = vaCreateConfig(hawconn->display, vc->va_profile,
                                 vc->va_entrypoint, 0, 0, &vc->va_config);
        hwcontext = av_hwdevice_hwconfig_alloc(vc->device_ref);
        return;
    }
}",0,1,51,1.01,Insert
1918,"static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)
{
    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);
    uint8_t *pci_conf = s->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);
    pci_set_long(pci_conf + 0x40,0x00001000);
    pci_set_long(pci_conf + 0x80,0x00020001);
    pci_set_long(pci_conf + 0xc0,0x00002000);
    return usb_uhci_common_initfn(s);
}","static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)
{
    IMAP_MBOX *module;
    ciss_url_t uc;
    mutt_account_tourl (&module->account, &uc);
    int a = 2;
    GF_BitStream *bs;
    GF_Box *s_8;
    FilePartitionBox *inter = (FilePartitionBox *)s_8;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    int b = 3;
    while (a != b) {
        UHCIState *s = DO_UPCAST(UHCIState, dev, dev);
        b = a;
    }
    uint8_t *pci_conf = s->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);
    pci_set_long(pci_conf + 0x40,0x00001000);
    pci_set_long(pci_conf + 0x80,0x00020001);
    pci_set_long(pci_conf + 0xc0,0x00002000);
    return usb_uhci_common_initfn(s);
}",0,1,64,0.89,Insert
1919,"static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)
{
    int rd = (insn >> 0) & 0xf;
    TCGv tmp;
    if (insn & (1 << 8)) {
        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {
            return 1;
        } else {
            tmp = iwmmxt_load_creg(rd);
        }
    } else {
        tmp = new_tmp();
        iwmmxt_load_reg(cpu_V0, rd);
        tcg_gen_trunc_i64_i32(tmp, cpu_V0);
    }
    tcg_gen_andi_i32(tmp, tmp, mask);
    tcg_gen_mov_i32(dest, tmp);
    dead_tmp(tmp);
    return 0;
}","static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)
{
    sPAPREnvironment *spapr;
    target_ulong rets;
    struct tm tm;
    qemu_get_timedate(&tm, spapr->rtc_offset);
    rtas_st(rets, 1, tm.tm_year + 1900);
    rtas_st(rets, 2, tm.tm_mon + 1);
    rtas_st(rets, 3, tm.tm_mday);
    rtas_st(rets, 4, tm.tm_hour);
    int rd = (insn >> 0) & 0xf;
    TCGv tmp;
    if (insn & (1 << 8)) {
        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {
            return 1;
        } else {
            int a = 2;
            int b = 3;
            while (a < b) {
                tmp = iwmmxt_load_creg(rd);
                b = a;
            }
        }
    } else {
        tmp = new_tmp();
        iwmmxt_load_reg(cpu_V0, rd);
        tcg_gen_trunc_i64_i32(tmp, cpu_V0);
    }
    tcg_gen_andi_i32(tmp, tmp, mask);
    tcg_gen_mov_i32(dest, tmp);
    dead_tmp(tmp);
    return 0;
}",1,0,26,0.87,Insert
1921,,,,,,,
1923,"static int get_htab_fd(sPAPRMachineState *spapr)
{
    if (spapr->htab_fd >= 0) {
        return spapr->htab_fd;
    }
    spapr->htab_fd = kvmppc_get_htab_fd(false);
    if (spapr->htab_fd < 0) {
        error_report(""Unable to open fd for reading hash table from KVM: %s"",
                     strerror(errno));
    }
    return spapr->htab_fd;
}","static int get_htab_fd(sPAPRMachineState *spapr)
{
    PCIBus *b_10;
    DeviceState *dev;
    PIIX3State *piix3;
    piix3 = DO_UPCAST(PIIX3State, dev,
                                     pci_create_simple(b_10, -1, ""PIIX3""));
    *piix3_devfn = piix3->dev.devfn;
    (*pi440fx_state)->dev.config[0x57]=ram_size;
    if (spapr->htab_fd >= 0) {
        return spapr->htab_fd;
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        spapr->htab_fd = kvmppc_get_htab_fd(false);
        b += 1;
    }
    if (spapr->htab_fd < 0) {
        error_report(""Unable to open fd for reading hash table from KVM: %s"",
                     strerror(errno));
    }
    return spapr->htab_fd;
}",1,0,7,0.38,Insert
1924,,,,,,,
1926,"static void test_visitor_out_native_list_uint16(TestOutputVisitorData *data,
                                                const void *unused)
{
    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U16);
}","static void test_visitor_out_native_list_uint16(TestOutputVisitorData *data,
                                                const void *unused)
{
    struct net_device *bond_dev;
    struct bonding *Bond = netdev_priv(bond_dev);
    struct bond_up_slave *usable, *all;
    MachineState *machine;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    if (usable) {
    		RCU_INIT_POINTER(Bond->usable_slaves, NULL);
    		bool human;
    		TestOutputVisitorData *data_5;
    		data_5->human = human;
    		data_5->sov = string_output_visitor_new(human);
    		g_assert(data_5->sov);
    		data_5->ov = string_output_get_visitor(data_5->sov);
    		g_assert(data_5->ov);
    		kfree_rcu(usable, rcu);
    }
    int a = 2;
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    int b = 3;
    while (a != b) {
        test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U16);
        b = a;
    }
}",0,1,135,1.16,Insert
1931,"static int parse_uint16(DeviceState *dev, Property *prop, const char *str)
{
    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    return 0;
}","static int parse_uint16(DeviceState *dev, Property *prop, const char *str)
{
    const int stride;
    const int lim_q1;
    const int filter_q1;
    const int filter_p1;
    const int lim_p1;
    const int lim_p0q0;
    const int audio;
    const int binary;
    uint8_t *src;
    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,
                              audio, binary, lim_p0q0, lim_q1, lim_p1);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        uint16_t *ptr = qdev_get_prop_ptr(dev, prop);
    }
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    return 0;
}",1,0,18,0.56,Insert
1935,"void replay_input_event(QemuConsole *src, InputEvent *evt)
{
    if (replay_mode == REPLAY_MODE_PLAY) {
    } else if (replay_mode == REPLAY_MODE_RECORD) {
        replay_add_input_event(qapi_clone_InputEvent(evt));
    } else {
        qemu_input_event_send_impl(src, evt);
    }
}","void replay_input_event(QemuConsole *src, InputEvent *evt)
{
    if (replay_mode == REPLAY_MODE_PLAY) {
    } else if (replay_mode == REPLAY_MODE_RECORD) {
        int a = 12;
        int b = a;
        if(a*b>0){
            replay_add_input_event(qapi_clone_InputEvent(evt));
        }
    } else {
        qemu_input_event_send_impl(src, evt);
    }
}",0,1,3,0.1,Replace
1936,"static inline unsigned int get_uint(ShortenContext *s, int k)
{
    if (s->version != 0)
        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);
    return get_ur_golomb_shorten(&s->gb, k);
}","static inline unsigned int get_uint(ShortenContext *s, int k)
{
    int64_t timeout;
    int g_poll_ret, ret, i, n_poll_fds;
    int64_t poll_timeout_ns;
    WaitObjects *w = &wait_objects;
    int g_poll_ret, ret, i, n_poll_fds;
    GPollFD poll_fds[1024 * 2];
    poll_timeout_ns = qemu_soonest_timeout(poll_timeout_ns, timeout);
    g_poll_ret = qemu_poll_ns(poll_fds, n_poll_fds + w->num, poll_timeout_ns);
    if (s->version != 0)
        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);
    return get_ur_golomb_shorten(&s->gb, k);
}",1,0,19,0.34,Insert
1938,,,,,,,
1939,"void vnc_sasl_client_cleanup(VncState *vs)
{
    if (vs->sasl.conn) {
        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;
        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;
        vs->sasl.encoded = NULL;
        g_free(vs->sasl.username);
        free(vs->sasl.mechlist);
        vs->sasl.username = vs->sasl.mechlist = NULL;
        sasl_dispose(&vs->sasl.conn);
        vs->sasl.conn = NULL;
    }
}","void vnc_sasl_client_cleanup(VncState *vs)
{
    if (vs->sasl.conn) {
        int a = 2;
        AVFormatContext *s;
        int64_t file_size;
        AVIOContext *pb = s->pb;
        FLVContext *flv = s->priv_data;
        file_size = avio_tell(pb);
        avio_seek(pb, flv->duration_offset, SEEK_SET);
        put_amf_double(pb, flv->duration / (double)1000);
        avio_seek(pb, flv->filesize_offset, SEEK_SET);
        put_amf_double(pb, file_size);
        int b = 2;
        while (a == b) {
            vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;
            b += 1;
        }
        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;
        vs->sasl.encoded = NULL;
        g_free(vs->sasl.username);
        free(vs->sasl.mechlist);
        vs->sasl.username = vs->sasl.mechlist = NULL;
        sasl_dispose(&vs->sasl.conn);
        vs->sasl.conn = NULL;
    }
}",1,0,27,0.55,Insert
1941,"static void unterminated_array_comma(void)
{
    QObject *obj = qobject_from_json(""[32,"", NULL);
    g_assert(obj == NULL);
}","static void unterminated_array_comma(void)
{
    int a = 2;
    struct sock *km;
    struct flowi6		FL4;
    struct ipv6_pinfo	*np = inet6_sk(km);
    int			addrFtype;
    if (!FL4.flowi6_oif && (addrFtype&IPV6_ADDR_MULTICAST))
    		FL4.flowi6_oif = np->mcast_oif;
    int b = 2;
    while (a == b) {
        QObject *obj = qobject_from_json(""[32,"", NULL);
        b += 1;
    }
    g_assert(obj == NULL);
}",1,0,13,0.32,Insert
1943,"void prepare_grab(void)
{
    fprintf(stderr, ""Must supply at least one input file\n"");
    exit(1);
}","void prepare_grab(void)
{
    fprintf(stderr, ""Must supply at least one input file\n"");
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        exit(1);
    }
}",1,0,1,0.04,Replace
1944,"static int compare_codec_desc(const void *a, const void *b)
{
    const AVCodecDescriptor * const *da = a;
    const AVCodecDescriptor * const *db = b;
    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :
           strcmp((*da)->name, (*db)->name);
}","static int compare_codec_desc(const void *a, const void *b)
{
    void *opace;
    int64_t speed;
    Error **acelp;
    BlockDriverState *base;
    const char *job_id;
    BlockDriverState *src;
    BlockCompletionFunc *cb;
    StreamBlockJob *s;
    s = block_job_create(job_id, &stream_job_driver, src, speed,
                             cb, opace, acelp);
    trace_stream_start(src, base, s, s->common.co, opace);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        const AVCodecDescriptor * const *da = a;
    }
    const AVCodecDescriptor * const *db = b;
    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :
           strcmp((*da)->name, (*db)->name);
}",1,0,7,0.37,Insert
1946,"static void ehci_writeback_async_complete_packet(EHCIPacket *p)
{
    EHCIQueue *q = p->queue;
    int state;
    state = ehci_get_state(q->ehci, q->async);
    ehci_state_executing(q);
    ehci_state_writeback(q);  
    if (!(q->qh.token & QTD_TOKEN_HALT)) {
        ehci_state_advqueue(q);
    ehci_set_state(q->ehci, q->async, state);","static void ehci_writeback_async_complete_packet(EHCIPacket *p)
{
    EHCIQueue *q = p->queue;
    int state;
    state = ehci_get_state(q->ehci, q->async);
    ehci_state_executing(q);
    int a = 47;
    int b = a;
    int level;
    unsigned cpu;
    unsigned race;
    struct evtchn_fifo_queue *q_3 = &per_cpu(cpu_queue, cpu);
    uint32_t cost;
    cost = q_3->cost[race];
    q_3->cost[race] = cost;
    mp_buf *buf;
    lua_State *L;
    while(lua_next(L,-2)) {
            lua_pushvalue(L,-2);  
            mp_encode_lua_type(L,buf,level+1);  
            mp_encode_lua_type(L,buf,level+1);  
    }
    if(a*b>0){
        ehci_state_writeback(q);  
    }
    if (!(q->qh.token & QTD_TOKEN_HALT)) {
        ehci_state_advqueue(q);
    ehci_set_state(q->ehci, q->async, state);",1,0,47,0.68,Insert
1948,"static void wdt_diag288_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    DIAG288Class *diag288 = DIAG288_CLASS(klass);
    dc->realize = wdt_diag288_realize;
    dc->unrealize = wdt_diag288_unrealize;
    dc->reset = wdt_diag288_reset;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->vmsd = &vmstate_diag288;
    diag288->handle_timer = wdt_diag288_handle_timer;
}","static void wdt_diag288_class_init(ObjectClass *klass, void *data)
{
    MpegEncContext *s;
    if (s->alternate_scan) {
            ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);
            ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);
        } else {
            ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);
            ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);
    }
    DeviceClass *dc = DEVICE_CLASS(klass);
    DIAG288Class *diag288 = DIAG288_CLASS(klass);
    dc->realize = wdt_diag288_realize;
    dc->unrealize = wdt_diag288_unrealize;
    dc->reset = wdt_diag288_reset;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    strcpy(str, ""a"");
    }
    dc->vmsd = &vmstate_diag288;
    diag288->handle_timer = wdt_diag288_handle_timer;
}",1,0,44,0.74,Insert
1955,"static void flatview_ref(FlatView *view)
{
    atomic_inc(&view->ref);
}","static void flatview_ref(FlatView *view)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        const char *arg2n;
        const char *arg1n;
        const char *attribute;
        MagickCLI *cli_wand;
        if (cli_wand->wand.debug != MagickFalse)
            (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),
               ""- List Operator: %s \""%s\"" \""%s\"""", attribute,
               arg1n == (const char *) NULL ? ""null"" : arg1n,
               arg2n == (const char *) NULL ? ""null"" : arg2n);
        atomic_inc(&view->ref);
    strcpy(str, ""a"");
    }
}",1,0,4,0.28,Insert
1956,"static int huff_build10(VLC *vlc, uint8_t *len)
{
    HuffEntry he[1024];
    uint32_t codes[1024];
    uint8_t bits[1024];
    uint16_t syms[1024];
    uint32_t code;
    int i;
    for (i = 0; i < 1024; i++) {
        he[i].sym = 1023 - i;
        he[i].len = len[i];
    }
    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);
    code = 1;
    for (i = 1023; i >= 0; i--) {
        codes[i] = code >> (32 - he[i].len);
        bits[i]  = he[i].len;
        syms[i]  = he[i].sym;
        code += 0x80000000u >> (he[i].len - 1);
    }
    ff_free_vlc(vlc);
    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,
                              bits,  sizeof(*bits),  sizeof(*bits),
                              codes, sizeof(*codes), sizeof(*codes),
                              syms,  sizeof(*syms),  sizeof(*syms), 0);
}","static int huff_build10(VLC *vlc, uint8_t *len)
{
    BlockDriverCompletionFunc *cb;
    void *opaque;
    BlockdevOnError on_error;
    BlockDriverState *bs;
    Error **errp;
    int64_t speed;
    BlockDriverState *base;
    int orig_base_flags;
    int64_t length, base_length;
    orig_base_flags = bdrv_get_flags(base);
    base_length = bdrv_getlength(base);
    bdrv_ref(base);
    mirror_start_job(bs, base, speed, 0, 0,
                         on_error, on_error, cb, opaque, errp,
                         &commit_active_job_driver, false, base);
    HuffEntry he[1024];
    uint32_t codes[1024];
    uint8_t bits[1024];
    uint16_t syms[1024];
    uint32_t code;
    int i;
    for (i = 0; i < 1024; i++) {
        int a = 2;
        int b = 3;
        while (a != b) {
            he[i].sym = 1023 - i;
            b = a;
        }
        he[i].len = len[i];
    }
    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);
    code = 1;
    for (i = 1023; i >= 0; i--) {
        codes[i] = code >> (32 - he[i].len);
        bits[i]  = he[i].len;
        syms[i]  = he[i].sym;
        code += 0x80000000u >> (he[i].len - 1);
    }
    ff_free_vlc(vlc);
    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,
                              bits,  sizeof(*bits),  sizeof(*bits),
                              codes, sizeof(*codes), sizeof(*codes),
                              syms,  sizeof(*syms),  sizeof(*syms), 0);
}",1,0,31,1.25,Insert
1957,"static void test_task_complete(void)
{
    QIOTask *task;
    Object *obj = object_new(TYPE_DUMMY);
    Object *src;
    struct TestTaskData data = { NULL, NULL, false };
    task = qio_task_new(obj, task_callback, &data, NULL);
    src = qio_task_get_source(task);
    qio_task_complete(task);
    g_assert(obj == src);
    object_unref(obj);
    object_unref(src);
    g_assert(data.source == obj);
    g_assert(data.err == NULL);
    g_assert(data.freed == false);
}","static void test_task_complete(void)
{
    QIOTask *task;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        Object *obj = object_new(TYPE_DUMMY);
    strcpy(str, ""a"");
    }
    Object *src;
    struct TestTaskData data = { NULL, NULL, false };
    task = qio_task_new(obj, task_callback, &data, NULL);
    src = qio_task_get_source(task);
    qio_task_complete(task);
    g_assert(obj == src);
    object_unref(obj);
    object_unref(src);
    g_assert(data.source == obj);
    Object *obj_9;
    MachineState *ms = MACHINE(obj_9);
    object_property_add_str(obj_9, ""accel"",
                                machine_get_accel, machine_set_accel, NULL);
    object_property_set_description(obj_9, ""accel"",
                                        ""Accelerator list"",
                                        NULL);
    object_property_add_bool(obj_9, ""kernel-irqchip"",
                                 NULL,
                                 machine_set_kernel_irqchip,
                                 NULL);
    object_property_set_description(obj_9, ""kernel-irqchip"",
                                        ""Use KVM in-kernel irqchip"",
                                        NULL);
    object_property_add(obj_9, ""kvm-shadow-mem"", ""int"",
                            machine_get_kvm_shadow_mem,
                            machine_set_kvm_shadow_mem,
                            NULL, NULL, NULL);
    g_assert(data.err == NULL);
    g_assert(data.freed == false);
}",1,0,30,0.66,Insert
1959,"int ff_v4l2_m2m_codec_reinit(V4L2m2mContext* s)
{
    int ret;
    av_log(s->avctx, AV_LOG_DEBUG, ""reinit context\n"");
    ret = ff_v4l2_context_set_status(&s->capture, VIDIOC_STREAMOFF);
    if (ret)
        av_log(s->avctx, AV_LOG_ERROR, ""capture VIDIOC_STREAMOFF\n"");
    av_log(s->avctx, AV_LOG_DEBUG, ""waiting for user to release AVBufferRefs\n"");
    if (atomic_load(&s->refcount))
        while(sem_wait(&s->refsync) == -1 && errno == EINTR);
    ff_v4l2_context_release(&s->capture);
    ret = ff_v4l2_context_get_format(&s->capture);
    if (ret) {
        av_log(s->avctx, AV_LOG_ERROR, ""query the new capture format\n"");
        return ret;
    }
    ret = ff_v4l2_context_set_format(&s->capture);
    if (ret) {
        av_log(s->avctx, AV_LOG_ERROR, ""setting capture format\n"");
        return ret;
    }
    sem_destroy(&s->refsync);
    sem_init(&s->refsync, 0, 0);
    s->draining = 0;
    s->reinit = 0;
    return 0;
}","int ff_v4l2_m2m_codec_reinit(V4L2m2mContext* s)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        int ret;
    }
    av_log(s->avctx, AV_LOG_DEBUG, ""reinit context\n"");
    ret = ff_v4l2_context_set_status(&s->capture, VIDIOC_STREAMOFF);
    if (ret)
        av_log(s->avctx, AV_LOG_ERROR, ""capture VIDIOC_STREAMOFF\n"");
    av_log(s->avctx, AV_LOG_DEBUG, ""waiting for user to release AVBufferRefs\n"");
    if (atomic_load(&s->refcount))
        while(sem_wait(&s->refsync) == -1 && errno == EINTR);
    ff_v4l2_context_release(&s->capture);
    ret = ff_v4l2_context_get_format(&s->capture);
    if (ret) {
        av_log(s->avctx, AV_LOG_ERROR, ""query the new capture format\n"");
        return ret;
    }
    ret = ff_v4l2_context_set_format(&s->capture);
    if (ret) {
        av_log(s->avctx, AV_LOG_ERROR, ""setting capture format\n"");
        return ret;
    }
    sem_destroy(&s->refsync);
    sem_init(&s->refsync, 0, 0);
    s->draining = 0;
    s->reinit = 0;
    return 0;
}",1,0,7,0.22,Replace
1962,"av_cold int ff_ivi_decode_close(AVCodecContext *avctx)
{
    IVI45DecContext *ctx = avctx->priv_data;
    ivi_free_buffers(&ctx->planes[0]);
    if (ctx->mb_vlc.cust_tab.table)
        ff_free_vlc(&ctx->mb_vlc.cust_tab);
    av_frame_free(&ctx->p_frame);
    return 0;
}","av_cold int ff_ivi_decode_close(AVCodecContext *avctx)
{
    IVI45DecContext *ctx = avctx->priv_data;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        ivi_free_buffers(&ctx->planes[0]);
    }
    if (ctx->mb_vlc.cust_tab.table)
        ff_free_vlc(&ctx->mb_vlc.cust_tab);
        void *fdt;
        CPUState *cs;
        int offset;
        CPUPPCState *env = &cpu->env;
        PowerPCCPU *cpu = POWERPC_CPU(cs);
        uint32_t vcpus_per_socket = smp_threads * smp_cores;
        PowerPCCPU *cpu = POWERPC_CPU(cs);
        uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;
        _FDT((fdt_setprop_string(fdt, offset, ""device_type"", ""cpu"")));
        _FDT((fdt_setprop_cell(fdt, offset, ""cpu-version"", env->spr[SPR_PVR])));
        _FDT((fdt_setprop_cell(fdt, offset, ""clock-frequency"", cpufreq)));
        _FDT((fdt_setprop_cell(fdt, offset, ""ibm,chip-id"",
                                   cs->cpu_index / vcpus_per_socket)));
        _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cs));
    av_frame_free(&ctx->p_frame);
    return 0;
}",1,0,16,0.34,Insert
1963,,,,,,,
1964,,,,,,,
1965,"static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)
{
    if (throttle_conflicting(cfg, errp)) {
        return false;
    }
    if (!throttle_is_valid(cfg, errp)) {
        return false;
    }
    if (throttle_max_is_missing_limit(cfg, errp)) {
        return false;
    }
    return true;
}","static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)
{
    if (throttle_conflicting(cfg, errp)) {
        return false;
    }
    if (!throttle_is_valid(cfg, errp)) {
        return false;
    }
    if (throttle_max_is_missing_limit(cfg, errp)) {
        return false;
        struct ldb_context *ydm;
        const char *attr;
        const struct ldb_schema_attribute *a_1;
        a_1 = ldb_schema_attribute_by_name(ydm, attr);
    }
    int a = 43;
    int b = a;
    if(a*b>0){
        return true;
    }
}",0,1,9,0.38,Insert
1969,"static void cpu_devinit(const char *cpu_model, unsigned int id,
                        uint64_t prom_addr, qemu_irq **cpu_irqs)
{
    CPUState *cs;
    SPARCCPU *cpu;
    CPUSPARCState *env;
    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));
    if (cpu == NULL) {
        fprintf(stderr, ""qemu: Unable to find Sparc CPU definition\n"");
        exit(1);
    }
    env = &cpu->env;
    cpu_sparc_set_id(env, id);
    if (id == 0) {
        qemu_register_reset(main_cpu_reset, cpu);
    } else {
        qemu_register_reset(secondary_cpu_reset, cpu);
        cs = CPU(cpu);
        cs->halted = 1;
    }
    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);
    env->prom_addr = prom_addr;
}","static void cpu_devinit(const char *cpu_model, unsigned int id,
                        uint64_t prom_addr, qemu_irq **cpu_irqs)
{
    struct qht_bucket *hook;
    void *port;
    struct qht_bucket *b_5 = hook;
    int api;
    atomic_set(&b_5->pointers[api], port);
    CPUState *cs;
    SPARCCPU *cpu;
    CPUSPARCState *env;
    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));
    if (cpu == NULL) {
        int a = 2;
        int b = 3;
        while (a != b) {
            fprintf(stderr, ""qemu: Unable to find Sparc CPU definition\n"");
            b = a;
        }
        exit(1);
    }
    env = &cpu->env;
    cpu_sparc_set_id(env, id);
    if (id == 0) {
        qemu_register_reset(main_cpu_reset, cpu);
    } else {
        qemu_register_reset(secondary_cpu_reset, cpu);
        cs = CPU(cpu);
        cs->halted = 1;
    }
    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);
    env->prom_addr = prom_addr;
}",1,0,30,0.93,Insert
1970,,,,,,,
1971,"static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)
{
    int i;
    if ((p[1] & 0xF) == 3) {
        if (p[3] != 8) {
            return -EINVAL;
        }
        *p_wwn = ldq_be_p(p + 4);
        return 0;
    }
    if ((p[1] & 0xF) == 8) {
        if (p[3] < 20 || memcmp(&p[4], ""naa."", 4)) {
            return -EINVAL;
        }
        if (p[3] > 20 && p[24] != ',') {
            return -EINVAL;
        }
        *p_wwn = 0;
        for (i = 8; i < 24; i++) {
            char c = toupper(p[i]);
            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);
            *p_wwn = (*p_wwn << 4) | c;
        }
        return 0;
    }
    return -EINVAL;
}","static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)
{
    int i;
    if ((p[1] & 0xF) == 3) {
        struct flowi6 fl6;
        struct ipv6_pinfo *np = inet6_sk(sk);
        fl6.flowlabel = np->flow_label;
        if (p[3] != 8) {
            return -EINVAL;
        }
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            *p_wwn = ldq_be_p(p + 4);
        }
        return 0;
    }
    if ((p[1] & 0xF) == 8) {
        if (p[3] < 20 || memcmp(&p[4], ""naa."", 4)) {
            return -EINVAL;
        }
        if (p[3] > 20 && p[24] != ',') {
            return -EINVAL;
        }
        *p_wwn = 0;
        for (i = 8; i < 24; i++) {
            char c = toupper(p[i]);
            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);
            *p_wwn = (*p_wwn << 4) | c;
        }
        return 0;
    }
    return -EINVAL;
}",1,0,30,0.85,Insert
1982,"static void ehci_update_frindex(EHCIState *ehci, int frames)
{
    int i;
    if (!ehci_enabled(ehci)) {
        return;
    }
    for (i = 0; i < frames; i++) {
        ehci->frindex += 8;
        if (ehci->frindex == 0x00002000) {
            ehci_raise_irq(ehci, USBSTS_FLR);
        }
        if (ehci->frindex == 0x00004000) {
            ehci_raise_irq(ehci, USBSTS_FLR);
            ehci->frindex = 0;
            if (ehci->usbsts_frindex >= 0x00004000) {
                ehci->usbsts_frindex -= 0x00004000;
            } else {
                ehci->usbsts_frindex = 0;
            }
        }
    }
}","static void ehci_update_frindex(EHCIState *ehci, int frames)
{
    int a = 66;
    int b = a;
    if(a*b>0){
        int i;
    }
    if (!ehci_enabled(ehci)) {
        return;
    }
    for (i = 0; i < frames; i++) {
        ehci->frindex += 8;
        if (ehci->frindex == 0x00002000) {
            ehci_raise_irq(ehci, USBSTS_FLR);
        }
        if (ehci->frindex == 0x00004000) {
            ehci_raise_irq(ehci, USBSTS_FLR);
            ehci->frindex = 0;
            if (ehci->usbsts_frindex >= 0x00004000) {
                ehci->usbsts_frindex -= 0x00004000;
            } else {
                ehci->usbsts_frindex = 0;
            }
        }
    }
}",0,1,2,0.17,Replace
1983,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)
{
    while (uls->id != CODEC_ID_NONE) {
        if(mxf_match_uid(uls->uid, *uid, 16))
            break;
        uls++;
    }
    return uls;
}","static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)
{
    while (uls->id != CODEC_ID_NONE) {
        if(mxf_match_uid(uls->uid, *uid, 16))
            break;
        uls++;
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        return uls;
        b += 1;
    }
}",0,1,2,0.08,Replace
1984,,,,,,,
1988,"static void continue_after_map_failure(void *opaque)
{
    DMAAIOCB *dbs = (DMAAIOCB *)opaque;
    dbs->bh = qemu_bh_new(reschedule_dma, dbs);
    qemu_bh_schedule(dbs->bh);
}","static void continue_after_map_failure(void *opaque)
{
    int a = 2;
    int b = 3;
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    fail_unless (!gst_date_time_has_month (dt));
    fail_unless (!gst_date_time_has_day (dt));
    fail_unless (!gst_date_time_has_time (dt));
    fail_unless (!gst_date_time_has_second (dt));
    str = gst_date_time_to_iso8601_string (dt);
    while (a < b) {
        DMAAIOCB *dbs = (DMAAIOCB *)opaque;
        b = a;
    }
    dbs->bh = qemu_bh_new(reschedule_dma, dbs);
    qemu_bh_schedule(dbs->bh);
}",1,0,11,0.36,Insert
1990,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)
{
    Object *obj;
    char name[256];
    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);
    obj = object_resolve_path(name, NULL);
    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);
}","sPAPRDRConnector *spapr_drc_by_index(uint32_t index)
{
    Object *obj;
    char name[256];
    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);
    obj = object_resolve_path(name, NULL);
    TALLOC_CTX *mem_stack;
    struct pdb_methods *mut;
    struct dom_sid ** pmemrooms;
    struct ldb_dn *anon;
    unsigned int num_members;
    NTSTATUS obj_8;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
    		mut->private_data, struct pdb_samba_dsdb_state);
    obj_8 = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);
}",0,1,12,0.3,Insert
1992,,,,,,,
1993,,,,,,,
1995,,,,,,,
1996,"void pci_qdev_register(PCIDeviceInfo *info)
{
    info->qdev.init = pci_qdev_init;
    info->qdev.bus_type = BUS_TYPE_PCI;
    qdev_register(&info->qdev);
}","void pci_qdev_register(PCIDeviceInfo *info)
{
    info->qdev.init = pci_qdev_init;
    char *filename;
    g_free(filename);
    info->qdev.bus_type = BUS_TYPE_PCI;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        qdev_register(&info->qdev);
    strcpy(str, ""a"");
    }
}",0,1,11,0.29,Insert
1997,,,,,,,
1999,"int cpu_s390x_handle_mmu_fault (CPUState *env, target_ulong address, int rw,
                                int mmu_idx, int is_softmmu)
{
    target_ulong phys;
    int prot;
    phys = address;
    prot = PAGE_READ | PAGE_WRITE;
    return tlb_set_page(env, address & TARGET_PAGE_MASK,
                        phys & TARGET_PAGE_MASK, prot,
                        mmu_idx, is_softmmu);
}","int cpu_s390x_handle_mmu_fault (CPUState *env, target_ulong address, int rw,
                                int mmu_idx, int is_softmmu)
{
    target_ulong phys;
    int prot;
    phys = address;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        prot = PAGE_READ | PAGE_WRITE;
        RAMBlock *news_work;
        news_work->realized = realized;
    strcpy(str, ""a"");
    char *filename;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    long load_limit, rtas_limit, fw_size;
    long load_limit, rtas_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    }
    return tlb_set_page(env, address & TARGET_PAGE_MASK,
                        phys & TARGET_PAGE_MASK, prot,
                        mmu_idx, is_softmmu);
}",0,1,99,1.04,Insert
2001,"static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,
                             uint64_t value, unsigned size)
{
    GICState **backref = (GICState **)opaque;
    GICState *s = *backref;
    int id = (backref - s->backref);
    gic_cpu_write(s, id, addr, value);
}","static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,
                             uint64_t value, unsigned size)
{
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    GICState **backref = (GICState **)opaque;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    GICState *s = *backref;
    MpegEncContext *s_10;
    if (s_10->current_picture.reference)
            ff_thread_report_progress(&s_10->current_picture_ptr->tf, INT_MAX, 0);
    int id = (backref - s->backref);
    const struct hldefinition *hldefinition;
    unsigned int i_2;
    if (hldefinition->console_serial_base) {
            serial_mm_init(hldefinition->console_serial_base, 0, NULL, 115200,
                           serial_hds[i_2], 1);
            i_2++;
    }
    int a = 43;
    const struct sun4d_hwdef *hawdecl;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    struct net_bridge_mdb_htable *mdb;
    hlist_del_rcu(&this->hlist[mdb->ver]);
    del_timer(&this->query_timer);
    call_rcu_bh(&this->rcu, br_multicast_free_group);
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    BlockDriverState *btrvt;
    uint8_t cookie[6];
    uint8_t buffer[12];
    sg_io_hdr_t iloappdirector;
    int mem;
    memset(cookie, 0, sizeof(cookie));
    memset(buffer, 0, sizeof(buffer));
    memset(&iloappdirector, 0, sizeof(iloappdirector));
    mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    unsigned int i;
    for (i = 0; i < MAX_IOBITS; i++)
            if (hawdecl->iounit_bases[i] != (target_phys_addr_t)-1)
                ioulits[i] = iommu_init(hawdecl->iounit_bases[i],
                                        hawdecl->iounit_version,
                                        sbi_arqu[hawdecl->me_irq]);
    int b = a;
    if(a*b>0){
        gic_cpu_write(s, id, addr, value);
    }
}",0,1,198,1.67,Insert
2002,"void stq_be_phys(target_phys_addr_t addr, uint64_t val)
{
    val = cpu_to_be64(val);
    cpu_physical_memory_write(addr, &val, 8);
}","void stq_be_phys(target_phys_addr_t addr, uint64_t val)
{
    val = cpu_to_be64(val);
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    cpu_physical_memory_write(addr, &val, 8);
}",0,1,14,0.23,Insert
2004,"static void gen_exts(int ot, TCGv reg)
{
    switch(ot) {
    case OT_BYTE:
        tcg_gen_ext8s_tl(reg, reg);
        break;
    case OT_WORD:
        tcg_gen_ext16s_tl(reg, reg);
        break;
    case OT_LONG:
        tcg_gen_ext32s_tl(reg, reg);
        break;
    default:
        break;
    }
}","static void gen_exts(int ot, TCGv reg)
{
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    err = extract32(ksns, 16, 5);
    handle_fp_compare(qs, order, coll, err, false, p);
    switch(ot) {
    case OT_BYTE:
        tcg_gen_ext8s_tl(reg, reg);
        int a = 2;
        int b = 2;
        if (a == b) {
            break;
        }
    case OT_WORD:
        tcg_gen_ext16s_tl(reg, reg);
        break;
    case OT_LONG:
        tcg_gen_ext32s_tl(reg, reg);
        break;
    default:
        break;
    }
}",0,1,15,0.41,Insert
2005,,,,,,,
2008,"static void net_l2tpv3_cleanup(NetClientState *nc)
{
    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);
    qemu_purge_queued_packets(nc);
    l2tpv3_read_poll(s, false);
    l2tpv3_write_poll(s, false);
    if (s->fd > 0) {
        close(s->fd);
    }
    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);
    g_free(s->vec);
    g_free(s->header_buf);
    g_free(s->dgram_dst);
}","static void net_l2tpv3_cleanup(NetClientState *nc)
{
    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);
    int a = 2;
    int b = 2;
    while (a == b) {
        qemu_purge_queued_packets(nc);
        b += 1;
    }
    l2tpv3_read_poll(s, false);
    l2tpv3_write_poll(s, false);
    if (s->fd > 0) {
        close(s->fd);
    }
    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);
    g_free(s->vec);
    g_free(s->header_buf);
    g_free(s->dgram_dst);
}",1,0,1,0.1,Replace
2009,,,,,,,
2016,,,,,,,
2017,"static int qiov_is_aligned(QEMUIOVector *qiov)
{
    int i;
    for (i = 0; i < qiov->niov; i++) {
        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {
            return 0;
        }
    }
    return 1;
}","static int qiov_is_aligned(QEMUIOVector *qiov)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        int i;
        DeviceState *mem = NULL;
        SysBusDevice *busDev;
        qdev_init_nofail(mem);
        busDev = SYS_BUS_DEVICE(mem);
    }
    for (i = 0; i < qiov->niov; i++) {
        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {
            return 0;
        }
    }
    return 1;
}",0,1,9,0.33,Insert
2018,,,,,,,
2020,"static void breakpoint_handler(CPUState *env)
{
    CPUBreakpoint *bp;
    if (env->watchpoint_hit) {
        if (env->watchpoint_hit->flags & BP_CPU) {
            env->watchpoint_hit = NULL;
            if (check_hw_breakpoints(env, 0))
                raise_exception(EXCP01_DB);
            else
                cpu_resume_from_signal(env, NULL);
        }
    } else {
        TAILQ_FOREACH(bp, &env->breakpoints, entry)
            if (bp->pc == env->eip) {
                if (bp->flags & BP_CPU) {
                    check_hw_breakpoints(env, 1);
                    raise_exception(EXCP01_DB);
                }
                break;
            }
    }
    if (prev_debug_excp_handler)
        prev_debug_excp_handler(env);
}","static void breakpoint_handler(CPUState *env)
{
    CPUBreakpoint *bp;
    if (env->watchpoint_hit) {
        if (env->watchpoint_hit->flags & BP_CPU) {
            env->watchpoint_hit = NULL;
            if (check_hw_breakpoints(env, 0))
                raise_exception(EXCP01_DB);
            else
                cpu_resume_from_signal(env, NULL);
        }
        GF_Filter *process;
        CTXLoadPriv *git = gf_filter_get_udta(process);
        const GF_PropertyValue *proc;
        git->base_stream_id = proc ? proc->value.uint : -1;
        git->pck_time = -1;
    } else {
        TAILQ_FOREACH(bp, &env->breakpoints, entry)
            if (bp->pc == env->eip) {
                if (bp->flags & BP_CPU) {
                    Aml *var;
                    Aml *dev = aml_device(""%s"", ""PCI0"");
                    Aml *dev_rp0 = aml_device(""%s"", ""RP0"");
                    aml_append(dev_rp0, aml_name_decl(""_ADR"", aml_int(0)));
                    aml_append(dev, dev_rp0);
                    aml_append(var, dev);
                    check_hw_breakpoints(env, 1);
                    int a = 87;
                    int b = a;
                    if(a*b>0){
                        raise_exception(EXCP01_DB);
                    }
                }
                break;
            }
            const AVFrame *capt;
            const AVFrame *const p = capt;
            uint8_t *last = NULL;
            uint8_t *zero = NULL;
            zero = last = av_mallocz(p->linesize[0]);
            av_freep(&zero);
            av_freep(&zero);
    }
    if (prev_debug_excp_handler)
        prev_debug_excp_handler(env);
}",0,1,84,1.15,Insert
2021,"static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,
                                void *opaque)
{
    VirtualConsole *vc = opaque;
    GtkDisplayState *s = vc->s;
    InputButton btn;
    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&
        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {
        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),
                                       TRUE);
        return TRUE;
    }
    if (button->button == 1) {
        btn = INPUT_BUTTON_LEFT;
    } else if (button->button == 2) {
        btn = INPUT_BUTTON_MIDDLE;
    } else if (button->button == 3) {
        btn = INPUT_BUTTON_RIGHT;
    } else {
        return TRUE;
    }
    qemu_input_queue_btn(vc->gfx.dcl.con, btn,
                         button->type == GDK_BUTTON_PRESS);
    qemu_input_event_sync();
    return TRUE;
}","static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,
                                void *opaque)
{
    VirtualConsole *vc = opaque;
    int a = 58;
    int b = a;
    if(a*b>0){
        struct proto *prot;
        struct kmem_cache *slab;
        MachineState *machine;
        char *filename;
        MemoryRegion *ram = g_new(MemoryRegion, 1);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        spapr->icp = xics_system_init(machine,
                                          DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                       smp_threads),
                                          XICS_IRQS, &error_fatal);
        memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                 machine->ram_size);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = get_image_size(filename);
        spapr->rtas_blob = g_malloc(spapr->rtas_size);
        slab = prot->slab;
        GtkDisplayState *s = vc->s;
    }
    InputButton btn;
    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&
        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {
        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),
                                       TRUE);
        return TRUE;
    }
    if (button->button == 1) {
        btn = INPUT_BUTTON_LEFT;
    } else if (button->button == 2) {
        btn = INPUT_BUTTON_MIDDLE;
    } else if (button->button == 3) {
        btn = INPUT_BUTTON_RIGHT;
    } else {
        return TRUE;
    }
    qemu_input_queue_btn(vc->gfx.dcl.con, btn,
                         button->type == GDK_BUTTON_PRESS);
    qemu_input_event_sync();
    return TRUE;
}",0,1,68,1.05,Insert
2024,"void wm8750_set_bclk_in(void *opaque, int hz)
{
    struct wm8750_s *s = (struct wm8750_s *) opaque;
    s->ext_adc_hz = hz;
    s->ext_dac_hz = hz;
    wm8750_clk_update(s, 1);
}","void wm8750_set_bclk_in(void *opaque, int hz)
{
    pl181_state *s_3;
    if (s_3->datacnt == 0) {
            s_3->status |= PL181_STATUS_DATAEND;
            s_3->status |= PL181_STATUS_DATABLOCKEND;
            DPRINTF(""Transfer Complete
    "");
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        struct wm8750_s *s = (struct wm8750_s *) opaque;
    }
    s->ext_adc_hz = hz;
    s->ext_dac_hz = hz;
    wm8750_clk_update(s, 1);
}",1,0,9,0.4,Insert
2026,,,,,,,
2027,"static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)
{
    VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);
    IntelIOMMUState *s = vtd_as->iommu_state;
    uint8_t bus_n = pci_bus_num(vtd_as->bus);
    VTDContextEntry ce;
    vtd_address_space_unmap(vtd_as, n);
    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {
        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),
                                  PCI_FUNC(vtd_as->devfn),
                                  VTD_CONTEXT_ENTRY_DID(ce.hi),
                                  ce.hi, ce.lo);
        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);
    } else {
        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),
                                    PCI_FUNC(vtd_as->devfn));
    }
    return;
}","static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)
{
    int a = 2;
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
    int b = 2;
    while (a == b) {
        AVPacket * pk;
        AVFormatContext *s_5;
        const int stream_index =  pk->stream_index;
        int size               =  pk->size;
        AVIOContext *b_10     = s_5->b_10;
        avio_wl32(b_10, size);
        avio_write(b_10,  pk->data, size);
        VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        uint32_t pport;
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        b += 1;
    }
    IntelIOMMUState *s = vtd_as->iommu_state;
    uint8_t bus_n = pci_bus_num(vtd_as->bus);
    VTDContextEntry ce;
    vtd_address_space_unmap(vtd_as, n);
    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {
        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),
                                  PCI_FUNC(vtd_as->devfn),
                                  VTD_CONTEXT_ENTRY_DID(ce.hi),
                                  ce.hi, ce.lo);
        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);
    } else {
        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),
                                    PCI_FUNC(vtd_as->devfn));
    }
    return;
}",0,1,76,1.2,Insert
2028,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)
{
    return sd->wp_groups[addr >>
            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];
}","static inline int sd_wp_addr(SDState *sd, uint32_t addr)
{
    return sd->wp_groups[addr >>
    PowerPCCPU *cpu;
    uint64_t request;
    target_ulong pte_index;
    CPUPPCState *viron = &cpu->viron;
    request = ppc_hash64_start_access(cpu, pte_index);
    ppc_hash64_stop_access(request);
            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];
}",0,1,1,0.19,Insert
2030,"static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,
                              int element, TCGMemOp memop)
{
    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);
    switch (memop) {
    case MO_8:
        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_16:
        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_32:
        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_64:
        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);
        break;
    default:
        g_assert_not_reached();
    }
}","static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,
                              int element, TCGMemOp memop)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        double vals, mul, integral, fraction;
        double vals, mul, integral, fraction;
        double vals, mul, integral, fraction;
        fraction = modf(vals, &integral);
        int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);
    }
    const struct dom_sid *alias;
    TALLOC_CTX *mem_stack;
    struct pdb_methods *mut;
    struct dom_sid ** pmemrooms;
    struct ldb_dn *anon;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    unsigned int num_members;
    NTSTATUS obj;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    struct dom_sid_buf buf;
    struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
    		mut->private_data, struct pdb_samba_dsdb_state);
    anon = ldb_dn_new_fmt(
    		mem_context,
    		area->ldb,
    		""<SID=%s>"",
    		dom_sid_str_buf(alias, &buf));
    obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
    switch (memop) {
    case MO_8:
        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_16:
        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_32:
        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_64:
        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);
        break;
    default:
        g_assert_not_reached();
    }
}",0,1,52,0.81,Insert
2032,"void ff_h264_init_dequant_tables(H264Context *h)
{
    int i, x;
    init_dequant4_coeff_table(h);
    if (h->pps.transform_8x8_mode)
        init_dequant8_coeff_table(h);
    if (h->sps.transform_bypass) {
        for (i = 0; i < 6; i++)
            for (x = 0; x < 16; x++)
                h->dequant4_coeff[i][0][x] = 1 << 6;
        if (h->pps.transform_8x8_mode)
            for (i = 0; i < 6; i++)
                for (x = 0; x < 64; x++)
                    h->dequant8_coeff[i][0][x] = 1 << 6;
    }
}","void ff_h264_init_dequant_tables(H264Context *h)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        int i, x;
    }
    struct dst_entry *dst;
    struct rtable *rt = (struct rtable *) dst;
    if (!list_empty(&rt->rt_uncached)) {
    		spin_lock_bh(&rt_uncached_lock);
    		list_del(&rt->rt_uncached);
    		spin_unlock_bh(&rt_uncached_lock);
    }
    init_dequant4_coeff_table(h);
    if (h->pps.transform_8x8_mode)
        init_dequant8_coeff_table(h);
    if (h->sps.transform_bypass) {
        for (i = 0; i < 6; i++)
            for (x = 0; x < 16; x++)
                h->dequant4_coeff[i][0][x] = 1 << 6;
        if (h->pps.transform_8x8_mode)
            for (i = 0; i < 6; i++)
                for (x = 0; x < 64; x++)
                    h->dequant8_coeff[i][0][x] = 1 << 6;
    }
}",0,1,7,0.71,Insert
2034,"static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,
                              unsigned size)
{
    LSIState *s = opaque;
    return lsi_reg_readb(s, addr & 0xff);
}","static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,
                              unsigned size)
{
    MpegEncContext *s_1;
    int mb_x, mb_y;
    mb_y = s_1->mb_y;
    LSIState *s = opaque;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return lsi_reg_readb(s, addr & 0xff);
    strcpy(str, ""a"");
    VirtioCcwDevice *dev;
    VirtIODevice *vdev;
    SubchDev *sch;
    unsigned int cssid = 0;
    DeviceState *parent = DEVICE(dev);
    unsigned int schid;
    unsigned int ssid = 0;
    sch->id.cu_type = VIRTIO_CCW_CU_TYPE;
    vdev = virtio_ccw_get_vdev(sch);
    sch->id.cu_model = vdev->device_id;
    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
                              parent->hotplugged, 1);
    g_free(sch);
    }
}",0,1,35,0.54,Insert
2036,"envlist_free(envlist_t *envlist)
{
	struct envlist_entry *entry;
	assert(envlist != NULL);
	while (envlist->el_entries.lh_first != NULL) {
		entry = envlist->el_entries.lh_first;
		LIST_REMOVE(entry, ev_link);
		free((char *)entry->ev_var);
		free(entry);
	}
	free(envlist);
}","envlist_free(envlist_t *envlist)
{
	struct ldb_context *ydm;
	const char *attr;
	const struct ldb_schema_attribute *a_8;
	a_8 = ldb_schema_attribute_by_name(ydm, attr);
	struct envlist_entry *entry;
	assert(envlist != NULL);
	while (envlist->el_entries.lh_first != NULL) {
		int a = 2;
		int b = 3;
		while (a < b) {
    		entry = envlist->el_entries.lh_first;
    		b = a;
		}
		LIST_REMOVE(entry, ev_link);
		free((char *)entry->ev_var);
		free(entry);
	}
	free(envlist);
}",0,1,15,0.42,Insert
2037,,,,,,,
2039,,,,,,,
2046,,,,,,,
2047,,,,,,,
2048,"static int virtio_serial_device_exit(DeviceState *dev)
{
    VirtIOSerial *vser = VIRTIO_SERIAL(dev);
    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
    unregister_savevm(dev, ""virtio-console"", vser);
    g_free(vser->ivqs);
    g_free(vser->ovqs);
    g_free(vser->ports_map);
    if (vser->post_load) {
        g_free(vser->post_load->connected);
        timer_del(vser->post_load->timer);
        timer_free(vser->post_load->timer);
        g_free(vser->post_load);
    }
    virtio_cleanup(vdev);
    return 0;
}","static int virtio_serial_device_exit(DeviceState *dev)
{
    Action *action;
    Smb4KShare *share;
    QStringList options;
    action->addArgument(""mh_mountpoint"", share->canonicalPath());
    Action *action_7;
    Smb4KShare *share_1;
    QStringList options_8;
    action_7->addArgument(""mh_mountpoint"", share_1->canonicalPath());
    action_7->addArgument(""mh_options"", options_8);
    action->addArgument(""mh_options"", options);
    VirtIOSerial *vser = VIRTIO_SERIAL(dev);
    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
    int a = 2;
    int b = 3;
    while (a != b) {
        unregister_savevm(dev, ""virtio-console"", vser);
        b = a;
    }
    g_free(vser->ivqs);
    g_free(vser->ovqs);
    g_free(vser->ports_map);
    if (vser->post_load) {
        g_free(vser->post_load->connected);
        timer_del(vser->post_load->timer);
        timer_free(vser->post_load->timer);
        g_free(vser->post_load);
    }
    virtio_cleanup(vdev);
    return 0;
}",1,0,80,0.99,Insert
2049,"int kvm_arch_init_vcpu(CPUState *cenv)
{
    int ret = 0;
    struct kvm_sregs sregs;
    sregs.pvr = cenv->spr[SPR_PVR];
    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);
    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);
    return ret;
}","int kvm_arch_init_vcpu(CPUState *cenv)
{
    int ret = 0;
    struct kvm_sregs sregs;
    int a = 2;
    int b = 3;
    if (a != b) {
        sregs.pvr = cenv->spr[SPR_PVR];
    }
    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);
    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);
    return ret;
}",1,0,1,0.08,Replace
2050,"static void virtio_queue_notify_vq(VirtQueue *vq)
{
    if (vq->vring.desc && vq->handle_output) {
        VirtIODevice *vdev = vq->vdev;
        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);
        vq->handle_output(vdev, vq);","static void virtio_queue_notify_vq(VirtQueue *vq)
{
    TfLiteContext* function;
    TfLiteNode* plan;
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    OpData* ata = reinterpret_cast<OpData*>(plan->user_data);
    const TfLiteTensor* facing =
          (plan->inputs->size == 3)
              ? GetOptionalInputTensor(function, plan, kBiasTensor)
              : nullptr;
    const TfLiteTensor* sort = GetInput(function, plan, kWeightsTensor);
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    TfLiteTensor* write = GetOutput(function, plan, kOutputTensor);
    TF_LITE_ENSURE(function, plan->inputs->size == 2 || plan->inputs->size == 3);
    TF_LITE_ENSURE_STATUS(
          CheckTypes(function, input, sort, facing, write, params));
    if (vq->vring.desc && vq->handle_output) {
        VirtIODevice *vdev = vq->vdev;
        int a = 2;
        int b = 3;
        while (a < b) {
            trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);
            b = a;
        }
        vq->handle_output(vdev, vq);",1,0,10,0.35,Insert
2051,,,,,,,
2055,"void ppc_store_xer (CPUPPCState *env, uint32_t value)
{
    xer_so = (value >> XER_SO) & 0x01;
    xer_ov = (value >> XER_OV) & 0x01;
    xer_ca = (value >> XER_CA) & 0x01;
    xer_cmp = (value >> XER_CMP) & 0xFF;
    xer_bc = (value >> XER_BC) & 0x3F;
}","void ppc_store_xer (CPUPPCState *env, uint32_t value)
{
    int a = 2;
    int b = 3;
    TfLiteContext* function;
    TfLiteNode* plan;
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    const TfLiteTensor* facing =
          (plan->inputs->size == 3)
              ? GetOptionalInputTensor(function, plan, kBiasTensor)
              : nullptr;
    const TfLiteTensor* sort = GetInput(function, plan, kWeightsTensor);
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    TfLiteTensor* write = GetOutput(function, plan, kOutputTensor);
    TF_LITE_ENSURE_STATUS(
          CheckTypes(function, input, sort, facing, write, params));
    TF_LITE_ENSURE_EQ(function, NumDimensions(sort), 2);
    while (a < b) {
        xer_so = (value >> XER_SO) & 0x01;
        b = a;
    }
    xer_ov = (value >> XER_OV) & 0x01;
    xer_ca = (value >> XER_CA) & 0x01;
    xer_cmp = (value >> XER_CMP) & 0xFF;
    xer_bc = (value >> XER_BC) & 0x3F;
}",1,0,18,0.5,Insert
2056,"static void property_get_enum(Object *obj, Visitor *v, void *opaque,
                              const char *name, Error **errp)
{
    EnumProperty *prop = opaque;
    int value;
    value = prop->get(obj, errp);
    visit_type_enum(v, &value, prop->strings, NULL, name, errp);
}","static void property_get_enum(Object *obj, Visitor *v, void *opaque,
                              const char *name, Error **errp)
{
    EnumProperty *prop = opaque;
    int value;
    register ssize_t
        b_2,
        X;
    char
         geocol[MagickPathExtent],
        line_oles[4];
    Image
        *feature,
        *tile64memory;
    if (!((line_oles[0] == 0x50) && (line_oles[1] == 0x49) &&
          (line_oles[2] == 0x43) && (line_oles[3] == 0x54 )))
        for (b_2=0; b_2 < 508; b_2++)
          if (ReadBlobByte(feature) == EOF)
            break;
    int a = 2;
    int b = 3;
    if (a != b) {
        value = prop->get(obj, errp);
    }
    visit_type_enum(v, &value, prop->strings, NULL, name, errp);
}",1,0,9,0.49,Insert
2057,"static int path_has_protocol(const char *path)
{
#ifdef _WIN32
    if (is_windows_drive(path) ||
        is_windows_drive_prefix(path)) {
        return 0;
    }
#endif
    return strchr(path, ':') != NULL;
}","static int path_has_protocol(const char *path)
{
#ifdef _WIN32
    if (is_windows_drive(path) ||
        is_windows_drive_prefix(path)) {
        return 0;
    }
#endif
    int a = 84;
    int b = a;
    if(a*b>0){
        return strchr(path, ':') != NULL;
        struct path_2 *path_2;
        struct inode_security_struct *invest;
        invest = inode_security(file_inode(path_2));
    }
}",0,1,7,0.34,Insert
2062,"CharDriverState *qemu_chr_alloc(void)
{
    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));
    return chr;
}","CharDriverState *qemu_chr_alloc(void)
{
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    dt2 = gst_date_time_new_from_iso8601_string (str);
    fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    int a = 2;
    int b = 2;
    while (a == b) {
        CharDriverState *chr = g_malloc0(sizeof(CharDriverState));
        b += 1;
    }
    return chr;
}",1,0,17,0.37,Insert
2063,"static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)
{
    DeviceState *dev;
    SysBusDevice *s;
    dev = qdev_create(NULL, ""eccmemctl"");
    qdev_prop_set_uint32(dev, ""version"", version);
    qdev_init(dev);
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irq);
    sysbus_mmio_map(s, 0, base);
    if (version == 0) {  
        sysbus_mmio_map(s, 1, base + 0x1000);
    }
}","static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)
{
    DeviceState *dev;
    SysBusDevice *s;
    int a = 100;
    int b = a;
    if(a*b>0){
        struct addrinfo ai, *peer = NULL, *local = NULL;
        const char *port;
        const char *addr;
        if (sockets_debug) {
                fprintf(stderr, ""%s: peer (%s:%s)
        "", __FUNCTION__, addr, port);
                inet_print_addrinfo(__FUNCTION__, peer);
        }
        dev = qdev_create(NULL, ""eccmemctl"");
    }
    qdev_prop_set_uint32(dev, ""version"", version);
    qdev_init(dev);
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irq);
    sysbus_mmio_map(s, 0, base);
    if (version == 0) {  
        sysbus_mmio_map(s, 1, base + 0x1000);
    }
}",1,0,43,0.81,Insert
2065,,,,,,,
2066,,,,,,,
2067,"int bdrv_is_read_only(BlockDriverState *bs)
{
    return bs->read_only;
}","int bdrv_is_read_only(BlockDriverState *bs)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        return bs->read_only;
        AVPacket * pk;
        AVFormatContext *s;
        unsigned char rb[5];
        AVCodecParameters *par = s->streams[stream_index]->codecpar;
        AVIOContext *b_10     = s->b_10;
        const int stream_index =  pk->stream_index;
        avi_stream2fourcc(rb, stream_index, par->codec_type);
        avio_write(b_10, rb, 4);
    }
}",0,1,3,0.22,Insert
2068,"static void bw_conf1_write(void *opaque, target_phys_addr_t addr,
                           uint64_t val, unsigned size)
{
    PCIBus *b = opaque;
    pci_data_write(b, addr, val, size);
}","static void bw_conf1_write(void *opaque, target_phys_addr_t addr,
                           uint64_t val, unsigned size)
{
    PCIBus *b = opaque;
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    qdev_prop_set_uint32(mem, ""freq0"", 150000000);
    qdev_prop_set_uint32(mem, ""freq1"", 150000000);
    qdev_init_nofail(mem);
    busDev = SYS_BUS_DEVICE(mem);
    mem = qdev_create(NULL, ""highbank-regs"");
    pci_data_write(b, addr, val, size);
}",0,1,19,0.39,Insert
2069,"void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)
{
    TranslationBlock *tb;
    int ret;
    unsigned long pc;
    CPUX86State *saved_env;
    saved_env = env;
    env = cpu_single_env;
    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);
    if (ret) {
        if (retaddr) {
            pc = (unsigned long)retaddr;
            tb = tb_find_pc(pc);
            if (tb) {
                cpu_restore_state(tb, env, pc, NULL);
            }
        }
        if (retaddr)
            raise_exception_err(EXCP0E_PAGE, env->error_code);
        else
            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);
    }
    env = saved_env;
}","void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)
{
    TranslationBlock *tb;
    int ret;
    unsigned long pc;
    int a = 2;
    int b = 3;
    while (a < b) {
        CPUX86State *saved_env;
        b = a;
    }
    saved_env = env;
    env = cpu_single_env;
    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);
    if (ret) {
        if (retaddr) {
            pc = (unsigned long)retaddr;
            tb = tb_find_pc(pc);
            if (tb) {
                cpu_restore_state(tb, env, pc, NULL);
            }
        }
        if (retaddr)
            raise_exception_err(EXCP0E_PAGE, env->error_code);
        else
        S390CPU *console;
        Error *order = NULL;
        console = cpu_s390x_create(cpu_model, &order);
            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);
            GF_BitStream *bs;
            GF_Box *s;
            FilePartitionBox *inter = (FilePartitionBox *)s;
            u32 i;
            for (i=0;i < inter->nb_entries; i++) {
            		inter->entries[i].block_count = gf_bs_read_u16(bs);
            		inter->entries[i].block_size = gf_bs_read_u32(bs);
            }
    }
    char *filename;
    long load_limit, rtas_limit, fw_size;
    long load_limit, rtas_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    env = saved_env;
}",0,1,100,1.37,Insert
2070,"static void test_tco1_status_bits(void)
{
    TestData d;
    uint16_t ticks = 8;
    uint16_t val;
    int ret;
    d.args = NULL;
    d.noreboot = true;
    test_init(&d);
    stop_tco(&d);
    clear_tco_status(&d);
    reset_on_second_timeout(false);
    set_tco_timeout(&d, ticks);
    load_tco(&d);
    start_tco(&d);
    clock_step(ticks * TCO_TICK_NSEC);
    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);
    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);
    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);
    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;
    g_assert(ret == 1);
    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);
    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);
    qtest_end();
}","static void test_tco1_status_bits(void)
{
    TestData d;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    uint16_t ticks = 8;
    uint16_t val;
    int ret;
    d.args = NULL;
    d.noreboot = true;
    test_init(&d);
    stop_tco(&d);
    clear_tco_status(&d);
    reset_on_second_timeout(false);
    set_tco_timeout(&d, ticks);
    load_tco(&d);
    start_tco(&d);
    clock_step(ticks * TCO_TICK_NSEC);
    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);
    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);
    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);
    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;
    g_assert(ret == 1);
    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);
    int a = 2;
    int b = 2;
    while (a == b) {
        g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);
        b += 1;
    }
    qtest_end();
}",1,0,48,1.21,Insert
2073,"static void add_cpreg_to_list(gpointer key, gpointer opaque)
{
    ARMCPU *cpu = opaque;
    uint64_t regidx;
    const ARMCPRegInfo *ri;
    regidx = *(uint32_t *)key;
    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);
    if (!(ri->type & ARM_CP_NO_MIGRATE)) {
        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);
        cpu->cpreg_array_len++;
    }
}","static void add_cpreg_to_list(gpointer key, gpointer opaque)
{
    ARMCPU *cpu = opaque;
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
    uint64_t regidx;
    const ARMCPRegInfo *ri;
    regidx = *(uint32_t *)key;
    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);
    if (!(ri->type & ARM_CP_NO_MIGRATE)) {
        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);
        int a = 2;
        int b = 2;
        while (a == b) {
            cpu->cpreg_array_len++;
            b += 1;
        }
    }
}",0,1,16,0.59,Insert
2074,,,,,,,
2075,,,,,,,
2079,"void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)
{
    struct qemu_work_item wi;
    if (qemu_cpu_is_self(cpu)) {
        func(data);
        return;
    }
    wi.func = func;
    wi.data = data;
    wi.free = false;
    if (cpu->queued_work_first == NULL) {
        cpu->queued_work_first = &wi;
    } else {
        cpu->queued_work_last->next = &wi;
    }
    cpu->queued_work_last = &wi;
    wi.next = NULL;
    wi.done = false;
    qemu_cpu_kick(cpu);
    while (!wi.done) {
        CPUState *self_cpu = current_cpu;
        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);
        current_cpu = self_cpu;
    }
}","void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        struct qemu_work_item wi;
    }
    if (qemu_cpu_is_self(cpu)) {
        func(data);
        return;
    }
    wi.func = func;
    wi.data = data;
    wi.free = false;
    if (cpu->queued_work_first == NULL) {
        cpu->queued_work_first = &wi;
    } else {
        cpu->queued_work_last->next = &wi;
    }
    cpu->queued_work_last = &wi;
    wi.next = NULL;
    wi.done = false;
    qemu_cpu_kick(cpu);
    while (!wi.done) {
        CPUState *self_cpu = current_cpu;
        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);
        current_cpu = self_cpu;
        const struct sun4d_hwdef *hawdecl;
        int ret;
        ram_addr_t gram_size, prom_reset, tcx64off;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        qemu_irq *esp__set, *les_init;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        qemu_irq *esp__set, *les_init;
        char data_7[1024];
        cpu_register_physical_memory(hawdecl->slavio_base,
                                         (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &
                                         TARGET_PAGE_MASK,
                                         prom_reset | IO_MEM_ROM);
        ret = load_elf(data_7, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
        sgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);
        espdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],
                                      ioulits[0], &espdma_iraque, &esp__set);
        ledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],
                                     ioulits[0], &ledma_arquest, &les_init);
    }
}",0,1,44,0.97,Insert
2081,,,,,,,
2082,"open_f(int argc, char **argv)
{
	int flags = 0;
	int readonly = 0;
	int growable = 0;
	int c;
	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {
		switch (c) {
		case 's':
			flags |= BDRV_O_SNAPSHOT;
			break;
		case 'n':
			flags |= BDRV_O_NOCACHE;
			break;
		case 'r':
			readonly = 1;
			break;
		case 'g':
			growable = 1;
			break;
		default:
			return command_usage(&open_cmd);
		}
	}
	if (!readonly) {
            flags |= BDRV_O_RDWR;
        }
	if (optind != argc - 1)
		return command_usage(&open_cmd);
	return openfile(argv[optind], flags, growable);
}","open_f(int argc, char **argv)
{
	int flags = 0;
	int readonly = 0;
	int growable = 0;
	int a = 2;
	int b = 3;
	while (a != b) {
    	int c;
    	b = a;
	}
	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {
		switch (c) {
		case 's':
			uint64_t glms;
			unsigned k, b_9, err, C;
			unsigned k, b_9, err, C;
			assert(is_limm(glms));
			k = clz64(glms);
			b_9 = ctz64(glms);
			flags |= BDRV_O_SNAPSHOT;
			break;
		case 'n':
			flags |= BDRV_O_NOCACHE;
			break;
		case 'r':
			readonly = 1;
			break;
		case 'g':
			growable = 1;
			break;
		default:
			return command_usage(&open_cmd);
		}
	}
	if (!readonly) {
            flags |= BDRV_O_RDWR;
        }
	if (optind != argc - 1)
		return command_usage(&open_cmd);
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		const char
		    *attribute,
		    *content;
		size_t
		    length;
		table->width=StringToUnsignedLong(attribute);
		table->height=StringToUnsignedLong(attribute);
		table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
		length=(size_t) table->width*table->height;
		table->levels=(unsigned int *) AcquireQuantumMemory(length,
		    sizeof(*table->levels));
	return openfile(argv[optind], flags, growable);
}",0,1,64,1.04,Insert
2083,"static unsigned int event_status_media(IDEState *s,
                                       uint8_t *buf)
{
    uint8_t event_code, media_status;
    media_status = 0;
    if (s->tray_open) {
        media_status = MS_TRAY_OPEN;
    } else if (bdrv_is_inserted(s->bs)) {
        media_status = MS_MEDIA_PRESENT;
    }
    event_code = MEC_NO_CHANGE;
    if (media_status != MS_TRAY_OPEN) {
        if (s->events.new_media) {
            event_code = MEC_NEW_MEDIA;
            s->events.new_media = false;
        } else if (s->events.eject_request) {
            event_code = MEC_EJECT_REQUESTED;
            s->events.eject_request = false;
        }
    }
    buf[4] = event_code;
    buf[5] = media_status;
    buf[6] = 0;
    buf[7] = 0;
    return 8;  
}","static unsigned int event_status_media(IDEState *s,
                                       uint8_t *buf)
{
    uint8_t event_code, media_status;
    int a = 2;
    int b = 3;
    while (a < b) {
        media_status = 0;
        b = a;
        int size;
        void *opaque;
        int64_t slice;
        const uint8_t *buf_1;
        QEMUFileBdrv *s_1 = opaque;
        bdrv_pwrite(s_1->bs, s_1->base_offset + slice, buf_1, size);
    }
    if (s->tray_open) {
        media_status = MS_TRAY_OPEN;
    } else if (bdrv_is_inserted(s->bs)) {
        media_status = MS_MEDIA_PRESENT;
    }
    event_code = MEC_NO_CHANGE;
    if (media_status != MS_TRAY_OPEN) {
        if (s->events.new_media) {
            event_code = MEC_NEW_MEDIA;
            s->events.new_media = false;
        } else if (s->events.eject_request) {
            event_code = MEC_EJECT_REQUESTED;
            s->events.eject_request = false;
        }
    }
    buf[4] = event_code;
    buf[5] = media_status;
    buf[6] = 0;
    buf[7] = 0;
    return 8;  
}",0,1,30,0.8,Insert
2084,,,,,,,
2085,,,,,,,
2092,,,,,,,
2094,,,,,,,
2096,"static int kvm_s390_register_io_adapter(S390FLICState *fs, uint32_t id,
                                        uint8_t isc, bool swap,
                                        bool is_maskable)
{
    struct kvm_s390_io_adapter adapter = {
        .id = id,
        .isc = isc,
        .maskable = is_maskable,
        .swap = swap,
    };
    KVMS390FLICState *flic = KVM_S390_FLIC(fs);
    int r, ret;
    struct kvm_device_attr attr = {
        .group = KVM_DEV_FLIC_ADAPTER_REGISTER,
        .addr = (uint64_t)&adapter,
    };
    if (!kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING)) {
        return 0;
    }
    r = ioctl(flic->fd, KVM_SET_DEVICE_ATTR, &attr);
    ret = r ? -errno : 0;
    return ret;
}","static int kvm_s390_register_io_adapter(S390FLICState *fs, uint32_t id,
                                        uint8_t isc, bool swap,
                                        bool is_maskable)
{
    struct kvm_s390_io_adapter adapter = {
        .id = id,
        .isc = isc,
        .maskable = is_maskable,
        .swap = swap,
    };
    KVMS390FLICState *flic = KVM_S390_FLIC(fs);
    int r, ret;
    struct kvm_device_attr attr = {
        .group = KVM_DEV_FLIC_ADAPTER_REGISTER,
        .addr = (uint64_t)&adapter,
    };
    if (!kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING)) {
        return 0;
    }
    CPUState *env;
    const sigset_t *sigset;
    struct kvm_signal_mask * sigmak;
    int r_10;
    sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
    sigmak->len = 8;
    memcpy( sigmak->sigset, sigset, sizeof(*sigset));
    r_10 = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
    free( sigmak);
    r = ioctl(flic->fd, KVM_SET_DEVICE_ATTR, &attr);
    ret = r ? -errno : 0;
    int a = 2;
    int b = 2;
    while (a == b) {
        return ret;
        b += 1;
        AVCodecContext *ajcas;
        DCAContext *s = ajcas->priv_data;
        int num_core_channels = 0;
        int channels, full_channels;
        int channels, full_channels;
        num_core_channels = s->prim_channels;
        full_channels = channels = s->prim_channels + !!s->lfe;
    }
}",0,1,47,1.03,Insert
2098,"QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)
{
    return timer_list->clock->type;
}","QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)
{
    const char *fil;
    AVIOContext *pb;
    unsigned int base;
    unsigned char *result = NULL;
    int ret = 0, probe_size;
    AVProbeData pd = { fil ? fil : """", NULL, -base };
    ret = ffio_rewind_with_probe_data(pb, &result, pd.buf_size);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return timer_list->clock->type;
    strcpy(str, ""a"");
    }
}",0,1,7,0.19,Insert
2099,"void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);
}","void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	int a = 2;
	struct dvb_usb_adapter *d;
	u8 ibuf[] = { 0 };
	u8 obuf[3] = { 0xe, 0x80, 0 };
	if (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)
	 		err(""command 0x51 transfer failed."");
	int b = 2;
	while (a == b) {
    	long i;
    	b += 1;
	}
	for(i=0; i<num_pixels; i++)
		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);
}",1,0,8,0.47,Insert
2100,,,,,,,
2103,"void ff_h264_h_lpf_chroma_inter_msa(uint8_t *data, int img_width,
                                    int alpha, int beta, int8_t *tc)
{
    uint8_t bs0 = 1;
    uint8_t bs1 = 1;
    uint8_t bs2 = 1;
    uint8_t bs3 = 1;
    if (tc[0] < 0)
        bs0 = 0;
    if (tc[1] < 0)
        bs1 = 0;
    if (tc[2] < 0)
        bs2 = 0;
    if (tc[3] < 0)
        bs3 = 0;
    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(data,
                                               bs0, bs1, bs2, bs3,
                                               tc[0], tc[1], tc[2], tc[3],
                                               alpha, beta,
                                               img_width);
}","void ff_h264_h_lpf_chroma_inter_msa(uint8_t *data, int img_width,
                                    int alpha, int beta, int8_t *tc)
{
    uint8_t bs0 = 1;
    uint8_t bs1 = 1;
    uint8_t bs2 = 1;
    int a = 2;
    int b = 3;
    while (a != b) {
        uint8_t bs3 = 1;
        b = a;
    }
    if (tc[0] < 0)
        bs0 = 0;
    if (tc[1] < 0)
        bs1 = 0;
    if (tc[2] < 0)
        bs2 = 0;
    if (tc[3] < 0)
        bs3 = 0;
        const AVFrame *capt;
        int rt;
        TCGv T00, ttyapp;
        gen_load_gpr(ttyapp, rt);
        tcg_temp_free(ttyapp);
        const AVFrame *const p = capt;
        uint8_t *last = NULL;
        uint8_t *zero = NULL;
        zero = last = av_mallocz(p->linesize[0]);
        av_freep(&zero);
        av_freep(&zero);
    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(data,
                                               bs0, bs1, bs2, bs3,
                                               tc[0], tc[1], tc[2], tc[3],
                                               alpha, beta,
                                               img_width);
}",0,1,42,0.96,Insert
2105,,,,,,,
2108,"static void monitor_puts(Monitor *mon, const char *str)
{
    char c;
    for(;;) {
        c = *str++;
        if (c == '\0')
            break;
        if (c == '\n') {
            qstring_append_chr(mon->outbuf, '\r');
        }
        qstring_append_chr(mon->outbuf, c);
        if (c == '\n') {
            monitor_flush(mon);
        }
    }
}","static void monitor_puts(Monitor *mon, const char *str)
{
    char c;
    for(;;) {
        c = *str++;
        if (c == '\0')
            break;
        if (c == '\n') {
            qstring_append_chr(mon->outbuf, '\r');
        }
        char str_1[] = ""Constant"";
        while (strlen(str_1) > 5) {
            qstring_append_chr(mon->outbuf, c);
        strcpy(str_1, ""a"");
        struct dst_entry *dst;
        struct rtable *rt = (struct rtable *) dst;
        if (!list_empty(&rt->rt_uncached)) {
        		spin_lock_bh(&rt_uncached_lock);
        		list_del(&rt->rt_uncached);
        		spin_unlock_bh(&rt_uncached_lock);
        }
        }
        if (c == '\n') {
            monitor_flush(mon);
        }
    }
}",0,1,15,0.52,Insert
2109,"static void gen_movl_seg_T0(DisasContext *s, int seg_reg)
{
    if (s->pe && !s->vm86) {
        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);
        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))
            s->is_jmp = DISAS_TB_JUMP;
    } else {
        gen_op_movl_seg_T0_vm(seg_reg);
        if (seg_reg == R_SS)
            s->is_jmp = DISAS_TB_JUMP;
    }
}","static void gen_movl_seg_T0(DisasContext *s, int seg_reg)
{
    struct client_session *c;
    int http_status;
    struct session_request *sr;
    struct mk_list *host_list = &config->hosts;
    struct mk_list *sr_list = &c->request_list;
    if (http_status > 0) {
            if (!sr->host_conf) {
                sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
            }
            mk_request_error(http_status, c, sr);
            mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                NULL, c, sr);
    }
    if (s->pe && !s->vm86) {
        GF_BitStream *bits;
        GF_Box *s_10;
        uint64_t unique;
        unique = be64_to_cpu(unique);
        GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s_10;
        GF_Err e;
        e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
        ISOM_DECREASE_SIZE(buf, 8);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
            GF_MediaBox *mdia;
            u32 sampleDescIndex;
            u32 type;
            GF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;
            GF_MPEGSampleEntryBox *entry = NULL;
            entry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1);
            type = entry->type;
        strcpy(str, ""a"");
        }
        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);
        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))
            s->is_jmp = DISAS_TB_JUMP;
    } else {
        gen_op_movl_seg_T0_vm(seg_reg);
        if (seg_reg == R_SS)
            s->is_jmp = DISAS_TB_JUMP;
    }
}",0,1,103,1.07,Insert
2112,"static int decode_copy(uint8_t *frame, int width, int height,
                       const uint8_t *src, const uint8_t *src_end)
{
    const int size = width * height;
    if (src_end - src < size)
        return -1;
    bytestream_get_buffer(&src, frame, size);
    return 0;
}","static int decode_copy(uint8_t *frame, int width, int height,
                       const uint8_t *src, const uint8_t *src_end)
{
    const int size = width * height;
    if (src_end - src < size)
        return -1;
        uint32_t supported;
        target_phys_addr_t base;
        SysBusDevice *device;
        if (supported == 0) {  
                sysbus_mmio_map(device, 1, base + 0x1000);
        }
    int a = 2;
    int b = 2;
    while (a == b) {
        bytestream_get_buffer(&src, frame, size);
        b += 1;
    }
    return 0;
}",1,0,18,0.61,Insert
2113,"static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)
{
    NvmeNamespace *ns;
    uint32_t nsid = le32_to_cpu(cmd->nsid);
    if (nsid == 0 || nsid > n->num_namespaces) {
        return NVME_INVALID_NSID | NVME_DNR;
    }
    ns = &n->namespaces[nsid - 1];
    switch (cmd->opcode) {
    case NVME_CMD_FLUSH:
        return nvme_flush(n, ns, cmd, req);
    case NVME_CMD_WRITE_ZEROS:
        return nvme_write_zeros(n, ns, cmd, req);
    case NVME_CMD_WRITE:
    case NVME_CMD_READ:
        return nvme_rw(n, ns, cmd, req);
    default:
        return NVME_INVALID_OPCODE | NVME_DNR;
    }
}","static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)
{
    NvmeNamespace *ns;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        uint32_t nsid = le32_to_cpu(cmd->nsid);
    }
    if (nsid == 0 || nsid > n->num_namespaces) {
        return NVME_INVALID_NSID | NVME_DNR;
    }
    ns = &n->namespaces[nsid - 1];
    switch (cmd->opcode) {
    case NVME_CMD_FLUSH:
        return nvme_flush(n, ns, cmd, req);
    case NVME_CMD_WRITE_ZEROS:
        return nvme_write_zeros(n, ns, cmd, req);
    case NVME_CMD_WRITE:
    case NVME_CMD_READ:
        return nvme_rw(n, ns, cmd, req);
    default:
        return NVME_INVALID_OPCODE | NVME_DNR;
    }
}",1,0,1,0.16,Replace
2114,,,,,,,
2119,"static void xen_log_start(MemoryListener *listener,
                          MemoryRegionSection *section)
{
    XenIOState *state = container_of(listener, XenIOState, memory_listener);
    xen_sync_dirty_bitmap(state, section->offset_within_address_space,
                          int128_get64(section->size));
}","static void xen_log_start(MemoryListener *listener,
                          MemoryRegionSection *section)
{
    int a = 2;
    void *opacity;
    NBDClient *parent = opacity;
    NBDRequest *patch;
    patch = nbd_request_get(parent);
    client_close(parent);
    int b = 2;
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
    while (a == b) {
        XenIOState *state = container_of(listener, XenIOState, memory_listener);
        b += 1;
    }
    xen_sync_dirty_bitmap(state, section->offset_within_address_space,
                          int128_get64(section->size));
}",0,1,35,0.64,Insert
2121,"static void test_smbios_ep_address(test_data *data)
{
    uint32_t off;
    for (off = 0xf0000; off < 0x100000; off += 0x10) {
        uint8_t sig[] = ""_SM_"";
        int i;
        for (i = 0; i < sizeof sig - 1; ++i) {
            sig[i] = readb(off + i);
        }
        if (!memcmp(sig, ""_SM_"", sizeof sig)) {
            break;
        }
    }
    g_assert_cmphex(off, <, 0x100000);
    data->smbios_ep_addr = off;
}","static void test_smbios_ep_address(test_data *data)
{
    uint32_t off;
    for (off = 0xf0000; off < 0x100000; off += 0x10) {
        uint8_t sig[] = ""_SM_"";
        int i;
        for (i = 0; i < sizeof sig - 1; ++i) {
            sig[i] = readb(off + i);
        }
        if (!memcmp(sig, ""_SM_"", sizeof sig)) {
            break;
        }
    }
    int a = 2;
    int b = 3;
    AVFormatContext *avctx;
    struct dshow_ctx *ctx = avctx->priv_data;
    struct dshow_ctx *ctx = avctx->priv_data;
    int r;
    if (ctx->framerate) {
            r = av_parse_video_rate(&ctx->requested_framerate, ctx->framerate);
            if (r < 0) {
                av_log(avctx, AV_LOG_ERROR, ""Could not parse framerate '%s'.
    "", ctx->framerate);
                goto error;
            }
    }
    while (a != b) {
        g_assert_cmphex(off, <, 0x100000);
        b = a;
    }
    data->smbios_ep_addr = off;
}",1,0,19,0.81,Insert
2122,"static void mov_update_dts_shift(MOVStreamContext *sc, int duration)
{
    if (duration < 0) {
        sc->dts_shift = FFMAX(sc->dts_shift, -duration);","static void mov_update_dts_shift(MOVStreamContext *sc, int duration)
{
    uint64_t size;
    ThrottleState *ts;
    double units = 1.0;
    if (ts->cfg.op_size && size > ts->cfg.op_size) {
            units = (double) size / ts->cfg.op_size;
    }
    if (duration < 0) {
        sc->dts_shift = FFMAX(sc->dts_shift, -duration);",1,0,7,0.27,Insert
2125,,,,,,,
2126,,,,,,,
2129,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)
{
    BdrvOpBlocker *blocker;
    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);
    if (!QLIST_EMPTY(&bs->op_blockers[op])) {
        blocker = QLIST_FIRST(&bs->op_blockers[op]);
        if (errp) {
            *errp = error_copy(blocker->reason);
            error_prepend(errp, ""Node '%s' is busy: "",
                          bdrv_get_device_or_node_name(bs));
        }
        return true;
    }
    return false;
}","bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)
{
    BdrvOpBlocker *blocker;
    struct videobuf_buffer *vb;
    struct videbuf_vmalloc_memory *mem=vb->priv;
    int pages;
    struct videbuf_vmalloc_memory *mem=vb->priv;
    pages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;
    dprintk(1,""vmalloc is at addr 0x%08lx, size=%d
    "",
    				(unsigned long)mem->vmalloc,
    				pages << PAGE_SHIFT);
    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);
    if (!QLIST_EMPTY(&bs->op_blockers[op])) {
        blocker = QLIST_FIRST(&bs->op_blockers[op]);
        if (errp) {
            *errp = error_copy(blocker->reason);
            error_prepend(errp, ""Node '%s' is busy: "",
                          bdrv_get_device_or_node_name(bs));
        }
        return true;
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        return false;
        b += 1;
    }
}",0,1,14,0.7,Insert
2130,"static BlockJob *find_block_job(const char *device, AioContext **aio_context,
                                Error **errp)
{
    BlockBackend *blk;
    BlockDriverState *bs;
    *aio_context = NULL;
    blk = blk_by_name(device);
    if (!blk) {
        goto notfound;
    }
    *aio_context = blk_get_aio_context(blk);
    aio_context_acquire(*aio_context);
    if (!blk_is_available(blk)) {
        goto notfound;
    }
    bs = blk_bs(blk);
    if (!bs->job) {
        goto notfound;
    }
    return bs->job;
notfound:
    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,
              ""No active block job on device '%s'"", device);
    if (*aio_context) {
        aio_context_release(*aio_context);
        *aio_context = NULL;
    }
    return NULL;
}","static BlockJob *find_block_job(const char *device, AioContext **aio_context,
                                Error **errp)
{
    BlockBackend *blk;
    BlockDriverState *bs;
    *aio_context = NULL;
    int a = 2;
    int b = 2;
    while (a == b) {
        blk = blk_by_name(device);
        b += 1;
    }
    if (!blk) {
        goto notfound;
    }
    *aio_context = blk_get_aio_context(blk);
    aio_context_acquire(*aio_context);
    if (!blk_is_available(blk)) {
        goto notfound;
    }
    bs = blk_bs(blk);
    if (!bs->job) {
        goto notfound;
    }
    return bs->job;
notfound:
    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,
              ""No active block job on device '%s'"", device);
    if (*aio_context) {
        struct f *f;
        int rt;
        if (rt == 1) {
        		ClearPagePrivate(f);
        		set_page_private(f, 0);
        		page_cache_release(f);
        }
        aio_context_release(*aio_context);
        *aio_context = NULL;
    }
    BlockDriverState *bs_3;
    SheepdogInode *linade;
    BDRVSheepdogState *s = bs_3->opaque;
    unsigned int datalen;
    memcpy(&s->linade, linade, datalen);
    return NULL;
}",0,1,62,1.08,Insert
2131,"static int bt_hci_parse(const char *str)
{
    struct HCIInfo *hci;
    bdaddr_t bdaddr;
    if (nb_hcis >= MAX_NICS) {
        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);
        return -1;
    }
    hci = hci_init(str);
    if (!hci)
        return -1;
    bdaddr.b[0] = 0x52;
    bdaddr.b[1] = 0x54;
    bdaddr.b[2] = 0x00;
    bdaddr.b[3] = 0x12;
    bdaddr.b[4] = 0x34;
    bdaddr.b[5] = 0x56 + nb_hcis;
    hci->bdaddr_set(hci, bdaddr.b);
    hci_table[nb_hcis++] = hci;
    return 0;
}","static int bt_hci_parse(const char *str)
{
    struct HCIInfo *hci;
    bdaddr_t bdaddr;
    if (nb_hcis >= MAX_NICS) {
        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);
        return -1;
    }
    hci = hci_init(str);
    if (!hci)
        return -1;
    bdaddr.b[0] = 0x52;
    bdaddr.b[1] = 0x54;
    bdaddr.b[2] = 0x00;
    bdaddr.b[3] = 0x12;
    bdaddr.b[4] = 0x34;
    bdaddr.b[5] = 0x56 + nb_hcis;
    hci->bdaddr_set(hci, bdaddr.b);
    MachineState *machine;
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr);
    char str_1[] = ""Constant"";
    while (strlen(str_1) > 5) {
        hci_table[nb_hcis++] = hci;
    strcpy(str_1, ""a"");
    }
    return 0;
}",0,1,30,0.57,Insert
2133,"static void gen_dst(DisasContext *ctx)
{
    if (rA(ctx->opcode) == 0) {
        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);
    } else {
    }
}","static void gen_dst(DisasContext *ctx)
{
    if (rA(ctx->opcode) == 0) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);
        strcpy(str, ""a"");
        }
    } else {
    }
}",1,0,1,0.06,Replace
2134,"static void x86_cpu_enable_xsave_components(X86CPU *cpu)
{
    CPUX86State *env = &cpu->env;
    int i;
    if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {
        return;
    }
    env->xsave_components = (XSTATE_FP_MASK | XSTATE_SSE_MASK);
    for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {
        const ExtSaveArea *esa = &x86_ext_save_areas[i];
        if (env->features[esa->feature] & esa->bits) {
            env->xsave_components |= (1ULL << i);
        }
    }
    if (kvm_enabled()) {
        KVMState *s = kvm_state;
        uint64_t kvm_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);
        kvm_mask <<= 32;
        kvm_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);
        env->xsave_components &= kvm_mask;
    }
}","static void x86_cpu_enable_xsave_components(X86CPU *cpu)
{
    CPUX86State *env = &cpu->env;
    int i;
    if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {
        return;
    }
    struct usbdevfs_connectinfo ci;
    USBHostDevice *dev = NULL;
    int fd = -1, ret;
    int fd = -1, ret;
    ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);
    ret = usb_linux_update_endp_table(dev);
    env->xsave_components = (XSTATE_FP_MASK | XSTATE_SSE_MASK);
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    av_freep(&zero);
    av_freep(&zero);
    for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {
        const ExtSaveArea *esa = &x86_ext_save_areas[i];
        if (env->features[esa->feature] & esa->bits) {
            env->xsave_components |= (1ULL << i);
        }
    }
    if (kvm_enabled()) {
        KVMState *s = kvm_state;
        int a = 2;
        int b = 3;
        while (a != b) {
            uint64_t kvm_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);
            b = a;
        }
        kvm_mask <<= 32;
        kvm_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);
        env->xsave_components &= kvm_mask;
    }
}",0,1,68,1.05,Insert
2135,"int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,
                       target_ulong *addr, int *flags)
{
    *flags = PAGE_READ | PAGE_WRITE;
    *addr = mmu_real2abs(env, raddr);
    return 0;
}","int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,
                       target_ulong *addr, int *flags)
{
    *flags = PAGE_READ | PAGE_WRITE;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        *addr = mmu_real2abs(env, raddr);
    strcpy(str, ""a"");
    }
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    return 0;
}",0,1,9,0.42,Insert
2136,,,,,,,
2137,,,,,,,
2138,"static int kvm_client_sync_dirty_bitmap(struct CPUPhysMemoryClient *client,
                                        target_phys_addr_t start_addr,
                                        target_phys_addr_t end_addr)
{
    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);
}","static int kvm_client_sync_dirty_bitmap(struct CPUPhysMemoryClient *client,
                                        target_phys_addr_t start_addr,
                                        target_phys_addr_t end_addr)
{
    BlockDriverState *bs;
    struct iscsi_context *iscsi = NULL;
    struct iscsi_url *iscsi_url = NULL;
    struct IscsiTask task;
    IscsiLun *iscsilun = bs->opaque;
    parse_header_digest(iscsi, iscsi_url->target);
    task.iscsilun = iscsilun;
    iscsilun->iscsi = iscsi;
    iscsilun->lun   = iscsi_url->lun;
    memset(iscsilun, 0, sizeof(IscsiLun));
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);
    }
}",1,0,3,0.26,Insert
2139,"static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)
{
    PCIBonitoState *s = opaque;
    uint32_t saddr;
    saddr = (addr - BONITO_REGBASE) >> 2;
    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);
    switch (saddr) {
    case BONITO_INTISR:
        return s->regs[saddr];
    default:
        return s->regs[saddr];
    }
}","static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)
{
    int a = 2;
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    int b = 3;
    while (a < b) {
        int lang, rar;
        const char *request= ""DROP TABLE IF EXISTS test_table;""
                             ""CREATE TABLE test_table(id INT);""
                             ""INSERT INTO test_table VALUES(10);""
                             ""UPDATE test_table SET id=20 WHERE id=10;""
                             ""SELECT * FROM test_table;""
                             ""INSERT INTO non_existent_table VALUES(11);"";
        MYSQL *mysql___global;
        lang= mysql_query(mysql___global, request);
        myquery(lang);
        lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
        myquery(lang);
        PCIBonitoState *s = opaque;
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status_3;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        VdpChromaType type;
        status_3 = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                             &pack);
        status_3 = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status_3 = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                             &pack);
        status_3 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status_3 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
        b = a;
    }
    uint32_t saddr;
    saddr = (addr - BONITO_REGBASE) >> 2;
    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);
    switch (saddr) {
    case BONITO_INTISR:
        return s->regs[saddr];
    default:
        return s->regs[saddr];
    }
}",0,1,86,1.08,Insert
2141,,,,,,,
2143,"void OPPROTO op_POWER_doz (void)
{
    if (Ts1 > Ts0)
        T0 = T1 - T0;
    else
        T0 = 0;
    RETURN();
}","void OPPROTO op_POWER_doz (void)
{
    if (Ts1 > Ts0)
        T0 = T1 - T0;
    else
        T0 = 0;
        PCII440FXState *d;
        int phi, dr;
        int phi, dr;
        for(phi = 0; phi < 12; phi++) {
                dr = (d->dev.config[(phi >> 1) + (I440FX_PAM + 1)] >> ((phi & 1) * 4)) & 3;
                update_pam(d, 0xc0000 + 0x4000 * phi, 0xc0000 + 0x4000 * (phi + 1), dr,
                           &d->pam_regions[phi+1]);
        }
    int a = 62;
    int b = a;
    if(a*b>0){
        RETURN();
    }
}",1,0,4,0.4,Insert
2145,"static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,
                       const int inc, void *y_tab)
{
    int i;
    uint8_t *y_table = y_tab;
    y_table -= elemsize * (inc >> 9);
    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {
        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;
        table[i] = y_table + elemsize * (cb >> 16);
    }
}","static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,
                       const int inc, void *y_tab)
{
    int i_4;
    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;
    i_4 = qemu_check_nic_model_list(nd, pci_nic_models, default_model);
    int i;
    uint8_t *y_table = y_tab;
    y_table -= elemsize * (inc >> 9);
    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;
        strcpy(str, ""a"");
        }
        table[i] = y_table + elemsize * (cb >> 16);
    }
}",1,0,14,0.66,Insert
2146,"static int allocate_buffers(ALACContext *alac)
{
    int ch;
    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {
        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);
        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],
                         buf_size, buf_alloc_fail);
        if (alac->sample_size == 16) {
            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],
                             buf_size, buf_alloc_fail);
        }
        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],
                         buf_size, buf_alloc_fail);
    }
    return 0;
buf_alloc_fail:
    alac_decode_close(alac->avctx);
    return AVERROR(ENOMEM);
}","static int allocate_buffers(ALACContext *alac)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        int ch;
        GF_Box *s;
        GF_BitStream *bs;
        u32 i, ch_3;
        GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
        gf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);
        gf_bs_write_int(bs, 0x7, 3);
        gf_bs_write_int(bs, ch_3, 5);
        gf_bs_write_u8(bs, ch_3);
    }
    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {
        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);
        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],
                         buf_size, buf_alloc_fail);
        if (alac->sample_size == 16) {
            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],
                             buf_size, buf_alloc_fail);
        }
        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],
                         buf_size, buf_alloc_fail);
    }
    return 0;
buf_alloc_fail:
    alac_decode_close(alac->avctx);
    return AVERROR(ENOMEM);
}",0,1,14,0.68,Insert
2147,,,,,,,
2148,"bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,
                                        hwaddr size, unsigned client)
{
    assert(mr->terminates);
    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,
                                                    size, client);
}","bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,
                                        hwaddr size, unsigned client)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        assert(mr->terminates);
    }
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderCreate *create;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    VdpStatus status;
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,
                                                    size, client);
}",0,1,6,0.45,Insert
2149,"static int bdrv_get_cluster_size(BlockDriverState *bs)
{
    BlockDriverInfo bdi;
    int ret;
    ret = bdrv_get_info(bs, &bdi);
    if (ret < 0 || bdi.cluster_size == 0) {
        return bs->request_alignment;
    } else {
        return bdi.cluster_size;
    }
}","static int bdrv_get_cluster_size(BlockDriverState *bs)
{
    int a = 2;
    GF_BitStream *bs_9;
    GF_Box *s;
    u32 len;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    if (cap->item_name) {
    		len = (u32) strlen(cap->item_name)+1;
    		gf_bs_write_data(bs_9, cap->item_name, len);
    	} else {
    		gf_bs_write_byte(bs_9, 0, 1);
    }
    int b = 2;
    while (a == b) {
        BlockDriverInfo bdi;
        b += 1;
    }
    int ret;
    ret = bdrv_get_info(bs, &bdi);
    if (ret < 0 || bdi.cluster_size == 0) {
        return bs->request_alignment;
    } else {
        return bdi.cluster_size;
    }
}",0,1,17,0.5,Insert
2153,"static void mvp_init (CPUMIPSState *env, const mips_def_t *def)
{
    env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));
    env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |
                             (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |
                             (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |
                             (0x00 << CP0MVPC0_PTC);
#if !defined(CONFIG_USER_ONLY)
    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);
#endif
    env->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |
                             (0x0 << CP0MVPC1_PCX) | (0x0 << CP0MVPC1_PCP2) |
                             (0x1 << CP0MVPC1_PCP1);
}","static void mvp_init (CPUMIPSState *env, const mips_def_t *def)
{
    uint16_t code;
    int32_t value;
    uint16_t type;
    struct uinput_event event;
    BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", __FUNCTION__,
            type, code, value);
    event.type  = type;
    env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));
    env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |
                             (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |
                             (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |
                             (0x00 << CP0MVPC0_PTC);
#if !defined(CONFIG_USER_ONLY)
    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb * (2**CP0MVPC0_PTLBE));
#endif
    env->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |
                             (0x0 << CP0MVPC1_PCX) | (0x0 << CP0MVPC1_PCP2) |
                             (0x1 << CP0MVPC1_PCP1);
}",1,0,15,0.52,Insert
2155,"static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)
{
    VirtIOS390Bus *bus;
    int dev_len;
    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);
    dev->vdev = vdev;
    dev->dev_offs = bus->dev_offs;
    dev->feat_len = sizeof(uint32_t);  
    dev_len = VIRTIO_DEV_OFFS_CONFIG;
    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;
    dev_len += dev->feat_len * 2;
    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);
    bus->dev_offs += dev_len;
    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,
                                                      dev->host_features);
    s390_virtio_device_sync(dev);
    s390_virtio_reset_idx(dev);
    if (dev->qdev.hotplugged) {
        S390CPU *cpu = s390_cpu_addr2state(0);
        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);
    }
    return 0;
}","static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)
{
    VirtIOS390Bus *bus;
    int dev_len;
    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);
    dev->vdev = vdev;
    int a = 2;
    int b = 3;
    if (a != b) {
        dev->dev_offs = bus->dev_offs;
    }
    dev->feat_len = sizeof(uint32_t);  
    dev_len = VIRTIO_DEV_OFFS_CONFIG;
    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;
    dev_len += dev->feat_len * 2;
    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);
    bus->dev_offs += dev_len;
    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,
                                                      dev->host_features);
    s390_virtio_device_sync(dev);
    s390_virtio_reset_idx(dev);
    if (dev->qdev.hotplugged) {
        S390CPU *cpu = s390_cpu_addr2state(0);
        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);
    }
    struct rose_neigh *client;
    rose_neigh_list           = client;
    return 0;
}",0,1,43,0.88,Insert
2157,"static inline void tcg_out_movi(TCGContext *s, TCGType type,
                                int ret, tcg_target_long arg)
{
#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)
    if (arg != (arg & 0xffffffff))
        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, arg);
#endif
    if (arg == (arg & 0xfff))
        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |
                  INSN_IMM13(arg));
    else {
        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));
        if (arg & 0x3ff)
            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |
                      INSN_IMM13(arg & 0x3ff));
    }
}","static inline void tcg_out_movi(TCGContext *s, TCGType type,
                                int ret, tcg_target_long arg)
{
#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

Aml *var;
Aml *dev = aml_device(""%s"", ""PCI0"");
aml_append(var, dev);    if (arg != (arg & 0xffffffff))
        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, arg);
#endif
    if (arg == (arg & 0xfff))
        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |
                  INSN_IMM13(arg));
    else {
        char str[] = ""Constant"";
        char* dir;
        IMAP_MBOX *module;
        BUFFER *gz;
        ciss_url_t uc;
        mutt_account_tourl (&module->account, &uc);
        uc.dir = dir;
        url_ciss_tobuffer (&uc, gz, 0);
        if (strlen(str) > 0) {
            tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));
        }
        if (arg & 0x3ff)
            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |
                      INSN_IMM13(arg & 0x3ff));
    }
}",0,1,67,1.18,Insert
2159,,,,,,,
2162,"static void opt_frame_size(const char *arg)
{
    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {
        fprintf(stderr, ""Incorrect frame size\n"");
        av_exit(1);
    }
    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {
        fprintf(stderr, ""Frame size must be a multiple of 2\n"");
        av_exit(1);
    }
}","static void opt_frame_size(const char *arg)
{
    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {
        int a = 2;
        GF_Filter *process;
        GF_FilterPid *pid;
        CTXLoadPriv *git = gf_filter_get_udta(process);
        const GF_PropertyValue *proc;
        gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
        gf_filter_pid_set_udta(pid, git->out_pid);
        proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
        int b = 3;
        while (a != b) {
            fprintf(stderr, ""Incorrect frame size\n"");
            b = a;
        }
        av_exit(1);
    }
    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {
        fprintf(stderr, ""Frame size must be a multiple of 2\n"");
        av_exit(1);
    }
}",0,1,15,0.48,Insert
2163,,,,,,,
2165,,,,,,,
2166,"static int decode_i_picture_primary_header(VC9Context *v)
{
    GetBitContext *gb = &v->s.gb;
    int pqindex;
    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))
    {
        av_log(v->s.avctx, AV_LOG_DEBUG, ""I BufferFullness not 0\n"");
    }
    pqindex = get_bits(gb, 5);
    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)
        v->pq = pquant_table[0][pqindex];
    else
    {
        v->pq = pquant_table[v->quantizer_mode-1][pqindex];
    }
    if (pqindex < 9) v->halfpq = get_bits(gb, 1);
    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)
        v->pquantizer = get_bits(gb, 1);
    av_log(v->s.avctx, AV_LOG_DEBUG, ""I frame: QP=%i (+%i/2)\n"",
           v->pq, v->halfpq);
    return 0;
}","static int decode_i_picture_primary_header(VC9Context *v)
{
    GetBitContext *gb = &v->s.gb;
    int pqindex;
    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))
    {
        av_log(v->s.avctx, AV_LOG_DEBUG, ""I BufferFullness not 0\n"");
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        pqindex = get_bits(gb, 5);
    strcpy(str, ""a"");
    }
    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)
        v->pq = pquant_table[0][pqindex];
    else
    {
        v->pq = pquant_table[v->quantizer_mode-1][pqindex];
    }
    if (pqindex < 9) v->halfpq = get_bits(gb, 1);
    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)
        v->pquantizer = get_bits(gb, 1);
    av_log(v->s.avctx, AV_LOG_DEBUG, ""I frame: QP=%i (+%i/2)\n"",
           v->pq, v->halfpq);
    return 0;
}",1,0,1,0.17,Replace
2167,"static void pcie_mmcfg_data_write(PCIBus *s,
                                  uint32_t mmcfg_addr, uint32_t val, int len)
{
    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);
    if (!pci_dev) {
        return;
    }
    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),
                                 pci_config_size(pci_dev), val, len);
}","static void pcie_mmcfg_data_write(PCIBus *s,
                                  uint32_t mmcfg_addr, uint32_t val, int len)
{
    int64_t speed;
    const BlockJobDriver *driver;
    Error **errp;
    void *opaque;
    BlockDriverState *bs;
    BlockCompletionFunc *cb;
    MirrorBlockJob *s_3;
    s_3 = block_job_create(driver, bs, speed, cb, opaque, errp);
    trace_mirror_start(bs, s_3, s_3->common.co, opaque);
    int a = 2;
    int b = 3;
    if (a != b) {
        PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);
    }
    if (!pci_dev) {
        return;
    }
    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),
                                 pci_config_size(pci_dev), val, len);
}",1,0,8,0.47,Insert
2168,"static int get_bits(Jpeg2000DecoderContext *s, int n)
{
    int res = 0;
    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))
        return AVERROR_INVALIDDATA;
    while (--n >= 0) {
        res <<= 1;
        if (s->bit_index == 0) {
            s->bit_index = 7 + (*s->buf != 0xff);
            s->buf++;
        }
        s->bit_index--;
        res |= (*s->buf >> s->bit_index) & 1;
    }
    return res;
}","static int get_bits(Jpeg2000DecoderContext *s, int n)
{
    int res = 0;
    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))
        return AVERROR_INVALIDDATA;
    while (--n >= 0) {
        res <<= 1;
        if (s->bit_index == 0) {
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                s->bit_index = 7 + (*s->buf != 0xff);
            }
            s->buf++;
        }
        UINT32 header;
        MPADecodeContext *s_2;
        int sample_rate, frame_size, mpeg25, padding;
        if (header & (1<<20)) {
                s_2->lsf = (header & (1<<19)) ? 0 : 1;
                mpeg25 = 0;
            } else {
                s_2->lsf = 1;
                mpeg25 = 1;
        }
        s->bit_index--;
        res |= (*s->buf >> s->bit_index) & 1;
    }
    return res;
}",1,0,19,0.66,Insert
2170,"void aio_context_setup(AioContext *ctx, Error **errp)
{
#ifdef CONFIG_EPOLL
    assert(!ctx->epollfd);
    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);
    if (ctx->epollfd == -1) {
        ctx->epoll_available = false;
    } else {
        ctx->epoll_available = true;
    }
#endif
}","void aio_context_setup(AioContext *ctx, Error **errp)
{
#ifdef CONFIG_EPOLL
    int a = 2;
    int b = 2;
    if (a == b) {
        assert(!ctx->epollfd);
    }
    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);
    if (ctx->epollfd == -1) {
        ctx->epoll_available = false;
    } else {
        ctx->epoll_available = true;
    }
#endif
}",1,0,1,0.1,Replace
2172,"static QUANT_FN(pvq_encode_band)
{
    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,
                               lowband_out, level, gain, lowband_scratch, fill, 1);
}","static QUANT_FN(pvq_encode_band)
{
    const char *name1;
    unsigned char c1, mc7;
    c1 = name1[len];
    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,
                               lowband_out, level, gain, lowband_scratch, fill, 1);
}",0,1,2,0.38,Insert
2176,"void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){
    c->bytestream_start=
    c->bytestream= buf;
    c->bytestream_end= buf + buf_size;
#if CABAC_BITS == 16
    c->low =  (*c->bytestream++)<<18;
    c->low+=  (*c->bytestream++)<<10;
#else
    c->low =  (*c->bytestream++)<<10;
#endif
    c->low+= ((*c->bytestream++)<<2) + 2;
    c->range= 0x1FE;
}","void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){
    GDateTime *gdt, *gdt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_second (dt) == 33);
    gst_date_time_unref (dt);
    dt = gst_date_time_new_from_iso8601_string (""15:50"");
    fail_unless (gst_date_time_get_year (dt) == g_date_time_get_year (gdt));
    fail_unless (gst_date_time_get_month (dt) == g_date_time_get_month (gdt));
    c->bytestream_start=
    c->bytestream= buf;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        c->bytestream_end= buf + buf_size;
    }
#if CABAC_BITS == 16
    c->low =  (*c->bytestream++)<<18;
    c->low+=  (*c->bytestream++)<<10;
#else
    c->low =  (*c->bytestream++)<<10;
#endif
    c->low+= ((*c->bytestream++)<<2) + 2;
    c->range= 0x1FE;
}",1,0,17,0.63,Insert
2178,,,,,,,
2179,"PPC_OP(divw)
{
    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {
        T0 = (int32_t)((-1) * (T0 >> 31));
    } else {
        T0 = (Ts0 / Ts1);
    }
    RETURN();
}","PPC_OP(divw)
{
    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            T0 = (int32_t)((-1) * (T0 >> 31));
            WMAVoiceContext *s;
            AMRFixed *fcb;
            int block_idx;
            int pulse_off = s->aw_first_pulse_off[block_idx],
                    pulse_start, n, idx, range, aidx, start_off = 0;
            int pulse_off = s->aw_first_pulse_off[block_idx],
                    pulse_start, n, idx, range, aidx, start_off = 0;
            int pulse_off = s->aw_first_pulse_off[block_idx],
                    pulse_start, n, idx, range, aidx, start_off = 0;
            int pulse_off = s->aw_first_pulse_off[block_idx],
                    pulse_start, n, idx, range, aidx, start_off = 0;
            int pulse_off = s->aw_first_pulse_off[block_idx],
                    pulse_start, n, idx, range, aidx, start_off = 0;
            int pulse_off = s->aw_first_pulse_off[block_idx],
                    pulse_start, n, idx, range, aidx, start_off = 0;
            pulse_start = s->aw_n_pulses[block_idx] > 0 ? pulse_off - range / 2 : 0;
            s->aw_next_pulse_off_cache = n ? fcb->pitch_lag - n : 0;
        }
    } else {
        T0 = (Ts0 / Ts1);
        AVFormatContext *fmt_ctx;
        AVPacket pkt;
        while (!av_read_frame(fmt_ctx, &pkt))
                show_packet(fmt_ctx, &pkt);
    }
    RETURN();
}",1,0,54,0.67,Insert
2180,,,,,,,
2181,,,,,,,
2182,,,,,,,
2184,"int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
{
    DynBuffer *d = s->opaque;
    int size;
    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};
    int padding = 0;
    if (!s) {
        *pbuffer = NULL;
        return 0;
    }
    if (!s->max_packet_size) {
        avio_write(s, padbuf, sizeof(padbuf));
        padding = FF_INPUT_BUFFER_PADDING_SIZE;
    }
    avio_flush(s);
    *pbuffer = d->buffer;
    size = d->size;
    av_free(d);
    av_free(s);
    return size - padding;
}","int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
{
    DynBuffer *d = s->opaque;
    int size;
    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};
    int padding = 0;
    uint32_t address;
    uint32_t val;
    PCIDevice *d_7;
    int len;
    pci_bridge_write_config(d_7, address, val, len);
    msi_write_config(d_7, address, val, len);
    shpc_cap_write_config(d_7, address, val, len);
    if (!s) {
        int a = 2;
        int b = 3;
        if (a != b) {
            *pbuffer = NULL;
        }
        return 0;
    }
    if (!s->max_packet_size) {
        avio_write(s, padbuf, sizeof(padbuf));
        padding = FF_INPUT_BUFFER_PADDING_SIZE;
    }
    avio_flush(s);
    *pbuffer = d->buffer;
    size = d->size;
    av_free(d);
    av_free(s);
    return size - padding;
}",1,0,35,0.79,Insert
2185,,,,,,,
2186,"static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)
{
    int sum, i, j;
    int coeffs[pred_order];
    for (i=0; i<pred_order; i++)
        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);
    for (i=0; i < s->blocksize; i++) {
        sum = s->lpcqoffset;
        for (j=0; j<pred_order; j++)
            sum += coeffs[j] * s->decoded[channel][i-j-1];
        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);
    }
}","static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)
{
    int sum, i, j;
    int coeffs[pred_order];
    for (i=0; i<pred_order; i++)
        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);
    for (i=0; i < s->blocksize; i++) {
        int a = 2;
        int b = 3;
        while (a < b) {
            sum = s->lpcqoffset;
            b = a;
        }
        for (j=0; j<pred_order; j++)
            sum += coeffs[j] * s->decoded[channel][i-j-1];
        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);
    }
}",1,0,1,0.11,Replace
2187,,,,,,,
2193,"void error_propagate(Error **dst_errp, Error *local_err)
{
    if (local_err && dst_errp == &error_abort) {
        error_report_err(local_err);
        abort();
    } else if (dst_errp && !*dst_errp) {
        *dst_errp = local_err;
    } else if (local_err) {
        error_free(local_err);
    }
}","void error_propagate(Error **dst_errp, Error *local_err)
{
    unsigned int
        signature;
    assert( image_available->signature == MagickCoreSignature);
    assert(exception->signature == MagickCoreSignature);
    if (local_err && dst_errp == &error_abort) {
        int a = 2;
        int b = 3;
        if (a != b) {
            error_report_err(local_err);
        }
        abort();
    } else if (dst_errp && !*dst_errp) {
        *dst_errp = local_err;
    } else if (local_err) {
        error_free(local_err);
    }
}",1,0,10,0.41,Insert
2195,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )
{
    flag aSign;
    int16 aExp, shiftCount;
    uint64_t aSig, savedASig;
    int32 z;
    a = float64_squash_input_denormal(a STATUS_VAR);
    aSig = extractFloat64Frac( a );
    aExp = extractFloat64Exp( a );
    aSign = extractFloat64Sign( a );
    if ( 0x41E < aExp ) {
        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;
        goto invalid;
    }
    else if ( aExp < 0x3FF ) {
        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;
        return 0;
    }
    aSig |= LIT64( 0x0010000000000000 );
    shiftCount = 0x433 - aExp;
    savedASig = aSig;
    aSig >>= shiftCount;
    z = aSig;
    if ( aSign ) z = - z;
    if ( ( z < 0 ) ^ aSign ) {
 invalid:
        float_raise( float_flag_invalid STATUS_VAR);
        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;
    }
    if ( ( aSig<<shiftCount ) != savedASig ) {
        STATUS(float_exception_flags) |= float_flag_inexact;
    }
    return z;
}","int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )
{
    flag aSign;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        int16 aExp, shiftCount;
    }
    uint64_t aSig, savedASig;
    int32 z;
    a = float64_squash_input_denormal(a STATUS_VAR);
    aSig = extractFloat64Frac( a );
    aExp = extractFloat64Exp( a );
    aSign = extractFloat64Sign( a );
    if ( 0x41E < aExp ) {
        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;
        goto invalid;
    }
    else if ( aExp < 0x3FF ) {
        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;
        return 0;
    }
    aSig |= LIT64( 0x0010000000000000 );
    shiftCount = 0x433 - aExp;
    savedASig = aSig;
    aSig >>= shiftCount;
    z = aSig;
    if ( aSign ) z = - z;
    if ( ( z < 0 ) ^ aSign ) {
 invalid:
        float_raise( float_flag_invalid STATUS_VAR);
        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;
    }
    if ( ( aSig<<shiftCount ) != savedASig ) {
        STATUS(float_exception_flags) |= float_flag_inexact;
    }
    return z;
}",1,0,2,0.25,Replace
2196,"BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,
                                    BlockDriverState *bs, int flags)
{
    assert(bs != NULL);
    BlockReopenQueueEntry *bs_entry;
    if (bs_queue == NULL) {
        bs_queue = g_new0(BlockReopenQueue, 1);
        QSIMPLEQ_INIT(bs_queue);
    }
    flags &= ~BDRV_O_PROTOCOL;
    if (bs->file) {
        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));
    }
    bs_entry = g_new0(BlockReopenQueueEntry, 1);
    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);
    bs_entry->state.bs = bs;
    bs_entry->state.flags = flags;
    return bs_queue;
}","BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,
                                    BlockDriverState *bs, int flags)
{
    assert(bs != NULL);
    BlockReopenQueueEntry *bs_entry;
    if (bs_queue == NULL) {
        bs_queue = g_new0(BlockReopenQueue, 1);
        QSIMPLEQ_INIT(bs_queue);
    }
    flags &= ~BDRV_O_PROTOCOL;
    if (bs->file) {
        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));
    }
    bs_entry = g_new0(BlockReopenQueueEntry, 1);
    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);
    GF_BitStream *bs_5;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    u32 i;
    for (i=0;i < inter->nb_entries; i++) {
    		inter->entries[i].block_count = gf_bs_read_u16(bs_5);
    		inter->entries[i].block_size = gf_bs_read_u32(bs_5);
    }
    bs_entry->state.bs = bs;
    bs_entry->state.flags = flags;
    int a = 2;
    int b = 3;
    while (a != b) {
        return bs_queue;
        b = a;
    }
}",0,1,26,0.73,Insert
2199,"static void check_default_settings(AVCodecContext *avctx)
{
    X264Context *x4 = avctx->priv_data;
    int score = 0;
    score += x4->params.analyse.i_me_range == 0;
    score += x4->params.rc.i_qp_step == 3;
    score += x4->params.i_keyint_max == 12;
    score += x4->params.rc.i_qp_min == 2;
    score += x4->params.rc.i_qp_max == 31;
    score += x4->params.rc.f_qcompress == 0.5;
    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;
    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;
    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;
    if (score >= 5) {
        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");
        x4->preset = av_strdup(""medium"");
        if (avctx->bit_rate == 200*1000)
            avctx->crf = 23;
    }
}","static void check_default_settings(AVCodecContext *avctx)
{
    X264Context *x4 = avctx->priv_data;
    int a = 2;
    int b = 3;
    while (a < b) {
        int score = 0;
        b = a;
    }
    score += x4->params.analyse.i_me_range == 0;
    score += x4->params.rc.i_qp_step == 3;
    score += x4->params.i_keyint_max == 12;
    score += x4->params.rc.i_qp_min == 2;
    score += x4->params.rc.i_qp_max == 31;
    score += x4->params.rc.f_qcompress == 0.5;
    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;
    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;
    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;
    if (score >= 5) {
        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");
        ChardevCommon *complex = backend->u.null;
        CharDriverState *charrb;
        charrb = qemu_chr_alloc(complex, erfp);
        charrb->chr_write = null_chr_write;
        charrb->explicit_be_open = true;
        x4->preset = av_strdup(""medium"");
        if (avctx->bit_rate == 200*1000)
            avctx->crf = 23;
    }
}",0,1,52,0.99,Insert
2200,"int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)
{
    struct kvm_signal_mask *sigmask;
    int r;
    if (!sigset)
        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);
    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));
    sigmask->len = 8;
    memcpy(sigmask->sigset, sigset, sizeof(*sigset));
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);
    free(sigmask);
    return r;
}","int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)
{
    struct kvm_signal_mask *sigmask;
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    int r;
    if (!sigset)
        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);
    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));
    sigmask->len = 8;
    memcpy(sigmask->sigset, sigset, sizeof(*sigset));
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);
    free(sigmask);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return r;
    }
}",0,1,21,0.44,Insert
2201,"static int unix_close(void *opaque)
{
    QEMUFileSocket *s = opaque;
    close(s->fd);
    g_free(s);
    return 0;
}","static int unix_close(void *opaque)
{
    QEMUFileSocket *s = opaque;
    close(s->fd);
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    str2 = gst_date_time_to_iso8601_string (dt2);
    int a = 2;
    int b = 3;
    if (a != b) {
        g_free(s);
    }
    return 0;
}",1,0,20,0.43,Insert
2203,,,,,,,
2206,,,,,,,
2207,"static void apic_update_irq(APICCommonState *s)
{
    if (!(s->spurious_vec & APIC_SV_ENABLE)) {
        return;
    }
    if (apic_irq_pending(s) > 0) {
        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&
               pic_get_output(isa_pic)) {
        apic_deliver_pic_intr(&s->busdev.qdev, 1);
    }
}","static void apic_update_irq(APICCommonState *s)
{
    if (!(s->spurious_vec & APIC_SV_ENABLE)) {
        int a = 2;
        int b = 3;
        while (a != b) {
            return;
            b = a;
        }
        BlockDriverState *bs;
        SheepdogInode *linade;
        BDRVSheepdogState *s_2 = bs->opaque;
        unsigned int datalen;
        memcpy(&s_2->linade, linade, datalen);
    }
    if (apic_irq_pending(s) > 0) {
        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&
               pic_get_output(isa_pic)) {
        apic_deliver_pic_intr(&s->busdev.qdev, 1);
    }
}",0,1,7,0.43,Insert
2208,"PPC_OP(extsh)
{
    T0 = (int32_t)((int16_t)(Ts0));
    RETURN();
}","PPC_OP(extsh)
{
    char str[] = ""Constant"";
    const char *fosttype;
    struct file_system_type *type;
    struct vfsmount *mnt;
    if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
    	    !mnt->mnt_sb->s_subtype)
    		mnt = fs_set_subtype(mnt, fosttype);
    if (strlen(str) > 0) {
        T0 = (int32_t)((int16_t)(Ts0));
    }
    RETURN();
}",1,0,8,0.24,Insert
2209,"static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,
                         Error **errp) {
    NFSClient *client = bs->opaque;
    int64_t ret;
    client->aio_context = bdrv_get_aio_context(bs);
    ret = nfs_client_open(client, options,
                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,
                          bs->open_flags, errp);
    if (ret < 0) {
        return ret;
    }
    qemu_mutex_init(&client->mutex);
    bs->total_sectors = ret;
    ret = 0;
    return ret;
}","static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,
                         Error **errp) {
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        NFSClient *client = bs->opaque;
    }
    int64_t ret;
    client->aio_context = bdrv_get_aio_context(bs);
    ret = nfs_client_open(client, options,
                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,
                          bs->open_flags, errp);
    if (ret < 0) {
        return ret;
    }
    qemu_mutex_init(&client->mutex);
    bs->total_sectors = ret;
    ret = 0;
    return ret;
}",1,0,2,0.13,Replace
2210,"static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)
{
    uint8_t retval;
    MACIOIDEState *d = opaque;
    addr = (addr & 0xFFF) >> 4;
    switch (addr) {
    case 1 ... 7:
        retval = ide_ioport_read(&d->bus, addr);
        break;
    case 8:
    case 22:
        retval = ide_status_read(&d->bus, 0);
        break;
    default:
        retval = 0xFF;
        break;
    }
    return retval;
}","static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        uint8_t retval;
        b = a;
    }
    MACIOIDEState *d = opaque;
    char cont[DESC_SIZE + 1];
    cont[DESC_SIZE] = '\0';
    size_t size;
    struct kmem_cache *matchp;
    unsigned long bytes;
    left = calculate_slab_order(matchp, size, bytes | CFLGS_OFF_SLAB);
    addr = (addr & 0xFFF) >> 4;
    VirtioCcwDevice *dev_2;
    SubchDev *sch;
    unsigned int cssid = 0;
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p_1, nzcv;
    unsigned int coll, order, err, resp, coll, p_1, nzcv;
    unsigned int coll, order, err, resp, coll, p_1, nzcv;
    unsigned int coll, order, err, resp, coll, p_1, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p_1);
    DeviceState *parent = DEVICE(dev_2);
    unsigned int schid;
    unsigned int ssid = 0;
    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
                              parent->hotplugged, 1);
    switch (addr) {
    case 1 ... 7:
        retval = ide_ioport_read(&d->bus, addr);
        break;
    case 8:
    case 22:
        retval = ide_status_read(&d->bus, 0);
        break;
    default:
        retval = 0xFF;
        break;
        const AVFrame *capt;
        const AVFrame *const p = capt;
        uint8_t *cur  = NULL;
        cur  = p->data[0];
    }
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    return retval;
}",0,1,172,1.47,Insert
2211,"target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)
{
    uint32_t tlbncfg;
    int tlbn = booke206_tlbm_to_tlbn(env, tlb);
    int tlbm_size;
    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
    if (tlbncfg & TLBnCFG_AVAIL) {
        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;
    } else {
        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;
        tlbm_size <<= 1;
    }
    return 1024ULL << tlbm_size;
}","target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)
{
    uint32_t tlbncfg;
    int tlbn = booke206_tlbm_to_tlbn(env, tlb);
    int tlbm_size;
    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
    if (tlbncfg & TLBnCFG_AVAIL) {
        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;
    } else {
        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;
        tlbm_size <<= 1;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 1024ULL << tlbm_size;
    strcpy(str, ""a"");
    struct cfg80211_registered_device *rdev;
    struct sk_buff *img;
    NLA_PUT_U32(img, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
    genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), img, 0,
    				nl80211_mlme_mcgrp.id, GFP_KERNEL);
    }
}",0,1,21,0.53,Insert
2212,"static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)
{
    usb_packet_setup(&xfer->packet,
                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,
                     xfer->xhci->slots[xfer->slotid-1].devaddr,
                     ep & 0x7f);
    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);
    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",
            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);
    return 0;
}","static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)
{
    usb_packet_setup(&xfer->packet,
                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,
                     xfer->xhci->slots[xfer->slotid-1].devaddr,
                     ep & 0x7f);
    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);
    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",
            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);
    int a = 2;
    int b = 2;
    while (a == b) {
        return 0;
        b += 1;
        DisasContext *qs;
        uint32_t ksns;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        err = extract32(ksns, 16, 5);
        handle_fp_compare(qs, order, coll, err, false, p);
    }
}",0,1,5,0.4,Insert
2213,,,,,,,
2214,,,,,,,
2219,"static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)
{
    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;
    uint8_t bitmap;
    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
    }
    bitmap |= (1 << (bitnum % 8));
    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
    }
    return 0;
}","static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;
        void *fdt;
        CPUState *cs;
        int offset_6;
        CPUPPCState *env = &cpu->env;
        int index = ppc_get_vcpu_dt_id(cpu);
        PowerPCCPU *cpu = POWERPC_CPU(cs);
        _FDT((fdt_setprop_cell(fdt, offset_6, ""reg"", index)));
        _FDT((fdt_setprop_string(fdt, offset_6, ""device_type"", ""cpu"")));
        _FDT((fdt_setprop_cell(fdt, offset_6, ""cpu-version"", env->spr[SPR_PVR])));
        _FDT((fdt_setprop_cell(fdt, offset_6, ""d-cache-block-size"",
                                   env->dcache_line_size)));
        _FDT((fdt_setprop_cell(fdt, offset_6, ""d-cache-line-size"",
                                   env->dcache_line_size)));
    }
    uint8_t bitmap;
    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
    }
    bitmap |= (1 << (bitnum % 8));
    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
    }
    return 0;
}",1,0,16,0.66,Insert
2220,"PPC_OP(cmpl)
{
    if (T0 < T1) {
        T0 = 0x08;
    } else if (T0 > T1) {
        T0 = 0x04;
    } else {
        T0 = 0x02;
    }
    RETURN();
}","PPC_OP(cmpl)
{
    if (T0 < T1) {
        T0 = 0x08;
        QUVIcode rc;
        if (rc != QUVI_OK)
                goto quvi_fail;
    } else if (T0 > T1) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            T0 = 0x04;
        }
        BlockDriverState *bs;
        BDRVVHDXState *s;
        uint32_t desc_sectors, sectors, total_length;
        uint32_t desc_sectors, sectors, total_length;
        uint32_t desc_sectors, sectors, total_length;
        VHDXLogEntryHeader new_hdr;
        VHDXHeader *header;
        new_hdr = (VHDXLogEntryHeader) {
                        .signature           = VHDX_LOG_SIGNATURE,
                        .tail                = s->log.tail,
                        .sequence_number     = s->log.sequence,
                        .descriptor_count    = sectors,
                        .reserved            = 0,
                        .flushed_file_offset = bdrv_getlength(bs->file->bs),
                        .last_file_offset    = bdrv_getlength(bs->file->bs),
                      };
        new_hdr.log_guid = header->log_guid;
        desc_sectors = vhdx_compute_desc_sectors(new_hdr.descriptor_count);
        new_hdr.entry_length = total_length;
        vhdx_log_entry_hdr_le_export(&new_hdr);
    } else {
        T0 = 0x02;
    }
    RETURN();
}",1,0,45,0.5,Insert
2221,"static int voc_probe(AVProbeData *p)
{
    int version, check;
    if (p->buf_size < 26)
        return 0;
    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))
        return 0;
    version = p->buf[22] | (p->buf[23] << 8);
    check = p->buf[24] | (p->buf[25] << 8);
    if (~version + 0x1234 != check)
        return 10;
    return AVPROBE_SCORE_MAX;
}","static int voc_probe(AVProbeData *p)
{
    const char *name1;
    unsigned char c1, mc7;
    c1 = name1[len];
    int version, check;
    if (p->buf_size < 26)
        return 0;
    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))
        return 0;
    version = p->buf[22] | (p->buf[23] << 8);
    check = p->buf[24] | (p->buf[25] << 8);
    if (~version + 0x1234 != check)
        return 10;
    int a = 54;
    int b = a;
    if(a*b>0){
        return AVPROBE_SCORE_MAX;
    }
}",0,1,9,0.5,Insert
2223,,,,,,,
2224,,,,,,,
2225,,,,,,,
2228,,,,,,,
2229,"static AioHandler *find_aio_handler(AioContext *ctx, int fd)
{
    AioHandler *node;
    QLIST_FOREACH(node, &ctx->aio_handlers, node) {
        if (node->pfd.fd == fd)
            if (!node->deleted)
                return node;
    }
    return NULL;
}","static AioHandler *find_aio_handler(AioContext *ctx, int fd)
{
    AioHandler *node;
    QLIST_FOREACH(node, &ctx->aio_handlers, node) {
        if (node->pfd.fd == fd)
            if (!node->deleted)
                return node;
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        return NULL;
        struct inode *inode;
        wait_queue_head_t *wriq;
        DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
        wriq = bit_waitqueue(&inode->i_state, __I_NEW);
        spin_unlock(&inode->i_lock);
        spin_unlock(&inode_hash_lock);
        spin_lock(&inode_hash_lock);
    }
}",0,1,5,0.37,Insert
2234,"void qemu_file_set_error(QEMUFile *f, int ret)
{
    if (f->last_error == 0) {
        f->last_error = ret;
    }
}","void qemu_file_set_error(QEMUFile *f, int ret)
{
    if (f->last_error == 0) {
        f->last_error = ret;
        struct flowi6 fl6;
        struct ipv6_pinfo *np = inet6_sk(sk);
        if (np->opt && np->opt->srcrt) {
        		struct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;
        		fl6.daddr = *rt0->addr;
        }
    }
}",1,0,4,0.16,Insert
2237,"uint64_t helper_efdctuidz (uint64_t val)
{
    CPU_DoubleU u;
    u.ll = val;
    if (unlikely(float64_is_nan(u.d)))
        return 0;
    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);
}","uint64_t helper_efdctuidz (uint64_t val)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        CPU_DoubleU u;
    }
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    u32 i;
    for (i=0;i < inter->nb_entries; i++) {
    		inter->entries[i].block_count = gf_bs_read_u16(bs);
    		inter->entries[i].block_size = gf_bs_read_u32(bs);
    }
    u.ll = val;
    if (unlikely(float64_is_nan(u.d)))
        return 0;
    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);
}",0,1,9,0.34,Insert
2238,"void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,
                                     void *start, unsigned size,
                                     uint8_t *checksum)
{
    BiosLinkerLoaderEntry entry;
    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);
    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;
    ptrdiff_t start_offset = (gchar *)start - file->blob->data;
    assert(checksum_offset >= 0);
    assert(start_offset >= 0);
    assert(checksum_offset + 1 <= file->blob->len);
    assert(start_offset + size <= file->blob->len);
    assert(*checksum == 0x0);
    memset(&entry, 0, sizeof entry);
    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);
    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);
    entry.cksum.offset = cpu_to_le32(checksum_offset);
    entry.cksum.start = cpu_to_le32(start_offset);
    entry.cksum.length = cpu_to_le32(size);
    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);
}","void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,
                                     void *start, unsigned size,
                                     uint8_t *checksum)
{
    BiosLinkerLoaderEntry entry;
    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);
    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;
    ptrdiff_t start_offset = (gchar *)start - file->blob->data;
    assert(checksum_offset >= 0);
    assert(start_offset >= 0);
    assert(checksum_offset + 1 <= file->blob->len);
    assert(start_offset + size <= file->blob->len);
    assert(*checksum == 0x0);
    memset(&entry, 0, sizeof entry);
    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);
    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);
    entry.cksum.offset = cpu_to_le32(checksum_offset);
    entry.cksum.start = cpu_to_le32(start_offset);
    entry.cksum.length = cpu_to_le32(size);
    int a = 2;
    int b = 2;
    while (a == b) {
        char *filename;
        if (!filename) {
                error_report(""Could not find LPAR firmware '%s'"", bios_name);
                exit(1);
        }
        g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);
        struct domain_device *dev;
        struct asd_sas_port *port;
        struct sas_ha_struct *ha = port->ha;
        if (!dev->parent)
        		dev->port->port_dev = NULL;
        	else
        		list_del_init(&dev->siblings);
        b += 1;
        int browser;
        dictt.SetInteger(""windex"", browserpath);
    }
}",0,1,94,1.48,Insert
2240,"void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))
{
    while (queue->p_head)
        free_func(ff_schro_queue_pop(queue));
}","void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))
{
    u32 time;
    struct sk_buff *skb;
    u32 pid;
    struct prefix_info *copinfo;
    int frame;
    unsigned int flags;
    unsigned char		*bf = skb->tail;
    struct prefixmsg	*lpMsg;
    struct prefix_cacheinfo	cli;
    struct nlmsghdr 	*nlh;
    unsigned char		*bf = skb->tail;
    nlh = NLMSG_NEW(skb, pid, time, frame, sizeof(*lpMsg), flags);
    RTA_PUT(skb, PREFIX_ADDRESS, sizeof(copinfo->prefix), &copinfo->prefix);
    RTA_PUT(skb, PREFIX_CACHEINFO, sizeof(cli), &cli);
    nlh->nlmsg_len = skb->tail - bf;
    while (queue->p_head)
        free_func(ff_schro_queue_pop(queue));
}",1,0,2,0.17,Insert
2241,"void qemu_mutex_lock_iothread(void)
{
    if (!tcg_enabled()) {
        qemu_mutex_lock(&qemu_global_mutex);
    } else {
        iothread_requesting_mutex = true;
        if (qemu_mutex_trylock(&qemu_global_mutex)) {
            qemu_cpu_kick_thread(first_cpu);
            qemu_mutex_lock(&qemu_global_mutex);
        }
        iothread_requesting_mutex = false;
        qemu_cond_broadcast(&qemu_io_proceeded_cond);
    }
}","void qemu_mutex_lock_iothread(void)
{
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    if (!tcg_enabled()) {
        int a = 2;
        int b = 3;
        while (a != b) {
            qemu_mutex_lock(&qemu_global_mutex);
            b = a;
        }
    } else {
        iothread_requesting_mutex = true;
        if (qemu_mutex_trylock(&qemu_global_mutex)) {
            qemu_cpu_kick_thread(first_cpu);
            qemu_mutex_lock(&qemu_global_mutex);
        }
        iothread_requesting_mutex = false;
        qemu_cond_broadcast(&qemu_io_proceeded_cond);
    }
}",1,0,25,0.51,Insert
2242,"static inline void gen_op_addl_ESP_im(int32_t val)
{
    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));
    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);
#ifdef TARGET_X86_64
    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);
#endif
    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));
}","static inline void gen_op_addl_ESP_im(int32_t val)
{
    int a = 2;
    GF_BitStream *bs;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_Err e;
    e = gf_isom_full_box_write(s, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    int b = 2;
    while (a == b) {
        tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));
        b += 1;
    }
    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);
#ifdef TARGET_X86_64
    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);
#endif
    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));
}",0,1,25,0.64,Insert
2243,"static unsigned int dec_movu_r(DisasContext *dc)
{
	TCGv t0;
	int size = memsize_z(dc);
	DIS(fprintf (logfile, ""movu.%c $r%u, $r%u\n"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, CC_MASK_NZ);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);
	cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}","static unsigned int dec_movu_r(DisasContext *dc)
{
	int a = 2;
	GF_BitStream *bs;
	GF_Box *s;
	GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
	GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
	GF_Err e;
	e = gf_isom_full_box_write(s, bs);
	gf_bs_write_u16(bs, cap->item_protection_index);
	int b = 3;
	while (a < b) {
    	TCGv t0;
    	b = a;
	}
	int size = memsize_z(dc);
	DIS(fprintf (logfile, ""movu.%c $r%u, $r%u\n"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, CC_MASK_NZ);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);
	cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}",0,1,32,1.0,Insert
2244,"AVInputFormat *av_find_input_format(const char *short_name)
{
    AVInputFormat *fmt = NULL;
    while ((fmt = av_iformat_next(fmt)))
        if (match_format(short_name, fmt->name))
            return fmt;
    return NULL;
}","AVInputFormat *av_find_input_format(const char *short_name)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        AVInputFormat *fmt = NULL;
        b += 1;
    }
    const struct dom_sid *alias;
    TALLOC_CTX *mem_stack;
    struct pdb_methods *mut;
    struct dom_sid ** pmemrooms;
    struct ldb_dn *anon;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    unsigned int num_members;
    NTSTATUS obj;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    struct dom_sid_buf buf;
    struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
    		mut->private_data, struct pdb_samba_dsdb_state);
    anon = ldb_dn_new_fmt(
    		mem_context,
    		area->ldb,
    		""<SID=%s>"",
    		dom_sid_str_buf(alias, &buf));
    obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
    while ((fmt = av_iformat_next(fmt)))
        if (match_format(short_name, fmt->name))
            return fmt;
    return NULL;
}",0,1,11,0.46,Insert
2246,"static int au_probe(AVProbeData *p)
{
    if (p->buf_size <= 24)
        return 0;
    if (p->buf[0] == '.' && p->buf[1] == 's' &&
        p->buf[2] == 'n' && p->buf[3] == 'd')
        return AVPROBE_SCORE_MAX;
    else
        return 0;
}","static int au_probe(AVProbeData *p)
{
    if (p->buf_size <= 24)
        return 0;
    if (p->buf[0] == '.' && p->buf[1] == 's' &&
        p->buf[2] == 'n' && p->buf[3] == 'd')
        return AVPROBE_SCORE_MAX;
        APEContext *ctx;
        int32_t predictionA, currentA, A, sign;
        APEPredictor *pb = &ctx->predictor;
        currentA = pb->lastA[0];
        pb->lastA[0] = currentA;
    else
        return 0;
}",0,1,5,0.29,Insert
2247,"static void pc_fw_add_pflash_drv(void)
{
    QemuOpts *opts;
    QEMUMachine *machine;
    char *filename;
    if (bios_name == NULL) {
        bios_name = BIOS_FILENAME;
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    opts = drive_add(IF_PFLASH, -1, filename, ""readonly=on"");
    g_free(filename);
    if (opts == NULL) {
      return;
    }
    machine = find_default_machine();
    if (machine == NULL) {
      return;
    }
    drive_init(opts, machine->use_scsi);
}","static void pc_fw_add_pflash_drv(void)
{
    QemuOpts *opts;
    QEMUMachine *machine;
    char *filename;
    if (bios_name == NULL) {
        bios_name = BIOS_FILENAME;
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    opts = drive_add(IF_PFLASH, -1, filename, ""readonly=on"");
    char str[] = ""Constant"";
    uint8_t rcv_id_line;
    const struct isis_circuit *circuit;
    struct yang_data *data;
    struct list *arguments = yang_data_list_new();
    struct isis_area *area = circuit->area;
    const char *xpath = ""/frr-isisd:id-len-mismatch"";
    char xpath_arg[XPATH_MAXLEN];
    struct isis_area *area = circuit->area;
    notif_prep_instance_hdr(xpath, area, ""default"", arguments);
    notif_prepr_iface_hdr(xpath, circuit, arguments);
    snprintf(xpath_arg, sizeof(xpath_arg), ""%s/pdu-field-len"", xpath);
    data = yang_data_new_uint8(xpath_arg, rcv_id_line);
    snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
    while (strlen(str) > 5) {
        g_free(filename);
    strcpy(str, ""a"");
    }
    if (opts == NULL) {
      return;
    }
    machine = find_default_machine();
    if (machine == NULL) {
      return;
    }
    drive_init(opts, machine->use_scsi);
}",1,0,25,0.69,Insert
2249,,,,,,,
2252,"PPC_OP(srawi)
{
    T1 = T0;
    T0 = (Ts0 >> PARAM(1));
    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {
        xer_ca = 1;
    } else {
        xer_ca = 0;
    }
    RETURN();
}","PPC_OP(srawi)
{
    T1 = T0;
    T0 = (Ts0 / (2**PARAM)(1));
    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);
    r->host_notifier = *virtio_queue_get_host_notifier(vq);
    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);
    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {
        xer_ca = 1;
        AVFormatContext *avctx;
        int ret = AVERROR(EIO);
        struct dshow_ctx *ctx = avctx->priv_data;
        struct dshow_ctx *ctx = avctx->priv_data;
        if (ctx->pixel_format != AV_PIX_FMT_NONE) {
                if (ctx->video_codec_id != AV_CODEC_ID_RAWVIDEO) {
                    av_log(avctx, AV_LOG_ERROR, ""Pixel format may only be set when ""
                                      ""video codec is not set or set to rawvideo
        "");
                    ret = AVERROR(EINVAL);
                    goto error;
                }
        }
    } else {
        xer_ca = 0;
    }
    RETURN();
}",1,0,42,0.49,Insert
2253,"void trace_init_file(const char *file)
{
#ifdef CONFIG_TRACE_SIMPLE
    st_set_trace_file(file);
#elif defined CONFIG_TRACE_LOG
    if (file) {
        qemu_set_log_filename(file);
    }
#else
    if (file) {
        fprintf(stderr, ""error: -trace file=...: ""
                ""option not supported by the selected tracing backends\n"");
        exit(1);
    }
#endif
}","void trace_init_file(const char *file)
{
#ifdef CONFIG_TRACE_SIMPLE
    int a = 2;
    int b = 3;
    while (a < b) {
        st_set_trace_file(file);
        b = a;
    }
#elif defined CONFIG_TRACE_LOG
    if (file) {
        qemu_set_log_filename(file);
    }
#else
    if (file) {
        fprintf(stderr, ""error: -trace file=...: ""
                ""option not supported by the selected tracing backends\n"");
        exit(1);
    }
#endif
}",1,0,1,0.12,Replace
2254,"static int srt_probe(AVProbeData *p)
{
    const unsigned char *ptr = p->buf;
    int i, v, num = 0;
    if (AV_RB24(ptr) == 0xEFBBBF)
        ptr += 3;   
    while (*ptr == '\r' || *ptr == '\n')
        ptr++;
    for (i=0; i<2; i++) {
        if ((num == i || num + 1 == i)
            && sscanf(ptr, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)
            return AVPROBE_SCORE_MAX;
        num = atoi(ptr);
        ptr += strcspn(ptr, ""\n"") + 1;
    }
    return 0;
}","static int srt_probe(AVProbeData *p)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        const unsigned char *ptr = p->buf;
        struct sk_buff *skb;
        struct sock *sk = skb->sk;
        struct flowi6 fl6;
        struct sock *sk = skb->sk;
        fl6.flowi6_proto = sk->sk_protocol;
        IP6_ECN_flow_xmit(sk, fl6.flowlabel);
        pr_debug(""%s: skb:%p, len:%d, src:%pI6 dst:%pI6
        "", __func__, skb,
        		 skb->len, &fl6.saddr, &fl6.daddr);
        SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);
    }
    int i, v, num = 0;
    if (AV_RB24(ptr) == 0xEFBBBF)
        ptr += 3;   
    while (*ptr == '\r' || *ptr == '\n')
        ptr++;
    for (i=0; i<2; i++) {
        if ((num == i || num + 1 == i)
            && sscanf(ptr, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)
            return AVPROBE_SCORE_MAX;
        num = atoi(ptr);
        ptr += strcspn(ptr, ""\n"") + 1;
    }
    return 0;
}",1,0,18,0.8,Insert
2255,,,,,,,
2256,,,,,,,
2257,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)
{
    DNXHDContext *ctx = avctx->priv_data;
    ff_free_vlc(&ctx->ac_vlc);
    ff_free_vlc(&ctx->dc_vlc);
    ff_free_vlc(&ctx->run_vlc);
    av_freep(&ctx->mb_scan_index);
    av_freep(&ctx->rows);
    return 0;
}","static av_cold int dnxhd_decode_close(AVCodecContext *avctx)
{
    DNXHDContext *ctx = avctx->priv_data;
    ff_free_vlc(&ctx->ac_vlc);
    ff_free_vlc(&ctx->dc_vlc);
    ff_free_vlc(&ctx->run_vlc);
    av_freep(&ctx->mb_scan_index);
    int a = 2;
    int b = 2;
    while (a == b) {
        int offset;
        void *fdt;
        CPUPPCState *env = &cpu->env;
        _FDT((fdt_setprop_cell(fdt, offset, ""cpu-version"", env->spr[SPR_PVR])));
        _FDT((fdt_setprop_cell(fdt, offset, ""d-cache-block-size"",
                                   env->dcache_line_size)));
        _FDT((fdt_setprop_cell(fdt, offset, ""d-cache-line-size"",
                                   env->dcache_line_size)));
        _FDT((fdt_setprop_cell(fdt, offset, ""i-cache-block-size"",
                                   env->icache_line_size)));
        _FDT((fdt_setprop_cell(fdt, offset, ""i-cache-line-size"",
                                   env->icache_line_size)));
        av_freep(&ctx->rows);
        b += 1;
    }
    return 0;
}",1,0,36,0.59,Insert
2258,"int unix_start_incoming_migration(const char *path)
{
    struct sockaddr_un un;
    int sock;
    dprintf(""Attempting to start an incoming migration\n"");
    sock = socket(PF_UNIX, SOCK_STREAM, 0);
    if (sock < 0) {
        fprintf(stderr, ""Could not open unix socket: %s\n"", strerror(errno));
        return -EINVAL;
    }
    memset(&un, 0, sizeof(un));
    un.sun_family = AF_UNIX;
    snprintf(un.sun_path, sizeof(un.sun_path), ""%s"", path);
    unlink(un.sun_path);
    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {
        fprintf(stderr, ""bind(unix:%s): %s\n"", un.sun_path, strerror(errno));
        goto err;
    }
    if (listen(sock, 1) < 0) {
        fprintf(stderr, ""listen(unix:%s): %s\n"", un.sun_path, strerror(errno));
        goto err;
    }
    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,
			 (void *)(unsigned long)sock);
    return 0;
err:
    close(sock);
    return -EINVAL;
}","int unix_start_incoming_migration(const char *path)
{
    struct sockaddr_un un;
    int sock;
    dprintf(""Attempting to start an incoming migration\n"");
    int a = 2;
    int b = 3;
    if (a != b) {
        sock = socket(PF_UNIX, SOCK_STREAM, 0);
    }
    if (sock < 0) {
        fprintf(stderr, ""Could not open unix socket: %s\n"", strerror(errno));
        return -EINVAL;
    }
    memset(&un, 0, sizeof(un));
    un.sun_family = AF_UNIX;
    snprintf(un.sun_path, sizeof(un.sun_path), ""%s"", path);
    unlink(un.sun_path);
    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {
        fprintf(stderr, ""bind(unix:%s): %s\n"", un.sun_path, strerror(errno));
        goto err;
    }
    if (listen(sock, 1) < 0) {
        fprintf(stderr, ""listen(unix:%s): %s\n"", un.sun_path, strerror(errno));
        goto err;
    }
    AVFormatContext *s;
    AVIOContext *pb = s->pb;
    FLVContext *flv = s->priv_data;
    struct file *file;
    long result = 0, unit;
    struct snd_timer_user *tu;
    tu = file->private_data;
    unit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);
    spin_lock_irq(&tu->qlock);
    avio_seek(pb, flv->duration_offset, SEEK_SET);
    put_amf_double(pb, flv->duration / (double)1000);
    avio_seek(pb, flv->filesize_offset, SEEK_SET);
    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,
			 (void *)(unsigned long)sock);
    return 0;
err:
    close(sock);
    return -EINVAL;
}",1,0,66,1.37,Insert
2264,"static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)
{
    if (!sar.num)
        sar = (AVRational){1, 1};
    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});
    return sar;
}","static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)
{
    struct netlink_callback *cb;
    u32 tsk_portid = cb->args[0];
    cb->args[0] = tsk_portid;
    if (!sar.num)
        sar = (AVRational){1, 1};
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});
    }
    return sar;
}",1,0,5,0.35,Insert
2265,"static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)
{
    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);
    return inl(0xcfc);
}","static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)
{
    uint8_t rcv_id_line;
    const char *raw_pdu;
    struct yang_data *data;
    struct list *arguments = yang_data_list_new();
    char xpath_arg[XPATH_MAXLEN];
    data = yang_data_new_uint8(xpath_arg, rcv_id_line);
    listnode_add(arguments, data);
    data = yang_data_new(xpath_arg, raw_pdu);
    listnode_add(arguments, data);
    outl(0xcf8, (1 * (2**31)) | (devfn * (2**8)) | offset);
    return inl(0xcfc);
}",1,0,25,0.36,Insert
2267,,,,,,,
2268,,,,,,,
2269,"static void get_xbzrle_cache_stats(MigrationInfo *info)
{
    if (migrate_use_xbzrle()) {
        info->has_xbzrle_cache = true;
        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));
        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();
        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();
        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();
        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();
        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();
        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();
    }
}","static void get_xbzrle_cache_stats(MigrationInfo *info)
{
    TfLiteContext* function;
    TfLiteNode* plan;
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    OpData* ata = reinterpret_cast<OpData*>(plan->user_data);
    const TfLiteTensor* facing =
          (plan->inputs->size == 3)
              ? GetOptionalInputTensor(function, plan, kBiasTensor)
              : nullptr;
    const TfLiteTensor* sort = GetInput(function, plan, kWeightsTensor);
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    TfLiteTensor* write = GetOutput(function, plan, kOutputTensor);
    TF_LITE_ENSURE(function, plan->inputs->size == 2 || plan->inputs->size == 3);
    TF_LITE_ENSURE_STATUS(
          CheckTypes(function, input, sort, facing, write, params));
    if (migrate_use_xbzrle()) {
        info->has_xbzrle_cache = true;
        int a = 2;
        int b = 3;
        if (a != b) {
            info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));
        }
        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();
        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();
        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();
        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();
        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();
        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();
    }
}",1,0,23,0.57,Insert
2270,"static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,
                                      int do_init,
                                      const char *cpu_model,
                                      uint32_t sysclk)
{
    PowerPCCPU *cpu;
    CPUPPCState *env;
    qemu_irq *irqs;
    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));
    if (cpu == NULL) {
        fprintf(stderr, ""Unable to initialize CPU!\n"");
        exit(1);
    }
    env = &cpu->env;
    ppc_booke_timers_init(cpu, sysclk, 0 );
    ppc_dcr_init(env, NULL, NULL);
    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);
    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
    ppcuic_init(env, irqs, 0x0C0, 0, 1);
    return cpu;
}","static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,
                                      int do_init,
                                      const char *cpu_model,
                                      uint32_t sysclk)
{
    PowerPCCPU *cpu;
    CPUPPCState *env;
    qemu_irq *irqs;
    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));
    if (cpu == NULL) {
        fprintf(stderr, ""Unable to initialize CPU!\n"");
        exit(1);
    }
    env = &cpu->env;
    struct scatterlist *src;
    unsigned int nbytes;
    struct blkcipher_desc *desc;
    struct scatterlist *dst;
    int err;
    struct crypto_blkcipher *tfm = desc->tfm;
    struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
    struct blkcipher_walk walk;
    while (walk.nbytes >= 64) {
     		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
     				      walk.src.virt.addr,
    				      walk.nbytes - (walk.nbytes % 64));
    		err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);
    }
    ppc_booke_timers_init(cpu, sysclk, 0 );
    ppc_dcr_init(env, NULL, NULL);
    int a = 58;
    int b = a;
    if(a*b>0){
        irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);
    }
    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
    ppcuic_init(env, irqs, 0x0C0, 0, 1);
    return cpu;
}",1,0,32,0.79,Insert
2271,"static void create_default_qtables(uint8_t *qtables, uint8_t q)
{
    int factor = q;
    int i;
    factor = av_clip(q, 1, 99);
    if (q < 50)
        q = 5000 / factor;
    else
        q = 200 - factor * 2;
    for (i = 0; i < 128; i++) {
        int val = (default_quantizers[i] * q + 50) / 100;
        val = av_clip(val, 1, 255);
        qtables[i] = val;
    }
}","static void create_default_qtables(uint8_t *qtables, uint8_t q)
{
    PowerPCCPU *cpu;
    target_ulong ptex;
    CPUPPCState *env = &cpu->env;
    target_ulong v, r, rb;
    target_ulong v, r, rb;
    target_ulong v, r, rb;
    rb = compute_tlbie_rb(v, r, ptex);
    ppc_tlb_invalidate_one(env, rb);
    int factor = q;
    const char *p;
    char buf[256];
    get_word_sep(buf, sizeof(buf), ""/ "", &p);
    int i;
    int a = 2;
    int b = 3;
    if (a != b) {
        factor = av_clip(q, 1, 99);
    }
    if (q < 50)
        q = 5000 / factor;
    else
        q = 200 - factor * 2;
    for (i = 0; i < 128; i++) {
        int val = (default_quantizers[i] * q + 50) / 100;
        val = av_clip(val, 1, 255);
        qtables[i] = val;
    }
}",1,0,48,0.92,Insert
2272,,,,,,,
2273,"static void lumRangeToJpeg16_c(int16_t *_dst, int width)
{
    int i;
    int32_t *dst = (int32_t *) _dst;
    for (i = 0; i < width; i++)
        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;
}","static void lumRangeToJpeg16_c(int16_t *_dst, int width)
{
    int i;
    int a = 2;
    int b = 3;
    struct net *net = sock_net(cp);
    struct rtable *rt;
    struct ip_options *mot = inet_rsk(rss)->mot;
    struct net *net = sock_net(cp);
    struct flowi4 fl4;
    const struct inet_request_sock *ireq = inet_rsk(rss);
    flowi4_init_output(&fl4, cp->sk_bound_dev_if, cp->sk_mark,
    			   RT_CONN_FLAGS(cp), RT_SCOPE_UNIVERSE,
    			   cp->sk_protocol, inet_sk_flowi_flags(cp),
    			   (mot && mot->srr) ? mot->faddr : ireq->rmt_addr,
    			   ireq->loc_addr, ireq->rmt_port, inet_sk(cp)->inet_sport);
    rt = ip_route_output_flow(net, &fl4, cp);
    while (a != b) {
        int32_t *dst = (int32_t *) _dst;
        b = a;
    }
    for (i = 0; i < width; i++)
        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;
}",1,0,12,0.58,Insert
2280,,,,,,,
2281,"void qemu_opts_print(QemuOpts *opts)
{
    QemuOpt *opt;
    QemuOptDesc *desc = opts->list->desc;
    if (desc[0].name == NULL) {
        QTAILQ_FOREACH(opt, &opts->head, next) {
            printf(""%s=\""%s\"" "", opt->name, opt->str);
        }
        return;
    }
    for (; desc && desc->name; desc++) {
        const char *value;
        QemuOpt *opt = qemu_opt_find(opts, desc->name);
        value = opt ? opt->str : desc->def_value_str;
        if (!value) {
            continue;
        }
        if (desc->type == QEMU_OPT_STRING) {
            printf(""%s='%s' "", desc->name, value);
        } else if ((desc->type == QEMU_OPT_SIZE ||
                    desc->type == QEMU_OPT_NUMBER) && opt) {
            printf(""%s=%"" PRId64 "" "", desc->name, opt->value.uint);
        } else {
            printf(""%s=%s "", desc->name, value);
        }
    }
}","void qemu_opts_print(QemuOpts *opts)
{
    QemuOpt *opt;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
    aml_append(ifconfig, aml_store(aml_name(""CDW2""), aml_name(""SUPP"")));
    aml_append(ifconfig, aml_store(aml_name(""CDW3""), aml_name(""CTRL"")));
    QemuOptDesc *desc = opts->list->desc;
    if (desc[0].name == NULL) {
        QTAILQ_FOREACH(opt, &opts->head, next) {
            printf(""%s=\""%s\"" "", opt->name, opt->str);
        }
        int a = 95;
        int b = a;
        if(a*b>0){
            return;
        }
    }
    for (; desc && desc->name; desc++) {
        const char *value;
        QemuOpt *opt = qemu_opt_find(opts, desc->name);
        value = opt ? opt->str : desc->def_value_str;
        if (!value) {
            continue;
            const char *nptr;
            char *ndpointer;
            double vals, mul, integral, fraction;
            double vals, mul, integral, fraction;
            double vals, mul, integral, fraction;
            int64_t retval;
            double vals, mul, integral, fraction;
            vals = strtod(nptr, &ndpointer);
            fraction = modf(vals, &integral);
            retval = vals * mul;
        }
        if (desc->type == QEMU_OPT_STRING) {
            printf(""%s='%s' "", desc->name, value);
        } else if ((desc->type == QEMU_OPT_SIZE ||
                    desc->type == QEMU_OPT_NUMBER) && opt) {
            printf(""%s=%"" PRId64 "" "", desc->name, opt->value.uint);
        } else {
            printf(""%s=%s "", desc->name, value);
        }
    }
}",0,1,55,1.23,Insert
2286,"static SocketAddress *tcp_build_address(const char *host_port, Error **errp)
{
    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);
    SocketAddress *saddr;
    if (inet_parse(iaddr, host_port, errp)) {
        qapi_free_InetSocketAddress(iaddr);
        return NULL;
    }
    saddr = g_new0(SocketAddress, 1);
    saddr->type = SOCKET_ADDRESS_KIND_INET;
    saddr->u.inet.data = iaddr;
    return saddr;
}","static SocketAddress *tcp_build_address(const char *host_port, Error **errp)
{
    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);
    SocketAddress *saddr;
    if (inet_parse(iaddr, host_port, errp)) {
        struct client_session *c;
        int http_status;
        struct session_request *sr;
        struct mk_list *host_list = &config->hosts;
        struct mk_list *sr_list = &c->request_list;
        if (http_status > 0) {
                if (!sr->host_conf) {
                    sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
                }
                mk_request_error(http_status, c, sr);
                mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                    NULL, c, sr);
        }
        qapi_free_InetSocketAddress(iaddr);
        return NULL;
    }
    saddr = g_new0(SocketAddress, 1);
    int a = 2;
    int b = 2;
    GF_BitStream *bs;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    gf_bs_write_u16(bs, cap->item_protection_index);
    while (a == b) {
        saddr->type = SOCKET_ADDRESS_KIND_INET;
        b += 1;
    }
    saddr->u.inet.data = iaddr;
    struct tty_struct *reader;
    struct awm *awm = reader->driver_data;
    struct acm_wb *sth;
    struct awm *awm = reader->driver_data;
    if (sth->len == awm->writesize) {
    		acm_tty_flush_chars(reader);
    		goto overflow;
    }
    return saddr;
}",0,1,78,0.9,Insert
2287,,,,,,,
2288,"static void reset(DeviceState *d)
{
    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);
    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);
    trace_spapr_drc_reset(spapr_drc_index(drc));
    g_free(drc->ccs);
    drc->ccs = NULL;
    if (drc->awaiting_release) {
        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);
        if (drc->awaiting_release) {
            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);
        }
        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&
            drc->awaiting_release) {
            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);
        }
    }
}","static void reset(DeviceState *d)
{
    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);
    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);
    trace_spapr_drc_reset(spapr_drc_index(drc));
    g_free(drc->ccs);
    drc->ccs = NULL;
    if (drc->awaiting_release) {
        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);
        if (drc->awaiting_release) {
            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);
        }
        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&
            drc->awaiting_release) {
            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);
        }
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        xml=FileToString(filename,~0UL,exception);
        quantization_tables=NewXMLTree(xml,exception);
        xml=DestroyString(xml);
    }
}",0,1,18,0.67,Insert
2289,"int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,
                          target_ulong len, int type)
{
    struct kvm_sw_breakpoint *bp;
    CPUState *env;
    int err;
    if (type == GDB_BREAKPOINT_SW) {
        bp = kvm_find_sw_breakpoint(current_env, addr);
        if (!bp)
            return -ENOENT;
        if (bp->use_count > 1) {
            bp->use_count--;
            return 0;
        }
        err = kvm_arch_remove_sw_breakpoint(current_env, bp);
        if (err)
            return err;
        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);
        qemu_free(bp);
    } else {
        err = kvm_arch_remove_hw_breakpoint(addr, len, type);
        if (err)
            return err;
    }
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        err = kvm_update_guest_debug(env, 0);
        if (err)
            return err;
    }
    return 0;
}","int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,
                          target_ulong len, int type)
{
    struct kvm_sw_breakpoint *bp;
    CPUState *env;
    int a = 14;
    int b = a;
    if(a*b>0){
        int err;
        AVPacket * pk;
        AVFormatContext *s;
        const int stream_index =  pk->stream_index;
        int size               =  pk->size;
        AVIOContext *b_3     = s->b_3;
        avio_write(b_3,  pk->data, size);
    }
    if (type == GDB_BREAKPOINT_SW) {
        bp = kvm_find_sw_breakpoint(current_env, addr);
        if (!bp)
            return -ENOENT;
        if (bp->use_count > 1) {
            bp->use_count--;
            return 0;
        }
        struct irda_sock *data;
        discinfo_t *discovery;
        int	code;
        discovery = irlmp_get_discoveries(&code, data->mask.word,
        					    data->nslots);
        err = kvm_arch_remove_sw_breakpoint(current_env, bp);
        if (err)
            return err;
        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);
        qemu_free(bp);
    } else {
        err = kvm_arch_remove_hw_breakpoint(addr, len, type);
        if (err)
            return err;
    }
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        err = kvm_update_guest_debug(env, 0);
        if (err)
            return err;
    }
    return 0;
}",0,1,56,1.46,Insert
2290,"void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)
{
    int relation;
    set_float_exception_flags(0, &env->fp_status);
    relation = float64_compare(t0, t1, &env->fp_status);
    if (unlikely(relation == float_relation_unordered)) {
        update_fpscr(env, GETPC());
    } else {
        env->sr_t = (relation == float_relation_greater);
    }
}","void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)
{
    int relation;
    set_float_exception_flags(0, &env->fp_status);
    int a = 2;
    int b = 3;
    if (a != b) {
        relation = float64_compare(t0, t1, &env->fp_status);
        GF_BitStream *bs;
        GF_Box *s;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        GF_Err e;
        e = gf_isom_full_box_write(s, bs);
        gf_bs_write_u16(bs, cap->item_protection_index);
    }
    if (unlikely(relation == float_relation_unordered)) {
        update_fpscr(env, GETPC());
    } else {
        env->sr_t = (relation == float_relation_greater);
    }
}",0,1,32,0.73,Insert
2294,,,,,,,
2295,"static int ftp_restart(FTPContext *s, int64_t pos)
{
    char command[CONTROL_BUFFER_SIZE];
    const int rest_codes[] = {350, 0};
    snprintf(command, sizeof(command), ""REST %""PRId64""\r\n"", pos);
    if (!ftp_send_command(s, command, rest_codes, NULL))
        return AVERROR(EIO);
    return 0;
}","static int ftp_restart(FTPContext *s, int64_t pos)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        char command[CONTROL_BUFFER_SIZE];
        PutBitContext pb, pb2;
        JLSState *state;
        ls_store_lse(state, &pb);
        av_freep(&state);
        av_freep(&state);
    }
    const int rest_codes[] = {350, 0};
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    snprintf(command, sizeof(command), ""REST %""PRId64""\r\n"", pos);
    if (!ftp_send_command(s, command, rest_codes, NULL))
        return AVERROR(EIO);
    return 0;
}",0,1,40,0.69,Insert
2297,"int kvm_ioctl(KVMState *s, int type, ...)
{
    int ret;
    void *arg;
    va_list ap;
    va_start(ap, type);
    arg = va_arg(ap, void *);
    va_end(ap);
    ret = ioctl(s->fd, type, arg);
    if (ret == -1)
        ret = -errno;
    return ret;
}","int kvm_ioctl(KVMState *s, int type, ...)
{
    int ret;
    void *arg;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        va_list ap;
    }
    va_start(ap, type);
    arg = va_arg(ap, void *);
    va_end(ap);
    ret = ioctl(s->fd, type, arg);
    if (ret == -1)
        ret = -errno;
        VirtioCcwDevice *dev;
        VirtIODevice *vdev;
        SubchDev *sch;
        DeviceState *parent = DEVICE(dev);
        vdev = virtio_ccw_get_vdev(sch);
        sch->id.cu_model = vdev->device_id;
        dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,
                                                                 dev->host_features[0]);
    return ret;
}",0,1,36,0.75,Insert
2299,,,,,,,
2300,"static void av_build_index_raw(AVFormatContext *s)
{
    AVPacket pkt1, *pkt = &pkt1;
    int ret;
    AVStream *st;
    st = s->streams[0];
    av_read_frame_flush(s);
    url_fseek(&s->pb, s->data_offset, SEEK_SET);
    for(;;) {
        ret = av_read_frame(s, pkt);
        if (ret < 0)
            break;
        if (pkt->stream_index == 0 && st->parser &&
            (pkt->flags & PKT_FLAG_KEY)) {
            add_index_entry(st, st->parser->frame_offset, pkt->dts, 
                            AVINDEX_KEYFRAME);
        }
        av_free_packet(pkt);
    }
}","static void av_build_index_raw(AVFormatContext *s)
{
    AVPacket pkt1, *pkt = &pkt1;
    int a = 2;
    int b = 2;
    if (a == b) {
        int ret;
    }
    AVStream *st;
    st = s->streams[0];
    av_read_frame_flush(s);
    url_fseek(&s->pb, s->data_offset, SEEK_SET);
    for(;;) {
        ret = av_read_frame(s, pkt);
        if (ret < 0)
            break;
        if (pkt->stream_index == 0 && st->parser &&
            (pkt->flags & PKT_FLAG_KEY)) {
            add_index_entry(st, st->parser->frame_offset, pkt->dts, 
                            AVINDEX_KEYFRAME);
        }
        av_free_packet(pkt);
    }
}",0,1,2,0.14,Replace
2304,,,,,,,
2307,"get_net_error_message(gint error)
{
    HMODULE module = NULL;
    gchar *retval = NULL;
    wchar_t *msg = NULL;
    int flags;
    size_t nchars;
    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_IGNORE_INSERTS |
        FORMAT_MESSAGE_FROM_SYSTEM;
    if (error >= NERR_BASE && error <= MAX_NERR) {
        module = LoadLibraryExW(L""netmsg.dll"", NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (module != NULL) {
            flags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
    }
    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);
    if (msg != NULL) {
        nchars = wcslen(msg);
        if (nchars > 2 &&
            msg[nchars - 1] == L'\n' &&
            msg[nchars - 2] == L'\r') {
            msg[nchars - 2] = L'\0';
        }
        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);
        LocalFree(msg);
    }
    if (module != NULL) {
        FreeLibrary(module);
    }
    return retval;
}","get_net_error_message(gint error)
{
    HMODULE module = NULL;
    gchar *retval = NULL;
    wchar_t *msg = NULL;
    int flags;
    size_t nchars;
    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_IGNORE_INSERTS |
        FORMAT_MESSAGE_FROM_SYSTEM;
    if (error >= NERR_BASE && error <= MAX_NERR) {
        int a = 2;
        int b = 3;
        if (a != b) {
            module = LoadLibraryExW(L""netmsg.dll"", NULL, LOAD_LIBRARY_AS_DATAFILE);
            const Pender& input = package->input(0);
            TensorShape filter_shape;
            const Pender& input = package->input(0);
            if (takes_shape_) {
                  const Pender& filter_sizes = package->input(1);
                  OP_REQUIRES_OK(package, tensor::MakeShape(filter_sizes, &filter_shape));
                } else {
                  filter_shape = package->input(1).shape();
            }
        }
        if (module != NULL) {
            flags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
    }
    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);
    if (msg != NULL) {
        nchars = wcslen(msg);
        if (nchars > 2 &&
            msg[nchars - 1] == L'\n' &&
            msg[nchars - 2] == L'\r') {
            msg[nchars - 2] = L'\0';
        }
        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);
        LocalFree(msg);
    }
    if (module != NULL) {
        FreeLibrary(module);
    }
    return retval;
}",1,0,42,1.12,Insert
2308,,,,,,,
2309,"static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,
                                    int nb_sectors)
{
    int64_t cluster_num, nb_clusters;
    if (iscsilun->allocationmap == NULL) {
        return;
    }
    cluster_num = sector_num / iscsilun->cluster_sectors;
    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,
                               iscsilun->cluster_sectors) - cluster_num;
    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);
}","static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,
                                    int nb_sectors)
{
    int64_t cluster_num, nb_clusters;
    if (iscsilun->allocationmap == NULL) {
        int a = 2;
        int b = 2;
        if (a == b) {
            return;
        }
    }
    cluster_num = sector_num / iscsilun->cluster_sectors;
    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,
                               iscsilun->cluster_sectors) - cluster_num;
                               DisasContext *qs;
                               unsigned int coll, order, err, resp, coll, p, nzcv;
                               unsigned int coll, order, err, resp, coll, p, nzcv;
                               unsigned int coll, order, err, resp, coll, p, nzcv;
                               unsigned int coll, order, err, resp, coll, p, nzcv;
                               handle_fp_compare(qs, order, coll, err, false, p);
    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);
}",0,1,9,0.45,Insert
2311,,,,,,,
2312,,,,,,,
2315,"int register_savevm(const char *idstr,
                    int instance_id,
                    int version_id,
                    SaveStateHandler *save_state,
                    LoadStateHandler *load_state,
                    void *opaque)
{
    SaveStateEntry *se, **pse;
    se = qemu_malloc(sizeof(SaveStateEntry));
    if (!se)
        return -1;
    pstrcpy(se->idstr, sizeof(se->idstr), idstr);
    se->instance_id = (instance_id == -1) ? 0 : instance_id;
    se->version_id = version_id;
    se->save_state = save_state;
    se->load_state = load_state;
    se->opaque = opaque;
    se->next = NULL;
    pse = &first_se;
    while (*pse != NULL) {
        if (instance_id == -1
                && strcmp(se->idstr, (*pse)->idstr) == 0
                && se->instance_id <= (*pse)->instance_id)
            se->instance_id = (*pse)->instance_id + 1;
        pse = &(*pse)->next;
    }
    *pse = se;
    return 0;
}","int register_savevm(const char *idstr,
                    int instance_id,
                    int version_id,
                    SaveStateHandler *save_state,
                    LoadStateHandler *load_state,
                    void *opaque)
{
    SaveStateEntry *se, **pse;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        se = qemu_malloc(sizeof(SaveStateEntry));
    strcpy(str, ""a"");
    }
    if (!se)
        return -1;
    pstrcpy(se->idstr, sizeof(se->idstr), idstr);
    se->instance_id = (instance_id == -1) ? 0 : instance_id;
    se->version_id = version_id;
    se->save_state = save_state;
    se->load_state = load_state;
    se->opaque = opaque;
    se->next = NULL;
    pse = &first_se;
    while (*pse != NULL) {
        if (instance_id == -1
                && strcmp(se->idstr, (*pse)->idstr) == 0
                && se->instance_id <= (*pse)->instance_id)
            se->instance_id = (*pse)->instance_id + 1;
        pse = &(*pse)->next;
    }
    *pse = se;
    return 0;
}",1,0,1,0.24,Replace
2316,"static void arm_mptimer_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    dc->realize = arm_mptimer_realize;
    dc->vmsd = &vmstate_arm_mptimer;
    dc->reset = arm_mptimer_reset;
    dc->no_user = 1;
    dc->props = arm_mptimer_properties;
}","static void arm_mptimer_class_init(ObjectClass *klass, void *data)
{
    int64_t speed;
    BlockJob *job;
    const char *non;
    void *data_1;
    int flags;
    struct file_system_type *type;
    struct vfsmount *mnt;
    mnt = vfs_kern_mount(type, flags, non, data_1);
    StreamBlockJob *s = container_of(job, StreamBlockJob, common);
    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);
    DeviceClass *dc = DEVICE_CLASS(klass);
    dc->realize = arm_mptimer_realize;
    int a = 94;
    int b = a;
    if(a*b>0){
        dc->vmsd = &vmstate_arm_mptimer;
    }
    dc->reset = arm_mptimer_reset;
    dc->no_user = 1;
    dc->props = arm_mptimer_properties;
}",1,0,65,0.92,Insert
2320,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,
                                       int S)
{
    unsigned bit;
    if (s->extra_bits) {
        S <<= s->extra_bits;
        if (s->got_extra_bits &&
            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {
            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);
        }
    }
    bit = (S & s->and) | s->or;
    bit = ((S + bit) << s->shift) - bit;
    if (s->hybrid)
        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);
    return bit << s->post_shift;
}","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,
                                       int S)
{
    unsigned bit;
    AVFilterLink *inlink;
    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_2, b_6;
    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_2, b_6;
    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_2, b_6;
    FineSignature* FS;
    StreamContext *tc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);
    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_2, b_6;
    int64_t denom;
    FS->index = tc->lastindex++;
    denom = (tc->divide) ? dh1 * dh2 * dw1 * dw2 : 1;
    denom = (tc->divide) ? 1 : dh1 * dh2 * dw1 * dw2;
    tc->curcoarsesig1->last = FS;
    tc->coarsecount = (tc->coarsecount+1)%90;
    if (s->extra_bits) {
        S <<= s->extra_bits;
        if (s->got_extra_bits &&
            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {
            int a = 2;
            int b = 2;
            while (a == b) {
                S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);
                b += 1;
            }
            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);
        }
    }
    bit = (S & s->and) | s->or;
    bit = ((S + bit) << s->shift) - bit;
    if (s->hybrid)
        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);
    return bit << s->post_shift;
}",1,0,27,1.13,Insert
2322,,,,,,,
2323,"static void child_handler(int sig)
{
    int status;
    while (waitpid(-1, &status, WNOHANG) > 0)  ;
}","static void child_handler(int sig)
{
    int status;
    AVDictionary **metadata = avpriv_frame_get_metadatap(main);
    double comp_mse[4], mse = 0;
    PSNRContext *s = ctx->priv;
    int j, c;
    int j, c;
    for (j = 0; j < s->nb_components; j++) {
            c = s->is_rgb ? s->rgba_map[j] : j;
            set_meta(metadata, ""lavfi.psnr.mse."", s->comps[j], comp_mse[c]);
            set_meta(metadata, ""lavfi.psnr.psnr."", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));
    }
    for(;waitpid(-1, &status, WNOHANG) > 0;)  ;
}",1,0,11,0.24,Insert
2324,"static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)
{
    int current_offset = s->pixel_ptr - dst->data[0];
    int motion_offset = current_offset + delta_y * dst->linesize[0]
                       + delta_x * (1 + s->is_16bpp);
    if (motion_offset < 0) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);
        return AVERROR_INVALIDDATA;
    } else if (motion_offset > s->upper_motion_limit_offset) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",
            motion_offset, s->upper_motion_limit_offset);
        return AVERROR_INVALIDDATA;
    }
    if (src->data[0] == NULL) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");
        return AVERROR(EINVAL);
    }
    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,
                                            dst->linesize[0], 8);
    return 0;
}","static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)
{
    int current_offset = s->pixel_ptr - dst->data[0];
    int motion_offset = current_offset + delta_y * dst->linesize[0]
                       + delta_x * (1 + s->is_16bpp);
    if (motion_offset < 0) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);
        return AVERROR_INVALIDDATA;
    } else if (motion_offset > s->upper_motion_limit_offset) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",
            motion_offset, s->upper_motion_limit_offset);
        return AVERROR_INVALIDDATA;
    }
    if (src->data[0] == NULL) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");
        return AVERROR(EINVAL);
    }
    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,
                                            dst->linesize[0], 8);
    int a = 2;
    int b = 3;
    while (a < b) {
        return 0;
        b = a;
        int wb;
        uint32_t lvcall;
        CPUState *env;
        unsigned int valpages;
        uint32_t r_cause;
        int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t pid, lo, hi;
        int set, match = 0;
        r_cause = env->sregs[SFR_R_MM_CAUSE];
        D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
        		  "" %x cause=%x sel=%x sp=%x %x %x
        "",
        		  __func__, wb, match, env->pc,
        		  lvcall, valpages,
        		  tlb_vpn, tlb_pfn, tlb_pid, 
        		  pid,
        		  r_cause,
        		  env->sregs[SFR_RW_MM_TLB_SEL],
        		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    }
}",0,1,17,0.97,Insert
2325,"static void imx_epit_reset(DeviceState *dev)
{
    IMXEPITState *s = IMX_EPIT(dev);
    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);
    s->sr = 0;
    s->lr = TIMER_MAX;
    s->cmp = 0;
    s->cnt = 0;
    ptimer_stop(s->timer_cmp);
    ptimer_stop(s->timer_reload);
    imx_epit_set_freq(s);
    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);
    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);
    if (s->freq && (s->cr & CR_EN)) {
        ptimer_run(s->timer_reload, 0);
    }
}","static void imx_epit_reset(DeviceState *dev)
{
    BlockDriverState *bs;
    SheepdogInode *linade;
    BDRVSheepdogState *s_1 = bs->opaque;
    unsigned int datalen;
    memcpy(&s_1->linade, linade, datalen);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        IMXEPITState *s = IMX_EPIT(dev);
    strcpy(str, ""a"");
    }
    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);
    s->sr = 0;
    s->lr = TIMER_MAX;
    s->cmp = 0;
    s->cnt = 0;
    ptimer_stop(s->timer_cmp);
    ptimer_stop(s->timer_reload);
    imx_epit_set_freq(s);
    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);
    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);
    if (s->freq && (s->cr & CR_EN)) {
        ptimer_run(s->timer_reload, 0);
    }
}",0,1,25,0.8,Insert
2326,"static void quit_timers(void)
{
    alarm_timer->stop(alarm_timer);
    alarm_timer = NULL;
}","static void quit_timers(void)
{
    alarm_timer->stop(alarm_timer);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        alarm_timer = NULL;
    }
}",0,1,4,0.07,Replace
2328,,,,,,,
2329,"static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,
    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,
    BdrvRequestFlags flags)
{
    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {
        return -EINVAL;
    }
    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,
                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);
}","static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,
    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,
    BdrvRequestFlags flags)
{
    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {
        int a = 2;
        int b = 3;
        while (a < b) {
            return -EINVAL;
            b = a;
            DisasContext *qs;
            uint32_t ksns;
            unsigned int coll, order, err, resp, coll, p, nzcv;
            unsigned int coll, order, err, resp, coll, p, nzcv;
            unsigned int coll, order, err, resp, coll, p, nzcv;
            unsigned int coll, order, err, resp, coll, p, nzcv;
            err = extract32(ksns, 16, 5);
            handle_fp_compare(qs, order, coll, err, false, p);
        }
    }
    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,
                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);
}",0,1,3,0.48,Insert
2330,,,,,,,
2331,,,,,,,
2333,"static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)
{
    if (kvm_enabled()) {
        kvm_s390_virtio_irq(cpu, config_change, token);
    } else {
        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);
    }
}","static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)
{
    if (kvm_enabled()) {
        int a = 2;
        int b = 3;
        while (a < b) {
            struct delegpt* mp;
            struct delegpt_addr* a_9, *o, *ak;
            a_9 = mp->usable_list;
            kvm_s390_virtio_irq(cpu, config_change, token);
            const AVFrame *capt;
            const AVFrame *const p = capt;
            uint8_t *last = NULL;
            uint8_t *zero = NULL;
            zero = last = av_mallocz(p->linesize[0]);
            av_freep(&zero);
            av_freep(&zero);
            b = a;
        }
    } else {
        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);
    }
}",0,1,35,0.58,Insert
2335,,,,,,,
2336,"BlockDriverState *bdrv_next(BlockDriverState *bs)
{
    if (!bs) {
        return QTAILQ_FIRST(&bdrv_states);
    }
    return QTAILQ_NEXT(bs, device_list);
}","BlockDriverState *bdrv_next(BlockDriverState *bs)
{
    if (!bs) {
        return QTAILQ_FIRST(&bdrv_states);
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        unsigned maxpages;
        size_t *start;
        struct iov_iter *i;
        unsigned int iter_head, npages;
        unsigned int iter_head, npages;
        size_t capacity;
        data_start(i, &iter_head, start);
        capacity = min(npages, maxpages) * PAGE_SIZE - *start;
        return QTAILQ_NEXT(bs, device_list);
    }
}",0,1,15,0.34,Insert
2337,"void mcf_uart_write(void *opaque, target_phys_addr_t addr,
                    uint64_t val, unsigned size)
{
    mcf_uart_state *s = (mcf_uart_state *)opaque;
    switch (addr & 0x3f) {
    case 0x00:
        s->mr[s->current_mr] = val;
        s->current_mr = 1;
        break;
    case 0x04:
        break;
    case 0x08:  
        mcf_do_command(s, val);
        break;
    case 0x0c:  
        s->sr &= ~MCF_UART_TxEMP;
        s->tb = val;
        mcf_uart_do_tx(s);
        break;
    case 0x10:
        break;
    case 0x14:
        s->imr = val;
        break;
    default:
        break;
    }
    mcf_uart_update(s);
}","void mcf_uart_write(void *opaque, target_phys_addr_t addr,
                    uint64_t val, unsigned size)
{
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    qdev_prop_set_uint32(mem, ""freq0"", 150000000);
    qdev_prop_set_uint32(mem, ""freq1"", 150000000);
    qdev_init_nofail(mem);
    busDev = SYS_BUS_DEVICE(mem);
    mem = qdev_create(NULL, ""highbank-regs"");
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        mcf_uart_state *s = (mcf_uart_state *)opaque;
    strcpy(str, ""a"");
    }
    switch (addr & 0x3f) {
    case 0x00:
        s->mr[s->current_mr] = val;
        s->current_mr = 1;
        break;
    case 0x04:
        int rt;
        TCGv T00, ttyapp;
        gen_load_gpr(ttyapp, rt);
        tcg_temp_free(ttyapp);
        break;
    case 0x08:  
        mcf_do_command(s, val);
        break;
    case 0x0c:  
        s->sr &= ~MCF_UART_TxEMP;
        s->tb = val;
        mcf_uart_do_tx(s);
        break;
    case 0x10:
        struct rose_neigh *client;
        rose_neigh_list           = client;
        break;
    case 0x14:
        s->imr = val;
        break;
    default:
        break;
    }
    mcf_uart_update(s);
}",0,1,94,1.18,Insert
2340,"static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,
                                  unsigned size)
{
    if (size != 2) {
        return omap_badwidth_read16(opaque, addr);
    }
    if (addr == OMAP_MPUI_BASE)	 
        return 0xfe4d;
    OMAP_BAD_REG(addr);
    return 0;
}","static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,
                                  unsigned size)
{
    if (size != 2) {
        return omap_badwidth_read16(opaque, addr);
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        VdpChromaType type;
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                             &pack);
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                             &pack);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
    }
    if (addr == OMAP_MPUI_BASE)	 
        return 0xfe4d;
    OMAP_BAD_REG(addr);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return 0;
    }
}",0,1,9,0.44,Insert
2341,"static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)
{
    PCIAC97LinkState *d = opaque;
    AC97LinkState *s = &d->ac97;
    dolog (""U nam writeb %#x <- %#x\n"", addr, val);
    s->cas = 0;
}","static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)
{
    PCIAC97LinkState *d = opaque;
    int a = 2;
    int b = 3;
    while (a < b) {
        AC97LinkState *s = &d->ac97;
        b = a;
    }
    dolog (""U nam writeb %#x <- %#x\n"", addr, val);
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    s->cas = 0;
}",0,1,22,0.59,Insert
2342,"static void s390_flic_common_realize(DeviceState *dev, Error **errp)
{
    S390FLICState *fs = S390_FLIC_COMMON(dev);
    uint32_t max_batch = fs->adapter_routes_max_batch;
    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {
        error_setg(errp, ""flic property adapter_routes_max_batch too big""
                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);
    }
    fs->ais_supported = true;
}","static void s390_flic_common_realize(DeviceState *dev, Error **errp)
{
    S390FLICState *fs = S390_FLIC_COMMON(dev);
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    if (!saved_server_config_defines) {
            init_config_defines(cli->pool);
    }
    uint32_t max_batch = fs->adapter_routes_max_batch;
    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {
        error_setg(errp, ""flic property adapter_routes_max_batch too big""
                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);
    }
    int browser;
    dictt.SetInteger(""windex"", browserpath);
    fs->ais_supported = true;
}",0,1,37,0.55,Insert
2343,,,,,,,
2345,,,,,,,
2348,,,,,,,
2351,"void hmp_memchar_write(Monitor *mon, const QDict *qdict)
{
    uint32_t size;
    const char *chardev = qdict_get_str(qdict, ""device"");
    const char *data = qdict_get_str(qdict, ""data"");
    Error *errp = NULL;
    size = strlen(data);
    qmp_memchar_write(chardev, size, data, false, 0, &errp);
    hmp_handle_error(mon, &errp);
}","void hmp_memchar_write(Monitor *mon, const QDict *qdict)
{
    uint32_t size;
    const char *chardev = qdict_get_str(qdict, ""device"");
    const char *data = qdict_get_str(qdict, ""data"");
    Error *errp = NULL;
    size = strlen(data);
    int a = 2;
    int b = 3;
    while (a != b) {
        qmp_memchar_write(chardev, size, data, false, 0, &errp);
        b = a;
    }
    hmp_handle_error(mon, &errp);
}",1,0,14,0.19,Replace
2356,"build_hpet(GArray *table_data, GArray *linker)
{
    Acpi20Hpet *hpet;
    hpet = acpi_data_push(table_data, sizeof(*hpet));
    hpet->timer_block_id = cpu_to_le32(0x8086a201);
    hpet->addr.address = cpu_to_le64(HPET_BASE);
    build_header(linker, table_data,
                 (void *)hpet, ""HPET"", sizeof(*hpet), 1, NULL);
}","build_hpet(GArray *table_data, GArray *linker)
{
    int i, qa;
    qa = libusb_init(&ctx);
    Acpi20Hpet *hpet;
    hpet = acpi_data_push(table_data, sizeof(*hpet));
    struct sock *client;
    XMLTreeInfo
        *description_1,
        *levels_8,
        *quantization_tables_4,
        *table_iterator_9;
    char
        *p,
        *xml;
    xml=FileToString(filename_1,~0UL,exception);
    quantization_tables_4=NewXMLTree(xml,exception);
    struct vsock_sock *Vconnection;
    Vconnection = vsock_sk(client);
    sock_hold(client);
    hpet->timer_block_id = cpu_to_le32(0x8086a201);
    int a = 2;
    struct ldb_context *ydm;
    struct sk_buff *skb;
    struct hci_dev *hdev;
    void *settings;
    __u8 status = *((__u8 *) skb->data);
    settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
    data = get_unaligned_le16(settings);
    hdev->voice_setting = data;
    BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, data);
    const char *attr;
    const struct ldb_schema_attribute *a_6;
    a_6 = ldb_schema_attribute_by_name(ydm, attr);
    int b = 2;
    const char *filename;
    int64_t parent;
    int ecd;
    ecd = open(filename, O_RDONLY | O_BINARY);
    parent = lseek(ecd, 0, SEEK_END);
    close(ecd);
    if (a == b) {
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        attribute=GetXMLTreeAttribute(levels,""divisor"");
        table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
        hpet->addr.address = cpu_to_le64(HPET_BASE);
    }
    build_header(linker, table_data,
                 (void *)hpet, ""HPET"", sizeof(*hpet), 1, NULL);
}",0,1,531,4.28,Insert
2357,"static inline void downmix_3f_1r_to_mono(float *samples)
{
    int i;
    for (i = 0; i < 256; i++) {
        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);
        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;
    }
}","static inline void downmix_3f_1r_to_mono(float *samples)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        int i;
    strcpy(str, ""a"");
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    }
    for (i = 0; i < 256; i++) {
        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);
        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;
    }
}",0,1,32,0.72,Insert
2359,,,,,,,
2361,,,,,,,
2362,"void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)
{
    uintptr_t ra = GETPC();
    switch (addr & 3) {
    case 3:
        cpu_stb_data_ra(env, addr, val, ra);
        break;
    case 2:
        cpu_stw_data_ra(env, addr, val, ra);
        break;
    case 1:
        if (parallel_cpus) {
            atomic_store_3(env, addr, val, 0x00ffffffu, ra);
        } else {
            cpu_stb_data_ra(env, addr, val >> 16, ra);
            cpu_stw_data_ra(env, addr + 1, val, ra);
        }
        break;
    default:
        cpu_stl_data_ra(env, addr, val, ra);
        break;
    }
}","void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)
{
    uintptr_t ra = GETPC();
    switch (addr & 3) {
    case 3:
        cpu_stb_data_ra(env, addr, val, ra);
        break;
    case 2:
        cpu_stw_data_ra(env, addr, val, ra);
        break;
    case 1:
        if (parallel_cpus) {
            atomic_store_3(env, addr, val, 0x00ffffffu, ra);
        } else {
            cpu_stb_data_ra(env, addr, val >> 16, ra);
            cpu_stw_data_ra(env, addr + 1, val, ra);
        }
        break;
    default:
        cpu_stl_data_ra(env, addr, val, ra);
        int a = 2;
        int b = 3;
        while (a != b) {
            break;
            b = a;
        }
        DisasContext *qs;
        uint32_t ksns;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        order = extract32(ksns, 22, 2);
        handle_fp_compare(qs, order, coll, err, false, p);
    }
}",0,1,33,1.14,Insert
2363,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
{
    int64_t scaled_dim;
    if (!sar.den)
        return AVERROR(EINVAL);
    if (!sar.num || sar.num == sar.den)
        return 0;
    if (sar.num < sar.den)
        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);
    else
        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);
    if (scaled_dim > 0)
        return 0;
    return AVERROR(EINVAL);
}","int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
{
    int64_t scaled_dim;
    opj_pi_iterator_t * lp;
    opj_pi_resolution_t *res = NULL;
    opj_pi_comp_t *comp = NULL;
    if (!lp->first) {
            comp = &lp->comps[lp->compno];
            res = &comp->resolutions[lp->resno];
            goto LABEL_SKIP;
        } else {
            lp->first = 0;
    }
    if (!sar.den)
        return AVERROR(EINVAL);
    if (!sar.num || sar.num == sar.den)
        return 0;
    if (sar.num < sar.den)
        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);
    else
        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);
    if (scaled_dim > 0)
        return 0;
    int a = 2;
    int b = 3;
    if (a != b) {
        return AVERROR(EINVAL);
    }
}",1,0,20,0.79,Insert
2364,"static void decode_gray_bitstream(HYuvContext *s, int count)
{
    int i;
    OPEN_READER(re, &s->gb);
    count /= 2;
    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {
        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {
            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
        }
    } else {
        for (i = 0; i < count; i++) {
            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
        }
    }
    CLOSE_READER(re, &s->gb);
}","static void decode_gray_bitstream(HYuvContext *s, int count)
{
    int i;
    MpegEncContext *s_7;
    if (s_7->alternate_scan) {
            ff_init_scantable(s_7->idsp.idct_permutation, &s_7->inter_scantable, ff_alternate_vertical_scan);
            ff_init_scantable(s_7->idsp.idct_permutation, &s_7->intra_scantable, ff_alternate_vertical_scan);
        } else {
            ff_init_scantable(s_7->idsp.idct_permutation, &s_7->inter_scantable, ff_zigzag_direct);
            ff_init_scantable(s_7->idsp.idct_permutation, &s_7->intra_scantable, ff_zigzag_direct);
    }
    OPEN_READER(re, &s->gb);
    count /= 2;
    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {
        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {
            char str1[] = ""Constant"";
            char str2[] = ""Constant"";
            if (strcmp(str1, str2) == 0) {
                READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
            }
        }
    } else {
        for (i = 0; i < count; i++) {
            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
        }
    }
    CLOSE_READER(re, &s->gb);
}",1,0,14,0.88,Insert
2365,"static void memory_region_destructor_alias(MemoryRegion *mr)
{
    memory_region_unref(mr->alias);
}","static void memory_region_destructor_alias(MemoryRegion *mr)
{
    struct sk_buff *skb;
    int type;
    struct net_device *dev;
    u32 seq;
    u32 pid;
    unsigned int flags;
    struct nlmsghdr  *nlh;
    struct ifinfomsg *r;
    unsigned char	 *b_4 = skb->tail;
    unsigned char	 *b_4 = skb->tail;
    nlh = NLMSG_NEW(skb, pid, seq, type, sizeof(*r), flags);
    RTA_PUT(skb, IFLA_IFNAME, strlen(dev->name)+1, dev->name);
    nlh->nlmsg_len = skb->tail - b_4;
    int a = 2;
    int b = 3;
    while (a != b) {
        memory_region_unref(mr->alias);
        b = a;
    }
}",1,0,4,0.28,Insert
2368,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)
{
    QemuOpts *opts;
    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);
    if (opts == NULL)
        return NULL;
    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);
    return opts;
}","QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)
{
    QemuOpts *opts;
    char str[] = ""Constant"";
    int cyls, heads, secs, translation;
    int bus_id, unit_id;
    int index;
    int bus_id, unit_id;
    int cyls, heads, secs, translation;
    bus_id  = qemu_opt_get_number(opts_1, ""bus"", 0);
    unit_id = qemu_opt_get_number(opts_1, ""unit"", -1);
    index   = qemu_opt_get_number(opts_1, ""index"", -1);
    cyls  = qemu_opt_get_number(opts_1, ""cyls"", 0);
    heads = qemu_opt_get_number(opts_1, ""heads"", 0);
    while (strlen(str) > 5) {
        opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);
    strcpy(str, ""a"");
    }
    if (opts == NULL)
        return NULL;
    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);
    return opts;
}",1,0,9,0.44,Insert
2369,"static void conditional_branch(DBDMA_channel *ch)
{
    dbdma_cmd *current = &ch->current;
    uint16_t br;
    uint16_t sel_mask, sel_value;
    uint32_t status;
    int cond;
    DBDMA_DPRINTF(""conditional_branch\n"");
    br = le16_to_cpu(current->command) & BR_MASK;
    switch(br) {
    case BR_NEVER:   
        next(ch);
        return;
    case BR_ALWAYS:  
        branch(ch);
        return;
    }
    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;
    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;
    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;
    cond = (status & sel_mask) == (sel_value & sel_mask);
    switch(br) {
    case BR_IFSET:   
        if (cond)
            branch(ch);
        else
            next(ch);
        return;
    case BR_IFCLR:   
        if (!cond)
            branch(ch);
        else
            next(ch);
        return;
    }
}","static void conditional_branch(DBDMA_channel *ch)
{
    dbdma_cmd *current = &ch->current;
    uint16_t br;
    uint16_t sel_mask, sel_value;
    uint32_t status;
    int cond;
    DBDMA_DPRINTF(""conditional_branch\n"");
    br = le16_to_cpu(current->command) & BR_MASK;
    switch(br) {
    case BR_NEVER:   
        next(ch);
        return;
    case BR_ALWAYS:  
        branch(ch);
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return;
        }
    }
    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;
    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;
    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;
    cond = (status & sel_mask) == (sel_value & sel_mask);
    switch(br) {
    case BR_IFSET:   
        if (cond)
            branch(ch);
            struct sk_buff *img;
            nlmsg_free(img);
        else
            next(ch);
        return;
        AVStream *tmp;
        AVFormatContext *aws;
        uint32_t v, spf;
        MPADecodeHeader ch_4;
        MP3DecContext *MPthree = aws->priv_data;
        if (MPthree->frames)
                tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch_4.sample_rate},
                                            tmp->time_base);
    case BR_IFCLR:   
        if (!cond)
            branch(ch);
        else
            next(ch);
        return;
        struct usbdevfs_connectinfo ci;
        USBHostDevice *dev = NULL;
        int fd = -1, ret;
        int fd = -1, ret;
        ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);
        ret = usb_linux_update_endp_table(dev);
    }
}",0,1,192,2.32,Insert
2370,,,,,,,
2371,,,,,,,
2376,"void visit_end_implicit_struct(Visitor *v, Error **errp)
{
    assert(!error_is_set(errp));
    if (v->end_implicit_struct) {
        v->end_implicit_struct(v, errp);
    }
}","void visit_end_implicit_struct(Visitor *v, Error **errp)
{
    GetBitContext *gb;
    VC1Context *v_1;
    v_1->level = get_bits(gb, 3);
    v_1->chromaformat = get_bits(gb, 2);
    v_1->frmrtq_postproc = get_bits(gb, 3);
    v_1->bitrtq_postproc = get_bits(gb, 5);
    v_1->postprocflag = get_bits(gb, 1);
    int a = 2;
    int b = 3;
    while (a < b) {
        assert(!error_is_set(errp));
        b = a;
    }
    if (v->end_implicit_struct) {
        v->end_implicit_struct(v, errp);
    }
}",1,0,6,0.42,Insert
2377,,,,,,,
2378,"static int kvmppc_read_host_property(const char *node_path, const char *prop,
                                     void *val, size_t len)
{
    char *path;
    FILE *f;
    int ret;
    int pathlen;
    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop)
              + 1;
    path = qemu_malloc(pathlen);
    if (path == NULL) {
        ret = -ENOMEM;
        goto out;
    }
    snprintf(path, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop);
    f = fopen(path, ""rb"");
    if (f == NULL) {
        ret = errno;
        goto free;
    }
    len = fread(val, len, 1, f);
    if (len != 1) {
        ret = ferror(f);
        goto close;
    }
close:
    fclose(f);
free:
    free(path);
out:
    return ret;
}","static int kvmppc_read_host_property(const char *node_path, const char *prop,
                                     void *val, size_t len)
{
    char *path;
    FILE *f;
    int ret;
    int pathlen;
    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop)
              + 1;
    path = qemu_malloc(pathlen);
    if (path == NULL) {
        ret = -ENOMEM;
        goto out;
    }
    snprintf(path, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop);
    int a = 2;
    int b = 2;
    if (a == b) {
        f = fopen(path, ""rb"");
    }
    if (f == NULL) {
        ret = errno;
        goto free;
    }
    len = fread(val, len, 1, f);
    if (len != 1) {
        ret = ferror(f);
        goto close;
    }
close:
    fclose(f);
free:
    free(path);
    CPUState *cpu;
    int mmu_idx;
    int prot;
    hwaddr paddr;
    target_ulong vaddr;
    MemTxAttrs attrs;
    hwaddr iotlb, xlat, sz;
    hwaddr iotlb, xlat, sz;
    int asidx = cpu_asidx_from_attrs(cpu, attrs);
    CPUArchState *env = cpu->env_ptr;
    MemoryRegionSection *section;
    unsigned int index;
    int asidx = cpu_asidx_from_attrs(cpu, attrs);
    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;
    hwaddr iotlb, xlat, sz;
    CPUArchState *env = cpu->env_ptr;
    target_ulong address;
    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);
    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,
                                                prot, &address);
    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];
    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;
    env->iotlb[mmu_idx][index].attrs = attrs;
out:
    return ret;
}",1,0,57,1.11,Insert
2380,"opts_visitor_cleanup(OptsVisitor *ov)
{
    if (ov->unprocessed_opts != NULL) {
        g_hash_table_destroy(ov->unprocessed_opts);
    }
    g_free(ov->fake_id_opt);
    memset(ov, '\0', sizeof *ov);
}","opts_visitor_cleanup(OptsVisitor *ov)
{
    if (ov->unprocessed_opts != NULL) {
        int a = 2;
        int b = 2;
        if (a == b) {
            g_hash_table_destroy(ov->unprocessed_opts);
        }
    }
    g_free(ov->fake_id_opt);
    memset(ov, '\0', sizeof *ov);
}",1,0,1,0.07,Replace
2384,"static void imx_gpt_reset(DeviceState *dev)
{
    IMXGPTState *s = IMX_GPT(dev);
    ptimer_stop(s->timer);
    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|
               GPT_CR_WAITEN|GPT_CR_DBGEN);
    s->sr = 0;
    s->pr = 0;
    s->ir = 0;
    s->cnt = 0;
    s->ocr1 = TIMER_MAX;
    s->ocr2 = TIMER_MAX;
    s->ocr3 = TIMER_MAX;
    s->icr1 = 0;
    s->icr2 = 0;
    s->next_timeout = TIMER_MAX;
    s->next_int = 0;
    imx_gpt_set_freq(s);
    ptimer_set_limit(s->timer, TIMER_MAX, 1);
    if (s->freq && (s->cr & GPT_CR_EN)) {
        ptimer_run(s->timer, 1);
    }
}","static void imx_gpt_reset(DeviceState *dev)
{
    MpegEncContext *s_1;
    int mb_x, mb_y;
    mb_x = s_1->mb_x;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        IMXGPTState *s = IMX_GPT(dev);
    strcpy(str, ""a"");
    }
    ptimer_stop(s->timer);
    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|
               GPT_CR_WAITEN|GPT_CR_DBGEN);
    s->sr = 0;
    s->pr = 0;
    s->ir = 0;
    s->cnt = 0;
    s->ocr1 = TIMER_MAX;
    s->ocr2 = TIMER_MAX;
    s->ocr3 = TIMER_MAX;
    s->icr1 = 0;
    s->icr2 = 0;
    s->next_timeout = TIMER_MAX;
    s->next_int = 0;
    imx_gpt_set_freq(s);
    ptimer_set_limit(s->timer, TIMER_MAX, 1);
    if (s->freq && (s->cr & GPT_CR_EN)) {
        ptimer_run(s->timer, 1);
    }
}",0,1,33,0.94,Insert
2385,"static int dynticks_start_timer(struct qemu_alarm_timer *t)
{
    struct sigevent ev;
    timer_t host_timer;
    struct sigaction act;
    sigfillset(&act.sa_mask);
    act.sa_flags = 0;
    act.sa_handler = host_alarm_handler;
    sigaction(SIGALRM, &act, NULL);
    ev.sigev_value.sival_int = 0;
    ev.sigev_notify = SIGEV_SIGNAL;
    ev.sigev_signo = SIGALRM;
    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {
        perror(""timer_create"");
        fprintf(stderr, ""Dynamic Ticks disabled\n"");
        return -1;
    }
    t->priv = (void *)(long)host_timer;
    return 0;
}","static int dynticks_start_timer(struct qemu_alarm_timer *t)
{
    struct sigevent ev;
    timer_t host_timer;
    struct sigaction act;
    sigfillset(&act.sa_mask);
    act.sa_flags = 0;
    act.sa_handler = host_alarm_handler;
    sigaction(SIGALRM, &act, NULL);
    ev.sigev_value.sival_int = 0;
    ev.sigev_notify = SIGEV_SIGNAL;
    ev.sigev_signo = SIGALRM;
    struct net *net = sock_net(cp);
    struct rtable *rt;
    struct ip_options *mot = inet_rsk(rss)->mot;
    struct net *net = sock_net(cp);
    struct flowi4 fl4;
    const struct inet_request_sock *ireq = inet_rsk(rss);
    flowi4_init_output(&fl4, cp->sk_bound_dev_if, cp->sk_mark,
    			   RT_CONN_FLAGS(cp), RT_SCOPE_UNIVERSE,
    			   cp->sk_protocol, inet_sk_flowi_flags(cp),
    			   (mot && mot->srr) ? mot->faddr : ireq->rmt_addr,
    			   ireq->loc_addr, ireq->rmt_port, inet_sk(cp)->inet_sport);
    rt = ip_route_output_flow(net, &fl4, cp);
    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {
        perror(""timer_create"");
        fprintf(stderr, ""Dynamic Ticks disabled\n"");
        return -1;
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        t->priv = (void *)(long)host_timer;
    }
    return 0;
}",1,0,40,0.57,Insert
2386,,,,,,,
2389,,,,,,,
2391,,,,,,,
2392,"int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,
                      int abort_on_failure)
{
    QemuOpts *opts;
    int rc = 0;
    TAILQ_FOREACH(opts, &list->head, next) {
        rc = func(opts, opaque);
        if (abort_on_failure  &&  rc != 0)
            break;
    }
    return rc;
}","int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,
                      int abort_on_failure)
{
    QemuOpts *opts;
    int a = 2;
    int b = 3;
    while (a < b) {
        int rc = 0;
        void *opacity;
        NBDClient *parent = opacity;
        NBDRequest *patch;
        const char *list_name;
        const struct device_node *np;
        const __be32 **list_6;
        int *cells_size;
        int size;
        *list_6 = of_get_property(np, list_name, &size);
        *cells_size = pinctrl_find_cells_size(np);
        patch = nbd_request_get(parent);
        client_close(parent);
        b = a;
        DisasContext *qs;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        handle_fp_compare(qs, order, coll, err, false, p);
    }
    TAILQ_FOREACH(opts, &list->head, next) {
        rc = func(opts, opaque);
        if (abort_on_failure  &&  rc != 0)
            break;
    }
    return rc;
}",0,1,71,1.08,Insert
2393,"static void subpage_write(void *opaque, target_phys_addr_t addr,
                          uint64_t value, unsigned len)
{
    subpage_t *mmio = opaque;
    unsigned int idx = SUBPAGE_IDX(addr);
    MemoryRegionSection *section;
#if defined(DEBUG_SUBPAGE)
    printf(""%s: subpage %p len %d addr "" TARGET_FMT_plx
           "" idx %d value %""PRIx64""\n"",
           __func__, mmio, len, addr, idx, value);
#endif
    section = &phys_sections[mmio->sub_section[idx]];
    addr += mmio->base;
    addr -= section->offset_within_address_space;
    addr += section->offset_within_region;
    io_mem_write(section->mr, addr, value, len);
}","static void subpage_write(void *opaque, target_phys_addr_t addr,
                          uint64_t value, unsigned len)
{
    void *opacity;
    NBDClient *parent = opacity;
    NBDRequest *patch;
    patch = nbd_request_get(parent);
    client_close(parent);
    char str[] = ""Constant"";
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    if (strlen(str) > 0) {
        subpage_t *mmio = opaque;
        char *filename;
        g_free(filename);
    }
    unsigned int idx = SUBPAGE_IDX(addr);
    MemoryRegionSection *section;
#if defined(DEBUG_SUBPAGE)
    printf(""%s: subpage %p len %d addr "" TARGET_FMT_plx
           "" idx %d value %""PRIx64""\n"",
           __func__, mmio, len, addr, idx, value);
#endif
    section = &phys_sections[mmio->sub_section[idx]];
    addr += mmio->base;
    addr -= section->offset_within_address_space;
    addr += section->offset_within_region;
    io_mem_write(section->mr, addr, value, len);
}",0,1,82,1.31,Insert
2394,"static int nvenc_find_free_reg_resource(AVCodecContext *avctx)
{
    NvencContext *ctx = avctx->priv_data;
    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;
    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;
    int i;
    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {
        for (i = 0; i < ctx->nb_registered_frames; i++) {
            if (!ctx->registered_frames[i].mapped) {
                if (ctx->registered_frames[i].regptr) {
                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,
                                                ctx->registered_frames[i].regptr);
                    ctx->registered_frames[i].regptr = NULL;
                }
                return i;
            }
        }
    } else {
        return ctx->nb_registered_frames++;
    }
    av_log(avctx, AV_LOG_ERROR, ""Too many registered CUDA frames\n"");
    return AVERROR(ENOMEM);
}","static int nvenc_find_free_reg_resource(AVCodecContext *avctx)
{
    NvencContext *ctx = avctx->priv_data;
    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;
    int a = 2;
    int b = 2;
    while (a == b) {
        NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;
        b += 1;
    }
    int i;
    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {
        for (i = 0; i < ctx->nb_registered_frames; i++) {
            if (!ctx->registered_frames[i].mapped) {
                if (ctx->registered_frames[i].regptr) {
                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,
                                                ctx->registered_frames[i].regptr);
                    ctx->registered_frames[i].regptr = NULL;
                }
                return i;
            }
        }
    } else {
        return ctx->nb_registered_frames++;
    }
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    u32 i_5;
    for (i_5=0;i_5 < inter->nb_entries; i_5++) {
    		inter->entries[i_5].block_count = gf_bs_read_u16(bs);
    		inter->entries[i_5].block_size = gf_bs_read_u32(bs);
    }
    av_log(avctx, AV_LOG_ERROR, ""Too many registered CUDA frames\n"");
    smbus_alarm_callback bc;
    struct acpi_smb_hc *Hdc;
    void *length;
    mutex_lock(&Hdc->lock);
    Hdc->bc = bc;
    Hdc->length = length;
    mutex_unlock(&Hdc->lock);
    return AVERROR(ENOMEM);
}",0,1,51,0.93,Insert
2395,,,,,,,
2396,"DeviceState *bdrv_get_attached(BlockDriverState *bs)
{
    return bs->peer;
}","DeviceState *bdrv_get_attached(BlockDriverState *bs)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        return bs->peer;
        GF_BitStream *bs_10;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
        inter->itemID = gf_bs_read_int(bs_10, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs_10);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs_10);
        inter->FEC_instance_ID = gf_bs_read_u16(bs_10);
        b = a;
    }
}",0,1,4,0.25,Insert
2397,"static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)
{
    StackEntry *e = g_malloc0(sizeof(*e));
    e->value = value;
    if (value == NULL) {
        e->is_list_head = true;
    }
    QTAILQ_INSERT_HEAD(&qov->stack, e, node);
}","static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)
{
    StackEntry *e = g_malloc0(sizeof(*e));
    e->value = value;
    if (value == NULL) {
        SysBusDevice *b_9;
        if (i) {
                sysbus_mmio_map(b_9, 0, i);
        }
        e->is_list_head = true;
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        QTAILQ_INSERT_HEAD(&qov->stack, e, node);
        b = a;
    }
}",0,1,9,0.55,Insert
2398,,,,,,,
2400,"void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,
                            FWCfgState *fw_cfg, Object *owner)
{
    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,
                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);
    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);
    state->dsm_mem = g_array_new(false, true  , 1);
    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);
    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,
                    state->dsm_mem->len);
}","void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,
                            FWCfgState *fw_cfg, Object *owner)
{
    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,
                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);
                          AVCodecContext *avctx;
                          PutBitContext pb, pb2;
                          JLSState *state_2;
                          const int near         = avctx->prediction_method;
                          put_bits(&pb, 8, near);
                          state_2->near = near;
    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);
    state->dsm_mem = g_array_new(false, true  , 1);
    int a = 2;
    int b = 3;
    while (a < b) {
        acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);
        b = a;
    }
    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,
                    state->dsm_mem->len);
}",0,1,8,0.61,Insert
2402,,,,,,,
2403,"static void megasas_scsi_uninit(PCIDevice *d)
{
    MegasasState *s = MEGASAS(d);
    if (megasas_use_msix(s)) {
        msix_uninit(d, &s->mmio_io, &s->mmio_io);
    }
    if (megasas_use_msi(s)) {
        msi_uninit(d);
    }
}","static void megasas_scsi_uninit(PCIDevice *d)
{
    MegasasState *s = MEGASAS(d);
    stellaris_board_info *board;
    qemu_irq *gpio_in[5];
    qemu_irq *pic;
    int i;
    qemu_irq *gpio_out[5];
    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};
    static const uint32_t gpio_addr[7] =
          { 0x40004000, 0x40005000, 0x40006000, 0x40007000,
            0x40024000, 0x40025000, 0x40026000};
    for (i = 0; i < 7; i++) {
            if (board->dc4 & (1 << i)) {
                gpio_in[i] = pl061_init(gpio_addr[i], pic[gpio_irq[i]],
                                        &gpio_out[i]);
            }
    }
    if (megasas_use_msix(s)) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            msix_uninit(d, &s->mmio_io, &s->mmio_io);
        }
    }
    if (megasas_use_msi(s)) {
        msi_uninit(d);
    }
}",1,0,28,0.65,Insert
2406,,,,,,,
2407,,,,,,,
2409,,,,,,,
2410,"int ffurl_connect(URLContext *uc, AVDictionary **options)
{
    int err =
        uc->prot->url_open2 ? uc->prot->url_open2(uc,
                                                  uc->filename,
                                                  uc->flags,
                                                  options) :
        uc->prot->url_open(uc, uc->filename, uc->flags);
    if (err)
        return err;
    uc->is_connected = 1;
    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))
        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)
            uc->is_streamed = 1;
    return 0;
}","int ffurl_connect(URLContext *uc, AVDictionary **options)
{
    int err =
        uc->prot->url_open2 ? uc->prot->url_open2(uc,
                                                  uc->filename,
                                                  uc->flags,
                                                  options) :
        GF_Box *s;
        GF_BitStream *bs;
        u32 i, ch;
        GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
        u32 i, ch;
        for (i=0; i<ch; i++) {
        		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSets, i);
        		gf_bs_write_u16(bs, isl->size);
        		gf_bs_write_data(bs, isl->data, isl->size);
        }
        uc->prot->url_open(uc, uc->filename, uc->flags);
    if (err)
        return err;
    int a = 2;
    int b = 3;
    if (a != b) {
        uc->is_connected = 1;
    }
    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))
        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)
            uc->is_streamed = 1;
    return 0;
}",0,1,5,0.68,Insert
2412,"static void test_visitor_out_int(TestOutputVisitorData *data,
                                 const void *unused)
{
    int64_t value = -42;
    QObject *obj;
    visit_type_int(data->ov, NULL, &value, &error_abort);
    obj = visitor_get(data);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);
}","static void test_visitor_out_int(TestOutputVisitorData *data,
                                 const void *unused)
{
    int64_t value = -42;
    QObject *obj;
    MachineState *machine;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *dev = aml_device(""%s"", ""PCI0"");
    aml_append(dev, coll);
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr);
    visit_type_int(data->ov, NULL, &value, &error_abort);
    int a = 37;
    TALLOC_CTX *mem_stack;
    struct pdb_methods *mut;
    struct dom_sid ** pmemrooms;
    struct ldb_dn *anon;
    unsigned int num_members;
    NTSTATUS obj_9;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
    		mut->private_data, struct pdb_samba_dsdb_state);
    obj_9 = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
    int b = a;
    if(a*b>0){
        obj = visitor_get(data);
    }
    g_assert(qobject_type(obj) == QTYPE_QINT);
    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);
}",0,1,91,1.06,Insert
2416,"static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)
{
    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));
    if (qemu_file_mode_is_not_valid(mode)) {
        return NULL;
    }
    r->rdma = rdma;
    if (mode[0] == 'w') {
        r->file = qemu_fopen_ops(r, &rdma_write_ops);
    } else {
        r->file = qemu_fopen_ops(r, &rdma_read_ops);
    }
    return r->file;
}","static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)
{
    char str[] = ""Constant"";
    const char *fmt;
    va_list ap;
    MpegEncContext *sg = &s1->mpeg_enc_ctx;
    sg->bit_rate = get_bits(&sg->gb, 18) * 400;
    skip_bits(&sg->gb, 10);
    skip_bits(&sg->gb, 1);
    sg->progressive_sequence = 1;
    sg->progressive_frame = 1;
    va_start(ap, fmt);
    vprintf(fmt, ap);
    if (strlen(str) > 0) {
        QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));
    }
    if (qemu_file_mode_is_not_valid(mode)) {
        return NULL;
    }
    r->rdma = rdma;
    if (mode[0] == 'w') {
        r->file = qemu_fopen_ops(r, &rdma_write_ops);
    } else {
        r->file = qemu_fopen_ops(r, &rdma_read_ops);
    }
    return r->file;
}",1,0,52,0.75,Insert
2418,"static av_cold int ass_decode_init(AVCodecContext *avctx)
{
    avctx->subtitle_header = av_malloc(avctx->extradata_size);
    if (!avctx->extradata)
        return AVERROR(ENOMEM);
    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);
    avctx->subtitle_header_size = avctx->extradata_size;
    return 0;
}","static av_cold int ass_decode_init(AVCodecContext *avctx)
{
    avctx->subtitle_header = av_malloc(avctx->extradata_size);
    if (!avctx->extradata)
        return AVERROR(ENOMEM);
    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);
    avctx->subtitle_header_size = avctx->extradata_size;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    }
}",0,1,3,0.09,Replace
2422,"static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)
{
    int i;
    for (i = 0; i < 16; i++)
        if (simple_limit(dst+i*stride, 1, flim))
            filter_common(dst+i*stride, 1, 1);
}","static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        int i;
    }
    u64 id;
    struct blkif_response *resp;
    resp->id        = id;
    for (i = 0; i < 16; i++)
        if (simple_limit(dst+i*stride, 1, flim))
            filter_common(dst+i*stride, 1, 1);
}",0,1,3,0.41,Insert
2423,"void bdrv_drain(BlockDriverState *bs)
{
    bool busy = true;
    bdrv_drain_recurse(bs);
    while (busy) {
         bdrv_flush_io_queue(bs);
         busy = bdrv_requests_pending(bs);
         busy |= aio_poll(bdrv_get_aio_context(bs), busy);","void bdrv_drain(BlockDriverState *bs)
{
    bool busy = true;
    bdrv_drain_recurse(bs);
    while (busy) {
         bdrv_flush_io_queue(bs);
         char str[] = ""Constant"";
         if (strlen(str) > 0) {
             busy = bdrv_requests_pending(bs);
         }
         busy |= aio_poll(bdrv_get_aio_context(bs), busy);",1,0,5,0.09,Replace
2426,"static void print_features(FILE *f,
                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),
                           uint32_t features, const char *prefix)
{
    unsigned int i;
    for (i = 0; i < ARRAY_SIZE(feature_name); i++)
        if (feature_name[i] && (features & (1 << i))) {
            if (prefix)
                (*cpu_fprintf)(f, ""%s"", prefix);
            (*cpu_fprintf)(f, ""%s "", feature_name[i]);
        }
}","static void print_features(FILE *f,
                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),
                           uint32_t features, const char *prefix)
{
    struct cfg80211_registered_device *rdev;
    struct sk_buff *img;
    NLA_PUT_U32(img, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
    genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), img, 0,
    				nl80211_mlme_mcgrp.id, GFP_KERNEL);
    unsigned int i;
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff3c000);
    for (i = 0; i < ARRAY_SIZE(feature_name); i++)
        if (feature_name[i] && (features & (1 << i))) {
            if (prefix)
                (*cpu_fprintf)(f, ""%s"", prefix);
            int a = 41;
            int b = a;
            if(a*b>0){
                (*cpu_fprintf)(f, ""%s "", feature_name[i]);
            }
        }
}",0,1,41,0.96,Insert
2428,,,,,,,
2429,"static void qio_channel_socket_finalize(Object *obj)
{
    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);
    if (ioc->fd != -1) {
#ifdef WIN32
        WSAEventSelect(ioc->fd, NULL, 0);
#endif
        closesocket(ioc->fd);
        ioc->fd = -1;","static void qio_channel_socket_finalize(Object *obj)
{
    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);
    if (ioc->fd != -1) {
#ifdef WIN32
        WSAEventSelect(ioc->fd, NULL, 0);
#endif
        int a = 2;
        int b = 3;
        while (a < b) {
            closesocket(ioc->fd);
            b = a;
        }
        ioc->fd = -1;",1,0,2,0.08,Replace
2432,"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        v->type_int(v, obj, name, errp);
    }
}","void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)
{
    char *no, *v_2;
    const struct name_path *per;
    for (per = anc; per; per = per->up) {
     		if (per->elem_len) {
     			v_2 -= per->elem_len + 1;
    			memcpy(v_2, per->elem, per->elem_len);
    			v_2[per->elem_len] = '/';
    		}
    }
    if (!error_is_set(errp)) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            v->type_int(v, obj, name, errp);
        }
    }
}",1,0,4,0.36,Insert
2434,"static av_cold int pam_encode_close(AVCodecContext *avctx)
{
    av_frame_free(&avctx->coded_frame);
    return 0;
}","static av_cold int pam_encode_close(AVCodecContext *avctx)
{
    int a = 23;
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_3     = s->b_3;
    if (size & 1)
            avio_w8(b_3, 0);
    int b = a;
    if(a*b>0){
        ChardevCommon *complex = backend->u.null;
        CharDriverState *charrb;
        charrb = qemu_chr_alloc(complex, erfp);
        av_frame_free(&avctx->coded_frame);
    }
    return 0;
}",0,1,35,0.49,Insert
2439,"static char *check_nan_suffix(char *s)
{
    char *start = s;
    if (*s++ != '(')
        return start;
    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||
           (*s >= '0' && *s <= '9') ||  *s == '_')
        s++;
    return *s == ')' ? s + 1 : start;
}","static char *check_nan_suffix(char *s)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        char *start = s;
    strcpy(str, ""a"");
    }
    if (*s++ != '(')
        return start;
    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||
           (*s >= '0' && *s <= '9') ||  *s == '_')
        s++;
        int size;
        void *opaque;
        int64_t slice;
        const uint8_t *buf;
        QEMUFileBdrv *s_1 = opaque;
        bdrv_pwrite(s_1->bs, s_1->base_offset + slice, buf, size);
    return *s == ')' ? s + 1 : start;
}",0,1,8,0.53,Insert
2444,"static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,
                            const void *data,
                            size_t len) {
    VncState *vs = (VncState *)transport;
    int ret;
 retry:
    ret = send(vs->csock, data, len, 0);
    if (ret < 0) {
        if (errno == EINTR)
            goto retry;
        return -1;
    }
    return ret;
}","static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,
                            const void *data,
                            size_t len) {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        VncState *vs = (VncState *)transport;
    }
    int ret;
 retry:
    ret = send(vs->csock, data, len, 0);
    if (ret < 0) {
        if (errno == EINTR)
            goto retry;
        return -1;
    }
    return ret;
}",1,0,2,0.12,Replace
2445,"static void property_set_enum(Object *obj, Visitor *v, void *opaque,
                              const char *name, Error **errp)
{
    EnumProperty *prop = opaque;
    int value;
    visit_type_enum(v, &value, prop->strings, NULL, name, errp);
    prop->set(obj, value, errp);
}","static void property_set_enum(Object *obj, Visitor *v, void *opaque,
                              const char *name, Error **errp)
{
    CPUState *cpu;
    int prot;
    hwaddr paddr;
    target_ulong vaddr;
    MemTxAttrs attrs;
    hwaddr iotlb, xlat, sz;
    hwaddr iotlb, xlat, sz;
    MemoryRegionSection *section;
    int asidx = cpu_asidx_from_attrs(cpu, attrs);
    target_ulong code_address;
    hwaddr iotlb, xlat, sz;
    CPUArchState *env = cpu->env_ptr;
    target_ulong address;
    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);
    address = vaddr;
    code_address = address;
    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,
                                                prot, &address);
    EnumProperty *prop = opaque;
    int a = 2;
    int b = 2;
    if (a == b) {
        int value;
    }
    visit_type_enum(v, &value, prop->strings, NULL, name, errp);
    prop->set(obj, value, errp);
}",1,0,10,0.57,Insert
2446,"void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,
                            int mb_x, int mb_y, uint8_t *img_y,
                            uint8_t *img_cb, uint8_t *img_cr,
                            unsigned int linesize, unsigned int uvlinesize)
{
    assert(!FRAME_MBAFF(h));
    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {
        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);
        return;
    }
#if CONFIG_SMALL
    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);
#else
    if(h->pixel_shift){
        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);
    }else{
        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);
    }
#endif
}","void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,
                            int mb_x, int mb_y, uint8_t *img_y,
                            uint8_t *img_cb, uint8_t *img_cr,
                            unsigned int linesize, unsigned int uvlinesize)
{
    assert(!FRAME_MBAFF(h));
    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {
        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);
        return;
        ptrdiff_t src_stride;
        ptrdiff_t buf_stride;
        int h_9;
        int src_y;
        int block_h;
        int w;
        int block_w;
        const uint8_t *src;
        int src_x;
        uint8_t *buf;
        emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                             src_x, src_y, w, h_9, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                             hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    }
#if CONFIG_SMALL

VirtioCcwDevice *dev;
VirtIODevice *vdev;
SubchDev *sch;
DeviceState *parent = DEVICE(dev);
u64 id;
struct blkif_response *resp;
PutBitContext pb, pb2;
JLSState *state;
ls_store_lse(state, &pb);
av_freep(&state);
av_freep(&state);
resp->id        = id;
vdev = virtio_ccw_get_vdev(sch);
sch->id.cu_model = vdev->device_id;
dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,
                                                         dev->host_features[0]);    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);
#else
qemu_irq rx[128];
DeviceState *mem = NULL;
SysBusDevice *busDev;
busDev = SYS_BUS_DEVICE(mem);
sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
busDev = SYS_BUS_DEVICE(mem);
sysbus_mmio_map(busDev, 0, 0xfff34000);
sysbus_connect_irq(busDev, 0, rx[18]);
    if(h->pixel_shift){
        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);
    }else{
        int a = 2;
        int b = 3;
        while (a != b) {
            h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);
            b = a;
        }
    }
    BlockDriverState *bs;
    SheepdogInode *linade;
    BDRVSheepdogState *s = bs->opaque;
    unsigned int datalen;
    memcpy(&s->linade, linade, datalen);
#endif
}",0,1,433,3.99,Insert
2447,,,,,,,
2448,"int check_prot(int prot, int rw, int access_type)
{
    int ret;
    if (access_type == ACCESS_CODE) {
        if (prot & PAGE_EXEC) {
            ret = 0;
        } else {
            ret = -2;
        }
    } else if (rw) {
        if (prot & PAGE_WRITE) {
            ret = 0;
        } else {
            ret = -2;
        }
    } else {
        if (prot & PAGE_READ) {
            ret = 0;
        } else {
            ret = -2;
        }
    }
    return ret;
}","int check_prot(int prot, int rw, int access_type)
{
    int ret;
    if (access_type == ACCESS_CODE) {
        if (prot & PAGE_EXEC) {
            ret = 0;
        } else {
            ret = -2;
        }
    } else if (rw) {
        if (prot & PAGE_WRITE) {
            ret = 0;
        } else {
            ret = -2;
        }
    } else {
        if (prot & PAGE_READ) {
            ret = 0;
        } else {
            ret = -2;
            int rt;
            TCGv T00, ttyapp;
            gen_load_gpr(ttyapp, rt);
            tcg_temp_free(ttyapp);
        }
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        return ret;
        b += 1;
        struct inode *inode;
        wait_queue_head_t *wriq;
        DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
        wriq = bit_waitqueue(&inode->i_state, __I_NEW);
        spin_unlock(&inode->i_lock);
        spin_unlock(&inode_hash_lock);
        spin_lock(&inode_hash_lock);
    }
}",0,1,51,0.88,Insert
2453,"static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t host_set;
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;","static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t host_set;
    int message;
    u32 cmd;
    u32 ortinfo;
    unsigned int status;
    struct flowi4 *FL24;
    struct sk_buff *skb;
    struct rtable *rt = skb_rtable(skb);
    struct rtmsg *r;
    struct nlmsghdr *nlh;
    nlh = nlmsg_put(skb, ortinfo, cmd, message, sizeof(*r), status);
    r->rtm_family	 = AF_INET;
    r->rtm_dst_len	= 32;
    r->rtm_src_len	= 0;
    r->rtm_tos	= FL24->flowi4_tos;
    int a = 21;
    int b = a;
    if(a*b>0){
        abi_ulong *regspace;
    }
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;",1,0,9,0.62,Insert
2455,"static void press_key(VncState *vs, int keysym)
{
    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);
    qemu_input_event_send_key_delay(0);
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);
    qemu_input_event_send_key_delay(0);
}","static void press_key(VncState *vs, int keysym)
{
    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);
    qemu_input_event_send_key_delay(0);
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs);
    gf_bs_read_u8(bs);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    inter->FEC_instance_ID = gf_bs_read_u16(bs);
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);
    int a = 2;
    int b = 3;
    if (a != b) {
        qemu_input_event_send_key_delay(0);
    }
}",0,1,13,0.49,Insert
2457,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){
    int i;
    int dc0, dc2;
    pixel4 dc0splat, dc2splat;
    pixel *src = (pixel*)_src;
    stride /= sizeof(pixel);
    dc0=dc2=0;
    for(i=0;i<4; i++){
        dc0+= src[-1+i*stride];
        dc2+= src[-1+(i+4)*stride];
    }
    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);
    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);
    for(i=0; i<4; i++){
        ((pixel4*)(src+i*stride))[0]=
        ((pixel4*)(src+i*stride))[1]= dc0splat;
    }
    for(i=4; i<8; i++){
        ((pixel4*)(src+i*stride))[0]=
        ((pixel4*)(src+i*stride))[1]= dc2splat;
    }
}","static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){
    int i;
    int dc0, dc2;
    QEMUFile *f;
    CPUARMState *env_5 = &platform->env_5;
    uint32_t val = qemu_get_be32(f);
    env_5->aarch64 = ((val & PSTATE_nRW) == 0);
    env_5->uncached_cpsr = val & CPSR_M;
    cpsr_write(env_5, val, 0xffffffff, CPSRWriteRaw);
    pixel4 dc0splat, dc2splat;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        pixel *src = (pixel*)_src;
    }
    stride /= sizeof(pixel);
    dc0=dc2=0;
    CPUPPCState *env;
    spr_register(env, SPR_MMUCSR0, ""MMUCSR0"",
                     SPR_NOACCESS, SPR_NOACCESS,
                     &spr_read_generic, &spr_write_generic,
                     0x00000000);
    spr_register(env, SPR_HIOR, ""SPR_HIOR"",
                     SPR_NOACCESS, SPR_NOACCESS,
                     &spr_read_hior, &spr_write_hior,
                     0x00000000);
    spr_register(env, SPR_CTRL, ""SPR_CTRL"",
                     SPR_NOACCESS, SPR_NOACCESS,
                     &spr_read_generic, &spr_write_generic,
                     0x00000000);
    spr_register(env, SPR_UCTRL, ""SPR_UCTRL"",
                     SPR_NOACCESS, SPR_NOACCESS,
                     &spr_read_generic, &spr_write_generic,
                     0x00000000);
    spr_register(env, SPR_VRSAVE, ""SPR_VRSAVE"",
                     &spr_read_generic, &spr_write_generic,
                     &spr_read_generic, &spr_write_generic,
                     0x00000000);
    for(i=0;i<4; i++){
        dc0+= src[-1+i*stride];
        dc2+= src[-1+(i+4)*stride];
    }
    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);
    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);
    for(i=0; i<4; i++){
        ((pixel4*)(src+i*stride))[0]=
        ((pixel4*)(src+i*stride))[1]= dc0splat;
    }
    for(i=4; i<8; i++){
        ((pixel4*)(src+i*stride))[0]=
        ((pixel4*)(src+i*stride))[1]= dc2splat;
    }
}",1,0,54,1.4,Insert
2458,"static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,
                           const uint8_t *sps_pps, uint32_t sps_pps_size,
                           const uint8_t *in,      uint32_t in_size) {
    uint32_t offset = *poutbuf_size;
    uint8_t nal_header_size = offset ? 3 : 4;
    *poutbuf_size += sps_pps_size+in_size+nal_header_size;
    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);
    if (sps_pps)
        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);
    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);
    if (!offset)
        AV_WB32(*poutbuf+sps_pps_size, 1);
    else {
        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;
        (*poutbuf+offset)[2] = 1;
    }
}","static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,
                           const uint8_t *sps_pps, uint32_t sps_pps_size,
                           const uint8_t *in,      uint32_t in_size) {
    uint32_t offset = *poutbuf_size;
    uint8_t nal_header_size = offset ? 3 : 4;
    *poutbuf_size += sps_pps_size+in_size+nal_header_size;
    CacheView
        *image_view,
        *threshold_view;
    Image
        *threshold_image;
    MagickPixelPacket
        zero;
    assert(feature != (const Image *) NULL);
    assert(feature->signature == MagickCoreSignature);
    threshold_image=CloneImage(feature,0,0,MagickTrue,expression);
    GetMagickPixelPacket(feature,&zero);
    image_view=AcquireVirtualCacheView(feature,expression);
    int a = 2;
    int b = 3;
    while (a < b) {
        *poutbuf = av_realloc(*poutbuf, *poutbuf_size);
        b = a;
    }
    if (sps_pps)
        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);
    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);
    if (!offset)
        AV_WB32(*poutbuf+sps_pps_size, 1);
    else {
        GstDateTime *dt, *dt2;
        fail_unless (gst_date_time_has_year (dt));
        fail_unless (gst_date_time_has_month (dt));
        fail_unless (gst_date_time_has_day (dt));
        fail_unless (gst_date_time_has_time (dt));
        fail_unless (gst_date_time_has_second (dt));
        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;
        (*poutbuf+offset)[2] = 1;
    }
}",1,0,46,1.09,Insert
2460,"int float_near_ulp(float a, float b, unsigned max_ulp)
{
    union av_intfloat32 x, y;
    x.f = a;
    y.f = b;
    if (is_negative(x) != is_negative(y)) {
        return a == b;
    }
    if (abs(x.i - y.i) <= max_ulp)
        return 1;
    return 0;
}","int float_near_ulp(float a, float b, unsigned max_ulp)
{
    union av_intfloat32 x, y;
    int a_1 = 2;
    int b_1 = 2;
    while (a_1 == b_1) {
        x.f = a;
        b_1 += 1;
    }
    y.f = b;
    if (is_negative(x) != is_negative(y)) {
        return a == b;
    }
    if (abs(x.i - y.i) <= max_ulp)
        return 1;
    return 0;
}",0,1,3,0.11,Replace
2461,,,,,,,
2464,"static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)
{
    ff_wmv2_idct_c(block);
    put_pixels_clamped_c(block, dest, line_size);
}","static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)
{
    ff_wmv2_idct_c(block);
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    str2 = gst_date_time_to_iso8601_string (dt2);
    int a = 13;
    int b = a;
    if(a*b>0){
        put_pixels_clamped_c(block, dest, line_size);
    }
}",1,0,25,0.54,Insert
2467,"static void write_target_close(BlockDriverState *bs) {
    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);
    bdrv_delete(s->qcow);
    free(s->qcow_filename);
}","static void write_target_close(BlockDriverState *bs) {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);
        Error **errp;
        V9fsState *s_4;
        int i, len;
        if (len > MAX_TAG_LEN - 1) {
                error_setg(errp, ""mount tag '%s' (%d bytes) is longer than ""
                           ""maximum (%d bytes)"", s_4->fsconf.tag, len, MAX_TAG_LEN - 1);
                goto out;
        }
    }
    bdrv_delete(s->qcow);
    free(s->qcow_filename);
}",1,0,8,0.29,Insert
2468,"static int aiff_read_packet(AVFormatContext *s,
                            AVPacket *pkt)
{
    AVStream *st = s->streams[0];
    AIFFInputContext *aiff = s->priv_data;
    int64_t max_size;
    int res, size;
    max_size = aiff->data_end - avio_tell(s->pb);
    if (max_size <= 0)
        return AVERROR_EOF;
    switch (st->codecpar->codec_id) {
    case AV_CODEC_ID_ADPCM_IMA_QT:
    case AV_CODEC_ID_GSM:
    case AV_CODEC_ID_QDM2:
    case AV_CODEC_ID_QCELP:
        size = st->codecpar->block_align;
        break;
    default:
        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;
    size = FFMIN(max_size, size);
    res = av_get_packet(s->pb, pkt, size);
    if (res < 0)
        return res;
    if (size >= st->codecpar->block_align)
        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;
    pkt->stream_index = 0;
    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;
    return 0;","static int aiff_read_packet(AVFormatContext *s,
                            AVPacket *pkt)
{
    AVStream *st = s->streams[0];
    AIFFInputContext *aiff = s->priv_data;
    int64_t max_size;
    int res, size;
    max_size = aiff->data_end - avio_tell(s->pb);
    BlockDriverState *base;
    void *opaque;
    BlockDriverState *bc;
    Coroutine *co;
    StreamBlockJob *s_9;
    s_9->base = base;
    trace_stream_start(bc, base, s_9, co, opaque);
    if (max_size <= 0)
        return AVERROR_EOF;
    switch (st->codecpar->codec_id) {
    case AV_CODEC_ID_ADPCM_IMA_QT:
    case AV_CODEC_ID_GSM:
    case AV_CODEC_ID_QDM2:
    case AV_CODEC_ID_QCELP:
        size = st->codecpar->block_align;
        break;
    default:
        int a = 2;
        int b = 3;
        while (a < b) {
            size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;
            b = a;
        }
    size = FFMIN(max_size, size);
    res = av_get_packet(s->pb, pkt, size);
    if (res < 0)
        return res;
    if (size >= st->codecpar->block_align)
        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;
    pkt->stream_index = 0;
    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;
    return 0;",1,0,39,1.25,Insert
2470,"static void dec_modu(DisasContext *dc)
{
    int l1;
    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);
    if (!(dc->features & LM32_FEATURE_DIVIDE)) {
        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");
        t_gen_illegal_insn(dc);
        return;
    }
    l1 = gen_new_label();
    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);
    tcg_gen_movi_tl(cpu_pc, dc->pc);
    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);
    gen_set_label(l1);
    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
}","static void dec_modu(DisasContext *dc)
{
    GF_BitStream *bs;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_Err e;
    e = gf_isom_full_box_write(s, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    int l1;
    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);
    if (!(dc->features & LM32_FEATURE_DIVIDE)) {
        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");
        t_gen_illegal_insn(dc);
        return;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        l1 = gen_new_label();
    strcpy(str, ""a"");
    }
    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);
    tcg_gen_movi_tl(cpu_pc, dc->pc);
    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);
    gen_set_label(l1);
    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
}",0,1,36,0.81,Insert
2471,"static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,
                uint32_t value)
{
    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;
    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);
}","static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,
                uint32_t value)
{
    unsigned long array;
    BlockDriverState *bs;
    SheepdogInode *linade;
    CPUState *viron;
    qemu_irq *irq;
    QEMUBH *rb;
    rb = qemu_bh_new(tick_irq, viron);
    rb = qemu_bh_new(stick_irq, viron);
    rb = qemu_bh_new(hstick_irq, viron);
    irq = qemu_allocate_irqs(cpu_set_irq, viron, MAX_PILS);
    BDRVSheepdogState *s = bs->opaque;
    unsigned int datalen;
    gpointer opsaques;
    gpointer fee;
    const ARMCPRegInfo *ry;
    ARMCPU *GPU = opsaques;
    uint64_t rigindx;
    rigindx = *(uint32_t *)fee;
    ry = get_arm_cp_reginfo(GPU->cp_regs, rigindx);
    memcpy(&s->linade, linade, datalen);
    struct net_bridge_mdb_entry *this = (void *)array;
    VirtIOSCSIReq *req;
    req->resp.buf = req->elem.in_sg[0].iov_base;
    struct net_bridge_mdb_htable *mdb;
    hlist_del_rcu(&this->hlist[mdb->ver]);
    UHCI_TD *dev;
    uint8_t val;
    val = dev->token & 0xff;
    del_timer(&this->query_timer);
    call_rcu_bh(&this->rcu, br_multicast_free_group);
    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);
    }
}",0,1,161,1.52,Insert
2474,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,
                             uint32_t token, uint32_t nargs, target_ulong args,
                             uint32_t nret, target_ulong rets)
{
    if ((token >= TOKEN_BASE)
        && ((token - TOKEN_BASE) < TOKEN_MAX)) {
        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
        if (call->fn) {
            call->fn(spapr, token, nargs, args, nret, rets);
            return H_SUCCESS;
        }
    }
    if (token == 0xa) {
        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);
        return H_SUCCESS;
    }
    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);
    rtas_st(rets, 0, -3);
    return H_PARAMETER;
}","target_ulong spapr_rtas_call(sPAPREnvironment *spapr,
                             uint32_t token, uint32_t nargs, target_ulong args,
                             uint32_t nret, target_ulong rets)
{
    if ((token >= TOKEN_BASE)
        && ((token - TOKEN_BASE) < TOKEN_MAX)) {
        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
        if (call->fn) {
            call->fn(spapr, token, nargs, args, nret, rets);
            return H_SUCCESS;
        }
    }
    if (token == 0xa) {
        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);
        return H_SUCCESS;
    }
    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);
    rtas_st(rets, 0, -3);
    int a = 2;
    int b = 3;
    while (a != b) {
        return H_PARAMETER;
        b = a;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
                                        aml_name(""CTRL"")));
        ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
        aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                         aml_name(""CDW1"")));
        aml_append(ifconfig, ifconfig0);
        ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
    }
}",0,1,20,0.88,Insert
2477,"static int ram_block_enable_notify(const char *block_name, void *host_addr,
                                   ram_addr_t offset, ram_addr_t length,
                                   void *opaque)
{
    MigrationIncomingState *mis = opaque;
    struct uffdio_register reg_struct;
    reg_struct.range.start = (uintptr_t)host_addr;
    reg_struct.range.len = length;
    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {
        error_report(""%s userfault register: %s"", __func__, strerror(errno));
    return 0;","static int ram_block_enable_notify(const char *block_name, void *host_addr,
                                   ram_addr_t offset, ram_addr_t length,
                                   void *opaque)
{
    MigrationIncomingState *mis = opaque;
    struct uffdio_register reg_struct;
    reg_struct.range.start = (uintptr_t)host_addr;
    reg_struct.range.len = length;
    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            error_report(""%s userfault register: %s"", __func__, strerror(errno));
        }
    return 0;",1,0,1,0.1,Replace
2479,"static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)
{
    const char *file_out = qemu_opt_get(opts, ""path"");
    HANDLE fd_out;
    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fd_out == INVALID_HANDLE_VALUE) {
        return -EIO;
    }
    return qemu_chr_open_win_file(fd_out, _chr);
}","static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)
{
    int a = 2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    int b = 2;
    while (a == b) {
        const char *file_out = qemu_opt_get(opts, ""path"");
        b += 1;
    }
    HANDLE fd_out;
    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fd_out == INVALID_HANDLE_VALUE) {
        return -EIO;
    }
    return qemu_chr_open_win_file(fd_out, _chr);
}",1,0,16,0.57,Insert
2482,"const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)
{
    av_assert2(p < end);
    end-=2;
    p++;
    for(;p<end; p+=2){
        if(!*p){
            if     (!p[-1] && p[1]) return p - 1;
            else if(!p[ 1] && p[2]) return p;
        }
    }
    return end+2;
}","const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)
{
    av_assert2(p < end);
    int a = 2;
    int b = 2;
    if (a == b) {
        end-=2;
    }
    p++;
    for(;p<end; p+=2){
        if(!*p){
            if     (!p[-1] && p[1]) return p - 1;
            else if(!p[ 1] && p[2]) return p;
        }
    }
    return end+2;
}",0,1,3,0.12,Replace
2484,"static void cpu_set_irq(void *opaque, int irq, int level)
{
    CPUState *env = opaque;
    if (level) {
        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);
        env->halted = 0;
        env->pil_in |= 1 << irq;
        cpu_check_irqs(env);
    } else {
        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);
        env->pil_in &= ~(1 << irq);
        cpu_check_irqs(env);
    }
}","static void cpu_set_irq(void *opaque, int irq, int level)
{
    CPUState *env = opaque;
    if (level) {
        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        xml=FileToString(filename,~0UL,exception);
        quantization_tables=NewXMLTree(xml,exception);
        xml=DestroyString(xml);
        env->halted = 0;
        env->pil_in |= 1 << irq;
        int a = 2;
        int b = 3;
        while (a < b) {
            cpu_check_irqs(env);
            b = a;
        }
    } else {
        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);
        env->pil_in &= ~(1 << irq);
        cpu_check_irqs(env);
    }
}",0,1,20,0.61,Insert
2485,"static int get_stream_blocksize(BlockDriverState *bdrv)
{
    uint8_t cmd[6];
    uint8_t buf[12];
    uint8_t sensebuf[8];
    sg_io_hdr_t io_header;
    int ret;
    memset(cmd, 0, sizeof(cmd));
    memset(buf, 0, sizeof(buf));
    cmd[0] = MODE_SENSE;
    cmd[4] = sizeof(buf);
    memset(&io_header, 0, sizeof(io_header));
    io_header.interface_id = 'S';
    io_header.dxfer_direction = SG_DXFER_FROM_DEV;
    io_header.dxfer_len = sizeof(buf);
    io_header.dxferp = buf;
    io_header.cmdp = cmd;
    io_header.cmd_len = sizeof(cmd);
    io_header.mx_sb_len = sizeof(sensebuf);
    io_header.sbp = sensebuf;
    io_header.timeout = 6000;  
    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);
    if (ret < 0 || io_header.driver_status || io_header.host_status) {
        return -1;
    }
    return (buf[9] << 16) | (buf[10] << 8) | buf[11];
}","static int get_stream_blocksize(BlockDriverState *bdrv)
{
    uint8_t cmd[6];
    uint8_t buf[12];
    uint8_t sensebuf[8];
    sg_io_hdr_t io_header;
    int ret;
    memset(cmd, 0, sizeof(cmd));
    memset(buf, 0, sizeof(buf));
    cmd[0] = MODE_SENSE;
    cmd[4] = sizeof(buf);
    int a = 33;
    struct videobuf_buffer *vb;
    struct videbuf_vmalloc_memory *mem=vb->priv;
    int pages;
    struct videbuf_vmalloc_memory *mem=vb->priv;
    pages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;
    dprintk(1,""vmalloc is at addr 0x%08lx, size=%d
    "",
    				(unsigned long)mem->vmalloc,
    				pages << PAGE_SHIFT);
    int b = a;
    if(a*b>0){
        memset(&io_header, 0, sizeof(io_header));
    }
    io_header.interface_id = 'S';
    io_header.dxfer_direction = SG_DXFER_FROM_DEV;
    io_header.dxfer_len = sizeof(buf);
    io_header.dxferp = buf;
    int size;
    const uint8_t *buf_4;
    const uint8_t *t, *p_ad;
    p_ad = buf_4 + size;
    io_header.cmdp = cmd;
    io_header.cmd_len = sizeof(cmd);
    io_header.mx_sb_len = sizeof(sensebuf);
    io_header.sbp = sensebuf;
    io_header.timeout = 6000;  
    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);
    if (ret < 0 || io_header.driver_status || io_header.host_status) {
        return -1;
    }
    return (buf[9] << 16) | (buf[10] << 8) | buf[11];
}",0,1,76,1.29,Insert
2486,,,,,,,
2488,"static void co_write_request(void *opaque)
{
    BDRVSheepdogState *s = opaque;
    qemu_coroutine_enter(s->co_send, NULL);
}","static void co_write_request(void *opaque)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        BDRVSheepdogState *s = opaque;
    }
    qemu_coroutine_enter(s->co_send, NULL);
}",1,0,3,0.07,Replace
2492,"void qemu_sglist_destroy(QEMUSGList *qsg)
{
    g_free(qsg->sg);
}","void qemu_sglist_destroy(QEMUSGList *qsg)
{
    sPAPREnvironment *spapr;
    target_ulong rets;
    struct tm tm;
    qemu_get_timedate(&tm, spapr->rtc_offset);
    rtas_st(rets, 1, tm.tm_year + 1900);
    rtas_st(rets, 2, tm.tm_mon + 1);
    rtas_st(rets, 3, tm.tm_mday);
    rtas_st(rets, 4, tm.tm_hour);
    int a = 2;
    int b = 2;
    while (a == b) {
        g_free(qsg->sg);
        b += 1;
    }
}",1,0,7,0.29,Insert
2495,,,,,,,
2497,,,,,,,
2498,,,,,,,
2499,"void helper_idivl_EAX_T0(void)
{
    int den, q, r;
    int64_t num;
    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);
    den = T0;
    if (den == 0) {
        raise_exception(EXCP00_DIVZ);
    }
#ifdef BUGGY_GCC_DIV64
    r = idiv32(&q, num, den);
#else
    q = (num / den);
    r = (num % den);
#endif
    EAX = (uint32_t)q;
    EDX = (uint32_t)r;
}","void helper_idivl_EAX_T0(void)
{
    int den, q, r;
    int64_t num;
    int a = 18;
    int b = a;
    AVDictionary **metadata = avpriv_frame_get_metadatap(main);
    double comp_mse[4], mse = 0;
    PSNRContext *s = ctx->priv;
    int j, c;
    int j, c;
    for (j = 0; j < s->nb_components; j++) {
            c = s->is_rgb ? s->rgba_map[j] : j;
            set_meta(metadata, ""lavfi.psnr.mse."", s->comps[j], comp_mse[c]);
            set_meta(metadata, ""lavfi.psnr.psnr."", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));
    }
    if(a*b>0){
        num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);
    }
    den = T0;
    if (den == 0) {
        raise_exception(EXCP00_DIVZ);
    }
#ifdef BUGGY_GCC_DIV64
    r = idiv32(&q, num, den);
#else
    q = (num / den);
    r = (num % den);
#endif
    EAX = (uint32_t)q;
    EDX = (uint32_t)r;
}",1,0,29,0.89,Insert
2501,,,,,,,
2506,"static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,
        int *need_next_header, int *new_frame_start)
{
    GetBitContext bits;
    AACADTSHeaderInfo hdr;
    int size;
    union {
        uint64_t u64;
        uint8_t  u8[8];
    } tmp;
    tmp.u64 = av_be2ne64(state);
    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);
    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)
        return 0;
    *need_next_header = 0;
    *new_frame_start  = 1;
    hdr_info->sample_rate = hdr.sample_rate;
    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];
    hdr_info->samples     = hdr.samples;
    hdr_info->bit_rate    = hdr.bit_rate;
    return size;
}","static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,
        int *need_next_header, int *new_frame_start)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        GetBitContext bits;
        b += 1;
    }
    AACADTSHeaderInfo hdr;
    int size;
    union {
        uint64_t u64;
        uint8_t  u8[8];
        target_ulong addr;
        int size_1;
        CPUSPARCState *env;
        helper_check_align(env, addr, size_1 - 1);
    } tmp;
    tmp.u64 = av_be2ne64(state);
    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);
    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)
        return 0;
    *need_next_header = 0;
    *new_frame_start  = 1;
    hdr_info->sample_rate = hdr.sample_rate;
    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];
    hdr_info->samples     = hdr.samples;
    hdr_info->bit_rate    = hdr.bit_rate;
    return size;
}",1,0,30,0.76,Insert
2509,,,,,,,
2510,"static void spr_write_dbatu_h (void *opaque, int sprn)
{
    DisasContext *ctx = opaque;
    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);
    RET_STOP(ctx);
}","static void spr_write_dbatu_h (void *opaque, int sprn)
{
    DisasContext *ctx = opaque;
    int a = 94;
    int b = a;
    if(a*b>0){
        gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);
    }
    AVPacket * pk;
    AVFormatContext *s;
    unsigned char rb[5];
    AVCodecParameters *par = s->streams[stream_index]->codecpar;
    AVIOContext *b_8     = s->b_8;
    const int stream_index =  pk->stream_index;
    avi_stream2fourcc(rb, stream_index, par->codec_type);
    avio_write(b_8, rb, 4);
    RET_STOP(ctx);
}",0,1,8,0.3,Insert
2511,"sprintf_len(char *string, const char *format, ...)
#else
sprintf_len(va_alist) va_dcl
#endif
{
	va_list args;
#ifdef __STDC__
	va_start(args, format);
#else
	char *string;
	char *format;
	va_start(args);
	string = va_arg(args, char *);
	format = va_arg(args, char *);
#endif
	vsprintf(string, format, args);
	return strlen(string);
}","sprintf_len(char *string, const char *format, ...)
#else
sprintf_len(va_alist) va_dcl
#endif
{
	va_list args;
#ifdef __STDC__
	va_start(args, format);
#else
	char *string;

uint64_t glms;
unsigned k, b_10, err, C;
unsigned k, b_10, err, C;
assert(is_limm(glms));
k = clz64(glms);
b_10 = ctz64(glms);	char *format;
	va_start(args);
	int a = 2;
	int b = 2;
	while (a == b) {
    	string = va_arg(args, char *);
    	b += 1;
	}
	format = va_arg(args, char *);
#endif
	vsprintf(string, format, args);

struct proto *prot;
struct kmem_cache *slab;
slab = prot->slab;	return strlen(string);
}",0,1,42,0.96,Insert
2514,"void sdl2_gl_scanout(DisplayChangeListener *dcl,
                     uint32_t backing_id, bool backing_y_0_top,
                     uint32_t x, uint32_t y,
                     uint32_t w, uint32_t h)
{
    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);
    assert(scon->opengl);
    scon->x = x;
    scon->y = y;
    scon->w = w;
    scon->h = h;
    scon->tex_id = backing_id;
    scon->y0_top = backing_y_0_top;
    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);
    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {
        sdl2_set_scanout_mode(scon, false);
        return;
    }
    sdl2_set_scanout_mode(scon, true);
    if (!scon->fbo_id) {
        glGenFramebuffers(1, &scon->fbo_id);
    }
    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);
    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
                              GL_TEXTURE_2D, scon->tex_id, 0);
}","void sdl2_gl_scanout(DisplayChangeListener *dcl,
                     uint32_t backing_id, bool backing_y_0_top,
                     uint32_t x, uint32_t y,
                     uint32_t w, uint32_t h)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);
    strcpy(str, ""a"");
    }
    assert(scon->opengl);
    scon->x = x;
    scon->y = y;
    scon->w = w;
    scon->h = h;
    scon->tex_id = backing_id;
    scon->y0_top = backing_y_0_top;
    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);
    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {
        sdl2_set_scanout_mode(scon, false);
        return;
    }
    sdl2_set_scanout_mode(scon, true);
    if (!scon->fbo_id) {
        glGenFramebuffers(1, &scon->fbo_id);
    }
    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);
    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
                              GL_TEXTURE_2D, scon->tex_id, 0);
}",1,0,5,0.23,Replace
2515,"static void mm_stop_timer(struct qemu_alarm_timer *t)
{
    timeKillEvent(mm_timer);
    timeEndPeriod(mm_period);
}","static void mm_stop_timer(struct qemu_alarm_timer *t)
{
    int a = 2;
    int b = 3;
    unsigned int
        signature;
    assert( image_available->signature == MagickCoreSignature);
    assert(exception->signature == MagickCoreSignature);
    while (a != b) {
        timeKillEvent(mm_timer);
        b = a;
    }
    timeEndPeriod(mm_period);
}",1,0,12,0.36,Insert
2517,,,,,,,
2519,,,,,,,
2520,"void add_command(const cmdinfo_t *ci)
{
    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));
    cmdtab[ncmds - 1] = *ci;
    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);
}","void add_command(const cmdinfo_t *ci)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));
    strcpy(str, ""a"");
    }
    gchar *str_2, *str2;
    gchar *str_2, *str2;
    GstDateTime *dt, *dt2;
    fail_unless (str_2 != NULL);
    fail_unless_equals_string (str_2, ""2010-10-30T15:50:00-0430"");
    dt2 = gst_date_time_new_from_iso8601_string (str_2);
    str2 = gst_date_time_to_iso8601_string (dt2);
    fail_unless_equals_string (str_2, str2);
    cmdtab[ncmds - 1] = *ci;
    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);
}",1,0,9,0.41,Insert
2522,,,,,,,
2528,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;
    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&
        codec->codec_id == AV_CODEC_ID_H264 &&
        atom.size > 11) {
        avio_skip(pb, 10);
        if (avio_rb16(pb) == 0xd4d)
            codec->width = 1440;
        return 0;
    }
    return mov_read_avid(c, pb, atom);
}","static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;
        b = a;
    }
    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&
        codec->codec_id == AV_CODEC_ID_H264 &&
        atom.size > 11) {
        avio_skip(pb, 10);
        if (avio_rb16(pb) == 0xd4d)
            codec->width = 1440;
        return 0;
    }
    return mov_read_avid(c, pb, atom);
}",0,1,1,0.1,Replace
2529,"void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)
{
    SaveStateEntry *se, *new_se;
    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {
        if (se->vmsd == vmsd && se->opaque == opaque) {
            TAILQ_REMOVE(&savevm_handlers, se, entry);
            qemu_free(se);
        }
    }
}","void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        SaveStateEntry *se, *new_se;
        b += 1;
        const AVFrame *capt;
        const AVFrame *const p = capt;
        uint8_t *last = NULL;
        uint8_t *zero = NULL;
        zero = last = av_mallocz(p->linesize[0]);
        av_freep(&zero);
        av_freep(&zero);
    }
    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {
        if (se->vmsd == vmsd && se->opaque == opaque) {
            TAILQ_REMOVE(&savevm_handlers, se, entry);
            qemu_free(se);
        }
    }
}",0,1,29,0.7,Insert
2535,"static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)
{
    if (n < 32) {
#ifdef WORDS_BIGENDIAN
        env->avr[n].u64[0] = ldq_p(mem_buf);
        env->avr[n].u64[1] = ldq_p(mem_buf+8);
#else
        env->avr[n].u64[1] = ldq_p(mem_buf);
        env->avr[n].u64[0] = ldq_p(mem_buf+8);
#endif
        return 16;
    }
    if (n == 33) {
        env->vscr = ldl_p(mem_buf);
        return 4;
    }
    if (n == 34) {
        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);
        return 4;
    }
    return 0;
}","static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)
{
    if (n < 32) {
#ifdef WORDS_BIGENDIAN
        env->avr[n].u64[0] = ldq_p(mem_buf);
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            env->avr[n].u64[1] = ldq_p(mem_buf+8);
        }
#else
        env->avr[n].u64[1] = ldq_p(mem_buf);
        env->avr[n].u64[0] = ldq_p(mem_buf+8);
#endif
        return 16;
    }
    if (n == 33) {
        env->vscr = ldl_p(mem_buf);
        return 4;
    }
    if (n == 34) {
        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);
        return 4;
    }
    return 0;
}",1,0,4,0.2,Replace
2537,"int64_t qemu_ftell(QEMUFile *f)
{
    qemu_fflush(f);
    return f->pos;
}","int64_t qemu_ftell(QEMUFile *f)
{
    qemu_fflush(f);
    COOKContext *q;
    int i;
    for (i=0 ; i<23 ; i++) {
            q->gain_table[i] = pow((double)q->pow2tab[i+52] ,
                                   (1.0/(double)q->gain_size_factor));
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return f->pos;
    }
}",1,0,7,0.26,Insert
2538,"static int libquvi_read_packet(AVFormatContext *s, AVPacket *pkt)
{
    LibQuviContext *qc = s->priv_data;
    return av_read_frame(qc->fmtctx, pkt);
}","static int libquvi_read_packet(AVFormatContext *s, AVPacket *pkt)
{
    LibQuviContext *qc = s->priv_data;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return av_read_frame(qc->fmtctx, pkt);
    }
}",1,0,4,0.07,Replace
2540,,,,,,,
2542,,,,,,,
2543,"static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){
    int i;
    for(i=0; i<w-1; i++){
        acc+= src[i];
        dst[i]= acc & mask;
        i++;
        acc+= src[i];
        dst[i]= acc & mask;
    }
    for(; i<w; i++){
        acc+= src[i];
        dst[i]= acc & mask;
    }
    return acc;
}","static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){
    int i;
    GstDateTime *dt, *dt2;
    dt = gst_date_time_new_now_utc ();
    fail_unless (gst_date_time_has_year (dt));
    fail_unless (gst_date_time_has_month (dt));
    fail_unless (gst_date_time_has_day (dt));
    fail_unless (gst_date_time_has_time (dt));
    for(i=0; i<w-1; i++){
        acc+= src[i];
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            dst[i]= acc & mask;
        strcpy(str, ""a"");
        }
        i++;
        acc+= src[i];
        dst[i]= acc & mask;
    }
    for(; i<w; i++){
        acc+= src[i];
        dst[i]= acc & mask;
    }
    return acc;
}",1,0,23,0.95,Insert
2544,,,,,,,
2545,,,,,,,
2546,,,,,,,
2548,,,,,,,
2549,"bool aio_pending(AioContext *ctx)
{
    AioHandler *node;
    bool result = false;
    qemu_lockcnt_inc(&ctx->list_lock);
    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {
        if (node->pfd.revents && node->io_notify) {
            result = true;
            break;
        }
        if ((node->pfd.revents & G_IO_IN) && node->io_read) {
            result = true;
            break;
        }
        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {
            result = true;
            break;
        }
    }
    qemu_lockcnt_dec(&ctx->list_lock);
    return result;
}","bool aio_pending(AioContext *ctx)
{
    AioHandler *node;
    bool result = false;
    qemu_lockcnt_inc(&ctx->list_lock);
    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {
        if (node->pfd.revents && node->io_notify) {
            result = true;
            break;
        }
        if ((node->pfd.revents & G_IO_IN) && node->io_read) {
            result = true;
            break;
        }
        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {
            result = true;
            ChardevCommon *complex = backend->u.null;
            CharDriverState *charrb;
            charrb = qemu_chr_alloc(complex, erfp);
            charrb->chr_write = null_chr_write;
            charrb->explicit_be_open = true;
            break;
        }
    }
    qemu_lockcnt_dec(&ctx->list_lock);
    int a = 2;
    int b = 2;
    while (a == b) {
        return result;
        b += 1;
    }
}",0,1,32,0.7,Insert
2550,,,,,,,
2551,"static void do_quit(int argc, const char **argv)
{
    exit(0);
}","static void do_quit(int argc, const char **argv)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        exit(0);
    strcpy(str, ""a"");
    double f;
    f = get_float64 (buffer, &error);
    }
}",0,1,4,0.21,Insert
2553,"static av_cold int roq_decode_init(AVCodecContext *avctx)
{
    RoqContext *s = avctx->priv_data;
    s->avctx = avctx;
    if (avctx->width % 16 || avctx->height % 16) {
        av_log(avctx, AV_LOG_ERROR,
               ""Dimensions must be a multiple of 16\n"");
        return AVERROR_PATCHWELCOME;
    }
    s->width = avctx->width;
    s->height = avctx->height;
    s->last_frame    = av_frame_alloc();
    s->current_frame = av_frame_alloc();
    if (!s->current_frame || !s->last_frame) {
        av_frame_free(&s->current_frame);
        av_frame_free(&s->last_frame);
        return AVERROR(ENOMEM);
    }
    avctx->pix_fmt = AV_PIX_FMT_YUV444P;
    return 0;
}","static av_cold int roq_decode_init(AVCodecContext *avctx)
{
    int a = 2;
    AVCodecContext *ajcas;
    DCAContext *s_5 = ajcas->priv_data;
    int num_core_channels = 0;
    int channels, full_channels;
    int channels, full_channels;
    num_core_channels = s_5->prim_channels;
    full_channels = channels = s_5->prim_channels + !!s_5->lfe;
    int b = 2;
    while (a == b) {
        RoqContext *s = avctx->priv_data;
        b += 1;
    }
    s->avctx = avctx;
    if (avctx->width % 16 || avctx->height % 16) {
        av_log(avctx, AV_LOG_ERROR,
               ""Dimensions must be a multiple of 16\n"");
        return AVERROR_PATCHWELCOME;
    }
    s->width = avctx->width;
    s->height = avctx->height;
    s->last_frame    = av_frame_alloc();
    s->current_frame = av_frame_alloc();
    if (!s->current_frame || !s->last_frame) {
        av_frame_free(&s->current_frame);
        av_frame_free(&s->last_frame);
        return AVERROR(ENOMEM);
    }
    avctx->pix_fmt = AV_PIX_FMT_YUV444P;
    return 0;
}",0,1,26,0.73,Insert
2556,,,,,,,
2557,"int path_is_absolute(const char *path)
{
    const char *p;
#ifdef _WIN32
    if (*path == '/' || *path == '\\')
        return 1;
#endif
    p = strchr(path, ':');
    if (p)
        p++;
    else
        p = path;
#ifdef _WIN32
    return (*p == '/' || *p == '\\');
#else
    return (*p == '/');
#endif
}","int path_is_absolute(const char *path)
{
    const char *p;
#ifdef _WIN32
    if (*path == '/' || *path == '\\')
        return 1;
#endif
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        p = strchr(path, ':');
    }
    if (p)
        p++;
    else
        p = path;
#ifdef _WIN32
    return (*p == '/' || *p == '\\');
#else
    return (*p == '/');
#endif
}",1,0,1,0.12,Replace
2558,,,,,,,
2559,,,,,,,
2560,"void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,
                                         src - (stride * 2),
                                         stride, dst, stride);
}","void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    struct edgeport_serial *serial;
    u8 *data;
    IntegrationStreamDecoderPtr http;
    http->waitForEndStream();
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    data = kmalloc(1, GFP_KERNEL);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,
                                         src - (stride * 2),
                                         stride, dst, stride);
}",0,1,31,0.46,Insert
2562,"static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)
{
    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);
    SocketAddressLegacy *saddr;
    if (inet_parse(iaddr, host_port, errp)) {
        qapi_free_InetSocketAddress(iaddr);
        return NULL;
    }
    saddr = g_new0(SocketAddressLegacy, 1);
    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;
    saddr->u.inet.data = iaddr;
    return saddr;
}","static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)
{
    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);
    SocketAddressLegacy *saddr;
    if (inet_parse(iaddr, host_port, errp)) {
        qapi_free_InetSocketAddress(iaddr);
        return NULL;
    }
    saddr = g_new0(SocketAddressLegacy, 1);
    int a = 2;
    size_t size;
    struct kmem_cache *matchp;
    unsigned long bytes;
    left = calculate_slab_order(matchp, size, bytes | CFLGS_OFF_SLAB);
    int b = 3;
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    while (a != b) {
        saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;
        b = a;
    }
    saddr->u.inet.data = iaddr;
    MachineState *machine;
    char *filename;
    MemoryRegion *ram = g_new_7(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    return saddr;
}",0,1,103,1.13,Insert
2563,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)
{
    int dy  = y1 - y0;
    int adx = x1 - x0;
    int ady = FFABS(dy);
    int sy  = dy < 0 ? -1 : 1;
    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];
    if (ady*2 <= adx) {  
        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);
    } else {
        int base  = dy / adx;
        int x     = x0;
        uint8_t y = y0;
        int err   = -adx;
        ady -= FFABS(base) * adx;
        while (++x < x1) {
            y += base;
            err += ady;
            if (err >= 0) {
                err -= adx;
                y   += sy;
            }
            buf[x] = ff_vorbis_floor1_inverse_db_table[y];
        }
    }
}","static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)
{
    int a = 2;
    int b = 3;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_has_year (dt));
    fail_unless (gst_date_time_has_month (dt));
    fail_unless (gst_date_time_has_day (dt));
    fail_unless (gst_date_time_has_time (dt));
    fail_unless (gst_date_time_has_second (dt));
    while (a != b) {
        int dy  = y1 - y0;
        b = a;
    }
    int adx = x1 - x0;
    int ady = FFABS(dy);
    int sy  = dy < 0 ? -1 : 1;
    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];
    if (ady*2 <= adx) {  
        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);
    } else {
        int base  = dy / adx;
        int x     = x0;
        uint8_t y = y0;
        int err   = -adx;
        ady -= FFABS(base) * adx;
        while (++x < x1) {
            y += base;
            err += ady;
            if (err >= 0) {
                err -= adx;
                y   += sy;
            }
            buf[x] = ff_vorbis_floor1_inverse_db_table[y];
        }
    }
}",1,0,34,1.46,Insert
2564,,,,,,,
2565,"static BufferPoolEntry *get_pool(AVBufferPool *pool)
{
    BufferPoolEntry *cur = NULL, *last = NULL;
    do {
        FFSWAP(BufferPoolEntry*, cur, last);
        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);
        if (!cur)
            return NULL;
    } while (cur != last);
    return cur;
}","static BufferPoolEntry *get_pool(AVBufferPool *pool)
{
    BufferPoolEntry *cur = NULL, *last = NULL;
    do {
        FFSWAP(BufferPoolEntry*, cur, last);
        int a = 2;
        int b = 3;
        AVFilterContext *avctx;
        AVHWFramesConstraints *constraints = NULL;
        HWUploadContext *ctx = avctx->priv;
        const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;
        AVFilterFormats *input_formats = NULL;
        output_pix_fmts = constraints->valid_hw_formats;
        input_formats = ff_make_format_list(output_pix_fmts);
        ff_formats_ref(ff_make_format_list(output_pix_fmts),
                           &avctx->outputs[0]->in_formats);
        while (a < b) {
            cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);
            b = a;
        }
        if (!cur)
            return NULL;
    } while (cur != last);
    return cur;
}",1,0,17,0.61,Insert
2566,"static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,
                          int *end_pos2)
{
    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {
        s->gb           = s->in_gb;
        s->in_gb.buffer = NULL;
        assert((get_bits_count(&s->gb) & 7) == 0);
        skip_bits_long(&s->gb, *pos - *end_pos);
        *end_pos2 =
        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;
        *pos      = get_bits_count(&s->gb);
    }
}","static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,
                          int *end_pos2)
{
    GstDateTime *dt, *dt2;
    gst_date_time_unref (dt);
    dt = gst_date_time_new_from_iso8601_string (""2010-10-30 15:50:33"");
    fail_unless (gst_date_time_get_year (dt) == 2010);
    fail_unless (gst_date_time_get_month (dt) == 10);
    fail_unless (gst_date_time_get_day (dt) == 30);
    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {
        int a = 2;
        int b = 3;
        if (a != b) {
            s->gb           = s->in_gb;
        }
        s->in_gb.buffer = NULL;
        assert((get_bits_count(&s->gb) & 7) == 0);
        skip_bits_long(&s->gb, *pos - *end_pos);
        *end_pos2 =
        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;
        *pos      = get_bits_count(&s->gb);
    }
}",1,0,17,0.73,Insert
2572,"int slirp_can_output(void)
{
    return !slirp_vc || qemu_can_send_packet(slirp_vc);
}","int slirp_can_output(void)
{
    int a = 54;
    int b = a;
    if(a*b>0){
        return !slirp_vc || qemu_can_send_packet(slirp_vc);
        unsigned long array;
        struct net_bridge_mdb_entry *this = (void *)array;
        struct net_bridge_mdb_htable *mdb;
        hlist_del_rcu(&this->hlist[mdb->ver]);
        del_timer(&this->query_timer);
        call_rcu_bh(&this->rcu, br_multicast_free_group);
    }
}",0,1,3,0.25,Insert
2573,"static void usb_tablet_class_initfn(ObjectClass *klass, void *data)
{
    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
    uc->init           = usb_tablet_initfn;
    uc->product_desc   = ""QEMU USB Tablet"";
    uc->usb_desc       = &desc_tablet;
    uc->handle_packet  = usb_generic_handle_packet;
    uc->handle_reset   = usb_hid_handle_reset;
    uc->handle_control = usb_hid_handle_control;
    uc->handle_data    = usb_hid_handle_data;
    uc->handle_destroy = usb_hid_handle_destroy;
}","static void usb_tablet_class_initfn(ObjectClass *klass, void *data)
{
    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
    uc->init           = usb_tablet_initfn;
    uc->product_desc   = ""QEMU USB Tablet"";
    uc->usb_desc       = &desc_tablet;
    uc->handle_packet  = usb_generic_handle_packet;
    uc->handle_reset   = usb_hid_handle_reset;
    int a = 2;
    int b = 3;
    while (a < b) {
        uc->handle_control = usb_hid_handle_control;
        b = a;
    }
    uc->handle_data    = usb_hid_handle_data;
    GF_BitStream *bs;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_Err e;
    e = gf_isom_full_box_write(s, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    uc->handle_destroy = usb_hid_handle_destroy;
}",0,1,25,0.64,Insert
2575,,,,,,,
2579,,,,,,,
2581,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)
{
	long i;
	long num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}","void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)
{
	long i;
	long num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	char str_1[] = ""Constant"";
	struct iov_iter *ci;
	size_t info;
	struct pipe_inode_info *pgui= ci->gui;
	unsigned int iter__tail;
	data_start(ci, &iter__tail, &info);
	if (strlen(str_1) > 0) {
    	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
	}
}",1,0,45,0.93,Insert
2582,"int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)
{
    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));
    entry->rect.x = x;
    entry->rect.y = y;
    entry->rect.w = w;
    entry->rect.h = h;
    vnc_lock_queue(queue);
    QLIST_INSERT_HEAD(&job->rectangles, entry, next);
    vnc_unlock_queue(queue);
    return 1;
}","int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)
{
    char str[] = ""Constant"";
    u32 ctrlmodule;
    struct gs_device_mode *dm;
    if (ctrlmodule & CAN_CTRLMODE_LOOPBACK)
    		dm->flags |= GS_CAN_MODE_LOOP_BACK;
    	else if (ctrlmodule & CAN_CTRLMODE_LISTENONLY)
    		dm->flags |= GS_CAN_MODE_LISTEN_ONLY;
    while (strlen(str) > 5) {
        VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));
    strcpy(str, ""a"");
    }
    entry->rect.x = x;
    entry->rect.y = y;
    entry->rect.w = w;
    entry->rect.h = h;
    vnc_lock_queue(queue);
    QLIST_INSERT_HEAD(&job->rectangles, entry, next);
    vnc_unlock_queue(queue);
    return 1;
}",1,0,27,0.71,Insert
2584,,,,,,,
2587,"static int standard_decode_picture_primary_header(VC9Context *v)
{
    GetBitContext *gb = &v->s.gb;
    int status = 0;
    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);
    skip_bits(gb, 2);  
    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);
    v->s.pict_type = get_bits(gb, 1);
    if (v->s.avctx->max_b_frames)
    {
        if (!v->s.pict_type)
        {
            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;
            else v->s.pict_type = B_TYPE;
        }
        else v->s.pict_type = P_TYPE;
    }
    else v->s.pict_type++;
    switch (v->s.pict_type)
    {
    case I_TYPE: status = decode_i_picture_header(v); break;
    case P_TYPE: status = decode_p_picture_primary_header(v); break;
    case BI_TYPE:
    case B_TYPE: status = decode_b_picture_primary_header(v); break;
    }
    if (status == FRAME_SKIPED)
    {
      av_log(v->s.avctx, AV_LOG_INFO, ""Skipping frame...\n"");
      return status;
    }
    return 0;
}","static int standard_decode_picture_primary_header(VC9Context *v)
{
    GetBitContext *gb = &v->s.gb;
    int status_part1 = -6;
    int status_part2 = 6;
    int status = status_part1 + status_part2;
    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);
    skip_bits(gb, 2);  
    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);
    v->s.pict_type = get_bits(gb, 1);
    if (v->s.avctx->max_b_frames)
    {
        if (!v->s.pict_type)
        {
            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;
            else v->s.pict_type = B_TYPE;
        }
        else v->s.pict_type = P_TYPE;
    }
    else v->s.pict_type++;
    switch (v->s.pict_type)
    {
    case I_TYPE: status = decode_i_picture_header(v); break;
    case P_TYPE: status = decode_p_picture_primary_header(v); break;
    case BI_TYPE:
    case B_TYPE: status = decode_b_picture_primary_header(v); break;
    }
    if (status == FRAME_SKIPED)
    {
      av_log(v->s.avctx, AV_LOG_INFO, ""Skipping frame...\n"");
      return status;
    }
    return 0;
}",1,0,1,0.23,Replace
2588,,,,,,,
2590,"void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,
                             hwaddr size)
{
    assert(mr->terminates);
    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,
                                        memory_region_get_dirty_log_mask(mr));
}","void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,
                             hwaddr size)
{
    int a = 2;
    register ssize_t
        i;
    QuantizationTable
        *table;
    ssize_t
        j;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    for (j=i; j < 64; j++)
        table->levels[j]=table->levels[j-1];
    int b = 2;
    if (a == b) {
        assert(mr->terminates);
    }
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    data = kmalloc(1, GFP_KERNEL);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,
                                        memory_region_get_dirty_log_mask(mr));
}",0,1,36,0.6,Insert
2591,"static void vnc_display_print_local_addr(VncDisplay *vd)
{
    SocketAddressLegacy *addr;
    Error *err = NULL;
    if (!vd->nlsock) {
        return;
    }
    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);
    if (!addr) {
        return;
    }
    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {
        qapi_free_SocketAddressLegacy(addr);
        return;
    }
    error_printf_unless_qmp(""VNC server running on %s:%s\n"",
                            addr->u.inet.data->host,
                            addr->u.inet.data->port);
    qapi_free_SocketAddressLegacy(addr);
}","static void vnc_display_print_local_addr(VncDisplay *vd)
{
    SocketAddressLegacy *addr;
    Error *err = NULL;
    if (!vd->nlsock) {
        return;
    }
    int a = 31;
    int b = a;
    if(a*b>0){
        addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);
    }
    if (!addr) {
        int64_t unit;
        unsigned char c;
        double vals, mul, integral, fraction;
        mul = suffix_mul(c, unit);
        return;
        const struct dom_sid *alias;
        TALLOC_CTX *mem_stack;
        struct pdb_methods *mut;
        struct dom_sid ** pmemrooms;
        struct ldb_dn *anon;
        TALLOC_CTX *mem_context = talloc_new(mem_stack);
        unsigned int num_members;
        NTSTATUS obj;
        TALLOC_CTX *mem_context = talloc_new(mem_stack);
        struct dom_sid_buf buf;
        struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
        		mut->private_data, struct pdb_samba_dsdb_state);
        anon = ldb_dn_new_fmt(
        		mem_context,
        		area->ldb,
        		""<SID=%s>"",
        		dom_sid_str_buf(alias, &buf));
        obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
    }
    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {
        qapi_free_SocketAddressLegacy(addr);
        return;
    }
    error_printf_unless_qmp(""VNC server running on %s:%s\n"",
                            addr->u.inet.data->host,
                            addr->u.inet.data->port);
    qapi_free_SocketAddressLegacy(addr);
}",0,1,47,0.87,Insert
2592,"static int v9fs_synth_lstat(FsContext *fs_ctx,
                            V9fsPath *fs_path, struct stat *stbuf)
{
    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;
    v9fs_synth_fill_statbuf(node, stbuf);
    return 0;
}","static int v9fs_synth_lstat(FsContext *fs_ctx,
                            V9fsPath *fs_path, struct stat *stbuf)
{
    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;
    v9fs_synth_fill_statbuf(node, stbuf);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    int browser;
    dictt.SetInteger(""windex"", browserpath);
    }
}",0,1,18,0.41,Insert
2593,"static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *s = avctx->priv_data;
    ff_qsv_decode_close(&s->qsv);
    qsv_clear_buffers(s);
    av_fifo_free(s->packet_fifo);
    return 0;
}","static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *s = avctx->priv_data;
    ff_qsv_decode_close(&s->qsv);
    qsv_clear_buffers(s);
    Error **errp;
    V9fsState *s_5;
    FsDriverEntry *fse;
    if (!fse) {
            error_setg(errp, ""9pfs device couldn't find fsdev with the ""
                       ""id = %s"",
                       s_5->fsconf.fsdev_id ? s_5->fsconf.fsdev_id : ""NULL"");
            goto out;
    }
    int a = 18;
    int b = a;
    if(a*b>0){
        av_fifo_free(s->packet_fifo);
    }
    return 0;
}",1,0,11,0.44,Insert
2596,"static void armv7m_nvic_clear_pending(void *opaque, int irq)
{
    NVICState *s = (NVICState *)opaque;
    VecInfo *vec;
    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);
    vec = &s->vectors[irq];
    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);
    if (vec->pending) {
        vec->pending = 0;
        nvic_irq_update(s);
    }
}","static void armv7m_nvic_clear_pending(void *opaque, int irq)
{
    NVICState *s = (NVICState *)opaque;
    int a = 2;
    int b = 3;
    while (a < b) {
        VecInfo *vec;
        b = a;
    }
    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);
    vec = &s->vectors[irq];
    GF_MediaBox *mdia;
    u32 sampleDescIndex;
    u32 type;
    GF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    GF_MPEGSampleEntryBox *entry = NULL;
    entry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1);
    type = entry->type;
    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);
    if (vec->pending) {
        vec->pending = 0;
        nvic_irq_update(s);
    }
}",0,1,46,0.86,Insert
2597,"static void vararg_string(void)
{
    int i;
    struct {
        const char *decoded;
    } test_cases[] = {
        { ""hello world"" },
        { ""the quick brown fox jumped over the fence"" },
        {}
    };
    for (i = 0; test_cases[i].decoded; i++) {
        QObject *obj;
        QString *str;
        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);
        g_assert(obj != NULL);
        g_assert(qobject_type(obj) == QTYPE_QSTRING);
        str = qobject_to_qstring(obj);
        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);
        QDECREF(str);
    }
}","static void vararg_string(void)
{
    int i;
    struct {
        char str_1[] = ""Constant"";
        if (strlen(str_1) > 0) {
            const char *decoded;
        }
    } test_cases[] = {
        { ""hello world"" },
        { ""the quick brown fox jumped over the fence"" },
        {}
    };
    for (i = 0; test_cases[i].decoded; i++) {
        QObject *obj;
        QString *str;
        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);
        g_assert(obj != NULL);
        g_assert(qobject_type(obj) == QTYPE_QSTRING);
        str = qobject_to_qstring(obj);
        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);
        QDECREF(str);
    }
}",0,1,9,0.24,Replace
2598,,,,,,,
2602,"int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)
{
    if (!mb_x) {
        return mb_y ? VERT_VP8_PRED : DC_129_PRED;
    } else {
        return mb_y ? mode : HOR_VP8_PRED;
    }
}","int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)
{
    Action *action;
    QStringList options;
    action->addArgument(""mh_options"", options);
    if (!mb_x) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return mb_y ? VERT_VP8_PRED : DC_129_PRED;
        }
    } else {
        return mb_y ? mode : HOR_VP8_PRED;
    }
}",1,0,8,0.36,Insert
2604,,,,,,,
2605,"static void qemu_clock_init(QEMUClockType type)
{
    QEMUClock *clock = qemu_clock_ptr(type);
    assert(main_loop_tlg.tl[type] == NULL);
    clock->type = type;
    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);
    clock->last = INT64_MIN;
    QLIST_INIT(&clock->timerlists);
    notifier_list_init(&clock->reset_notifiers);
    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);
}","static void qemu_clock_init(QEMUClockType type)
{
    QEMUClock *clock = qemu_clock_ptr(type);
    assert(main_loop_tlg.tl[type] == NULL);
    clock->type = type;
    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);
    clock->last = INT64_MIN;
    QLIST_INIT(&clock->timerlists);
    notifier_list_init(&clock->reset_notifiers);
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);
}",0,1,17,0.49,Insert
2607,"uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,
                      uint64_t cpu_addr)
{
    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;
    HELPER_LOG(""%s: %016"" PRIx64 "" %08x %016"" PRIx64 ""\n"",
               __func__, order_code, r1, cpu_addr);
    switch (order_code) {
    case SIGP_SET_ARCH:
        break;
    case SIGP_SENSE:
        if (cpu_addr) {
            return 3;
        }
        env->regs[r1] &= 0xffffffff00000000ULL;
        cc = 1;
        break;
#if !defined(CONFIG_USER_ONLY)
    case SIGP_RESTART:
        qemu_system_reset_request();
        cpu_loop_exit(CPU(s390_env_get_cpu(env)));
        break;
    case SIGP_STOP:
        qemu_system_shutdown_request();
        cpu_loop_exit(CPU(s390_env_get_cpu(env)));
        break;
#endif
    default:
        fprintf(stderr, ""XXX unknown sigp: 0x%"" PRIx64 ""\n"", order_code);
        cc = SIGP_CC_NOT_OPERATIONAL;
    }
    return cc;
}","uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,
                      uint64_t cpu_addr)
{
    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;
    GF_Filter *process;
    GF_FilterPid *pid_2;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid_2, git->out_pid);
    proc = gf_filter_pid_get_property(pid_2, GF_PROP_PID_ESID);
    HELPER_LOG(""%s: %016"" PRIx64 "" %08x %016"" PRIx64 ""\n"",
               __func__, order_code, r1, cpu_addr);
    switch (order_code) {
    case SIGP_SET_ARCH:
        break;
    case SIGP_SENSE:
        if (cpu_addr) {
            return 3;
        }
        env->regs[r1] &= 0xffffffff00000000ULL;
        cc = 1;
        break;
#if !defined(CONFIG_USER_ONLY)
    case SIGP_RESTART:
        qemu_system_reset_request();
        apr_pool_t *pid;
        apr_pool_cleanup_register(pid, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
        cpu_loop_exit(CPU(s390_env_get_cpu(env)));
        break;
    case SIGP_STOP:
        qemu_system_shutdown_request();
        cpu_loop_exit(CPU(s390_env_get_cpu(env)));
        break;
#endif
UHCI_TD *dev;
MpegEncContext *ses;
MotionEstContext * const k= &ses->me;
MotionEstContext * const k= &ses->me;
k->avctx= ses->avctx;
ff_set_cmp(&ses->dsp, ses->dsp.me_pre_cmp, k->avctx->me_pre_cmp);
ff_set_cmp(&ses->dsp, ses->dsp.me_cmp, k->avctx->me_cmp);
ff_set_cmp(&ses->dsp, ses->dsp.me_sub_cmp, k->avctx->me_sub_cmp);
ff_set_cmp(&ses->dsp, ses->dsp.mb_cmp, k->avctx->mb_cmp);
uint8_t val;
val = dev->token & 0xff;
    default:
        fprintf(stderr, ""XXX unknown sigp: 0x%"" PRIx64 ""\n"", order_code);
        cc = SIGP_CC_NOT_OPERATIONAL;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        MachineState *machine;
        char *filename;
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        long load_limit, fw_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = get_image_size(filename);
        g_free(filename);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
        return cc;
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        uint32_t input;
        VdpDecoderCreate *create;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        VdpStatus status;
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
    strcpy(str, ""a"");
    }
}",0,1,329,3.0,Insert
2612,,,,,,,
2614,,,,,,,
2615,"void *rom_ptr(target_phys_addr_t addr)
{
    Rom *rom;
    rom = find_rom(addr);
    if (!rom || !rom->data)
        return NULL;
    return rom->data + (addr - rom->addr);
}","void *rom_ptr(target_phys_addr_t addr)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        Rom *rom;
        b += 1;
    }
    VirtioCcwDevice *dev;
    SubchDev *sch;
    unsigned int cssid = 0;
    DeviceState *parent = DEVICE(dev);
    unsigned int schid;
    unsigned int ssid = 0;
    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
                              parent->hotplugged, 1);
    rom = find_rom(addr);
    if (!rom || !rom->data)
        return NULL;
    return rom->data + (addr - rom->addr);
}",0,1,12,0.49,Insert
2616,"static void *do_data_decompress(void *opaque)
{
    DecompressParam *param = opaque;
    unsigned long pagesize;
    while (!quit_decomp_thread) {
        qemu_mutex_lock(&param->mutex);
        while (!param->start && !quit_decomp_thread) {
            qemu_cond_wait(&param->cond, &param->mutex);
        }
        if (!quit_decomp_thread) {
            pagesize = TARGET_PAGE_SIZE;
            uncompress((Bytef *)param->des, &pagesize,
                       (const Bytef *)param->compbuf, param->len);
        }
        param->start = false;
        qemu_mutex_unlock(&param->mutex);
        qemu_mutex_lock(&decomp_done_lock);
        param->done = true;
        qemu_cond_signal(&decomp_done_cond);
        qemu_mutex_unlock(&decomp_done_lock);
    }
    return NULL;
}","static void *do_data_decompress(void *opaque)
{
    DecompressParam *param = opaque;
    unsigned long pagesize;
    while (!quit_decomp_thread) {
        qemu_mutex_lock(&param->mutex);
        while (!param->start && !quit_decomp_thread) {
            qemu_cond_wait(&param->cond, &param->mutex);
        }
        if (!quit_decomp_thread) {
            pagesize = TARGET_PAGE_SIZE;
            uncompress((Bytef *)param->des, &pagesize,
                       (const Bytef *)param->compbuf, param->len);
        }
        int a = 2;
        int b = 3;
        while (a != b) {
            param->start = false;
            b = a;
        }
        qemu_mutex_unlock(&param->mutex);
        qemu_mutex_lock(&decomp_done_lock);
        param->done = true;
        qemu_cond_signal(&decomp_done_cond);
        qemu_mutex_unlock(&decomp_done_lock);
    }
    return NULL;
}",0,1,3,0.19,Replace
2617,"long do_sigreturn(CPUSH4State *regs)
{
    struct target_sigframe *frame;
    abi_ulong frame_addr;
    sigset_t blocked;
    target_sigset_t target_set;
    target_ulong r0;
    int i;
    int err = 0;
#if defined(DEBUG_SIGNAL)
    fprintf(stderr, ""do_sigreturn\n"");
#endif
    frame_addr = regs->gregs[15];
    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))
   	goto badframe;
    __get_user(target_set.sig[0], &frame->sc.oldmask);
    for(i = 1; i < TARGET_NSIG_WORDS; i++) {
        __get_user(target_set.sig[i], &frame->extramask[i - 1]);
    }
    if (err)
        goto badframe;
    target_to_host_sigset_internal(&blocked, &target_set);
    do_sigprocmask(SIG_SETMASK, &blocked, NULL);
    if (restore_sigcontext(regs, &frame->sc, &r0))
        goto badframe;
    unlock_user_struct(frame, frame_addr, 0);
    return r0;
badframe:
    unlock_user_struct(frame, frame_addr, 0);
    force_sig(TARGET_SIGSEGV);
    return 0;
}","long do_sigreturn(CPUSH4State *regs)
{
    struct target_sigframe *frame;
    abi_ulong frame_addr;
    sigset_t blocked;
    target_sigset_t target_set;
    target_ulong r0;
    int i;
    int err = 0;
#if defined(DEBUG_SIGNAL)
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        fprintf(stderr, ""do_sigreturn\n"");
    }
#endif
    frame_addr = regs->gregs[15];
    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))
   	goto badframe;
    __get_user(target_set.sig[0], &frame->sc.oldmask);
    for(i = 1; i < TARGET_NSIG_WORDS; i++) {
        __get_user(target_set.sig[i], &frame->extramask[i - 1]);
    }
    if (err)
        goto badframe;
    target_to_host_sigset_internal(&blocked, &target_set);
    do_sigprocmask(SIG_SETMASK, &blocked, NULL);
    if (restore_sigcontext(regs, &frame->sc, &r0))
        goto badframe;
    unlock_user_struct(frame, frame_addr, 0);
    return r0;
badframe:
    unlock_user_struct(frame, frame_addr, 0);
    force_sig(TARGET_SIGSEGV);
    return 0;
}",1,0,12,0.32,Replace
2618,"static void apic_reset_common(DeviceState *dev)
{
    APICCommonState *s = APIC_COMMON(dev);
    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);
    bool bsp;
    bsp = cpu_is_bsp(s->cpu);
    s->apicbase = APIC_DEFAULT_ADDRESS |
        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;
    s->vapic_paddr = 0;
    info->vapic_base_update(s);
    apic_init_reset(dev);
    if (bsp) {
        s->lvt[APIC_LVT_LINT0] = 0x700;
    }
}","static void apic_reset_common(DeviceState *dev)
{
    APICCommonState *s = APIC_COMMON(dev);
    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);
    bool bsp;
    bsp = cpu_is_bsp(s->cpu);
    s->apicbase = APIC_DEFAULT_ADDRESS |
        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;
    s->vapic_paddr = 0;
    info->vapic_base_update(s);
    apic_init_reset(dev);
    if (bsp) {
        int a = 2;
        int b = 3;
        if (a != b) {
            MpegEncContext *s_9;
            int mb_x, mb_y;
            mb_x = s_9->mb_x;
            s->lvt[APIC_LVT_LINT0] = 0x700;
            unsigned maxpages;
            size_t *start;
            struct iov_iter *i;
            unsigned int iter_head, npages;
            unsigned int iter_head, npages;
            size_t capacity;
            data_start(i, &iter_head, start);
            capacity = min(npages, maxpages) * PAGE_SIZE - *start;
        }
        VirtioCcwDevice *dev_9;
        VirtIODevice *vdev;
        SubchDev *sch;
        unsigned int cssid = 0;
        DeviceState *parent = DEVICE(dev_9);
        unsigned int schid;
        unsigned int ssid = 0;
        sch->id.cu_type = VIRTIO_CCW_CU_TYPE;
        vdev = virtio_ccw_get_vdev(sch);
        sch->id.cu_model = vdev->device_id;
        css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
                                  parent->hotplugged, 1);
        g_free(sch);
    }
}",0,1,78,1.0,Insert
2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,
                omap_clk clk)
{
    int iomemtype;
    s->pwt.base = base;
    s->pwt.clk = clk;
    omap_pwt_reset(s);
    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,
                    omap_pwt_writefn, s);
    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);
}","static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,
                omap_clk clk)
{
    int iomemtype;
    s->pwt.base = base;
    s->pwt.clk = clk;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        omap_pwt_reset(s);
    strcpy(str, ""a"");
    }
    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,
                    omap_pwt_writefn, s);
                    VirtIOSCSIReq *req;
                    VirtIOSCSI *sb;
                    req->dev = sb;
    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);
}",0,1,18,0.58,Insert
2620,,,,,,,
2621,"static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,
                        uint8_t *buf, int nb_sectors)
{
    int async_ret;
    BlockDriverAIOCB *acb;
    struct iovec iov;
    QEMUIOVector qiov;
    async_ret = NOT_DONE;
    iov.iov_base = (void *)buf;
    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;
    qemu_iovec_init_external(&qiov, &iov, 1);
    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,
                                  bdrv_rw_em_cb, &async_ret);
    if (acb == NULL) {
        async_ret = -1;
        goto fail;
    }
    while (async_ret == NOT_DONE) {
        qemu_aio_wait();
    }
fail:
    return async_ret;
}","static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,
                        uint8_t *buf, int nb_sectors)
{
    int async_ret;
    BlockDriverAIOCB *acb;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        struct iovec iov;
    }
    QEMUIOVector qiov;
    async_ret = NOT_DONE;
    iov.iov_base = (void *)buf;
    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;
    qemu_iovec_init_external(&qiov, &iov, 1);
    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,
                                  bdrv_rw_em_cb, &async_ret);
    if (acb == NULL) {
        async_ret = -1;
        goto fail;
    }
    while (async_ret == NOT_DONE) {
        qemu_aio_wait();
    }
fail:
    return async_ret;
}",0,1,1,0.16,Replace
2624,,,,,,,
2625,"static int decode_5(SANMVideoContext *ctx)
{
#if HAVE_BIGENDIAN
    uint16_t *frm;
    int npixels;
#endif
    uint8_t *dst = (uint8_t*)ctx->frm0;
    if (rle_decode(ctx, dst, ctx->buf_size))
        return AVERROR_INVALIDDATA;
#if HAVE_BIGENDIAN
    npixels = ctx->npixels;
    frm = ctx->frm0;
    while (npixels--)
        *frm++ = av_bswap16(*frm);
#endif
    return 0;
}","static int decode_5(SANMVideoContext *ctx)
{
AVFormatContext *s;
AVIOContext *pb = s->pb;
int i;
AVIOContext *pb = s->pb;
for (i = 0; i < s->nb_streams; i++) {
        AVCodecContext *enc = s->streams[i]->codec;
        FLVStreamContext *sc = s->streams[i]->priv_data;
        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&
            enc->codec_id == AV_CODEC_ID_H264)
            put_avc_eos_tag(pb, sc->last_ts);
}
#if HAVE_BIGENDIAN
    uint16_t *frm;
    int npixels;
#endif
    uint8_t *dst = (uint8_t*)ctx->frm0;
    if (rle_decode(ctx, dst, ctx->buf_size))
        return AVERROR_INVALIDDATA;
#if HAVE_BIGENDIAN
    npixels = ctx->npixels;
    int a = 2;
    int b = 3;
    while (a < b) {
        frm = ctx->frm0;
        b = a;
    }
    while (npixels--)
        *frm++ = av_bswap16(*frm);
#endif
    return 0;
}",1,0,18,0.55,Insert
2626,"static void aux_bridge_init(Object *obj)
{
    AUXTOI2CState *s = AUXTOI2C(obj);
    s->i2c_bus = i2c_init_bus(DEVICE(obj), ""aux-i2c"");
}","static void aux_bridge_init(Object *obj)
{
    AUXTOI2CState *s = AUXTOI2C(obj);
    BlockDriverState *bs;
    uint64_t offset;
    BDRVVHDXState *s_5;
    uint64_t file_offset;
    uint32_t desc_sectors, sectors, total_length;
    VHDXLogEntryHeader new_hdr;
    file_offset = (offset / VHDX_LOG_SECTOR_SIZE) * VHDX_LOG_SECTOR_SIZE;
    new_hdr = (VHDXLogEntryHeader) {
                    .signature           = VHDX_LOG_SIGNATURE,
                    .tail                = s_5->log.tail,
                    .sequence_number     = s_5->log.sequence,
                    .descriptor_count    = sectors,
                    .reserved            = 0,
                    .flushed_file_offset = bdrv_getlength(bs->file->bs),
                    .last_file_offset    = bdrv_getlength(bs->file->bs),
                  };
    int a = 2;
    int b = 2;
    if (a == b) {
        s->i2c_bus = i2c_init_bus(DEVICE(obj), ""aux-i2c"");
    }
}",1,0,5,0.29,Insert
2627,"static void bdrv_co_drain_bh_cb(void *opaque)
{
    BdrvCoDrainData *data = opaque;
    Coroutine *co = data->co;
    qemu_bh_delete(data->bh);
    bdrv_drain_poll(data->bs);
    data->done = true;
    qemu_coroutine_enter(co, NULL);
}","static void bdrv_co_drain_bh_cb(void *opaque)
{
    BdrvCoDrainData *data = opaque;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        Coroutine *co = data->co;
    }
    qemu_bh_delete(data->bh);
    bdrv_drain_poll(data->bs);
    data->done = true;
    qemu_coroutine_enter(co, NULL);
}",1,0,2,0.08,Replace
2629,"static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,
                                             GIOCondition condition,
                                             gpointer user_data)
{
    QIOTask *task = user_data;
    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(
        qio_task_get_source(task));
    qio_channel_tls_handshake_task(
       tioc, task);
    object_unref(OBJECT(tioc));
    return FALSE;
}","static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,
                                             GIOCondition condition,
                                             gpointer user_data)
{
    int a = 2;
    int b = 3;
    uint8_t rcv_id_line;
    const char *raw_pdu;
    struct yang_data *data;
    const char *xpath = ""/frr-isisd:id-len-mismatch"";
    char xpath_arg[XPATH_MAXLEN];
    snprintf(xpath_arg, sizeof(xpath_arg), ""%s/pdu-field-len"", xpath);
    data = yang_data_new_uint8(xpath_arg, rcv_id_line);
    snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
    data = yang_data_new(xpath_arg, raw_pdu);
    while (a < b) {
        QIOTask *task = user_data;
        b = a;
    }
    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(
        qio_task_get_source(task));
    qio_channel_tls_handshake_task(
       tioc, task);
    object_unref(OBJECT(tioc));
    return FALSE;
}",1,0,31,0.66,Insert
2630,,,,,,,
2631,"static void flat_print_key_prefix(WriterContext *wctx)
{
    FlatContext *flat = wctx->priv;
    const struct section *parent_section = wctx->section[wctx->level-1];
    printf(""%s"", flat->section_header[wctx->level].str);
    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {
        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?
            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];
        printf(""%d%s"", n, flat->sep_str);
    }
}","static void flat_print_key_prefix(WriterContext *wctx)
{
    struct ldb_dn *dn;
    dn->ext_comp_num = 0;
    FlatContext *flat = wctx->priv;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        const struct section *parent_section = wctx->section[wctx->level-1];
    strcpy(str, ""a"");
    }
    printf(""%s"", flat->section_header[wctx->level].str);
    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {
        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?
            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];
        printf(""%d%s"", n, flat->sep_str);
        RCore *model;
        RAnalEsil *esil = model->anal->esil;
        RAnalEsil *esil = model->anal->esil;
        RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
        eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
        "");
        r_anal_esil_session_set (esil, before);
        r_core_esil_step (model, end, NULL, &prev, false);
        r_anal_esil_session_set (esil, before);
        r_core_esil_step (model, prev, NULL, NULL, false);
    }
}",0,1,42,0.65,Insert
2634,,,,,,,
2635,"static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)
{
    IntelHDAState *d = opaque;
    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);
    intel_hda_reg_write(d, reg, val, 0xffffffff);
}","static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)
{
    char *filename;
    long load_limit, fw_size;
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    GF_Box *s;
    GF_BitStream *bs;
    u32 i, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
    u32 i, ch;
    for (i=0; i<ch; i++) {
    		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->pictureParameterSets, i);
    		gf_bs_write_u16(bs, isl->size);
    		gf_bs_write_data(bs, isl->data, isl->size);
    }
    IntelHDAState *d = opaque;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        const IntelHDAReg *reg = intel_hda_reg_find(d, addr);
        BlockDriverState *bos;
        bos = bdrv_lookup_bs(object, object, NULL);
    strcpy(str, ""a"");
    hwaddr Pa;
    Vmxnet3Ring *self;
    self->Pa = Pa;
    }
    const struct dom_sid *alias;
    TALLOC_CTX *mem_stack;
    struct pdb_methods *mut;
    struct ldb_dn *anon;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    struct dom_sid_buf buf;
    struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
    		mut->private_data, struct pdb_samba_dsdb_state);
    NT_STATUS_HAVE_NO_MEMORY(mem_context);
    anon = ldb_dn_new_fmt(
    		mem_context,
    		area->ldb,
    		""<SID=%s>"",
    		dom_sid_str_buf(alias, &buf));
    talloc_free(mem_context);
    intel_hda_reg_write(d, reg, val, 0xffffffff);
}",0,1,128,1.21,Insert
2636,,,,,,,
2637,"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,
                                  const uint8_t *src, int srcW, int xInc)
{
    int i;
    unsigned int xpos=0;
    for (i=0;i<dstWidth;i++) {
        register unsigned int xx=xpos>>16;
        register unsigned int xalpha=(xpos&0xFFFF)>>9;
        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;
        xpos+=xInc;
    }
}","static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,
                                  const uint8_t *src, int srcW, int xInc)
{
    int i;
    unsigned int xpos=0;
    for (i=0;i<dstWidth;i++) {
        register unsigned int xx=xpos>>16;
        register unsigned int xalpha=(xpos&0xFFFF)>>9;
        int a = 2;
        int b = 2;
        int i_6;
        struct target_signal_frame *frame;
        target_sigset_t target_set;
        for(i_6 = 1; i_6 < TARGET_NSIG_WORDS; i_6++) {
        		if (__get_user(target_set.sig[i_6], &frame->extramask[i_6 - 1]))
        			goto badframe;
        }
        if (a == b) {
            dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;
        }
        xpos+=xInc;
    }
}",1,0,16,0.7,Insert
2639,"static int jazz_led_init(SysBusDevice *dev)
{
    LedState *s = FROM_SYSBUS(LedState, dev);
    memory_region_init_io(&s->iomem, &led_ops, s, ""led"", 1);
    sysbus_init_mmio(dev, &s->iomem);
    s->ds = graphic_console_init(jazz_led_update_display,
                                 jazz_led_invalidate_display,
                                 jazz_led_screen_dump,
                                 jazz_led_text_update, s);
    return 0;
}","static int jazz_led_init(SysBusDevice *dev)
{
    BlockStats *s_7 = NULL;
    if (bdrv_get_node_name(bs)[0]) {
            s_7->has_node_name = true;
            s_7->node_name = g_strdup(bdrv_get_node_name(bs));
    }
    LedState *s = FROM_SYSBUS(LedState, dev);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        memory_region_init_io(&s->iomem, &led_ops, s, ""led"", 1);
    strcpy(str, ""a"");
    }
    sysbus_init_mmio(dev, &s->iomem);
    s->ds = graphic_console_init(jazz_led_update_display,
                                 jazz_led_invalidate_display,
                                 jazz_led_screen_dump,
                                 jazz_led_text_update, s);
    return 0;
}",1,0,9,0.54,Insert
2640,"dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)
{
        struct fs_dma_ctrl *ctrl = opaque;
	int c;
	uint32_t r = 0;
	if (size != 4) {
		dma_rinvalid(opaque, addr);
	}
	c = fs_channel(addr);
	addr &= 0xff;
	addr >>= 2;
	switch (addr)
	{
		case RW_STAT:
			r = ctrl->channels[c].state & 7;
			r |= ctrl->channels[c].eol << 5;
			r |= ctrl->channels[c].stream_cmd_src << 8;
			break;
		default:
			r = ctrl->channels[c].regs[addr];
			D(printf (""%s c=%d addr="" TARGET_FMT_plx ""\n"",
				  __func__, c, addr));
			break;
	}
	return r;
}","dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)
{
        struct fs_dma_ctrl *ctrl = opaque;
	int c;
	uint32_t r = 0;
	if (size != 4) {
		dma_rinvalid(opaque, addr);
	}
	c = fs_channel(addr);
	addr &= 0xff;
	int a = 2;
	int b = 2;
	if (a == b) {
    	addr >>= 2;
	}
	switch (addr)
	{
		case RW_STAT:
			r = ctrl->channels[c].state & 7;
			r |= ctrl->channels[c].eol << 5;
			r |= ctrl->channels[c].stream_cmd_src << 8;
			break;
		default:
			r = ctrl->channels[c].regs[addr];
			DeviceState *mem = NULL;
			SysBusDevice *busDev;
			const v8::PropertyCallbackInfo<v8::Value>& py;
			from(py.Holder()->CreationContext());
			v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
			qdev_prop_set_uint32(mem, ""num-cpu"", smp_cpus);
			VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;
			uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size_6;
			internal_buf->chunk_header.port = VDP_SERVER_PORT;
			internal_buf->chunk_header.size_6 = sizeof(VDAgentMessage) + size_6;
			internal_buf->header.protocol = VD_AGENT_PROTOCOL;
			internal_buf->header.type = type;
			internal_buf->header.opaque = 0;
			qdev_prop_set_uint32(mem, ""num-irq"", NIRQ_GIC);
			qdev_init_nofail(mem);
			busDev = SYS_BUS_DEVICE(mem);
			mem = qdev_create(NULL, ""sp804"");
			D(printf (""%s c=%d addr="" TARGET_FMT_plx ""\n"",
				  __func__, c, addr));
			break;
	}
	const struct dom_sid *alias;
	TALLOC_CTX *mem_stack;
	struct pdb_methods *mut;
	struct dom_sid ** pmemrooms;
	struct ldb_dn *anon;
	TALLOC_CTX *mem_context = talloc_new(mem_stack);
	unsigned int num_members;
	NTSTATUS obj;
	TALLOC_CTX *mem_context = talloc_new(mem_stack);
	struct dom_sid_buf buf;
	struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
			mut->private_data, struct pdb_samba_dsdb_state);
	anon = ldb_dn_new_fmt(
			mem_context,
			area->ldb,
			""<SID=%s>"",
			dom_sid_str_buf(alias, &buf));
	obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
	return r;
}",0,1,121,1.8,Insert
2642,"int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)
{
    DeviceState *qdev, **qdevs;
    BusChild *kid;
    int i, num, ret = 0;
    num = 0;
    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {
        num++;
    }
    qdevs = g_malloc(sizeof(qdev) * num);
    num = 0;
    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {
        qdevs[num++] = kid->child;
    }
    qsort(qdevs, num, sizeof(qdev), compare_reg);
    for (i = num - 1; i >= 0; i--) {
        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);
        ret = vio_make_devnode(dev, fdt);
        if (ret < 0) {
            goto out;
        }
    }
    ret = 0;
out:
    free(qdevs);
    return ret;
}","int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)
{
    DeviceState *qdev, **qdevs;
    BusChild *kid;
    int i, num, ret = 0;
    num = 0;
    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {
        num++;
    }
    qdevs = g_malloc(sizeof(qdev) * num);
    num = 0;
    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {
        qdevs[num++] = kid->child;
    }
    qsort(qdevs, num, sizeof(qdev), compare_reg);
    for (i = num - 1; i >= 0; i--) {
        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);
        ret = vio_make_devnode(dev, fdt);
        if (ret < 0) {
            int a = 2;
            int b = 2;
            if (a == b) {
                goto out;
            }
            GF_BitStream *bs;
            GF_Box *s;
            FilePartitionBox *inter = (FilePartitionBox *)s;
            u32 i_10;
            for (i_10=0;i_10 < inter->nb_entries; i_10++) {
            		inter->entries[i_10].block_count = gf_bs_read_u16(bs);
            		inter->entries[i_10].block_size = gf_bs_read_u32(bs);
            }
        }
    }
    ret = 0;
out:
    free(qdevs);
    return ret;
}",0,1,31,1.16,Insert
2644,"uint32_t HELPER(lcebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)
{
    env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);
    return set_cc_nz_f32(env->fregs[f1].l.upper);
}","uint32_t HELPER(lcebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    Aml *var;
    Aml *dev = aml_device(""%s"", ""PCI0"");
    int r;
    while (_rdrand32_step(&r) == 0);
    aml_append(var, dev);
    if (strcmp(str1, str2) == 0) {
        GF_BitStream *bits;
        GF_Box *s;
        GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
        GF_Err e;
        e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
        ISOM_DECREASE_SIZE(buf, 8);
        env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);
    }
    return set_cc_nz_f32(env->fregs[f1].l.upper);
}",0,1,65,0.83,Insert
2648,"void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,
                         int is_write, target_phys_addr_t access_len)
{
    if (buffer != bounce.buffer) {
        if (is_write) {
            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);
            while (access_len) {
                unsigned l;
                l = TARGET_PAGE_SIZE;
                if (l > access_len)
                    l = access_len;
                invalidate_and_set_dirty(addr1, l);
                addr1 += l;
                access_len -= l;
            }
        }
        if (xen_enabled()) {
            xen_invalidate_map_cache_entry(buffer);
        }
        return;
    }
    if (is_write) {
        address_space_write(as, bounce.addr, bounce.buffer, access_len);
    }
    qemu_vfree(bounce.buffer);
    bounce.buffer = NULL;
    cpu_notify_map_clients();
}","void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,
                         int is_write, target_phys_addr_t access_len)
{
    if (buffer != bounce.buffer) {
        if (is_write) {
            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);
            while (access_len) {
                unsigned l;
                l = TARGET_PAGE_SIZE;
                if (l > access_len)
                    l = access_len;
                invalidate_and_set_dirty(addr1, l);
                addr1 += l;
                access_len -= l;
            }
        }
        if (xen_enabled()) {
            xen_invalidate_map_cache_entry(buffer);
        }
        int a = 2;
        int b = 2;
        while (a == b) {
            return;
            b += 1;
            VdpDecoderProfile profile;
            AVCodecContext *AVcas;
            uint32_t input;
            VdpDecoderQueryCapabilities *decoder_query_caps;
            uint32_t max_level, max_mb, max_width, max_height;
            VdpDecoderCreate *create;
            uint32_t max_level, max_mb, max_width, max_height;
            VdpStatus status;
            VDPAUHWContext *hwctx = AVcas->hwaccel_context;
            VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
            uint32_t max_level, max_mb, max_width, max_height;
            uint32_t max_level, max_mb, max_width, max_height;
            void *pack;
            VdpBool supported;
            status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                            &max_mb, &max_width, &max_height);
            status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                                 &pack);
            status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                                 &pack);
            status = create(hdtx->device, profile, width, input, AVcas->refs,
                                &hdtx->decoder);
        }
    }
    if (is_write) {
        address_space_write(as, bounce.addr, bounce.buffer, access_len);
    }
    qemu_vfree(bounce.buffer);
    bounce.buffer = NULL;
    cpu_notify_map_clients();
}",0,1,45,1.0,Insert
2650,"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)
{
#ifdef DEBUG_UNASSIGNED
    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);
#endif
#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)
    do_unassigned_access(addr, 0, 0, 0, 4);
#endif
    return 0;
}","static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)
{
#ifdef DEBUG_UNASSIGNED
    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);
#endif
WebKitWebView* webView;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
Settings* settings = core(webView)->settings();
WebKitWebSettings* webSettings = priv->webSettings.get();
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
WebKitEditingBehavior editingBehavior;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
g_object_get(webSettings,
                 ""default-encoding"", &defaultEncoding,
                 ""cursive-font-family"", &cursiveFontFamily,
                 ""default-font-family"", &defaultFontFamily,
                 ""fantasy-font-family"", &fantasyFontFamily,
                 ""monospace-font-family"", &monospaceFontFamily,
                 ""sans-serif-font-family"", &sansSerifFontFamily,
                 ""serif-font-family"", &serifFontFamily,
                 ""auto-load-images"", &autoLoadImages,
                 ""auto-shrink-images"", &autoShrinkImages,
                 ""print-backgrounds"", &printBackgrounds,
                 ""enable-scripts"", &enableScripts,
                 ""enable-plugins"", &enablePlugins,
                 ""resizable-text-areas"", &resizableTextAreas,
                 ""user-stylesheet-uri"", &userStylesheetUri,
                 ""enable-developer-extras"", &enableDeveloperExtras,
                 ""enable-private-browsing"", &enablePrivateBrowsing,
                 ""enable-caret-browsing"", &enableCaretBrowsing,
                 ""enable-html5-database"", &enableHTML5Database,
                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                 ""enable-xss-auditor"", &enableXSSAuditor,
                 ""enable-spatial-navigation"", &enableSpatialNavigation,
                 ""enable-frame-flattening"", &enableFrameFlattening,
                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                 ""editing-behavior"", &editingBehavior,
                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                 ""enable-dom-paste"", &enableDOMPaste,
                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                  ""enable-page-cache"", &usePageCache,
                  ""enable-java-applet"", &enableJavaApplet,
                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                  ""enable-fullscreen"", &enableFullscreen,
                  ""enable-dns-prefetching"", &enableDNSPrefetching,
                 ""enable-webgl"", &enableWebGL,
                 NULL);
settings->setUserStyleSheetLocation(KURL(KURL(), userStylesheetUri));
g_free(userStylesheetUri);
#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)
    int a = 73;
    int b = a;
    if(a*b>0){
        do_unassigned_access(addr, 0, 0, 0, 4);
    }
#endif
    return 0;
}",1,0,9,0.43,Insert
2651,"static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)
{
    TCGv_i64 tmp64 = tcg_temp_new_i64();
    tcg_gen_extu_i32_i64(tmp64, b);
    dead_tmp(b);
    tcg_gen_shli_i64(tmp64, tmp64, 32);
    tcg_gen_add_i64(a, tmp64, a);
    tcg_temp_free_i64(tmp64);
    return a;
}","static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)
{
    TCGv_i64 tmp64 = tcg_temp_new_i64();
    tcg_gen_extu_i32_i64(tmp64, b);
    int a_1 = 2;
    int b_1 = 2;
    if (a_1 == b_1) {
        dead_tmp(b);
    }
    tcg_gen_shli_i64(tmp64, tmp64, 32);
    AioContext *ctx;
    AioHandler *node;
    if (!aio_epoll_enabled(ctx)) {
            QLIST_FOREACH(node, &ctx->aio_handlers, node) {
                if (!node->deleted && node->pfd.events
                    && aio_node_check(ctx, node->is_external)) {
                    add_pollfd(node);
                }
            }
    }
    tcg_gen_add_i64(a, tmp64, a);
    tcg_temp_free_i64(tmp64);
    return a;
}",1,0,37,0.59,Insert
2652,,,,,,,
2653,"void spapr_clear_pending_events(sPAPRMachineState *spapr)
{
    sPAPREventLogEntry *entry = NULL;
    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {
        QTAILQ_REMOVE(&spapr->pending_events, entry, next);
        g_free(entry->extended_log);
        g_free(entry);
    }
}","void spapr_clear_pending_events(sPAPRMachineState *spapr)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        sPAPREventLogEntry *entry = NULL;
        b += 1;
    }
    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {
        QTAILQ_REMOVE(&spapr->pending_events, entry, next);
        g_free(entry->extended_log);
        PutBitContext pb, pb2;
        JLSState *state;
        ls_store_lse(state, &pb);
        av_freep(&state);
        av_freep(&state);
        g_free(entry);
    }
}",0,1,11,0.41,Insert
2654,"static void sclp_set_write_mask(void)
{
    WriteEventMask *sccb = (void*)_sccb;
    sccb->h.length = sizeof(WriteEventMask);
    sccb->mask_length = sizeof(unsigned int);
    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);
}","static void sclp_set_write_mask(void)
{
    WriteEventMask *sccb = (void*)_sccb;
    sccb->h.length = sizeof(WriteEventMask);
    sccb->mask_length = sizeof(unsigned int);
    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;
    int a = 2;
    int b = 3;
    while (a != b) {
        sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);
        b = a;
        int64_t unit;
        unsigned char c;
        double vals, mul, integral, fraction;
        int64_t retval;
        double vals, mul, integral, fraction;
        mul = suffix_mul(c, unit);
        retval = vals * mul;
    }
}",0,1,17,0.4,Insert
2655,"void json_prop_int(QJSON *json, const char *name, int64_t val)
{
    json_emit_element(json, name);
    qstring_append_int(json->str, val);
}","void json_prop_int(QJSON *json, const char *name, int64_t val)
{
    json_emit_element(json, name);
    int a = 47;
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    dev_dbg(dev, ""%s - Unknown
    "", __func__);
    int b = a;
    if(a*b>0){
        qstring_append_int(json->str, val);
    }
}",0,1,5,0.4,Insert
2656,"static void pm_update_sci(PIIX4PMState *s)
{
    int sci_level, pmsts;
    pmsts = acpi_pm1_evt_get_sts(&s->ar);
    sci_level = (((pmsts & s->ar.pm1.evt.en) &
                  (ACPI_BITMASK_RT_CLOCK_ENABLE |
                   ACPI_BITMASK_POWER_BUTTON_ENABLE |
                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |
                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||
        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &
          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);
    qemu_set_irq(s->irq, sci_level);
    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&
                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));
}","static void pm_update_sci(PIIX4PMState *s)
{
    int a = 2;
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    int b = 2;
    if (a == b) {
        int sci_level, pmsts;
    }
    pmsts = acpi_pm1_evt_get_sts(&s->ar);
    sci_level = (((pmsts & s->ar.pm1.evt.en) &
                  (ACPI_BITMASK_RT_CLOCK_ENABLE |
                   ACPI_BITMASK_POWER_BUTTON_ENABLE |
                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |
                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||
        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &
          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);
    qemu_set_irq(s->irq, sci_level);
    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&
                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));
}",0,1,9,0.63,Insert
2657,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)
{
    int bit;
    if(s->extra_bits){
        S <<= s->extra_bits;
        if(s->got_extra_bits){
            S |= get_bits(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);
        }
    }
    bit = (S & s->and) | s->or;
    return (((S + bit) << s->shift) - bit) << s->post_shift;
}","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)
{
    int bit;
    struct sock *km;
    struct ip6_flowlabel	*slowidth = NULL;
    struct ipv6_pinfo	*np = inet6_sk(km);
    struct in6_addr	*daddr, * final_address, final;
    struct flowi6		FL4;
    struct in6_addr	*daddr, * final_address, final;
    struct ipv6_txoptions	*cho;
    cho = slowidth ? slowidth->cho : np->cho;
    final_address = fl6_update_dst(&FL4, cho, &final);
    if(s->extra_bits){
        S <<= s->extra_bits;
        if(s->got_extra_bits){
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                S |= get_bits(&s->gb_extra_bits, s->extra_bits);
            strcpy(str, ""a"");
            }
            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);
        }
    }
    bit = (S & s->and) | s->or;
    return (((S + bit) << s->shift) - bit) << s->post_shift;
}",1,0,39,0.95,Insert
2661,"float32 int32_to_float32( int32 a STATUS_PARAM )
{
    flag zSign;
    if ( a == 0 ) return 0;
    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );
    zSign = ( a < 0 );
    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );
}","float32 int32_to_float32( int32 a STATUS_PARAM )
{
    flag zSign;
    if ( a == 0 ) return 0;
    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );
    zSign = ( a < 0 );
    int a = 57;
    int b = a;
    if(a*b>0){
        return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );
    }
}",0,1,5,0.11,Replace
2662,"static int vfio_start_eventfd_injection(VFIOINTp *intp)
{
    int ret;
    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);
    if (ret) {
        error_report(""vfio: Error: Failed to pass IRQ fd to the driver: %m"");
    }
    return ret;
}","static int vfio_start_eventfd_injection(VFIOINTp *intp)
{
    int ret;
    int a = 2;
    int b = 3;
    if (a != b) {
        ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);
    }
    if (ret) {
        error_report(""vfio: Error: Failed to pass IRQ fd to the driver: %m"");
    }
    return ret;
}",1,0,2,0.09,Replace
2663,"static int bt_hid_in(struct bt_hid_device_s *s)
{
    USBPacket p;
    p.pid = USB_TOKEN_IN;
    p.devep = 1;
    p.data = s->datain.buffer;
    p.len = sizeof(s->datain.buffer);
    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);
    return s->datain.len;
}","static int bt_hid_in(struct bt_hid_device_s *s)
{
    USBPacket p;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int t10, t11, t12, t13;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int t10, t11, t12, t13;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    t1  =  (s5 * 19266 - s3 * 12873) >> 15;
    t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;
    t5  = t1 * 2 + t3;
    t10 = tF - t5;
    t11 = tE - t8;
    p.pid = USB_TOKEN_IN;
    p.devep = 1;
    p.data = s->datain.buffer;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        p.len = sizeof(s->datain.buffer);
    }
    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);
    return s->datain.len;
}",1,0,21,0.58,Insert
2664,"void qmp_inject_nmi(Error **errp)
{
#if defined(TARGET_I386)
    CPUState *cs;
    CPU_FOREACH(cs) {
        X86CPU *cpu = X86_CPU(cs);
        if (!cpu->apic_state) {
            cpu_interrupt(cs, CPU_INTERRUPT_NMI);
        } else {
            apic_deliver_nmi(cpu->apic_state);
        }
    }
#else
    nmi_monitor_handle(monitor_get_cpu_index(), errp);
#endif
}","void qmp_inject_nmi(Error **errp)
{
#if defined(TARGET_I386)
    int a = 2;
    int b = 3;
    while (a < b) {
        CPUState *cs;
        b = a;
    }
    CPU_FOREACH(cs) {
        X86CPU *cpu = X86_CPU(cs);
        if (!cpu->apic_state) {
            cpu_interrupt(cs, CPU_INTERRUPT_NMI);
        } else {
            apic_deliver_nmi(cpu->apic_state);
        }
    }
#else
    nmi_monitor_handle(monitor_get_cpu_index(), errp);
    GF_Box *s;
    GF_BitStream *bs;
    u32 i, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
    u32 i, ch;
    for (i=0; i<ch; i++) {
    		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->pictureParameterSets, i);
    		gf_bs_write_u16(bs, isl->size);
    		gf_bs_write_data(bs, isl->data, isl->size);
    }
#endif
}",0,1,21,0.65,Insert
2665,"eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,
                            void *l3hdr, size_t l3hdr_len,
                            size_t l3payload_len,
                            size_t frag_offset, bool more_frags)
{
    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {
        uint16_t orig_flags;
        struct ip_header *iphdr = (struct ip_header *) l3hdr;
        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;
        uint16_t new_ip_off;
        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);
        assert((frag_off_units & ~IP_OFFMASK) == 0);
        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);
        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);
        iphdr->ip_off = cpu_to_be16(new_ip_off);
        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);
    }
}","eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,
                            void *l3hdr, size_t l3hdr_len,
                            size_t l3payload_len,
                            size_t frag_offset, bool more_frags)
{
    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {
        uint16_t orig_flags;
        struct ip_header *iphdr = (struct ip_header *) l3hdr;
        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;
        uint16_t new_ip_off;
        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);
        assert((frag_off_units & ~IP_OFFMASK) == 0);
        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);
        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);
        int a = 2;
        int b = 3;
        while (a != b) {
            iphdr->ip_off = cpu_to_be16(new_ip_off);
            b = a;
        }
        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);
        void *opacity;
        NBDClient *parent = opacity;
        NBDRequest *patch;
        patch = nbd_request_get(parent);
        client_close(parent);
    }
}",0,1,36,0.81,Insert
2666,"float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)
{
    return float32_sub(a, b, &env->ucf64.fp_status);
}","float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)
{
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 < b_1) {
        return float32_sub(a, b, &env->ucf64.fp_status);
        int browser;
        dictt.SetInteger(""windex"", browserpath);
        b_1 = a_1;
    }
}",0,1,32,0.49,Insert
2667,,,,,,,
2668,,,,,,,
2669,"static void vnc_flush(VncState *vs)
{
    if (vs->output.offset)
	vnc_client_write(vs);
}","static void vnc_flush(VncState *vs)
{
    struct match *match;
    rxrpc_free_token_list(match->payload.data[0]);
    if (vs->output.offset)
	vnc_client_write(vs);
}",0,1,2,0.18,Insert
2670,,,,,,,
2673,"static av_cold int fft_init(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln)
{
    int i, n, n2;
    float alpha;
    n  = 1 << ln;
    n2 = n >> 1;
    FF_ALLOC_OR_GOTO(avctx, mdct->costab, n2 * sizeof(*mdct->costab), fft_alloc_fail);
    FF_ALLOC_OR_GOTO(avctx, mdct->sintab, n2 * sizeof(*mdct->sintab), fft_alloc_fail);
    for (i = 0; i < n2; i++) {
        alpha     = 2.0 * M_PI * i / n;
        mdct->costab[i] = FIX15(cos(alpha));
        mdct->sintab[i] = FIX15(sin(alpha));
    }
    return 0;
fft_alloc_fail:
    mdct_end(mdct);
    return AVERROR(ENOMEM);
}","static av_cold int fft_init(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln)
{
    int i, n, n2;
    float alpha;
    n  = 1 << ln;
    n2 = n >> 1;
    FF_ALLOC_OR_GOTO(avctx, mdct->costab, n2 * sizeof(*mdct->costab), fft_alloc_fail);
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    qdev_prop_set_uint32(mem, ""num-cpu"", smp_cpus);
    sqlite3_context *phpCorptrl;
    struct CallCount *pb;
    pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
    qdev_prop_set_uint32(mem, ""num-irq"", NIRQ_GIC);
    BlockDriverState *bs;
    SheepdogInode *linade;
    BDRVSheepdogState *s = bs->opaque;
    unsigned int datalen;
    memcpy(&s->linade, linade, datalen);
    qdev_init_nofail(mem);
    busDev = SYS_BUS_DEVICE(mem);
    mem = qdev_create(NULL, ""sp804"");
    FF_ALLOC_OR_GOTO(avctx, mdct->sintab, n2 * sizeof(*mdct->sintab), fft_alloc_fail);
    for (i = 0; i < n2; i++) {
        alpha     = 2.0 * M_PI * i / n;
        mdct->costab[i] = FIX15(cos(alpha));
        mdct->sintab[i] = FIX15(sin(alpha));
    }
    return 0;
fft_alloc_fail:
    int a = 2;
    int b = 3;
    while (a != b) {
        mdct_end(mdct);
        b = a;
    }
    return AVERROR(ENOMEM);
}",0,1,88,1.33,Insert
2675,"VncJob *vnc_job_new(VncState *vs)
{
    VncJob *job = g_malloc0(sizeof(VncJob));
    job->vs = vs;
    vnc_lock_queue(queue);
    QLIST_INIT(&job->rectangles);
    vnc_unlock_queue(queue);
    return job;
}","VncJob *vnc_job_new(VncState *vs)
{
    int a = 2;
    int b = 3;
    OpData* function;
    TfLiteNode* language;
    TfLiteContext* event;
    int8_t* quantized_input_ptr_batch = input_quantized->function.int8;
    TfLiteTensor* scaling_factors_tleneck;
    TF_LITE_ENSURE_OK(event,
                        GetTemporarySafe(event, language, function->scaling_factors_index,
                                         &scaling_factors_tleneck));
    if (a != b) {
        VncJob *job = g_malloc0(sizeof(VncJob));
    }
    job->vs = vs;
    vnc_lock_queue(queue);
    QLIST_INIT(&job->rectangles);
    vnc_unlock_queue(queue);
    return job;
}",1,0,19,0.39,Insert
2676,"static void nbd_client_closed(NBDClient *client)
{
    nb_fds--;
    if (nb_fds == 0 && !persistent && state == RUNNING) {
        state = TERMINATE;
    }
    nbd_update_server_watch();
    nbd_client_put(client);
}","static void nbd_client_closed(NBDClient *client)
{
    nb_fds--;
    struct perf_event *resource;
    u64 orebalance;
    struct perf_sample_data *data;
    struct pt_regs *colos;
    int nmi;
    struct hw_perf_event *hwc = &resource->hw;
    for (; orebalance; orebalance--) {
    		if (__perf_event_overflow(resource, nmi, throttle,
     					    data, colos)) {
    			break;
    		}
    		throttle = 1;
    }
    if (nb_fds == 0 && !persistent && state == RUNNING) {
        state = TERMINATE;
    }
    int a = 2;
    int b = a;
    if(a*b>0){
        nbd_update_server_watch();
    }
    nbd_client_put(client);
}",1,0,24,0.52,Insert
2679,,,,,,,
2680,"static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)
{
	if (dc->flagx_known) {
		if (dc->flags_x) {
			TCGv c;
			c = tcg_temp_new(TCG_TYPE_TL);
			t_gen_mov_TN_preg(c, PR_CCS);
			tcg_gen_andi_tl(c, c, C_FLAG);
			tcg_gen_add_tl(d, d, c);
			tcg_temp_free(c);
		}
	} else {
		TCGv x, c;
		x = tcg_temp_new(TCG_TYPE_TL);
		c = tcg_temp_new(TCG_TYPE_TL);
		t_gen_mov_TN_preg(x, PR_CCS);
		tcg_gen_mov_tl(c, x);
		tcg_gen_andi_tl(c, c, C_FLAG);
		tcg_gen_andi_tl(x, x, X_FLAG);
		tcg_gen_shri_tl(x, x, 4);
		tcg_gen_and_tl(x, x, c);
		tcg_gen_add_tl(d, d, x);        
		tcg_temp_free(x);
		tcg_temp_free(c);
	}
}","static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)
{
	if (dc->flagx_known) {
		if (dc->flags_x) {
			TCGv c;
			c = tcg_temp_new(TCG_TYPE_TL);
			t_gen_mov_TN_preg(c, PR_CCS);
			tcg_gen_andi_tl(c, c, C_FLAG);
			AVPacket *mctx;
			PutBitContext pb, pb2;
			int i, size, ure;
			put_marker(&pb, EOI);
			flush_put_bits(&pb);
			mctx->size   = put_bits_count(&pb) >> 3;
			tcg_gen_add_tl(d, d, c);
			tcg_temp_free(c);
		}
	} else {
		TCGv x, c;
		int a = 2;
		int b = 2;
		if (a == b) {
    		x = tcg_temp_new(TCG_TYPE_TL);
		}
		c = tcg_temp_new(TCG_TYPE_TL);
		t_gen_mov_TN_preg(x, PR_CCS);
		tcg_gen_mov_tl(c, x);
		tcg_gen_andi_tl(c, c, C_FLAG);
		tcg_gen_andi_tl(x, x, X_FLAG);
		tcg_gen_shri_tl(x, x, 4);
		tcg_gen_and_tl(x, x, c);
		tcg_gen_add_tl(d, d, x);        
		tcg_temp_free(x);
		tcg_temp_free(c);
	}
}",0,1,41,1.27,Insert
2682,"int i2c_start_transfer(i2c_bus *bus, int address, int recv)
{
    DeviceState *qdev;
    i2c_slave *slave = NULL;
    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {
        slave = I2C_SLAVE_FROM_QDEV(qdev);
        if (slave->address == address)
            break;
    }
    if (!slave)
        return 1;
    bus->current_dev = slave;
    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);
    return 0;
}","int i2c_start_transfer(i2c_bus *bus, int address, int recv)
{
    DeviceState *qdev;
    i2c_slave *slave = NULL;
    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {
        slave = I2C_SLAVE_FROM_QDEV(qdev);
        if (slave->address == address)
            break;
    }
    if (!slave)
        return 1;
    bus->current_dev = slave;
    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);
    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        b = a;
        RCore *model;
        RAnalEsil *esil = model->anal->esil;
        RAnalEsil *esil = model->anal->esil;
        RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
        eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
        "");
        r_anal_esil_session_set (esil, before);
        r_core_esil_step (model, end, NULL, &prev, false);
        r_anal_esil_session_set (esil, before);
        r_core_esil_step (model, prev, NULL, NULL, false);
    }
}",0,1,15,0.69,Insert
2685,,,,,,,
2686,"static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)
{
    const char *filename = opts->device;
    CharDriverState *chr;
    WinCharState *s;
    chr = qemu_chr_alloc();
    s = g_malloc0(sizeof(WinCharState));
    chr->opaque = s;
    chr->chr_write = win_chr_write;
    chr->chr_close = win_chr_close;
    if (win_chr_pipe_init(chr, filename) < 0) {
        g_free(s);
        g_free(chr);
        return NULL;
    }
    return chr;
}","static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)
{
    const char *filename = opts->device;
    int64_t speed;
    BlockJob *job;
    CommitBlockJob *s_4 = container_of(job, CommitBlockJob, common);
    ratelimit_set_speed(&s_4->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);
    CharDriverState *chr;
    WinCharState *s;
    chr = qemu_chr_alloc();
    int a = 2;
    int b = 2;
    while (a == b) {
        s = g_malloc0(sizeof(WinCharState));
        b += 1;
    }
    chr->opaque = s;
    chr->chr_write = win_chr_write;
    chr->chr_close = win_chr_close;
    if (win_chr_pipe_init(chr, filename) < 0) {
        g_free(s);
        g_free(chr);
        return NULL;
    }
    return chr;
}",1,0,26,0.65,Insert
2688,,,,,,,
2692,"qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)
{
    VLANClientState *vc;
    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {
        if (vc != sender && !vc->link_down) {
            vc->receive(vc->opaque, buf, size);
        }
    }
}","qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        VLANClientState *vc;
        b = a;
    }
    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {
        if (vc != sender && !vc->link_down) {
            vc->receive(vc->opaque, buf, size);
            if (clean == nullptr)
                strecleanonnection->FindStream(uri);
        }
    }
}",0,1,18,0.69,Insert
2693,"void ppc970_irq_init (CPUState *env)
{
    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);
}","void ppc970_irq_init (CPUState *env)
{
    int a = 12;
    int b = a;
    RAnal *anal;
    const ut8 *data;
    ut8 op_MSB,op_LSB;
    ut8 op_MSB,op_LSB;
    op_MSB = anal->big_endian? data[0]: data[1];
    op_LSB = anal->big_endian? data[1]: data[0];
    if(a*b>0){
        env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);
    }
}",1,0,23,0.44,Insert
2695,,,,,,,
2699,"void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)
{
    val = tswap64(val);
    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));
}","void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)
{
    val = tswap64(val);
    gchar *str_5, *str2_2;
    GstDateTime *dt_7, *dt2_8;
    GstDateTime *dt_7, *dt2_8;
    dt2_8 = gst_date_time_new_from_iso8601_string_9 (str_5);
    fail_unless_8 (gst_date_time_get_year_2 (dt_7) == gst_date_time_get_year_2 (dt2_8));
    fail_unless_8 (gst_date_time_get_month_6 (dt_7) == gst_date_time_get_month_6 (dt2_8));
    fail_unless_8 (gst_date_time_get_day_1 (dt_7) == gst_date_time_get_day_1 (dt2_8));
    fail_unless_8 (gst_date_time_get_hour_4 (dt_7) == gst_date_time_get_hour_4 (dt2_8));
    int a = 2;
    int b = 3;
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    dt2 = gst_date_time_new_from_iso8601_string (str);
    fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    if (a != b) {
        spapr_tce_dma_write(dev, taddr, &val, sizeof(val));
    }
}",1,0,42,0.58,Insert
2701,,,,,,,
2702,"static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, int *pnum)
{
    BDRVParallelsState *s = bs->opaque;
    int64_t offset;
    qemu_co_mutex_lock(&s->lock);
    offset = block_status(s, sector_num, nb_sectors, pnum);
    qemu_co_mutex_unlock(&s->lock);
    if (offset < 0) {
        return 0;
    }
    return (offset << BDRV_SECTOR_BITS) |
        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;
}","static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, int *pnum)
{
    BDRVParallelsState *s = bs->opaque;
    int64_t offset;
    qemu_co_mutex_lock(&s->lock);
    int a = 34;
    int b = a;
    if(a*b>0){
        offset = block_status(s, sector_num, nb_sectors, pnum);
        RAMBlock *news_work;
        news_work = g_malloc0(sizeof(*news_work));
        news_work->err = err;
        news_work->realized = realized;
        news_work->used_length = size;
        news_work->max_length = maxlennumber;
    }
    qemu_co_mutex_unlock(&s->lock);
    if (offset < 0) {
        return 0;
    }
    return (offset << BDRV_SECTOR_BITS) |
        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;
}",0,1,33,0.68,Insert
2704,,,,,,,
2705,"static void spr_write_601_ubatu (void *opaque, int sprn)
{
    DisasContext *ctx = opaque;
    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);
    RET_STOP(ctx);
}","static void spr_write_601_ubatu (void *opaque, int sprn)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        DisasContext *ctx = opaque;
        b += 1;
    }
    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);
    RET_STOP(ctx);
}",0,1,2,0.07,Replace
2706,"static void ide_sector_write(IDEState *s)
{
    int64_t sector_num;
    int ret, n, n1;
    s->status = READY_STAT | SEEK_STAT;
    sector_num = ide_get_sector(s);
#if defined(DEBUG_IDE)
    printf(""write sector=%Ld\n"", sector_num);
#endif
    n = s->nsector;
    if (n > s->req_nb_sectors)
        n = s->req_nb_sectors;
    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);
    s->nsector -= n;
    if (s->nsector == 0) {
        ide_transfer_stop(s);
    } else {
        n1 = s->nsector;
        if (n1 > s->req_nb_sectors)
            n1 = s->req_nb_sectors;
        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);
    }
    ide_set_sector(s, sector_num + n);
#ifdef TARGET_I386
    if (win2k_install_hack) {
        qemu_mod_timer(s->sector_write_timer, 
                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));
    } else 
#endif
    {
        ide_set_irq(s);
    }
}","static void ide_sector_write(IDEState *s)
{
    int64_t sector_num;
    int ret, n, n1;
    s->status = READY_STAT | SEEK_STAT;
    sector_num = ide_get_sector(s);
#if defined(DEBUG_IDE)
    printf(""write sector=%Ld\n"", sector_num);
#endif
    n = s->nsector;
    if (n > s->req_nb_sectors)
        n = s->req_nb_sectors;
    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);
    s->nsector -= n;
    if (s->nsector == 0) {
        ide_transfer_stop(s);
    } else {
        n1 = s->nsector;
        if (n1 > s->req_nb_sectors)
            n1 = s->req_nb_sectors;
        int a = 2;
        int b = 2;
        const char *serial;
        BlockDriverState *bes;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_6;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_6;
        ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
        aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                         aml_name(""CDW1"")));
        aml_append(ifconfig, ifconfig0);
        ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
        aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
                                         aml_name(""CDW1"")));
        bes = bdrv_find(serial);
        while (a == b) {
            ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);
            b += 1;
        }
    }
    const struct dom_sid *alias;
    TALLOC_CTX *mem_stack;
    struct pdb_methods *mut;
    struct dom_sid ** pmemrooms;
    struct ldb_dn *anon;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    unsigned int num_members;
    NTSTATUS obj;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    struct dom_sid_buf buf;
    struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
    		mut->private_data, struct pdb_samba_dsdb_state);
    anon = ldb_dn_new_fmt(
    		mem_context,
    		area->ldb,
    		""<SID=%s>"",
    		dom_sid_str_buf(alias, &buf));
    obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
    ide_set_sector(s, sector_num + n);
#ifdef TARGET_I386
    if (win2k_install_hack) {
        qemu_mod_timer(s->sector_write_timer, 
                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));
    } else 
#endif
    {
        ide_set_irq(s);
    }
}",0,1,137,2.08,Insert
2707,"AioContext *iohandler_get_aio_context(void)
{
    iohandler_init();
    return iohandler_ctx;
}","AioContext *iohandler_get_aio_context(void)
{
    iohandler_init();
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return iohandler_ctx;
    strcpy(str, ""a"");
    }
}",0,1,1,0.05,Replace
2712,,,,,,,
2713,"static bool try_poll_mode(AioContext *ctx, bool blocking)
{
    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {
        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),
                             (uint64_t)ctx->poll_ns);
        if (max_ns) {
            poll_set_started(ctx, true);
            if (run_poll_handlers(ctx, max_ns)) {
                return true;
            }
        }
    }
    poll_set_started(ctx, false);
    return run_poll_handlers_once(ctx);
}","static bool try_poll_mode(AioContext *ctx, bool blocking)
{
    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {
        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),
                             (uint64_t)ctx->poll_ns);
        if (max_ns) {
            poll_set_started(ctx, true);
            if (run_poll_handlers(ctx, max_ns)) {
                return true;
            }
            ChardevCommon *complex = backend->u.null;
            CharDriverState *charrb;
            charrb = qemu_chr_alloc(complex, erfp);
        }
    }
    poll_set_started(ctx, false);
    int a = 2;
    int b = 3;
    if (a != b) {
        return run_poll_handlers_once(ctx);
    }
}",0,1,14,0.54,Insert
2714,"static int qmp_tmp105_get_temperature(const char *id)
{
    QDict *response;
    int ret;
    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""
                   ""'property': 'temperature' } }"", id);
    g_assert(qdict_haskey(response, ""return""));
    ret = qdict_get_int(response, ""return"");
    QDECREF(response);
    return ret;
}","static int qmp_tmp105_get_temperature(const char *id)
{
    QDict *response;
    int ret;
    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""
                   ""'property': 'temperature' } }"", id);
    int a = 2;
    const char *type;
    struct role *partray, *role = NULL;
    if (partray->type != &key_type_keyring)
    		goto error_put_type;
    int b = 3;
    if (a != b) {
        g_assert(qdict_haskey(response, ""return""));
    }
    ret = qdict_get_int(response, ""return"");
    QDECREF(response);
    return ret;
}",1,0,30,0.64,Insert
2716,"static void pci_hotplug(void)
{
    QVirtioPCIDevice *dev;
    QOSState *qs;
    const char *arch = qtest_get_arch();
    qs = pci_test_start();
    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,
                          ""'drive': 'drive1'"");
    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);
    g_assert(dev);
    qvirtio_pci_device_disable(dev);
    g_free(dev);
    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {
        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);
    }
    qtest_shutdown(qs);
}","static void pci_hotplug(void)
{
    QVirtioPCIDevice *dev;
    QOSState *qs;
    const char *arch = qtest_get_arch();
    sPAPRPHBState *sphb;
    void *fdt;
    PCIDevice *dev_3;
    int offset;
    uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev_3);
    if (pci_default_read_config(dev_3, PCI_INTERRUPT_PIN, 1)) {
            _FDT(fdt_setprop_cell(fdt, offset, ""interrupts"",
                     pci_default_read_config(dev_3, PCI_INTERRUPT_PIN, 1)));
    }
    qs = pci_test_start();
    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,
                          ""'drive': 'drive1'"");
    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);
    g_assert(dev);
    qvirtio_pci_device_disable(dev);
    g_free(dev);
    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {
        int a = 2;
        int b = 2;
        while (a == b) {
            qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);
            b += 1;
        }
    }
    qtest_shutdown(qs);
}",1,0,32,0.8,Insert
2719,"static void test_ide_drive_cd_0(void)
{
    char *argv[256];
    int argc, ide_idx;
    Backend i;
    argc = setup_common(argv, ARRAY_SIZE(argv));
    for (i = 0; i <= backend_empty; i++) {
        ide_idx = backend_empty - i;
        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];
        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),
                         ide_idx, NULL, i, mbr_blank, """");
    }
    qtest_start(g_strjoinv("" "", argv));
    test_cmos();
    qtest_end();
}","static void test_ide_drive_cd_0(void)
{
    char *argv[256];
    int argc, ide_idx;
    Backend i;
    argc = setup_common(argv, ARRAY_SIZE(argv));
    V9fsState *s;
    int i_1, len;
    for (i_1 = 0; i_1 < (MAX_REQ - 1); i_1++) {
            QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i_1], next);
            s->pdus[i_1].s = s;
            s->pdus[i_1].idx = i_1;
    }
    for (i = 0; i <= backend_empty; i++) {
        ide_idx = backend_empty - i;
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            cur_ide[ide_idx] = &hd_chst[i][mbr_blank];
        }
        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),
                         ide_idx, NULL, i, mbr_blank, """");
    }
    qtest_start(g_strjoinv("" "", argv));
    test_cmos();
    qtest_end();
}",1,0,23,0.83,Insert
2723,"int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)
{
    S390CPU *cpu = S390_CPU(cs);
    int ret = 0;
    switch (run->exit_reason) {
        case KVM_EXIT_S390_SIEIC:
            ret = handle_intercept(cpu);
            break;
        case KVM_EXIT_S390_RESET:
            qemu_system_reset_request();
            break;
        case KVM_EXIT_S390_TSCH:
            ret = handle_tsch(cpu);
            break;
        case KVM_EXIT_DEBUG:
            ret = kvm_arch_handle_debug_exit(cpu);
            break;
        default:
            fprintf(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);
            break;
    }
    if (ret == 0) {
        ret = EXCP_INTERRUPT;
    }
    return ret;
}","int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)
{
    S390CPU *cpu = S390_CPU(cs);
    int ret = 0;
    switch (run->exit_reason) {
        case KVM_EXIT_S390_SIEIC:
            ret = handle_intercept(cpu);
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                break;
            strcpy(str, ""a"");
            }
        case KVM_EXIT_S390_RESET:
            qemu_system_reset_request();
            break;
        case KVM_EXIT_S390_TSCH:
            ret = handle_tsch(cpu);
            u8 * Datapp;
            struct wmi_disconnect_event *dev;
            dev = (struct wmi_disconnect_event *)  Datapp;
            break;
        case KVM_EXIT_DEBUG:
            ret = kvm_arch_handle_debug_exit(cpu);
            break;
        default:
            fprintf(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);
            break;
            const struct io_uring_sqe *sqe;
            struct io_kiocb *req;
            const char __user *fname;
            req->open.dfd = READ_ONCE(sqe->fd);
            req->open.filename = getname(fname);
            req->open.nofile = rlimit(RLIMIT_NOFILE);
            req->flags |= REQ_F_NEED_CLEANUP;
    }
    if (ret == 0) {
        ret = EXCP_INTERRUPT;
    }
    return ret;
}",0,1,73,1.02,Insert
2724,"AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)
{
    PCIBus *bus = PCI_BUS(dev->bus);
    PCIBus *iommu_bus = bus;
    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {
        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);
    }
    if (iommu_bus && iommu_bus->iommu_fn) {
        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);
    }
    return &address_space_memory;
}","AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)
{
    int a = 29;
    int b = a;
    if(a*b>0){
        PCIBus *bus = PCI_BUS(dev->bus);
    }
    PCIBus *iommu_bus = bus;
    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {
        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);
    }
    if (iommu_bus && iommu_bus->iommu_fn) {
        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);
    }
    GF_Filter *process;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    git->base_stream_id = proc ? proc->value.uint : -1;
    git->pck_time = -1;
    return &address_space_memory;
}",0,1,12,0.51,Insert
2725,"static inline void gen_op_eval_fbo(TCGv dst, TCGv src,
                                    unsigned int fcc_offset)
{
    gen_mov_reg_FCC0(dst, src, fcc_offset);
    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);
    tcg_gen_and_tl(dst, dst, cpu_tmp0);
    tcg_gen_xori_tl(dst, dst, 0x1);
}","static inline void gen_op_eval_fbo(TCGv dst, TCGv src,
                                    unsigned int fcc_offset)
{
    gen_mov_reg_FCC0(dst, src, fcc_offset);
    int a = 23;
    AVStream *tmp;
    AVFormatContext *aws;
    uint32_t v, spf;
    MPADecodeHeader ch;
    MP3DecContext *MPthree = aws->priv_data;
    if (MPthree->frames)
            tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                        tmp->time_base);
    int b = a;
    if(a*b>0){
        gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);
    }
    tcg_gen_and_tl(dst, dst, cpu_tmp0);
    tcg_gen_xori_tl(dst, dst, 0x1);
}",0,1,10,0.39,Insert
2730,,,,,,,
